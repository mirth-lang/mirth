module std.input

import std.prelude
import std.byte
import std.maybe
import std.str
import std.buffer
import std.world
import std.file

#########
# Input #
#########

def INPUT_BUFFER_SIZE [ USize ] { 0x2000 >Nat-clamp >USize }

struct +InputOpenState {
    length: USize
    offset: UOffset
    +file:   +File
    +buffer: +Buffer
    --
    def end! [ +InputOpenState -- +File ] {
        /+InputOpenState
        length> offset> drop2
        +buffer> rdrop
        +file>
    }

    def refill-buffer! [ +InputOpenState -- +Input ] {
        +buffer(base size) +file:unsafe:read-bytes! over 0> && if(
            length!
            0u >UOffset offset!
            +Input.+InputOpen,
            drop end! +Input.+InputDone
        )
    }

    ||| Refill input buffer if empty.
    def prepare-for-more! [ +InputOpenState -- +Input ] {
        length 0= if(refill-buffer!, +Input.+InputOpen)
    }
}

data +Input {
    +InputOpen [ +InputOpenState ]
    +InputDone [ +File ]
    --
    def start! [ +File -- +Input ] {
        >+file
        INPUT_BUFFER_SIZE +Buffer.new >+buffer
        0u >USize   >length
        0u >UOffset >offset
        +InputOpenState refill-buffer!
    }

    def stop! [ +Input -- +Input ] {
        end! +Input.+InputDone
    }

    def end! [ +Input -- +File ] {
        { +InputOpen -> end! }
        { +InputDone -> id }
    }

    def done? [ +Input -- Bool +Input ] {
        { +InputOpen -> False +Input.+InputOpen }
        { +InputDone -> True +Input.+InputDone }
    }

    ||| Return the current char in the input buffer.
    ||| Returns NUL if the file is already exhausted.
    def peek [ +Input -- Byte +Input ] {
        { +InputOpen -> offset +buffer:@U8 >Byte +Input.+InputOpen }
        { +InputDone -> Byte.BNUL +Input.+InputDone }
    }

    ||| Move to next char in input buffer.
    ||| Does nothing if the file is already exhausted.
    def move! [ +Input -- +Input ] {
        { +InputOpen -> length:pred offset:1+ prepare-for-more! }
        { +InputDone -> +Input.+InputDone }
    }

    ||| Read a chunk of input.
    def read-chunk! [ +Input -- Maybe(Str) +Input ] {
        { +InputOpen ->
            offset length +buffer:@Str Some
            refill-buffer! }
        { +InputDone ->
            None +Input.+InputDone }
    }

    ||| Read the whole file.
    def read-file! [ +Input -- Str +Input ] {
        "" while-some(read-chunk!, cat)
    }
}
