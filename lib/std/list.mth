module(std.list)

import(std.prelude)
import(std.maybe)
import(std.either)
import(std.str)

data List(t) {
    0 Nil
    1 Cons [ t List(t) ]
    --
    def L0 [                   -- List(t) ] { Nil }
    def L1 [ t                 -- List(t) ] { Nil Cons }
    def L2 [ t t               -- List(t) ] { Nil Cons Cons }
    def L3 [ t t t             -- List(t) ] { Nil Cons Cons Cons }
    def L4 [ t t t t           -- List(t) ] { Nil Cons Cons Cons Cons }
    def L5 [ t t t t  t        -- List(t) ] { Nil Cons Cons Cons Cons Cons }
    def L6 [ t t t t  t t      -- List(t) ] { Nil Cons Cons Cons Cons Cons Cons }
    def L7 [ t t t t  t t t    -- List(t) ] { Nil Cons Cons Cons Cons Cons Cons Cons }
    def L8 [ t t t t  t t t t  -- List(t) ] { Nil Cons Cons Cons Cons Cons Cons Cons Cons }

    def empty? [ List(t) -- Bool ] { enum-value 0= }
    def single? [ List(t) -- Maybe(t) ] { Nil -> None, Cons -> empty? if(Some, drop None) }

    def >L0? [ List(t) -- Maybe(L0)    ] { Nil -> L0 Some, _ -> drop None }
    def >L1? [ List(t) -- Maybe(L1(t)) ] { Cons -> empty? if(L1 Some, drop None), Nil -> None }
    def >L2? [ List(t) -- Maybe(L2(t)) ] { Cons -> >L1? if-some(/L1 L2 Some, drop None), Nil -> None }
    def >L3? [ List(t) -- Maybe(L3(t)) ] { Cons -> >L2? if-some(/L2 L3 Some, drop None), Nil -> None }
    def >List+? [ List(t) -- Maybe(List+(t)) ] { Cons -> >tail >head List+ Some, Nil -> None }
    def len [ List(t) -- Nat ] { 0u swap for(drop 1+) }

    def cons [ t List(t) -- List+(t) ] { >tail >head List+ }
    def uncons [ List(t) -- Maybe(t) List(t) ] {
        { Nil -> None Nil }
        { Cons -> dip(Some) }
    }

    def Snoc [ List(t) t -- List(t) ] { swap reverse Cons reverse }
    def snoc [ List(t) t -- List+(t) ] { swap reverse cons reverse }
    def unsnoc [ List(t) -- List(t) Maybe(t) ] { reverse uncons reverse swap }

    def cat [ List(t) List(t) -- List(t) ] {
        { Nil -> id }
        { _ -> swap reverse-for(swap Cons) }
    }
    def cat+ [ List+(t) List(t) -- List+(t) ] {
        dip(uncons) cat cons
    }

    def head [ List(x) -- Maybe(x) ] {
        { Nil -> None }
        { Cons -> drop Some }
    }
    def tail [ List(x) -- List(x) ] {
        { Nil -> Nil }
        { Cons -> nip }
    }
    def first [ List(t) -- Maybe(t) ] { >List+? map(head) }
    def last  [ List(t) -- Maybe(t) ] { >List+? map(last) }

    def drop-slice [ Nat List(x) -- List(x) ] { swap repeat(tail) }

    ||| Reverse the list.
    def reverse [ List(a) -- List(a) ] {
        Nil swap for(swap Cons)
    }

    ||| Transform each element of the list.
    def map(f) [ (*c a -- *c b) *c List(a) -- *c List(b) ] {
        LIST(for(rdip(f) ;))
    }

   def if-cons(f,g) [ (*a x List(x) -- *b, *a -- *b) *a List(x) -- *b ] {
        { Cons -> f }
        { Nil -> g }
    }

    ||| Traverse the list, left to right.
    def for(f) [ (*c a -- *c) *c List(a) -- *c ] {
        while(if-cons(dip(f) True, Nil False)) drop
    }

    ||| Traverse the list, right to left.
    def reverse-for(f) [ (*c a -- *c) *c List(a) -- *c ] {
        reverse for(f)
    }

    ||| Traverse the list, left to right, with an action between each item.
    def for(f,g) [ (*a t -- *a, *a -- *a) *a List(t) -- *a ] {
        uncons dip:for(f) for(dip(g) f)
    }

    ||| Reduce a list via binary operation.
    def fold(g) [ (*c a a -- *c a) *c List(a) -- *c Maybe(a) ] {
        >List+? map(fold(g))
    }

    ||| Sum together a list of numbers.
    def sum(g {+}) [ (*c a a -- *c a) *c List(a) -- *c Maybe(a)] {
        fold(g)
    }

    ||| Multiply together a list of numbers.
    def product(g {*}) [ (*c a a -- *c a) *c List(a) -- *c Maybe(a)] {
        fold(g)
    }

    ||| Filter away any list elements that don't satisfy the predicate.
    def filter(f) [ (*c a -- *c Bool) *c List(a) -- *c List(a) ] {
        LIST(for(dup dip:rdip(f) swap if(;, drop)))
    }

    ||| Transform each element of a list into a new list, and concatenate all these lists.
    def flatmap(f) [ (*c a -- *c List(b)) *c List(a) -- *c List(b) ] {
        LIST(for(rdip(f) for(;)))
    }
    alias(List.bind(f), List.flatmap)

    ||| Map each element of a list into the [Maybe] type, and collect all of the
    ||| [Some] results while discarding all of the [None] results.
    def filter-some(p) [ (*c a -- *c Maybe(b)) *c List(a) -- *c List(b) ] {
        LIST(for(rdip(p) for(;)))
    }

    ||| Find first element that returns [Some], if it exists.
    def find-some(f) [ (*c a -- *c Maybe(b)) *c List(a) -- *c Maybe(b) ] {
        None swap while-some(
            uncons swap,
            dip'(dip'(f)) match(
                None -> id,
                _ -> dip(drop2) Nil
            )
        ) drop
    }

    ||| Find last element that returns Some, if it exists.
    def reverse-find-some(f) [ (*c a -- *c Maybe(b)) *c List(a) -- *c Maybe(b) ] {
        reverse find-some(f)
    }

    ||| Find the first element that satisfies the predicate, if it exists.
    def find(f) [ (*c a -- *c Bool) *c List(a) -- *c Maybe(a) ] {
        find-some(dup dip(f) swap if(Some, drop None))
    }

    ||| Find the last element that satisfies the predicate, if it exists.
    def reverse-find(f) [ (*c a -- *c Bool) *c List(a) -- *c Maybe(a) ] {
        reverse-find-some(dup dip(f) swap if(Some, drop None))
    }

    ||| Is the predicate true for any element of the list?
    def has(f) [ (*c a -- *c Bool) *c List(a) -- *c Bool ] {
        find(f) some?
    }

    ||| Is the predicate true for all elements of the list?
    def all(f) [ (*c a -- *c Bool) *c List(a) -- *c Bool ] {
        find(f not) none?
    }

    ||| If the predicate matches all elements of the list, return the result. Otherwise return None.
    def all-some(f) [ (*c a -- *c Maybe(b)) *c List(a) -- *c Maybe(List(b)) ] {
        >rest True >ok +List.+L0 while-some(
            @rest:uncons,
            @rest(@ok(dip2:rdip(f))) if-some(
                ; ,
                False !ok
                Nil !rest
            )
        )
        rest> drop
        ok> if(freeze Some, rdrop None)
    }

    def ==(eq {==}) [ (*c a a -- *c Bool) *c List(a) List(a) -- *c Bool ] {
        True while (
            dip(dip(uncons) uncons dip(swap) dip2(==(eq)) rotl) &&
            over2 empty? over2 empty? && not over &&,
            id
        )
        dip(drop2)
    }

    def(lookup(p {.key ==}), (*c k a -- *c Bool) *c k List(a) -- *c Maybe(a),
        find(over dip(p) swap) nip)

    def(reverse-lookup(p {.key ==}), (*c k a -- *c Bool) *c k List(a) -- *c Maybe(a),
        reverse-find(over dip(p) swap) nip)

    def(member(p {==}), (*c k a -- *c Bool) *c k List(a) -- *c Bool,
        lookup(p) some?)

    def(difference(eq {==}), (*c a a -- *c Bool) *c List(a) List(a) -- *c List(a),
        swap filter(over dip(swap member(eq) not) swap) nip)

    def(union(eq {==}), (*c a a -- *c Bool) *c List(a) List(a) -- *c List(a),
        over dip(swap difference(eq)) swap cat)

    def(unions(eq {==}), (*c a a -- *c Bool) *c List(List(a)) -- *c List(a),
        fold(union(eq)) unwrap(Nil))

    def(map2(f), (*c x y -- *c z) *c List(x) List(y) -- *c List(z),
        collect(uncons dip(dip:uncons swap dip:map2:f) rotl) dip:drop2)

    def(take-while(p), (*a t -- *a Bool) *a List(t) -- *a List(t),
        collect(uncons dip:filter(p) swap) nip)

    def split-at(p) [ (*a t -- *a Bool) *a List(t) -- *a List(t) List(t) ] {
        LIST(
            while (
                if-cons(
                    dip:sip:rdip(p) rotl if(
                        Cons False,
                        dip(;) True
                    ),
                    Nil False
                )
            )
        ) swap
    }

    def(partition-either(p), (*a t -- *a Either(t1,t2))
            *a List(t) -- *a List(t1) List(t2),
        Nil Nil rotl for(
            dip'(dip'(p)) match(
                Left -> rotr dip(Cons),
                Right -> swap Cons
            )
        ) dip(reverse) reverse)

    def(partition(p), (*a t -- *a Bool) *a List(t) -- *a List(t) List(t),
        partition-either(dup dip(p) swap if(Right, Left)))

    def(show;(f {show;}), (t +Str -- +Str) List(t) +Str -- +Str,
        "LIST( " ; for(f " ; " ;) ")" ;)
}


struct List+(t) {
    head: t
    tail: List(t)
    --
    def L1 [ t                 -- List+(t) ] { List.L0 >tail >head List+ }
    def L2 [ t t               -- List+(t) ] { List.L1 >tail >head List+ }
    def L3 [ t t t             -- List+(t) ] { List.L2 >tail >head List+ }
    def L4 [ t t t t           -- List+(t) ] { List.L3 >tail >head List+ }
    def L5 [ t t t t  t        -- List+(t) ] { List.L4 >tail >head List+ }
    def L6 [ t t t t  t t      -- List+(t) ] { List.L5 >tail >head List+ }
    def L7 [ t t t t  t t t    -- List+(t) ] { List.L6 >tail >head List+ }
    def L8 [ t t t t  t t t t  -- List+(t) ] { List.L7 >tail >head List+ }

    def single? [ List+(t) -- Maybe(t) ] {
        /List+ head> tail> empty? if(Some, drop None)
    }

    def >List [ List+(t) -- List(t) ] { /List+ head> tail> List.Cons }
    def >L1? { >List >L1? }
    def >L2? { >List >L2? }
    def >L3? { >List >L3? }

    def len [ List+(t) -- Nat ] { tail len 1+ }

    def cons [ t List+(t) -- List+(t) ] { >List >tail >head List+ }
    def uncons [ List+(t) -- t List(t) ] { /List+ head> tail> }

    def snoc [ List+(t) t -- List+(t) ] { dip(>List) List.snoc }
    def unsnoc [ List+(t) -- List(t) t ] { reverse uncons reverse swap }

    def cat  [ List(t) List+(t) -- List+(t) ] { swap reverse-for(swap cons) }
    def cat+ [ List+(t) List+(t) -- List+(t) ] { >List cat+ }

    def first [ List+(t) -- t ] { head }
    def last  [ List+(t) -- t ] { uncons for(nip) }

    ||| Reverse the list.
    def reverse [ List+(t) -- List+(t) ] {
        /List+ head> List+.L1 tail> for(swap cons)
    }

    ||| Transform each element of the list.
    def map(f) [ (*c a -- *c b) *c List+(a) -- *c List+(b) ] {
        uncons on2(f, map(f)) cons
    }

    ||| Traverse the list, left to right.
    def for(f) [ (*c a -- *c) *c List+(a) -- *c ] {
        uncons dip(f) for(f)
    }

    ||| Traverse the list, right to left.
    def reverse-for(f) [ (*c a -- *c) *c List+(a) -- *c ] {
        uncons swap dip(reverse-for(f)) f
    }

    ||| Traverse the list, left to right, with an action between each item.
    def for(f,g) [ (*a t -- *b, *b -- *a) *a List+(t) -- *b ] {
        uncons dip(f) for(dip(g) f)
    }

    ||| Reduce a list via binary operation.
    def fold(g) [ (*c a a -- *c a) *c List+(a) -- *c a ] {
        uncons for(g)
    }

    ||| Sum together a list of numbers.
    def sum(g {+}) [ (*c a a -- *c a) *c List+(a) -- *c a ] {
        fold(g)
    }

    ||| Multiply together a list of numbers.
    def product(g {*}) [ (*c a a -- *c a) *c List+(a) -- *c a ] {
        fold(g)
    }

    ||| Filter away any list elements that don't satisfy the predicate.
    def filter(f) [ (*c a -- *c Bool) *c List+(a) -- *c List(a) ] {
        >List filter(f)
    }

    ||| Transform each element of a list into a new list, and concatenate all these lists.
    def flatmap(f) [ (*c a -- *c List(b)) *c List+(a) -- *c List(b) ] {
        >List flatmap(f)
    }

    ||| Transform each element of a list into a new list, and concatenate all these lists.
    ||| This variant of [List.flatmap] preserves the non-emptiness of the list.
    def flatmap+(f) [ (*c a -- *c List+(b)) *c List+(a) -- *c List+(b) ] {
        uncons LIST+(
            dip(rdip(f) uncons dip(;+) for(;))
            for(rdip(f) for(;))
        )
    }
    alias(List+.bind(f), List+.flatmap+)

    ||| Map each element of a list into the [Maybe] type, and collect all of the
    ||| [Some] results while discarding all of the [None] results.
    def filter-some(p) [ (*c a -- *c Maybe(b)) *c List+(a) -- *c List(b) ] {
        >List filter-some(p)
    }

    ||| Find first element that returns [Some], if it exists.
    def find-some(f) [ (*c a -- *c Maybe(b)) *c List+(a) -- *c Maybe(b) ] {
        >List find-some(f)
    }

    ||| Find last element that returns Some, if it exists.
    def reverse-find-some(f) [ (*c a -- *c Maybe(b)) *c List+(a) -- *c Maybe(b) ] {
        >List reverse-find-some(f)
    }

    ||| Find the first element that satisfies the predicate, if it exists.
    def find(f) [ (*c a -- *c Bool) *c List+(a) -- *c Maybe(a) ] {
        find-some(dup dip(f) swap if(Some, drop None))
    }

    ||| Find the last element that satisfies the predicate, if it exists.
    def reverse-find(f) [ (*c a -- *c Bool) *c List+(a) -- *c Maybe(a) ] {
        reverse-find-some(dup dip(f) swap if(Some, drop None))
    }

    ||| Is the predicate true for any element of the list?
    def has(f) [ (*c a -- *c Bool) *c List+(a) -- *c Bool ] {
        find(f) some?
    }

    ||| Is the predicate true for all elements of the list?
    def all(f) [ (*c a -- *c Bool) *c List+(a) -- *c Bool ] {
        find(f not) none?
    }

    def ==(eq {==}) [ (*c a a -- *c Bool) *c List+(a) List+(a) -- *c Bool ] {
        dip(>List) >List ==(eq)
    }

    def(ookup(p {.key ==}), (*c k a -- *c Bool) *c k List+(a) -- *c Maybe(a),
        find(over dip(p) swap) nip)

    def(reverse-lookup(p {.key ==}), (*c k a -- *c Bool) *c k List+(a) -- *c Maybe(a),
        reverse-find(over dip(p) swap) nip)

    def(member(p {==}), (*c k a -- *c Bool) *c k List+(a) -- *c Bool,
        >List lookup(p) some?)

    def(map2(f), (*c x y -- *c z) *c List+(x) List+(y) -- *c List+(z),
        dip(uncons) uncons dip(swap dip:f) rotl dip(map2(f)) swap cons)

    def(take-while(p), (*a t -- *a Bool) *a List+(t) -- *a List(t),
        >List take-while(p))

    def(partition-either(p), (*a t -- *a Either(t1,t2))
            *a List+(t) -- *a List(t1) List(t2),
        >List partition-either(p))

    def(partition(p), (*a t -- *a Bool) *a List+(t) -- *a List(t) List(t),
        partition-either(dup dip(p) swap if(Right, Left)))

    def(show;(f {show;}), (t +Str -- +Str) List+(t) +Str -- +Str,
        "LIST+( " ; unsnoc dip:for(f " ; " ;) f " ;+ )" ;)

}


||| Build a list through iteration, stopping at the first None.
def collect(f {.next swap}) [ (*a -- *a Maybe(b)) *a -- *a List(b) ] {
    LIST(while-some(rdip(f), ;))
}

||| Build a list through repetition, stopping when condition becomes false.
def collect-while(f,g) [ (*a -- *a Bool, *a -- *a b) *a -- *a List(b) ] {
    LIST(while(rdip(f), rdip(g) ;))
}

||| Count up, inclusive at both ends.
def Int.range [ Int Int -- List(Int) ] {
    collect-while(dup2 <=, over dip2:1+) dip:drop2
}

inline(
    ||| Count up, inclusive at both ends.
    ||| Same as [Int.range] but takes the lower bound from the stack,
    ||| and the upper bound from the parameter `f`.
    |||
    |||     1 to: -1 => ( L0 )
    |||     1 to: 0 => ( L0 )
    |||     1 to: 1 => ( 1 L1 )
    |||     1 to: 2 => ( 1 2 L2 )
    |||     1 to: 3 => ( 1 2 3 L3 )
    |||     1 to: 4 => ( 1 2 3 4 L4 )
    def Int.to(f) [ (*a -- *a Int) *a Int -- *a List(Int) ] {
        dip(f) swap range
    }

    ||| Count up, inclusive at both ends.
    ||| Same as [Int.range] but takes the upper bound from the stack,
    ||| and the lower bound from the parameter `f`.
    |||
    |||     0 from: 1 => ( L0 )
    |||     1 from: 1 => ( 1 L1 )
    |||     2 from: 1 => ( 1 2 L2 )
    |||     3 from: 1 => ( 1 2 3 L3 )
    |||     4 from: 1 => ( 1 2 3 4 L4 )
    def Int.from(f) [ (*a -- *a Int) *a Int -- *a List(Int) ] {
        dip(f) range
    }
)

struct +List(t) { List(t) }
struct +List+(t) { List+(t) }

inline(
    def +List.rdrop  [ +List (t) -- ] { +List  -> drop }
    def +List+.rdrop [ +List+(t) -- ] { +List+ -> drop }

    def +List.rdup  [ +List (t) -- +List (t) +List (t) ] { +List  -> dup dip(+List)  +List  }
    def +List+.rdup [ +List+(t) -- +List+(t) +List+(t) ] { +List+ -> dup dip(+List+) +List+ }

    def +List.+L0 [       -- +List(t) ] { List.L0 +List }
    def +List.+L1 [     t -- +List(t) ] { List.L1 +List }
    def +List.+L2 [   t t -- +List(t) ] { swap List.L2 +List }
    def +List.+L3 [ t t t -- +List(t) ] { flip3 List.L3 +List }

    def(List.thaw, List(t) -- +List(t), reverse +List)
    def(+List.freeze, +List(t) -- List(t), /+List reverse)
    def(+List.push!, +List(t) t -- +List(t), /+List Cons +List)
    def(+List.push+!, +List(t) t -- +List+(t), /+List cons +List+)
    def(+List.pop!, +List(t) -- +List(t) Maybe(t), /+List uncons +List)
    inline:def(+List.;, +List(t) t -- +List(t), +List.push!)
    inline:def(+List.;+, +List(t) t -- +List+(t), +List.push+!)

    def(List+.thaw, List+(t) -- +List+(t), reverse +List+)
    def(+List+.freeze, +List+(t) -- List+(t), /+List+ reverse)
    def(+List+.push!, +List+(t) t -- +List+(t), /+List+ cons +List+)
    def(+List+.pop!, +List+(t) -- +List(t) t, /+List+ uncons +List)
    inline:def(+List+.;, +List+(t) t -- +List+(t), +List+.push!)

    def(LIST(f), (*a +List(t) -- *b +List(t)) *a -- *b List(t), List.L0 thaw f freeze)
    def(LIST+(f), (*a +List(t) -- *b +List+(t)) *a -- *b List+(t), List.L0 thaw f freeze)
)

struct L0 {
    --
    def >List { L0 -> List.L0 }
}

struct L1(t) {
    t
    --
    def >List  { L1 -> List.L1 }
    def >List+ { L1 -> List+.L1 }
}

struct L2(t) {
    t t
    --
    def >List  { L2 -> List.L2  }
    def >List+ { L2 -> List+.L2 }
}

struct L3(t) {
    t t t
    --
    def >List  { L3 -> List.L3 }
    def >List+ { L3 -> List.L3 }
}

struct L4(t) {
    t t t t
    --
    def >List  { L4 -> List.L4 }
    def >List+ { L4 -> List+.L4 }
}

struct L5(t) {
    t t t t t
    --
    def >List  { L5 -> List.L5 }
    def >List+ { L5 -> List+.L5 }
}

struct L6(t) {
    t t t t t t
    --
    def >List  { L6 -> List.L6 }
    def >List+ { L6 -> List+.L6 }
}

struct L7(t) {
    t t t t t t t
    --
    def >List  { L7 -> List.L7 }
    def >List+ { L7 -> List+.L7 }
}

struct L8(t) {
    t t t t t t t t
    --
    def >List  { L8 -> List.L8 }
    def >List+ { L8 -> List+.L8 }
}
