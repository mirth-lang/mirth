module(arg-parser.parse)

import(std.prelude)
import(std.str)
import(std.list)
import(std.maybe)
import(std.either)
import(std.byte)
import(std.buffer)
import(std.posix)
import(std.terminal)

import(arg-parser.types)
import(arg-parser.state)

||| Print an autogenerated usage message for the parser
def(print-usage, +ArgumentParser(a) -- +ArgumentParser(a),
    Str(Bold emit; "Usage:" ; Reset emit;) print-ln!

    "  " print!
    state program-name print!
    " [options] " print!
    argument-parser args-doc for(print!)
    "" print-ln!

    "" print-ln!

    argument-parser options for(print-usage-for-option)
    "" print-ln!)

def(print-usage-for-option, +ArgumentParser(a) ArgpOption -- +ArgumentParser(a),
    "  " print!

    0 >col-offset
    dup flag-type match(
        Short ->
            dup is-printable then(
                @col-offset(2 +)
                "-" print! dup to-str-unsafe print!,
            ) drop,
        _ -> drop
    )

    # If we have both a short and long version of the argument we separate them
    dup flag-type has-short? and(dup name some?) then(
        ", " print!
        @col-offset(2 +)
    )

    dup name then-some(
        "--" print!

        dup num-bytes >Int @col-offset(2 + +)

        print!

        dup arg-doc then-some(
            " " print!

            dup num-bytes >Int @col-offset(1 + +)
            print!
        )
    )

    dup doc then-some(
        @col-offset state longest-arg-length dup2 < if(
            swap - from: 0 for(drop " " print!),
            drop2
        )
        "    " print! print!
    ) col-offset> drop

    "" print-ln!
    drop)

||| Check if the currently parsed argument is something we accept
def(check-short-flag, +ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool,
    over flag-type match(
        Short -> 0 >Offset rotl byte@ ==,
        _ -> drop drop False
    ))

||| Parse a short cli flag, possibly with a argument value
def(parse-flags-where(f), (+ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool)
        +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
    argument-parser options
    find(over f) swap drop match(
        Some ->
            dup arg-doc match(
                Some ->
                    True state parsing?! state!
                    drop Some state option-option! state!,
                None -> flag-type state arguments swap None swap parser match(
                    Some -> run state arguments! state! ,
                    None -> drop drop drop
                )
            ) None,
        None -> UnknownArg Some
    ))

||| Check if the currently parsed argument is something we accept
def(check-long-flag, +ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool,
    over name match(
        Some -> ==,
        None -> drop False
    ))

||| Parse either a short or long flag
def(parse-flags, +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
    dup num-bytes 2 >Size >= and(1 >Offset over byte@ B'-' ==) if(
        2 >Size over unsafe(drop-bytes) parse-flags-where(check-long-flag),
        1 >Size over unsafe(drop-bytes) parse-flags-where(check-short-flag)
    ) swap drop)

||| Parse a positional argument, advancing the current index
def(do-positional-option, +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
    state arguments swap Some Positional parser unwrap run
    state arguments! state! None
    state positional-index 1+ state positional-index! state!)

||| Run the argument parser
def(parse-args, a ArgumentParser(a) -- Either(ArgumentParsingError, a),
    >argument-parser State.init >state +ArgumentParser
    argument-parser options for(
        0 >doc-length

        dup flag-type match(
            Short -> drop doc-length> 2 + >doc-length,
            _ -> drop
        )

        dup name then-some(num-bytes >Int doc-length> 3 + + >doc-length)
        arg-doc then-some(num-bytes >Int doc-length> 1 + + >doc-length)


        doc-length> dup state longest-arg-length > if(
            state:longest-arg-length!,
            drop
        )
    )

    state State.argv for(
        dup num-bytes 1 >Size > if(
            0 >Offset over byte@ B'-' == if(
                # if in the middle of currently parsing an option when we shouldn't be,
                # turn it off, otherwise error because need an option value
                state parsing? if(
                    drop state option-option match(
                        Some -> arg-doc match (
                            Some -> drop MissingArgValue Some,
                            None -> False state parsing?! state! None
                        ),
                        None -> MissingArgValue Some
                    ),
                    parse-flags
                ),

                # Parse the associated value for an option
                state parsing? if(
                    state option-option match(
                        Some -> arg-doc match(
                            Some -> drop state arguments swap Some state option-option unwrap flag-type parser unwrap run state:arguments! None,
                            None -> drop UnknownArg Some
                        ),
                        None -> drop UnknownArg Some
                    ) False state:parsing?!,
                    do-positional-option
                )
            ),
            drop None
        ) then-some(
            Some state:error!,
        )
    )

    # Check if we are still waiting for an associated value for an option
    state parsing? then(
        MissingArgValue Some state error! state!
    )

    # Run the callback function one last time to let it clean up
    # and run final checks
    state arguments None End parser unwrap run state:arguments!

    state arguments state error
    match(
        Some -> Left swap drop print-usage,
        None -> Right
    )
    rdrop)

def(read-from-argv, +Unsafe Int -- Str +Unsafe,
    Ptr.sizeof >Int * >Size >Offset argv offset @Ptr Str.copy-cstr)

def(argv-to-str, -- List(Str),
    1 to(argc 1-) map(unsafe:read-from-argv))
