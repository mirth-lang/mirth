module mirth.elab

import std.prelude
import std.str
import std.list
import std.maybe
import std.either
import std.byte
import std.terminal

import mirth.mirth
import mirth.name
import mirth.def
import mirth.token
import mirth.data
import mirth.external
import mirth.word
import mirth.var
import mirth.buffer
import mirth.table
import mirth.tycon
import mirth.type
import mirth.typedef
import mirth.var
import mirth.arrow
import mirth.word
import mirth.prim
import mirth.module
import mirth.package
import mirth.alias
import mirth.match
import mirth.lexer
import mirth.label
import mirth.macro
import mirth.version

####################
# Type Elaboration #
####################

struct +TypeElab {
    ctx:Ctx
    token:Token
    allow-type-holes:Bool
    allow-implicit-type-vars:Bool
    --
    def rdrop [ +TypeElab -- ] {
        /+TypeElab
        ctx> token> drop2
        allow-type-holes> drop
        allow-implicit-type-vars> drop
    }

    def Start! [ Token -- +TypeElab ] {
        >token
        Ctx.L0 >ctx
        False >allow-type-holes
        True >allow-implicit-type-vars
        +TypeElab
    }

    def elab-type-sig! [ +Mirth +TypeElab |- StackType -- ArrowType ] {
        >base

        token rdip:run-end? then(token "expected type signature" rdip:emit-error!)
        @base elab-type-sig-params!
        @base elab-stack-type!
        token rdip:vdash? then(
            !base
            token:succ @base elab-type-sig-params! cat
            @base elab-stack-type!
        )
        token rdip:sig-dashes? if(token:succ @base elab-stack-type!, dip:@base)
        token rdip:run-end? else(token "expected right paren or comma" rdip:emit-error!)
        dip(swap for(T*)) T->

        base> drop
    }

    def elab-type-sig-params! [ +Mirth +TypeElab |- StackType -- List(Type) ] {
        >base

        token rdip:lparen? if(
            token rdip:next
            token rdip:args map(
                token!
                @base elab-type-sig! Type.Arrow
            )
            dip:token!,
            L0
        )

        base> drop
    }

    def elab-stack-type! [ +Mirth +TypeElab |- StackType -- StackType ] {
        elab-stack-type-base!
        elab-stack-type-parts!
    }

    def elab-stack-type-base! [ +Mirth +TypeElab |- StackType -- StackType ] {
        token rdip:sig-stack-var? for(
            elab-stack-type-var!
            swap rdip:split-parts swap rdip:unit? else(
                token "Duplicate stack base, context already provided a stack base." rdip:emit-error!
            ) for(cons)
        )
    }

    def elab-stack-type-parts! [ +Mirth +TypeElab |- StackType -- StackType ] {
        while(token rdip:sig-stack-end? not, elab-stack-type-part! cons)
    }

    def elab-type-arg! [ +Mirth +TypeElab |- Type ] {
        token elab-stack-type-part!
        match(
            Cons -> nip,
            ConsLabel -> drop2 "Expected type, not label." rdip:emit-error! Type.Error,
            With -> drop "Expected type, not resource." rdip:emit-error! Type.Error,
            WithLabel -> drop2 "Expected type, not labelled resource." rdip:emit-error! Type.Error,
        )
        token rdip:arg-end? else(
            token "Unexpected token after type." rdip:emit-error!
        )
    }

    def elab-resource-arg! [ +Mirth +TypeElab |- Resource ] {
        token elab-stack-type-part!
        match(
            Cons -> drop "Expected resource, not type." rdip:emit-error! Type.Error Resource,
            ConsLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
            With -> nip,
            WithLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
        )
        token rdip:arg-end? else(
            token "Unexpected token after resource." rdip:emit-error!
        )
    }

    def elab-stack-type-part! [ +Mirth +TypeElab |- StackTypePart ] {
        token rdip:sig-label? if?(
            elab-stack-label!,

        token rdip:sig-type-var? if?(
            elab-type-var! StackTypePart.Cons,

        token rdip:sig-type-con? if?(
            elab-type-con! StackTypePart.Cons,

        token rdip:sig-resource-var? if?(
            elab-resource-var! StackTypePart.With,

        token rdip:sig-resource-con? if?(
            elab-resource-con! StackTypePart.With,

        token rdip:pat-underscore? if(
            elab-type-dont-care! StackTypePart.Cons,

        token rdip:sig-type-hole? if?(
            elab-type-hole! StackTypePart.Cons,

        token rdip:lsquare? .if(
            elab-type-quote! StackTypePart.Cons,

            token "Expected type, got unknown token." rdip:emit-error!
            token:next Type.Error StackTypePart.Cons
        ))))))))
    }

    def elab-stack-label! [ +Mirth +TypeElab |- Label -- StackTypePart ] {
        token rdip:next dip(
            token:args-1 dup rdip:is-resource-label? if(
                elab-resource-arg! swap StackTypePart.WithLabel,
                elab-type-arg! swap StackTypePart.ConsLabel
            )
        ) token!
    }

    def elab-stack-type-var! [ +Mirth +TypeElab |- Name -- StackType ] {
        Type.STACK elab-implicit-var! if?(StackType.Var, StackType.Error)
    }

    def elab-type-var! [ +Mirth +TypeElab |- Name -- Type ] {
        Type.TYPE elab-implicit-var! if?(Type.Var, Type.Error)
    }

    def elab-resource-var! [ +Mirth +TypeElab |- Name -- Resource ] {
        Type.RESOURCE elab-implicit-var! if?(Type.Var, Type.Error) Resource
    }

    def elab-implicit-var! [ +Mirth +TypeElab |- Name Type -- Maybe(Var) ] {
        token rdip:error-token!
        over ctx rdip:lookup match(
            Some -> sip(dip:nip rdip:type rdip:unify! drop) Some,
            None ->
                allow-implicit-type-vars if(
                    swap ctx(dip:Var.new! over Ctx.new) Some,
                    "Implicit type variable not allowed here." rdip:error!
                    drop2 None
                )
        )
        token rdip:args-0
        token:succ
    }

    def resolve-type-con-name! [ +Mirth +TypeElab |- Name/DName -- Type List(Var) ] {
        >name/dname
        False >report-ambiguous-as-warning
        False >ignore-last-name
        token >token "type" >sort rdip:resolve-def(
            filter(dup rdip:defines-a-type?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            L0 filter-roots
        ) if? (
            match(
                Data -> sip:Type.Data rdip:params,
                Table -> Type.Table L0,
                Type -> rdip(sip:target params), # TODO: this doesn't quite make sense.
                _ ->
                    drop token "compiler bug: resolve-type-con-name! doesn't understand type"
                    rdip:emit-error! Type.Error L0,
            ),
            Type.Error L0
        )
    }

    def elab-type-con! [ +Mirth +TypeElab |- Name/DName -- Type ] {
        dup left? rdip:has(>Str "Mut" =) if(
            drop token rdip:next dip(
                token:args-1
                elab-type-arg!
                Type.Mut
            ) token!,

            resolve-type-con-name! elab-type-args!
            token:next
        )
    }

    def elab-resource-con! [ +Mirth +TypeElab |- Name/DName -- Resource ] {
        elab-type-con! Resource
    }

    def with-token(f) [ +TypeElab |- (*a -- *b) *a Token -- *b ] {
        token:swap dip(f) token!
    }

    def elab-type-args! [ +Mirth +TypeElab |- Type List(Var) -- Type ] {
        token rdip:args for(
            with-token(elab-type-app!)
        ) drop
    }

    def elab-type-app! [ +Mirth +TypeElab |- Type List(Var) -- Type List(Var) ] {
        uncons swap if? (
            rdip:sort? else?(token "Type parameter has unknown sort." rdip:emit-fatal-error!) match {
                { Resource -> elab-resource-arg! >Type }
                { Stack -> T0 elab-stack-type! >Type }
                { Type -> elab-type-arg! }
            } swap dip:Type.App,

            drop rdip:tycon? then?(
                token rdip(Str("Too many type arguments to "; swap qname;) emit-error!)
            )
            Type.Error L0
        )
    }

    def elab-type-hole! [ +Mirth +TypeElab |- Name -- Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Hole,
            drop
            token "type holes are not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-dont-care! [ +Mirth +TypeElab |- Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Ignore,
            token "underscore is not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-quote! [ +Mirth +TypeElab |- Type ] {
        token rdip:next dip(
            token:args-1
            token rdip:sig-has-vdash-or-dashes? if(
                T0 elab-type-sig! >Type,
                T0 elab-stack-type! >Type
            )
        ) token!
    }
}

# TODO: separate this into a reason and a def.
data RejectedDef {
    WrongSort          [ Def ]
    WrongArity         [ Def ]
    NotVisible         [ Def ]
    NotImported        [ Def ]
    WrongQualifier     [ Def ]
    WrongConstructor   [ Def ]
    MethodNotAvailable [ Def ]
    MethodWrongType    [ Def List(Namespace) ]
}

struct +ResolveDef {
    sort: Str
    token: Token
    name/dname: Name/DName
    candidates: List(Def)
    rejected: List(RejectedDef)
    ignore-last-name: Bool
    report-ambiguous-as-warning: Bool
    --
    def rdrop [ +ResolveDef -- ] {
        /+ResolveDef
        sort> token> name/dname> drop3
        candidates> rejected> drop2
        ignore-last-name> drop
        report-ambiguous-as-warning> drop
    }

    def Begin! [
        sort:Str
        token:Token
        name/dname:Name/DName
        ignore-last-name:Bool
        report-ambiguous-as-warning:Bool
        +Mirth
        -- +Mirth +ResolveDef
    ] {
        @ignore-last-name if(
            @name/dname name/dname-penultimate-name? unwrap(
                @token "Expected a namespace." emit-fatal-error!
            ),
            @name/dname name/dname-last-name
        ) defs >candidates
        List.Nil >rejected
        +ResolveDef
    }

    def expunge(p) [ *a |- ( Def -- Bool ) +ResolveDef -- +ResolveDef ] {
        candidates:filter(p not)
    }

    def filter(p) [ *a +ResolveDef |- ( Def -- Either(RejectedDef, Def) ) -- ] {
        candidates partition-either(p) dip:rejected:cat candidates!
    }

    def filter(p,q) [ *a +ResolveDef |- ( Def -- Def Bool, Def -- RejectedDef ) -- ] {
        filter(p if(Right, q Left))
    }

    def filter-sort(p) [ *a +ResolveDef |- ( Def -- Def Bool ) -- ] {
        filter(p, RejectedDef.WrongSort)
    }

    def filter-arity [ +Mirth +ResolveDef |- ] {
        token rdip:num-args filter(
            dup2 rdip:qname-hard arity dip(>Int) arity-compatible?,
            RejectedDef.WrongArity
        ) drop
    }

    def filter-visible [ +Mirth +ResolveDef |- ] {
        filter(token over rdip:def-visible-from-token?, RejectedDef.NotVisible)
    }

    def filter-qualifiers [ +Mirth +ResolveDef |- ] {
        token rdip:dname? for(
            filter(dup2 rdip:qname-hard climb-up-dname? empty? not, RejectedDef.WrongQualifier)
            drop
        )
    }

    def filter-roots [ +Mirth +ResolveDef |- List(Namespace) -- ] {
        !namespaces(name/dname match {
            { Left ->
                >name
                filter(
                    dup rdip:qname-hard namespace @namespaces member
                    or(token over rdip:def-is-imported-at-token?),
                    dup rdip:qname-hard namespace match(
                        Tycon ->
                            drop @name rdip:can-be-relative? if(
                                @namespaces empty? if(
                                    RejectedDef.MethodNotAvailable,
                                    @namespaces RejectedDef.MethodWrongType
                                ),
                                RejectedDef.NotImported
                            ),
                        _ -> drop RejectedDef.NotImported
                    )
                )
                name> drop
            }

            { Right ->
                dup is-relative? and(ignore-last-name not) if(
                    filter(dup2 rdip:qname-hard climb-up-dname? has(@namespaces member),
                        @namespaces empty? if(
                            RejectedDef.MethodNotAvailable,
                            @namespaces RejectedDef.MethodWrongType
                        )
                    ),
                    filter(dup2 rdip:qname-hard climb-up-dname? has(
                        dip:token rdip:namespace-is-imported-at-token?
                    ), RejectedDef.NotImported)
                ) drop
            }
        })
        drop
    }

    def end! [ +Mirth |- +ResolveDef -- Maybe(Def) ] {
        candidates match(
            Nil -> resolve-def-unknown None,
            Cons -> match(
                Nil -> rdrop Some,
                _ -> List.filter(over rdip:same-resolved? not) match(
                    Nil -> rdrop Some,
                    _ -> drop2 resolve-def-ambiguous None
                )
            )
        )
    }

    def resolve-def-ambiguous [ +Mirth |- +ResolveDef -- ] {
        report-ambiguous-as-warning if(
            token Str(
                "Can't resolve " ; rdip:sort ; " due to previous errors. Candidates are:" ;
                " " rdip:candidates for(swap ; rdip_:qname; ", ") drop
            ) rdip:emit-warning!,

            token Str(
                "Ambiguous " ; rdip:sort ; ". Can't decide between:" ;
                " " rdip:candidates for(swap ; rdip_:qname; ", ") drop
            ) rdip:emit-error!
        ) rdrop
    }

    def resolve-def-unknown [ +Mirth |- +ResolveDef -- ] {
        token Str(rdip:rejected match(
            Nil -> "Unknown " ; rdip:sort ; " name, possibly a misspelling." ;,
            Cons ->
                match(
                    Nil -> match(
                        WrongSort ->
                            "Expected a " ; rdip:sort ; ", but " ; rdip_:qname; " is not a " ; rdip:sort ; "." ; ,
                        NotVisible ->
                            "Not visible in current scope: " ; rdip_:qname; ,
                        NotImported ->
                            "Not imported in current scope: " ; rdip_:qname; ,
                        WrongArity ->
                            rdip2:qname-hard dup rdip_:qname; " expects " ; arity int;
                            " arguments, but got " ; rdip:token rdip2:num-args int; "." ; ,
                        WrongQualifier ->
                            "Qualified name not found. Perhaps you meant: " ; rdip_:qname; ,
                        WrongConstructor ->
                            "Constructor is for a different type: " ; rdip_:qname; ,
                        MethodWrongType ->
                            swap "Method "; rdip_:qname;
                            " does not match ["; for(rdip_:name;, " ";) "]"; ,
                        MethodNotAvailable ->
                            "Method is not available for current stack: " ; rdip_:qname; ,
                    ),
                    _ -> cons "Multiple definitions for name, but none are suitable:" ;
                        L0 >namespaces
                        dup filter-some:match(
                            MethodWrongType -> @namespaces(drop id) Some,
                            _ -> drop None
                        )
                        " " >separator
                        >Nest? for(
                            separator> ; "Method "; rdip:name/dname left(last-name) rdip_:name;
                            " is for different type – expected one of"; for(" "; rdip:rdip:qname-hard namespace rdip_:qname;)
                            " but got ["; @namespaces for(rdip_:name;, " ";) "]";
                            ", " >separator
                        )
                        namespaces> drop
                        filter-some:match(MethodWrongType -> drop drop None, _ -> Some)
                        for(separator> ; match(
                            WrongSort -> rdip_:qname; " is not a " ; rdip:sort ; ,
                            NotVisible -> rdip_:qname; " is not visible in current scope" ; ,
                            NotImported -> rdip_:qname; " is not imported in current scope" ; ,
                            WrongArity -> rdip2:qname-hard dup rdip_:qname; " expects " ; arity int; " arguments" ; ,
                            WrongQualifier -> rdip_:qname; " doesn't match the given qualified name" ; ,
                            WrongConstructor -> rdip_:qname; " is constructor for a different type" ; ,
                            MethodWrongType -> impossible!,
                            MethodNotAvailable -> rdip_:qname; " is not avaliable for current stack" ; ,
                        ) ", " >separator)
                        separator> drop
                )
        )) rdip:emit-error! rdrop
    }
}

def +Mirth.resolve-def(f) [
    (+Mirth +ResolveDef |- *a -- *b)
    *a +Mirth
    sort:Str
    token:Token
    name/dname:Name/DName
    ignore-last-name:Bool
    report-ambiguous-as-warning:Bool
    --
    *b +Mirth Maybe(Def)
] {
    +ResolveDef.Begin! f end!
}

def QName.punning? [ +Mirth |- QName -- Bool ] {
    dup namespace match {
        { Tycon -> name swap name = }
        { _ -> drop2 False }
    }
}

def Def.punning? [ +Mirth |- Def -- Bool ] {
    qname-hard punning?
}

||| Check whether a definition can be referred to without qualification.
def def-is-imported-at-token? [ +Mirth |- Token Def -- Bool ] {
    # TODO: implement finer grained control over what is imported.
    #   https://github.com/mirth-lang/mirth/issues/243
    dup qname-hard namespace match(
        Root -> drop2 True,
        Package -> drop3 True,
        Module -> nip module-visible-from-token?,
        Tycon -> dip:swap tycon-is-visible-at-token? if(punning?, drop False),
        Word -> drop3 False
    )
}

def tycon-is-visible-at-token? [ +Mirth |- Token Tycon -- Bool ] {
    Data -> head? if?(.module module-visible-from-token?, drop True),
    Table -> head .module module-visible-from-token?,
    Prim -> drop2 True
}

def namespace-is-imported-at-token? [ +Mirth |- Token Namespace -- Bool ] {
    Root -> drop True,
    Package -> drop2 True,
    Module -> module-visible-from-token?,
    Tycon -> qname-hard namespace namespace-is-imported-at-token?,
    Word -> drop2 False
}

def QName.climb-up-name? [ +Mirth |- Name QName -- List(Namespace) ] {
    >qname >name

    @qname name @name = if(
        @qname namespace L1,
        L0
    ) >accum
    name> defs for(match(
        Alias ->
            dup ~target try-force! has(qname-hard @qname =) if(
                namespace-hard @accum:cons,
                drop
            ),
        Type ->
            dup target tycon? has(qname-hard @qname =) if(
                namespace @accum:cons,
                drop
            ),
        _ -> drop
    ))
    qname> drop
    accum>
}

def QName.climb-up-dname? [ +Mirth +ResolveDef |- DName QName -- List(Namespace) ] {
    dip(sip(root? >List) parts unsnoc dip(cat)
        ignore-last-name then(drop unsnoc unwrap(
            token "Error, expected a namespace in QName.climb-up-dname?" rdip:emit-fatal-error!
        ))
    )
    rdip:climb-up-name? swap
    reverse-for(swap bind(rdip:qname if?(dip(dup) rdip:climb-up-name?, L0)) nip)
}

def elab-type-unify! [ +Mirth |- Type Type Token -- Type Token ] {
    dup with-error-token(dip:unify!)
}
def elab-stack-type-unify! [ +Mirth |- StackType StackType Token -- StackType Token ] {
    dup with-error-token(dip:unify!)
}

def elab-simple-type-arg! [ +Mirth |- Token -- Type ] {
    >token
    Ctx.L0 >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab elab-type-arg! rdrop
}

####################
# Word Elaboration #
####################

struct +AB {
    arrow:Arrow
    --
    def ab-token@ [ +AB -- +AB Token ] { arrow token-end }
    def ab-token! [ +AB Token -- +AB ] { arrow:token-end! }
    def ab-type@ [ +AB -- +AB StackType ] { arrow cod }
    def ab-type! [ +AB StackType -- +AB ] { arrow:cod! }
    def ab-ctx@ [ +AB -- +AB Ctx ] { arrow ctx }
    def ab-home@ [ +AB -- +AB Home ] { arrow home }

    def ab-unify-type! [ +Mirth +AB |- StackType -- ] {
        ab-token@ rdip:error-token!
        dip:ab-type@ rdip:unify! ab-type!
    }

    def ab-atom! [ +Mirth +AB |- Atom -- ] {
        dup token ab-token!
        # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
            # ^ a sanity check to make sure
            # atom dom matches ab-arrow cod
        dup cod ab-type!
        arrow:atoms(swap ab-optimized-snoc!)
    }

    def ab-op! [ +Mirth +AB |- Op -- ] {
        ab-ctx@ >ctx
        ab-token@ >token
        ab-home@ >home
        dup >op
        rdip:elab-op-fresh-sig! dip:>subst
        ab-expand-opsig! >cod >dom
        L0 >args Atom ab-atom!
    }

    def ab-expand-opsig! [ +Mirth +AB |- OpSig -- StackType StackType ] {
        { OpSig.Id -> ab-type@ dup }
        { OpSig.Push -> dip(ab-type@ dup) StackType.Cons }
        { OpSig.Apply ->
            /ArrowType
            ab-type@
            dom> ab-token@ rdip:elab-stack-type-unify! drop
            cod> }
    }

    def ab-push-value! [ +Mirth +AB |- PushValue -- ] { Op.Push ab-op! }
    def ab-int! [ +Mirth +AB |- Int -- ] { PushValue.Int ab-push-value! }
    def ab-str! [ +Mirth +AB |- Str -- ] { PushValue.Str ab-push-value! }
    def ab-buffer! [ +Mirth +AB |- Buffer -- ] { Op.Buffer ab-op! }
    def ab-field! [ +Mirth +AB |- Field -- ] { Op.Field ab-op! }
    def ab-var! [ +Mirth +AB |- Var -- ] { Op.Var ab-op! }
    def ab-tag! [ +Mirth +AB |- Tag -- ] { Op.Tag ab-op! }
    def ab-prim! [ +Mirth +AB |- Prim -- ] { Op.Prim ab-op! }
    def ab-word! [ +Mirth +AB |- Word -- ] { Op.Word ab-op! }
    def ab-external! [ +Mirth +AB |- External -- ] { Op.External ab-op! }
    def ab-label-push! [ +Mirth +AB |- Label -- ] { Op.LabelPush ab-op! }
    def ab-label-pop! [ +Mirth +AB |- Label -- ] { Op.LabelPop ab-op! }
    def ab-label-push-r! [ +Mirth +AB |- Label -- ] { Op.LabelPushR ab-op! }
    def ab-label-pop-r! [ +Mirth +AB |- Label -- ] { Op.LabelPopR ab-op! }

    def ab-block-at!(f) [ +Mirth +AB |- ( *a -- *b ) *a StackType Token -- *b ] {
        ab-ctx@ rotr ab-home@ rdip(ab-build!(f))
        rdip:Block.new! Op.BlockPush ab-op!
    }

    def ab-block!(f) [ +Mirth +AB |- (*a -- *b) *a StackType -- *b ] {
        ab-token@ ab-block-at!(f)
    }

    def ab-dip!(f) [ +Mirth +AB |- (*a -- *b) *a -- *b ] {
        ab-type@ rdip:force-cons?! if?(unpack2 drop, StackType.Error)
        ab-block!(f) Prim.Dip ab-prim!
    }

    def ab-rdip!(f) [ +Mirth +AB |- (*a -- *b) *a -- *b ] {
        ab-type@ rdip:force-with?! if?(unpack2 drop, StackType.Error)
        ab-block!(f) Prim.RDip ab-prim!
    }

    def ab-if!(f,g) [ +Mirth +AB |- (*a -- *b, *b -- *c) *a -- *c ] {
        ab-type@ rdip:force-cons?! if?(unpack2 drop, StackType.Error) dup
        dip:ab-block!(f) ab-block!(g) Prim.If ab-prim!
    }

    def ab-while!(f,g) [ +Mirth +AB |- (*a -- *b, *b -- *c) *a -- *c ] {
        ab-type@ dup
        dip:ab-block!(f)
        ab-block!(g) Prim.While ab-prim!
    }

    def ab-lambda!(f) [ +Mirth +AB |- (*a -- *b) *a List(Var) -- *b ] {
        dip(ab-token@) ab-lambda-at!(f)
    }

    def ab-lambda-at!(f) [ +Mirth +AB |- (*a -- *b) *a Token List(Var) -- *b ] {
        dup dip(
            dip(ab-ctx@ ab-type@) reverse-for(
                swap dip(dup dip(Ctx.new))
                ab-token@ rdip:elab-expand-tensor!
                dip(rotl rdip:type) rdip:elab-type-unify! drop2
            )
            rotl ab-home@ rdip(ab-build!(f))
        )
        >params >body
        ab-ctx@ >outer-ctx
        ab-type@ >dom
        ab-token@ >token
        Lambda Op.Lambda ab-op!
    }

    def ab-match!(f) [ +Mirth |- (*a +Match -- *b +Match) *a cod:StackType body:Token +AB -- *b +AB ] {
        ab-ctx@ >ctx
        ab-type@ >dom
        ab-token@ >token
        ab-home@ >home
        L0 >cases
        rdip(+Match f freeze) Op.Match ab-op!
    }

    def ab-ldip!(f) [ +Mirth +AB |- (*a -- *b) *a List(Label) -- *b ] {
        { Nil -> f }
        { Cons -> swap ab-ldip-one!(ab-ldip!(f)) }
    }

    def ab-ldip-one!(f) [ +Mirth +AB |- (*a -- *b) *a Label -- *b ] {
        dup rdip:is-resource-label? if(
            dup ab-label-pop-r!
            dip(ab-rdip!(f))
            ab-label-push-r!,

            dup ab-label-pop!
            dip(ab-dip!(f))
            ab-label-push!
        )
    }

    def elab-atoms! [ +Mirth +AB |- ] {
        while(
            ab-token@ rdip:run-end? not,
            elab-atom! ab-token@ rdip:next ab-token!
        )
    }

    def elab-atom! [ +Mirth +AB |- ] {
        ab-token@ rdip:value match(
            Name -> elab-atom-name!,
            DName -> elab-atom-dname!,
            Str -> ab-str!,
            Int -> ab-int!,
            U8  -> PushValue.U8  ab-push-value!,
            U16 -> PushValue.U16 ab-push-value!,
            U32 -> PushValue.U32 ab-push-value!,
            U64 -> PushValue.U64 ab-push-value!,
            I8  -> PushValue.I8  ab-push-value!,
            I16 -> PushValue.I16 ab-push-value!,
            I32 -> PushValue.I32 ab-push-value!,
            I64 -> PushValue.I64 ab-push-value!,
            F32 -> PushValue.F32 ab-push-value!,
            F64 -> PushValue.F64 ab-push-value!,
            LSquare -> drop elab-atom-block!,
            LCurly -> drop elab-atom-assert!,
            LabelPush -> ab-token@ rdip:args-0 ab-label-push!,
            LabelPop -> ab-token@ rdip:args-0 ab-label-pop!,
            LabelPushR -> ab-token@ rdip:args-0 ab-label-push-r!,
            LabelPopR -> ab-token@ rdip:args-0 ab-label-pop-r!,
            LabelGet -> elab-label-get!,
            LabelSet -> elab-label-set!,
            _ -> ab-token@ "Unexpected token in elab-atom!" rdip:emit-fatal-error!
        )
    }

    def elab-label-get! [ +Mirth +AB |- Label -- ] {
        dup rdip:is-resource-label? if(
            dup ab-label-pop-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-push-r!,

            dup ab-label-pop!
            ab-token@ rdip:num-args 0= if(
                Prim.Dup ab-prim!,
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            )
            ab-label-push!
        )
    }

    def elab-label-set! [ +Mirth +AB |- Label -- ] {
        dup rdip:is-resource-label? if(
            dup ab-label-push-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-pop-r!,

            ab-token@ rdip:num-args 0= if(
                dup ab-label-pop!
                Prim.Drop ab-prim!
                ab-label-push!,

                dup ab-label-push!
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
                ab-label-pop!
            )
        )
    }

    def elab-atom-block! [ +Mirth +AB |- ] {
        ab-token@ rdip:args-1 elab-block-at!
    }

    def elab-block-at! [ +Mirth +AB |- Token -- ] {
        ab-ctx@ swap ab-home@ rdip:Block.new-deferred!(
            dup ctx swap
            dup dom swap
            dup cod swap
            dup token swap
            home
            elab-arrow-hom!
        ) Op.BlockPush ab-op!
    }

    def elab-args! [ +Mirth +AB |- ] {
        ab-token@ rdip:args for(elab-block-at!)
    }

    def elab-word-args! [ +Mirth +AB |- Word -- Word ] {
        elab-args!
        ab-token@ rdip:num-args over rdip:arity < then(
            ab-token@ rdip:num-args over rdip:params drop-slice for(
                default if? (
                    ab-token@ rdip:location >location rdip:clone-run! elab-block-at!,
                    ab-token@ "word parameter is missing, has no default implementation" rdip:emit-fatal-error!
                )
            )
        )
    }

    def elab-no-args! [ +Mirth +AB |- ] {
        ab-token@ rdip:args-0
    }

    def elab-atom-name! [ +Mirth +AB |- Name -- ] {
        dup ab-ctx@ rdip:lookup match(
            Some -> nip elab-args! ab-var!,
            None -> Left elab-atom-resolve-def!
        )
    }

    def elab-atom-dname! [ +Mirth +AB |- DName -- ] {
        Right elab-atom-resolve-def!
    }

    def Token.can-be-relative-name-or-dname? [ +Mirth |- Token -- Bool ] {
        value match(
            Name -> can-be-relative?,
            DName -> is-relative?,
            _ -> drop False
        )
    }

    def elab-atom-resolve-def! [ +Mirth +AB |- Name/DName -- ] {
        >name/dname
        ab-type@ rdip:top-types-are-fine? not >report-ambiguous-as-warning
        ab-token@ >token
        "word" >sort
        False >ignore-last-name
        >+ab resolve-def(
            filter(dup rdip:callable?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            token rdip:can-be-relative-name-or-dname? if(
                @+ab:ab-type@ rdip:top-types-are-fine? then(
                    @+ab:ab-type@ rdip:top-namespaces filter-roots
                ),
                L0 filter-roots
            )
        ) +ab> match (
            None -> elab-atom-failed!,
            Some -> elab-atom-def!
        )
    }

    def elab-atom-failed! [ +Mirth +AB |- ] {
        StackType.Error ab-type!
    }

    def elab-atom-def! [ +Mirth +AB |- Def -- ] {
        Alias -> rdip:target elab-atom-def!,
        Buffer -> elab-no-args! ab-buffer!,
        External -> elab-no-args! ab-external!,
        Field -> elab-no-args! ab-field!,
        Word -> elab-word-args! ab-word!,
        Tag -> elab-args! ab-tag!,
        Prim -> elab-prim!,
        Macro -> elab-macro!,
        _ -> rdip:qname-hard elab-atom-not-callable!
    }

    def elab-atom-not-callable! [ +Mirth +AB |- QName -- ] {
        ab-type@ rdip:top-types-are-fine? if(
            ab-token@ swap rdip:str("Not callable: "; qname;) rdip:emit-error!,
            drop
        ) elab-atom-failed!
    }

    def elab-macro! [ +Mirth +AB |- Macro -- ] {
        rdip:action arrow? if?(
            run,

            ab-token@ "macro cannot be invoked here" rdip:emit-error!
            StackType.Error ab-type!
        )
    }

    def elab-prim! [ +Mirth +AB |- Prim -- ] {
        elab-args! ab-prim!
    }

    def elab-atom-assert! [ +Mirth +AB |- ] {
        ab-token@ rdip:args-1 >token
        ab-ctx@ >ctx
        True >allow-type-holes
        False >allow-implicit-type-vars
        +TypeElab T0 rdip_:elab-stack-type! rdrop
        ab-token@ rdip:error-token!
        dip:ab-type@ rdip:unify! drop
    }

    ||| Parse an ldip. It takes on one of the forms:
    |||
    |||     ldip(body)
    |||     ldip(label1 ... labeln, body)
    |||     ldip { body }
    |||     ldip(label1 ... labeln) { body }
    |||
    ||| Sets up ab-token@ so that Token.next on it will be past the ldip.
    def elab-parse-ldip! [ +Mirth +AB |- labels:Maybe(List(Label)) body:Token ] {
        ab-token@ rdip:next rdip:lcurly? if(
            ab-token@ rdip:num-args 0= if(
                None >labels,
                ab-token@ rdip:args-1 Some >labels
            )
            ab-token@ rdip:next rdip:succ >body
            ab-token@ rdip:next ab-token!,

            ab-token@ rdip:num-args dup 0= if(
                ab-token@ "Missing ldip body: ldip { ... }" rdip:emit-fatal-error!,

                1 = if(
                    None >labels
                    ab-token@ rdip:args-1 >body,

                    ab-token@ rdip:args-2
                    >body
                    Some >labels
                )
            )
        )

        @labels:map:rdip(
            run-tokens map(
                dup args-0
                dup name? else?("Expected label name." emit-fatal-error!)
                dup could-be-label-name? else(Str("Invalid label name: "; name;) emit-fatal-error!)
                Label.new! nip
            )
        )
    }


    ||| Run function but with labels dipped.
    ||| If list of labels is not given, it is inferred from the stack type.
    |||
    |||     ldip(body)
    |||     ldip(label1 ... labeln, body)
    |||     ldip { body }
    |||     ldip(label1 ... labeln) { body }
    |||
    def elab-ldip! [ +Mirth +AB |- ] {
        elab-parse-ldip! ab-token@
        labels> else?(ab-type@ rdip(label-names unique))
        ab-ldip!(body> ab-token! elab-atoms!)
        ab-token!
    }

    def elab-atom-match! [ +Mirth +AB |- ] {
        rdip:StackType.Fresh! >cod
        ab-token@ succ rdip:lcurly? if(
            ab-token@ succ succ >body
            ab-token@ succ ab-token!,
            ab-token@ rdip:args+ first >body
        )
        elab-match-at!
    }

    ||| Elaborate a match body within AB. Takes the output stack type,
    ||| and the token for the body of the match, from the stack. Takes
    ||| the rest from the AB environment.
    def elab-match-at! [ +Mirth +AB |- cod:StackType body:Token -- ] {
        ab-match!(
            elab-match-cases!
            elab-match-exhaustive!
        )
    }
}

def arity-compatible? [ Int Int -- Bool ] {
    dup -1 = dip(=) or
}

def ab-build!(f) [ (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow ] {
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx L0 >atoms
    Arrow >arrow +AB
    f /+AB arrow>
}

||| Like ab-build! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def ab-build-hom!(f) [
    +Mirth |- (*a StackType +AB -- *b StackType +AB) *a Ctx ArrowType Token Home -- *b Arrow
] {
    dip2(/ArrowType dom>)
    ab-build!(cod> f ab-unify-type!)
}

||| Build the arrow for a word. If the word type and context are available, use that.
||| Otherwise, we are in a situation where type and context were not given, so we infer them.
|||
||| To infer ctx-type, we start with an initial guess based on the word head (with lots
||| of metavariables). We temporarily set that as our ctx-type. Then we elaborate the word
||| body. After elaboration, we rigidify the type to obtain a generalized definition, by
||| replacing any free metavariables with universally quantified variables.
def ab-build-word-arrow!(f) [
    +Mirth |- (*a StackType +AB -- *b StackType +AB) *a Word -- *b Arrow
] {
    initial-ctx-type-body-home
    dip:ab-build-hom!(f)
    finalize-word-arrow
}

def initial-ctx-type-body-home [ +Mirth |- Word -- Ctx ArrowType Token Home Word ] {
    >word
    @word ~ctx-type try-force!
    match(Some -> unpack2, None -> guess-initial-ctx-type)
    @word body
    @word Home.Word
    word>
}

def finalize-word-arrow [ +Mirth |- Arrow Word -- Arrow ] {
    >word >arrow
    @word inferring-type? then(
        @arrow Arrow.ctx-type rigidify-sig!
        dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
        False @word ~inferring-type? !
        /ArrowType
        cod> @arrow:cod!
        dom> @arrow:dom!
        @arrow:ctx!
    )
    arrow> word> drop
}

def guess-initial-ctx-type [ +Mirth word:Word |- Ctx ArrowType ] {
    Ctx.L0 >ctx
    StackType.Fresh! >dom
    StackType.Fresh! >cod
    @word namespace-hard match(
        Tycon ->
            full-type-fresh
            @word name can-be-relative? if(
                @dom(swap T*+),
                @cod(swap T*+)
            ),
        Module ->
            drop
            @word name >Str "main" = then(
                T0 Resource.World T+ !dom
                T0 Resource.World T+ !cod
            ),
        _ ->
            drop
    )
    @word arity repeat(
        @dom(
            ArrowType.Fresh! >Type T*
        )
    )
    ctx> dom> cod> T->
    dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
    True @word ~inferring-type? !
}

def ab-build-word!(f) [ +Mirth |- (*a +AB -- *b +AB) *a Word -- *b Word ] {
    sip(ab-build-word-arrow!(dip(f))) sip(PropLabel.WordArrow prop)
    tuck ~arrow !
}

||| Add an atom to a list of atoms .. smartly.
def ab-optimized-snoc! [ +Mirth |- List(Atom) Atom -- List(Atom) ] {
    while(over atoms-has-last-block? and(atom-accepts-args?),
        swap atoms-turn-last-block-to-arg swap)
    List.Snoc
}

def atom-accepts-args? [ +Mirth |- Atom -- Atom Bool ] {
    dup op match(
        Word -> dip(dup args len) arity <,
        Prim ->
            match(
                Dip -> dup args len 1u <,
                RDip -> dup args len 1u <,
                If -> dup args len 2u <,
                While -> dup args len 2u <,
                _ -> drop False
            ),
        _ -> drop False
    )
}

def atoms-has-last-block? [ List(Atom) -- Bool ] {
    last match(
        None -> False,
        Some ->
            op match(
                BlockPush -> drop True,
                _ -> drop False
            )
    )
}

def atoms-turn-last-block-to-arg [ Atom List(Atom) -- Atom List(Atom) ] {
   >Nest? match(
        None -> L0,
        Some ->
            unsnoc dup op match(
                BlockPush ->
                    { Atom List(Atom) Atom Block }
                    dip(dom rotl dom!)
                    { List(Atom) Atom Block }
                    Arg.Block swap args:cons
                    swap,
                _ -> drop List.Snoc
            )
    )
}

data OpSig {
    Id
    Push  [ Type ]
    Apply [ ArrowType ]
}

def PushValue.type [ +Mirth |- PushValue -- Type ] {
    { Str -> Value.Str Type.Value }
    { Int -> Value.Int Type.Value }
    { U8  -> drop Type.U8 }
    { U16 -> drop Type.U16 }
    { U32 -> drop Type.U32 }
    { U64 -> drop Type.U64 }
    { I8  -> drop Type.I8 }
    { I16 -> drop Type.I16 }
    { I32 -> drop Type.I32 }
    { I64 -> drop Type.I64 }
    { F32 -> drop Type.F32 }
    { F64 -> Value.F64 Type.Value }
}

def elab-op-fresh-sig! [ +Mirth |- Op -- Subst OpSig ] {
    Subst.Nil swap match (
        Push -> type OpSig.Push,
        Buffer -> drop Type.Ptr OpSig.Push,
        Tag -> type freshen-sig OpSig.Apply,
        Word -> dup inferring-type? if(type, type freshen-sig) OpSig.Apply,
        Prim -> type freshen-sig OpSig.Apply,
        External -> type freshen-sig OpSig.Apply,
        Field -> type freshen-sig OpSig.Apply,
        BlockPush -> elab-block-sig!,
        BlockRun -> type semifreshen-sig OpSig.Apply,
        Var -> elab-var-sig!,
        Match -> elab-match-sig!,
        Lambda -> elab-lambda-sig!,
        LabelPush -> elab-label-push-sig!,
        LabelPop -> elab-label-pop-sig!,
        LabelPushR -> elab-label-push-r-sig!,
        LabelPopR -> elab-label-pop-r-sig!,
        DataGetEnumValue -> data-get-enum-value-type freshen-sig OpSig.Apply,
        DataFromEnumValue -> data-from-enum-value-type freshen-sig OpSig.Apply,
        DataGetLabel -> data-get-label-type freshen-sig OpSig.Apply,
        DataSetLabel -> data-set-label-type freshen-sig OpSig.Apply,
        TableToIndex -> table-to-index-type freshen-sig OpSig.Apply,
        TableFromIndex -> table-from-index-type freshen-sig OpSig.Apply,
    )
}

def data-get-enum-value-type [ +Mirth |- Data -- ArrowType ] {
    full-type match {
        { Left  -> T1 Type.I64 T1 T-> }
        { Right -> # not currently exposed for resources, but this is what it would be.
            T0 over T+ Type.I64 T1 rotl T+ T-> }
    }
}
def data-from-enum-value-type [ +Mirth |- Data -- ArrowType ] {
    Type.I64 T1 T0 rotl full-type T*+ T->
}

def table-to-index-type [ +Mirth |- Table -- ArrowType ] {
    Type.Table T1 Type.U64 T1 T->
}
def table-from-index-type [ +Mirth |- Table -- ArrowType ] {
    Type.Table T1 Type.U64 T1 swap T->
}

def elab-block-sig! [ Block -- OpSig ] {
    Value.Block Type.Value OpSig.Push
}

def elab-match-sig! [ Match -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-lambda-sig! [ Lambda -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-var-sig! [ +Mirth |- Var -- OpSig ] {
    dup auto-run? if?(
        nip semifreshen-sig OpSig.Apply,
        type OpSig.Push
    )
}

def elab-label-push-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Type.Fresh! dup2)
    StackType.ConsLabel dip(StackType.Cons) T-> OpSig.Apply
}

def elab-label-pop-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Type.Fresh! dup2)
    StackType.ConsLabel dip(StackType.Cons) swap T-> OpSig.Apply
}

def elab-label-push-r-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Resource.Fresh! dup2)
    StackType.WithLabel dip(StackType.With) T-> OpSig.Apply
}

def elab-label-pop-r-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Resource.Fresh! dup2)
    StackType.WithLabel dip(StackType.With) swap T-> OpSig.Apply
}

def elab-arrow! [ +Mirth |- Ctx ArrowType Token Home -- Arrow ] {
    dip2(/ArrowType dom> cod>) elab-arrow-hom!
}

def elab-arrow-hom! [ +Mirth |- Ctx StackType StackType Token Home -- Arrow ] {
    rotl dip(
        elab-arrow-fwd!
        dup token-end error-token!
        dup cod
    )
    unify! drop
}

def elab-arrow-fwd! [ +Mirth |- Ctx StackType Token Home -- Arrow ] {
    ab-build!(elab-atoms!)
}

||| Elaborate match cases.
def elab-match-cases! [ +Mirth +Match |- ] {
    body rdip:lcurly? if(
        elab-match-cases-curly!,
        elab-match-cases-args!
    )
}

def elab-match-cases-curly! [ +Mirth +Match |- ] {
    body rdip:run-tokens for(
        dup rdip:lcurly?
        else("Expected a pattern match case of the form { ... -> ... }" rdip:emit-fatal-error!)
        rdip:args-1 elab-match-case!
        drop
    )
}

def elab-match-cases-args! [ +Mirth +Match |- ] {
    body while(dup rdip:args-end? not, elab-match-case!) drop
}

||| Elaborate match case based on starting token.
def elab-match-case! [ Token +Mirth +Match |- ] {
    dup rdip:run-arrow? unwrap("Expected pattern match case ... -> ..." rdip:emit-fatal-error!)
    dup2 = then("expected pattern" rdip:emit-fatal-error!)
    dup2 rdip:prev = else("multi-part pattern not supported" rdip:emit-fatal-error!)
    rdip(dip:pat-tokens sip:prev succ) +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup rdip:comma? then(succ)
    )
}

def elab-pattern! [ +Mirth +Pattern |- List(Token) -- ] {
    reverse-for(elab-pattern-atom!)
}

def elab-pattern-atom! [ +Mirth +Pattern |- Token -- ] {
    dup pattern:token-start!
    dup rdip:error-token!

    dup rdip:pat-underscore? if(
        drop +Pattern.underscore!,

    dup rdip:name/dname? if?(
        >name/dname >token
        "constructor" >sort
        pattern mid rdip:top-types-are-fine? not >report-ambiguous-as-warning
        False >ignore-last-name
        >+pat resolve-def(
            filter(dup tag? some?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            @+pat:pattern mid rdip:top-types-are-fine? then(
                @+pat:pattern mid rdip:top-namespaces
                token rdip:name? if(
                    filter(dup2 rdip:qname-hard namespace swap member, RejectedDef.WrongConstructor) drop,
                    filter-roots
                )
            )
        ) +pat> bind(tag?) match(
            Some -> +Pattern.tag!,
            None -> StackType.Error pattern:mid!
        ),

        "Expected constructor name." rdip:emit-fatal-error!
    ))
}

def +Match.case!(mkpat,mkbod) [
    +Mirth |- (*a +Pattern -- *b +Pattern, *b +AB -- *c +AB) *a Token Token +Match -- *c +Match
] {
    dip(
        +Match.home >home dup >token-start >token-end
        +Match.ctx dup >outer-ctx >inner-ctx
        L0 >saved +Match.dom dup >mid >cod L0 >atoms
        Pattern rdip(thaw mkpat freeze) >pattern
    )
    @pattern inner-ctx
    @pattern Pattern.dom +Match.cod T->
    rotl
    +Match.home
    ldip:rdip(ab-build-hom!(dip(mkbod)))
    >body Case add-case
}

def elab-expand-tensor! [ +Mirth StackType |- Token -- Type Token ] {
    >tok force-cons?! match(
        Some -> unpack2 tok>,
        None -> StackType.Error Type.Error tok> dup "expected tuple type" emit-error!
    )
}

def elab-lambda-param? [ +Mirth Token |- Maybe(Var) ] {
    dup pattern-var? if?(
        dip(dup args-0 next)
        dip(Type.Fresh!)
        Var.new! Some,

    dup pattern-auto-run-var? if?(
        dip(dup succ args-0 next)
        dip(ArrowType.Fresh!)
        Var.new-auto-run! Some,

        None
    ))
}

def elab-atom-lambda! [ +Mirth +AB |- ] {
    ab-token@ rdip:args-1
    collect(rdip:elab-lambda-param?)
    dip(rdip:expect-token-arrow succ)
    ab-lambda-at!(elab-atoms!)
}

||| Check that a match is exhaustive.
def elab-match-exhaustive! [ +Mirth +Match |- ] {
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw
}

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def elab-module! [ +World +Mirth Module |- ] {
    dup start
    elab-module-header!
    over Namespace.Module PropLabel.DefiningNamespace prop Some with-defining-namespace (
        elab-decls!
        dup module-end? else(
            "Unexpected token in module." emit-fatal-error!
        )
    )
    drop
}

def elab-module-qname [ +Mirth |- Token -- QName ] {
    parse-module-package-name! dip(Namespace.Package) 0 QName.Mk
}

struct ModuleHeader {
    doc: Maybe(Str)
    package: Package
    name: Name
    head: Token
    imports: List(ModuleImport)
}

||| Parse the `module` declaration at the top of the module:
|||
|||     module(ModuleName)
|||     module ModuleName
|||
def parse-module-header! [ +Mirth Token |- ModuleHeader ] {
    dup doc >doc
    dup error-token!
    dup module-header? else("Expected module header." emit-fatal-error!)
    dup num-args 0> if (
        sip(next) args-1 >head
        @head parse-module-package-name! >name >package
        @head next dup arg-end? else("Expected end of argument." emit-fatal-error!) drop,

        succ >head
        @head parse-module-package-name! >name >package
        @head next
    )
    L0 >imports
    while(dup module-import?, parse-module-import @imports:cons)
    @imports:reverse
    dup sig-dashes? then(succ)
    ModuleHeader
}

||| Parse a ModuleName.
def parse-module-package-name! [ +Mirth |- Token -- Package Name ] {
    dup name/dname? else("Expected module name." emit-fatal-error!)
    dup dname? unwrap("Invalid module name: Module name must include package, for example \"package.module\"" emit-fatal-error!) over args-0
    dup root? unwrap(drop "Invalid module name: Package name is missing." emit-fatal-error!)
    swap parts single? unwrap(drop "Expected module name. (3)" emit-fatal-error!)
    dip(Package.Find-Or-New! nip)
}

||| Elaborate the module header and save the name and package.
def elab-module-header! [ +World +Mirth Token |- ] {
    dup .module >module
    parse-module-header! /ModuleHeader
    name> @module ~name !
    doc> @module ~doc !
    package> @module ~package !
    @module qname defined-soft? then(@head "Module name already taken." emit-fatal-error!)
    head> @module ~head !
    @module Def.Module register
    dup module> check-module-path
    imports> for(process-module-import!)
}

def check-module-path [ +World +Mirth |- Token Module -- ] {
    dup path rdip:split-last match(
        None ->
            swap qname to-module-path dup2 = else(
                "Expected module name to match path.\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
            ) drop3,

        Some ->
            split-last-byte(Byte.BDOT =) "mth" Some =
            else(over3 "Expected .mth extension for mirth file." emit-warning!)
            over2 name >Str = else(over2 .module .head "Expected module name to match file name." emit-fatal-error!)
            over package path! drop2
    )
}

||| Elaborate a series of declarations. Decl*
def elab-decls! [ +World +Mirth Token |- ] {
    while(dup arg-end? not over module-end? not and, elab-decl!)
}

||| Elaborate either a single declaration or a block of declarations:
|||
|||     Decl
|||     { Decl* }
def elab-decl-or-decl-block! [ +World +Mirth Token |- ] {
    dup lcurly? if(
        elab-decl-block!,
        elab-decl!
    )
}

||| Elaborate a declaration block.
|||
|||     { Decl* }
def elab-decl-block! [ +World +Mirth Token |- ] {
    dup lcurly? else("Expected { ... }" emit-fatal-error!) succ
    elab-decls!
    dup rcurly? else("Expected end of declaration block." emit-fatal-error!)
    succ
}

||| Skip a declaration block without elaborating it.
||| The contents of the block aren't even parsed so this can
||| be used for conditional compilation across versions.
|||
|||     { ... }
def skip-decl-block! [ +Mirth Token |- ] {
    dup lcurly? else("Expected { ... }" emit-fatal-error!) next
}

||| Elaborate a declaration. Returns the next token.
def elab-decl! [ +World +Mirth Token |- ] {
    dup error-token!
    dup name? unwrap("unknown declaration" emit-fatal-error!)
    defs find-some(macro? bind(action decl?))
    unwrap("unknown declaration" emit-fatal-error!) run
}

def load-module [ +World +Mirth Token |- QName -- Module ] {
    dup def-soft? match(
        Some -> module? unwrap(drop "module name already taken" emit-fatal-error!) nip,
        None ->
            to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
                #    https://github.com/mirth-lang/mirth/issues/241
    )
}

struct ModuleImport {
    name: Token
}

||| Parse a module import statement. Return token after import.
|||
|||     import(ModuleName)
|||     import ModuleName
def parse-module-import [ +Mirth Token |- ModuleImport ] {
    dup module-import? else("Expected import statement." emit-fatal-error!)
    dup num-args 0> if(
        sip(next) args-1 >name
        @name succ arg-end? else(@name succ "expected arg end" emit-fatal-error!),
        succ dup >name next
    )
    ModuleImport
}

||| Process a module import statement.
def process-module-import! [ +World +Mirth |- ModuleImport -- ] {
    /ModuleImport
    name> dup with-error-token(dup elab-module-qname load-module)
    swap module ~imports modify:cons
}

||| Parse a data declaration. It looks like one of:
|||
|||     data ( TypeAtom, DataTag* DataDecls )
|||     data TypeAtom { DataTag* DataDecls }
def parse-data [ +Mirth Token |- SyntaxData ] {
    dup doc >doc
    dup num-args 0> if(
        succ dup lparen? else("expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-data-tags >tags
        parse-data-decls! >decls
        dup rparen? else("expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-data-tags >tags
        parse-data-decls! >decls
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

def parse-data-header [ +Mirth Token |- SyntaxDataHeader ] {
    dup >head next
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    SyntaxDataHeader
}

def parse-data-tags [ +Mirth Token |- List(SyntaxDataTag) ] {
    collect-while(dup data-tags-end? not, parse-data-tag)
}

def data-tags-end? [ +Mirth |- Token -- Bool ] {
    dup args-end? or(dup sig-dashes?) nip
}

||| Parse a data tag. It looks like one of these:
|||
|||     Tag
|||     Tag -> Type* &ArgEnd
|||     Tag [ Type* ]
|||
def parse-data-tag [ +Mirth Token |- SyntaxDataTag ] {
    dup doc >doc
    dup >head
    dup int? dup >value? then(succ)
    dup name? filter(could-be-constructor)
    unwrap("Expected constructor name." emit-fatal-error!) >name
    succ dup arrow? if(
        succ dup Some >sig? sig-next-stack-end
        dup arg-end? else("Expected comma." emit-fatal-error!),
        dup lsquare? if(
            succ dup Some >sig? sig-next-stack-end
            dup rsquare? else("Expected right square bracket ']'" emit-fatal-error!)
            succ,

            None >sig?
        )
    )
    dup comma? then(succ)
    SyntaxDataTag
}

||| Parse a struct declaration. This looks like this:
|||
|||     struct(TypeAtom, Type* DataDecls)
|||     struct TypeAtom { Type* DataDecls }
|||
def parse-struct [ +Mirth Token |- SyntaxData ] {
    dup doc >doc
    dup num-args 0> if(
        succ dup lparen? then("Expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-struct-tag L1 >tags
        parse-data-decls! >decls
        dup rparen? then("Expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-struct-tag L1 >tags
        parse-data-decls! >decls
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

||| Data declarations. These start with sig-dashes.
||| This is either empty, or it is dashes followed by decls within an expression.
def parse-data-decls! [ +Mirth Token |- Maybe(Token) ] {
    dup sig-dashes? if(
        succ dup while(dup arg-end? not, next) swap Some,
        None
    )
}

def parse-struct-tag [ +Mirth Token header:SyntaxDataHeader |- SyntaxDataTag ] {
    None >doc
    @header head >head
    @head last-name? filter(could-be-constructor)
    unwrap(@header head "Expected constructor name." emit-fatal-error!) >name
    None >value?
    dup Some >sig?
    sig-next-stack-end
    SyntaxDataTag
}

struct SyntaxData {
    doc: Maybe(Str)
    header: SyntaxDataHeader
    tags: List(SyntaxDataTag)
    decls: Maybe(Token)
}

struct SyntaxDataHeader {
    head: Token
}

struct SyntaxDataTag {
    doc: Maybe(Str)
    head: Token
    value?: Maybe(Int)
    name: Name
    sig?: Maybe(Token)
}

def elab-data!   { parse-data   elab-data-aux! }
def elab-struct! { parse-struct elab-data-aux! }

def elab-data-aux! [ +World +Mirth |- SyntaxData -- ] {
    /SyntaxData
    Data.alloc! List.Nil over ~tags !
    doc> over ~doc !
    header> elab-data-header!
    tags> for(elab-data-tag!)
    decls> for(elab-data-decls!)
    elab-data-done!
}

||| Get the header, name, arity for a data type.
def elab-data-header! [ +Mirth Data |- SyntaxDataHeader -- ] {
    /SyntaxDataHeader >data
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    elab-def-head
    @head Some @data ~head? !
    arity> >Int @data ~arity !
    name> @data ~name !
    @data PropLabel.DataQName >label Prop @data ~qname !
    @head args @data PropLabel.DataParams prop(elab-data-params!) @data ~params !
    @data Def.Data register
    head> drop
    data>
}

# TODO check header args are well-formed / elaborate them properly
#  as part of: https://github.com/mirth-lang/mirth/issues/246
def elab-data-params! [ +Mirth |- List(Token) -- List(Var) ] {
    Ctx.L0 swap for(
        dup name? unwrap("Expected a parameter name." emit-fatal-error!)
        over2 Ctx.lookup then("Duplicate parameter name." emit-fatal-error!)

        None
        or?(dup sig-type-var? map(Type.TYPE swap Var.new!))
        or?(dup sig-resource-var? map(Type.RESOURCE swap Var.new!))
        or?(dup sig-stack-var? map(Type.STACK swap Var.new!))
        unwrap("Invalid parameter name." emit-fatal-error!)
        nip Ctx.new
    ) >List
}

||| Get a tag associated with a data type.
def elab-data-tag! [ +Mirth Data |- SyntaxDataTag -- ] {
    >syn >dat
    Tag.alloc! >tag

    @syn doc @tag ~doc !
    @dat @syn name 0 data-qname @tag ~qname !
    @syn sig? @tag ~sig? !
    @syn value? for(@tag ~value !)
    @dat @tag ~data !
    @tag @dat add-tag!
    @tag Def.Tag register

    @syn head @tag @tag PropLabel.TagType prop2(
        >tag >token
        @tag .data params >Ctx >ctx
        True >allow-implicit-type-vars
        False >allow-type-holes
        +TypeElab
        T0 @tag rdip(data full-type) T*+
        tag> rdip:sig? match(
            None -> T0,
            Some -> token! T0 elab-stack-type-parts!
        )
        swap T-> dip:ctx pack2 rdrop
    ) @tag ~ctx-type !
    @tag num-type-inputs-from-sig @tag ~num-type-inputs !
    @tag num-resource-inputs-from-sig @tag ~num-resource-inputs !
    @tag label-inputs-from-sig @tag ~label-inputs !

    @tag outputs-resource? not then(
        @tag sig? for(
            run-tokens find(
                or(sig-resource-con? >Bool, sig-resource-var? >Bool)
            ) for ("Value type cannot contain resource." emit-error!)
        )
    )

    tag> syn> drop2
    dat>
}

def elab-data-decls! [ +World +Mirth Data |- Token -- ] {
    dup Some >error-token
    over Tycon.Data Namespace.Tycon PropLabel.DefiningNamespace prop Some >defining-namespace
    LexicalState with-lexical-state (
        while(dup arg-end? not, elab-decl!)
        drop
    )
}

def data-word-new! [ +Mirth |- Data Str Nat doc:Maybe(Str) -- Word ] {
    dup >arity
    over >Name >name
    dip2(dup head? unwrap("Missing data token information." fatal-error!) dup >body >head)
    data-word-qname >qname
    None >sig?
    Word.New!

    qname> over PropLabel.WordQName prop over ~qname !
}

def elab-data-done! [ +Mirth |- Data -- ] {
    >dat
    @dat is-value-type? then (
        None >doc # TODO
        @dat "enum-value" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-get-enum-value-type
        @word PropLabel.WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat Op.DataGetEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat is-enum? then (
        None >doc # TODO
        @dat "from-enum-value-unsafe" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-from-enum-value-type
        @word PropLabel.WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat Op.DataFromEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat tags single? for(
        >tag
        None >doc # TODO
        @dat "/" @tag name >Str cat 0u data-word-new! >untag
        @untag Some @tag ~untag !
        @tag @untag PropLabel.WordType prop(ctx-type invert pack2) @untag ~ctx-type !
        @tag @untag @untag PropLabel.WordArrow prop2(
            >untag >tag
            untag> ab-build-word-arrow!(
                @tag rdip:type dom >cod
                @tag rdip:data rdip:head? unwrap("Missing data token info" rdip:fatal-error!) dup >body
                ab-match!(
                    dup case!(@tag +Pattern.tag!, id)
                )
            )
            tag> drop
        ) @untag ~arrow !
        @untag make-inline!
        @tag create-projectors!
        tag> untag> drop2
    )

    @dat @dat PropLabel.DataCType prop(
        >dat
        @dat is-unit? if(
            "void" CType.Void Some,
        @dat is-enum? if(
            "int" CType.Int Some,
        @dat semi-transparent? if?(
            input match(
                Cons -> ctype?,
                ConsLabel -> drop ctype?,
                With -> ctype?,
                WithLabel -> drop ctype?,
            ),
            None
        )))
        dat> drop
    ) @dat ~ctype? !
    dat> drop
}

||| Return the tag's output type or resource in context.
field(Tag.~output-type, Tag, Type/Resource)
def Tag.output-type [ +Mirth |- Tag -- Type/Resource ] {
    >tag
    @tag ~output-type memoize(
        @tag type cod expand match {
            { Cons -> nip Left }
            { With -> nip Right }
            { _ ->
                drop @tag str("Unexpected output type for constructor "; qname;)
                @tag .data head? if?(swap emit-error!, error!)
                Type.Error @tag .data is-resource? if(
                    Resource Right,
                    Left
                )
            }
        }
    )
    tag> drop
}

||| Return the tag's output type or resource in context, except for a missing field.
def Tag.output-type-except-field [ +Mirth |- Label Tag -- Type/Resource ] {
    dup output-type map(except-field, except-field)
}

||| Return the input type for a tag along a given label.
def Tag.project-input-label [ +Mirth |- Label Tag -- Maybe(Type/Resource) ] {
    type dom label-top?
}

def Tag.project-tag-field [ +Mirth |- Label Tag -- Maybe(TagField) ] {
    dup2 project-input-label if? (
        >type/resource >tag >label TagField Some,
        drop2 None
    )
}

def data-get-label-type [ +Mirth |- TagField -- ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T0 @tag output-type T*+ swap T1
            @tag .data is-resource? then(@tag output-type T*+)
            T-> }
        { Right ->
            T0 @tag output-type T*+
            T0 rotl T+ @label @tag output-type-except-field T*+
            T-> }
    }
    label> tag> drop2
}

def data-set-label-type [ +Mirth |- TagField -- ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T1 @tag output-type T*+
            T0 @tag output-type T*+
            T-> }
        { Right ->
            T0 swap T+ @label @tag output-type-except-field T*+
            T0 @tag output-type T*+
            T-> }
    }
    label> tag> drop2
}

def create-projectors! [ +Mirth |- Tag -- ] {
    >tag
    @tag .data >dat
    @tag label-inputs reverse-for(
        >lbl
        @dat @lbl name 0 data-qname undefined-soft? then(
            None >doc # TODO
            @dat @lbl >Str 0u data-word-new! >lbl_get

            None >doc # TODO
            @dat @lbl >Str "!" cat 0u data-word-new! >lbl_set

            None >doc # TODO
            @dat @lbl >Str 1u data-word-new! >lbl_lens

            @lbl_get make-inline!
            @tag @lbl @lbl_get PropLabel.WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-get-label-type
                pack2
            ) @lbl_get ~ctx-type !
            @tag @lbl @lbl_get dup PropLabel.WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    Op.DataGetLabel ab-op!
                )
            )) @lbl_get ~arrow !

            @lbl_set make-inline!
            @tag @lbl @lbl_set PropLabel.WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-set-label-type
                pack2
            ) @lbl_set ~ctx-type !
            @tag @lbl @lbl_set dup PropLabel.WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    Op.DataSetLabel ab-op!
                )
            )) @lbl_set ~arrow !

            @lbl_lens make-inline!
            @tag @lbl @lbl_lens PropLabel.WordType prop2(
                >lbl >tag
                lbl> @tag project-input-label unwrap("logic error: expeted field in tag." fatal-error!) >lblty
                @tag output-type >datty

                @tag ctx
                "*x" StackType.NewInCtx >sx
                "*y" StackType.NewInCtx >sy
                @sx @datty T*+
                    @sx @lblty T*+
                    @sy @lblty T*+ T-> >Type T*
                @sy  @datty T*+
                T-> pack2

                sx> sy> drop2
                lblty> datty> drop2
                tag> drop
            ) @lbl_lens ~ctx-type !
            @lbl_lens dup PropLabel.WordParams prop(
                type dom top-type? unwrap("logic error: expected parameter" fatal-error!)
                arrow? unwrap("logic error: expected arrow" fatal-error!)
                "f" >Name Var.new-auto-run! >var None >default Param L1
            ) @lbl_lens ~params !

            @dat @lbl_get @lbl_set @lbl_lens dup PropLabel.WordArrow prop4(
                >lbl_lens >lbl_set >lbl_get >dat
                @lbl_lens ab-build-word-arrow!(
                    lbl_lens> rdip:params map(.var) dup ab-lambda!(
                        single? unwrap("Expected one parameter." rdip:fatal-error!) >f
                        dat> rdip:is-resource? if(
                            lbl_get> ab-word!
                            ab-rdip!(f> ab-var!)
                            lbl_set> ab-word!,

                            Prim.Dup ab-prim!
                            ab-dip!(
                                lbl_get> ab-word!
                                f> ab-var!
                            )
                            lbl_set> ab-word!
                        )
                    )
                )
            ) @lbl_lens ~arrow !
            lbl_get> lbl_set> lbl_lens> drop3
        )
        lbl> drop
    )
    dat> tag> drop2
}

def expect-token-arrow [ +Mirth Token |- ] {
    dup arrow? else("Expected arrow." emit-fatal-error!)
}

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def elab-def-missing! [ +Mirth Token |- ] {
    dup args len 3u < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined-hard? if(next, elab-def!)
}

def +Mirth.with-inline(f) [ +Mirth |- (*a -- *b) *a Bool -- *b ] {
    prefer-inline-defs:swap
    dip(f) prefer-inline-defs!
}

||| Mark the following definition(s) as inline.
|||
|||     inline Decl
|||     inline ( Decl* )
|||     inline { Decl* }
def elab-inline! [ +World +Mirth Token |- ] {
    True with-inline(
        dup num-args 0> if(
            sip:next args-1 elab-decls! drop,
            succ elab-decl-or-decl-block!
        )
    )
}

||| Elaborate a patch declaration. This is a way to add definitions in a
||| particular namespace.
|||
|||     patch Namespace { Decl* }
def elab-patch! [ +World +Mirth Token |- ] {
    dup args-0
    succ dup args-0
    dup name/dname? else?("Expected a type constructor." emit-fatal-error!)
    dip:dup PropLabel.DefiningNamespace prop2(
        >name/dname
        False >ignore-last-name
        dup resolve-def-namespace
        else?("Cannot compute patch namespace." emit-fatal-error!)
        nip
    ) Some with-defining-namespace (
        succ elab-decl-block!
    )
}

||| Elaborate max-mirth-revision block. This will skip a
||| declaration block if mirth-revision is too high.
|||
|||     max-mirth-revision Int { Decl* }
def elab-max-mirth-revision! [ +World +Mirth Token |- ] {
    dup args-0
    succ dup int? else?("Expected a revision number." emit-fatal-error!)
    mirth-revision >= if(
        succ elab-decl-block!,
        succ skip-decl-block!
    )
}

||| Elaborate min-mirth-revision block. This will skip a
||| declaration block if mirth-revision is too low.
|||
|||     min-mirth-revision Int { Decl* }
def elab-min-mirth-revision! [ +World +Mirth Token |- ] {
    dup args-0
    succ dup int? else?("Expected a revision number." emit-fatal-error!)
    mirth-revision <= if(
        succ elab-decl-block!,
        succ skip-decl-block!
    )
}

struct SyntaxDef {
    doc:  Maybe(Str)
    head: Token
    sig?: Maybe(Token)
    body: Token
}

||| Parse a word definition. It looks like one of these:
|||
|||     def(word, sig, body...)
|||     def word [ sig ] { body... }
|||     def word { body... }
|||
||| Returns the next token after the definition.
def parse-def [ +Mirth Token |- SyntaxDef ] {
    dup error-token!
    dup doc >doc
    dup args empty? if(
        next
        dup >head next
        dup lsquare? if(dup args-1 Some >sig? next, None >sig?)
        dup lcurly? else("expected { ... }" emit-fatal-error!)
        dup args+ >body
        next,

        sip(next)
        dup args dup len 3u <
            then(drop
                 "def(...) expects at least three arguments"
                 emit-fatal-error!)
            nip
        >Nest? unwrap(impossible!) uncons dip(>head)
        >Nest? unwrap(impossible!) uncons dip(Some >sig?)
        >Nest? unwrap(impossible!) >body

        @head next arg-end? else(
            @head next "expected comma after word name" emit-fatal-error!
        )
    )
    body> uncons empty? or(dup run-arrow? >Bool)
        else("expected match case" emit-fatal-error!) >body
    SyntaxDef
}

||| Elaborate a word definition.
def elab-def! [ +Mirth Token |- ] {
    parse-def /SyntaxDef
    elab-def-head Word.New! >word
    @word PropLabel.WordQName >label Prop @word ~qname !

    prefer-inline-defs @word ~prefer-inline? !

    @word @word PropLabel.WordType prop(
        dup sig? match(
            Some ->
                nip
                +TypeElab.Start!
                T0 elab-type-sig!
                dip:ctx pack2
                rdrop,
            None ->
                arrow ctx-type pack2
        )
    ) @word ~ctx-type !
    @word @word PropLabel.WordParams prop(elab-def-params!) @word ~params !
    @word @word PropLabel.WordArrow prop(
        dup dup ab-build-word-arrow!(
            swap rdip:params dup empty? if(
                drop elab-def-body!,
                map(.var) ab-lambda!(elab-def-body!)
            )
        ) tuck check-inline-recursion-arrow!
    ) @word ~arrow !
    word> drop
}

def check-inline-recursion-arrow! [ +Mirth |- Word Arrow -- ] {
    atoms for(dip:dup check-inline-recursion-atom!) drop
}
def check-inline-recursion-atom! [ +Mirth |- Word Atom -- ] {
    over prefer-inline? if(
        dup2 op check-inline-recursion-op!
        args for(dip:dup check-inline-recursion-arg!) drop,
        drop2
    )
}
def check-inline-recursion-arg! [ +Mirth |- Word Arg -- ] {
    Block -> arrow check-inline-recursion-arrow!
}
def check-inline-recursion-op! [ +Mirth |- Word Op -- ] {
    BlockRun -> arrow check-inline-recursion-arrow!,
    Word ->
        dup2 = if(
            drop check-inline-recursion-failed!,
            dup prefer-inline? if(
                ~arrow try-force! if?(
                    check-inline-recursion-arrow!,
                    check-inline-recursion-failed!
                ),
                drop2
            )
        ),
    Match -> cases for(dip:dup body check-inline-recursion-arrow!) drop,
    Lambda -> body check-inline-recursion-arrow!,
    _ -> drop2
}
def check-inline-recursion-failed! [ +Mirth |- Word -- ] {
    dup prefer-inline? if(
        False over ~prefer-inline? !
        head "recursive word cannot be inlined" emit-warning!,
        drop
    )
}

||| Elaborate a word's parameters from its type and declaration.
def elab-def-params! [ +Mirth |- Word -- List(Param) ] {
    L0 over type
    rotl head dip(/ArrowType dom> cod>) nip
    args reverse-for(
        dup sig-param-name? unwrap("expected parameter name" emit-fatal-error!) >name
        dup succ dup run-end? if(
            drop None >default,
            dup lcurly? if(
                dup succ Some >default
                next dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!),

                "expected right paren, left curly, or comma" emit-fatal-error!
            )
        )
        elab-expand-tensor!
        swap arrow? unwrap("need function type for param" emit-fatal-error!)
        nip name> Var.new-auto-run! >var Param
        rotr dip:cons
    ) drop
}

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def elab-def-body! [ +Mirth +AB |- StackType -- StackType ] {
    ab-token@ rdip:run-arrow? or(ab-token@ rdip:lcurly? some?) if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    )
}

data ExternalDeclPart {
    EDPCode [ token:Token code:Str ]
    EDPDef  [ doc:Maybe(Str) head:Token symbol:Maybe(Token) sig:Token ]
}

||| Parse an external block.
|||
|||     external( ExternalPart* )
|||     external{ ExternalPart* }
|||     external ExternalPart
def parse-external-decl [ +Mirth Token |- List(ExternalDeclPart) doc:Maybe(Str) ] {
    dup doc >doc
    succ dup num-args 0> or(dup lcurly? >Bool) if(
        List(
            succ
            while(dup rdip:args-end? not,
                rdip(parse-external-decl-part) ;
            )
            succ
        ),

        parse-external-decl-word L1
        None >doc
    )
}

def parse-external-decl-part [ +Mirth Token |- ExternalDeclPart ] {
    dup str? if?(
        >code dup >token
        succ
        ExternalDeclPart.EDPCode,

        dup doc >doc
        parse-external-decl-word
    )
    dip(dup comma? then(succ))
}

def parse-external-decl-word [ +Mirth Token |- doc:Maybe(Str) -- ExternalDeclPart ] {
    dup >head
    dup name/dname? else("expected external word name" emit-fatal-error!)
    succ
    dup arrow? if(
        succ dup name? else("expected external symbol name" emit-fatal-error!)
        dup Some >symbol
        succ,

        None >symbol
    )
    dup lsquare? if(
        dup args-1 >sig
        next,

        dup comma? else("expected type signature" emit-fatal-error!)
        succ
        dup arg-end? then("expected type signature" emit-fatal-error!)
        dup >sig
        next-arg-end
    )
    ExternalDeclPart.EDPDef
}

||| Elaborate an external declaration.
def elab-external! [ +Mirth Token |- ] {
    dup >token
    parse-external-decl
    map(elab-external-block-part!) >parts
    ExternalBlock.alloc! >extblock
    doc> @extblock ~doc !
    token> @extblock ~token !
    parts> @extblock ~parts !
    extblock> drop
}

def elab-external-block-part! [ +Mirth |- ExternalDeclPart -- ExternalBlockPart ] {
    { EDPCode -> token> drop code> ExternalBlockPart.EBPCode }
    { EDPDef -> elab-external-def! ExternalBlockPart.EBPDef }
}

def elab-external-def! [ +Mirth |- doc:Maybe(Str) head:Token symbol:Maybe(Token) sig:Token -- External ] {
    elab-def-head

    symbol> bind(name?) unwrap(@name) >Str >symbol

    External.alloc! >external
    doc> @external ~doc !
    name> @external ~name !
    arity> >Int @external ~arity !
    @external PropLabel.ExternalQName >label Prop @external ~qname !
    symbol> @external ~symbol !
    sig> @external ~sig !
    head> @external ~head !
    @external dup PropLabel.ExternalType prop(
        sig +TypeElab.Start!
        T0 elab-type-sig! dip:ctx pack2 rdrop
    ) @external ~ctx-type !
    @external dup PropLabel.ExternalCType prop(
        elab-external-ctype
    ) @external ~ctype !
    @external Def.External register
    external>
}

def elab-external-ctype [ +Mirth |- External -- CTypeArrow ] {
    dup head with-error-token(
        type ctype
        dup cod parts
        filter(sip(label? none?) ctype phantom? not and)
        len 1u > then(
            "External has too many outputs." error!
        )

        dup dom parts filter-some(label?)
        over cod parts filter-some(label?)
        swap difference for(
            Str("Output label "; name; " not present in input";) error!
        )
    )
}

||| Parse a type definition.
|||
|||     def-type(t1,t2)
|||     def-type t1 t2
def parse-def-type [ +Mirth Token |- head:Token target:Token doc:Maybe(Str) ] {
    dup doc >doc
    dup num-args 0> if (
        sip(next) args-2 >target >head
        @head args-0
        @head sig-type-con? else(@head "expected type constructor" emit-fatal-error!)
        @head next arg-end? else(@head next "expected comma" emit-fatal-error!)
        @target next arg-end? else(@target next "expected end of args" emit-fatal-error!),

        succ dup >head next dup >target next
        @head args-0
        @head sig-type-con? else(@head "expected type constructor" emit-fatal-error!)
    )
}

||| Elaborate a type definition `def-type(t1, t2)`.
def elab-def-type! [ +Mirth Token |- ] {
    parse-def-type
    elab-def-head @head:Some
    arity> drop
    TypeDef.new!
    doc> over ~doc !
    target> over PropLabel.TypeDefTarget prop(elab-simple-type-arg!) swap ~target !
}

||| Elaborate a buffer declaration.
|||
|||     buffer(Name, Size)
|||     buffer Name Size
def parse-buffer [ +Mirth Token |- head:Token doc:Maybe(Str) size:Size ] {
    dup doc >doc
    dup num-args 0> if(
        sip(next) args-2 >sizearg >head
        @head args-0
        @head name/dname? else(@head "Expected buffer name." emit-fatal-error!)
        @head next arg-end? else(@head next "Expected comma." emit-fatal-error!)
        @sizearg int? else?(@sizearg "Expected buffer size." emit-fatal-error!) >size
        @sizearg next args-end? else(@sizearg next "Expected end of arguments." emit-fatal-error!),

        succ dup >head next dup >sizearg next
        @head name/dname? else(@head "Expected buffer name." emit-fatal-error!)
        @sizearg int? else?(@sizearg "Expected buffer size." emit-fatal-error!) >size
    )
    @size 0> else(@sizearg "Buffer size must be positive." emit-error! 8 !size)
    @size:>Size
    sizearg> drop
}

||| Elaborate a buffer definition `buffer(B, size)`.
def elab-buffer! [ +Mirth Token |- ] {
    parse-buffer elab-def-head arity> drop
    Buffer.new! >buffer
    @buffer PropLabel.BufferQName >label Prop @buffer ~qname !
    buffer> Def.Buffer register
}

||| Parse a table declaration.
|||
|||     table(Tycon)
|||     table Tycon
def parse-table-decl [ +Mirth Token |- head:Token doc:Maybe(Str) ] {
    dup doc >doc
    dup num-args 0> if(
        sip(next) args-1 >head
        @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
        @head args-0
        @head succ arg-end? else(@head succ "expected end of argument after table name" emit-fatal-error!),

        succ dup >head
        @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
        @head args-0
        succ
    )
}

||| Elaborate a table definition `table(True)`.
def elab-table! [ +Mirth Token |- ] {
    parse-table-decl
    elab-def-head
    arity> drop
    table-new! drop
}

||| Create entry point based on word name.
def elab-entry-point [ +Mirth |- QName -- Arrow ] {
    dup def-hard? bind(word?) unwrap(
        dup namespace module? for(start error-token!)
        str("Can't find entry point "; qname;)
        fatal-error!
    ) nip { Word +Mirth }
    dup dip(Ctx.L0 T0 Resource.World T+ T0 Resource.World T+ T->)
    head dup Home.Main ab-build-hom!(
        dip(ab-word!)
    )
}

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def elab-embed-str! [ +World +Mirth Token |- ] {
    dup doc >doc
    sip:next args-2 swap
    >head elab-def-head
    @arity 0= else(@head "expected no arguments" emit-fatal-error!)
    dup >body None >sig?
    dup str? unwrap("expected source path" emit-fatal-error!)
    >Path >+mirth open-file! +else(+mirth> io-error!) read-file! close-file! then?(+mirth> io-error!) nip >contents +mirth>
    Word.New!
    dup PropLabel.WordQName >label Prop over ~qname !

    Ctx.L0 T0 Type.Str T1 T-> over2 PropLabel.WordType prop2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop
}

||| Ensure that everything so far has been typechecked.
def typecheck-everything! [ +Mirth |- ] {
    Name.for(defs for(dup qname-hard drop typecheck!))
    Block.for(typecheck!)
    External.for(ctype drop)
}

#########
# TABLE #
#########

def table-qname [ +Mirth |- Table Str Int -- QName ] {
    >arity >Name >name Tycon.Table Namespace.Tycon >namespace QName
}

def table-word-new! [ +Mirth |- Table Str Nat doc:Maybe(Str) -- Word ] {
    over2 head dup >head >body None >sig?
    dup >arity over >Name >name >Int table-qname >qname Word.New!
    qname> over PropLabel.WordQName prop over ~qname !
}

def table-new! [ +Mirth |- head:Token name:Name state:PropState(QName) doc:Maybe(Str) -- Table ] {
    Table.alloc! >tbl
    @tbl PropLabel.TableQName >label Prop @tbl ~qname !
    @head @tbl ~head !
    name> @tbl ~name !
    doc> @tbl ~doc !
    @tbl Def.Table register

    # Table.nil
    None >doc # TODO
    @tbl "nil" 0u table-word-new! >word

    Ctx.L0
    T0 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @head ab-token!
        0u64 PushValue.U64 ab-push-value!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.NUM
    None >doc # TODO
    @head >head
    "NUM" >Name >name
    8 bytes >size
    Buffer.new! >buf
    @buf @tbl ~num-buffer !
    @tbl "Num" 0 table-qname
    @buf PropLabel.BufferQName prop
    @buf ~qname !
    @buf Def.Buffer register

    # Table.index
    None >doc # TODO
    @tbl "index" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 Type.U64 T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableToIndex ab-op!
    ) drop

    # Table.from-index
    None >doc # TODO
    @tbl "from-index" 0u table-word-new! >word

    Ctx.L0
    Type.U64 T1 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.succ
    None >doc # TODO
    @tbl "succ" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableToIndex ab-op!
        1u64 PushValue.U64 ab-push-value!
        Prim.U64Add ab-prim!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.pred
    None >doc # TODO
    @tbl "pred" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableToIndex ab-op!
        Prim.Dup ab-prim!
        0u64 PushValue.U64 ab-push-value!
        Prim.U64Eq ab-prim!
        ab-if!(
            ,
            1u64 PushValue.U64 ab-push-value!
            Prim.U64Sub ab-prim!
        )
        @tbl Op.TableFromIndex ab-op!
    ) drop

    { +Mirth tbl:Table buf:Buffer head:Token }

    # Table.for
    None >doc # TODO
    @tbl "for" 1u table-word-new! >word
    Type.STACK "*a" >Name Var.new! >va
    @va StackType.Var @tbl Type.Table T* @va StackType.Var T-> "f" >Name Var.new-auto-run! >vx

    @va Ctx.L1
    @va StackType.Var @vx type T* @va StackType.Var T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    @vx >var None >default Param L1
    @word PropLabel.WordParams prop
    @word ~params !
    @word make-inline!

    word> ab-build-word! (
        @head ab-token!
        @vx L1 ab-lambda!(
            1u64 PushValue.U64 ab-push-value!
            ab-while!(
                Prim.Dup ab-prim!
                @buf ab-buffer!
                Prim.U64Get ab-prim!
                Prim.U64Le ab-prim!,

                Prim.Dup ab-prim!
                ab-dip! (
                    @tbl Op.TableFromIndex ab-op!
                    @vx ab-var!
                )
                1u64 PushValue.U64 ab-push-value!
                Prim.U64Add ab-prim!
            )
            Prim.Drop ab-prim!
        )
    ) drop
    va> vx> drop2

    # Table.alloc!
    None >doc # TODO
    @tbl "alloc!" 0u table-word-new! >word

    Ctx.L0
    T0 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @buf ab-buffer!
        Prim.U64Get ab-prim!
        1u64 PushValue.U64 ab-push-value!
        Prim.U64Add ab-prim!
        Prim.Dup ab-prim!
        @buf ab-buffer!
        Prim.U64Set ab-prim!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    head> buf> drop2
    tbl>
}

#########
# FIELD #
#########

def resolve-def-namespace [ +Mirth |- Token name/dname:Name/DName ignore-last-name:Bool -- Maybe(Namespace) ] {
    >token
    "namespace" >sort
    False >report-ambiguous-as-warning
    resolve-def(
        filter-sort(dup rdip:as-def-namespace? >Bool)
        filter-qualifiers
        L0 filter-roots
    )
    bind(as-def-namespace?)
}

def elab-qname-from-nonrelative-dname [ +Mirth |- Token DName arity:Int -- QName ] {
    dup Right >name/dname
    dup root? else(drop "relative name not allowed" emit-fatal-error!)
    last-name >name
    True >ignore-last-name
    dup resolve-def-namespace unwrap(panic-diagnostics!) >namespace
    drop QName
}

def module-visible-from-token? [ +Mirth |- Token Module -- Bool ] {
    swap .module visible
}

def def-visible-from-token? [ +Mirth |- Token Def -- Bool ] {
    defining-module? match(
        None -> drop True,
        Some -> module-visible-from-token?
    )
}

def Token.is-default-param? [ +Mirth |- Token -- Bool ] {
    dup name? and( dup succ lcurly? >Bool ) nip
}

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def elab-def-qname [ +Mirth |- Token -- QName ] {
    dup args dup has(is-default-param?) if(drop -1, len >Int) >arity
    dup name/dname? unwrap("expected name" emit-fatal-error!)
    match(
        Left -> >name defining-namespace-or-error >namespace QName,
        Right -> elab-qname-from-nonrelative-dname
    )
}

||| The namespace for definitions by default.
def defining-namespace-or-error [ +Mirth |- Token -- Namespace ] {
    lexical-state defining-namespace(
        unwrap("error: no namespace for definition" emit-fatal-error!)
        compute Some
    ) lexical-state!
    unwrap("error: couldn't compute namespace for definition" emit-fatal-error!)
    nip
}

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def elab-def-qname-undefined [ +Mirth |- Token -- QName ] {
    dup elab-def-qname
    dup defined-soft? then(drop "name already defined" emit-fatal-error!)
    nip
}

||| Elaborate the head, i.e. the name-giving token, of a definition.
||| We defer the full resolution of the qualified name, but otherwise
||| we collect arity and (simple) name data from the head token.
def elab-def-head [ +Mirth head:Token |- name:Name arity:Nat state:PropState(QName) ] {
    @head name/dname?
        unwrap(@head "expected name" emit-fatal-error!)
        either(id, parts last) >name
    @head num-args >arity
    lexical-state @head [ elab-def-qname-undefined ] PropState.Delay >state
}

||| Parse a field definition, `field(f, T1, T2)`
def parse-field [ +Mirth Token |- doc:Maybe(Str) head:Token index-type:Token value-type:Token ] {
    dup doc >doc
    sip(next) args-3 >value-type >index-type >head
    @head name/dname? else(@head "expected field name" emit-fatal-error!)
    @head args-0
}

||| Elaborate a field definition `field(f, T1, T2)`.
def elab-field! [ +Mirth Token |- ] {
    parse-field elab-def-head
    Field.alloc! >fld
    doc> @fld ~doc !
    name> @fld ~name !
    head> @fld ~head !
    arity> 0= else(@fld head "Field cannot take arguments." emit-error!)
    @fld PropLabel.FieldQName >label Prop @fld ~qname !
    index-type> @fld PropLabel.FieldIndexType prop(elab-simple-type-arg!) @fld ~index-type !
    value-type> @fld PropLabel.FieldValueType prop(elab-simple-type-arg!) @fld ~value-type !
    fld> Def.Field register
}
