module mirth.elab

import std.prelude
import std.str
import std.list
import std.maybe
import std.either
import std.byte
import std.terminal

import mirth.mirth
import mirth.name
import mirth.def
import mirth.token
import mirth.data
import mirth.external
import mirth.word
import mirth.var
import mirth.buffer
import mirth.variable
import mirth.table
import mirth.tycon
import mirth.type
import mirth.typedef
import mirth.var
import mirth.arrow
import mirth.word
import mirth.prim
import mirth.module
import mirth.package
import mirth.alias
import mirth.match
import mirth.lexer
import mirth.label
import mirth.macro

####################
# Type Elaboration #
####################

struct +TypeElab {
    ctx:Ctx
    token:Token
    allow-type-holes:Bool
    allow-implicit-type-vars:Bool
    --
    def rdrop [ +TypeElab -- ] {
        /+TypeElab
        ctx> token> drop2
        allow-type-holes> drop
        allow-implicit-type-vars> drop
    }

    def Start! [ Token -- +TypeElab ] {
        >token
        Ctx.L0 >ctx
        False >allow-type-holes
        True >allow-implicit-type-vars
        +TypeElab
    }

    def elab-type-sig! [ +Mirth +TypeElab -- +Mirth +TypeElab ArrowType ] {
        token run-end? then(token "expected type signature" rdip:emit-error!)
        elab-type-sig-params!
        elab-stack-type!
        token sig-dashes? if(token:succ elab-stack-type!, dip:T0)
        token run-end? else(token "expected right paren or comma" rdip:emit-error!)
        dip(swap for(T*)) T->
    }

    def elab-type-sig-params! [ +Mirth +TypeElab -- +Mirth +TypeElab List(Type) ] {
        token lparen? if(
            token next
            token args map(token! elab-type-sig! Type.Arrow)
            dip:token!,
            List.L0
        )
    }

    def elab-stack-type! [ +Mirth +TypeElab -- +Mirth +TypeElab StackType ] {
        token sig-stack-var? if?(elab-stack-type-var!, T0)
        elab-stack-type-parts!
    }

    def elab-stack-type-parts! [ +Mirth +TypeElab StackType -- +Mirth +TypeElab StackType ] {
        while(token sig-stack-end? not, elab-stack-type-part! cons)
    }

    def elab-type-arg! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
        token elab-stack-type-part!
        match(
            Cons -> nip,
            ConsLabel -> drop2 "Expected type, not label." rdip:emit-error! Type.Error,
            With -> drop "Expected type, not resource." rdip:emit-error! Type.Error,
            WithLabel -> drop2 "Expected type, not labelled resource." rdip:emit-error! Type.Error,
        )
        token arg-end? else(
            token "Unexpected token after type." rdip:emit-error!
        )
    }

    def elab-resource-arg! [ +Mirth +TypeElab -- +Mirth +TypeElab Resource ] {
        token elab-stack-type-part!
        match(
            Cons -> drop "Expected resource, not type." rdip:emit-error! Type.Error Resource,
            ConsLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
            With -> nip,
            WithLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
        )
        token arg-end? else(
            token "Unexpected token after resource." rdip:emit-error!
        )
    }

    def elab-stack-type-part! [ +Mirth +TypeElab -- +Mirth +TypeElab StackTypePart ] {
        token sig-label? if?(
            elab-stack-label!,

        token sig-type-var? if?(
            elab-type-var! StackTypePart.Cons,

        token sig-type-con? if?(
            elab-type-con! StackTypePart.Cons,

        token sig-resource-var? if?(
            elab-resource-var! StackTypePart.With,

        token sig-resource-con? if?(
            elab-resource-con! StackTypePart.With,

        token pat-underscore? if(
            elab-type-dont-care! StackTypePart.Cons,

        token sig-type-hole? if?(
            elab-type-hole! StackTypePart.Cons,

        token lsquare? .if(
            elab-type-quote! StackTypePart.Cons,

            token "Expected type, got unknown token." rdip:emit-error!
            token:next Type.Error StackTypePart.Cons
        ))))))))
    }

    def elab-stack-label! [ +Mirth +TypeElab Label -- +Mirth +TypeElab StackTypePart ] {
        token next dip(
            token:args-1 dup is-resource-label? if(
                elab-resource-arg! swap StackTypePart.WithLabel,
                elab-type-arg! swap StackTypePart.ConsLabel
            )
        ) token!
    }

    def elab-stack-type-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab StackType ] {
        Type.StackType elab-implicit-var! if?(StackType.Var, StackType.Error)
    }

    def elab-type-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Type ] {
        Type.Type elab-implicit-var! if?(Type.Var, Type.Error)
    }

    def elab-resource-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Resource ] {
        Type.ResourceType elab-implicit-var! if?(Type.Var, Type.Error) Resource
    }

    def gamma(f) [ (*a +Gamma -- *b +Gamma) *a +TypeElab -- *b +TypeElab ] {
        token rdip(>token +Gamma f rdrop)
    }

    def elab-implicit-var! [ +Mirth +TypeElab Name Type -- +Mirth +TypeElab Maybe(Var) ] {
        over ctx lookup match(
            Some -> sip(dip:nip type gamma:unify! drop) Some,
            None ->
                allow-implicit-type-vars if(
                    swap Var.new! ctx(over Ctx.new) Some,
                    token "Implicit type variable not allowed here." rdip:emit-error!
                    drop2 None
                )
        )
        token rdip:args-0
        token:succ
    }

    def resolve-type-con-name! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Type List(Var) ] {
        >name/dname
        False >report-ambiguous-as-warning
        False >ignore-last-name
        token >token "type" >sort rdip:resolve-def(
            filter(dup rdip:defines-a-type?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            List.L0 filter-roots
        ) if? (
            match(
                Data -> sip:Type.Data rdip:params,
                Table -> Type.Table List.L0,
                Type -> rdip(sip:target params),
                _ ->
                    drop token "compiler bug: resolve-type-con-name! doesn't understand type"
                    rdip:emit-error! Type.Error List.L0,
            ),
            Type.Error List.L0
        )
    }

    def elab-type-con! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Type ] {
        dup left? has(>Str "Mut" ==) if(
            drop token next dip(
                token:args-1
                elab-type-arg!
                Type.Mut
            ) token!,

            resolve-type-con-name! elab-type-args!
            token:next
        )
    }

    def elab-resource-con! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Resource ] {
        elab-type-con! Resource
    }

    def with-token(f) [ (*a +TypeElab -- *b +TypeElab) *a +TypeElab Token -- *b +TypeElab ] {
        token:swap dip(f) token!
    }

    def elab-type-args! [ +Mirth +TypeElab Type List(Var) -- +Mirth +TypeElab Type ] {
        token args for(
            with-token(elab-type-app!)
        ) drop
    }

    def elab-type-app! [ +Mirth +TypeElab Type List(Var) -- +Mirth +TypeElab Type List(Var) ] {
        uncons swap if? (
            rdip:sort? else?(token "Type parameter has unknown sort." rdip:emit-fatal-error!) match {
                { Resource -> elab-resource-arg! >Type }
                { Stack -> elab-stack-type! >Type }
                { Type -> elab-type-arg! }
            } swap dip:Type.App,

            drop tycon? then?(
                token rdip:Str("Too many type arguments to "; swap rdip(qname-hard >Str) ;) rdip:emit-error!
            )
            Type.Error List.L0
        )
    }

    def elab-type-hole! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Hole,
            drop
            token "type holes are not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-dont-care! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Ignore,
            token "underscore is not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-quote! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
        token next dip(
            token:args-1
            token sig-has-dashes? if(
                elab-type-sig! >Type,
                elab-stack-type! >Type
            )
        ) token!
    }
}

def show-num-arguments [ Int -- Str ] {
    dup 1 == if(drop "1 argument",
    show " arguments" cat)
}

# TODO: separate this into a reason and a def.
data RejectedDef {
    WrongSort          [ Def ]
    WrongArity         [ Def ]
    NotVisible         [ Def ]
    NotImported        [ Def ]
    WrongQualifier     [ Def ]
    WrongConstructor   [ Def ]
    MethodNotAvailable [ Def ]
    MethodWrongType    [ Def ]
}

struct +ResolveDef {
    sort: Str
    token: Token
    name/dname: Name/DName
    candidates: List(Def)
    rejected: List(RejectedDef)
    ignore-last-name: Bool
    report-ambiguous-as-warning: Bool
    --
    def rdrop [ +ResolveDef -- ] {
        /+ResolveDef
        sort> token> name/dname> drop3
        candidates> rejected> drop2
        ignore-last-name> drop
        report-ambiguous-as-warning> drop
    }

    def Begin! [
        sort:Str
        token:Token
        name/dname:Name/DName
        ignore-last-name:Bool
        report-ambiguous-as-warning:Bool
        +Mirth
        -- +Mirth +ResolveDef
    ] {
        @ignore-last-name if(
            @name/dname name/dname-penultimate-name? unwrap(
                @token "Expected a namespace." emit-fatal-error!
            ),
            @name/dname name/dname-last-name
        ) defs >candidates
        List.Nil >rejected
        +ResolveDef
    }

    def expunge(p) [
        (*a Def -- *a Bool)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        candidates:filter(p not)
    }

    def filter(p) [
        (*a Def +ResolveDef -- *a Either(RejectedDef, Def) +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        candidates partition-either(p) dip:rejected:cat candidates!
    }

    def filter(p,q) [
        (*a Def +ResolveDef -- *a Def Bool +ResolveDef,
         *a Def +ResolveDef -- *a RejectedDef +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        filter(p if(Right, q Left))
    }


    def filter-sort(p) [
        (*a Def +ResolveDef -- *a Def Bool +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        filter(p, RejectedDef.WrongSort)
    }

    def filter-arity [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        token num-args filter(
            dup2 rdip:qname-hard arity dip(>Int) arity-compatible?,
            RejectedDef.WrongArity
        ) drop
    }

    def filter-visible [ +ResolveDef -- +ResolveDef ] {
        filter(token over def-visible-from-token?, RejectedDef.NotVisible)
    }

    def filter-qualifiers [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        token dname? for(
            filter(dup2 rdip:qname-hard climb-up-dname? empty? not, RejectedDef.WrongQualifier)
            drop
        )
    }

    def filter-roots [ List(Namespace) +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        name/dname match {
            { Left ->
                >name
                filter(
                    dup2 rdip:qname-hard namespace swap member
                    or(token over rdip:def-is-imported-at-token?),
                    dup rdip:qname-hard namespace match(
                        Tycon ->
                            drop @name can-be-relative? if(
                                over empty? if(
                                    RejectedDef.MethodNotAvailable,
                                    RejectedDef.MethodWrongType
                                ),
                                RejectedDef.NotImported
                            ),
                        _ -> drop RejectedDef.NotImported
                    )
                )
                name> drop
            }

            { Right ->
                dup is-relative? and(ignore-last-name not) if(
                    filter(dup2 rdip:qname-hard climb-up-dname? has(over3 member),
                        over2 empty? if(
                            RejectedDef.MethodNotAvailable,
                            RejectedDef.MethodWrongType
                        )
                    ),
                    filter(dup2 rdip:qname-hard climb-up-dname? has(
                        dip:token rdip:namespace-is-imported-at-token?
                    ), RejectedDef.NotImported)
                ) drop
            }
        }

        drop
    }

    def end! [ +Mirth +ResolveDef -- +Mirth Maybe(Def) ] {
        candidates match(
            Nil -> resolve-def-unknown None,
            Cons -> match(
                Nil -> rdrop Some,
                _ -> List.filter(over rdip:same-resolved? not) match(
                    Nil -> rdrop Some,
                    _ -> drop2 resolve-def-ambiguous None
                )
            )
        )
    }

    def resolve-def-ambiguous [ +Mirth +ResolveDef -- +Mirth ] {
        report-ambiguous-as-warning if(
            token Str(
                "Can't resolve " ; rdip:sort ; " due to previous errors. Candidates are:" ;
                " " rdip:candidates for(swap ; rdip2(qname-hard >Str) ; ", ") drop
            ) rdip:emit-warning!,

            token Str(
                "Ambiguous " ; rdip:sort ; ". Can't decide between:" ;
                " " rdip:candidates for(swap ; rdip2(qname-hard >Str) ; ", ") drop
            ) rdip:emit-error!
        ) rdrop
    }

    def resolve-def-unknown [ +Mirth +ResolveDef -- +Mirth ] {
        token Str(rdip:rejected match(
            Nil -> "Unknown " ; rdip:sort ; " name, possibly a misspelling." ;,
            Cons ->
                match(
                    Nil -> match(
                        WrongSort ->
                            "Expected a " ; rdip:sort ; ", but " ;
                            rdip2(qname-hard >Str) ; " is not a " ; rdip:sort ; "." ; ,
                        NotVisible ->
                            "Not visible in current scope: " ; rdip2(qname-hard >Str) ; ,
                        NotImported ->
                            "Not imported in current scope: " ; rdip2(qname-hard >Str) ; ,
                        WrongArity ->
                            rdip2(qname-hard dup >Str) ; " expects " ; arity show;
                            " arguments, but got " ; rdip:token num-args show; "." ; ,
                        WrongQualifier ->
                            "Qualified name not found. Perhaps you meant: " ; rdip2(qname-hard >Str) ; ,
                        WrongConstructor ->
                            "Constructor is for a different type: " ; rdip2(qname-hard >Str) ; ,
                        MethodWrongType ->
                            "Method is for a different type: " ; rdip2(qname-hard >Str) ; ,
                        MethodNotAvailable ->
                            "Method is not available for current stack: " ; rdip2(qname-hard >Str) ; ,
                    ),
                    _ -> cons "Multiple definitions for name, but none are suitable:" ;
                        dip:" " for(swap ; match(
                            WrongSort -> rdip2(qname-hard >Str) ; " is not a " ; rdip:sort ; ,
                            NotVisible ->
                                rdip2(qname-hard >Str) ; " is not visible in current scope" ; ,
                            NotImported ->
                                rdip2(qname-hard >Str) ; " is not imported in current scope" ; ,
                            WrongArity ->
                                rdip2(qname-hard dup >Str) ; " expects " ;
                                arity show; " arguments" ; ,
                            WrongQualifier ->
                                rdip2(qname-hard >Str) ; " doesn't match the given qualified name" ; ,
                            WrongConstructor ->
                                rdip2(qname-hard >Str) ; " is constructor for a different type" ; ,
                            MethodWrongType ->
                                rdip2(qname-hard >Str) ; " is method for a different type" ; ,
                            MethodNotAvailable ->
                                rdip2(qname-hard >Str) ; " is not avaliable for current stack" ; ,
                        ) ", ") drop
                )
        )) rdip:emit-error! rdrop
    }
}

def +Mirth.resolve-def(f) [
    (*a +Mirth +ResolveDef -- *b +Mirth +ResolveDef)
    *a +Mirth
    sort:Str
    token:Token
    name/dname: Name/DName
    ignore-last-name:Bool
    report-ambiguous-as-warning:Bool
    --
    *b +Mirth Maybe(Def),
] {
    +ResolveDef.Begin! f end!
}

def QName.punning? [ +Mirth QName -- +Mirth Bool ] {
    dup namespace match {
        { Tycon -> name swap name == }
        { _ -> drop2 False }
    }
}

def Def.punning? [ +Mirth Def -- +Mirth Bool ] {
    qname-hard punning?
}

||| Check whether a definition can be referred to without qualification.
def def-is-imported-at-token? [ +Mirth Token Def -- +Mirth Bool ] {
    # TODO: implement finer grained control over what is imported.
    #   https://github.com/mirth-lang/mirth/issues/243
    dup qname-hard namespace match(
        Root -> drop2 True,
        Package -> drop3 True,
        Module -> nip module-visible-from-token?,
        Tycon -> dip:swap tycon-is-visible-at-token? if(punning?, drop False),
        Word -> drop3 False
    )
}

def tycon-is-visible-at-token? [ Token Tycon -- Bool ] {
    Data -> head? if?(.module module-visible-from-token?, drop True),
    Table -> head .module module-visible-from-token?,
    Prim -> drop2 True
}

def namespace-is-imported-at-token? [ +Mirth Token Namespace -- +Mirth Bool ] {
    Root -> drop True,
    Package -> drop2 True,
    Module -> module-visible-from-token?,
    Tycon -> qname-hard namespace namespace-is-imported-at-token?,
    Word -> drop2 False
}

def QName.climb-up-name? [ +Mirth Name QName -- +Mirth List(Namespace) ] {
    >qname >name

    @qname name @name == if(
        @qname namespace List.L1,
        List.L0
    ) >accum
    name> defs for(match(
        Alias ->
            dup ~target try-force! has(qname-hard @qname ==) if(
                namespace-hard @accum:cons,
                drop
            ),
        Type ->
            dup target tycon? has(qname-hard @qname ==) if(
                namespace @accum:cons,
                drop
            ),
        _ -> drop
    ))
    qname> drop
    accum>
}

def QName.climb-up-dname? [ +Mirth +ResolveDef DName QName -- +Mirth +ResolveDef List(Namespace) ] {
    dip(sip(root? >List) parts unsnoc dip(cat)
        ignore-last-name then(drop unsnoc unwrap(
            token "Error, expected a namespace in QName.climb-up-dname?" rdip:emit-fatal-error!
        ))
    )
    rdip:climb-up-name? swap
    reverse-for(swap bind(rdip:qname if?(dip(dup) rdip:climb-up-name?, List.L0)) nip)
}

def elab-type-unify! [ +Mirth Type Type Token -- +Mirth Type Token ] {
    >token +Gamma unify! /+Gamma token>
}
def elab-stack-type-unify! [ +Mirth StackType StackType Token -- +Mirth StackType Token ] {
    >token +Gamma unify! /+Gamma token>
}

def elab-simple-type-arg! [ +Mirth Token -- +Mirth Type ] {
    >token
    Ctx.L0 >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab elab-type-arg! rdrop
}

####################
# Word Elaboration #
####################

struct +AB {
    arrow:Arrow
    --
    def ab-token@ [ +AB -- +AB Token ] { arrow token-end }
    def ab-token! [ +AB Token -- +AB ] { arrow:token-end! }
    def ab-type@ [ +AB -- +AB StackType ] { arrow cod }
    def ab-type! [ +AB StackType -- +AB ] { arrow:cod! }
    def ab-ctx@ [ +AB -- +AB Ctx ] { arrow ctx }
    def ab-home@ [ +AB -- +AB Home ] { arrow home }
    def gamma(f) [ (*a +Gamma -- *b +Gamma) *a +AB -- *b +AB ] {
        ab-token@ rdip(>token +Gamma f rdrop)
    }

    def ab-unify-type! [ StackType +Mirth +AB -- +Mirth +AB ] {
        dip:ab-type@ gamma:unify! ab-type!
    }

    def ab-atom! [ Atom +AB -- +AB ] {
        dup token ab-token!
        # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
            # ^ a sanity check to make sure
            # atom dom matches ab-arrow cod
        dup cod ab-type!
        arrow:atoms(swap ab-optimized-snoc!)
    }

    def ab-op! [ Op +Mirth +AB -- +Mirth +AB ] {
        ab-ctx@ >ctx
        ab-token@ >token
        ab-home@ >home
        dup >op
        rdip:elab-op-fresh-sig! dip:>subst
        ab-expand-opsig! >cod >dom
        List.L0 >args Atom ab-atom!
    }

    def ab-expand-opsig! [ OpSig +Mirth +AB -- StackType StackType +Mirth +AB ] {
        { OpSig.Id -> ab-type@ dup }
        { OpSig.Push -> dip(ab-type@ dup) StackType.Cons }
        { OpSig.Apply ->
            /ArrowType
            ab-type@
            dom> ab-token@ rdip:elab-stack-type-unify! drop
            cod> }
    }

    def ab-int! [ Int +Mirth +AB -- +Mirth +AB ] { Op.Int ab-op! }
    def ab-f64! [ F64 +Mirth +AB -- +Mirth +AB ] { Op.F64 ab-op! }
    def ab-str! [ Str +Mirth +AB -- +Mirth +AB ] { Op.Str ab-op! }
    def ab-buffer! [ Buffer +Mirth +AB -- +Mirth +AB ] { Op.Buffer ab-op! }
    def ab-variable! [ Variable +Mirth +AB -- +Mirth +AB ] { Op.Variable ab-op! }
    def ab-field! [ Field +Mirth +AB -- +Mirth +AB ] { Op.Field ab-op! }
    def ab-var! [ Var +Mirth +AB -- +Mirth +AB ] { Op.Var ab-op! }
    def ab-tag! [ Tag +Mirth +AB -- +Mirth +AB ] { Op.Tag ab-op! }
    def ab-prim! [ Prim +Mirth +AB -- +Mirth +AB ] { Op.Prim ab-op! }
    def ab-word! [ Word +Mirth +AB -- +Mirth +AB ] { Op.Word ab-op! }
    def ab-external! [ External +Mirth +AB -- +Mirth +AB ] { Op.External ab-op! }
    def ab-label-push! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPush ab-op! }
    def ab-label-pop! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPop ab-op! }
    def ab-label-push-r! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPushR ab-op! }
    def ab-label-pop-r! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPopR ab-op! }

    def ab-block-at!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Token +Mirth +AB -- *b +Mirth +AB ] {
        ab-ctx@ MetaVar.new! StackType.Meta rotl ab-home@ rdip(ab-build!(f))
        rdip:Block.new! Op.BlockPush ab-op!
    }

    def ab-block!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
        ab-token@ ab-block-at!(f)
    }

    def ab-dip!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
        ab-block!(f) Prim.Dip ab-prim!
    }

    def ab-rdip!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
        ab-block!(f) Prim.RDip ab-prim!
    }

    def ab-if!(f,g) [
        (*a +Mirth +AB -- *b +Mirth +AB,
        *b +Mirth +AB -- *c +Mirth +AB)
        *a +Mirth +AB -- *c +Mirth +AB
    ] {
        ab-block!(f) ab-block!(g) Prim.If ab-prim!
    }

    def ab-while!(f,g) [
        (*a +Mirth +AB -- *b +Mirth +AB,
        *b +Mirth +AB -- *c +Mirth +AB)
        *a +Mirth +AB -- *c +Mirth +AB
    ] {
        ab-block!(f) ab-block!(g) Prim.While ab-prim!
    }

    def ab-lambda!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a List(Var) +Mirth +AB -- *b +Mirth +AB ] {
        dip(ab-token@) ab-lambda-at!(f)
    }

    def ab-lambda-at!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Token List(Var) +Mirth +AB -- *b +Mirth +AB ] {
        dup dip(
            dip(ab-ctx@ ab-type@) reverse-for(
                swap dip(dup dip(Ctx.new))
                ab-token@ rdip:elab-expand-tensor!
                dip(rotl type) rdip:elab-type-unify! drop2
            )
            rotl ab-home@ rdip(ab-build!(f))
        )
        >params >body
        ab-ctx@ >outer-ctx
        ab-type@ >dom
        ab-token@ >token
        Lambda Op.Lambda ab-op!
    }

    def ab-match!(f) [
        (*a +Mirth +Match -- *b +Mirth +Match)
        *a cod:StackType body:Token +Mirth +AB -- *b +Mirth +AB
    ] {
        ab-ctx@ >ctx
        ab-type@ >dom
        ab-token@ >token
        ab-home@ >home
        List.L0 >cases
        rdip(+Match f freeze) Op.Match ab-op!
    }

    def elab-atoms! [ +Mirth +AB -- +Mirth +AB ] {
        while(
            ab-token@ run-end? not,
            elab-atom! ab-token@ next ab-token!
        )
    }

    def elab-atom! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ value match(
            Name -> elab-atom-name!,
            DName -> elab-atom-dname!,
            Int -> ab-int!,
            Str -> ab-str!,
            F64 -> ab-f64!,
            LSquare -> drop elab-atom-block!,
            LCurly -> drop elab-atom-assert!,
            LabelPush -> ab-token@ rdip:args-0 ab-label-push!,
            LabelPop -> ab-token@ rdip:args-0 ab-label-pop!,
            LabelPushR -> ab-token@ rdip:args-0 ab-label-push-r!,
            LabelPopR -> ab-token@ rdip:args-0 ab-label-pop-r!,
            LabelGet -> elab-label-get!,
            LabelSet -> elab-label-set!,
            _ -> ab-token@ "Unexpected token in elab-atom!" rdip:emit-fatal-error!
        )
    }

    def elab-label-get! [ Label +Mirth +AB -- +Mirth +AB ] {
        dup is-resource-label? if(
            dup ab-label-pop-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-push-r!,

            dup ab-label-pop!
            ab-token@ num-args 0= if(
                Prim.Dup ab-prim!,
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            )
            ab-label-push!
        )
    }

    def elab-label-set! [ Label +Mirth +AB -- +Mirth +AB ] {
        dup is-resource-label? if(
            dup ab-label-push-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-pop-r!,

            ab-token@ num-args 0= if(
                dup ab-label-pop!
                Prim.Drop ab-prim!
                ab-label-push!,

                dup ab-label-push!
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
                ab-label-pop!
            )
        )
    }

    def elab-atom-block! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args-1 elab-block-at!
    }

    def elab-block-at! [ Token +Mirth +AB -- +Mirth +AB ] {
        ab-ctx@ swap ab-home@ rdip:Block.new-deferred!(
            dup ctx swap
            dup dom swap
            dup cod swap
            dup token swap
            home
            elab-arrow-hom!
        ) Op.BlockPush ab-op!
    }

    def elab-args! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ args for(elab-block-at!)
    }

    def elab-word-args! [ Word +Mirth +AB -- Word +Mirth +AB ] {
        elab-args!
        ab-token@ num-args over arity < then(
            ab-token@ num-args over rdip:params drop-slice for(
                default if? (
                    ab-token@ location >location clone-run! elab-block-at!,
                    ab-token@ "word parameter is missing, has no default implementation" rdip:emit-fatal-error!
                )
            )
        )
    }

    def elab-no-args! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args-0
    }

    def elab-atom-name! [ Name +Mirth +AB -- +Mirth +AB ] {
        dup ab-ctx@ lookup match(
            Some -> nip elab-args! ab-var!,
            None -> Left elab-atom-resolve-def!
        )
    }

    def elab-atom-dname! [ DName +Mirth +AB -- +Mirth +AB ] {
        Right elab-atom-resolve-def!
    }

    def Token.can-be-relative-name-or-dname? [ Token -- Bool ] {
        value match(
            Name -> can-be-relative?,
            DName -> is-relative?,
            _ -> drop False
        )
    }

    def elab-atom-resolve-def! [ +Mirth +AB Name/DName -- +Mirth +AB ] {
        >name/dname
        ab-type@ top-types-are-fine? not >report-ambiguous-as-warning
        ab-token@ >token
        "word" >sort
        False >ignore-last-name
        >+ab resolve-def(
            filter(dup rdip:callable?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            token can-be-relative-name-or-dname? if(
                @+ab:ab-type@ top-types-are-fine? then(
                    @+ab:ab-type@ top-namespaces filter-roots
                ),
                List.L0 filter-roots
            )
        ) +ab> match (
            None -> elab-atom-failed!,
            Some -> elab-atom-def!
        )
    }

    def elab-atom-failed! [ +Mirth +AB -- +Mirth +AB ] {
        StackType.Error ab-type!
    }

    def elab-ambiguous-name-error! [ *a Token List(QName) +Mirth -- *b +Mirth ] {
        dip("name is ambiguous, can't decide between:")
        for(dip(" " cat) >Str cat) emit-fatal-error!
    }

    def elab-atom-def! [ Def +Mirth +AB -- +Mirth +AB ] {
        Alias -> rdip:target elab-atom-def!,
        Buffer -> elab-no-args! ab-buffer!,
        Variable -> elab-no-args! ab-variable!,
        External -> elab-no-args! ab-external!,
        Field -> elab-no-args! ab-field!,
        Word -> elab-word-args! ab-word!,
        Tag -> elab-args! ab-tag!,
        Prim -> elab-prim!,
        Macro -> elab-macro!,
        _ -> rdip:qname-hard elab-atom-not-a-word!
    }

    def elab-atom-not-a-word! [ QName +Mirth +AB -- +Mirth +AB ] {
        ab-type@ top-types-are-fine? if(
            dip(ab-token@ "Not a word: ") rdip:>Str cat rdip:emit-error!,
            drop
        ) elab-atom-failed!
    }

    def elab-macro! [ Macro +Mirth +AB -- +Mirth +AB ] {
        action arrow? if?(
            run,

            ab-token@ "macro cannot be invoked here" rdip:emit-error!
            StackType.Error ab-type!
        )
    }

    def elab-prim! [ Prim +Mirth +AB -- +Mirth +AB ] {
        elab-args! ab-prim!
    }

    def elab-atom-assert! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args-1 >token
        ab-ctx@ >ctx
        True >allow-type-holes
        False >allow-implicit-type-vars
        +TypeElab rdip':elab-stack-type! rdrop
        dip:ab-type@ gamma:unify! drop
    }

    def elab-atom-match! [ +Mirth +AB -- +Mirth +AB ] {
        MetaVar.new! StackType.Meta >cod
        ab-token@ succ lcurly? if(
            ab-token@ succ succ >body
            ab-token@ succ ab-token!,
            ab-token@ rdip:args+ first >body
        )
        elab-match-at!
    }

    ||| Elaborate a match body within AB. Takes the output stack type,
    ||| and the token for the body of the match, from the stack. Takes
    ||| the rest from the AB environment.
    def elab-match-at! [ cod:StackType body:Token +Mirth +AB -- +Mirth +AB ] {
        ab-match!(
            elab-match-cases!
            elab-match-exhaustive!
        )
    }
}

def arity-compatible? [ Int Int -- Bool ] {
    dup -1 == dip(==) ||
}

def ab-build!(f) [ (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow ] {
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx List.L0 >atoms
    Arrow >arrow +AB
    f /+AB arrow>
}

||| Like ab-build! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def ab-build-hom!(f) [
    (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
    *a Ctx ArrowType Token Home +Mirth -- *b Arrow +Mirth
] {
    dip2(/ArrowType dom>)
    ab-build!(cod> f ab-unify-type!)
}

||| Build the arrow for a word. If the word type and context are available, use that.
||| Otherwise, we are in a situation where type and context were not given, so we infer them.
|||
||| To infer ctx-type, we start with an initial guess based on the word head (with lots
||| of metavariables). We temporarily set that as our ctx-type. Then we elaborate the word
||| body. After elaboration, we rigidify the type to obtain a generalized definition, by
||| replacing any free metavariables with universally quantified variables.
def ab-build-word-arrow!(f) [
    (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
    *a Word +Mirth -- *b Arrow +Mirth
] {
    initial-ctx-type-body-home
    dip:ab-build-hom!(f)
    finalize-word-arrow
}

def initial-ctx-type-body-home [ +Mirth Word -- +Mirth Ctx ArrowType Token Home Word ] {
    >word
    @word ~ctx-type try-force!
    match(Some -> unpack2, None -> guess-initial-ctx-type)
    @word body
    @word Home.Word
    word>
}

def finalize-word-arrow [ +Mirth Arrow Word -- +Mirth Arrow ] {
    >word >arrow
    @word inferring-type? then(
        @arrow Arrow.ctx-type rigidify-sig!
        dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
        False @word ~inferring-type? !
        /ArrowType
        cod> @arrow:cod!
        dom> @arrow:dom!
        @arrow:ctx!
    )
    arrow> word> drop
}

def guess-initial-ctx-type [ +Mirth word:Word -- +Mirth Ctx ArrowType word:Word ] {
    Ctx.L0 >ctx
    MetaVar.new! StackType.Meta >dom
    MetaVar.new! StackType.Meta >cod
    @word namespace-hard match(
        Tycon ->
            full-type-fresh
            @word name can-be-relative? if(
                @dom(swap T*+),
                @cod(swap T*+)
            ),
        Module ->
            drop
            @word name >Str "main" == then(
                T0 Resource.World T+ !dom
                T0 Resource.World T+ !cod
            ),
        _ ->
            drop
    )
    @word arity repeat(
        @dom(
            MetaVar.new! StackType.Meta
            MetaVar.new! StackType.Meta T-> >Type T*
        )
    )
    ctx> dom> cod> T->
    dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
    True @word ~inferring-type? !
}

def ab-build-word!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Word +Mirth -- *b Word +Mirth ] {
    sip(ab-build-word-arrow!(dip(f))) sip(PropLabel.WordArrow prop)
    tuck ~arrow !
}

||| Add an atom to a list of atoms .. smartly.
def ab-optimized-snoc! [ List(Atom) Atom -- List(Atom) ] {
    while(over atoms-has-last-block? and(atom-accepts-args?),
        swap atoms-turn-last-block-to-arg swap)
    List.Snoc
}

def atom-accepts-args? [ Atom -- Atom Bool ] {
    dup op match(
        Word -> dip(dup args len) arity <,
        Prim ->
            match(
                Dip -> dup args len 1u <,
                RDip -> dup args len 1u <,
                If -> dup args len 2u <,
                While -> dup args len 2u <,
                _ -> drop False
            ),
        _ -> drop False
    )
}

def atoms-has-last-block? [ List(Atom) -- Bool ] {
    last match(
        None -> False,
        Some ->
            op match(
                BlockPush -> drop True,
                _ -> drop False
            )
    )
}

def atoms-turn-last-block-to-arg [ Atom List(Atom) -- Atom List(Atom) ] {
   >List+? match(
        None -> List.L0,
        Some ->
            unsnoc dup op match(
                BlockPush ->
                    { Atom List(Atom) Atom Block }
                    dip(dom rotl dom!)
                    { List(Atom) Atom Block }
                    Arg.Block swap args:cons
                    swap,
                _ -> drop List.Snoc
            )
    )
}

data OpSig {
    Id
    Push  [ Type ]
    Apply [ ArrowType ]
}

def elab-op-fresh-sig! [ +Mirth Op -- +Mirth Subst OpSig ] {
    Subst.nil swap match (
        Int -> Value.Int Type.Value OpSig.Push,
        F64 -> Value.F64 Type.Value OpSig.Push,
        Str -> Value.Str Type.Value OpSig.Push,
        Buffer -> drop Type.Ptr OpSig.Push,
        Variable -> type Type.Mut OpSig.Push,
        Tag -> type freshen-sig OpSig.Apply,
        Word -> dup inferring-type? if(type, type freshen-sig) OpSig.Apply,
        Prim -> type freshen-sig OpSig.Apply,
        External -> type freshen-sig OpSig.Apply,
        Field -> type freshen-sig OpSig.Apply,
        BlockPush -> elab-block-sig!,
        BlockRun -> type semifreshen-sig OpSig.Apply,
        Var -> elab-var-sig!,
        Match -> elab-match-sig!,
        Lambda -> elab-lambda-sig!,
        LabelPush -> elab-label-push-sig!,
        LabelPop -> elab-label-pop-sig!,
        LabelPushR -> elab-label-push-r-sig!,
        LabelPopR -> elab-label-pop-r-sig!,
        DataGetEnumValue -> data-get-enum-value-type freshen-sig OpSig.Apply,
        DataFromEnumValue -> data-from-enum-value-type freshen-sig OpSig.Apply,
        DataGetLabel -> data-get-label-type freshen-sig OpSig.Apply,
        DataSetLabel -> data-set-label-type freshen-sig OpSig.Apply,
        TableToIndex -> table-to-index-type freshen-sig OpSig.Apply,
        TableFromIndex -> table-from-index-type freshen-sig OpSig.Apply,
    )
}

def data-get-enum-value-type [ +Mirth Data -- +Mirth ArrowType ] {
    full-type match {
        { Left  -> T1 Type.Int T1 T-> }
        { Right -> # not currently exposed for resources, but this is what it would be.
            T0 over T+ Type.Int T1 rotl T+ T-> }
    }
}
def data-from-enum-value-type [ +Mirth Data -- +Mirth ArrowType ] {
    Type.Int T1 T0 rotl full-type T*+ T->
}

def table-to-index-type [ +Mirth Table -- +Mirth ArrowType ] {
    Type.Table T1 Type.Int T1 T->
}
def table-from-index-type [ +Mirth Table -- +Mirth ArrowType ] {
    Type.Table T1 Type.Int T1 swap T->
}

def elab-block-sig! [ Block -- OpSig ] {
    Value.Block Type.Value OpSig.Push
}

def elab-match-sig! [ Match -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-lambda-sig! [ Lambda -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-var-sig! [ Var -- OpSig ] {
    dup auto-run? if?(
        nip semifreshen-sig OpSig.Apply,
        type OpSig.Push
    )
}

def elab-label-push-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta dup2)
    StackType.ConsLabel dip(StackType.Cons) T-> OpSig.Apply
}

def elab-label-pop-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta dup2)
    StackType.ConsLabel dip(StackType.Cons) swap T-> OpSig.Apply
}

def elab-label-push-r-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta Resource dup2)
    StackType.WithLabel dip(StackType.With) T-> OpSig.Apply
}

def elab-label-pop-r-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta Resource dup2)
    StackType.WithLabel dip(StackType.With) swap T-> OpSig.Apply
}

def elab-arrow! [ +Mirth Ctx ArrowType Token Home -- +Mirth Arrow ] {
    dip2(/ArrowType dom> cod>) elab-arrow-hom!
}

def elab-arrow-hom! [ +Mirth Ctx StackType StackType Token Home -- +Mirth Arrow ] {
    rotl dip(
        elab-arrow-fwd!
        dup token-end >token +Gamma
        dup cod
    )
    unify! rdrop drop
}

def elab-arrow-fwd! [ +Mirth Ctx StackType Token Home -- +Mirth Arrow ] {
    ab-build!(elab-atoms!)
}

||| Elaborate match cases.
def elab-match-cases! [ +Mirth +Match -- +Mirth +Match ] {
    body lcurly? if(
        elab-match-cases-curly!,
        elab-match-cases-args!
    )
}

def elab-match-cases-curly! [ +Mirth +Match -- +Mirth +Match ] {
    body run-tokens for(
        dup lcurly?
        else("Expected a pattern match case of the form { ... -> ... }" rdip:emit-fatal-error!)
        rdip:args-1 elab-match-case!
        drop
    )
}

def elab-match-cases-args! [ +Mirth +Match -- +Mirth +Match ] {
    body while(dup args-end? not, elab-match-case!) drop
}

||| Elaborate match case based on starting token.
def elab-match-case! [ Token +Mirth +Match -- Token +Mirth +Match ] {
    dup run-arrow? unwrap("Expected pattern match case ... -> ..." rdip:emit-fatal-error!)
    dup2 == then("expected pattern" rdip:emit-fatal-error!)
    dup2 prev == else("multi-part pattern not supported" rdip:emit-fatal-error!)
    dip:pat-tokens sip:prev succ +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup comma? then(succ)
    )
}

def elab-pattern! [ List(Token) +Mirth +Pattern -- +Mirth +Pattern ] {
    reverse-for(elab-pattern-atom!)
}

def elab-pattern-atom! [ Token +Mirth +Pattern -- +Mirth +Pattern ] {
    dup pattern:token-start!

    dup pat-underscore? if(
        drop +Pattern.underscore!,

    dup name/dname? if?(
        >name/dname >token
        "constructor" >sort
        pattern mid top-types-are-fine? not >report-ambiguous-as-warning
        False >ignore-last-name
        >+pat resolve-def(
            filter(dup tag? some?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            @+pat:pattern mid top-types-are-fine? then(
                @+pat:pattern mid top-namespaces
                token name? if(
                    filter(dup2 rdip:qname-hard namespace swap member, RejectedDef.WrongConstructor) drop,
                    filter-roots
                )
            )
        ) +pat> bind(tag?) match(
            Some -> +Pattern.tag!,
            None -> StackType.Error pattern:mid!
        ),

        "Expected constructor name." rdip:emit-fatal-error!
    ))
}

def +Match.case!(mkpat,mkbod) [
    (*a +Mirth +Pattern -- *b +Mirth +Pattern,
        *b +Mirth +AB -- *c +Mirth +AB)
    *a Token Token +Mirth +Match -- *c +Mirth +Match,
] {
    dip(
        +Match.home >home dup >token-start >token-end
        +Match.ctx dup >outer-ctx >inner-ctx
        List.L0 >saved +Match.dom dup >mid >cod List.L0 >atoms
        Pattern rdip(thaw mkpat freeze) >pattern
    )
    @pattern inner-ctx
    @pattern Pattern.dom +Match.cod T->
    rotl
    +Match.home
    @pattern:dip:rdip(ab-build-hom!(dip(mkbod)))
    >body Case add-case
}

def elab-expand-tensor! [ +Mirth StackType Token -- +Mirth StackType Type Token ] {
    >tok force-cons?! match(
        Some -> unpack2 tok>,
        None -> StackType.Error Type.Error tok> dup "expected tuple type" emit-error!
    )
}

def elab-lambda-param? [ +Mirth Token -- +Mirth Token Maybe(Var) ] {
    dup pattern-var? if?(
        dip(dup args-0 next)
        dip(MetaVar.new! Type.Meta)
        Var.new! Some,

    dup pattern-auto-run-var? if?(
        dip(dup succ args-0 next)
        dip(MetaVar.new! StackType.Meta MetaVar.new! StackType.Meta T->)
        Var.new-auto-run! Some,

        None
    ))
}

def elab-atom-lambda! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-1
    collect(rdip:elab-lambda-param?)
    dip(rdip:expect-token-arrow succ)
    ab-lambda-at!(elab-atoms!)
}

||| Check that a match is exhaustive.
def elab-match-exhaustive! [ +Mirth +Match -- +Mirth +Match ] {
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw
}

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def elab-module! [ Module +World +Mirth -- Module +World +Mirth ] {
    dup start
    elab-module-header!
    over Namespace.Module Some with-defining-namespace (
        elab-decls!
        dup module-end? else(
            "Unexpected token in module." emit-fatal-error!
        )
    )
    drop
}

def elab-module-qname [ +Mirth Token -- +Mirth QName ] {
    parse-module-package-name! dip(Namespace.Package) 0 QName.Mk
}

struct ModuleHeader {
    package: Package
    name: Name
    head: Token
}

||| Parse the `module` declaration at the top of the module:
|||
|||     module(ModuleName)
|||     module ModuleName
|||
def parse-module-header! [ +Mirth Token -- +Mirth Token ModuleHeader ] {
    dup Some lexical-state:error-token!
    dup module-header? else("Expected module header." emit-fatal-error!)
    dup num-args 0> if (
        sip(next) args-1 >head
        @head parse-module-package-name! >name >package
        @head next dup arg-end? else("Expected end of argument." emit-fatal-error!) drop,

        succ >head
        @head parse-module-package-name! >name >package
        @head next
    )
    ModuleHeader
}

||| Parse a ModuleName.
def parse-module-package-name! [ Token +Mirth -- Package Name +Mirth ] {
    dup name/dname? else("Expected module name." emit-fatal-error!)
    dup dname? unwrap("Invalid module name: Module name must include package, for example \"package.module\"" emit-fatal-error!) over args-0
    dup root? unwrap(drop "Invalid module name: Package name is missing." emit-fatal-error!)
    swap parts single? unwrap(drop "Expected module name. (3)" emit-fatal-error!)
    dip(Package.find-or-new! nip)
}

||| Elaborate the module header and save the name and package.
def elab-module-header! [ +World +Mirth Token -- +World +Mirth Token ] {
    dup .module >module
    parse-module-header! /ModuleHeader
    name> @module ~name !
    package> @module ~package !
    @module qname defined-soft? then(@head "Module name already taken." emit-fatal-error!)
    head> @module ~head !
    @module Def.Module register
    dup module> check-module-path
}

def check-module-path [ Token Module +World +Mirth -- +World +Mirth ] {
    dup path rdip:split-last match(
        None ->
            swap qname to-module-path dup2 == else(
                "Expected module name to match path.\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
            ) drop3,

        Some ->
            split-last-byte(Byte.BDOT ==) "mth" Some ==
            else(over3 "Expected .mth extension for mirth file." emit-warning!)
            over2 name >Str == else(over2 .module .head "Expected module name to match file name." emit-fatal-error!)
            over package path! drop2
    )
}

||| Elaborate a series of declarations. Decl*
def elab-decls! [ +World +Mirth Token -- +World +Mirth Token ] {
    while(dup arg-end? not over module-end? not &&, elab-decl!)
}

||| Elaborate either a single declaration or a block of declarations:
|||
|||     Decl
|||     { Decl* }
def elab-decl-or-decl-block! [ +World +Mirth Token -- +World +Mirth Token ] {
    dup lcurly? if(
        succ elab-decls!
        dup rcurly? else("Expected right curly brace." emit-fatal-error!)
        succ,
        elab-decl!
    )
}

||| Elaborate a declaration. Returns the next token.
def elab-decl! [ Token +World +Mirth -- Token +World +Mirth ] {
    dup Some lexical-state:error-token!
    dup name? unwrap("unknown declaration" emit-fatal-error!)
    defs find-some(macro? bind(action decl?))
    unwrap("unknown declaration" emit-fatal-error!) run
}

def load-module [ Token QName +World +Mirth -- Token Module +World +Mirth ] {
    dup def-soft? match(
        Some -> module? unwrap(drop "module name already taken" emit-fatal-error!) nip,
        None ->
            to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
                #    https://github.com/mirth-lang/mirth/issues/241
    )
}

||| Elaborate import statement. Return token after import.
|||
|||     import(ModuleName)
|||     import ModuleName
def elab-module-import! [ Token +World +Mirth -- Token +World +Mirth ] {
    dup num-args 0> if(
        sip(next) args-1
        dup next dup arg-end? else("expected arg end" emit-fatal-error!) drop,
        succ sip(next)
    )
    dup elab-module-qname load-module
    dip(.module) add-import!
}

||| Parse a data declaration. It looks like one of:
|||
|||     data ( TypeAtom, DataTag* DataDecls )
|||     data TypeAtom { DataTag* DataDecls }
def parse-data [ +Mirth Token -- +Mirth Token SyntaxData ] {
    dup num-args 0> if(
        succ dup lparen? else("expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-data-tags >tags
        parse-data-decls! >decls
        dup rparen? else("expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-data-tags >tags
        parse-data-decls! >decls
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

def parse-data-header [ +Mirth Token -- +Mirth Token SyntaxDataHeader ] {
    dup >head next
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    SyntaxDataHeader
}

def parse-data-tags [ +Mirth Token -- +Mirth Token List(SyntaxDataTag) ] {
    collect-while(dup data-tags-end? not, parse-data-tag)
}

def data-tags-end? [ Token -- Bool ] {
    dup args-end? or(dup sig-dashes?) nip
}

||| Parse a data tag. It looks like one of these:
|||
|||     Tag
|||     Tag -> Type* &ArgEnd
|||     Tag [ Type* ]
|||
def parse-data-tag [ +Mirth Token -- +Mirth Token SyntaxDataTag ] {
    dup >head
    dup int? dup >value? then(succ)
    dup name? filter(could-be-constructor)
    unwrap("Expected constructor name." emit-fatal-error!) >name
    succ dup arrow? if(
        succ dup Some >sig? sig-next-stack-end
        dup arg-end? else("Expected comma." emit-fatal-error!),
        dup lsquare? if(
            succ dup Some >sig? sig-next-stack-end
            dup rsquare? else("Expected right square bracket ']'" emit-fatal-error!)
            succ,

            None >sig?
        )
    )
    dup comma? then(succ)
    SyntaxDataTag
}

||| Parse a struct declaration. This looks like this:
|||
|||     struct(TypeAtom, Type* DataDecls)
|||     struct TypeAtom { Type* DataDecls }
|||
def parse-struct [ +Mirth Token -- +Mirth Token SyntaxData ] {
    dup num-args 0> if(
        succ dup lparen? then("Expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-struct-tag List.L1 >tags
        parse-data-decls! >decls
        dup rparen? then("Expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-struct-tag List.L1 >tags
        parse-data-decls! >decls
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

||| Data declarations. These start with sig-dashes.
||| This is either empty, or it is dashes followed by decls within an expression.
def parse-data-decls! [ +Mirth Token -- +Mirth Token Maybe(Token) ] {
    dup sig-dashes? if(
        succ dup while(dup arg-end? not, next) swap Some,
        None
    )
}

def parse-struct-tag
    [  +Mirth Token header:SyntaxDataHeader
    -- +Mirth Token header:SyntaxDataHeader SyntaxDataTag ]
{
    @header head >head
    @head last-name? filter(could-be-constructor)
    unwrap(@header head "Expected constructor name." emit-fatal-error!) >name
    None >value?
    dup Some >sig?
    sig-next-stack-end
    SyntaxDataTag
}

struct SyntaxData {
    header: SyntaxDataHeader
    tags: List(SyntaxDataTag)
    decls: Maybe(Token)
}

struct SyntaxDataHeader {
    head: Token
}

struct SyntaxDataTag {
    head: Token
    value?: Maybe(Int)
    name: Name
    sig?: Maybe(Token)
}

def elab-data!   { parse-data   elab-data-aux! }
def elab-struct! { parse-struct elab-data-aux! }

def elab-data-aux! [ +World +Mirth SyntaxData -- +World +Mirth ] {
    /SyntaxData
    Data.alloc! List.Nil over ~tags !
    header> elab-data-header!
    tags> for(elab-data-tag!)
    decls> for(elab-data-decls!)
    elab-data-done!
}

||| Get the header, name, arity for a data type.
def elab-data-header! [ Data SyntaxDataHeader +Mirth -- Data +Mirth ] {
    /SyntaxDataHeader >data
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    elab-def-head
    @head Some @data ~head? !
    arity> >Int @data ~arity !
    name> @data ~name !
    @data PropLabel.DataQName >label Prop @data ~qname !
    @head args @data PropLabel.DataParams prop(elab-data-params!) @data ~params !
    @data Def.Data register
    head> drop
    data>
}

# TODO check header args are well-formed / elaborate them properly
#  as part of: https://github.com/mirth-lang/mirth/issues/246
def elab-data-params! [ List(Token) +Mirth -- List(Var) +Mirth ] {
    Ctx.L0 swap for(
        dup name? unwrap("Expected a parameter name." emit-fatal-error!)
        over2 Ctx.lookup then("Duplicate parameter name." emit-fatal-error!)

        None
        or?(dup sig-type-var? map(Type.Type swap Var.new!))
        or?(dup sig-resource-var? map(Type.ResourceType swap Var.new!))
        or?(dup sig-stack-var? map(Type.StackType swap Var.new!))
        unwrap("Invalid parameter name." emit-fatal-error!)
        nip Ctx.new
    ) >List
}

||| Get a tag associated with a data type.
def elab-data-tag! [ Data SyntaxDataTag +Mirth -- Data +Mirth ] {
    >syn >dat
    Tag.alloc! >tag

    @dat @syn name 0 data-qname @tag ~qname !
    @syn sig? @tag ~sig? !
    @syn value? for(@tag ~value !)
    @dat @tag ~data !
    @tag @dat add-tag!
    @tag Def.Tag register

    @syn head @tag @tag PropLabel.TagType prop2(
        >tag >token
        @tag .data params >Ctx >ctx
        True >allow-implicit-type-vars
        False >allow-type-holes
        +TypeElab
        T0 @tag .data rdip:full-type T*+
        tag> sig? match(
            None -> T0,
            Some -> token! T0 elab-stack-type-parts!
        )
        swap T-> dip:ctx pack2 rdrop
    ) @tag ~ctx-type !
    @tag num-type-inputs-from-sig @tag ~num-type-inputs !
    @tag num-resource-inputs-from-sig @tag ~num-resource-inputs !
    @tag label-inputs-from-sig @tag ~label-inputs !

    @tag outputs-resource? not then(
        @tag sig? for(
            run-tokens find(
                or(sig-resource-con? >Bool, sig-resource-var? >Bool)
            ) for ("Value type cannot contain resource." emit-error!)
        )
    )

    tag> syn> drop2
    dat>
}

def elab-data-decls! [ +World +Mirth Data Token -- +World +Mirth Data ] {
    dup Some >error-token
    over Tycon.Data Namespace.Tycon Some >defining-namespace
    LexicalState with-lexical-state (
        while(dup arg-end? not, elab-decl!)
        drop
    )
}

def data-word-new! [ +Mirth Data Str Nat -- +Mirth Word ] {
    dup >arity
    over >Name >name
    dip2(dup head? unwrap("Missing data token information." fatal-error!) dup >body >head)
    data-word-qname >qname
    None >sig?
    Word.new!

    qname> over PropLabel.WordQName prop over ~qname !
}

def elab-data-done! [ +Mirth Data -- +Mirth ] {
    >dat
    @dat is-value-type? then (
        @dat "enum-value" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-get-enum-value-type
        @word PropLabel.WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat Op.DataGetEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat is-enum? then (
        @dat "from-enum-value-unsafe" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-from-enum-value-type
        @word PropLabel.WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat Op.DataFromEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat tags single? for(
        >tag
        @dat "/" @tag name >Str cat 0u data-word-new! >untag
        @untag Some @tag ~untag !
        @tag @untag PropLabel.WordType prop(ctx-type invert pack2) @untag ~ctx-type !
        @tag @untag @untag PropLabel.WordArrow prop2(
            >untag >tag
            untag> ab-build-word-arrow!(
                @tag rdip:type dom >cod
                @tag .data head? unwrap("Missing data token info" rdip:fatal-error!) dup >body
                ab-match!(
                    dup case!(@tag +Pattern.tag!, id)
                )
            )
            tag> drop
        ) @untag ~arrow !
        @untag make-inline!
        @tag create-projectors!
        tag> untag> drop2
    )

    @dat @dat PropLabel.DataCType prop(
        >dat
        @dat is-unit? if(
            CType.Phantom Some,
        @dat is-enum? if(
            "int" CType.IntLike Some,
        @dat semi-transparent? if?(
            input match(
                Cons -> ctype?,
                ConsLabel -> drop ctype?,
                With -> ctype?,
                WithLabel -> drop ctype?,
            ),
            None
        )))
        dat> drop
    ) @dat ~ctype? !
    dat> drop
}

||| Return the tag's output type or resource in context.
field(Tag.~output-type, Tag, Type/Resource)
def Tag.output-type [ +Mirth Tag -- +Mirth Type/Resource ] {
    >tag
    @tag ~output-type memoize(
        @tag type cod expand match {
            { Cons -> nip Left }
            { With -> nip Right }
            { _ ->
                drop
                "Unexpected output type for constructor "
                @tag qname >Str cat
                @tag .data head? if?(swap emit-error!, error!)
                Type.Error @tag .data is-resource? if(
                    Resource Right,
                    Left
                )
            }
        }
    )
    tag> drop
}

||| Return the tag's output type or resource in context, except for a missing field.
def Tag.output-type-except-field [ +Mirth Label Tag -- +Mirth Type/Resource ] {
    dup output-type map(except-field, except-field)
}

||| Return the input type for a tag along a given label.
def Tag.project-input-label [ +Mirth Label Tag -- +Mirth Maybe(Type/Resource) ] {
    type dom label-top?
}

def Tag.project-tag-field [ +Mirth Label Tag -- +Mirth Maybe(TagField) ] {
    dup2 project-input-label if? (
        >type/resource >tag >label TagField Some,
        drop2 None
    )
}

def data-get-label-type [ +Mirth TagField -- +Mirth ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T0 @tag output-type T*+ swap T1
            @tag .data is-resource? then(@tag output-type T*+)
            T-> }
        { Right ->
            T0 @tag output-type T*+
            T0 rotl T+ @label @tag output-type-except-field T*+
            T-> }
    }
    label> tag> drop2
}

def data-set-label-type [ +Mirth TagField -- +Mirth ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T1 @tag output-type T*+
            T0 @tag output-type T*+
            T-> }
        { Right ->
            T0 swap T+ @label @tag output-type-except-field T*+
            T0 @tag output-type T*+
            T-> }
    }
    label> tag> drop2
}

def create-projectors! [ +Mirth Tag -- +Mirth ] {
    >tag
    @tag .data >dat
    @tag label-inputs reverse-for(
        >lbl
        @dat @lbl name 0 data-qname undefined-soft? then(
            @dat @lbl >Str 0u data-word-new! >lbl_get
            @dat @lbl >Str "!" cat 0u data-word-new! >lbl_set
            @dat @lbl >Str 1u data-word-new! >lbl_lens

            @lbl_get make-inline!
            @tag @lbl @lbl_get PropLabel.WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-get-label-type
                pack2
            ) @lbl_get ~ctx-type !
            @tag @lbl @lbl_get dup PropLabel.WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    Op.DataGetLabel ab-op!
                )
            )) @lbl_get ~arrow !

            @lbl_set make-inline!
            @tag @lbl @lbl_set PropLabel.WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-set-label-type
                pack2
            ) @lbl_set ~ctx-type !
            @tag @lbl @lbl_set dup PropLabel.WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    Op.DataSetLabel ab-op!
                )
            )) @lbl_set ~arrow !

            @lbl_lens make-inline!
            @tag @lbl @lbl_lens PropLabel.WordType prop2(
                >lbl >tag
                lbl> @tag project-input-label unwrap("logic error: expeted field in tag." fatal-error!) >lblty
                @tag output-type >datty

                @tag ctx
                "*x" StackType.NewInCtx >sx
                "*y" StackType.NewInCtx >sy
                @sx @datty T*+
                    @sx @lblty T*+
                    @sy @lblty T*+ T-> >Type T*
                @sy  @datty T*+
                T-> pack2

                sx> sy> drop2
                lblty> datty> drop2
                tag> drop
            ) @lbl_lens ~ctx-type !
            @lbl_lens dup PropLabel.WordParams prop(
                type dom top-type? unwrap("logic error: expected parameter" fatal-error!)
                morphism? unwrap("logic error: expected morphism" fatal-error!)
                "f" >Name Var.new-auto-run! >var None >default Param List.L1
            ) @lbl_lens ~params !

            @dat @lbl_get @lbl_set @lbl_lens dup PropLabel.WordArrow prop4(
                >lbl_lens >lbl_set >lbl_get >dat
                @lbl_lens ab-build-word-arrow!(
                    lbl_lens> rdip:params map(.var) dup ab-lambda!(
                        single? unwrap("Expected one parameter." rdip:fatal-error!) >f
                        dat> is-resource? if(
                            lbl_get> ab-word!
                            ab-rdip!(f> ab-var!)
                            lbl_set> ab-word!,

                            Prim.Dup ab-prim!
                            ab-dip!(
                                lbl_get> ab-word!
                                f> ab-var!
                            )
                            lbl_set> ab-word!
                        )
                    )
                )
            ) @lbl_lens ~arrow !
            lbl_get> lbl_set> lbl_lens> drop3
        )
        lbl> drop
    )
    dat> tag> drop2
}

def expect-token-arrow [ +Mirth Token -- +Mirth Token ] {
    dup arrow? else("Expected arrow." emit-fatal-error!)
}

||| Parse an alias declaration.
||| Either `alias(head, target)` or `alias head target`.
||| Both `head` and `target` are names (or dnames), with `head` taking
||| an optional argument list (for the arity), and `target` taking no arguments.
def parse-alias [ +Mirth Token -- +Mirth Token head:Token target:Token name/dname:Name/DName ] {
    dup succ lparen? >Bool >has-paren
    @has-paren if(
        sip(next) args-2 >target >head,
        next dup >head next dup >target next
    )
    @head name/dname? else(@head "expected alias name" emit-fatal-error!)
    @target name/dname? unwrap(@target "expected alias target, which must be a name" emit-fatal-error!) >name/dname
    @target args-0
    @has-paren then(
        @head next arg-end? else(@head "expected comma after alias name" emit-fatal-error!)
        @target succ arg-end? else(@head "expected end of arguments after alias target" emit-fatal-error!)
    )
    has-paren> drop
}

||| Elaborate an alias declaration.
def elab-alias! [ +Mirth Token -- +Mirth Token ] {
    parse-alias elab-def-head @arity:>Int Alias.new!
    dup PropLabel.AliasQName >label Prop over ~qname !

    name/dname> target> over2 dup PropLabel.AliasTarget prop3(
        >alias >target >name/dname
        @target >token
        "target" >sort
        False >report-ambiguous-as-warning
        False >ignore-last-name
        resolve-def(
            expunge(alias? if?(@alias ==, False))
            alias> arity filter(
                dup2 rdip:arity arity-compatible?,
                RejectedDef.WrongArity
            ) drop
            filter-qualifiers
            List.L0 filter-roots
        )
        unwrap( panic-diagnostics! )
        match(
            Alias ->
                ~target force-or!(
                    @target
                    "Alias points to itself, circular aliases are not allowed."
                    emit-fatal-error!
                ),
            _ -> id
        )
        target> drop
    ) swap ~target !
}

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def elab-def-missing! [ +Mirth Token -- +Mirth Token ] {
    dup args len 3u < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined-hard? if(next, elab-def!)
}

def +Mirth.with-inline(f) [ (*a +Mirth -- *b +Mirth) *a Bool +Mirth -- *b +Mirth ] {
    prefer-inline-defs:swap
    dip(f) prefer-inline-defs!
}

||| Mark the following definition(s) as inline.
|||
|||     inline Decl
|||     inline ( Decl* )
|||     inline { Decl* }
def elab-inline! [ Token +World +Mirth -- Token +World +Mirth ] {
    True with-inline(
        dup num-args 0> if(
            sip:next args-1 elab-decls! drop,
            succ elab-decl-or-decl-block!
        )
    )
}

struct SyntaxDef {
    head: Token
    sig?: Maybe(Token)
    body: Token
}

||| Parse a word definition. It looks like one of these:
|||
|||     def(word, sig, body...)
|||     def word [ sig ] { body... }
|||     def word { body... }
|||
||| Returns the next token after the definition.
def parse-def [ +Mirth Token -- +Mirth Token SyntaxDef ]
{
    dup Some lexical-state:error-token!
    dup args empty? if(
        next
        dup >head next
        dup lsquare? if(dup args-1 Some >sig? next, None >sig?)
        dup lcurly? else("expected { ... }" emit-fatal-error!)
        dup args+ >body
        next,

        sip(next)
        dup args dup len 3u <
            then(drop
                 "def(...) expects at least three arguments"
                 emit-fatal-error!)
            nip
        >List+? unwrap(impossible!) uncons dip(>head)
        >List+? unwrap(impossible!) uncons dip(Some >sig?)
        >List+? unwrap(impossible!) >body

        @head next arg-end? else(
            @head next "expected comma after word name" emit-fatal-error!
        )
    )
    body> uncons empty? or(dup run-arrow? >Bool)
        else("expected match case" emit-fatal-error!) >body
    SyntaxDef
}

||| Elaborate a word definition.
def elab-def! [ +Mirth Token -- +Mirth Token ] {
    parse-def /SyntaxDef
    elab-def-head Word.new! >word
    @word PropLabel.WordQName >label Prop @word ~qname !

    prefer-inline-defs @word ~prefer-inline? !

    @word @word PropLabel.WordType prop(
        dup sig? match(
            Some ->
                nip
                +TypeElab.Start!
                elab-type-sig!
                dip:ctx pack2
                rdrop,
            None ->
                arrow ctx-type pack2
        )
    ) @word ~ctx-type !
    @word @word PropLabel.WordParams prop(elab-def-params!) @word ~params !
    @word @word PropLabel.WordArrow prop(
        dup dup ab-build-word-arrow!(
            swap rdip:params dup empty? if(
                drop elab-def-body!,
                map(.var) ab-lambda!(elab-def-body!)
            )
        ) tuck check-inline-recursion-arrow!
    ) @word ~arrow !
    word> drop
}

def check-inline-recursion-arrow! [ +Mirth Word Arrow -- +Mirth ] {
    atoms for(dip:dup check-inline-recursion-atom!) drop
}
def check-inline-recursion-atom! [ +Mirth Word Atom -- +Mirth ] {
    over prefer-inline? if(
        dup2 op check-inline-recursion-op!
        args for(dip:dup check-inline-recursion-arg!) drop,
        drop2
    )
}
def check-inline-recursion-arg! [ +Mirth Word Arg -- +Mirth ] {
    Block -> arrow check-inline-recursion-arrow!
}
def check-inline-recursion-op! [ +Mirth Word Op -- +Mirth ] {
    BlockRun -> arrow check-inline-recursion-arrow!,
    Word ->
        dup2 == if(
            drop check-inline-recursion-failed!,
            dup prefer-inline? if(
                ~arrow try-force! if?(
                    check-inline-recursion-arrow!,
                    check-inline-recursion-failed!
                ),
                drop2
            )
        ),
    Match -> cases for(dip:dup body check-inline-recursion-arrow!) drop,
    Lambda -> body check-inline-recursion-arrow!,
    _ -> drop2
}
def check-inline-recursion-failed! [ +Mirth Word -- +Mirth ] {
    dup prefer-inline? if(
        False over ~prefer-inline? !
        head "recursive word cannot be inlined" emit-warning!,
        drop
    )
}

||| Elaborate a word's parameters from its type and declaration.
def elab-def-params! [ +Mirth Word -- +Mirth List(Param) ] {
    List.L0 over type
    rotl head dip(/ArrowType dom> cod>) nip
    args reverse-for(
        dup sig-param-name? unwrap("expected parameter name" emit-fatal-error!) >name
        dup succ dup run-end? if(
            drop None >default,
            dup lcurly? if(
                dup succ Some >default
                next dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!),

                "expected right paren, left curly, or comma" emit-fatal-error!
            )
        )
        elab-expand-tensor!
        swap morphism? unwrap("need function type for param" emit-fatal-error!)
        nip name> Var.new-auto-run! >var Param
        rotr dip:cons
    ) drop
}

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def elab-def-body! [ StackType +Mirth +AB -- StackType +Mirth +AB ] {
    ab-token@ run-arrow? or(ab-token@ lcurly? some?) if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    )
}

data ExternalDeclPart {
    EDPCode [ token:Token code:Str ]
    EDPDef  [ head:Token symbol:Maybe(Token) sig:Token ]
}

def parse-external-decl [ +Mirth Token -- +Mirth Token List(ExternalDeclPart) ] {
    sip(next)
    succ dup lparen-or-lcolon? else(
        pred Str(
            Sgr.FGCyan emit; "external"; Sgr.Reset emit;
            " requires arguments";
        )
        emit-fatal-error!
    )
    LIST(
        succ
        while(dup args-end? not,
            rdip(parse-external-decl-part) ;)
        drop
    )
}

def parse-external-decl-part [ +Mirth Token -- +Mirth Token ExternalDeclPart ] {
    dup str? if?(
        >code dup >token
        succ
        ExternalDeclPart.EDPCode,

        dup >head
        dup name/dname? else("expected external word name" emit-fatal-error!)
        succ
        dup arrow? if(
            succ dup name? else("expected external symbol name" emit-fatal-error!)
            dup Some >symbol
            succ,

            None >symbol
        )
        dup lsquare? if(
            dup args-1 >sig
            next,

            dup comma? else("expected type signature" emit-fatal-error!)
            succ
            dup arg-end? then("expected type signature" emit-fatal-error!)
            dup >sig
            next-arg-end
        )
        ExternalDeclPart.EDPDef
    )
    dip(dup comma? then(succ))
}

def elab-def-external! [ +Mirth Token -- +Mirth Token ] {
    dup "def-external" >old "external" >new emit-deprecated!
    elab-external!
}

||| Elaborate an external declaration.
def elab-external! [ +Mirth Token -- +Mirth Token ] {
    dup >token
    parse-external-decl
    map(elab-external-block-part!) >parts
    ExternalBlock.alloc! >extblock
    token> @extblock ~token !
    parts> @extblock ~parts !
    extblock> drop
}

def elab-external-block-part! [ +Mirth ExternalDeclPart -- +Mirth ExternalBlockPart ] {
    { EDPCode -> token> drop code> ExternalBlockPart.EBPCode }
    { EDPDef -> elab-external-def! ExternalBlockPart.EBPDef }
}

def elab-external-def! [ +Mirth head:Token symbol:Maybe(Token) sig:Token -- +Mirth External ] {
    elab-def-head

    symbol> bind(name?) unwrap(@name) >Str >symbol

    External.alloc! >external
    name> @external ~name !
    arity> >Int @external ~arity !
    @external PropLabel.ExternalQName >label Prop @external ~qname !
    symbol> @external ~symbol !
    sig> @external ~sig !
    head> @external ~head !
    @external dup PropLabel.ExternalType prop(
        sig +TypeElab.Start!
        elab-type-sig! dip:ctx pack2 rdrop
    ) @external ~ctx-type !
    @external dup PropLabel.ExternalCType prop(
        elab-def-external-ctype
    ) @external ~ctype !
    @external Def.External register
    external>
}

def elab-def-external-ctype [ +Mirth External -- +Mirth CTypeArrow ] {
    dup head with-error-token(
        type ctype
        dup cod parts
        filter(sip(label? none?) ctype phantom? not &&)
        len 1u > then(
            "External has too many outputs." error!
        )

        dup dom parts filter-some(label?)
        over cod parts filter-some(label?)
        swap difference for(
            Str("Output label "; name >Str ; " not present in input";) error!
        )
    )
}

||| Elaborate a type definition `def-type(t1, t2)`.
def elab-def-type! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-2 >target >head
    @head args-0
    @head sig-type-con? else("expected type constructor" emit-fatal-error!)
    elab-def-head @head:Some
    arity> drop
    TypeDef.new!
    target> over PropLabel.TypeDefTarget prop(elab-simple-type-arg!) swap ~target !
}

||| Elaborate a buffer definition `buffer(B, size)`.
def elab-buffer! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-2
    swap dup elab-def-qname-undefined
    rotl dup int? unwrap("expected buffer size" emit-fatal-error!)
    >USize-if(nip, drop "buffer size must not be negative" emit-error! 0u >USize) Buffer.new! drop
}

||| Elaborate a var declaration `var(v, type)`.
def elab-variable! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-2
    swap dup elab-def-qname-undefined Variable.new!
    tuck PropLabel.VariableType prop(elab-simple-type-arg!)
    over ~type ! drop
}

||| Elaborate a table definition `table(True)`.
def elab-table! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-1 >head
    @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
    @head args-0
    @head succ arg-end? else(@head succ "expected end of argument after table name" emit-fatal-error!)
    elab-def-head
    arity> drop
    table-new! drop
}

||| Create entry point based on word name.
def elab-entry-point [ QName +Mirth -- Arrow +Mirth ] {
    dup def-hard? bind(word?) unwrap(
        dup dip(
            namespace module? for(start Some lexical-state:error-token!)
            "can't find entry point "
        ) >Str cat
        fatal-error!
    ) nip { Word +Mirth }
    dup dip(Ctx.L0 T0 Resource.World T+ T0 Resource.World T+ T->)
    head dup Home.Main ab-build-hom!(
        dip(ab-word!)
    )
}

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def elab-embed-str! [ Token +World +Mirth -- Token +World +Mirth ] {
    sip:next args-2 swap
    >head elab-def-head
    @arity 0= else(@head "expected no arguments" emit-fatal-error!)
    dup >body None >sig?
    dup str? unwrap("expected source path" emit-fatal-error!)
    >Path >+mirth open-file! +else(+mirth> fatal-error!) read-file! close-file! nip >contents +mirth>
    Word.new!
    dup PropLabel.WordQName >label Prop over ~qname !

    Ctx.L0 T0 Type.Str T1 T-> over2 PropLabel.WordType prop2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop
}

||| Ensure that everything so far has been typechecked.
def typecheck-everything! [ +Mirth -- +Mirth ] {
    Name.for(defs for(dup qname-hard drop typecheck!))
    Block.for(typecheck!)
    External.for(ctype drop)
}

#########
# TABLE #
#########

def table-qname [ Table Str Int -- QName ] {
    >arity >Name >name Tycon.Table Namespace.Tycon >namespace QName
}

def table-word-new! [ +Mirth Table Str Nat -- +Mirth Word ] {
    over2 head dup >head >body None >sig?
    dup >arity over >Name >name >Int table-qname >qname Word.new!
    qname> over PropLabel.WordQName prop over ~qname !
}

def table-new! [ +Mirth head:Token name:Name state:PropState(QName) -- +Mirth Table ] {
    Table.alloc! >tbl
    @tbl PropLabel.TableQName >label Prop @tbl ~qname !
    head> @tbl ~head !
    name> @tbl ~name !
    @tbl Def.Table register

    # Table.nil
    @tbl "nil" 0u table-word-new! >word

    Ctx.L0
    T0 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @tbl head ab-token!
        0 ab-int!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.NUM
    @tbl head
    @tbl "NUM" 0 table-qname
    8u >USize Buffer.new!
    @tbl ~num-buffer !

    # Table.index
    @tbl "index" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 Type.Int T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl Op.TableToIndex ab-op!
    ) drop

    # Table.from-index
    @tbl "from-index" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 Type.Int T1 swap T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.succ
    @tbl "succ" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl Op.TableToIndex ab-op!
        1 ab-int!
        Prim.IntAdd ab-prim!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.pred
    @tbl "pred" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl Op.TableToIndex ab-op!
        Prim.Dup ab-prim!
        0 ab-int!
        Prim.IntEq ab-prim!
        ab-if!(
            ,
            1 ab-int!
            Prim.IntSub ab-prim!
        )
        @tbl Op.TableFromIndex ab-op!
    ) drop

    { +Mirth tbl:Table }

    # Table.for
    @tbl "for" 1u table-word-new! >word
    Type.StackType "*a" >Name Var.new! >va
    @va StackType.Var @tbl Type.Table T* @va StackType.Var T-> "f" >Name Var.new-auto-run! >vx

    @va Ctx.L1
    @va StackType.Var @vx type T* @va StackType.Var T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    @vx >var None >default Param List.L1
    @word PropLabel.WordParams prop
    @word ~params !
    @word make-inline!

    word> ab-build-word! (
        @tbl head ab-token!
        @vx List.L1 ab-lambda!(
            1 ab-int!
            ab-while!(
                Prim.Dup ab-prim!
                @tbl num-buffer ab-buffer!
                Prim.I64Get ab-prim!
                Prim.I64ToInt ab-prim!
                Prim.IntLe ab-prim!,

                Prim.Dup ab-prim!
                ab-dip! (
                    @tbl Op.TableFromIndex ab-op!
                    @vx ab-var!
                )
                1 ab-int!
                Prim.IntAdd ab-prim!
            )
            Prim.Drop ab-prim!
        )
    ) drop
    va> vx> drop2

    # Table.alloc!
    @tbl "alloc!" 0u table-word-new! >word

    Ctx.L0
    T0 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl num-buffer ab-buffer!
        Prim.I64Get ab-prim!
        Prim.I64ToInt ab-prim!
        1 ab-int!
        Prim.IntAdd ab-prim!
        Prim.Dup ab-prim!
        Prim.IntToI64 ab-prim!
        @tbl num-buffer ab-buffer!
        Prim.I64Set ab-prim!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    tbl>
}

#########
# FIELD #
#########

def resolve-def-namespace [ +Mirth Token name/dname:Name/DName -- +Mirth Maybe(Namespace) ] {
    >token
    "namespace" >sort
    True >ignore-last-name
    False >report-ambiguous-as-warning
    resolve-def(
        filter-sort(dup rdip:exposed-tycon? >Bool)
        filter-qualifiers
        List.L0 filter-roots
    )
    bind(as-namespace?)
}

def elab-qname-from-nonrelative-dname [ +Mirth Token DName arity:Int -- +Mirth QName ] {
    dup Right >name/dname
    dup root? else(drop "relative name not allowed" emit-fatal-error!)
    last-name >name
    dup resolve-def-namespace unwrap(panic-diagnostics!) >namespace
    drop QName
}

def module-visible-from-token? [ Token Module -- Bool ] {
    swap .module visible
}

def def-visible-from-token? [ Token Def -- Bool ] {
    defining-module? match(
        None -> drop True,
        Some -> module-visible-from-token?
    )
}

def Token.is-default-param? [ Token -- Bool ] {
    dup name? and( dup succ lcurly? >Bool ) nip
}

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def elab-def-qname [ +Mirth Token -- +Mirth QName ] {
    dup args dup has(is-default-param?) if(drop -1, len >Int) >arity
    dup name/dname? unwrap("expected name" emit-fatal-error!)
    match(
        Left -> >name defining-namespace-or-error >namespace QName,
        Right -> elab-qname-from-nonrelative-dname
    )
}

||| The namespace for definitions by default.
def defining-namespace-or-error [ +Mirth Token -- +Mirth Namespace ] {
    lexical-state defining-namespace
    unwrap("error: no namespace for definition" emit-fatal-error!)
    nip
}

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def elab-def-qname-undefined [ +Mirth Token -- +Mirth QName ] {
    dup elab-def-qname
    dup defined-soft? then(drop "name already defined" emit-fatal-error!)
    nip
}

||| Elaborate the head, i.e. the name-giving token, of a definition.
||| We defer the full resolution of the qualified name, but otherwise
||| we collect arity and (simple) name data from the head token.
def elab-def-head [
    +Mirth head:Token --
    +Mirth head:Token name:Name arity:Nat state:PropState(QName)
] {
    @head name/dname?
        unwrap(@head "expected name" emit-fatal-error!)
        either(id, parts last) >name
    @head num-args >arity
    lexical-state @head [ elab-def-qname-undefined ] PropState.Delay >state
}

||| Parse a field definition, `field(f, T1, T2)`
def parse-field [
    +Mirth Token -- +Mirth Token
    head:Token index-type:Token value-type:Token
] {
    sip(next) args-3 >value-type >index-type >head
    @head name/dname? else(@head "expected field name" emit-fatal-error!)
    @head args-0
}

||| Elaborate a field definition `field(f, T1, T2)`.
def elab-field! [ +Mirth Token -- +Mirth Token ] {
    parse-field elab-def-head
    Field.alloc! >fld
    name> @fld ~name !
    head> @fld ~head !
    arity> 0= else(@fld head "Field cannot take arguments." emit-error!)
    @fld PropLabel.FieldQName >label Prop @fld ~qname !
    index-type> @fld PropLabel.FieldIndexType prop(elab-simple-type-arg!) @fld ~index-type !
    value-type> @fld PropLabel.FieldValueType prop(elab-simple-type-arg!) @fld ~value-type !
    fld> Def.Field register
}
