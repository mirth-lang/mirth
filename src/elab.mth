module mirth.elab

import std.prelude
import std.str
import std.list
import std.maybe
import std.either
import std.byte
import std.terminal

import mirth.mirth
import mirth.name
import mirth.def
import mirth.token
import mirth.data
import mirth.external
import mirth.word
import mirth.var
import mirth.buffer
import mirth.table
import mirth.tycon
import mirth.type
import mirth.typedef
import mirth.var
import mirth.arrow
import mirth.word
import mirth.prim
import mirth.module
import mirth.package
import mirth.alias
import mirth.match
import mirth.lexer
import mirth.label
import mirth.macro
import mirth.version

####################
# Type Elaboration #
####################

struct +TypeElab {
    ctx:Ctx
    token:Token
    allow-type-holes:Bool
    allow-implicit-type-vars:Bool
    --
    def rdrop [ +TypeElab -- ] {
        /+TypeElab
        ctx> token> drop2
        allow-type-holes> drop
        allow-implicit-type-vars> drop
    }

    def Start! [ Token -- +TypeElab ] {
        >token
        Ctx.L0 >ctx
        False >allow-type-holes
        True >allow-implicit-type-vars
        +TypeElab
    }

    def elab-type-sig! [ +Mirth +TypeElab |- StackType -- ArrowType ] {
        >base

        token rdip:run-end? then(token "expected type signature" rdip:emit-error!)
        @base elab-type-sig-params!
        @base elab-stack-type!
        token rdip:vdash? then(
            !base
            token:succ @base elab-type-sig-params! cat
            @base elab-stack-type!
        )
        token rdip:sig-dashes? if(token:succ @base elab-stack-type!, dip:@base)
        token rdip:run-end? else(token "expected right paren or comma" rdip:emit-error!)
        dip(swap for(T*)) T->

        base> drop
    }

    def elab-type-sig-params! [ +Mirth +TypeElab |- StackType -- List(Type) ] {
        >base

        token rdip:lparen? if(
            token rdip:next
            token rdip:args map(
                token!
                @base elab-type-sig! Type.Arrow
            )
            dip:token!,
            L0
        )

        base> drop
    }

    def elab-stack-type! [ +Mirth +TypeElab |- StackType -- StackType ] {
        elab-stack-type-base!
        elab-stack-type-parts!
    }

    def elab-stack-type-base! [ +Mirth +TypeElab |- StackType -- StackType ] {
        token rdip:sig-stack-var? for(
            elab-stack-type-var!
            swap rdip:split-parts swap rdip:unit? else(
                token "Duplicate stack base, context already provided a stack base." rdip:emit-error!
            ) for(cons)
        )
    }

    def elab-stack-type-parts! [ +Mirth +TypeElab |- StackType -- StackType ] {
        while(token rdip:sig-stack-end? not, elab-stack-type-part! cons)
    }

    def elab-type-atom! [ +Mirth +TypeElab |- Type ] {
        token elab-stack-type-part!
        match(
            Cons -> nip,
            ConsLabel -> drop2 "Expected type, not label." rdip:emit-error! Type.Error,
            With -> drop "Expected type, not resource." rdip:emit-error! Type.Error,
            WithLabel -> drop2 "Expected type, not labelled resource." rdip:emit-error! Type.Error,
        )
    }

    def elab-type-arg! [ +Mirth +TypeElab |- Type ] {
        elab-type-atom!
        token rdip:arg-end? else(
            token "Unexpected token after type." rdip:emit-error!
        )
    }

    def elab-resource-arg! [ +Mirth +TypeElab |- Resource ] {
        token elab-stack-type-part!
        match(
            Cons -> drop "Expected resource, not type." rdip:emit-error! Type.Error Resource,
            ConsLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
            With -> nip,
            WithLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
        )
        token rdip:arg-end? else(
            token "Unexpected token after resource." rdip:emit-error!
        )
    }

    def elab-stack-type-part! [ +Mirth +TypeElab |- StackTypePart ] {
        token rdip:sig-label? if?(
            elab-stack-label!,

        token rdip:sig-type-var? if?(
            elab-type-var! StackTypePart.Cons,

        token rdip:sig-type-con? if?(
            elab-type-con! StackTypePart.Cons,

        token rdip:sig-resource-var? if?(
            elab-resource-var! StackTypePart.With,

        token rdip:sig-resource-con? if?(
            elab-resource-con! StackTypePart.With,

        token rdip:pat-underscore? if(
            elab-type-dont-care! StackTypePart.Cons,

        token rdip:sig-type-hole? if?(
            elab-type-hole! StackTypePart.Cons,

        token rdip:lsquare? .if(
            elab-type-quote! StackTypePart.Cons,

            token "Expected type, got unknown token." rdip:emit-error!
            token:next Type.Error StackTypePart.Cons
        ))))))))
    }

    def elab-stack-label! [ +Mirth +TypeElab |- Label -- StackTypePart ] {
        token rdip:next dip(
            token:args-1 dup rdip:is-resource-label? if(
                elab-resource-arg! swap StackTypePart.WithLabel,
                elab-type-arg! swap StackTypePart.ConsLabel
            )
        ) token!
    }

    def elab-stack-type-var! [ +Mirth +TypeElab |- Name -- StackType ] {
        Type.STACK elab-implicit-var! if?(StackType.Var, StackType.Error)
    }

    def elab-type-var! [ +Mirth +TypeElab |- Name -- Type ] {
        Type.TYPE elab-implicit-var! if?(Type.Var, Type.Error)
    }

    def elab-resource-var! [ +Mirth +TypeElab |- Name -- Resource ] {
        Type.RESOURCE elab-implicit-var! if?(Type.Var, Type.Error) Resource
    }

    def elab-implicit-var! [ +Mirth +TypeElab |- Name Type -- Maybe(Var) ] {
        token rdip:error-token!
        over ctx rdip:lookup match(
            Some -> sip(dip:nip rdip:type rdip:unify! drop) Some,
            None ->
                allow-implicit-type-vars if(
                    swap ctx(dip:Var.New! over Ctx.new) Some,
                    "Implicit type variable not allowed here." rdip:error!
                    drop2 None
                )
        )
        token rdip:args-0
        token:succ
    }

    def resolve-type-con-name! [ +Mirth +TypeElab |- Name/DName -- Type List(Var) ] {
        >name/dname
        False >report-ambiguous-as-warning
        False >ignore-last-name
        token >token "type" >sort rdip:resolve-def(
            filter(dup rdip:defines-a-type?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            L0 filter-roots
        ) if? (
            match(
                Data -> sip:Type.Data rdip:params,
                Table -> Type.Table L0,
                Type -> rdip(sip:target params), # TODO: this doesn't quite make sense.
                _ ->
                    drop token "compiler bug: resolve-type-con-name! doesn't understand type"
                    rdip:emit-error! Type.Error L0,
            ),
            Type.Error L0
        )
    }

    def elab-type-con! [ +Mirth +TypeElab |- Name/DName -- Type ] {
        dup left? rdip:has(>Str "Mut" =) if(
            drop token rdip:next dip(
                token:args-1
                elab-type-arg!
                Type.Mut
            ) token!,

            resolve-type-con-name! elab-type-args!
            token:next
        )
    }

    def elab-resource-con! [ +Mirth +TypeElab |- Name/DName -- Resource ] {
        elab-type-con! Resource
    }

    def with-token(f) [ +TypeElab |- (*a -- *b) *a Token -- *b ] {
        token:swap dip(f) token!
    }

    def elab-type-args! [ +Mirth +TypeElab |- Type List(Var) -- Type ] {
        token rdip:args for(
            with-token(elab-type-app!)
        ) drop
    }

    def elab-type-app! [ +Mirth +TypeElab |- Type List(Var) -- Type List(Var) ] {
        uncons swap if? (
            rdip:sort? else?(token "Type parameter has unknown sort." rdip:emit-fatal-error!) match {
                { Resource -> elab-resource-arg! >Type }
                { Stack -> T0 elab-stack-type! >Type }
                { Type -> elab-type-arg! }
            } swap dip:Type.App,

            drop rdip:tycon? then?(
                token rdip(Str("Too many type arguments to "; swap qname;) emit-error!)
            )
            Type.Error L0
        )
    }

    def elab-type-hole! [ +Mirth +TypeElab |- Name -- Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Hole,
            drop
            token "type holes are not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-dont-care! [ +Mirth +TypeElab |- Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Ignore,
            token "underscore is not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-quote! [ +Mirth +TypeElab |- Type ] {
        token rdip:next dip(
            token:args-1
            token rdip:sig-has-vdash-or-dashes? if(
                T0 elab-type-sig! >Type,
                T0 elab-stack-type! >Type
            )
        ) token!
    }
}

# TODO: separate this into a reason and a def.
data RejectedDef {
    WrongSort          [ Def ]
    WrongArity         [ Def ]
    NotVisible         [ Def ]
    NotImported        [ Def ]
    WrongQualifier     [ Def ]
    WrongConstructor   [ Def ]
    MethodNotAvailable [ Def ]
    MethodWrongType    [ Def List(Namespace) ]
}

struct +ResolveDef {
    sort: Str
    token: Token
    name/dname: Name/DName
    candidates: List(Def)
    rejected: List(RejectedDef)
    ignore-last-name: Bool
    report-ambiguous-as-warning: Bool
    --
    def rdrop [ +ResolveDef -- ] {
        /+ResolveDef
        sort> token> name/dname> drop3
        candidates> rejected> drop2
        ignore-last-name> drop
        report-ambiguous-as-warning> drop
    }

    def Begin! [
        sort:Str
        token:Token
        name/dname:Name/DName
        ignore-last-name:Bool
        report-ambiguous-as-warning:Bool
        +Mirth
        -- +Mirth +ResolveDef
    ] {
        @ignore-last-name if(
            @name/dname name/dname-penultimate-name? unwrap(
                @token "Expected a namespace." emit-fatal-error!
            ),
            @name/dname name/dname-last-name
        ) defs >candidates
        List.Nil >rejected
        +ResolveDef
    }

    def expunge(p) [ *a |- ( Def -- Bool ) +ResolveDef -- +ResolveDef ] {
        candidates:filter(p not)
    }

    def filter(p) [ *a +ResolveDef |- ( Def -- Either(RejectedDef, Def) ) -- ] {
        candidates partition-either(p) dip:rejected:cat candidates!
    }

    def filter(p,q) [ *a +ResolveDef |- ( Def -- Def Bool, Def -- RejectedDef ) -- ] {
        filter(p if(Right, q Left))
    }

    def filter-sort(p) [ *a +ResolveDef |- ( Def -- Def Bool ) -- ] {
        filter(p, RejectedDef.WrongSort)
    }

    def filter-arity [ +Mirth +ResolveDef |- ] {
        token rdip:num-args filter(
            dup2 rdip:qname-hard arity dip(>Int) arity-compatible?,
            RejectedDef.WrongArity
        ) drop
    }

    def filter-visible [ +Mirth +ResolveDef |- ] {
        filter(token over rdip:def-visible-from-token?, RejectedDef.NotVisible)
    }

    def filter-qualifiers [ +Mirth +ResolveDef |- ] {
        token rdip:dname? for(
            filter(dup2 rdip:qname-hard climb-up-dname? empty? not, RejectedDef.WrongQualifier)
            drop
        )
    }

    def filter-roots [ +Mirth +ResolveDef |- List(Namespace) -- ] {
        !namespaces(name/dname match {
            { Left ->
                >name
                filter(
                    dup rdip:qname-hard namespace @namespaces member
                    or(token over rdip:def-is-imported-at-token?),
                    dup rdip:qname-hard namespace match(
                        Tycon ->
                            drop @name rdip:can-be-relative? if(
                                @namespaces empty? if(
                                    RejectedDef.MethodNotAvailable,
                                    @namespaces RejectedDef.MethodWrongType
                                ),
                                RejectedDef.NotImported
                            ),
                        _ -> drop RejectedDef.NotImported
                    )
                )
                name> drop
            }

            { Right ->
                dup is-relative? and(ignore-last-name not) if(
                    filter(dup2 rdip:qname-hard climb-up-dname? has(@namespaces member),
                        @namespaces empty? if(
                            RejectedDef.MethodNotAvailable,
                            @namespaces RejectedDef.MethodWrongType
                        )
                    ),
                    filter(dup2 rdip:qname-hard climb-up-dname? has(
                        dip:token rdip:namespace-is-imported-at-token?
                    ), RejectedDef.NotImported)
                ) drop
            }
        })
        drop
    }

    def end! [ +Mirth |- +ResolveDef -- Maybe(Def) ] {
        candidates match(
            Nil -> resolve-def-unknown None,
            Cons -> match(
                Nil -> +ResolveDef.rdrop Some,
                _ -> List.filter(over rdip:same-resolved? not) match(
                    Nil -> +ResolveDef.rdrop Some,
                    _ -> drop2 resolve-def-ambiguous None
                )
            )
        )
    }

    def resolve-def-ambiguous [ +Mirth |- +ResolveDef -- ] {
        report-ambiguous-as-warning if(
            token Str(
                "Can't resolve " ; rdip:sort ; " due to previous errors. Candidates are:" ;
                " " rdip:candidates for(swap ; rdip_:qname; ", ") drop
            ) rdip:emit-warning!,

            token Str(
                "Ambiguous " ; rdip:sort ; ". Can't decide between:" ;
                " " rdip:candidates for(swap ; rdip_:qname; ", ") drop
            ) rdip:emit-error!
        ) +ResolveDef.rdrop
    }

    def resolve-def-unknown [ +Mirth |- +ResolveDef -- ] {
        token Str(rdip:rejected match(
            Nil -> "Unknown " ; rdip:sort ; " name, possibly a misspelling." ;,
            Cons ->
                match(
                    Nil -> match(
                        WrongSort ->
                            "Expected a " ; rdip:sort ; ", but " ; rdip_:qname; " is not a " ; rdip:sort ; "." ; ,
                        NotVisible ->
                            "Not visible in current scope: " ; rdip_:qname; ,
                        NotImported ->
                            "Not imported in current scope: " ; rdip_:qname; ,
                        WrongArity ->
                            rdip2:qname-hard dup rdip_:qname; " expects " ; arity int;
                            " arguments, but got " ; rdip:token rdip2:num-args int; "." ; ,
                        WrongQualifier ->
                            "Qualified name not found. Perhaps you meant: " ; rdip_:qname; ,
                        WrongConstructor ->
                            "Constructor is for a different type: " ; rdip_:qname; ,
                        MethodWrongType ->
                            swap "Method "; rdip_:qname;
                            " does not match ["; for(rdip_:name;, " ";) "]"; ,
                        MethodNotAvailable ->
                            "Method is not available for current stack: " ; rdip_:qname; ,
                    ),
                    _ -> cons "Multiple definitions for name, but none are suitable:" ;
                        L0 >namespaces
                        dup filter-some:match(
                            MethodWrongType -> @namespaces(drop id) Some,
                            _ -> drop None
                        )
                        " " >separator
                        >Nest? for(
                            separator> ; "Method "; rdip:name/dname left(last-name) rdip_:name;
                            " is for different type – expected one of"; for(" "; rdip:rdip:qname-hard namespace rdip_:qname;)
                            " but got ["; @namespaces for(rdip_:name;, " ";) "]";
                            ", " >separator
                        )
                        namespaces> drop
                        filter-some:match(MethodWrongType -> drop drop None, _ -> Some)
                        for(separator> ; match(
                            WrongSort -> rdip_:qname; " is not a " ; rdip:sort ; ,
                            NotVisible -> rdip_:qname; " is not visible in current scope" ; ,
                            NotImported -> rdip_:qname; " is not imported in current scope" ; ,
                            WrongArity -> rdip2:qname-hard dup rdip_:qname; " expects " ; arity int; " arguments" ; ,
                            WrongQualifier -> rdip_:qname; " doesn't match the given qualified name" ; ,
                            WrongConstructor -> rdip_:qname; " is constructor for a different type" ; ,
                            MethodWrongType -> impossible!,
                            MethodNotAvailable -> rdip_:qname; " is not avaliable for current stack" ; ,
                        ) ", " >separator)
                        separator> drop
                )
        )) rdip:emit-error! +ResolveDef.rdrop
    }
}

def +Mirth.resolve-def(f) [
    (+Mirth +ResolveDef |- *a -- *b)
    *a +Mirth
    sort:Str
    token:Token
    name/dname:Name/DName
    ignore-last-name:Bool
    report-ambiguous-as-warning:Bool
    --
    *b +Mirth Maybe(Def)
] {
    +ResolveDef.Begin! f end!
}

def QName.punning? [ +Mirth |- QName -- Bool ] {
    dup namespace match {
        { Tycon -> name swap name = }
        { _ -> drop2 False }
    }
}

def Def.punning? [ +Mirth |- Def -- Bool ] {
    qname-hard punning?
}

||| Check whether a definition can be referred to without qualification.
def def-is-imported-at-token? [ +Mirth |- Token Def -- Bool ] {
    # TODO: implement finer grained control over what is imported.
    #   https://github.com/mirth-lang/mirth/issues/243
    dup qname-hard namespace match(
        Root -> drop2 True,
        Package -> drop3 True,
        Module -> nip module-visible-from-token?,
        Tycon -> dip:swap tycon-is-visible-at-token? if(punning?, drop False),
        Word -> drop3 False
    )
}

def tycon-is-visible-at-token? [ +Mirth |- Token Tycon -- Bool ] {
    Data -> head? if?(.module module-visible-from-token?, drop True),
    Table -> head .module module-visible-from-token?,
    Prim -> drop2 True
}

def namespace-is-imported-at-token? [ +Mirth |- Token Namespace -- Bool ] {
    Root -> drop True,
    Package -> drop2 True,
    Module -> module-visible-from-token?,
    Tycon -> qname-hard namespace namespace-is-imported-at-token?,
    Word -> drop2 False
}

def QName.climb-up-name? [ +Mirth |- Name QName -- List(Namespace) ] {
    >qname >name

    @qname name @name = if(
        @qname namespace L1,
        L0
    ) >accum
    name> defs for(match(
        Alias ->
            dup ~target try-force! has(qname-hard @qname =) if(
                namespace @accum:cons,
                drop
            ),
        Type ->
            dup target tycon? has(qname-hard @qname =) if(
                namespace @accum:cons,
                drop
            ),
        _ -> drop
    ))
    qname> drop
    accum>
}

def QName.climb-up-dname? [ +Mirth +ResolveDef |- DName QName -- List(Namespace) ] {
    dip(sip(root? >List) parts unsnoc dip(cat)
        ignore-last-name then(drop unsnoc unwrap(
            token "Error, expected a namespace in QName.climb-up-dname?" rdip:emit-fatal-error!
        ))
    )
    rdip:climb-up-name? swap
    reverse-for(swap bind(rdip:qname if?(dip(dup) rdip:climb-up-name?, L0)) nip)
}

def elab-type-unify! [ +Mirth |- Type Type Token -- Type Token ] {
    dup with-error-token(dip:unify!)
}
def elab-stack-type-unify! [ +Mirth |- StackType StackType Token -- StackType Token ] {
    dup with-error-token(dip:unify!)
}

def elab-simple-type-arg! [ +Mirth |- Token -- Type ] {
    >token
    Ctx.L0 >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab elab-type-arg! +TypeElab.rdrop
}

def elab-simple-type-atom! [ +Mirth |- Ctx Token -- Type ] {
    >token >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab elab-type-atom! +TypeElab.rdrop
}

####################
# Word Elaboration #
####################

struct +AB {
    arrow:Arrow
    --
    def ab-token@ [ +AB -- +AB Token ] { arrow token-end }
    def ab-token! [ +AB Token -- +AB ] { arrow:token-end! }
    def ab-type@ [ +AB -- +AB StackType ] { arrow cod }
    def ab-type! [ +AB StackType -- +AB ] { arrow:cod! }
    def ab-ctx@ [ +AB -- +AB Ctx ] { arrow ctx }
    def ab-home@ [ +AB -- +AB Home ] { arrow home }

    def ab-finalize! [ +Mirth |- +AB StackType -- Arrow ] {
        ab-unify-type!
        /+AB arrow>
    }

    def worth-sliding-for? [ +Mirth +AB |- List(Tycon) -- Bool ] {
        dup empty? if(
            drop False,
            ab-type@ rdip:top-resource-tycons swap
            on2:reverse worth-sliding-for-aux
        )
    }

    def worth-sliding-for-aux [ +Mirth +AB |- List(Tycon) List(Tycon) -- Bool ] {
        { Nil -> drop False }
        { Cons ->
            >ys >y match {
                { Nil -> ys> y> drop2 False }
                { Cons -> >xs
                    @y = if(
                        y> drop
                        xs> ys> worth-sliding-for-aux,

                        ys> drop
                        y> xs> member
                    )
                }
            }
        }
    }

    ||| Slide the top resource tycons around until they match the list.
    ||| Returns True on success.
    def ab-slide-resource-tycons-to-top! [ +Mirth +AB |- List(Tycon) -- ] {
        dup worth-sliding-for? if(
            unsnoc unwrap("logic error: expected resource for sliding" panic!)
            ab-slide-resource-tycon-to-top! if(
                ab-rdip!(ab-slide-resource-tycons-to-top!),
                drop
            ),

            drop
        )
    }

    ||| Slide the top resource tycons around to bring to the front.
    ||| Returns True on success.
    def ab-slide-resource-tycon-to-top! [ +Mirth +AB |- Tycon -- Bool ] {
        ab-type@ rdip:top-resource-tycon? if?(
            over = if(
                drop True,
                ab-rdip!(ab-slide-resource-tycon-to-top!)
                if(L0 Prim.RSwap ab-prim! True, False)
            ),
            drop False
        )
    }

    def ab-unify-type! [ +Mirth +AB |- StackType -- ] {
        ab-token@ error-token!
        dup ab-prepare-for-unification!
        dip:ab-type@ unify! ab-type!
    }

    def ab-atom! [ +Mirth +AB |- Atom -- ] {
        dup token ab-token!
        # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
            # ^ a sanity check to make sure
            # atom dom matches ab-arrow cod
        dup cod ab-type!
        arrow:atoms(swap List.Snoc)
    }

    def ab-op! [ +Mirth +AB |- List(Arg) Op -- ] {
        swap >args
        ab-ctx@ >ctx
        ab-token@ >token
        ab-home@ >home
        dup >op
        rdip:elab-op-fresh-sig! dip:>subst
        match {
            { OpSig.Id -> ab-type@ dup >dom >cod Atom ab-atom! }
            { OpSig.Push -> dip(ab-type@ dup >dom) StackType.Cons >cod Atom ab-atom! }
            { OpSig.Apply ->
                /ArrowType
                @args reverse map(
                    dom> force-cons?!
                    unwrap(ab-token@ "Expected arg type in type signature." fatal-error!)
                    unpack2 rotr >dom pack2
                ) reverse >typed-args
                ab-codip-extraneous!(
                    @dom ab-unify-type!
                    typed-args> for(unpack2 ab-arg-unify-type!)
                    @dom >dom @cod >cod
                    Atom ab-atom!
                ) dom> cod> drop2
            }
        }
    }

    def ab-prepare-for-codipping! [ +Mirth +AB |- StackType -- ] {
        top-resource-tycons ab-slide-resource-tycons-to-top!
    }

    def ab-prepare-for-unification!  [ +Mirth +AB |- StackType -- ] {
        top-resource-tycons ab-slide-resource-tycons-to-top!
    }


    ||| Prepare for a call with a fixed base (e.g. auto-run variables) by co-dipping everything that isn't required.
    def ab-codip-extraneous!(f) [ +Mirth +AB dom:StackType cod:StackType |- (*a -- *b) *a -- *b ] {
        @dom base is-fixed? if(
            @dom ab-prepare-for-codipping!

            @dom count-parts \dom-counts
            @cod count-parts \cod-counts
            ab-type@ count-parts @dom-counts difference \codip-counts
            "_codip"   Name Label \codip
            "_dip"     Name Label \dip
            "+_rcodip" Name Label \rcodip
            "+_rdip"   Name Label \rdip

            0u \total-codip
            0u \total-rcodip

            @codip-counts values 0> then(
                @dom-counts   values repeat( @dip   ab-label-push! )
                @codip-counts values repeat( @codip ab-label-push! )
                @codip-counts values @total-codip:+
                @dom-counts   values repeat( @dip   ab-label-pop!  )
            )

            @codip-counts resources 0> then(
                @dom-counts   resources repeat( @rdip   ab-label-push-r! )
                @codip-counts resources repeat( @rcodip ab-label-push-r! )
                @codip-counts resources @total-rcodip:+
                @dom-counts   resources repeat( @rdip   ab-label-pop-r!  )
            )

            @codip-counts labels for-pairs(
                \count \label
                @label is-resource-label? if(
                    @label @dom-counts label repeat(@label ab-label-pop-r!)
                    @count repeat(
                        @label ab-label-pop-r!
                        @rcodip ab-label-push-r!
                        @total-rcodip:1+
                    )
                    @label @dom-counts label repeat(@label ab-label-push-r!),

                    @label @dom-counts label repeat(@label ab-label-pop!)
                    @count repeat(
                        @label ab-label-pop!
                        @codip ab-label-push!
                        @total-codip:1+
                    )
                    @label @dom-counts label repeat(@label ab-label-push!)
                )
            )

            @total-codip repeat(@codip ab-label-pop!)
            @total-rcodip repeat(@rcodip ab-label-pop-r!)

            @total-rcodip ab-rdip-n!(
                @total-codip ab-dip-n!(
                    ldip(
                        dom-counts
                        cod-counts
                        codip-counts
                        codip
                        dip
                        rcodip
                        rdip
                        total-codip
                        total-rcodip,

                        f
                    )
                )
            )
            @total-rcodip repeat(@rcodip ab-label-push-r!)
            @total-codip repeat(@codip ab-label-push!)

            @codip-counts labels reverse-for-pairs(
                \count \label
                @label is-resource-label? if(
                    @label @cod-counts label repeat(@label ab-label-pop-r!)
                    @count repeat(
                        @rcodip ab-label-pop-r!
                        @label ab-label-push-r!
                    )
                    @label @cod-counts label repeat(@label ab-label-push-r!),

                    @label @cod-counts label repeat(@label ab-label-pop!)
                    @count repeat(
                        @codip ab-label-pop!
                        @label ab-label-push!
                    )
                    @label @cod-counts label repeat(@label ab-label-push!)
                )
            )

            @codip-counts resources 0> then(
                @cod-counts   resources repeat( @rdip   ab-label-push-r! )
                @codip-counts resources repeat( @rcodip ab-label-pop-r!  )
                @cod-counts   resources repeat( @rdip   ab-label-pop-r!  )
            )

            @codip-counts values 0> then(
                @cod-counts   values repeat( @dip   ab-label-push! )
                @codip-counts values repeat( @codip ab-label-pop!  )
                @cod-counts   values repeat( @dip   ab-label-pop!  )
            ),

            f
        )
    }

    def ab-rdip-n!(f) [ +Mirth +AB |- (*a -- *b) *a Nat -- *b ] {
        dup 0> if(
            ab-rdip!(pred ab-rdip-n!(f)),
            drop f
        )
    }

    def ab-dip-n!(f) [ +Mirth +AB |- (*a -- *b) *a Nat -- *b ] {
        dup 0> if(
            ab-dip!(pred ab-dip-n!(f)),
            drop f
        )
    }

    def ab-arg-unify-type! [ +Mirth +AB |- Type Arg -- ] {
        { Block -> swap rdip:unify-block! drop }
    }

    def ab-push-value! [ +Mirth +AB |- PushValue -- ] { dip:L0 Op.Push ab-op! }
    def ab-int! [ +Mirth +AB |- Int -- ] { PushValue.Int ab-push-value! }
    def ab-str! [ +Mirth +AB |- Str -- ] { PushValue.Str ab-push-value! }
    def ab-buffer! [ +Mirth +AB |- Buffer -- ] { L0 swap Op.Buffer ab-op! }
    def ab-field! [ +Mirth +AB |- Field -- ] { L0 swap Op.Field ab-op! }
    def ab-var! [ +Mirth +AB |- Var -- ] { L0 swap Op.Var ab-op! }
    def ab-tag! [ +Mirth +AB |- Tag -- ] { L0 swap Op.Tag ab-op! }
    def ab-prim! [ +Mirth +AB |- List(Arg) Prim -- ] { Op.Prim ab-op! }
    def ab-word! [ +Mirth +AB |- List(Arg) Word -- ] { Op.Word ab-op! }
    def ab-external! [ +Mirth +AB |- External -- ] { L0 swap Op.External ab-op! }
    def ab-label-push! [ +Mirth +AB |- Label -- ] { L0 swap Op.LabelPush ab-op! }
    def ab-label-pop! [ +Mirth +AB |- Label -- ] { L0 swap Op.LabelPop ab-op! }
    def ab-label-push-r! [ +Mirth +AB |- Label -- ] { L0 swap Op.LabelPushR ab-op! }
    def ab-label-pop-r! [ +Mirth +AB |- Label -- ] { L0 swap Op.LabelPopR ab-op! }

    def ab-push-block-at!(f) [ +Mirth +AB |- ( *a -- *b ) *a ArrowType Token -- *b ] {
        ab-ctx@ rotr ab-home@ rdip(ab-build-hom!(dip:f))
        rdip:Block.New! Op.BlockPush L0 swap ab-op!
    }

    def ab-push-block!(f) [ +Mirth +AB |- (*a -- *b) *a ArrowType -- *b ] {
        ab-token@ ab-push-block-at!(f)
    }

    def ab-arg-block!(f) [ +Mirth +AB |- (*a -- *b) *a ArrowType -- *b Arg ] {
        ab-ctx@ swap
        ab-token@
        ab-home@
        rdip:ab-build-hom!(dip(f))
        rdip:Block.New! Arg.Block
    }

    def ab-dip!(f) [ +Mirth +AB |- (*a -- *b) *a -- *b ] {
        ab-type@ rdip:force-cons?! if?(unpack2 drop, StackType.Error)
        rdip:StackType.Fresh! T-> ab-arg-block!(f)
        L1 Prim.Dip ab-prim!
    }

    def ab-rdip!(f) [ +Mirth +AB |- (*a -- *b) *a -- *b ] {
        ab-type@ rdip:force-with?! if?(unpack2 drop, StackType.Error)
        rdip:StackType.Fresh! T-> ab-arg-block!(f)
        L1 Prim.RDip ab-prim!
    }

    def ab-if!(f,g) [ +Mirth +AB |- (*a -- *b, *b -- *c) *a -- *c ] {
        ab-type@ rdip:force-cons?! if?(unpack2 drop, StackType.Error)
        rdip:StackType.Fresh! T->
        dup on2(ab-arg-block!(f), ab-arg-block!(g))
        L2 Prim.If ab-prim!
    }

    def ab-while!(f,g) [ +Mirth +AB |- (*a -- *b, *b -- *c) *a -- *c ] {
        ab-type@ dup on2(
            dup Type.Bool T* T-> ab-arg-block!(f),
            dup T-> ab-arg-block!(g)
        ) L2 Prim.While ab-prim!
    }

    def ab-lambda!(f) [ +Mirth +AB |- (*a -- *b) *a List(Var) StackType -- *b ] {
        dip2:ab-token@ ab-lambda-at!(f)
    }

    def ab-lambda-at!(f) [ +Mirth +AB |- (*a -- *b) *a Token List(Var) StackType -- *b ] {
        over dip(
            >cod
            dip(ab-ctx@ ab-type@) reverse-for(
                swap dip(dup dip(Ctx.new))
                ab-token@ rdip:elab-expand-tensor!
                dip(rotl rdip:type) rdip:elab-type-unify! drop2
            ) cod> T->
            rotl ab-home@ rdip(ab-build-hom!(dip:f))
        )
        >params >body
        ab-ctx@ >outer-ctx
        ab-type@ >dom
        ab-token@ >token
        Lambda Op.Lambda L0 swap ab-op!
    }

    def ab-match!(f) [ +Mirth |- (*a +Match -- *b +Match) *a cod:StackType body:Token +AB -- *b +AB ] {
        ab-ctx@ >ctx
        ab-type@ >dom
        ab-token@ >token
        ab-home@ >home
        L0 >cases
        rdip(+Match f freeze) Op.Match L0 swap ab-op!
    }

    def ab-ldip!(f) [ +Mirth +AB |- (*a -- *b) *a List(Label) -- *b ] {
        { Nil -> f }
        { Cons -> swap ab-ldip-one!(ab-ldip!(f)) }
    }

    def ab-ldip-one!(f) [ +Mirth +AB |- (*a -- *b) *a Label -- *b ] {
        dup rdip:is-resource-label? if(
            dup ab-label-pop-r!
            dip(ab-rdip!(f))
            ab-label-push-r!,

            dup ab-label-pop!
            dip(ab-dip!(f))
            ab-label-push!
        )
    }

    def elab-atoms! [ +Mirth +AB |- ] {
        L0 >deferred-drops
        while(
            ab-token@ rdip:run-end? not,
            elab-atom! ab-token@ rdip:next ab-token!
        )
        deferred-drops> for(
            ab-label-pop!
            L0 Prim.Drop ab-prim!
        )
    }

    def elab-atom! [ +Mirth +AB deferred-drops:List(Label) |- ] {
        ab-token@ rdip:value match(
            Name -> elab-atom-name!,
            DName -> elab-atom-dname!,
            Str -> ab-str!,
            Int -> ab-int!,
            U8  -> PushValue.U8  ab-push-value!,
            U16 -> PushValue.U16 ab-push-value!,
            U32 -> PushValue.U32 ab-push-value!,
            U64 -> PushValue.U64 ab-push-value!,
            I8  -> PushValue.I8  ab-push-value!,
            I16 -> PushValue.I16 ab-push-value!,
            I32 -> PushValue.I32 ab-push-value!,
            I64 -> PushValue.I64 ab-push-value!,
            F32 -> PushValue.F32 ab-push-value!,
            F64 -> PushValue.F64 ab-push-value!,
            LSquare -> drop elab-atom-block!,
            LCurly -> drop elab-atom-assert!,
            LabelPush -> ab-token@ rdip:args-0 ab-label-push!,
            LabelPop -> ab-token@ rdip:args-0 ab-label-pop!,
            LabelPushR -> ab-token@ rdip:args-0 ab-label-push-r!,
            LabelPopR -> ab-token@ rdip:args-0 ab-label-pop-r!,
            LabelGet -> elab-label-get!,
            LabelSet -> elab-label-set!,
            LabelLam -> elab-label-lam!,
            _ -> ab-token@ "Unexpected token in elab-atom!" rdip:emit-fatal-error!
        )
    }

    def elab-label-get! [ +Mirth +AB |- Label -- ] {
        dup rdip:is-resource-label? if(
            dup ab-label-pop-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-push-r!,

            dup ab-label-pop!
            ab-token@ rdip:num-args 0= if(
                L0 Prim.Dup ab-prim!,
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            )
            ab-label-push!
        )
    }

    def elab-label-set! [ +Mirth +AB |- Label -- ] {
        dup rdip:is-resource-label? if(
            dup ab-label-push-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-pop-r!,

            ab-token@ rdip:num-args 0= if(
                dup ab-label-pop!
                L0 Prim.Drop ab-prim!
                ab-label-push!,

                dup ab-label-push!
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
                ab-label-pop!
            )
        )
    }

    def elab-label-lam! [ +Mirth +AB deferred-drops:List(Label) |- Label -- ] {
        dup ab-label-push!
        @deferred-drops:cons
    }

    def elab-atom-block! [ +Mirth +AB |- ] {
        ab-token@ rdip:args-1 elab-block-at!
        Op.BlockPush L0 swap ab-op!
    }

    def elab-block-at! [ +Mirth +AB |- Token -- Block ] {
        ab-ctx@ swap ab-home@ rdip:Block.NewDeferred!(
            dup ctx swap
            dup dom swap
            dup cod swap
            dup token swap
            home
            elab-arrow-hom!
        )
    }

    def elab-args! [ +Mirth +AB |- List(Arg) ] {
        ab-token@ rdip:args map(elab-block-at! Arg.Block)
    }

    def elab-word-args! [ +Mirth +AB |- Word -- List(Arg) Word ] {
        elab-args! swap
        over len over rdip:arity < then(
            over len over rdip:params drop-slice map(
                default if? (
                    ab-token@ rdip:location >location rdip:clone-run! elab-block-at! Arg.Block,
                    ab-token@ "word parameter is missing, has no default implementation" rdip:emit-fatal-error!
                )
            ) swap dip:cat
        )
    }

    def elab-no-args! [ +Mirth +AB |- ] {
        ab-token@ rdip:args-0
    }

    def elab-atom-name! [ +Mirth +AB |- Name -- ] {
        dup ab-ctx@ rdip:lookup match(
            Some -> nip elab-no-args! ab-var!,
            None -> Left elab-atom-resolve-def!
        )
    }

    def elab-atom-dname! [ +Mirth +AB |- DName -- ] {
        Right elab-atom-resolve-def!
    }

    def Token.can-be-relative-name-or-dname? [ +Mirth |- Token -- Bool ] {
        value match(
            Name -> can-be-relative?,
            DName -> is-relative?,
            _ -> drop False
        )
    }

    def elab-atom-resolve-def! [ +Mirth +AB |- Name/DName -- ] {
        >name/dname
        ab-type@ rdip:top-types-are-fine? not >report-ambiguous-as-warning
        ab-token@ >token
        "word" >sort
        False >ignore-last-name
        >+ab resolve-def(
            filter(dup rdip:callable?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            token rdip:can-be-relative-name-or-dname? if(
                @+ab:ab-type@ rdip:top-types-are-fine? then(
                    @+ab:ab-type@ rdip:top-namespaces filter-roots
                ),
                L0 filter-roots
            )
        ) +ab> match (
            None -> elab-atom-failed!,
            Some -> elab-atom-def!
        )
    }

    def elab-atom-failed! [ +Mirth +AB |- ] {
        StackType.Error ab-type!
    }

    def elab-atom-def! [ +Mirth +AB |- Def -- ] {
        Alias -> rdip:target elab-atom-def!,
        Buffer -> elab-no-args! ab-buffer!,
        External -> elab-no-args! ab-external!,
        Field -> elab-no-args! ab-field!,
        Word -> elab-word-args! ab-word!,
        Tag -> elab-args! swap Op.Tag ab-op!,
        Prim -> elab-prim!,
        Macro -> elab-macro!,
        _ -> rdip:qname-hard elab-atom-not-callable!
    }

    def elab-atom-not-callable! [ +Mirth +AB |- QName -- ] {
        ab-type@ rdip:top-types-are-fine? if(
            ab-token@ swap rdip:str("Not callable: "; qname;) rdip:emit-error!,
            drop
        ) elab-atom-failed!
    }

    def elab-macro! [ +Mirth +AB |- Macro -- ] {
        rdip:action arrow? if?(
            run,

            ab-token@ "macro cannot be invoked here" rdip:emit-error!
            StackType.Error ab-type!
        )
    }

    def elab-prim! [ +Mirth +AB |- Prim -- ] {
        elab-args! swap ab-prim!
    }

    def elab-atom-assert! [ +Mirth +AB |- ] {
        ab-token@ rdip:args-1 >token
        ab-ctx@ >ctx
        True >allow-type-holes
        False >allow-implicit-type-vars
        +TypeElab T0 rdip_:elab-stack-type! +TypeElab.rdrop
        ab-token@ rdip:error-token!
        dip:ab-type@ rdip:unify! drop
    }

    ||| Parse an ldip. It takes on one of the forms:
    |||
    |||     ldip(body)
    |||     ldip(label1 ... labeln, body)
    |||     ldip { body }
    |||     ldip(label1 ... labeln) { body }
    |||
    ||| Sets up ab-token@ so that Token.next on it will be past the ldip.
    def elab-parse-ldip! [ +Mirth +AB |- labels:Maybe(List(Label)) body:Token ] {
        ab-token@ rdip:next rdip:lcurly? if(
            ab-token@ rdip:num-args 0= if(
                None >labels,
                ab-token@ rdip:args-1 Some >labels
            )
            ab-token@ rdip:next rdip:succ >body
            ab-token@ rdip:next ab-token!,

            ab-token@ rdip:num-args dup 0= if(
                ab-token@ "Missing ldip body: ldip { ... }" rdip:emit-fatal-error!,

                1 = if(
                    None >labels
                    ab-token@ rdip:args-1 >body,

                    ab-token@ rdip:args-2
                    >body
                    Some >labels
                )
            )
        )
        @labels:map:parse-label-names
    }

    def +Mirth.parse-label-names [ +Mirth |- Token -- List(Label) ] {
        run-tokens map(
            dup args-0
            dup name? else?("Expected label name." emit-fatal-error!)
            dup could-be-label-name? else(Str("Invalid label name: "; name;) emit-fatal-error!)
            Label nip
        )
    }

    ||| Run function but with labels dipped.
    ||| If list of labels is not given, it is inferred from the stack type.
    |||
    |||     ldip(body)
    |||     ldip(label1 ... labeln, body)
    |||     ldip { body }
    |||     ldip(label1 ... labeln) { body }
    |||
    def elab-ldip! [ +Mirth +AB |- ] {
        elab-parse-ldip! ab-token@
        labels> else?(ab-type@ label-names unique)
        ab-ldip!(body> ab-token! elab-atoms!)
        ab-token!
    }


    ||| Elaborate an ldrop, which drops elements of all
    |||
    |||     ldrop
    |||     ldrop(label1 ... labeln)
    def elab-ldrop! [ +Mirth +AB |- ] {
        ab-token@ dup num-args 0> if(
            args-1 parse-label-names,
            args-0 ab-type@ label-names unique
        ) for (
            dup is-resource-label? if(
                ab-label-pop-r!
                L0 "rdrop" Name ab-rmethod!,
                ab-label-pop!
                L0 Prim.Drop ab-prim!
            )
        )
    }

    ||| Invoke method on resource.
    def ab-rmethod! [ +Mirth +AB |- List(Arg) Name -- ] {
        \name
        ab-type@ top-resource-tycon? if?(
            \tycon
            @tycon >Namespace >namespace
            @name >name dup len >Int >arity
            QName def-hard? if?(
                ab-def!,
                ab-error!("Resource "; @tycon qname; " doesn't implement "; @name name; "/"; len int;)
            ),
            ab-error!(
                "Can't invoke "; @name name; "/"; len int;
                " on unknown or generic resource.";
            )
        )
    }

    def ab-def! [ +Mirth +AB |- List(Arg) Def -- ] {
        { Alias -> target ab-def! }
        { Word -> Op.Word ab-op! }
        { Prim -> Op.Prim ab-op! }
        { External -> Op.External ab-op! }
        { Field -> Op.Field ab-op! }
        { Tag -> Op.Tag ab-op! }
        { Buffer -> Op.Buffer ab-op! }
        { _ -> drop2 ab-error!("Unexpected definition in ab-def!";) }
    }

    def ab-error! [ +Mirth +AB |- Str -- ] {
        ab-token@ swap emit-error!
        StackType.Error ab-unify-type!
        StackType.Error ab-type!
    }

    def ab-error!(f) [ +Mirth +AB |- (+Str |- *a -- *b) *a -- *b ] {
        Str(f) ab-error!
    }

    def elab-atom-match! [ +Mirth +AB |- ] {
        rdip:StackType.Fresh! >cod
        ab-token@ succ lcurly? if(
            ab-token@ succ succ >body
            ab-token@ succ ab-token!,
            ab-token@ args+ first >body
        )
        elab-match-at!
    }

    ||| Elaborate a match body within AB. Takes the output stack type,
    ||| and the token for the body of the match, from the stack. Takes
    ||| the rest from the AB environment.
    def elab-match-at! [ +Mirth +AB |- cod:StackType body:Token -- ] {
        ab-match!(
            elab-match-cases!
            elab-match-exhaustive!
        )
    }
}

def arity-compatible? [ Int Int -- Bool ] {
    dup -1 = dip(=) or
}

def ab-build-fwd!(f) [ (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow ] {
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx L0 >atoms
    Arrow >arrow +AB
    f /+AB arrow>
}

||| Like ab-build-fwd! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def ab-build-hom!(f) [
    +Mirth |- (*a StackType +AB -- *b StackType +AB) *a Ctx ArrowType Token Home -- *b Arrow
] {
    dip2(/ArrowType dom>)
    ab-build-fwd!(cod> f ab-unify-type!)
}

||| Build the arrow for a word. If the word type and context are available, use that.
||| Otherwise, we are in a situation where type and context were not given, so we infer them.
|||
||| To infer ctx-type, we start with an initial guess based on the word head (with lots
||| of metavariables). We temporarily set that as our ctx-type. Then we elaborate the word
||| body. After elaboration, we rigidify the type to obtain a generalized definition, by
||| replacing any free metavariables with universally quantified variables.
def ab-build-word-arrow!(f) [
    +Mirth |- (*a StackType +AB -- *b StackType +AB) *a Word -- *b Arrow
] {
    initial-ctx-type-body-home
    dip:ab-build-hom!(f)
    finalize-word-arrow
}

def initial-ctx-type-body-home [ +Mirth |- Word -- Ctx ArrowType Token Home Word ] {
    >word
    @word ~ctx-type try-force!
    match(Some -> unpack2, None -> guess-initial-ctx-type)
    @word body
    @word Home.Word
    word>
}

def finalize-word-arrow [ +Mirth |- Arrow Word -- Arrow ] {
    >word >arrow
    @word inferring-type? then(
        @arrow Arrow.ctx-type rigidify-sig!
        dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
        False @word inferring-type?!
        /ArrowType
        cod> @arrow:cod!
        dom> @arrow:dom!
        @arrow:ctx!
    )
    arrow> word> drop
}

def guess-initial-ctx-type [ +Mirth word:Word |- Ctx ArrowType ] {
    Ctx.L0 >ctx
    StackType.Fresh! >dom
    StackType.Fresh! >cod
    @word namespace-hard match(
        Tycon ->
            full-type-fresh
            @word name can-be-relative? if(
                @dom(swap T*+),
                @cod(swap T*+)
            ),
        Module ->
            drop
            @word name >Str "main" = then(
                T0 Resource.World T+ !dom
                T0 Resource.World T+ !cod
            ),
        _ ->
            drop
    )
    @word arity repeat(
        @dom(
            ArrowType.Fresh! >Type T*
        )
    )
    ctx> dom> cod> T->
    dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
    True @word inferring-type?!
}

def ab-build-word!(f) [ +Mirth |- (*a +AB -- *b +AB) *a Word -- *b Word ] {
    sip(ab-build-word-arrow!(dip(f))) sip(PropLabel.WordArrow prop)
    tuck ~arrow !
}

data OpSig {
    Id
    Push  [ Type ]
    Apply [ ArrowType ]
}

def PushValue.type [ +Mirth |- PushValue -- Type ] {
    { Str -> Value.Str Type.Value }
    { Int -> Value.Int Type.Value }
    { U8  -> drop Type.U8 }
    { U16 -> drop Type.U16 }
    { U32 -> drop Type.U32 }
    { U64 -> drop Type.U64 }
    { I8  -> drop Type.I8 }
    { I16 -> drop Type.I16 }
    { I32 -> drop Type.I32 }
    { I64 -> drop Type.I64 }
    { F32 -> drop Type.F32 }
    { F64 -> Value.F64 Type.Value }
}

def elab-op-fresh-sig! [ +Mirth |- Op -- Subst OpSig ] {
    Subst.Nil swap match (
        Push -> type OpSig.Push,
        Buffer -> drop Type.Ptr OpSig.Push,
        Tag -> type freshen-sig OpSig.Apply,
        Word -> dup inferring-type? if(type, type freshen-sig) OpSig.Apply,
        Prim -> type freshen-sig OpSig.Apply,
        External -> type freshen-sig OpSig.Apply,
        Field -> type freshen-sig OpSig.Apply,
        BlockPush -> elab-block-sig!,
        BlockRun -> type semifreshen-sig OpSig.Apply,
        Var -> elab-var-sig!,
        Match -> elab-match-sig!,
        Lambda -> elab-lambda-sig!,
        LabelPush -> elab-label-push-sig!,
        LabelPop -> elab-label-pop-sig!,
        LabelPushR -> elab-label-push-r-sig!,
        LabelPopR -> elab-label-pop-r-sig!,
        DataGetEnumValue -> data-get-enum-value-type freshen-sig OpSig.Apply,
        DataFromEnumValue -> data-from-enum-value-type freshen-sig OpSig.Apply,
        DataGetLabel -> data-get-label-type freshen-sig OpSig.Apply,
        DataSetLabel -> data-set-label-type freshen-sig OpSig.Apply,
        TableToIndex -> table-to-index-type freshen-sig OpSig.Apply,
        TableFromIndex -> table-from-index-type freshen-sig OpSig.Apply,
    )
}

def data-get-enum-value-type [ +Mirth |- Data -- ArrowType ] {
    full-type match {
        { Left  -> T1 Type.I64 T1 T-> }
        { Right -> # not currently exposed for resources, but this is what it would be.
            T0 over T+ Type.I64 T1 rotl T+ T-> }
    }
}
def data-from-enum-value-type [ +Mirth |- Data -- ArrowType ] {
    Type.I64 T1 T0 rotl full-type T*+ T->
}

def table-to-index-type [ +Mirth |- Table -- ArrowType ] {
    Type.Table T1 Type.U64 T1 T->
}
def table-from-index-type [ +Mirth |- Table -- ArrowType ] {
    Type.Table T1 Type.U64 T1 swap T->
}

def elab-block-sig! [ Block -- OpSig ] {
    Value.Block Type.Value OpSig.Push
}

def elab-match-sig! [ Match -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-lambda-sig! [ Lambda -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-var-sig! [ +Mirth |- Var -- OpSig ] {
    dup auto-run? if?(
        nip semifreshen-sig OpSig.Apply,
        type OpSig.Push
    )
}

def elab-label-push-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Type.Fresh! dup2)
    StackType.ConsLabel dip(StackType.Cons) T-> OpSig.Apply
}

def elab-label-pop-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Type.Fresh! dup2)
    StackType.ConsLabel dip(StackType.Cons) swap T-> OpSig.Apply
}

def elab-label-push-r-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Resource.Fresh! dup2)
    StackType.WithLabel dip(StackType.With) T-> OpSig.Apply
}

def elab-label-pop-r-sig! [ +Mirth |- Label -- OpSig ] {
    dip(StackType.Fresh! Resource.Fresh! dup2)
    StackType.WithLabel dip(StackType.With) swap T-> OpSig.Apply
}

def elab-arrow! [ +Mirth |- Ctx ArrowType Token Home -- Arrow ] {
    dip2(/ArrowType dom> cod>) elab-arrow-hom!
}

def elab-arrow-hom! [ +Mirth |- Ctx StackType StackType Token Home -- Arrow ] {
    dip2:T-> ab-build-hom!(elab-atoms!)
}

||| Elaborate match cases.
def elab-match-cases! [ +Mirth +Match |- ] {
    body rdip:lcurly? if(
        elab-match-cases-curly!,
        elab-match-cases-args!
    )
}

def elab-match-cases-curly! [ +Mirth +Match |- ] {
    body rdip:run-tokens for(
        dup rdip:lcurly?
        else("Expected a pattern match case of the form { ... -> ... }" rdip:emit-fatal-error!)
        rdip:args-1 elab-match-case!
        drop
    )
}

def elab-match-cases-args! [ +Mirth +Match |- ] {
    body while(dup rdip:args-end? not, elab-match-case!) drop
}

||| Elaborate match case based on starting token.
def elab-match-case! [ Token +Mirth +Match |- ] {
    dup rdip:run-arrow? unwrap("Expected pattern match case ... -> ..." rdip:emit-fatal-error!)
    dup2 = then("expected pattern" emit-fatal-error!)
    dup2 prev = else("multi-part pattern not supported" emit-fatal-error!)
    dip:pat-tokens sip:prev succ +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup rdip:comma? then(succ)
    )
}

def elab-pattern! [ +Mirth +Pattern |- List(Token) -- ] {
    reverse-for(elab-pattern-atom!)
}

def elab-pattern-atom! [ +Mirth +Pattern |- Token -- ] {
    dup pattern:token-start!
    dup rdip:error-token!

    dup rdip:pat-underscore? if(
        drop +Pattern.underscore!,

    dup rdip:name/dname? if?(
        >name/dname >token
        "constructor" >sort
        pattern mid rdip:top-types-are-fine? not >report-ambiguous-as-warning
        False >ignore-last-name
        >+pat resolve-def(
            filter(dup tag? some?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            @+pat:pattern mid rdip:top-types-are-fine? then(
                @+pat:pattern mid rdip:top-namespaces
                token rdip:name? if(
                    filter(dup2 rdip:qname-hard namespace swap member, RejectedDef.WrongConstructor) drop,
                    filter-roots
                )
            )
        ) +pat> bind(tag?) match(
            Some -> +Pattern.tag!,
            None -> StackType.Error pattern:mid!
        ),

        "Expected constructor name." rdip:emit-fatal-error!
    ))
}

def +Match.case!(mkpat,mkbod) [
    +Mirth |- (*a +Pattern -- *b +Pattern, *b +AB -- *c +AB) *a Token Token +Match -- *c +Match
] {
    dip(
        +Match.home >home dup >token-start >token-end
        +Match.ctx dup >outer-ctx >inner-ctx
        L0 >saved +Match.dom dup >mid >cod L0 >atoms
        Pattern rdip(thaw mkpat freeze) >pattern
    )
    @pattern inner-ctx
    @pattern Pattern.dom +Match.cod T->
    rotl
    +Match.home
    ldip:rdip(ab-build-hom!(dip(mkbod)))
    >body Case add-case
}

def elab-expand-tensor! [ +Mirth StackType |- Token -- Type Token ] {
    >tok force-cons?! match(
        Some -> unpack2 tok>,
        None -> StackType.Error Type.Error tok> dup "expected tuple type" emit-error!
    )
}

def elab-lambda-param? [ +Mirth Token |- Maybe(Var) ] {
    dup pattern-var? if?(
        dip(dup args-0 next)
        dip(Type.Fresh!)
        Var.New! Some,

    dup pattern-auto-run-var? if?(
        dip(dup succ args-0 next)
        dip(ArrowType.Fresh!)
        Var.NewAutoRun! Some,

        None
    ))
}

def elab-atom-lambda! [ +Mirth +AB |- ] {
    ab-token@ rdip:args-1
    collect(rdip:elab-lambda-param?)
    dip(rdip:expect-token-arrow succ)
    StackType.Fresh!
    ab-lambda-at!(elab-atoms!)
}

||| Check that a match is exhaustive.
def elab-match-exhaustive! [ +Mirth +Match |- ] {
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw
}

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def elab-module! [ +World +Mirth Module |- ] {
    dup start
    elab-module-header!
    over Namespace.Module PropLabel.DefiningNamespace prop Some with-defining-namespace (
        elab-decls!
        dup module-end? else(
            "Unexpected token in module." emit-fatal-error!
        )
    )
    drop
}

def elab-module-qname [ +Mirth |- Token -- QName ] {
    parse-module-package-name! dip(Namespace.Package) 0 QName.Mk
}

struct ModuleHeader {
    doc: Maybe(Str)
    package: Package
    name: Name
    head: Token
    imports: List(ModuleImport)
}

||| Parse the `module` declaration at the top of the module:
|||
|||     module(ModuleName)
|||     module ModuleName
|||
def parse-module-header! [ +Mirth Token |- ModuleHeader ] {
    dup doc >doc
    dup error-token!
    dup module-header? else("Expected module header." emit-fatal-error!)
    dup num-args 0> if (
        sip(next) args-1 >head
        @head parse-module-package-name! >name >package
        @head next dup arg-end? else("Expected end of argument." emit-fatal-error!) drop,

        succ >head
        @head parse-module-package-name! >name >package
        @head next
    )
    L0 >imports
    while(dup module-import?, parse-module-import @imports:cons)
    @imports:reverse
    dup sig-dashes? then(succ)
    ModuleHeader
}

||| Parse a ModuleName.
def parse-module-package-name! [ +Mirth |- Token -- Package Name ] {
    dup name/dname? else("Expected module name." emit-fatal-error!)
    dup dname? unwrap("Invalid module name: Module name must include package, for example \"package.module\"" emit-fatal-error!) over args-0
    dup root? unwrap(drop "Invalid module name: Package name is missing." emit-fatal-error!)
    swap parts single? unwrap(drop "Expected module name. (3)" emit-fatal-error!)
    dip(Package.Find-Or-New! nip)
}

||| Elaborate the module header and save the name and package.
def elab-module-header! [ +World +Mirth Token |- ] {
    dup .module >module
    parse-module-header! /ModuleHeader
    name> @module name!
    doc> @module doc!
    package> @module package!
    @module qname defined-soft? then(@head "Module name already taken." emit-fatal-error!)
    head> @module head!
    @module Def.Module register
    dup module> check-module-path
    imports> for(process-module-import!)
}

def check-module-path [ +World +Mirth |- Token Module -- ] {
    dup path rdip:split-last match(
        None ->
            swap qname to-module-path dup2 = else(
                "Expected module name to match path.\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
            ) drop3,

        Some ->
            split-last-byte(Byte.BDOT =) "mth" Some =
            else(over3 "Expected .mth extension for mirth file." emit-warning!)
            over2 name >Str = else(over2 .module .head "Expected module name to match file name." emit-fatal-error!)
            over package try-path! drop2
    )
}

||| Elaborate a series of declarations. Decl*
def elab-decls! [ +World +Mirth Token |- ] {
    while(dup arg-end? not over module-end? not and, elab-decl!)
}

||| Elaborate either a single declaration or a block of declarations:
|||
|||     Decl
|||     { Decl* }
def elab-decl-or-decl-block! [ +World +Mirth Token |- ] {
    dup lcurly? if(
        elab-decl-block!,
        elab-decl!
    )
}

||| Elaborate a declaration block.
|||
|||     { Decl* }
def elab-decl-block! [ +World +Mirth Token |- ] {
    dup lcurly? else("Expected { ... }" emit-fatal-error!) succ
    elab-decls!
    dup rcurly? else("Expected end of declaration block." emit-fatal-error!)
    succ
}

||| Skip a declaration block without elaborating it.
||| The contents of the block aren't even parsed so this can
||| be used for conditional compilation across versions.
|||
|||     { ... }
def skip-decl-block! [ +Mirth Token |- ] {
    dup lcurly? else("Expected { ... }" emit-fatal-error!) next
}

||| Elaborate a declaration. Returns the next token.
def elab-decl! [ +World +Mirth Token |- ] {
    dup error-token!
    dup name? unwrap("unknown declaration" emit-fatal-error!)
    defs find-some(macro? bind(action decl?))
    unwrap("unknown declaration" emit-fatal-error!) run
}

def load-module [ +World +Mirth Token |- QName -- Module ] {
    dup def-soft? match(
        Some -> module? unwrap(drop "module name already taken" emit-fatal-error!) nip,
        None ->
            to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
                #    https://github.com/mirth-lang/mirth/issues/241
    )
}

struct ModuleImport {
    name: Token
}

||| Parse a module import statement. Return token after import.
|||
|||     import(ModuleName)
|||     import ModuleName
def parse-module-import [ +Mirth Token |- ModuleImport ] {
    dup module-import? else("Expected import statement." emit-fatal-error!)
    dup num-args 0> if(
        sip(next) args-1 >name
        @name succ arg-end? else(@name succ "expected arg end" emit-fatal-error!),
        succ dup >name next
    )
    ModuleImport
}

||| Process a module import statement.
def process-module-import! [ +World +Mirth |- ModuleImport -- ] {
    /ModuleImport
    name> dup with-error-token(dup elab-module-qname load-module)
    swap module sip(imports swap List.Snoc) imports!
}

def expect-token-arrow [ +Mirth Token |- ] {
    dup arrow? else("Expected arrow." emit-fatal-error!)
}

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def elab-def-missing! [ +Mirth Token |- ] {
    dup args len 3u < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined-hard? if(next, elab-def!)
}

def +Mirth.with-inline(f) [ +Mirth |- (*a -- *b) *a Bool -- *b ] {
    prefer-inline-defs:swap
    dip(f) prefer-inline-defs!
}

||| Mark the following definition(s) as inline.
|||
|||     inline Decl
|||     inline ( Decl* )
|||     inline { Decl* }
def elab-inline! [ +World +Mirth Token |- ] {
    True with-inline(
        dup num-args 0> if(
            sip:next args-1 elab-decls! drop,
            succ elab-decl-or-decl-block!
        )
    )
}

||| Elaborate a patch declaration. This is a way to add definitions in a
||| particular namespace.
|||
|||     patch Namespace { Decl* }
def elab-patch! [ +World +Mirth Token |- ] {
    dup args-0
    succ dup args-0
    dup name/dname? else?("Expected a type constructor." emit-fatal-error!)
    dip:dup PropLabel.DefiningNamespace prop2(
        >name/dname
        False >ignore-last-name
        dup resolve-def-namespace
        else?("Cannot compute patch namespace." emit-fatal-error!)
        nip
    ) Some with-defining-namespace (
        succ elab-decl-block!
    )
}

||| Elaborate max-mirth-revision block. This will skip a
||| declaration block if mirth-revision is too high.
|||
|||     max-mirth-revision Int { Decl* }
def elab-max-mirth-revision! [ +World +Mirth Token |- ] {
    dup args-0
    succ dup int? else?("Expected a revision number." emit-fatal-error!)
    mirth-revision >= if(
        succ elab-decl-block!,
        succ skip-decl-block!
    )
}

||| Elaborate min-mirth-revision block. This will skip a
||| declaration block if mirth-revision is too low.
|||
|||     min-mirth-revision Int { Decl* }
def elab-min-mirth-revision! [ +World +Mirth Token |- ] {
    dup args-0
    succ dup int? else?("Expected a revision number." emit-fatal-error!)
    mirth-revision <= if(
        succ elab-decl-block!,
        succ skip-decl-block!
    )
}

struct SyntaxDef {
    doc:  Maybe(Str)
    head: Token
    sig?: Maybe(Token)
    body: Token
}

||| Parse a word definition. It looks like one of these:
|||
|||     def(word, sig, body...)
|||     def word [ sig ] { body... }
|||     def word { body... }
|||
||| Returns the next token after the definition.
def parse-def [ +Mirth Token |- SyntaxDef ] {
    dup error-token!
    dup doc >doc
    dup args empty? if(
        next
        dup >head next
        dup lsquare? if(dup args-1 Some >sig? next, None >sig?)
        dup lcurly? else("expected { ... }" emit-fatal-error!)
        dup args+ >body
        next,

        sip(next)
        dup args dup len 3u <
            then(drop
                 "def(...) expects at least three arguments"
                 emit-fatal-error!)
            nip
        >Nest? unwrap(impossible!) uncons dip(>head)
        >Nest? unwrap(impossible!) uncons dip(Some >sig?)
        >Nest? unwrap(impossible!) >body

        @head next arg-end? else(
            @head next "expected comma after word name" emit-fatal-error!
        )
    )
    body> uncons empty? or(dup run-arrow? >Bool)
        else("expected match case" emit-fatal-error!) >body
    SyntaxDef
}

||| Elaborate a word definition.
def elab-def! [ +Mirth Token |- ] {
    parse-def /SyntaxDef
    elab-def-head Word.New! >word
    @word PropLabel.WordQName >label Prop @word ~qname !

    prefer-inline-defs @word prefer-inline?!

    @word @word PropLabel.WordType prop(
        dup sig? match(
            Some ->
                nip
                +TypeElab.Start!
                T0 elab-type-sig!
                dip:ctx pack2
                +TypeElab.rdrop,
            None ->
                arrow ctx-type pack2
        )
    ) @word ~ctx-type !
    @word @word PropLabel.WordParams prop(elab-def-params!) @word ~params !
    @word @word PropLabel.WordArrow prop(
        dup dup ab-build-word-arrow!(
            swap rdip:params dup empty? if(
                drop elab-def-body!,
                map(.var) over ab-lambda!(elab-def-body!)
            )
        ) tuck check-inline-recursion-arrow!
    ) @word ~arrow !
    word> drop
}

def check-inline-recursion-arrow! [ +Mirth |- Word Arrow -- ] {
    atoms for(dip:dup check-inline-recursion-atom!) drop
}
def check-inline-recursion-atom! [ +Mirth |- Word Atom -- ] {
    over prefer-inline? if(
        dup2 op check-inline-recursion-op!
        args for(dip:dup check-inline-recursion-arg!) drop,
        drop2
    )
}
def check-inline-recursion-arg! [ +Mirth |- Word Arg -- ] {
    Block -> arrow check-inline-recursion-arrow!
}
def check-inline-recursion-op! [ +Mirth |- Word Op -- ] {
    BlockRun -> arrow check-inline-recursion-arrow!,
    Word ->
        dup2 = if(
            drop check-inline-recursion-failed!,
            dup prefer-inline? if(
                ~arrow try-force! if?(
                    check-inline-recursion-arrow!,
                    check-inline-recursion-failed!
                ),
                drop2
            )
        ),
    Match -> cases for(dip:dup body check-inline-recursion-arrow!) drop,
    Lambda -> body check-inline-recursion-arrow!,
    _ -> drop2
}
def check-inline-recursion-failed! [ +Mirth |- Word -- ] {
    dup prefer-inline? if(
        False over prefer-inline?!
        head "recursive word cannot be inlined" emit-warning!,
        drop
    )
}

||| Elaborate a word's parameters from its type and declaration.
def elab-def-params! [ +Mirth |- Word -- List(Param) ] {
    L0 over type
    rotl head dip(/ArrowType dom> cod>) nip
    args reverse-for(
        dup sig-param-name? unwrap("expected parameter name" emit-fatal-error!) >name
        dup succ dup run-end? if(
            drop None >default,
            dup lcurly? if(
                dup succ Some >default
                next dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!),

                "expected right paren, left curly, or comma" emit-fatal-error!
            )
        )
        elab-expand-tensor!
        swap arrow? unwrap("need function type for param" emit-fatal-error!)
        nip name> Var.NewAutoRun! >var Param
        rotr dip:cons
    ) drop
}

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def elab-def-body! [ +Mirth +AB |- StackType -- StackType ] {
    ab-token@ rdip:run-arrow? or(ab-token@ rdip:lcurly? some?) if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    )
}


||| Create entry point based on word name.
def elab-entry-point [ +Mirth |- QName -- Arrow ] {
    dup def-hard? bind(word?) unwrap(
        dup namespace module? for(start error-token!)
        str("Can't find entry point "; qname;)
        fatal-error!
    ) nip { Word +Mirth }
    dup dip(Ctx.L0 T0 Resource.World T+ T0 Resource.World T+ T->)
    head dup Home.Main ab-build-hom!(
        dip(L0 swap ab-word!)
    )
}

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def elab-embed-str! [ +World +Mirth Token |- ] {
    dup doc >doc
    sip:next args-2 swap
    >head elab-def-head
    @arity 0= else(@head "expected no arguments" emit-fatal-error!)
    dup >body None >sig?
    dup str? unwrap("expected source path" emit-fatal-error!)
    >Path >+mirth open-file! +else(+mirth> io-error!) read-file! close-file! then?(+mirth> io-error!) nip >contents +mirth>
    Word.New!
    dup PropLabel.WordQName >label Prop over ~qname !

    Ctx.L0 T0 Type.Str T1 T-> over2 PropLabel.WordType prop2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop
}

||| Ensure that everything so far has been typechecked.
def typecheck-everything! [ +Mirth |- ] {
    Name.for(defs for(dup qname-hard drop typecheck!))
    Block.for(typecheck!)
    External.for(ctype drop)
}

def resolve-def-namespace [ +Mirth |- Token name/dname:Name/DName ignore-last-name:Bool -- Maybe(Namespace) ] {
    >token
    "namespace" >sort
    False >report-ambiguous-as-warning
    resolve-def(
        filter-sort(dup rdip:as-def-namespace? >Bool)
        filter-qualifiers
        L0 filter-roots
    )
    bind(as-def-namespace?)
}

def elab-qname-from-nonrelative-dname [ +Mirth |- Token DName arity:Int -- QName ] {
    dup Right >name/dname
    dup root? else(drop "relative name not allowed" emit-fatal-error!)
    last-name >name
    True >ignore-last-name
    dup resolve-def-namespace unwrap(panic-diagnostics!) >namespace
    drop QName
}

def module-visible-from-token? [ +Mirth |- Token Module -- Bool ] {
    swap .module visible
}

def def-visible-from-token? [ +Mirth |- Token Def -- Bool ] {
    defining-module? match(
        None -> drop True,
        Some -> module-visible-from-token?
    )
}

def Token.is-default-param? [ +Mirth |- Token -- Bool ] {
    dup name? and( dup succ lcurly? >Bool ) nip
}

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def elab-def-qname [ +Mirth |- Token -- QName ] {
    dup args dup has(is-default-param?) if(drop -1, len >Int) >arity
    dup name/dname? unwrap("expected name" emit-fatal-error!)
    match(
        Left -> >name defining-namespace-or-error >namespace QName,
        Right -> elab-qname-from-nonrelative-dname
    )
}

||| The namespace for definitions by default.
def defining-namespace-or-error [ +Mirth |- Token -- Namespace ] {
    lexical-state defining-namespace(
        unwrap("error: no namespace for definition" emit-fatal-error!)
        compute Some
    ) lexical-state!
    unwrap("error: couldn't compute namespace for definition" emit-fatal-error!)
    nip
}

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def elab-def-qname-undefined [ +Mirth |- Token -- QName ] {
    dup elab-def-qname
    dup defined-soft? then(drop "name already defined" emit-fatal-error!)
    nip
}

||| Elaborate the head, i.e. the name-giving token, of a definition.
||| We defer the full resolution of the qualified name, but otherwise
||| we collect arity and (simple) name data from the head token.
def elab-def-head [ +Mirth head:Token |- name:Name arity:Nat state:PropState(QName) ] {
    @head name/dname?
        unwrap(@head "expected name" emit-fatal-error!)
        either(id, parts last) >name
    @head num-args >arity
    lexical-state @head [ elab-def-qname-undefined ] PropState.Delay >state
}
