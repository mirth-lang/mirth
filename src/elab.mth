module(mirth.elab)

import(std.prelude)
import(std.str)
import(std.list)
import(std.maybe)
import(std.either)
import(std.path)
import(std.byte)
import(std.posix)
import(std.file)

import(mirth.mirth)
import(mirth.name)
import(mirth.def)
import(mirth.token)
import(mirth.data)
import(mirth.external)
import(mirth.word)
import(mirth.var)
import(mirth.buffer)
import(mirth.variable)
import(mirth.table)
import(mirth.tycon)
import(mirth.type)
import(mirth.typedef)
import(mirth.var)
import(mirth.arrow)
import(mirth.word)
import(mirth.prim)
import(mirth.module)
import(mirth.package)
import(mirth.alias)
import(mirth.match)
import(mirth.lexer)
import(mirth.label)

####################
# Type Elaboration #
####################

data(+TypeElab, TYPE_ELAB ->
    ctx:Ctx token:Token
    allow-type-holes:Bool
    allow-implicit-type-vars:Bool)

def(+TypeElab.type-sig-start!, Token -- +TypeElab,
    >token
    Ctx0 >ctx
    False >allow-type-holes
    True >allow-implicit-type-vars
    TYPE_ELAB)

def(+TypeElab.rdrop, +TypeElab --,
    /TYPE_ELAB
    ctx> token> drop2
    allow-type-holes> drop
    allow-implicit-type-vars> drop)

def(+TypeElab.elab-type-sig!, +Mirth +TypeElab -- +Mirth +TypeElab ArrowType,
    token run-end? then(token "expected type signature" rdip:emit-error!)
    elab-type-sig-params!
    elab-stack-type!
    token sig-dashes? if(token:succ elab-stack-type!, dip:T0)
    token run-end? else(token "expected right paren or comma" rdip:emit-error!)
    dip(swap for(T*)) T->)

def(+TypeElab.elab-type-sig-params!, +Mirth +TypeElab -- +Mirth +TypeElab List(Type),
    token lparen? if(
        token next
        token args map(token! elab-type-sig! TMorphism)
        dip:token!,
        L0
    ))

def(+TypeElab.elab-stack-type!, +Mirth +TypeElab -- +Mirth +TypeElab StackType,
    token sig-stack-var? if(elab-stack-type-var!, T0)
    elab-stack-type-parts!)

def(+TypeElab.elab-stack-type-parts!, +Mirth +TypeElab StackType -- +Mirth +TypeElab StackType,
    while(token sig-stack-end? not, elab-stack-type-part! cons))

def(+TypeElab.elab-type-arg!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    token elab-stack-type-part!
    match(
        STPCons -> nip,
        STPConsLabel -> drop2 "Expected type, not label." rdip:emit-error! TYPE_ERROR,
        STPWith -> drop "Expected type, not resource." rdip:emit-error! TYPE_ERROR,
        STPWithLabel -> drop2 "Expected type, not labelled resource." rdip:emit-error! TYPE_ERROR,
    )
    token arg-end? else(
        token "Unexpected token after type." rdip:emit-error!
    ))

def(+TypeElab.elab-resource-arg!, +Mirth +TypeElab -- +Mirth +TypeElab Resource,
    token elab-stack-type-part!
    match(
        STPCons -> drop "Expected resource, not type." rdip:emit-error! TYPE_ERROR RESOURCE,
        STPConsLabel -> drop2 "Expected resource, not label." rdip:emit-error! TYPE_ERROR RESOURCE,
        STPWith -> nip,
        STPWithLabel -> drop2 "Expected resource, not label." rdip:emit-error! TYPE_ERROR RESOURCE,
    )
    token arg-end? else(
        token "Unexpected token after resource." rdip:emit-error!
    ))

def(+TypeElab.elab-stack-type-part!, +Mirth +TypeElab -- +Mirth +TypeElab StackTypePart,
    token could-be-sig-label? if(
        elab-stack-label!,

    token sig-type-var? if(
        elab-type-var! STPCons,

    token sig-type-con? if(
        elab-type-con! STPCons,

    token sig-resource-var? if(
        elab-resource-var! STPWith,

    token sig-resource-con? if(
        elab-resource-con! STPWith,

    token pat-underscore? if(
        elab-type-dont-care! STPCons,

    token sig-type-hole? if(
        elab-type-hole! STPCons,

    token lsquare? .if(
        elab-type-quote! STPCons,

        token "Expected type, got unknown token." rdip:emit-error!
        token:next TYPE_ERROR STPCons
    )))))))))

def(+TypeElab.elab-stack-label!, +Mirth +TypeElab -- +Mirth +TypeElab StackTypePart,
    token next dip(
        token name? unwrap Label.new!
        token:args-1 dup is-resource-label? if(
            elab-resource-arg! swap STPWithLabel,
            elab-type-arg! swap STPConsLabel
        )
    ) token!)

def(+TypeElab.elab-stack-type-var!, +Mirth +TypeElab -- +Mirth +TypeElab StackType,
    TYPE_STACK elab-implicit-var! if-some(STVar, STACK_TYPE_ERROR))

def(+TypeElab.elab-type-var!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    TYPE_TYPE elab-implicit-var! if-some(TVar, TYPE_ERROR))

def(+TypeElab.elab-resource-var!, +Mirth +TypeElab -- +Mirth +TypeElab Resource,
    TYPE_RESOURCE elab-implicit-var! if-some(TVar, TYPE_ERROR) RESOURCE)

def(+TypeElab.gamma(f), (*a +Gamma -- *b +Gamma) *a +TypeElab -- *b +TypeElab,
    token rdip(>token +Gamma f rdrop))

def(+TypeElab.elab-implicit-var!, +Mirth +TypeElab Type -- +Mirth +TypeElab Maybe(Var),
    token name? unwrap dup ctx lookup match(
        Some -> sip(nip type gamma:unify! drop) Some,
        None ->
            allow-implicit-type-vars if(
                Var.new! ctx(over Ctx.new) Some,
                token "Implicit type variable not allowed here." rdip:emit-error!
                drop2 None
            )
    )
    token rdip:args-0
    token:succ)

def(show-num-arguments, Int -- Str,
    dup 1 == if(drop "1 argument",
    show " arguments" cat))

data(+ResolveDef, RESOLVE_DEF ->
    sort: Str
    token: Token
    candidates: List(Def)
    rejected: List(RejectedDef)
    report-ambiguous-as-warning: Bool)

def(+ResolveDef.filter(p),
        (*a Def +ResolveDef -- *a Either(RejectedDef, Def) +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef,
    candidates partition-either(p) dip:rejected:cat candidates!)

def(+ResolveDef.filter(p,q),
        (*a Def +ResolveDef -- *a Def Bool +ResolveDef,
         *a Def +ResolveDef -- *a RejectedDef +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef,
    filter(p if(Right, q Left)))

data(RejectedDef,
    RD_WRONG_SORT -> Def,
    RD_WRONG_ARITY -> Def,
    RD_NOT_VISIBLE -> Def,
    RD_NOT_IMPORTED -> Def,
    RD_WRONG_QUALIFIER -> Def,
    RD_WRONG_CONSTRUCTOR -> Def,
    RD_METHOD_NOT_AVAILABLE -> Def,
    RD_METHOD_WRONG_TYPE -> Def)

def(resolve-def(f), (*a +Mirth +ResolveDef -- *b +Mirth +ResolveDef)
        *a +Mirth sort:Str token:Token report-ambiguous-as-warning:Bool
        -- *b +Mirth Maybe(Def),
    @token last-name? unwrap defs >candidates
    L0 >rejected
    RESOLVE_DEF
    f
    candidates match(
        Nil -> resolve-def-unknown None,
        Cons -> match(
            Nil -> rdrop Some,
            _ -> List.filter(dup2 rdip:same-resolved? not) match(
                Nil -> rdrop Some,
                _ -> drop2 resolve-def-ambiguous None
            )
        )
    ))

def(+ResolveDef.rdrop, +ResolveDef --,
    /RESOLVE_DEF
    sort> token> drop2
    candidates> rejected> drop2
    report-ambiguous-as-warning> drop)

def(+ResolveDef.resolve-def-ambiguous, +Mirth +ResolveDef -- +Mirth,
    report-ambiguous-as-warning if(
        token Str(
            "Can't resolve " ; rdip:sort ; " due to previous errors. Candidates are:" ;
            " " rdip:candidates for(swap ; rdip2(qname >Str) ; ", ") drop
        ) rdip:emit-warning!,

        token Str(
            "Ambiguous " ; rdip:sort ; ". Can't decide between:" ;
            " " rdip:candidates for(swap ; rdip2(qname >Str) ; ", ") drop
        ) rdip:emit-error!
    ) rdrop)
def(+ResolveDef.resolve-def-unknown, +Mirth +ResolveDef -- +Mirth,
    token Str(rdip:rejected match(
        Nil -> "Unknown " ; rdip:sort ; " name, possibly a misspelling." ;,
        Cons ->
            match(
                Nil -> match(
                    RD_WRONG_SORT ->
                        "Expected a " ; rdip:sort ; ", but " ;
                        rdip2(qname >Str) ; " is not a " ; rdip:sort ; "." ; ,
                    RD_NOT_VISIBLE ->
                        "Not visible in current scope: " ; rdip2(qname >Str) ; ,
                    RD_NOT_IMPORTED ->
                        "Not imported in current scope: " ; rdip2(qname >Str) ; ,
                    RD_WRONG_ARITY ->
                        rdip2(qname dup >Str) ; " expects " ; arity show;
                        " arguments, but got " ; rdip:token num-args show; "." ; ,
                    RD_WRONG_QUALIFIER ->
                        "Qualified name not found. Perhaps you meant: " ; rdip2(qname >Str) ; ,
                    RD_WRONG_CONSTRUCTOR ->
                        "Constructor is for a different type: " ; rdip2(qname >Str) ; ,
                    RD_METHOD_WRONG_TYPE ->
                        "Method is for a different type: " ; rdip2(qname >Str) ; ,
                    RD_METHOD_NOT_AVAILABLE ->
                        "Method is not available for current stack: " ; rdip2(qname >Str) ; ,
                ),
                _ -> Cons "Multiple definitions for name, but none are suitable:" ;
                    dip:" " for(swap ; match(
                        RD_WRONG_SORT -> rdip2(qname >Str) ; " is not a " ; rdip:sort ; ,
                        RD_NOT_VISIBLE ->
                            rdip2(qname >Str) ; " is not visible in current scope" ; ,
                        RD_NOT_IMPORTED ->
                            rdip2(qname >Str) ; " is not imported in current scope" ; ,
                        RD_WRONG_ARITY ->
                            rdip2(qname dup >Str) ; " expects " ;
                            arity show; " arguments" ; ,
                        RD_WRONG_QUALIFIER ->
                            rdip2(qname >Str) ; " doesn't match the given qualified name" ; ,
                        RD_WRONG_CONSTRUCTOR ->
                            rdip2(qname >Str) ; " is constructor for a different type" ; ,
                        RD_METHOD_WRONG_TYPE ->
                            rdip2(qname >Str) ; " is method for a different type" ; ,
                        RD_METHOD_NOT_AVAILABLE ->
                            rdip2(qname >Str) ; " is not avaliable for current stack" ; ,
                    ) ", ") drop
            )
    )) rdip:emit-error! rdrop)

def(+ResolveDef.filter-sort(p),
        (*a Def +ResolveDef -- *a Def Bool +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef,
    filter(p, RD_WRONG_SORT))
def(+ResolveDef.filter-arity, +Mirth +ResolveDef -- +Mirth +ResolveDef,
    token num-args filter(
        dup2 rdip:qname arity arity-compatible?,
        RD_WRONG_ARITY
    ) drop)
def(+ResolveDef.filter-visible, +ResolveDef -- +ResolveDef,
    filter(token over def-visible-from-token?, RD_NOT_VISIBLE))

def(+ResolveDef.filter-qualifiers, +Mirth +ResolveDef -- +Mirth +ResolveDef,
    token dname? for(
        filter(dup2 rdip(qname climb-up-dname?) some?, RD_WRONG_QUALIFIER)
        drop
    ))

def(+ResolveDef.filter-roots, List(Namespace) +Mirth +ResolveDef -- +Mirth +ResolveDef,
    token name? then(
        filter(
            dup2 rdip:qname namespace swap member(==)
            or(token over rdip:def-is-imported-at-token?),
            dup rdip:qname namespace match(
                NAMESPACE_TYCON ->
                    drop token name? unwrap can-be-relative? if(
                        over empty? if(
                            RD_METHOD_NOT_AVAILABLE,
                            RD_METHOD_WRONG_TYPE
                        ),
                        RD_NOT_IMPORTED
                    ),
                _ -> drop RD_NOT_IMPORTED
            )
        )
    )
    token dname? for(
        dup is-relative? if(
            filter(dup2 rdip(qname climb-up-dname?) and-some(over3 member(==)),
                over2 empty? if(
                    RD_METHOD_NOT_AVAILABLE,
                    RD_METHOD_WRONG_TYPE
                )
            ),
            filter(dup2 rdip(qname climb-up-dname?) and-some(
                token swap rdip:namespace-is-imported-at-token?
            ), RD_NOT_IMPORTED)
        ) drop
    )
    drop)

||| Check whether a definition can be referred to without qualification.
def(def-is-imported-at-token?, +Mirth Token Def -- +Mirth Bool,
    # TODO: implement finer grained control over what is imported.
    #   https://github.com/mirth-lang/mirth/issues/243
    dup qname namespace match(
        NAMESPACE_ROOT -> drop2 True,
        NAMESPACE_PACKAGE -> drop3 True,
        NAMESPACE_MODULE -> nip module-visible-from-token?,
        NAMESPACE_TYCON -> dip:swap tycon-is-visible-at-token? if(tag? >Bool, drop False),
        NAMESPACE_WORD -> drop3 False
    ))

def(tycon-is-visible-at-token?, Token Tycon -- Bool,
    TYCON_DATA -> head? if-some(.module module-visible-from-token?, drop True),
    TYCON_TABLE -> head .module module-visible-from-token?,
    TYCON_PRIM -> drop2 True)

def(namespace-is-imported-at-token?, +Mirth Token Namespace -- +Mirth Bool,
    NAMESPACE_ROOT -> drop True,
    NAMESPACE_PACKAGE -> drop2 True,
    NAMESPACE_MODULE -> module-visible-from-token?,
    NAMESPACE_TYCON -> qname namespace namespace-is-imported-at-token?,
    NAMESPACE_WORD -> drop2 False)

def(QName.climb-up-name?, Name QName -- Maybe(Namespace),
    tuck name == if(
        namespace Some,
        drop None
    ))

def(QName.climb-up-dname?, +Mirth DName QName -- +Mirth Maybe(Namespace),
    dip(sip(root? >List) parts unsnoc dip(cat))
    climb-up-name? swap
    reverse-for(swap bind(qname) match(
        Some -> climb-up-name?,
        None -> drop None
    )))

def(+TypeElab.resolve-type-con-name!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    False >report-ambiguous-as-warning
    token >token "type" >sort rdip:resolve-def(
        filter(dup rdip:defines-a-type?, RD_WRONG_SORT)
        filter-arity
        filter-visible
        filter-qualifiers
        L0 filter-roots
    ) map:match(
        DefData -> TData,
        DefTable -> TTable,
        DefType -> target,
        _ ->
            drop token "compiler bug: resolve-type-con-name! doesn't understand type"
            rdip:emit-error! TYPE_ERROR,
    ) unwrap-or(TYPE_ERROR))

def(+TypeElab.elab-type-con!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    token name? and-some(>Str "Mut" ==) if(
        token next dip(
            token:args-1
            elab-type-arg!
            TMut
        ) token!,

        resolve-type-con-name! elab-type-args!
        token:next
    ))

def(+TypeElab.elab-resource-con!, +Mirth +TypeElab -- +Mirth +TypeElab Resource,
    elab-type-con! RESOURCE)

def(+TypeElab.elab-type-args!, +Mirth +TypeElab Type -- +Mirth +TypeElab Type,
    token has-args? if(
        token dip(
            token args for(
                token!
                elab-type-arg! TApp
            )
        ) token!,

        id
    ))

def(+TypeElab.elab-type-hole!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    allow-type-holes if(
        token rdip:args-0
        token name? unwrap THole,
        token "type holes are not allowed here" rdip:emit-error!
        TYPE_ERROR
    )
    token:next)

def(+TypeElab.elab-type-dont-care!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    allow-type-holes if(
        token rdip:args-0
        TYPE_DONT_CARE,
        token "underscore is not allowed here" rdip:emit-error!
        TYPE_ERROR
    )
    token:next)

def(+TypeElab.elab-type-quote!, +Mirth +TypeElab -- +Mirth +TypeElab Type,
    token next dip(
        token:args-1
        token sig-has-dashes? if(
            elab-type-sig! >Type,
            elab-stack-type! >Type
        )
    ) token!)

def(elab-type-unify!, +Mirth Type Type Token -- +Mirth Type Token,
    >token +Gamma unify! /+Gamma token>)
def(elab-stack-type-unify!, +Mirth StackType StackType Token -- +Mirth StackType Token,
    >token +Gamma unify! /+Gamma token>)

def(elab-simple-type-arg!, +Mirth Token -- +Mirth Type,
    >token
    Ctx0 >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    TYPE_ELAB elab-type-arg! rdrop)

####################
# Word Elaboration #
####################

data(+AB, MKAB -> arrow:Arrow)
def(ab-arrow@, +AB -- +AB Arrow, arrow)
def(ab-token@, +AB -- +AB Token, arrow token-end)
def(ab-token!, +AB Token -- +AB, arrow:token-end!)
def(ab-type@, +AB -- +AB StackType, arrow cod)
def(ab-type!, +AB StackType -- +AB, arrow:cod!)
def(ab-ctx@, +AB -- +AB Ctx, arrow ctx)
def(ab-home@, +AB -- +AB Home, arrow home)

def(+AB.gamma(f), (*a +Gamma -- *b +Gamma) *a +AB -- *b +AB,
    ab-token@ rdip(>token +Gamma f rdrop))

def(ab-build!(f), (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow,
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx L0 >atoms
    Arrow >arrow MKAB
    f /MKAB arrow>)

||| Like ab-build! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def(ab-build-hom!(f), (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
        *a Ctx ArrowType Token Home +Mirth -- *b Arrow +Mirth,
    dip2(unpack rotr)
    ab-build!(f ab-unify-type!))
def(ab-build-word-arrow!(f), (*a StackType +Mirth +AB -- *b StackType +Mirth +AB) *a Word +Mirth -- *b Arrow +Mirth,
    sip(ctx-type) sip(body) HomeWord ab-build-hom!(f))
def(ab-build-word!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a Word +Mirth -- *b Word +Mirth,
    sip(ab-build-word-arrow!(dip(f))) sip(WordArrow prop)
    tuck ~arrow !)

def(ab-unify-type!, StackType +Mirth +AB -- +Mirth +AB,
    dip:ab-type@ gamma:unify! ab-type!)

def(ab-atom!, Atom +AB -- +AB,
    dup token ab-token!
    # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
        # ^ a sanity check to make sure
        # atom dom matches ab-arrow cod
    dup cod ab-type!
    arrow:atoms(swap ab-optimized-snoc!))

||| Add an atom to a list of atoms .. smartly.
def(ab-optimized-snoc!, List(Atom) Atom -- List(Atom),
    while(dip?(atoms-has-last-block?) and(atom-accepts-args?),
        swap atoms-turn-last-block-to-arg swap)
    List.snoc)

def(atom-accepts-args?, Atom -- Atom Bool,
    dup op match(
        OpWord -> dip(dup args len >Int) arity <,
        OpPrim ->
            match(
                PRIM_CORE_DIP -> dup args len 1 >Nat <,
                PRIM_CORE_RDIP -> dup args len 1 >Nat <,
                PRIM_CORE_IF -> dup args len 2 >Nat <,
                PRIM_CORE_WHILE -> dup args len 2 >Nat <,
                _ -> drop False
            ),
        _ -> drop False
    ))

def(atoms-has-last-block?, List(Atom) -- List(Atom) Bool,
    dup last match(
        None -> False,
        Some ->
            op match(
                OpBlockPush -> drop True,
                _ -> drop False
            )
    ))

def(atoms-turn-last-block-to-arg, Atom List(Atom) -- Atom List(Atom),
   >List+ match(
        None -> L0,
        Some ->
            unsnoc dup op match(
                OpBlockPush ->
                    { Atom List(Atom) Atom Block }
                    dip(dom rotl dom!)
                    { List(Atom) Atom Block }
                    ArgBlock swap args:cons
                    swap,
                _ -> drop List.snoc
            )
    ))

def(ab-op!, Op +Mirth +AB -- +Mirth +AB,
    ab-ctx@ >ctx
    ab-token@ >token
    ab-home@ >home
    dup >op
    rdip:elab-op-fresh-sig! dip:>subst
    ab-expand-opsig! >cod >dom
    L0 >args Atom ab-atom!)

def(ab-expand-opsig!, OpSig +Mirth +AB -- StackType StackType +Mirth +AB,
    OPSIG_ID -> ab-type@ dup,
    OPSIG_PUSH -> dip(ab-type@ dup) STCons,
    OPSIG_APPLY ->
        dip(ab-type@) unpack
        dip(ab-token@ rdip:elab-stack-type-unify! drop))

def(ab-int!, Int +Mirth +AB -- +Mirth +AB, OpInt ab-op!)
def(ab-str!, Str +Mirth +AB -- +Mirth +AB, OpStr ab-op!)
def(ab-buffer!, Buffer +Mirth +AB -- +Mirth +AB, OpBuffer ab-op!)
def(ab-variable!, Variable +Mirth +AB -- +Mirth +AB, OpVariable ab-op!)
def(ab-field!, Field +Mirth +AB -- +Mirth +AB, OpField ab-op!)
def(ab-var!, Var +Mirth +AB -- +Mirth +AB, OpVar ab-op!)
def(ab-tag!, Tag +Mirth +AB -- +Mirth +AB, OpTag ab-op!)
def(ab-prim!, Prim +Mirth +AB -- +Mirth +AB,
    dup ~type mut-is-set if(
        OpPrim ab-op!,
        ab-token@ "prim does not have type" rdip:emit-fatal-error!
    ))
def(ab-word!, Word +Mirth +AB -- +Mirth +AB, OpWord ab-op!)
def(ab-external!, External +Mirth +AB -- +Mirth +AB, OpExternal ab-op!)
def(ab-coerce!, Coerce +Mirth +AB -- +Mirth +AB, OpCoerce ab-op!)
def(ab-label-push!, Label +Mirth +AB -- +Mirth +AB, OpLabelPush ab-op!)
def(ab-label-pop!, Label +Mirth +AB -- +Mirth +AB, OpLabelPop ab-op!)
def(ab-label-push-r!, Label +Mirth +AB -- +Mirth +AB, OpLabelPushR ab-op!)
def(ab-label-pop-r!, Label +Mirth +AB -- +Mirth +AB, OpLabelPopR ab-op!)

def(ab-block-at!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a Token +Mirth +AB -- *b +Mirth +AB,
    ab-ctx@ MetaVar.new! STMeta rotl ab-home@ rdip(ab-build!(f))
    rdip:Block.new! OpBlockPush ab-op!)

def(ab-block!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB,
    ab-token@ ab-block-at!(f))

def(ab-dip!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB,
    ab-block!(f) PRIM_CORE_DIP ab-prim!)

def(ab-rdip!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB,
    ab-block!(f) PRIM_CORE_RDIP ab-prim!)

def(ab-if!(f,g), (*a +Mirth +AB -- *b +Mirth +AB,
                  *b +Mirth +AB -- *c +Mirth +AB)
                  *a +Mirth +AB -- *c +Mirth +AB,
    ab-block!(f) ab-block!(g) PRIM_CORE_IF ab-prim!)

def(ab-while!(f,g), (*a +Mirth +AB -- *b +Mirth +AB,
                     *b +Mirth +AB -- *c +Mirth +AB)
                     *a +Mirth +AB -- *c +Mirth +AB,
    ab-block!(f) ab-block!(g) PRIM_CORE_WHILE ab-prim!)

def(ab-lambda!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a List(Var) +Mirth +AB -- *b +Mirth +AB,
    dip(ab-token@) ab-lambda-at!(f))
def(ab-lambda-at!(f), (*a +Mirth +AB -- *b +Mirth +AB) *a Token List(Var) +Mirth +AB -- *b +Mirth +AB,
    dup dip(
        dip(ab-ctx@ ab-type@) reverse-for(
            swap dip(dup dip(Ctx.new))
            ab-token@ rdip:elab-expand-tensor!
            dip(rotl type) rdip:elab-type-unify! drop2
        )
        rotl ab-home@ rdip(ab-build!(f))
    )
    >params >body
    ab-ctx@ >outer-ctx
    ab-type@ >dom
    ab-token@ >token
    Lambda OpLambda ab-op!)

data(OpSig,
    OPSIG_ID,
    OPSIG_PUSH -> Type,
    OPSIG_APPLY -> ArrowType)

def(elab-op-fresh-sig!, +Mirth Op -- +Mirth Subst OpSig,
    Subst.nil swap match(
        OpNone -> OPSIG_ID,
        OpInt -> VALUE_INT TValue OPSIG_PUSH,
        OpStr -> VALUE_STR TValue OPSIG_PUSH,
        OpBuffer -> drop TYPE_PTR OPSIG_PUSH,
        OpVariable -> type TMut OPSIG_PUSH,
        OpTag -> type freshen-sig OPSIG_APPLY,
        OpWord -> type freshen-sig OPSIG_APPLY,
        OpPrim -> type freshen-sig OPSIG_APPLY,
        OpExternal -> type freshen-sig OPSIG_APPLY,
        OpField -> type freshen-sig OPSIG_APPLY,
        OpBlockPush -> elab-block-sig!,
        OpBlockRun -> type semifreshen-sig OPSIG_APPLY,
        OpVar -> elab-var-sig!,
        OpMatch -> elab-match-sig!,
        OpLambda -> elab-lambda-sig!,
        OpCoerce -> elab-coerce-sig!,
        OpLabelPush -> elab-label-push-sig!,
        OpLabelPop -> elab-label-pop-sig!,
        OpLabelPushR -> elab-label-push-r-sig!,
        OpLabelPopR -> elab-label-pop-r-sig!,
        OpDataGetTag -> data-get-tag-type freshen-sig OPSIG_APPLY,
        OpDataGetLabel -> data-get-label-type freshen-sig OPSIG_APPLY,
        OpDataSetLabel -> data-set-label-type freshen-sig OPSIG_APPLY,
    ))

def(data-get-tag-type, +Mirth Data -- +Mirth ArrowType,
    full-type left? unwrap T1
    TYPE_INT T1 T->)

def(elab-coerce-sig!, Coerce -- OpSig,
    CoerceUnsafe ->
        MetaVar.new! STMeta dup
        MetaVar.new! TMeta T* swap
        MetaVar.new! TMeta T* T-> OPSIG_APPLY)

def(elab-block-sig!, Block -- OpSig,
    VALUE_BLOCK TValue OPSIG_PUSH)

def(elab-match-sig!, Match -- OpSig,
    sip(dom) cod T-> OPSIG_APPLY)

def(elab-lambda-sig!, Lambda -- OpSig,
    sip(dom) cod T-> OPSIG_APPLY)

def(elab-var-sig!, Var -- OpSig,
    dup auto-run? if(
        type morphism? unwrap semifreshen-sig OPSIG_APPLY,
        type OPSIG_PUSH
    ))

def(elab-label-push-sig!, Label -- OpSig,
    dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2)
    STConsLabel dip(STCons) T-> OPSIG_APPLY)

def(elab-label-pop-sig!, Label -- OpSig,
    dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2)
    STConsLabel dip(STCons) swap T-> OPSIG_APPLY)

def(elab-label-push-r-sig!, Label -- OpSig,
    dip(MetaVar.new! STMeta MetaVar.new! TMeta RESOURCE dup2)
    STWithLabel dip(STWith) T-> OPSIG_APPLY)

def(elab-label-pop-r-sig!, Label -- OpSig,
    dip(MetaVar.new! STMeta MetaVar.new! TMeta RESOURCE dup2)
    STWithLabel dip(STWith) swap T-> OPSIG_APPLY)

def(elab-arrow!, +Mirth Ctx ArrowType Token Home -- +Mirth Arrow,
    dip2(unpack) elab-arrow-hom!)

def(elab-arrow-hom!, +Mirth Ctx StackType StackType Token Home -- +Mirth Arrow,
    rotl dip(
        elab-arrow-fwd!
        dup token-end >token +Gamma
        dup cod
    )
    unify! rdrop drop)

def(elab-arrow-fwd!, +Mirth Ctx StackType Token Home -- +Mirth Arrow,
    ab-build!(elab-atoms!))

def(elab-atoms!, +Mirth +AB -- +Mirth +AB,
    while(
        ab-token@ run-end? not,
        elab-atom! ab-token@ next ab-token!
    ))

def(elab-atom!, +Mirth +AB -- +Mirth +AB,
    ab-token@ value match(
        TokenName -> elab-atom-name!,
        TokenDName -> elab-atom-dname!,
        TokenInt -> ab-int!,
        TokenStr -> ab-str!,
        TokenLSquare -> drop elab-atom-block!,
        TokenLCurly -> drop elab-atom-assert!,
        TokenLabelPush -> ab-token@ rdip:args-0 ab-label-push!,
        TokenLabelPop -> ab-token@ rdip:args-0 ab-label-pop!,
        TokenLabelPushR -> ab-token@ rdip:args-0 ab-label-push-r!,
        TokenLabelPopR -> ab-token@ rdip:args-0 ab-label-pop-r!,
        TokenLabelGet -> elab-label-get!,
        TokenLabelSet -> elab-label-set!,
        _ -> ab-token@ "Unexpected token in elab-atom!" rdip:emit-fatal-error!
    ))

def(elab-label-get!, Label +Mirth +AB -- +Mirth +AB,
    dup is-resource-label? if(
        dup ab-label-pop-r!
        ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
        ab-label-push-r!,

        dup ab-label-pop!
        ab-token@ num-args 0= if(
            PRIM_CORE_DUP ab-prim!,
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
        )
        ab-label-push!
    ))

def(elab-label-set!, Label +Mirth +AB -- +Mirth +AB,
    ab-token@ rdip:args-0
    dup ab-label-pop!
    PRIM_CORE_DROP ab-prim!
    ab-label-push!)

def(elab-atom-block!, +Mirth +AB -- +Mirth +AB,
    ab-token@ rdip:args-1 elab-block-at!)

def(elab-block-at!, Token +Mirth +AB -- +Mirth +AB,
    ab-ctx@ swap ab-home@ rdip:Block.new-deferred!(
        dup ctx swap
        dup dom swap
        dup cod swap
        dup token swap
        home
        elab-arrow-hom!
    ) OpBlockPush ab-op!)

def(elab-args!, +Mirth +AB -- +Mirth +AB,
    ab-token@ args for(elab-block-at!))

def(elab-no-args!, +Mirth +AB -- +Mirth +AB,
    ab-token@ rdip:args-0)

def(arity-compatible?, Int Int -- Bool,
    dup -1 == dip(==) ||)

def(elab-atom-name!, Name +Mirth +AB -- +Mirth +AB,
    ab-ctx@ lookup match(
        Some -> elab-args! ab-var!,
        None -> elab-atom-resolve-def!
    ))

def(elab-atom-dname!, DName +Mirth +AB -- +Mirth +AB,
    drop elab-atom-resolve-def!)

def(Token.can-be-relative-name-or-dname?, Token -- Bool,
    value match(
        TokenName -> can-be-relative?,
        TokenDName -> is-relative?,
        _ -> drop False
    ))

def(elab-atom-resolve-def!, +Mirth +AB -- +Mirth +AB,
    ab-type@ top-types-are-fine? not >report-ambiguous-as-warning
    ab-token@ >token
    "word" >sort
    >+ab resolve-def(
        filter(dup rdip:callable?, RD_WRONG_SORT)
        filter-arity
        filter-visible
        filter-qualifiers
        token can-be-relative-name-or-dname? if(
            @+ab:ab-type@ top-types-are-fine? then(
                @+ab:ab-type@ top-namespaces filter-roots
            ),
            L0 filter-roots
        )
    ) +ab> match (
        None -> elab-atom-failed!,
        Some -> elab-atom-def!
    ))

def(elab-atom-failed!, +Mirth +AB -- +Mirth +AB,
    STACK_TYPE_ERROR ab-type!)

def(elab-ambiguous-name-error!, *a Token List(QName) +Mirth -- *b +Mirth,
    dip("name is ambiguous, can't decide between:")
    for(dip(" " cat) >Str cat) emit-fatal-error!)

def(elab-atom-def!, Def +Mirth +AB -- +Mirth +AB,
    DefAlias -> rdip:target elab-atom-def!,
    DefBuffer -> elab-no-args! ab-buffer!,
    DefVariable -> elab-no-args! ab-variable!,
    DefExternal -> elab-no-args! ab-external!,
    DefField -> elab-no-args! ab-field!,
    DefWord -> elab-args! ab-word!,
    DefTag -> elab-args! ab-tag!,
    DefPrim -> elab-prim!,
    _ -> rdip:qname elab-atom-not-a-word!)

def(elab-atom-not-a-word!, QName +Mirth +AB -- +Mirth +AB,
    ab-type@ top-types-are-fine? if(
        dip(ab-token@ "Not a word: ") rdip:>Str cat rdip:emit-error!,
        drop
    ) elab-atom-failed!)

def(elab-prim!, Prim +Mirth +AB -- +Mirth +AB,
    match(
        PRIM_CORE_MATCH -> elab-atom-match!,
        PRIM_CORE_LAMBDA -> elab-atom-lambda!,
        _ -> elab-args! ab-prim!
    ))

def(elab-atom-assert!, +Mirth +AB -- +Mirth +AB,
    ab-token@ rdip:args-1 >token
    ab-ctx@ >ctx
    True >allow-type-holes
    False >allow-implicit-type-vars
    TYPE_ELAB rdip':elab-stack-type! rdrop
    dip:ab-type@ gamma:unify! drop)

def(elab-atom-match!, +Mirth +AB -- +Mirth +AB,
    MetaVar.new! STMeta >cod
    ab-token@ rdip:args+ first >body
    elab-match-at!)

||| Elaborate a match body within AB. Takes the output stack type,
||| and the token for the body of the match, from the stack. Takes
||| the rest from the AB environment.
def(elab-match-at!, cod:StackType body:Token +Mirth +AB -- +Mirth +AB,
    ab-match!(
        elab-match-cases!
        elab-match-exhaustive!
    ))

||| Elaborate match cases.
def(elab-match-cases!, +Mirth +Match -- +Mirth +Match,
    body while(dup args-end? not, elab-match-case!) drop)

||| Elaborate match case based on starting token.
def(elab-match-case!, Token +Mirth +Match -- Token +Mirth +Match,
    dup run-arrow? unwrap-or("expected arrow end" rdip:emit-fatal-error!)
    dup2 == then("expected pattern" rdip:emit-fatal-error!)
    dup2 prev == else("multi-part pattern not supported" rdip:emit-fatal-error!)
    dip:pat-tokens sip:prev succ +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup comma? then(succ)
    ))

def(elab-pattern!, List(Token) +Mirth +Pattern -- +Mirth +Pattern,
    reverse-for(elab-pattern-atom!))

def(elab-pattern-atom!, Token +Mirth +Pattern -- +Mirth +Pattern,
    dup pattern:token-start!

    dup pat-underscore? if(
        drop +Pattern.underscore!,

    dup name-or-dname? if(
        >token
        "constructor" >sort
        pattern mid top-types-are-fine? not >report-ambiguous-as-warning
        >+pat resolve-def(
            filter(dup tag? some?, RD_WRONG_SORT)
            filter-arity
            filter-visible
            filter-qualifiers
            @+pat:pattern mid top-types-are-fine? then(
                @+pat:pattern mid top-namespaces
                token name? if(
                    filter(dup2 rdip:qname namespace swap member(==), RD_WRONG_CONSTRUCTOR) drop,
                    filter-roots
                )
            )
        ) +pat> bind(tag?) match(
            Some -> +Pattern.tag!,
            None -> STACK_TYPE_ERROR pattern:mid!
        ),

        "Expected constructor name." rdip:emit-fatal-error!
    )))

def(ab-match!(f),
        (*a +Mirth +Match -- *b +Mirth +Match)
        *a cod:StackType body:Token +Mirth +AB -- *b +Mirth +AB,
    ab-ctx@ >ctx
    ab-type@ >dom
    ab-token@ >token
    ab-home@ >home
    L0 >cases
    rdip(+Match f freeze) OpMatch ab-op!)

def(+Match.case!(mkpat,mkbod),
        (*a +Mirth +Pattern -- *b +Mirth +Pattern,
         *b +Mirth +AB -- *c +Mirth +AB)
        *a Token Token +Mirth +Match -- *c +Mirth +Match,

    dip(
        home >home dup >token-start >token-end
        ctx dup >outer-ctx >inner-ctx
        L0 >saved dom dup >mid >cod L0 >atoms
        Pattern rdip(thaw mkpat freeze)
    ) swap \(pat ->
        pat inner-ctx
        pat Pattern.dom +Match.cod T->
        rotl
        +Match.home
        rdip(ab-build-hom!(dip(mkbod)))
        >body
        pat >pattern
        CASE add-case
    ))

def(elab-expand-tensor!, +Mirth StackType Token -- +Mirth StackType Type Token,
    >tok force-cons?! match(
        Some -> unpack2 tok>,
        None -> STACK_TYPE_ERROR TYPE_ERROR tok> dup "expected tuple type" emit-error!
    ))

def(elab-lambda-param?, +Mirth Token -- +Mirth Token Maybe(Var),
    dup pattern-var? if(
        dup args-0 sip:next
        dip(MetaVar.new! TMeta) name? unwrap Var.new! Some,
    dup lsquare?
    and(dup succ pattern-var?)
    and(dup succ succ rsquare? >Bool) if(
        dup succ args-0 sip:next
        dip(MetaVar.new! STMeta MetaVar.new! STMeta T-> TMorphism)
        succ name? unwrap Var.new-auto-run! Some,
        None
    )))

def(elab-atom-lambda!, +Mirth +AB -- +Mirth +AB,
    ab-token@ rdip:args-1
    collect(rdip:elab-lambda-param?)
    dip(rdip:expect-token-arrow succ)
    ab-lambda-at!(elab-atoms!))

||| Check that a match is exhaustive.
def(elab-match-exhaustive!, +Mirth +Match -- +Mirth +Match,
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw)

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def(elab-module!, Module +World +Mirth -- Module +World +Mirth,
    dup start
    elab-module-header!
    while(dup module-end? not, elab-module-decl!)
    drop)

def(elab-module-package-name, Token +Mirth -- Package Name +Mirth,
    dup dname? unwrap-or("Expected module name. (1)" emit-fatal-error!) over args-0
    dup root? unwrap-or(drop "Expected module name. (2)" emit-fatal-error!)
    swap parts /L1+ unwrap-or(drop "Expected module name. (3)" emit-fatal-error!)
    dip(Package.find-or-new! nip))

def(elab-module-qname, +Mirth Token -- +Mirth QName,
    elab-module-package-name dip(NAMESPACE_PACKAGE) QNAME0)

||| Check that the `module(M)` statement exists and save the name.
def(elab-module-header!, +World +Mirth Token -- +World +Mirth Token,
    # dup token-name@ name-str @ str-trace-ln!
    dup module-header? if(
        sip(next) args-1 dup elab-module-package-name
        over2 .module
        tuck ~name !
        tuck ~package !
        dup qname defined? then(drop "Module name already taken." emit-fatal-error!)
        dup DefModule register
        check-module-path,

        dup "Expected module header." emit-fatal-error!
    ))

def(check-module-path, Token Module +World +Mirth -- +World +Mirth,
    dup path split-last match(
        None ->
            swap qname rdip:to-module-path dup2 == else(
                "expected module name to match path\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
            ) drop3,

        Some ->
            split-last-byte(BDOT ==) "mth" Some ==:==
            else(over3 "expected .mth extension for mirth file" emit-warning!)
            over2 name >Str == else(over2 "expected module name to match file name" emit-fatal-error!)
            over package path! drop2
    ))

||| Elaborate a declaration. Returns the next token.
def(elab-module-decl!, Token +World +Mirth -- Token +World +Mirth,
    dup name? unwrap-or("unknown declaration" emit-fatal-error!)
    defs find-some(prim?) unwrap-or("unknown declaration" emit-fatal-error!)
    match(
        PRIM_SYNTAX_IMPORT -> elab-module-import!,
        PRIM_SYNTAX_ALIAS -> elab-alias!,
        PRIM_SYNTAX_INLINE -> elab-inline!,
        PRIM_SYNTAX_DEF -> elab-def!,
        PRIM_SYNTAX_DEF_MISSING -> elab-def-missing!,
        PRIM_SYNTAX_DEF_TYPE -> elab-def-type!,
        PRIM_SYNTAX_DEF_EXTERNAL -> elab-def-external!,
        PRIM_SYNTAX_BUFFER -> elab-buffer!,
        PRIM_SYNTAX_VARIABLE -> elab-variable!,
        PRIM_SYNTAX_TABLE -> elab-table!,
        PRIM_SYNTAX_FIELD -> elab-field!,
        PRIM_SYNTAX_DATA -> elab-data!,
        PRIM_SYNTAX_EMBED_STR -> elab-embed-str!,
        _ -> drop "unknown declaration" emit-fatal-error!
    ))

def(load-module, Token QName +World +Mirth -- Token Module +World +Mirth,
    dup def? match(
        Some -> module? unwrap-or(drop "module name already taken" emit-fatal-error!) nip,
        None ->
            rdip:to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
                #    https://github.com/mirth-lang/mirth/issues/241
    ))

||| Elaborate `import(M)` statement. Return token after import.
def(elab-module-import!, Token +World +Mirth -- Token +World +Mirth,
    sip(next)
    args-1 dup elab-module-qname
    load-module dip(.module) add-import!)

||| Elaborate a data definition `data(True, ..)`
def(elab-data!, Token +Mirth -- Token +Mirth,
    sip(
        Data.alloc!
        L0 over ~tags !
        swap args+
        uncons dip(elab-data-header!)
        for(elab-data-tag!)
        elab-data-done!
    ) next)

||| Get the header, name, arity for a data type.
def(elab-data-header!, Data Token +Mirth -- Data +Mirth,
    dup2 Some swap ~head? !
    dup sig-type-con? or(dup sig-resource-con?) else("Expected type name." emit-fatal-error!)
    dup2 elab-def-qname-undefined
    over ~qname !
    dup DefData register
    # TODO check header args are well-formed / elaborate them properly
    #  as part of: https://github.com/mirth-lang/mirth/issues/246
    dip(dup num-args) ~arity !
    args over DataParams prop(elab-data-params!) over ~params !)

def(elab-data-params!, List(Token) +Mirth -- List(Var) +Mirth,
    Ctx0 swap for(
        dup sig-type-var? else("expected type variable" emit-fatal-error!)
        dup name? unwrap over2 Ctx.lookup then("duplicate parameter name" emit-fatal-error!)
        name? unwrap TYPE_TYPE swap Var.new! Ctx.new
    ) >List)

||| Get a tag associated with a data type.
||| This looks like either "TAG" or "TAG -> TYPE1 .. TYPEN".
def(elab-data-tag!, Data Token +Mirth -- Data +Mirth,
    dup2 name? unwrap-or(drop "Expected constructor name." emit-fatal-error!)
    0 data-qname
    Tag.alloc!
    None over ~untag !
    tuck ~qname !
    dup DefTag register
    { +Mirth Data Token Tag }
    dip(over) dup2 ~data !
    tuck dip(add-tag!)
    { +Mirth Data Token Tag }
    swap succ
    dup pat-arrow? if(
        succ Some over ~sig? !,
    dup run-end? if(
        drop None over ~sig? !,
        "Expected arrow, comma, or right paren." emit-fatal-error!
    ))
    { +Mirth Data Tag }
    dup dup TagType prop(
        dup .data head? unwrap >token
        dup .data params >Ctx >ctx
        True >allow-implicit-type-vars
        False >allow-type-holes
        TYPE_ELAB
        T0 over .data rdip:full-type T*+
        swap sig? match(
            None -> T0,
            Some -> token! T0 elab-stack-type-parts!
        )
        swap T-> dip:ctx pack2 rdrop
    ) over ~ctx-type !
    sip(num-type-inputs-from-sig) sip(~num-type-inputs !)
    sip(num-resource-inputs-from-sig) sip(~num-resource-inputs !)
    sip(label-inputs-from-sig) sip(~label-inputs !)

    dup outputs-resource? not
    over num-resource-inputs 0> && then(
        dup sig? unwrap run-tokens find(
            dup sig-resource-con? or(dup sig-resource-var?)
        ) unwrap "Value type cannot contain resource." emit-error!
    )

    drop)

def(data-word-new!, +Mirth Data Str Int -- +Mirth Word,
    dup >arity
    dip2(dup head? unwrap dup >body >head)
    data-word-qname >qname
    None >sig
    Word.new!)

def(elab-data-done!, +Mirth Data -- +Mirth,
    \(dat ->
        dat is-value-type? then(
            dat "tag" 0 data-word-new! \(tag ->
                dat params >Ctx
                dat data-get-tag-type
                tag WordType prop2 tag ~ctx-type !
                tag ab-build-word!(
                    dat OpDataGetTag ab-op!
                ) drop
            )
        )

        dat is-enum? then(
            dat "from-tag-unsafe" 0 data-word-new! \(ftag ->
                Ctx0 TYPE_INT T1 dat TData T1 T->
                ftag WordType prop2 ftag ~ctx-type !
                ftag ab-build-word!(
                    CoerceUnsafe ab-coerce!
                ) drop
            ),
        )

        dat tags /L1 match(
            Some -> \(tag ->
                dat "/" tag name >Str cat 0 data-word-new! \(untag ->
                    tag untag WordType prop(ctx-type unpack swap T-> pack2) untag ~ctx-type !
                    untag untag WordArrow prop(ab-build-word-arrow!(
                        untag rdip:type cod >cod
                        dat head? unwrap >body
                        ab-match!(
                            dat head? unwrap dup
                            case!(tag +Pattern.tag!, id)
                        )
                    )) untag ~arrow !
                    untag Some tag ~untag !
                    tag create-projectors!
                )
            ),
            None -> id
        )

        dat DataCType prop0(
            dat is-unit? if(
                Phantom Some,
            dat is-enum? if(
                "int" IntLike Some,
            dat is-transparent? if(
                dat tags /L1 unwrap type dom match(
                    STCons -> nip ctype?,
                    STWith -> nip ctype?,
                    _ -> "unexpected tag inputs for transparent data" panic!
                ),
                None
            )))
        ) dat ~ctype? !
    ))

||| Return the tag's output type or resource in context.
def(Tag.output-type, +Mirth Tag -- +Mirth Type/Resource,
    dup type cod expand match(
        STCons -> Left dip(drop2),
        STWith -> Right dip(drop2),
        _ -> drop dip("Unexpected output type for constructor ") qname >Str cat panic!
    ))

||| Return the tag's output type or resource in context, except for a missing field.
def(Tag.output-type-except-field, +Mirth Label Tag -- +Mirth Type/Resource,
    dup output-type map(except-field, except-field))

||| Return the input type for a tag along a given label.
def(Tag.project-input-label, +Mirth Label Tag -- +Mirth Maybe(Type/Resource),
    type dom label-top?)

def(data-get-label-type, +Mirth Tag Label -- +Mirth ArrowType,
    \(tag lbl ->
        lbl tag project-input-label unwrap match(
            Left ->
                T0 tag output-type T*+ swap T1
                tag .data is-resource? then(tag output-type T*+)
                T->,
            Right ->
                T0 tag output-type T*+
                T0 rotl T+ lbl tag output-type-except-field T*+
                T->
        )
    ))

def(data-set-label-type, +Mirth Tag Label -- +Mirth ArrowType,
    \(tag lbl ->
        lbl tag project-input-label unwrap match(
            Left ->
                T1 tag output-type T*+
                T0 tag output-type T*+
                T->,
            Right ->
                T0 swap T+ lbl tag output-type-except-field T*+
                T0 tag output-type T*+ T->
        )
    ))

def(create-projectors!, +Mirth Tag -- +Mirth,
    dup .data over .untag unwrap \(tag dat untag ->
    tag label-inputs reverse-for(\(lbl -> dat lbl name 0 data-qname undefined? then(
        dat lbl >Str 0 data-word-new!
        dat lbl >Str "!" cat 0 data-word-new!
        dat lbl >Str 1 data-word-new! \(lbl_get lbl_set lbl_lens ->
            lbl_get WordType prop0(
                tag ctx
                tag lbl data-get-label-type
                pack2
            ) lbl_get ~ctx-type !
            lbl_get dup WordArrow prop(ab-build-word-arrow!(
                tag lbl OpDataGetLabel ab-op!
            )) lbl_get ~arrow !

            lbl_set WordType prop0(
                tag ctx
                tag lbl data-set-label-type
                pack2
            ) lbl_set ~ctx-type !
            lbl_set dup WordArrow prop(ab-build-word-arrow!(
                tag lbl OpDataSetLabel ab-op!
            )) lbl_set ~arrow !

            lbl_lens WordType prop0(
                TYPE_STACK "*x" >Name Var.new!
                TYPE_STACK "*y" >Name Var.new!
                lbl tag project-input-label unwrap
                tag output-type \(sx sy lblty datty ->
                    tag ctx /Ctx sx sy L2 cat Ctx
                    sx STVar datty T*+
                        sx STVar lblty T*+
                        sy STVar lblty T*+ T-> TMorphism T*
                    sy STVar datty T*+
                    T-> pack2
                )
            ) lbl_lens ~ctx-type !
            lbl_lens dup WordParams prop(
                type dom force-cons?! unwrap unpack2 nip "f" >Name Var.new-auto-run! L1
            ) lbl_lens ~params !

            lbl_lens dup WordArrow prop(ab-build-word-arrow!(
                lbl_lens rdip:params dup ab-lambda!(
                    /L1 unwrap >f
                    dat is-resource? if(
                        lbl_get ab-word!
                        ab-rdip!(f> ab-var!)
                        lbl_set ab-word!,

                        PRIM_CORE_DUP ab-prim!
                        ab-dip!(
                            lbl_get ab-word!
                            f> ab-var!
                        )
                        lbl_set ab-word!
                    )
                )
            )) lbl_lens ~arrow !
        )
    )))))

def(expect-token-arrow, +Mirth Token -- +Mirth Token,
    dup pat-arrow? else("Expected arrow." emit-fatal-error!))

||| Break apart the arguments for `def` into three categories:
|||     - head: the name of the definition, plus params
|||     - sig: the type signature
|||     - body: a nonempty list of body arguments
def(token-def-args, +Mirth Token -- +Mirth Token Token List+(Token),
    dup args dup len 3 >Nat < then(drop "def expects at least three arguments" emit-fatal-error!) nip
    >List+ unwrap uncons
    >List+ unwrap uncons
    >List+ unwrap)

||| Elaborate an alias `alias(w1,w2)`
def(elab-alias!, +Mirth Token -- +Mirth Token,
    sip(next) args-2 swap
    dup elab-def-qname-undefined dup \(aliasqname ->
    over next arg-end? else(over "expected comma after alias name" emit-fatal-error!)
    rotl dup name-or-dname? unwrap-or("expected alias target, which must be a name" emit-fatal-error!)
    over args-0 over succ arg-end? else(over "expected end of argument after alias target" emit-fatal-error!)
    dip2(Alias.new!)
    over2 AliasTarget prop2(
        match(
            Left ->
                defs filter(dup2 def-visible-from-token?) match(
                    Nil -> "unknown alias target" emit-fatal-error!,
                    Cons -> match(
                        Nil -> id,
                        _ -> Cons map(qname) elab-ambiguous-name-error!
                    )
                ),
            Right ->
                dip(dup) aliasqname arity elab-qname-from-nonrelative-dname
                dup def? unwrap-or(dip("undefined alias target ") >Str cat emit-fatal-error!) nip
        )
        dup2 def-visible-from-token? else(
            dip("alias target is not visible")
            defining-module? for(dip(", need to import " cat) qname >Str cat)
            emit-fatal-error!
        )
        match(
            DefAlias ->
                # Detect circular aliases, e.g. `alias(x, y) alias(y, x)`,
                # and avoid storing alias chains (so each alias points to its ultimate target directly).
                ~target force-or!("alias points to itself, circular aliases not allowed." emit-fatal-error!) nip,
            _ -> nip,
        )
    )
    over ~target !
    drop))

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def(elab-def-missing!, +Mirth Token -- +Mirth Token,
    dup args len 3 >Nat < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined? if(next, elab-def!))

def(elab-inline!, Token +World +Mirth -- Token +World +Mirth,
    sip:next args-1
    dip:prefer-inline-defs
    True prefer-inline-defs!
    while(dup arg-end? not, elab-module-decl!)
    drop prefer-inline-defs!)

||| Elaborate a word definition `def(w, t, b...)`.
def(elab-def!, +Mirth Token -- +Mirth Token,
    sip(next) token-def-args
    uncons empty? or(dup run-arrow? >Bool) else("expected match case" emit-fatal-error!) >body
    Some >sig
    dup >head
    dup num-args >arity
    elab-def-qname-undefined >qname
    Word.new!

    prefer-inline-defs over ~prefer-inline? !

    dup dup WordType prop(
        sig unwrap
        +TypeElab.type-sig-start!
        elab-type-sig!
        dip:ctx pack2
        rdrop
    ) over ~ctx-type !
    dup dup WordParams prop(elab-def-params!) over ~params !
    dup dup WordArrow prop(
        dup dup ab-build-word-arrow!(
            swap rdip:params dup empty? if(
                drop elab-def-body!,
                ab-lambda!(elab-def-body!)
            )
        ) tuck check-inline-recursion-arrow!
    ) swap ~arrow !)

def(check-inline-recursion-arrow!, +Mirth Word Arrow -- +Mirth,
    atoms for(dip:dup check-inline-recursion-atom!) drop)
def(check-inline-recursion-atom!, +Mirth Word Atom -- +Mirth,
    over prefer-inline? if(
        dup2 op check-inline-recursion-op!
        args for(dip:dup check-inline-recursion-arg!) drop,
        drop2
    ))
def(check-inline-recursion-arg!, +Mirth Word Arg -- +Mirth,
    ArgBlock -> arrow check-inline-recursion-arrow!)
def(check-inline-recursion-op!, +Mirth Word Op -- +Mirth,
    OpBlockRun -> arrow check-inline-recursion-arrow!,
    OpWord ->
        dup2 == if(
            drop check-inline-recursion-failed!,
            dup prefer-inline? if(
                ~arrow try-force! if-some(
                    check-inline-recursion-arrow!,
                    check-inline-recursion-failed!
                ),
                drop2
            )
        ),
    OpMatch -> cases for(dip:dup body check-inline-recursion-arrow!) drop,
    OpLambda -> body check-inline-recursion-arrow!,
    _ -> drop2)
def(check-inline-recursion-failed!, +Mirth Word -- +Mirth,
    dup prefer-inline? if(
        False over ~prefer-inline? !
        head "recursive word cannot be inlined" emit-warning!,
        drop
    ))

||| Elaborate a word's parameters from its type and declaration.
def(elab-def-params!, +Mirth Word -- +Mirth List(Var),
    L0 over type
    rotl head dip(unpack) nip
    args reverse-for(
        dup sig-param-name? else("expected parameter name" emit-fatal-error!)
        dup succ dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!)
        elab-expand-tensor!
        over morphism? else(
            "need function type for param" emit-fatal-error!)
        name? unwrap Var.new-auto-run!
        rotr dip(cons)
    ) drop)

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def(elab-def-body!, StackType +Mirth +AB -- StackType +Mirth +AB,
    ab-token@ run-arrow? if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    ))

||| Elaborate an external declaration `def-external(w, t)` or `def-external(w -> sym, t)`
def(elab-def-external!, +Mirth Token -- +Mirth Token,
    sip(next) args-2
    over dup elab-def-qname-undefined
    swap succ dup comma? if(
        drop dup name,
        expect-token-arrow succ
        dup name? unwrap-or("expected external symbol name" emit-fatal-error!) nip
    ) >Str swap

    External.alloc!
    tuck ~qname !
    tuck ~symbol !
    tuck ~sig !
    tuck ~head !
    dup dup ExternalType prop(
        sig +TypeElab.type-sig-start!
        elab-type-sig! dip:ctx pack2 rdrop
    ) over ~ctx-type !
    dup dup ExternalCType prop(
        elab-def-external-ctype
    ) over ~ctype !
    DefExternal register)

def(elab-def-external-ctype, +Mirth External -- +Mirth CTypeArrow,
    dup head with-error-token(
        type ctype
        dup cod parts
        filter(dup ctype phantom? not)
        len 1 >Nat > then(
            "External has too many outputs." error!
            # TODO Allow for external resources to be used
            # on both input and output without affecting count.
        )
    ))

||| Elaborate a type definition `def-type(t1, t2)`.
def(elab-def-type!, +Mirth Token -- +Mirth Token,
    sip(next) args-2
    swap dup sig-type-con? else("expected type constructor" emit-fatal-error!)
    dup elab-def-qname-undefined
    dip(Some) rotl elab-simple-type-arg! TypeDef.new! drop)

||| Elaborate a buffer definition `buffer(B, size)`.
def(elab-buffer!, +Mirth Token -- +Mirth Token,
    sip(next) args-2
    swap dup elab-def-qname-undefined
    rotl dup int? unwrap-or("expected buffer size" emit-fatal-error!) nip
   >Size Buffer.new! drop)

||| Elaborate a var declaration `var(v, type)`.
def(elab-variable!, +Mirth Token -- +Mirth Token,
    sip(next) args-2
    swap dup elab-def-qname-undefined Variable.new!
    tuck VariableType prop(elab-simple-type-arg!)
    over ~type ! drop)

||| Elaborate a table definition `table(True)`.
def(elab-table!, +Mirth Token -- +Mirth Token,
    sip(next) args-1
    dup sig-type-con? else("expected type name" emit-fatal-error!)
    dup args-0
    dup succ arg-end? else(succ "expected end of argument after table name" emit-fatal-error!)
    dup elab-def-qname-undefined
    table-new! drop)

||| Create entry point based on word name.
def(elab-entry-point, QName +Mirth -- Arrow +Mirth,
    dup def? bind(word?) unwrap-or(
        dup dip(
            namespace module? unwrap start
            "can't find entry point "
        ) >Str cat
        emit-fatal-error!
    ) nip { Word +Mirth }
    dup dip(Ctx0 T0 RESOURCE_WORLD T+ T0 RESOURCE_WORLD T+ T->)
    head dup HomeMain ab-build-hom!(
        dip(ab-word!)
    ))

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def(elab-embed-str!, Token +World +Mirth -- Token +World +Mirth,
    sip:next args-2 swap
    dup >head elab-def-qname-undefined >qname
    dup >body None >sig 0 >arity
    dup str? unwrap-or("expected source path" emit-fatal-error!)
    >Path rdip(open-file! unwrap! read-file! close-file! nip >contents)
    Word.new!
    Ctx0 T0 TYPE_STR T1 T-> over2 WordType prop2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop)

||| Ensure that everything so far has been typechecked.
def(typecheck-everything!, +Mirth -- +Mirth,
    Name.for(defs for(typecheck!))
    Block.for(typecheck!)
    External.for(ctype drop))

#########
# TABLE #
#########

def(TABLE_MAX_COUNT, Nat, 0x80000 >Nat)

def(table-qname, Table Str Int -- QName,
    >arity >Name >name TYCON_TABLE NAMESPACE_TYCON >namespace MKQNAME)

def(table-word-new!, +Mirth Table Str Int -- +Mirth Word,
    over2 head dup >head >body None >sig
    dup >arity table-qname >qname Word.new!)

def(table-new!, +Mirth Token QName -- +Mirth Table,
    Table.alloc! >tbl
    @tbl ~qname !
    @tbl ~head !
    TABLE_MAX_COUNT @tbl ~max-count !
    @tbl DefTable register

    # Table.MAX
    @tbl "MAX" 0 table-word-new! >word

    L0 Ctx
    T0 TYPE_INT T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @tbl head ab-token!
        TABLE_MAX_COUNT >Int ab-int!
    ) drop

    # Table.nil
    @tbl "nil" 0 table-word-new! >word

    L0 Ctx
    T0 @tbl TTable T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @tbl head ab-token!
        0 ab-int!
        CoerceUnsafe ab-coerce!
    ) drop

    # Table.NUM
    @tbl head
    @tbl "NUM" 0 table-qname
    8 >Size Buffer.new!
    @tbl ~num-buffer !

    # Table.index
    @tbl "index" 0 table-word-new! >word

    L0 Ctx
    @tbl TTable T1 TYPE_INT T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        CoerceUnsafe ab-coerce!
    ) drop

    # Table.from-index
    @tbl "from-index" 0 table-word-new! >word

    L0 Ctx
    @tbl TTable T1 TYPE_INT T1 swap T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        CoerceUnsafe ab-coerce!
    ) drop

    # Table.succ
    @tbl "succ" 0 table-word-new! >word

    L0 Ctx
    @tbl TTable T1 dup T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        CoerceUnsafe ab-coerce!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        @tbl num-buffer ab-buffer!
        PRIM_U64_GET ab-prim!
        CoerceUnsafe ab-coerce!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        PRIM_INT_MOD ab-prim!
        CoerceUnsafe ab-coerce!
    ) drop

    # Table.pred
    @tbl "pred" 0 table-word-new! >word

    L0 Ctx
    @tbl TTable T1 dup T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        CoerceUnsafe ab-coerce!
        PRIM_CORE_DUP ab-prim!
        0 ab-int!
        PRIM_INT_EQ ab-prim!
        ab-if!(
            ,
            1 ab-int!
            PRIM_INT_SUB ab-prim!
        )
        CoerceUnsafe ab-coerce!
    ) drop

    { +Mirth tbl:Table }

    # Table.for
    @tbl "for" 1 table-word-new! >word
    TYPE_STACK "*a" >Name Var.new! >va
    @va STVar @tbl TTable T* @va STVar T-> >Type "f" >Name Var.new-auto-run! >vx

    @va Ctx1
    @va STVar @vx type T* @va STVar T->
    @word WordType prop2
    @word ~ctx-type !

    @vx L1
    @word WordParams prop
    @word ~params !

    word> ab-build-word! (
        @tbl head ab-token!
        @vx L1 ab-lambda!(
            1 ab-int!
            ab-while!(
                PRIM_CORE_DUP ab-prim!
                @tbl num-buffer ab-buffer!
                PRIM_U64_GET ab-prim!
                CoerceUnsafe ab-coerce!
                1 ab-int!
                PRIM_INT_ADD ab-prim!
                PRIM_INT_LT ab-prim!,

                PRIM_CORE_DUP ab-prim!
                ab-dip! (
                    CoerceUnsafe ab-coerce!
                    @vx ab-var!
                )
                1 ab-int!
                PRIM_INT_ADD ab-prim!
            )
            PRIM_CORE_DROP ab-prim!
        )
    ) drop
    va> vx> drop2

    # Table.alloc!
    @tbl "alloc!" 0 table-word-new! >word

    L0 Ctx
    T0 @tbl TTable T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl num-buffer ab-buffer!
        PRIM_U64_GET ab-prim!
        CoerceUnsafe ab-coerce!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        PRIM_CORE_DUP ab-prim!
        CoerceUnsafe ab-coerce!
        @tbl num-buffer ab-buffer!
        PRIM_U64_SET ab-prim!
        CoerceUnsafe ab-coerce!
    ) drop

    tbl>)

#########
# FIELD #
#########

def(elab-qname-from-nonrelative-dname, +Mirth Token DName Int -- +Mirth QName,
    over root? unwrap-or(drop2 "relative name not allowed" emit-fatal-error!)
    dup could-be-type-or-resource-con if(
        rotl parts /L1+ unwrap-or(drop2 "type-qualified name has too many parts" emit-fatal-error!)
        rotl elab-tycon-qname,
        rotr dip(parts cons+) elab-absolute-qname
    ))

def(module-visible-from-token?, Token Module -- Bool,
    swap .module visible)

def(def-visible-from-token?, Token Def -- Bool,
    defining-module? match(
        None -> drop True,
        Some -> module-visible-from-token?
    ))

def(elab-tycon, +Mirth Token Name -- +Mirth Tycon,
    dup defs find-some(
        over2 over def-visible-from-token? if(
            exposed-tycon?,
            drop None
        )
    )
    unwrap-or("unknown type constructor: " swap >Str cat emit-fatal-error!)
    dip(drop2))

def(elab-tycon-qname, +Mirth Token Name Name Int -- +Mirth QName,
    >arity >name elab-tycon NAMESPACE_TYCON >namespace MKQNAME)

def(elab-absolute-namespace, +Mirth Token List(Name) -- +Mirth Namespace,
    NAMESPACE_ROOT swap for(
        QNAME0 dup def? unwrap-or("unknown namespace: " swap >Str cat emit-fatal-error!)
        match(
            DefPackage -> NAMESPACE_PACKAGE,
            DefModule -> NAMESPACE_MODULE,
            _ -> exposed-tycon? unwrap-or("invalid namespace: " swap >Str cat emit-fatal-error!) NAMESPACE_TYCON,
        ) nip
    ) nip)

def(elab-absolute-qname, +Mirth Token List+(Name) Int -- +Mirth QName,
    >arity unsnoc >name
    elab-absolute-namespace >namespace MKQNAME)

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def(elab-def-qname, +Mirth Token -- +Mirth QName,
    dup name-or-dname? unwrap-or("expected name" emit-fatal-error!)
    match(
        Left -> >name dup .module NAMESPACE_MODULE >namespace num-args >arity MKQNAME,
        Right -> over num-args elab-qname-from-nonrelative-dname
    ))

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def(elab-def-qname-undefined, +Mirth Token -- +Mirth QName,
    dup elab-def-qname
    dup defined? then(drop "name already defined" emit-fatal-error!)
    nip)

||| Elaborate a field definition `field(f, T1, T2)`.
def(elab-field!, +Mirth Token -- +Mirth Token,
    sip(next) args-3
    rotl dup elab-def-qname-undefined
    field-new! drop)

def(field-new!, +Mirth Token Token Token QName -- +Mirth Field,
    Field.alloc! >fld
    @fld ~qname !
    @fld ~head !
    @fld FieldValueType prop(elab-simple-type-arg!) @fld ~value-type !
    @fld FieldIndexType prop(elab-simple-type-arg!) @fld ~index-type !
    @fld DefField register
    fld>)
