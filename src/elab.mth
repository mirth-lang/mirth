module(mirth.elab)

import(std.prelude)
import(std.str)
import(std.list)
import(std.maybe)
import(std.either)
import(std.byte)
import(std.terminal)

import(mirth.mirth)
import(mirth.name)
import(mirth.def)
import(mirth.token)
import(mirth.data)
import(mirth.external)
import(mirth.word)
import(mirth.var)
import(mirth.buffer)
import(mirth.variable)
import(mirth.table)
import(mirth.tycon)
import(mirth.type)
import(mirth.typedef)
import(mirth.var)
import(mirth.arrow)
import(mirth.word)
import(mirth.prim)
import(mirth.module)
import(mirth.package)
import(mirth.alias)
import(mirth.match)
import(mirth.lexer)
import(mirth.label)

####################
# Type Elaboration #
####################

struct +TypeElab {
    ctx:Ctx token:Token
    allow-type-holes:Bool
    allow-implicit-type-vars:Bool
}

def +TypeElab.type-sig-start! [ Token -- +TypeElab ] {
    >token
    Ctx0 >ctx
    False >allow-type-holes
    True >allow-implicit-type-vars
    +TypeElab
}

def +TypeElab.rdrop [ +TypeElab -- ] {
    /+TypeElab
    ctx> token> drop2
    allow-type-holes> drop
    allow-implicit-type-vars> drop
}

def +TypeElab.elab-type-sig! [ +Mirth +TypeElab -- +Mirth +TypeElab ArrowType ] {
    token run-end? then(token "expected type signature" rdip:emit-error!)
    elab-type-sig-params!
    elab-stack-type!
    token sig-dashes? if(token:succ elab-stack-type!, dip:T0)
    token run-end? else(token "expected right paren or comma" rdip:emit-error!)
    dip(swap for(T*)) T->
}

def +TypeElab.elab-type-sig-params! [ +Mirth +TypeElab -- +Mirth +TypeElab List(Type) ] {
    token lparen? if(
        token next
        token args map(token! elab-type-sig! TMorphism)
        dip:token!,
        L0
    )
}

def +TypeElab.elab-stack-type! [ +Mirth +TypeElab -- +Mirth +TypeElab StackType ] {
    token sig-stack-var? if-some(elab-stack-type-var!, T0)
    elab-stack-type-parts!
}

def +TypeElab.elab-stack-type-parts! [ +Mirth +TypeElab StackType -- +Mirth +TypeElab StackType ] {
    while(token sig-stack-end? not, elab-stack-type-part! cons)
}

def +TypeElab.elab-type-arg! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
    token elab-stack-type-part!
    match(
        STPCons -> nip,
        STPConsLabel -> drop2 "Expected type, not label." rdip:emit-error! TYPE_ERROR,
        STPWith -> drop "Expected type, not resource." rdip:emit-error! TYPE_ERROR,
        STPWithLabel -> drop2 "Expected type, not labelled resource." rdip:emit-error! TYPE_ERROR,
    )
    token arg-end? else(
        token "Unexpected token after type." rdip:emit-error!
    )
}

def +TypeElab.elab-resource-arg! [ +Mirth +TypeElab -- +Mirth +TypeElab Resource ] {
    token elab-stack-type-part!
    match(
        STPCons -> drop "Expected resource, not type." rdip:emit-error! TYPE_ERROR Resource,
        STPConsLabel -> drop2 "Expected resource, not label." rdip:emit-error! TYPE_ERROR Resource,
        STPWith -> nip,
        STPWithLabel -> drop2 "Expected resource, not label." rdip:emit-error! TYPE_ERROR Resource,
    )
    token arg-end? else(
        token "Unexpected token after resource." rdip:emit-error!
    )
}

def +TypeElab.elab-stack-type-part! [ +Mirth +TypeElab -- +Mirth +TypeElab StackTypePart ] {
    token sig-label? if-some(
        elab-stack-label!,

    token sig-type-var? if-some(
        elab-type-var! STPCons,

    token sig-type-con? if-some(
        elab-type-con! STPCons,

    token sig-resource-var? if-some(
        elab-resource-var! STPWith,

    token sig-resource-con? if-some(
        elab-resource-con! STPWith,

    token pat-underscore? if(
        elab-type-dont-care! STPCons,

    token sig-type-hole? if-some(
        elab-type-hole! STPCons,

    token lsquare? .if(
        elab-type-quote! STPCons,

        token "Expected type, got unknown token." rdip:emit-error!
        token:next TYPE_ERROR STPCons
    ))))))))
}

def +TypeElab.elab-stack-label! [ +Mirth +TypeElab Label -- +Mirth +TypeElab StackTypePart ] {
    token next dip(
        token:args-1 dup is-resource-label? if(
            elab-resource-arg! swap STPWithLabel,
            elab-type-arg! swap STPConsLabel
        )
    ) token!
}

def +TypeElab.elab-stack-type-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab StackType ] {
    TYPE_STACK elab-implicit-var! if-some(STVar, STACK_TYPE_ERROR)
}

def +TypeElab.elab-type-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Type ] {
    TYPE_TYPE elab-implicit-var! if-some(TVar, TYPE_ERROR)
}

def +TypeElab.elab-resource-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Resource ] {
    TYPE_RESOURCE elab-implicit-var! if-some(TVar, TYPE_ERROR) Resource
}

def +TypeElab.gamma(f) [ (*a +Gamma -- *b +Gamma) *a +TypeElab -- *b +TypeElab ] {
    token rdip(>token +Gamma f rdrop)
}

def +TypeElab.elab-implicit-var! [ +Mirth +TypeElab Name Type -- +Mirth +TypeElab Maybe(Var) ] {
    over ctx lookup match(
        Some -> sip(dip:nip type gamma:unify! drop) Some,
        None ->
            allow-implicit-type-vars if(
                swap Var.new! ctx(over Ctx.new) Some,
                token "Implicit type variable not allowed here." rdip:emit-error!
                drop2 None
            )
    )
    token rdip:args-0
    token:succ
}

def show-num-arguments [ Int -- Str ] {
    dup 1 == if(drop "1 argument",
    show " arguments" cat)
}

struct +ResolveDef {
    sort: Str
    token: Token
    name/dname: Name/DName
    candidates: List(Def)
    rejected: List(RejectedDef)
    ignore-last-name: Bool
    report-ambiguous-as-warning: Bool
}

def +ResolveDef.filter(p) [
    (*a Def +ResolveDef -- *a Either(RejectedDef, Def) +ResolveDef)
    *a +ResolveDef -- *a +ResolveDef
] {
    candidates partition-either(p) dip:rejected:cat candidates!
}

def +ResolveDef.filter(p,q) [
    (*a Def +ResolveDef -- *a Def Bool +ResolveDef,
        *a Def +ResolveDef -- *a RejectedDef +ResolveDef)
    *a +ResolveDef -- *a +ResolveDef
] {
    filter(p if(Right, q Left))
}

# TODO: separate this into a reason and a def.
data RejectedDef {
    RD_WRONG_SORT           [ Def ]
    RD_WRONG_ARITY          [ Def ]
    RD_NOT_VISIBLE          [ Def ]
    RD_NOT_IMPORTED         [ Def ]
    RD_WRONG_QUALIFIER      [ Def ]
    RD_WRONG_CONSTRUCTOR    [ Def ]
    RD_METHOD_NOT_AVAILABLE [ Def ]
    RD_METHOD_WRONG_TYPE    [ Def ]
}

def resolve-def-begin! [
    sort:Str
    token:Token
    name/dname:Name/DName
    ignore-last-name:Bool
    report-ambiguous-as-warning:Bool
    +Mirth
    -- +Mirth +ResolveDef
] {
    @ignore-last-name if(
        @name/dname name/dname-penultimate-name? unwrap(
            @token "Expected a namespace." emit-fatal-error!
        ),
        @name/dname name/dname-last-name
    ) defs >candidates
    L0 >rejected
    +ResolveDef
}

def resolve-def-end! [ +Mirth +ResolveDef -- +Mirth Maybe(Def) ] {
    candidates match(
        Nil -> resolve-def-unknown None,
        Cons -> match(
            Nil -> rdrop Some,
            _ -> List.filter(over rdip:same-resolved? not) match(
                Nil -> rdrop Some,
                _ -> drop2 resolve-def-ambiguous None
            )
        )
    )
}

def resolve-def(f) [
    (*a +Mirth +ResolveDef -- *b +Mirth +ResolveDef)
    *a +Mirth
    sort:Str
    token:Token
    name/dname: Name/DName
    ignore-last-name:Bool
    report-ambiguous-as-warning:Bool
    --
    *b +Mirth Maybe(Def),
] {
    resolve-def-begin! f resolve-def-end!
}

def +ResolveDef.rdrop [ +ResolveDef -- ] {
    /+ResolveDef
    sort> token> name/dname> drop3
    candidates> rejected> drop2
    report-ambiguous-as-warning> drop
    ignore-last-name> drop
}

def +ResolveDef.resolve-def-ambiguous [ +Mirth +ResolveDef -- +Mirth ] {
    report-ambiguous-as-warning if(
        token Str(
            "Can't resolve " ; rdip:sort ; " due to previous errors. Candidates are:" ;
            " " rdip:candidates for(swap ; rdip2(qname-hard >Str) ; ", ") drop
        ) rdip:emit-warning!,

        token Str(
            "Ambiguous " ; rdip:sort ; ". Can't decide between:" ;
            " " rdip:candidates for(swap ; rdip2(qname-hard >Str) ; ", ") drop
        ) rdip:emit-error!
    ) rdrop
}
def +ResolveDef.resolve-def-unknown [ +Mirth +ResolveDef -- +Mirth ] {
    token Str(rdip:rejected match(
        Nil -> "Unknown " ; rdip:sort ; " name, possibly a misspelling." ;,
        Cons ->
            match(
                Nil -> match(
                    RD_WRONG_SORT ->
                        "Expected a " ; rdip:sort ; ", but " ;
                        rdip2(qname-hard >Str) ; " is not a " ; rdip:sort ; "." ; ,
                    RD_NOT_VISIBLE ->
                        "Not visible in current scope: " ; rdip2(qname-hard >Str) ; ,
                    RD_NOT_IMPORTED ->
                        "Not imported in current scope: " ; rdip2(qname-hard >Str) ; ,
                    RD_WRONG_ARITY ->
                        rdip2(qname-hard dup >Str) ; " expects " ; arity show;
                        " arguments, but got " ; rdip:token num-args show; "." ; ,
                    RD_WRONG_QUALIFIER ->
                        "Qualified name not found. Perhaps you meant: " ; rdip2(qname-hard >Str) ; ,
                    RD_WRONG_CONSTRUCTOR ->
                        "Constructor is for a different type: " ; rdip2(qname-hard >Str) ; ,
                    RD_METHOD_WRONG_TYPE ->
                        "Method is for a different type: " ; rdip2(qname-hard >Str) ; ,
                    RD_METHOD_NOT_AVAILABLE ->
                        "Method is not available for current stack: " ; rdip2(qname-hard >Str) ; ,
                ),
                _ -> Cons "Multiple definitions for name, but none are suitable:" ;
                    dip:" " for(swap ; match(
                        RD_WRONG_SORT -> rdip2(qname-hard >Str) ; " is not a " ; rdip:sort ; ,
                        RD_NOT_VISIBLE ->
                            rdip2(qname-hard >Str) ; " is not visible in current scope" ; ,
                        RD_NOT_IMPORTED ->
                            rdip2(qname-hard >Str) ; " is not imported in current scope" ; ,
                        RD_WRONG_ARITY ->
                            rdip2(qname-hard dup >Str) ; " expects " ;
                            arity show; " arguments" ; ,
                        RD_WRONG_QUALIFIER ->
                            rdip2(qname-hard >Str) ; " doesn't match the given qualified name" ; ,
                        RD_WRONG_CONSTRUCTOR ->
                            rdip2(qname-hard >Str) ; " is constructor for a different type" ; ,
                        RD_METHOD_WRONG_TYPE ->
                            rdip2(qname-hard >Str) ; " is method for a different type" ; ,
                        RD_METHOD_NOT_AVAILABLE ->
                            rdip2(qname-hard >Str) ; " is not avaliable for current stack" ; ,
                    ) ", ") drop
            )
    )) rdip:emit-error! rdrop
}

def +ResolveDef.filter-sort(p) [
    (*a Def +ResolveDef -- *a Def Bool +ResolveDef)
    *a +ResolveDef -- *a +ResolveDef
] {
    filter(p, RD_WRONG_SORT)
}

def +ResolveDef.filter-arity [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
    token num-args filter(
        dup2 rdip:qname-hard arity dip(>Int) arity-compatible?,
        RD_WRONG_ARITY
    ) drop
}
def +ResolveDef.filter-visible [ +ResolveDef -- +ResolveDef ] {
    filter(token over def-visible-from-token?, RD_NOT_VISIBLE)
}

def +ResolveDef.filter-qualifiers [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
    token dname? for(
        filter(dup2 rdip:qname-hard climb-up-dname? empty? not, RD_WRONG_QUALIFIER)
        drop
    )
}

def +ResolveDef.filter-roots [ List(Namespace) +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
    name/dname match {
        { Left ->
            >name
            filter(
                dup2 rdip:qname-hard namespace swap member
                or(token over rdip:def-is-imported-at-token?),
                dup rdip:qname-hard namespace match(
                    NAMESPACE_TYCON ->
                        drop @name can-be-relative? if(
                            over empty? if(
                                RD_METHOD_NOT_AVAILABLE,
                                RD_METHOD_WRONG_TYPE
                            ),
                            RD_NOT_IMPORTED
                        ),
                    _ -> drop RD_NOT_IMPORTED
                )
            )
            name> drop
        }

        { Right ->
            dup is-relative? and(ignore-last-name not) if(
                filter(dup2 rdip:qname-hard climb-up-dname? has(over3 member),
                    over2 empty? if(
                        RD_METHOD_NOT_AVAILABLE,
                        RD_METHOD_WRONG_TYPE
                    )
                ),
                filter(dup2 rdip:qname-hard climb-up-dname? has(
                    dip:token rdip:namespace-is-imported-at-token?
                ), RD_NOT_IMPORTED)
            ) drop
        }
    }

    drop
}

||| Check whether a definition can be referred to without qualification.
def def-is-imported-at-token? [ +Mirth Token Def -- +Mirth Bool ] {
    # TODO: implement finer grained control over what is imported.
    #   https://github.com/mirth-lang/mirth/issues/243
    dup qname-hard namespace match(
        NAMESPACE_ROOT -> drop2 True,
        NAMESPACE_PACKAGE -> drop3 True,
        NAMESPACE_MODULE -> nip module-visible-from-token?,
        NAMESPACE_TYCON -> dip:swap tycon-is-visible-at-token? if(tag? >Bool, drop False),
        NAMESPACE_WORD -> drop3 False
    )
}

def tycon-is-visible-at-token? [ Token Tycon -- Bool ] {
    TYCON_DATA -> head? if-some(.module module-visible-from-token?, drop True),
    TYCON_TABLE -> head .module module-visible-from-token?,
    TYCON_PRIM -> drop2 True
}

def namespace-is-imported-at-token? [ +Mirth Token Namespace -- +Mirth Bool ] {
    NAMESPACE_ROOT -> drop True,
    NAMESPACE_PACKAGE -> drop2 True,
    NAMESPACE_MODULE -> module-visible-from-token?,
    NAMESPACE_TYCON -> qname-hard namespace namespace-is-imported-at-token?,
    NAMESPACE_WORD -> drop2 False
}

def QName.climb-up-name? [ +Mirth Name QName -- +Mirth List(Namespace) ] {
    >qname >name

    @qname name @name == if(
        @qname namespace L1,
        L0
    ) >accum
    name> defs for(match(
        DefAlias ->
            dup target qname-hard @qname == if(
                namespace-hard @accum:cons,
                drop
            ),
        DefType ->
            dup target tycon? has(qname-hard @qname ==) if(
                namespace @accum:cons,
                drop
            ),
        _ -> drop
    ))
    qname> drop
    accum>
}

def QName.climb-up-dname? [ +Mirth +ResolveDef DName QName -- +Mirth +ResolveDef List(Namespace) ] {
    dip(sip(root? >List) parts unsnoc dip(cat)
        ignore-last-name then(drop unsnoc unwrap(
            token "Error, expected a namespace in QName.climb-up-dname?" rdip:emit-fatal-error!
        ))
    )
    rdip:climb-up-name? swap
    reverse-for(swap bind(rdip:qname if-some(dip(dup) rdip:climb-up-name?, L0)) nip)
}

def +TypeElab.resolve-type-con-name! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Type ] {
    >name/dname
    False >report-ambiguous-as-warning
    False >ignore-last-name
    token >token "type" >sort rdip:resolve-def(
        filter(dup rdip:defines-a-type?, RD_WRONG_SORT)
        filter-arity
        filter-qualifiers
        L0 filter-roots
    ) map:match(
        DefData -> TData,
        DefTable -> TTable,
        DefType -> rdip:target,
        _ ->
            drop token "compiler bug: resolve-type-con-name! doesn't understand type"
            rdip:emit-error! TYPE_ERROR,
    ) unwrap(TYPE_ERROR)
}

def +TypeElab.elab-type-con! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Type ] {
    dup left? has(>Str "Mut" ==) if(
        drop token next dip(
            token:args-1
            elab-type-arg!
            TMut
        ) token!,

        resolve-type-con-name! elab-type-args!
        token:next
    )
}

def +TypeElab.elab-resource-con! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Resource ] {
    elab-type-con! Resource
}

def +TypeElab.elab-type-args! [ +Mirth +TypeElab Type -- +Mirth +TypeElab Type ] {
    token has-args? then(
        token dip(
            token args for(
                token!
                elab-type-arg! TApp
            )
        ) token!
    )
}

def +TypeElab.elab-type-hole! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Type ] {
    allow-type-holes if(
        token rdip:args-0
        THole,
        drop
        token "type holes are not allowed here" rdip:emit-error!
        TYPE_ERROR
    )
    token:next
}

def +TypeElab.elab-type-dont-care! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
    allow-type-holes if(
        token rdip:args-0
        TYPE_DONT_CARE,
        token "underscore is not allowed here" rdip:emit-error!
        TYPE_ERROR
    )
    token:next
}

def +TypeElab.elab-type-quote! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
    token next dip(
        token:args-1
        token sig-has-dashes? if(
            elab-type-sig! >Type,
            elab-stack-type! >Type
        )
    ) token!
}

def elab-type-unify! [ +Mirth Type Type Token -- +Mirth Type Token ] {
    >token +Gamma unify! /+Gamma token>
}
def elab-stack-type-unify! [ +Mirth StackType StackType Token -- +Mirth StackType Token ] {
    >token +Gamma unify! /+Gamma token>
}

def elab-simple-type-arg! [ +Mirth Token -- +Mirth Type ] {
    >token
    Ctx0 >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab elab-type-arg! rdrop
}

####################
# Word Elaboration #
####################

struct +AB { arrow:Arrow }
def ab-token@ [ +AB -- +AB Token ] { arrow token-end }
def ab-token! [ +AB Token -- +AB ] { arrow:token-end! }
def ab-type@ [ +AB -- +AB StackType ] { arrow cod }
def ab-type! [ +AB StackType -- +AB ] { arrow:cod! }
def ab-ctx@ [ +AB -- +AB Ctx ] { arrow ctx }
def ab-home@ [ +AB -- +AB Home ] { arrow home }

def +AB.gamma(f) [ (*a +Gamma -- *b +Gamma) *a +AB -- *b +AB ] {
    ab-token@ rdip(>token +Gamma f rdrop)
}

def ab-build!(f) [ (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow ] {
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx L0 >atoms
    Arrow >arrow +AB
    f /+AB arrow>
}

||| Like ab-build! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def ab-build-hom!(f) [
    (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
    *a Ctx ArrowType Token Home +Mirth -- *b Arrow +Mirth
] {
    dip2(/ArrowType dom>)
    ab-build!(cod> f ab-unify-type!)
}

||| Build the arrow for a word. If the word type and context are available, use that.
||| Otherwise, we are in a situation where type and context were not given, so we infer them.
|||
||| To infer ctx-type, we start with an initial guess based on the word head (with lots
||| of metavariables). We temporarily set that as our ctx-type. Then we elaborate the word
||| body. After elaboration, we rigidify the type to obtain a generalized definition, by
||| replacing any free metavariables with universally quantified variables.
def ab-build-word-arrow!(f) [
    (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
    *a Word +Mirth -- *b Arrow +Mirth
] {
    initial-ctx-type-body-home
    dip:ab-build-hom!(f)
    finalize-word-arrow
}

def initial-ctx-type-body-home [ +Mirth Word -- +Mirth Ctx ArrowType Token Home Word ] {
    >word
    @word ~ctx-type try-force!
    match(Some -> unpack2, None -> guess-initial-ctx-type)
    @word body
    @word HomeWord
    word>
}

def finalize-word-arrow [ +Mirth Arrow Word -- +Mirth Arrow ] {
    >word >arrow
    @word inferring-type? then(
        @arrow Arrow.ctx-type rigidify-sig!
        dup2 pack2 @word WordType prop @word ~ctx-type !
        False @word ~inferring-type? !
        /ArrowType
        cod> @arrow:cod!
        dom> @arrow:dom!
        @arrow:ctx!
    )
    arrow> word> drop
}

def guess-initial-ctx-type [ +Mirth word:Word -- +Mirth Ctx ArrowType word:Word ] {
    Ctx0 >ctx
    MetaVar.new! STMeta >dom
    MetaVar.new! STMeta >cod
    @word namespace-hard match(
        NAMESPACE_TYCON ->
            full-type-fresh
            @word name can-be-relative? if(
                @dom(swap T*+),
                @cod(swap T*+)
            ),
        NAMESPACE_MODULE ->
            drop
            @word name >Str "main" == then(
                T0 RESOURCE_WORLD T+ !dom
                T0 RESOURCE_WORLD T+ !cod
            ),
        _ ->
            drop
    )
    @word arity repeat(
        @dom(
            MetaVar.new! STMeta
            MetaVar.new! STMeta T-> >Type T*
        )
    )
    ctx> dom> cod> T->
    dup2 pack2 @word WordType prop @word ~ctx-type !
    True @word ~inferring-type? !
}

def ab-build-word!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Word +Mirth -- *b Word +Mirth ] {
    sip(ab-build-word-arrow!(dip(f))) sip(WordArrow prop)
    tuck ~arrow !
}

def ab-unify-type! [ StackType +Mirth +AB -- +Mirth +AB ] {
    dip:ab-type@ gamma:unify! ab-type!
}

def ab-atom! [ Atom +AB -- +AB ] {
    dup token ab-token!
    # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
        # ^ a sanity check to make sure
        # atom dom matches ab-arrow cod
    dup cod ab-type!
    arrow:atoms(swap ab-optimized-snoc!)
}

||| Add an atom to a list of atoms .. smartly.
def ab-optimized-snoc! [ List(Atom) Atom -- List(Atom) ] {
    while(over atoms-has-last-block? and(atom-accepts-args?),
        swap atoms-turn-last-block-to-arg swap)
    List.snoc
}

def atom-accepts-args? [ Atom -- Atom Bool ] {
    dup op match(
        OpWord -> dip(dup args len) arity <,
        OpPrim ->
            match(
                PRIM_CORE_DIP -> dup args len 1u <,
                PRIM_CORE_RDIP -> dup args len 1u <,
                PRIM_CORE_IF -> dup args len 2u <,
                PRIM_CORE_WHILE -> dup args len 2u <,
                _ -> drop False
            ),
        _ -> drop False
    )
}

def atoms-has-last-block? [ List(Atom) -- Bool ] {
    last match(
        None -> False,
        Some ->
            op match(
                OpBlockPush -> drop True,
                _ -> drop False
            )
    )
}

def atoms-turn-last-block-to-arg [ Atom List(Atom) -- Atom List(Atom) ] {
   >List+ match(
        None -> L0,
        Some ->
            unsnoc dup op match(
                OpBlockPush ->
                    { Atom List(Atom) Atom Block }
                    dip(dom rotl dom!)
                    { List(Atom) Atom Block }
                    ArgBlock swap args:cons
                    swap,
                _ -> drop List.snoc
            )
    )
}

def ab-op! [ Op +Mirth +AB -- +Mirth +AB ] {
    ab-ctx@ >ctx
    ab-token@ >token
    ab-home@ >home
    dup >op
    rdip:elab-op-fresh-sig! dip:>subst
    ab-expand-opsig! >cod >dom
    L0 >args Atom ab-atom!
}

def ab-expand-opsig! [ OpSig +Mirth +AB -- StackType StackType +Mirth +AB ] {
    { OPSIG_ID -> ab-type@ dup }
    { OPSIG_PUSH -> dip(ab-type@ dup) STCons }
    { OPSIG_APPLY ->
        /ArrowType
        ab-type@
        dom> ab-token@ rdip:elab-stack-type-unify! drop
        cod> }
}

def ab-int! [ Int +Mirth +AB -- +Mirth +AB ] { OpInt ab-op! }
def ab-f64! [ F64 +Mirth +AB -- +Mirth +AB ] { OpF64 ab-op! }
def ab-str! [ Str +Mirth +AB -- +Mirth +AB ] { OpStr ab-op! }
def ab-buffer! [ Buffer +Mirth +AB -- +Mirth +AB ] { OpBuffer ab-op! }
def ab-variable! [ Variable +Mirth +AB -- +Mirth +AB ] { OpVariable ab-op! }
def ab-field! [ Field +Mirth +AB -- +Mirth +AB ] { OpField ab-op! }
def ab-var! [ Var +Mirth +AB -- +Mirth +AB ] { OpVar ab-op! }
def ab-tag! [ Tag +Mirth +AB -- +Mirth +AB ] { OpTag ab-op! }
def ab-prim! [ Prim +Mirth +AB -- +Mirth +AB ] {
    dup ~type mut-is-set if(
        OpPrim ab-op!,
        ab-token@ "prim does not have type" rdip:emit-fatal-error!
    )
}
def ab-word! [ Word +Mirth +AB -- +Mirth +AB ] { OpWord ab-op! }
def ab-external! [ External +Mirth +AB -- +Mirth +AB ] { OpExternal ab-op! }
def ab-label-push! [ Label +Mirth +AB -- +Mirth +AB ] { OpLabelPush ab-op! }
def ab-label-pop! [ Label +Mirth +AB -- +Mirth +AB ] { OpLabelPop ab-op! }
def ab-label-push-r! [ Label +Mirth +AB -- +Mirth +AB ] { OpLabelPushR ab-op! }
def ab-label-pop-r! [ Label +Mirth +AB -- +Mirth +AB ] { OpLabelPopR ab-op! }

def ab-block-at!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Token +Mirth +AB -- *b +Mirth +AB ] {
    ab-ctx@ MetaVar.new! STMeta rotl ab-home@ rdip(ab-build!(f))
    rdip:Block.new! OpBlockPush ab-op!
}

def ab-block!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
    ab-token@ ab-block-at!(f)
}

def ab-dip!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
    ab-block!(f) PRIM_CORE_DIP ab-prim!
}

def ab-rdip!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
    ab-block!(f) PRIM_CORE_RDIP ab-prim!
}

def ab-if!(f,g) [
    (*a +Mirth +AB -- *b +Mirth +AB,
    *b +Mirth +AB -- *c +Mirth +AB)
    *a +Mirth +AB -- *c +Mirth +AB
] {
    ab-block!(f) ab-block!(g) PRIM_CORE_IF ab-prim!
}

def ab-while!(f,g) [
    (*a +Mirth +AB -- *b +Mirth +AB,
    *b +Mirth +AB -- *c +Mirth +AB)
    *a +Mirth +AB -- *c +Mirth +AB
] {
    ab-block!(f) ab-block!(g) PRIM_CORE_WHILE ab-prim!
}

def ab-lambda!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a List(Var) +Mirth +AB -- *b +Mirth +AB ] {
    dip(ab-token@) ab-lambda-at!(f)
}

def ab-lambda-at!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Token List(Var) +Mirth +AB -- *b +Mirth +AB ] {
    dup dip(
        dip(ab-ctx@ ab-type@) reverse-for(
            swap dip(dup dip(Ctx.new))
            ab-token@ rdip:elab-expand-tensor!
            dip(rotl type) rdip:elab-type-unify! drop2
        )
        rotl ab-home@ rdip(ab-build!(f))
    )
    >params >body
    ab-ctx@ >outer-ctx
    ab-type@ >dom
    ab-token@ >token
    Lambda OpLambda ab-op!
}

data OpSig {
    OPSIG_ID
    OPSIG_PUSH  [ Type ]
    OPSIG_APPLY [ ArrowType ]
}

def elab-op-fresh-sig! [ +Mirth Op -- +Mirth Subst OpSig ] {
    Subst.nil swap match (
        OpNone -> OPSIG_ID,
        OpInt -> VALUE_INT TValue OPSIG_PUSH,
        OpF64 -> VALUE_F64 TValue OPSIG_PUSH,
        OpStr -> VALUE_STR TValue OPSIG_PUSH,
        OpBuffer -> drop TYPE_PTR OPSIG_PUSH,
        OpVariable -> type TMut OPSIG_PUSH,
        OpTag -> type freshen-sig OPSIG_APPLY,
        OpWord -> dup inferring-type? if(type, type freshen-sig) OPSIG_APPLY,
        OpPrim -> type freshen-sig OPSIG_APPLY,
        OpExternal -> type freshen-sig OPSIG_APPLY,
        OpField -> type freshen-sig OPSIG_APPLY,
        OpBlockPush -> elab-block-sig!,
        OpBlockRun -> type semifreshen-sig OPSIG_APPLY,
        OpVar -> elab-var-sig!,
        OpMatch -> elab-match-sig!,
        OpLambda -> elab-lambda-sig!,
        OpLabelPush -> elab-label-push-sig!,
        OpLabelPop -> elab-label-pop-sig!,
        OpLabelPushR -> elab-label-push-r-sig!,
        OpLabelPopR -> elab-label-pop-r-sig!,
        OpDataGetEnumValue -> data-get-enum-value-type freshen-sig OPSIG_APPLY,
        OpDataFromEnumValue -> data-from-enum-value-type freshen-sig OPSIG_APPLY,
        OpDataGetLabel -> data-get-label-type freshen-sig OPSIG_APPLY,
        OpDataSetLabel -> data-set-label-type freshen-sig OPSIG_APPLY,
        OpTableToIndex -> table-to-index-type freshen-sig OPSIG_APPLY,
        OpTableFromIndex -> table-from-index-type freshen-sig OPSIG_APPLY,
    )
}

def data-get-enum-value-type [ +Mirth Data -- +Mirth ArrowType ] {
    full-type match {
        { Left  -> T1 TYPE_INT T1 T-> }
        { Right -> # not currently exposed for resources, but this is what it would be.
            T0 over T+ TYPE_INT T1 rotl T+ T-> }
    }
}
def data-from-enum-value-type [ +Mirth Data -- +Mirth ArrowType ] {
    TYPE_INT T1 T0 rotl full-type T*+ T->
}

def table-to-index-type [ +Mirth Table -- +Mirth ArrowType ] {
    TTable T1 TYPE_INT T1 T->
}
def table-from-index-type [ +Mirth Table -- +Mirth ArrowType ] {
    TTable T1 TYPE_INT T1 swap T->
}

def elab-block-sig! [ Block -- OpSig ] {
    VALUE_BLOCK TValue OPSIG_PUSH
}

def elab-match-sig! [ Match -- OpSig ] {
    sip(dom) cod T-> OPSIG_APPLY
}

def elab-lambda-sig! [ Lambda -- OpSig ] {
    sip(dom) cod T-> OPSIG_APPLY
}

def elab-var-sig! [ Var -- OpSig ] {
    dup auto-run? if-some(
        nip semifreshen-sig OPSIG_APPLY,
        type OPSIG_PUSH
    )
}

def elab-label-push-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2)
    STConsLabel dip(STCons) T-> OPSIG_APPLY
}

def elab-label-pop-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2)
    STConsLabel dip(STCons) swap T-> OPSIG_APPLY
}

def elab-label-push-r-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! STMeta MetaVar.new! TMeta Resource dup2)
    STWithLabel dip(STWith) T-> OPSIG_APPLY
}

def elab-label-pop-r-sig! [ Label -- OpSig ] {
    dip(MetaVar.new! STMeta MetaVar.new! TMeta Resource dup2)
    STWithLabel dip(STWith) swap T-> OPSIG_APPLY
}

def elab-arrow! [ +Mirth Ctx ArrowType Token Home -- +Mirth Arrow ] {
    dip2(/ArrowType dom> cod>) elab-arrow-hom!
}

def elab-arrow-hom! [ +Mirth Ctx StackType StackType Token Home -- +Mirth Arrow ] {
    rotl dip(
        elab-arrow-fwd!
        dup token-end >token +Gamma
        dup cod
    )
    unify! rdrop drop
}

def elab-arrow-fwd! [ +Mirth Ctx StackType Token Home -- +Mirth Arrow ] {
    ab-build!(elab-atoms!)
}

def elab-atoms! [ +Mirth +AB -- +Mirth +AB ] {
    while(
        ab-token@ run-end? not,
        elab-atom! ab-token@ next ab-token!
    )
}

def elab-atom! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ value match(
        TokenName -> elab-atom-name!,
        TokenDName -> elab-atom-dname!,
        TokenInt -> ab-int!,
        TokenStr -> ab-str!,
        TokenF64 -> ab-f64!,
        TokenLSquare -> drop elab-atom-block!,
        TokenLCurly -> drop elab-atom-assert!,
        TokenLabelPush -> ab-token@ rdip:args-0 ab-label-push!,
        TokenLabelPop -> ab-token@ rdip:args-0 ab-label-pop!,
        TokenLabelPushR -> ab-token@ rdip:args-0 ab-label-push-r!,
        TokenLabelPopR -> ab-token@ rdip:args-0 ab-label-pop-r!,
        TokenLabelGet -> elab-label-get!,
        TokenLabelSet -> elab-label-set!,
        _ -> ab-token@ "Unexpected token in elab-atom!" rdip:emit-fatal-error!
    )
}

def elab-label-get! [ Label +Mirth +AB -- +Mirth +AB ] {
    dup is-resource-label? if(
        dup ab-label-pop-r!
        ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
        ab-label-push-r!,

        dup ab-label-pop!
        ab-token@ num-args 0= if(
            PRIM_CORE_DUP ab-prim!,
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
        )
        ab-label-push!
    )
}

def elab-label-set! [ Label +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-0
    dup ab-label-pop!
    PRIM_CORE_DROP ab-prim!
    ab-label-push!
}

def elab-atom-block! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-1 elab-block-at!
}

def elab-block-at! [ Token +Mirth +AB -- +Mirth +AB ] {
    ab-ctx@ swap ab-home@ rdip:Block.new-deferred!(
        dup ctx swap
        dup dom swap
        dup cod swap
        dup token swap
        home
        elab-arrow-hom!
    ) OpBlockPush ab-op!
}

def elab-args! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ args for(elab-block-at!)
}

def elab-word-args! [ Word +Mirth +AB -- Word +Mirth +AB ] {
    elab-args!
    ab-token@ num-args over arity < then(
        ab-token@ num-args over rdip:params drop-slice for(
            default if-some (
                elab-block-at!,
                ab-token@ "word parameter is missing, has no default implementation" rdip:emit-fatal-error!
            )
        )
    )
}

def elab-no-args! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-0
}

def arity-compatible? [ Int Int -- Bool ] {
    dup -1 == dip(==) ||
}

def elab-atom-name! [ Name +Mirth +AB -- +Mirth +AB ] {
    dup ab-ctx@ lookup match(
        Some -> nip elab-args! ab-var!,
        None -> Left elab-atom-resolve-def!
    )
}

def elab-atom-dname! [ DName +Mirth +AB -- +Mirth +AB ] {
    Right elab-atom-resolve-def!
}

def Token.can-be-relative-name-or-dname? [ Token -- Bool ] {
    value match(
        TokenName -> can-be-relative?,
        TokenDName -> is-relative?,
        _ -> drop False
    )
}

def elab-atom-resolve-def! [ +Mirth +AB Name/DName -- +Mirth +AB ] {
    >name/dname
    ab-type@ top-types-are-fine? not >report-ambiguous-as-warning
    ab-token@ >token
    "word" >sort
    False >ignore-last-name
    >+ab resolve-def(
        filter(dup rdip:callable?, RD_WRONG_SORT)
        filter-arity
        filter-qualifiers
        token can-be-relative-name-or-dname? if(
            @+ab:ab-type@ top-types-are-fine? then(
                @+ab:ab-type@ top-namespaces filter-roots
            ),
            L0 filter-roots
        )
    ) +ab> match (
        None -> elab-atom-failed!,
        Some -> elab-atom-def!
    )
}

def elab-atom-failed! [ +Mirth +AB -- +Mirth +AB ] {
    STACK_TYPE_ERROR ab-type!
}

def elab-ambiguous-name-error! [ *a Token List(QName) +Mirth -- *b +Mirth ] {
    dip("name is ambiguous, can't decide between:")
    for(dip(" " cat) >Str cat) emit-fatal-error!
}

def elab-atom-def! [ Def +Mirth +AB -- +Mirth +AB ] {
    DefAlias -> rdip:target elab-atom-def!,
    DefBuffer -> elab-no-args! ab-buffer!,
    DefVariable -> elab-no-args! ab-variable!,
    DefExternal -> elab-no-args! ab-external!,
    DefField -> elab-no-args! ab-field!,
    DefWord -> elab-word-args! ab-word!,
    DefTag -> elab-args! ab-tag!,
    DefPrim -> elab-prim!,
    _ -> rdip:qname-hard elab-atom-not-a-word!
}

def elab-atom-not-a-word! [ QName +Mirth +AB -- +Mirth +AB ] {
    ab-type@ top-types-are-fine? if(
        dip(ab-token@ "Not a word: ") rdip:>Str cat rdip:emit-error!,
        drop
    ) elab-atom-failed!
}

def elab-prim! [ Prim +Mirth +AB -- +Mirth +AB ] {
    match(
        PRIM_CORE_MATCH -> elab-atom-match!,
        PRIM_CORE_LAMBDA -> elab-atom-lambda!,
        _ -> elab-args! ab-prim!
    )
}

def elab-atom-assert! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-1 >token
    ab-ctx@ >ctx
    True >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab rdip':elab-stack-type! rdrop
    dip:ab-type@ gamma:unify! drop
}

def elab-atom-match! [ +Mirth +AB -- +Mirth +AB ] {
    MetaVar.new! STMeta >cod
    ab-token@ succ lcurly? if(
        ab-token@ succ succ >body
        ab-token@ succ ab-token!,
        ab-token@ rdip:args+ first >body
    )
    elab-match-at!
}

||| Elaborate a match body within AB. Takes the output stack type,
||| and the token for the body of the match, from the stack. Takes
||| the rest from the AB environment.
def elab-match-at! [ cod:StackType body:Token +Mirth +AB -- +Mirth +AB ] {
    ab-match!(
        elab-match-cases!
        elab-match-exhaustive!
    )
}

||| Elaborate match cases.
def elab-match-cases! [ +Mirth +Match -- +Mirth +Match ] {
    body lcurly? if(
        elab-match-cases-curly!,
        elab-match-cases-args!
    )
}

def elab-match-cases-curly! [ +Mirth +Match -- +Mirth +Match ] {
    body run-tokens for(
        dup lcurly?
        else("Expected a pattern match case of the form { ... -> ... }" rdip:emit-fatal-error!)
        rdip:args-1 elab-match-case!
        drop
    )
}

def elab-match-cases-args! [ +Mirth +Match -- +Mirth +Match ] {
    body while(dup args-end? not, elab-match-case!) drop
}

||| Elaborate match case based on starting token.
def(elab-match-case!, Token +Mirth +Match -- Token +Mirth +Match,
    dup run-arrow? unwrap("Expected pattern match case ... -> ..." rdip:emit-fatal-error!)
    dup2 == then("expected pattern" rdip:emit-fatal-error!)
    dup2 prev == else("multi-part pattern not supported" rdip:emit-fatal-error!)
    dip:pat-tokens sip:prev succ +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup comma? then(succ)
    ))

def elab-pattern! [ List(Token) +Mirth +Pattern -- +Mirth +Pattern ] {
    reverse-for(elab-pattern-atom!)
}

def elab-pattern-atom! [ Token +Mirth +Pattern -- +Mirth +Pattern ] {
    dup pattern:token-start!

    dup pat-underscore? if(
        drop +Pattern.underscore!,

    dup name/dname? if-some(
        >name/dname >token
        "constructor" >sort
        pattern mid top-types-are-fine? not >report-ambiguous-as-warning
        False >ignore-last-name
        >+pat resolve-def(
            filter(dup tag? some?, RD_WRONG_SORT)
            filter-arity
            filter-qualifiers
            @+pat:pattern mid top-types-are-fine? then(
                @+pat:pattern mid top-namespaces
                token name? if(
                    filter(dup2 rdip:qname-hard namespace swap member, RD_WRONG_CONSTRUCTOR) drop,
                    filter-roots
                )
            )
        ) +pat> bind(tag?) match(
            Some -> +Pattern.tag!,
            None -> STACK_TYPE_ERROR pattern:mid!
        ),

        "Expected constructor name." rdip:emit-fatal-error!
    ))
}

def ab-match!(f) [
    (*a +Mirth +Match -- *b +Mirth +Match)
    *a cod:StackType body:Token +Mirth +AB -- *b +Mirth +AB
] {
    ab-ctx@ >ctx
    ab-type@ >dom
    ab-token@ >token
    ab-home@ >home
    L0 >cases
    rdip(+Match f freeze) OpMatch ab-op!
}

def +Match.case!(mkpat,mkbod) [
    (*a +Mirth +Pattern -- *b +Mirth +Pattern,
        *b +Mirth +AB -- *c +Mirth +AB)
    *a Token Token +Mirth +Match -- *c +Mirth +Match,
] {
    dip(
        +Match.home >home dup >token-start >token-end
        +Match.ctx dup >outer-ctx >inner-ctx
        L0 >saved +Match.dom dup >mid >cod L0 >atoms
        Pattern rdip(thaw mkpat freeze) >pattern
    )
    @pattern inner-ctx
    @pattern Pattern.dom +Match.cod T->
    rotl
    +Match.home
    @pattern:dip:rdip(ab-build-hom!(dip(mkbod)))
    >body Case add-case
}

def elab-expand-tensor! [ +Mirth StackType Token -- +Mirth StackType Type Token ] {
    >tok force-cons?! match(
        Some -> unpack2 tok>,
        None -> STACK_TYPE_ERROR TYPE_ERROR tok> dup "expected tuple type" emit-error!
    )
}

def elab-lambda-param? [ +Mirth Token -- +Mirth Token Maybe(Var) ] {
    dup pattern-var? if-some(
        dip(dup args-0 next)
        dip(MetaVar.new! TMeta)
        Var.new! Some,

    dup pattern-auto-run-var? if-some(
        dip(dup succ args-0 next)
        dip(MetaVar.new! STMeta MetaVar.new! STMeta T->)
        Var.new-auto-run! Some,

        None
    ))
}

def elab-atom-lambda! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-1
    collect(rdip:elab-lambda-param?)
    dip(rdip:expect-token-arrow succ)
    ab-lambda-at!(elab-atoms!)
}

||| Check that a match is exhaustive.
def elab-match-exhaustive! [ +Mirth +Match -- +Mirth +Match ] {
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw
}

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def elab-module! [ Module +World +Mirth -- Module +World +Mirth ] {
    dup start
    elab-module-header!
    while(dup module-end? not, elab-module-decl!)
    drop
}

def elab-module-package-name [ Token +Mirth -- Package Name +Mirth ] {
    dup dname? unwrap("Expected module name. (1)" emit-fatal-error!) over args-0
    dup root? unwrap(drop "Expected module name. (2)" emit-fatal-error!)
    swap parts /L1+ unwrap(drop "Expected module name. (3)" emit-fatal-error!)
    dip(Package.find-or-new! nip)
}

def elab-module-qname [ +Mirth Token -- +Mirth QName ] {
    elab-module-package-name dip(NAMESPACE_PACKAGE) QNAME0
}

||| Check that the `module(M)` statement exists and save the name.
def elab-module-header! [ +World +Mirth Token -- +World +Mirth Token ] {
    dup Some error-token!
    dup module-header? if(
        sip(next) args-1 dup elab-module-package-name
        over2 .module
        tuck ~name !
        tuck ~package !
        dup qname defined-soft? then(drop "Module name already taken." emit-fatal-error!)
        dup DefModule register
        check-module-path,

        dup "Expected module header." emit-fatal-error!
    )
}

def check-module-path [ Token Module +World +Mirth -- +World +Mirth ] {
    dup path split-last match(
        None ->
            swap qname to-module-path dup2 == else(
                "expected module name to match path\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
            ) drop3,

        Some ->
            split-last-byte(BDOT ==) "mth" Some ==
            else(over3 "expected .mth extension for mirth file" emit-warning!)
            over2 name >Str == else(over2 "expected module name to match file name" emit-fatal-error!)
            over package path! drop2
    )
}

||| Elaborate a declaration. Returns the next token.
def elab-module-decl! [ Token +World +Mirth -- Token +World +Mirth ] {
    dup Some error-token!
    dup name? unwrap("unknown declaration" emit-fatal-error!)
    defs find-some(prim?) unwrap("unknown declaration" emit-fatal-error!)
    match(
        PRIM_SYNTAX_IMPORT -> elab-module-import!,
        PRIM_SYNTAX_ALIAS -> elab-alias!,
        PRIM_SYNTAX_INLINE -> elab-inline!,
        PRIM_SYNTAX_DEF -> elab-def!,
        PRIM_SYNTAX_DEF_MISSING -> elab-def-missing!,
        PRIM_SYNTAX_DEF_TYPE -> elab-def-type!,
        PRIM_SYNTAX_DEF_EXTERNAL ->
            dup "def-external" >old "external" >new emit-deprecated!
            elab-external!,
        PRIM_SYNTAX_EXTERNAL -> elab-external!,
        PRIM_SYNTAX_BUFFER -> elab-buffer!,
        PRIM_SYNTAX_VARIABLE -> elab-variable!,
        PRIM_SYNTAX_TABLE -> elab-table!,
        PRIM_SYNTAX_FIELD -> elab-field!,
        PRIM_SYNTAX_DATA -> elab-data!,
        PRIM_SYNTAX_STRUCT -> elab-struct!,
        PRIM_SYNTAX_EMBED_STR -> elab-embed-str!,
        _ -> drop "unknown declaration" emit-fatal-error!
    )
}

def load-module [ Token QName +World +Mirth -- Token Module +World +Mirth ] {
    dup def-soft? match(
        Some -> module? unwrap(drop "module name already taken" emit-fatal-error!) nip,
        None ->
            to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
                #    https://github.com/mirth-lang/mirth/issues/241
    )
}

||| Elaborate `import(M)` statement. Return token after import.
def elab-module-import! [ Token +World +Mirth -- Token +World +Mirth ] {
    sip(next)
    args-1 dup elab-module-qname
    load-module dip(.module) add-import!
}

def parse-data [ +Mirth Token -- +Mirth Token SyntaxData ] {
    dup num-args 0> if(
        succ dup lparen? else("expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-data-tags >tags
        dup rparen? else("expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-data-tags >tags
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

def parse-data-header [ +Mirth Token -- +Mirth Token SyntaxDataHeader ] {
    dup >head next
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    SyntaxDataHeader
}

def parse-data-tags [ +Mirth Token -- +Mirth Token List(SyntaxDataTag) ] {
    collect-while(dup arg-end? not, parse-data-tag)
}

||| Parse a data tag. It looks like one of these:
|||
|||     Tag
|||     Tag -> Type* &ArgEnd
|||     Tag [ Type* ]
|||
def parse-data-tag [ +Mirth Token -- +Mirth Token SyntaxDataTag ] {
    dup >head
    dup int? dup >value? then(succ)
    dup name? filter(could-be-constructor)
    unwrap("Expected constructor name." emit-fatal-error!) >name
    succ dup arrow? if(
        succ dup Some >sig? sig-next-stack-end
        dup arg-end? else("Expected comma." emit-fatal-error!),
        dup lsquare? if(
            succ dup Some >sig? sig-next-stack-end
            dup rsquare? else("Expected right square bracket ']'" emit-fatal-error!)
            succ,

            None >sig?
        )
    )
    dup comma? then(succ)
    SyntaxDataTag
}

||| Parse a struct declaration. This looks like this:
|||
|||     struct(TypeCon, Type*)
|||     struct TypeCon { Type* }
|||
def parse-struct [ +Mirth Token -- +Mirth Token SyntaxData ] {
    dup num-args 0> if(
        succ dup lparen? then("Expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-struct-tag L1 >tags
        dup rparen? then("Expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-struct-tag L1 >tags
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

def parse-struct-tag
    [  +Mirth Token header:SyntaxDataHeader
    -- +Mirth Token header:SyntaxDataHeader SyntaxDataTag ]
{
    @header head >head
    @head last-name? filter(could-be-constructor)
    unwrap(@header head "Expected constructor name." emit-fatal-error!) >name
    None >value?
    dup Some >sig?
    sig-next-stack-end
    SyntaxDataTag
}

struct SyntaxData {
    header: SyntaxDataHeader
    tags: List(SyntaxDataTag)
}

struct SyntaxDataHeader {
    head: Token
}

struct SyntaxDataTag {
    head: Token
    value?: Maybe(Int)
    name: Name
    sig?: Maybe(Token)
}

def elab-data!   { parse-data   elab-data-aux! }
def elab-struct! { parse-struct elab-data-aux! }

def elab-data-aux! [ SyntaxData +Mirth -- +Mirth ] {
    /SyntaxData
    Data.alloc! L0 over ~tags !
    header> elab-data-header!
    tags> for(elab-data-tag!)
    elab-data-done!
}

||| Get the header, name, arity for a data type.
def elab-data-header! [ Data SyntaxDataHeader +Mirth -- Data +Mirth ] {
    /SyntaxDataHeader >data
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    elab-def-head
    @head Some @data ~head? !
    arity> >Int @data ~arity !
    name> @data ~name !
    @data DataQName >label Prop @data ~qname !
    @head args @data DataParams prop(elab-data-params!) @data ~params !
    @data DefData register
    head> drop
    data>
}

# TODO check header args are well-formed / elaborate them properly
#  as part of: https://github.com/mirth-lang/mirth/issues/246
def elab-data-params! [ List(Token) +Mirth -- List(Var) +Mirth ] {
    Ctx0 swap for(
        dup sig-type-var? unwrap("Expected a type variable." emit-fatal-error!)
        dup over3 Ctx.lookup then(swap "Duplicate parameter name." emit-fatal-error!)
        nip TYPE_TYPE swap Var.new! Ctx.new
    ) >List
}

||| Get a tag associated with a data type.
def elab-data-tag! [ Data SyntaxDataTag +Mirth -- Data +Mirth ] {
    >syn >dat
    Tag.alloc! >tag

    @dat @syn name 0 data-qname @tag ~qname !
    @syn sig? @tag ~sig? !
    @syn value? for(@tag ~value !)
    @dat @tag ~data !
    @tag @dat add-tag!
    @tag DefTag register

    @syn head @tag @tag TagType prop2(
        >tag >token
        @tag .data params >Ctx >ctx
        True >allow-implicit-type-vars
        False >allow-type-holes
        +TypeElab
        T0 @tag .data rdip:full-type T*+
        tag> sig? match(
            None -> T0,
            Some -> token! T0 elab-stack-type-parts!
        )
        swap T-> dip:ctx pack2 rdrop
    ) @tag ~ctx-type !
    @tag num-type-inputs-from-sig @tag ~num-type-inputs !
    @tag num-resource-inputs-from-sig @tag ~num-resource-inputs !
    @tag label-inputs-from-sig @tag ~label-inputs !

    @tag outputs-resource? not then(
        @tag sig? for(
            run-tokens find(
                or(sig-resource-con? >Bool, sig-resource-var? >Bool)
            ) for ("Value type cannot contain resource." emit-error!)
        )
    )

    tag> syn> drop2
    dat>
}

def data-word-new! [ +Mirth Data Str Nat -- +Mirth Word ] {
    dup >arity
    over >Name >name
    dip2(dup head? unwrap("Missing data token information." fatal-error!) dup >body >head)
    data-word-qname >qname
    None >sig?
    Word.new!

    qname> over WordQName prop over ~qname !
}

def elab-data-done! [ +Mirth Data -- +Mirth ] {
    >dat
    @dat is-value-type? then (
        @dat "enum-value" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-get-enum-value-type
        @word WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat OpDataGetEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat is-enum? then (
        @dat "from-enum-value-unsafe" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-from-enum-value-type
        @word WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat OpDataFromEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat tags /L1 for(
        >tag
        @dat "/" @tag name >Str cat 0u data-word-new! >untag
        @untag Some @tag ~untag !
        @tag @untag WordType prop(ctx-type invert pack2) @untag ~ctx-type !
        @tag @untag @untag WordArrow prop2(
            >untag >tag
            untag> ab-build-word-arrow!(
                @tag rdip:type dom >cod
                @tag .data head? unwrap("Missing data token info" rdip:fatal-error!) dup >body
                ab-match!(
                    dup case!(@tag +Pattern.tag!, id)
                )
            )
            tag> drop
        ) @untag ~arrow !
        @untag make-inline!
        @tag create-projectors!
        tag> untag> drop2
    )

    @dat @dat DataCType prop(
        >dat
        @dat is-unit? if(
            Phantom Some,
        @dat is-enum? if(
            "int" IntLike Some,
        @dat semi-transparent? if-some(
            input match(
                STPCons -> ctype?,
                STPConsLabel -> drop ctype?,
                STPWith -> ctype?,
                STPWithLabel -> drop ctype?,
            ),
            None
        )))
        dat> drop
    ) @dat ~ctype? !
    dat> drop
}

||| Return the tag's output type or resource in context.
field(Tag.~output-type, Tag, Type/Resource)
def Tag.output-type [ +Mirth Tag -- +Mirth Type/Resource ] {
    >tag
    @tag ~output-type memoize(
        @tag type cod expand match {
            { STCons -> nip Left }
            { STWith -> nip Right }
            { _ ->
                drop
                "Unexpected output type for constructor "
                @tag qname >Str cat
                @tag .data head? if-some(swap emit-error!, error!)
                TYPE_ERROR @tag .data is-resource? if(
                    Resource Right,
                    Left
                )
            }
        }
    )
    tag> drop
}

||| Return the tag's output type or resource in context, except for a missing field.
def Tag.output-type-except-field [ +Mirth Label Tag -- +Mirth Type/Resource ] {
    dup output-type map(except-field, except-field)
}

||| Return the input type for a tag along a given label.
def Tag.project-input-label [ +Mirth Label Tag -- +Mirth Maybe(Type/Resource) ] {
    type dom label-top?
}

def Tag.project-tag-field [ +Mirth Label Tag -- +Mirth Maybe(TagField) ] {
    dup2 project-input-label if-some (
        >type/resource >tag >label TagField Some,
        drop2 None
    )
}

def data-get-label-type [ +Mirth TagField -- +Mirth ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T0 @tag output-type T*+ swap T1
            @tag .data is-resource? then(@tag output-type T*+)
            T-> }
        { Right ->
            T0 @tag output-type T*+
            T0 rotl T+ @label @tag output-type-except-field T*+
            T-> }
    }
    label> tag> drop2
}

def data-set-label-type [ +Mirth TagField -- +Mirth ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T1 @tag output-type T*+
            T0 @tag output-type T*+
            T-> }
        { Right ->
            T0 swap T+ @label @tag output-type-except-field T*+
            T0 @tag output-type T*+
            T-> }
    }
    label> tag> drop2
}

def create-projectors! [ +Mirth Tag -- +Mirth ] {
    >tag
    @tag .data >dat
    @tag label-inputs reverse-for(
        >lbl
        @dat @lbl name 0 data-qname undefined-soft? then(
            @dat @lbl >Str 0u data-word-new! >lbl_get
            @dat @lbl >Str "!" cat 0u data-word-new! >lbl_set
            @dat @lbl >Str 1u data-word-new! >lbl_lens

            @lbl_get make-inline!
            @tag @lbl @lbl_get WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-get-label-type
                pack2
            ) @lbl_get ~ctx-type !
            @tag @lbl @lbl_get dup WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    OpDataGetLabel ab-op!
                )
            )) @lbl_get ~arrow !

            @lbl_set make-inline!
            @tag @lbl @lbl_set WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-set-label-type
                pack2
            ) @lbl_set ~ctx-type !
            @tag @lbl @lbl_set dup WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    OpDataSetLabel ab-op!
                )
            )) @lbl_set ~arrow !

            @lbl_lens make-inline!
            @tag @lbl @lbl_lens WordType prop2(
                >lbl >tag
                TYPE_STACK "*x" >Name Var.new! >sx
                TYPE_STACK "*y" >Name Var.new! >sy
                lbl> @tag project-input-label unwrap("logic error: expeted field in tag." fatal-error!) >lblty
                @tag output-type >datty

                @tag ctx /Ctx @sx @sy L2 cat Ctx
                @sx STVar @datty T*+
                    @sx STVar @lblty T*+
                    @sy STVar @lblty T*+ T-> TMorphism T*
                @sy STVar @datty T*+
                T-> pack2

                sx> sy> drop2
                lblty> datty> drop2
                tag> drop
            ) @lbl_lens ~ctx-type !
            @lbl_lens dup WordParams prop(
                type dom top-type? unwrap("logic error: expected parameter" fatal-error!)
                morphism? unwrap("logic error: expected morphism" fatal-error!)
                "f" >Name Var.new-auto-run! >var None >default Param L1
            ) @lbl_lens ~params !

            @dat @lbl_get @lbl_set @lbl_lens dup WordArrow prop4(
                >lbl_lens >lbl_set >lbl_get >dat
                @lbl_lens ab-build-word-arrow!(
                    lbl_lens> rdip:params map(.var) dup ab-lambda!(
                        /L1 unwrap("Expected one parameter." rdip:fatal-error!) >f
                        dat> is-resource? if(
                            lbl_get> ab-word!
                            ab-rdip!(f> ab-var!)
                            lbl_set> ab-word!,

                            PRIM_CORE_DUP ab-prim!
                            ab-dip!(
                                lbl_get> ab-word!
                                f> ab-var!
                            )
                            lbl_set> ab-word!
                        )
                    )
                )
            ) @lbl_lens ~arrow !
            lbl_get> lbl_set> lbl_lens> drop3
        )
        lbl> drop
    )
    dat> tag> drop2
}

def expect-token-arrow [ +Mirth Token -- +Mirth Token ] {
    dup arrow? else("Expected arrow." emit-fatal-error!)
}

||| Parse an alias declaration.
||| Either `alias(head, target)` or `alias head target`.
||| Both `head` and `target` are names (or dnames), with `head` taking
||| an optional argument list (for the arity), and `target` taking no arguments.
def parse-alias [ +Mirth Token -- +Mirth Token head:Token target:Token name/dname:Name/DName ] {
    dup succ lparen? >Bool >has-paren
    @has-paren if(
        sip(next) args-2 >target >head,
        next dup >head next dup >target next
    )
    @head name/dname? else(@head "expected alias name" emit-fatal-error!)
    @target name/dname? unwrap(@target "expected alias target, which must be a name" emit-fatal-error!) >name/dname
    @target args-0
    @has-paren then(
        @head next arg-end? else(@head "expected comma after alias name" emit-fatal-error!)
        @target succ arg-end? else(@head "expected end of arguments after alias target" emit-fatal-error!)
    )
    has-paren> drop
}

||| Elaborate an alias declaration.
def elab-alias! [ +Mirth Token -- +Mirth Token ] {
    parse-alias elab-def-head @arity:>Int Alias.new!
    dup AliasQName >label Prop over ~qname !

    name/dname> target> over2 dup AliasTarget prop3(
        >alias >target >name/dname
        @target >token
        "target" >sort
        False >report-ambiguous-as-warning
        False >ignore-last-name
        resolve-def(
            alias> arity filter(
                dup2 rdip:arity arity-compatible?,
                RD_WRONG_ARITY
            ) drop
            filter-qualifiers
            L0 filter-roots
        )
        unwrap( panic-diagnostics! )
        match(
            DefAlias ->
                ~target force-or!(
                    @target
                    "Alias points to itself, circular aliases are not allowed."
                    emit-fatal-error!
                ),
            _ -> id
        )
        target> drop
    ) swap ~target !
}

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def elab-def-missing! [ +Mirth Token -- +Mirth Token ] {
    dup args len 3u < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined-hard? if(next, elab-def!)
}

def elab-inline! [ Token +World +Mirth -- Token +World +Mirth ] {
    sip:next args-1
    dip:prefer-inline-defs
    True prefer-inline-defs!
    while(dup arg-end? not, elab-module-decl!)
    drop prefer-inline-defs!
}

struct SyntaxDef {
    head: Token
    sig?: Maybe(Token)
    body: Token
}

||| Parse a word definition. It looks like one of these:
|||
|||     def(word, sig, body...)
|||     def word [ sig ] { body... }
|||     def word { body... }
|||
||| Returns the next token after the definition.
def parse-def [ +Mirth Token -- +Mirth Token SyntaxDef ]
{
    dup Some error-token!
    dup args empty? if(
        next
        dup >head next
        dup lsquare? if(dup args-1 Some >sig? next, None >sig?)
        dup lcurly? else("expected { ... }" emit-fatal-error!)
        dup args+ >body
        next,

        sip(next)
        dup args dup len 3u <
            then(drop
                 "def(...) expects at least three arguments"
                 emit-fatal-error!)
            nip
        >List+ unwrap(impossible!) uncons dip(>head)
        >List+ unwrap(impossible!) uncons dip(Some >sig?)
        >List+ unwrap(impossible!) >body

        @head next arg-end? else(
            @head next "expected comma after word name" emit-fatal-error!
        )
    )
    body> uncons empty? or(dup run-arrow? >Bool)
        else("expected match case" emit-fatal-error!) >body
    SyntaxDef
}

||| Elaborate a word definition.
def elab-def! [ +Mirth Token -- +Mirth Token ] {
    parse-def /SyntaxDef
    elab-def-head Word.new! >word
    @word WordQName >label Prop @word ~qname !

    prefer-inline-defs @word ~prefer-inline? !

    @word @word WordType prop(
        dup sig? match(
            Some ->
                nip
                +TypeElab.type-sig-start!
                elab-type-sig!
                dip:ctx pack2
                rdrop,
            None ->
                arrow ctx-type pack2
        )
    ) @word ~ctx-type !
    @word @word WordParams prop(elab-def-params!) @word ~params !
    @word @word WordArrow prop(
        dup dup ab-build-word-arrow!(
            swap rdip:params dup empty? if(
                drop elab-def-body!,
                map(.var) ab-lambda!(elab-def-body!)
            )
        ) tuck check-inline-recursion-arrow!
    ) @word ~arrow !
    word> drop
}

def check-inline-recursion-arrow! [ +Mirth Word Arrow -- +Mirth ] {
    atoms for(dip:dup check-inline-recursion-atom!) drop
}
def check-inline-recursion-atom! [ +Mirth Word Atom -- +Mirth ] {
    over prefer-inline? if(
        dup2 op check-inline-recursion-op!
        args for(dip:dup check-inline-recursion-arg!) drop,
        drop2
    )
}
def check-inline-recursion-arg! [ +Mirth Word Arg -- +Mirth ] {
    ArgBlock -> arrow check-inline-recursion-arrow!
}
def check-inline-recursion-op! [ +Mirth Word Op -- +Mirth ] {
    OpBlockRun -> arrow check-inline-recursion-arrow!,
    OpWord ->
        dup2 == if(
            drop check-inline-recursion-failed!,
            dup prefer-inline? if(
                ~arrow try-force! if-some(
                    check-inline-recursion-arrow!,
                    check-inline-recursion-failed!
                ),
                drop2
            )
        ),
    OpMatch -> cases for(dip:dup body check-inline-recursion-arrow!) drop,
    OpLambda -> body check-inline-recursion-arrow!,
    _ -> drop2
}
def check-inline-recursion-failed! [ +Mirth Word -- +Mirth ] {
    dup prefer-inline? if(
        False over ~prefer-inline? !
        head "recursive word cannot be inlined" emit-warning!,
        drop
    )
}

||| Elaborate a word's parameters from its type and declaration.
def elab-def-params! [ +Mirth Word -- +Mirth List(Param) ] {
    L0 over type
    rotl head dip(/ArrowType dom> cod>) nip
    args reverse-for(
        dup sig-param-name? unwrap("expected parameter name" emit-fatal-error!) >name
        dup succ dup run-end? if(
            drop None >default,
            dup lcurly? if(
                dup succ Some >default
                next dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!),

                "expected right paren, left curly, or comma" emit-fatal-error!
            )
        )
        elab-expand-tensor!
        swap morphism? unwrap("need function type for param" emit-fatal-error!)
        nip name> Var.new-auto-run! >var Param
        rotr dip(cons)
    ) drop
}

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def elab-def-body! [ StackType +Mirth +AB -- StackType +Mirth +AB ] {
    ab-token@ run-arrow? or(ab-token@ lcurly? some?) if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    )
}

data ExternalDeclPart {
    EDPCode [ token:Token code:Str ]
    EDPDef  [ head:Token symbol:Maybe(Token) sig:Token ]
}

def parse-external-decl [ +Mirth Token -- +Mirth Token List(ExternalDeclPart) ] {
    sip(next)
    succ dup lparen-or-lcolon? else(
        pred Str(
            FGCyan emit; "external"; Reset emit;
            " requires arguments";
        )
        emit-fatal-error!
    )
    LIST(
        succ
        while(dup args-end? not,
            rdip(parse-external-decl-part) ;)
        drop
    )
}

def parse-external-decl-part [ +Mirth Token -- +Mirth Token ExternalDeclPart ] {
    dup str? if-some(
        >code dup >token
        succ
        EDPCode,

        dup >head
        dup name/dname? else("expected external word name" emit-fatal-error!)
        succ
        dup arrow? if(
            succ dup name? else("expected external symbol name" emit-fatal-error!)
            dup Some >symbol
            succ,

            None >symbol
        )
        dup lsquare? if(
            dup args-1 >sig
            next,

            dup comma? else("expected type signature" emit-fatal-error!)
            succ
            dup arg-end? then("expected type signature" emit-fatal-error!)
            dup >sig
            next-arg-end
        )
        EDPDef
    )
    dip(dup comma? then(succ))
}

||| Elaborate an external declaration.
def elab-external! [ +Mirth Token -- +Mirth Token ] {
    dup >token
    parse-external-decl
    map(elab-external-block-part!) >parts
    ExternalBlock.alloc! >extblock
    token> @extblock ~token !
    parts> @extblock ~parts !
    extblock> drop
}

def elab-external-block-part! [ +Mirth ExternalDeclPart -- +Mirth ExternalBlockPart ] {
    { EDPCode -> token> drop code> EBPCode }
    { EDPDef -> elab-external-def! EBPDef }
}

def elab-external-def! [ +Mirth head:Token symbol:Maybe(Token) sig:Token -- +Mirth External ] {
    elab-def-head

    symbol> bind(name?) unwrap(@name) >Str >symbol

    External.alloc! >external
    name> @external ~name !
    arity> >Int @external ~arity !
    @external ExternalQName >label Prop @external ~qname !
    symbol> @external ~symbol !
    sig> @external ~sig !
    head> @external ~head !
    @external dup ExternalType prop(
        sig +TypeElab.type-sig-start!
        elab-type-sig! dip:ctx pack2 rdrop
    ) @external ~ctx-type !
    @external dup ExternalCType prop(
        elab-def-external-ctype
    ) @external ~ctype !
    @external DefExternal register
    external>
}

def elab-def-external-ctype [ +Mirth External -- +Mirth CTypeArrow ] {
    dup head with-error-token(
        type ctype
        dup cod parts
        filter(sip(label? none?) ctype phantom? not &&)
        len 1u > then(
            "External has too many outputs." error!
        )

        dup dom parts filter-some(label?)
        over cod parts filter-some(label?)
        swap difference for(
            Str("Output label "; name >Str ; " not present in input";) error!
        )
    )
}

||| Elaborate a type definition `def-type(t1, t2)`.
def elab-def-type! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-2 >target >head
    @head args-0
    @head sig-type-con? else("expected type constructor" emit-fatal-error!)
    elab-def-head @head:Some
    arity> drop
    TypeDef.new!
    target> over TypeDefTarget prop(elab-simple-type-arg!) swap ~target !
}

||| Elaborate a buffer definition `buffer(B, size)`.
def elab-buffer! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-2
    swap dup elab-def-qname-undefined
    rotl dup int? unwrap("expected buffer size" emit-fatal-error!)
    >USize(nip, drop "buffer size must not be negative" emit-error! 0u >USize) Buffer.new! drop
}

||| Elaborate a var declaration `var(v, type)`.
def elab-variable! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-2
    swap dup elab-def-qname-undefined Variable.new!
    tuck VariableType prop(elab-simple-type-arg!)
    over ~type ! drop
}

||| Elaborate a table definition `table(True)`.
def elab-table! [ +Mirth Token -- +Mirth Token ] {
    sip(next) args-1 >head
    @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
    @head args-0
    @head succ arg-end? else(@head succ "expected end of argument after table name" emit-fatal-error!)
    elab-def-head
    arity> drop
    table-new! drop
}

||| Create entry point based on word name.
def elab-entry-point [ QName +Mirth -- Arrow +Mirth ] {
    dup def-hard? bind(word?) unwrap(
        dup dip(
            namespace module? for(start Some error-token!)
            "can't find entry point "
        ) >Str cat
        fatal-error!
    ) nip { Word +Mirth }
    dup dip(Ctx0 T0 RESOURCE_WORLD T+ T0 RESOURCE_WORLD T+ T->)
    head dup HomeMain ab-build-hom!(
        dip(ab-word!)
    )
}

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def elab-embed-str! [ Token +World +Mirth -- Token +World +Mirth ] {
    sip:next args-2 swap
    >head elab-def-head
    @arity 0= else(@head "expected no arguments" emit-fatal-error!)
    dup >body None >sig?
    dup str? unwrap("expected source path" emit-fatal-error!)
    >Path >+mirth open-file! unwrap!(+mirth> fatal-error!) read-file! close-file! nip >contents +mirth>
    Word.new!
    dup WordQName >label Prop over ~qname !

    Ctx0 T0 TYPE_STR T1 T-> over2 WordType prop2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop
}

||| Ensure that everything so far has been typechecked.
def typecheck-everything! [ +Mirth -- +Mirth ] {
    Name.for(defs for(dup qname-hard drop typecheck!))
    Block.for(typecheck!)
    External.for(ctype drop)
}

#########
# TABLE #
#########

def table-qname [ Table Str Int -- QName ] {
    >arity >Name >name TYCON_TABLE NAMESPACE_TYCON >namespace MKQNAME
}

def table-word-new! [ +Mirth Table Str Nat -- +Mirth Word ] {
    over2 head dup >head >body None >sig?
    dup >arity over >Name >name >Int table-qname >qname Word.new!
    qname> over WordQName prop over ~qname !
}

def table-new! [ +Mirth head:Token name:Name state:PropState(QName) -- +Mirth Table ] {
    Table.alloc! >tbl
    @tbl TableQName >label Prop @tbl ~qname !
    head> @tbl ~head !
    name> @tbl ~name !
    @tbl DefTable register

    # Table.nil
    @tbl "nil" 0u table-word-new! >word

    L0 Ctx
    T0 @tbl TTable T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @tbl head ab-token!
        0 ab-int!
        @tbl OpTableFromIndex ab-op!
    ) drop

    # Table.NUM
    @tbl head
    @tbl "NUM" 0 table-qname
    8u >USize Buffer.new!
    @tbl ~num-buffer !

    # Table.index
    @tbl "index" 0u table-word-new! >word

    L0 Ctx
    @tbl TTable T1 TYPE_INT T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl OpTableToIndex ab-op!
    ) drop

    # Table.from-index
    @tbl "from-index" 0u table-word-new! >word

    L0 Ctx
    @tbl TTable T1 TYPE_INT T1 swap T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl OpTableFromIndex ab-op!
    ) drop

    # Table.succ
    @tbl "succ" 0u table-word-new! >word

    L0 Ctx
    @tbl TTable T1 dup T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl OpTableToIndex ab-op!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        @tbl OpTableFromIndex ab-op!
    ) drop

    # Table.pred
    @tbl "pred" 0u table-word-new! >word

    L0 Ctx
    @tbl TTable T1 dup T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl OpTableToIndex ab-op!
        PRIM_CORE_DUP ab-prim!
        0 ab-int!
        PRIM_INT_EQ ab-prim!
        ab-if!(
            ,
            1 ab-int!
            PRIM_INT_SUB ab-prim!
        )
        @tbl OpTableFromIndex ab-op!
    ) drop

    { +Mirth tbl:Table }

    # Table.for
    @tbl "for" 1u table-word-new! >word
    TYPE_STACK "*a" >Name Var.new! >va
    @va STVar @tbl TTable T* @va STVar T-> "f" >Name Var.new-auto-run! >vx

    @va Ctx1
    @va STVar @vx type T* @va STVar T->
    @word WordType prop2
    @word ~ctx-type !

    @vx >var None >default Param L1
    @word WordParams prop
    @word ~params !
    @word make-inline!

    word> ab-build-word! (
        @tbl head ab-token!
        @vx L1 ab-lambda!(
            1 ab-int!
            ab-while!(
                PRIM_CORE_DUP ab-prim!
                @tbl num-buffer ab-buffer!
                PRIM_I64_GET ab-prim!
                PRIM_I64_TO_INT ab-prim!
                PRIM_INT_LE ab-prim!,

                PRIM_CORE_DUP ab-prim!
                ab-dip! (
                    @tbl OpTableFromIndex ab-op!
                    @vx ab-var!
                )
                1 ab-int!
                PRIM_INT_ADD ab-prim!
            )
            PRIM_CORE_DROP ab-prim!
        )
    ) drop
    va> vx> drop2

    # Table.alloc!
    @tbl "alloc!" 0u table-word-new! >word

    L0 Ctx
    T0 @tbl TTable T1 T->
    @word WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @tbl head ab-token!
        @tbl num-buffer ab-buffer!
        PRIM_I64_GET ab-prim!
        PRIM_I64_TO_INT ab-prim!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        PRIM_CORE_DUP ab-prim!
        PRIM_INT_TO_I64 ab-prim!
        @tbl num-buffer ab-buffer!
        PRIM_I64_SET ab-prim!
        @tbl OpTableFromIndex ab-op!
    ) drop

    tbl>
}

#########
# FIELD #
#########

def resolve-def-namespace [ +Mirth Token name/dname:Name/DName -- +Mirth Maybe(Namespace) ] {
    >token
    "namespace" >sort
    True >ignore-last-name
    False >report-ambiguous-as-warning
    resolve-def(
        filter-sort(dup rdip:exposed-tycon? >Bool)
        filter-qualifiers
        L0 filter-roots
    )
    bind(as-namespace?)
}

def elab-qname-from-nonrelative-dname [ +Mirth Token DName arity:Int -- +Mirth QName ] {
    dup Right >name/dname
    dup root? else(drop "relative name not allowed" emit-fatal-error!)
    last-name >name
    dup resolve-def-namespace unwrap(panic-diagnostics!) >namespace
    drop MKQNAME
}

def module-visible-from-token? [ Token Module -- Bool ] {
    swap .module visible
}

def def-visible-from-token? [ Token Def -- Bool ] {
    defining-module? match(
        None -> drop True,
        Some -> module-visible-from-token?
    )
}

def Token.is-default-param? [ Token -- Bool ] {
    dup name? and( dup succ lcurly? >Bool ) nip
}

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def elab-def-qname [ +Mirth Token -- +Mirth QName ] {
    dup args dup has(is-default-param?) if(drop -1, len >Int) >arity
    dup name/dname? unwrap("expected name" emit-fatal-error!)
    match(
        Left -> >name .module NAMESPACE_MODULE >namespace MKQNAME,
        Right -> elab-qname-from-nonrelative-dname
    )
}

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def elab-def-qname-undefined [ +Mirth Token -- +Mirth QName ] {
    dup elab-def-qname
    dup defined-soft? then(drop "name already defined" emit-fatal-error!)
    nip
}

||| Elaborate the head, i.e. the name-giving token, of a definition.
||| We defer the full resolution of the qualified name, but otherwise
||| we collect arity and (simple) name data from the head token.
def elab-def-head [
    +Mirth head:Token --
    +Mirth head:Token name:Name arity:Nat state:PropState(QName)
] {
    @head name/dname?
        unwrap(@head "expected name" emit-fatal-error!)
        either(id, parts last) >name
    @head num-args >arity
    @head [elab-def-qname-undefined] PSDelay >state
}

||| Parse a field definition, `field(f, T1, T2)`
def parse-field [
    +Mirth Token -- +Mirth Token
    head:Token index-type:Token value-type:Token
] {
    sip(next) args-3 >value-type >index-type >head
    @head name/dname? else(@head "expected field name" emit-fatal-error!)
    @head args-0
}

||| Elaborate a field definition `field(f, T1, T2)`.
def elab-field! [ +Mirth Token -- +Mirth Token ] {
    parse-field elab-def-head
    Field.alloc! >fld
    name> @fld ~name !
    head> @fld ~head !
    arity> 0= else(@fld head "Field cannot take arguments." emit-error!)
    @fld FieldQName >label Prop @fld ~qname !
    index-type> @fld FieldIndexType prop(elab-simple-type-arg!) @fld ~index-type !
    value-type> @fld FieldValueType prop(elab-simple-type-arg!) @fld ~value-type !
    fld> DefField register
}
