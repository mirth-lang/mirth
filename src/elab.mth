module mirth.elab

import std.prelude
import std.str
import std.list
import std.maybe
import std.either
import std.byte
import std.terminal

import mirth.mirth
import mirth.name
import mirth.def
import mirth.token
import mirth.data
import mirth.external
import mirth.word
import mirth.var
import mirth.buffer
import mirth.table
import mirth.tycon
import mirth.type
import mirth.typedef
import mirth.var
import mirth.arrow
import mirth.word
import mirth.prim
import mirth.module
import mirth.package
import mirth.alias
import mirth.match
import mirth.lexer
import mirth.label
import mirth.macro

####################
# Type Elaboration #
####################

struct +TypeElab {
    ctx:Ctx
    token:Token
    allow-type-holes:Bool
    allow-implicit-type-vars:Bool
    --
    def rdrop [ +TypeElab -- ] {
        /+TypeElab
        ctx> token> drop2
        allow-type-holes> drop
        allow-implicit-type-vars> drop
    }

    def Start! [ Token -- +TypeElab ] {
        >token
        Ctx.L0 >ctx
        False >allow-type-holes
        True >allow-implicit-type-vars
        +TypeElab
    }

    def elab-type-sig! [ +Mirth +TypeElab -- +Mirth +TypeElab ArrowType ] {
        token rdip:run-end? then(token "expected type signature" rdip:emit-error!)
        elab-type-sig-params!
        elab-stack-type!
        token rdip:sig-dashes? if(token:succ elab-stack-type!, dip:T0)
        token rdip:run-end? else(token "expected right paren or comma" rdip:emit-error!)
        dip(swap for(T*)) T->
    }

    def elab-type-sig-params! [ +Mirth +TypeElab -- +Mirth +TypeElab List(Type) ] {
        token rdip:lparen? if(
            token rdip:next
            token rdip:args map(token! elab-type-sig! Type.Arrow)
            dip:token!,
            L0
        )
    }

    def elab-stack-type! [ +Mirth +TypeElab -- +Mirth +TypeElab StackType ] {
        token rdip:sig-stack-var? if?(elab-stack-type-var!, T0)
        elab-stack-type-parts!
    }

    def elab-stack-type-parts! [ +Mirth +TypeElab StackType -- +Mirth +TypeElab StackType ] {
        while(token rdip:sig-stack-end? not, elab-stack-type-part! cons)
    }



    def elab-type-arg! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
        token elab-stack-type-part!
        match(
            Cons -> nip,
            ConsLabel -> drop2 "Expected type, not label." rdip:emit-error! Type.Error,
            With -> drop "Expected type, not resource." rdip:emit-error! Type.Error,
            WithLabel -> drop2 "Expected type, not labelled resource." rdip:emit-error! Type.Error,
        )
        token rdip:arg-end? else(
            token "Unexpected token after type." rdip:emit-error!
        )
    }

    def elab-resource-arg! [ +Mirth +TypeElab -- +Mirth +TypeElab Resource ] {
        token elab-stack-type-part!
        match(
            Cons -> drop "Expected resource, not type." rdip:emit-error! Type.Error Resource,
            ConsLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
            With -> nip,
            WithLabel -> drop2 "Expected resource, not label." rdip:emit-error! Type.Error Resource,
        )
        token rdip:arg-end? else(
            token "Unexpected token after resource." rdip:emit-error!
        )
    }

    def elab-stack-type-part! [ +Mirth +TypeElab -- +Mirth +TypeElab StackTypePart ] {
        token rdip:sig-label? if?(
            elab-stack-label!,

        token rdip:sig-type-var? if?(
            elab-type-var! StackTypePart.Cons,

        token rdip:sig-type-con? if?(
            elab-type-con! StackTypePart.Cons,

        token rdip:sig-resource-var? if?(
            elab-resource-var! StackTypePart.With,

        token rdip:sig-resource-con? if?(
            elab-resource-con! StackTypePart.With,

        token rdip:pat-underscore? if(
            elab-type-dont-care! StackTypePart.Cons,

        token rdip:sig-type-hole? if?(
            elab-type-hole! StackTypePart.Cons,

        token rdip:lsquare? .if(
            elab-type-quote! StackTypePart.Cons,

            token "Expected type, got unknown token." rdip:emit-error!
            token:next Type.Error StackTypePart.Cons
        ))))))))
    }

    def elab-stack-label! [ +Mirth +TypeElab Label -- +Mirth +TypeElab StackTypePart ] {
        token rdip:next dip(
            token:args-1 dup rdip:is-resource-label? if(
                elab-resource-arg! swap StackTypePart.WithLabel,
                elab-type-arg! swap StackTypePart.ConsLabel
            )
        ) token!
    }

    def elab-stack-type-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab StackType ] {
        Type.StackType elab-implicit-var! if?(StackType.Var, StackType.Error)
    }

    def elab-type-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Type ] {
        Type.Type elab-implicit-var! if?(Type.Var, Type.Error)
    }

    def elab-resource-var! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Resource ] {
        Type.ResourceType elab-implicit-var! if?(Type.Var, Type.Error) Resource
    }

    def gamma(f) [ (*a +Gamma -- *b +Gamma) *a +TypeElab -- *b +TypeElab ] {
        token rdip(>token +Gamma f rdrop)
    }

    def elab-implicit-var! [ +Mirth +TypeElab Name Type -- +Mirth +TypeElab Maybe(Var) ] {
        over ctx rdip:lookup match(
            Some -> sip(dip:nip rdip:type gamma:unify! drop) Some,
            None ->
                allow-implicit-type-vars if(
                    swap ctx(dip:Var.new! over Ctx.new) Some,
                    token "Implicit type variable not allowed here." rdip:emit-error!
                    drop2 None
                )
        )
        token rdip:args-0
        token:succ
    }

    def resolve-type-con-name! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Type List(Var) ] {
        >name/dname
        False >report-ambiguous-as-warning
        False >ignore-last-name
        token >token "type" >sort rdip:resolve-def(
            filter(dup rdip:defines-a-type?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            L0 filter-roots
        ) if? (
            match(
                Data -> sip:Type.Data rdip:params,
                Table -> Type.Table L0,
                Type -> rdip(sip:target params),
                _ ->
                    drop token "compiler bug: resolve-type-con-name! doesn't understand type"
                    rdip:emit-error! Type.Error L0,
            ),
            Type.Error L0
        )
    }

    def elab-type-con! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Type ] {
        dup left? rdip:has(>Str "Mut" ==) if(
            drop token rdip:next dip(
                token:args-1
                elab-type-arg!
                Type.Mut
            ) token!,

            resolve-type-con-name! elab-type-args!
            token:next
        )
    }

    def elab-resource-con! [ +Mirth +TypeElab Name/DName -- +Mirth +TypeElab Resource ] {
        elab-type-con! Resource
    }

    def with-token(f) [ (*a +TypeElab -- *b +TypeElab) *a +TypeElab Token -- *b +TypeElab ] {
        token:swap dip(f) token!
    }

    def elab-type-args! [ +Mirth +TypeElab Type List(Var) -- +Mirth +TypeElab Type ] {
        token rdip:args for(
            with-token(elab-type-app!)
        ) drop
    }

    def elab-type-app! [ +Mirth +TypeElab Type List(Var) -- +Mirth +TypeElab Type List(Var) ] {
        uncons swap if? (
            rdip:sort? else?(token "Type parameter has unknown sort." rdip:emit-fatal-error!) match {
                { Resource -> elab-resource-arg! >Type }
                { Stack -> elab-stack-type! >Type }
                { Type -> elab-type-arg! }
            } swap dip:Type.App,

            drop rdip:tycon? then?(
                token rdip:Str("Too many type arguments to "; swap rdip(qname-hard >Str) ;) rdip:emit-error!
            )
            Type.Error L0
        )
    }

    def elab-type-hole! [ +Mirth +TypeElab Name -- +Mirth +TypeElab Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Hole,
            drop
            token "type holes are not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-dont-care! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
        allow-type-holes if(
            token rdip:args-0
            Type.Ignore,
            token "underscore is not allowed here" rdip:emit-error!
            Type.Error
        )
        token:next
    }

    def elab-type-quote! [ +Mirth +TypeElab -- +Mirth +TypeElab Type ] {
        token rdip:next dip(
            token:args-1
            token rdip:sig-has-dashes? if(
                elab-type-sig! >Type,
                elab-stack-type! >Type
            )
        ) token!
    }
}

def show-num-arguments [ Int -- Str ] {
    dup 1 == if(drop "1 argument",
    show " arguments" cat)
}

# TODO: separate this into a reason and a def.
data RejectedDef {
    WrongSort          [ Def ]
    WrongArity         [ Def ]
    NotVisible         [ Def ]
    NotImported        [ Def ]
    WrongQualifier     [ Def ]
    WrongConstructor   [ Def ]
    MethodNotAvailable [ Def ]
    MethodWrongType    [ Def ]
}

struct +ResolveDef {
    sort: Str
    token: Token
    name/dname: Name/DName
    candidates: List(Def)
    rejected: List(RejectedDef)
    ignore-last-name: Bool
    report-ambiguous-as-warning: Bool
    --
    def rdrop [ +ResolveDef -- ] {
        /+ResolveDef
        sort> token> name/dname> drop3
        candidates> rejected> drop2
        ignore-last-name> drop
        report-ambiguous-as-warning> drop
    }

    def Begin! [
        sort:Str
        token:Token
        name/dname:Name/DName
        ignore-last-name:Bool
        report-ambiguous-as-warning:Bool
        +Mirth
        -- +Mirth +ResolveDef
    ] {
        @ignore-last-name if(
            @name/dname name/dname-penultimate-name? unwrap(
                @token "Expected a namespace." emit-fatal-error!
            ),
            @name/dname name/dname-last-name
        ) defs >candidates
        List.Nil >rejected
        +ResolveDef
    }

    def expunge(p) [
        (*a Def -- *a Bool)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        candidates:filter(p not)
    }

    def filter(p) [
        (*a Def +ResolveDef -- *a Either(RejectedDef, Def) +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        candidates partition-either(p) dip:rejected:cat candidates!
    }

    def filter(p,q) [
        (*a Def +ResolveDef -- *a Def Bool +ResolveDef,
         *a Def +ResolveDef -- *a RejectedDef +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        filter(p if(Right, q Left))
    }


    def filter-sort(p) [
        (*a Def +ResolveDef -- *a Def Bool +ResolveDef)
        *a +ResolveDef -- *a +ResolveDef
    ] {
        filter(p, RejectedDef.WrongSort)
    }

    def filter-arity [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        token rdip:num-args filter(
            dup2 rdip:qname-hard arity dip(>Int) arity-compatible?,
            RejectedDef.WrongArity
        ) drop
    }

    def filter-visible [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        filter(token over rdip:def-visible-from-token?, RejectedDef.NotVisible)
    }

    def filter-qualifiers [ +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        token rdip:dname? for(
            filter(dup2 rdip:qname-hard climb-up-dname? empty? not, RejectedDef.WrongQualifier)
            drop
        )
    }

    def filter-roots [ List(Namespace) +Mirth +ResolveDef -- +Mirth +ResolveDef ] {
        name/dname match {
            { Left ->
                >name
                filter(
                    dup2 rdip:qname-hard namespace swap member
                    or(token over rdip:def-is-imported-at-token?),
                    dup rdip:qname-hard namespace match(
                        Tycon ->
                            drop @name rdip:can-be-relative? if(
                                over empty? if(
                                    RejectedDef.MethodNotAvailable,
                                    RejectedDef.MethodWrongType
                                ),
                                RejectedDef.NotImported
                            ),
                        _ -> drop RejectedDef.NotImported
                    )
                )
                name> drop
            }

            { Right ->
                dup is-relative? and(ignore-last-name not) if(
                    filter(dup2 rdip:qname-hard climb-up-dname? has(over3 member),
                        over2 empty? if(
                            RejectedDef.MethodNotAvailable,
                            RejectedDef.MethodWrongType
                        )
                    ),
                    filter(dup2 rdip:qname-hard climb-up-dname? has(
                        dip:token rdip:namespace-is-imported-at-token?
                    ), RejectedDef.NotImported)
                ) drop
            }
        }

        drop
    }

    def end! [ +Mirth +ResolveDef -- +Mirth Maybe(Def) ] {
        candidates match(
            Nil -> resolve-def-unknown None,
            Cons -> match(
                Nil -> rdrop Some,
                _ -> List.filter(over rdip:same-resolved? not) match(
                    Nil -> rdrop Some,
                    _ -> drop2 resolve-def-ambiguous None
                )
            )
        )
    }

    def resolve-def-ambiguous [ +Mirth +ResolveDef -- +Mirth ] {
        report-ambiguous-as-warning if(
            token Str(
                "Can't resolve " ; rdip:sort ; " due to previous errors. Candidates are:" ;
                " " rdip:candidates for(swap ; rdip2(qname-hard >Str) ; ", ") drop
            ) rdip:emit-warning!,

            token Str(
                "Ambiguous " ; rdip:sort ; ". Can't decide between:" ;
                " " rdip:candidates for(swap ; rdip2(qname-hard >Str) ; ", ") drop
            ) rdip:emit-error!
        ) rdrop
    }

    def resolve-def-unknown [ +Mirth +ResolveDef -- +Mirth ] {
        token Str(rdip:rejected match(
            Nil -> "Unknown " ; rdip:sort ; " name, possibly a misspelling." ;,
            Cons ->
                match(
                    Nil -> match(
                        WrongSort ->
                            "Expected a " ; rdip:sort ; ", but " ;
                            rdip2(qname-hard >Str) ; " is not a " ; rdip:sort ; "." ; ,
                        NotVisible ->
                            "Not visible in current scope: " ; rdip2(qname-hard >Str) ; ,
                        NotImported ->
                            "Not imported in current scope: " ; rdip2(qname-hard >Str) ; ,
                        WrongArity ->
                            rdip2(qname-hard dup >Str) ; " expects " ; arity show;
                            " arguments, but got " ; rdip:token rdip2:num-args show; "." ; ,
                        WrongQualifier ->
                            "Qualified name not found. Perhaps you meant: " ; rdip2(qname-hard >Str) ; ,
                        WrongConstructor ->
                            "Constructor is for a different type: " ; rdip2(qname-hard >Str) ; ,
                        MethodWrongType ->
                            "Method is for a different type: " ; rdip2(qname-hard >Str) ; ,
                        MethodNotAvailable ->
                            "Method is not available for current stack: " ; rdip2(qname-hard >Str) ; ,
                    ),
                    _ -> cons "Multiple definitions for name, but none are suitable:" ;
                        dip:" " for(swap ; match(
                            WrongSort -> rdip2(qname-hard >Str) ; " is not a " ; rdip:sort ; ,
                            NotVisible ->
                                rdip2(qname-hard >Str) ; " is not visible in current scope" ; ,
                            NotImported ->
                                rdip2(qname-hard >Str) ; " is not imported in current scope" ; ,
                            WrongArity ->
                                rdip2(qname-hard dup >Str) ; " expects " ;
                                arity show; " arguments" ; ,
                            WrongQualifier ->
                                rdip2(qname-hard >Str) ; " doesn't match the given qualified name" ; ,
                            WrongConstructor ->
                                rdip2(qname-hard >Str) ; " is constructor for a different type" ; ,
                            MethodWrongType ->
                                rdip2(qname-hard >Str) ; " is method for a different type" ; ,
                            MethodNotAvailable ->
                                rdip2(qname-hard >Str) ; " is not avaliable for current stack" ; ,
                        ) ", ") drop
                )
        )) rdip:emit-error! rdrop
    }
}

def +Mirth.resolve-def(f) [
    (*a +Mirth +ResolveDef -- *b +Mirth +ResolveDef)
    *a +Mirth
    sort:Str
    token:Token
    name/dname: Name/DName
    ignore-last-name:Bool
    report-ambiguous-as-warning:Bool
    --
    *b +Mirth Maybe(Def),
] {
    +ResolveDef.Begin! f end!
}

def QName.punning? [ +Mirth QName -- +Mirth Bool ] {
    dup namespace match {
        { Tycon -> name swap name == }
        { _ -> drop2 False }
    }
}

def Def.punning? [ +Mirth Def -- +Mirth Bool ] {
    qname-hard punning?
}

||| Check whether a definition can be referred to without qualification.
def def-is-imported-at-token? [ +Mirth Token Def -- +Mirth Bool ] {
    # TODO: implement finer grained control over what is imported.
    #   https://github.com/mirth-lang/mirth/issues/243
    dup qname-hard namespace match(
        Root -> drop2 True,
        Package -> drop3 True,
        Module -> nip module-visible-from-token?,
        Tycon -> dip:swap tycon-is-visible-at-token? if(punning?, drop False),
        Word -> drop3 False
    )
}

def tycon-is-visible-at-token? [ +Mirth Token Tycon -- +Mirth Bool ] {
    Data -> head? if?(.module module-visible-from-token?, drop True),
    Table -> head .module module-visible-from-token?,
    Prim -> drop2 True
}

def namespace-is-imported-at-token? [ +Mirth Token Namespace -- +Mirth Bool ] {
    Root -> drop True,
    Package -> drop2 True,
    Module -> module-visible-from-token?,
    Tycon -> qname-hard namespace namespace-is-imported-at-token?,
    Word -> drop2 False
}

def QName.climb-up-name? [ +Mirth Name QName -- +Mirth List(Namespace) ] {
    >qname >name

    @qname name @name == if(
        @qname namespace L1,
        L0
    ) >accum
    name> defs for(match(
        Alias ->
            dup ~target try-force! has(qname-hard @qname ==) if(
                namespace-hard @accum:cons,
                drop
            ),
        Type ->
            dup target tycon? has(qname-hard @qname ==) if(
                namespace @accum:cons,
                drop
            ),
        _ -> drop
    ))
    qname> drop
    accum>
}

def QName.climb-up-dname? [ +Mirth +ResolveDef DName QName -- +Mirth +ResolveDef List(Namespace) ] {
    dip(sip(root? >List) parts unsnoc dip(cat)
        ignore-last-name then(drop unsnoc unwrap(
            token "Error, expected a namespace in QName.climb-up-dname?" rdip:emit-fatal-error!
        ))
    )
    rdip:climb-up-name? swap
    reverse-for(swap bind(rdip:qname if?(dip(dup) rdip:climb-up-name?, L0)) nip)
}

def elab-type-unify! [ +Mirth Type Type Token -- +Mirth Type Token ] {
    >token +Gamma unify! /+Gamma token>
}
def elab-stack-type-unify! [ +Mirth StackType StackType Token -- +Mirth StackType Token ] {
    >token +Gamma unify! /+Gamma token>
}

def elab-simple-type-arg! [ +Mirth Token -- +Mirth Type ] {
    >token
    Ctx.L0 >ctx
    False >allow-type-holes
    False >allow-implicit-type-vars
    +TypeElab elab-type-arg! rdrop
}

####################
# Word Elaboration #
####################

struct +AB {
    arrow:Arrow
    --
    def ab-token@ [ +AB -- +AB Token ] { arrow token-end }
    def ab-token! [ +AB Token -- +AB ] { arrow:token-end! }
    def ab-type@ [ +AB -- +AB StackType ] { arrow cod }
    def ab-type! [ +AB StackType -- +AB ] { arrow:cod! }
    def ab-ctx@ [ +AB -- +AB Ctx ] { arrow ctx }
    def ab-home@ [ +AB -- +AB Home ] { arrow home }
    def gamma(f) [ (*a +Gamma -- *b +Gamma) *a +AB -- *b +AB ] {
        ab-token@ rdip(>token +Gamma f rdrop)
    }

    def ab-unify-type! [ StackType +Mirth +AB -- +Mirth +AB ] {
        dip:ab-type@ gamma:unify! ab-type!
    }

    def ab-atom! [ Atom +AB -- +AB ] {
        dup token ab-token!
        # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
            # ^ a sanity check to make sure
            # atom dom matches ab-arrow cod
        dup cod ab-type!
        arrow:atoms(swap ab-optimized-snoc!)
    }

    def ab-op! [ Op +Mirth +AB -- +Mirth +AB ] {
        ab-ctx@ >ctx
        ab-token@ >token
        ab-home@ >home
        dup >op
        rdip:elab-op-fresh-sig! dip:>subst
        ab-expand-opsig! >cod >dom
        L0 >args Atom ab-atom!
    }

    def ab-expand-opsig! [ OpSig +Mirth +AB -- StackType StackType +Mirth +AB ] {
        { OpSig.Id -> ab-type@ dup }
        { OpSig.Push -> dip(ab-type@ dup) StackType.Cons }
        { OpSig.Apply ->
            /ArrowType
            ab-type@
            dom> ab-token@ rdip:elab-stack-type-unify! drop
            cod> }
    }

    def ab-int! [ Int +Mirth +AB -- +Mirth +AB ] { Op.Int ab-op! }
    def ab-f64! [ F64 +Mirth +AB -- +Mirth +AB ] { Op.F64 ab-op! }
    def ab-str! [ Str +Mirth +AB -- +Mirth +AB ] { Op.Str ab-op! }
    def ab-buffer! [ Buffer +Mirth +AB -- +Mirth +AB ] { Op.Buffer ab-op! }
    def ab-field! [ Field +Mirth +AB -- +Mirth +AB ] { Op.Field ab-op! }
    def ab-var! [ Var +Mirth +AB -- +Mirth +AB ] { Op.Var ab-op! }
    def ab-tag! [ Tag +Mirth +AB -- +Mirth +AB ] { Op.Tag ab-op! }
    def ab-prim! [ Prim +Mirth +AB -- +Mirth +AB ] { Op.Prim ab-op! }
    def ab-word! [ Word +Mirth +AB -- +Mirth +AB ] { Op.Word ab-op! }
    def ab-external! [ External +Mirth +AB -- +Mirth +AB ] { Op.External ab-op! }
    def ab-label-push! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPush ab-op! }
    def ab-label-pop! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPop ab-op! }
    def ab-label-push-r! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPushR ab-op! }
    def ab-label-pop-r! [ Label +Mirth +AB -- +Mirth +AB ] { Op.LabelPopR ab-op! }

    def ab-block-at!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Token +Mirth +AB -- *b +Mirth +AB ] {
        ab-ctx@ rdip:MetaVar.new! StackType.Meta rotl ab-home@ rdip(ab-build!(f))
        rdip:Block.new! Op.BlockPush ab-op!
    }

    def ab-block!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
        ab-token@ ab-block-at!(f)
    }

    def ab-dip!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
        ab-block!(f) Prim.Dip ab-prim!
    }

    def ab-rdip!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a +Mirth +AB -- *b +Mirth +AB ] {
        ab-block!(f) Prim.RDip ab-prim!
    }

    def ab-if!(f,g) [
        (*a +Mirth +AB -- *b +Mirth +AB,
        *b +Mirth +AB -- *c +Mirth +AB)
        *a +Mirth +AB -- *c +Mirth +AB
    ] {
        ab-block!(f) ab-block!(g) Prim.If ab-prim!
    }

    def ab-while!(f,g) [
        (*a +Mirth +AB -- *b +Mirth +AB,
        *b +Mirth +AB -- *c +Mirth +AB)
        *a +Mirth +AB -- *c +Mirth +AB
    ] {
        ab-block!(f) ab-block!(g) Prim.While ab-prim!
    }

    def ab-lambda!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a List(Var) +Mirth +AB -- *b +Mirth +AB ] {
        dip(ab-token@) ab-lambda-at!(f)
    }

    def ab-lambda-at!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Token List(Var) +Mirth +AB -- *b +Mirth +AB ] {
        dup dip(
            dip(ab-ctx@ ab-type@) reverse-for(
                swap dip(dup dip(Ctx.new))
                ab-token@ rdip:elab-expand-tensor!
                dip(rotl rdip:type) rdip:elab-type-unify! drop2
            )
            rotl ab-home@ rdip(ab-build!(f))
        )
        >params >body
        ab-ctx@ >outer-ctx
        ab-type@ >dom
        ab-token@ >token
        Lambda Op.Lambda ab-op!
    }

    def ab-match!(f) [
        (*a +Mirth +Match -- *b +Mirth +Match)
        *a cod:StackType body:Token +Mirth +AB -- *b +Mirth +AB
    ] {
        ab-ctx@ >ctx
        ab-type@ >dom
        ab-token@ >token
        ab-home@ >home
        L0 >cases
        rdip(+Match f freeze) Op.Match ab-op!
    }

    def elab-atoms! [ +Mirth +AB -- +Mirth +AB ] {
        while(
            ab-token@ rdip:run-end? not,
            elab-atom! ab-token@ rdip:next ab-token!
        )
    }

    def elab-atom! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:value match(
            Name -> elab-atom-name!,
            DName -> elab-atom-dname!,
            Int -> ab-int!,
            Str -> ab-str!,
            F64 -> ab-f64!,
            LSquare -> drop elab-atom-block!,
            LCurly -> drop elab-atom-assert!,
            LabelPush -> ab-token@ rdip:args-0 ab-label-push!,
            LabelPop -> ab-token@ rdip:args-0 ab-label-pop!,
            LabelPushR -> ab-token@ rdip:args-0 ab-label-push-r!,
            LabelPopR -> ab-token@ rdip:args-0 ab-label-pop-r!,
            LabelGet -> elab-label-get!,
            LabelSet -> elab-label-set!,
            _ -> ab-token@ "Unexpected token in elab-atom!" rdip:emit-fatal-error!
        )
    }

    def elab-label-get! [ Label +Mirth +AB -- +Mirth +AB ] {
        dup rdip:is-resource-label? if(
            dup ab-label-pop-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-push-r!,

            dup ab-label-pop!
            ab-token@ rdip:num-args 0= if(
                Prim.Dup ab-prim!,
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            )
            ab-label-push!
        )
    }

    def elab-label-set! [ Label +Mirth +AB -- +Mirth +AB ] {
        dup rdip:is-resource-label? if(
            dup ab-label-push-r!
            ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
            ab-label-pop-r!,

            ab-token@ rdip:num-args 0= if(
                dup ab-label-pop!
                Prim.Drop ab-prim!
                ab-label-push!,

                dup ab-label-push!
                ab-token@ dup rdip:args-1 ab-token! elab-atoms! ab-token!
                ab-label-pop!
            )
        )
    }

    def elab-atom-block! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args-1 elab-block-at!
    }

    def elab-block-at! [ Token +Mirth +AB -- +Mirth +AB ] {
        ab-ctx@ swap ab-home@ rdip:Block.new-deferred!(
            dup ctx swap
            dup dom swap
            dup cod swap
            dup token swap
            home
            elab-arrow-hom!
        ) Op.BlockPush ab-op!
    }

    def elab-args! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args for(elab-block-at!)
    }

    def elab-word-args! [ Word +Mirth +AB -- Word +Mirth +AB ] {
        elab-args!
        ab-token@ rdip:num-args over arity < then(
            ab-token@ rdip:num-args over rdip:params drop-slice for(
                default if? (
                    ab-token@ rdip:location >location rdip:clone-run! elab-block-at!,
                    ab-token@ "word parameter is missing, has no default implementation" rdip:emit-fatal-error!
                )
            )
        )
    }

    def elab-no-args! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args-0
    }

    def elab-atom-name! [ Name +Mirth +AB -- +Mirth +AB ] {
        dup ab-ctx@ rdip:lookup match(
            Some -> nip elab-args! ab-var!,
            None -> Left elab-atom-resolve-def!
        )
    }

    def elab-atom-dname! [ DName +Mirth +AB -- +Mirth +AB ] {
        Right elab-atom-resolve-def!
    }

    def Token.can-be-relative-name-or-dname? [ +Mirth Token -- +Mirth Bool ] {
        value match(
            Name -> can-be-relative?,
            DName -> is-relative?,
            _ -> drop False
        )
    }

    def elab-atom-resolve-def! [ +Mirth +AB Name/DName -- +Mirth +AB ] {
        >name/dname
        ab-type@ rdip:top-types-are-fine? not >report-ambiguous-as-warning
        ab-token@ >token
        "word" >sort
        False >ignore-last-name
        >+ab resolve-def(
            filter(dup rdip:callable?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            token rdip:can-be-relative-name-or-dname? if(
                @+ab:ab-type@ rdip:top-types-are-fine? then(
                    @+ab:ab-type@ rdip:top-namespaces filter-roots
                ),
                L0 filter-roots
            )
        ) +ab> match (
            None -> elab-atom-failed!,
            Some -> elab-atom-def!
        )
    }

    def elab-atom-failed! [ +Mirth +AB -- +Mirth +AB ] {
        StackType.Error ab-type!
    }

    def elab-ambiguous-name-error! [ *a Token List(QName) +Mirth -- *b +Mirth ] {
        dip("name is ambiguous, can't decide between:")
        for(dip(" " cat) >Str cat) emit-fatal-error!
    }

    def elab-atom-def! [ Def +Mirth +AB -- +Mirth +AB ] {
        Alias -> rdip:target elab-atom-def!,
        Buffer -> elab-no-args! ab-buffer!,
        External -> elab-no-args! ab-external!,
        Field -> elab-no-args! ab-field!,
        Word -> elab-word-args! ab-word!,
        Tag -> elab-args! ab-tag!,
        Prim -> elab-prim!,
        Macro -> elab-macro!,
        _ -> rdip:qname-hard elab-atom-not-a-word!
    }

    def elab-atom-not-a-word! [ QName +Mirth +AB -- +Mirth +AB ] {
        ab-type@ rdip:top-types-are-fine? if(
            dip(ab-token@ "Not a word: ") rdip:>Str cat rdip:emit-error!,
            drop
        ) elab-atom-failed!
    }

    def elab-macro! [ Macro +Mirth +AB -- +Mirth +AB ] {
        action arrow? if?(
            run,

            ab-token@ "macro cannot be invoked here" rdip:emit-error!
            StackType.Error ab-type!
        )
    }

    def elab-prim! [ Prim +Mirth +AB -- +Mirth +AB ] {
        elab-args! ab-prim!
    }

    def elab-atom-assert! [ +Mirth +AB -- +Mirth +AB ] {
        ab-token@ rdip:args-1 >token
        ab-ctx@ >ctx
        True >allow-type-holes
        False >allow-implicit-type-vars
        +TypeElab rdip':elab-stack-type! rdrop
        dip:ab-type@ gamma:unify! drop
    }

    def elab-atom-match! [ +Mirth +AB -- +Mirth +AB ] {
        rdip:MetaVar.new! StackType.Meta >cod
        ab-token@ succ rdip:lcurly? if(
            ab-token@ succ succ >body
            ab-token@ succ ab-token!,
            ab-token@ rdip:args+ first >body
        )
        elab-match-at!
    }

    ||| Elaborate a match body within AB. Takes the output stack type,
    ||| and the token for the body of the match, from the stack. Takes
    ||| the rest from the AB environment.
    def elab-match-at! [ cod:StackType body:Token +Mirth +AB -- +Mirth +AB ] {
        ab-match!(
            elab-match-cases!
            elab-match-exhaustive!
        )
    }
}

def arity-compatible? [ Int Int -- Bool ] {
    dup -1 == dip(==) ||
}

def ab-build!(f) [ (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow ] {
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx L0 >atoms
    Arrow >arrow +AB
    f /+AB arrow>
}

||| Like ab-build! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def ab-build-hom!(f) [
    (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
    *a Ctx ArrowType Token Home +Mirth -- *b Arrow +Mirth
] {
    dip2(/ArrowType dom>)
    ab-build!(cod> f ab-unify-type!)
}

||| Build the arrow for a word. If the word type and context are available, use that.
||| Otherwise, we are in a situation where type and context were not given, so we infer them.
|||
||| To infer ctx-type, we start with an initial guess based on the word head (with lots
||| of metavariables). We temporarily set that as our ctx-type. Then we elaborate the word
||| body. After elaboration, we rigidify the type to obtain a generalized definition, by
||| replacing any free metavariables with universally quantified variables.
def ab-build-word-arrow!(f) [
    (*a StackType +Mirth +AB -- *b StackType +Mirth +AB)
    *a Word +Mirth -- *b Arrow +Mirth
] {
    initial-ctx-type-body-home
    dip:ab-build-hom!(f)
    finalize-word-arrow
}

def initial-ctx-type-body-home [ +Mirth Word -- +Mirth Ctx ArrowType Token Home Word ] {
    >word
    @word ~ctx-type try-force!
    match(Some -> unpack2, None -> guess-initial-ctx-type)
    @word body
    @word Home.Word
    word>
}

def finalize-word-arrow [ +Mirth Arrow Word -- +Mirth Arrow ] {
    >word >arrow
    @word inferring-type? then(
        @arrow Arrow.ctx-type rigidify-sig!
        dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
        False @word ~inferring-type? !
        /ArrowType
        cod> @arrow:cod!
        dom> @arrow:dom!
        @arrow:ctx!
    )
    arrow> word> drop
}

def guess-initial-ctx-type [ +Mirth word:Word -- +Mirth Ctx ArrowType word:Word ] {
    Ctx.L0 >ctx
    MetaVar.new! StackType.Meta >dom
    MetaVar.new! StackType.Meta >cod
    @word namespace-hard match(
        Tycon ->
            full-type-fresh
            @word name can-be-relative? if(
                @dom(swap T*+),
                @cod(swap T*+)
            ),
        Module ->
            drop
            @word name >Str "main" == then(
                T0 Resource.World T+ !dom
                T0 Resource.World T+ !cod
            ),
        _ ->
            drop
    )
    @word arity repeat(
        @dom(
            MetaVar.new! StackType.Meta
            MetaVar.new! StackType.Meta T-> >Type T*
        )
    )
    ctx> dom> cod> T->
    dup2 pack2 @word PropLabel.WordType prop @word ~ctx-type !
    True @word ~inferring-type? !
}

def ab-build-word!(f) [ (*a +Mirth +AB -- *b +Mirth +AB) *a Word +Mirth -- *b Word +Mirth ] {
    sip(ab-build-word-arrow!(dip(f))) sip(PropLabel.WordArrow prop)
    tuck ~arrow !
}

||| Add an atom to a list of atoms .. smartly.
def ab-optimized-snoc! [ List(Atom) Atom -- List(Atom) ] {
    while(over atoms-has-last-block? and(atom-accepts-args?),
        swap atoms-turn-last-block-to-arg swap)
    List.Snoc
}

def atom-accepts-args? [ Atom -- Atom Bool ] {
    dup op match(
        Word -> dip(dup args len) arity <,
        Prim ->
            match(
                Dip -> dup args len 1u <,
                RDip -> dup args len 1u <,
                If -> dup args len 2u <,
                While -> dup args len 2u <,
                _ -> drop False
            ),
        _ -> drop False
    )
}

def atoms-has-last-block? [ List(Atom) -- Bool ] {
    last match(
        None -> False,
        Some ->
            op match(
                BlockPush -> drop True,
                _ -> drop False
            )
    )
}

def atoms-turn-last-block-to-arg [ Atom List(Atom) -- Atom List(Atom) ] {
   >Nest? match(
        None -> L0,
        Some ->
            unsnoc dup op match(
                BlockPush ->
                    { Atom List(Atom) Atom Block }
                    dip(dom rotl dom!)
                    { List(Atom) Atom Block }
                    Arg.Block swap args:cons
                    swap,
                _ -> drop List.Snoc
            )
    )
}

data OpSig {
    Id
    Push  [ Type ]
    Apply [ ArrowType ]
}

def elab-op-fresh-sig! [ +Mirth Op -- +Mirth Subst OpSig ] {
    Subst.nil swap match (
        Int -> Value.Int Type.Value OpSig.Push,
        F64 -> Value.F64 Type.Value OpSig.Push,
        Str -> Value.Str Type.Value OpSig.Push,
        Buffer -> drop Type.Ptr OpSig.Push,
        Tag -> type freshen-sig OpSig.Apply,
        Word -> dup inferring-type? if(type, type freshen-sig) OpSig.Apply,
        Prim -> type freshen-sig OpSig.Apply,
        External -> type freshen-sig OpSig.Apply,
        Field -> type freshen-sig OpSig.Apply,
        BlockPush -> elab-block-sig!,
        BlockRun -> type semifreshen-sig OpSig.Apply,
        Var -> elab-var-sig!,
        Match -> elab-match-sig!,
        Lambda -> elab-lambda-sig!,
        LabelPush -> elab-label-push-sig!,
        LabelPop -> elab-label-pop-sig!,
        LabelPushR -> elab-label-push-r-sig!,
        LabelPopR -> elab-label-pop-r-sig!,
        DataGetEnumValue -> data-get-enum-value-type freshen-sig OpSig.Apply,
        DataFromEnumValue -> data-from-enum-value-type freshen-sig OpSig.Apply,
        DataGetLabel -> data-get-label-type freshen-sig OpSig.Apply,
        DataSetLabel -> data-set-label-type freshen-sig OpSig.Apply,
        TableToIndex -> table-to-index-type freshen-sig OpSig.Apply,
        TableFromIndex -> table-from-index-type freshen-sig OpSig.Apply,
    )
}

def data-get-enum-value-type [ +Mirth Data -- +Mirth ArrowType ] {
    full-type match {
        { Left  -> T1 Type.Int T1 T-> }
        { Right -> # not currently exposed for resources, but this is what it would be.
            T0 over T+ Type.Int T1 rotl T+ T-> }
    }
}
def data-from-enum-value-type [ +Mirth Data -- +Mirth ArrowType ] {
    Type.Int T1 T0 rotl full-type T*+ T->
}

def table-to-index-type [ +Mirth Table -- +Mirth ArrowType ] {
    Type.Table T1 Type.Int T1 T->
}
def table-from-index-type [ +Mirth Table -- +Mirth ArrowType ] {
    Type.Table T1 Type.Int T1 swap T->
}

def elab-block-sig! [ Block -- OpSig ] {
    Value.Block Type.Value OpSig.Push
}

def elab-match-sig! [ Match -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-lambda-sig! [ Lambda -- OpSig ] {
    sip(dom) cod T-> OpSig.Apply
}

def elab-var-sig! [ +Mirth Var -- +Mirth OpSig ] {
    dup auto-run? if?(
        nip semifreshen-sig OpSig.Apply,
        type OpSig.Push
    )
}

def elab-label-push-sig! [ +Mirth Label -- +Mirth OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta dup2)
    StackType.ConsLabel dip(StackType.Cons) T-> OpSig.Apply
}

def elab-label-pop-sig! [ +Mirth Label -- +Mirth OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta dup2)
    StackType.ConsLabel dip(StackType.Cons) swap T-> OpSig.Apply
}

def elab-label-push-r-sig! [ +Mirth Label -- +Mirth OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta Resource dup2)
    StackType.WithLabel dip(StackType.With) T-> OpSig.Apply
}

def elab-label-pop-r-sig! [ +Mirth Label -- +Mirth OpSig ] {
    dip(MetaVar.new! StackType.Meta MetaVar.new! Type.Meta Resource dup2)
    StackType.WithLabel dip(StackType.With) swap T-> OpSig.Apply
}

def elab-arrow! [ +Mirth Ctx ArrowType Token Home -- +Mirth Arrow ] {
    dip2(/ArrowType dom> cod>) elab-arrow-hom!
}

def elab-arrow-hom! [ +Mirth Ctx StackType StackType Token Home -- +Mirth Arrow ] {
    rotl dip(
        elab-arrow-fwd!
        dup token-end >token +Gamma
        dup cod
    )
    unify! rdrop drop
}

def elab-arrow-fwd! [ +Mirth Ctx StackType Token Home -- +Mirth Arrow ] {
    ab-build!(elab-atoms!)
}

||| Elaborate match cases.
def elab-match-cases! [ +Mirth +Match -- +Mirth +Match ] {
    body rdip:lcurly? if(
        elab-match-cases-curly!,
        elab-match-cases-args!
    )
}

def elab-match-cases-curly! [ +Mirth +Match -- +Mirth +Match ] {
    body rdip:run-tokens for(
        dup rdip:lcurly?
        else("Expected a pattern match case of the form { ... -> ... }" rdip:emit-fatal-error!)
        rdip:args-1 elab-match-case!
        drop
    )
}

def elab-match-cases-args! [ +Mirth +Match -- +Mirth +Match ] {
    body while(dup rdip:args-end? not, elab-match-case!) drop
}

||| Elaborate match case based on starting token.
def elab-match-case! [ Token +Mirth +Match -- Token +Mirth +Match ] {
    dup rdip:run-arrow? unwrap("Expected pattern match case ... -> ..." rdip:emit-fatal-error!)
    dup2 == then("expected pattern" rdip:emit-fatal-error!)
    dup2 rdip:prev == else("multi-part pattern not supported" rdip:emit-fatal-error!)
    rdip(dip:pat-tokens sip:prev succ) +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup rdip:comma? then(succ)
    )
}

def elab-pattern! [ List(Token) +Mirth +Pattern -- +Mirth +Pattern ] {
    reverse-for(elab-pattern-atom!)
}

def elab-pattern-atom! [ Token +Mirth +Pattern -- +Mirth +Pattern ] {
    dup pattern:token-start!

    dup rdip:pat-underscore? if(
        drop +Pattern.underscore!,

    dup rdip:name/dname? if?(
        >name/dname >token
        "constructor" >sort
        pattern mid rdip:top-types-are-fine? not >report-ambiguous-as-warning
        False >ignore-last-name
        >+pat resolve-def(
            filter(dup tag? some?, RejectedDef.WrongSort)
            filter-arity
            filter-qualifiers
            @+pat:pattern mid rdip:top-types-are-fine? then(
                @+pat:pattern mid rdip:top-namespaces
                token rdip:name? if(
                    filter(dup2 rdip:qname-hard namespace swap member, RejectedDef.WrongConstructor) drop,
                    filter-roots
                )
            )
        ) +pat> bind(tag?) match(
            Some -> +Pattern.tag!,
            None -> StackType.Error pattern:mid!
        ),

        "Expected constructor name." rdip:emit-fatal-error!
    ))
}

def +Match.case!(mkpat,mkbod) [
    (*a +Mirth +Pattern -- *b +Mirth +Pattern,
        *b +Mirth +AB -- *c +Mirth +AB)
    *a Token Token +Mirth +Match -- *c +Mirth +Match,
] {
    dip(
        +Match.home >home dup >token-start >token-end
        +Match.ctx dup >outer-ctx >inner-ctx
        L0 >saved +Match.dom dup >mid >cod L0 >atoms
        Pattern rdip(thaw mkpat freeze) >pattern
    )
    @pattern inner-ctx
    @pattern Pattern.dom +Match.cod T->
    rotl
    +Match.home
    @pattern:dip:rdip(ab-build-hom!(dip(mkbod)))
    >body Case add-case
}

def elab-expand-tensor! [ +Mirth StackType Token -- +Mirth StackType Type Token ] {
    >tok force-cons?! match(
        Some -> unpack2 tok>,
        None -> StackType.Error Type.Error tok> dup "expected tuple type" emit-error!
    )
}

def elab-lambda-param? [ +Mirth Token -- +Mirth Token Maybe(Var) ] {
    dup pattern-var? if?(
        dip(dup args-0 next)
        dip(MetaVar.new! Type.Meta)
        Var.new! Some,

    dup pattern-auto-run-var? if?(
        dip(dup succ args-0 next)
        dip(MetaVar.new! StackType.Meta MetaVar.new! StackType.Meta T->)
        Var.new-auto-run! Some,

        None
    ))
}

def elab-atom-lambda! [ +Mirth +AB -- +Mirth +AB ] {
    ab-token@ rdip:args-1
    collect(rdip:elab-lambda-param?)
    dip(rdip:expect-token-arrow succ)
    ab-lambda-at!(elab-atoms!)
}

||| Check that a match is exhaustive.
def elab-match-exhaustive! [ +Mirth +Match -- +Mirth +Match ] {
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw
}

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def elab-module! [ Module +World +Mirth -- Module +World +Mirth ] {
    dup start
    elab-module-header!
    over Namespace.Module Some with-defining-namespace (
        elab-decls!
        dup module-end? else(
            "Unexpected token in module." emit-fatal-error!
        )
    )
    drop
}

def elab-module-qname [ +Mirth Token -- +Mirth QName ] {
    parse-module-package-name! dip(Namespace.Package) 0 QName.Mk
}

struct ModuleHeader {
    doc: Maybe(Str)
    package: Package
    name: Name
    head: Token
    imports: List(ModuleImport)
}

||| Parse the `module` declaration at the top of the module:
|||
|||     module(ModuleName)
|||     module ModuleName
|||
def parse-module-header! [ +Mirth Token -- +Mirth Token ModuleHeader ] {
    dup doc >doc
    dup Some lexical-state:error-token!
    dup module-header? else("Expected module header." emit-fatal-error!)
    dup num-args 0> if (
        sip(next) args-1 >head
        @head parse-module-package-name! >name >package
        @head next dup arg-end? else("Expected end of argument." emit-fatal-error!) drop,

        succ >head
        @head parse-module-package-name! >name >package
        @head next
    )
    L0 >imports
    while(dup module-import?, parse-module-import @imports:cons)
    @imports:reverse
    dup sig-dashes? then(succ)
    ModuleHeader
}

||| Parse a ModuleName.
def parse-module-package-name! [ Token +Mirth -- Package Name +Mirth ] {
    dup name/dname? else("Expected module name." emit-fatal-error!)
    dup dname? unwrap("Invalid module name: Module name must include package, for example \"package.module\"" emit-fatal-error!) over args-0
    dup root? unwrap(drop "Invalid module name: Package name is missing." emit-fatal-error!)
    swap parts single? unwrap(drop "Expected module name. (3)" emit-fatal-error!)
    dip(Package.find-or-new! nip)
}

||| Elaborate the module header and save the name and package.
def elab-module-header! [ +World +Mirth Token -- +World +Mirth Token ] {
    dup .module >module
    parse-module-header! /ModuleHeader
    name> @module ~name !
    doc> @module ~doc !
    package> @module ~package !
    @module qname defined-soft? then(@head "Module name already taken." emit-fatal-error!)
    head> @module ~head !
    @module Def.Module register
    dup module> check-module-path
    imports> for(process-module-import!)
}

def check-module-path [ Token Module +World +Mirth -- +World +Mirth ] {
    dup path rdip:split-last match(
        None ->
            swap qname to-module-path dup2 == else(
                "Expected module name to match path.\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
            ) drop3,

        Some ->
            split-last-byte(Byte.BDOT ==) "mth" Some ==
            else(over3 "Expected .mth extension for mirth file." emit-warning!)
            over2 name >Str == else(over2 .module .head "Expected module name to match file name." emit-fatal-error!)
            over package path! drop2
    )
}

||| Elaborate a series of declarations. Decl*
def elab-decls! [ +World +Mirth Token -- +World +Mirth Token ] {
    while(dup arg-end? not over module-end? not &&, elab-decl!)
}

||| Elaborate either a single declaration or a block of declarations:
|||
|||     Decl
|||     { Decl* }
def elab-decl-or-decl-block! [ +World +Mirth Token -- +World +Mirth Token ] {
    dup lcurly? if(
        succ elab-decls!
        dup rcurly? else("Expected right curly brace." emit-fatal-error!)
        succ,
        elab-decl!
    )
}

||| Elaborate a declaration. Returns the next token.
def elab-decl! [ Token +World +Mirth -- Token +World +Mirth ] {
    dup Some lexical-state:error-token!
    dup name? unwrap("unknown declaration" emit-fatal-error!)
    defs find-some(macro? bind(action decl?))
    unwrap("unknown declaration" emit-fatal-error!) run
}

def load-module [ Token QName +World +Mirth -- Token Module +World +Mirth ] {
    dup def-soft? match(
        Some -> module? unwrap(drop "module name already taken" emit-fatal-error!) nip,
        None ->
            to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
                #    https://github.com/mirth-lang/mirth/issues/241
    )
}

struct ModuleImport {
    name: Token
}

||| Parse a module import statement. Return token after import.
|||
|||     import(ModuleName)
|||     import ModuleName
def parse-module-import [ +Mirth Token -- +Mirth Token ModuleImport ] {
    dup module-import? else("Expected import statement." emit-fatal-error!)
    dup num-args 0> if(
        sip(next) args-1 >name
        @name succ arg-end? else(@name succ "expected arg end" emit-fatal-error!),
        succ dup >name next
    )
    ModuleImport
}

||| Process a module import statement.
def process-module-import! [ ModuleImport +World +Mirth -- +World +Mirth ] {
    /ModuleImport
    name> dup with-error-token(dup elab-module-qname load-module)
    dip(.module) add-import!
}

||| Parse a data declaration. It looks like one of:
|||
|||     data ( TypeAtom, DataTag* DataDecls )
|||     data TypeAtom { DataTag* DataDecls }
def parse-data [ +Mirth Token -- +Mirth Token SyntaxData ] {
    dup doc >doc
    dup num-args 0> if(
        succ dup lparen? else("expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-data-tags >tags
        parse-data-decls! >decls
        dup rparen? else("expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-data-tags >tags
        parse-data-decls! >decls
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

def parse-data-header [ +Mirth Token -- +Mirth Token SyntaxDataHeader ] {
    dup >head next
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    SyntaxDataHeader
}

def parse-data-tags [ +Mirth Token -- +Mirth Token List(SyntaxDataTag) ] {
    collect-while(dup data-tags-end? not, parse-data-tag)
}

def data-tags-end? [ +Mirth Token -- +Mirth Bool ] {
    dup args-end? or(dup sig-dashes?) nip
}

||| Parse a data tag. It looks like one of these:
|||
|||     Tag
|||     Tag -> Type* &ArgEnd
|||     Tag [ Type* ]
|||
def parse-data-tag [ +Mirth Token -- +Mirth Token SyntaxDataTag ] {
    dup doc >doc
    dup >head
    dup int? dup >value? then(succ)
    dup name? filter(could-be-constructor)
    unwrap("Expected constructor name." emit-fatal-error!) >name
    succ dup arrow? if(
        succ dup Some >sig? sig-next-stack-end
        dup arg-end? else("Expected comma." emit-fatal-error!),
        dup lsquare? if(
            succ dup Some >sig? sig-next-stack-end
            dup rsquare? else("Expected right square bracket ']'" emit-fatal-error!)
            succ,

            None >sig?
        )
    )
    dup comma? then(succ)
    SyntaxDataTag
}

||| Parse a struct declaration. This looks like this:
|||
|||     struct(TypeAtom, Type* DataDecls)
|||     struct TypeAtom { Type* DataDecls }
|||
def parse-struct [ +Mirth Token -- +Mirth Token SyntaxData ] {
    dup doc >doc
    dup num-args 0> if(
        succ dup lparen? then("Expected left parenthesis '('" emit-fatal-error!)
        succ parse-data-header >header
        dup comma? then(succ)
        parse-struct-tag L1 >tags
        parse-data-decls! >decls
        dup rparen? then("Expected right parenthesis ')'" emit-fatal-error!)
        succ,

        succ parse-data-header >header
        dup lcurly? else("expected left curly brace '{'" emit-fatal-error!)
        succ parse-struct-tag L1 >tags
        parse-data-decls! >decls
        dup rcurly? else("expected right curly brace '}'" emit-fatal-error!)
        succ
    )
    SyntaxData
}

||| Data declarations. These start with sig-dashes.
||| This is either empty, or it is dashes followed by decls within an expression.
def parse-data-decls! [ +Mirth Token -- +Mirth Token Maybe(Token) ] {
    dup sig-dashes? if(
        succ dup while(dup arg-end? not, next) swap Some,
        None
    )
}

def parse-struct-tag
    [  +Mirth Token header:SyntaxDataHeader
    -- +Mirth Token header:SyntaxDataHeader SyntaxDataTag ]
{
    None >doc
    @header head >head
    @head last-name? filter(could-be-constructor)
    unwrap(@header head "Expected constructor name." emit-fatal-error!) >name
    None >value?
    dup Some >sig?
    sig-next-stack-end
    SyntaxDataTag
}

struct SyntaxData {
    doc: Maybe(Str)
    header: SyntaxDataHeader
    tags: List(SyntaxDataTag)
    decls: Maybe(Token)
}

struct SyntaxDataHeader {
    head: Token
}

struct SyntaxDataTag {
    doc: Maybe(Str)
    head: Token
    value?: Maybe(Int)
    name: Name
    sig?: Maybe(Token)
}

def elab-data!   { parse-data   elab-data-aux! }
def elab-struct! { parse-struct elab-data-aux! }

def elab-data-aux! [ +World +Mirth SyntaxData -- +World +Mirth ] {
    /SyntaxData
    Data.alloc! List.Nil over ~tags !
    doc> over ~doc !
    header> elab-data-header!
    tags> for(elab-data-tag!)
    decls> for(elab-data-decls!)
    elab-data-done!
}

||| Get the header, name, arity for a data type.
def elab-data-header! [ Data SyntaxDataHeader +Mirth -- Data +Mirth ] {
    /SyntaxDataHeader >data
    @head last-name? has(could-be-constructor)
        else(@head "Expected type name." emit-fatal-error!)
    elab-def-head
    @head Some @data ~head? !
    arity> >Int @data ~arity !
    name> @data ~name !
    @data PropLabel.DataQName >label Prop @data ~qname !
    @head args @data PropLabel.DataParams prop(elab-data-params!) @data ~params !
    @data Def.Data register
    head> drop
    data>
}

# TODO check header args are well-formed / elaborate them properly
#  as part of: https://github.com/mirth-lang/mirth/issues/246
def elab-data-params! [ List(Token) +Mirth -- List(Var) +Mirth ] {
    Ctx.L0 swap for(
        dup name? unwrap("Expected a parameter name." emit-fatal-error!)
        over2 Ctx.lookup then("Duplicate parameter name." emit-fatal-error!)

        None
        or?(dup sig-type-var? map(Type.Type swap Var.new!))
        or?(dup sig-resource-var? map(Type.ResourceType swap Var.new!))
        or?(dup sig-stack-var? map(Type.StackType swap Var.new!))
        unwrap("Invalid parameter name." emit-fatal-error!)
        nip Ctx.new
    ) >List
}

||| Get a tag associated with a data type.
def elab-data-tag! [ Data SyntaxDataTag +Mirth -- Data +Mirth ] {
    >syn >dat
    Tag.alloc! >tag

    @syn doc @tag ~doc !
    @dat @syn name 0 data-qname @tag ~qname !
    @syn sig? @tag ~sig? !
    @syn value? for(@tag ~value !)
    @dat @tag ~data !
    @tag @dat add-tag!
    @tag Def.Tag register

    @syn head @tag @tag PropLabel.TagType prop2(
        >tag >token
        @tag .data params >Ctx >ctx
        True >allow-implicit-type-vars
        False >allow-type-holes
        +TypeElab
        T0 @tag .data rdip:full-type T*+
        tag> sig? match(
            None -> T0,
            Some -> token! T0 elab-stack-type-parts!
        )
        swap T-> dip:ctx pack2 rdrop
    ) @tag ~ctx-type !
    @tag num-type-inputs-from-sig @tag ~num-type-inputs !
    @tag num-resource-inputs-from-sig @tag ~num-resource-inputs !
    @tag label-inputs-from-sig @tag ~label-inputs !

    @tag outputs-resource? not then(
        @tag sig? for(
            run-tokens find(
                or(sig-resource-con? >Bool, sig-resource-var? >Bool)
            ) for ("Value type cannot contain resource." emit-error!)
        )
    )

    tag> syn> drop2
    dat>
}

def elab-data-decls! [ +World +Mirth Data Token -- +World +Mirth Data ] {
    dup Some >error-token
    over Tycon.Data Namespace.Tycon Some >defining-namespace
    LexicalState with-lexical-state (
        while(dup arg-end? not, elab-decl!)
        drop
    )
}

def data-word-new! [ +Mirth Data Str Nat doc:Maybe(Str) -- +Mirth Word ] {
    dup >arity
    over >Name >name
    dip2(dup head? unwrap("Missing data token information." fatal-error!) dup >body >head)
    data-word-qname >qname
    None >sig?
    Word.new!

    qname> over PropLabel.WordQName prop over ~qname !
}

def elab-data-done! [ +Mirth Data -- +Mirth ] {
    >dat
    @dat is-value-type? then (
        None >doc # TODO
        @dat "enum-value" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-get-enum-value-type
        @word PropLabel.WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat Op.DataGetEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat is-enum? then (
        None >doc # TODO
        @dat "from-enum-value-unsafe" 0u data-word-new! >word
        @dat params >Ctx
        @dat data-from-enum-value-type
        @word PropLabel.WordType prop2 @word ~ctx-type !
        @word ab-build-word!(
            @dat Op.DataFromEnumValue ab-op!
        ) make-inline!
        word> drop
    )

    @dat tags single? for(
        >tag
        None >doc # TODO
        @dat "/" @tag name >Str cat 0u data-word-new! >untag
        @untag Some @tag ~untag !
        @tag @untag PropLabel.WordType prop(ctx-type invert pack2) @untag ~ctx-type !
        @tag @untag @untag PropLabel.WordArrow prop2(
            >untag >tag
            untag> ab-build-word-arrow!(
                @tag rdip:type dom >cod
                @tag rdip:data rdip:head? unwrap("Missing data token info" rdip:fatal-error!) dup >body
                ab-match!(
                    dup case!(@tag +Pattern.tag!, id)
                )
            )
            tag> drop
        ) @untag ~arrow !
        @untag make-inline!
        @tag create-projectors!
        tag> untag> drop2
    )

    @dat @dat PropLabel.DataCType prop(
        >dat
        @dat is-unit? if(
            CType.Phantom Some,
        @dat is-enum? if(
            "int" CType.IntLike Some,
        @dat semi-transparent? if?(
            input match(
                Cons -> ctype?,
                ConsLabel -> drop ctype?,
                With -> ctype?,
                WithLabel -> drop ctype?,
            ),
            None
        )))
        dat> drop
    ) @dat ~ctype? !
    dat> drop
}

||| Return the tag's output type or resource in context.
field(Tag.~output-type, Tag, Type/Resource)
def Tag.output-type [ +Mirth Tag -- +Mirth Type/Resource ] {
    >tag
    @tag ~output-type memoize(
        @tag type cod expand match {
            { Cons -> nip Left }
            { With -> nip Right }
            { _ ->
                drop
                "Unexpected output type for constructor "
                @tag qname >Str cat
                @tag .data head? if?(swap emit-error!, error!)
                Type.Error @tag .data is-resource? if(
                    Resource Right,
                    Left
                )
            }
        }
    )
    tag> drop
}

||| Return the tag's output type or resource in context, except for a missing field.
def Tag.output-type-except-field [ +Mirth Label Tag -- +Mirth Type/Resource ] {
    dup output-type map(except-field, except-field)
}

||| Return the input type for a tag along a given label.
def Tag.project-input-label [ +Mirth Label Tag -- +Mirth Maybe(Type/Resource) ] {
    type dom label-top?
}

def Tag.project-tag-field [ +Mirth Label Tag -- +Mirth Maybe(TagField) ] {
    dup2 project-input-label if? (
        >type/resource >tag >label TagField Some,
        drop2 None
    )
}

def data-get-label-type [ +Mirth TagField -- +Mirth ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T0 @tag output-type T*+ swap T1
            @tag .data is-resource? then(@tag output-type T*+)
            T-> }
        { Right ->
            T0 @tag output-type T*+
            T0 rotl T+ @label @tag output-type-except-field T*+
            T-> }
    }
    label> tag> drop2
}

def data-set-label-type [ +Mirth TagField -- +Mirth ArrowType ] {
    /TagField
    type/resource> match {
        { Left ->
            T1 @tag output-type T*+
            T0 @tag output-type T*+
            T-> }
        { Right ->
            T0 swap T+ @label @tag output-type-except-field T*+
            T0 @tag output-type T*+
            T-> }
    }
    label> tag> drop2
}

def create-projectors! [ +Mirth Tag -- +Mirth ] {
    >tag
    @tag .data >dat
    @tag label-inputs reverse-for(
        >lbl
        @dat @lbl name 0 data-qname undefined-soft? then(
            None >doc # TODO
            @dat @lbl >Str 0u data-word-new! >lbl_get

            None >doc # TODO
            @dat @lbl >Str "!" cat 0u data-word-new! >lbl_set

            None >doc # TODO
            @dat @lbl >Str 1u data-word-new! >lbl_lens

            @lbl_get make-inline!
            @tag @lbl @lbl_get PropLabel.WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-get-label-type
                pack2
            ) @lbl_get ~ctx-type !
            @tag @lbl @lbl_get dup PropLabel.WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    Op.DataGetLabel ab-op!
                )
            )) @lbl_get ~arrow !

            @lbl_set make-inline!
            @tag @lbl @lbl_set PropLabel.WordType prop2(
                dip(dup dip(ctx))
                swap project-tag-field unwrap("logic error: expected field in tag." fatal-error!)
                data-set-label-type
                pack2
            ) @lbl_set ~ctx-type !
            @tag @lbl @lbl_set dup PropLabel.WordArrow prop3(ab-build-word-arrow!(
                dip(
                    swap rdip:project-tag-field unwrap("logic error: expected field in tag." rdip:fatal-error!)
                    Op.DataSetLabel ab-op!
                )
            )) @lbl_set ~arrow !

            @lbl_lens make-inline!
            @tag @lbl @lbl_lens PropLabel.WordType prop2(
                >lbl >tag
                lbl> @tag project-input-label unwrap("logic error: expeted field in tag." fatal-error!) >lblty
                @tag output-type >datty

                @tag ctx
                "*x" StackType.NewInCtx >sx
                "*y" StackType.NewInCtx >sy
                @sx @datty T*+
                    @sx @lblty T*+
                    @sy @lblty T*+ T-> >Type T*
                @sy  @datty T*+
                T-> pack2

                sx> sy> drop2
                lblty> datty> drop2
                tag> drop
            ) @lbl_lens ~ctx-type !
            @lbl_lens dup PropLabel.WordParams prop(
                type dom top-type? unwrap("logic error: expected parameter" fatal-error!)
                morphism? unwrap("logic error: expected morphism" fatal-error!)
                "f" >Name Var.new-auto-run! >var None >default Param L1
            ) @lbl_lens ~params !

            @dat @lbl_get @lbl_set @lbl_lens dup PropLabel.WordArrow prop4(
                >lbl_lens >lbl_set >lbl_get >dat
                @lbl_lens ab-build-word-arrow!(
                    lbl_lens> rdip:params map(.var) dup ab-lambda!(
                        single? unwrap("Expected one parameter." rdip:fatal-error!) >f
                        dat> rdip:is-resource? if(
                            lbl_get> ab-word!
                            ab-rdip!(f> ab-var!)
                            lbl_set> ab-word!,

                            Prim.Dup ab-prim!
                            ab-dip!(
                                lbl_get> ab-word!
                                f> ab-var!
                            )
                            lbl_set> ab-word!
                        )
                    )
                )
            ) @lbl_lens ~arrow !
            lbl_get> lbl_set> lbl_lens> drop3
        )
        lbl> drop
    )
    dat> tag> drop2
}

def expect-token-arrow [ +Mirth Token -- +Mirth Token ] {
    dup arrow? else("Expected arrow." emit-fatal-error!)
}

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def elab-def-missing! [ +Mirth Token -- +Mirth Token ] {
    dup args len 3u < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined-hard? if(next, elab-def!)
}

def +Mirth.with-inline(f) [ (*a +Mirth -- *b +Mirth) *a Bool +Mirth -- *b +Mirth ] {
    prefer-inline-defs:swap
    dip(f) prefer-inline-defs!
}

||| Mark the following definition(s) as inline.
|||
|||     inline Decl
|||     inline ( Decl* )
|||     inline { Decl* }
def elab-inline! [ Token +World +Mirth -- Token +World +Mirth ] {
    True with-inline(
        dup num-args 0> if(
            sip:next args-1 elab-decls! drop,
            succ elab-decl-or-decl-block!
        )
    )
}

struct SyntaxDef {
    doc:  Maybe(Str)
    head: Token
    sig?: Maybe(Token)
    body: Token
}

||| Parse a word definition. It looks like one of these:
|||
|||     def(word, sig, body...)
|||     def word [ sig ] { body... }
|||     def word { body... }
|||
||| Returns the next token after the definition.
def parse-def [ +Mirth Token -- +Mirth Token SyntaxDef ]
{
    dup Some lexical-state:error-token!
    dup doc >doc
    dup args empty? if(
        next
        dup >head next
        dup lsquare? if(dup args-1 Some >sig? next, None >sig?)
        dup lcurly? else("expected { ... }" emit-fatal-error!)
        dup args+ >body
        next,

        sip(next)
        dup args dup len 3u <
            then(drop
                 "def(...) expects at least three arguments"
                 emit-fatal-error!)
            nip
        >Nest? unwrap(impossible!) uncons dip(>head)
        >Nest? unwrap(impossible!) uncons dip(Some >sig?)
        >Nest? unwrap(impossible!) >body

        @head next arg-end? else(
            @head next "expected comma after word name" emit-fatal-error!
        )
    )
    body> uncons empty? or(dup run-arrow? >Bool)
        else("expected match case" emit-fatal-error!) >body
    SyntaxDef
}

||| Elaborate a word definition.
def elab-def! [ +Mirth Token -- +Mirth Token ] {
    parse-def /SyntaxDef
    elab-def-head Word.new! >word
    @word PropLabel.WordQName >label Prop @word ~qname !

    prefer-inline-defs @word ~prefer-inline? !

    @word @word PropLabel.WordType prop(
        dup sig? match(
            Some ->
                nip
                +TypeElab.Start!
                elab-type-sig!
                dip:ctx pack2
                rdrop,
            None ->
                arrow ctx-type pack2
        )
    ) @word ~ctx-type !
    @word @word PropLabel.WordParams prop(elab-def-params!) @word ~params !
    @word @word PropLabel.WordArrow prop(
        dup dup ab-build-word-arrow!(
            swap rdip:params dup empty? if(
                drop elab-def-body!,
                map(.var) ab-lambda!(elab-def-body!)
            )
        ) tuck check-inline-recursion-arrow!
    ) @word ~arrow !
    word> drop
}

def check-inline-recursion-arrow! [ +Mirth Word Arrow -- +Mirth ] {
    atoms for(dip:dup check-inline-recursion-atom!) drop
}
def check-inline-recursion-atom! [ +Mirth Word Atom -- +Mirth ] {
    over prefer-inline? if(
        dup2 op check-inline-recursion-op!
        args for(dip:dup check-inline-recursion-arg!) drop,
        drop2
    )
}
def check-inline-recursion-arg! [ +Mirth Word Arg -- +Mirth ] {
    Block -> arrow check-inline-recursion-arrow!
}
def check-inline-recursion-op! [ +Mirth Word Op -- +Mirth ] {
    BlockRun -> arrow check-inline-recursion-arrow!,
    Word ->
        dup2 == if(
            drop check-inline-recursion-failed!,
            dup prefer-inline? if(
                ~arrow try-force! if?(
                    check-inline-recursion-arrow!,
                    check-inline-recursion-failed!
                ),
                drop2
            )
        ),
    Match -> cases for(dip:dup body check-inline-recursion-arrow!) drop,
    Lambda -> body check-inline-recursion-arrow!,
    _ -> drop2
}
def check-inline-recursion-failed! [ +Mirth Word -- +Mirth ] {
    dup prefer-inline? if(
        False over ~prefer-inline? !
        head "recursive word cannot be inlined" emit-warning!,
        drop
    )
}

||| Elaborate a word's parameters from its type and declaration.
def elab-def-params! [ +Mirth Word -- +Mirth List(Param) ] {
    L0 over type
    rotl head dip(/ArrowType dom> cod>) nip
    args reverse-for(
        dup sig-param-name? unwrap("expected parameter name" emit-fatal-error!) >name
        dup succ dup run-end? if(
            drop None >default,
            dup lcurly? if(
                dup succ Some >default
                next dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!),

                "expected right paren, left curly, or comma" emit-fatal-error!
            )
        )
        elab-expand-tensor!
        swap morphism? unwrap("need function type for param" emit-fatal-error!)
        nip name> Var.new-auto-run! >var Param
        rotr dip:cons
    ) drop
}

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def elab-def-body! [ StackType +Mirth +AB -- StackType +Mirth +AB ] {
    ab-token@ rdip:run-arrow? or(ab-token@ rdip:lcurly? some?) if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    )
}

data ExternalDeclPart {
    EDPCode [ token:Token code:Str ]
    EDPDef  [ doc:Maybe(Str) head:Token symbol:Maybe(Token) sig:Token ]
}

||| Parse an external block.
|||
|||     external( ExternalPart* )
|||     external{ ExternalPart* }
|||     external ExternalPart
def parse-external-decl [ +Mirth Token -- +Mirth Token List(ExternalDeclPart) doc:Maybe(Str) ] {
    dup doc >doc
    succ dup num-args 0> or(dup lcurly? >Bool) if(
        List.Mk(
            succ
            while(dup rdip:args-end? not,
                rdip(parse-external-decl-part) ;
            )
            succ
        ),

        parse-external-decl-word L1
        None >doc
    )
}

def parse-external-decl-part [ +Mirth Token -- +Mirth Token ExternalDeclPart ] {
    dup str? if?(
        >code dup >token
        succ
        ExternalDeclPart.EDPCode,

        dup doc >doc
        parse-external-decl-word
    )
    dip(dup comma? then(succ))
}

def parse-external-decl-word [ +Mirth Token doc:Maybe(Str) -- +Mirth Token ExternalDeclPart ] {
    dup >head
    dup name/dname? else("expected external word name" emit-fatal-error!)
    succ
    dup arrow? if(
        succ dup name? else("expected external symbol name" emit-fatal-error!)
        dup Some >symbol
        succ,

        None >symbol
    )
    dup lsquare? if(
        dup args-1 >sig
        next,

        dup comma? else("expected type signature" emit-fatal-error!)
        succ
        dup arg-end? then("expected type signature" emit-fatal-error!)
        dup >sig
        next-arg-end
    )
    ExternalDeclPart.EDPDef
}

||| Elaborate an external declaration.
def elab-external! [ +Mirth Token -- +Mirth Token ] {
    dup >token
    parse-external-decl
    map(elab-external-block-part!) >parts
    ExternalBlock.alloc! >extblock
    doc> @extblock ~doc !
    token> @extblock ~token !
    parts> @extblock ~parts !
    extblock> drop
}

def elab-external-block-part! [ +Mirth ExternalDeclPart -- +Mirth ExternalBlockPart ] {
    { EDPCode -> token> drop code> ExternalBlockPart.EBPCode }
    { EDPDef -> elab-external-def! ExternalBlockPart.EBPDef }
}

def elab-external-def! [ +Mirth doc:Maybe(Str) head:Token symbol:Maybe(Token) sig:Token -- +Mirth External ] {
    elab-def-head

    symbol> bind(name?) unwrap(@name) >Str >symbol

    External.alloc! >external
    doc> @external ~doc !
    name> @external ~name !
    arity> >Int @external ~arity !
    @external PropLabel.ExternalQName >label Prop @external ~qname !
    symbol> @external ~symbol !
    sig> @external ~sig !
    head> @external ~head !
    @external dup PropLabel.ExternalType prop(
        sig +TypeElab.Start!
        elab-type-sig! dip:ctx pack2 rdrop
    ) @external ~ctx-type !
    @external dup PropLabel.ExternalCType prop(
        elab-external-ctype
    ) @external ~ctype !
    @external Def.External register
    external>
}

def elab-external-ctype [ +Mirth External -- +Mirth CTypeArrow ] {
    dup head with-error-token(
        type ctype
        dup cod parts
        filter(sip(label? none?) ctype phantom? not &&)
        len 1u > then(
            "External has too many outputs." error!
        )

        dup dom parts filter-some(label?)
        over cod parts filter-some(label?)
        swap difference for(
            Str("Output label "; name; " not present in input";) error!
        )
    )
}

||| Parse a type definition.
|||
|||     def-type(t1,t2)
|||     def-type t1 t2
def parse-def-type [ +Mirth Token -- +Mirth Token head:Token target:Token doc:Maybe(Str) ] {
    dup doc >doc
    dup num-args 0> if (
        sip(next) args-2 >target >head
        @head args-0
        @head sig-type-con? else(@head "expected type constructor" emit-fatal-error!)
        @head next arg-end? else(@head next "expected comma" emit-fatal-error!)
        @target next arg-end? else(@target next "expected end of args" emit-fatal-error!),

        succ dup >head next dup >target next
        @head args-0
        @head sig-type-con? else(@head "expected type constructor" emit-fatal-error!)
    )
}

||| Elaborate a type definition `def-type(t1, t2)`.
def elab-def-type! [ +Mirth Token -- +Mirth Token ] {
    parse-def-type
    elab-def-head @head:Some
    arity> drop
    TypeDef.new!
    doc> over ~doc !
    target> over PropLabel.TypeDefTarget prop(elab-simple-type-arg!) swap ~target !
}

||| Elaborate a buffer declaration.
|||
|||     buffer(Name, Size)
|||     buffer Name Size
def parse-buffer [ +Mirth Token -- +Mirth Token head:Token doc:Maybe(Str) size:USize ] {
    dup doc >doc
    dup num-args 0> if(
        sip(next) args-2 >sizearg >head
        @head args-0
        @head name/dname? else(@head "Expected buffer name." emit-fatal-error!)
        @head next arg-end? else(@head next "Expected comma." emit-fatal-error!)
        @sizearg int? else?(@sizearg "Expected buffer size." emit-fatal-error!) >size
        @sizearg next args-end? else(@sizearg next "Expected end of arguments." emit-fatal-error!),

        succ dup >head next dup >sizearg next
        @head name/dname? else(@head "Expected buffer name." emit-fatal-error!)
        @sizearg int? else?(@sizearg "Expected buffer size." emit-fatal-error!) >size
    )
    @size:>USize-else(drop @sizearg "Buffer size must not be negative." emit-error! 0u >USize)
    sizearg> drop
}

||| Elaborate a buffer definition `buffer(B, size)`.
def elab-buffer! [ +Mirth Token -- +Mirth Token ] {
    parse-buffer elab-def-head arity> drop
    Buffer.new! >buffer
    @buffer PropLabel.BufferQName >label Prop @buffer ~qname !
    buffer> Def.Buffer register
}

||| Parse a table declaration.
|||
|||     table(Tycon)
|||     table Tycon
def parse-table-decl [ Token +Mirth -- Token +Mirth head:Token doc:Maybe(Str) ] {
    dup doc >doc
    dup num-args 0> if(
        sip(next) args-1 >head
        @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
        @head args-0
        @head succ arg-end? else(@head succ "expected end of argument after table name" emit-fatal-error!),

        succ dup >head
        @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
        @head args-0
        succ
    )
}

||| Elaborate a table definition `table(True)`.
def elab-table! [ +Mirth Token -- +Mirth Token ] {
    parse-table-decl
    elab-def-head
    arity> drop
    table-new! drop
}

||| Create entry point based on word name.
def elab-entry-point [ QName +Mirth -- Arrow +Mirth ] {
    dup def-hard? bind(word?) unwrap(
        dup dip(
            namespace module? for(start Some lexical-state:error-token!)
            "can't find entry point "
        ) >Str cat
        fatal-error!
    ) nip { Word +Mirth }
    dup dip(Ctx.L0 T0 Resource.World T+ T0 Resource.World T+ T->)
    head dup Home.Main ab-build-hom!(
        dip(ab-word!)
    )
}

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def elab-embed-str! [ Token +World +Mirth -- Token +World +Mirth ] {
    dup doc >doc
    sip:next args-2 swap
    >head elab-def-head
    @arity 0= else(@head "expected no arguments" emit-fatal-error!)
    dup >body None >sig?
    dup str? unwrap("expected source path" emit-fatal-error!)
    >Path >+mirth open-file! +else(+mirth> fatal-error!) read-file! close-file! nip >contents +mirth>
    Word.new!
    dup PropLabel.WordQName >label Prop over ~qname !

    Ctx.L0 T0 Type.Str T1 T-> over2 PropLabel.WordType prop2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop
}

||| Ensure that everything so far has been typechecked.
def typecheck-everything! [ +Mirth -- +Mirth ] {
    Name.for(defs for(dup qname-hard drop typecheck!))
    Block.for(typecheck!)
    External.for(ctype drop)
}

#########
# TABLE #
#########

def table-qname [ +Mirth Table Str Int -- +Mirth QName ] {
    >arity >Name >name Tycon.Table Namespace.Tycon >namespace QName
}

def table-word-new! [ +Mirth Table Str Nat doc:Maybe(Str) -- +Mirth Word ] {
    over2 head dup >head >body None >sig?
    dup >arity over >Name >name >Int table-qname >qname Word.new!
    qname> over PropLabel.WordQName prop over ~qname !
}

def table-new! [ +Mirth head:Token name:Name state:PropState(QName) doc:Maybe(Str) -- +Mirth Table ] {
    Table.alloc! >tbl
    @tbl PropLabel.TableQName >label Prop @tbl ~qname !
    @head @tbl ~head !
    name> @tbl ~name !
    doc> @tbl ~doc !
    @tbl Def.Table register

    # Table.nil
    None >doc # TODO
    @tbl "nil" 0u table-word-new! >word

    Ctx.L0
    T0 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @head ab-token!
        0 ab-int!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.NUM
    None >doc # TODO
    @head >head
    "NUM" >Name >name
    8u >USize >size
    Buffer.new! >buf
    @buf @tbl ~num-buffer !
    @tbl "Num" 0 table-qname
    @buf PropLabel.BufferQName prop
    @buf ~qname !
    @buf Def.Buffer register

    # Table.index
    None >doc # TODO
    @tbl "index" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 Type.Int T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableToIndex ab-op!
    ) drop

    # Table.from-index
    None >doc # TODO
    @tbl "from-index" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 Type.Int T1 swap T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.succ
    None >doc # TODO
    @tbl "succ" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableToIndex ab-op!
        1 ab-int!
        Prim.IntAdd ab-prim!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.pred
    None >doc # TODO
    @tbl "pred" 0u table-word-new! >word

    Ctx.L0
    @tbl Type.Table T1 dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @tbl Op.TableToIndex ab-op!
        Prim.Dup ab-prim!
        0 ab-int!
        Prim.IntEq ab-prim!
        ab-if!(
            ,
            1 ab-int!
            Prim.IntSub ab-prim!
        )
        @tbl Op.TableFromIndex ab-op!
    ) drop

    { +Mirth tbl:Table buf:Buffer head:Token }

    # Table.for
    None >doc # TODO
    @tbl "for" 1u table-word-new! >word
    Type.StackType "*a" >Name Var.new! >va
    @va StackType.Var @tbl Type.Table T* @va StackType.Var T-> "f" >Name Var.new-auto-run! >vx

    @va Ctx.L1
    @va StackType.Var @vx type T* @va StackType.Var T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    @vx >var None >default Param L1
    @word PropLabel.WordParams prop
    @word ~params !
    @word make-inline!

    word> ab-build-word! (
        @head ab-token!
        @vx L1 ab-lambda!(
            1 ab-int!
            ab-while!(
                Prim.Dup ab-prim!
                @buf ab-buffer!
                Prim.I64Get ab-prim!
                Prim.I64ToInt ab-prim!
                Prim.IntLe ab-prim!,

                Prim.Dup ab-prim!
                ab-dip! (
                    @tbl Op.TableFromIndex ab-op!
                    @vx ab-var!
                )
                1 ab-int!
                Prim.IntAdd ab-prim!
            )
            Prim.Drop ab-prim!
        )
    ) drop
    va> vx> drop2

    # Table.alloc!
    None >doc # TODO
    @tbl "alloc!" 0u table-word-new! >word

    Ctx.L0
    T0 @tbl Type.Table T1 T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @buf ab-buffer!
        Prim.I64Get ab-prim!
        Prim.I64ToInt ab-prim!
        1 ab-int!
        Prim.IntAdd ab-prim!
        Prim.Dup ab-prim!
        Prim.IntToI64 ab-prim!
        @buf ab-buffer!
        Prim.I64Set ab-prim!
        @tbl Op.TableFromIndex ab-op!
    ) drop

    head> buf> drop2
    tbl>
}

#########
# FIELD #
#########

def resolve-def-namespace [ +Mirth Token name/dname:Name/DName -- +Mirth Maybe(Namespace) ] {
    >token
    "namespace" >sort
    True >ignore-last-name
    False >report-ambiguous-as-warning
    resolve-def(
        filter-sort(dup rdip:exposed-tycon? >Bool)
        filter-qualifiers
        L0 filter-roots
    )
    bind(as-namespace?)
}

def elab-qname-from-nonrelative-dname [ +Mirth Token DName arity:Int -- +Mirth QName ] {
    dup Right >name/dname
    dup root? else(drop "relative name not allowed" emit-fatal-error!)
    last-name >name
    dup resolve-def-namespace unwrap(panic-diagnostics!) >namespace
    drop QName
}

def module-visible-from-token? [ +Mirth Token Module -- +Mirth Bool ] {
    swap .module visible
}

def def-visible-from-token? [ +Mirth Token Def -- +Mirth Bool ] {
    defining-module? match(
        None -> drop True,
        Some -> module-visible-from-token?
    )
}

def Token.is-default-param? [ +Mirth Token -- +Mirth Bool ] {
    dup name? and( dup succ lcurly? >Bool ) nip
}

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def elab-def-qname [ +Mirth Token -- +Mirth QName ] {
    dup args dup has(is-default-param?) if(drop -1, len >Int) >arity
    dup name/dname? unwrap("expected name" emit-fatal-error!)
    match(
        Left -> >name defining-namespace-or-error >namespace QName,
        Right -> elab-qname-from-nonrelative-dname
    )
}

||| The namespace for definitions by default.
def defining-namespace-or-error [ +Mirth Token -- +Mirth Namespace ] {
    lexical-state defining-namespace
    unwrap("error: no namespace for definition" emit-fatal-error!)
    nip
}

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def elab-def-qname-undefined [ +Mirth Token -- +Mirth QName ] {
    dup elab-def-qname
    dup defined-soft? then(drop "name already defined" emit-fatal-error!)
    nip
}

||| Elaborate the head, i.e. the name-giving token, of a definition.
||| We defer the full resolution of the qualified name, but otherwise
||| we collect arity and (simple) name data from the head token.
def elab-def-head [
    +Mirth head:Token --
    +Mirth head:Token name:Name arity:Nat state:PropState(QName)
] {
    @head name/dname?
        unwrap(@head "expected name" emit-fatal-error!)
        either(id, parts last) >name
    @head num-args >arity
    lexical-state @head [ elab-def-qname-undefined ] PropState.Delay >state
}

||| Parse a field definition, `field(f, T1, T2)`
def parse-field [
    +Mirth Token -- +Mirth Token
    doc:Maybe(Str) head:Token index-type:Token value-type:Token
] {
    dup doc >doc
    sip(next) args-3 >value-type >index-type >head
    @head name/dname? else(@head "expected field name" emit-fatal-error!)
    @head args-0
}

||| Elaborate a field definition `field(f, T1, T2)`.
def elab-field! [ +Mirth Token -- +Mirth Token ] {
    parse-field elab-def-head
    Field.alloc! >fld
    doc> @fld ~doc !
    name> @fld ~name !
    head> @fld ~head !
    arity> 0= else(@fld head "Field cannot take arguments." emit-error!)
    @fld PropLabel.FieldQName >label Prop @fld ~qname !
    index-type> @fld PropLabel.FieldIndexType prop(elab-simple-type-arg!) @fld ~index-type !
    value-type> @fld PropLabel.FieldValueType prop(elab-simple-type-arg!) @fld ~value-type !
    fld> Def.Field register
}
