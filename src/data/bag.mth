module(data.bag)
import(prelude)
import(data.list)
import(data.maybe)

||| A bag is a set where items can appear more than once.
||| Bags are represented by sorted lists, where the sorting
||| is done by the generic order relation on values (<=).
data(Bag(v), BAG -> List(v))

def(unBAG, Bag(v) -- List(v), match(BAG -> id))
def(B0, Bag(v), L0 BAG)
def(B1, v -- Bag(v), L1 BAG)
def(B2, v v -- Bag(v), order2 L2 BAG)
def(B3, v v v -- Bag(v), order3 L3 BAG)

||| Same as `Bag(v)` but non-empty.
data(Bag+(v), BAG+ -> List+(v))

def(unBAG+, Bag+(v) -- List+(v), BAG+ -> id)
def(B1+, v -- Bag+(v), L1+ BAG+)
def(B2+, v v -- Bag+(v), order2 L2+ BAG+)
def(B3+, v v v -- Bag+(v), order3 L3+ BAG+)

def(Bag+->Bag, Bag+(v) -- Bag(v), unBAG+ List+->List BAG)
def(Bag->Bag+, Bag(v) -- Maybe(Bag+(v)), unBAG List->List+ maybe-map(BAG+))

def(bag-empty, Bag(v), L0 BAG)
def(bag-is-empty, Bag(v) -- Bool, BAG -> list-is-empty)
def(bag-singleton, v -- Bag(v), B1)
def(bag-is-singleton, Bag(v) -- Bool, bag-len 1 ==)
def(bag-is-singleton+, Bag+(v) -- Bool, bag-len+ 1 ==)
def(bag-len, Bag(v) -- Int, unBAG len)
def(bag-len+, Bag+(v) -- Int, unBAG+ len+)
def(bag-len?, Bag(v) -- Bag(v) Int, dup bag-len)
def(bag-len+?, Bag+(v) -- Bag+(v) Int, dup bag-len+)

def(bag-first, Bag(v) -- Maybe(v), unBAG first)
def(bag-last, Bag(v) -- Maybe(v), unBAG last)
def(bag-middle, Bag(v) -- Maybe(v), unBAG middle)

def(bag-first+, Bag+(v) -- v, unBAG+ first+)
def(bag-last+, Bag+(v) -- v, unBAG+ last+)
def(bag-middle+, Bag+(v) -- v, unBAG+ middle+)

def(bag-split-half-left, Bag+(v) -- Bag+(v) Bag(v),
    unBAG+ split-half-left dip(BAG+) BAG)
def(bag-split-half-right, Bag+(v) -- Bag(v) Bag+(v),
    unBAG+ split-half-right dip(BAG) BAG+)
def(bag-split-half, Bag(v) -- Bag(v) Bag(v),
    unBAG split-half dip(BAG) BAG)

def(bag-uncons, Bag+(v) -- v Bag(v), unBAG+ uncons BAG)
def(bag-unsnoc, Bag+(v) -- Bag(v) v, unBAG+ unsnoc dip(BAG))

def(bag-cons, v Bag(v) -- Bag(v), swap bag-insert)
def(bag-snoc, Bag(v) v -- Bag(v), bag-insert)

def(bag-cons+, v Bag(v) -- Bag+(v), swap bag-insert+)
def(bag-snoc+, Bag(v) v -- Bag+(v), bag-insert+)

def(bag-cons++, v Bag+(v) -- Bag+(v), swap bag-insert++)
def(bag-snoc++, Bag+(v) v -- Bag+(v), bag-insert++)

def(bag-has, Bag(v) v -- Bool,
    swap Bag->Bag+ match(
        NONE -> drop false,
        SOME -> swap bag-has+
    ))

def(bag-has+, Bag+(v) v -- Bool,
    over bag-is-singleton+ if(
        dip(bag-first+) ==,

        dip(bag-split-half-right)
        over bag-first+
        cmp? match(
            EQ -> drop4 true,
            LT -> drop nip bag-has,
            GT -> drop dip(nip) bag-has+
        )
    ))

def(bag-has?, Bag(v) v -- Bag(v) v Bool, dup2 bag-has)

||| Insert a value into the bag in the proper location.
||| Note that `bag-insert` will happily insert duplicates.
||| Use `bag-replace` to prevent duplicate insertion.
def(bag-insert, Bag(v) v -- Bag(v),
    bag-insert+ Bag+->Bag)

||| Same as `bag-insert` but returns a `Bag+`.
def(bag-insert+, Bag(v) v -- Bag+(v),
    swap Bag->Bag+ match(
        NONE -> B1+,
        SOME -> swap bag-insert++
    ))

||| Same as `bag-insert` but takes and returns a `Bag+`.
def(bag-insert++, Bag+(v) v -- Bag+(v),
    over bag-is-singleton+ if(
        dip(bag-first+) B2+,

        dip(bag-split-half-right)
        over bag-first+
        dup2 >= if(
            drop bag-insert++ bag-cat-unsafe_+,
            drop swap dip(bag-insert+) bag-cat-unsafe+
        )
    ))

||| Insert a value into the bag in the proper location,
||| unless the bag already contains this value. This
||| prevents introducing new duplicates. Use `bag-insert`
||| instead if duplicates are desirable.
def(bag-replace, Bag(v) v -- Bag(v),
    bag-has? if(drop, bag-insert))

||| Concatenate two bags. To maintain the bag invariant,
||| it is necessary for the last item of the first bag
||| be less than or equal to the first item of the
||| second bag. In normal code it is recommended to
||| use `bag-merge` instead.
def(bag-cat-unsafe, Bag(v) Bag(v) -- Bag(v),
    dip(unBAG) unBAG cat BAG)

def(bag-cat-unsafe_+, Bag(v) Bag+(v) -- Bag+(v),
    dip(unBAG) unBAG+ cat_+ BAG+)

def(bag-cat-unsafe+, Bag+(v) Bag+(v) -- Bag+(v),
    dip(unBAG+) unBAG+ cat+ BAG+)

||| Put two stack items in order.
def(order2, v v -- v v,
    dup2 <= if(id, swap))

||| Put three stack items in order.
def(order3, v v v -- v v v,
    dip(order2) dup2 <= if(id, swap dip(order2)))

||| Prerform lookup as an ordered map. Use the key to
||| find a corresponding item. Note: If multiple items
||| match the key, you may get any of them. There's
||| no guarantee it'll be the first item, last item,
||| middle item, etc, to match the key.
def(bag-lookup-key, Bag([v k]) k -- Maybe(v),
    swap Bag->Bag+ match(
        NONE -> drop NONE,
        SOME -> swap bag-lookup-key+
    ))

||| Same as `bag-lookup-key` for non-empty bags.
def(bag-lookup-key+, Bag+([v k]) k -- Maybe(v),
    over bag-is-singleton+ if(
        dip(bag-first+ unpack2) == if(SOME, drop NONE),

        dip(bag-split-half-right dup bag-first+ unpack2)
        cmp? match(
            EQ -> drop2 SOME dip(drop2),
            LT -> dip(drop2 nip) bag-lookup-key+,
            GT -> dip(drop3) bag-lookup-key
        )
    ))

||| See `bag-lookup-key`.
def(bag-lookup-key?, Bag([v k]) k -- Bag([v k]) k Maybe(v),
    dup2 bag-lookup-key)

||| Insert key/value pair in bag, but replace an item
||| with a matching key if it exists.
def(bag-replace-key, Bag([v k]) [v k] -- Bag([v k]),
    bag-replace-key+ Bag+->Bag)

||| Same as `bag-replace-key` but returns a `Bag+`.
def(bag-replace-key+, Bag([v k]) [v k] -- Bag+([v k]),
    swap Bag->Bag+ match(
        NONE -> B1+,
        SOME -> swap bag-replace-key++
    ))

||| Same as `bag-replace-key` but takes and returns a `Bag+`.
def(bag-replace-key++, Bag+([v k]) [v k] -- Bag+([v k]),
    over bag-is-singleton+ if(
        dip(bag-first+) dup2 ==key if(
            nip B1+,
            B2+
        ),

        dip(bag-split-half-right dup bag-first+)
        dup2 <=key if(
            nip bag-replace-key++ bag-cat-unsafe_+,
            nip swap dip(bag-replace-key+) bag-cat-unsafe+
        )
    ))

||| Compare two pairs by their top item (the "key").
def(==key, [v k] [v k] -- Bool, dip(unpack2 nip) unpack2 nip ==)

||| Compare two pairs by their top item (the "key").
def(<=key, [v k] [v k] -- Bool, dip(unpack2 nip) unpack2 nip <=)

||| Get underlying list of values from bag.
def(bag-values, Bag(v) -- List(v), unBAG)

||| Get underlying non-empty list of values from non-empty bag.
def(bag-values+, Bag+(v) -- List+(v), unBAG+)
