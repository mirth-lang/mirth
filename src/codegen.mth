module(codegen)
import(prelude)
import(names)
import(tokens)


###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)

quad def-static-buffer(CODEGEN_FILE)
quad def-static-buffer(CODEGEN_LENGTH)
CODEGEN_BUF_SIZE def-static-buffer(CODEGEN_BUF)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE @)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE !)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH @)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH !)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ CODEGEN_BUF codegen-length@ posix-write!
        0 codegen-length!,
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup u8@, dup u8@ .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    0 codegen-file!
    0 codegen-length!)

def(run-output-c99!, Token String -- +IO,
    load-output-path!
    STR_BUF create-file! codegen-start!
    c99-emit-header!
    c99-emit-strings!
    c99-emit-prims!
    c99-emit-buffers!
    c99-emit-externals!
    c99-emit-word-sigs!
    c99-emit-word-defs!
    c99-emit-main!
    codegen-end!)

quad def-static-buffer(C99_DEPTH)
def(c99-depth@, -- Int +Codegen, C99_DEPTH @)
def(c99-depth!, Int -- +Codegen, C99_DEPTH !)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, str-buf-int! STR_BUF .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! STR_BUF .)

def(.w, Name -- +IO,
    "void mw" . .name " (void)" .)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WIN32 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>";;

    "typedef uint8_t u8;";
    "typedef uint16_t u16;";
    "typedef uint32_t u32;";
    "typedef uint64_t u64;";
    "typedef int8_t i8;";
    "typedef int16_t i16;";
    "typedef int32_t i32;";
    "typedef int64_t i64;";
    "typedef uintptr_t usize;";;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;

    "#define STACK_SIZE 2000" ;
    "static volatile usize sc = STACK_SIZE;" ;
    "static volatile i64 stack[STACK_SIZE] = {0};" ;;
    )

def(c99-emit-strings!, +IO,
    "#define STRINGS_SIZE " . strings-size@ .n "" ;
    "static const char strings[STRINGS_SIZE] = { " ;
    0
    while(dup strings-size@ <,
        dup STRINGS_BUF u8@@ dup U8->Int .n "," .
        if(id, .lf)
        1+
    ) drop
    "};" ;;)

def(c99-emit-buffers!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-buffer!
        1+)
    .lf drop)

def(c99-emit-buffer!, Name -- +IO,
    name-is-buffer? if(
        " volatile u8 b" . dup .name "[" . dup name-buffer@ buffer-size@ .n "] = {0};" ;
        " void mw" . dup .name " (void) { push((i64)b" . .name "); }" ;  ,
        drop
    ))

def(c99-emit-prims!, +IO,
    " i64 pop (void) {" ;
    "    if (sc < STACK_SIZE) {" ;
    "        return stack[sc++];" ;
    "    } else {" ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    "        exit(1);" ;
    "        return 0;" ;
    "    }" ;
    "}" ;;
    " void* pop_ptr (void) {" ;
    "    i64 x = (i64)pop();" ;
    "    return (void*)x;" ;
    "}";;
    " u8 pop_u8 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u8)x;" ;
    "}";;
    " u16 pop_u16 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u16)x;" ;
    "}";;
    " u32 pop_u32 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u32)x;" ;
    "}";;
    " u64 pop_u64 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u64)x;" ;
    "}";;
    " i8 pop_i8 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i8)x;" ;
    "}";;
    " i16 pop_i16 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i16)x;" ;
    "}";;
    " i32 pop_i32 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i32)x;" ;
    "}";;
    " i64 pop_i64 (void) {" ;
    "    return pop();" ;
    "}";;

    " void push (i64 x) {" ;
    "    if (sc > 0) {" ;
    "        stack[--sc] = x;" ;
    "    } else {" ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
    "        exit(1);" ;
    "    }" ;
    "}" ;;

    PRIM_ID .w " {" ;
    "}" ;;

    PRIM_DUP .w " {" ;
    "    i64 x = pop();" ;
    "    push(x); push(x);" ;
    "}" ;;

    PRIM_DROP .w " {" ;
    "    pop();" ;
    "}" ;;

    PRIM_SWAP .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x); push(y);" ;
    "}" ;;

    PRIM_INT_ADD .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x + y);" ;
    "}" ;;

    PRIM_INT_SUB .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y - x);" ;
    "}" ;;

    PRIM_INT_MUL .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x * y);" ;
    "}" ;;

    PRIM_INT_DIV .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y / x);" ;
    "}" ;;

    PRIM_INT_MOD .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y % x);" ;
    "}" ;;

    PRIM_INT_EQ .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x == y);" ;
    "}" ;;

    PRIM_INT_LT .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y < x);" ;
    "}" ;;

    PRIM_INT_LE .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y <= x);" ;
    "}" ;;

    PRIM_INT_AND .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y & x);" ;
    "}" ;;

    PRIM_INT_OR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y | x);" ;
    "}" ;;

    PRIM_INT_XOR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y ^ x);" ;
    "}" ;;

    PRIM_INT_SHL .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y << x);" ;
    "}" ;;

    PRIM_INT_SHR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y >> x);" ;
    "}" ;;

    PRIM_POSIX_WRITE .w " {" ;
    "    usize n = (usize)pop();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop();" ;
    "    write(f, p, n);" ; # TODO: push return code
    "}" ;;

    PRIM_POSIX_READ .w " {" ;
    "    usize n = (usize)pop();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop();" ;
    "    push(read(f,p,n));" ;
    "}" ;;

    PRIM_POSIX_OPEN .w " {" ;
    "    int m = (int)pop();" ;
    "    int f = (int)pop();" ;
    "    void* p = pop_ptr();" ;
    "    push(open(p,f,m));" ;
    "}" ;;

    PRIM_POSIX_CLOSE .w " {" ;
    "    int x = (int)pop();" ;
    "    push(close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .w " {" ;
    "    int x = (int)pop();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .w " {" ;
    "    #ifdef MIRTH_WIN32" ;
    "    pop(); pop(); pop(); pop();" ;
    "    usize b = (usize)pop();" ;
    "    pop();" ;
    "    push((i64)malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop();" ;
    "    int e = (int)pop();" ;
    "    int d = (int)pop();" ;
    "    int c = (int)pop();" ;
    "    usize b = (usize)pop();" ;
    "    void* a = pop_ptr();" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push((i64)p);" ;
    "    #endif" ;
    "}" ;;

    PRIM_DEBUG .w " {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)sc; i--) {" ;
    "        cp = c+30;" ;
    "        x = (i64)stack[i];" ;
    "        n = 1;" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_MIRTH_REVISION .w " {" ;
    "    push(" . NEW_MIRTH_REVISION .n ");";
    "}" ;;

    PRIM_MEM_GET .w " {" ;
    "    stack[sc] = *(i64*)(stack[sc]);" ;
    "}" ;;

    PRIM_MEM_SET .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = (i64)pop();" ;
    "}" ;;

    PRIM_MEM_GET_BYTE .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_BYTE .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U8 .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U8 .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U16 .w " {" ;
    "    u16* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U16 .w " {" ;
    "    u16* x = pop_ptr();" ;
    "    *x = pop_u16();" ;
    "}" ;;

    PRIM_MEM_GET_U32 .w " {" ;
    "    u32* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U32 .w " {" ;
    "    u32* x = pop_ptr();" ;
    "    *x = pop_u32();" ;
    "}" ;;

    PRIM_MEM_GET_U64 .w " {" ;
    "    u64* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U64 .w " {" ;
    "    u64* x = pop_ptr();" ;
    "    *x = pop_u64();" ;
    "}" ;;

    PRIM_MEM_GET_I8 .w " {" ;
    "    i8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I8 .w " {" ;
    "    i8* x = pop_ptr();" ;
    "    *x = pop_i8();" ;
    "}" ;;

    PRIM_MEM_GET_I16 .w " {" ;
    "    i16* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I16 .w " {" ;
    "    i16* x = pop_ptr();" ;
    "    *x = pop_i16();" ;
    "}" ;;

    PRIM_MEM_GET_I32 .w " {" ;
    "    i32* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I32 .w " {" ;
    "    i32* x = pop_ptr();" ;
    "    *x = pop_i32();" ;
    "}" ;;

    PRIM_MEM_GET_I64 .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I64 .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = pop_i64();" ;
    "}" ;;

    PRIM_RUNNING_OS .w " {" ;
    "#if defined(MIRTH_WIN32)" ;
    "    push(" . WIN32 .n ");" ;
    "#elif defined(MIRTH_LINUX)" ;
    "    push(" . LINUX .n ");" ;
    "#elif defined(MIRTH_MACOS)" ;
    "    push(" . MACOS .n ");" ;
    "#else" ;
    "    push(" . UNKNOWN .n ");" ;
    "#endif" ;
    "}" ;;

    )

def(c99-emit-externals!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-external!
        1+)
    .lf drop)

def(c99-emit-external!, Name -- +IO,
    name-is-external? if(
        name-sig? sig-arity
        dup 2 >= if(
            "can't declare external with multiple return values" panic!,

            dup 1 >= if(
                "i64 " .,
                "void " .
            )
        )
        dip(dip(dup .name))
        " (" .
        over dup if(
            "i64" .
            1- while(dup,
                ", i64" .
                1-
            ) drop,
            drop
        ) ");" ;

        " void mw" . dip(dip(dup .name)) " (void) {" ;
        over while(dup,
            "    i64 x" . dup .n " = pop();" ;
            1-
        ) drop
        dup if("    push(", "    ") .
        dip(dip(dup .name))
        "(" .
        dip(dup if(
            "x1" .
            dup 1-
            while(dup,
                ", x" .
                dup2 - 1+ .n
                1-
            ) drop,
            id
        ))
        ")" .
        dup if(");", ";") ;
        "}" ;

        drop3,

        drop
    ))

def(c99-emit-word-sigs!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-word-sig!
        1+
    )
    "" ;
    drop)

def(c99-emit-word-sig!, Name -- +IO,
    name-is-word? if(
        " void mw" . .name " (void);" ;,
        drop
    ))

def(c99-emit-word-defs!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-word-def!
        1+)
    drop)

def(c99-emit-word-def!, Name -- +IO,
    name-is-word? if(
        dup typecheck-name!
        dup .w "{" ;
        name-word@ word-body@ c99-emit-run!
        "}" ;;,
        drop
    ))

def(c99-emit-run!, Token -- +IO,
    c99-depth++
    while(token-run-end? not,
        dup c99-emit-token!
        token-next
    ) drop
    c99-depth--)

def(c99-emit-token!, Token -- +IO,
    dup typecheck-token!

    token-type? TOKEN_INT = if(
        "    push(" . token-int@ .n ");" ;,

    token-type? TOKEN_STR = if(
        "    push((i64)(strings + " . token-value@ TokenValue->Int .n "));" ;, # FIXME: just push a string literal.

    token-type? TOKEN_NAME = if(
        c99-emit-word!,

        drop
    ))))

def(c99-emit-word!, Token -- +IO,
    token-name? PRIM_DIP = if(
        token-args-1
        "    { i64 d" . .d " = pop();" ;
        c99-emit-run!
        "      push(d" . .d "); }" ;,

    token-name? PRIM_IF = if(
        token-args-2
        "    if (pop()) {" ;
        dip(c99-emit-run!)
        "    } else {" ;
        c99-emit-run!
        "    }" ;,

    token-name? PRIM_WHILE = if(
        token-args-2
        "    while(1) {" ;
        dip(c99-emit-run!)
        "    if (!pop()) break;" ;
        c99-emit-run!
        "    }" ;,

        token-name@
        "    mw" . .name "();" ;
    ))))

def(c99-emit-main!, Token -- +IO,
    "int main (int argc, char** argv) {" ;
    c99-emit-run!
    "    return 0;" ;
    "}" ;
    )
