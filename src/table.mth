module mirth.table

import std.prelude
import std.maybe
import std.str
import std.list

import mirth.name
import mirth.type
import mirth.buffer
import mirth.word
import mirth.token
import mirth.mirth
import mirth.prim
import mirth.tycon
import mirth.elab
import mirth.def
import mirth.var
import mirth.arrow
import mirth.data

data StateOwner {
    Error
    Default
    Resource [ Ctx Resource ]
    --
    def ctx [ +Mirth |- StateOwner -- Ctx ] {
        { Error -> Ctx.L0 }
        { Default -> Ctx.L0 }
        { Resource -> drop }
    }
    def resource? [ +Mirth |- StateOwner -- Maybe(Resource) ] {
        { Error -> None }
        { Default -> None }
        { Resource -> nip Some }
    }
    def push [ +Mirth |- StackType StateOwner -- StackType ] {
        { Error -> drop StackType.Error }
        { Default -> }
        { Resource -> nip T+ }
    }
    def else(f) [ *a |- (-- StateOwner) StateOwner -- StateOwner ] {
        { Default -> f }
        { _ -> }
    }
}

||| Parse a state owner tag.
|||
|||     +Foo |-
def +Mirth.parse-owner [ +Mirth Token |- owner:Maybe(Token) ] {
    dup name/dname? and(dup next vdash?)
    >Maybe( sip(next succ) ) >owner
}
def +Mirth.resolve-owner [ +Mirth |- Maybe(Token) -- StateOwner ] {
    { None -> StateOwner.Default }
    { Some ->
        +TypeElab.Start!
        token sig-resource-con? if?(
            elab-resource-con!
            dup can-own-state? if(
                ctx swap StateOwner.Resource,
                token "Resource cannot own state." emit-error!
                drop StateOwner.Error
            ),

            token "Expected a resource name." emit-error! StateOwner.Error
        )
        +TypeElab.rdrop
    }
}

# mirth/data/table
table(Table)
patch Table {
    field(~doc, Table, Maybe(Str))
    field(~head, Table, Token) # where the table was defined
    field(~name, Table, Name)
    field(~qname, Table, Prop(QName))
    field(~owner, Table, Prop(StateOwner))
    field(~num-buffer, Table, Buffer)

    def doc        [ +Mirth |- Table -- Maybe(Str)   ] { ~doc @ }
    def head       [ +Mirth |- Table -- Token        ] { ~head @ }
    def qname-soft [ +Mirth |- Table -- Maybe(QName) ] { ~qname @? bind(ready?) }
    def qname-hard [ +Mirth |- Table -- QName        ] { ~qname force! }
    def namespace  [ +Mirth |- Table -- Namespace    ] { qname-hard namespace }
    def name       [ +Mirth |- Table -- Name         ] { ~name @ }
    def owner      [ +Mirth |- Table -- StateOwner   ] { ~owner force! }
    def num-buffer [ +Mirth |- Table -- Buffer       ] { ~num-buffer @ }

    def = [ Table Table -- Bool ] { on2:index = }
    def unify! [ +Mirth |- Table Table -- Type ] {
        dup2 = if(drop >Type, on2:>Type unify-failed!)
    }
    def >Type [ Table -- Type ] { Type.Table }

    def name;  [ +Mirth +Str |- Table -- ] { rdip:name name; }
    def qname; [ +Mirth +Str |- Table -- ] { rdip:qname-hard qname; }
}

table(Field)
patch Field {
    field(~doc, Field, Maybe(Str))
    field(~head, Field, Token)
    field(~name, Field, Name)
    field(~qname, Field, Prop(QName))
    field(~owner, Field, Prop(StateOwner))
    field(~index-type, Field, Prop(Type))
    field(~value-type, Field, Prop(Type))

    def doc        [ +Mirth |- Field -- Maybe(Str)   ] { ~doc @ }
    def head       [ +Mirth |- Field -- Token        ] { ~head @ }
    def name       [ +Mirth |- Field -- Name         ] { ~name @ }
    def qname-soft [ +Mirth |- Field -- Maybe(QName) ] { ~qname @? bind(ready?) }
    def qname-hard [ +Mirth |- Field -- QName        ] { ~qname force! }
    def namespace  [ +Mirth |- Field -- Namespace    ] { qname-hard namespace }
    def owner      [ +Mirth |- Field -- StateOwner   ] { ~owner force! }
    def index-type [ +Mirth |- Field -- Type         ] { ~index-type force! }
    def value-type [ +Mirth |- Field -- Type         ] { ~value-type force! }

    def name;  [ +Mirth +Str |- Field -- ] { rdip:name name; }
    def qname; [ +Mirth +Str |- Field -- ] { rdip:qname-hard qname; }

    def basis [ +Mirth |- Field -- StackType ] { T0 swap owner push }
    def dom   [ +Mirth |- Field -- StackType ] { sip(basis) index-type T* }
    def cod   [ +Mirth |- Field -- StackType ] { sip(basis) value-type Type.Mut T* }
    def type  [ +Mirth |- Field -- ArrowType ] { sip(dom) cod T-> }

    def = [ Field Field -- Bool ] { on2:index = }
}

def table-qname [ +Mirth |- Table Str Int -- QName ] {
    >arity >Name >name Tycon.Table Namespace.Tycon >namespace QName
}

def table-word-new! [ +Mirth |- Table Str Nat doc:Maybe(Str) -- Word ] {
    over2 head dup >head >body None >sig?
    dup >arity over >Name >name >Int table-qname >qname Word.New!
    qname> over PropLabel.WordQName prop over ~qname !
}

def table-new! [ +Mirth |- owner:Maybe(Token) head:Token name:Name state:PropState(QName) doc:Maybe(Str) -- Table ] {
    Table.alloc! >tbl
    @tbl PropLabel.TableQName >label Prop @tbl ~qname !
    @head @tbl ~head !
    name> @tbl ~name !
    doc> @tbl ~doc !
    @tbl Def.Table register

    owner> @tbl PropLabel.TableOwner prop:resolve-owner @tbl ~owner !

    @tbl owner ctx >ctx
    T0 @tbl owner push >basis

    # Table.nil
    None >doc # TODO
    @tbl "nil" 0u table-word-new! >word

    @ctx
    @basis @basis @tbl Type.Table T* T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word!(
        @head ab-token!
        0u64 PushValue.U64 ab-push-value!
        L0 @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.NUM
    None >doc # TODO
    @head >head
    "NUM" >Name >name
    8 bytes >size
    Buffer.New! >buf
    @buf @tbl ~num-buffer !
    @tbl "Num" 0 table-qname
    @buf PropLabel.BufferQName prop
    @buf ~qname !
    @buf Def.Buffer register

    # Table.index
    None >doc # TODO
    @tbl "index" 0u table-word-new! >word

    Ctx.L0
    @basis @tbl Type.Table T* @basis Type.U64 T* T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        L0 @tbl Op.TableToIndex ab-op!
    ) drop

    # Table.from-index
    None >doc # TODO
    @tbl "from-index" 0u table-word-new! >word

    @ctx
    @basis Type.U64 T* @basis @tbl Type.Table T* T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        L0 @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.succ
    None >doc # TODO
    @tbl "succ" 0u table-word-new! >word

    @ctx
    @basis @tbl Type.Table T* dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        L0 @tbl Op.TableToIndex ab-op!
        1u64 PushValue.U64 ab-push-value!
        L0 Prim.U64Add ab-prim!
        L0 @tbl Op.TableFromIndex ab-op!
    ) drop

    # Table.pred
    None >doc # TODO
    @tbl "pred" 0u table-word-new! >word

    @ctx
    @basis @tbl Type.Table T* dup T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        L0 @tbl Op.TableToIndex ab-op!
        L0 Prim.Dup ab-prim!
        0u64 PushValue.U64 ab-push-value!
        L0 Prim.U64Eq ab-prim!
        ab-if!(
            ,
            1u64 PushValue.U64 ab-push-value!
            L0 Prim.U64Sub ab-prim!
        )
        L0 @tbl Op.TableFromIndex ab-op!
    ) drop

    { +Mirth ctx:Ctx basis:StackType tbl:Table buf:Buffer head:Token }

    # Table.for
    None >doc # TODO
    @tbl "for" 1u table-word-new! >word

    Type.STACK "*a" >Name Var.New! >va
    @va StackType.Var @tbl owner push sip(@tbl Type.Table T*) T-> "f" >Name Var.NewAutoRun! >vx

    @ctx @va Ctx.new
    @va StackType.Var @tbl owner push sip(@vx type T*) T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    @vx >var None >default Param L1
    @word PropLabel.WordParams prop
    @word ~params !
    @word make-inline!

    word> ab-build-word! (
        @head ab-token!
        @vx L1 @va StackType.Var @tbl owner push ab-lambda!(
            1u64 PushValue.U64 ab-push-value!
            ab-while!(
                L0 Prim.Dup ab-prim!
                @buf ab-buffer!
                L0 Prim.U64Get ab-prim!
                L0 Prim.U64Le ab-prim!,

                L0 Prim.Dup ab-prim!
                ab-dip! (
                    L0 @tbl Op.TableFromIndex ab-op!
                    @vx ab-var!
                )
                1u64 PushValue.U64 ab-push-value!
                L0 Prim.U64Add ab-prim!
            )
            L0 Prim.Drop ab-prim!
        )
    ) drop
    va> vx> drop2

    # Table.alloc!
    None >doc # TODO
    @tbl "alloc!" 0u table-word-new! >word

    @ctx
    @basis dup @tbl Type.Table T* T->
    @word PropLabel.WordType prop2
    @word ~ctx-type !

    word> ab-build-word! (
        @head ab-token!
        @buf ab-buffer!
        L0 Prim.U64Get ab-prim!
        1u64 PushValue.U64 ab-push-value!
        L0 Prim.U64Add ab-prim!
        L0 Prim.Dup ab-prim!
        @buf ab-buffer!
        L0 Prim.U64Set ab-prim!
        L0 @tbl Op.TableFromIndex ab-op!
    ) drop

    ctx> basis> drop2
    head> buf> drop2
    tbl>
}

||| Parse a table declaration.
|||
|||     table(Tycon)
|||     table(Owner |- Tycon)
|||     table Tycon
|||     table Owner |- Tycon
def parse-table-decl [ +Mirth Token |- owner:Maybe(Token) head:Token doc:Maybe(Str) ] {
    dup doc >doc
    dup num-args 0> if(
        sip(next) args-1 parse-owner >head
        @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
        @head args-0
        @head succ arg-end? else(@head succ "expected end of argument after table name" emit-fatal-error!),

        succ parse-owner dup >head
        @head sig-type-con? else(@head "expected type name" emit-fatal-error!)
        @head args-0
        succ
    )
}

||| Elaborate a table definition `table(True)`.
def elab-table! [ +Mirth Token |- ] {
    parse-table-decl
    elab-def-head
    arity> drop
    table-new! drop
}

||| Parse a field definition
|||
|||     field(f, T1, T2)`
def parse-field [ +Mirth Token |- doc:Maybe(Str) owner:Maybe(Token) head:Token index-type:Token value-type:Token ] {
    dup doc >doc
    sip(next) args-3 >value-type >index-type parse-owner >head
    @head name/dname? else(@head "expected field name" emit-fatal-error!)
    @head args-0
}



||| Elaborate a field definition `field(f, T1, T2)`.
def elab-field! [ +Mirth Token |- ] {
    parse-field elab-def-head
    Field.alloc! >self
    doc> @self ~doc !
    name> @self ~name !
    head> @self ~head !
    arity> 0= else(@self head "Field cannot take arguments." emit-error!)
    @self PropLabel.FieldQName >label Prop @self ~qname !
    index-type> @self PropLabel.FieldIndexType prop(elab-simple-type-arg!) @self ~index-type !
    value-type> @self PropLabel.FieldValueType prop(elab-simple-type-arg!) @self ~value-type !
    @self owner> @self PropLabel.FieldOwner prop2(
        resolve-owner else(
            dup index-type tycon? bind:table?
            if?(owner, StateOwner.Default)
        ) nip
    ) @self ~owner !
    @self Def.Field register

    "Get field value." Some >doc
    @self head dup >head >body
    @self name >Str "@" cat L0 Word.Build! (
        @self namespace,

        @self owner ctx
        T0 @self owner push @self index-type T*
        T0 @self owner push @self value-type T*
        T->,

        L0 @self Op.Field ab-op!
        L0 Prim.MutGet ab-prim!
    ) drop

    "Set field value." Some >doc
    @self head dup >head >body
    @self name >Str "!" cat L0 Word.Build! (
        @self namespace,

        @self owner ctx
        T0 @self owner push @self value-type T* @self index-type T*
        T0 @self owner push
        T->,

        L0 @self Op.Field ab-op!
        L0 Prim.MutSet ab-prim!
    ) drop

    self> drop
}
