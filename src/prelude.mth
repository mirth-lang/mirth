module(prelude)

############################################
# not re-exported because of optimisations #
############################################
# def(dip, *a c [*a -- *b] -- *b c, prim.core.dip)
# def(if, *a Bool [*a -- *b] [*a -- *b] -- *b, prim.core.if)
# def(while, *a [*a -- *a] [*a -- *a Bool] -- *a, prim.core.while)
############################################

##################################################
# not re-exported because they're special syntax #
##################################################
# match
# lambda
##################################################

# Re-exported primitives.
def(id, --, prim.core.id)
def(dup, a -- a a, prim.core.dup)
def(drop, a --, prim.core.drop)
def(swap, a b -- b a, prim.core.swap)
def(??, --, prim.core.debug)
def(run, *a [ *a -- *b ] -- *b, \([f] -> f))

def(==, a a -- Bool, prim.value.eq)
def(<=, a a -- Bool, prim.value.le)
def(<,  a a -- Bool, prim.value.lt)
# def(cast, a -- b, prim.unsafe.cast)
def(value@, Ptr -- a, prim.value.get)
def(value!, a Ptr --, prim.value.set)

def(+, Int Int -- Int, prim.int.add)
def(-, Int Int -- Int, prim.int.sub)
def(*, Int Int -- Int, prim.int.mul)
def(/, Int Int -- Int, prim.int.div)
def(%, Int Int -- Int, prim.int.mod)
def(&, Int Int -- Int, prim.int.and)
def(|, Int Int -- Int, prim.int.or)
def(^, Int Int -- Int, prim.int.xor)
def(<<, Int Int -- Int, prim.int.shl)
def(>>, Int Int -- Int, prim.int.shr)
def(int@, Ptr -- Int, prim.int.get)
def(int!, Int Ptr --, prim.int.set)

def(true, Bool, prim.bool.true)
def(false, Bool, prim.bool.false)
def(&&, Bool Bool -- Bool, prim.bool.and)
def(||, Bool Bool -- Bool, prim.bool.or)

def(ptr+, Int Ptr -- Ptr, prim.ptr.add)
def(|ptr|, Int, prim.ptr.size)
def(ptr@, Ptr -- Ptr, prim.ptr.get)
def(ptr!, Ptr Ptr --,prim.ptr.set)

data(RawPtr, RAWPTR -> Int)
def(with-raw-ptr, *a Ptr [*a RawPtr -- *b] -- *b Ptr,
    \([f] -> prim.ptr.raw RAWPTR swap dip(f)))

def(u8@, Ptr -- U8, prim.u8.get)
def(u8!, U8 Ptr --, prim.u8.set)
def(u16@, Ptr -- U16, prim.u16.get)
def(u16!, U16 Ptr --, prim.u16.set)
def(u32@, Ptr -- U32, prim.u32.get)
def(u32!, U32 Ptr --, prim.u32.set)
def(u64@, Ptr -- U64, prim.u64.get)
def(u64!, U64 Ptr --, prim.u64.set)

def(i8@, Ptr -- I8, prim.i8.get)
def(i8!, I8 Ptr --, prim.i8.set)
def(i16@, Ptr -- I16, prim.i16.get)
def(i16!, I16 Ptr --, prim.i16.set)
def(i32@, Ptr -- I32, prim.i32.get)
def(i32!, I32 Ptr --, prim.i32.set)
def(i64@, Ptr -- I64, prim.i64.get)
def(i64!, I64 Ptr --, prim.i64.set)

data(OS,
    OS_UNKNOWN,
    OS_WINDOWS,
    OS_LINUX,
    OS_MACOS)

def(OS->Int, OS -- Int,
    match(
        OS_UNKNOWN -> 0,
        OS_WINDOWS -> 1,
        OS_LINUX -> 2,
        OS_MACOS -> 3
    ))

def(Int->OS, Int -- OS,
    dup 1 == if(
        drop OS_WINDOWS,
    dup 2 == if(
        drop OS_LINUX,
    dup 3 == if(
        drop OS_MACOS,
        drop OS_UNKNOWN
    ))))

def(RUNNING_OS, OS, prim.sys.os Int->OS)
def(argc, Int, prim.sys.argc)
def(argv, Ptr, prim.sys.argv)

def(posix-read!, Int Ptr Int -- Int, prim.posix.read)
def(posix-write!, Int Ptr Int -- Int, prim.posix.write)
def(posix-open!, Str Int Int -- Int, dip2(Str->Ptr) prim.posix.open)
def(posix-close!, Int -- Int, prim.posix.close)
def(posix-exit!, *a Int -- *b, prim.posix.exit)
def(posix-mmap!, Ptr Int Int Int Int Int -- Ptr, prim.posix.mmap)

def(rotr, a b c -- c a b, swap dip(swap))
def(rotl, a b c -- b c a, dip(swap) swap)

def(over, a b -- a b a, dip(dup) swap)
def(over2, a b1 b2 -- a b1 b2 a, dip(over) swap)
def(over3, a b1 b2 b3 -- a b1 b2 b3 a, dip(over2) swap)

def(tuck, a b -- b a b, dup dip(swap))

def(nip, a b -- b, dip(drop))

def(dup2, a b   -- a b    a b  , over over)
def(dup3, a b c -- a b c  a b c, dup dip(dip(dup2) rotr))

def(dip?, *a c [*a -- *a Bool] -- *a c Bool,
    \([f] -> dip(f) swap))

def(dip', *a c x [*a x -- *b y] -- *b c y,
    \([f] -> swap dip(f) swap))

def(dip2, *a c1 c2 [*a -- *b] -- *b c1 c2,
    \([f] -> dip(dip(f))))

def(dip3, *a c1 c2 c3 [*a -- *b] -- *b c1 c2 c3,
    \([f] -> dip(dip(dip(f)))))

def(drop2, a b --, drop drop)
def(drop3, a b c --, drop drop drop)
def(drop4, a b c d --, drop drop drop drop)

def(rot4r, a b c d -- d a b c, swap dip(rotr))
def(rot4l, a b c d -- b c d a, dip(rotl) swap)

def(or, *a Bool [*a -- *a Bool] -- *a Bool,
    \([f] -> if(true, f)))
# or(f) = if(true, f)

def(and, *a Bool [*a -- *a Bool] -- *a Bool,
    \([f] -> if(f, false)))
# and(f) = if(f, false)

def-type(Byte, U8)
def-type(Size, Int)
def-type(Offset, Int)

def(Str->Ptr, Str -- Ptr, prim.unsafe.cast) # TODO
def(Ptr->Str, Ptr -- Str, prim.unsafe.cast) # TODO

def(U8_MAX, Int, 0xFF)
def(U16_MAX, Int, 0xFFFF)
def(U32_MAX, Int, 0xFFFFFFFF)

def(I8_MAX, Int, 0x7F)
def(I16_MAX, Int, 0x7FFF)
def(I32_MAX, Int, 0x7FFFFFFF)

def(U8_MIN, Int, 0)
def(U16_MIN, Int, 0)
def(U32_MIN, Int, 0)

def(I8_MIN, Int, -0x80)
def(I16_MIN, Int, -0x8000)
def(I32_MIN, Int, -0x80000000)

def(not, Bool -- Bool, false ==)

data(Comparison, EQ, LT, GT)

def(cmp, a a -- Comparison,
    dup2 == if(
        drop2 EQ,
        < if(
            LT,
            GT
        )
    ))
def(cmp?, a a -- a a Comparison, dup2 cmp)
def(<>, a a -- Bool, == not)
def(>, a a -- Bool, swap <)
def(>=, a a -- Bool, swap <=)
def(0=, Int -- Bool, 0 ==)
def(0<, Int -- Bool, 0 <)
def(0>, Int -- Bool, 0 >)
def(0<>, Int -- Bool, 0 <>)
def(1+, Int -- Int, 1 +)
def(1-, Int -- Int, 1 -)
def(max, a a -- a, dup2 < if(nip, drop))
def(min, a a -- a, dup2 < if(drop, nip))

def(ptrs, Size -- Size, |ptr| *)
def(ptr@@, Offset Ptr -- Ptr, dip(ptrs) ptr+ ptr@)
def(ptr!!, Ptr Offset Ptr --, dip(ptrs) ptr+ ptr!)

def(u8@@, Offset Ptr -- Byte, ptr+ u8@)
def(u8!!, Byte Offset Ptr --, ptr+ u8!)

def(ints, Size -- Size, 8 *)
def(int@@, Offset Ptr -- Int, dip(ints) ptr+ int@)
def(int!!, Int Offset Ptr --, dip(ints) ptr+ int!)

def(values, Size -- Size, 16 *)
def(value@@, Offset Ptr -- a, dip(values) ptr+ value@)
def(value!!, a Offset Ptr --, dip(values) ptr+ value!)

def(in-range, Int Int Int -- Bool, dip(over dip(>=)) <= &&)

def(Int->U8, Int -- U8, prim.unsafe.cast)  # U8_MAX & cast
    # dup U8_MIN U8_MAX in-range if(
    #     cast,
    #     "Int->U8 failed: out of bounds" panic!
    # )

def(Int->U16, Int -- U16, prim.unsafe.cast) # U16_MAX & cast
    # dup U16_MIN U16_MAX in-range if(
    #     cast,
    #     "Int->U16 failed: out of bounds" panic!
    # )

def(Int->U32, Int -- U32, prim.unsafe.cast) # U32_MAX & cast
    # dup U32_MIN U32_MAX in-range if(
    #     cast,
    #     "Int->U32 failed: out of bounds" panic!
    # )

def(Int->U64, Int -- U64, prim.unsafe.cast)

def(Int->I8, Int -- I8, prim.unsafe.cast)
    # dup I8_MIN I8_MAX in-range if(
    #     cast,
    #     "Int->I8 failed: out of bounds" panic!
    # )

def(Int->I16, Int -- I16, prim.unsafe.cast)
    # dup I16_MIN I16_MAX in-range if(
    #     cast,
    #     "Int->I16 failed: out of bounds" panic!
    # )

def(Int->I32, Int -- I32, prim.unsafe.cast)
    # dup I32_MIN I32_MAX in-range if(
    #     cast,
    #     "Int->I32 failed: out of bounds" panic!
    # )

def(Int->I64, Int -- I64, prim.unsafe.cast)

def(U8->Int, U8 -- Int, prim.unsafe.cast)
def(U16->Int, U16 -- Int, prim.unsafe.cast)
def(U32->Int, U32 -- Int, prim.unsafe.cast)
def(U64->Int, U64 -- Int, prim.unsafe.cast)

def(I8->Int, I8 -- Int, prim.unsafe.cast) # TODO  test this
def(I16->Int, I16 -- Int, prim.unsafe.cast)
def(I32->Int, I32 -- Int, prim.unsafe.cast)
def(I64->Int, I64 -- Int, prim.unsafe.cast)

def(Int->Char, Int -- Char, prim.unsafe.cast) # unsafe
def(Char->Int, Char -- Int, prim.unsafe.cast)

def(negate, Int -- Int, -1 *)
def(abs, Int -- Int, dup 0< if(negate, id))

#######
# NIL #
#######

||| Default value for any type. This is the 0-filled memory
||| version of the type (hence "nil"). Best practice is to
||| set up your types such that 0-filled memory is a sensible
||| default value.
|||
||| Use nil with care! Don't confuse it for an "optional"
||| value, use `Maybe(t)` instead. Rather, `nil` should
||| be a value within the acceptable range of the type, and
||| a sensible default value for fields of this type.
|||
||| In the future, there will be better control over which
||| types admit a `nil` value.
|||
||| - For booleans, this is false.
||| - For integers, this is zero.
||| - For pointers, this is NULL.
||| - For table typess, this is the 0th row, which you never alloc.
|||   Its fields have nil value unless you override them.
||| - For data types, this is the first constructor, applied to nil values.
||| - For n-tuples, this is [ nil ... nil ]
def(nil, a, 0 prim.unsafe.cast)

||| Test for nil.
def(is-nil, a -- Bool, nil ==)

||| Test for nil.
def(is-nil?, a -- a Bool, dup nil ==)

##########
# TUPLES #
##########

||| Return the "nil" pack, i.e. null.
def(pack-nil, [*a], nil)

||| Is this a nil pack?
def(pack-nil?, [*a] -- [*a] Bool, dup pack-nil ==)

||| Construct a tuple by appending an element.
def(pack-cons, [*a] b -- [*a b], prim.pack.cons)

||| Deconstruct a tuple by splitting it at its last element.
def(pack-uncons, [*a b] -- [*a] b, prim.pack.uncons)

def(pack0, [], pack-nil)
def(pack1, a -- [a], dip(pack0) pack-cons)
def(pack2, a b -- [a b], dip(pack1) pack-cons)
def(pack3, a b c -- [a b c], dip(pack2) pack-cons)
def(pack4, a b c d -- [a b c d], dip(pack3) pack-cons)
def(pack5, a b c d e -- [a b c d e], dip(pack4) pack-cons)

def(unpack0, [] --, drop)
def(unpack1, [a] -- a, pack-uncons nip)
def(unpack2, [a b] -- a b, pack-uncons dip(unpack1))
def(unpack3, [a b c] -- a b c, pack-uncons dip(unpack2))
def(unpack4, [a b c d] -- a b c d, pack-uncons dip(unpack3))
def(unpack5, [a b c d e] -- a b c d e, pack-uncons dip(unpack4))

def(.0, [*a b] -- b, pack-uncons nip)
def(.1, [*a b c] -- b, pack-uncons drop .0)
def(.2, [*a b c d] -- b, pack-uncons drop .1)
def(.3, [*a b c d e] -- b, pack-uncons drop .2)
def(.4, [*a b c d e f] -- b, pack-uncons drop .3)
def(.5, [*a b c d e f g] -- b, pack-uncons drop .4)
