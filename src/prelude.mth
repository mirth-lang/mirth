module(prelude)
import(data.maybe)

############################################
# not re-exported because of optimisations #
############################################
# def(dip, (*a -- *b) *a c -- *b c, prim.core.dip)
# def(if, (*a -- *b, *a -- *b) *a Bool -- *b, prim.core.if)
# def(while, (*a -- *a Bool, *a -- *a) *a -- *a, prim.core.while)
############################################

##################################################
# not re-exported because they're special syntax #
##################################################
# match
# lambda
##################################################

# Re-exported primitives.
alias(id, prim-id)
alias(??, prim-debug)
alias(swap, prim-swap)
alias(dup, prim-dup)
alias(drop, prim-drop)
alias(run, prim-run)

alias(rswap, prim-rswap)
alias(rdip, prim-rdip)

alias(Int+, prim-int-add)
alias(Int-, prim-int-sub)
alias(Int*, prim-int-mul)
alias(Int/, prim-int-div)
alias(Int%, prim-int-mod)
alias(Int&, prim-int-and)
alias(Int|, prim-int-or)
alias(Int^, prim-int-xor)
alias(Int<<, prim-int-shl)
alias(Int>>, prim-int-shr)

def(Bool&&, Bool Bool -- Bool, T -> id, F -> drop F)
def(Bool||, Bool Bool -- Bool, T -> drop T, F -> id)
def(Bool.not, Bool -- Bool, T -> F, F -> T)
def(Bool.or(p),  (*a -- *a Bool) *a Bool -- *a Bool, if(T, p))
def(Bool.and(p), (*a -- *a Bool) *a Bool -- *a Bool, if(p, F))

def-missing(Bool.if(then,else), (*a -- *b, *a -- *b) *a Bool -- *b,
    T -> then,
    F -> else)
def(Bool.then(f), (*a -- *a) *a Bool -- *a,
    T -> f,
    F -> id)
def(Bool.else(f), (*a -- *a) *a Bool -- *a,
    T -> id,
    F -> f)

||| Add byte offset to Ptr. This is unsafe because you lose a reference to the
||| original pointer, so the underlying memory could be garbage collected.
||| Therefore, use Ptr.offset-unsafe only if the Ptr points to a static buffer,
||| or if there are other references to the Ptr. Otherwise use Ptr.offset,
||| which keeps the reference alive while you use the offset pointer.
alias(Ptr.offset-unsafe, prim-ptr-add)

||| Add byte offset to Ptr and use that offset pointer. Unless you know what
||| you're doing (see `Ptr.offset-unsafe`), make sure to fully use the offset
||| pointer within the callback `f`, do not leak it.
def(Ptr.offset(f), (*a Ptr -- *b) *a Offset Ptr -- *b,
    dup dip(prim-ptr-add f) drop)

alias(Ptr@Ptr, prim-ptr-get)
alias(Ptr!Ptr, prim-ptr-set)
alias(Ptr.sizeof, prim-ptr-size)

data(RawPtr, Int>RawPtr -> Int)
def(with-raw-ptr(f), (*a RawPtr -- *b) *a Ptr -- *b Ptr,
    prim-ptr-raw >RawPtr swap dip(f))

alias(Ptr@U8,  prim-u8-get ) alias(Ptr!U8,  prim-u8-set )
alias(Ptr@U16, prim-u16-get) alias(Ptr!U16, prim-u16-set)
alias(Ptr@U32, prim-u32-get) alias(Ptr!U32, prim-u32-set)
alias(Ptr@U64, prim-u64-get) alias(Ptr!U64, prim-u64-set)
alias(Ptr@I8,  prim-i8-get ) alias(Ptr!I8,  prim-i8-set )
alias(Ptr@I16, prim-i16-get) alias(Ptr!I16, prim-i16-set)
alias(Ptr@I32, prim-i32-get) alias(Ptr!I32, prim-i32-set)
alias(Ptr@I64, prim-i64-get) alias(Ptr!I64, prim-i64-set)

data(OS,
    OS_UNKNOWN,
    OS_WINDOWS,
    OS_LINUX,
    OS_MACOS)

def(OS>Int, OS -- Int,
    OS_UNKNOWN -> 0,
    OS_WINDOWS -> 1,
    OS_LINUX -> 2,
    OS_MACOS -> 3)

def(Int>OS, Int -- OS,
    dup 1 = if(
        drop OS_WINDOWS,
    dup 2 = if(
        drop OS_LINUX,
    dup 3 = if(
        drop OS_MACOS,
        drop OS_UNKNOWN
    ))))

def(OS=, OS OS -- Bool, both(>Int) =)

def(RUNNING_OS, OS, prim-sys-os >OS)
alias(argc, prim-sys-argc)
alias(argv, prim-sys-argv)

alias(posix-read!, prim-posix-read)
alias(posix-write!, prim-posix-write)
def(posix-open!, Str Int Int -- Int,
    rotl dup dip(
        prim-str-base rotr
        prim-posix-open
    ) drop)
alias(posix-close!, prim-posix-close)
alias(posix-exit!, prim-posix-exit)

def(rotr, a b c -- c a b, swap dip(swap))
def(rotl, a b c -- b c a, dip(swap) swap)

def(rrotr, +a +b +c -- +c +a +b, rswap rdip(rswap))
def(rrotl, +a +b +c -- +b +c +a, rdip(rswap) rswap)

def(over, a b -- a b a, dip(dup) swap)
def(over2, a b1 b2 -- a b1 b2 a, dip(over) swap)
def(over3, a b1 b2 b3 -- a b1 b2 b3 a, dip(over2) swap)
def(over4, a b1 b2 b3 b4 -- a b1 b2 b3 b4 a, dip(over3) swap)

def(tuck, a b -- b a b, dup dip(swap))

def(nip, a b -- b, dip(drop))

def(dup2, a b   -- a b    a b  , over over)
def(dup3, a b c -- a b c  a b c, dup dip(dip(dup2) rotr))

def(dip?(f), (*a -- *a Bool) *a c -- *a c Bool, dip(f) swap)
def(dip'(f), (*a x -- *b y) *a c x -- *b c y, swap dip(f) swap)

def(dip2(f), (*a -- *b) *a c1 c2 -- *b c1 c2,
    dip(dip(f)))
def(dip3(f), (*a -- *b) *a c1 c2 c3 -- *b c1 c2 c3,
    dip(dip(dip(f))))

def(rdip'(f), (*a +r1 -- *b +r2) *a +c +r1 -- *b +c +r2,
    rswap rdip(f) rswap)

def(rdip2(f), (*a -- *b) *a +c1 +c2 -- *b +c1 +c2,
    rdip(rdip(f)))
def(rdip3(f), (*a -- *b) *a +c1 +c2 +c3 -- *b +c1 +c2 +c3,
    rdip(rdip(rdip(f))))

def(sip(f), (*a x -- *b) *a x -- *b x,
    dup dip(f))
def(sip2(f), (*a x1 x2 -- *b) *a x1 x2 -- *b x1 x2,
    dup2 dip(dip(f)))

def(both(f), (a -- b) a a -- b b, dip(f) f)
def(both2(f), (a1 a2 -- b) a1 a2 a1 a2 -- b b, dip2(f) f)

def(drop2, a b --, drop drop)
def(drop3, a b c --, drop drop drop)
def(drop4, a b c d --, drop drop drop drop)

def(rot4r, a b c d -- d a b c, swap dip(rotr))
def(rot4l, a b c d -- b c d a, dip(rotl) swap)

def(rrot4r, +a +b +c +d -- +d +a +b +c, rswap rdip(rrotr))
def(rrot4l, +a +b +c +d -- +b +c +d +a, rdip(rrotl) rswap)

def(repeat(f), (*a -- *a) *a Int -- *a,
    while(dup 0>, dip(f) 1-) drop)

def(count(f), (*a Int -- *a) *a Int -- *a,
    0 swap repeat(dup dip(f) 1+) drop)
def(countdown(f), (*a Int -- *a) *a Int -- *a,
    dup 1- swap repeat(dup dip(f) 1-) drop)

def-type(Size, Int)
def-type(Offset, Int)

def(U8_MAX, Int, 0xFF)
def(U16_MAX, Int, 0xFFFF)
def(U32_MAX, Int, 0xFFFFFFFF)

def(I8_MAX, Int, 0x7F)
def(I16_MAX, Int, 0x7FFF)
def(I32_MAX, Int, 0x7FFFFFFF)

def(U8_MIN, Int, 0)
def(U16_MIN, Int, 0)
def(U32_MIN, Int, 0)

def(I8_MIN, Int, -0x80)
def(I16_MIN, Int, -0x8000)
def(I32_MIN, Int, -0x80000000)

data(Comparison, LT, EQ, GT)
def(Comparison.is-eq, Comparison -- Bool, LT -> F, EQ -> T, GT -> F)
def(Comparison.is-lt, Comparison -- Bool, LT -> T, EQ -> F, GT -> F)
def(Comparison.is-le, Comparison -- Bool, LT -> T, EQ -> T, GT -> F)
def(Comparison.is-gt, Comparison -- Bool, LT -> F, EQ -> F, GT -> T)
def(Comparison.is-ge, Comparison -- Bool, LT -> F, EQ -> T, GT -> T)
def(Comparison.is-ne, Comparison -- Bool, LT -> T, EQ -> F, GT -> T)

alias(Int=, prim-int-eq)
alias(Int<, prim-int-lt)
def(Int>,  Int Int -- Bool, swap <)
def(Int>=, Int Int -- Bool, < not)
def(Int<=, Int Int -- Bool, swap < not)
def(Int<>, Int Int -- Bool, = not)
def(Int.cmp, Int Int -- Comparison, dup2 = if(drop2 EQ, < if(LT, GT)))
def(Int.max, Int Int -- Int, dup2 < if(nip, drop))
def(Int.min, Int Int -- Int, dup2 < if(drop, nip))
def(Int.in-range, Int Int Int -- Bool, dip(over dip(>=)) <= &&)

def(Str.cmp, Str Str -- Comparison, prim-str-cmp 0 .cmp)
def(Str=,  Str Str -- Bool, .cmp .is-eq)
def(Str<,  Str Str -- Bool, .cmp .is-lt)
def(Str>,  Str Str -- Bool, .cmp .is-gt)
def(Str<=, Str Str -- Bool, .cmp .is-le)
def(Str>=, Str Str -- Bool, .cmp .is-ge)
def(Str<>, Str Str -- Bool, .cmp .is-ne)
def(Str.max, Str Str -- Str, dup2 < if(nip, drop))
def(Str.min, Str Str -- Str, dup2 < if(drop, nip))

def-missing(prim-int-succ, Int -- Int, 1 +)
def-missing(prim-int-pred, Int -- Int, 1 -)
def-missing(prim-int-negate, Int -- Int, -1 *)
alias(negate, prim-int-negate)
alias(1+, prim-int-succ)
alias(1-, prim-int-pred)
alias(Int.negate, prim-int-negate)
alias(Int.succ, prim-int-succ)
alias(Int.pred, prim-int-pred)
def(0=, Int -- Bool, 0 =)
def(0<, Int -- Bool, 0 <)
def(0>, Int -- Bool, 0 >)
def(0>=, Int -- Bool, 0 >=)
def(0<=, Int -- Bool, 0 <=)
def(0<>, Int -- Bool, 0 <>)

alias(Ptr.null, prim-ptr-nil)
def(Ptr.is-null, Ptr -- Bool, prim-unsafe-cast 0=)

def(Ptr@@Ptr, Offset Ptr -- Ptr, dip(Ptr.sizeof *).offset(@Ptr))
def(Ptr!!Ptr, Ptr Offset Ptr --, dip(Ptr.sizeof *).offset(!Ptr))

def(Ptr@@U8,  Offset Ptr -- U8,          .offset(@U8))
def(Ptr@@U16, Offset Ptr -- U16, dip(2 *).offset(@U16))
def(Ptr@@U32, Offset Ptr -- U32, dip(4 *).offset(@U32))
def(Ptr@@U64, Offset Ptr -- U64, dip(8 *).offset(@U64))
def(Ptr@@I8,  Offset Ptr -- I8,          .offset(@I8))
def(Ptr@@I16, Offset Ptr -- I16, dip(2 *).offset(@I16))
def(Ptr@@I32, Offset Ptr -- I32, dip(4 *).offset(@I32))
def(Ptr@@I64, Offset Ptr -- I64, dip(8 *).offset(@I64))

def(Ptr!!U8,  U8  Offset Ptr --,         .offset(!U8))
def(Ptr!!U16, U16 Offset Ptr --, dip(2 *).offset(!U16))
def(Ptr!!U32, U32 Offset Ptr --, dip(4 *).offset(!U32))
def(Ptr!!U64, U64 Offset Ptr --, dip(8 *).offset(!U64))
def(Ptr!!I8,  I8  Offset Ptr --,         .offset(!I8))
def(Ptr!!I16, I16 Offset Ptr --, dip(2 *).offset(!I16))
def(Ptr!!I32, I32 Offset Ptr --, dip(4 *).offset(!I32))
def(Ptr!!I64, I64 Offset Ptr --, dip(8 *).offset(!I64))

def(U8>Int,  U8  -- Int, prim-unsafe-cast)
def(U16>Int, U16 -- Int, prim-unsafe-cast)
def(U32>Int, U32 -- Int, prim-unsafe-cast)
def(U64>Int-unsafe, U64 -- Int, prim-unsafe-cast)
def(U64>Int?, U64 -- Maybe(Int), prim-unsafe-cast dup 0 Int>= if(SOME, drop NONE))
def(U64>Int!, U64 -- Int, U64>Int? unwrap-or("U64 cannot be safely represented by Int" panic!))

def(I8>Int,  I8  -- Int, prim-unsafe-cast)
def(I16>Int, I16 -- Int, prim-unsafe-cast)
def(I32>Int, I32 -- Int, prim-unsafe-cast)
def(I64>Int, I64 -- Int, prim-unsafe-cast)

def-missing(Int>U8-unsafe,  Int --  U8, prim-unsafe-cast)
def-missing(Int>U16-unsafe, Int -- U16, prim-unsafe-cast)
def-missing(Int>U32-unsafe, Int -- U32, prim-unsafe-cast)
def-missing(Int>U64-unsafe, Int -- U64, prim-unsafe-cast)
def-missing(Int>I8-unsafe,  Int --  I8, prim-unsafe-cast)
def-missing(Int>I16-unsafe, Int -- I16, prim-unsafe-cast)
def-missing(Int>I32-unsafe, Int -- I32, prim-unsafe-cast)
def-missing(Int>I64-unsafe, Int -- I64, prim-unsafe-cast)

def(Int>U8%,  Int --  U8,  U8_MAX &  >U8-unsafe)
def(Int>U16%, Int -- U16, U16_MAX & >U16-unsafe)
def(Int>U32%, Int -- U32, U32_MAX & >U32-unsafe)
def(Int>U64%, Int -- U64,           >U64-unsafe)
def(Int>U8?,  Int -- Maybe( U8), dup U8_MIN  U8_MAX  .in-range if( >U8-unsafe SOME, drop NONE))
def(Int>U16?, Int -- Maybe(U16), dup U16_MIN U16_MAX .in-range if(>U16-unsafe SOME, drop NONE))
def(Int>U32?, Int -- Maybe(U32), dup U32_MIN U32_MAX .in-range if(>U32-unsafe SOME, drop NONE))
def(Int>U64?, Int -- Maybe(U64), dup 0 >= if(>U64-unsafe SOME, drop NONE))
def(Int>U8,  Int --  U8, Int>U8?  unwrap-or( "U8 out of bounds" panic!))
def(Int>U16, Int -- U16, Int>U16? unwrap-or("U16 out of bounds" panic!))
def(Int>U32, Int -- U32, Int>U32? unwrap-or("U32 out of bounds" panic!))
def(Int>U64, Int -- U64, Int>U64? unwrap-or("U64 out of bounds" panic!))

def(Int>I8?,  Int -- Maybe( I8), dup I8_MIN  I8_MAX  .in-range if( >I8-unsafe SOME, drop NONE))
def(Int>I16?, Int -- Maybe(I16), dup I16_MIN I16_MAX .in-range if(>I16-unsafe SOME, drop NONE))
def(Int>I32?, Int -- Maybe(I32), dup I32_MIN I32_MAX .in-range if(>I32-unsafe SOME, drop NONE))
def(Int>I64?, Int -- Maybe(I64), >I64-unsafe SOME)
def(Int>I8,  Int -- I8,  Int>I8?  unwrap-or( "I8 out of bounds" panic!))
def(Int>I16, Int -- I16, Int>I16? unwrap-or("I16 out of bounds" panic!))
def(Int>I32, Int -- I32, Int>I32? unwrap-or("I32 out of bounds" panic!))
def(Int>I64, Int -- I64, >I64-unsafe)

def(U8|,   U8  U8 --  U8, both(>Int) |  >U8-unsafe)
def(U16|, U16 U16 -- U16, both(>Int) | >U16-unsafe)
def(U32|, U32 U32 -- U32, both(>Int) | >U32-unsafe)
def(U64|, U64 U64 -- U64, both(>Int-unsafe) | >U64-unsafe)

##########
# TUPLES #
##########

alias(pack0, prim-pack-nil)
def(pack1, a -- [a], dip(pack0) prim-pack-cons)
def(pack2, a b -- [a b], dip(pack1) prim-pack-cons)
def(pack3, a b c -- [a b c], dip(pack2) prim-pack-cons)
def(pack4, a b c d -- [a b c d], dip(pack3) prim-pack-cons)
def(pack5, a b c d e -- [a b c d e], dip(pack4) prim-pack-cons)

alias(unpack0, drop)
def(unpack1, [a] -- a, prim-pack-uncons nip)
def(unpack2, [a b] -- a b, prim-pack-uncons dip(unpack1))
def(unpack3, [a b c] -- a b c, prim-pack-uncons dip(unpack2))
def(unpack4, [a b c d] -- a b c d, prim-pack-uncons dip(unpack3))
def(unpack5, [a b c d e] -- a b c d e, prim-pack-uncons dip(unpack4))

alias(@, prim-mut-get)
alias(!, prim-mut-set)
alias(mut-is-set, prim-mut-is-set)
def(modify(f), (*a t -- *b t) *a Mut(t) -- *b, dup dip(@ f) !)

alias(panic!, prim-panic)
def(expect!(f,g), (*a -- *a Bool, *a -- *b Str) *a -- *a,
    f if(id, g panic!))
def(assert!(f,g), (*a -- *a Bool, *a -- *b Str) *a -- *a,
    expect!(f,g "assertion failed: " swap prim-str-cat))
