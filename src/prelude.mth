module(prelude)

############################################
# not re-exported because of optimisations #
############################################
# def(dip, *a c [*a -- *b] -- *b c, prim.core.dip)
# def(if, *a Bool [*a -- *b] [*a -- *b] -- *b, prim.core.if)
# def(while, *a [*a -- *a] [*a -- *a Bool] -- *a, prim.core.while)
############################################

##################################################
# not re-exported because they're special syntax #
##################################################
# match
# lambda
##################################################

# Re-exported primitives.
def(id, --, prim.core.id)
def(dup, a -- a a, prim.core.dup)
def(drop, a --, prim.core.drop)
def(swap, a b -- b a, prim.core.swap)
def(??, --, prim.core.debug)
def(run, *a [ *a -- *b ] -- *b, prim.core.run)

def(==, a a -- Bool, prim.value.eq)
def(<=, a a -- Bool, prim.value.le)
def(<,  a a -- Bool, prim.value.lt)
def(cast, a -- b, prim.value.cast)
def(value@, Ptr -- a, prim.value.get)
def(value!, a Ptr --, prim.value.set)

def(+, Int Int -- Int, prim.int.add)
def(-, Int Int -- Int, prim.int.sub)
def(*, Int Int -- Int, prim.int.mul)
def(/, Int Int -- Int, prim.int.div)
def(%, Int Int -- Int, prim.int.mod)
def(&, Int Int -- Int, prim.int.and)
def(|, Int Int -- Int, prim.int.or)
def(^, Int Int -- Int, prim.int.xor)
def(<<, Int Int -- Int, prim.int.shl)
def(>>, Int Int -- Int, prim.int.shr)
def(int@, Ptr -- Int, prim.int.get)
def(int!, Int Ptr --, prim.int.set)

def(true, Bool, prim.bool.true)
def(false, Bool, prim.bool.false)
def(&&, Bool Bool -- Bool, prim.bool.and)
def(||, Bool Bool -- Bool, prim.bool.or)

def(ptr+, Int Ptr -- Ptr, prim.ptr.add)
def(|ptr|, Int, prim.ptr.size)
def(ptr@, Ptr -- Ptr, prim.ptr.get)
def(ptr!, Ptr Ptr --,prim.ptr.set)

def(u8@, Ptr -- U8, prim.u8.get)
def(u8!, U8 Ptr --, prim.u8.set)
def(u16@, Ptr -- U16, prim.u16.get)
def(u16!, U16 Ptr --, prim.u16.set)
def(u32@, Ptr -- U32, prim.u32.get)
def(u32!, U32 Ptr --, prim.u32.set)
def(u64@, Ptr -- U64, prim.u64.get)
def(u64!, U64 Ptr --, prim.u64.set)

def(i8@, Ptr -- I8, prim.i8.get)
def(i8!, I8 Ptr --, prim.i8.set)
def(i16@, Ptr -- I16, prim.i16.get)
def(i16!, I16 Ptr --, prim.i16.set)
def(i32@, Ptr -- I32, prim.i32.get)
def(i32!, I32 Ptr --, prim.i32.set)
def(i64@, Ptr -- I64, prim.i64.get)
def(i64!, I64 Ptr --, prim.i64.set)

data OS
    OS_UNKNOWN
    OS_WINDOWS
    OS_LINUX
    OS_MACOS
end
def(RUNNING_OS, OS, prim.sys.os cast)
def(argc, Int, prim.sys.argc)
def(argv, Ptr, prim.sys.argv)

def(posix-read!, Int Ptr Int -- Int, prim.posix.read)
def(posix-write!, Int Ptr Int -- Int, prim.posix.write)
def(posix-open!, Str Int Int -- Int, dip2(Str->Ptr) prim.posix.open)
def(posix-close!, Int -- Int, prim.posix.close)
def(posix-exit!, *a Int -- *b, prim.posix.exit)
def(posix-mmap!, Ptr Int Int Int Int Int -- Ptr, prim.posix.mmap)

rotr : a b c -- c a b
rotr = \(a b c -> c a b)

rotl : a b c -- b c a
rotl = \(a b c -> b c a)

over : a b -- a b a
over = \(a b -> a b a)

tuck : a b -- b a b
tuck = \(a b -> b a b)

nip : a b -- b
nip = \(a b -> b)

trip : a -- a a a
quad : a -- a a a a

trip = \(a -> a a a)
quad = \(a -> a a a a)

swap2 : a1 a2 b1 b2 -- b1 b2 a1 a2
swap3 : a1 a2 a3 b1 b2 b3 -- b1 b2 b3 a1 a2 a3
swap4 : a1 a2 a3 a4 b1 b2 b3 b4 -- b1 b2 b3 b4 a1 a2 a3 a4

swap2 = \(a1 a2 b1 b2 -> b1 b2 a1 a2)
swap3 = \(a1 a2 a3 b1 b2 b3 -> b1 b2 b3 a1 a2 a3)
swap4 = \(a1 a2 a3 a4 b1 b2 b3 b4 -> b1 b2 b3 b4 a1 a2 a3 a4)

dup2 : a1 a2 -- a1 a2 a1 a2
dup3 : a1 a2 a3 -- a1 a2 a3 a1 a2 a3
dup4 : a1 a2 a3 a4 -- a1 a2 a3 a4 a1 a2 a3 a4

dup2 = \(a1 a2 -> a1 a2 a1 a2)
dup3 = \(a1 a2 a3 -> a1 a2 a3 a1 a2 a3)
dup4 = \(a1 a2 a3 a4 -> a1 a2 a3 a4 a1 a2 a3 a4)

dip2 : *a c1 c2       [*a -- *b] -- *b c1 c2
dip3 : *a c1 c2 c3    [*a -- *b] -- *b c1 c2 c3
dip4 : *a c1 c2 c3 c4 [*a -- *b] -- *b c1 c2 c3 c4

dip2 = \(c1 c2       [f] -> f c1 c2)
dip3 = \(c1 c2 c3    [f] -> f c1 c2 c3)
dip4 = \(c1 c2 c3 c4 [f] -> f c1 c2 c3 c4)

dip'  : *a1 c1 a2          [*a1 a2 -- *b1 b2] -- *b1 c1 b2
dip2' : *a1 c1 a2 c2       [*a1 a2 -- *b1 b2] -- *b1 c1 b2 c2
dip3' : *a1 c1 a2 c2 c3    [*a1 a2 -- *b1 b2] -- *b1 c1 b2 c2 c3
dip4' : *a1 c1 a2 c2 c3 c4 [*a1 a2 -- *b1 b2] -- *b1 c1 b2 c2 c3 c4

dip'   = \([f] -> swap dip(f) swap)
dip2'  = \([f] -> dip(swap dip(f) swap))
dip3'  = \([f] -> dip(dip(swap dip(f) swap)))
dip4'  = \([f] -> dip(dip(dip(swap dip(f) swap))))

dip2'' : *a1 c1 c2 a2       [*a1 a2 -- *b1 b2] -- *b1 c1 c2 b2
dip3'' : *a1 c1 c2 a2 c3    [*a1 a2 -- *b1 b2] -- *b1 c1 c2 b2 c3
dip4'' : *a1 c1 c2 a2 c3 c4 [*a1 a2 -- *b1 b2] -- *b1 c1 c2 b2 c3 c4

dip2'' = \([f] -> rotr dip(dip(f)) rotl)
dip3'' = \([f] -> dip(rotr dip(dip(f)) rotl))
dip4'' = \([f] -> dip(dip(rotr dip(dip(f)) rotl)))

dip3''' : *a1 c1 c2 c3 a2    [*a1 a2 -- *b1 b2] -- *b1 c1 c2 c3 b2
dip4''' : *a1 c1 c2 c3 a2 c4 [*a1 a2 -- *b1 b2] -- *b1 c1 c2 c3 b2 c4

dip3''' = \([f] -> rot4r dip3(f) rot4l)
dip4''' = \([f] -> dip(dip3'''(f)))

dip4'''' : *a1 c1 c2 c3 c4 a2 [*a1 a2 -- *b1 b2] -- *b1 c1 c2 c3 c4 b2
dip4'''' = \([f] -> rot5r dip4(f) rot5l)

drop2 : a b --
drop3 : a b c --
drop4 : a b c d --
drop5 : a b c d e --

drop2 = \(a b ->)
drop3 = \(a b c ->)
drop4 = \(a b c d ->)
drop5 = \(a b c d e ->)

rot2r : x y -- y x
rot3r : x1 x2 y -- y x1 x2
rot4r : x1 x2 x3 y -- y x1 x2 x3
rot5r : x1 x2 x3 x4 y -- y x1 x2 x3 x4
rot6r : x1 x2 x3 x4 x5 y -- y x1 x2 x3 x4 x5
rot7r : x1 x2 x3 x4 x5 x6 y -- y x1 x2 x3 x4 x5 x6
rot8r : x1 x2 x3 x4 x5 x6 x7 y -- y x1 x2 x3 x4 x5 x6 x7

rot2l : y x -- x y
rot3l : y x1 x2 -- x1 x2 y
rot4l : y x1 x2 x3 -- x1 x2 x3 y
rot5l : y x1 x2 x3 x4 -- x1 x2 x3 x4 y
rot6l : y x1 x2 x3 x4 x5 -- x1 x2 x3 x4 x5 y
rot7l : y x1 x2 x3 x4 x5 x6 -- x1 x2 x3 x4 x5 x6 y
rot8l : y x1 x2 x3 x4 x5 x6 x7 -- x1 x2 x3 x4 x5 x6 x7 y

rot2r = \(x y -> y x)
rot3r = \(x1 x2 y -> y x1 x2)
rot4r = \(x1 x2 x3 y -> y x1 x2 x3)
rot5r = \(x1 x2 x3 x4 y -> y x1 x2 x3 x4)
rot6r = \(x1 x2 x3 x4 x5 y -> y x1 x2 x3 x4 x5)
rot7r = \(x1 x2 x3 x4 x5 x6 y -> y x1 x2 x3 x4 x5 x6)
rot8r = \(x1 x2 x3 x4 x5 x6 x7 y -> y x1 x2 x3 x4 x5 x6 x7)

rot2l = \(y x -> x y)
rot3l = \(y x1 x2 -> x1 x2 y)
rot4l = \(y x1 x2 x3 -> x1 x2 x3 y)
rot5l = \(y x1 x2 x3 x4 -> x1 x2 x3 x4 y)
rot6l = \(y x1 x2 x3 x4 x5 -> x1 x2 x3 x4 x5 y)
rot7l = \(y x1 x2 x3 x4 x5 x6 -> x1 x2 x3 x4 x5 x6 y)
rot8l = \(y x1 x2 x3 x4 x5 x6 x7 -> x1 x2 x3 x4 x5 x6 x7 y)

def-type(Byte, U8)
def-type(Char, U8)
def-type(Size, Int)
def-type(Offset, Int)

Str->Ptr : Str -- Ptr
Str->Ptr = cast

Ptr->Str : Ptr -- Str
Ptr->Str = cast

Int->Ptr : Int -- Ptr
Int->Ptr = cast

Ptr->Int : Ptr -- Int
Ptr->Int = cast

U8_MAX : Int
U8_MAX = 0xFF

U16_MAX : Int
U16_MAX = 0xFFFF

U32_MAX : Int
U32_MAX = 0xFFFFFFFF

I8_MAX : Int
I8_MAX = 0x7F

I16_MAX : Int
I16_MAX = 0x7FFF

I32_MAX : Int
I32_MAX = 0x7FFFFFFF


U8_MIN : Int
U8_MIN = 0

U16_MIN : Int
U16_MIN = 0

U32_MIN : Int
U32_MIN = 0

I8_MIN : Int
I8_MIN = -0x80

I16_MIN : Int
I16_MIN = -0x8000

I32_MIN : Int
I32_MIN = -0x80000000

not : Bool -- Bool
not = false ==

!= : a a -- Bool
!= = == not

data Comparison
    EQ
    LT
    GT
end

cmp : a a -- Comparison
cmp =
    dup2 == if(
        drop2 EQ,
        < if(
            LT,
            GT
        )
    )

cmp? : a a -- a a Comparison
cmp? = dup2 cmp

> : a a -- Bool
> = swap <

>= : a a -- Bool
>= = swap <=

0= : Int -- Bool
0= = 0 ==

0< : Int -- Bool
0< = 0 <

1+ : Int -- Int
1+ = 1 +

1- : Int -- Int
1- = 1 -

max : Int Int -- Int
max = dup2 < if(nip, drop)

min : Int Int -- Int
min = dup2 < if(drop, nip)

square : Int -- Int
square = dup *

nonzero : Int -- Bool
nonzero = 0 !=

ptrs : Size -- Size
ptrs = |ptr| *

ptr@@ : Offset Ptr -- Ptr
ptr@@ = dip(ptrs) ptr+ ptr@

ptr!! : Ptr Offset Ptr --
ptr!! = dip(ptrs) ptr+ ptr!

u8@@ : Offset Ptr -- Byte
u8@@ = ptr+ u8@

u8!! : Byte Offset Ptr --
u8!! = ptr+ u8!

ints : Size -- Size
ints = 8 *

int@@ : Offset Ptr -- Int
int@@ = dip(ints) ptr+ int@

int!! : Int Offset Ptr --
int!! = dip(ints) ptr+ int!

values : Size -- Size
values = 16 *

value@@ : Offset Ptr -- a
value@@ = dip(values) ptr+ value@

value!! : a Offset Ptr --
value!! = dip(values) ptr+ value!

in-range : Int Int Int -- Bool
in-range = dip(over dip(>=)) <= &&

Int->U8 : Int -- U8
Int->U8 =
    dup U8_MIN U8_MAX in-range if(
        cast,
        "Int->U8 failed: out of bounds" panic!
    )

Int->U16 : Int -- U16
Int->U16 =
    dup U16_MIN U16_MAX in-range if(
        cast,
        "Int->U16 failed: out of bounds" panic!
    )

Int->U32 : Int -- U32
Int->U32 =
    dup U32_MIN U32_MAX in-range if(
        cast,
        "Int->U32 failed: out of bounds" panic!
    )

Int->U64 : Int -- U64
Int->U64 = cast

Int->I8 : Int -- I8
Int->I8 =
    dup I8_MIN I8_MAX in-range if(
        cast,
        "Int->I8 failed: out of bounds" panic!
    )

Int->I16 : Int -- I16
Int->I16 =
    dup I16_MIN I16_MAX in-range if(
        cast,
        "Int->I16 failed: out of bounds" panic!
    )

Int->I32 : Int -- I32
Int->I32 =
    dup I32_MIN I32_MAX in-range if(
        cast,
        "Int->I32 failed: out of bounds" panic!
    )

Int->I64 : Int -- I64
Int->I64 = cast

U8->Int : U8 -- Int
U8->Int = cast

U16->Int : U16 -- Int
U16->Int = cast

U32->Int : U32 -- Int
U32->Int = cast

U64->Int : U64 -- Int
U64->Int = cast

I8->Int : I8 -- Int
I8->Int = cast

I16->Int : I16 -- Int
I16->Int = cast

I32->Int : I32 -- Int
I32->Int = cast

I64->Int : I64 -- Int
I64->Int = cast

negate : Int -- Int
negate = -1 *

abs : Int -- Int
abs = dup 0< if(negate, id)

###########
# STRINGS #
###########

# TODO: UTF8 support
str-head : Str -- U8
str-head = Str->Ptr u8@

# TODO: UTF8 support
str-tail : Str -- Str
str-tail = Str->Ptr 1 swap ptr+ Ptr->Str

str-numbytes : Str -- Int
str-numbytes = is-nil? if(drop 0, Str->Ptr prim.ptr.numbytes)

str-length : Str -- Int
str-length =
    0 swap while(
        str-is-empty? not,
        dip(1+) str-tail
    ) drop

str-length? : Str -- Str Int
str-length? = dup str-length

str-concat : List(Str) -- Str
str-concat = (
    dup 1 swap for(str-numbytes + 1-) prim.ptr.alloc
    dup dip(
        swap for(swap str-copy-partial!)
        nil swap u8!
    ) Ptr->Str
)

str-cat : Str Str -- Str
str-cat = L2 str-concat

str-is-empty : Str -- Bool
str-is-empty = is-nil? if(drop true, str-head is-nil)

str-is-empty? : Str -- Str Bool
str-is-empty? = dup str-is-empty

||| Copy first argument to second argument until a zero byte
||| is reached in first argument. Return first unwritten
||| location in second argument.
ptr-copy-nonzero! : Ptr Ptr -- Ptr
ptr-copy-nonzero! = (
    over is-nil if(
        nip,
        while( over u8@ U8->Int nonzero,
            over u8@ over u8!
            dip(1 swap ptr+) 1 swap ptr+)
        nip
    )
)

||| Copy string bytes to second argument without adding 0 at end.
||| Return first unwritten location in second argument.
str-copy-partial! : Str Ptr -- Ptr
str-copy-partial! = dip(Str->Ptr) ptr-copy-nonzero!

||| Copy string to second argument, and add the 0 byte at the end.
str-copy! : Str Ptr --
str-copy! = (
    dip(Str->Ptr)
    ptr-copy-nonzero!
    nil swap u8!
)

STR_BUF_SIZE : Int
STR_BUF_SIZE = 0x1000
buffer(STR_BUF, 0x1000)
buffer(STR_BUF_LEN, 8)

build-str! : *a [ *a -- *b ] -- *b Str
build-str! =
    str-buf-dup! str-buf-clear! dip(
        run str-buf-dup!
    ) str-buf!

str-buf-dup! : Str
str-buf-dup! = (
    str-buf-length? 1+ prim.ptr.alloc
    dup Ptr->Str dip(STR_BUF swap ptr-copy-nonzero! nil swap u8!)
)

str-buf-length? : Int +StrBuf
str-buf-length? = STR_BUF_LEN int@

str-buf-length! : Int -- +StrBuf
str-buf-length! = (
    dup STR_BUF_LEN int!
    dip(0 Int->U8) str-buf-u8!
)

str-buf-u8@ : Offset -- U8 +StrBuf
str-buf-u8@ = STR_BUF u8@@

str-buf-u8! : U8 Offset -- +StrBuf
str-buf-u8! = STR_BUF u8!!

str-buf-empty? : Bool +StrBuf
str-buf-empty? = str-buf-length? 0=

str-buf-full? : Bool +StrBuf
str-buf-full? = str-buf-length? 1+ STR_BUF_SIZE >=

str-buf-clear! : +StrBuf
str-buf-clear! = 0 str-buf-length!

str-buf-push! : U8 -- +StrBuf
str-buf-push! =
    str-buf-full? if(
        "str-buf-push! but STR_BUF is already full" panic!,
        str-buf-length? str-buf-u8!
        str-buf-length? 1+ str-buf-length!
    )

||| Append the given string into STR_BUF. If the string is
||| too large it gets truncated.
str-buf-push-str! : Str -- +StrBuf
str-buf-push-str! = Str->Ptr str-buf-push-ptr!

str-buf-push-ptr! : Ptr -- +StrBuf
str-buf-push-ptr! =
    while(
        str-buf-full? if(false, dup u8@ U8->Int nonzero),
        dup u8@ str-buf-push!
        1 swap ptr+
    ) drop

||| Set the STR_BUF to a given string. If the string is
||| too large it gets truncated.
str-buf! : Str -- +StrBuf
str-buf! = str-buf-clear! str-buf-push-str!

# TODO UTF8 support?
str-buf-char! : Char -- +StrBuf
str-buf-char! = 0 str-buf-u8! 1 str-buf-length!

to-digit : Int -- U8
to-digit = 10 % 48 + Int->U8

||| Put integer into STR_BUF.
str-buf-int! : Int -- +StrBuf
str-buf-int! =
    dup 0= if(
        drop "0" str-buf!,
        dup dip(
            abs
            str-buf-clear!
            while(dup nonzero, dup to-digit str-buf-push! 10 /) drop
        ) 0 < if(45 Int->U8 str-buf-push!, id)
        str-buf-reverse!
    )

int-show : Int -- Str
int-show = build-str!(str-buf-int!)

||| Swap two bytes in STR_BUF.
str-buf-swap-u8! : Int Int -- +StrBuf
str-buf-swap-u8! = (
    dup2 swap
    dip3(str-buf-u8@)
    dip(str-buf-u8@)
    str-buf-u8! str-buf-u8!
)

||| Reverse contents of STR_BUF bytewise.
str-buf-reverse! : +StrBuf
str-buf-reverse! = (
    0 str-buf-length? 1-
    while(dup2 <,
        dup2 str-buf-swap-u8!
        dip(1+) 1-
    )
    drop2
)

||| Are two strings equal?
str-eq : Str Str -- Bool
str-eq =
    str-is-empty? if(
        drop str-is-empty,
        dup2 str-head swap str-head == if(
            str-tail swap str-tail str-eq,
            drop2 false
        )
    )

||| Are two strings equal? Preserve pointers.
str-eq? : Str Str -- Str Str Bool
str-eq? = dup2 str-eq

||| Traverse string characters.
str-for : *a Str [*a Char -- *a] -- *a
str-for = \([f] ->
    while(str-is-empty? not,
        dup str-tail
        dip(str-head f)
    ) drop
)

#######
# NIL #
#######

||| Default value for any type. This is the 0-filled memory
||| version of the type (hence "nil"). Best practice is to
||| set up your types such that 0-filled memory is a sensible
||| default value.
|||
||| Use nil with care! Don't confuse it for an "optional"
||| value, use `Maybe(t)` instead. Rather, `nil` should
||| be a value within the acceptable range of the type, and
||| a sensible default value for fields of this type.
|||
||| In the future, there will be better control over which
||| types admit a `nil` value.
|||
||| - For booleans, this is false.
||| - For integers, this is zero.
||| - For pointers, this is NULL.
||| - For table typess, this is the 0th row, which you never alloc.
|||   Its fields have nil value unless you override them.
||| - For data types, this is the first constructor, applied to nil values.
||| - For n-tuples, this is [ nil ... nil ]
nil : a
nil = 0 cast

||| Test for nil.
is-nil : a -- Bool
is-nil = nil ==

||| Test for nil.
is-nil? : a -- a Bool
is-nil? = dup nil ==

##########
# TUPLES #
##########

||| Return the "nil" pack, i.e. null.
pack-nil : [*a]
pack-nil = nil

||| Is this a nil pack?
pack-nil? : [*a] -- [*a] Bool
pack-nil? = dup pack-nil ==

||| Construct a tuple by appending an element.
pack-cons : [*a] b -- [*a b]
pack-cons = prim.pack.cons

||| Deconstruct a tuple by splitting it at its last element.
pack-uncons : [*a b] -- [*a] b
pack-uncons = prim.pack.uncons

pack0 : []
pack0 = pack-nil

pack1 : a -- [a]
pack1 = dip(pack0) pack-cons

pack2 : a b -- [a b]
pack2 = dip(pack1) pack-cons

pack3 : a b c -- [a b c]
pack3 = dip(pack2) pack-cons

pack4 : a b c d -- [a b c d]
pack4 = dip(pack3) pack-cons

pack5 : a b c d e -- [a b c d e]
pack5 = dip(pack4) pack-cons

unpack0 : [] --
unpack0 = drop

unpack1 : [a] -- a
unpack1 = pack-uncons nip

unpack2 : [a b] -- a b
unpack2 = pack-uncons dip(unpack1)

unpack3 : [a b c] -- a b c
unpack3 = pack-uncons dip(unpack2)

unpack4 : [a b c d] -- a b c d
unpack4 = pack-uncons dip(unpack3)

unpack5 : [a b c d e] -- a b c d e
unpack5 = pack-uncons dip(unpack4)

.0 : [*a b] -- b
.0 = pack-uncons nip

.1 : [*a b c] -- b
.1 = pack-uncons drop .0

.2 : [*a b c d] -- b
.2 = pack-uncons drop .1

.3 : [*a b c d e] -- b
.3 = pack-uncons drop .2

.4 : [*a b c d e f] -- b
.4 = pack-uncons drop .3

.5 : [*a b c d e f g] -- b
.5 = pack-uncons drop .4

.0? : [*a b] -- [*a b] b
.0? = dup .0

.1? : [*a b c] -- [*a b c] b
.1? = dup .1

.2? : [*a b c d] -- [*a b c d] b
.2? = dup .2

.3? : [*a b c d e] -- [*a b c d e] b
.3? = dup .3

.4? : [*a b c d e f] -- [*a b c d e f] b
.4? = dup .4

.5? : [*a b c d e f g] -- [*a b c d e f g] b
.5? = dup .5

.0! : y [*a x] -- [*a y]
.0! = pack-uncons drop swap pack-cons

.1! : y [*a x b] -- [*a y b]
.1! = pack-uncons dip(.0!) pack-cons

.2! : y [*a x b c] -- [*a y b c]
.2! = pack-uncons dip(.1!) pack-cons

.3! : y [*a x b c d] -- [*a y b c d]
.3! = pack-uncons dip(.2!) pack-cons

.4! : y [*a x b c d e] -- [*a y b c d e]
.4! = pack-uncons dip(.3!) pack-cons

.5! : y [*a x b c d e f] -- [*a y b c d e f]
.5! = pack-uncons dip(.4!) pack-cons

#########
# Maybe #
#########

data Maybe(t)
    NONE
    SOME -> t
end

is-none : Maybe(t) -- Bool
is-none = is-nil

is-some : Maybe(t) -- Bool
is-some = is-nil not

is-none? : Maybe(t) -- Maybe(t) Bool
is-none? = is-nil?

is-some? : Maybe(t) -- Maybe(t) Bool
is-some? = is-nil? not

maybe-map : *c Maybe(a) [*c a -- *c b] -- *c Maybe(b)
maybe-map =
    swap match(
        NONE -> drop NONE,
        SOME -> swap run SOME,
    )

maybe-bind : *c Maybe(a) [*c a -- *c Maybe(b)] -- *c Maybe(b)
maybe-bind =
    swap match(
        NONE -> drop NONE,
        SOME -> swap run
    )

maybe-for : *c Maybe(a) [*c a -- *c] -- *c
maybe-for =
    swap match(
        NONE -> drop,
        SOME -> swap run
    )

maybe-filter : *c Maybe(a) [*c a -- *c a Bool] -- *c Maybe(a)
maybe-filter =
    swap match(
        NONE -> drop NONE,
        SOME -> swap run if(SOME, drop NONE)
    )

#########
# LISTS #
#########

data List(t)
    L0
    L1 -> t
    L2 -> t t
    L3 -> t t t
    LCAT -> List+(t) List+(t) Int
end

L4 : t t  t t -- List(t)
L4 = L4+ List+->List

L5 : t t  t t t -- List(t)
L5 = L5+ List+->List

L6 : t t t  t t t -- List(t)
L6 = L6+ List+->List

L7 : t t t   t t  t t  -- List(t)
L7 = L7+ List+->List

L8 : t t t   t t  t t t  -- List(t)
L8 = L8+ List+->List

L9 : t t t   t t t  t t t -- List(t)
L9 = L9+ List+->List

L10 : t t  t t t   t t  t t t -- List(t)
L10 = L10+ List+->List

L11 : t t  t t t   t t t  t t t -- List(t)
L11 = L11+ List+->List

L12 : t t t  t t t  t t t  t t t -- List(t)
L12 = L12+ List+->List

data List+(t)
    L1+ -> t
    L2+ -> t t
    L3+ -> t t t
    LCAT+ -> List+(t) List+(t) Int
end

L4+ : t t  t t -- List+(t)
L4+ = L2+ dip(L2+) 4 LCAT+

L5+ : t t  t t t -- List+(t)
L5+ = L3+ dip(L2+) 5 LCAT+

L6+ : t t t  t t t -- List+(t)
L6+ = L3+ dip(L3+) 6 LCAT+

L7+ : t t t   t t  t t  -- List+(t)
L7+ = L4+ dip(L3+) 7 LCAT+

L8+ : t t t   t t  t t t  -- List+(t)
L8+ = L5+ dip(L3+) 8 LCAT+

L9+ : t t t   t t t  t t t -- List+(t)
L9+ = L6+ dip(L3+) 9 LCAT+

L10+ : t t  t t t   t t  t t t -- List+(t)
L10+ = L5+ dip(L5+) 10 LCAT+

L11+ : t t  t t t   t t t  t t t -- List+(t)
L11+ = L6+ dip(L5+) 11 LCAT+

L12+ : t t t  t t t  t t t  t t t -- List+(t)
L12+ = L6+ dip(L6+) 12 LCAT+

List+->List : List+(t) -- List(t)
List+->List =
    match(
        L1+ -> L1,
        L2+ -> L2,
        L3+ -> L3,
        LCAT+ -> LCAT,
    )

List->List+ : List(t) -- Maybe(List+(t))
List->List+ =
    match(
        L0 -> NONE,
        L1 -> L1+ SOME,
        L2 -> L2+ SOME,
        L3 -> L3+ SOME,
        LCAT -> LCAT+ SOME
    )

len : List(t) -- Int
len =
    match(
        L0 -> 0,
        L1 -> drop 1,
        L2 -> drop2 2,
        L3 -> drop3 3,
        LCAT -> dip(drop2)
    )

len+ : List+(t) -- Int
len+ =
    match(
        L1+ -> drop 1,
        L2+ -> drop2 2,
        L3+ -> drop3 3,
        LCAT+ -> dip(drop2)
    )

len? : List(t) -- List(t) Int
len? = dup len

len+? : List+(t) -- List+(t) Int
len+? = dup len+

cons+ : t List(t) -- List+(t)
cons+ =
    match(
        L0 -> L1+,
        L1 -> L2+,
        L2 -> L3+,
        L3 -> L4+,
        LCAT -> 1+ dip(dip(cons++) rebalance+) LCAT+
    )

snoc+ : List(t) t -- List+(t)
snoc+ =
    swap match(
        L0 -> L1+,
        L1 -> rot2l L2+,
        L2 -> rot3l L3+,
        L3 -> rot4l L4+,
        LCAT -> 1+ dip(rot3l snoc++ rebalance+) LCAT+
    )

cons++ : t List+(t) -- List+(t)
cons++ = List+->List cons+

snoc++ : List+(t) t -- List+(t)
snoc++ = dip(List+->List) snoc+

cons : t List(t) -- List(t)
cons = cons+ List+->List

snoc : List(t) t -- List(t)
snoc = snoc+ List+->List

uncons : List+(t) -- t List(t)
uncons =
    match(
        L1+ -> L0,
        L2+ -> L1,
        L3+ -> L2,
        LCAT+ -> drop dip(uncons) cat_+ List+->List
    )

unsnoc : List+(t) -- List(t) t
unsnoc =
    match(
        L1+ -> dip(L0),
        L2+ -> dip(L1),
        L3+ -> dip(L2),
        LCAT+ -> drop unsnoc dip(cat+_ List+->List)
    )

cat : List(t) List(t) -- List(t)
cat =
    swap List->List+ match(
        NONE -> id,
        SOME ->
            swap List->List+ match(
                NONE -> List+->List,
                SOME -> cat+ List+->List
            )
    )

cat_+ : List(t) List+(t) -- List+(t)
cat_+ =
    swap List->List+ match(
        NONE -> id,
        SOME -> swap cat+
    )

cat+_ : List+(t) List(t) -- List+(t)
cat+_ =
    List->List+ match(
        NONE -> id,
        SOME -> cat+
    )

cat+ : List+(t) List+(t) -- List+(t)
cat+ =
    swap match(
        L1+ -> swap cons++,
        L2+ ->
            rot3l match(
                L1+ -> L3+,
                L2+ -> L4+,
                L3+ -> L5+,
                _ -> dip(L2+) cat-aux
            ),
        L3+ ->
            rot4l match(
                L1+ -> L4+,
                L2+ -> L5+,
                L3+ -> L6+,
                _ -> dip(L3+) cat-aux
            ),
        _ ->
            swap match(
                L1+ -> snoc++,
                _ -> cat-aux
            )
    )

cat-aux : List+(t) List+(t) -- List+(t)
cat-aux = rebalance+ dup2 dip(len+) len+ + LCAT+

rebalance+ : List+(t) List+(t) -- List+(t) List+(t)
rebalance+ =
    dup2 dip(len+) len+ dup2 3 * > if(
        drop2 dip(split-half-left) cat_+ rebalance+,
        dip(3 *) < if(
            split-half-right dip(cat+_) rebalance+,
            id
        )
    )

split-half-left : List+(t) -- List+(t) List(t)
split-half-left =
    match(
        L1+ -> L0 dip(L1+),
        L2+ -> L1 dip(L1+),
        L3+ -> L1 dip(L2+),
        LCAT+ -> drop List+->List
    )

split-half-right : List+(t) -- List(t) List+(t)
split-half-right =
    match(
        L1+ -> L1+ dip(L0),
        L2+ -> L1+ dip(L1),
        L3+ -> L2+ dip(L1),
        LCAT+ -> drop dip(List+->List)
    )

split-half : List(t) -- List(t) List(t)
split-half =
    match(
        L0 -> L0 L0,
        L1 -> L1 dip(L0),
        L2 -> L1 dip(L1),
        L3 -> L2 dip(L1),
        LCAT -> drop dip(List+->List) List+->List
    )


first : List(t) -- Maybe(t)
first = List->List+ maybe-map(first+)

last : List(t) -- Maybe(t)
last = List->List+ maybe-map(last+)

middle : List(t) -- Maybe(t)
middle = List->List+ maybe-map(middle+)

first+ : List+(t) -- t
first+ =
    match(
        L1+ -> id,
        L2+ -> drop,
        L3+ -> drop2,
        LCAT+ -> drop2 first+
    )

last+ : List+(t) -- t
last+ =
    match(
        L1+ -> id,
        L2+ -> dip(drop),
        L3+ -> dip(drop2),
        LCAT+ -> drop nip last+
    )

middle+ : List+(t) -- t
middle+ =
    match(
        L1+ -> id,
        L2+ -> nip,
        L3+ -> drop nip,
        LCAT+ -> drop nip first+
    )


||| Show the structure of the list.
trace-list-struc! : List(t) -- +IO
trace-list-struc! =
    match(
        L0 -> "L0" str-trace!,
        L1 -> drop "L1" str-trace!,
        L2 -> drop2 "L2" str-trace!,
        L3 -> drop3 "L3" str-trace!,
        LCAT ->
            dip2(List+->List trace-list-struc! " " str-trace!)
            dip(List+->List trace-list-struc! " " str-trace!)
            int-trace! " LCAT" str-trace!
    )

||| Reverse the list.
reverse : List(a) -- List(a)
reverse =
    match(
        L0 -> L0,
        L1 -> L1,
        L2 -> swap L2,
        L3 -> rotr swap L3,
        LCAT -> dip(reverse+ swap reverse+) LCAT
    )

||| Reverse the list.
reverse+ : List+(a) -- List+(a)
reverse+ =
    match(
        L1+ -> L1+,
        L2+ -> swap L2+,
        L3+ -> rotr swap L3+,
        LCAT+ -> dip(reverse+ swap reverse+) LCAT+
    )

||| Transform each element of the list.
map : *c List(a) [*c a -- *c b] -- *c List(b)
map = \( [f] ->
    match(
        L0 -> L0,
        L1 -> f L1,
        L2 -> dip(f) swap dip(f) swap L2,
        L3 -> dip(dip(f)) rotr dip(dip(f)) rotr dip(dip(f)) rotr L3,
        LCAT -> dip(dip(map+(f)) swap dip(map+(f)) swap) LCAT
    )
)

||| Transform each element of the list.
map+ : *c List+(a) [*c a -- *c b] -- *c List+(b)
map+ = \( [f] ->
    match(
        L1+ -> f L1+,
        L2+ -> dip(f) swap dip(f) swap L2+,
        L3+ -> dip(dip(f)) rotr dip(dip(f)) rotr dip(dip(f)) rotr L3+,
        LCAT+ -> dip(dip(map+(f)) swap dip(map+(f)) swap) LCAT+
    )
)

||| Traverse the list, left to right.
for : *c List(a) [*c a -- *c] -- *c
for = \([f] ->
    match(
        L0 -> id,
        L1 -> f,
        L2 -> dip(f) f,
        L3 -> dip(dip(f) f) f,
        LCAT -> drop dip(for+(f)) for+(f)
    )
)

||| Traverse the list, left to right.
for+ : *c List+(a) [*c a -- *c] -- *c
for+ = \([f] ->
    match(
        L1+ -> f,
        L2+ -> dip(f) f,
        L3+ -> dip(dip(f) f) f,
        LCAT+ -> drop dip(for+(f)) for+(f)
    )
)

||| Traverse the list, right to left.
reverse-for : *c List(a) [*c a -- *c] -- *c
reverse-for = \([f] ->
    match(
        L0 -> id,
        L1 -> f,
        L2 -> swap dip(f) f,
        L3 -> rotr dip2(f) swap dip(f) f,
        LCAT -> drop swap dip(reverse-for+(f)) reverse-for+(f)
    )
)

||| Traverse the list, right to left.
reverse-for+ : *c List+(a) [*c a -- *c] -- *c
reverse-for+ = \([f] ->
    match(
        L1+ -> f,
        L2+ -> swap dip(f) f,
        L3+ -> rotr dip2(f) swap dip(f) f,
        LCAT+ -> drop swap dip(reverse-for+(f)) reverse-for+(f)
    )
)

||| Reduce a list in a bottom-up manner.
reduce : List(a) [a a -- a] -- Maybe(a)
reduce = \([g] -> List->List+ maybe-map(reduce+(g)))

||| Reduce a list in a bottom-up manner.
reduce+ : List+(a) [a a -- a] -- a
reduce+ = \( [g] ->
    match(
        L1+ -> id,
        L2+ -> g,
        L3+ -> g g,
        LCAT+ -> drop dip(reduce+(g)) reduce+(g) g
    )
)

||| Reduce a list in a bottom-up manner, after mapping its elements.
map-reduce : List(a) [b b -- b] [a -- b] -- Maybe(b)
map-reduce = \([g] [f] -> map(f) reduce(g))

||| Reduce a list in a bottom-up manner, after mapping its elements.
map-reduce+ : List+(a) [b b -- b] [a -- b] -- b
map-reduce+ = \([g] [f] -> map+(f) reduce+(g))

||| Filter away any list elements that don't satisfy the predicate.
filter : *c List(a) [*c a -- *c a Bool] -- *c List(a)
filter = \([f] ->
    List->List+ match(
        NONE -> L0,
        SOME -> filter+(f)
    )
)

||| Filter away any list elements that don't satisfy the predicate.
filter+ : *c List+(a) [*c a -- *c a Bool] -- *c List(a)
filter+ = \([f] ->
    match(
        LCAT+ -> drop dip(filter+(f)) dip'(filter+(f)) cat,
        _ ->
            uncons dip(f) swap if(
                dip'(filter(f)) cons,
                nip filter(f)
            )
    )
)

||| Find the first element that satisfies the predicate, if it exists.
find : *c List(a) [*c a -- *c a Bool] -- *c Maybe(a)
find = \([f] ->
    List->List+ match(
        NONE -> NONE,
        SOME -> find+(f)
    )
)

||| Find the first element that satisfies the predicate, if it exists.
find+ : *c List+(a) [*c a -- *c a Bool] -- *c Maybe(a)
find+ = \([f] ->
    match(
        LCAT+ ->
            drop dip(find+(f)) swap
            match(
                SOME -> nip SOME,
                NONE -> find+(f)
            ),

        _ ->
            uncons dip(f) swap if(
                drop SOME,
                nip find(f)
            )
    )
)

||| Like `find` but preserves the list.
find? : *c List(a) [*c a -- *c a Bool] -- *c List(a) Maybe(a)
find? = over dip(find) swap

||| Like `find` but goes backward through the list.
reverse-find : *c List(a) [*c a -- *c a Bool] -- *c Maybe(a)
reverse-find = dip(reverse) find # TODO: implement directly?

||| Like `find?` but goes backward through the list.
reverse-find? : *c List(a) [*c a -- *c a Bool] -- *c List(a) Maybe(a)
reverse-find? = over dip(reverse-find) swap

||| Is the predicate true for any element of the list?
any : *c List(a) [*c a -- *c a Bool] -- *c Bool
any = find is-some

||| Is the predicate true for any element of the list?
any? : *c List(a) [*c a -- *c a Bool] -- *c List(a) Bool
any? = find? is-some

||| Is the predicate true for all elements of the list?
all : *c List(a) [*c a -- *c a Bool] -- *c Bool
all = find is-none not

||| Is the predicate true for all elements of the list?
all? : *c List(a) [*c a -- *c a Bool] -- *c List(a) Bool
all? = find? is-none not

#######
# BAG #
#######

||| A bag is a set where items can appear more than once.
||| Bags are represented by sorted lists, where the sorting
||| is done by the generic order relation on values (<=).
data Bag(v)
    BAG -> List(v)
end

unBAG : Bag(v) -- List(v)
unBAG = match(BAG -> id)

B0 : Bag(v)
B0 = nil

B1 : v -- Bag(v)
B1 = L1 BAG

B2 : v v -- Bag(v)
B2 = order2 L2 BAG

B3 : v v v -- Bag(v)
B3 = order3 L3 BAG


||| Same as `Bag(v)` but non-empty.
data Bag+(v)
    BAG+ -> List+(v)
end

unBAG+ : Bag+(v) -- List+(v)
unBAG+ = match(BAG+ -> id)

B1+ : v -- Bag+(v)
B1+ = L1+ BAG+

B2+ : v v -- Bag+(v)
B2+ = order2 L2+ BAG+

B3+ : v v v -- Bag+(v)
B3+ = order3 L3+ BAG+

Bag+->Bag : Bag+(v) -- Bag(v)
Bag+->Bag = unBAG+ List+->List BAG

Bag->Bag+ : Bag(v) -- Maybe(Bag+(v))
Bag->Bag+ = unBAG List->List+ maybe-map(BAG+)

bag-empty : Bag(v)
bag-empty = nil

bag-is-empty : Bag(v) -- Bool
bag-is-empty = is-nil

bag-is-empty? : Bag(v) -- Bag(v) Bool
bag-is-empty? = is-nil?

bag-singleton : v -- Bag(v)
bag-singleton = B1

bag-is-singleton : Bag(v) -- Bool
bag-is-singleton = bag-len 1 ==

bag-is-singleton+ : Bag+(v) -- Bool
bag-is-singleton+ = bag-len+ 1 ==

bag-len : Bag(v) -- Int
bag-len = unBAG len

bag-len? : Bag(v) -- Bag(v) Int
bag-len? = dup bag-len

bag-len+ : Bag+(v) -- Int
bag-len+ = unBAG+ len+

bag-len+? : Bag+(v) -- Bag+(v) Int
bag-len+? = dup bag-len+

bag-first : Bag(v) -- Maybe(v)
bag-first = unBAG first

bag-last : Bag(v) -- Maybe(v)
bag-last = unBAG last

bag-middle : Bag(v) -- Maybe(v)
bag-middle = unBAG middle

bag-first+ : Bag+(v) -- v
bag-first+ = unBAG+ first+

bag-last+ : Bag+(v) -- v
bag-last+ = unBAG+ last+

bag-middle+ : Bag+(v) -- v
bag-middle+ = unBAG+ middle+

bag-split-half-left : Bag+(v) -- Bag+(v) Bag(v)
bag-split-half-left = unBAG+ split-half-left dip(BAG+) BAG

bag-split-half-right : Bag+(v) -- Bag(v) Bag+(v)
bag-split-half-right = unBAG+ split-half-right dip(BAG) BAG+

bag-split-half : Bag(v) -- Bag(v) Bag(v)
bag-split-half = unBAG split-half dip(BAG) BAG

bag-uncons : Bag+(v) -- v Bag(v)
bag-uncons = unBAG+ uncons BAG

bag-unsnoc : Bag+(v) -- Bag(v) v
bag-unsnoc = unBAG+ unsnoc dip(BAG)

bag-cons : v Bag(v) -- Bag(v)
bag-cons = swap bag-insert

bag-snoc : Bag(v) v -- Bag(v)
bag-snoc = bag-insert

bag-cons+ : v Bag(v) -- Bag+(v)
bag-cons+ = swap bag-insert+

bag-snoc+ : Bag(v) v -- Bag+(v)
bag-snoc+ = bag-insert+

bag-cons++ : v Bag+(v) -- Bag+(v)
bag-cons++ = swap bag-insert++

bag-snoc++ : Bag+(v) v -- Bag+(v)
bag-snoc++ = bag-insert++

bag-has : Bag(v) v -- Bool
bag-has =
    swap Bag->Bag+ match(
        NONE -> drop false,
        SOME -> swap bag-has+
    )

bag-has+ : Bag+(v) v -- Bool
bag-has+ =
    over bag-is-singleton+ if(
        dip(bag-first+) ==,

        dip(bag-split-half-right)
        over bag-first+
        cmp? match(
            EQ -> drop4 true,
            LT -> drop nip bag-has,
            GT -> drop dip(nip) bag-has+
        )
    )

bag-has? : Bag(v) v -- Bag(v) v Bool
bag-has? = dup2 bag-has

||| Insert a value into the bag in the proper location.
||| Note that `bag-insert` will happily insert duplicates.
||| Use `bag-replace` to prevent duplicate insertion.
bag-insert : Bag(v) v -- Bag(v)
bag-insert = bag-insert+ Bag+->Bag

||| Same as `bag-insert` but returns a `Bag+`.
bag-insert+ : Bag(v) v -- Bag+(v)
bag-insert+ =
    swap Bag->Bag+ match(
        NONE -> B1+,
        SOME -> swap bag-insert++
    )

||| Same as `bag-insert` but takes and returns a `Bag+`.
bag-insert++ : Bag+(v) v -- Bag+(v)
bag-insert++ =
    over bag-is-singleton+ if(
        dip(bag-first+) B2+,

        dip(bag-split-half-right)
        over bag-first+
        dup2 >= if(
            drop bag-insert++ bag-cat-unsafe_+,
            drop swap dip(bag-insert+) bag-cat-unsafe+
        )
    )

||| Insert a value into the bag in the proper location,
||| unless the bag already contains this value. This
||| prevents introducing new duplicates. Use `bag-insert`
||| instead if duplicates are desirable.
bag-replace : Bag(v) v -- Bag(v)
bag-replace = bag-has? if(drop, bag-insert)

||| Concatenate two bags. To maintain the bag invariant,
||| it is necessary for the last item of the first bag
||| be less than or equal to the first item of the
||| second bag. In normal code it is recommended to
||| use `bag-merge` instead.
bag-cat-unsafe : Bag(v) Bag(v) -- Bag(v)
bag-cat-unsafe = dip(unBAG) unBAG cat BAG

bag-cat-unsafe_+ : Bag(v) Bag+(v) -- Bag+(v)
bag-cat-unsafe_+ = dip(unBAG) unBAG+ cat_+ BAG+

bag-cat-unsafe+ : Bag+(v) Bag+(v) -- Bag+(v)
bag-cat-unsafe+ = dip(unBAG+) unBAG+ cat+ BAG+

||| Put two stack items in order.
order2 : v v -- v v
order2 = dup2 <= if(id, swap)

||| Put three stack items in order.
order3 : v v v -- v v v
order3 = dip(order2) dup2 <= if(id, swap dip(order2))

||| Prerform lookup as an ordered map. Use the key to
||| find a corresponding item. Note: If multiple items
||| match the key, you may get any of them. There's
||| no guarantee it'll be the first item, last item,
||| middle item, etc, to match the key.
bag-lookup-key : Bag([v k]) k -- Maybe(v)
bag-lookup-key =
    swap Bag->Bag+ match(
        NONE -> drop NONE,
        SOME -> swap bag-lookup-key+
    )

||| Same as `bag-lookup-key` for non-empty bags.
bag-lookup-key+ : Bag+([v k]) k -- Maybe(v)
bag-lookup-key+ =
    over bag-is-singleton+ if(
        dip(bag-first+ unpack2) == if(SOME, drop NONE),

        dip(bag-split-half-right dup bag-first+ unpack2)
        cmp? match(
            EQ -> drop2 SOME dip(drop2),
            LT -> dip(drop2 nip) bag-lookup-key+,
            GT -> dip(drop3) bag-lookup-key
        )
    )

||| See `bag-lookup-key`.
bag-lookup-key? : Bag([v k]) k -- Bag([v k]) k Maybe(v)
bag-lookup-key? = dup2 bag-lookup-key


||| Insert key/value pair in bag, but replace an item
||| with a matching key if it exists.
bag-replace-key : Bag([v k]) [v k] -- Bag([v k])
bag-replace-key = bag-replace-key+ Bag+->Bag

||| Same as `bag-replace-key` but returns a `Bag+`.
bag-replace-key+ : Bag([v k]) [v k] -- Bag+([v k])
bag-replace-key+ =
    swap Bag->Bag+ match(
        NONE -> B1+,
        SOME -> swap bag-replace-key++
    )

||| Same as `bag-replace-key` but takes and returns a `Bag+`.
bag-replace-key++ : Bag+([v k]) [v k] -- Bag+([v k])
bag-replace-key++ =
    over bag-is-singleton+ if(
        dip(bag-first+) dup2 ==key if(
            nip B1+,
            B2+
        ),

        dip(bag-split-half-right dup bag-first+)
        dup2 <=key if(
            nip bag-replace-key++ bag-cat-unsafe_+,
            nip swap dip(bag-replace-key+) bag-cat-unsafe+
        )
    )

||| Compare two pairs by their top item (the "key").
==key : [v k] [v k] -- Bool
==key = dip(.0) .0 ==

||| Compare two pairs by their top item (the "key").
<=key : [v k] [v k] -- Bool
<=key = dip(.0) .0 <=

||| Get underlying list of values from bag.
bag-values : Bag(v) -- List(v)
bag-values = unBAG

||| Get underlying non-empty list of values from non-empty bag.
bag-values+ : Bag+(v) -- List+(v)
bag-values+ = unBAG+

#######
# SET #
#######

||| A set is a bag without duplicates. It's stored as
||| sorted list, where items are strictly increasing.
data Set(v)
    SET -> Bag(v)
end

#######
# MAP #
#######

||| A map associates keys with values. A single key
||| has at most one value it corresponds to. Maps are
||| represented as bags, but with the condition that
||| no two pairs share the same key.
data Map(k,v)
    MAP -> Bag([v k])
end

unMAP : Map(k,v) -- Bag([v k])
unMAP = match(MAP -> id)

map-empty : Map(k,v)
map-empty = nil

map-is-empty : Map(k,v) -- Bool
map-is-empty = is-nil

map-is-empty? : Map(k,v) -- Map(k,v) Bool
map-is-empty? = is-nil?

map-singleton : [v k] -- Map(k,v)
map-singleton = B1 MAP

map-is-singleton : Map(k,v) -- Bool
map-is-singleton = unMAP bag-is-singleton

map-has : Map(k,v) k -- Bool
map-has = map-lookup is-some

map-has? : Map(k,v) k -- Map(k,v) k Bool
map-has? = dup2 map-has

map-lookup : Map(k,v) k -- Maybe(v)
map-lookup = dip(unMAP) bag-lookup-key

map-lookup? : Map(k,v) k -- Map(k,v) k Maybe(v)
map-lookup? = dup2 map-lookup

map-insert : Map(k,v) [v k] -- Map(k,v)
map-insert = dip(unMAP) bag-replace-key MAP

map-cons : [v k] Map(k,v) -- Map(k,v)
map-cons = swap map-insert

map-snoc : Map(k,v) [v k] -- Map(k,v)
map-snoc = map-insert

map-pairs : Map(k,v) -- List([v k])
map-pairs = unMAP bag-values

map-keys : Map(k,v) -- List(k)
map-keys = map-pairs [.0] map

map-values : Map(k,v) -- List(v)
map-values = map-pairs [.1] map

######
# IO #
######

panic! : *a Str -- *b
panic! = "panic: " str-trace! str-trace-ln! 1 posix-exit!

data(File, FILE -> Int)

Int->File : Int -- File
Int->File = FILE

File->Int : File -- Int
File->Int = match(FILE -> id)

file@ : Ptr -- File
file@ = int@ Int->File

file! : File Ptr --
file! = dip(File->Int) int!

stdin : File
stdin = 0 Int->File

stdout : File
stdout = 1 Int->File

stderr : File
stderr = 2 Int->File

str-write! : Str File -- +IO
str-write! = (
    File->Int swap dup str-length dup
    dip(dip(Str->Ptr) posix-write!) swap
    dup 0 < if(
        "error: write failed!" panic!,
        swap < if(
            "error: write output fewer bytes than expected!" panic!,
            id
        )
    )
)

str-print! : Str -- +IO
str-print! = stdout str-write!

str-trace! : Str -- +IO
str-trace! = stderr str-write!

str-print-ln! : Str -- +IO
str-print-ln! = str-print! print-ln!

str-trace-ln! : Str -- +IO
str-trace-ln! = str-trace! trace-ln!

print-ln! : +IO
print-ln! = "\n" str-print!

trace-ln! : +IO
trace-ln! = "\n" str-trace!

str-buf-write! : File -- +StrBuf +IO
str-buf-write! = (
    File->Int STR_BUF str-buf-length?
    posix-write!
    dup 0 < if(
        "error: str-buf write failed!" panic!,
        str-buf-length? < if(
            "error: str-buf write wrote fewer bytes than expected!" panic!,
            id
        )
    )
)

str-buf-print! : +StrBuf +IO
str-buf-print! = stdout str-buf-write!

str-buf-trace! : +StrBuf +IO
str-buf-trace! = stderr str-buf-write!

str-buf-read! : File -- +IO
str-buf-read! = (
    File->Int str-buf-clear!
    STR_BUF STR_BUF_SIZE 1- posix-read!
    dup 0< if(
        "str-buf-read! failed" panic!,
        str-buf-length!
    )
)

str-buf-input! : -- +IO
str-buf-input! = stdin str-buf-read!

data TransducerStep
    TS_STOP
    TS_SKIP
    TS_CHAR -> Char
    TS_PUSH -> List(Char)
end

str-transduce : *a Str [ *a Char -- *a TransducerStep ] -- *a Str
str-transduce = \([f] ->
    build-str!(
        while(str-is-empty? not,
            dup dip(str-head f) str-tail
            swap match(
                TS_STOP -> drop "",
                TS_SKIP -> id,
                TS_CHAR -> str-buf-push!,
                TS_PUSH -> for(str-buf-push!)
            )
        ) drop
    )
)

print-char! : Char -- +IO
print-char! = build-str!(str-buf-push!) str-print!

trace-char! : Char -- +IO
trace-char! = build-str!(str-buf-push!) str-trace!

int-write! : Int File -- +IO
int-write! = dip(str-buf-int!) str-buf-write!

int-print! : Int -- +IO
int-print! = stdout int-write!

int-trace! : Int -- +IO
int-trace! = stderr int-write!

int-print-ln! : Int -- +IO
int-print-ln! = int-print! print-ln!

int-trace-ln! : Int -- +IO
int-trace-ln! = int-trace! trace-ln!

open-file! : Str -- File +IO
open-file! = (
    0 0 posix-open!
    dup 0 < if(
        "Failed to open file!" panic!,
        Int->File
    )
)

create-file! : Str -- File +IO
create-file! = (
    O_WRONLY|O_CREAT|O_TRUNC
    0x1B6
        # this is the default mode for creating a file
        # on unix, 666 in octal, i.e. owner can
        # read+write, everyone can read
        #  ---- NB: this is inaccurate . . .
    posix-open!
    dup 0 < if(
        "Failed to create file!" panic!,
        Int->File
    )
)

O_WRONLY|O_CREAT|O_TRUNC : Int
O_WRONLY|O_CREAT|O_TRUNC =
    RUNNING_OS match(
        OS_MACOS -> 0x601, # O_WRONLY = 0x1, O_CREAT = 0x200, O_TRUNC = 0x400
        OS_LINUX -> 0x241, # O_WRONLY = 0x1, O_CREAT = 0x40, O_TRUNC = 0x200
        OS_WINDOWS -> 0x301, # O_WRONLY = 0x1, O_CREAT|O_TRUNC = 0x300
        OS_UNKNOWN -> "O_WRONLY|O_CREAT|O_TRUNC on unknown os" panic!
    )


close-file! : File -- +IO
close-file! = (
    File->Int posix-close!
    0 < if(
        "failed to close file." panic!,
        id
    )
)

########
# Heap #
########

buffer(HEAP_LENGTH, 8)

heap-length@ : Size
heap-length@ = HEAP_LENGTH int@

heap-length! : Size --
heap-length! = HEAP_LENGTH int!

buffer(HEAP_BASE, 8)

heap-base@ : Ptr
heap-base@ = HEAP_BASE ptr@

heap-base! : Ptr --
heap-base! = HEAP_BASE ptr!

buffer(HEAP_TIMES_EXPANDED, 8)

heap-times-expanded@ : Int
heap-times-expanded@ = HEAP_TIMES_EXPANDED int@

heap-times-expanded! : Int --
heap-times-expanded! = HEAP_TIMES_EXPANDED int!

++heap-times-expanded : Int
++heap-times-expanded =
    heap-times-expanded@ 1+ dup heap-times-expanded!

||| Ensure that at at least X space on the heap is available.
|||
||| If the space left is too small (or heap has not been allocated,
||| in which the space left is 0), then it tries to make the heap
||| larger in place. This usually works, but if it fails, we just
||| allocate a new buffer and forget about the old one, leaking
||| some memory and introducing fragmentation.
|||
||| Panics if reservation is impossible.
heap-reserve! : Size --
heap-reserve! =
    dup heap-length@ <= if(
        drop,

        heap-new-size dup # size
        heap-length@ heap-base@ ptr+ swap # pointer hint
        PROT_READ|PROT_WRITE
        MAP_ANON|MAP_PRIVATE
        -1 # file descriptor (-1 for MAP_ANONYMOUS)
        0 # offset
        posix-mmap!
        dup Ptr->Int nonzero if(
            dup heap-length@ heap-base@ ptr+ == if(
                drop heap-length@ + heap-length!,
                heap-base! heap-length!
            ),
            "Failed to allocate heap buffer." panic!
        )
    )

PROT_READ|PROT_WRITE : Int
PROT_READ|PROT_WRITE = 0x3
    # PROT_READ = 0x1, PROT_WRITE = 0x2

MAP_ANON|MAP_PRIVATE : Int
MAP_ANON|MAP_PRIVATE =
    RUNNING_OS match(
        OS_MACOS ->
            0x1002, # MAP_ANON = 0x1000, MAP_PRIVATE = 0x2
        _ ->
            drop 0x22, # MAP_ANON = 0x20, MAP_PRIVATE = 0x2
    )

||| Aligns a by b, rounding upward. For instance,
|||
|||   10 64 align == 64
|||   64 64 align == 64
|||   70 64 align == 128
align : Size Size -- Size
align = dup dip(1- + dup) % -

||| Figure out how much to expand heap size by, based on a minimum size
||| (i.e. requested size aligned to 4096).
||| The expansion has a quadratic lower bound.
heap-new-size : Size -- Size
heap-new-size = (
    4096 align
    4096 ++heap-times-expanded square *
    max
)

||| Allocate a buffer on the heap.
heap-alloc! : Size -- Ptr +Heap
heap-alloc! = (
    64 align
    dup heap-reserve!
    dup heap-length@ swap - heap-length!
    heap-base@ dup dip(swap) ptr+ heap-base!
)
