module(words)
import(prelude)
import(names)
import(types)

def(init-words!, --,
    0 NUM_WORDS !)

#########
# WORDS #
#########

def-type(Word, U16)
def(Word->Int, Word -- Int, U16->Int)
def(Int->Word, Int -- Word, Int->U16)

def(MAX_WORDS, Size, 0x4000)
quad def-static-buffer(NUM_WORDS)
def(word-alloc!, Word +Words,
    NUM_WORDS @ dup 1+ NUM_WORDS !
    dup MAX_WORDS >= if(
        "compiler error: NUM_WORDS > MAX_WORDS" panic!,
        id
    )
    0 over word-name!
    0 over word-sig!
    0 over word-body!
    0 over word-status!
    ctx-empty over word-ctx!
    TYPE_ERROR over word-type!)

def(WORD_METADATA_SIZE, Size, 32)
MAX_WORDS WORD_METADATA_SIZE * def-static-buffer(WORD_METADATA_BUF)
def(word-metadata&, Word -- Ptr, Word->Int WORD_METADATA_SIZE * WORD_METADATA_BUF +)

def(word-name&, Word -- Ptr, word-metadata&)
def(word-name@, Word -- Name, word-name& u32@ U32->Name)
def(word-name!, Name Word --, dip(Name->U32) word-name& u32!)

def(word-sig&, Word -- Ptr, word-metadata& 4 +)
def(word-sig@, Word -- Token, word-sig& u32@ U32->Int Int->Token)
def(word-sig!, Token Word --, dip(Token->Int Int->U32) word-sig& u32!)

def(word-body&, Word -- Ptr, word-metadata& 8 +)
def(word-body@, Word -- Token, word-body& u32@ U32->Int Int->Token)
def(word-body!, Token Word --, dip(Token->Int Int->U32) word-body& u32!)

def-type(WordStatus, U8)
def(word-status&, Word -- Ptr, word-metadata& 12 +)
def(word-status@, Word -- WordStatus, word-status& u8@)
def(word-status!, WordStatus Word --, word-status& u8!)

# 1 byte unused

def(word-ctx&, Word -- Ptr, word-metadata& 14 +)
def(word-ctx@, Word -- Ctx, word-ctx& u16@)
def(word-ctx!, Ctx Word --, word-ctx& u16!)

def(word-type&, Word -- Ptr, word-metadata& 16 +)
def(word-type@, Word -- Type, word-type& u32@)
def(word-type!, Type Word --, word-type& u32!)

# 4 bytes unused

def(word-morphism&, Word -- Ptr, word-metadata& 24 +)
def(word-morphism@, Word -- Morphism, word-morphism& u64@)
def(word-morphism!, Morphism Word --, word-morphism& u64!)

# def(word-core&, Word -- Ptr, word-metadata& 24 +)
# def(word-core@, Word -- Core, word-core& u64@)
# def(word-core!, Core Word --, word-core& u64!)

def(word-sig-is-checked?, Word -- Word Bool,
    dup word-status@ U8->Int 1 &)
def(word-sig-is-checked!, Word --,
    dup dip(word-status@ U8->Int 1 | Int->U8) word-status!)

def(word-body-is-checked?, Word -- Word Bool,
    dup word-status@ U8->Int 2 & if(1, 0))
def(word-body-is-checked!, Word --,
    dup dip(word-status@ U8->Int 2 | Int->U8) word-status!)

def(word-dom@, Word -- Type,
    word-type@ type-get-morphism morphism-type-dom@)

def(word-cod@, Word -- Type,
    word-type@ type-get-morphism morphism-type-cod@)

#############
# MORPHISMS #
#############

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation, but, to reduce indirection,
# we represent it as a flat sequence.

def-type(Morphism, U64)
def(Morphism->Int, U64 -- Int, U64->Int)
def(Int->Morphism, Int -- U64, Int->U64)

def(MOPRHISM_ERROR, Morphism, 0 Int->Morphism)

