module mirth.macro

import std.prelude
import std.maybe
import mirth.mirth
import mirth.name
import mirth.token
import mirth.name
import mirth.elab
import mirth.def
import mirth.alias

table(Macro)
field(Macro.~name, Macro, Name)
field(Macro.~qname, Macro, Prop(QName))
field(Macro.~arity, Macro, Int)
field(Macro.~head, Macro, Token)
field(Macro.~action, Macro, MacroAction)

def Macro.name       [ +Mirth |- Macro -- Name ] { ~name @ }
def Macro.qname-hard [ +Mirth |- Macro -- QName ] { ~qname force! }
def Macro.qname-soft [ +Mirth |- Macro -- Maybe(QName) ] { ~qname @? bind(ready?) }
def Macro.arity      [ +Mirth |- Macro -- Int ] { ~arity @ }
def Macro.head?      [ +Mirth |- Macro -- Maybe(Token) ] { ~head @? }
def Macro.action     [ +Mirth |- Macro -- MacroAction ] { ~action @ }

def Macro.>Int [ Macro -- Int ] { index >Int }
def Macro.= [ Macro Macro -- Bool ] { on2:>Int = }

data MacroAction {
    Decl  [[ +World +Mirth Token -- +World +Mirth Token ]]
    Arrow [[        +Mirth +AB   -- +Mirth +AB          ]]
    --
    def decl?  { Decl -> Some, _ -> drop None }
    def arrow? { Arrow -> Some, _ -> drop None }
    def callable? { arrow? >Bool }
}

def Macro.Prim [ +Mirth |- Str Int MacroAction -- Macro ] {
    Macro.alloc! >macro
    @macro ~action !
    over >Name @macro ~name !
    dup  @macro ~arity !
    QName.Prim @macro PropLabel.MacroQName prop @macro ~qname !
    macro>
}

def module-statement-error! [ +Mirth Token |- ] {
    "'module' statement outside of module header." emit-fatal-error!
}
def import-statement-error! [ +Mirth Token |- ] {
    "'import' statement outside of module header." emit-fatal-error!
}

def prim-decl-macro! { MacroAction.Decl  Macro.Prim Def.Macro register }
def prim-word-macro! { MacroAction.Arrow Macro.Prim Def.Macro register }

def +Mirth.init-macros! [ +Mirth |- ] {
    "module"             -1 [ module-statement-error!  ] prim-decl-macro!
    "import"             -1 [ import-statement-error!  ] prim-decl-macro!
    "patch"              -1 [ elab-patch!              ] prim-decl-macro!
    "alias"              -1 [ elab-alias!              ] prim-decl-macro!
    "inline"             -1 [ elab-inline!             ] prim-decl-macro!
    "def"                -1 [ elab-def!                ] prim-decl-macro!
    "def-missing"        -1 [ elab-def-missing!        ] prim-decl-macro!
    "def-type"           -1 [ elab-def-type!           ] prim-decl-macro!
    "external"           -1 [ elab-external!           ] prim-decl-macro!
    "buffer"             -1 [ elab-buffer!             ] prim-decl-macro!
    "table"              -1 [ elab-table!              ] prim-decl-macro!
    "field"              -1 [ elab-field!              ] prim-decl-macro!
    "data"               -1 [ elab-data!               ] prim-decl-macro!
    "struct"             -1 [ elab-struct!             ] prim-decl-macro!
    "embed-str"          -1 [ elab-embed-str!          ] prim-decl-macro!
    "max-mirth-revision" -1 [ elab-max-mirth-revision! ] prim-decl-macro!
    "min-mirth-revision" -1 [ elab-min-mirth-revision! ] prim-decl-macro!

    "match" -1 [ elab-atom-match!    ] prim-word-macro!
    "\\"    -1 [ elab-atom-lambda!   ] prim-word-macro!
    "ldip"  -1 [ elab-ldip!          ] prim-word-macro!
}
