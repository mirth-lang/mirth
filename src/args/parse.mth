module(args.parse)

import(prelude)
import(data.str)
import(data.list)
import(data.maybe)
import(data.either)
import(data.byte)

import(resource.buffer)

import(platform.posix)

import(args.types)

||| Print an autogenerated usage message for the parser
def(print-usage, +ArgumentParser -- +ArgumentParser,
  "Usage:" print-ln!
  LIST("  " ; rdip(state ~program-name @) ; " [options] "; rdip(argument-parser ~args-doc @ unwrap-or("")) ;) for(print!) "" print-ln!

  "" print-ln!

  argument-parser ~options @ match(
  SOME ->
  for(
    LIST("  " ;
    dup ~type @ match( 
      OPTION_SHORT -> dup is-printable then("-" ; dup to-str-unsafe ;) drop,
      _ -> drop
    )

    # If we have both a short and long version of the argument we separate them
    dup ~type @ has-short? and(dup ~long @ some?) if(
      ", " ;,
      "  " ;,
    )
    dup ~long @ match(
      SOME -> "--"; ; dup ~arg @ match (
        SOME -> "="; ;,
	NONE ->
      ),
      NONE ->
    )
    dup ~doc @ match(
      SOME -> "\t"; ;,
      NONE ->
    )
    ) for(print!) "" print-ln!
    drop
  ),
  NONE ->
  )
  "" print-ln!
)

||| Check if the currently parsed argument is something we accept
def(check-short-option, +ArgumentParser ArgpOption Str -- +ArgumentParser ArgpOption Bool,
  over ~type @ match(
    OPTION_SHORT -> 0 >Offset rotl str-byte@ =,
    _ -> drop drop F
  )
)

||| Parse a short cli flag, possibly with a argument value
def(parse-short-flags, +ArgumentParser Str -- +ArgumentParser Maybe(ArgumentParsingError),
  argument-parser ~options @ match(
    SOME -> find(over check-short-option) swap drop match(
      SOME -> dup ~arg @ match(
        SOME -> 
	  state ~currently-parsing-option T swap !
	  drop SOME state ~current-option-option !,
	NONE -> ~type @ state ~arguments @ swap NONE swap parser match(
	  SOME -> run state ~arguments ! ,
	  NONE -> drop drop drop
	) 
      ) NONE,
      NONE -> UNKNOWN_ARG SOME
    ),
    NONE -> drop UNKNOWN_ARG SOME
  )
)

||| Check if the currently parsed argument is something we accept 
def(check-long-option, +ArgumentParser ArgpOption Str -- +ArgumentParser ArgpOption Bool,
  over ~long @ match(
    SOME -> =,
    NONE -> drop F 
  )
)

||| Parse a long flag, possibly with an argument value
def(parse-long-flag, +ArgumentParser Str -- +ArgumentParser Maybe(ArgumentParsingError), 
  argument-parser ~options @ match(
    SOME -> find(over check-long-option) swap drop match(
      SOME -> dup ~arg @ match(
        SOME -> 
	  state ~currently-parsing-option T swap !
	  drop SOME state ~current-option-option !,
	NONE -> ~type @ state ~arguments @ swap NONE swap parser match(
	  SOME -> run state ~arguments ! ,
	  NONE -> drop drop drop
	) 
      ) NONE,
      NONE -> UNKNOWN_ARG SOME
    ),
    NONE -> drop UNKNOWN_ARG SOME
  ) 
)

||| Parse either a short or long flag
def(parse-flags, +ArgumentParser Str -- +ArgumentParser Maybe(ArgumentParsingError),
  dup num-bytes 2 >Size >= and(1 >Offset over str-byte@ B'-' =) if(
    2 dip(dup dup num-bytes >Int) unsafe(unsafe-unchecked-str-substr) parse-long-flag,
    1 dip(dup dup num-bytes >Int) unsafe(unsafe-unchecked-str-substr) parse-short-flags
  ) swap drop ,
)

||| Parse a positional argument, advancing the current index
def(do-positional-option, +ArgumentParser Str -- +ArgumentParser Maybe(ArgumentParsingError),
  state ~arguments @ swap SOME OPTION_POSITIONAL parser unwrap run
  state ~arguments ! NONE
  state ~current-positional-arg modify(1+)
)

||| Run the argument parser
def(parse-args, a ArgumentParser -- Either(a,ArgumentParsingError),
  swap ArgumentParserState.init +ARGUMENTPARSER
  state ~argv @ for(
    dup num-bytes 1 >Size > if(
      0 >Offset over str-byte@ B'-' = if(
        # if in the middle of currently parsing an option when we shouldn't be,
	# turn it off, otherwise error because need an option value
        state ~currently-parsing-option @ if(
	  drop state ~current-option-option @ match(
            SOME -> ~arg @ match (
	      SOME -> drop MISSING_ARGUMENT_VALUE SOME,
	      NONE -> F state ~currently-parsing-option ! NONE
	    ),
	    NONE -> MISSING_ARGUMENT_VALUE SOME
	  ),
	  parse-flags
	),
	# Parse the associated value for an option
	state ~currently-parsing-option @ if(
	  state ~current-option-option @ match(
	    SOME -> ~arg @ match(
	      SOME -> drop state ~arguments @ swap SOME state ~current-option-option @ unwrap ~type @ parser unwrap run state ~arguments ! NONE,
	      NONE -> drop UNKNOWN_ARG SOME
	    ),
	    NONE -> drop UNKNOWN_ARG SOME
	  ) F state ~currently-parsing-option !,
          do-positional-option
	)
      ),
      drop NONE
    ) match(
      SOME -> SOME state ~current-error !,
      NONE ->
    )
  ) 

  # Check if we are still waiting for an associated value for an option
  state ~currently-parsing-option @ then(
    MISSING_ARGUMENT_VALUE SOME state ~current-error !
  )

  # Run the callback function one last time to let it clean up
  # and run final checks
  state ~arguments modify(NONE OPTION_END parser unwrap run)

  state ~arguments @ state ~current-error @
  match(
    SOME -> RIGHT swap drop print-usage,
    NONE -> LEFT 
  )
  rdrop
)

def(read-from-argv, +Unsafe Int -- Str +Unsafe, 
    Ptr.sizeof >Int * >Size >Offset argv offset @Ptr str-copy-cstr
)

def(argv-to-str, -- List(Str), 
  LIST(
  1 while(argc over >,
    dup unsafe(read-from-argv) ;
    1+ 
  ) drop
  )
)

||| Very unsafe substr that doesn't check if the indices are inside the string
def(unsafe-unchecked-str-substr, +Unsafe Str Int Int -- Str +Unsafe,
  dip2(dup num-bytes +Buffer.new 0 >Offset !Str)
  swap over - >Size swap >Offset swap +Buffer@Str rdrop
)
