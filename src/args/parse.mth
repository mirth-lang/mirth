module(args.parse)

import(prelude)
import(data.str)
import(data.list)
import(data.maybe)
import(data.either)
import(data.byte)

import(resource.buffer)

import(platform.posix)

import(args.types)
import(args.state)

||| Print an autogenerated usage message for the parser
def(print-usage, +ArgumentParser(a) -- +ArgumentParser(a),
  "Usage:" print-ln!

  "  " print!
  state program-name  print! 
  " [options] " print! 
  argument-parser args-doc  for(print!)
  "" print-ln!

  "" print-ln!

  argument-parser options for(print-usage-for-option) 
  "" print-ln!
)

def(print-usage-for-option, ArgpOption --,
  "  " print!
  dup ~type @ match( 
    OPTION_SHORT -> dup is-printable then("-" print! dup to-str-unsafe print!) drop,
    _ -> drop
  )

  # If we have both a short and long version of the argument we separate them
  dup ~type @ has-short? and(dup ~long @ some?) if(
    ", " ,
    "  " 
  ) print!

  dup ~long @ match(
    SOME -> "--" print! print! dup ~arg @ match (
      SOME -> "=" print! print!,
      NONE ->
    ),
    NONE ->
  )
  dup ~doc @ match(
    SOME -> "\t" print! print!,
    NONE ->
  ) 

  "" print-ln!
  drop
)

||| Check if the currently parsed argument is something we accept
def(check-short-flag, +ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool,
  over ~type @ match(
    OPTION_SHORT -> 0 >Offset rotl str-byte@ =,
    _ -> drop drop F
  )
)

||| Parse a short cli flag, possibly with a argument value
def(parse-flags-where(f), (+ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool) +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
  argument-parser options
  find(over f) swap drop match(
    SOME -> dup ~arg @ match(
      SOME -> 
	T state currently-parsing-option! state!
	drop SOME state current-option-option! state!,
      NONE -> ~type @ state arguments swap NONE swap parser match(
	SOME -> run state arguments! state! ,
	NONE -> drop drop drop
      ) 
    ) NONE,
    NONE -> UNKNOWN_ARG SOME
  ) 
)

||| Check if the currently parsed argument is something we accept 
def(check-long-flag, +ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool,
  over ~long @ match(
    SOME -> =,
    NONE -> drop F 
  )
)

||| Parse either a short or long flag
def(parse-flags, +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
  dup num-bytes 2 >Size >= and(1 >Offset over str-byte@ B'-' =) if(
    2 >Size over unsafe(drop-bytes) parse-flags-where(check-long-flag),
    1 >Size over unsafe(drop-bytes) parse-flags-where(check-short-flag)
  ) swap drop ,
)

||| Parse a positional argument, advancing the current index
def(do-positional-option, +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
  state arguments swap SOME OPTION_POSITIONAL parser unwrap run
  state arguments! state! NONE
  state current-positional-arg 1+ state current-positional-arg! state!
)

||| Run the argument parser
def(parse-args, a ArgumentParser(a) -- Either(ArgumentParsingError, a),
  swap ArgumentParserState.init +ARGUMENTPARSER
  state ArgumentParserState.argv for(
    dup num-bytes 1 >Size > if(
      0 >Offset over str-byte@ B'-' = if(
        # if in the middle of currently parsing an option when we shouldn't be,
	# turn it off, otherwise error because need an option value
        state currently-parsing-option if(
	  drop state current-option-option match(
            SOME -> ~arg @ match (
	      SOME -> drop MISSING_ARGUMENT_VALUE SOME,
	      NONE -> F state currently-parsing-option! state! NONE
	    ),
	    NONE -> MISSING_ARGUMENT_VALUE SOME
	  ),
	  parse-flags
	),
	# Parse the associated value for an option
	state currently-parsing-option if(
	  state current-option-option match(
	    SOME -> ~arg @ match(
	      SOME -> drop state arguments swap SOME state current-option-option unwrap ~type @ parser unwrap run state arguments! state! NONE,
	      NONE -> drop UNKNOWN_ARG SOME
	    ),
	    NONE -> drop UNKNOWN_ARG SOME
	  ) F state currently-parsing-option! state!,
          do-positional-option
	)
      ),
      drop NONE
    ) match(
      SOME -> SOME state current-error! state!,
      NONE ->
    )
  ) 

  # Check if we are still waiting for an associated value for an option
  state currently-parsing-option then(
    MISSING_ARGUMENT_VALUE SOME state current-error! state!
  )

  # Run the callback function one last time to let it clean up
  # and run final checks
  state arguments NONE OPTION_END parser unwrap run state arguments! state!

  state arguments state current-error
  match(
    SOME -> LEFT swap drop print-usage,
    NONE -> RIGHT
  )
  rdrop
)

def(read-from-argv, +Unsafe Int -- Str +Unsafe, 
    Ptr.sizeof >Int * >Size >Offset argv offset @Ptr str-copy-cstr
)

def(argv-to-str, -- List(Str), 
  LIST(
  1 while(argc over >,
    dup unsafe(read-from-argv) ;
    1+ 
  ) drop
  )
)
