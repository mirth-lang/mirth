module(args.parse)

import(std.prelude)
import(std.str)
import(std.list)
import(std.maybe)
import(std.either)
import(std.byte)
import(std.buffer)
import(posix.posix)
import(args.types)
import(args.state)

import(ansi.ansi)

||| Print an autogenerated usage message for the parser
def(print-usage, +ArgumentParser(a) -- +ArgumentParser(a),
  Str(Bold show ; "Usage:" ; Reset show ;) print-ln!

  "  " print!
  state program-name print!
  " [options] " print!
  argument-parser args-doc for(print!)
  "" print-ln!

  "" print-ln!

  argument-parser options for(print-usage-for-option)
  "" print-ln!
)

def(print-usage-for-option, +ArgumentParser(a) ArgpOption -- +ArgumentParser(a),
  "  " print!


  0 >col-offset
  dup flag-type match(
    SHORT -> dup is-printable then(
        col-offset> 2 + >col-offset
        "-" print! dup to-str-unsafe print!,
    ) drop,
    _ -> drop 
  )

  # If we have both a short and long version of the argument we separate them
  dup flag-type has-short? and(dup name some?) then(
    ", " print!
    col-offset> 2 + >col-offset
  )

  dup name then-some( 
    "--" print! 

    dup num-bytes >Int col-offset> 2 + + >col-offset

    print! 

    dup arg-doc then-some(
      " " print! 

      dup num-bytes >Int col-offset> 1 + + >col-offset
      print!
    )
  )

  dup doc then-some(
    col-offset> dup >col-offset state longest-arg-length dup2 < if(
      swap - 0 swap range for(drop " " print!),
      drop2
    )
    "    " print! print!
  ) col-offset> drop

  "" print-ln!
  drop
)

||| Check if the currently parsed argument is something we accept
def(check-short-flag, +ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool,
    over flag-type match(
        SHORT -> 0 >Offset rotl byte@ ==,
        _ -> drop drop F
    ))

||| Parse a short cli flag, possibly with a argument value
def(parse-flags-where(f), (+ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool)
  +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
  argument-parser options
  find(over f) swap drop match(
    SOME -> dup arg-doc match(
      SOME ->
	T state parsing?! state!
	drop SOME state option-option! state!,
      NONE -> flag-type state arguments swap NONE swap parser match(
	SOME -> run state arguments! state! ,
	NONE -> drop drop drop
      )
    ) NONE,
    NONE -> UNKNOWN_ARG SOME
  )
)

||| Check if the currently parsed argument is something we accept
def(check-long-flag, +ArgumentParser(a) ArgpOption Str -- +ArgumentParser(a) ArgpOption Bool,
    over name match(
        SOME -> ==,
        NONE -> drop F
    ))

||| Parse either a short or long flag
def(parse-flags, +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
    dup num-bytes 2 >Size >= and(1 >Offset over byte@ B'-' ==) if(
        2 >Size over unsafe(drop-bytes) parse-flags-where(check-long-flag),
        1 >Size over unsafe(drop-bytes) parse-flags-where(check-short-flag)
    ) swap drop)

||| Parse a positional argument, advancing the current index
def(do-positional-option, +ArgumentParser(a) Str -- +ArgumentParser(a) Maybe(ArgumentParsingError),
    state arguments swap SOME POSITIONAL parser unwrap run
    state arguments! state! NONE
    state positional-index 1+ state positional-index! state!)

||| Run the argument parser
def(parse-args, a ArgumentParser(a) -- Either(ArgumentParsingError, a),
  >argument-parser State.init >state +ARGUMENTPARSER
  argument-parser options for(
    0 >doc-length

    dup flag-type match(
      SHORT -> drop doc-length> 2 + >doc-length,
      _ -> drop
    )

    dup name then-some(num-bytes >Int doc-length> 3 + + >doc-length)
    arg-doc then-some(num-bytes >Int doc-length> 2 + + >doc-length)

     
    doc-length> dup state longest-arg-length > if(
      state:longest-arg-length!,
      drop
    )
  )

  state State.argv for(
    dup num-bytes 1 >Size > if(
      0 >Offset over byte@ B'-' == if(
        # if in the middle of currently parsing an option when we shouldn't be,
	# turn it off, otherwise error because need an option value
        state parsing? if(
	  drop state option-option match(
            SOME -> arg-doc match (
	      SOME -> drop MISSING_ARGUMENT_VALUE SOME,
	      NONE -> F state parsing?! state! NONE
	    ),
	    NONE -> MISSING_ARGUMENT_VALUE SOME
	  ),
	  parse-flags
	),
	# Parse the associated value for an option
	state parsing? if(
	  state option-option match(
	    SOME -> arg-doc match(
	      SOME -> drop state arguments swap SOME state option-option unwrap flag-type parser unwrap run state:arguments! NONE,
	      NONE -> drop UNKNOWN_ARG SOME
	    ),
	    NONE -> drop UNKNOWN_ARG SOME
	  ) F state:parsing?!,
          do-positional-option
	)
      ),
      drop NONE
    ) then-some(
      SOME state:error!,
    )
  )

  # Check if we are still waiting for an associated value for an option
  state parsing? then(
    MISSING_ARGUMENT_VALUE SOME state error! state!
  )

  # Run the callback function one last time to let it clean up
  # and run final checks
  state arguments NONE END parser unwrap run state:arguments!

  state arguments state error
  match(
    SOME -> LEFT swap drop print-usage,
    NONE -> RIGHT
  )
  rdrop
)

def(read-from-argv, +Unsafe Int -- Str +Unsafe,
    Ptr.sizeof >Int * >Size >Offset argv offset @Ptr Str.copy-cstr
)

def(increment-index, index:Int -- index:Int,
  index> 1+ >index)

def(index, index:Int -- Int index:Int,
  index> dup >index)

def(argv-to-str, -- List(Str),
    LIST(
        1 >index
        while(argc index >,
            index unsafe(read-from-argv) ;
	    increment-index
        )
	index> drop
    ))
