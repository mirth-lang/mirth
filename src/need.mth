module mirth.need

import std.prelude
import std.list
import std.maybe
import std.set
import mirth.mirth
import mirth.prim
import mirth.arrow
import mirth.word
import mirth.data
import mirth.match

########
# NEED #
########

data(Need,
    NEED_WORD  -> Word,
    NEED_BLOCK -> Block,
    NEED_TAGW  -> Tag,
    NEED_TAGP  -> Tag)

def Need.>Nat [ Need -- Nat ] {
    { NEED_WORD  -> index 4 *     >Nat-clamp }
    { NEED_BLOCK -> index 4 * 1 + >Nat-clamp }
    { NEED_TAGW  -> index 4 * 2 + >Nat-clamp }
    { NEED_TAGP  -> index 4 * 3 + >Nat-clamp }
}

#########
# NEEDS #
#########

data(+Needs, +Needs ->
    stack: List(Need)
    +set: +Set)

def(+Needs.new, -- +Needs, List.Nil >stack +Set.Empty >+set +Needs)
def(+Needs.rdrop, +Needs --, /+Needs +set> rdrop stack> drop)

def(Need.needed?, Need +Needs -- Bool +Needs, >Nat +set:member?)
def(Word.needed?, Word +Needs -- Bool +Needs, Need.NEED_WORD needed?)
def(Block.needed?, Block +Needs -- Bool +Needs, Need.NEED_BLOCK needed?)
def(Tag.word-needed?, Tag +Needs -- Bool +Needs, Need.NEED_TAGW needed?)
def(Tag.pat-needed?, Tag +Needs -- Bool +Needs, Need.NEED_TAGP needed?)

def(+Needs.need!, Need +Needs -- +Needs,
    dup needed? if(
        drop,
        dup >Nat +set:insert! stack:List.Cons
    ))
def(+Needs.need-word!, Word +Needs -- +Needs, Need.NEED_WORD need!)
def(+Needs.need-block!, Block +Needs -- +Needs, Need.NEED_BLOCK need!)
def(+Needs.need-tag-word!, Tag +Needs -- +Needs, Need.NEED_TAGW need!)
def(+Needs.need-tag-pat!, Tag +Needs -- +Needs, Need.NEED_TAGP need!)

def(+Needs.determine-arrow-needs!, Arrow +Mirth +Needs -- +Mirth +Needs,
    run-arrow! determine-transitive-needs!)
def(+Needs.determine-transitive-needs!, +Mirth +Needs -- +Mirth +Needs,
    while-some(stack:uncons, run-need!))

def(+Needs.run-need!, Need +Mirth +Needs -- +Mirth +Needs,
    NEED_BLOCK -> run-block!,
    NEED_WORD -> run-word!,
    NEED_TAGW -> drop,
    NEED_TAGP -> drop)

def(+Needs.run-args!, List(Arg) +Mirth +Needs -- +Mirth +Needs, for(run-arg!))
def(+Needs.run-arg!, Arg +Mirth +Needs -- +Mirth +Needs, Block -> run-block!)
def(+Needs.run-block!, Block +Mirth +Needs -- +Mirth +Needs, rdip:arrow run-arrow!)
def(+Needs.run-word!, Word +Mirth +Needs -- +Mirth +Needs, rdip:arrow run-arrow!)
def(+Needs.run-arrow!, Arrow +Mirth +Needs -- +Mirth +Needs, atoms for(run-atom!))
def(+Needs.run-atom!, Atom +Mirth +Needs -- +Mirth +Needs, sip(args) op run-op!)

def +Needs.run-op! [ List(Arg) Op +Mirth +Needs -- +Mirth +Needs ] {
    { Int -> drop2 }
    { F64 -> drop2 }
    { Str -> drop2 }
    { Word -> dup prefer-inline? if(run-word!, need-word!) push-args! }
    { External -> drop push-args! }
    { Buffer -> drop push-args! }
    { Variable -> drop push-args! }
    { Field -> drop push-args! }
    { Tag -> need-tag-word! push-args! }
    { Prim -> run-prim! }
    { Match -> nip run-match! }
    { Lambda -> nip run-lambda! }
    { Var -> drop2 }
    { BlockPush -> nip push-block! }
    { BlockRun -> nip run-block! }
    { LabelPush -> drop2 }
    { LabelPop -> drop2 }
    { LabelPushR -> drop2 }
    { LabelPopR -> drop2 }
    { DataGetEnumValue -> drop2 }
    { DataFromEnumValue -> drop2 }
    { DataGetLabel -> drop2 }
    { DataSetLabel -> drop2 }
    { TableToIndex -> drop2 }
    { TableFromIndex -> drop2 }
}

def(+Needs.run-prim!, List(Arg) Prim +Mirth +Needs -- +Mirth +Needs,
    PRIM_CORE_DIP -> dup single? if(run-args!, push-args!),
    PRIM_CORE_RDIP -> dup single? if(run-args!, push-args!),
    PRIM_CORE_IF -> dup >L2? if(run-args!, push-args!),
    PRIM_CORE_WHILE -> dup >L2? if(run-args!, push-args!),
    _ -> drop push-args!)
def(+Needs.run-match!, Match +Mirth +Needs -- +Mirth +Needs, cases for(run-case!))
def(+Needs.run-case!, Case +Mirth +Needs -- +Mirth +Needs, dup pattern run-pattern! body run-arrow!)
def(+Needs.run-lambda!, Lambda +Mirth +Needs -- +Mirth +Needs, body run-arrow!)

def(+Needs.run-pattern!, Pattern +Mirth +Needs -- +Mirth +Needs, atoms for:run-patatom!)
def(+Needs.run-patatom!, PatternAtom +Mirth +Needs -- +Mirth +Needs,
    op match(
        PatOpUnderscore -> id,
        PatOpTag -> need-tag-pat!
    ))

def(+Needs.push-args!, List(Arg) +Mirth +Needs -- +Mirth +Needs, for(push-arg!))
def(+Needs.push-arg!, Arg +Mirth +Needs -- +Mirth +Needs,
    Block -> push-block!)
def(+Needs.push-block!, Block +Mirth +Needs -- +Mirth +Needs,
    dup rdip:to-run-var match(
        Some -> drop2,
        None -> need-block!
    ))
