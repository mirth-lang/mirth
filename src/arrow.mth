module(mirth.arrow)

import(std.prelude)
import(std.maybe)
import(std.list)
import(std.lazy)
import(std.str)

import(mirth.token)
import(mirth.type)
import(mirth.data)
import(mirth.match)
import(mirth.var)
import(mirth.name)
import(mirth.word)
import(mirth.prim)
import(mirth.external)
import(mirth.buffer)
import(mirth.variable)
import(mirth.table)
import(mirth.label)

##########
# ARROWS #
##########

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation.

# Originally this type was called Morphism but that's hard to spell and
# to type repeatedly so now it's called Arrow :-)

# mirth/data/arrow
table(Block)

data(Arg, ARG_BLOCK -> Block)

data(Op,
    OP_NONE,
    OP_PRIM -> Prim,
    OP_WORD -> Word,
    OP_EXTERNAL -> External,
    OP_BUFFER -> Buffer,
    OP_VARIABLE -> Variable,
    OP_FIELD -> Field,
    OP_INT -> Int,
    OP_STR -> Str,
    OP_TAG -> Tag,
    OP_MATCH -> Match,
    OP_LAMBDA -> Lambda,
    OP_VAR -> Var,
    OP_BLOCK -> Block,
    OP_RUN -> Block,
    OP_COERCE -> Coerce,
    OP_LABEL_PUSH -> Label,
    OP_LABEL_POP -> Label,
    OP_DATA_GET_TAG -> Data,
    OP_DATA_GET_LABEL -> Tag Label,
    OP_DATA_SET_LABEL -> Tag Label)

data(Coerce,
    COERCE_UNSAFE)

data(Home,
    HOME_MAIN -> Token,
    HOME_WORD -> Word)

data(Arrow, ARROW ->
    home:Home
    token-start:Token
    token-end:Token
    ctx:Ctx
    dom:StackType
    cod:StackType
    atoms:List(Atom))
def(Arrow.type, Arrow -- ArrowType, sip(dom) cod T->)

data(Atom, ATOM ->
    home:Home
    token:Token
    ctx:Ctx
    op:Op
    args:List(Arg)
    dom:StackType
    cod:StackType
    subst:Subst)

data(Lambda, LAMBDA ->
    token:Token
    outer-ctx:Ctx
    dom:StackType
    params:List(Var)
    body:Arrow)
def(Lambda.inner-ctx, Lambda -- Ctx, body ctx)
def(Lambda.mid, Lambda -- StackType, body dom)
def(Lambda.cod, Lambda -- StackType, body cod) # assuming no dependent types

#########
# BLOCK #
#########

field(Block.~ctx, Block, Ctx)
field(Block.~token, Block, Token)
field(Block.~home, Block, Home)
field(Block.~dom, Block, StackType)
field(Block.~cod, Block, StackType)
field(Block.~arrow, Block, Lazy(Arrow))
field(Block.~qname, Block, QName)

def(Block.ctx, Block -- Ctx, ~ctx @)
def(Block.token, Block -- Token, ~token @)
def(Block.dom, Block -- StackType, ~dom @)
def(Block.cod, Block -- StackType, ~cod @)
def(Block.home, Block -- Home, ~home @)

def(Block.type, Block -- ArrowType, sip(dom) cod T->)
def(Block.arrow, Block -- Arrow, ~arrow force!)
def(Block.infer-type!, Block -- ArrowType, arrow type)

def(Block.qname, Block -- QName,
    dup ~qname memoize(dup dup home match(
        HOME_MAIN ->
            .module NAMESPACE_MODULE
            swap arrow token-start index show
            dip:"entry@" cat >Name QNAME0,
        HOME_WORD -> dup NAMESPACE_WORD
            dip(dip:arrow arrow both(token-start index) - show >Name)
            swap QNAME0
    )) nip)

def(Block.==, Block Block -- Bool, both(Block.index) ==)

field(Word.~num-blocks, Word, Int)
def(Word.inc-num-blocks!, Word -- Int,
    dup ~num-blocks @? match(
        SOME -> tuck 1+ swap ~num-blocks !,
        NONE -> 1 swap ~num-blocks ! 0
    ))

field(Block.~home-index, Block, Int)
def(Block.register-home!, Block --,
    dup home match(
        HOME_WORD ->
            inc-num-blocks! swap ~home-index !,
        HOME_MAIN ->
            drop2
    ))

field(Block.~cname, Block, Str)
def(Block.cname, Block -- Str, dup ~cname memoize(
    dup home match(
        HOME_WORD -> Str("mb_" ; qname mangled ; "_" ; dup ~home-index @ show ;),
        HOME_MAIN -> drop Str("mb_" ; dup index show ;),
    )) nip)

def(Block.new!, Arrow -- Block,
    Block.alloc!
    over home over ~home !
    dup register-home!
    over ctx over ~ctx !
    over token-start over ~token !
    over dom over ~dom !
    over cod over ~cod !
    tuck dip(ready) ~arrow !)

def(Block.new-deferred!(f), (Block -- Arrow) Ctx Token Home -- Block,
    Block.alloc!
    tuck ~home !
    dup register-home!
    tuck ~token !
    tuck ~ctx !
    MetaVar.new! STMeta over ~dom !
    MetaVar.new! STMeta over ~cod !
    dup delay(f) over ~arrow !)

def(Block.typecheck!, Block --,
    arrow drop)

def(block-unify-type!, Gamma Block ArrowType -- Gamma ArrowType,
    dip(dup type) rotl dip(unify! drop) arrow type)

def(Block.to-run-var, Block -- Maybe(Var),
    arrow to-run-var)

def(Arrow.to-run-var, Arrow -- Maybe(Var),
    atoms /L1 bind(to-run-var))

def(Atom.to-run-var, Atom -- Maybe(Var),
    op match(
        OP_VAR -> dup auto-run? if(SOME, drop NONE),
        _ -> drop NONE
    ))

def(Arg.>Str, Arg -- Str,
    ARG_BLOCK -> qname >Str)
def(Arg.==, Arg Arg -- Bool,
    both(/ARG_BLOCK) ==)

field(Block.~free-vars, Block, List(Var))
def(Block.free-vars, Block -- List(Var),
    dup ~free-vars memoize(
        dup arrow free-vars
    ) nip)

def(Arrow.free-vars, Arrow -- List(Var),
    atoms map(free-vars) unions(==))
def(Atom.free-vars, Atom -- List(Var),
    dup args map(free-vars) unions(==)
    swap op free-vars union(==))
def(Arg.free-vars, Arg -- List(Var),
    ARG_BLOCK -> free-vars)
def(Op.free-vars, Op -- List(Var),
    OP_NONE -> L0,
    OP_PRIM -> drop L0,
    OP_WORD -> drop L0,
    OP_EXTERNAL -> drop L0,
    OP_BUFFER -> drop L0,
    OP_VARIABLE -> drop L0,
    OP_FIELD -> drop L0,
    OP_INT -> drop L0,
    OP_STR -> drop L0,
    OP_TAG -> drop L0,
    OP_MATCH -> free-vars,
    OP_LAMBDA -> free-vars,
    OP_VAR -> L1,
    OP_BLOCK -> free-vars,
    OP_RUN -> free-vars,
    OP_COERCE -> drop L0,
    OP_LABEL_PUSH -> drop L0,
    OP_LABEL_POP -> drop L0,
    OP_DATA_GET_TAG -> drop L0,
    OP_DATA_GET_LABEL -> drop2 L0,
    OP_DATA_SET_LABEL -> drop2 L0)
def(Match.free-vars, Match -- List(Var),
    cases map(free-vars) unions(==))
def(Case.free-vars, Case -- List(Var),
    body free-vars)
def(Lambda.free-vars, Lambda -- List(Var),
    dup body free-vars
    swap params difference(==))

def(Arg.token, Arg -- Token,
    ARG_BLOCK -> token)
def(Arg.type, Arg -- ArrowType,
    ARG_BLOCK -> type)
