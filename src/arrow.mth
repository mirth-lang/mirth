module mirth.arrow

import std.prelude
import std.maybe
import std.list
import std.str

import mirth.mirth
import mirth.token
import mirth.type
import mirth.data
import mirth.match
import mirth.var
import mirth.name
import mirth.word
import mirth.prim
import mirth.external
import mirth.buffer
import mirth.variable
import mirth.table
import mirth.label

##########
# ARROWS #
##########

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation.

# Originally this type was called Morphism but that's hard to spell and
# to type repeatedly so now it's called Arrow :-)

struct Arrow {
    home:Home
    token-start:Token
    token-end:Token
    ctx:Ctx
    dom:StackType
    cod:StackType
    atoms:List(Atom)
    --
    def ctx-type { sip(ctx) type }
    def type { sip(dom) cod T-> }

    def to-run-var [ Arrow -- Maybe(Var) ] {
        atoms single? bind(to-run-var)
    }
    def free-vars [ +Mirth Arrow -- +Mirth List(Var) ] {
        atoms map(free-vars) unions
    }
}

struct Atom {
    home:Home
    token:Token
    ctx:Ctx
    op:Op
    args:List(Arg)
    dom:StackType
    cod:StackType
    subst:Subst
    --
    def to-run-var [ Atom -- Maybe(Var) ] { op to-run-var }
    def free-vars [ +Mirth Atom -- +Mirth List(Var) ] {
        dup args map(free-vars) unions
        swap op free-vars union
    }
}

data Arg {
    ArgBlock [ Block ]
    --
    def token { ArgBlock -> token }
    def type  { ArgBlock -> type }
    def free-vars { ArgBlock -> free-vars }
    def >Str [ +Mirth Arg -- +Mirth Str ] { ArgBlock -> qname >Str }
    def == [ Arg Arg -- Bool ] { both(/ArgBlock) == }
}

data Op {
    OpNone
    OpPrim [ Prim ]
    OpWord [ Word ]
    OpExternal [ External ]
    OpBuffer [ Buffer ]
    OpVariable [ Variable ]
    OpField [ Field ]
    OpInt [ Int ]
    OpF64 [ F64 ]
    OpStr [ Str ]
    OpTag [ Tag ]
    OpMatch [ Match ]
    OpLambda [ Lambda ]
    OpVar [ Var ]
    OpBlockPush [ Block ]
    OpBlockRun  [ Block ]
    OpLabelPush  [ Label ]
    OpLabelPop   [ Label ]
    OpLabelPushR [ Label ]
    OpLabelPopR  [ Label ]
    OpDataGetEnumValue  [ Data ]
    OpDataFromEnumValue [ Data ]
    OpDataGetLabel [ TagField ]
    OpDataSetLabel [ TagField ]
    OpTableToIndex [ Table ]
    OpTableFromIndex [ Table ]
    --
    def to-run-var [ Op -- Maybe(Var) ] {
        { OpVar -> dup auto-run? if(Some, drop None) }
        { _ -> drop None }
    }
    def free-vars [ +Mirth Op -- +Mirth List(Var) ] {
        { OpNone -> List.Nil }
        { OpPrim -> drop List.Nil }
        { OpWord -> drop List.Nil }
        { OpExternal -> drop List.Nil }
        { OpBuffer -> drop List.Nil }
        { OpVariable -> drop List.Nil }
        { OpField -> drop List.Nil }
        { OpInt -> drop List.Nil }
        { OpF64 -> drop List.Nil }
        { OpStr -> drop List.Nil }
        { OpTag -> drop List.Nil }
        { OpMatch -> free-vars }
        { OpLambda -> free-vars }
        { OpVar -> List.L1 }
        { OpBlockPush -> free-vars }
        { OpBlockRun -> free-vars }
        { OpLabelPush -> drop List.Nil }
        { OpLabelPop -> drop List.Nil }
        { OpLabelPushR -> drop List.Nil }
        { OpLabelPopR -> drop List.Nil }
        { OpDataGetEnumValue -> drop List.Nil }
        { OpDataFromEnumValue -> drop List.Nil }
        { OpDataGetLabel -> drop List.Nil }
        { OpDataSetLabel -> drop List.Nil }
        { OpTableToIndex -> drop List.Nil }
        { OpTableFromIndex -> drop List.Nil }
    }
}

data Home {
    HomeMain [ Token ]
    HomeWord [ Word  ]
}

struct Lambda {
    token:Token
    outer-ctx:Ctx
    dom:StackType
    params:List(Var)
    body:Arrow
    --
    def inner-ctx [ Lambda -- Ctx ] { body ctx }
    def mid [ Lambda -- StackType ] { body dom }
    def cod [ Lambda -- StackType ] { body cod } # assuming no dependent types
    def free-vars [ +Mirth Lambda -- +Mirth List(Var) ] {
        dup body free-vars
        swap params difference
    }
}

#########
# BLOCK #
#########

table(Block)

field(Block.~ctx, Block, Ctx)
field(Block.~token, Block, Token)
field(Block.~home, Block, Home)
field(Block.~dom, Block, StackType)
field(Block.~cod, Block, StackType)
field(Block.~arrow, Block, Prop(Arrow))
field(Block.~qname, Block, QName)

def(Block.ctx, Block -- Ctx, ~ctx @)
def(Block.token, Block -- Token, ~token @)
def(Block.dom, Block -- StackType, ~dom @)
def(Block.cod, Block -- StackType, ~cod @)
def(Block.home, Block -- Home, ~home @)

def(Block.type, Block -- ArrowType, sip(dom) cod T->)
def(Block.arrow, +Mirth Block -- +Mirth Arrow, ~arrow force!)
def(Block.infer-type!, +Mirth Block -- +Mirth ArrowType, arrow type)

def(Block.qname, +Mirth Block -- +Mirth QName,
    dup ~qname memoize(dup dup home match(
        HomeMain ->
            .module Namespace.NAMESPACE_MODULE
            swap arrow token-start index show
            dip:"entry@" cat >Name 0 QName.Mk,
        HomeWord -> dup Namespace.NAMESPACE_WORD
            dip(dip:arrow arrow both(token-start index) - show >Name)
            swap 0 QName.Mk
    )) nip)

def(Block.==, Block Block -- Bool, both(Block.index) ==)

field(Block.~home-index, Block, Int)
def(Block.register-home!, Block --,
    dup home match(
        HomeWord ->
            inc-num-blocks! swap ~home-index !,
        HomeMain ->
            drop2
    ))

field(Block.~cname, Block, Str)
def(Block.cname, +Mirth Block -- +Mirth Str, dup ~cname memoize(
    dup home match(
        HomeWord -> qname-hard mangled Str("mb_" ; ; "_" ; dup ~home-index @ show;),
        HomeMain -> drop Str("mb_" ; dup index show;),
    )) nip)

def(Block.new!, +Mirth Arrow -- +Mirth Block,
    Block.alloc!
    over home over ~home !
    dup register-home!
    over ctx over ~ctx !
    over token-start over ~token !
    over dom over ~dom !
    over cod over ~cod !
    tuck dup dip(PropLabel.BlockArrow prop) ~arrow !)

def(Block.new-deferred!(f), (+Mirth Block -- +Mirth Arrow) +Mirth Ctx Token Home -- +Mirth Block,
    Block.alloc!
    tuck ~home !
    dup register-home!
    tuck ~token !
    tuck ~ctx !
    MetaVar.new! StackType.STMeta over ~dom !
    MetaVar.new! StackType.STMeta over ~cod !
    dup dup PropLabel.BlockArrow prop(f) over ~arrow !)

def(Block.typecheck!, +Mirth Block -- +Mirth,
    arrow drop)

def(block-unify-type!, +Mirth +Gamma Block ArrowType -- +Mirth +Gamma ArrowType,
    dip(dup type) rotl dip(unify! drop) rdip:arrow type)

def(Block.to-run-var, +Mirth Block -- +Mirth Maybe(Var),
    arrow to-run-var)

field(Block.~free-vars, Block, List(Var))
def(Block.free-vars, +Mirth Block -- +Mirth List(Var),
    dup ~free-vars memoize(
        dup arrow free-vars
    ) nip)

def(Match.free-vars, +Mirth Match -- +Mirth List(Var),
    cases map(free-vars) unions)
def(Case.free-vars, +Mirth Case -- +Mirth List(Var),
    body free-vars)
