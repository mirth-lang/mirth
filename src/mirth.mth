module(mirth)

import(prelude)
import(platform.posix)
import(data.path)
import(data.str)
import(data.list)
import(data.byte)
import(resource.file)
import(data.maybe)

import(mirth.data.error)
import(mirth.data.prim)
import(mirth.data.word)
import(mirth.data.type)
import(mirth.data.name)
import(mirth.data.def)
import(mirth.lexer)
import(mirth.elab)
import(mirth.data.ctx)

import(mirth.codegen.c99)

import(args.parse)
import(args.types)
import(args.state)

def(init!, --,
    init-errors!
    init-paths!
    init-types!
    init-prims!)

table(Arguments)
field(Arguments~input-file, Arguments, Path)
field(Arguments~output-file, Arguments, Maybe(Path))
field(Arguments~entry-point, Arguments, Maybe(Str))

# Helpers to read table fields
def(Arguments.input-file, Arguments -- Path, ~input-file @)
def(Arguments.output-file, Arguments -- Maybe(Path), ~output-file @)
def(Arguments.entry-point, Arguments -- Maybe(Str), ~entry-point @)

def(Arguments.new, Path Maybe(Path) Maybe(Str) -- Arguments, 
  Arguments.alloc!
  dup dip(~entry-point !)
  dup dip(~output-file !)
  dup dip(~input-file !)
)

||| Create a default initialized arguments table
||| Since the input file is always required we don't need it to be Maybe(Path)
def(Arguments.default, -- Arguments,
  "mirth.mth" >Path
  NONE
  "main" SOME
  Arguments.new
)

||| Pretty print the contents of the arguments struct
def(Arguments.show, Arguments -- Str,
  LIST(
    "Arguments {";
      "output-file: " ; dup output-file match(SOME -> >Str, NONE -> "(none)") ; 
      ", input-file: " ; dup input-file >Str ; 
      ", entry-point: " ; dup entry-point match(SOME -> , NONE -> "(none)") ; 
    " }";)
  reduce(cat)
  swap drop unwrap
)

########
# Main #
########

def(compile!, Arguments +World -- +World,
    "Compiling " trace!
    dup input-file >Str trace-ln!

    dup input-file run-lexer!

    # show-names-table!
    # show-tokens!

    "Building." trace-ln!

    elab-module! drop
    typecheck-everything!

    num-errors @ 0> if(
        num-errors @ trace!
        " errors." trace-ln!
        1 posix-exit!,
	"No errors." trace-ln!
    )


    dup entry-point match(
      SOME -> 
        "Codegen." trace-ln!
        >Name >Def .word? unwrap-or("could not find entry point" panic!)
        arrow swap output-file unwrap run-output-c99!,
      NONE -> "Skipping Codegen." trace-ln! drop
    )
)

def(compiler-parse-args, +ArgumentParser(Arguments) Arguments Maybe(Str) ArgpOptionType -- +ArgumentParser(Arguments) Arguments,
  match(
    OPTION_SHORT -> match(
      B'o' -> unwrap >Path SOME over ~output-file !,
      B'e' -> unwrap SOME over ~entry-point !,
      B'c' -> drop NONE over ~entry-point !,
      _ -> drop drop UNKNOWN_ARG SOME state current-error! state!
    ),
    OPTION_POSITIONAL -> state current-positional-arg 0 = if(
      unwrap >Path over ~input-file !,
      drop TOO_MANY_ARGS SOME state current-error! state!
    ),
    OPTION_END -> state current-positional-arg 1 < then(
      TOO_FEW_ARGS SOME state current-error! state!
    ) 

    state arguments ~output-file @ match(
      SOME -> drop,
      # If we have an entry point we need to have an output file currently
      NONE -> state arguments ~entry-point @ match (
        SOME -> drop "output-file" MISSING_ARG SOME state current-error! state!,
	NONE ->
      )
    )
    drop,
    _ -> drop drop UNKNOWN_ARG SOME state current-error! state!
  ) 
)

def(main, +World -- +World,
    init!

    Arguments.default

    LIST(
      "output-file" SOME
      B'o' OPTION_SHORT
      "OUTPUT_FILE" SOME
      "Test argument" SOME
      NONE ArgpOption.new ; 

      "compile-only" SOME
      B'c' OPTION_SHORT
      NONE
      "Compile code without running codegen step" SOME
      NONE ArgpOption.new ;

      "entry-point" SOME
      B'e' OPTION_SHORT
      "ENTRY_POINT" SOME
      "Custom entry point word for compilation" SOME
      NONE ArgpOption.new ;
    )
    [ compiler-parse-args ] SOME
    "input-file" SOME
    "Mirth Compiler" 
    ArgumentParser.new

    parse-args match(
      RIGHT -> ,
      LEFT -> show panic!
    )

    compile!
)
