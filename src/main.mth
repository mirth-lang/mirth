module(mirth.main)

import(std.prelude)
import(std.path)
import(std.str)
import(std.list)
import(std.byte)
import(std.maybe)
import(std.either)

import(arg-parser.parse)
import(arg-parser.types)
import(arg-parser.state)

import(std.posix)
import(std.file)
import(std.test)

import(mirth.package)
import(mirth.error)
import(mirth.prim)
import(mirth.word)
import(mirth.type)
import(mirth.name)
import(mirth.def)
import(mirth.lexer)
import(mirth.elab)
import(mirth.var)
import(mirth.specializer)
import(mirth.c99)

import(std.terminal)

def(init!, --,
    init-errors!
    init-types!
    init-prims!)

data(Arguments,
    Arguments ->
        input-file:Path
    output-file:Maybe(Path)
    entry-point:Maybe(Str)
    packages:List([Str Path])
    emit-debug-info:Bool)

||| Create a default initialized arguments table
||| Since the input file is always required we don't need it to be Maybe(Path)
def(Arguments.default, -- Arguments,
    F >emit-debug-info
    "mirth.mth" >Path >input-file
    None >output-file
    "main" Some >entry-point
    L0 >packages
    Arguments)

||| Pretty print the contents of the arguments struct
def(Arguments.show, Arguments -- Str,
    /Arguments
    "Arguments { "
    "output-file: " cat output-file> if-some(>Str, "(none)") cat
    ", input-file: " cat input-file> >Str cat
    ", entry-point: " cat entry-point> unwrap-or("(none)") cat
    ", emit-debug-info: " cat emit-debug-info> if("yes", "no") cat
    ", packages: " cat "[" packages> for(dip(cat) unpack2 dip(Str.cat ":" cat) >Str cat " ") drop "]" cat
    " }" cat)

########
# Main #
########

def(compile!, Arguments +World -- +World,
    /Arguments
    "Compiling " trace!
    input-file> dup >Str trace-ln! >input-file
    packages> for(
      unpack2 swap >Name Package.new-or-set-path! drop
    )
    input-file> run-lexer!
    "Building." trace-ln!

    elab-module!
    typecheck-everything!

    entry-point> map(
        dip(dup NAMESPACE_MODULE) >Name QNAME0
        elab-entry-point
    ) nip

    num-errors @ 0> if(
        FGRed show trace!
        num-errors @ trace!
        " errors." trace-ln!
        Reset show trace!
        1 posix-exit!,

        FGGreen show trace!
        "No errors." trace!
        Reset show trace-ln!
    )

    match(
        Some ->
            "Specializer." trace-ln!
            run-specializer!
            "Codegen." trace-ln!
            output-file> unwrap >output-path
            C99_Options.make run-output-c99!,
        None ->
            "Skipping Codegen." trace-ln!
            emit-debug-info> drop
            output-file> drop
    ))

def(parse-package-def, Str -- [Str Path],
    dip(BCOLON) split-byte
    /L2 unwrap-or("Invalid package path definition" panic!)
    unpack2 >Path pack2)

def(compiler-parse-args, +ArgumentParser(Arguments) Arguments Maybe(Str) ArgpOptionType -- +ArgumentParser(Arguments) Arguments,
    SHORT -> dip(swap) match(
        B'o' -> output-file(drop unwrap >Path Some),
        B'e' -> entry-point(drop unwrap Some),
        B'c' -> entry-point(drop drop None),
        B'p' -> dip(unwrap parse-package-def) packages(cons),
        _ -> drop swap drop UNKNOWN_ARG Some state:error!
    ),
    POSITIONAL -> swap state positional-index 0= if(
        input-file(drop unwrap >Path),
        dip(drop) TOO_MANY_ARGS Some state:error!
    ),
    LONG_ONLY -> dup "debug" == if(
        drop2 T swap emit-debug-info!,
        drop2 UNKNOWN_ARG Some state:error!
    ),
    END ->
        state positional-index 1 < then(
            TOO_FEW_ARGS Some state:error!
        )
        state arguments output-file else(
        state arguments entry-point then(
            "output-file" MISSING_ARG Some state:error!
            )
        )
        drop,
    _ -> drop drop UNKNOWN_ARG Some state error! state!)

def(main, +World -- +World,
    init!

    Arguments.default
    LIST(
        "output-file" Some >name
        B'o' SHORT >flag-type
        "OUTPUT_FILE" Some >arg-doc
        "Test argument" Some >doc
        None >group
        ArgpOption ;

        "compile-only" Some >name
        B'c' SHORT >flag-type
        None >arg-doc
        "Compile code without running codegen step" Some >doc
        None >group
        ArgpOption ;

        "entry-point" Some >name
        B'e' SHORT >flag-type
        "ENTRY_POINT" Some >arg-doc
        "Custom entry point word for compilation" Some >doc
        None >group
        ArgpOption ;

        "package" Some >name
        B'p' SHORT >flag-type
        "(PACKAGE:PATH)*" Some >arg-doc
        "Package locations" Some >doc
        None >group
        ArgpOption ;

        "debug" Some >name
        "debug" LONG_ONLY >flag-type
        None >arg-doc
        "Emit debugging information during codegen" Some >doc
        None >group
        ArgpOption ;
    ) >options
    [ compiler-parse-args ] Some >parser
    "input-file" Some >args-doc
    "Mirth Compiler" >doc
    ArgumentParser

    parse-args match(
        Right -> ,
        Left -> show panic!
    )

    compile!)
