module(mirth.c99)

import(std.prelude)
import(std.str)
import(std.path)
import(std.list)
import(std.lazy)
import(std.byte)
import(std.maybe)
import(std.either)

import(std.file)
import(std.output)

import(mirth.mirth)
import(mirth.module)
import(mirth.location)
import(mirth.token)
import(mirth.name)
import(mirth.buffer)
import(mirth.arrow)
import(mirth.word)
import(mirth.table)
import(mirth.variable)
import(mirth.external)
import(mirth.tycon)
import(mirth.type)
import(mirth.data)
import(mirth.package)
import(mirth.prim)
import(mirth.var)
import(mirth.match)
import(mirth.elab)
import(mirth.need)
import(mirth.label)
import(mirth.def)

#######
# C99 #
#######

struct C99_Options {
    output-path: Path
    emit-debug-info: Bool
}

struct +C99 {
    options: C99_Options
    depth: Nat
    fresh-counter: Nat
    +needs: +Needs
    +output: +Output
    +mirth: +Mirth
}

def(+C99.put, Str +C99 -- +C99, +output:put)
def(+C99.put-byte, Byte +C99 -- +C99, +output:put-byte)
def(+C99.line, +C99 -- +C99, +output:line)

def(c99-start!, Arrow C99_Options +World +Mirth -- Arrow +World +C99,
    >options
    0 >Nat >depth
    0 >Nat >fresh-counter
    +Needs.new dup determine-arrow-needs! >+needs >+mirth
    @options output-path create-file! unwrap! +Output.start! >+output
    +C99)

def(c99-end!, +World +C99 -- +World +Mirth,
    /+C99
    depth> fresh-counter> options> drop3
    +needs> rdrop
    +output> end! close-file!
    +mirth>)

def +C99.reset-fresh-counter! [ +C99 -- +C99 ] {
    0 >Nat fresh-counter!
}

def +C99.fresh-nat! [ +C99 -- Nat +C99 ] {
    fresh-counter
    dup 1+ fresh-counter!
}

def +C99.fresh-name! [ +C99 -- Str +C99 ] {
    fresh-nat! Str("v"; show;)
}

def +C99.fresh-resource-name! [ +C99 -- Str +C99 ] {
    fresh-nat! Str("r"; show;)
}

def(run-output-c99!, Arrow C99_Options +World +Mirth -- +World +Mirth,
    num-errors 0> if(
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-tag-defs!
        c99-buffers!
        c99-variables!
        c99-external-blocks!
        c99-word-sigs!
        c99-block-sigs!
        c99-field-sigs!
        c99-main!
        c99-field-defs!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    ))

field(Tag.~word-cname, Tag, Str)
field(Tag.~pat-cname, Tag, Str)
field(Buffer.~cname, Buffer, Str)
field(Variable.~cname, Variable, Str)
field(Field.~cname, Field, Str)
field(External.~cname, External, Str)
field(Prim.~cname, Prim, Str)

def(Tag.word-cname, +Mirth Tag -- +Mirth Str, dup ~word-cname memoize(
    Str("mtw_" ; dup qname rdip:mangled ;)) nip)
def(Tag.pat-cname, +Mirth Tag -- +Mirth Str, dup ~pat-cname memoize(
    Str("mtp_" ; dup qname rdip:mangled ;)) nip)
def(Buffer.cname, +Mirth Buffer -- +Mirth Str, dup ~cname memoize(
    Str("mbuf_" ; dup qname rdip:mangled ;)) nip)
def(Variable.cname, +Mirth Variable -- +Mirth Str, dup ~cname memoize(
    Str("mvar_" ; dup qname rdip:mangled ;)) nip)
def(Field.cname, +Mirth Field -- +Mirth Str, dup ~cname memoize(
    dup qname-hard mangled Str("mfld_" ; ;)) nip)
def(External.cname, +Mirth External -- +Mirth Str, dup ~cname memoize(
    dup qname-hard mangled Str("mext_" ; ;)) nip)
def(Prim.cname, Prim -- Str, dup ~cname memoize(
    Str("mp_" ; dup name mangled ;)) nip)

def(+C99.sig-put, Str +C99 -- +C99, "static void " put put " (void)" put)

embed-str(c99-header-str, "src/mirth.h")
def(c99-header!, +C99 -- +C99,
    "#define MIRTH_DEBUG " put
    options emit-debug-info if("1", "0") put line
    c99-header-str put line)

def(c99-buffers!, +C99 -- +C99, Buffer.for(c99-buffer!))
def(c99-buffer!, Buffer +C99 -- +C99,
    dup +mirth:cname sig-put " {" put line
    "\tstatic uint8_t b[" put dup size show put "] = {0};" put line
    "\tpush_ptr(&b);" put line
    "}" put line
    drop)

def(c99-variables!, +C99 -- +C99, Variable.for(c99-variable!))
def(c99-variable!, Variable +C99 -- +C99,
    +mirth:cname sig-put " {" put line
    "\tstatic VAL v = {0};" put line
    "\tpush_ptr(&v);" put line
    "}" put line)

def(c99-tag-defs!, +C99 -- +C99, Tag.for(c99-tag-def!))

def c99-tag-def! [ Tag +C99 -- +C99 ] {
    >tag
    @tag prefer-inline? else(
        @tag +needs:word-needed? then(
            @tag +mirth:word-cname sig-put " {" put line
            reset-fresh-counter!
            @tag is-transparent? else(
                @tag is-semi-transparent? if(
                    @tag outputs-resource? if(
                        @tag num-type-inputs 0> if(
                            "\tpush_resource(pop_value());" put line,
                            "\tpush_resource(lpop(&lbl_" put
                            @tag label-inputs /L1 unwrap name mangled put
                            "));" put line
                        ),
                        "\tpush_value(lpop(&lbl_" put
                        @tag label-inputs /L1 unwrap name mangled put
                        "));" put line
                    ),

                @tag num-total-inputs 0= if(
                    @tag outputs-resource? if(
                        "\tpush_resource(MKI64(",
                        "\tpush_value(MKI64("
                    ) put
                        @tag value-show put
                        "LL));" put line
                    ,

                    "\tTUP* tup = tup_new(" put
                        @tag num-total-inputs 1+ show put
                        ");" put line
                    "\ttup->size = " put
                        @tag num-total-inputs 1+ show put
                        ";" put line
                    "\ttup->cells[0] = MKI64(" put
                        @tag value-show put
                        "LL);" put line
                    @tag num-total-inputs
                    @tag label-inputs reverse-for(
                        "\ttup->cells[" put
                            over show put
                            "] = lpop(&lbl_" put
                            name mangled put
                            ");" put line
                        1-
                    )
                    @tag num-resource-inputs repeat(
                        "\ttup->cells[" put
                            dup show put
                            "] = pop_resource();" put line
                        1-
                    )
                    @tag num-type-inputs repeat(
                        "\ttup->cells[" put
                            dup show put
                            "] = pop_value();" put line
                        1-
                    )
                    drop
                    @tag outputs-resource? if(
                        "\tpush_resource(MKTUP(tup, ",
                        "\tpush_value(MKTUP(tup, "
                    ) put
                        @tag num-total-inputs 1+ show put
                        "));" put line
                ))
            )
            "}" put line
        )

        @tag +needs:pat-needed? then(
            @tag +mirth:pat-cname sig-put " {" put line
            reset-fresh-counter!
            @tag is-transparent? else(
                @tag outputs-resource? if(
                    "\tVAL val = pop_resource();",
                    "\tVAL val = pop_value();"
                ) put line
                @tag is-semi-transparent? if(
                    @tag num-type-inputs 0> if(
                        "\tpush_value(val);" put line,
                        "\tlpush(&lbl_" put
                        @tag label-inputs /L1 unwrap name mangled put
                        ", val);" put line
                    ),
                @tag num-total-inputs 0= if(
                    "\t(void)val;" put line,
                    "\tASSERT1(IS_TUP(val),val);" put line
                    "\tTUP* tup = VTUP(val);" put line
                    1
                    @tag num-type-inputs repeat(
                        "\tpush_value(tup->cells[" put
                            dup show put
                            "]);" put line
                        1+
                    )
                    @tag num-resource-inputs repeat(
                        "\tpush_resource(tup->cells[" put
                            dup show put
                            "]);" put line
                        1+
                    )
                    @tag label-inputs for(
                        "\tlpush(&lbl_" put
                            name mangled put
                            ", tup->cells[" put
                            dup show put
                            "]);" put line
                        1+
                    )
                    drop
                    "\tif (tup->refs > 1) {" put line
                    1 @tag num-total-inputs repeat(
                        "\t\tincref(tup->cells[" put
                            dup show put
                            "]);" put line
                        1+
                    ) drop
                    "\t\tdecref(val);" put line
                    "\t} else {" put line
                    "\t\tfree(tup);" put line
                    "\t}" put line
                ))
            )
            "}" put line
        )
    ) tag> drop
}

def(c99-tag-label-index, Tag Label +C99 -- Nat +C99,
    over num-total-inputs 1+
    over2 label-inputs reverse-find(dip(1- over) ==) drop
    dip:drop2)

def c99-tag-get-label! [ Tag Label +C99Branch -- +C99Branch ] {
    >label >tag
    @label @tag +core:+mirth:project-input-label unwrap >fieldty
    @tag is-semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag outputs-resource? if(
                    # wrapper is resource
                    type-to-c99-repr pop-to-local-resource!
                    dup-local-resource-as-value!
                    rdip(push-local-resource!) push-local!,

                    # wrapper is value
                    drop
                )
            }

            { Right -> # field and wrapper are both resources
                drop
                C99RT_I64 push-resource-expression!("0" put)
            }
        },

        @tag .data pop-local-value/resource-data! >+tuplevar
        fieldty> match {
            { Left -> # field is value
                type-to-c99-repr >fieldrepr
                @fieldrepr +core:local-expression!(
                    fieldrepr> v-macro put
                    "(VTUP(" put @+tuplevar:rdup consume-as-VAL put ")->cells[" put
                    @tag @label c99-tag-label-index show put
                    "])" put
                ) rswap dup-local! rdrop push-local!
                +tuplevar> match {
                    { +Left -> # tuple is value
                        drop-local! }
                    { +Right -> # tuple is resource
                        push-local-resource! }
                }
            }
            { Right -> # field and tuple are resources
                resource-to-c99-repr >fieldrepr
                @fieldrepr push-resource-expression!(
                    fieldrepr> v-macro put
                    "(VTUP(" put @+tuplevar:rdup consume-as-VAL put ")->cells[" put
                    @tag @label c99-tag-label-index show put
                    "])" put
                )
                +tuplevar> push-local-value/resource!
            }
        }
    )
    label> tag> drop2
}

def c99-tag-set-label! [ Tag Label +C99Branch -- +C99Branch ] {
    >label >tag
    @label @tag +core:+mirth:project-input-label unwrap >fieldty
    @tag is-semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag .data pop-local-value/resource-data! match {
                    { +Right -> # wrapper is resource
                        drop-local-resource-as-value!
                        type-to-c99-repr pop-to-local!
                        turn-into-resource! push-local-resource! }
                    { +Left -> # wrapper is value
                        drop drop-local! }
                }
            }
            { Right -> # field and wrapper are resource
                C99RT_I64 pop-to-local-resource! rdrop # vacant wrapper is unit
                drop
            }
        },

        @tag .data pop-local-value/resource-data! >+tuplevar
        @fieldty match {
            { Left -> type-to-c99-repr pop-to-local! consume-as-VAL }
            { Right -> resource-to-c99-repr pop-to-local-resource! consume-as-VAL }
        } >fieldval
        +tuplevar> match {
            { +Left -> # field and tuple are both values
                consume-as-VAL >tupleval
                C99RT_VAL push-expression!(
                    "tup_replace(" put
                    tupleval> put
                    ", " put
                    @tag @label c99-tag-label-index show put
                    ", " put
                    fieldval> put
                    ")" put
                )
                fieldty> drop
            }
            { +Right -> # tuple is resource
                >+tuplevar
                fieldty> match {
                    { Left -> # field is value
                        type-to-c99-repr >fieldrepr
                        @fieldrepr needs-refcounting? then (
                            @fieldrepr +core:local-expression! (
                                "VTUP(" put
                                @+tuplevar:rdup consume-as-VAL put
                                ")->cells[" put
                                @tag @label c99-tag-label-index show put
                                "]" put
                            ) rswap drop-local!
                        )
                        fieldrepr> drop
                    }
                    { Right -> # field is resource
                        drop
                    }
                }
                c99-line(
                    "VTUP(" put
                    @+tuplevar:rdup consume-as-VAL put
                    ")->cells[" put
                    @tag @label c99-tag-label-index show put
                    "] = " put
                    fieldval> put
                    ";" put
                )
                +tuplevar>
                push-local-resource!
            }
        }
    )
    label> tag> drop2
}

def(c99-external-blocks!, +C99 -- +C99,
    ExternalBlock.for(c99-external-block!))

def(c99-external-block!, ExternalBlock +C99 -- +C99,
    parts for(match(
        EBPCode -> put line,
        EBPDef -> c99-external-def!
    )))

def(c99-external-def!, External +C99 -- +C99,
    >ext
    @ext +mirth:ctype >cty

    @cty cod parts find(and(label? none?, ctype phantom? not)) >outty
    @outty if-some(ctype, Phantom) cname put " " put
    @ext symbol put

    " (" put
    @cty dom parts filter(ctype phantom? not)
    match(
        Nil -> "void" put,
        _ -> for(ctype cname put, ", " put)
    )
    ");" put line

    @ext +mirth:cname sig-put " {" put line
    reset-fresh-counter!

    @cty dom parts
    dup len >arg-index
    reverse-for(
        dup ctype phantom? else(
            "\t" put
            dup ctype cname put " " put
            dup c99-arg-name put
            " = " put
        )
        c99-pop
        ";" put line
        @arg-index:1-
    )

    "\t" put
    @outty for(ctype cname put " Y = " put)
    @ext symbol put "(" put

    1 >Nat !arg-index
    @cty dom parts filter-some(
        dup ctype phantom? if(drop None, c99-arg-name Some)
        @arg-index:1+
    )
    for(put, ", " put)
    ");" put line

    @cty cod parts for(
        "\t" put
        sip(label? if-some(name mangled, "Y"))
        c99-push
        line
    )

    "}" put line

    arg-index> drop
    ext> cty> outty> drop3)

def(CType.c99-pop-value, CType +C99 -- +C99,
    IntLike -> "(" put put ")pop_i64()" put,
    F32Like -> "(" put put ")pop_f32()" put,
    F64Like -> "(" put put ")pop_f64()" put,
    PtrLike -> "(" put put ")pop_ptr()" put,
    FnPtr   -> "(" put put ")pop_fnptr()" put,
    Phantom -> "(void)pop_value()" put )

def(CType.c99-pop-resource, CType +C99 -- +C99,
    IntLike -> "(" put put ")value_i64(pop_resource())" put,
    F32Like -> "(" put put ")value_f32(pop_resource())" put,
    F64Like -> "(" put put ")value_f64(pop_resource())" put,
    PtrLike -> "(" put put ")value_ptr(pop_resource())" put,
    FnPtr   -> "(" put put ")value_fnptr(pop_resource())" put,
    Phantom -> "(void)pop_resource()" put)

def(CType.c99-pop-label, Label CType +C99 -- +C99,
    IntLike -> "(" put put ")value_i64(lpop(&lbl_" put name mangled put "))" put,
    F32Like -> "(" put put ")value_f32(lpop(&lbl_" put name mangled put "))" put,
    F64Like -> "(" put put ")value_f64(lpop(&lbl_" put name mangled put "))" put,
    PtrLike -> "(" put put ")value_ptr(lpop(&lbl_" put name mangled put "))" put,
    FnPtr   -> "(" put put ")value_fnptr(lpop(&lbl_" put name mangled put "))" put,
    Phantom -> "(void)lpop(&lbl_" put name mangled put ")" put)

def(CType.c99-push-value, Str CType +C99 -- +C99,
    IntLike -> drop "push_i64((int64_t)(" put put "));" put,
    F32Like -> drop "push_f32((float)(" put put "));" put,
    F64Like -> drop "push_f64((double)(" put put "));" put,
    PtrLike -> drop "push_ptr((void*)(" put put "));" put,
    FnPtr   -> drop "push_fnptr((FNPTR)(" put put "));" put,
    Phantom -> drop "push_i64(0);" put)

def(CType.c99-push-resource, Str CType +C99 -- +C99,
    IntLike -> drop "push_resource(MKI64((int64_t)(" put put ")));" put,
    F32Like -> drop "push_resource(MKF32((float)(" put put ")));" put,
    F64Like -> drop "push_resource(MKF64((double)(" put put ")));" put,
    PtrLike -> drop "push_resource(MKPTR((void*)(" put put ")));" put,
    FnPtr   -> drop "push_resource(MKFNPTR((FNPTR)(" put put ")));" put,
    Phantom -> drop "push_resource(MKI64(0));" put)

def CType.c99-push-label [ Str Label CType +C99 -- +C99 ] {
    { IntLike -> drop "lpush(&lbl_" put name mangled put ", " put "MKI64((int64_t)(" put put ")));" put }
    { F32Like -> drop "lpush(&lbl_" put name mangled put ", " put "MKF32((float)(" put put ")));" put }
    { F64Like -> drop "lpush(&lbl_" put name mangled put ", " put "MKF64((double)(" put put ")));" put }
    { PtrLike -> drop "lpush(&lbl_" put name mangled put ", " put "MKPTR((void*)(" put put ")));" put }
    { FnPtr   -> drop "lpush(&lbl_" put name mangled put ", " put "MKFNPTR((FNPTR)(" put put ")));" put }
    { Phantom -> nip  "lpush(&lbl_" put name mangled put ", " put "MKI64((int64_t)(0)));" put }
}

def(CTypeStackPart.c99-arg-name, arg-index:Nat CTypeStackPart +C99 -- arg-index:Nat Str +C99,
    label? if-some(
        name mangled,
        Str("X" ; @arg-index show;)
    ))

def(CTypeStackPart.c99-pop, CTypeStackPart +C99 -- +C99,
    CTSPCons -> c99-pop-value,
    CTSPWith -> c99-pop-resource,
    CTSPConsLabel -> swap c99-pop-label,
    CTSPWithLabel -> swap c99-pop-label)

def(CTypeStackPart.c99-push, Str CTypeStackPart +C99 -- +C99,
    CTSPCons -> c99-push-value,
    CTSPWith -> c99-push-resource,
    CTSPConsLabel -> swap c99-push-label,
    CTSPWithLabel -> swap c99-push-label)

inline (
    def(+C99.c99-nest(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99, depth:1+ f depth:1-)
    def(+C99.c99-line(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99, indent f line)

    def +C99Branch.c99-line(f) [ (*a +C99 -- *b +C99) *a +C99Branch -- *b +C99Branch ]
        { +core:c99-line(f) }
    def +C99Branch.c99-nest(f) [ (*a +C99Branch -- *b +C99Branch) *a +C99Branch -- *b +C99Branch ]
        { +core:depth:1+ f +core:depth:1- }
)
def(+C99.indent, +C99 -- +C99, depth repeat("\t" put))

def(c99-call!, List(Arg) Str +C99Branch -- +C99Branch,
    dip(c99-args-push!)
    flush-cache! +core:c99-line(put "();" put))

def(c99-arrow!, Arrow +C99Branch -- +C99Branch, atoms for(c99-atom!))
def(c99-atom!, Atom +C99Branch -- +C99Branch,
    +core:options emit-debug-info and(dup show-in-stack-trace?) then(
        +core:c99-line("WORD_ATOM(" put
            dup token row >Int show put ", " put
            dup token col >Int show put ", " put
            dup token name? if-some(>Str, "") put-cstr
            ");" put
        )
    )
    dup op
    c99-atom-op!)

def(Atom.show-in-stack-trace?, Atom -- Bool,
    op match(
        OpNone -> False,
        OpInt -> drop False,
        OpF64 -> drop False,
        OpStr -> drop False,
        OpWord -> prefer-inline? not,
        OpExternal -> drop True,
        OpBuffer -> drop False,
        OpVariable -> drop False,
        OpField -> drop False,
        OpTag -> prefer-inline? not,
        OpPrim -> drop True,
        OpMatch -> drop False,
        OpLambda -> drop False,
        OpVar -> drop False,
        OpBlockPush -> drop False,
        OpBlockRun -> drop False,
        OpCoerce -> drop False,
        OpLabelPush -> drop False,
        OpLabelPop -> drop False,
        OpLabelPushR -> drop False,
        OpLabelPopR -> drop False,
        OpDataGetTag -> drop False,
        OpDataGetLabel -> drop2 False,
        OpDataSetLabel -> drop2 False
    ))

def c99-atom-op! [ Atom Op +C99Branch -- +C99Branch ] {
    { OpNone          -> drop }
    { OpInt           -> nip c99-int! }
    { OpF64           -> nip c99-f64! }
    { OpStr           -> nip c99-str! }
    { OpWord          -> dip:args c99-word! }
    { OpExternal      -> dip:args +core:+mirth:cname c99-call! }
    { OpBuffer        -> dip:args +core:+mirth:cname c99-call! }
    { OpVariable      -> dip:args +core:+mirth:cname c99-call! }
    { OpField         -> dip:args +core:+mirth:cname c99-call! }
    { OpTag           -> dip:args c99-tag-word! }
    { OpPrim          -> c99-prim! }
    { OpMatch         -> nip c99-match! }
    { OpLambda        -> nip c99-lambda! }
    { OpVar           -> nip c99-var! }
    { OpBlockPush     -> nip c99-block-push! }
    { OpBlockRun      -> nip c99-block-run! }
    { OpCoerce        -> drop2 }
    { OpLabelPush     -> c99-label-push! }
    { OpLabelPop      -> c99-label-pop! }
    { OpLabelPushR    -> c99-label-push-r! }
    { OpLabelPopR     -> c99-label-pop-r! }
    { OpDataGetTag    -> nip c99-get-data-tag! }
    { OpDataGetLabel  -> c99-tag-get-label! drop }
    { OpDataSetLabel  -> c99-tag-set-label! drop }
}

def(c99-get-data-tag!, Data +C99Branch -- +C99Branch,
    dup is-enum? or(dup is-unit?) else(
        end-branch!
        c99-line("{" put)
        c99-nest(
            c99-line("VAL val = pop_value();" put)
            dup is-semi-transparent? if(
                c99-line(
                    "push_u64(" put
                    dup tags /L1 unwrap value show put
                    "LL);" put),

                c99-line("USIZE tag = get_data_tag(val);" put)
                c99-line("push_u64(tag);" put )
            )
            c99-line("decref(val);" put)
        )
        c99-line("}" put)
        start-branch!
    ) drop)

def(c99-word!, List(Arg) Word +C99Branch -- +C99Branch,
    dup prefer-inline? if(
        dip:c99-args-push!
        +core:+mirth:arrow c99-arrow!,
        +core:+mirth:cname c99-call!
    ))

field(Tag.~value-show, Tag, Str)
def(Tag.value-show, Tag -- Str, dup ~value-show memoize(dup value show) nip)

def(c99-tag-word!, List(Arg) Tag +C99Branch -- +C99Branch,
    dup prefer-inline? if(
        dup .data is-transparent? else(
            dup outputs-resource? if(
                C99RT_I64 push-resource-expression!(
                    dup value-show put "LL /* " put
                    dup name >Str put " */" put
                ),
                C99RT_I64 push-expression!(
                    dup value-show put "LL /* " put
                    dup name >Str put " */" put
                )
            )
        ) drop2,
        +core:+mirth:word-cname c99-call!
    ))

def c99-reverse-tag! [ Tag +C99Branch -- +C99Branch ] {
    dup prefer-inline? if (
        .data dup is-transparent? if(
            drop,
            pop-local-value/resource-data! rdrop # it's a unit
        ),
        dip:L0 +core:+mirth:pat-cname c99-call!
    )
}

def(c99-label-defs!, +C99 -- +C99, Label.for(c99-label-def!))
def(c99-label-def!, Label +C99 -- +C99, "static VAL lbl_" put name mangled put " = MKNIL_C;" put line)

def push-local-label-direct! [ Label +C99 +C99Local -- +C99 ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-local-label! [ Label +C99Branch +C99Local -- +C99Branch ] {
    rswap +stack(rswap +SCConsLabel)
}
def push-local-resource-label-direct! [ Label +C99 +C99LocalResource -- +C99 ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-local-resource-label! [ Label +C99Branch +C99LocalResource -- +C99Branch ] {
    rswap +stack(rswap +SCWithLabel)
}

def pop-local-label-direct! [ C99ReprType Label +C99 -- +C99 +C99Local ] {
    swap dup local-expression!(
        match {
            { C99RT_VAL -> "lpop(&lbl_" put name mangled put ")" put }
            { _ -> v-macro put "(lpop(&lbl_" put name mangled put "))" put }
        }
    ) rswap
}

def pop-local-resource-label-direct! [ C99ReprType Label +C99 -- +C99 +C99LocalResource ] {
    swap dup local-resource-expression!(
        match {
            { C99RT_VAL -> "lpop(&lbl_" put name mangled put ")" put }
            { _ -> v-macro put "(lpop(&lbl_" put name mangled put "))" put }
        }
    ) rswap
}

def c99-label-push! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-local-from-stack-type! drop
    push-local-label!
}
def c99-label-push-r! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-local-resource-from-stack-type! drop
    push-local-resource-label!
}
def c99-label-pop! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-local-label-from-stack-type! drop
    push-local!
}
def c99-label-pop-r! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-local-resource-label-from-stack-type! drop
    push-local-resource!
}

def(c99-int!, Int +C99Branch -- +C99Branch,
    C99RT_I64 push-expression!(show put "LL" put))

def(c99-f64!, F64 +C99Branch -- +C99Branch,
    C99RT_F64 push-expression!(>Str put))

def(c99-str!, Str +C99Branch -- +C99Branch,
    end-branch! # TODO: do something smarter
    dup num-bytes 4090 >Size > if(
        c99-line("STRLIT(" put)
        c99-nest(
            c99-line(dup put-cstr-long "," put)
            c99-line(dup num-bytes show put)
        )
        c99-line(");" put),

        c99-line("STRLIT(" put
            dup put-cstr ", " put
            dup num-bytes show put ");" put)
    ) drop
    start-branch!)

def(+C99.put-cstr-long, Str +C99 -- +C99,
    False >avoid-hexdigit
    BQUOTE put-byte
    BNUL swap bytes-for(
        swap BLF == then(
            BQUOTE put-byte
            line indent
            BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    BQUOTE put-byte
    avoid-hexdigit> drop2)

def(+C99.put-cstr, Str +C99 -- +C99,
    False >avoid-hexdigit
    BQUOTE put-byte bytes-for(c99-string-byte!) BQUOTE put-byte
    avoid-hexdigit> drop)

def(c99-string-byte!, Byte avoid-hexdigit:Bool +C99 -- avoid-hexdigit:Bool +C99,
    B'\' ->   "\\\\" put False !avoid-hexdigit,
    BQUOTE -> "\\\"" put False !avoid-hexdigit,
    BHT ->    "\\t"  put False !avoid-hexdigit,
    BLF ->    "\\n"  put False !avoid-hexdigit,
    BCR ->    "\\r"  put False !avoid-hexdigit,
    _ ->
        dup BSPACE B'~' in-range
        and(dup is-hexdigit @avoid-hexdigit && not) if(
            put-byte
            False !avoid-hexdigit,
            "\\x" put to-hexdigits dip(put-byte) put-byte
            True !avoid-hexdigit
        )
    )

data C99ReprType {
    C99RT_VAL
    C99RT_STR

    C99RT_I64 C99RT_I32 C99RT_I16 C99RT_I8
    C99RT_U64 C99RT_U32 C99RT_U16 C99RT_U8
    C99RT_F64 C99RT_F32
    C99RT_BOOL
    C99RT_PTR
    C99RT_FNPTR
}

def C99ReprType.== [ C99ReprType C99ReprType -- Bool ] {
    both(tag) ==
}

def C99ReprType.needs-refcounting? [ C99ReprType -- Bool ] {
   { C99RT_VAL -> True }
   { C99RT_STR -> True }
   { _ -> drop False }
}

def C99ReprType.is-int-like? [ C99ReprType -- Bool ] {
    { C99RT_I64 -> True } { C99RT_I32 -> True } { C99RT_I16 -> True } { C99RT_I8 -> True }
    { C99RT_U64 -> True } { C99RT_U32 -> True } { C99RT_U16 -> True } { C99RT_U8 -> True }
    { C99RT_BOOL -> True }
    { _ -> drop False }
}

def C99ReprType.is-float-like? [ C99ReprType -- Bool ] {
    { C99RT_F64 -> True } { C99RT_F32 -> True }
    { _ -> drop False }
}

def C99ReprType.underlying-c99-type [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "VAL"      }
    { C99RT_STR   -> "STR*"     }
    { C99RT_I64   -> "int64_t"  }
    { C99RT_I32   -> "int32_t"  }
    { C99RT_I16   -> "int16_t"  }
    { C99RT_I8    -> "int8_t"   }
    { C99RT_U64   -> "uint64_t" }
    { C99RT_U32   -> "uint32_t" }
    { C99RT_U16   -> "uint16_t" }
    { C99RT_U8    -> "uint8_t"  }
    { C99RT_F64   -> "double"   }
    { C99RT_F32   -> "float"    }
    { C99RT_BOOL  -> "bool"     }
    { C99RT_PTR   -> "void*"    }
    { C99RT_FNPTR -> "FNPTR"    }
}

def C99ReprType.v-macro [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "VVAL"   }
    { C99RT_STR   -> "VSTR"   }
    { C99RT_I64   -> "VI64"   }
    { C99RT_I32   -> "VI32"   }
    { C99RT_I16   -> "VI16"   }
    { C99RT_I8    -> "VI8"    }
    { C99RT_U64   -> "VU64"   }
    { C99RT_U32   -> "VU32"   }
    { C99RT_U16   -> "VU16"   }
    { C99RT_U8    -> "VU8"    }
    { C99RT_F64   -> "VF64"   }
    { C99RT_F32   -> "VF32"   }
    { C99RT_BOOL  -> "VBOOL"  }
    { C99RT_PTR   -> "VPTR"   }
    { C99RT_FNPTR -> "VFNPTR" }
}

def C99ReprType.mk-macro [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "MKVAL"   }
    { C99RT_STR   -> "MKSTR"   }
    { C99RT_I64   -> "MKI64"   }
    { C99RT_I32   -> "MKI32"   }
    { C99RT_I16   -> "MKI16"   }
    { C99RT_I8    -> "MKI8"    }
    { C99RT_U64   -> "MKU64"   }
    { C99RT_U32   -> "MKU32"   }
    { C99RT_U16   -> "MKU16"   }
    { C99RT_U8    -> "MKU8"    }
    { C99RT_F32   -> "MKF32"   }
    { C99RT_F64   -> "MKF64"   }
    { C99RT_BOOL  -> "MKBOOL"  }
    { C99RT_PTR   -> "MKPTR"   }
    { C99RT_FNPTR -> "MKFNPTR" }
}

def C99ReprType.pop-macro [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "pop_value" }
    { C99RT_STR   -> "pop_str"   }
    { C99RT_I64   -> "pop_i64"   }
    { C99RT_I32   -> "pop_i32"   }
    { C99RT_I16   -> "pop_i16"   }
    { C99RT_I8    -> "pop_i8"    }
    { C99RT_U64   -> "pop_u64"   }
    { C99RT_U32   -> "pop_u32"   }
    { C99RT_U16   -> "pop_u16"   }
    { C99RT_U8    -> "pop_u8"    }
    { C99RT_F64   -> "pop_f64"   }
    { C99RT_F32   -> "pop_f32"   }
    { C99RT_BOOL  -> "pop_bool"  }
    { C99RT_PTR   -> "pop_ptr"   }
    { C99RT_FNPTR -> "pop_fnptr" }
}

def C99ReprType.push-macro [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "push_value" }
    { C99RT_STR   -> "push_str"   }
    { C99RT_I64   -> "push_i64"   }
    { C99RT_I32   -> "push_i32"   }
    { C99RT_I16   -> "push_i16"   }
    { C99RT_I8    -> "push_i8"    }
    { C99RT_U64   -> "push_u64"   }
    { C99RT_U32   -> "push_u32"   }
    { C99RT_U16   -> "push_u16"   }
    { C99RT_U8    -> "push_u8"    }
    { C99RT_F64   -> "push_f64"   }
    { C99RT_F32   -> "push_f32"   }
    { C99RT_BOOL  -> "push_bool"  }
    { C99RT_PTR   -> "push_ptr"   }
    { C99RT_FNPTR -> "push_fnptr" }
}

def Resource.c99-repr [ Resource +Mirth -- C99ReprType +Mirth ] {
    >Type c99-repr
}

def Type.c99-repr [ Type +Mirth -- C99ReprType +Mirth ] {
    { TYPE_ERROR -> C99RT_VAL }
    { TYPE_DONT_CARE -> C99RT_VAL }
    { TPrim -> c99-repr }
    { TMeta -> expand-if(c99-repr, drop C99RT_VAL) }
    { THole -> drop C99RT_VAL }
    { TVar -> drop C99RT_VAL }
    { TTable -> drop C99RT_U64 }
    { TData -> c99-repr }
    { TDataPartial -> .data c99-repr }
    { TMorphism -> drop C99RT_VAL }
    { TTensor -> drop C99RT_VAL }
    { TApp -> drop c99-repr }
    { TMut -> drop C99RT_VAL }
    { TValue -> drop C99RT_VAL }
}

def PrimType.c99-repr [ PrimType -- C99ReprType ] {
    { PRIM_TYPE_TYPE -> C99RT_VAL }
    { PRIM_TYPE_STACK -> C99RT_VAL }
    { PRIM_TYPE_RESOURCE -> C99RT_VAL }
    { PRIM_TYPE_INT -> C99RT_I64 }
    { PRIM_TYPE_F32 -> C99RT_F32 }
    { PRIM_TYPE_F64 -> C99RT_F64 }
    { PRIM_TYPE_STR -> C99RT_VAL }
    { PRIM_TYPE_PTR -> C99RT_VAL }
    { PRIM_TYPE_WORLD -> C99RT_VAL }
}

def Data.c99-repr [ Data +Mirth -- C99ReprType +Mirth ] {
    dup is-enum? if(drop C99RT_I64,
        dup is-semi-transparent? if(
            tags /L1 unwrap type dom c99-repr-semi-transparent,
            drop C99RT_VAL
        )
    )
}

def StackType.c99-repr-semi-transparent [ StackType +Mirth -- C99ReprType +Mirth ] {
    { STACK_TYPE_ERROR -> C99RT_VAL }
    { STACK_TYPE_DONT_CARE -> C99RT_VAL }
    { STACK_TYPE_UNIT -> C99RT_VAL }
    { STVar -> drop C99RT_VAL }
    { STMeta -> expand-if(>StackType c99-repr-semi-transparent, drop C99RT_VAL) }
    { STCons -> nip c99-repr }
    { STConsLabel -> drop nip c99-repr }
    { STWith -> nip c99-repr }
    { STWithLabel -> drop nip c99-repr }
}

struct +C99Local {
    local-repr: C99ReprType
    local-name: Str
}

def +C99Local.rdup [ +C99Local -- +C99Local +C99Local ] {
    local-repr >local-repr
    local-name >local-name
    +C99Local
}

def +C99Local.rdrop [ +C99Local -- ] {
    /+C99Local
    local-repr> drop
    local-name> drop
}

def C99ReprType.new-local! [ C99ReprType +C99Branch -- +C99Branch +C99Local ] {
    >local-repr
    +core:fresh-name! >local-name
    c99-line(@local-repr underlying-c99-type put " " put
             @local-name put ";" put)
    +C99Local
}

def C99ReprType.pop-to-local-direct! [ C99ReprType +C99 -- +C99 +C99Local ] {
    >local-repr
    fresh-name! >local-name
    c99-line(@local-repr underlying-c99-type put " " put
             @local-name put " = " put
             @local-repr pop-macro put "();" put)
    +C99Local
}

def +C99.pop-local-direct! [ +C99 -- +C99 +C99Local ] {
    C99RT_VAL pop-to-local-direct!
}

inline (
    ||| Push a value with a certain repr type on the stack.
    ||| `f` must emit the C99 expression that calculates the value,
    ||| which must be of the underlying C99 repr type.
    def C99ReprType.push-expression!(f) [
        (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
    ] {
        +core:local-expression!(f) rswap push-local!
    }

    def push-resource-expression!(f) [
        (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
    ] {
        +core:local-resource-expression!(f) rswap push-local-resource!
    }

    def C99ReprType.local-expression!(f) [
        (*a +C99 -- *b +C99) *a C99ReprType +C99 -- *b +C99Local +C99
    ] {
        >local-repr
        fresh-name! >local-name
        rdip:+C99Local
        c99-line(rdip:local-repr underlying-c99-type put " " put
                rdip:local-name put " = " put
                rswap rdip:f rswap ";" put)
    }

    def local-resource-expression!(f) [
        (*a +C99 -- *b +C99) *a C99ReprType +C99 -- *b +C99LocalResource +C99
    ] {
        >local-resource-repr
        fresh-name! >local-resource-name rdip:+C99LocalResource
        c99-line(rdip:local-resource-repr underlying-c99-type put " " put
                 rdip:local-resource-name put " = (" put
                 rswap rdip:f rswap ");" put)
    }
)

def +C99Local.push-local-direct! [ +C99 +C99Local -- +C99 ] {
    /+C99Local c99-line(
        local-repr> push-macro put "(" put
        local-name> put ");" put
    )
}

def +C99Local.consume [ +C99Local -- Str ] {
    /+C99Local local-repr> drop local-name>
}

def +C99Local.consume-as-VAL [ +C99Local -- Str ] {
    /+C99Local local-repr> match {
        C99RT_VAL -> local-name>,
        _ -> Str(mk-macro ; "(" ; local-name> ; ")";)
    }
}

def +C99Local.consume-as [ C99ReprType +C99Local -- Str ] {
    { C99RT_VAL -> consume-as-VAL }
    { _ ->
        /+C99Local
        @local-repr match {
            { C99RT_VAL -> Str( v-macro ; "(" ; local-name> ; ")" ; ) }
            { _ ->
                over == if(
                    drop local-name>,
                    dup is-int-like? @local-repr is-int-like? && if(
                        Str( "(" ; underlying-c99-type ; ")(" ; local-name> ; ")" ; ),
                        "attempted to cast between incompatible C99 repr types" panic!
                    )
                )
            }
        }
        local-repr> drop
    }
}

def +C99Local.drop-local! [ +C99Branch +C99Local -- +C99Branch ] {
    local-repr needs-refcounting? if(
        consume-as-VAL +core:c99-line("decref(" put put ");" put),
        rdrop
    )
}

def +C99Local.dup-local! [ +C99Branch +C99Local -- +C99Branch +C99Local +C99Local ] {
    local-repr needs-refcounting? then(
        rdup consume-as-VAL rdip:+core:c99-line("incref(" put put ");" put)
    )
    rdup
}

def +C99Local.peek-data-tag [ +C99Local -- +C99Local Str ] {
    local-repr match {
        { C99RT_VAL -> local-name Str("get_data_tag(" ; ; ")" ;) }
        { _ -> drop local-name }
    }
}

struct +C99LocalResource {
    local-resource-repr: C99ReprType
    local-resource-name: Str
}

def +C99LocalResource.rdup [ +C99LocalResource -- +C99LocalResource +C99LocalResource ] {
    local-resource-repr >local-resource-repr
    local-resource-name >local-resource-name
    +C99LocalResource
}

def +C99LocalResource.rdrop [ +C99LocalResource -- ] {
    consume drop
}

def +C99Local.turn-into-resource! [ +C99Local -- +C99LocalResource ] {
    /+C99Local
    local-repr> >local-resource-repr
    local-name> >local-resource-name
    +C99LocalResource
}

def +C99LocalResource.turn-into-value! [ +C99LocalResource -- +C99Local ] {
    /+C99LocalResource
    local-resource-repr> >local-repr
    local-resource-name> >local-name
    +C99Local
}

def +C99LocalResource.drop-local-resource-as-value! [ +C99Branch +C99LocalResource -- +C99Branch ] {
    turn-into-value! drop-local!
}

def +C99LocalResource.dup-local-resource-as-value! [ +C99Branch +C99LocalResource -- +C99Branch +C99LocalResource +C99Local ] {
    rdup turn-into-value! rswap rdip(dup-local! rdrop) rswap
}

def +C99LocalResource.consume [ +C99LocalResource -- Str ] {
    /+C99LocalResource
    local-resource-repr> drop
    local-resource-name>
}

def +C99LocalResource.consume-as-VAL [ +C99LocalResource -- Str ] {
    /+C99LocalResource local-resource-repr> match {
        C99RT_VAL -> local-resource-name>,
        _ -> Str(mk-macro ; "(" ; local-resource-name> ; ")";)
    }
}

def +C99.pop-local-resource-direct! [ +C99 C99ReprType -- +C99 +C99LocalResource ] {
    >local-resource-repr
    fresh-resource-name! >local-resource-name
    c99-line(
        @local-resource-repr underlying-c99-type put " " put
        @local-resource-name put " = " put
        @local-resource-repr match {
            { C99RT_VAL -> "pop_resource()" put }
            { _ -> v-macro put "(pop_resource())" put }
        }
        ";" put
    )
    +C99LocalResource
}

def +C99LocalResource.push-local-resource-direct! [ +C99 +C99LocalResource -- +C99 ] {
    /+C99LocalResource
    c99-line(
        "push_resource(" put
        local-resource-repr> match {
            { C99RT_VAL -> local-resource-name> put }
            { _ -> mk-macro put "(" put local-resource-name> put ")" put }
        }
        ");" put
    )
}

def +C99LocalResource.peek-data-tag [ +C99LocalResource -- +C99LocalResource Str ] {
    local-resource-repr match {
        { C99RT_VAL -> local-resource-name Str("get_data_tag(" ; ; ")" ;) }
        { _ -> drop local-resource-name }
    }
}

data +C99LocalValue/Resource {
    +Left  [ +C99Local ]
    +Right [ +C99LocalResource ]
}

def +C99Local.>Value/Resource { +C99LocalValue/Resource.+Left }
def +C99LocalResource.>Value/Resource { +C99LocalValue/Resource.+Right }
def +C99LocalValue/Resource.push-local-value/resource! {
    { +Left -> push-local! }
    { +Right -> push-local-resource! }
}
def +C99LocalValue/Resource.peek-data-tag [ +C99LocalValue/Resource -- +C99LocalValue/Resource Str ] {
    { +Left -> peek-data-tag +Left }
    { +Right -> peek-data-tag +Right }
}
def +C99LocalValue/Resource.rdup [ +C99LocalValue/Resource -- +C99LocalValue/Resource +C99LocalValue/Resource ] {
    { +Left -> rdup +Left rdip(+Left) }
    { +Right -> rdup +Right rdip(+Right) }
}
def +C99LocalValue/Resource.rdrop  [ +C99LocalValue/Resource -- ] {
    { +Left -> rdrop }
    { +Right -> rdrop }
}
def +C99LocalValue/Resource.consume-as-VAL [ +C99LocalValue/Resource -- Str ] {
    { +Left -> consume-as-VAL }
    { +Right -> consume-as-VAL }
}

def +C99Branch.pop-local-value/resource-data! [ Data +C99Branch -- +C99Branch +C99LocalValue/Resource ] {
    dup is-resource? if(
        +core:+mirth:c99-repr pop-to-local-resource! +C99LocalValue/Resource.+Right,
        +core:+mirth:c99-repr pop-to-local! +C99LocalValue/Resource.+Left
    )
}

data +C99Local? {
    +C99LocalNone
    +C99LocalSome [ +C99Local ]
}

data +C99LocalResource? {
    +C99LocalResourceNone
    +C99LocalResourceSome [ +C99LocalResource ]
}

data +C99StackCache {
    +SCNil
    +SCCons [ +C99StackCache +C99Local ]
    +SCWith [ +C99StackCache +C99LocalResource ]
    +SCConsLabel [ +C99StackCache +C99Local Label ]
    +SCWithLabel [ +C99StackCache +C99LocalResource Label ]
}

def +C99StackCache.pop-local? [ +C99StackCache -- +C99Local? +C99StackCache ] {
    { +SCNil -> +C99LocalNone +SCNil }
    { +SCCons -> +C99LocalSome rswap }
    { +SCWith -> rdip:pop-local? +SCWith }
    { +SCConsLabel -> rdip:pop-local? +SCConsLabel }
    { +SCWithLabel -> rdip:pop-local? +SCWithLabel }
}

def +C99StackCache.pop-local-resource? [ +C99StackCache -- +C99LocalResource? +C99StackCache ] {
    { +SCNil -> +C99LocalResourceNone +SCNil }
    { +SCWith -> +C99LocalResourceSome rswap }
    { +SCCons -> rdip:pop-local-resource? +SCCons }
    { +SCConsLabel -> rdip:pop-local-resource? +SCConsLabel }
    { +SCWithLabel -> rdip:pop-local-resource? +SCWithLabel }
}

def +C99StackCache.pop-local-label? [ Label +C99StackCache -- Label +C99Local? +C99StackCache ] {
    { +SCNil -> +C99LocalNone +SCNil }
    { +SCCons -> rdip:pop-local-label? +SCCons }
    { +SCWith -> rdip:pop-local-label? +SCWith }
    { +SCWithLabel -> dip:rdip:pop-local-label? +SCWithLabel }
    { +SCConsLabel ->
        dup2 == if(
            drop +C99LocalSome rswap,
            dip:rdip:pop-local-label? +SCConsLabel
        )
    }
}

def +C99StackCache.pop-local-resource-label? [ Label +C99StackCache -- Label +C99LocalResource? +C99StackCache ] {
    { +SCNil -> +C99LocalResourceNone +SCNil }
    { +SCCons -> rdip:pop-local-resource-label? +SCCons }
    { +SCWith -> rdip:pop-local-resource-label? +SCWith }
    { +SCConsLabel -> dip:rdip:pop-local-resource-label? +SCConsLabel }
    { +SCWithLabel ->
        dup2 == if(
            drop +C99LocalResourceSome rswap,
            dip:rdip:pop-local-resource-label? +SCWithLabel
        )
    }
}

def +C99StackCache.flush-all! [ +C99 +C99StackCache -- +C99 ] {
    { +SCNil -> }
    { +SCCons -> rdip:flush-all! push-local-direct! }
    { +SCWith -> rdip:flush-all! push-local-resource-direct! }
    { +SCConsLabel -> rdip:flush-all! push-local-label-direct! }
    { +SCWithLabel -> rdip:flush-all! push-local-resource-label-direct! }
}

def +C99StackCache.rdup [ +C99StackCache -- +C99StackCache +C99StackCache ] {
    { +SCNil -> +SCNil +SCNil }
    { +SCCons -> rdip:rdup rdup rdip:rswap +SCCons rdip:+SCCons }
    { +SCWith -> rdip:rdup rdup rdip:rswap +SCWith rdip:+SCWith }
    { +SCConsLabel -> dup rdip:rdup rdup rdip:rswap +SCConsLabel rdip:+SCConsLabel }
    { +SCWithLabel -> dup rdip:rdup rdup rdip:rswap +SCWithLabel rdip:+SCWithLabel }
}

def +C99StackCache.rdrop [ +C99StackCache -- ] {
    { +SCNil -> }
    { +SCCons -> rdrop rdrop }
    { +SCWith -> rdrop rdrop }
    { +SCConsLabel -> drop rdrop rdrop }
    { +SCWithLabel -> drop rdrop rdrop }
}

struct +C99BranchSplit {
    +core: +C99
    +stack: +C99StackCache
}

def +C99Branch.begin-branch-split! [ +C99Branch -- +C99BranchSplit ] {
    /+C99Branch +C99BranchSplit
}
def +C99BranchSplit.end-branch-split! [ +C99BranchSplit -- +C99Branch ] {
    /+C99BranchSplit
    +stack> rdrop
    +core> start-branch!
}
def +C99BranchSplit.sub-branch(f)
    [ (*a +C99Branch -- *b +C99Branch) *a +C99BranchSplit -- *b +C99BranchSplit ]
    { /+C99BranchSplit +stack> rdup >+stack
      rdip(+C99Branch f end-branch! >+core) >+stack +C99BranchSplit }

inline (
    def +C99BranchSplit.c99-line(f) { +core:c99-line(f) }
    def +C99BranchSplit.c99-nest(f) { +core:depth:1+ f +C99BranchSplit.+core:depth:1- }
)

struct +C99Branch {
    +core: +C99
    +stack: +C99StackCache
}

def +C99.start-branch! [ +C99 -- +C99Branch ] {
    >+core +SCNil >+stack +C99Branch
}

def +C99Branch.end-branch! [ +C99Branch -- +C99 ] {
    /+C99Branch +core> +stack> flush-all!
}

def +C99Branch.flush-cache! [ +C99Branch -- +C99Branch ] {
    end-branch!
    start-branch!
}

def +C99Branch.pop-to-local! [ +C99Branch C99ReprType -- +C99Branch +C99Local ] {
    +stack(pop-local?) rswap match {
        { +C99LocalSome -> drop }
        { +C99LocalNone -> +core(pop-to-local-direct! rswap) rswap }
    }
}

def +C99Branch.pop-to-local-label! [ C99ReprType Label +C99Branch -- +C99Branch +C99Local ] {
    +stack(pop-local-label?) rswap match {
        { +C99LocalSome -> drop2 }
        { +C99LocalNone -> +core(pop-local-label-direct! rswap) rswap }
    }
}

def +C99Branch.pop-to-local-resource! [ +C99Branch C99ReprType -- +C99Branch +C99LocalResource ] {
    +stack(pop-local-resource?) rswap match {
        { +C99LocalResourceSome -> drop }
        { +C99LocalResourceNone -> +core(pop-local-resource-direct! rswap) rswap }
    }
}

def +C99Branch.pop-to-local-resource-label! [ C99ReprType Label +C99Branch -- +C99Branch +C99LocalResource ] {
    +stack(pop-local-resource-label?) rswap match {
        { +C99LocalResourceSome -> drop2 }
        { +C99LocalResourceNone -> +core(pop-local-resource-label-direct! rswap) rswap }
    }
}

def +C99Local.push-local! [ +C99Branch +C99Local -- +C99Branch ] {
    rswap +stack(rswap +SCCons)
}

def +C99LocalResource.push-local-resource! [ +C99Branch +C99LocalResource -- +C99Branch ] {
    rswap +stack(rswap +SCWith)
}

struct C99BinOp {
    prefix: Str
    operator: Str
    suffix: Str
    arg1-type: C99ReprType
    arg2-type: C99ReprType
    args-swapped: Bool
    out-type: Maybe(C99ReprType)
}

def c99-binop-expr! [ C99BinOp +arg1:+C99Local +arg2:+C99Local +C99 -- +C99 ] {
    /C99BinOp
    prefix> put
    +arg1> arg1-type> consume-as put
    operator> put
    +arg2> arg2-type> consume-as put
    suffix> put
    args-swapped> drop
    out-type> drop
}

def c99-binop! [ C99BinOp +C99Branch -- +C99Branch ] {
    dup args-swapped if(
        dup arg1-type pop-to-local! >+arg1
        dup arg2-type pop-to-local! >+arg2,

        dup arg2-type pop-to-local! >+arg2
        dup arg1-type pop-to-local! >+arg1
    )

    dup out-type match {
        { Some -> push-expression!(c99-binop-expr!) }
        { None -> c99-line(c99-binop-expr!) }
    }
}

def C99BinOp.Mk [ Str C99ReprType Str C99ReprType Str Bool Maybe(C99ReprType) -- C99BinOp ] {
    >out-type >args-swapped
    >suffix >arg2-type >operator >arg1-type >prefix
    C99BinOp
}

def c99-prim-binop? [ Prim -- Maybe(C99BinOp) ] {
    { PRIM_INT_ADD -> "i64_add(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some C99BinOp.Mk Some }
    { PRIM_INT_SUB -> "i64_sub(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some C99BinOp.Mk Some }
    { PRIM_INT_MUL -> "i64_mul(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some C99BinOp.Mk Some }
    { PRIM_INT_DIV -> "i64_div(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some C99BinOp.Mk Some }
    { PRIM_INT_MOD -> "i64_mod(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some C99BinOp.Mk Some }
    { PRIM_INT_SHL -> "u64_shl(" C99RT_U64 ", " C99RT_U64 ")" False C99RT_U64 Some C99BinOp.Mk Some }
    { PRIM_INT_SHR -> "u64_shr(" C99RT_U64 ", " C99RT_U64 ")" False C99RT_U64 Some C99BinOp.Mk Some }
    { PRIM_INT_LT  -> "(" C99RT_I64 " < "  C99RT_I64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_INT_LE  -> "(" C99RT_I64 " <= " C99RT_I64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_INT_GT  -> "(" C99RT_I64 " > "  C99RT_I64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_INT_GE  -> "(" C99RT_I64 " >= " C99RT_I64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_INT_NE  -> "(" C99RT_I64 " != " C99RT_I64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_INT_EQ  -> "(" C99RT_I64 " == " C99RT_I64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_INT_AND -> "(" C99RT_U64 " & "  C99RT_U64 ")" False C99RT_U64  Some C99BinOp.Mk Some }
    { PRIM_INT_XOR -> "(" C99RT_U64 " ^ "  C99RT_U64 ")" False C99RT_U64  Some C99BinOp.Mk Some }
    { PRIM_INT_OR  -> "(" C99RT_U64 " | "  C99RT_U64 ")" False C99RT_U64  Some C99BinOp.Mk Some }

    { PRIM_F32_ADD -> "(" C99RT_F32 " + "  C99RT_F32 ")" False C99RT_F32  Some C99BinOp.Mk Some }
    { PRIM_F32_SUB -> "(" C99RT_F32 " - "  C99RT_F32 ")" False C99RT_F32  Some C99BinOp.Mk Some }
    { PRIM_F32_MUL -> "(" C99RT_F32 " * "  C99RT_F32 ")" False C99RT_F32  Some C99BinOp.Mk Some }
    { PRIM_F32_DIV -> "(" C99RT_F32 " / "  C99RT_F32 ")" False C99RT_F32  Some C99BinOp.Mk Some }
    { PRIM_F32_LT  -> "(" C99RT_F32 " < "  C99RT_F32 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_F32_EQ  -> "(" C99RT_F32 " == " C99RT_F32 ")" False C99RT_BOOL Some C99BinOp.Mk Some }

    { PRIM_F64_ADD -> "(" C99RT_F64 " + "  C99RT_F64 ")" False C99RT_F64  Some C99BinOp.Mk Some }
    { PRIM_F64_SUB -> "(" C99RT_F64 " - "  C99RT_F64 ")" False C99RT_F64  Some C99BinOp.Mk Some }
    { PRIM_F64_MUL -> "(" C99RT_F64 " * "  C99RT_F64 ")" False C99RT_F64  Some C99BinOp.Mk Some }
    { PRIM_F64_DIV -> "(" C99RT_F64 " / "  C99RT_F64 ")" False C99RT_F64  Some C99BinOp.Mk Some }
    { PRIM_F64_LT  -> "(" C99RT_F64 " < "  C99RT_F64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_F64_EQ  -> "(" C99RT_F64 " == " C99RT_F64 ")" False C99RT_BOOL Some C99BinOp.Mk Some }

    { PRIM_BOOL_AND -> "(" C99RT_BOOL " && " C99RT_BOOL ")" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_BOOL_OR  -> "(" C99RT_BOOL " || " C99RT_BOOL ")" False C99RT_BOOL Some C99BinOp.Mk Some }

    { PRIM_STR_COPY -> "str_make(" C99RT_PTR ", " C99RT_U64 ")" False C99RT_STR Some C99BinOp.Mk Some }
    { PRIM_STR_CMP -> "str_cmp(" C99RT_STR ", " C99RT_STR ")" False C99RT_I64 Some C99BinOp.Mk Some }
    { PRIM_STR_EQ  -> "(str_cmp(" C99RT_STR ", " C99RT_STR ") == 0)" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_STR_LT  -> "(str_cmp(" C99RT_STR ", " C99RT_STR ") < 0)"  False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_STR_LE  -> "(str_cmp(" C99RT_STR ", " C99RT_STR ") <= 0)" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_STR_GT  -> "(str_cmp(" C99RT_STR ", " C99RT_STR ") > 0)"  False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_STR_GE  -> "(str_cmp(" C99RT_STR ", " C99RT_STR ") >= 0)" False C99RT_BOOL Some C99BinOp.Mk Some }
    { PRIM_STR_NE  -> "(str_cmp(" C99RT_STR ", " C99RT_STR ") != 0)" False C99RT_BOOL Some C99BinOp.Mk Some }

    { PRIM_PTR_REALLOC -> "ptr_realloc(" C99RT_PTR "," C99RT_U64 ")" False C99RT_PTR Some C99BinOp.Mk Some }
    { PRIM_PTR_ADD -> "(void*)(" C99RT_I64 " + (char*)" C99RT_PTR ")" False C99RT_PTR Some C99BinOp.Mk Some }
    { PRIM_PTR_EQ  -> "(" C99RT_PTR " == " C99RT_PTR ")" False C99RT_BOOL Some C99BinOp.Mk Some }

    { PRIM_PACK_CONS -> "mkcons(" C99RT_VAL ", " C99RT_VAL ")" False C99RT_VAL Some C99BinOp.Mk Some }

    # { PRIM_F32_SET -> "*(float*)"    C99RT_PTR " = " C99RT_F32 ";" True None C99BinOp.Mk Some }
    # { PRIM_F64_SET -> "*(double*)"   C99RT_PTR " = " C99RT_F64 ";" True None C99BinOp.Mk Some }
    { PRIM_U64_SET -> "*(uint64_t*)" C99RT_PTR " = " C99RT_U64 ";" True None C99BinOp.Mk Some }
    { PRIM_U32_SET -> "*(uint32_t*)" C99RT_PTR " = " C99RT_U32 ";" True None C99BinOp.Mk Some }
    { PRIM_U16_SET -> "*(uint16_t*)" C99RT_PTR " = " C99RT_U16 ";" True None C99BinOp.Mk Some }
    { PRIM_U8_SET  -> "*(uint8_t*)"  C99RT_PTR " = " C99RT_U8  ";" True None C99BinOp.Mk Some }
    { PRIM_I64_SET -> "*(int64_t*)"  C99RT_PTR " = " C99RT_I64 ";" True None C99BinOp.Mk Some }
    { PRIM_I32_SET -> "*(int32_t*)"  C99RT_PTR " = " C99RT_I32 ";" True None C99BinOp.Mk Some }
    { PRIM_I16_SET -> "*(int16_t*)"  C99RT_PTR " = " C99RT_I16 ";" True None C99BinOp.Mk Some }
    { PRIM_I8_SET  -> "*(int8_t*)"   C99RT_PTR " = " C99RT_I8  ";" True None C99BinOp.Mk Some }
    { PRIM_PTR_SET -> "*(void**)"    C99RT_PTR " = " C99RT_PTR ";" True None C99BinOp.Mk Some }

    { _ -> drop None }
}

struct C99UnOp {
    prefix:   Str
    arg-type: C99ReprType
    suffix:   Str
    out-type: Maybe(C99ReprType)
}

def c99-unop-expr! [ C99UnOp +arg:+C99Local +C99 -- +C99 ] {
    /C99UnOp
    prefix> put
    +arg> arg-type> consume-as put
    suffix> put
    out-type> drop
}

def c99-unop! [ C99UnOp +C99Branch -- +C99Branch ] {
    dup arg-type pop-to-local! >+arg
    dup out-type match {
        { Some -> push-expression!(c99-unop-expr!) }
        { None -> c99-line(c99-unop-expr!) }
    }
}

def C99UnOp.Mk [ Str C99ReprType Str Maybe(C99ReprType) -- C99UnOp ] {
    >out-type >suffix >arg-type >prefix C99UnOp
}

def c99-prim-unop? [ Prim -- Maybe(C99UnOp) ] {
    { PRIM_BOOL_NOT -> "!" C99RT_BOOL "" C99RT_BOOL Some C99UnOp.Mk Some }
    { PRIM_I64_GET  -> "*(int64_t*)"  C99RT_PTR "" C99RT_I64 Some C99UnOp.Mk Some }
    { PRIM_I32_GET  -> "*(int32_t*)"  C99RT_PTR "" C99RT_I32 Some C99UnOp.Mk Some }
    { PRIM_I16_GET  -> "*(int16_t*)"  C99RT_PTR "" C99RT_I16 Some C99UnOp.Mk Some }
    { PRIM_I8_GET   -> "*(int8_t*)"   C99RT_PTR "" C99RT_I8  Some C99UnOp.Mk Some }
    { PRIM_U64_GET  -> "*(uint64_t*)" C99RT_PTR "" C99RT_U64 Some C99UnOp.Mk Some }
    { PRIM_U32_GET  -> "*(uint32_t*)" C99RT_PTR "" C99RT_U32 Some C99UnOp.Mk Some }
    { PRIM_U16_GET  -> "*(uint16_t*)" C99RT_PTR "" C99RT_U16 Some C99UnOp.Mk Some }
    { PRIM_U8_GET   -> "*(uint8_t*)"  C99RT_PTR "" C99RT_U8  Some C99UnOp.Mk Some }
    { PRIM_PTR_GET  -> "*(void**)"    C99RT_PTR "" C99RT_PTR Some C99UnOp.Mk Some }

    { PRIM_INT_TO_F32 -> "(float)"   C99RT_I64 ""  C99RT_F32 Some C99UnOp.Mk Some }
    { PRIM_INT_TO_F64 -> "(double)"  C99RT_I64 ""  C99RT_F64 Some C99UnOp.Mk Some }
    { PRIM_INT_TO_STR -> "i64_show(" C99RT_I64 ")" C99RT_STR Some C99UnOp.Mk Some }
    { PRIM_F32_TO_INT -> "(int64_t)" C99RT_F32 ""  C99RT_I64 Some C99UnOp.Mk Some }
    { PRIM_F32_TO_F64 -> "(double)"  C99RT_F32 ""  C99RT_F64 Some C99UnOp.Mk Some }
    { PRIM_F32_TO_STR -> "f32_show(" C99RT_F32 ")" C99RT_STR Some C99UnOp.Mk Some }
    { PRIM_F64_TO_INT -> "(int64_t)" C99RT_F64 ""  C99RT_I64 Some C99UnOp.Mk Some }
    { PRIM_F64_TO_F32 -> "(float)"   C99RT_F64 ""  C99RT_F32 Some C99UnOp.Mk Some }
    { PRIM_F64_TO_STR -> "f64_show(" C99RT_F64 ")" C99RT_STR Some C99UnOp.Mk Some }

    { PRIM_PTR_ALLOC -> "ptr_alloc(" C99RT_U64 ");" C99RT_PTR Some C99UnOp.Mk Some }
    { PRIM_PTR_FREE -> "free(" C99RT_PTR ");" None C99UnOp.Mk Some }

    { _ -> drop None }
}

def +C99Branch.type-to-c99-repr [ Type +C99Branch -- C99ReprType +C99Branch ] { +core:+mirth:c99-repr }
def +C99Branch.resource-to-c99-repr [ Resource +C99Branch -- C99ReprType +C99Branch ] { +core:+mirth:c99-repr }

def +C99Branch.pop-local-from-stack-type! [ StackType +C99Branch -- StackType +C99Branch +C99Local ] {
    force-cons?! unwrap unpack2
    type-to-c99-repr pop-to-local!
}
def +C99Branch.pop-local-resource-from-stack-type! [ StackType +C99Branch -- StackType +C99Branch +C99LocalResource ] {
    force-with?! unwrap unpack2
    resource-to-c99-repr pop-to-local-resource!
}

def +C99Branch.pop-local-label-from-stack-type! [ Label StackType +C99Branch -- StackType +C99Branch +C99Local ] {
    dip:dup force-cons-label?! unwrap unpack2 type-to-c99-repr
    rotl pop-to-local-label!
}

def +C99Branch.pop-local-resource-label-from-stack-type! [ Label StackType +C99Branch -- StackType +C99Branch +C99LocalResource ] {
    dip:dup force-with-label?! unwrap unpack2 resource-to-c99-repr
    rotl pop-to-local-resource-label!
}

def c99-prim! [ Atom Prim +C99Branch -- +C99Branch ] {
    { PRIM_CORE_ID -> drop }
    { PRIM_CORE_DROP ->
        dom pop-local-from-stack-type! drop
        drop-local!
    }
    { PRIM_CORE_DUP ->
        dom pop-local-from-stack-type! drop
        dup-local! rdip:push-local! push-local!
    }
    { PRIM_CORE_SWAP ->
        dom
        pop-local-from-stack-type! >+b
        pop-local-from-stack-type! >+a
        drop
        +b> push-local!
        +a> push-local!
    }
    { PRIM_CORE_RSWAP ->
        dom
        pop-local-resource-from-stack-type! >+b
        pop-local-resource-from-stack-type! >+a
        drop
        +b> push-local-resource!
        +a> push-local-resource!
    }
    { PRIM_CORE_DIP ->
        dup args /L1 match(
            Some ->
                swap dom pop-local-from-stack-type! drop >+dipped
                c99-arg-run!
                +dipped> push-local!,
            None ->
                args PRIM_CORE_DIP c99-prim-default!
        )
    }
    { PRIM_CORE_RDIP ->
        dup args /L1 match(
            Some ->
                swap dom pop-local-resource-from-stack-type! drop >+dipped
                c99-arg-run!
                +dipped> push-local-resource!,
            None ->
                args PRIM_CORE_RDIP c99-prim-default!
        )
    }
    { PRIM_CORE_IF ->
        args dup /L2 match(
            Some ->
                nip unpack2
                C99RT_BOOL pop-to-local! >+cond

                begin-branch-split!
                c99-line("if (" put +cond> C99RT_BOOL consume-as put ") {" put)
                c99-nest:sub-branch(swap c99-arg-run!)
                c99-line("} else {" put)
                c99-nest:sub-branch(c99-arg-run!)
                c99-line("}" put)
                end-branch-split!,
            None ->
                PRIM_CORE_IF c99-prim-default!
        )
    }
    { PRIM_CORE_WHILE ->
        args dup /L2 match(
            Some ->
                nip unpack2
                end-branch!
                c99-line("while(1) {" put)
                c99-nest(
                    start-branch!
                    swap c99-arg-run!
                    C99RT_BOOL pop-to-local! >+cond
                    end-branch!
                    c99-line("if (!" put +cond> C99RT_BOOL consume-as put ") break;" put)
                    start-branch!
                    c99-arg-run!
                    end-branch!
                )
                c99-line("}" put)
                start-branch!,

            None ->
                PRIM_CORE_WHILE c99-prim-default!
        )
    }
    { PRIM_CORE_RUN ->
        assert!(dup args empty?, "expected no arguments to prim-core-run") drop
        C99RT_VAL pop-to-local! >+closure
        flush-cache!
        c99-line("run_value(" put +closure> consume-as-VAL put ");" put)
    }

    { PRIM_PACK_NIL -> drop C99RT_VAL push-expression!("MKNIL" put) }
    { PRIM_PACK_UNCONS ->
        drop
        C99RT_VAL pop-to-local! >+cons
        C99RT_VAL new-local! >+tail
        C99RT_VAL new-local! >+head
        c99-line (
            "value_uncons(" put
            +cons> consume-as-VAL put
            ", &" put
            @+tail:local-name put
            ", &" put
            @+head:local-name put
            ");" put
        )
        +tail> push-local!
        +head> push-local! }

    { PRIM_PTR_NIL -> drop C99RT_PTR push-expression!("(void*)0" put) }
    { PRIM_PTR_SIZE -> drop C99RT_U64 push-expression!("sizeof(void*)" put) }
    { PRIM_PTR_COPY ->
        drop
        C99RT_PTR pop-to-local! >+dst
        C99RT_U64 pop-to-local! >+len
        C99RT_PTR pop-to-local! >+src
        c99-line (
            "ptr_copy(" put
                +src> C99RT_PTR consume-as put
            ", " put
                +len> C99RT_U64 consume-as put
            ", " put
                +dst> C99RT_PTR consume-as put
            ");" put
        )
    }
    { PRIM_PTR_FILL ->
        drop
        C99RT_PTR pop-to-local! >+dst
        C99RT_U64 pop-to-local! >+len
        C99RT_U8  pop-to-local! >+val
        c99-line (
            "ptr_fill(" put
                +val> C99RT_U8  consume-as put
            ", " put
                +len> C99RT_U64 consume-as put
            ", " put
                +dst> C99RT_PTR consume-as put
            ");" put
        )
    }

    { _ ->
        dip(args) over empty? if(
            dup c99-prim-binop? if-some(
                dip:drop2 c99-binop!,
            dup c99-prim-unop? if-some(
                dip:drop2 c99-unop!,
                c99-prim-default!
            )),
            c99-prim-default!
        )
    }
}

def(c99-prim-default!, List(Arg) Prim +C99Branch -- +C99Branch,
    cname c99-call!)

def(c99-args-push!, List(Arg) +C99Branch -- +C99Branch,
    for(c99-arg-push!))

def(c99-arg-push!, Arg +C99Branch -- +C99Branch,
    ArgBlock -> c99-block-push!)

def(c99-arg-run!, Arg +C99Branch -- +C99Branch,
    ArgBlock -> c99-block-run!)

def(c99-block-run!, Block +C99Branch -- +C99Branch,
    +core:+mirth:arrow c99-arrow!)

def(+C99.var-put, Var +C99 -- +C99, "var_" put name mangled put)

def(c99-pack-closure-vars!, List(Var) +C99Branch -- +C99Branch,
    filter(is-physical?) for(
        c99-var-push!
        L0 PRIM_PACK_CONS c99-prim-default!
    ))

def c99-pop-to-var! [ Var +C99Branch -- +C99Branch ] {
    dup .type +core:+mirth:c99-repr pop-to-local! consume-as-VAL swap
    +core:c99-line("VAL " put var-put " = " put put ";" put)
}

def(c99-unpack-closure-vars!, List(Var) +C99Branch -- +C99Branch,
    filter(is-physical?) dup empty? if(
        drop,
        reverse-for(
            L0 PRIM_PACK_UNCONS c99-prim-default!
            c99-pop-to-var!
        )
        L0 PRIM_CORE_DROP c99-prim-default!
    ))

def(c99-decref-closure-vars!, List(Var) +C99Branch -- +C99Branch,
    filter(is-physical?) reverse-for(
        +core:c99-line("decref(" put var-put ");" put)
    ))

def(c99-block-push!, Block +C99Branch -- +C99Branch,
    dup +core:+mirth:to-run-var match(
        Some -> nip c99-var-push!,
        None ->
            C99RT_FNPTR push-expression!("&" put dup +mirth:cname put)
            dup +core:+mirth:free-vars c99-pack-closure-vars!
            drop
    ))

def(c99-var!, Var +C99Branch -- +C99Branch,
    dup auto-run? if(c99-var-run!, c99-var-push!))


def(c99-var-run!, Var +C99Branch -- +C99Branch,
    flush-cache!
    +core:c99-line("incref(" put dup var-put ");" put)
    +core:c99-line("run_value(" put dup var-put ");" put)
    drop)

def(c99-var-push!, Var +C99Branch -- +C99Branch,
    +core:c99-line("incref(" put dup var-put ");" put)
    C99RT_VAL push-expression!(dup var-put)
    drop)

def(c99-lambda!, Lambda +C99Branch -- +C99Branch,
    end-branch!
    c99-line("{" put)
    c99-nest(
        start-branch!
        dup params reverse-for(c99-pop-to-var!)
        dup body c99-arrow!
        params reverse-for(
            +core:c99-line("decref(" put var-put ");" put)
        )
        end-branch!
    )
    c99-line("}" put)
    start-branch!)

def(c99-match!, Match +C99Branch -- +C99Branch,
    dup is-transparent? if(
        cases first unwrap body c99-arrow!,

    dup semi-transparent-tag? if-some(
        dip:L0 +core:+mirth:pat-cname c99-call!
        cases first unwrap body c99-arrow!,

    dup unit-tag? if-some(
        .data pop-local-value/resource-data! rdrop
        cases first unwrap body c99-arrow!,

    dup cases /L1 if-some(
        nip c99-single-case!,

        dup scrutinee-data?
        unwrap(token "non-uniform match, not supported at present" +core:+mirth:emit-fatal-error!)
        pop-local-value/resource-data! >+scrutinee
        begin-branch-split!
        c99-line("switch (" put @+scrutinee:peek-data-tag put ") {" put)
        c99-nest(
            dup cases for(@+scrutinee:rdup >+scrutinee c99-case!)
            has-default-case? else(
                c99-line("default: {" put)
                c99-nest:sub-branch(
                    c99-line("push_value(mkstr(\"unexpected fallthrough in match\\n\", 32));" put)
                    L0 PRIM_CORE_PANIC c99-prim-default!
                )
                c99-line("}" put)
            )
            +scrutinee> rdrop
        )
        c99-line("}" put)
        end-branch-split!
    )))))

def c99-single-case! [ Case +C99Branch -- +C99Branch ] {
    dup pattern is-default? if(
        body c99-arrow!,

    dup pattern single-tag? if-some(
        c99-reverse-tag!
        body c99-arrow!,

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +core:+mirth:emit-fatal-error!
    ))
}

def c99-case! [ Case +C99BranchSplit +scrutinee:+C99LocalValue/Resource -- +C99BranchSplit ] {
    dup pattern is-default? if(
        c99-line("default: {" put)
        c99-nest:sub-branch(
            +scrutinee> push-local-value/resource!
            body c99-arrow!
        )
        c99-line("} break;" put),

    dup pattern single-tag? if-some(
        c99-line("case " put dup value-show put "LL: { // " put dup name >Str put)
        c99-nest:sub-branch(
            +scrutinee> push-local-value/resource!
            c99-reverse-tag!
            body c99-arrow!
        )
        c99-line("} break;" put),

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +core:+mirth:emit-fatal-error!
    ))
}

def(c99-word-sigs!, +C99 -- +C99, Word.for(dup +needs(needed?) if(c99-word-sig!, drop)))
def(c99-word-sig!, Word +C99 -- +C99, c99-line(+mirth:cname sig-put ";" put))

def(c99-block-sigs!, +C99 -- +C99, Block.for(dup +needs(needed?) if(c99-block-sig!, drop)))
def(c99-block-sig!, Block +C99 -- +C99, c99-line(+mirth:cname sig-put ";" put))

def(c99-field-sigs!, +C99 -- +C99, Field.for(c99-field-sig!))
def(c99-field-sig!, Field +C99 -- +C99, c99-line(+mirth:cname sig-put ";" put))

def(c99-block-enter!, Block +C99 -- +C99Branch,
    options emit-debug-info if(
        c99-line("WORD_ENTER(" put
            dup +mirth:cname put ", " put
            dup home match(
                HomeMain -> drop "block",
                HomeWord -> name >Str " block" cat,
            ) put-cstr ", " put
            dup token .module source-path >Str put-cstr ", " put
            dup token row >Int show put ", " put
            dup token col >Int show put ");" put
        ) drop,
        drop
    )
    start-branch!)

def(c99-block-exit!, Block +C99Branch -- +C99,
    end-branch!
    options emit-debug-info if(
        c99-line("WORD_EXIT(" put +mirth:cname put ");" put),
        drop
    ))

def(c99-block-defs!, +C99 -- +C99, Block.for(dup +needs(needed?) if(c99-block-def!, drop)))
def(c99-block-def!, Block +C99 -- +C99,
    c99-line(dup +mirth:cname sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-block-enter!
        dup +core:+mirth:arrow
        dup +core:+mirth:free-vars c99-unpack-closure-vars!
        dup c99-arrow!
        +core:+mirth:free-vars c99-decref-closure-vars!
        c99-block-exit!
    )
    c99-line("}" put))

def(c99-word-enter!, Word +C99 -- +C99Branch,
    options emit-debug-info if(
        c99-line(
            "WORD_ENTER(" put
            dup +mirth:cname put ", " put
            dup name >Str put-cstr ", " put
            dup body .module source-path >Str put-cstr ", " put
            dup body row >Int show put ", " put
            dup body col >Int show put ");" put
        ) drop,
        drop
    )
    start-branch!)

def(c99-word-exit!, Word +C99Branch -- +C99,
    end-branch!
    options emit-debug-info if(
        c99-line("WORD_EXIT(" put +mirth:cname put ");" put),
        drop
    ))

def(c99-word-defs!, +C99 -- +C99, Word.for(dup +needs(needed?) if(c99-word-def!, drop)))
def(c99-word-def!, Word +C99 -- +C99,
    c99-line(dup +mirth:cname sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-word-enter!
        dup +core:+mirth:arrow c99-arrow!
        dup c99-word-exit!
    )
    c99-line("}" put)
    drop)

def(c99-field-defs!, +C99 -- +C99, Field.for(c99-field-def!))
def(c99-field-def!, Field +C99 -- +C99,
    dup +mirth:cname sig-put " {" put line
    reset-fresh-counter!
    "\tsize_t i = (size_t)pop_u64();" put line
    "\tstatic struct VAL * p = 0;" put line
    "\tsize_t m = " put TABLE_MAX_COUNT show put ";" put line
    "\tif (! p) { p = calloc(m, sizeof *p); }" put line
    "\tEXPECT(i<m, \"table grew too big\");" put line
    "\tpush_ptr(p+i);" put line
    "}" put line line
    drop)

def(c99-main!, Arrow +C99 -- +C99,
    c99-line("int main (int argc, char** argv) {" put)
    reset-fresh-counter!
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        options emit-debug-info then(
            c99-line("WORD_ENTER(" put
                "(void(*)(void))0, " put
                "\"<main>\", " put
                dup token-start .module source-path >Str put-cstr ", " put
                dup token-start row >Int show put ", " put
                dup token-start col >Int show put ");" put)
        )
        start-branch!
        C99RT_I64 push-resource-expression!("0 /* The World! */" put)
        c99-arrow!
        end-branch!
        options emit-debug-info then(
            c99-line("WORD_EXIT((void(*)(void))0);" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put))
