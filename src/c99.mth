module mirth.c99

import std.prelude
import std.str
import std.path
import std.list
import std.byte
import std.maybe
import std.either
import std.file
import std.output

import mirth.mirth
import mirth.module
import mirth.location
import mirth.token
import mirth.name
import mirth.buffer
import mirth.arrow
import mirth.word
import mirth.table
import mirth.variable
import mirth.external
import mirth.tycon
import mirth.type
import mirth.data
import mirth.package
import mirth.prim
import mirth.var
import mirth.match
import mirth.elab
import mirth.need
import mirth.label
import mirth.def

#######
# C99 #
#######

struct C99_Options {
    output-path: Path
    emit-debug-info: Bool
}

struct +C99 {
    options: C99_Options
    depth: Nat
    fresh-counter: Nat
    put-enabled: Bool
    +needs: +Needs
    +output: +Output
    +mirth: +Mirth
}

def +C99.put [ Str +C99 -- +C99 ] { put-enabled if(+output:put, drop) }
def +C99.put-byte [ Byte +C99 -- +C99 ] { put-enabled if(+output:put-byte, drop) }
def +C99.line [ +C99 -- +C99 ] { put-enabled then(+output:line) }

def c99-start! [ Arrow C99_Options +World +Mirth -- Arrow +World +C99 ] {
    >options
    0u >depth
    0u >fresh-counter
    True >put-enabled
    +Needs.new dup determine-arrow-needs! >+needs >+mirth
    @options output-path create-file! +else(+mirth> fatal-error!) +Output.start! >+output
    +C99
}

def c99-end! [ +World +C99 -- +World +Mirth ] {
    /+C99
    depth> fresh-counter> options> drop3
    put-enabled> drop
    +needs> rdrop
    +output> end! close-file!
    +mirth>
}

def +C99.reset-fresh-counter! [ +C99 -- +C99 ] {
    0u fresh-counter!
}

def +C99.fresh-nat! [ +C99 -- Nat +C99 ] {
    fresh-counter
    dup 1+ fresh-counter!
}

def +C99.with-fresh-counter(f) [ ( *a +C99 -- *b +C99 ) *a Nat +C99 -- *b Nat +C99 ] {
    fresh-counter dip(fresh-counter! f fresh-counter) fresh-counter!
}

def +C99.fresh-name! [ +C99 -- Str +C99 ] {
    "v" fresh-name-on!
}

def +C99.fresh-resource-name! [ +C99 -- Str +C99 ] {
    "r" fresh-name-on!
}

def +C99.fresh-name-on! [ Str +C99 -- Str +C99 ] {
    fresh-nat! show cat
}

def run-output-c99! [ Arrow C99_Options +World +Mirth -- +World +Mirth ] {
    num-errors 0> if(
        "There were errors, so codegen stopped." rdip:trace
        panic-diagnostics!
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-field-defs!
        c99-tag-defs!
        c99-buffers!
        c99-variables!
        c99-external-blocks!
        c99-word-sigs!
        c99-block-sigs!
        c99-main!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    )
}

field(Tag.~word-cname, Tag, Str)
field(Tag.~pat-cname, Tag, Str)
field(Buffer.~cname, Buffer, Str)
field(Variable.~cname, Variable, Str)
field(Field.~cname, Field, Str)
field(External.~cname, External, Str)
field(Prim.~cname, Prim, Str)

def Tag.word-cname [ +Mirth Tag -- +Mirth Str ] { dup ~word-cname memoize(
    Str("mtw_" ; dup qname rdip:mangled ;)) nip }
def Tag.pat-cname [ +Mirth Tag -- +Mirth Str ] { dup ~pat-cname memoize(
    Str("mtp_" ; dup qname rdip:mangled ;)) nip }
def Buffer.cname [ +Mirth Buffer -- +Mirth Str ] { dup ~cname memoize(
    Str("mbuf_" ; dup qname rdip:mangled ;)) nip }
def Variable.cname [ +Mirth Variable -- +Mirth Str ] { dup ~cname memoize(
    Str("mvar_" ; dup qname rdip:mangled ;)) nip }
def Field.cname [ +Mirth Field -- +Mirth Str ] { dup ~cname memoize(
    dup qname-hard mangled Str("mfld_" ; ;)) nip }
def External.cname [ +Mirth External -- +Mirth Str ] { dup ~cname memoize(
    dup qname-hard mangled Str("mext_" ; ;)) nip }

embed-str(c99-header-str, "src/mirth.h")
def c99-header! [ +C99 -- +C99 ] {
    "#define MIRTH_DEBUG " put
    options emit-debug-info if("1", "0") put line
    c99-header-str put line
}

def c99-buffers! [ +C99 -- +C99 ] { Buffer.for(c99-buffer!) }
def c99-buffer! [ Buffer +C99 -- +C99 ] {
    "static char " put
    dup +mirth:cname put
    "[" put size show put "] = {0};" put line
}
def c99-buffer-call! [ Buffer +C99Branch -- +C99Branch ] {
    C99ReprType.PTR push-value-expression!(+mirth:cname put)
}

def c99-variables! [ +C99 -- +C99 ] { Variable.for(c99-variable!) }
def c99-variable! [ Variable +C99 -- +C99 ] {
    "static VAL " put
    +mirth:cname put
    " = {0};" put line
}
def c99-variable-call! [ Variable +C99Branch -- +C99Branch ] {
    C99ReprType.PTR push-value-expression!("&" put +mirth:cname put)
}

def c99-tag-defs! [ +C99 -- +C99 ] { Tag.for(c99-tag-def!) }
def c99-tag-def! [ Tag +C99 -- +C99 ] {
    >tag
    @tag +mirth:prefer-inline? else(
        @tag +needs:word-needed? then(
            @tag word-c99-api c99-smart-def!(
                @tag c99-tag-body!
            )
        )

        @tag +needs:pat-needed? then(
            @tag pat-c99-api c99-smart-def!(
                @tag c99-reverse-tag-body!
            )
        )
    ) tag> drop
}

def c99-tag-body! [ Tag +C99Branch -- +C99Branch ] {
    >tag
    @tag +mirth:semi-transparent? if?(
        input match {
            { ConsLabel ->
                dip:type-to-c99-repr pop-value-label!
                @tag outputs-resource? if(
                    turn-into-resource! push-resource!,
                    push-value!
                )
            }
            { WithLabel ->
                dip:resource-to-c99-repr pop-resource-label!
                push-resource!
            }
            { Cons ->
                type-to-c99-repr pop-value!
                @tag outputs-resource? if(
                    turn-into-resource! push-resource!,
                    push-value!
                )
            }
            { With ->
                resource-to-c99-repr pop-resource!
                push-resource!
            }
        },

    @tag num-total-inputs 0= if(
        @tag .data is-enum-or-unit? if(C99ReprType.I64 "" >pfx "" >sfx, C99ReprType.VAL "MKI64(" >pfx ")" >sfx)
        @tag outputs-resource? if(
            push-resource-expression!(
                pfx> put
                @tag value-show put "LL /* " put
                @tag name >Str put " */" put
                sfx> put
            ),
            push-value-expression!(
                pfx> put
                @tag value-show put "LL /* " put
                @tag name >Str put " */" put
                sfx> put
            )
        ),

        @tag +mirth:inputs >parts
        @tag Some filter(only-tag? not) >tag
        c99-pack-tuple!
        @tag outputs-resource? if(
            push-resource!,
            turn-into-value! push-value!
        )
    ))
    tag> drop
}

def c99-reverse-tag-body! [ Tag +C99Branch -- +C99Branch ] {
    >tag
    @tag +mirth:semi-transparent? if?(
        input match {
            { ConsLabel ->
                swap type-to-c99-repr
                @tag outputs-resource? if(
                    pop-resource! turn-into-value!,
                    pop-value!
                )
                push-value-label!
            }
            { WithLabel ->
                swap resource-to-c99-repr
                pop-resource!
                push-resource-label!
            }
            { Cons ->
                type-to-c99-repr
                @tag outputs-resource? if(
                    pop-resource! turn-into-value!,
                    pop-value!
                )
                push-value!
            }
            { With ->
                resource-to-c99-repr pop-resource!
                push-resource!
            }
        },

    @tag num-total-inputs 0= if(
        @tag .data pop-data! rdrop, # decref is unnecessary

        @tag +mirth:inputs >parts
        @tag .data pop-data! turn-into-resource!
        @tag Some filter(only-tag? not) >tag
        c99-unpack-tuple!
    ))
    tag> drop
}

def +C99.tag-value-put [ +C99 Tag -- +C99 ] {
    dup value-show put "LL /* " put name >Str put " */" put
}

def c99-pack-tuple! [ +C99Branch tag:Maybe(Tag) parts:List(StackTypePart) -- +C99Branch +C99Resource ] {
    @tag len @parts len + >tuplen
    @tuplen C99ReprType.TUP resource-expression!("tup_new(" put @tuplen show put ")" put) >+tup
    @+tup:resource-name >tup
    c99-line(@tup put "->size = " put @tuplen show put ";" put)
    tuplen> pred >i
    parts> reverse-for(
        match {
            { Cons -> type-to-c99-repr pop-value! consume-as-VAL }
            { With -> resource-to-c99-repr pop-resource! consume-as-VAL }
            { ConsLabel -> dip:type-to-c99-repr pop-value-label! consume-as-VAL }
            { WithLabel -> dip:resource-to-c99-repr pop-resource-label! consume-as-VAL }
        }
        c99-line(@tup put "->cells[" put @i show put "] = " put put ";" put)
        @i:pred
    )
    i> drop
    tag> for(c99-line(@tup put "->cells[0] = MKI64(" put tag-value-put ");" put))
    tup> drop
    +tup>
}

def c99-unpack-tuple! [ +C99Branch +C99Resource tag:Maybe(Tag) parts:List(StackTypePart) -- +C99Branch ] {
    @tag len @parts len + C99ReprType.TUP consume-as >tup
    tag> len >i
    parts> for(
        Str(@tup ; "->cells[" ; @i show; "]" ;)
        swap match {
            { Cons -> type-to-c99-repr dup push-value-expression!(v-macro(put)) }
            { With -> resource-to-c99-repr dup push-resource-expression!(v-macro(put)) }
            { ConsLabel -> dip(type-to-c99-repr dup value-expression!(v-macro(put))) push-value-label! }
            { WithLabel -> dip(resource-to-c99-repr dup resource-expression!(v-macro(put))) push-resource-label! }
        }
        @i:succ
    )
    c99-line("tup_decref_outer(" put tup> put "," put i> show put ");" put)
}

def c99-tag-label-index [ Tag Label +C99 -- Nat +C99 ] {
    >label sip(+mirth:inputs dup len) only-tag? if(id, 1+) >i
    reverse-find(@i:pred label if?(@label ==, False))
    label> drop2 i>
}

def c99-tag-get-label! [ TagField +C99Branch -- +C99Branch ] {
    /TagField
    type/resource> >fieldty
    @tag +mirth:semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag outputs-resource? if(
                    # wrapper is resource
                    type-to-c99-repr pop-resource!
                    dup-resource-as-value!
                    rdip(push-resource!) push-value!,

                    # wrapper is value
                    drop
                )
            }

            { Right -> # field and wrapper are both resources
                drop
                C99ReprType.I64 push-resource-expression!("0" put)
            }
        },

        @tag .data pop-data! >+tuplevar
        @+tuplevar:rdup consume-as-TUP >tuplevar
        fieldty> match {
            { Left -> # field is value
                type-to-c99-repr >fieldrepr
                @fieldrepr value-expression!(
                    fieldrepr> v-macro(
                        @tuplevar put "->cells[" put
                        @tag @label c99-tag-label-index show put
                        "]" put
                    )
                ) dup-value! rdrop push-value!
                +tuplevar> +for(drop-value!, push-resource!)
            }
            { Right -> # field and tuple are resources
                resource-to-c99-repr >fieldrepr
                @fieldrepr push-resource-expression!(
                    fieldrepr> v-macro (
                        @tuplevar put "->cells[" put
                        @tag @label c99-tag-label-index show put
                        "]" put
                    )
                )
                +tuplevar> push-value/resource!
            }
        }
        tuplevar> drop
    )
    label> tag> drop2
}

def c99-tag-set-label! [ TagField +C99Branch -- +C99Branch ] {
    /TagField
    type/resource> >fieldty
    @tag +mirth:semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag .data pop-data! +for(
                    drop drop-value!,

                    drop-resource-as-value!
                    type-to-c99-repr pop-value!
                    turn-into-resource! push-resource!
                )
            }
            { Right -> # field and wrapper are resource
                C99ReprType.I64 pop-resource! rdrop # vacant wrapper is unit
                drop
            }
        },

        @tag .data pop-data! >+tuplevar
        @fieldty match {
            { Left -> type-to-c99-repr pop-value! consume-as-VAL }
            { Right -> resource-to-c99-repr pop-resource! consume-as-VAL }
        } >fieldval
        +tuplevar> +for (
            # field and tuple are both values
            consume-as-VAL >tupleval
            C99ReprType.VAL push-value-expression!(
                "tup_replace(" put
                tupleval> put
                ", " put
                @tag @label c99-tag-label-index show put
                ", " put
                fieldval> put
                ")" put
            )
            fieldty> drop,

            # tuple is resource
            >+tuplevar
            @+tuplevar:rdup consume-as-TUP >tuplevar
            fieldty> match {
                { Left -> # field is value
                    type-to-c99-repr >fieldrepr
                    @fieldrepr needs-refcounting? then (
                        @fieldrepr dup value-expression! (
                            v-macro (
                                @tuplevar put
                                "->cells[" put
                                @tag @label c99-tag-label-index show put
                                "]" put
                            )
                        ) drop-value!
                    )
                    fieldrepr> drop
                }
                { Right -> # field is resource
                    drop
                }
            }
            c99-line(
                @tuplevar put
                "->cells[" put
                @tag @label c99-tag-label-index show put
                "] = " put
                fieldval> put
                ";" put
            )
            +tuplevar>
            push-resource!
            tuplevar> drop
        )
    )
    label> tag> drop2
}

def c99-external-blocks! [ +C99 -- +C99 ] {
    ExternalBlock.for(c99-external-block!)
}
def c99-external-block! [ ExternalBlock +C99 -- +C99 ] {
    parts for(match(
        EBPCode -> put line,
        EBPDef -> c99-external-def!
    ))
}

def External.cname-type [ External +Mirth -- Str ArrowType +Mirth ] {
    dup cname swap type
}

field(External.~c99-api, External, C99API)
def External.c99-api [ External +C99 -- C99API +C99 ] {
    dup ~c99-api memoize(dup +mirth:cname-type cname-type-to-c99-api) nip
}
def c99-external-call! [ List(Arg) External +C99Branch -- +C99Branch ] {
    +c99:c99-api c99-smart-call!
}

def c99-external-def! [ External +C99 -- +C99 ] {
    >ext
    @ext +mirth:ctype >cty

    @cty cod parts find(and(label? none?, ctype phantom? not)) >outty
    @outty if?(ctype, CType.Phantom) cname put " " put
    @ext symbol put

    " (" put
    @cty dom parts filter(ctype phantom? not)
    match(
        Nil -> "void" put,
        _ -> for(ctype cname put, ", " put)
    )
    ");" put line

    @ext c99-api c99-smart-def! (
        @cty dom parts
        dup len >arg-index
        reverse-for(
            dup c99-pop >expr
            dup ctype phantom? if(
                expr> drop,
                c99-line(
                    dup ctype cname put
                    " " put
                    dup c99-arg-name put
                    " = (" put
                    dup ctype cname put
                    ")(" put
                    expr> put
                    ");" put
                )
            )
            drop
            @arg-index:pred
        )

        c99-line(
            @outty for(ctype cname put " Y = " put)
            @ext symbol put "(" put

            1u !arg-index
            @cty dom parts filter-some(
                dup ctype phantom? if(drop None, c99-arg-name Some)
                @arg-index:1+
            )
            for(put, ", " put)
            ");" put
        )

        @cty cod parts for(
            sip(dup ctype phantom? if(drop "0", label? if?(name mangled, "Y")))
            c99-push
        )
    )

    arg-index> drop
    ext> cty> outty> drop3
}

def CTypeStackPart.c99-arg-name [ arg-index:Nat CTypeStackPart +C99 -- arg-index:Nat Str +C99 ] {
    label? if?(
        name mangled,
        Str("X" ; @arg-index show;)
    )
}

def CType.>C99ReprType [ CType -- C99ReprType ] {
    { IntLike -> drop C99ReprType.I64 }
    { F32Like -> drop C99ReprType.F32 }
    { F64Like -> drop C99ReprType.F64 }
    { PtrLike -> drop C99ReprType.PTR }
    { FnPtr   -> drop C99ReprType.FNPTR }
    { Phantom -> C99ReprType.I64 }
}

def CTypeStackPart.c99-pop [ CTypeStackPart +C99Branch -- Str +C99Branch ] {
    { Cons -> >C99ReprType dup pop-value! consume-as }
    { With -> >C99ReprType dup pop-resource! turn-into-value! consume-as }
    { ConsLabel -> dip(>C99ReprType dup) pop-value-label! consume-as }
    { WithLabel -> dip(>C99ReprType dup) pop-resource-label! turn-into-value! consume-as }
}

def CTypeStackPart.c99-push [ Str CTypeStackPart +C99Branch -- +C99Branch ] {
    { Cons -> >C99ReprType dup push-value-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { With -> >C99ReprType dup push-resource-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { ConsLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { WithLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
}

def +C99.indent [ +C99 -- +C99 ] { depth repeat("\t" put) }
def +C99.c99-nest(f) [ (*a +C99 -- *b +C99) *a +C99 -- *b +C99 ] { depth:succ f depth:pred }
def +C99.c99-line(f) [ (*a +C99 -- *b +C99) *a +C99 -- *b +C99 ] {
    indent f line
}
def +C99.c99-line-if(f) [ (*a +C99 -- *b +C99) *a Bool +C99 -- *b +C99 ] {
    put-enabled(tuck &&)
    dip:c99-line(f)
    put-enabled!
}

def +C99Branch.c99-line(f) [ (*a +C99 -- *b +C99) *a +C99Branch -- *b +C99Branch ] {
    reachable +c99:c99-line-if(f)
}
def +C99Branch.c99-line-if(f) [ (*a +C99 -- *b +C99) *a Bool +C99Branch -- *b +C99Branch ] {
    reachable && +c99:c99-line-if(f)
}
def +C99Branch.c99-nest(f) [ (*a +C99Branch -- *b +C99Branch) *a +C99Branch -- *b +C99Branch ] {
    +c99:depth:succ f +c99:depth:pred
}

data C99APIArgSource {
    Value
    ValueLabel [ Label ]
    Resource
    ResourceLabel [ Label ]
}

data C99APIArgMode {
    In
    Out
    InOut
    Branch
}

def C99APIArgMode.mode-arg-prefix {
    { In     -> "in_"    }
    { Out    -> "out_"   }
    { InOut  -> "inout_" }
    { Branch -> "branch_"  }
}

struct C99APIArg {
    mode: C99APIArgMode
    source: C99APIArgSource
    repr: C99ReprType
    name: Str
}

def C99APIArg.is-physical? [ C99APIArg -- Bool ] {
    repr is-physical?
}

def C99APIArg.is-physical-value? [ C99APIArg -- Bool ] {
    dup is-physical? if(
        source match {
            { Value -> True }
            { ValueLabel -> drop False }
            { _ -> drop False }
        },
        drop False
    )
}

def C99APIArg.pop-consume! [ C99APIArg +C99Branch -- +C99Branch Str ] {
    /C99APIArg mode> name> drop2 repr> dup source> match {
        { Value -> pop-value! consume-as }
        { Resource -> pop-resource! turn-into-value! consume-as }
        { ValueLabel -> pop-value-label! consume-as }
        { ResourceLabel -> pop-resource-label! turn-into-value! consume-as }
    }
}

def C99APIArg.pop-consume-physical! [ C99APIArg +C99Branch -- +C99Branch Maybe(Str) ] {
    sip:pop-consume!
    repr is-physical? if(
        Some,
        drop None
    )
}

def C99APIArg.pop-to-reserved! [ C99APIArg +C99Branch -- +C99Branch ] {
    dup pop-consume-physical! if?(
        c99-line(swap name put " = " put put ";" put),
        drop
    )
}

def C99APIArg.push-to! [ Str C99APIArg +C99Branch -- +C99Branch ] {
    /C99APIArg name> mode> drop2 repr> source> match {
        { Value -> push-value-expression!(put) }
        { Resource -> push-resource-expression!(put) }
        { ValueLabel -> push-label-expression!(put) }
        { ResourceLabel -> push-label-expression!(put) }
    }
}

def C99APIArg.push-api-arg! [ C99APIArg +C99Branch -- +C99Branch ] {
    /C99APIArg
    name> >value-name
    repr> >value-repr
    mode> drop
    +C99Value
    source> match {
        { Value -> push-value! }
        { ValueLabel -> push-value-label! }
        { Resource -> turn-into-resource! push-resource! }
        { ResourceLabel -> turn-into-resource! push-resource-label! }
    }
}

struct C99API {
    cname: Str
    type: ArrowType
    in-params: List(C99APIArg)
    out-params-1: List(C99APIArg)
    return-param: Maybe(C99APIArg)
    out-params-2: List(C99APIArg)
    must-flush: Bool
    doesnt-return: Bool
}

def name-arg-prefix [ Name -- Str ] {
    mangled "_" cat
}

def type-arg-prefix [ Type -- Str ] {
    { Meta -> expand-if(type-arg-prefix, drop "") }
    { Var -> name name-arg-prefix }
    { Table -> name name-arg-prefix }
    { Data -> name name-arg-prefix }
    { DataPartial -> .data name name-arg-prefix }
    { App -> drop type-arg-prefix }
    { Mut -> dip("Mut") type-arg-prefix cat }
    { Prim -> match {
        { Type -> "Type_" }
        { StackType -> "StackType_" }
        { ResourceType -> "ResourceType_" }
        { Int -> "Int_" }
        { F32 -> "F32_" }
        { F64 -> "F64_" }
        { Ptr -> "Ptr_" }
        { Str -> "Str_" }
        { World -> "World_" }
    } }
    { _ -> drop "_" }
}

def fresh-arg-name! [ +C99 mode:C99APIArgMode repr:C99ReprType Type -- +C99 mode:C99APIArgMode  repr:C99ReprType Str ] {
    @repr is-physical? if(
        dip(@mode mode-arg-prefix) type-arg-prefix cat fresh-name-on!,
        drop "0"
    )
}

def cons-fresh-arg! [ +C99 List(C99APIArg) Type C99APIArgSource mode:C99APIArgMode -- +C99 List(C99APIArg) mode:C99APIArgMode ] {
    >source
    dup +mirth:c99-repr >repr
    fresh-arg-name! >name
    @mode >mode
    C99APIArg swap cons
}

def +C99.stack-type-to-c99-api-params-aux [ StackType mode:C99APIArgMode +C99 -- mode:C99APIArgMode must-flush:Bool List(C99APIArg) +C99 ] {
    { Unit -> False >must-flush List.Nil }
    { Error -> True >must-flush List.Nil }
    { Ignore -> True >must-flush List.Nil }
    { Meta -> expand-if(>StackType stack-type-to-c99-api-params-aux, drop True >must-flush List.Nil) }
    { Var -> drop True >must-flush List.Nil }
    { Cons -> C99APIArgSource.Value dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { With -> C99APIArgSource.Resource dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { ConsLabel -> C99APIArgSource.ValueLabel dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { WithLabel -> C99APIArgSource.ResourceLabel dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
}

def +C99.stack-type-to-c99-api-params [ StackType C99APIArgMode +C99 -- must-flush:Bool List(C99APIArg) +C99 ] {
    >mode
    +C99.stack-type-to-c99-api-params-aux reverse
    mode> drop
}

def +C99.cname-type-to-c99-api [ Str ArrowType +C99 -- C99API +C99 ] {
    >type >cname
    1u with-fresh-counter (
        @type dom C99APIArgMode.In  stack-type-to-c99-api-params >in-params
        @type cod C99APIArgMode.Out stack-type-to-c99-api-params
        split-at(is-physical-value?) uncons
        >out-params-2 >return-param >out-params-1
    ) drop
    must-flush> must-flush> || >must-flush
    @type cod linear-base-var? if?(
        @type dom linear-base-var? if?(
            <>,
            drop False
        ),
        False
    ) >doesnt-return
    @doesnt-return not @must-flush:&&
    C99API
}

def C99APIArg.reserve-as-new-value! [ C99APIArg +C99Branch -- C99APIArg +C99Branch ] {
    dup is-physical? if(
        dup repr new-value!
        consume swap name!,
        "0" swap name!
    )
}

def C99APIArg.reserve-as-is! [ C99APIArg +C99Branch -- +C99Branch ] {
    dup is-physical? if(
        /C99APIArg
        c99-line(
            repr> underlying-c99-type put " " put
            name> put ";" put
        )
        source> mode> drop2,
        drop
    )
}

def C99APIArg.reserve-new-expression! [ Str C99APIArg +C99Branch -- C99APIArg +C99Branch ] {
    >arg
    +c99:fresh-name! @arg:name!
    c99-line (
        @arg repr underlying-c99-type put " " put
        @arg name put " = " put
        put ";" put
    )
    arg>
}

def c99-smart-call! [ List(Arg) C99API +C99Branch -- +C99Branch ] {
    >api
    c99-args-push!
    @api in-params reverse map(pop-consume-physical!) reverse >popped-inputs
    @api must-flush then(flush-cache!)
    @api out-params-1 map(reserve-as-new-value!) >reserved-outputs-1
    @api out-params-2 map(reserve-as-new-value!) >reserved-outputs-2
    Str(
        @api cname ; "(" ;
        "" >sep
        popped-inputs> for:for(sep> ; ", " >sep ;)
        @reserved-outputs-1 @reserved-outputs-2 cat for(
            dup is-physical?
            if(sep> ; ", " >sep "&" ; name ;, drop)
        )
        sep> drop
        ")" ;
    )
    @api return-param if?(
        @api doesnt-return if(
            swap c99-line("(void)" put put ";" put) Some,
            reserve-new-expression! Some
        ),
        c99-line(put ";" put) None
    ) >reserved-return
    api> doesnt-return not reachable:&&
    reserved-outputs-1> for(push-api-arg!)
    reserved-return>    for(push-api-arg!)
    reserved-outputs-2> for(push-api-arg!)
}

def +C99.smart-sig-put [ C99API +C99 -- +C99 ] {
    >api
    "static " put
    @api return-param if?(
        repr underlying-c99-type put,
        "void" put
    )
    " " put
    @api cname put
    " (" put
    "" >sep
    @api in-params filter(is-physical?) for(
        sep> put ", " >sep
        dup repr underlying-c99-type put
        " " put name put
    )
    @api out-params-1 @api out-params-2 cat filter(is-physical?) for(
        sep> put ", " >sep
        dup repr underlying-c99-type put
        " *" put name put
    )
    sep> empty? then("void" put)
    ")" put
    api> drop
}

def c99-smart-sig! [ C99API +C99 -- +C99 ] {
    c99-line(smart-sig-put ";" put)
}

def c99-api-enter! [ C99API +C99 -- +C99Branch ] {
    >api
    @api in-params len
    @api out-params-1 len +
    @api out-params-2 len +
    @api return-param then(1+)
    1+ fresh-counter!
    True >reachable
    List.Nil >env
    start-branch!
    @api in-params for(push-api-arg!)
    api> drop
}

def c99-api-exit! [ C99API +C99Branch -- +C99 ] {
    >api
    @api out-params-2 reverse-for(
        dup pop-consume-physical! if?(
            swap name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    @api return-param map(pop-consume!)
    @api out-params-1 reverse-for(
        dup pop-consume-physical! if?(
            swap name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    end-branch!
    reachable> if(
        for(c99-line("return " put put ";" put)),
        drop @api return-param for(
            repr dummy-value
            c99-line("return " put put "; /* unreachable */" put)
        )
    )
    api> drop
    env> drop
}

def c99-smart-def! (f) [ (*a +C99Branch -- *b +C99Branch) *a C99API +C99 -- *b +C99 ] {
    c99-line(dup smart-sig-put " {" put)
    c99-nest(
        dup dip(c99-api-enter! f)
        c99-api-exit!
    )
    c99-line("}" put)
}

def c99-codip-arrow! [ Arrow +C99Branch -- +C99Branch ] {
    dup +mirth:type /ArrowType
    cod> split-parts >cod-parts >cod-base
    dom> split-parts >dom-parts >dom-base
    cod-base> unit? dom-base> unit? && if(
        dom-parts> dip-parts( +stack(+C99Stack.+Nil) )
        c99-arrow!
        cod-parts> dip-parts(
            +stack(rdrop)
        ),

        cod-parts> dom-parts> drop2
        c99-arrow!
    )
}

def +C99Branch.dip-parts(f) [
    ( *a +C99Branch -- *b +C99Branch )
    *a List(StackTypePart) +C99Branch -- *b +C99Branch
] {
    pop-stack!
    rdip (f)
    push-stack!
}

||| Pop stack parts (right-to-left) into a separate stack cache.
def +C99Branch.pop-stack! [ List(StackTypePart) +C99Branch -- +C99Branch +C99Stack ] {
    +C99Stack.+Nil reverse-for(pop-stack-part!)
}

||| Pop a part from branch to separate stack.
def +C99Stack.pop-stack-part! [ StackTypePart +C99Branch +C99Stack -- +C99Branch +C99Stack ] {
    { Cons -> rdip(type-to-c99-repr pop-value!) rswap +C99Stack.+Cons }
    { With -> rdip(resource-to-c99-repr pop-resource!) rswap +C99Stack.+With }
    { ConsLabel -> rdip(dip:type-to-c99-repr tuck pop-value-label!) rswap +C99Stack.+ConsLabel }
    { WithLabel -> rdip(dip:resource-to-c99-repr tuck pop-resource-label!) rswap +C99Stack.+WithLabel }
}

def +C99Stack.reverse-cat! [ +C99Stack +C99Stack -- +C99Stack ] {
    while ( match {
        { +Nil -> +C99Stack.+Nil False }
        { +Cons -> rswap rdip:+C99Stack.+Cons True }
        { +With -> rswap rdip:+C99Stack.+With True }
        { +ConsLabel -> rswap rdip:+C99Stack.+ConsLabel True }
        { +WithLabel -> rswap rdip:+C99Stack.+WithLabel True }
    } ) rdrop
}

||| Push stack onto branch, right to left.
def +C99Stack.push-stack! [ +C99Branch +C99Stack -- +C99Branch ] {
    rswap +stack(rswap reverse-cat!)
}

def c99-arrow! [ Arrow +C99Branch -- +C99Branch ] { atoms for(c99-atom!) }
def c99-atom! [ Atom +C99Branch -- +C99Branch ] {
    +c99:options emit-debug-info and(dup op show-in-stack-trace?) then(
        +c99:c99-line("WORD_ATOM(" put
            dup token row >Int show put ", " put
            dup token col >Int show put ", " put
            dup token name? if?(>Str, "") put-cstr
            ");" put
        )
    )
    dup op
    c99-atom-op!
}

def Op.show-in-stack-trace? [ Op -- Bool ] {
    { Int -> drop False }
    { F64 -> drop False }
    { Str -> drop False }
    { Word -> prefer-inline? not }
    { External -> drop True }
    { Buffer -> drop False }
    { Variable -> drop False }
    { Field -> drop False }
    { Tag -> drop False }
    { Prim -> drop True }
    { Match -> drop False }
    { Lambda -> drop False }
    { Var -> drop False }
    { BlockPush -> drop False }
    { BlockRun -> drop False }
    { LabelPush -> drop False }
    { LabelPop -> drop False }
    { LabelPushR -> drop False }
    { LabelPopR -> drop False }
    { DataGetEnumValue -> drop False }
    { DataFromEnumValue -> drop False }
    { DataGetLabel -> drop False }
    { DataSetLabel -> drop False }
    { TableToIndex -> drop False }
    { TableFromIndex -> drop False }
}

def c99-atom-op! [ Atom Op +C99Branch -- +C99Branch ] {
    { Int           -> nip c99-int! }
    { F64           -> nip c99-f64! }
    { Str           -> nip c99-str! }
    { Word          -> dip:args c99-word! }
    { External      -> dip:args c99-external-call! }
    { Buffer        -> nip c99-buffer-call! }
    { Variable      -> nip c99-variable-call! }
    { Field         -> nip c99-field-call! }
    { Tag           -> dip:args c99-tag-call! }
    { Prim          -> c99-prim! }
    { Match         -> nip c99-match! }
    { Lambda        -> nip c99-lambda! }
    { Var           -> nip c99-var! }
    { BlockPush     -> nip c99-block-push! }
    { BlockRun      -> nip c99-block-run! }
    { LabelPush     -> c99-label-push! }
    { LabelPop      -> c99-label-pop! }
    { LabelPushR    -> c99-label-push-r! }
    { LabelPopR     -> c99-label-pop-r! }
    { DataGetEnumValue -> nip c99-get-enum-value! }
    { DataFromEnumValue -> nip c99-from-enum-value! }
    { DataGetLabel  -> c99-tag-get-label! drop }
    { DataSetLabel  -> c99-tag-set-label! drop }
    { TableToIndex -> drop2 }
    { TableFromIndex -> drop2 }
}

def c99-get-enum-value! [ Data +C99Branch -- +C99Branch ] {
    >data
    @data is-enum? else(
        @data Type.Data type-to-c99-repr pop-value! >+scrutinee
        @data is-unit? if?(
            C99ReprType.I64 push-value-expression!(value show put "LL" put),

        @data +mirth:semi-transparent? if?(
            C99ReprType.I64 push-value-expression!(tag value show put "LL" put),
            C99ReprType.I64 push-value-expression!(
                "get_data_tag(" put
                @+scrutinee:rdup consume-as-VAL put
                ")" put
            )
        ))
        +scrutinee> drop-value!
    )
    data> drop
}

def c99-from-enum-value! [ Data +C99Branch -- +C99Branch ] {
    is-enum? else("_.from-enum-value-unsafe on non-enum" +mirth:fatal-error!)
}

def c99-word! [ List(Arg) Word +C99Branch -- +C99Branch ] {
    dup prefer-inline? if(
        dip:c99-args-push!
        +mirth:arrow c99-codip-arrow!,
        +c99:c99-api c99-smart-call!
    )
}

field(Tag.~value-show, Tag, Str)
def Tag.value-show [ Tag -- Str ] { dup ~value-show memoize(dup value show) nip }

def c99-tag-call! [ List(Arg) Tag +C99Branch -- +C99Branch ] {
    dup +mirth:prefer-inline? if(
        nip c99-tag-body!,
        +c99:word-c99-api c99-smart-call!
    )
}

def c99-reverse-tag! [ Tag +C99Branch -- +C99Branch ] {
    dup +mirth:prefer-inline? if(
        c99-reverse-tag-body!,
        dip:List.Nil +c99:pat-c99-api c99-smart-call!
    )
}

def c99-label-defs! [ +C99 -- +C99 ] { Label.for(c99-label-def!) }
def c99-label-def! [ Label +C99 -- +C99 ] { "static STACK lbl_" put name mangled put " = {0};" put line }

def push-value-label-direct! [ Label +C99Branch +C99Value -- +C99Branch ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-value-label! [ Label +C99Branch +C99Value -- +C99Branch ] {
    rswap +stack(rswap +C99Stack.+ConsLabel)
}
def push-resource-label-direct! [ Label +C99Branch +C99Resource -- +C99Branch ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-resource-label! [ Label +C99Branch +C99Resource -- +C99Branch ] {
    rswap +stack(rswap +C99Stack.+WithLabel)
}

def pop-value-label-direct! [ C99ReprType Label +C99Branch -- +C99Branch +C99Value ] {
    swap dup value-expression!(
        v-macro("lpop(&lbl_" put name mangled put ")" put)
    )
}

def pop-resource-label-direct! [ C99ReprType Label +C99Branch -- +C99Branch +C99Resource ] {
    swap dup resource-expression!(
        v-macro("lpop(&lbl_" put name mangled put ")" put)
    )
}

def c99-label-push! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-value-from-stack-type! drop
    push-value-label!
}
def c99-label-push-r! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-resource-from-stack-type! drop
    push-resource-label!
}
def c99-label-pop! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-value-label-from-stack-type! drop
    push-value!
}
def c99-label-pop-r! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-resource-label-from-stack-type! drop
    push-resource!
}

def c99-int! [ Int +C99Branch -- +C99Branch ] {
    C99ReprType.I64 push-value-expression!(show put "LL" put)
}

def c99-f64! [ F64 +C99Branch -- +C99Branch ] {
    C99ReprType.F64 push-value-expression!(>Str put)
}

def c99-str! [ Str +C99Branch -- +C99Branch ] {
    C99ReprType.STR new-value! >+str
    dup num-bytes 4090 >Nat-clamp >USize > if(
        c99-line("STRLIT(" put @+str:rdup consume put "," put)
        c99-nest(
            c99-line(dup put-cstr-long "," put)
            c99-line(dup num-bytes show put)
        )
        c99-line(");" put),

        c99-line("STRLIT(" put
            @+str:rdup consume put ", " put
            dup put-cstr ", " put
            dup num-bytes show put ");" put)
    ) drop

    +str> push-value!
}

def +C99.put-cstr-long [ Str +C99 -- +C99 ] {
    False >avoid-hexdigit
    Byte.BQUOTE put-byte
    Byte.BNUL swap bytes-for(
        swap Byte.BLF == then(
            Byte.BQUOTE put-byte
            line indent
            Byte.BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    Byte.BQUOTE put-byte
    avoid-hexdigit> drop2
}

def +C99.put-cstr [ Str +C99 -- +C99 ] {
    False >avoid-hexdigit
    Byte.BQUOTE put-byte bytes-for(c99-string-byte!) Byte.BQUOTE put-byte
    avoid-hexdigit> drop
}

def c99-string-byte! [ Byte avoid-hexdigit:Bool +C99 -- avoid-hexdigit:Bool +C99 ] {
    { B'\' ->   "\\\\" put False !avoid-hexdigit }
    { BQUOTE -> "\\\"" put False !avoid-hexdigit }
    { BHT ->    "\\t"  put False !avoid-hexdigit }
    { BLF ->    "\\n"  put False !avoid-hexdigit }
    { BCR ->    "\\r"  put False !avoid-hexdigit }
    { _ ->
        dup Byte.BSPACE Byte.B'~' in-range
        and(dup is-hexdigit @avoid-hexdigit && not) if(
            put-byte
            False !avoid-hexdigit,
            "\\x" put to-hexdigits dip(put-byte) put-byte
            True !avoid-hexdigit
        )
    }
}

data C99ReprType {
    0 Void

    VAL
    STR
    TUP [ Nat ]

    I64 I32 I16 I8
    U64 U32 U16 U8
    F64 F32
    Bool
    PTR
    FNPTR
}

def C99ReprType.== [ C99ReprType C99ReprType -- Bool ] {
    { TUP -> swap match { TUP -> ==, _ -> drop2 False } }
    { _ -> on2:enum-value == }
}

inline (
    def C99ReprType.is-unit? [ C99ReprType -- Bool ] { enum-value 0= }
    def C99ReprType.is-physical? [ C99ReprType -- Bool ] { enum-value 0 <> }
    def C99ReprType.<> [ C99ReprType C99ReprType -- Bool ] { == not }
)

def C99ReprType.needs-refcounting? [ C99ReprType -- Bool ] {
    { VAL -> True }
    { STR -> True }
    { TUP -> drop True }

    { Void -> False }
    { I64 -> False } { I32 -> False } { I16 -> False } { I8 -> False }
    { U64 -> False } { U32 -> False } { U16 -> False } { U8 -> False }
    { F64 -> False } { F32 -> False }
    { Bool -> False }
    { PTR -> False }
    { FNPTR -> False }
}

def C99ReprType.is-int-like? [ C99ReprType -- Bool ] {
    { I64 -> True } { I32 -> True } { I16 -> True } { I8 -> True }
    { U64 -> True } { U32 -> True } { U16 -> True } { U8 -> True }
    { Bool -> True }
    { _ -> drop False }
}

def C99ReprType.is-float-like? [ C99ReprType -- Bool ] {
    { F64 -> True } { F32 -> True }
    { _ -> drop False }
}

def C99ReprType.dummy-value [ C99ReprType -- Str ] {
    { VAL   -> "(VAL){0}"  }
    { STR   -> "NULL"      }
    { Void  -> "0"         }
    { I64   -> "0"         }
    { I32   -> "0"         }
    { I16   -> "0"         }
    { I8    -> "0"         }
    { U64   -> "0"         }
    { U32   -> "0"         }
    { U16   -> "0"         }
    { U8    -> "0"         }
    { F64   -> "0.0"       }
    { F32   -> "0.0"       }
    { Bool  -> "0"         }
    { PTR   -> "NULL"      }
    { FNPTR -> "NULL"      }
    { TUP   -> drop "NULL" }
}

def C99ReprType.underlying-c99-type [ C99ReprType -- Str ] {
    { VAL   -> "VAL"      }
    { STR   -> "STR*"     }
    { Void  -> "int64_t"  }
    { I64   -> "int64_t"  }
    { I32   -> "int32_t"  }
    { I16   -> "int16_t"  }
    { I8    -> "int8_t"   }
    { U64   -> "uint64_t" }
    { U32   -> "uint32_t" }
    { U16   -> "uint16_t" }
    { U8    -> "uint8_t"  }
    { F64   -> "double"   }
    { F32   -> "float"    }
    { Bool  -> "bool"     }
    { PTR   -> "void*"    }
    { FNPTR -> "FNPTR"    }
    { TUP   -> drop "TUP*"  }
}

def C99ReprType.v-macro(f) [ (*a +C99 -- *b +C99) *a +C99 C99ReprType -- *b +C99 ] {
    v-macro-prefix-suffix
    dip(put f) put
}

def C99ReprType.v-macro-prefix-suffix [ C99ReprType -- Str Str ] {
    { VAL   -> "" "" }
    { STR   -> "value_str(" ")" }
    { Void  -> "(" ", 0)" }
    { I64   -> "value_i64(" ")" }
    { I32   -> "value_i32(" ")" }
    { I16   -> "value_i16(" ")" }
    { I8    -> "value_i8(" ")" }
    { U64   -> "value_u64(" ")" }
    { U32   -> "value_u32(" ")" }
    { U16   -> "value_u16(" ")" }
    { U8    -> "value_u8(" ")" }
    { F64   -> "value_f64(" ")" }
    { F32   -> "value_f32(" ")" }
    { Bool  -> "value_bool(" ")" }
    { PTR   -> "value_ptr(" ")" }
    { FNPTR -> "value_fnptr(" ")" }
    { TUP   -> "value_tup(" swap Str(", "; show ; ")";) }
}

def C99ReprType.mk-macro [ Str C99ReprType -- Str ] {
    { VAL   -> id }
    { STR   -> Str( "MKSTR(" ; ; ")" ; ) }
    { Void  -> Str( "MKI64(" ; ; ")" ; ) }
    { I64   -> Str( "MKI64(" ; ; ")" ; ) }
    { I32   -> Str( "MKI32(" ; ; ")" ; ) }
    { I16   -> Str( "MKI16(" ; ; ")" ; ) }
    { I8    -> Str( "MKI8("  ; ; ")" ; ) }
    { U64   -> Str( "MKU64(" ; ; ")" ; ) }
    { U32   -> Str( "MKU32(" ; ; ")" ; ) }
    { U16   -> Str( "MKU16(" ; ; ")" ; ) }
    { U8    -> Str( "MKU8(" ; ; ")" ; ) }
    { F64   -> Str( "MKF64(" ; ; ")" ; ) }
    { F32   -> Str( "MKF32(" ; ; ")" ; ) }
    { Bool  -> Str( "MKBOOL(" ; ; ")" ; ) }
    { PTR   -> Str( "MKPTR(" ; ; ")" ; ) }
    { FNPTR -> Str( "MKFNPTR(" ; ; ")" ; ) }
    { TUP   -> swap Str( "MKTUP(" ; ; ", " ; show ; ")" ; ) }
}

def Resource.c99-repr [ Resource +Mirth -- C99ReprType +Mirth ] {
    >Type c99-repr
}

def Type.c99-repr [ Type +Mirth -- C99ReprType +Mirth ] {
    { Error -> C99ReprType.VAL }
    { Ignore -> C99ReprType.VAL }
    { Prim -> c99-repr }
    { Meta -> expand-if(c99-repr, drop C99ReprType.VAL) }
    { Hole -> drop C99ReprType.VAL }
    { Var -> drop C99ReprType.VAL }
    { Table -> drop C99ReprType.U64 }
    { Data -> c99-repr }
    { DataPartial -> .data c99-repr }
    { Arrow -> drop C99ReprType.VAL }
    { Stack -> tuple-c99-repr }
    { App -> drop c99-repr }
    { Mut -> drop C99ReprType.PTR }
    { Value -> drop C99ReprType.VAL }
}

def StackType.tuple-c99-repr [ StackType -- C99ReprType ] {
    split-parts swap match {
        { Unit -> len dup 0= if (drop C99ReprType.Void, C99ReprType.TUP) }
        { _ -> drop2 C99ReprType.VAL }
    }
}

def PrimType.c99-repr [ PrimType -- C99ReprType ] {
    { Type -> C99ReprType.VAL }
    { StackType -> C99ReprType.VAL }
    { ResourceType -> C99ReprType.VAL }
    { Int -> C99ReprType.I64 }
    { F32 -> C99ReprType.F32 }
    { F64 -> C99ReprType.F64 }
    { Str -> C99ReprType.STR }
    { Ptr -> C99ReprType.PTR }
    { World -> C99ReprType.Void }
}

def Data.c99-repr [ Data +Mirth -- C99ReprType +Mirth ] {
    >dat
    @dat is-unit? if(C99ReprType.Void,
    @dat is-enum? if(C99ReprType.I64,
    @dat semi-transparent? if?(
        input type/resource either(c99-repr, c99-repr),
    @dat single-tag? if?(
        inputs len C99ReprType.TUP,
        C99ReprType.VAL
    ))))
    dat> drop
}

struct +C99Value {
    value-repr: C99ReprType
    value-name: Str
}

def +C99Value.rdup [ +C99Value -- +C99Value +C99Value ] {
    value-repr >value-repr
    value-name >value-name
    +C99Value
}

def +C99Value.rdrop [ +C99Value -- ] {
    /+C99Value
    value-repr> drop
    value-name> drop
}

def C99ReprType.new-value! [ C99ReprType +C99Branch -- +C99Branch +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put ";" put)
    +C99Value
}

def C99ReprType.pop-value-direct! [ C99ReprType +C99Branch -- +C99Branch +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put " = " put
             @value-repr v-macro ( "pop_value()" put ) ";" put)
    +C99Value
}

||| Push a value with a certain repr type on the stack.
||| `f` must emit the C99 expression that calculates the value,
||| which must be of the underlying C99 repr type.
def C99ReprType.push-value-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
] {
    value-expression!(f) push-value!
}

def C99ReprType.push-resource-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
] {
    resource-expression!(f) push-resource!
}

def push-label-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType Label +C99Branch -- *b +C99Branch
] {
    dip:value-expression!(f)
    dup is-resource-label? if(
        turn-into-resource! push-resource-label!,
        push-value-label!
    )
}

def C99ReprType.value-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch +C99Value
] {
    dup >value-repr is-physical? dup
    if(+c99:fresh-name!, "0") >value-name
    c99-line-if(
        @value-repr underlying-c99-type put " " put
        @value-name put " = " put
        +C99Value rdip:f rswap ";" put
    ) rswap
}

def C99ReprType.resource-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch +C99Resource
] {
    dup >resource-repr is-physical? dup
    if(+c99:fresh-name!, "0") >resource-name
    c99-line-if(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        +C99Resource rdip:f rswap ";" put
    ) rswap
}

def +C99Value.push-value-direct! [ +C99Branch +C99Value -- +C99Branch ] {
    consume-as-VAL
    c99-line("push_value(" put put ");" put)
}

def +C99Value.consume [ +C99Value -- Str ] {
    /+C99Value value-repr> drop value-name>
}

def +C99Value.consume-as-VAL [ +C99Value -- Str ] {
    /+C99Value value-name> value-repr> mk-macro
}

def +C99Value.consume-as-TUP [ +C99Value -- Str ] {
    turn-into-resource! consume-as-TUP
}

def +C99Value.consume-as [ C99ReprType +C99Value -- Str ] {
    { VAL -> consume-as-VAL }
    { Void -> rdrop "0" }
    { _ ->
        /+C99Value
        @value-repr match {
            { VAL -> Str( v-macro-prefix-suffix dip(; value-name> ;) ; ) }
            { _ ->
                over == if(
                    drop value-name>,
                    dup is-int-like? @value-repr is-int-like? && if(
                        Str( "((" ; underlying-c99-type ; ")" ; value-name> ; ")" ; ),
                        Str( "(\n#error \"attempted to cast " ; value-name> ; " to incompatible C99 repr type " ;
                            underlying-c99-type ; "\"\n" ; )
                    )
                )
            }
        }
        value-repr> drop
    }
}

def +C99Value.drop-value! [ +C99Branch +C99Value -- +C99Branch ] {
    value-repr needs-refcounting? if(
        consume-as-VAL +c99:c99-line("decref(" put put ");" put),
        rdrop
    )
}

def +C99Value.dup-value! [ +C99Branch +C99Value -- +C99Branch +C99Value +C99Value ] {
    value-repr needs-refcounting? then(
        rdup consume-as-VAL rdip:+c99:c99-line("incref(" put put ");" put)
    )
    rdup
}

def +C99Value.peek-data-tag [ +C99Value -- +C99Value Str ] {
    turn-into-resource! peek-data-tag turn-into-value!
}

struct +C99Resource {
    resource-repr: C99ReprType
    resource-name: Str
}

def +C99Resource.rdup [ +C99Resource -- +C99Resource +C99Resource ] {
    resource-repr >resource-repr
    resource-name >resource-name
    +C99Resource
}

def +C99Resource.rdrop [ +C99Resource -- ] {
    consume drop
}

def +C99Value.turn-into-resource! [ +C99Value -- +C99Resource ] {
    /+C99Value
    value-repr> >resource-repr
    value-name> >resource-name
    +C99Resource
}

def +C99Resource.turn-into-value! [ +C99Resource -- +C99Value ] {
    /+C99Resource
    resource-repr> >value-repr
    resource-name> >value-name
    +C99Value
}

def +C99Resource.drop-resource-as-value! [ +C99Branch +C99Resource -- +C99Branch ] {
    turn-into-value! drop-value!
}

def +C99Resource.dup-resource-as-value! [ +C99Branch +C99Resource -- +C99Branch +C99Resource +C99Value ] {
    rdup turn-into-value! rswap rdip(dup-value! rdrop) rswap
}

def +C99Resource.consume [ +C99Resource -- Str ] {
    /+C99Resource
    resource-repr> drop
    resource-name>
}

def +C99Resource.consume-as [ C99ReprType +C99Resource -- Str ] {
    turn-into-value! consume-as
}

def +C99Resource.consume-as-VAL [ +C99Resource -- Str ] {
    /+C99Resource resource-name> resource-repr> mk-macro
}

def +C99Resource.consume-as-TUP [ +C99Resource -- Str ] {
    /+C99Resource resource-repr> match {
        { VAL -> Str( "VTUP(" ; resource-name> ; ")" ; ) }
        { TUP -> drop resource-name> }
        { _ -> drop "c99: tried to consume non-tuple as tuple" panic! }
    }
}

def +C99Branch.pop-resource-direct! [ +C99Branch C99ReprType -- +C99Branch +C99Resource ] {
    >resource-repr
    +c99:fresh-resource-name! >resource-name
    c99-line(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        @resource-repr v-macro( "pop_resource()" put )
        ";" put
    )
    +C99Resource
}

def +C99Resource.push-resource-direct! [ +C99Branch +C99Resource -- +C99Branch ] {
    consume-as-VAL
    c99-line("push_resource(" put put ");" put)
}

def +C99Resource.peek-data-tag [ +C99Resource -- +C99Resource Str ] {
    resource-repr is-int-like? if(
        resource-name,
        rdup consume-as-VAL Str("get_data_tag(" ; ; ")";)
    )
}

def +C99Value.>Value/Resource { +Left +C99Value/Resource }
def +C99Resource.>Value/Resource { +Right +C99Value/Resource }
struct +C99Value/Resource {
    +Either(+C99Value, +C99Resource)
    --
    def +Left [ +C99Value -- +C99Value/Resource ] { +Either.+Left +C99Value/Resource }
    def +Right [ +C99Resource -- +C99Value/Resource ] { +Either.+Right +C99Value/Resource }
    def +for(f,g) { +C99Value/Resource -> +for(f,g) }
    def +map(f,g) { +C99Value/Resource -> +map(f,g) +C99Value/Resource }
    def rdup { +C99Value/Resource -> rdup +C99Value/Resource rdip:+C99Value/Resource }
    def rdrop { +C99Value/Resource -> rdrop }

    def push-value/resource! { +for(push-value!, push-resource!) }
    def peek-data-tag { +map(peek-data-tag, peek-data-tag) }
    def consume-as-VAL { +for(consume-as-VAL, consume-as-VAL) }
    def consume-as-TUP { +for(consume-as-TUP, consume-as-TUP) }
    def turn-into-resource! { +for(turn-into-resource!, id) }
}

def +C99Branch.pop-data! [ Data +C99Branch -- +C99Branch +C99Value/Resource ] {
    dup is-resource? if(
        +mirth:c99-repr pop-resource! >Value/Resource,
        +mirth:c99-repr pop-value! >Value/Resource
    )
}

data +C99Value? {
    +C99ValueNone
    +C99ValueSome [ +C99Value ]
}

def +C99Value?.unwrap!(f,g) {
    { +C99ValueSome -> f }
    { +C99ValueNone -> g }
}

data +C99Resource? {
    +C99ResourceNone
    +C99ResourceSome [ +C99Resource ]
}

def +C99Branch.refresh-branch! [ +C99Branch -- +C99Branch ] {
    /+C99Branch
    +c99> +stack>
    refresh-all!
}

def +C99Stack.refresh-all! [ +C99 +C99Stack reachable:Bool env:C99Env -- +C99Branch ] {
    { +Nil -> start-branch! }
    { +Cons ->
        >+x refresh-all!
        @+x:value-repr push-value-expression!(+x> consume put)
    }
    { +With ->
        >+x refresh-all!
        @+x:resource-repr push-resource-expression!(+x> consume put)
    }
    { +ConsLabel ->
        >+x refresh-all!
        @+x:value-repr swap push-label-expression!(+x> consume put)
    }
    { +WithLabel ->
        >+x refresh-all!
        @+x:resource-repr swap push-label-expression!(+x> consume put)
    }
}

def +C99Stack.tie-knot! [ +C99Branch +C99Stack -- +C99Branch ] {
    { +Nil -> flush-cache! }
    { +Cons ->
        value-repr dup rdip2(pop-value! consume-as)
        value-name
        value-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        push-value!
    }
    { +With ->
        resource-repr dup rdip2(pop-resource! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        push-resource!
    }
    { +ConsLabel -> >label
        value-repr dup rdip2(@label pop-value-label! consume-as)
        value-name
        value-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        label> push-value-label!
    }
    { +WithLabel -> >label
        resource-repr dup rdip2(@label pop-resource-label! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        label> push-resource-label!
    }
}

data +C99Stack {
    +Nil
    +Cons [ +C99Stack +C99Value ]
    +With [ +C99Stack +C99Resource ]
    +ConsLabel [ +C99Stack +C99Value Label ]
    +WithLabel [ +C99Stack +C99Resource Label ]
}

def +C99Stack.pop-value? [ +C99Stack -- +C99Value? +C99Stack ] {
    { +Nil -> +C99Value?.+C99ValueNone +C99Stack.+Nil }
    { +Cons -> +C99Value?.+C99ValueSome rswap }
    { +With -> rdip:pop-value? +C99Stack.+With }
    { +ConsLabel -> rdip:pop-value? +C99Stack.+ConsLabel }
    { +WithLabel -> rdip:pop-value? +C99Stack.+WithLabel }
}

def +C99Stack.pop-resource? [ +C99Stack -- +C99Resource? +C99Stack ] {
    { +Nil -> +C99Resource?.+C99ResourceNone +C99Stack.+Nil }
    { +With -> +C99Resource?.+C99ResourceSome rswap }
    { +Cons -> rdip:pop-resource? +C99Stack.+Cons }
    { +ConsLabel -> rdip:pop-resource? +C99Stack.+ConsLabel }
    { +WithLabel -> rdip:pop-resource? +C99Stack.+WithLabel }
}

def +C99Stack.pop-value-label? [ Label +C99Stack -- Label +C99Value? +C99Stack ] {
    { +Nil -> +C99Value?.+C99ValueNone +C99Stack.+Nil }
    { +Cons -> rdip:pop-value-label? +C99Stack.+Cons }
    { +With -> rdip:pop-value-label? +C99Stack.+With }
    { +WithLabel -> dip:rdip:pop-value-label? +C99Stack.+WithLabel }
    { +ConsLabel ->
        dup2 == if(
            drop +C99Value?.+C99ValueSome rswap,
            dip:rdip:pop-value-label? +C99Stack.+ConsLabel
        )
    }
}

def +C99Stack.pop-resource-label? [ Label +C99Stack -- Label +C99Resource? +C99Stack ] {
    { +Nil -> +C99Resource?.+C99ResourceNone +C99Stack.+Nil }
    { +Cons -> rdip:pop-resource-label? +C99Stack.+Cons }
    { +With -> rdip:pop-resource-label? +C99Stack.+With }
    { +ConsLabel -> dip:rdip:pop-resource-label? +C99Stack.+ConsLabel }
    { +WithLabel ->
        dup2 == if(
            drop +C99Resource?.+C99ResourceSome rswap,
            dip:rdip:pop-resource-label? +C99Stack.+WithLabel
        )
    }
}

def +C99Stack.push-stack-direct! [ +C99Branch +C99Stack -- +C99Branch ] {
    { +Nil -> }
    { +Cons -> rdip:push-stack-direct! push-value-direct! }
    { +With -> rdip:push-stack-direct! push-resource-direct! }
    { +ConsLabel -> rdip:push-stack-direct! push-value-label-direct! }
    { +WithLabel -> rdip:push-stack-direct! push-resource-label-direct! }
}

def +C99Stack.rdup [ +C99Stack -- +C99Stack +C99Stack ] {
    { +Nil -> +C99Stack.+Nil +C99Stack.+Nil }
    { +Cons -> rdip:rdup rdup rdip:rswap +C99Stack.+Cons rdip:+C99Stack.+Cons }
    { +With -> rdip:rdup rdup rdip:rswap +C99Stack.+With rdip:+C99Stack.+With }
    { +ConsLabel -> dup rdip:rdup rdup rdip:rswap +C99Stack.+ConsLabel rdip:+C99Stack.+ConsLabel }
    { +WithLabel -> dup rdip:rdup rdup rdip:rswap +C99Stack.+WithLabel rdip:+C99Stack.+WithLabel }
}

def +C99Stack.rdrop [ +C99Stack -- ] {
    { +Nil -> }
    { +Cons -> rdrop rdrop }
    { +With -> rdrop rdrop }
    { +ConsLabel -> drop rdrop rdrop }
    { +WithLabel -> drop rdrop rdrop }
}

struct +C99BranchSplit {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    branch-split-target: List(C99APIArg)
    reachable-in: Bool
    reachable-out: Bool
}

def +C99BranchSplit.+mirth(f) { +c99:+mirth(f) }

def +C99Branch.begin-branch-split! [ StackType +C99Branch -- +C99BranchSplit ] {
    C99APIArgMode.Branch +c99:stack-type-to-c99-api-params >branch-split-target
    must-flush> drop
    @branch-split-target for(reserve-as-is!)
    /+C99Branch
    reachable> >reachable-in
    False >reachable-out
    +C99BranchSplit
}
def +C99BranchSplit.end-branch-split! [ +C99BranchSplit -- +C99Branch ] {
    /+C99BranchSplit
    +stack> rdrop
    reachable-in> drop
    reachable-out> >reachable
    +c99> start-branch!
    branch-split-target> for(push-api-arg!)
}

def +C99BranchSplit.sub-branch(f) [ (*a +C99Branch -- *b +C99Branch) *a +C99BranchSplit -- *b +C99BranchSplit ] {
    +stack(rdup >+stack) branch-split-target
    reachable-in >reachable
    env >env
    +c99(
        >+c99 +C99Branch dip:f
        reverse-for(pop-to-reserved!)
        end-branch!
    )
    env> drop
    reachable> reachable-out:||
}


def +C99BranchSplit.c99-line(f) { reachable-in +c99:c99-line-if(f) }
def +C99BranchSplit.c99-line-if(f) { reachable-in && +c99:c99-line-if(f) }
def +C99BranchSplit.c99-nest(f) { +c99:depth:1+ f +C99BranchSplit.+c99:depth:pred }

struct C99Var {
    var-var: Var
    value-name: Str
    value-repr: C99ReprType
}

def +C99Branch.var-lookup [ +C99Branch Var -- +C99Branch Maybe(C99Var) ] {
    env lookup(var-var ==)
}

def +C99Branch.var-get! [ +C99Branch Var -- +C99Branch +C99Value ] {
    var-lookup unwrap("[c99] variable unexpectedly missing from environment" +mirth:fatal-error!)
    /C99Var var-var> drop
    +C99Value
}

def +C99Branch.var-dup! [ +C99Branch Var -- +C99Branch +C99Value ] {
    var-get! dup-value! rdrop
}

def +C99Value.push-to-env! [ +C99Branch Var +C99Value -- +C99Branch ] {
    >var-var /+C99Value C99Var env:cons
}

def +C99Branch.pop-from-env! [ +C99Branch -- +C99Branch Var +C99Value ] {
    env:uncons unwrap("[c99] variable environment unexpectedly empty" +mirth:fatal-error!)
    /C99Var +C99Value var-var>
}

def-type(C99Env, List(C99Var))

||| This resource represents a single active branch.
struct +C99Branch {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    reachable: Bool
}

def +C99Branch.+mirth(f) { +c99:+mirth(f) }

def +C99.start-branch! [ +C99 reachable:Bool env:C99Env -- +C99Branch ] {
    >+c99 +C99Stack.+Nil >+stack +C99Branch
}

def +C99Branch.end-branch! [ +C99Branch -- +C99 reachable:Bool env:C99Env ] {
    +stack(+C99Stack.+Nil) rswap push-stack-direct!
    /+C99Branch +c99> +stack> rdrop
}

def +C99Branch.flush-cache! [ +C99Branch -- +C99Branch ] {
    end-branch!
    start-branch!
}

def +C99Branch.pop-value! [ +C99Branch C99ReprType -- +C99Branch +C99Value ] {
    +stack(pop-value?) rswap match {
        { +C99ValueSome -> drop }
        { +C99ValueNone -> pop-value-direct! }
    }
}

def +C99Branch.pop-value-label! [ C99ReprType Label +C99Branch -- +C99Branch +C99Value ] {
    +stack(pop-value-label?) rswap match {
        { +C99ValueSome -> drop2 }
        { +C99ValueNone -> pop-value-label-direct! }
    }
}

def +C99Branch.pop-resource! [ +C99Branch C99ReprType -- +C99Branch +C99Resource ] {
    +stack(pop-resource?) rswap match {
        { +C99ResourceSome -> drop }
        { +C99ResourceNone -> pop-resource-direct! }
    }
}

def +C99Branch.pop-resource-label! [ C99ReprType Label +C99Branch -- +C99Branch +C99Resource ] {
    +stack(pop-resource-label?) rswap match {
        { +C99ResourceSome -> drop2 }
        { +C99ResourceNone -> pop-resource-label-direct! }
    }
}

def +C99Value.push-value! [ +C99Branch +C99Value -- +C99Branch ] {
    rswap +stack(rswap +C99Stack.+Cons)
}

def +C99Resource.push-resource! [ +C99Branch +C99Resource -- +C99Branch ] {
    rswap +stack(rswap +C99Stack.+With)
}

def +C99Branch.type-to-c99-repr [ Type +C99Branch -- C99ReprType +C99Branch ] { +mirth:c99-repr }
def +C99Branch.resource-to-c99-repr [ Resource +C99Branch -- C99ReprType +C99Branch ] { +mirth:c99-repr }

def +C99Branch.pop-value-from-stack-type! [ StackType +C99Branch -- StackType +C99Branch +C99Value ] {
    force-cons?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2
    type-to-c99-repr pop-value!
}
def +C99Branch.pop-resource-from-stack-type! [ StackType +C99Branch -- StackType +C99Branch +C99Resource ] {
    force-with?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2
    resource-to-c99-repr pop-resource!
}

def +C99Branch.pop-value-label-from-stack-type! [ Label StackType +C99Branch -- StackType +C99Branch +C99Value ] {
    dip:dup force-cons-label?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2 type-to-c99-repr
    rotl pop-value-label!
}

def +C99Branch.pop-resource-label-from-stack-type! [ Label StackType +C99Branch -- StackType +C99Branch +C99Resource ] {
    dip:dup force-with-label?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2 resource-to-c99-repr
    rotl pop-resource-label!
}

def c99-prim! [ Atom Prim +C99Branch -- +C99Branch ] {
    { Id -> drop }
    { Drop ->
        dom pop-value-from-stack-type! drop
        drop-value!
    }
    { Dup ->
        dom pop-value-from-stack-type! drop
        dup-value! rdip:push-value! push-value!
    }
    { Swap ->
        dom
        pop-value-from-stack-type! >+b
        pop-value-from-stack-type! >+a
        drop
        +b> push-value!
        +a> push-value!
    }
    { RSwap ->
        dom
        pop-resource-from-stack-type! >+b
        pop-resource-from-stack-type! >+a
        drop
        +b> push-resource!
        +a> push-resource!
    }
    { Dip ->
        dup args single? unwrap(token "unexpected number of arguments to Dip" +mirth:emit-fatal-error!)
        swap dom pop-value-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-value!
    }
    { RDip ->
        dup args single? unwrap(token "unexpected number of arguments to RDip" +mirth:emit-fatal-error!)
        swap dom pop-resource-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-resource!
    }
    { If ->
        dup args >L2? unwrap(token "unexpected number of arguments to If" +mirth:emit-fatal-error!)
        /L2 C99ReprType.Bool pop-value! >+cond

        rotl +mirth:cod
        begin-branch-split!
        c99-line("if (" put +cond> C99ReprType.Bool consume-as put ") {" put)
        c99-nest:sub-branch(swap c99-arg-run!)
        c99-line("} else {" put)
        c99-nest:sub-branch(c99-arg-run!)
        c99-line("}" put)
        end-branch-split!
    }
    { While ->
        dup args >L2? unwrap(token "unexpected number of arguments to While" +mirth:emit-fatal-error!)
        nip /L2 over c99-arg-run!
        C99ReprType.Bool pop-value! push-value!
        refresh-branch! +stack(rdup >+knot)
        C99ReprType.Bool dup pop-value! consume-as
        c99-line("while (" put put ") {" put)
        c99-nest(
            refresh-branch!
            c99-arg-run!
            c99-arg-run!
            +knot> tie-knot!
        )
        c99-line("}" put)
        C99ReprType.Bool pop-value! rdrop
    }
    { Debug -> drop flush-cache! c99-line("trace_stack();" put) }
    { Panic ->
        drop
        C99ReprType.STR dup pop-value! consume-as
        c99-line("do_panic(" put put ");" put)
        +stack(rdrop +C99Stack.+Nil)
        False reachable!
    }
    { Run ->
        dup args empty? else(token "expected no arguments to prim-core-run" +mirth:emit-fatal-error!) drop
        C99ReprType.VAL pop-value! run-value!
    }

    { IntEq  -> drop "(" C99ReprType.I64 " == " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { IntLt  -> drop "(" C99ReprType.I64 " < "  C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { IntLe  -> drop "(" C99ReprType.I64 " <= " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { IntGt  -> drop "(" C99ReprType.I64 " > "  C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { IntGe  -> drop "(" C99ReprType.I64 " >= " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { IntNe  -> drop "(" C99ReprType.I64 " != " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { IntAdd -> drop "i64_add(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { IntSub -> drop "i64_sub(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { IntMul -> drop "i64_mul(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { IntDiv -> drop "i64_div(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { IntMod -> drop "i64_mod(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { IntAnd -> drop "(" C99ReprType.U64 " & "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { IntXor -> drop "(" C99ReprType.U64 " ^ "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { IntOr  -> drop "(" C99ReprType.U64 " | "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { IntShl -> drop "u64_shl(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { IntShr -> drop "u64_shr(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { IntToI64 -> drop }
    { IntToF32 -> drop "(float)"   C99ReprType.I64 ""  C99ReprType.F32 Some c99-unop! }
    { IntToF64 -> drop "(double)"  C99ReprType.I64 ""  C99ReprType.F64 Some c99-unop! }
    { IntToStr -> drop "i64_show(" C99ReprType.I64 ")" C99ReprType.STR Some c99-unop! }

    { U8Get  -> drop "*(uint8_t*)"  C99ReprType.PTR "" C99ReprType.U8  Some c99-unop! }
    { U8Set  -> drop "*(uint8_t*)"  C99ReprType.PTR " = " C99ReprType.U8  ";" True None c99-binop! }

    { U16Get -> drop "*(uint16_t*)" C99ReprType.PTR "" C99ReprType.U16 Some c99-unop! }
    { U16Set -> drop "*(uint16_t*)" C99ReprType.PTR " = " C99ReprType.U16 ";" True None c99-binop! }

    { U32Get -> drop "*(uint32_t*)" C99ReprType.PTR "" C99ReprType.U32 Some c99-unop! }
    { U32Set -> drop "*(uint32_t*)" C99ReprType.PTR " = " C99ReprType.U32 ";" True None c99-binop! }

    { U64Get -> drop "*(uint64_t*)" C99ReprType.PTR "" C99ReprType.U64 Some c99-unop! }
    { U64Set -> drop "*(uint64_t*)" C99ReprType.PTR " = " C99ReprType.U64 ";" True None c99-binop! }

    { I8Get  -> drop "*(int8_t*)"   C99ReprType.PTR "" C99ReprType.I8  Some c99-unop! }
    { I8Set  -> drop "*(int8_t*)"   C99ReprType.PTR " = " C99ReprType.I8  ";" True None c99-binop! }

    { I16Get -> drop "*(int16_t*)"  C99ReprType.PTR "" C99ReprType.I16 Some c99-unop! }
    { I16Set -> drop "*(int16_t*)"  C99ReprType.PTR " = " C99ReprType.I16 ";" True None c99-binop! }

    { I32Get -> drop "*(int32_t*)"  C99ReprType.PTR "" C99ReprType.I32 Some c99-unop! }
    { I32Set -> drop "*(int32_t*)"  C99ReprType.PTR " = " C99ReprType.I32 ";" True None c99-binop! }

    { I64Get -> drop "*(int64_t*)"  C99ReprType.PTR "" C99ReprType.I64 Some c99-unop! }
    { I64Set -> drop "*(int64_t*)"  C99ReprType.PTR " = " C99ReprType.I64 ";" True None c99-binop! }
    { I64ToInt -> drop }

    # { PRIM_F32_SET -> drop "*(float*)"    C99ReprType.PTR " = " C99ReprType.F32 ";" True None c99-binop! }
    { F32Lt  -> drop "(" C99ReprType.F32 " < "  C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Eq  -> drop "(" C99ReprType.F32 " == " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Add -> drop "(" C99ReprType.F32 " + "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Sub -> drop "(" C99ReprType.F32 " - "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Mul -> drop "(" C99ReprType.F32 " * "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Div -> drop "(" C99ReprType.F32 " / "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32ToInt -> drop "(int64_t)" C99ReprType.F32 ""  C99ReprType.I64 Some c99-unop! }
    { F32ToF64 -> drop "(double)"  C99ReprType.F32 ""  C99ReprType.F64 Some c99-unop! }
    { F32ToStr -> drop "f32_show(" C99ReprType.F32 ")" C99ReprType.STR Some c99-unop! }

    # { PRIM_F64_SET -> drop "*(double*)"   C99ReprType.PTR " = " C99ReprType.F64 ";" True None c99-binop! }
    { F64Eq  -> drop "(" C99ReprType.F64 " == " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Lt  -> drop "(" C99ReprType.F64 " < "  C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Add -> drop "(" C99ReprType.F64 " + "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Sub -> drop "(" C99ReprType.F64 " - "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Mul -> drop "(" C99ReprType.F64 " * "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Div -> drop "(" C99ReprType.F64 " / "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64ToInt -> drop "(int64_t)" C99ReprType.F64 ""  C99ReprType.I64 Some c99-unop! }
    { F64ToF32 -> drop "(float)"   C99ReprType.F64 ""  C99ReprType.F32 Some c99-unop! }
    { F64ToStr -> drop "f64_show(" C99ReprType.F64 ")" C99ReprType.STR Some c99-unop! }

    { BoolAnd -> drop "(" C99ReprType.Bool " && " C99ReprType.Bool ")" False C99ReprType.Bool Some c99-binop! }
    { BoolOr  -> drop "(" C99ReprType.Bool " || " C99ReprType.Bool ")" False C99ReprType.Bool Some c99-binop! }
    { BoolNot -> drop "!" C99ReprType.Bool "" C99ReprType.Bool Some c99-unop! }

    { TupPack0 -> drop 0u C99ReprType.TUP push-value-expression!("NULL" put) }
    { TupPack1 -> drop 1u c99-tup-pack! }
    { TupPack2 -> drop 2u c99-tup-pack! }
    { TupPack3 -> drop 3u c99-tup-pack! }
    { TupPack4 -> drop 4u c99-tup-pack! }
    { TupPack5 -> drop 5u c99-tup-pack! }

    { TupUnpack0 -> drop 0u C99ReprType.TUP pop-value! drop-value! }
    { TupUnpack1 -> drop 1u c99-tup-unpack! }
    { TupUnpack2 -> drop 2u c99-tup-unpack! }
    { TupUnpack3 -> drop 3u c99-tup-unpack! }
    { TupUnpack4 -> drop 4u c99-tup-unpack! }
    { TupUnpack5 -> drop 5u c99-tup-unpack! }

    { MutGet    -> drop "mut_get(" C99ReprType.PTR ")" C99ReprType.VAL Some c99-unop! }
    { MutSet    -> drop "mut_set(" C99ReprType.VAL ", " C99ReprType.PTR ");" False None c99-binop! }
    { MutIsSet -> drop "mut_is_set(" C99ReprType.PTR ")" C99ReprType.Bool Some c99-unop! }

    { PtrGet -> drop "*(void**)"    C99ReprType.PTR "" C99ReprType.PTR Some c99-unop! }
    { PtrSet -> drop "*(void**)"    C99ReprType.PTR " = " C99ReprType.PTR ";" True None c99-binop! }
    { PtrNil -> drop C99ReprType.PTR push-value-expression!("(void*)0" put) }
    { PtrEq  -> drop "(" C99ReprType.PTR " == " C99ReprType.PTR ")" False C99ReprType.Bool Some c99-binop! }
    { PtrAdd -> drop "(void*)(" C99ReprType.I64 " + (char*)" C99ReprType.PTR ")" False C99ReprType.PTR Some c99-binop! }
    { PtrSize -> drop C99ReprType.U64 push-value-expression!("sizeof(void*)" put) }
    { PtrAlloc   -> drop "ptr_alloc(" C99ReprType.U64 ");" C99ReprType.PTR Some c99-unop! }
    { PtrRealloc -> drop "ptr_realloc(" C99ReprType.PTR "," C99ReprType.U64 ")" False C99ReprType.PTR Some  c99-binop! }
    { PtrFree    -> drop "free(" C99ReprType.PTR ");" None c99-unop! }
    { PtrCopy ->
        drop
        C99ReprType.PTR pop-value! >+dst
        C99ReprType.U64 pop-value! >+len
        C99ReprType.PTR pop-value! >+src
        c99-line (
            "ptr_copy(" put
                +src> C99ReprType.PTR consume-as put
            ", " put
                +len> C99ReprType.U64 consume-as put
            ", " put
                +dst> C99ReprType.PTR consume-as put
            ");" put
        )
    }
    { PtrFill ->
        drop
        C99ReprType.PTR pop-value! >+dst
        C99ReprType.U64 pop-value! >+len
        C99ReprType.U8  pop-value! >+val
        c99-line (
            "ptr_fill(" put
                +val> C99ReprType.U8  consume-as put
            ", " put
                +len> C99ReprType.U64 consume-as put
            ", " put
                +dst> C99ReprType.PTR consume-as put
            ");" put
        )
    }

    { StrCopy -> drop "str_make(" C99ReprType.PTR ", " C99ReprType.U64 ")" False C99ReprType.STR Some c99-binop! }
    { StrNumBytes -> drop "str_size(" C99ReprType.STR ")" C99ReprType.U64 Some c99-unop! }
    { StrBase      -> drop "str_base(" C99ReprType.STR ")" C99ReprType.PTR Some c99-unop! }
    { StrCat  -> drop "str_cat(" C99ReprType.STR ", " C99ReprType.STR ")" False C99ReprType.STR Some c99-binop! }
    { StrCmp  -> drop "str_cmp(" C99ReprType.STR ", " C99ReprType.STR ")" False C99ReprType.I64 Some c99-binop! }
    { StrEq   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") == 0)" False C99ReprType.Bool Some c99-binop! }
    { StrLt   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") < 0)"  False C99ReprType.Bool Some c99-binop! }
    { StrLe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") <= 0)" False C99ReprType.Bool Some c99-binop! }
    { StrGt   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") > 0)"  False C99ReprType.Bool Some c99-binop! }
    { StrGe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") >= 0)" False C99ReprType.Bool Some c99-binop! }
    { StrNe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") != 0)" False C99ReprType.Bool Some c99-binop! }

    { StrToF32 -> args "str_to_f32" Prim.StrToF32 +mirth:type +c99:cname-type-to-c99-api c99-smart-call! }
    { StrToF64 -> args "str_to_f64" Prim.StrToF64 +mirth:type +c99:cname-type-to-c99-api c99-smart-call! }

    { SysOs   -> drop C99ReprType.I64 push-value-expression!("RUNNING_OS" put) }
    { SysArch -> drop C99ReprType.I64 push-value-expression!("RUNNING_ARCH" put) }
    { SysArgc -> drop C99ReprType.I64 push-value-expression!("global_argc" put) }
    { SysArgv -> drop C99ReprType.PTR push-value-expression!("global_argv" put) }
}

def c99-tup-pack! [ Nat +C99Branch -- +C99Branch ] {
    None >tag
    LIST(repeat(Type.Ignore StackTypePart.Cons ;)) >parts
    c99-pack-tuple! turn-into-value! push-value!
}

def c99-tup-unpack! [ Nat +C99Branch -- +C99Branch ] {
    None >tag
    dup LIST(repeat(Type.Ignore StackTypePart.Cons ;)) >parts
    C99ReprType.TUP pop-value! turn-into-resource! c99-unpack-tuple!
}

def +C99Value.run-value! [ +C99Branch +C99Value -- +C99Branch ] {
    consume-as-VAL flush-cache!
    c99-line("run_value(" put put ");" put)
}

def c99-binop! [  Str C99ReprType Str C99ReprType Str Bool Maybe(C99ReprType) +C99Branch -- +C99Branch ] {
    >out-type >args-swapped
    >sfx >arg2-type >op >arg1-type >pfx

    args-swapped> if(
        arg1-type> dup pop-value! consume-as >arg1
        arg2-type> dup pop-value! consume-as >arg2,

        arg2-type> dup pop-value! consume-as >arg2
        arg1-type> dup pop-value! consume-as >arg1
    )

    out-type> match {
        { Some -> push-value-expression!(pfx> put arg1> put op> put arg2> put sfx> put) }
        { None -> c99-line(pfx> put arg1> put op> put arg2> put sfx> put) }
    }
}

def c99-unop! [ Str C99ReprType Str Maybe(C99ReprType) +C99Branch -- +C99Branch ] {
    >out-type >sfx >arg-type >pfx
    arg-type> dup pop-value! consume-as
    out-type> match {
        { Some -> push-value-expression!(pfx> put put sfx> put) }
        { None -> c99-line(pfx> put put sfx> put) }
    }
}

def c99-args-push! [ List(Arg) +C99Branch -- +C99Branch ] {
    for(c99-arg-push!)
}
def c99-arg-push! [ Arg +C99Branch -- +C99Branch ] {
    { Block -> c99-block-push! }
}
def c99-arg-run! [ Arg +C99Branch -- +C99Branch ] {
    { Block -> c99-block-run! }
}

def c99-block-run! [ Block +C99Branch -- +C99Branch ] {
    +mirth:arrow c99-codip-arrow!
}

def c99-pack-closure-vars! [ List(Var) +C99Branch -- +C99Branch ] {
    filter(is-physical?) dup empty? if(
        drop,
        Type.Ignore StackTypePart.Cons
        over map(type StackTypePart.Cons) cons >parts
        None >tag
        for(var-dup! push-value!)
        c99-pack-tuple!
        turn-into-value!
        push-value!
    )
}

def c99-unpack-closure-vars! [ List(Var) +C99Branch -- +C99Branch +closure:+C99Value? ] {
    filter(is-physical?) dup empty? if(
        +C99Value?.+C99ValueNone >+closure
        drop,
        C99ReprType.VAL pop-value! >+tup
        @+tup:rdup consume-as-TUP >tup
        1 >i
        for(
            dup type type-to-c99-repr
            dup value-expression! (
                v-macro (
                    @tup put
                    "->cells[" put
                    @i show put
                    "]" put
                )
            )
            push-to-env!
            @i:1+
        )
        i> drop
        tup> drop
        +tup> +C99Value?.+C99ValueSome >+closure
    )
}

def c99-block-push! [ Block +C99Branch -- +C99Branch ] {
    dup +mirth:to-run-var match(
        Some -> nip c99-var-push!,
        None ->
            C99ReprType.FNPTR push-value-expression!("&" put dup +mirth:cname put)
            dup +mirth:free-vars c99-pack-closure-vars!
            drop
    )
}

def c99-var! [ Var +C99Branch -- +C99Branch ] {
    dup auto-run? if(c99-var-run!, c99-var-push!)
}

def c99-var-run! [ Var +C99Branch -- +C99Branch ] {
    var-dup! run-value!
}

def c99-var-push! [ Var +C99Branch -- +C99Branch ] {
    var-dup! push-value!
}

def reverse-pop-values-to-env! [ List(Var) +C99Branch -- +C99Branch ] {
    { Nil -> id }
    { Cons ->
        over type type-to-c99-repr pop-value!
        rdip(reverse-pop-values-to-env!)
        push-to-env!
    }
}

def pop-values-to-env! [ List(Var) +C99Branch -- +C99Branch ] {
    reverse reverse-pop-values-to-env!
}

def drop-env-var! [ Var +C99Branch -- +C99Branch ] {
    pop-from-env!
    == else("[c99] unexpected variable in environment when exiting scope" rdip:+mirth:fatal-error!)
    drop-value!
}

def drop-env-vars! [ List(Var) +C99Branch -- +C99Branch ] {
    reverse-for(drop-env-var!)
}

def c99-lambda! [ Lambda +C99Branch -- +C99Branch ] {
    dup params pop-values-to-env!
    dup body c99-arrow!
    params drop-env-vars!
}

def c99-match! [ Match +C99Branch -- +C99Branch ] {
    dup cases single? if?(
        nip c99-single-case!,

        dup scrutinee-data?
        unwrap(token "non-uniform match, not supported at present" +mirth:emit-fatal-error!)
        pop-data! >+scrutinee
        dup cod begin-branch-split!
        c99-line("switch (" put @+scrutinee:peek-data-tag put ") {" put)
        c99-nest(
            dup cases for(@+scrutinee:rdup >+scrutinee c99-case!)
            has-default-case? else(
                c99-line("default: {" put)
                c99-nest(
                    c99-line("do_panic(str_make(\"unexpected fallthrough in match\\n\", 32));" put)
                )
                c99-line("}" put)
            )
            +scrutinee> rdrop
        )
        c99-line("}" put)
        end-branch-split!
    )
}

def c99-single-case! [ Case +C99Branch -- +C99Branch ] {
    dup pattern is-default? if(
        body c99-arrow!,

    dup pattern single-tag? if?(
        c99-reverse-tag!
        body c99-arrow!,

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def c99-case! [ Case +C99BranchSplit +scrutinee:+C99Value/Resource -- +C99BranchSplit ] {
    dup pattern is-default? if(
        c99-line("default: {" put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            body c99-arrow!
        )
        c99-line("} break;" put),

    dup pattern single-tag? if?(
        c99-line("case " put dup value-show put "LL: { // " put dup name >Str put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            c99-reverse-tag!
            body c99-arrow!
        )
        c99-line("} break;" put),

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def Tag.word-cname-type [ Tag +Mirth -- Str ArrowType +Mirth ] { sip:word-cname type }
def Tag.pat-cname-type [ Tag +Mirth -- Str ArrowType +Mirth ] { sip:pat-cname type invert }
def Word.cname-type [ Word +Mirth -- Str ArrowType +Mirth ] { sip:cname type }

field(Tag.~word-c99-api, Tag, C99API)
def Tag.word-c99-api [ Tag +C99 -- C99API +C99 ] {
    dup ~word-c99-api memoize(dup +mirth:word-cname-type cname-type-to-c99-api) nip
}

field(Tag.~pat-c99-api, Tag, C99API)
def Tag.pat-c99-api [ Tag +C99 -- C99API +C99 ] {
    dup ~pat-c99-api memoize(dup +mirth:pat-cname-type cname-type-to-c99-api) nip
}

field(Word.~c99-api, Word, C99API)
def Word.c99-api [ Word +C99 -- C99API +C99 ] {
    dup ~c99-api memoize(dup +mirth:cname-type cname-type-to-c99-api) nip
}

def c99-word-sigs! [ +C99 -- +C99 ] { Word.for(dup +needs(needed?) if(c99-word-sig!, drop)) }
def c99-word-sig! [ Word +C99 -- +C99 ] { c99-api c99-smart-sig! }

def c99-block-sigs! [ +C99 -- +C99 ] { Block.for(dup +needs(needed?) if(c99-block-sig!, drop)) }
def c99-block-sig! [ Block +C99 -- +C99 ] { c99-line(c99-block-sig-put ";" put) }

def c99-block-defs! [ +C99 -- +C99 ] { Block.for(dup +needs(needed?) if(c99-block-def!, drop)) }
def c99-block-def! [ Block +C99 -- +C99 ] {
    c99-line(dup c99-block-sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-block-enter!
        dup +mirth:arrow
        dup +mirth:free-vars c99-unpack-closure-vars!
        dup +mirth:type dom expose-stack-type!
        c99-arrow!
        +closure> unwrap!(drop-value!, id)
        c99-block-exit!
    )
    c99-line("}" put)
}

def c99-block-sig-put [ Block +C99 -- +C99 ] { "static void " put +mirth:cname put " (void)" put }

def c99-block-enter! [ Block +C99 -- +C99Branch ] {
    options emit-debug-info if(
        c99-line("WORD_ENTER(" put
            dup home match(
                Main -> drop "block",
                Word -> name >Str " block" cat,
            ) put-cstr ", " put
            dup token .module source-path >Str put-cstr ", " put
            dup token row >Int show put ", " put
            dup token col >Int show put ");" put
        ) drop,
        drop
    )
    True >reachable
    List.Nil >env
    start-branch!
}

def c99-block-exit! [ Block +C99Branch -- +C99 ] {
    end-branch!
    reachable> drop
    env> drop
    options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def expose-stack-type! [ StackType +C99Branch -- +C99Branch ] {
    { Meta -> expand-if(>StackType expose-stack-type!, drop) }
    { Cons -> type-to-c99-repr pop-value! rdip:expose-stack-type! push-value! }
    { With -> resource-to-c99-repr pop-resource! rdip:expose-stack-type! push-resource! }
    { ConsLabel ->
        >label type-to-c99-repr @label pop-value-label!
        rdip:expose-stack-type! label> push-value-label! }
    { WithLabel ->
        >label resource-to-c99-repr @label pop-resource-label!
        rdip:expose-stack-type! label> push-resource-label! }
    { _ -> drop }
}

def c99-word-enter! [ Word +C99Branch -- +C99Branch ] {
    +c99:options emit-debug-info then(
        c99-line(
            "WORD_ENTER(" put
            dup name >Str put-cstr ", " put
            dup body .module source-path >Str put-cstr ", " put
            dup body row >Int show put ", " put
            dup body col >Int show put ");" put
        )
    ) drop
}

def c99-word-exit! [ Word +C99Branch -- +C99Branch ] {
    +c99:options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def c99-word-defs! [ +C99 -- +C99 ] { Word.for(dup +needs(needed?) if(c99-word-def!, drop)) }
def c99-word-def! [ Word +C99 -- +C99 ] {
    dup c99-api c99-smart-def! (
        dup c99-word-enter!
        dup +mirth:arrow c99-arrow!
        dup c99-word-exit!
    )
    drop
}

def c99-field-defs! [ +C99 -- +C99 ] { Field.for(c99-field-def!) }
def c99-field-def! [ Field +C99 -- +C99 ] { c99-line("static FIELD " put +mirth:cname put " = {0};" put) }
def c99-field-call! [ Field +C99Branch -- +C99Branch ] {
    C99ReprType.U64 pop-value! >+index
    C99ReprType.PTR push-value-expression! (
        "field_mut(&" put
        +mirth:cname put
        ", " put
        +index> C99ReprType.U64 consume-as put
        ")" put
    )
}

def c99-main! [ Arrow +C99 -- +C99 ] {
    c99-line("int main (int argc, char** argv) {" put)
    reset-fresh-counter!
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        options emit-debug-info then(
            c99-line("WORD_ENTER(" put
                "\"<main>\", " put
                dup token-start .module source-path >Str put-cstr ", " put
                dup token-start row >Int show put ", " put
                dup token-start col >Int show put ");" put)
        )
        True >reachable
        List.Nil >env
        start-branch!
        C99ReprType.I64 push-resource-expression!("0 /* The World! */" put)
        c99-arrow!
        end-branch!
        env> drop
        reachable> drop
        options emit-debug-info then(
            c99-line("WORD_EXIT;" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put)
}
