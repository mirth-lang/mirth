module(mirth.c99)

import(std.prelude)
import(std.str)
import(std.path)
import(std.list)
import(std.byte)
import(std.maybe)
import(std.either)

import(std.file)
import(std.output)

import(mirth.mirth)
import(mirth.module)
import(mirth.location)
import(mirth.token)
import(mirth.name)
import(mirth.buffer)
import(mirth.arrow)
import(mirth.word)
import(mirth.table)
import(mirth.variable)
import(mirth.external)
import(mirth.tycon)
import(mirth.type)
import(mirth.data)
import(mirth.package)
import(mirth.prim)
import(mirth.var)
import(mirth.match)
import(mirth.elab)
import(mirth.need)
import(mirth.label)
import(mirth.def)

#######
# C99 #
#######

struct C99_Options {
    output-path: Path
    emit-debug-info: Bool
}

struct +C99 {
    options: C99_Options
    depth: Nat
    fresh-counter: Nat
    put-enabled: Bool
    +needs: +Needs
    +output: +Output
    +mirth: +Mirth
}

def +C99.put [ Str +C99 -- +C99 ] { put-enabled if(+output:put, drop) }
def +C99.put-byte [ Byte +C99 -- +C99 ] { put-enabled if(+output:put-byte, drop) }
def +C99.line [ +C99 -- +C99 ] { put-enabled then(+output:line) }

def c99-start! [ Arrow C99_Options +World +Mirth -- Arrow +World +C99 ] {
    >options
    0u >depth
    0u >fresh-counter
    True >put-enabled
    +Needs.new dup determine-arrow-needs! >+needs >+mirth
    @options output-path create-file! unwrap!(+mirth> fatal-error!) +Output.start! >+output
    +C99
}

def c99-end! [ +World +C99 -- +World +Mirth ] {
    /+C99
    depth> fresh-counter> options> drop3
    put-enabled> drop
    +needs> rdrop
    +output> end! close-file!
    +mirth>
}

def +C99.reset-fresh-counter! [ +C99 -- +C99 ] {
    0u fresh-counter!
}

def +C99.fresh-nat! [ +C99 -- Nat +C99 ] {
    fresh-counter
    dup 1+ fresh-counter!
}

def +C99.with-fresh-counter(f) [ ( *a +C99 -- *b +C99 ) *a Nat +C99 -- *b Nat +C99 ] {
    fresh-counter dip(fresh-counter! f fresh-counter) fresh-counter!
}

def +C99.fresh-name! [ +C99 -- Str +C99 ] {
    "v" fresh-name-on!
}

def +C99.fresh-resource-name! [ +C99 -- Str +C99 ] {
    "r" fresh-name-on!
}

def +C99.fresh-name-on! [ Str +C99 -- Str +C99 ] {
    fresh-nat! show cat
}

def run-output-c99! [ Arrow C99_Options +World +Mirth -- +World +Mirth ] {
    num-errors 0> if(
        "There were errors, so codegen stopped." rdip:trace
        panic-diagnostics!
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-field-defs!
        c99-tag-defs!
        c99-buffers!
        c99-variables!
        c99-external-blocks!
        c99-word-sigs!
        c99-block-sigs!
        c99-main!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    )
}

field(Tag.~word-cname, Tag, Str)
field(Tag.~pat-cname, Tag, Str)
field(Buffer.~cname, Buffer, Str)
field(Variable.~cname, Variable, Str)
field(Field.~cname, Field, Str)
field(External.~cname, External, Str)
field(Prim.~cname, Prim, Str)

def Tag.word-cname [ +Mirth Tag -- +Mirth Str ] { dup ~word-cname memoize(
    Str("mtw_" ; dup qname rdip:mangled ;)) nip }
def Tag.pat-cname [ +Mirth Tag -- +Mirth Str ] { dup ~pat-cname memoize(
    Str("mtp_" ; dup qname rdip:mangled ;)) nip }
def Buffer.cname [ +Mirth Buffer -- +Mirth Str ] { dup ~cname memoize(
    Str("mbuf_" ; dup qname rdip:mangled ;)) nip }
def Variable.cname [ +Mirth Variable -- +Mirth Str ] { dup ~cname memoize(
    Str("mvar_" ; dup qname rdip:mangled ;)) nip }
def Field.cname [ +Mirth Field -- +Mirth Str ] { dup ~cname memoize(
    dup qname-hard mangled Str("mfld_" ; ;)) nip }
def External.cname [ +Mirth External -- +Mirth Str ] { dup ~cname memoize(
    dup qname-hard mangled Str("mext_" ; ;)) nip }

embed-str(c99-header-str, "src/mirth.h")
def c99-header! [ +C99 -- +C99 ] {
    "#define MIRTH_DEBUG " put
    options emit-debug-info if("1", "0") put line
    c99-header-str put line
}

def c99-buffers! [ +C99 -- +C99 ] { Buffer.for(c99-buffer!) }
def c99-buffer! [ Buffer +C99 -- +C99 ] {
    "static char " put
    dup +mirth:cname put
    "[" put size show put "] = {0};" put line
}
def c99-buffer-call! [ Buffer +C99Branch -- +C99Branch ] {
    C99RT_PTR push-value-expression!(+mirth:cname put)
}

def c99-variables! [ +C99 -- +C99 ] { Variable.for(c99-variable!) }
def c99-variable! [ Variable +C99 -- +C99 ] {
    "static VAL " put
    +mirth:cname put
    " = {0};" put line
}
def c99-variable-call! [ Variable +C99Branch -- +C99Branch ] {
    C99RT_PTR push-value-expression!("&" put +mirth:cname put)
}

def c99-tag-defs! [ +C99 -- +C99 ] { Tag.for(c99-tag-def!) }
def c99-tag-def! [ Tag +C99 -- +C99 ] {
    >tag
    @tag +mirth:prefer-inline? else(
        @tag +needs:word-needed? then(
            @tag word-c99-api c99-smart-def!(
                @tag c99-tag-body!
            )
        )

        @tag +needs:pat-needed? then(
            @tag pat-c99-api c99-smart-def!(
                @tag c99-reverse-tag-body!
            )
        )
    ) tag> drop
}

def c99-tag-body! [ Tag +C99Branch -- +C99Branch ] {
    >tag
    @tag +mirth:semi-transparent? if-some(
        input match {
            { STPConsLabel ->
                dip:type-to-c99-repr pop-value-label!
                @tag outputs-resource? if(
                    turn-into-resource! push-resource!,
                    push-value!
                )
            }
            { STPWithLabel ->
                dip:resource-to-c99-repr pop-resource-label!
                push-resource!
            }
            { STPCons ->
                type-to-c99-repr pop-value!
                @tag outputs-resource? if(
                    turn-into-resource! push-resource!,
                    push-value!
                )
            }
            { STPWith ->
                resource-to-c99-repr pop-resource!
                push-resource!
            }
        },

    @tag num-total-inputs 0= if(
        @tag .data is-enum-or-unit? if(C99RT_I64 "" >pfx "" >sfx, C99RT_VAL "MKI64(" >pfx ")" >sfx)
        @tag outputs-resource? if(
            push-resource-expression!(
                pfx> put
                @tag value-show put "LL /* " put
                @tag name >Str put " */" put
                sfx> put
            ),
            push-value-expression!(
                pfx> put
                @tag value-show put "LL /* " put
                @tag name >Str put " */" put
                sfx> put
            )
        ),

        @tag +mirth:inputs >parts
        @tag Some >tag
        c99-pack-tuple!
        @tag outputs-resource? if(
            push-resource!,
            turn-into-value! push-value!
        )
    ))
    tag> drop
}

def c99-reverse-tag-body! [ Tag +C99Branch -- +C99Branch ] {
    >tag
    @tag +mirth:semi-transparent? if-some(
        input match {
            { STPConsLabel ->
                swap type-to-c99-repr
                @tag outputs-resource? if(
                    pop-resource! turn-into-value!,
                    pop-value!
                )
                push-value-label!
            }
            { STPWithLabel ->
                swap resource-to-c99-repr
                pop-resource!
                push-resource-label!
            }
            { STPCons ->
                type-to-c99-repr
                @tag outputs-resource? if(
                    pop-resource! turn-into-value!,
                    pop-value!
                )
                push-value!
            }
            { STPWith ->
                resource-to-c99-repr pop-resource!
                push-resource!
            }
        },

    @tag num-total-inputs 0= if(
        @tag .data pop-data! rdrop, # decref is unnecessary

        @tag +mirth:inputs >parts
        @tag .data pop-data! turn-into-resource!
        @tag Some >tag
        c99-unpack-tuple!
    ))
    tag> drop
}

def +C99.tag-value-put [ +C99 Tag -- +C99 ] {
    dup value-show put "LL /* " put name >Str put " */" put
}

def c99-pack-tuple! [ +C99Branch tag:Maybe(Tag) parts:List(StackTypePart) -- +C99Branch +C99Resource ] {
    @tag len @parts len + >tuplen
    @tuplen C99RT_TUP resource-expression!("tup_new(" put @tuplen show put ")" put) >+tup
    @+tup:resource-name >tup
    c99-line(@tup put "->size = " put @tuplen show put ";" put)
    tuplen> pred >i
    parts> reverse-for(
        match {
            { STPCons -> type-to-c99-repr pop-value! consume-as-VAL }
            { STPWith -> resource-to-c99-repr pop-resource! consume-as-VAL }
            { STPConsLabel -> dip:type-to-c99-repr pop-value-label! consume-as-VAL }
            { STPWithLabel -> dip:resource-to-c99-repr pop-resource-label! consume-as-VAL }
        }
        c99-line(@tup put "->cells[" put @i show put "] = " put put ";" put)
        @i:pred
    )
    i> drop
    tag> for(c99-line(@tup put "->cells[0] = MKI64(" put tag-value-put ");" put))
    tup> drop
    +tup>
}

def c99-unpack-tuple! [ +C99Branch +C99Resource tag:Maybe(Tag) parts:List(StackTypePart) -- +C99Branch ] {
    @tag len @parts len + C99RT_TUP consume-as >tup
    tag> len >i
    parts> for(
        Str(@tup ; "->cells[" ; @i show; "]" ;)
        swap match {
            { STPCons -> type-to-c99-repr dup push-value-expression!(v-macro(put)) }
            { STPWith -> resource-to-c99-repr dup push-resource-expression!(v-macro(put)) }
            { STPConsLabel -> dip(type-to-c99-repr dup value-expression!(v-macro(put))) push-value-label! }
            { STPWithLabel -> dip(resource-to-c99-repr dup resource-expression!(v-macro(put))) push-resource-label! }
        }
        @i:succ
    )
    c99-line("tup_decref_outer(" put tup> put "," put i> show put ");" put)
}

def c99-tag-label-index [ Tag Label +C99 -- Nat +C99 ] {
    >label +mirth:inputs dup len 1+ >i
    reverse-find(@i:pred label if-some(@label ==, False))
    label> drop2 i>
}

def c99-tag-get-label! [ TagField +C99Branch -- +C99Branch ] {
    /TagField
    type/resource> >fieldty
    @tag +mirth:semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag outputs-resource? if(
                    # wrapper is resource
                    type-to-c99-repr pop-resource!
                    dup-resource-as-value!
                    rdip(push-resource!) push-value!,

                    # wrapper is value
                    drop
                )
            }

            { Right -> # field and wrapper are both resources
                drop
                C99RT_I64 push-resource-expression!("0" put)
            }
        },

        @tag .data pop-data! >+tuplevar
        fieldty> match {
            { Left -> # field is value
                type-to-c99-repr >fieldrepr
                @fieldrepr value-expression!(
                    fieldrepr> v-macro(
                        "VTUP(" put @+tuplevar:rdup consume-as-VAL put ")->cells[" put
                        @tag @label c99-tag-label-index show put
                        "]" put
                    )
                ) dup-value! rdrop push-value!
                +tuplevar> match {
                    { +Left -> # tuple is value
                        drop-value! }
                    { +Right -> # tuple is resource
                        push-resource! }
                }
            }
            { Right -> # field and tuple are resources
                resource-to-c99-repr >fieldrepr
                @fieldrepr push-resource-expression!(
                    fieldrepr> v-macro (
                        "VTUP(" put @+tuplevar:rdup consume-as-VAL put ")->cells[" put
                        @tag @label c99-tag-label-index show put
                        "]" put
                    )
                )
                +tuplevar> push-value/resource!
            }
        }
    )
    label> tag> drop2
}

def c99-tag-set-label! [ TagField +C99Branch -- +C99Branch ] {
    /TagField
    type/resource> >fieldty
    @tag +mirth:semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag .data pop-data! match {
                    { +Right -> # wrapper is resource
                        drop-resource-as-value!
                        type-to-c99-repr pop-value!
                        turn-into-resource! push-resource! }
                    { +Left -> # wrapper is value
                        drop drop-value! }
                }
            }
            { Right -> # field and wrapper are resource
                C99RT_I64 pop-resource! rdrop # vacant wrapper is unit
                drop
            }
        },

        @tag .data pop-data! >+tuplevar
        @fieldty match {
            { Left -> type-to-c99-repr pop-value! consume-as-VAL }
            { Right -> resource-to-c99-repr pop-resource! consume-as-VAL }
        } >fieldval
        +tuplevar> match {
            { +Left -> # field and tuple are both values
                consume-as-VAL >tupleval
                C99RT_VAL push-value-expression!(
                    "tup_replace(" put
                    tupleval> put
                    ", " put
                    @tag @label c99-tag-label-index show put
                    ", " put
                    fieldval> put
                    ")" put
                )
                fieldty> drop
            }
            { +Right -> # tuple is resource
                >+tuplevar
                fieldty> match {
                    { Left -> # field is value
                        type-to-c99-repr >fieldrepr
                        @fieldrepr needs-refcounting? then (
                            @fieldrepr value-expression! (
                                "VTUP(" put
                                @+tuplevar:rdup consume-as-VAL put
                                ")->cells[" put
                                @tag @label c99-tag-label-index show put
                                "]" put
                            ) drop-value!
                        )
                        fieldrepr> drop
                    }
                    { Right -> # field is resource
                        drop
                    }
                }
                c99-line(
                    "VTUP(" put
                    @+tuplevar:rdup consume-as-VAL put
                    ")->cells[" put
                    @tag @label c99-tag-label-index show put
                    "] = " put
                    fieldval> put
                    ";" put
                )
                +tuplevar>
                push-resource!
            }
        }
    )
    label> tag> drop2
}

def c99-external-blocks! [ +C99 -- +C99 ] {
    ExternalBlock.for(c99-external-block!)
}
def c99-external-block! [ ExternalBlock +C99 -- +C99 ] {
    parts for(match(
        EBPCode -> put line,
        EBPDef -> c99-external-def!
    ))
}

def External.cname-type [ External +Mirth -- Str ArrowType +Mirth ] {
    dup cname swap type
}

field(External.~c99-api, External, C99API)
def External.c99-api [ External +C99 -- C99API +C99 ] {
    dup ~c99-api memoize(dup +mirth:cname-type cname-type-to-c99-api) nip
}
def c99-external-call! [ List(Arg) External +C99Branch -- +C99Branch ] {
    +c99:c99-api c99-smart-call!
}

def c99-external-def! [ External +C99 -- +C99 ] {
    >ext
    @ext +mirth:ctype >cty

    @cty cod parts find(and(label? none?, ctype phantom? not)) >outty
    @outty if-some(ctype, Phantom) cname put " " put
    @ext symbol put

    " (" put
    @cty dom parts filter(ctype phantom? not)
    match(
        Nil -> "void" put,
        _ -> for(ctype cname put, ", " put)
    )
    ");" put line

    @ext c99-api c99-smart-def! (
        @cty dom parts
        dup len >arg-index
        reverse-for(
            dup c99-pop >expr
            dup ctype phantom? if(
                expr> drop,
                c99-line(
                    dup ctype cname put
                    " " put
                    dup c99-arg-name put
                    " = (" put
                    dup ctype cname put
                    ")(" put
                    expr> put
                    ");" put
                )
            )
            drop
            @arg-index:pred
        )

        c99-line(
            @outty for(ctype cname put " Y = " put)
            @ext symbol put "(" put

            1u !arg-index
            @cty dom parts filter-some(
                dup ctype phantom? if(drop None, c99-arg-name Some)
                @arg-index:1+
            )
            for(put, ", " put)
            ");" put
        )

        @cty cod parts for(
            sip(dup ctype phantom? if(drop "0", label? if-some(name mangled, "Y")))
            c99-push
        )
    )

    arg-index> drop
    ext> cty> outty> drop3
}

def CTypeStackPart.c99-arg-name [ arg-index:Nat CTypeStackPart +C99 -- arg-index:Nat Str +C99 ] {
    label? if-some(
        name mangled,
        Str("X" ; @arg-index show;)
    )
}

def CType.>C99ReprType [ CType -- C99ReprType ] {
    { IntLike -> drop C99RT_I64 }
    { F32Like -> drop C99RT_F32 }
    { F64Like -> drop C99RT_F64 }
    { PtrLike -> drop C99RT_PTR }
    { FnPtr   -> drop C99RT_FNPTR }
    { Phantom -> C99RT_I64 }
}

def CTypeStackPart.c99-pop [ CTypeStackPart +C99Branch -- Str +C99Branch ] {
    { CTSPCons -> >C99ReprType dup pop-value! consume-as }
    { CTSPWith -> >C99ReprType dup pop-resource! turn-into-value! consume-as }
    { CTSPConsLabel -> dip(>C99ReprType dup) pop-value-label! consume-as }
    { CTSPWithLabel -> dip(>C99ReprType dup) pop-resource-label! turn-into-value! consume-as }
}

def CTypeStackPart.c99-push [ Str CTypeStackPart +C99Branch -- +C99Branch ] {
    { CTSPCons -> >C99ReprType dup push-value-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { CTSPWith -> >C99ReprType dup push-resource-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { CTSPConsLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { CTSPWithLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
}

def +C99.indent [ +C99 -- +C99 ] { depth repeat("\t" put) }
def +C99.c99-nest(f) [ (*a +C99 -- *b +C99) *a +C99 -- *b +C99 ] { depth:succ f depth:pred }
def +C99.c99-line(f) [ (*a +C99 -- *b +C99) *a +C99 -- *b +C99 ] {
    indent f line
}
def +C99.c99-line-if(f) [ (*a +C99 -- *b +C99) *a Bool +C99 -- *b +C99 ] {
    put-enabled(tuck &&)
    dip:c99-line(f)
    put-enabled!
}

def +C99Branch.c99-line(f) [ (*a +C99 -- *b +C99) *a +C99Branch -- *b +C99Branch ] {
    reachable +c99:c99-line-if(f)
}
def +C99Branch.c99-line-if(f) [ (*a +C99 -- *b +C99) *a Bool +C99Branch -- *b +C99Branch ] {
    reachable && +c99:c99-line-if(f)
}
def +C99Branch.c99-nest(f) [ (*a +C99Branch -- *b +C99Branch) *a +C99Branch -- *b +C99Branch ] {
    +c99:depth:succ f +c99:depth:pred
}

data C99APIArgSource {
    C99AAS_Value
    C99AAS_ValueLabel [ Label ]
    C99AAS_Resource
    C99AAS_ResourceLabel [ Label ]
}

data C99APIArgMode {
    In
    Out
    InOut
    Branch
}

def C99APIArgMode.mode-arg-prefix {
    { In     -> "in_"    }
    { Out    -> "out_"   }
    { InOut  -> "inout_" }
    { Branch -> "branch_"  }
}

struct C99APIArg {
    mode: C99APIArgMode
    source: C99APIArgSource
    repr: C99ReprType
    name: Str
}

def C99APIArg.is-physical? [ C99APIArg -- Bool ] {
    repr is-physical?
}

def C99APIArg.is-physical-value? [ C99APIArg -- Bool ] {
    dup is-physical? if(
        source match {
            { C99AAS_Value -> True }
            { C99AAS_ValueLabel -> drop False }
            { _ -> drop False }
        },
        drop False
    )
}

def C99APIArg.pop-consume! [ C99APIArg +C99Branch -- +C99Branch Str ] {
    /C99APIArg mode> name> drop2 repr> dup source> match {
        { C99AAS_Value -> pop-value! consume-as }
        { C99AAS_Resource -> pop-resource! turn-into-value! consume-as }
        { C99AAS_ValueLabel -> pop-value-label! consume-as }
        { C99AAS_ResourceLabel -> pop-resource-label! turn-into-value! consume-as }
    }
}

def C99APIArg.pop-consume-physical! [ C99APIArg +C99Branch -- +C99Branch Maybe(Str) ] {
    sip:pop-consume!
    repr is-physical? if(
        Some,
        drop None
    )
}

def C99APIArg.pop-to-reserved! [ C99APIArg +C99Branch -- +C99Branch ] {
    dup pop-consume-physical! if-some(
        c99-line(swap name put " = " put put ";" put),
        drop
    )
}

def C99APIArg.push-to! [ Str C99APIArg +C99Branch -- +C99Branch ] {
    /C99APIArg name> mode> drop2 repr> source> match {
        { C99AAS_Value -> push-value-expression!(put) }
        { C99AAS_Resource -> push-resource-expression!(put) }
        { C99AAS_ValueLabel -> push-label-expression!(put) }
        { C99AAS_ResourceLabel -> push-label-expression!(put) }
    }
}

def C99APIArg.push-api-arg! [ C99APIArg +C99Branch -- +C99Branch ] {
    /C99APIArg
    name> >value-name
    repr> >value-repr
    mode> drop
    +C99Value
    source> match {
        { C99AAS_Value -> push-value! }
        { C99AAS_ValueLabel -> push-value-label! }
        { C99AAS_Resource -> turn-into-resource! push-resource! }
        { C99AAS_ResourceLabel -> turn-into-resource! push-resource-label! }
    }
}

struct C99API {
    cname: Str
    type: ArrowType
    in-params: List(C99APIArg)
    out-params-1: List(C99APIArg)
    return-param: Maybe(C99APIArg)
    out-params-2: List(C99APIArg)
    must-flush: Bool
    doesnt-return: Bool
}

def name-arg-prefix [ Name -- Str ] {
    mangled "_" cat
}

def type-arg-prefix [ Type -- Str ] {
    { TMeta -> expand-if(type-arg-prefix, drop "") }
    { TVar -> name name-arg-prefix }
    { TTable -> name name-arg-prefix }
    { TData -> name name-arg-prefix }
    { TDataPartial -> .data name name-arg-prefix }
    { TApp -> drop type-arg-prefix }
    { TMut -> dip("Mut") type-arg-prefix cat }
    { TPrim -> match {
        { PRIM_TYPE_TYPE -> "TYPE_" }
        { PRIM_TYPE_STACK -> "STACK_" }
        { PRIM_TYPE_RESOURCE -> "RESOURCE_" }
        { PRIM_TYPE_INT -> "Int_" }
        { PRIM_TYPE_F32 -> "F32_" }
        { PRIM_TYPE_F64 -> "F64_" }
        { PRIM_TYPE_PTR -> "Ptr_" }
        { PRIM_TYPE_STR -> "Str_" }
        { PRIM_TYPE_WORLD -> "World_" }
    } }
    { _ -> drop "_" }
}

def fresh-arg-name! [ +C99 mode:C99APIArgMode repr:C99ReprType Type -- +C99 mode:C99APIArgMode  repr:C99ReprType Str ] {
    @repr is-physical? if(
        dip(@mode mode-arg-prefix) type-arg-prefix cat fresh-name-on!,
        drop "0"
    )
}

def cons-fresh-arg! [ +C99 List(C99APIArg) Type C99APIArgSource mode:C99APIArgMode -- +C99 List(C99APIArg) mode:C99APIArgMode ] {
    >source
    dup +mirth:c99-repr >repr
    fresh-arg-name! >name
    @mode >mode
    C99APIArg swap cons
}

def +C99.stack-type-to-c99-api-params-aux [ StackType mode:C99APIArgMode +C99 -- mode:C99APIArgMode must-flush:Bool List(C99APIArg) +C99 ] {
    { STACK_TYPE_UNIT -> False >must-flush L0 }
    { STACK_TYPE_ERROR -> True >must-flush L0 }
    { STACK_TYPE_DONT_CARE -> True >must-flush L0 }
    { STMeta -> expand-if(>StackType stack-type-to-c99-api-params-aux, drop True >must-flush L0) }
    { STVar -> drop True >must-flush L0 }
    { STCons -> C99AAS_Value dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { STWith -> C99AAS_Resource dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { STConsLabel -> C99AAS_ValueLabel dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { STWithLabel -> C99AAS_ResourceLabel dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
}

def +C99.stack-type-to-c99-api-params [ StackType C99APIArgMode +C99 -- must-flush:Bool List(C99APIArg) +C99 ] {
    >mode
    +C99.stack-type-to-c99-api-params-aux reverse
    mode> drop
}

def +C99.cname-type-to-c99-api [ Str ArrowType +C99 -- C99API +C99 ] {
    >type >cname
    1u with-fresh-counter (
        @type dom In  stack-type-to-c99-api-params >in-params
        @type cod Out stack-type-to-c99-api-params
        split-at(is-physical-value?) uncons
        >out-params-2 >return-param >out-params-1
    ) drop
    must-flush> must-flush> || >must-flush
    @type cod linear-base-var? if-some(
        @type dom linear-base-var? if-some(
            <>,
            drop False
        ),
        False
    ) >doesnt-return
    @doesnt-return not @must-flush:&&
    C99API
}

def C99APIArg.reserve-as-new-value! [ C99APIArg +C99Branch -- C99APIArg +C99Branch ] {
    dup is-physical? if(
        dup repr new-value!
        consume swap name!,
        "0" swap name!
    )
}

def C99APIArg.reserve-as-is! [ C99APIArg +C99Branch -- +C99Branch ] {
    dup is-physical? if(
        /C99APIArg
        c99-line(
            repr> underlying-c99-type put " " put
            name> put ";" put
        )
        source> mode> drop2,
        drop
    )
}

def C99APIArg.reserve-new-expression! [ Str C99APIArg +C99Branch -- C99APIArg +C99Branch ] {
    >arg
    +c99:fresh-name! @arg:name!
    c99-line (
        @arg repr underlying-c99-type put " " put
        @arg name put " = " put
        put ";" put
    )
    arg>
}

def c99-smart-call! [ List(Arg) C99API +C99Branch -- +C99Branch ] {
    >api
    c99-args-push!
    @api in-params reverse map(pop-consume-physical!) reverse >popped-inputs
    @api must-flush then(flush-cache!)
    @api out-params-1 map(reserve-as-new-value!) >reserved-outputs-1
    @api out-params-2 map(reserve-as-new-value!) >reserved-outputs-2
    Str(
        @api cname ; "(" ;
        "" >sep
        popped-inputs> for:for(sep> ; ", " >sep ;)
        @reserved-outputs-1 @reserved-outputs-2 cat for(
            dup is-physical?
            if(sep> ; ", " >sep "&" ; name ;, drop)
        )
        sep> drop
        ")" ;
    )
    @api return-param if-some(
        @api doesnt-return if(
            swap c99-line("(void)" put put ";" put) Some,
            reserve-new-expression! Some
        ),
        c99-line(put ";" put) None
    ) >reserved-return
    api> doesnt-return not reachable:&&
    reserved-outputs-1> for(push-api-arg!)
    reserved-return>    for(push-api-arg!)
    reserved-outputs-2> for(push-api-arg!)
}

def +C99.smart-sig-put [ C99API +C99 -- +C99 ] {
    >api
    "static " put
    @api return-param if-some(
        repr underlying-c99-type put,
        "void" put
    )
    " " put
    @api cname put
    " (" put
    "" >sep
    @api in-params filter(is-physical?) for(
        sep> put ", " >sep
        dup repr underlying-c99-type put
        " " put name put
    )
    @api out-params-1 @api out-params-2 cat filter(is-physical?) for(
        sep> put ", " >sep
        dup repr underlying-c99-type put
        " *" put name put
    )
    sep> empty? then("void" put)
    ")" put
    api> drop
}

def c99-smart-sig! [ C99API +C99 -- +C99 ] {
    c99-line(smart-sig-put ";" put)
}

def c99-api-enter! [ C99API +C99 -- +C99Branch ] {
    >api
    @api in-params len
    @api out-params-1 len +
    @api out-params-2 len +
    @api return-param then(1+)
    1+ fresh-counter!
    True >reachable
    L0 >env
    start-branch!
    @api in-params for(push-api-arg!)
    api> drop
}

def c99-api-exit! [ C99API +C99Branch -- +C99 ] {
    >api
    @api out-params-2 reverse-for(
        dup pop-consume-physical! if-some(
            swap name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    @api return-param map(pop-consume!)
    @api out-params-1 reverse-for(
        dup pop-consume-physical! if-some(
            swap name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    end-branch!
    reachable> if(
        for(c99-line("return " put put ";" put)),
        drop @api return-param for(
            repr dummy-value
            c99-line("return " put put "; /* unreachable */" put)
        )
    )
    api> drop
    env> drop
}

def c99-smart-def! (f) [ (*a +C99Branch -- *b +C99Branch) *a C99API +C99 -- *b +C99 ] {
    c99-line(dup smart-sig-put " {" put)
    c99-nest(
        dup dip(c99-api-enter! f)
        c99-api-exit!
    )
    c99-line("}" put)
}

def c99-codip-arrow! [ Arrow +C99Branch -- +C99Branch ] {
    dup +mirth:type /ArrowType
    cod> split-parts >cod-parts >cod-base
    dom> split-parts >dom-parts >dom-base
    cod-base> unit? dom-base> unit? && if(
        dom-parts> dip-parts( +stack(+SNil) )
        c99-arrow!
        cod-parts> dip-parts(
            +stack(rdrop)
        ),

        cod-parts> dom-parts> drop2
        c99-arrow!
    )
}

def +C99Branch.dip-parts(f) [
    ( *a +C99Branch -- *b +C99Branch )
    *a List(StackTypePart) +C99Branch -- *b +C99Branch
] {
    pop-stack!
    rdip (f)
    push-stack!
}

||| Pop stack parts (right-to-left) into a separate stack cache.
def +C99Branch.pop-stack! [ List(StackTypePart) +C99Branch -- +C99Branch +C99Stack ] {
    +SNil reverse-for(pop-stack-part!)
}

||| Pop a part from branch to separate stack.
def +C99Stack.pop-stack-part! [ StackTypePart +C99Branch +C99Stack -- +C99Branch +C99Stack ] {
    { STPCons -> rdip(type-to-c99-repr pop-value!) rswap +SCons }
    { STPWith -> rdip(resource-to-c99-repr pop-resource!) rswap +SWith }
    { STPConsLabel -> rdip(dip:type-to-c99-repr tuck pop-value-label!) rswap +SConsLabel }
    { STPWithLabel -> rdip(dip:resource-to-c99-repr tuck pop-resource-label!) rswap +SWithLabel }
}

def +C99Stack.reverse-cat! [ +C99Stack +C99Stack -- +C99Stack ] {
    while ( match {
        { +SNil -> +SNil False }
        { +SCons -> rswap rdip:+SCons True }
        { +SWith -> rswap rdip:+SWith True }
        { +SConsLabel -> rswap rdip:+SConsLabel True }
        { +SWithLabel -> rswap rdip:+SWithLabel True }
    } ) rdrop
}

||| Push stack onto branch, right to left.
def +C99Stack.push-stack! [ +C99Branch +C99Stack -- +C99Branch ] {
    rswap +stack(rswap reverse-cat!)
}

def c99-arrow! [ Arrow +C99Branch -- +C99Branch ] { atoms for(c99-atom!) }
def c99-atom! [ Atom +C99Branch -- +C99Branch ] {
    +c99:options emit-debug-info and(dup op show-in-stack-trace?) then(
        +c99:c99-line("WORD_ATOM(" put
            dup token row >Int show put ", " put
            dup token col >Int show put ", " put
            dup token name? if-some(>Str, "") put-cstr
            ");" put
        )
    )
    dup op
    c99-atom-op!
}

def Op.show-in-stack-trace? [ Op -- Bool ] {
    { OpNone -> False }
    { OpInt -> drop False }
    { OpF64 -> drop False }
    { OpStr -> drop False }
    { OpWord -> prefer-inline? not }
    { OpExternal -> drop True }
    { OpBuffer -> drop False }
    { OpVariable -> drop False }
    { OpField -> drop False }
    { OpTag -> drop False }
    { OpPrim -> drop True }
    { OpMatch -> drop False }
    { OpLambda -> drop False }
    { OpVar -> drop False }
    { OpBlockPush -> drop False }
    { OpBlockRun -> drop False }
    { OpLabelPush -> drop False }
    { OpLabelPop -> drop False }
    { OpLabelPushR -> drop False }
    { OpLabelPopR -> drop False }
    { OpDataGetEnumValue -> drop False }
    { OpDataFromEnumValue -> drop False }
    { OpDataGetLabel -> drop False }
    { OpDataSetLabel -> drop False }
    { OpTableToIndex -> drop False }
    { OpTableFromIndex -> drop False }
}

def c99-atom-op! [ Atom Op +C99Branch -- +C99Branch ] {
    { OpNone          -> drop }
    { OpInt           -> nip c99-int! }
    { OpF64           -> nip c99-f64! }
    { OpStr           -> nip c99-str! }
    { OpWord          -> dip:args c99-word! }
    { OpExternal      -> dip:args c99-external-call! }
    { OpBuffer        -> nip c99-buffer-call! }
    { OpVariable      -> nip c99-variable-call! }
    { OpField         -> nip c99-field-call! }
    { OpTag           -> dip:args c99-tag-call! }
    { OpPrim          -> c99-prim! }
    { OpMatch         -> nip c99-match! }
    { OpLambda        -> nip c99-lambda! }
    { OpVar           -> nip c99-var! }
    { OpBlockPush     -> nip c99-block-push! }
    { OpBlockRun      -> nip c99-block-run! }
    { OpLabelPush     -> c99-label-push! }
    { OpLabelPop      -> c99-label-pop! }
    { OpLabelPushR    -> c99-label-push-r! }
    { OpLabelPopR     -> c99-label-pop-r! }
    { OpDataGetEnumValue -> nip c99-get-enum-value! }
    { OpDataFromEnumValue -> nip c99-from-enum-value! }
    { OpDataGetLabel  -> c99-tag-get-label! drop }
    { OpDataSetLabel  -> c99-tag-set-label! drop }
    { OpTableToIndex -> drop2 }
    { OpTableFromIndex -> drop2 }
}

def c99-get-enum-value! [ Data +C99Branch -- +C99Branch ] {
    >data
    @data is-enum? else(
        @data TData type-to-c99-repr pop-value! >+scrutinee
        @data is-unit? if-some(
            C99RT_I64 push-value-expression!(value show put "LL" put),

        @data +mirth:semi-transparent? if-some(
            C99RT_I64 push-value-expression!(tag value show put "LL" put),
            C99RT_I64 push-value-expression!(
                "get_data_tag(" put
                @+scrutinee:rdup consume-as-VAL put
                ")" put
            )
        ))
        +scrutinee> drop-value!
    )
    data> drop
}

def c99-from-enum-value! [ Data +C99Branch -- +C99Branch ] {
    is-enum? else("_.from-enum-value-unsafe on non-enum" +mirth:fatal-error!)
}

def c99-word! [ List(Arg) Word +C99Branch -- +C99Branch ] {
    dup prefer-inline? if(
        dip:c99-args-push!
        +mirth:arrow c99-codip-arrow!,
        +c99:c99-api c99-smart-call!
    )
}

field(Tag.~value-show, Tag, Str)
def Tag.value-show [ Tag -- Str ] { dup ~value-show memoize(dup value show) nip }

def c99-tag-call! [ List(Arg) Tag +C99Branch -- +C99Branch ] {
    dup +mirth:prefer-inline? if(
        nip c99-tag-body!,
        +c99:word-c99-api c99-smart-call!
    )
}

def c99-reverse-tag! [ Tag +C99Branch -- +C99Branch ] {
    dup +mirth:prefer-inline? if(
        c99-reverse-tag-body!,
        dip:L0 +c99:pat-c99-api c99-smart-call!
    )
}

def c99-label-defs! [ +C99 -- +C99 ] { Label.for(c99-label-def!) }
def c99-label-def! [ Label +C99 -- +C99 ] { "static STACK lbl_" put name mangled put " = {0};" put line }

def push-value-label-direct! [ Label +C99Branch +C99Value -- +C99Branch ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-value-label! [ Label +C99Branch +C99Value -- +C99Branch ] {
    rswap +stack(rswap +SConsLabel)
}
def push-resource-label-direct! [ Label +C99Branch +C99Resource -- +C99Branch ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-resource-label! [ Label +C99Branch +C99Resource -- +C99Branch ] {
    rswap +stack(rswap +SWithLabel)
}

def pop-value-label-direct! [ C99ReprType Label +C99Branch -- +C99Branch +C99Value ] {
    swap dup value-expression!(
        v-macro("lpop(&lbl_" put name mangled put ")" put)
    )
}

def pop-resource-label-direct! [ C99ReprType Label +C99Branch -- +C99Branch +C99Resource ] {
    swap dup resource-expression!(
        v-macro("lpop(&lbl_" put name mangled put ")" put)
    )
}

def c99-label-push! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-value-from-stack-type! drop
    push-value-label!
}
def c99-label-push-r! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-resource-from-stack-type! drop
    push-resource-label!
}
def c99-label-pop! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-value-label-from-stack-type! drop
    push-value!
}
def c99-label-pop-r! [ Atom Label +C99Branch -- +C99Branch ] {
    swap dom pop-resource-label-from-stack-type! drop
    push-resource!
}

def c99-int! [ Int +C99Branch -- +C99Branch ] {
    C99RT_I64 push-value-expression!(show put "LL" put)
}

def c99-f64! [ F64 +C99Branch -- +C99Branch ] {
    C99RT_F64 push-value-expression!(>Str put)
}

def c99-str! [ Str +C99Branch -- +C99Branch ] {
    C99RT_STR new-value! >+str
    dup num-bytes 4090 .u >USize > if(
        c99-line("STRLIT(" put @+str:rdup consume put "," put)
        c99-nest(
            c99-line(dup put-cstr-long "," put)
            c99-line(dup num-bytes show put)
        )
        c99-line(");" put),

        c99-line("STRLIT(" put
            @+str:rdup consume put ", " put
            dup put-cstr ", " put
            dup num-bytes show put ");" put)
    ) drop

    +str> push-value!
}

def +C99.put-cstr-long [ Str +C99 -- +C99 ] {
    False >avoid-hexdigit
    BQUOTE put-byte
    BNUL swap bytes-for(
        swap BLF == then(
            BQUOTE put-byte
            line indent
            BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    BQUOTE put-byte
    avoid-hexdigit> drop2
}

def +C99.put-cstr [ Str +C99 -- +C99 ] {
    False >avoid-hexdigit
    BQUOTE put-byte bytes-for(c99-string-byte!) BQUOTE put-byte
    avoid-hexdigit> drop
}

def c99-string-byte! [ Byte avoid-hexdigit:Bool +C99 -- avoid-hexdigit:Bool +C99 ] {
    { B'\' ->   "\\\\" put False !avoid-hexdigit }
    { BQUOTE -> "\\\"" put False !avoid-hexdigit }
    { BHT ->    "\\t"  put False !avoid-hexdigit }
    { BLF ->    "\\n"  put False !avoid-hexdigit }
    { BCR ->    "\\r"  put False !avoid-hexdigit }
    { _ ->
        dup BSPACE B'~' in-range
        and(dup is-hexdigit @avoid-hexdigit && not) if(
            put-byte
            False !avoid-hexdigit,
            "\\x" put to-hexdigits dip(put-byte) put-byte
            True !avoid-hexdigit
        )
    }
}

data C99ReprType {
    0 C99RT_UNIT

    C99RT_VAL
    C99RT_STR
    C99RT_TUP [ Nat ]

    C99RT_I64 C99RT_I32 C99RT_I16 C99RT_I8
    C99RT_U64 C99RT_U32 C99RT_U16 C99RT_U8
    C99RT_F64 C99RT_F32
    C99RT_BOOL
    C99RT_PTR
    C99RT_FNPTR
}

def C99ReprType.== [ C99ReprType C99ReprType -- Bool ] {
    { C99RT_TUP -> swap match { C99RT_TUP -> ==, _ -> drop2 False } }
    { _ -> on2:enum-value == }
}

inline (
    def C99ReprType.is-unit? [ C99ReprType -- Bool ] { enum-value 0= }
    def C99ReprType.is-physical? [ C99ReprType -- Bool ] { enum-value 0 <> }
    def C99ReprType.<> [ C99ReprType C99ReprType -- Bool ] { == not }
)

def C99ReprType.needs-refcounting? [ C99ReprType -- Bool ] {
    { C99RT_VAL -> True }
    { C99RT_STR -> True }
    { C99RT_TUP -> drop True }

    { C99RT_UNIT -> False }
    { C99RT_I64 -> False } { C99RT_I32 -> False } { C99RT_I16 -> False } { C99RT_I8 -> False }
    { C99RT_U64 -> False } { C99RT_U32 -> False } { C99RT_U16 -> False } { C99RT_U8 -> False }
    { C99RT_F64 -> False } { C99RT_F32 -> False }
    { C99RT_BOOL -> False }
    { C99RT_PTR -> False }
    { C99RT_FNPTR -> False }
}

def C99ReprType.is-int-like? [ C99ReprType -- Bool ] {
    { C99RT_I64 -> True } { C99RT_I32 -> True } { C99RT_I16 -> True } { C99RT_I8 -> True }
    { C99RT_U64 -> True } { C99RT_U32 -> True } { C99RT_U16 -> True } { C99RT_U8 -> True }
    { C99RT_BOOL -> True }
    { _ -> drop False }
}

def C99ReprType.is-float-like? [ C99ReprType -- Bool ] {
    { C99RT_F64 -> True } { C99RT_F32 -> True }
    { _ -> drop False }
}

def C99ReprType.dummy-value [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "(VAL){0}"  }
    { C99RT_STR   -> "NULL"      }
    { C99RT_UNIT  -> "0"         }
    { C99RT_I64   -> "0"         }
    { C99RT_I32   -> "0"         }
    { C99RT_I16   -> "0"         }
    { C99RT_I8    -> "0"         }
    { C99RT_U64   -> "0"         }
    { C99RT_U32   -> "0"         }
    { C99RT_U16   -> "0"         }
    { C99RT_U8    -> "0"         }
    { C99RT_F64   -> "0.0"       }
    { C99RT_F32   -> "0.0"       }
    { C99RT_BOOL  -> "0"         }
    { C99RT_PTR   -> "NULL"      }
    { C99RT_FNPTR -> "NULL"      }
    { C99RT_TUP   -> drop "NULL" }
}

def C99ReprType.underlying-c99-type [ C99ReprType -- Str ] {
    { C99RT_VAL   -> "VAL"      }
    { C99RT_STR   -> "STR*"     }
    { C99RT_UNIT  -> "int64_t"  }
    { C99RT_I64   -> "int64_t"  }
    { C99RT_I32   -> "int32_t"  }
    { C99RT_I16   -> "int16_t"  }
    { C99RT_I8    -> "int8_t"   }
    { C99RT_U64   -> "uint64_t" }
    { C99RT_U32   -> "uint32_t" }
    { C99RT_U16   -> "uint16_t" }
    { C99RT_U8    -> "uint8_t"  }
    { C99RT_F64   -> "double"   }
    { C99RT_F32   -> "float"    }
    { C99RT_BOOL  -> "bool"     }
    { C99RT_PTR   -> "void*"    }
    { C99RT_FNPTR -> "FNPTR"    }
    { C99RT_TUP   -> drop "TUP*"  }
}

def C99ReprType.v-macro(f) [ (*a +C99 -- *b +C99) *a +C99 C99ReprType -- *b +C99 ] {
    v-macro-prefix-suffix
    dip(put f) put
}

def C99ReprType.v-macro-prefix-suffix [ C99ReprType -- Str Str ] {
    { C99RT_VAL   -> "" "" }
    { C99RT_STR   -> "value_str(" ")" }
    { C99RT_UNIT  -> "(" ", 0)" }
    { C99RT_I64   -> "value_i64(" ")" }
    { C99RT_I32   -> "value_i32(" ")" }
    { C99RT_I16   -> "value_i16(" ")" }
    { C99RT_I8    -> "value_i8(" ")" }
    { C99RT_U64   -> "value_u64(" ")" }
    { C99RT_U32   -> "value_u32(" ")" }
    { C99RT_U16   -> "value_u16(" ")" }
    { C99RT_U8    -> "value_u8(" ")" }
    { C99RT_F64   -> "value_f64(" ")" }
    { C99RT_F32   -> "value_f32(" ")" }
    { C99RT_BOOL  -> "value_bool(" ")" }
    { C99RT_PTR   -> "value_ptr(" ")" }
    { C99RT_FNPTR -> "value_fnptr(" ")" }
    { C99RT_TUP   -> "value_tup(" swap Str(", "; show ; ")";) }
}

def C99ReprType.mk-macro [ Str C99ReprType -- Str ] {
    { C99RT_VAL   -> id }
    { C99RT_STR   -> Str( "MKSTR(" ; ; ")" ; ) }
    { C99RT_UNIT  -> Str( "MKI64(" ; ; ")" ; ) }
    { C99RT_I64   -> Str( "MKI64(" ; ; ")" ; ) }
    { C99RT_I32   -> Str( "MKI32(" ; ; ")" ; ) }
    { C99RT_I16   -> Str( "MKI16(" ; ; ")" ; ) }
    { C99RT_I8    -> Str( "MKI8("  ; ; ")" ; ) }
    { C99RT_U64   -> Str( "MKU64(" ; ; ")" ; ) }
    { C99RT_U32   -> Str( "MKU32(" ; ; ")" ; ) }
    { C99RT_U16   -> Str( "MKU16(" ; ; ")" ; ) }
    { C99RT_U8    -> Str( "MKU8(" ; ; ")" ; ) }
    { C99RT_F64   -> Str( "MKF64(" ; ; ")" ; ) }
    { C99RT_F32   -> Str( "MKF32(" ; ; ")" ; ) }
    { C99RT_BOOL  -> Str( "MKBOOL(" ; ; ")" ; ) }
    { C99RT_PTR   -> Str( "MKPTR(" ; ; ")" ; ) }
    { C99RT_FNPTR -> Str( "MKFNPTR(" ; ; ")" ; ) }
    { C99RT_TUP   -> swap Str( "MKTUP(" ; ; ", " ; show ; ")" ; ) }
}

def Resource.c99-repr [ Resource +Mirth -- C99ReprType +Mirth ] {
    >Type c99-repr
}

def Type.c99-repr [ Type +Mirth -- C99ReprType +Mirth ] {
    { TYPE_ERROR -> C99RT_VAL }
    { TYPE_DONT_CARE -> C99RT_VAL }
    { TPrim -> c99-repr }
    { TMeta -> expand-if(c99-repr, drop C99RT_VAL) }
    { THole -> drop C99RT_VAL }
    { TVar -> drop C99RT_VAL }
    { TTable -> drop C99RT_U64 }
    { TData -> c99-repr }
    { TDataPartial -> .data c99-repr }
    { TMorphism -> drop C99RT_VAL }
    { TTensor -> tuple-c99-repr }
    { TApp -> drop c99-repr }
    { TMut -> drop C99RT_PTR }
    { TValue -> drop C99RT_VAL }
}

def StackType.tuple-c99-repr [ StackType -- C99ReprType ] {
    split-parts swap match {
        { STB_UNIT -> len dup 0= if (drop C99RT_UNIT, C99RT_TUP) }
        { _ -> drop2 C99RT_VAL }
    }
}

def PrimType.c99-repr [ PrimType -- C99ReprType ] {
    { PRIM_TYPE_TYPE -> C99RT_VAL }
    { PRIM_TYPE_STACK -> C99RT_VAL }
    { PRIM_TYPE_RESOURCE -> C99RT_VAL }
    { PRIM_TYPE_INT -> C99RT_I64 }
    { PRIM_TYPE_F32 -> C99RT_F32 }
    { PRIM_TYPE_F64 -> C99RT_F64 }
    { PRIM_TYPE_STR -> C99RT_VAL }
    { PRIM_TYPE_PTR -> C99RT_PTR }
    { PRIM_TYPE_WORLD -> C99RT_UNIT }
}

def Data.c99-repr [ Data +Mirth -- C99ReprType +Mirth ] {
    >dat
    @dat is-unit? if(C99RT_UNIT,
    @dat is-enum? if(C99RT_I64,
    @dat semi-transparent? if-some(
        input type/resource either(c99-repr, c99-repr),
        C99RT_VAL
    )))
    dat> drop
}

struct +C99Value {
    value-repr: C99ReprType
    value-name: Str
}

def +C99Value.rdup [ +C99Value -- +C99Value +C99Value ] {
    value-repr >value-repr
    value-name >value-name
    +C99Value
}

def +C99Value.rdrop [ +C99Value -- ] {
    /+C99Value
    value-repr> drop
    value-name> drop
}

def C99ReprType.new-value! [ C99ReprType +C99Branch -- +C99Branch +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put ";" put)
    +C99Value
}

def C99ReprType.pop-value-direct! [ C99ReprType +C99Branch -- +C99Branch +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put " = " put
             @value-repr v-macro ( "pop_value()" put ) ";" put)
    +C99Value
}

||| Push a value with a certain repr type on the stack.
||| `f` must emit the C99 expression that calculates the value,
||| which must be of the underlying C99 repr type.
def C99ReprType.push-value-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
] {
    value-expression!(f) push-value!
}

def C99ReprType.push-resource-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
] {
    resource-expression!(f) push-resource!
}

def push-label-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType Label +C99Branch -- *b +C99Branch
] {
    dip:value-expression!(f)
    dup is-resource-label? if(
        turn-into-resource! push-resource-label!,
        push-value-label!
    )
}

def C99ReprType.value-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch +C99Value
] {
    dup >value-repr is-physical? dup
    if(+c99:fresh-name!, "0") >value-name
    c99-line-if(
        @value-repr underlying-c99-type put " " put
        @value-name put " = " put
        +C99Value rdip:f rswap ";" put
    ) rswap
}

def C99ReprType.resource-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch +C99Resource
] {
    dup >resource-repr is-physical? dup
    if(+c99:fresh-name!, "0") >resource-name
    c99-line-if(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        +C99Resource rdip:f rswap ";" put
    ) rswap
}

def +C99Value.push-value-direct! [ +C99Branch +C99Value -- +C99Branch ] {
    consume-as-VAL
    c99-line("push_value(" put put ");" put)
}

def +C99Value.consume [ +C99Value -- Str ] {
    /+C99Value value-repr> drop value-name>
}

def +C99Value.consume-as-VAL [ +C99Value -- Str ] {
    /+C99Value value-name> value-repr> mk-macro
}

def +C99Value.consume-as [ C99ReprType +C99Value -- Str ] {
    { C99RT_VAL -> consume-as-VAL }
    { C99RT_UNIT -> rdrop "0" }
    { _ ->
        /+C99Value
        @value-repr match {
            { C99RT_VAL -> Str( v-macro-prefix-suffix dip(; value-name> ;) ; ) }
            { _ ->
                over == if(
                    drop value-name>,
                    dup is-int-like? @value-repr is-int-like? && if(
                        Str( "((" ; underlying-c99-type ; ")" ; value-name> ; ")" ; ),
                        Str( "(\n#error \"attempted to cast " ; value-name> ; " to incompatible C99 repr type " ;
                            underlying-c99-type ; "\"\n" ; )
                    )
                )
            }
        }
        value-repr> drop
    }
}

def +C99Value.drop-value! [ +C99Branch +C99Value -- +C99Branch ] {
    value-repr needs-refcounting? if(
        consume-as-VAL +c99:c99-line("decref(" put put ");" put),
        rdrop
    )
}

def +C99Value.dup-value! [ +C99Branch +C99Value -- +C99Branch +C99Value +C99Value ] {
    value-repr needs-refcounting? then(
        rdup consume-as-VAL rdip:+c99:c99-line("incref(" put put ");" put)
    )
    rdup
}

def +C99Value.peek-data-tag [ +C99Value -- +C99Value Str ] {
    turn-into-resource! peek-data-tag turn-into-value!
}

struct +C99Resource {
    resource-repr: C99ReprType
    resource-name: Str
}

def +C99Resource.rdup [ +C99Resource -- +C99Resource +C99Resource ] {
    resource-repr >resource-repr
    resource-name >resource-name
    +C99Resource
}

def +C99Resource.rdrop [ +C99Resource -- ] {
    consume drop
}

def +C99Value.turn-into-resource! [ +C99Value -- +C99Resource ] {
    /+C99Value
    value-repr> >resource-repr
    value-name> >resource-name
    +C99Resource
}

def +C99Resource.turn-into-value! [ +C99Resource -- +C99Value ] {
    /+C99Resource
    resource-repr> >value-repr
    resource-name> >value-name
    +C99Value
}

def +C99Resource.drop-resource-as-value! [ +C99Branch +C99Resource -- +C99Branch ] {
    turn-into-value! drop-value!
}

def +C99Resource.dup-resource-as-value! [ +C99Branch +C99Resource -- +C99Branch +C99Resource +C99Value ] {
    rdup turn-into-value! rswap rdip(dup-value! rdrop) rswap
}

def +C99Resource.consume [ +C99Resource -- Str ] {
    /+C99Resource
    resource-repr> drop
    resource-name>
}

def +C99Resource.consume-as [ C99ReprType +C99Resource -- Str ] {
    turn-into-value! consume-as
}

def +C99Resource.consume-as-VAL [ +C99Resource -- Str ] {
    /+C99Resource resource-name> resource-repr> mk-macro
}

def +C99Branch.pop-resource-direct! [ +C99Branch C99ReprType -- +C99Branch +C99Resource ] {
    >resource-repr
    +c99:fresh-resource-name! >resource-name
    c99-line(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        @resource-repr v-macro( "pop_resource()" put )
        ";" put
    )
    +C99Resource
}

def +C99Resource.push-resource-direct! [ +C99Branch +C99Resource -- +C99Branch ] {
    consume-as-VAL
    c99-line("push_resource(" put put ");" put)
}

def +C99Resource.peek-data-tag [ +C99Resource -- +C99Resource Str ] {
    resource-repr is-int-like? if(
        resource-name,
        rdup consume-as-VAL Str("get_data_tag(" ; ; ")";)
    )
}

data +C99Value/Resource {
    +Left  [ +C99Value ]
    +Right [ +C99Resource ]
}

def +C99Value.>Value/Resource { +C99Value/Resource.+Left }
def +C99Resource.>Value/Resource { +C99Value/Resource.+Right }
def +C99Value/Resource.push-value/resource! {
    { +Left -> push-value! }
    { +Right -> push-resource! }
}
def +C99Value/Resource.peek-data-tag [ +C99Value/Resource -- +C99Value/Resource Str ] {
    { +Left -> peek-data-tag +Left }
    { +Right -> peek-data-tag +Right }
}
def +C99Value/Resource.rdup [ +C99Value/Resource -- +C99Value/Resource +C99Value/Resource ] {
    { +Left -> rdup +Left rdip(+Left) }
    { +Right -> rdup +Right rdip(+Right) }
}
def +C99Value/Resource.rdrop  [ +C99Value/Resource -- ] {
    { +Left -> rdrop }
    { +Right -> rdrop }
}
def +C99Value/Resource.consume-as-VAL [ +C99Value/Resource -- Str ] {
    { +Left -> consume-as-VAL }
    { +Right -> consume-as-VAL }
}

def +C99Branch.pop-data! [ Data +C99Branch -- +C99Branch +C99Value/Resource ] {
    dup is-resource? if(
        +mirth:c99-repr pop-resource! +C99Value/Resource.+Right,
        +mirth:c99-repr pop-value! +C99Value/Resource.+Left
    )
}

def +C99Value/Resource.turn-into-resource! [ +C99Value/Resource -- +C99Resource ] {
    { +Left -> turn-into-resource! }
    { +Right -> id }
}

data +C99Value? {
    +C99ValueNone
    +C99ValueSome [ +C99Value ]
}

def +C99Value?.unwrap!(f,g) {
    { +C99ValueSome -> f }
    { +C99ValueNone -> g }
}

data +C99Resource? {
    +C99ResourceNone
    +C99ResourceSome [ +C99Resource ]
}

def +C99Branch.refresh-branch! [ +C99Branch -- +C99Branch ] {
    /+C99Branch
    +c99> +stack>
    refresh-all!
}

def +C99Stack.refresh-all! [ +C99 +C99Stack reachable:Bool env:C99Env -- +C99Branch ] {
    { +SNil -> start-branch! }
    { +SCons ->
        >+x refresh-all!
        @+x:value-repr push-value-expression!(+x> consume put)
    }
    { +SWith ->
        >+x refresh-all!
        @+x:resource-repr push-resource-expression!(+x> consume put)
    }
    { +SConsLabel ->
        >+x refresh-all!
        @+x:value-repr swap push-label-expression!(+x> consume put)
    }
    { +SWithLabel ->
        >+x refresh-all!
        @+x:resource-repr swap push-label-expression!(+x> consume put)
    }
}

def +C99Stack.tie-knot! [ +C99Branch +C99Stack -- +C99Branch ] {
    { +SNil -> flush-cache! }
    { +SCons ->
        value-repr dup rdip2(pop-value! consume-as)
        value-name
        value-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        push-value!
    }
    { +SWith ->
        resource-repr dup rdip2(pop-resource! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        push-resource!
    }
    { +SConsLabel -> >label
        value-repr dup rdip2(@label pop-value-label! consume-as)
        value-name
        value-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        label> push-value-label!
    }
    { +SWithLabel -> >label
        resource-repr dup rdip2(@label pop-resource-label! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        label> push-resource-label!
    }
}

data +C99Stack {
    +SNil
    +SCons [ +C99Stack +C99Value ]
    +SWith [ +C99Stack +C99Resource ]
    +SConsLabel [ +C99Stack +C99Value Label ]
    +SWithLabel [ +C99Stack +C99Resource Label ]
}

def +C99Stack.pop-value? [ +C99Stack -- +C99Value? +C99Stack ] {
    { +SNil -> +C99ValueNone +SNil }
    { +SCons -> +C99ValueSome rswap }
    { +SWith -> rdip:pop-value? +SWith }
    { +SConsLabel -> rdip:pop-value? +SConsLabel }
    { +SWithLabel -> rdip:pop-value? +SWithLabel }
}

def +C99Stack.pop-resource? [ +C99Stack -- +C99Resource? +C99Stack ] {
    { +SNil -> +C99ResourceNone +SNil }
    { +SWith -> +C99ResourceSome rswap }
    { +SCons -> rdip:pop-resource? +SCons }
    { +SConsLabel -> rdip:pop-resource? +SConsLabel }
    { +SWithLabel -> rdip:pop-resource? +SWithLabel }
}

def +C99Stack.pop-value-label? [ Label +C99Stack -- Label +C99Value? +C99Stack ] {
    { +SNil -> +C99ValueNone +SNil }
    { +SCons -> rdip:pop-value-label? +SCons }
    { +SWith -> rdip:pop-value-label? +SWith }
    { +SWithLabel -> dip:rdip:pop-value-label? +SWithLabel }
    { +SConsLabel ->
        dup2 == if(
            drop +C99ValueSome rswap,
            dip:rdip:pop-value-label? +SConsLabel
        )
    }
}

def +C99Stack.pop-resource-label? [ Label +C99Stack -- Label +C99Resource? +C99Stack ] {
    { +SNil -> +C99ResourceNone +SNil }
    { +SCons -> rdip:pop-resource-label? +SCons }
    { +SWith -> rdip:pop-resource-label? +SWith }
    { +SConsLabel -> dip:rdip:pop-resource-label? +SConsLabel }
    { +SWithLabel ->
        dup2 == if(
            drop +C99ResourceSome rswap,
            dip:rdip:pop-resource-label? +SWithLabel
        )
    }
}

def +C99Stack.push-stack-direct! [ +C99Branch +C99Stack -- +C99Branch ] {
    { +SNil -> }
    { +SCons -> rdip:push-stack-direct! push-value-direct! }
    { +SWith -> rdip:push-stack-direct! push-resource-direct! }
    { +SConsLabel -> rdip:push-stack-direct! push-value-label-direct! }
    { +SWithLabel -> rdip:push-stack-direct! push-resource-label-direct! }
}

def +C99Stack.rdup [ +C99Stack -- +C99Stack +C99Stack ] {
    { +SNil -> +SNil +SNil }
    { +SCons -> rdip:rdup rdup rdip:rswap +SCons rdip:+SCons }
    { +SWith -> rdip:rdup rdup rdip:rswap +SWith rdip:+SWith }
    { +SConsLabel -> dup rdip:rdup rdup rdip:rswap +SConsLabel rdip:+SConsLabel }
    { +SWithLabel -> dup rdip:rdup rdup rdip:rswap +SWithLabel rdip:+SWithLabel }
}

def +C99Stack.rdrop [ +C99Stack -- ] {
    { +SNil -> }
    { +SCons -> rdrop rdrop }
    { +SWith -> rdrop rdrop }
    { +SConsLabel -> drop rdrop rdrop }
    { +SWithLabel -> drop rdrop rdrop }
}

struct +C99BranchSplit {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    branch-split-target: List(C99APIArg)
    reachable-in: Bool
    reachable-out: Bool
}

def +C99BranchSplit.+mirth(f) { +c99:+mirth(f) }

def +C99Branch.begin-branch-split! [ StackType +C99Branch -- +C99BranchSplit ] {
    Branch +c99:stack-type-to-c99-api-params >branch-split-target
    must-flush> drop
    @branch-split-target for(reserve-as-is!)
    /+C99Branch
    reachable> >reachable-in
    False >reachable-out
    +C99BranchSplit
}
def +C99BranchSplit.end-branch-split! [ +C99BranchSplit -- +C99Branch ] {
    /+C99BranchSplit
    +stack> rdrop
    reachable-in> drop
    reachable-out> >reachable
    +c99> start-branch!
    branch-split-target> for(push-api-arg!)
}

def +C99BranchSplit.sub-branch(f) [ (*a +C99Branch -- *b +C99Branch) *a +C99BranchSplit -- *b +C99BranchSplit ] {
    +stack(rdup >+stack) branch-split-target
    reachable-in >reachable
    env >env
    +c99(
        >+c99 +C99Branch dip:f
        reverse-for(pop-to-reserved!)
        end-branch!
    )
    env> drop
    reachable> reachable-out:||
}


def +C99BranchSplit.c99-line(f) { reachable-in +c99:c99-line-if(f) }
def +C99BranchSplit.c99-line-if(f) { reachable-in && +c99:c99-line-if(f) }
def +C99BranchSplit.c99-nest(f) { +c99:depth:1+ f +C99BranchSplit.+c99:depth:pred }

struct C99Var {
    var-var: Var
    value-name: Str
    value-repr: C99ReprType
}

def +C99Branch.var-lookup [ +C99Branch Var -- +C99Branch Maybe(C99Var) ] {
    env lookup(var-var ==)
}

def +C99Branch.var-get! [ +C99Branch Var -- +C99Branch +C99Value ] {
    var-lookup unwrap("[c99] variable unexpectedly missing from environment" +mirth:fatal-error!)
    /C99Var var-var> drop
    +C99Value
}

def +C99Branch.var-dup! [ +C99Branch Var -- +C99Branch +C99Value ] {
    var-get! dup-value! rdrop
}

def +C99Value.push-to-env! [ +C99Branch Var +C99Value -- +C99Branch ] {
    >var-var /+C99Value C99Var env:Cons
}

def +C99Branch.pop-from-env! [ +C99Branch -- +C99Branch Var +C99Value ] {
    env:uncons unwrap("[c99] variable environment unexpectedly empty" +mirth:fatal-error!)
    /C99Var +C99Value var-var>
}

def-type(C99Env, List(C99Var))

||| This resource represents a single active branch.
struct +C99Branch {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    reachable: Bool
}

def +C99Branch.+mirth(f) { +c99:+mirth(f) }

def +C99.start-branch! [ +C99 reachable:Bool env:C99Env -- +C99Branch ] {
    >+c99 +SNil >+stack +C99Branch
}

def +C99Branch.end-branch! [ +C99Branch -- +C99 reachable:Bool env:C99Env ] {
    +stack(+SNil) rswap push-stack-direct!
    /+C99Branch +c99> +stack> rdrop
}

def +C99Branch.flush-cache! [ +C99Branch -- +C99Branch ] {
    end-branch!
    start-branch!
}

def +C99Branch.pop-value! [ +C99Branch C99ReprType -- +C99Branch +C99Value ] {
    +stack(pop-value?) rswap match {
        { +C99ValueSome -> drop }
        { +C99ValueNone -> pop-value-direct! }
    }
}

def +C99Branch.pop-value-label! [ C99ReprType Label +C99Branch -- +C99Branch +C99Value ] {
    +stack(pop-value-label?) rswap match {
        { +C99ValueSome -> drop2 }
        { +C99ValueNone -> pop-value-label-direct! }
    }
}

def +C99Branch.pop-resource! [ +C99Branch C99ReprType -- +C99Branch +C99Resource ] {
    +stack(pop-resource?) rswap match {
        { +C99ResourceSome -> drop }
        { +C99ResourceNone -> pop-resource-direct! }
    }
}

def +C99Branch.pop-resource-label! [ C99ReprType Label +C99Branch -- +C99Branch +C99Resource ] {
    +stack(pop-resource-label?) rswap match {
        { +C99ResourceSome -> drop2 }
        { +C99ResourceNone -> pop-resource-label-direct! }
    }
}

def +C99Value.push-value! [ +C99Branch +C99Value -- +C99Branch ] {
    rswap +stack(rswap +SCons)
}

def +C99Resource.push-resource! [ +C99Branch +C99Resource -- +C99Branch ] {
    rswap +stack(rswap +SWith)
}

def +C99Branch.type-to-c99-repr [ Type +C99Branch -- C99ReprType +C99Branch ] { +mirth:c99-repr }
def +C99Branch.resource-to-c99-repr [ Resource +C99Branch -- C99ReprType +C99Branch ] { +mirth:c99-repr }

def +C99Branch.pop-value-from-stack-type! [ StackType +C99Branch -- StackType +C99Branch +C99Value ] {
    force-cons?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2
    type-to-c99-repr pop-value!
}
def +C99Branch.pop-resource-from-stack-type! [ StackType +C99Branch -- StackType +C99Branch +C99Resource ] {
    force-with?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2
    resource-to-c99-repr pop-resource!
}

def +C99Branch.pop-value-label-from-stack-type! [ Label StackType +C99Branch -- StackType +C99Branch +C99Value ] {
    dip:dup force-cons-label?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2 type-to-c99-repr
    rotl pop-value-label!
}

def +C99Branch.pop-resource-label-from-stack-type! [ Label StackType +C99Branch -- StackType +C99Branch +C99Resource ] {
    dip:dup force-with-label?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2 resource-to-c99-repr
    rotl pop-resource-label!
}

def c99-prim! [ Atom Prim +C99Branch -- +C99Branch ] {
    { PRIM_CORE_ID -> drop }
    { PRIM_CORE_DROP ->
        dom pop-value-from-stack-type! drop
        drop-value!
    }
    { PRIM_CORE_DUP ->
        dom pop-value-from-stack-type! drop
        dup-value! rdip:push-value! push-value!
    }
    { PRIM_CORE_SWAP ->
        dom
        pop-value-from-stack-type! >+b
        pop-value-from-stack-type! >+a
        drop
        +b> push-value!
        +a> push-value!
    }
    { PRIM_CORE_RSWAP ->
        dom
        pop-resource-from-stack-type! >+b
        pop-resource-from-stack-type! >+a
        drop
        +b> push-resource!
        +a> push-resource!
    }
    { PRIM_CORE_DIP ->
        dup args /L1 unwrap(token "unexpected number of arguments to PRIM_CORE_DIP" +mirth:emit-fatal-error!)
        swap dom pop-value-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-value!
    }
    { PRIM_CORE_RDIP ->
        dup args /L1 unwrap(token "unexpected number of arguments to PRIM_CORE_RDIP" +mirth:emit-fatal-error!)
        swap dom pop-resource-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-resource!
    }
    { PRIM_CORE_IF ->
        dup args /L2 unwrap(token "unexpected number of arguments to PRIM_CORE_IF" +mirth:emit-fatal-error!)
        unpack2 C99RT_BOOL pop-value! >+cond

        rotl +mirth:cod
        begin-branch-split!
        c99-line("if (" put +cond> C99RT_BOOL consume-as put ") {" put)
        c99-nest:sub-branch(swap c99-arg-run!)
        c99-line("} else {" put)
        c99-nest:sub-branch(c99-arg-run!)
        c99-line("}" put)
        end-branch-split!
    }
    { PRIM_CORE_WHILE ->
        dup args /L2 unwrap(token "unexpected number of arguments to PRIM_CORE_WHILE" +mirth:emit-fatal-error!)
        nip unpack2 over c99-arg-run!
        C99RT_BOOL pop-value! push-value!
        refresh-branch! +stack(rdup >+knot)
        C99RT_BOOL dup pop-value! consume-as
        c99-line("while (" put put ") {" put)
        c99-nest(
            refresh-branch!
            c99-arg-run!
            c99-arg-run!
            +knot> tie-knot!
        )
        c99-line("}" put)
        C99RT_BOOL pop-value! rdrop
    }
    { PRIM_CORE_DEBUG -> drop flush-cache! c99-line("trace_stack();" put) }
    { PRIM_CORE_PANIC ->
        drop
        C99RT_STR dup pop-value! consume-as
        c99-line("do_panic(" put put ");" put)
        +stack(rdrop +SNil)
        False reachable!
    }
    { PRIM_CORE_RUN ->
        dup args empty? else(token "expected no arguments to prim-core-run" +mirth:emit-fatal-error!) drop
        C99RT_VAL pop-value! run-value!
    }

    { PRIM_INT_EQ  -> drop "(" C99RT_I64 " == " C99RT_I64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_INT_LT  -> drop "(" C99RT_I64 " < "  C99RT_I64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_INT_LE  -> drop "(" C99RT_I64 " <= " C99RT_I64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_INT_GT  -> drop "(" C99RT_I64 " > "  C99RT_I64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_INT_GE  -> drop "(" C99RT_I64 " >= " C99RT_I64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_INT_NE  -> drop "(" C99RT_I64 " != " C99RT_I64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_INT_ADD -> drop "i64_add(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some c99-binop! }
    { PRIM_INT_SUB -> drop "i64_sub(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some c99-binop! }
    { PRIM_INT_MUL -> drop "i64_mul(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some c99-binop! }
    { PRIM_INT_DIV -> drop "i64_div(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some c99-binop! }
    { PRIM_INT_MOD -> drop "i64_mod(" C99RT_I64 ", " C99RT_I64 ")" False C99RT_I64 Some c99-binop! }
    { PRIM_INT_AND -> drop "(" C99RT_U64 " & "  C99RT_U64 ")" False C99RT_U64  Some c99-binop! }
    { PRIM_INT_XOR -> drop "(" C99RT_U64 " ^ "  C99RT_U64 ")" False C99RT_U64  Some c99-binop! }
    { PRIM_INT_OR  -> drop "(" C99RT_U64 " | "  C99RT_U64 ")" False C99RT_U64  Some c99-binop! }
    { PRIM_INT_SHL -> drop "u64_shl(" C99RT_U64 ", " C99RT_U64 ")" False C99RT_U64 Some c99-binop! }
    { PRIM_INT_SHR -> drop "u64_shr(" C99RT_U64 ", " C99RT_U64 ")" False C99RT_U64 Some c99-binop! }
    { PRIM_INT_TO_I64 -> drop }
    { PRIM_INT_TO_F32 -> drop "(float)"   C99RT_I64 ""  C99RT_F32 Some c99-unop! }
    { PRIM_INT_TO_F64 -> drop "(double)"  C99RT_I64 ""  C99RT_F64 Some c99-unop! }
    { PRIM_INT_TO_STR -> drop "i64_show(" C99RT_I64 ")" C99RT_STR Some c99-unop! }

    { PRIM_U8_GET  -> drop "*(uint8_t*)"  C99RT_PTR "" C99RT_U8  Some c99-unop! }
    { PRIM_U8_SET  -> drop "*(uint8_t*)"  C99RT_PTR " = " C99RT_U8  ";" True None c99-binop! }

    { PRIM_U16_GET -> drop "*(uint16_t*)" C99RT_PTR "" C99RT_U16 Some c99-unop! }
    { PRIM_U16_SET -> drop "*(uint16_t*)" C99RT_PTR " = " C99RT_U16 ";" True None c99-binop! }

    { PRIM_U32_GET -> drop "*(uint32_t*)" C99RT_PTR "" C99RT_U32 Some c99-unop! }
    { PRIM_U32_SET -> drop "*(uint32_t*)" C99RT_PTR " = " C99RT_U32 ";" True None c99-binop! }

    { PRIM_U64_GET -> drop "*(uint64_t*)" C99RT_PTR "" C99RT_U64 Some c99-unop! }
    { PRIM_U64_SET -> drop "*(uint64_t*)" C99RT_PTR " = " C99RT_U64 ";" True None c99-binop! }

    { PRIM_I8_GET  -> drop "*(int8_t*)"   C99RT_PTR "" C99RT_I8  Some c99-unop! }
    { PRIM_I8_SET  -> drop "*(int8_t*)"   C99RT_PTR " = " C99RT_I8  ";" True None c99-binop! }

    { PRIM_I16_GET -> drop "*(int16_t*)"  C99RT_PTR "" C99RT_I16 Some c99-unop! }
    { PRIM_I16_SET -> drop "*(int16_t*)"  C99RT_PTR " = " C99RT_I16 ";" True None c99-binop! }

    { PRIM_I32_GET -> drop "*(int32_t*)"  C99RT_PTR "" C99RT_I32 Some c99-unop! }
    { PRIM_I32_SET -> drop "*(int32_t*)"  C99RT_PTR " = " C99RT_I32 ";" True None c99-binop! }

    { PRIM_I64_GET -> drop "*(int64_t*)"  C99RT_PTR "" C99RT_I64 Some c99-unop! }
    { PRIM_I64_SET -> drop "*(int64_t*)"  C99RT_PTR " = " C99RT_I64 ";" True None c99-binop! }
    { PRIM_I64_TO_INT -> drop }

    # { PRIM_F32_SET -> drop "*(float*)"    C99RT_PTR " = " C99RT_F32 ";" True None c99-binop! }
    { PRIM_F32_LT  -> drop "(" C99RT_F32 " < "  C99RT_F32 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_F32_EQ  -> drop "(" C99RT_F32 " == " C99RT_F32 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_F32_ADD -> drop "(" C99RT_F32 " + "  C99RT_F32 ")" False C99RT_F32  Some c99-binop! }
    { PRIM_F32_SUB -> drop "(" C99RT_F32 " - "  C99RT_F32 ")" False C99RT_F32  Some c99-binop! }
    { PRIM_F32_MUL -> drop "(" C99RT_F32 " * "  C99RT_F32 ")" False C99RT_F32  Some c99-binop! }
    { PRIM_F32_DIV -> drop "(" C99RT_F32 " / "  C99RT_F32 ")" False C99RT_F32  Some c99-binop! }
    { PRIM_F32_TO_INT -> drop "(int64_t)" C99RT_F32 ""  C99RT_I64 Some c99-unop! }
    { PRIM_F32_TO_F64 -> drop "(double)"  C99RT_F32 ""  C99RT_F64 Some c99-unop! }
    { PRIM_F32_TO_STR -> drop "f32_show(" C99RT_F32 ")" C99RT_STR Some c99-unop! }

    # { PRIM_F64_SET -> drop "*(double*)"   C99RT_PTR " = " C99RT_F64 ";" True None c99-binop! }
    { PRIM_F64_EQ  -> drop "(" C99RT_F64 " == " C99RT_F64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_F64_LT  -> drop "(" C99RT_F64 " < "  C99RT_F64 ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_F64_ADD -> drop "(" C99RT_F64 " + "  C99RT_F64 ")" False C99RT_F64  Some c99-binop! }
    { PRIM_F64_SUB -> drop "(" C99RT_F64 " - "  C99RT_F64 ")" False C99RT_F64  Some c99-binop! }
    { PRIM_F64_MUL -> drop "(" C99RT_F64 " * "  C99RT_F64 ")" False C99RT_F64  Some c99-binop! }
    { PRIM_F64_DIV -> drop "(" C99RT_F64 " / "  C99RT_F64 ")" False C99RT_F64  Some c99-binop! }
    { PRIM_F64_TO_INT -> drop "(int64_t)" C99RT_F64 ""  C99RT_I64 Some c99-unop! }
    { PRIM_F64_TO_F32 -> drop "(float)"   C99RT_F64 ""  C99RT_F32 Some c99-unop! }
    { PRIM_F64_TO_STR -> drop "f64_show(" C99RT_F64 ")" C99RT_STR Some c99-unop! }

    { PRIM_BOOL_AND -> drop "(" C99RT_BOOL " && " C99RT_BOOL ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_BOOL_OR  -> drop "(" C99RT_BOOL " || " C99RT_BOOL ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_BOOL_NOT -> drop "!" C99RT_BOOL "" C99RT_BOOL Some c99-unop! }

    { PRIM_TUP_PACK0 -> drop 0u C99RT_TUP push-value-expression!("NULL" put) }
    { PRIM_TUP_PACK1 -> drop 1u c99-tup-pack! }
    { PRIM_TUP_PACK2 -> drop 2u c99-tup-pack! }
    { PRIM_TUP_PACK3 -> drop 3u c99-tup-pack! }
    { PRIM_TUP_PACK4 -> drop 4u c99-tup-pack! }
    { PRIM_TUP_PACK5 -> drop 5u c99-tup-pack! }

    { PRIM_TUP_UNPACK0 -> drop 0u C99RT_TUP pop-value! drop-value! }
    { PRIM_TUP_UNPACK1 -> drop 1u c99-tup-unpack! }
    { PRIM_TUP_UNPACK2 -> drop 2u c99-tup-unpack! }
    { PRIM_TUP_UNPACK3 -> drop 3u c99-tup-unpack! }
    { PRIM_TUP_UNPACK4 -> drop 4u c99-tup-unpack! }
    { PRIM_TUP_UNPACK5 -> drop 5u c99-tup-unpack! }

    { PRIM_MUT_GET    -> drop "mut_get(" C99RT_PTR ")" C99RT_VAL Some c99-unop! }
    { PRIM_MUT_SET    -> drop "mut_set(" C99RT_VAL ", " C99RT_PTR ");" False None c99-binop! }
    { PRIM_MUT_IS_SET -> drop "mut_is_set(" C99RT_PTR ")" C99RT_BOOL Some c99-unop! }

    { PRIM_PTR_GET -> drop "*(void**)"    C99RT_PTR "" C99RT_PTR Some c99-unop! }
    { PRIM_PTR_SET -> drop "*(void**)"    C99RT_PTR " = " C99RT_PTR ";" True None c99-binop! }
    { PRIM_PTR_NIL -> drop C99RT_PTR push-value-expression!("(void*)0" put) }
    { PRIM_PTR_EQ  -> drop "(" C99RT_PTR " == " C99RT_PTR ")" False C99RT_BOOL Some c99-binop! }
    { PRIM_PTR_ADD -> drop "(void*)(" C99RT_I64 " + (char*)" C99RT_PTR ")" False C99RT_PTR Some c99-binop! }
    { PRIM_PTR_SIZE -> drop C99RT_U64 push-value-expression!("sizeof(void*)" put) }
    { PRIM_PTR_ALLOC   -> drop "ptr_alloc(" C99RT_U64 ");" C99RT_PTR Some c99-unop! }
    { PRIM_PTR_REALLOC -> drop "ptr_realloc(" C99RT_PTR "," C99RT_U64 ")" False C99RT_PTR Some  c99-binop! }
    { PRIM_PTR_FREE    -> drop "free(" C99RT_PTR ");" None c99-unop! }
    { PRIM_PTR_COPY ->
        drop
        C99RT_PTR pop-value! >+dst
        C99RT_U64 pop-value! >+len
        C99RT_PTR pop-value! >+src
        c99-line (
            "ptr_copy(" put
                +src> C99RT_PTR consume-as put
            ", " put
                +len> C99RT_U64 consume-as put
            ", " put
                +dst> C99RT_PTR consume-as put
            ");" put
        )
    }
    { PRIM_PTR_FILL ->
        drop
        C99RT_PTR pop-value! >+dst
        C99RT_U64 pop-value! >+len
        C99RT_U8  pop-value! >+val
        c99-line (
            "ptr_fill(" put
                +val> C99RT_U8  consume-as put
            ", " put
                +len> C99RT_U64 consume-as put
            ", " put
                +dst> C99RT_PTR consume-as put
            ");" put
        )
    }

    { PRIM_STR_COPY -> drop "str_make(" C99RT_PTR ", " C99RT_U64 ")" False C99RT_STR Some c99-binop! }
    { PRIM_STR_NUM_BYTES -> drop "str_size(" C99RT_STR ")" C99RT_U64 Some c99-unop! }
    { PRIM_STR_BASE      -> drop "str_base(" C99RT_STR ")" C99RT_PTR Some      c99-unop! }
    { PRIM_STR_CAT  -> drop "str_cat(" C99RT_STR ", " C99RT_STR ")" False C99RT_STR Some   c99-binop! }
    { PRIM_STR_CMP  -> drop "str_cmp(" C99RT_STR ", " C99RT_STR ")" False C99RT_I64 Some   c99-binop! }
    { PRIM_STR_EQ   -> drop "(str_cmp(" C99RT_STR ", " C99RT_STR ") == 0)" False C99RT_BOOL Some c99-binop! }
    { PRIM_STR_LT   -> drop "(str_cmp(" C99RT_STR ", " C99RT_STR ") < 0)"  False C99RT_BOOL Some c99-binop! }
    { PRIM_STR_LE   -> drop "(str_cmp(" C99RT_STR ", " C99RT_STR ") <= 0)" False C99RT_BOOL Some c99-binop! }
    { PRIM_STR_GT   -> drop "(str_cmp(" C99RT_STR ", " C99RT_STR ") > 0)"  False C99RT_BOOL Some c99-binop! }
    { PRIM_STR_GE   -> drop "(str_cmp(" C99RT_STR ", " C99RT_STR ") >= 0)" False C99RT_BOOL Some c99-binop! }
    { PRIM_STR_NE   -> drop "(str_cmp(" C99RT_STR ", " C99RT_STR ") != 0)" False C99RT_BOOL Some c99-binop! }

    { PRIM_SYS_OS   -> drop C99RT_I64 push-value-expression!("RUNNING_OS" put) }
    { PRIM_SYS_ARCH -> drop C99RT_I64 push-value-expression!("RUNNING_ARCH" put) }
    { PRIM_SYS_ARGC -> drop C99RT_I64 push-value-expression!("global_argc" put) }
    { PRIM_SYS_ARGV -> drop C99RT_PTR push-value-expression!("global_argv" put) }

    { PRIM_CORE_MATCH           -> c99-prim-syntax! }
    { PRIM_CORE_LAMBDA          -> c99-prim-syntax! }
    { PRIM_SYNTAX_MODULE        -> c99-prim-syntax! }
    { PRIM_SYNTAX_IMPORT        -> c99-prim-syntax! }
    { PRIM_SYNTAX_ALIAS         -> c99-prim-syntax! }
    { PRIM_SYNTAX_INLINE        -> c99-prim-syntax! }
    { PRIM_SYNTAX_DEF           -> c99-prim-syntax! }
    { PRIM_SYNTAX_DEF_MISSING   -> c99-prim-syntax! }
    { PRIM_SYNTAX_DEF_TYPE      -> c99-prim-syntax! }
    { PRIM_SYNTAX_BUFFER        -> c99-prim-syntax! }
    { PRIM_SYNTAX_VARIABLE      -> c99-prim-syntax! }
    { PRIM_SYNTAX_EXTERNAL      -> c99-prim-syntax! }
    { PRIM_SYNTAX_DEF_EXTERNAL  -> c99-prim-syntax! }
    { PRIM_SYNTAX_EMBED_STR     -> c99-prim-syntax! }
    { PRIM_SYNTAX_TABLE         -> c99-prim-syntax! }
    { PRIM_SYNTAX_FIELD         -> c99-prim-syntax! }
    { PRIM_SYNTAX_DATA          -> c99-prim-syntax! }
    { PRIM_SYNTAX_STRUCT        -> c99-prim-syntax! }
    { PRIM_SYNTAX_DASHES        -> c99-prim-syntax! }
    { PRIM_SYNTAX_ARROW         -> c99-prim-syntax! }
}

def c99-tup-pack! [ Nat +C99Branch -- +C99Branch ] {
    None >tag
    LIST(repeat(TYPE_DONT_CARE STPCons ;)) >parts
    c99-pack-tuple! turn-into-value! push-value!
}

def c99-tup-unpack! [ Nat +C99Branch -- +C99Branch ] {
    None >tag
    dup LIST(repeat(TYPE_DONT_CARE STPCons ;)) >parts
    C99RT_TUP pop-value! turn-into-resource! c99-unpack-tuple!
}

def +C99Value.run-value! [ +C99Branch +C99Value -- +C99Branch ] {
    consume-as-VAL flush-cache!
    c99-line("run_value(" put put ");" put)
}

def c99-prim-syntax! [ Atom +C99Branch -- +C99Branch ] {
    token "unexpected syntax primitive" +mirth:emit-fatal-error!
}

def c99-binop! [  Str C99ReprType Str C99ReprType Str Bool Maybe(C99ReprType) +C99Branch -- +C99Branch ] {
    >out-type >args-swapped
    >sfx >arg2-type >op >arg1-type >pfx

    args-swapped> if(
        arg1-type> dup pop-value! consume-as >arg1
        arg2-type> dup pop-value! consume-as >arg2,

        arg2-type> dup pop-value! consume-as >arg2
        arg1-type> dup pop-value! consume-as >arg1
    )

    out-type> match {
        { Some -> push-value-expression!(pfx> put arg1> put op> put arg2> put sfx> put) }
        { None -> c99-line(pfx> put arg1> put op> put arg2> put sfx> put) }
    }
}

def c99-unop! [ Str C99ReprType Str Maybe(C99ReprType) +C99Branch -- +C99Branch ] {
    >out-type >sfx >arg-type >pfx
    arg-type> dup pop-value! consume-as
    out-type> match {
        { Some -> push-value-expression!(pfx> put put sfx> put) }
        { None -> c99-line(pfx> put put sfx> put) }
    }
}

def c99-args-push! [ List(Arg) +C99Branch -- +C99Branch ] {
    for(c99-arg-push!)
}
def c99-arg-push! [ Arg +C99Branch -- +C99Branch ] {
    { ArgBlock -> c99-block-push! }
}
def c99-arg-run! [ Arg +C99Branch -- +C99Branch ] {
    { ArgBlock -> c99-block-run! }
}

def c99-block-run! [ Block +C99Branch -- +C99Branch ] {
    +mirth:arrow c99-codip-arrow!
}

def c99-pack-closure-vars! [ List(Var) +C99Branch -- +C99Branch ] {
    filter(is-physical?) dup empty? if(
        drop,
        dup len 1+ show >arity
        C99RT_FNPTR pop-value! >+fnptr
        C99RT_VAL value-expression!("MKTUP(tup_new(" put @arity put "), " put @arity put ")" put) >+tup
        c99-line("VTUP(" put @+tup:rdup consume-as-VAL put " )->size = " put arity> put ";" put)
        c99-line(
            "VTUP(" put @+tup:rdup consume-as-VAL put
            ")->cells[0] = " put +fnptr> consume-as-VAL put ";" put
        )
        1 >i for(
            var-dup! consume-as-VAL >var
            c99-line(
                "VTUP(" put @+tup:rdup consume-as-VAL put
                ")->cells[" put @i show put "] = " put
                var> put ";" put
            )
            @i:1+
        )
        i> drop
        +tup> push-value!
    )
}

def c99-unpack-closure-vars! [ List(Var) +C99Branch -- +C99Branch +closure:+C99Value? ] {
    filter(is-physical?) dup empty? if(
        +C99ValueNone >+closure
        drop,
        C99RT_VAL pop-value! >+tup
        1 >i
        for(
            dup type type-to-c99-repr
            dup value-expression! (
                v-macro (
                    "VTUP(" put
                    @+tup:rdup consume-as-VAL put
                    ")->cells[" put
                    @i show put
                    "]" put
                )
            )
            push-to-env!
            @i:1+
        )
        i> drop
        +tup> +C99ValueSome >+closure
    )
}

def c99-block-push! [ Block +C99Branch -- +C99Branch ] {
    dup +mirth:to-run-var match(
        Some -> nip c99-var-push!,
        None ->
            C99RT_FNPTR push-value-expression!("&" put dup +mirth:cname put)
            dup +mirth:free-vars c99-pack-closure-vars!
            drop
    )
}

def c99-var! [ Var +C99Branch -- +C99Branch ] {
    dup auto-run? if(c99-var-run!, c99-var-push!)
}

def c99-var-run! [ Var +C99Branch -- +C99Branch ] {
    var-dup! run-value!
}

def c99-var-push! [ Var +C99Branch -- +C99Branch ] {
    var-dup! push-value!
}

def reverse-pop-values-to-env! [ List(Var) +C99Branch -- +C99Branch ] {
    { Nil -> id }
    { Cons ->
        over type type-to-c99-repr pop-value!
        rdip(reverse-pop-values-to-env!)
        push-to-env!
    }
}

def pop-values-to-env! [ List(Var) +C99Branch -- +C99Branch ] {
    reverse reverse-pop-values-to-env!
}

def drop-env-var! [ Var +C99Branch -- +C99Branch ] {
    pop-from-env!
    == else("[c99] unexpected variable in environment when exiting scope" rdip:+mirth:fatal-error!)
    drop-value!
}

def drop-env-vars! [ List(Var) +C99Branch -- +C99Branch ] {
    reverse-for(drop-env-var!)
}

def c99-lambda! [ Lambda +C99Branch -- +C99Branch ] {
    dup params pop-values-to-env!
    dup body c99-arrow!
    params drop-env-vars!
}

def c99-match! [ Match +C99Branch -- +C99Branch ] {
    dup cases /L1 if-some(
        nip c99-single-case!,

        dup scrutinee-data?
        unwrap(token "non-uniform match, not supported at present" +mirth:emit-fatal-error!)
        pop-data! >+scrutinee
        dup cod begin-branch-split!
        c99-line("switch (" put @+scrutinee:peek-data-tag put ") {" put)
        c99-nest(
            dup cases for(@+scrutinee:rdup >+scrutinee c99-case!)
            has-default-case? else(
                c99-line("default: {" put)
                c99-nest(
                    c99-line("do_panic(str_make(\"unexpected fallthrough in match\\n\", 32));" put)
                )
                c99-line("}" put)
            )
            +scrutinee> rdrop
        )
        c99-line("}" put)
        end-branch-split!
    )
}

def c99-single-case! [ Case +C99Branch -- +C99Branch ] {
    dup pattern is-default? if(
        body c99-arrow!,

    dup pattern single-tag? if-some(
        c99-reverse-tag!
        body c99-arrow!,

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def c99-case! [ Case +C99BranchSplit +scrutinee:+C99Value/Resource -- +C99BranchSplit ] {
    dup pattern is-default? if(
        c99-line("default: {" put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            body c99-arrow!
        )
        c99-line("} break;" put),

    dup pattern single-tag? if-some(
        c99-line("case " put dup value-show put "LL: { // " put dup name >Str put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            c99-reverse-tag!
            body c99-arrow!
        )
        c99-line("} break;" put),

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def Tag.word-cname-type [ Tag +Mirth -- Str ArrowType +Mirth ] { sip:word-cname type }
def Tag.pat-cname-type [ Tag +Mirth -- Str ArrowType +Mirth ] { sip:pat-cname type invert }
def Word.cname-type [ Word +Mirth -- Str ArrowType +Mirth ] { sip:cname type }

field(Tag.~word-c99-api, Tag, C99API)
def Tag.word-c99-api [ Tag +C99 -- C99API +C99 ] {
    dup ~word-c99-api memoize(dup +mirth:word-cname-type cname-type-to-c99-api) nip
}

field(Tag.~pat-c99-api, Tag, C99API)
def Tag.pat-c99-api [ Tag +C99 -- C99API +C99 ] {
    dup ~pat-c99-api memoize(dup +mirth:pat-cname-type cname-type-to-c99-api) nip
}

field(Word.~c99-api, Word, C99API)
def Word.c99-api [ Word +C99 -- C99API +C99 ] {
    dup ~c99-api memoize(dup +mirth:cname-type cname-type-to-c99-api) nip
}

def c99-word-sigs! [ +C99 -- +C99 ] { Word.for(dup +needs(needed?) if(c99-word-sig!, drop)) }
def c99-word-sig! [ Word +C99 -- +C99 ] { c99-api c99-smart-sig! }

def c99-block-sigs! [ +C99 -- +C99 ] { Block.for(dup +needs(needed?) if(c99-block-sig!, drop)) }
def c99-block-sig! [ Block +C99 -- +C99 ] { c99-line(c99-block-sig-put ";" put) }

def c99-block-defs! [ +C99 -- +C99 ] { Block.for(dup +needs(needed?) if(c99-block-def!, drop)) }
def c99-block-def! [ Block +C99 -- +C99 ] {
    c99-line(dup c99-block-sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-block-enter!
        dup +mirth:arrow
        dup +mirth:free-vars c99-unpack-closure-vars!
        dup +mirth:type dom expose-stack-type!
        c99-arrow!
        +closure> unwrap!(drop-value!, id)
        c99-block-exit!
    )
    c99-line("}" put)
}

def c99-block-sig-put [ Block +C99 -- +C99 ] { "static void " put +mirth:cname put " (void)" put }

def c99-block-enter! [ Block +C99 -- +C99Branch ] {
    options emit-debug-info if(
        c99-line("WORD_ENTER(" put
            dup home match(
                HomeMain -> drop "block",
                HomeWord -> name >Str " block" cat,
            ) put-cstr ", " put
            dup token .module source-path >Str put-cstr ", " put
            dup token row >Int show put ", " put
            dup token col >Int show put ");" put
        ) drop,
        drop
    )
    True >reachable
    L0 >env
    start-branch!
}

def c99-block-exit! [ Block +C99Branch -- +C99 ] {
    end-branch!
    reachable> drop
    env> drop
    options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def expose-stack-type! [ StackType +C99Branch -- +C99Branch ] {
    { STMeta -> expand-if(>StackType expose-stack-type!, drop) }
    { STCons -> type-to-c99-repr pop-value! rdip:expose-stack-type! push-value! }
    { STWith -> resource-to-c99-repr pop-resource! rdip:expose-stack-type! push-resource! }
    { STConsLabel ->
        >label type-to-c99-repr @label pop-value-label!
        rdip:expose-stack-type! label> push-value-label! }
    { STWithLabel ->
        >label resource-to-c99-repr @label pop-resource-label!
        rdip:expose-stack-type! label> push-resource-label! }
    { _ -> drop }
}

def c99-word-enter! [ Word +C99Branch -- +C99Branch ] {
    +c99:options emit-debug-info then(
        c99-line(
            "WORD_ENTER(" put
            dup name >Str put-cstr ", " put
            dup body .module source-path >Str put-cstr ", " put
            dup body row >Int show put ", " put
            dup body col >Int show put ");" put
        )
    ) drop
}

def c99-word-exit! [ Word +C99Branch -- +C99Branch ] {
    +c99:options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def c99-word-defs! [ +C99 -- +C99 ] { Word.for(dup +needs(needed?) if(c99-word-def!, drop)) }
def c99-word-def! [ Word +C99 -- +C99 ] {
    dup c99-api c99-smart-def! (
        dup c99-word-enter!
        dup +mirth:arrow c99-arrow!
        dup c99-word-exit!
    )
    drop
}

def c99-field-defs! [ +C99 -- +C99 ] { Field.for(c99-field-def!) }
def c99-field-def! [ Field +C99 -- +C99 ] { c99-line("static FIELD " put +mirth:cname put " = {0};" put) }
def c99-field-call! [ Field +C99Branch -- +C99Branch ] {
    C99RT_U64 pop-value! >+index
    C99RT_PTR push-value-expression! (
        "field_mut(&" put
        +mirth:cname put
        ", " put
        +index> C99RT_U64 consume-as put
        ")" put
    )
}

def c99-main! [ Arrow +C99 -- +C99 ] {
    c99-line("int main (int argc, char** argv) {" put)
    reset-fresh-counter!
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        options emit-debug-info then(
            c99-line("WORD_ENTER(" put
                "\"<main>\", " put
                dup token-start .module source-path >Str put-cstr ", " put
                dup token-start row >Int show put ", " put
                dup token-start col >Int show put ");" put)
        )
        True >reachable
        L0 >env
        start-branch!
        C99RT_I64 push-resource-expression!("0 /* The World! */" put)
        c99-arrow!
        end-branch!
        env> drop
        reachable> drop
        options emit-debug-info then(
            c99-line("WORD_EXIT;" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put)
}
