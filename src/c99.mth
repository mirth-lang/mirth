module(mirth.c99)

import(std.prelude)
import(std.str)
import(std.path)
import(std.list)
import(std.lazy)
import(std.byte)
import(std.maybe)
import(std.either)

import(std.file)
import(std.output)

import(mirth.mirth)
import(mirth.module)
import(mirth.location)
import(mirth.token)
import(mirth.name)
import(mirth.buffer)
import(mirth.arrow)
import(mirth.word)
import(mirth.table)
import(mirth.variable)
import(mirth.external)
import(mirth.tycon)
import(mirth.type)
import(mirth.data)
import(mirth.package)
import(mirth.prim)
import(mirth.var)
import(mirth.match)
import(mirth.elab)
import(mirth.need)
import(mirth.label)
import(mirth.def)

#######
# C99 #
#######

struct C99_Options {
    output-path: Path
    emit-debug-info: Bool
}

struct +C99 {
    options: C99_Options
    depth: Nat
    fresh-counter: Nat
    +needs: +Needs
    +output: +Output
    +mirth: +Mirth
}

def(+C99.put, Str +C99 -- +C99, +output:put)
def(+C99.put-byte, Byte +C99 -- +C99, +output:put-byte)
def(+C99.line, +C99 -- +C99, +output:line)

def(c99-start!, Arrow C99_Options +World +Mirth -- Arrow +World +C99,
    >options
    0 >Nat >depth
    0 >Nat >fresh-counter
    +Needs.new dup determine-arrow-needs! >+needs >+mirth
    @options output-path create-file! unwrap! +Output.start! >+output
    +C99)

def(c99-end!, +World +C99 -- +World +Mirth,
    /+C99
    depth> fresh-counter> options> drop3
    +needs> rdrop
    +output> end! close-file!
    +mirth>)

def +C99.reset-fresh-counter! [ +C99 -- +C99 ] {
    0 >Nat fresh-counter!
}

def +C99.fresh-nat! [ +C99 -- Nat +C99 ] {
    fresh-counter
    dup 1+ fresh-counter!
}

def +C99.fresh-name! [ +C99 -- Str +C99 ] {
    fresh-nat! Str("v"; show;)
}

def +C99.fresh-resource-name! [ +C99 -- Str +C99 ] {
    fresh-nat! Str("r"; show;)
}

def(run-output-c99!, Arrow C99_Options +World +Mirth -- +World +Mirth,
    num-errors 0> if(
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-tag-defs!
        c99-buffers!
        c99-variables!
        c99-external-blocks!
        c99-word-sigs!
        c99-block-sigs!
        c99-field-sigs!
        c99-main!
        c99-field-defs!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    ))

field(Tag.~word-cname, Tag, Str)
field(Tag.~pat-cname, Tag, Str)
field(Buffer.~cname, Buffer, Str)
field(Variable.~cname, Variable, Str)
field(Field.~cname, Field, Str)
field(External.~cname, External, Str)
field(Prim.~cname, Prim, Str)

def(Tag.word-cname, +Mirth Tag -- +Mirth Str, dup ~word-cname memoize(
    Str("mtw_" ; dup qname rdip:mangled ;)) nip)
def(Tag.pat-cname, +Mirth Tag -- +Mirth Str, dup ~pat-cname memoize(
    Str("mtp_" ; dup qname rdip:mangled ;)) nip)
def(Buffer.cname, +Mirth Buffer -- +Mirth Str, dup ~cname memoize(
    Str("mbuf_" ; dup qname rdip:mangled ;)) nip)
def(Variable.cname, +Mirth Variable -- +Mirth Str, dup ~cname memoize(
    Str("mvar_" ; dup qname rdip:mangled ;)) nip)
def(Field.cname, +Mirth Field -- +Mirth Str, dup ~cname memoize(
    dup qname-hard mangled Str("mfld_" ; ;)) nip)
def(External.cname, +Mirth External -- +Mirth Str, dup ~cname memoize(
    dup qname-hard mangled Str("mext_" ; ;)) nip)
def(Prim.cname, Prim -- Str, dup ~cname memoize(
    Str("mp_" ; dup name mangled ;)) nip)

def(+C99.sig-put, Str +C99 -- +C99, "static void " put put " (void)" put)

embed-str(c99-header-str, "src/mirth.h")
def(c99-header!, +C99 -- +C99,
    "#define MIRTH_DEBUG " put
    options emit-debug-info if("1", "0") put line
    c99-header-str put line)

def(c99-buffers!, +C99 -- +C99, Buffer.for(c99-buffer!))
def(c99-buffer!, Buffer +C99 -- +C99,
    dup +mirth:cname sig-put " {" put line
    "\tstatic uint8_t b[" put dup size show put "] = {0};" put line
    "\tpush_ptr(&b);" put line
    "}" put line
    drop)

def(c99-variables!, +C99 -- +C99, Variable.for(c99-variable!))
def(c99-variable!, Variable +C99 -- +C99,
    +mirth:cname sig-put " {" put line
    "\tstatic VAL v = {0};" put line
    "\tpush_ptr(&v);" put line
    "}" put line)

def(c99-tag-defs!, +C99 -- +C99, Tag.for(c99-tag-def!))
def(c99-tag-def!, Tag +C99 -- +C99, \(tag -> tag prefer-inline? else(
    tag +needs:word-needed? then(
        tag +mirth:word-cname sig-put " {" put line
        reset-fresh-counter!
        tag is-transparent? else(
            tag is-semi-transparent? if(
                tag outputs-resource? if(
                    tag num-type-inputs 0> if(
                        "\tpush_resource(pop_value());" put line,
                        "\tpush_resource(lpop(&lbl_" put
                        tag label-inputs /L1 unwrap name mangled put
                        "));" put line
                    ),
                    "\tpush_value(lpop(&lbl_" put
                    tag label-inputs /L1 unwrap name mangled put
                    "));" put line
                ),

            tag num-total-inputs 0= if(
                tag outputs-resource? if(
                    "\tpush_resource(MKU64(",
                    "\tpush_value(MKU64("
                ) put
                    tag value-show put
                    "LL));" put line
                ,

                "\tTUP* tup = tup_new(" put
                    tag num-total-inputs 1+ show put
                    ");" put line
                "\ttup->size = " put
                    tag num-total-inputs 1+ show put
                    ";" put line
                "\ttup->cells[0] = MKU64(" put
                    tag value-show put
                    "LL);" put line
                tag num-total-inputs
                tag label-inputs reverse-for(
                    "\ttup->cells[" put
                        over show put
                        "] = lpop(&lbl_" put
                        name mangled put
                        ");" put line
                    1-
                )
                tag num-resource-inputs repeat(
                    "\ttup->cells[" put
                        dup show put
                        "] = pop_resource();" put line
                    1-
                )
                tag num-type-inputs repeat(
                    "\ttup->cells[" put
                        dup show put
                        "] = pop_value();" put line
                    1-
                )
                drop
                tag outputs-resource? if(
                    "\tpush_resource(MKTUP(tup, ",
                    "\tpush_value(MKTUP(tup, "
                ) put
                    tag num-total-inputs 1+ show put
                    "));" put line
            ))
        )
        "}" put line
    )

    tag +needs:pat-needed? then(
        tag +mirth:pat-cname sig-put " {" put line
        reset-fresh-counter!
        tag is-transparent? else(
            tag outputs-resource? if(
                "\tVAL val = pop_resource();",
                "\tVAL val = pop_value();"
            ) put line
            tag is-semi-transparent? if(
                tag num-type-inputs 0> if(
                    "\tpush_value(val);" put line,
                    "\tlpush(&lbl_" put
                    tag label-inputs /L1 unwrap name mangled put
                    ", val);" put line
                ),
            tag num-total-inputs 0= if(
                "\t(void)val;" put line,
                "\tASSERT1(IS_TUP(val),val);" put line
                "\tTUP* tup = VTUP(val);" put line
                1
                tag num-type-inputs repeat(
                    "\tpush_value(tup->cells[" put
                        dup show put
                        "]);" put line
                    1+
                )
                tag num-resource-inputs repeat(
                    "\tpush_resource(tup->cells[" put
                        dup show put
                        "]);" put line
                    1+
                )
                tag label-inputs for(
                    "\tlpush(&lbl_" put
                        name mangled put
                        ", tup->cells[" put
                        dup show put
                        "]);" put line
                    1+
                )
                drop
                "\tif (tup->refs > 1) {" put line
                1 tag num-total-inputs repeat(
                    "\t\tincref(tup->cells[" put
                        dup show put
                        "]);" put line
                    1+
                ) drop
                "\t\tdecref(val);" put line
                "\t} else {" put line
                "\t\tfree(tup);" put line
                "\t}" put line
            ))
        )
        "}" put line
    ))))

def(c99-tag-label-index, Tag Label +C99 -- Nat +C99,
    over num-total-inputs 1+
    over2 label-inputs reverse-find(dip(1- over) ==) drop
    dip:drop2)

def(c99-tag-get-label!, Tag Label +C99Branch -- +C99Branch,
    end-branch!
    c99-line("{" put)
    c99-nest(
        over is-semi-transparent? if(
            dup2 swap +mirth:project-input-label unwrap match(
                Left -> drop
                    over outputs-resource? then(
                        c99-line("VAL v = top_resource();" put)
                        c99-line("incref(v);" put)
                        c99-line("push_value(v);" put)
                    ),

                Right -> drop
                    c99-line("push_resource(MKU64(0));" put)
            ),

            over outputs-resource? if(
                c99-line("VAL v = pop_resource();" put),
                c99-line("VAL v = pop_value();" put)
            )
            c99-line("ASSERT1(IS_TUP(v), v);" put)
            c99-line("ASSERT1(VTUPLEN(v) == " put
                over num-total-inputs 1+ show put
                ", v);" put)
            c99-line("VAL* p = &VTUP(v)->cells[" put
                dup2 c99-tag-label-index show put
                "];" put)
            c99-line("VAL u = *p;" put)

            dup2 swap +mirth:project-input-label unwrap match(
                Left -> drop
                    c99-line("incref(u);" put)
                    over outputs-resource? if(
                        c99-line("push_resource(v);" put),
                        c99-line("decref(v);" put)
                    )
                    c99-line("push_value(u);" put),
                Right -> drop
                    c99-line("ASSERT1(VREFS(v) == 1, v);" put)
                    c99-line("*p = (VAL){0};" put)
                    c99-line("push_resource(u);" put)
                    c99-line("push_resource(v);" put)
            )
        ) drop2
    )
    c99-line("}" put)
    start-branch!)

def(c99-tag-set-label!, Tag Label +C99Branch -- +C99Branch, \(tag lbl ->
    end-branch!
    c99-line("{" put)
    c99-nest(

        lbl tag +mirth:project-input-label unwrap match(
            Left -> drop
                tag is-semi-transparent? if(
                    tag outputs-resource? if(
                        c99-line("VAL v = pop_resource();" put)
                        c99-line("push_resource(pop_value());" put)
                        c99-line("decref(v);" put),

                        c99-line("VAL v = pop_value();" put)
                        c99-line("decref(v);" put)
                    ),

                    tag outputs-resource? if(
                        c99-line("VAL v = top_resource();" put),
                        c99-line("VAL v = pop_value();" put)
                    )
                    c99-line("VAL u = pop_value();" put)
                    c99-line("ASSERT1(IS_TUP(v), v);" put)
                    c99-line("ASSERT1(VTUPLEN(v) == " put
                        tag num-total-inputs 1+ show put
                        ", v);" put)
                    tag outputs-resource? if(
                        c99-line("VAL* p = &VTUP(v)->cells[" put
                            tag lbl c99-tag-label-index show put
                            "];" put)
                        c99-line("VAL t = *p; *p = u; decref(t);" put),

                        c99-line("if (VTUP(v)->refs == 1) {" put)
                        c99-nest(
                            c99-line("VAL* p = &VTUP(v)->cells[" put
                                tag lbl c99-tag-label-index show put
                                "];" put)
                            c99-line("VAL t = *p; *p = u; decref(t);" put)
                            c99-line("push_value(v);" put)
                        )
                        c99-line("} else {" put)
                        c99-nest(
                            c99-line("TUP *tup = tup_new(" put
                                tag num-total-inputs 1+ show put
                                ");" put)
                            c99-line("tup->size = " put
                                tag num-total-inputs 1+ show put
                                ";" put)
                            0 >Nat while(dup tag num-total-inputs <=,
                                dup tag lbl c99-tag-label-index == if(
                                    c99-line("tup->cells[" put
                                        dup show put
                                        "] = u;" put),
                                    c99-line("tup->cells[" put
                                        dup show put
                                        "] = VTUP(v)->cells[" put
                                        dup show put
                                        "]; incref(tup->cells[" put
                                        dup show put
                                        "]);" put)
                                )
                                1+)
                            drop
                            c99-line("decref(v);" put)
                            c99-line("push_value(MKTUP(tup," put
                                tag num-total-inputs 1+ show put
                                "));" put)
                        )
                        c99-line("}" put)
                    )
                ),
            Right -> drop
                tag is-semi-transparent? if(
                    c99-line("(void)pop_resource();" put),

                    c99-line("VAL v = pop_resource();" put)
                    c99-line("VAL u = pop_resource();" put)
                    c99-line("ASSERT1(IS_TUP(v), v);" put)
                    c99-line("ASSERT1(VTUPLEN(v) == " put
                        tag num-total-inputs 1+ show put
                        ", v);" put)
                    c99-line("ASSERT1(VREFS(v) == 1, v);" put)
                    c99-line("VAL* p = &VTUP(v)->cells[" put
                        tag lbl c99-tag-label-index show put
                        "];" put)
                    c99-line("ASSERT1(p->tag == 0, v);" put)
                    c99-line("*p = u;" put)
                    c99-line("push_resource(v);" put)
                )
        ))
    )
    c99-line("}" put)
    start-branch!)

def(c99-external-blocks!, +C99 -- +C99,
    ExternalBlock.for(c99-external-block!))

def(c99-external-block!, ExternalBlock +C99 -- +C99,
    parts for(match(
        EBPCode -> put line,
        EBPDef -> c99-external-def!
    )))

def(c99-external-def!, External +C99 -- +C99,
    >ext
    @ext +mirth:ctype >cty

    @cty cod parts find(and(label? none?, ctype phantom? not)) >outty
    @outty if-some(ctype, Phantom) cname put " " put
    @ext symbol put

    " (" put
    @cty dom parts filter(ctype phantom? not)
    match(
        Nil -> "void" put,
        _ -> for(ctype cname put, ", " put)
    )
    ");" put line

    @ext +mirth:cname sig-put " {" put line
    reset-fresh-counter!

    @cty dom parts
    dup len >arg-index
    reverse-for(
        dup ctype phantom? else(
            "\t" put
            dup ctype cname put " " put
            dup c99-arg-name put
            " = " put
        )
        c99-pop
        ";" put line
        @arg-index:1-
    )

    "\t" put
    @outty for(ctype cname put " Y = " put)
    @ext symbol put "(" put

    1 >Nat !arg-index
    @cty dom parts filter-some(
        dup ctype phantom? if(drop None, c99-arg-name Some)
        @arg-index:1+
    )
    for(put, ", " put)
    ");" put line

    @cty cod parts for(
        "\t" put
        sip(label? if-some(name mangled, "Y"))
        c99-push
        line
    )

    "}" put line

    arg-index> drop
    ext> cty> outty> drop3)

def(CType.c99-pop-value, CType +C99 -- +C99,
    IntLike -> "(" put put ")pop_i64()" put,
    F32Like -> "(" put put ")pop_f32()" put,
    F64Like -> "(" put put ")pop_f64()" put,
    PtrLike -> "(" put put ")pop_ptr()" put,
    FnPtr   -> "(" put put ")pop_fnptr()" put,
    Phantom -> "(void)pop_value()" put )

def(CType.c99-pop-resource, CType +C99 -- +C99,
    IntLike -> "(" put put ")value_i64(pop_resource())" put,
    F32Like -> "(" put put ")value_f32(pop_resource())" put,
    F64Like -> "(" put put ")value_f64(pop_resource())" put,
    PtrLike -> "(" put put ")value_ptr(pop_resource())" put,
    FnPtr   -> "(" put put ")value_fnptr(pop_resource())" put,
    Phantom -> "(void)pop_resource()" put)

def(CType.c99-pop-label, Label CType +C99 -- +C99,
    IntLike -> "(" put put ")value_i64(lpop(&lbl_" put name mangled put "))" put,
    F32Like -> "(" put put ")value_f32(lpop(&lbl_" put name mangled put "))" put,
    F64Like -> "(" put put ")value_f64(lpop(&lbl_" put name mangled put "))" put,
    PtrLike -> "(" put put ")value_ptr(lpop(&lbl_" put name mangled put "))" put,
    FnPtr   -> "(" put put ")value_fnptr(lpop(&lbl_" put name mangled put "))" put,
    Phantom -> "(void)lpop(&lbl_" put name mangled put ")" put)

def(CType.c99-push-value, Str CType +C99 -- +C99,
    IntLike -> drop "push_i64((int64_t)(" put put "));" put,
    F32Like -> drop "push_f32((float)(" put put "));" put,
    F64Like -> drop "push_f64((double)(" put put "));" put,
    PtrLike -> drop "push_ptr((void*)(" put put "));" put,
    FnPtr   -> drop "push_fnptr((FNPTR)(" put put "));" put,
    Phantom -> drop "push_i64(0);" put)

def(CType.c99-push-resource, Str CType +C99 -- +C99,
    IntLike -> drop "push_resource(MKI64((int64_t)(" put put ")));" put,
    F32Like -> drop "push_resource(MKF32((float)(" put put ")));" put,
    F64Like -> drop "push_resource(MKF64((double)(" put put ")));" put,
    PtrLike -> drop "push_resource(MKPTR((void*)(" put put ")));" put,
    FnPtr   -> drop "push_resource(MKFNPTR((FNPTR)(" put put ")));" put,
    Phantom -> drop "push_resource(MKI64(0));" put)

def CType.c99-push-label [ Str Label CType +C99 -- +C99 ] {
    { IntLike -> drop "lpush(&lbl_" put name mangled put ", " put "MKI64((int64_t)(" put put ")));" put }
    { F32Like -> drop "lpush(&lbl_" put name mangled put ", " put "MKF32((float)(" put put ")));" put }
    { F64Like -> drop "lpush(&lbl_" put name mangled put ", " put "MKF64((double)(" put put ")));" put }
    { PtrLike -> drop "lpush(&lbl_" put name mangled put ", " put "MKPTR((void*)(" put put ")));" put }
    { FnPtr   -> drop "lpush(&lbl_" put name mangled put ", " put "MKFNPTR((FNPTR)(" put put ")));" put }
    { Phantom -> nip  "lpush(&lbl_" put name mangled put ", " put "MKI64((int64_t)(0)));" put }
}

def(CTypeStackPart.c99-arg-name, arg-index:Nat CTypeStackPart +C99 -- arg-index:Nat Str +C99,
    label? if-some(
        name mangled,
        Str("X" ; @arg-index show;)
    ))

def(CTypeStackPart.c99-pop, CTypeStackPart +C99 -- +C99,
    CTSPCons -> c99-pop-value,
    CTSPWith -> c99-pop-resource,
    CTSPConsLabel -> swap c99-pop-label,
    CTSPWithLabel -> swap c99-pop-label)

def(CTypeStackPart.c99-push, Str CTypeStackPart +C99 -- +C99,
    CTSPCons -> c99-push-value,
    CTSPWith -> c99-push-resource,
    CTSPConsLabel -> swap c99-push-label,
    CTSPWithLabel -> swap c99-push-label)

def(c99-nest(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99,
    depth:1+ f depth:1-)

def(+C99.indent, +C99 -- +C99, depth repeat("\t" put))
def(c99-line(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99, indent f line)

def(c99-call!, List(Arg) Str +C99Branch -- +C99Branch,
    dip(c99-args-push!)
    flush-cache! +core:c99-line(put "();" put))

def(c99-arrow!, Arrow +C99Branch -- +C99Branch, atoms for(c99-atom!))
def(c99-atom!, Atom +C99Branch -- +C99Branch,
    +core:options emit-debug-info and(dup show-in-stack-trace?) then(
        +core:c99-line("WORD_ATOM(" put
            dup token row >Int show put ", " put
            dup token col >Int show put ", " put
            dup token name? if-some(>Str, "") put-cstr
            ");" put
        )
    )
    sip(args) op
    c99-args-op!)

def(Atom.show-in-stack-trace?, Atom -- Bool,
    op match(
        OpNone -> False,
        OpInt -> drop False,
        OpF64 -> drop False,
        OpStr -> drop False,
        OpWord -> prefer-inline? not,
        OpExternal -> drop True,
        OpBuffer -> drop False,
        OpVariable -> drop False,
        OpField -> drop False,
        OpTag -> prefer-inline? not,
        OpPrim -> drop True,
        OpMatch -> drop False,
        OpLambda -> drop False,
        OpVar -> drop False,
        OpBlockPush -> drop False,
        OpBlockRun -> drop False,
        OpCoerce -> drop False,
        OpLabelPush -> drop False,
        OpLabelPop -> drop False,
        OpLabelPushR -> drop False,
        OpLabelPopR -> drop False,
        OpDataGetTag -> drop False,
        OpDataGetLabel -> drop2 False,
        OpDataSetLabel -> drop2 False
    ))

def(c99-args-op!, List(Arg) Op +C99Branch -- +C99Branch,
    OpNone     -> drop,
    OpInt      -> nip c99-int!,
    OpF64      -> nip c99-f64!,
    OpStr      -> nip c99-str!,
    OpWord     -> c99-word!,
    OpExternal -> +core:+mirth:cname c99-call!,
    OpBuffer   -> +core:+mirth:cname c99-call!,
    OpVariable -> +core:+mirth:cname c99-call!,
    OpField    -> +core:+mirth:cname c99-call!,
    OpTag      -> c99-tag-word!,
    OpPrim     -> c99-prim!,
    OpMatch    -> nip c99-match!,
    OpLambda   -> nip c99-lambda!,
    OpVar      -> nip c99-var!,
    OpBlockPush    -> nip c99-block-push!,
    OpBlockRun      -> nip c99-block-run!,
    OpCoerce   -> drop2,
    OpLabelPush -> nip c99-label-push!,
    OpLabelPop  -> nip c99-label-pop!,
    OpLabelPushR -> nip c99-label-push-r!,
    OpLabelPopR  -> nip c99-label-pop-r!,
    OpDataGetTag -> c99-get-data-tag!,
    OpDataGetLabel -> c99-tag-get-label! drop,
    OpDataSetLabel -> c99-tag-set-label! drop)

def(c99-get-data-tag!, List(Arg) Data +C99Branch -- +C99Branch,
    nip dup is-enum? or(dup is-unit?) else(
        end-branch!
        c99-line("{" put)
        c99-nest(
            c99-line("VAL val = pop_value();" put)
            dup is-semi-transparent? if(
                c99-line(
                    "push_u64(" put
                    dup tags /L1 unwrap value show put
                    "LL);" put),

                c99-line("USIZE tag = get_data_tag(val);" put)
                c99-line("push_u64(tag);" put )
            )
            c99-line("decref(val);" put)
        )
        c99-line("}" put)
        start-branch!
    ) drop)

def(c99-word!, List(Arg) Word +C99Branch -- +C99Branch,
    dup prefer-inline? if(
        dip:c99-args-push!
        +core:+mirth:arrow c99-arrow!,
        +core:+mirth:cname c99-call!
    ))

field(Tag.~value-show, Tag, Str)
def(Tag.value-show, Tag -- Str, dup ~value-show memoize(dup value show) nip)

def(c99-tag-word!, List(Arg) Tag +C99Branch -- +C99Branch,
    dup prefer-inline? if(
        dup .data is-transparent? else(
            dup outputs-resource? if(
                push-resource-expression!(
                    "MKU64(" put
                    dup value-show put "LL /* " put
                    dup name >Str put " */)" put
                ),
                C99RT_U64 push-expression!(
                    dup value-show put "LL /* " put
                    dup name >Str put " */" put
                )
            )
        ) drop2,
        +core:+mirth:word-cname c99-call!
    ))

def c99-reverse-tag! [ Tag +C99Branch -- +C99Branch ] {
    dup prefer-inline? if (
        dup .data is-transparent? else(
            +core:c99-line(
                dup outputs-resource? if(
                    "(void)pop_resource();",
                    "(void)pop_u64();"
                ) put
            )
        ) drop,
        dip:L0 +core:+mirth:pat-cname c99-call!
    )
}

def(c99-label-defs!, +C99 -- +C99, Label.for(c99-label-def!))
def(c99-label-def!, Label +C99 -- +C99, "static VAL lbl_" put name mangled put " = MKNIL_C;" put line)

def push-local-label-direct! [ Label +C99 +C99Local -- +C99 ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-local-label! [ Label +C99Branch +C99Local -- +C99Branch ] {
    rswap +stack(rswap +SCConsLabel)
}
def push-local-resource-label-direct! [ Label +C99 +C99LocalResource -- +C99 ] {
    consume swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-local-resource-label! [ Label +C99Branch +C99LocalResource -- +C99Branch ] {
    rswap +stack(rswap +SCWithLabel)
}


def pop-local-label-direct! [ Label +C99 -- +C99 +C99Local ] {
    C99RT_VAL local-expression!("lpop(&lbl_" put name mangled put ")" put) rswap
}

def pop-local-resource-label-direct! [ Label +C99 -- +C99 +C99LocalResource ] {
    local-resource-expression!("lpop(&lbl_" put name mangled put ")" put) rswap
}

def c99-label-push! [ Label +C99Branch -- +C99Branch ] {
    pop-local! push-local-label!
}
def c99-label-push-r! [ Label +C99Branch -- +C99Branch ] {
    pop-local-resource! push-local-resource-label!
}
def c99-label-pop! [ Label +C99Branch -- +C99Branch ] {
    pop-local-label! push-local!
}
def c99-label-pop-r! [ Label +C99Branch -- +C99Branch ] {
    pop-local-resource-label! push-local-resource!
}

def(c99-int!, Int +C99Branch -- +C99Branch,
    C99RT_I64 push-expression!(show put "LL" put))

def(c99-f64!, F64 +C99Branch -- +C99Branch,
    C99RT_F64 push-expression!(>Str put))

def(c99-str!, Str +C99Branch -- +C99Branch,
    end-branch! # TODO: do something smarter
    dup num-bytes 4090 >Size > if(
        c99-line("STRLIT(" put)
        c99-nest(
            c99-line(dup put-cstr-long "," put)
            c99-line(dup num-bytes show put)
        )
        c99-line(");" put),

        c99-line("STRLIT(" put
            dup put-cstr ", " put
            dup num-bytes show put ");" put)
    ) drop
    start-branch!)

def(+C99.put-cstr-long, Str +C99 -- +C99,
    False >avoid-hexdigit
    BQUOTE put-byte
    BNUL swap bytes-for(
        swap BLF == then(
            BQUOTE put-byte
            line indent
            BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    BQUOTE put-byte
    avoid-hexdigit> drop2)

def(+C99.put-cstr, Str +C99 -- +C99,
    False >avoid-hexdigit
    BQUOTE put-byte bytes-for(c99-string-byte!) BQUOTE put-byte
    avoid-hexdigit> drop)

def(c99-string-byte!, Byte avoid-hexdigit:Bool +C99 -- avoid-hexdigit:Bool +C99,
    B'\' ->   "\\\\" put False !avoid-hexdigit,
    BQUOTE -> "\\\"" put False !avoid-hexdigit,
    BHT ->    "\\t"  put False !avoid-hexdigit,
    BLF ->    "\\n"  put False !avoid-hexdigit,
    BCR ->    "\\r"  put False !avoid-hexdigit,
    _ ->
        dup BSPACE B'~' in-range
        and(dup is-hexdigit @avoid-hexdigit && not) if(
            put-byte
            False !avoid-hexdigit,
            "\\x" put to-hexdigits dip(put-byte) put-byte
            True !avoid-hexdigit
        )
    )

data C99ReprType {
    C99RT_VAL
    C99RT_I64
    C99RT_U64
    C99RT_F32
    C99RT_F64
    C99RT_BOOL
}

def C99ReprType.underlying-c99-type [ C99ReprType -- Str ] {
    { C99RT_VAL -> "VAL" }
    { C99RT_I64 -> "int64_t" }
    { C99RT_U64 -> "uint64_t" }
    { C99RT_F32 -> "float" }
    { C99RT_F64 -> "double" }
    { C99RT_BOOL -> "bool" }
}

def C99ReprType.is-macro [ C99ReprType -- Str ] {
    { C99RT_VAL -> "IS_VAL" }
    { C99RT_I64 -> "IS_I64" }
    { C99RT_U64 -> "IS_U64" }
    { C99RT_F32 -> "IS_F32" }
    { C99RT_F64 -> "IS_F64" }
    { C99RT_BOOL -> "IS_BOOL" }
}

def C99ReprType.v-macro [ C99ReprType -- Str ] {
    { C99RT_VAL -> "VVAL" }
    { C99RT_I64 -> "VI64" }
    { C99RT_U64 -> "VU64" }
    { C99RT_F32 -> "VF32" }
    { C99RT_F64 -> "VF64" }
    { C99RT_BOOL -> "VBOOL" }
}

def C99ReprType.mk-macro [ C99ReprType -- Str ] {
    { C99RT_VAL -> "MKVAL" }
    { C99RT_I64 -> "MKI64" }
    { C99RT_U64 -> "MKU64" }
    { C99RT_F32 -> "MKF32" }
    { C99RT_F64 -> "MKF64" }
    { C99RT_BOOL -> "MKBOOL" }
}

def C99ReprType.pop-macro [ C99ReprType -- Str ] {
    { C99RT_VAL -> "pop_value" }
    { C99RT_I64 -> "pop_i64" }
    { C99RT_U64 -> "pop_u64" }
    { C99RT_F32 -> "pop_f32" }
    { C99RT_F64 -> "pop_f64" }
    { C99RT_BOOL -> "pop_bool" }
}

def C99ReprType.push-macro [ C99ReprType -- Str ] {
    { C99RT_VAL -> "push_value" }
    { C99RT_I64 -> "push_i64" }
    { C99RT_U64 -> "push_u64" }
    { C99RT_F32 -> "push_f32" }
    { C99RT_F64 -> "push_f64" }
    { C99RT_BOOL -> "push_bool" }
}

struct +C99Local {
    local-repr: C99ReprType
    local-name: Str
}

def C99ReprType.pop-to-local-direct! [ C99ReprType +C99 -- +C99 +C99Local ] {
    >local-repr
    fresh-name! >local-name
    c99-line(@local-repr underlying-c99-type put " " put
             @local-name put " = " put
             @local-repr pop-macro put "();" put)
    +C99Local
}

def +C99.pop-local-direct! [ +C99 -- +C99 +C99Local ] {
    C99RT_VAL pop-to-local-direct!
}

||| Push a value with a certain repr type on the stack.
||| `f` must emit the C99 expression that calculates the value,
||| which must be of the underlying C99 repr type.
def C99ReprType.push-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99Branch -- *b +C99Branch
] {
    +core:local-expression!(f) rswap push-local!
}

def push-resource-expression!(f) [
    (*a +C99 -- *b +C99) *a +C99Branch -- *b +C99Branch
] {
    +core:local-resource-expression!(f) rswap push-local-resource!
}

def C99ReprType.local-expression!(f) [
    (*a +C99 -- *b +C99) *a C99ReprType +C99 -- *b +C99Local +C99
] {
    >local-repr
    fresh-name! >local-name
    rdip:+C99Local
    c99-line(rdip:local-repr underlying-c99-type put " " put
             rdip:local-name put " = (" put
             rswap rdip:f rswap ");" put)
}

def local-resource-expression!(f) [
    (*a +C99 -- *b +C99) *a +C99 -- *b +C99LocalResource +C99
] {
    fresh-name! >local-resource-name rdip:+C99LocalResource
    c99-line("VAL " put rdip:local-resource-name put " = (" put
        rswap rdip:f rswap ");" put)
}

def +C99Local.push-local-direct! [ +C99 +C99Local -- +C99 ] {
    /+C99Local c99-line(
        local-repr> push-macro put "(" put
        local-name> put ");" put
    )
}

def +C99Local.consume [ +C99Local -- Str ] {
    /+C99Local local-repr> drop local-name>
}

def +C99Local.consume-as-VAL [ +C99Local -- Str ] {
    /+C99Local local-repr> match {
        C99RT_VAL -> local-name>,
        _ -> Str(mk-macro ; "(" ; local-name> ; ")";)
    }
}

def +C99Local.consume-as-I64 [ +C99Local -- Str ] {
    /+C99Local local-name> local-repr> match {
        { C99RT_VAL  -> Str("VI64(" ; ; ")";) }
        { C99RT_I64  -> }
        { C99RT_U64  -> Str("((int64_t)(" ; ; "))";) }
        { C99RT_BOOL -> Str("((int64_t)(" ; ; "))";) }
        { _ -> "attempted to consume non-I64 as I64" panic! }
    }
}

def +C99Local.consume-as-U64 [ +C99Local -- Str ] {
    /+C99Local local-name> local-repr> match {
        { C99RT_VAL  -> Str("VU64(" ; ; ")";) }
        { C99RT_U64  -> }
        { C99RT_I64  -> Str("((uint64_t)(" ; ; "))";) }
        { C99RT_BOOL -> Str("((uint64_t)(" ; ; "))";) }
        { _ -> "attempted to consume non-U64 as U64" panic! }
    }
}

def +C99Local.consume-as-BOOL [ +C99Local -- Str ] {
    /+C99Local local-name> local-repr> match {
        { C99RT_VAL  -> Str("VBOOL(" ; ; ")";) }
        { C99RT_BOOL -> }
        { C99RT_I64  -> Str("((_Bool)(" ; ; "))";) }
        { C99RT_U64  -> Str("((_Bool)(" ; ; "))";) }
        { _ -> "attempted to consume non-U64 as U64" panic! }
    }
}

def +C99Local.consume-as-F32 [ +C99Local -- Str ] {
    /+C99Local local-name> local-repr> match {
        { C99RT_VAL -> Str("VF32(" ; ; ")";) }
        { C99RT_F32 -> }
        { _ -> "attempted to consume non-F32 as F32" panic! }
    }
}

def +C99Local.consume-as-F64 [ +C99Local -- Str ] {
    /+C99Local local-name> local-repr> match {
        { C99RT_VAL -> Str("VF64(" ; ; ")";) }
        { C99RT_F64 -> }
        { _ -> "attempted to consume non-F64 as F64" panic! }
    }
}

def +C99Local.consume-as [ C99ReprType +C99Local -- Str ] {
    C99RT_VAL  -> consume-as-VAL,
    C99RT_I64  -> consume-as-I64,
    C99RT_U64  -> consume-as-U64,
    C99RT_BOOL -> consume-as-BOOL,
    C99RT_F32  -> consume-as-F32,
    C99RT_F64  -> consume-as-F64,
}

def +C99Local.drop-local! [ +C99Branch +C99Local -- +C99Branch ] {
    local-repr match {
        { C99RT_VAL -> >+x +core:c99-line("decref(" put +x> consume put ");" put) }
        { C99RT_I64 -> consume drop }
        { C99RT_U64 -> consume drop }
        { C99RT_F32 -> consume drop }
        { C99RT_F64 -> consume drop }
        { C99RT_BOOL -> consume drop }
    }
}
def +C99Local.dup-local! [ +C99Branch +C99Local -- +C99Branch +C99Local +C99Local ] {
    local-repr >+x match {
        { C99RT_VAL -> +core:c99-line("incref(" put @+x:local-name put ");" put) }
        { C99RT_I64 -> }
        { C99RT_U64 -> }
        { C99RT_F32 -> }
        { C99RT_F64 -> }
        { C99RT_BOOL -> }
    }
    +x>
    local-repr >local-repr
    local-name >local-name
    +C99Local
}

struct +C99LocalResource {
    local-resource-name: Str
}

def +C99LocalResource.consume [ +C99LocalResource -- Str ] {
    /+C99LocalResource local-resource-name>
}

def +C99.pop-local-resource-direct! [ +C99 -- +C99 +C99LocalResource ] {
    fresh-resource-name! >local-resource-name
    c99-line("VAL " put @local-resource-name put " = pop_resource();" put)
    +C99LocalResource
}

def +C99LocalResource.push-local-resource-direct! [ +C99 +C99LocalResource -- +C99 ] {
    /+C99LocalResource
    c99-line("push_resource(" put local-resource-name> put ");" put)
}

data +C99Local? {
    +C99LocalNone
    +C99LocalSome [ +C99Local ]
}

data +C99LocalResource? {
    +C99LocalResourceNone
    +C99LocalResourceSome [ +C99LocalResource ]
}

data +C99StackCache {
    +SCNil
    +SCCons [ +C99StackCache +C99Local ]
    +SCWith [ +C99StackCache +C99LocalResource ]
    +SCConsLabel [ +C99StackCache +C99Local Label ]
    +SCWithLabel [ +C99StackCache +C99LocalResource Label ]
}

def +C99StackCache.pop-local? [ +C99StackCache -- +C99Local? +C99StackCache ] {
    { +SCNil -> +C99LocalNone +SCNil }
    { +SCCons -> +C99LocalSome rswap }
    { +SCWith -> rdip:pop-local? +SCWith }
    { +SCConsLabel -> rdip:pop-local? +SCConsLabel }
    { +SCWithLabel -> rdip:pop-local? +SCWithLabel }
}

def +C99StackCache.pop-local-resource? [ +C99StackCache -- +C99LocalResource? +C99StackCache ] {
    { +SCNil -> +C99LocalResourceNone +SCNil }
    { +SCWith -> +C99LocalResourceSome rswap }
    { +SCCons -> rdip:pop-local-resource? +SCCons }
    { +SCConsLabel -> rdip:pop-local-resource? +SCConsLabel }
    { +SCWithLabel -> rdip:pop-local-resource? +SCWithLabel }
}

def +C99StackCache.pop-local-label? [ Label +C99StackCache -- Label +C99Local? +C99StackCache ] {
    { +SCNil -> +C99LocalNone +SCNil }
    { +SCCons -> rdip:pop-local-label? +SCCons }
    { +SCWith -> rdip:pop-local-label? +SCWith }
    { +SCWithLabel -> dip:rdip:pop-local-label? +SCWithLabel }
    { +SCConsLabel ->
        dup2 == if(
            drop +C99LocalSome rswap,
            dip:rdip:pop-local-label? +SCConsLabel
        )
    }
}

def +C99StackCache.pop-local-resource-label? [ Label +C99StackCache -- Label +C99LocalResource? +C99StackCache ] {
    { +SCNil -> +C99LocalResourceNone +SCNil }
    { +SCCons -> rdip:pop-local-resource-label? +SCCons }
    { +SCWith -> rdip:pop-local-resource-label? +SCWith }
    { +SCConsLabel -> dip:rdip:pop-local-resource-label? +SCConsLabel }
    { +SCWithLabel ->
        dup2 == if(
            drop +C99LocalResourceSome rswap,
            dip:rdip:pop-local-resource-label? +SCWithLabel
        )
    }
}

def +C99StackCache.flush-all! [ +C99 +C99StackCache -- +C99 ] {
    { +SCNil -> }
    { +SCCons -> rdip:flush-all! push-local-direct! }
    { +SCWith -> rdip:flush-all! push-local-resource-direct! }
    { +SCConsLabel -> rdip:flush-all! push-local-label-direct! }
    { +SCWithLabel -> rdip:flush-all! push-local-resource-label-direct! }
}

struct +C99Branch {
    +core: +C99
    +stack: +C99StackCache
}

def +C99.start-branch! [ +C99 -- +C99Branch ] {
    >+core +SCNil >+stack +C99Branch
}

def +C99Branch.end-branch! [ +C99Branch -- +C99 ] {
    /+C99Branch +core> +stack> flush-all!
}

def +C99Branch.flush-cache! [ +C99Branch -- +C99Branch ] {
    end-branch!
    start-branch!
}

def +C99Branch.pop-local! [ +C99Branch -- +C99Branch +C99Local ] {
    +stack(pop-local?) rswap match {
        { +C99LocalSome -> }
        { +C99LocalNone -> +core(pop-local-direct! rswap) rswap }
    }
}

def +C99Branch.pop-local-label! [ Label +C99Branch -- +C99Branch +C99Local ] {
    +stack(pop-local-label?) rswap match {
        { +C99LocalSome -> drop }
        { +C99LocalNone -> +core(pop-local-label-direct! rswap) rswap }
    }
}

def +C99Branch.pop-local-resource! [ +C99Branch -- +C99Branch +C99LocalResource ] {
    +stack(pop-local-resource?) rswap match {
        { +C99LocalResourceSome -> }
        { +C99LocalResourceNone -> +core(pop-local-resource-direct! rswap) rswap }
    }
}

def +C99Branch.pop-local-resource-label! [ Label +C99Branch -- +C99Branch +C99LocalResource ] {
    +stack(pop-local-resource-label?) rswap match {
        { +C99LocalResourceSome -> drop }
        { +C99LocalResourceNone -> +core(pop-local-resource-label-direct! rswap) rswap }
    }
}

def +C99Local.push-local! [ +C99Branch +C99Local -- +C99Branch ] {
    rswap +stack(rswap +SCCons)
}

def +C99LocalResource.push-local-resource! [ +C99Branch +C99LocalResource -- +C99Branch ] {
    rswap +stack(rswap +SCWith)
}

struct C99BinOp {
    operator: Str
    precedence: Int
    arg1-type: C99ReprType
    arg2-type: C99ReprType
    out-type: C99ReprType
}

def C99BinOp.Mk [ Str Int C99ReprType C99ReprType C99ReprType -- C99BinOp ] {
    >out-type >arg2-type >arg1-type
    >precedence >operator
    C99BinOp
}

def c99-prim-binop? [ Prim -- Maybe(C99BinOp) ] {
    { PRIM_INT_MUL -> "*"  3  C99RT_I64 C99RT_I64 C99RT_I64 C99BinOp.Mk Some }
    # { PRIM_INT_DIV -> "/"  3  C99RT_I64 C99RT_I64 C99RT_I64  C99BinOp.Mk Some }
    # { PRIM_INT_MOD -> "%"  3  C99RT_I64 C99RT_I64 C99RT_I64  C99BinOp.Mk Some }
    # { PRIM_INT_ADD -> "+"  4  C99RT_I64 C99RT_I64 C99RT_I64 C99BinOp.Mk Some }
    # { PRIM_INT_SUB -> "-"  4  C99RT_I64 C99RT_I64 C99RT_I64 C99BinOp.Mk Some }
    # { PRIM_INT_SHL -> "<<" 5 C99RT_U64 C99RT_U64 C99RT_U64 C99BinOp.Mk Some }
    # { PRIM_INT_SHR -> ">>" 5 C99RT_U64 C99RT_U64 C99RT_U64 C99BinOp.Mk Some }
    { PRIM_INT_LT  -> "<"  6  C99RT_I64 C99RT_I64 C99RT_BOOL C99BinOp.Mk Some }
    { PRIM_INT_EQ  -> "==" 7  C99RT_I64 C99RT_I64 C99RT_BOOL C99BinOp.Mk Some }
    { PRIM_INT_AND -> "&"  8  C99RT_U64 C99RT_U64 C99RT_U64 C99BinOp.Mk Some }
    { PRIM_INT_XOR -> "^"  9  C99RT_U64 C99RT_U64 C99RT_U64 C99BinOp.Mk Some }
    { PRIM_INT_OR  -> "|"  10 C99RT_U64 C99RT_U64 C99RT_U64 C99BinOp.Mk Some }

    { PRIM_F32_ADD -> "+"  4  C99RT_F32 C99RT_F32 C99RT_F32  C99BinOp.Mk Some }
    { PRIM_F32_SUB -> "-"  4  C99RT_F32 C99RT_F32 C99RT_F32  C99BinOp.Mk Some }
    { PRIM_F32_MUL -> "*"  3  C99RT_F32 C99RT_F32 C99RT_F32  C99BinOp.Mk Some }
    { PRIM_F32_DIV -> "/"  3  C99RT_F32 C99RT_F32 C99RT_F32  C99BinOp.Mk Some }
    { PRIM_F32_LT  -> "<"  6  C99RT_F32 C99RT_F32 C99RT_BOOL C99BinOp.Mk Some }
    { PRIM_F32_EQ  -> "==" 7  C99RT_F32 C99RT_F32 C99RT_BOOL C99BinOp.Mk Some }

    { PRIM_F64_ADD -> "+"  4  C99RT_F64 C99RT_F64 C99RT_F64  C99BinOp.Mk Some }
    { PRIM_F64_SUB -> "-"  4  C99RT_F64 C99RT_F64 C99RT_F64  C99BinOp.Mk Some }
    { PRIM_F64_MUL -> "*"  3  C99RT_F64 C99RT_F64 C99RT_F64  C99BinOp.Mk Some }
    { PRIM_F64_DIV -> "/"  3  C99RT_F64 C99RT_F64 C99RT_F64  C99BinOp.Mk Some }
    { PRIM_F64_LT  -> "<"  6  C99RT_F64 C99RT_F64 C99RT_BOOL C99BinOp.Mk Some }
    { PRIM_F64_EQ  -> "==" 7  C99RT_F64 C99RT_F64 C99RT_BOOL C99BinOp.Mk Some }

    { _ -> drop None }
}

def c99-prim! [ List(Arg) Prim +C99Branch -- +C99Branch ] {
    { PRIM_CORE_ID -> drop }
    { PRIM_CORE_DROP -> drop pop-local! drop-local! }
    { PRIM_CORE_DUP -> drop pop-local! dup-local! rdip:push-local! push-local! }
    { PRIM_CORE_SWAP ->
        drop
        pop-local! >+b
        pop-local! >+a
        +b> push-local!
        +a> push-local!
    }
    { PRIM_CORE_RSWAP ->
        drop
        pop-local-resource! >+b
        pop-local-resource! >+a
        +b> push-local-resource!
        +a> push-local-resource!
    }
    { PRIM_CORE_DIP ->
        dup /L1 match(
            Some ->
                nip
                pop-local! >+dipped
                c99-arg-run!
                +dipped> push-local!,
            None ->
                PRIM_CORE_DIP c99-prim-default!
        )
    }
    { PRIM_CORE_RDIP ->
        dup /L1 match(
            Some ->
                nip
                pop-local-resource! >+dipped
                c99-arg-run!
                +dipped> push-local-resource!,
            None ->
                PRIM_CORE_RDIP c99-prim-default!
        )
    }
    { PRIM_CORE_IF ->
        dup /L2 match(
            Some ->
                nip unpack2
                pop-local! >+cond
                end-branch!
                c99-line("if (" put +cond> consume-as-BOOL put ") {" put)
                c99-nest(start-branch! swap c99-arg-run! end-branch!)
                c99-line("} else {" put)
                c99-nest(start-branch! c99-arg-run! end-branch!)
                c99-line("}" put)
                start-branch!,
            None ->
                PRIM_CORE_IF c99-prim-default!
        )
    }
    { PRIM_CORE_WHILE ->
        dup /L2 match(
            Some ->
                nip unpack2
                end-branch!
                c99-line("while(1) {" put)
                c99-nest(
                    start-branch!
                    swap c99-arg-run!
                    pop-local! >+cond
                    end-branch!
                    c99-line("if (!" put +cond> consume-as-BOOL put ") break;" put)
                    start-branch!
                    c99-arg-run!
                    end-branch!
                )
                c99-line("}" put)
                start-branch!,

            None ->
                PRIM_CORE_WHILE c99-prim-default!
        )
    }

    { _ ->
        over empty? if(
            dup c99-prim-binop? if-some(
                dip:drop2 c99-binop!,
                c99-prim-default!
            ),
            c99-prim-default!
        )
    }
}

def c99-binop! [ C99BinOp +C99Branch -- +C99Branch ] {
    /C99BinOp
    pop-local! >+arg2
    pop-local! >+arg1
    out-type> push-expression!(
        +arg1> arg1-type> consume-as put
        " " put operator> put " " put
        +arg2> arg2-type> consume-as put
    )

    precedence> drop
}

def(c99-prim-default!, List(Arg) Prim +C99Branch -- +C99Branch,
    cname c99-call!)

def(c99-args-push!, List(Arg) +C99Branch -- +C99Branch,
    for(c99-arg-push!))

def(c99-arg-push!, Arg +C99Branch -- +C99Branch,
    ArgBlock -> c99-block-push!)

def(c99-arg-run!, Arg +C99Branch -- +C99Branch,
    ArgBlock -> c99-block-run!)

def(c99-block-run!, Block +C99Branch -- +C99Branch,
    +core:+mirth:arrow c99-arrow!)

def(+C99.var-put, Var +C99 -- +C99, "var_" put name mangled put)

def(c99-pack-closure-vars!, List(Var) +C99Branch -- +C99Branch,
    filter(is-physical?) for(
        c99-var-push!
        L0 PRIM_PACK_CONS c99-prim!
    ))

def c99-pop-to-var! [ Var +C99Branch -- +C99Branch ] {
    pop-local! consume-as-VAL swap
    +core:c99-line("VAL " put var-put " = " put put ";" put)
}

def(c99-unpack-closure-vars!, List(Var) +C99Branch -- +C99Branch,
    filter(is-physical?) dup empty? if(
        drop,
        reverse-for(
            L0 PRIM_PACK_UNCONS c99-prim!
            c99-pop-to-var!
        )
        L0 PRIM_CORE_DROP c99-prim!
    ))

def(c99-decref-closure-vars!, List(Var) +C99Branch -- +C99Branch,
    filter(is-physical?) reverse-for(
        +core:c99-line("decref(" put var-put ");" put)
    ))

def(c99-block-push!, Block +C99Branch -- +C99Branch,
    dup +core:+mirth:to-run-var match(
        Some -> nip c99-var-push!,
        None ->
            flush-cache!
            C99RT_VAL push-expression!("MKFNPTR(&" put dup +mirth:cname put ")" put)
            dup +core:+mirth:free-vars c99-pack-closure-vars!
            drop
    ))

def(c99-var!, Var +C99Branch -- +C99Branch,
    dup auto-run? if(c99-var-run!, c99-var-push!))

def(c99-var-run!, Var +C99Branch -- +C99Branch,
    flush-cache!
    +core:c99-line("incref(" put dup var-put ");" put)
    +core:c99-line("run_value(" put dup var-put ");" put)
    drop)

def(c99-var-push!, Var +C99Branch -- +C99Branch,
    flush-cache!
    +core:c99-line("incref(" put dup var-put ");" put)
    C99RT_VAL push-expression!(dup var-put)
    drop)

def(c99-lambda!, Lambda +C99Branch -- +C99Branch,
    end-branch!
    c99-line("{" put)
    c99-nest(
        start-branch!
        dup params reverse-for(c99-pop-to-var!)
        dup body c99-arrow!
        params reverse-for(
            +core:c99-line("decref(" put var-put ");" put)
        )
        end-branch!
    )
    c99-line("}" put)
    start-branch!)

def(c99-match!, Match +C99Branch -- +C99Branch,
    dup is-transparent? if(
        cases first unwrap body c99-arrow!,

    dup semi-transparent-tag? if-some(
        dip:L0 +core:+mirth:pat-cname c99-call!
        cases first unwrap body c99-arrow!,

        end-branch!
        dup scrutinee-data?
        unwrap(token "non-uniform match, not supported at present" +mirth:emit-fatal-error!)
        is-resource? if(
            c99-line("switch (get_top_resource_data_tag()) {" put),
            c99-line("switch (get_top_data_tag()) {" put)
        )
        c99-nest(
            dup cases for(c99-case!)
            has-default-case? else(
                c99-line("default: {" put)
                c99-nest(
                    c99-line("push_value(mkstr(\"unexpected fallthrough in match\\n\", 32));" put)
                    start-branch! L0 PRIM_CORE_PANIC c99-prim! end-branch!
                )
                c99-line("}" put)
            )
        )
        c99-line("}" put)
        start-branch!
    )))

def c99-case! [ Case +C99 -- +C99 ] {
    dup pattern is-default? if(
        c99-line("default: {" put)
        c99-nest(
            start-branch!
            body c99-arrow!
            end-branch!
        )
        c99-line("} break;" put),

    dup pattern single-tag? if-some(
        c99-line("case " put dup value-show put "LL: { // " put dup name >Str put)
        c99-nest(
            start-branch!
            c99-reverse-tag!
            body c99-arrow!
            end-branch!
        )
        c99-line("} break;" put),

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def(c99-word-sigs!, +C99 -- +C99, Word.for(dup +needs(needed?) if(c99-word-sig!, drop)))
def(c99-word-sig!, Word +C99 -- +C99, c99-line(+mirth:cname sig-put ";" put))

def(c99-block-sigs!, +C99 -- +C99, Block.for(dup +needs(needed?) if(c99-block-sig!, drop)))
def(c99-block-sig!, Block +C99 -- +C99, c99-line(+mirth:cname sig-put ";" put))

def(c99-field-sigs!, +C99 -- +C99, Field.for(c99-field-sig!))
def(c99-field-sig!, Field +C99 -- +C99, c99-line(+mirth:cname sig-put ";" put))

def(c99-block-enter!, Block +C99 -- +C99Branch,
    options emit-debug-info if(
        c99-line("WORD_ENTER(" put
            dup +mirth:cname put ", " put
            dup home match(
                HomeMain -> drop "block",
                HomeWord -> name >Str " block" cat,
            ) put-cstr ", " put
            dup token .module source-path >Str put-cstr ", " put
            dup token row >Int show put ", " put
            dup token col >Int show put ");" put
        ) drop,
        drop
    )
    start-branch!)

def(c99-block-exit!, Block +C99Branch -- +C99,
    end-branch!
    options emit-debug-info if(
        c99-line("WORD_EXIT(" put +mirth:cname put ");" put),
        drop
    ))

def(c99-block-defs!, +C99 -- +C99, Block.for(dup +needs(needed?) if(c99-block-def!, drop)))
def(c99-block-def!, Block +C99 -- +C99,
    c99-line(dup +mirth:cname sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-block-enter!
        dup +core:+mirth:arrow
        dup +core:+mirth:free-vars c99-unpack-closure-vars!
        dup c99-arrow!
        +core:+mirth:free-vars c99-decref-closure-vars!
        c99-block-exit!
    )
    c99-line("}" put))

def(c99-word-enter!, Word +C99 -- +C99Branch,
    options emit-debug-info if(
        c99-line(
            "WORD_ENTER(" put
            dup +mirth:cname put ", " put
            dup name >Str put-cstr ", " put
            dup body .module source-path >Str put-cstr ", " put
            dup body row >Int show put ", " put
            dup body col >Int show put ");" put
        ) drop,
        drop
    )
    start-branch!)

def(c99-word-exit!, Word +C99Branch -- +C99,
    end-branch!
    options emit-debug-info if(
        c99-line("WORD_EXIT(" put +mirth:cname put ");" put),
        drop
    ))

def(c99-word-defs!, +C99 -- +C99, Word.for(dup +needs(needed?) if(c99-word-def!, drop)))
def(c99-word-def!, Word +C99 -- +C99,
    c99-line(dup +mirth:cname sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-word-enter!
        dup +core:+mirth:arrow c99-arrow!
        dup c99-word-exit!
    )
    c99-line("}" put)
    drop)

def(c99-field-defs!, +C99 -- +C99, Field.for(c99-field-def!))
def(c99-field-def!, Field +C99 -- +C99,
    dup +mirth:cname sig-put " {" put line
    reset-fresh-counter!
    "\tsize_t i = (size_t)pop_u64();" put line
    "\tstatic struct VAL * p = 0;" put line
    "\tsize_t m = " put TABLE_MAX_COUNT show put ";" put line
    "\tif (! p) { p = calloc(m, sizeof *p); }" put line
    "\tEXPECT(i<m, \"table grew too big\");" put line
    "\tpush_ptr(p+i);" put line
    "}" put line line
    drop)

def(c99-main!, Arrow +C99 -- +C99,
    c99-line("int main (int argc, char** argv) {" put)
    reset-fresh-counter!
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        options emit-debug-info then(
            c99-line("WORD_ENTER(" put
                "(void(*)(void))0, " put
                "\"<main>\", " put
                dup token-start .module source-path >Str put-cstr ", " put
                dup token-start row >Int show put ", " put
                dup token-start col >Int show put ");" put)
        )
        start-branch!
        push-resource-expression!("MKU64(0) /* The World! */" put)
        c99-arrow!
        end-branch!
        options emit-debug-info then(
            c99-line("WORD_EXIT((void(*)(void))0);" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put))
