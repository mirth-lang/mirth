module mirth.c99

import std.prelude
import std.str
import std.path
import std.list
import std.byte
import std.maybe
import std.either
import std.file
import std.output

import mirth.mirth
import mirth.module
import mirth.location
import mirth.token
import mirth.name
import mirth.buffer
import mirth.arrow
import mirth.word
import mirth.table
import mirth.external
import mirth.tycon
import mirth.type
import mirth.data
import mirth.package
import mirth.prim
import mirth.var
import mirth.match
import mirth.elab
import mirth.need
import mirth.label
import mirth.def

#######
# C99 #
#######

struct C99_Options {
    output-path: Path
    emit-debug-info: Bool
}

struct +C99 {
    options: C99_Options
    depth: Nat
    fresh-counter: Nat
    put-enabled: Bool
    +needs: +Needs
    +output: +Output
    +mirth: +Mirth
}

def +C99.put [ Str +C99 -- +C99 ] { put-enabled if(+output:put, drop) }
def +C99.put-byte [ Byte +C99 -- +C99 ] { put-enabled if(+output:put-byte, drop) }
def +C99.line [ +C99 -- +C99 ] { put-enabled then(+output:line) }

def run-output-c99! [ +World +Mirth |- Arrow C99_Options -- ] {
    num-errors 0> if(
        "There were errors, so codegen stopped." rdip:trace
        panic-diagnostics!
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-field-defs!
        c99-tag-defs!
        c99-buffers!
        c99-external-blocks!
        c99-word-sigs!
        c99-block-sigs!
        c99-main!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    )
}

def c99-start! [ +World Arrow |- C99_Options +Mirth -- +C99 ] {
    >options
    0u >depth
    0u >fresh-counter
    True >put-enabled
    +Needs.New dup determine-arrow-needs! >+needs >+mirth
    @options output-path create-file! +else(+mirth> io-error!) +Output.start! >+output
    +C99
}

def c99-end! [ +World |- +C99 -- +Mirth ] {
    /+C99
    depth> fresh-counter> options> drop3
    put-enabled> drop
    +needs> rdrop
    +output> end! close-file!
    +mirth>
    for(io-error!)
}

def +C99.reset-fresh-counter! [ +C99 |- ] {
    0u fresh-counter!
}

def +C99.fresh-nat! [ +C99 |- Nat ] {
    fresh-counter
    dup 1+ fresh-counter!
}

def +C99.with-fresh-counter(f) [ +C99 |- ( *a -- *b ) *a Nat -- *b Nat ] {
    fresh-counter dip(fresh-counter! f fresh-counter) fresh-counter!
}

def +C99.fresh-name-on!       [ +C99 |- Str -- Str ] { fresh-nat! >Str cat }
def +C99.fresh-name!          [ +C99 |-        Str ] { "v" fresh-name-on! }
def +C99.fresh-resource-name! [ +C99 |-        Str ] { "r" fresh-name-on! }

field(Tag.~word-cname, Tag, Str)
field(Tag.~pat-cname, Tag, Str)
field(Buffer.~cname, Buffer, Str)
field(Field.~cname, Field, Str)
field(External.~cname, External, Str)
field(Prim.~cname, Prim, Str)

def Tag.word-cname [ +Mirth |- Tag      -- Str ] { dup ~word-cname memoize(dup qname      Str("mtw_"  ; mangled;)) nip }
def Tag.pat-cname  [ +Mirth |- Tag      -- Str ] { dup ~pat-cname  memoize(dup qname      Str("mtp_"  ; mangled;)) nip }
def Buffer.cname   [ +Mirth |- Buffer   -- Str ] { dup ~cname      memoize(dup qname-hard Str("mbuf_" ; mangled;)) nip }
def Field.cname    [ +Mirth |- Field    -- Str ] { dup ~cname      memoize(dup qname-hard Str("mfld_" ; mangled;)) nip }
def External.cname [ +Mirth |- External -- Str ] { dup ~cname      memoize(dup qname-hard Str("mext_" ; mangled;)) nip }

embed-str(c99-header-str, "src/mirth.h")
def c99-header! [ +C99 |- ] {
    "#define MIRTH_DEBUG " put
    options emit-debug-info if("1", "0") put line
    c99-header-str put line
}

def c99-buffers! [ +C99 |- ] { Buffer.for(c99-buffer!) }
def c99-buffer! [ +C99 |- Buffer -- ] {
    "static char " put
    dup +mirth:cname put
    "[" put +mirth:size >Str put "] = {0};" put line
}
def c99-buffer-call! [ +C99Branch |- Buffer -- ] {
    C99ReprType.PTR push-value-expression!(+mirth:cname put)
}

def c99-tag-defs! [ +C99 |- ] { Tag.for(c99-tag-def!) }
def c99-tag-def! [ +C99 |- Tag -- ] {
    >tag
    @tag +mirth:prefer-inline? else(
        @tag +needs:word-needed? then(
            @tag word-c99-api c99-smart-def!(
                @tag c99-tag-body!
            )
        )

        @tag +needs:pat-needed? then(
            @tag pat-c99-api c99-smart-def!(
                @tag c99-reverse-tag-body!
            )
        )
    ) tag> drop
}

def c99-tag-body! [ +C99Branch |- Tag -- ] {
    >tag
    @tag +mirth:semi-transparent? if?(
        input match {
            { ConsLabel ->
                dip:type-to-c99-repr pop-value-label!
                @tag rdip:+mirth:outputs-resource? if(
                    turn-into-resource! push-resource!,
                    push-value!
                )
            }
            { WithLabel ->
                dip:resource-to-c99-repr pop-resource-label!
                push-resource!
            }
            { Cons ->
                type-to-c99-repr pop-value!
                @tag rdip:+mirth:outputs-resource? if(
                    turn-into-resource! push-resource!,
                    push-value!
                )
            }
            { With ->
                resource-to-c99-repr pop-resource!
                push-resource!
            }
        },

    @tag +mirth:num-total-inputs 0= if(
        @tag +mirth(data is-enum-or-unit?) if(
            C99ReprType.I64 "" >pfx "" >sfx,
            C99ReprType.VAL "MKI64(" >pfx ")" >sfx
        )
        @tag +mirth:outputs-resource? if(
            push-resource-expression!(
                pfx> put
                @tag +mirth:value-show put "LL /* " put
                @tag +mirth(name >Str) put " */" put
                sfx> put
            ),
            push-value-expression!(
                pfx> put
                @tag +mirth:value-show put "LL /* " put
                @tag +mirth(name >Str) put " */" put
                sfx> put
            )
        ),

        @tag +mirth:inputs >parts
        @tag Some +mirth:filter(only-tag? not) >tag
        c99-pack-tuple!
        @tag rdip:+mirth:outputs-resource? if(
            push-resource!,
            turn-into-value! push-value!
        )
    ))
    tag> drop
}

def c99-reverse-tag-body! [ +C99Branch |- Tag -- ] {
    >tag
    @tag +mirth:semi-transparent? if?(
        input match {
            { ConsLabel ->
                swap type-to-c99-repr
                @tag +mirth:outputs-resource? if(
                    pop-resource! turn-into-value!,
                    pop-value!
                )
                push-value-label!
            }
            { WithLabel ->
                swap resource-to-c99-repr
                pop-resource!
                push-resource-label!
            }
            { Cons ->
                type-to-c99-repr
                @tag +mirth:outputs-resource? if(
                    pop-resource! turn-into-value!,
                    pop-value!
                )
                push-value!
            }
            { With ->
                resource-to-c99-repr pop-resource!
                push-resource!
            }
        },

    @tag +mirth:num-total-inputs 0= if(
        @tag +mirth:data pop-data! rdrop, # decref is unnecessary

        @tag +mirth:inputs >parts
        @tag +mirth:data pop-data! turn-into-resource!
        @tag Some rdip:+mirth:filter(only-tag? not) >tag
        c99-unpack-tuple!
    ))
    tag> drop
}

def +C99.tag-value-put [ +C99 |- Tag -- ] {
    dup +mirth:value-show put "LL /* " put +mirth(name >Str) put " */" put
}

def c99-pack-tuple! [ +C99Branch |- tag:Maybe(Tag) parts:List(StackTypePart) -- +C99Resource ] {
    @tag len @parts len + >tuplen
    @tuplen C99ReprType.TUP resource-expression!("tup_new(" put @tuplen >Str put ")" put) >+tup
    @+tup:resource-name >tup
    c99-line(@tup put "->size = " put @tuplen >Str put ";" put)
    tuplen> pred >i
    parts> reverse-for(
        match {
            { Cons -> type-to-c99-repr pop-value! consume-as-VAL }
            { With -> resource-to-c99-repr pop-resource! consume-as-VAL }
            { ConsLabel -> dip:type-to-c99-repr pop-value-label! consume-as-VAL }
            { WithLabel -> dip:resource-to-c99-repr pop-resource-label! consume-as-VAL }
        }
        c99-line(@tup put "->cells[" put @i >Str put "] = " put put ";" put)
        @i:pred
    )
    i> drop
    tag> for(c99-line(@tup put "->cells[0] = MKI64(" put tag-value-put ");" put))
    tup> drop
    +tup>
}

def c99-unpack-tuple! [ +C99Branch |- +C99Resource tag:Maybe(Tag) parts:List(StackTypePart) -- ] {
    @tag len @parts len + C99ReprType.TUP consume-as >tup
    tag> len >i
    parts> for(
        Str(@tup ; "->cells[" ; @i int; "]" ;)
        swap match {
            { Cons -> type-to-c99-repr dup push-value-expression!(v-macro(put)) }
            { With -> resource-to-c99-repr dup push-resource-expression!(v-macro(put)) }
            { ConsLabel -> dip(type-to-c99-repr dup value-expression!(v-macro(put))) push-value-label! }
            { WithLabel -> dip(resource-to-c99-repr dup resource-expression!(v-macro(put))) push-resource-label! }
        }
        @i:succ
    )
    c99-line("tup_decref_outer(" put tup> put "," put i> >Str put ");" put)
}

def c99-tag-label-index [ +C99 |- Tag Label -- Nat ] {
    >label sip(+mirth:inputs dup len) +mirth:only-tag? if(id, 1+) >i
    reverse-find(@i:pred label if?(@label =, False))
    label> drop2 i>
}

def c99-tag-get-label! [ +C99Branch |- TagField -- ] {
    /TagField
    type/resource> >fieldty
    @tag +mirth:semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag +mirth:outputs-resource? if(
                    # wrapper is resource
                    type-to-c99-repr pop-resource!
                    dup-resource-as-value!
                    rdip(push-resource!) push-value!,

                    # wrapper is value
                    drop
                )
            }

            { Right -> # field and wrapper are both resources
                drop
                C99ReprType.I64 push-resource-expression!("0" put)
            }
        },

        @tag +mirth:data pop-data! >+tuplevar
        @+tuplevar:rdup consume-as-TUP >tuplevar
        fieldty> match {
            { Left -> # field is value
                type-to-c99-repr >fieldrepr
                @fieldrepr value-expression!(
                    fieldrepr> v-macro(
                        @tuplevar put "->cells[" put
                        @tag @label c99-tag-label-index >Str put
                        "]" put
                    )
                ) dup-value! rdrop push-value!
                +tuplevar> +for(drop-value!, push-resource!)
            }
            { Right -> # field and tuple are resources
                resource-to-c99-repr >fieldrepr
                @fieldrepr push-resource-expression!(
                    fieldrepr> v-macro (
                        @tuplevar put "->cells[" put
                        @tag @label c99-tag-label-index >Str put
                        "]" put
                    )
                )
                +tuplevar> push-value/resource!
            }
        }
        tuplevar> drop
    )
    label> tag> drop2
}

def c99-tag-set-label! [ +C99Branch |- TagField -- ] {
    /TagField
    type/resource> >fieldty
    @tag +mirth:semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                @tag +mirth:data pop-data! +for(
                    drop drop-value!,

                    drop-resource-as-value!
                    type-to-c99-repr pop-value!
                    turn-into-resource! push-resource!
                )
            }
            { Right -> # field and wrapper are resource
                C99ReprType.I64 pop-resource! rdrop # vacant wrapper is unit
                drop
            }
        },

        @tag +mirth:data pop-data! >+tuplevar
        @fieldty match {
            { Left -> type-to-c99-repr pop-value! consume-as-VAL }
            { Right -> resource-to-c99-repr pop-resource! consume-as-VAL }
        } >fieldval
        +tuplevar> +for (
            # field and tuple are both values
            consume-as-VAL >tupleval
            C99ReprType.VAL push-value-expression!(
                "tup_replace(" put
                tupleval> put
                ", " put
                @tag @label c99-tag-label-index >Str put
                ", " put
                fieldval> put
                ")" put
            )
            fieldty> drop,

            # tuple is resource
            >+tuplevar
            @+tuplevar:rdup consume-as-TUP >tuplevar
            fieldty> match {
                { Left -> # field is value
                    type-to-c99-repr >fieldrepr
                    @fieldrepr needs-refcounting? then (
                        @fieldrepr dup value-expression! (
                            v-macro (
                                @tuplevar put
                                "->cells[" put
                                @tag @label c99-tag-label-index >Str put
                                "]" put
                            )
                        ) drop-value!
                    )
                    fieldrepr> drop
                }
                { Right -> # field is resource
                    drop
                }
            }
            c99-line(
                @tuplevar put
                "->cells[" put
                @tag @label c99-tag-label-index >Str put
                "] = " put
                fieldval> put
                ";" put
            )
            +tuplevar>
            push-resource!
            tuplevar> drop
        )
    )
    label> tag> drop2
}

def c99-external-blocks! [ +C99 |- ] {
    ExternalBlock.for(c99-external-block!)
}
def c99-external-block! [ +C99 |- ExternalBlock -- ] {
    +mirth:parts for(match(
        EBPCode -> put line,
        EBPDef -> c99-external-def!
    ))
}

def External.cname-type [ +Mirth |- External -- Str ArrowType ] {
    dup cname swap type
}

field(External.~c99-api, External, C99API)
def External.c99-api [ +C99 |- External -- C99API ] {
    dup ~c99-api memoize(dup +mirth:cname-type cname-type-to-c99-api) nip
}
def c99-external-call! [ +C99Branch |- List(Arg) External -- ] {
    +c99:c99-api c99-smart-call!
}

def c99-external-def! [ +C99 |- External -- ] {
    >ext
    @ext +mirth:ctype >cty

    @cty cod parts find(and(label? none?, ctype phantom? not)) >outty
    @outty if?(ctype, "void" CType.Void) cname put " " put
    @ext +mirth:symbol put

    " (" put
    @cty dom parts filter(ctype phantom? not)
    match(
        Nil -> "void" put,
        _ -> for(ctype cname put, ", " put)
    )
    ");" put line

    @ext c99-api c99-smart-def! (
        @cty dom parts
        dup len >arg-index
        reverse-for(
            dup c99-pop >expr
            dup ctype phantom? if(
                expr> drop,
                c99-line(
                    dup ctype cname put
                    " " put
                    dup c99-arg-name put
                    " = (" put
                    dup ctype cname put
                    ")(" put
                    expr> put
                    ");" put
                )
            )
            drop
            @arg-index:pred
        )

        c99-line(
            @outty for(ctype cname put " Y = " put)
            @ext +mirth:symbol put "(" put

            1u !arg-index
            @cty dom parts filter-some(
                dup ctype phantom? if(drop None, c99-arg-name Some)
                @arg-index:1+
            )
            for(put, ", " put)
            ");" put
        )

        @cty cod parts for(
            +mirth:sip(dup ctype phantom? if(drop "0", label? if?(name mangled, "Y")))
            c99-push
        )
    )

    arg-index> drop
    ext> cty> outty> drop3
}

def CTypeStackPart.c99-arg-name [ +C99 |- arg-index:Nat CTypeStackPart -- arg-index:Nat Str ] {
    label? if?(
        +mirth(name mangled),
        Str("X" ; @arg-index int;)
    )
}

def CType.>C99ReprType [ CType -- C99ReprType ] {
    { UInt  -> drop C99ReprType.U64 }
    { Int   -> drop C99ReprType.I64 }
    { F32   -> drop C99ReprType.F32 }
    { F64   -> drop C99ReprType.F64 }
    { Ptr   -> drop C99ReprType.PTR }
    { FnPtr -> drop C99ReprType.FNPTR }
    { Void  -> drop C99ReprType.Void }
}

def CTypeStackPart.c99-pop [ +C99Branch |- CTypeStackPart -- Str ] {
    { Cons -> >C99ReprType dup pop-value! consume-as }
    { With -> >C99ReprType dup pop-resource! turn-into-value! consume-as }
    { ConsLabel -> dip(>C99ReprType dup) pop-value-label! consume-as }
    { WithLabel -> dip(>C99ReprType dup) pop-resource-label! turn-into-value! consume-as }
}

def CTypeStackPart.c99-push [ +C99Branch |- Str CTypeStackPart -- ] {
    { Cons -> >C99ReprType dup push-value-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { With -> >C99ReprType dup push-resource-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { ConsLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { WithLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
}

def +C99.indent [ +C99 |- ] { depth repeat("\t" put) }
def +C99.c99-nest(f) [ +C99 |- (*a -- *b) *a -- *b ] { depth:succ f depth:pred }
def +C99.c99-line(f) [ +C99 |- (*a -- *b) *a -- *b ] {
    indent f line
}
def +C99.c99-line-if(f) [ +C99 |- (*a -- *b) *a Bool -- *b ] {
    put-enabled(tuck and)
    dip:c99-line(f)
    put-enabled!
}

def +C99Branch.c99-line(f) [ (+C99 |- *a -- *b) +C99Branch |- *a -- *b ] {
    reachable +c99:c99-line-if(f)
}
def +C99Branch.c99-line-if(f) [ (+C99 |- *a -- *b) +C99Branch |- *a Bool -- *b ] {
    reachable and +c99:c99-line-if(f)
}
def +C99Branch.c99-nest(f) [ +C99Branch |- (*a -- *b) *a -- *b ] {
    +c99:depth:succ f +c99:depth:pred
}

data C99APIArgSource {
    Value
    ValueLabel [ Label ]
    Resource
    ResourceLabel [ Label ]
}

data C99APIArgMode {
    In
    Out
    InOut
    Branch
}

def C99APIArgMode.mode-arg-prefix {
    { In     -> "in_"    }
    { Out    -> "out_"   }
    { InOut  -> "inout_" }
    { Branch -> "branch_"  }
}

struct C99APIArg {
    arg-mode: C99APIArgMode
    arg-source: C99APIArgSource
    arg-repr: C99ReprType
    arg-name: Str
}

def C99APIArg.is-physical? [ C99APIArg -- Bool ] {
    arg-repr is-physical?
}

def C99APIArg.is-physical-value? [ C99APIArg -- Bool ] {
    dup is-physical? if(
        arg-source match {
            { Value -> True }
            { ValueLabel -> drop False }
            { _ -> drop False }
        },
        drop False
    )
}

def C99APIArg.pop-consume! [ +C99Branch |- C99APIArg -- Str ] {
    sip(arg-repr dup) arg-source match {
        { Value -> pop-value! consume-as }
        { Resource -> pop-resource! turn-into-value! consume-as }
        { ValueLabel -> pop-value-label! consume-as }
        { ResourceLabel -> pop-resource-label! turn-into-value! consume-as }
    }
}

def C99APIArg.pop-consume-physical! [ +C99Branch |- C99APIArg -- Maybe(Str) ] {
    sip:pop-consume!
    is-physical? if(
        Some,
        drop None
    )
}

def C99APIArg.pop-to-reserved! [ +C99Branch |- C99APIArg -- ] {
    dup pop-consume-physical! if?(
        c99-line(swap arg-name put " = " put put ";" put),
        drop
    )
}

def C99APIArg.push-to! [ +C99Branch |- Str C99APIArg -- ] {
    sip:arg-repr arg-source match {
        { Value -> push-value-expression!(put) }
        { Resource -> push-resource-expression!(put) }
        { ValueLabel -> push-label-expression!(put) }
        { ResourceLabel -> push-label-expression!(put) }
    }
}

def C99APIArg.push-api-arg! [ +C99Branch |- C99APIArg -- ] {
    /C99APIArg
    arg-name> >value-name
    arg-repr> >value-repr
    arg-mode> drop
    +C99Value
    arg-source> match {
        { Value -> push-value! }
        { ValueLabel -> push-value-label! }
        { Resource -> turn-into-resource! push-resource! }
        { ResourceLabel -> turn-into-resource! push-resource-label! }
    }
}

struct C99API {
    cname: Str
    type: ArrowType
    in-params: List(C99APIArg)
    out-params-1: List(C99APIArg)
    return-param: Maybe(C99APIArg)
    out-params-2: List(C99APIArg)
    must-flush: Bool
    doesnt-return: Bool
}

def name-arg-prefix [ +Mirth |- Name -- Str ] {
    mangled "_" cat
}

def type-arg-prefix [ +Mirth |- Type -- Str ] {
    { Meta -> expand-if(type-arg-prefix, drop "") }
    { Var -> name name-arg-prefix }
    { Table -> name name-arg-prefix }
    { Data -> name name-arg-prefix }
    { DataPartial -> .data name name-arg-prefix }
    { App -> drop type-arg-prefix }
    { Mut -> dip("Mut") type-arg-prefix cat }
    { Prim -> match {
        { KIND -> "KIND_" }
        { TYPE -> "TYPE_" }
        { STACK -> "STACK_" }
        { RESOURCE -> "RESOURCE_" }
        { Bool -> "Bool_" }
        { Int -> "Int_" }
        { U8  -> "U8_" }
        { U16 -> "U16_" }
        { U32 -> "U32_" }
        { U64 -> "U64_" }
        { I8  -> "I8_" }
        { I16 -> "I16_" }
        { I32 -> "I32_" }
        { I64 -> "I64_" }
        { F32 -> "F32_" }
        { F64 -> "F64_" }
        { Ptr -> "Ptr_" }
        { Str -> "Str_" }
        { World -> "World_" }
    } }
    { _ -> drop "_" }
}

def fresh-arg-name! [ +C99 arg-mode:C99APIArgMode arg-repr:C99ReprType |- Type -- Str ] {
    @arg-repr is-physical? if(
        dip(@arg-mode mode-arg-prefix) +mirth:type-arg-prefix cat fresh-name-on!,
        drop "0"
    )
}

def cons-fresh-arg! [ +C99 arg-mode:C99APIArgMode |- List(C99APIArg) Type C99APIArgSource -- List(C99APIArg) ] {
    >arg-source
    dup +mirth:c99-repr >arg-repr
    fresh-arg-name! >arg-name
    @arg-mode >arg-mode
    C99APIArg swap cons
}

def +C99.stack-type-to-c99-api-params-aux [ +C99 arg-mode:C99APIArgMode |- StackType -- must-flush:Bool List(C99APIArg) ] {
    { Unit -> False >must-flush List.Nil }
    { Error -> True >must-flush List.Nil }
    { Ignore -> True >must-flush List.Nil }
    { Meta ->
        +mirth rswap expand-if(
            rswap +mirth! >StackType stack-type-to-c99-api-params-aux,
            rswap +mirth! drop True >must-flush List.Nil
        )
    }
    { Var -> drop True >must-flush List.Nil }
    { Cons -> C99APIArgSource.Value dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { With -> C99APIArgSource.Resource dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { ConsLabel -> C99APIArgSource.ValueLabel dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { WithLabel -> C99APIArgSource.ResourceLabel dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
}

def +C99.stack-type-to-c99-api-params [ +C99 |- StackType C99APIArgMode -- must-flush:Bool List(C99APIArg) ] {
    >arg-mode
    +C99.stack-type-to-c99-api-params-aux reverse
    arg-mode> drop
}

def +C99.cname-type-to-c99-api [ +C99 |- Str ArrowType -- C99API ] {
    >type >cname
    1u with-fresh-counter (
        @type dom C99APIArgMode.In  stack-type-to-c99-api-params >in-params
        @type cod C99APIArgMode.Out stack-type-to-c99-api-params
        split-at(is-physical-value?) uncons
        >out-params-2 >return-param >out-params-1
    ) drop
    must-flush> must-flush> or >must-flush
    @type cod +mirth:linear-base-var? if?(
        @type dom +mirth:linear-base-var? if?(
            <>,
            drop False
        ),
        False
    ) >doesnt-return
    @doesnt-return not @must-flush:and
    C99API
}

def C99APIArg.reserve-as-new-value! [ +C99Branch |- C99APIArg -- C99APIArg ] {
    dup is-physical? if(
        dup arg-repr new-value!
        consume swap arg-name!,
        "0" swap arg-name!
    )
}

def C99APIArg.reserve-as-is! [ +C99Branch |- C99APIArg -- ] {
    dup is-physical? if(
        >arg
        c99-line(
            @arg arg-repr underlying-c99-type put " " put
            @arg arg-name put ";" put
        )
        arg> drop,
        drop
    )
}

def C99APIArg.reserve-new-expression! [ +C99Branch |- Str C99APIArg -- C99APIArg ] {
    >arg
    +c99:fresh-name! @arg:arg-name!
    c99-line (
        @arg arg-repr underlying-c99-type put " " put
        @arg arg-name put " = " put
        put ";" put
    )
    arg>
}

def c99-smart-call! [ +C99Branch |- List(Arg) C99API -- ] {
    >api
    c99-args-push!
    @api in-params reverse map(pop-consume-physical!) reverse >popped-inputs
    @api must-flush then(flush-cache!)
    @api out-params-1 map(reserve-as-new-value!) >reserved-outputs-1
    @api out-params-2 map(reserve-as-new-value!) >reserved-outputs-2
    Str(
        @api cname ; "(" ;
        "" >sep
        popped-inputs> for:for(sep> ; ", " >sep ;)
        @reserved-outputs-1 @reserved-outputs-2 cat for(
            dup is-physical?
            if(sep> ; ", " >sep "&" ; arg-name ;, drop)
        )
        sep> drop
        ")" ;
    )
    @api return-param if?(
        @api doesnt-return if(
            swap c99-line("(void)" put put ";" put) Some,
            reserve-new-expression! Some
        ),
        c99-line(put ";" put) None
    ) >reserved-return
    api> doesnt-return not reachable:and
    reserved-outputs-1> for(push-api-arg!)
    reserved-return>    for(push-api-arg!)
    reserved-outputs-2> for(push-api-arg!)
}

def +C99.smart-sig-put [ +C99 |- C99API -- ] {
    >api
    "static " put
    @api return-param if?(
        arg-repr underlying-c99-type put,
        "void" put
    )
    " " put
    @api cname put
    " (" put
    "" >sep
    @api in-params filter(is-physical?) for(
        sep> put ", " >sep
        dup arg-repr underlying-c99-type put
        " " put arg-name put
    )
    @api out-params-1 @api out-params-2 cat filter(is-physical?) for(
        sep> put ", " >sep
        dup arg-repr underlying-c99-type put
        " *" put arg-name put
    )
    sep> empty? then("void" put)
    ")" put
    api> drop
}

def c99-smart-sig! [ +C99 |- C99API -- ] {
    c99-line(smart-sig-put ";" put)
}

def c99-api-enter! [ +C99 C99API -- +C99Branch ] {
    >api
    @api in-params len
    @api out-params-1 len +
    @api out-params-2 len +
    @api return-param then(1+)
    1+ fresh-counter!
    True >reachable
    List.Nil >env
    start-branch!
    @api in-params for(push-api-arg!)
    api> drop
}

def c99-api-exit! [ +C99Branch C99API -- +C99 ] {
    >api
    @api out-params-2 reverse-for(
        dup pop-consume-physical! if?(
            swap arg-name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    @api return-param map(pop-consume!)
    @api out-params-1 reverse-for(
        dup pop-consume-physical! if?(
            swap arg-name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    end-branch!
    reachable> if(
        for(c99-line("return " put put ";" put)),
        drop @api return-param for(
            arg-repr dummy-value
            c99-line("return " put put "; /* unreachable */" put)
        )
    )
    api> drop
    env> drop
}

def c99-smart-def! (f) [ (+C99Branch |- *a -- *b) +C99 |- *a C99API -- *b ] {
    c99-line(dup smart-sig-put " {" put)
    c99-nest(
        dup dip(c99-api-enter! f)
        c99-api-exit!
    )
    c99-line("}" put)
}

def c99-codip-arrow! [ +C99Branch |- Arrow -- ] {
    dup +mirth:type /ArrowType
    cod> +mirth:split-parts >cod-parts >cod-base
    dom> +mirth:split-parts >dom-parts >dom-base
    cod-base> +mirth:unit? dom-base> +mirth:unit? and if(
        dom-parts> dip-parts( +stack(+C99Stack.+Nil) )
        c99-arrow!
        cod-parts> dip-parts(
            +stack(rdrop)
        ),

        cod-parts> dom-parts> drop2
        c99-arrow!
    )
}

def +C99Branch.dip-parts(f) [ +C99Branch |- (*a -- *b) *a List(StackTypePart) -- *b ] {
    pop-stack!
    rdip (f)
    push-stack!
}

||| Pop stack parts (right-to-left) into a separate stack cache.
def +C99Branch.pop-stack! [ +C99Branch |- List(StackTypePart) -- +C99Stack ] {
    +C99Stack.+Nil reverse-for(pop-stack-part!)
}

||| Pop a part from branch to separate stack.
def +C99Stack.pop-stack-part! [ +C99Branch +C99Stack |- StackTypePart -- ] {
    { Cons -> rdip(type-to-c99-repr pop-value!) rswap +C99Stack.+Cons }
    { With -> rdip(resource-to-c99-repr pop-resource!) rswap +C99Stack.+With }
    { ConsLabel -> rdip(dip:type-to-c99-repr tuck pop-value-label!) rswap +C99Stack.+ConsLabel }
    { WithLabel -> rdip(dip:resource-to-c99-repr tuck pop-resource-label!) rswap +C99Stack.+WithLabel }
}

def +C99Stack.reverse-cat! [ +C99Stack +C99Stack -- +C99Stack ] {
    while ( match {
        { +Nil -> +C99Stack.+Nil False }
        { +Cons -> rswap rdip:+C99Stack.+Cons True }
        { +With -> rswap rdip:+C99Stack.+With True }
        { +ConsLabel -> rswap rdip:+C99Stack.+ConsLabel True }
        { +WithLabel -> rswap rdip:+C99Stack.+WithLabel True }
    } ) rdrop
}

||| Push stack onto branch, right to left.
def +C99Stack.push-stack! [ +C99Branch |- +C99Stack -- ] {
    rswap +stack(rswap reverse-cat!)
}

def c99-arrow! [ +C99Branch |- Arrow -- ] { atoms for(c99-atom!) }
def c99-atom! [ +C99Branch |- Atom -- ] {
    +c99:options emit-debug-info and(dup op +mirth:show-in-stack-trace?) then(
        +c99:c99-line("WORD_ATOM(" put
            dup token +mirth:row >Int >Str put ", " put
            dup token +mirth:col >Int >Str put ", " put
            dup token +mirth(name? if?(>Str, "")) put-cstr
            ");" put
        )
    )
    dup op
    c99-atom-op!
}

def Op.show-in-stack-trace? [ +Mirth |- Op -- Bool ] {
    { Push -> drop False }
    { Word -> prefer-inline? not }
    { External -> drop True }
    { Buffer -> drop False }
    { Field -> drop False }
    { Tag -> drop False }
    { Prim -> drop True }
    { Match -> drop False }
    { Lambda -> drop False }
    { Var -> drop False }
    { BlockPush -> drop False }
    { BlockRun -> drop False }
    { LabelPush -> drop False }
    { LabelPop -> drop False }
    { LabelPushR -> drop False }
    { LabelPopR -> drop False }
    { DataGetEnumValue -> drop False }
    { DataFromEnumValue -> drop False }
    { DataGetLabel -> drop False }
    { DataSetLabel -> drop False }
    { TableToIndex -> drop False }
    { TableFromIndex -> drop False }
}

def c99-atom-op! [ +C99Branch |- Atom Op -- ] {
    { Push -> nip c99-push-value! }
    { Word          -> dip:args c99-word! }
    { External      -> dip:args c99-external-call! }
    { Buffer        -> nip c99-buffer-call! }
    { Field         -> nip c99-field-call! }
    { Tag           -> dip:args c99-tag-call! }
    { Prim          -> c99-prim! }
    { Match         -> nip c99-match! }
    { Lambda        -> nip c99-lambda! }
    { Var           -> nip c99-var! }
    { BlockPush     -> nip c99-block-push! }
    { BlockRun      -> nip c99-block-run! }
    { LabelPush     -> c99-label-push! }
    { LabelPop      -> c99-label-pop! }
    { LabelPushR    -> c99-label-push-r! }
    { LabelPopR     -> c99-label-pop-r! }
    { DataGetEnumValue -> nip c99-get-enum-value! }
    { DataFromEnumValue -> nip c99-from-enum-value! }
    { DataGetLabel  -> c99-tag-get-label! drop }
    { DataSetLabel  -> c99-tag-set-label! drop }
    { TableToIndex -> drop2 }
    { TableFromIndex -> drop2 }
}

def c99-push-value! [ +C99Branch |- PushValue -- ] {
    { Str -> c99-str! }
    { Int -> c99-int! }
    { U8  -> C99ReprType.U8  push-value-expression!(>Nat >Str put) }
    { U16 -> C99ReprType.U16 push-value-expression!(>Nat >Str put) }
    { U32 -> C99ReprType.U32 push-value-expression!(>Nat >Str put) }
    { U64 -> C99ReprType.U64 push-value-expression!(>Nat >Str put "ULL" put) }
    { I8  -> C99ReprType.I8  push-value-expression!(>Int >Str put) }
    { I16 -> C99ReprType.I16 push-value-expression!(>Int >Str put) }
    { I32 -> C99ReprType.I32 push-value-expression!(
        dup I32.Min = if(drop "INT32_MIN" put, >Int >Str put)) }
    { I64 -> C99ReprType.I64 push-value-expression!(
        dup I64.Min = if(drop "INT64_MIN" put, >Int >Str put "LL" put)) }
    { F32 -> C99ReprType.F32 push-value-expression!(>Str put) }
    { F64 -> C99ReprType.F64 push-value-expression!(>Str put) }
}

def c99-get-enum-value! [ +C99Branch |- Data -- ] {
    >data
    @data +mirth:is-enum? else(
        @data Type.Data type-to-c99-repr pop-value! >+scrutinee
        @data +mirth:is-unit? if?(
            C99ReprType.I64 push-value-expression!(+mirth:value-show put "LL" put),

        @data +mirth:semi-transparent? if?(
            C99ReprType.I64 push-value-expression!(tag +mirth:value-show put "LL" put),
            C99ReprType.I64 push-value-expression!(
                "get_data_tag(" put
                @+scrutinee:rdup consume-as-VAL put
                ")" put
            )
        ))
        +scrutinee> drop-value!
    )
    data> drop
}

def c99-from-enum-value! [ +C99Branch |- Data -- ] {
    +mirth:is-enum? else("_.from-enum-value-unsafe on non-enum" +mirth:fatal-error!)
}

def c99-word! [ +C99Branch |- List(Arg) Word -- ] {
    dup +mirth:prefer-inline? if(
        dip:c99-args-push!
        +mirth:arrow c99-codip-arrow!,
        +c99:c99-api c99-smart-call!
    )
}

field(Tag.~value-show, Tag, Str)
def Tag.value-show [ +Mirth |- Tag -- Str ] { dup ~value-show memoize(dup value >Str) nip }

def c99-tag-call! [ +C99Branch |- List(Arg) Tag -- ] {
    dup +mirth:prefer-inline? if(
        nip c99-tag-body!,
        +c99:word-c99-api c99-smart-call!
    )
}

def c99-reverse-tag! [ +C99Branch |- Tag -- ] {
    dup +mirth:prefer-inline? if(
        c99-reverse-tag-body!,
        dip:List.Nil +c99:pat-c99-api c99-smart-call!
    )
}

def c99-label-defs! [ +C99 |- ] { Label.for( dup +needs(needed?) if(c99-label-def!, drop) ) }
def c99-label-def! [ +C99 |- Label -- ] { "static STACK lbl_" put +mirth(name mangled) put " = {0};" put line }

def push-value-label-direct! [ +C99Branch |- Label +C99Value -- ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put +mirth(name mangled) put ", " put put ");" put)
}
def push-value-label! [ +C99Branch |- Label +C99Value -- ] {
    rswap +stack(rswap +C99Stack.+ConsLabel)
}
def push-resource-label-direct! [ +C99Branch |- Label +C99Resource -- ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put +mirth(name mangled) put ", " put put ");" put)
}
def push-resource-label! [ +C99Branch |- Label +C99Resource -- ] {
    rswap +stack(rswap +C99Stack.+WithLabel)
}

def pop-value-label-direct! [ +C99Branch |- C99ReprType Label -- +C99Value ] {
    swap dup value-expression!(
        v-macro("lpop(&lbl_" put +mirth(name mangled) put ")" put)
    )
}

def pop-resource-label-direct! [ +C99Branch |- C99ReprType Label -- +C99Resource ] {
    swap dup resource-expression!(
        v-macro("lpop(&lbl_" put +mirth(name mangled) put ")" put)
    )
}

def c99-label-push! [ +C99Branch |- Atom Label -- ] {
    swap dom pop-value-from-stack-type! drop
    push-value-label!
}
def c99-label-push-r! [ +C99Branch |- Atom Label -- ] {
    swap dom pop-resource-from-stack-type! drop
    push-resource-label!
}
def c99-label-pop! [ +C99Branch |- Atom Label -- ] {
    swap dom pop-value-label-from-stack-type! drop
    push-value!
}
def c99-label-pop-r! [ +C99Branch |- Atom Label -- ] {
    swap dom pop-resource-label-from-stack-type! drop
    push-resource!
}

def c99-f64! [ +C99Branch |- F64 -- ] {
    C99ReprType.F64 push-value-expression!(>Str put)
}

def Int.I63Min [ Int ] { -0x4000_0000_0000_0000 }
def Int.I63Max [ Int ] {  0x3FFF_FFFF_FFFF_FFFF }
def Int.in-i63-range? [ Int -- Bool ] { Int.I63Min Int.I63Max in-range }
def Int.c99-radixes [ Int -- List(U32) ] {
    List(
        while(
            0x1_0000_0000 divmod >U32-wrap dup ;
            0x8000_0000u32 and 0= if(dup 0 <>, dup -1 <>)
        )
        drop
    )
}

def c99-int! [ +C99Branch |- Int -- ] {
    dup in-i63-range? if(
        C99ReprType.Int push-value-expression!("WRAP_I63(" put >Str put "LL)" put),

        c99-radixes >rad
        @rad len >Str >size
        +c99:fresh-name! >name
        c99-line(
            "static struct BIG_S(" put @size put ") " put @name put
            " = { .refs=100, .cap=" put @size put ", .size=" put size> put
            ", .radix={" put rad> for( str:hex; put "," put ) "} };" put
        )
        c99-line(@name put ".refs++;" put)

        C99ReprType.Int >value-repr
        Str("WRAP_BIG(&" ; name> ; ")";) >value-name
        +C99Value push-value!
    )
}

def c99-str! [ +C99Branch |- Str -- ] {
    C99ReprType.STR new-value! >+str
    dup num-bytes 4090 bytes > if(
        c99-line("STRLIT(" put @+str:rdup consume put "," put)
        c99-nest(
            c99-line(dup put-cstr-long "," put)
            c99-line(dup num-bytes >Str put)
        )
        c99-line(");" put),

        c99-line("STRLIT(" put
            @+str:rdup consume put ", " put
            dup put-cstr ", " put
            dup num-bytes >Str put ");" put)
    ) drop

    +str> push-value!
}

def +C99.put-cstr-long [ +C99 |- Str -- ] {
    False >avoid-hexdigit
    Byte.BQUOTE put-byte
    Byte.BNUL swap bytes-for(
        swap Byte.BLF = then(
            Byte.BQUOTE put-byte
            line indent
            Byte.BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    Byte.BQUOTE put-byte
    avoid-hexdigit> drop2
}

def +C99.put-cstr [ +C99 |- Str -- ] {
    False >avoid-hexdigit
    Byte.BQUOTE put-byte bytes-for(c99-string-byte!) Byte.BQUOTE put-byte
    avoid-hexdigit> drop
}

def c99-string-byte! [ +C99 avoid-hexdigit:Bool |- Byte -- ] {
    { B'\' ->   "\\\\" put False !avoid-hexdigit }
    { BQUOTE -> "\\\"" put False !avoid-hexdigit }
    { BHT ->    "\\t"  put False !avoid-hexdigit }
    { BLF ->    "\\n"  put False !avoid-hexdigit }
    { BCR ->    "\\r"  put False !avoid-hexdigit }
    { _ ->
        dup Byte.BSPACE Byte.B'~' in-range
        and(dup is-hexdigit @avoid-hexdigit and not) if(
            put-byte
            False !avoid-hexdigit,
            "\\x" put to-hexdigits dip(put-byte) put-byte
            True !avoid-hexdigit
        )
    }
}

data C99ReprType {
    0 Void

    VAL
    STR
    TUP [ Nat ]
    Int

    I64 I32 I16 I8
    U64 U32 U16 U8
    F64 F32
    Bool
    PTR
    FNPTR
}

def C99ReprType.= [ C99ReprType C99ReprType -- Bool ] {
    { TUP -> swap match { TUP -> =, _ -> drop2 False } }
    { _ -> on2:enum-value = }
}

inline (
    def C99ReprType.is-unit? [ C99ReprType -- Bool ] { enum-value 0= }
    def C99ReprType.is-physical? [ C99ReprType -- Bool ] { is-unit? not }
)

def C99ReprType.needs-refcounting? [ C99ReprType -- Bool ] {
    { VAL -> True }
    { STR -> True }
    { TUP -> drop True }
    { Int -> True }

    { Void -> False }
    { I64 -> False } { I32 -> False } { I16 -> False } { I8 -> False }
    { U64 -> False } { U32 -> False } { U16 -> False } { U8 -> False }
    { F64 -> False } { F32 -> False }
    { Bool -> False }
    { PTR -> False }
    { FNPTR -> False }
}

def C99ReprType.is-int-like? [ C99ReprType -- Bool ] {
    { I64 -> True } { I32 -> True } { I16 -> True } { I8 -> True }
    { U64 -> True } { U32 -> True } { U16 -> True } { U8 -> True }
    { Bool -> True }
    { _ -> drop False }
}

def C99ReprType.is-float-like? [ C99ReprType -- Bool ] {
    { F64 -> True } { F32 -> True }
    { _ -> drop False }
}

def C99ReprType.dummy-value [ C99ReprType -- Str ] {
    { VAL   -> "(VAL){0}"    }
    { STR   -> "NULL"        }
    { Void  -> "0"           }
    { Int   -> "WRAP_I63(0)" }
    { I64   -> "0"           }
    { I32   -> "0"           }
    { I16   -> "0"           }
    { I8    -> "0"           }
    { U64   -> "0"           }
    { U32   -> "0"           }
    { U16   -> "0"           }
    { U8    -> "0"           }
    { F64   -> "0.0"         }
    { F32   -> "0.0"         }
    { Bool  -> "0"           }
    { PTR   -> "NULL"        }
    { FNPTR -> "NULL"        }
    { TUP   -> drop "NULL"   }
}

def C99ReprType.underlying-c99-type [ C99ReprType -- Str ] {
    { VAL   -> "VAL"      }
    { STR   -> "STR*"     }
    { Int   -> "INT"      }
    { Void  -> "int64_t"  }
    { I64   -> "int64_t"  }
    { I32   -> "int32_t"  }
    { I16   -> "int16_t"  }
    { I8    -> "int8_t"   }
    { U64   -> "uint64_t" }
    { U32   -> "uint32_t" }
    { U16   -> "uint16_t" }
    { U8    -> "uint8_t"  }
    { F64   -> "double"   }
    { F32   -> "float"    }
    { Bool  -> "bool"     }
    { PTR   -> "void*"    }
    { FNPTR -> "FNPTR"    }
    { TUP   -> drop "TUP*"  }
}

def C99ReprType.v-macro(f) [ +C99 |- (*a -- *b) *a C99ReprType -- *b ] {
    v-macro-prefix-suffix
    dip(put f) put
}

def C99ReprType.v-macro-prefix-suffix [ C99ReprType -- Str Str ] {
    { VAL   -> "" "" }
    { STR   -> "value_str(" ")" }
    { Int   -> "value_int(" ")" }
    { Void  -> "(" ", 0)" }
    { I64   -> "value_i64(" ")" }
    { I32   -> "value_i32(" ")" }
    { I16   -> "value_i16(" ")" }
    { I8    -> "value_i8(" ")" }
    { U64   -> "value_u64(" ")" }
    { U32   -> "value_u32(" ")" }
    { U16   -> "value_u16(" ")" }
    { U8    -> "value_u8(" ")" }
    { F64   -> "value_f64(" ")" }
    { F32   -> "value_f32(" ")" }
    { Bool  -> "value_bool(" ")" }
    { PTR   -> "value_ptr(" ")" }
    { FNPTR -> "value_fnptr(" ")" }
    { TUP   -> "value_tup(" swap Str(", "; int; ")";) }
}

def C99ReprType.mk-macro [ Str C99ReprType -- Str ] {
    { VAL   -> id }
    { STR   -> Str( "MKSTR(" ; ; ")" ; ) }
    { Int   -> Str( "MKINT(" ; ; ")" ; ) }
    { Void  -> Str( "MKI64(" ; ; ")" ; ) }
    { I64   -> Str( "MKI64(" ; ; ")" ; ) }
    { I32   -> Str( "MKI32(" ; ; ")" ; ) }
    { I16   -> Str( "MKI16(" ; ; ")" ; ) }
    { I8    -> Str( "MKI8("  ; ; ")" ; ) }
    { U64   -> Str( "MKU64(" ; ; ")" ; ) }
    { U32   -> Str( "MKU32(" ; ; ")" ; ) }
    { U16   -> Str( "MKU16(" ; ; ")" ; ) }
    { U8    -> Str( "MKU8(" ; ; ")" ; ) }
    { F64   -> Str( "MKF64(" ; ; ")" ; ) }
    { F32   -> Str( "MKF32(" ; ; ")" ; ) }
    { Bool  -> Str( "MKBOOL(" ; ; ")" ; ) }
    { PTR   -> Str( "MKPTR(" ; ; ")" ; ) }
    { FNPTR -> Str( "MKFNPTR(" ; ; ")" ; ) }
    { TUP   -> swap Str( "MKTUP(" ; ; ", " ; int; ")" ; ) }
}

def Resource.c99-repr [ +Mirth |- Resource -- C99ReprType ] {
    >Type c99-repr
}

def Type.c99-repr [ +Mirth |- Type -- C99ReprType ] {
    { Error -> C99ReprType.VAL }
    { Ignore -> C99ReprType.VAL }
    { Prim -> c99-repr }
    { Meta -> expand-if(c99-repr, drop C99ReprType.VAL) }
    { Hole -> drop C99ReprType.VAL }
    { Var -> drop C99ReprType.VAL }
    { Table -> drop C99ReprType.U64 }
    { Data -> c99-repr }
    { DataPartial -> .data c99-repr }
    { Arrow -> drop C99ReprType.VAL }
    { Stack -> tuple-c99-repr }
    { App -> drop c99-repr }
    { Mut -> drop C99ReprType.PTR }
    { Value -> drop C99ReprType.VAL }
}

def StackType.tuple-c99-repr [ +Mirth |- StackType -- C99ReprType ] {
    split-parts swap match {
        { Unit -> len dup 0= if (drop C99ReprType.Void, C99ReprType.TUP) }
        { _ -> drop2 C99ReprType.VAL }
    }
}

def PrimType.c99-repr [ PrimType -- C99ReprType ] {
    { KIND -> C99ReprType.VAL }
    { TYPE -> C99ReprType.VAL }
    { STACK -> C99ReprType.VAL }
    { RESOURCE -> C99ReprType.VAL }
    { Bool -> C99ReprType.Bool }
    { Int -> C99ReprType.Int }
    { U8  -> C99ReprType.U8  }
    { U16 -> C99ReprType.U16 }
    { U32 -> C99ReprType.U32 }
    { U64 -> C99ReprType.U64 }
    { I8  -> C99ReprType.I8  }
    { I16 -> C99ReprType.I16 }
    { I32 -> C99ReprType.I32 }
    { I64 -> C99ReprType.I64 }
    { F32 -> C99ReprType.F32 }
    { F64 -> C99ReprType.F64 }
    { Str -> C99ReprType.STR }
    { Ptr -> C99ReprType.PTR }
    { World -> C99ReprType.Void }
}

def Data.c99-repr [ +Mirth |- Data -- C99ReprType ] {
    >dat
    @dat is-unit? if(C99ReprType.Void,
    @dat is-enum? if(C99ReprType.I64,
    @dat semi-transparent? if?(
        input type/resource either(c99-repr, c99-repr),
    @dat single-tag? if?(
        inputs len C99ReprType.TUP,
        C99ReprType.VAL
    ))))
    dat> drop
}

struct +C99Value {
    value-repr: C99ReprType
    value-name: Str
}

def +C99Value.rdup [ +C99Value |- +C99Value ] {
    value-repr >value-repr
    value-name >value-name
    +C99Value
}

def +C99Value.rdrop [ +C99Value -- ] {
    /+C99Value
    value-repr> drop
    value-name> drop
}

def C99ReprType.new-value! [ +C99Branch |- C99ReprType -- +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put ";" put)
    +C99Value
}

def C99ReprType.pop-value-direct! [ +C99Branch |- C99ReprType -- +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put " = " put
             @value-repr v-macro ( "pop_value()" put ) ";" put)
    +C99Value
}

||| Push a value with a certain repr type on the stack.
||| `f` must emit the C99 expression that calculates the value,
||| which must be of the underlying C99 repr type.
def C99ReprType.push-value-expression!(f) [ (+C99 |- *a -- *b) +C99Branch |- *a C99ReprType -- *b ] {
    value-expression!(f) push-value!
}

def C99ReprType.push-resource-expression!(f) [ (+C99 |- *a -- *b) +C99Branch |- *a C99ReprType -- *b ] {
    resource-expression!(f) push-resource!
}

def push-label-expression!(f) [ (+C99 |- *a -- *b) +C99Branch |- *a C99ReprType Label -- *b ] {
    dip:value-expression!(f)
    dup rdip:+mirth:is-resource-label? if(
        turn-into-resource! push-resource-label!,
        push-value-label!
    )
}

def C99ReprType.value-expression!(f) [ (+C99 |- *a -- *b) +C99Branch |- *a C99ReprType -- *b +C99Value ] {
    dup >value-repr is-physical? dup
    if(+c99:fresh-name!, "0") >value-name
    c99-line-if(
        @value-repr underlying-c99-type put " " put
        @value-name put " = " put
        +C99Value rdip:f rswap ";" put
    ) rswap
}

def C99ReprType.resource-expression!(f) [ (+C99 |- *a -- *b) +C99Branch |- *a C99ReprType -- *b +C99Resource ] {
    dup >resource-repr is-physical? dup
    if(+c99:fresh-name!, "0") >resource-name
    c99-line-if(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        +C99Resource rdip:f rswap ";" put
    ) rswap
}

def +C99Value.push-value-direct! [ +C99Branch |- +C99Value -- ] {
    consume-as-VAL
    c99-line("push_value(" put put ");" put)
}

def +C99Value.consume [ +C99Value -- Str ] {
    /+C99Value value-repr> drop value-name>
}

def +C99Value.consume-as-VAL [ +C99Value -- Str ] {
    /+C99Value value-name> value-repr> mk-macro
}

def +C99Value.consume-as-TUP [ +C99Value -- Str ] {
    turn-into-resource! consume-as-TUP
}

def +C99Value.consume-as [ C99ReprType +C99Value -- Str ] {
    { VAL -> consume-as-VAL }
    { Void -> rdrop "0" }
    { _ ->
        /+C99Value
        @value-repr match {
            { VAL -> Str( v-macro-prefix-suffix dip(; value-name> ;) ; ) }
            { _ ->
                over = if(
                    drop value-name>,
                    dup is-int-like? @value-repr is-int-like? and if(
                        Str( "((" ; underlying-c99-type ; ")" ; value-name> ; ")" ; ),
                        Str( "(\n#error \"attempted to cast " ; value-name> ; " to incompatible C99 repr type " ;
                            underlying-c99-type ; "\"\n" ; )
                    )
                )
            }
        }
        value-repr> drop
    }
}

def +C99Value.drop-value! [ +C99Branch |- +C99Value -- ] {
    value-repr needs-refcounting? if(
        consume-as-VAL +c99:c99-line("decref(" put put ");" put),
        rdrop
    )
}

def +C99Value.dup-value! [ +C99Branch +C99Value |- +C99Value ] {
    value-repr needs-refcounting? then(
        rdup consume-as-VAL rdip:+c99:c99-line("incref(" put put ");" put)
    )
    rdup
}

def +C99Value.peek-data-tag [ +C99Value |- Str ] {
    turn-into-resource! peek-data-tag turn-into-value!
}

struct +C99Resource {
    resource-repr: C99ReprType
    resource-name: Str
}

def +C99Resource.rdup [ +C99Resource |- +C99Resource ] {
    resource-repr >resource-repr
    resource-name >resource-name
    +C99Resource
}

def +C99Resource.rdrop [ +C99Resource -- ] {
    consume drop
}

def +C99Value.turn-into-resource! [ +C99Value -- +C99Resource ] {
    /+C99Value
    value-repr> >resource-repr
    value-name> >resource-name
    +C99Resource
}

def +C99Resource.turn-into-value! [ +C99Resource -- +C99Value ] {
    /+C99Resource
    resource-repr> >value-repr
    resource-name> >value-name
    +C99Value
}

def +C99Resource.drop-resource-as-value! [ +C99Branch |- +C99Resource -- ] {
    turn-into-value! drop-value!
}

def +C99Resource.dup-resource-as-value! [ +C99Branch +C99Resource |- +C99Value ] {
    rdup turn-into-value! rswap rdip(dup-value! rdrop) rswap
}

def +C99Resource.consume [ +C99Resource -- Str ] {
    /+C99Resource
    resource-repr> drop
    resource-name>
}

def +C99Resource.consume-as [ C99ReprType +C99Resource -- Str ] {
    turn-into-value! consume-as
}

def +C99Resource.consume-as-VAL [ +C99Resource -- Str ] {
    /+C99Resource resource-name> resource-repr> mk-macro
}

def +C99Resource.consume-as-TUP [ +C99Resource -- Str ] {
    /+C99Resource resource-repr> match {
        { VAL -> Str( "VTUP(" ; resource-name> ; ")" ; ) }
        { TUP -> drop resource-name> }
        { _ -> drop "c99: tried to consume non-tuple as tuple" panic! }
    }
}

def +C99Branch.pop-resource-direct! [ +C99Branch |- C99ReprType -- +C99Resource ] {
    >resource-repr
    +c99:fresh-resource-name! >resource-name
    c99-line(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        @resource-repr v-macro( "pop_resource()" put )
        ";" put
    )
    +C99Resource
}

def +C99Resource.push-resource-direct! [ +C99Branch |- +C99Resource -- ] {
    consume-as-VAL
    c99-line("push_resource(" put put ");" put)
}

def +C99Resource.peek-data-tag [ +C99Resource |- Str ] {
    resource-repr is-int-like? if(
        resource-name,
        rdup consume-as-VAL Str("get_data_tag(" ; ; ")";)
    )
}

def +C99Value.>Value/Resource { +Left +C99Value/Resource }
def +C99Resource.>Value/Resource { +Right +C99Value/Resource }
struct +C99Value/Resource {
    +Either(+C99Value, +C99Resource)
    --
    def +Left [ +C99Value -- +C99Value/Resource ] { +Either.+Left +C99Value/Resource }
    def +Right [ +C99Resource -- +C99Value/Resource ] { +Either.+Right +C99Value/Resource }
    def +for(f,g) { +C99Value/Resource -> +for(f,g) }
    def +map(f,g) { +C99Value/Resource -> +map(f,g) +C99Value/Resource }
    def rdup { +C99Value/Resource -> rdup +C99Value/Resource rdip:+C99Value/Resource }
    def rdrop { +C99Value/Resource -> rdrop }

    def push-value/resource! { +for(push-value!, push-resource!) }
    def peek-data-tag { +map(peek-data-tag, peek-data-tag) }
    def consume-as-VAL { +for(consume-as-VAL, consume-as-VAL) }
    def consume-as-TUP { +for(consume-as-TUP, consume-as-TUP) }
    def turn-into-resource! { +for(turn-into-resource!, id) }
}

def +C99Branch.pop-data! [ +C99Branch |- Data -- +C99Value/Resource ] {
    dup +mirth:is-resource? if(
        +mirth:c99-repr pop-resource! +Right +C99Value/Resource,
        +mirth:c99-repr pop-value! +Left +C99Value/Resource
    )
}

def +C99Branch.refresh-branch! [ +C99Branch -- +C99Branch ] {
    /+C99Branch
    +c99> +stack>
    refresh-all!
}

def +C99Stack.refresh-all! [ +C99 +C99Stack reachable:Bool env:C99Env -- +C99Branch ] {
    { +Nil -> start-branch! }
    { +Cons ->
        >+x refresh-all!
        @+x:value-repr push-value-expression!(+x> consume put)
    }
    { +With ->
        >+x refresh-all!
        @+x:resource-repr push-resource-expression!(+x> consume put)
    }
    { +ConsLabel ->
        >+x refresh-all!
        @+x:value-repr swap push-label-expression!(+x> consume put)
    }
    { +WithLabel ->
        >+x refresh-all!
        @+x:resource-repr swap push-label-expression!(+x> consume put)
    }
}

def +C99Stack.tie-knot! [ +C99Branch |- +C99Stack -- ] {
    { +Nil -> flush-cache! }
    { +Cons ->
        value-repr dup rdip2(pop-value! consume-as)
        value-name
        value-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        push-value!
    }
    { +With ->
        resource-repr dup rdip2(pop-resource! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        push-resource!
    }
    { +ConsLabel -> >label
        value-repr dup rdip2(@label pop-value-label! consume-as)
        value-name
        value-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        label> push-value-label!
    }
    { +WithLabel -> >label
        resource-repr dup rdip2(@label pop-resource-label! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        rdip2:c99-line-if(put " = " put put ";" put)
        rdip:tie-knot!
        label> push-resource-label!
    }
}

data +C99Stack {
    +Nil
    +Cons [ +C99Stack +C99Value ]
    +With [ +C99Stack +C99Resource ]
    +ConsLabel [ +C99Stack +C99Value Label ]
    +WithLabel [ +C99Stack +C99Resource Label ]
}

def +C99Stack.pop-value? [ +C99Stack -- +Maybe(+C99Value) +C99Stack ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +Cons -> +Some rswap }
    { +With -> rdip:pop-value? +C99Stack.+With }
    { +ConsLabel -> rdip:pop-value? +C99Stack.+ConsLabel }
    { +WithLabel -> rdip:pop-value? +C99Stack.+WithLabel }
}

def +C99Stack.pop-resource? [ +C99Stack -- +Maybe(+C99Resource) +C99Stack ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +With -> +Some rswap }
    { +Cons -> rdip:pop-resource? +C99Stack.+Cons }
    { +ConsLabel -> rdip:pop-resource? +C99Stack.+ConsLabel }
    { +WithLabel -> rdip:pop-resource? +C99Stack.+WithLabel }
}

def +C99Stack.pop-value-label? [ Label +C99Stack -- Label +Maybe(+C99Value) +C99Stack ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +Cons -> rdip:pop-value-label? +C99Stack.+Cons }
    { +With -> rdip:pop-value-label? +C99Stack.+With }
    { +WithLabel -> dip:rdip:pop-value-label? +C99Stack.+WithLabel }
    { +ConsLabel ->
        dup2 = if(
            drop +Some rswap,
            dip:rdip:pop-value-label? +C99Stack.+ConsLabel
        )
    }
}

def +C99Stack.pop-resource-label? [ Label +C99Stack -- Label +Maybe(+C99Resource) +C99Stack ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +Cons -> rdip:pop-resource-label? +C99Stack.+Cons }
    { +With -> rdip:pop-resource-label? +C99Stack.+With }
    { +ConsLabel -> dip:rdip:pop-resource-label? +C99Stack.+ConsLabel }
    { +WithLabel ->
        dup2 = if(
            drop +Some rswap,
            dip:rdip:pop-resource-label? +C99Stack.+WithLabel
        )
    }
}

def +C99Stack.push-stack-direct! [ +C99Branch +C99Stack -- +C99Branch ] {
    { +Nil -> }
    { +Cons -> rdip:push-stack-direct! push-value-direct! }
    { +With -> rdip:push-stack-direct! push-resource-direct! }
    { +ConsLabel -> rdip:push-stack-direct! push-value-label-direct! }
    { +WithLabel -> rdip:push-stack-direct! push-resource-label-direct! }
}

def +C99Stack.rdup [ +C99Stack -- +C99Stack +C99Stack ] {
    { +Nil -> +C99Stack.+Nil +C99Stack.+Nil }
    { +Cons -> rdip:rdup +C99Value.rdup rdip:rswap +C99Stack.+Cons rdip:+C99Stack.+Cons }
    { +With -> rdip:rdup +C99Resource.rdup rdip:rswap +C99Stack.+With rdip:+C99Stack.+With }
    { +ConsLabel -> dup rdip:rdup +C99Value.rdup rdip:rswap +C99Stack.+ConsLabel rdip:+C99Stack.+ConsLabel }
    { +WithLabel -> dup rdip:rdup +C99Resource.rdup rdip:rswap +C99Stack.+WithLabel rdip:+C99Stack.+WithLabel }
}

def +C99Stack.rdrop [ +C99Stack -- ] {
    { +Nil -> }
    { +Cons -> +C99Value.rdrop rdrop }
    { +With -> +C99Resource.rdrop rdrop }
    { +ConsLabel -> drop +C99Value.rdrop rdrop }
    { +WithLabel -> drop +C99Resource.rdrop rdrop }
}

struct +C99BranchSplit {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    branch-split-target: List(C99APIArg)
    reachable-in: Bool
    reachable-out: Bool
}

def +C99BranchSplit.+mirth(f) { +c99:+mirth(f) }

def +C99Branch.begin-branch-split! [ StackType +C99Branch -- +C99BranchSplit ] {
    C99APIArgMode.Branch +c99:stack-type-to-c99-api-params >branch-split-target
    must-flush> drop
    @branch-split-target for(reserve-as-is!)
    /+C99Branch
    reachable> >reachable-in
    False >reachable-out
    +C99BranchSplit
}
def +C99BranchSplit.end-branch-split! [ +C99BranchSplit -- +C99Branch ] {
    /+C99BranchSplit
    +stack> rdrop
    reachable-in> drop
    reachable-out> >reachable
    +c99> start-branch!
    branch-split-target> for(push-api-arg!)
}

def +C99BranchSplit.sub-branch(f) [ (+C99Branch |- *a -- *b) +C99BranchSplit |- *a -- *b ] {
    +stack(rdup >+stack) branch-split-target
    reachable-in >reachable
    env >env
    +c99(
        >+c99 +C99Branch dip:f
        reverse-for(pop-to-reserved!)
        end-branch!
    )
    env> drop
    reachable> reachable-out:or
}


def +C99BranchSplit.c99-line(f) { reachable-in +c99:c99-line-if(f) }
def +C99BranchSplit.c99-line-if(f) { reachable-in and +c99:c99-line-if(f) }
def +C99BranchSplit.c99-nest(f) { +c99:depth:1+ f +C99BranchSplit.+c99:depth:pred }

struct C99Var {
    var-var: Var
    value-name: Str
    value-repr: C99ReprType
}

def +C99Branch.var-lookup [ +C99Branch |- Var -- Maybe(C99Var) ] {
    env lookup(var-var =)
}

def +C99Branch.var-get! [ +C99Branch |- Var -- +C99Value ] {
    var-lookup unwrap("[c99] variable unexpectedly missing from environment" +mirth:fatal-error!)
    /C99Var var-var> drop
    +C99Value
}

def +C99Branch.var-dup! [ +C99Branch |- Var -- +C99Value ] {
    var-get! dup-value! rdrop
}

def +C99Value.push-to-env! [ +C99Branch |- Var +C99Value -- ] {
    >var-var /+C99Value C99Var env:cons
}

def +C99Branch.pop-from-env! [ +C99Branch |- -- Var +C99Value ] {
    env:uncons unwrap("[c99] variable environment unexpectedly empty" +mirth:fatal-error!)
    /C99Var +C99Value var-var>
}

def-type(C99Env, List(C99Var))

||| This resource represents a single active branch.
struct +C99Branch {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    reachable: Bool
}

def +C99Branch.+mirth(f) { +c99:+mirth(f) }

def +C99.start-branch! [ +C99 reachable:Bool env:C99Env -- +C99Branch ] {
    >+c99 +C99Stack.+Nil >+stack +C99Branch
}

def +C99Branch.end-branch! [ +C99Branch -- +C99 reachable:Bool env:C99Env ] {
    +stack(+C99Stack.+Nil) rswap push-stack-direct!
    /+C99Branch +c99> +stack> rdrop
}

def +C99Branch.flush-cache! [ +C99Branch |- ] {
    end-branch!
    start-branch!
}

def +C99Branch.pop-value! [ +C99Branch |- C99ReprType -- +C99Value ] {
    +stack(pop-value?) rswap match {
        { +Some -> drop }
        { +None -> pop-value-direct! }
    }
}

def +C99Branch.pop-value-label! [ +C99Branch |- C99ReprType Label -- +C99Value ] {
    +stack(pop-value-label?) rswap match {
        { +Some -> drop2 }
        { +None -> pop-value-label-direct! }
    }
}

def +C99Branch.pop-resource! [ +C99Branch |- C99ReprType -- +C99Resource ] {
    +stack(pop-resource?) rswap match {
        { +Some -> drop }
        { +None -> pop-resource-direct! }
    }
}

def +C99Branch.pop-resource-label! [ +C99Branch |- C99ReprType Label -- +C99Resource ] {
    +stack(pop-resource-label?) rswap match {
        { +Some -> drop2 }
        { +None -> pop-resource-label-direct! }
    }
}

def +C99Value.push-value! [ +C99Branch |- +C99Value -- ] {
    rswap +stack(rswap +C99Stack.+Cons)
}

def +C99Resource.push-resource! [ +C99Branch |- +C99Resource -- ] {
    rswap +stack(rswap +C99Stack.+With)
}

def +C99Branch.type-to-c99-repr [ +C99Branch |- Type -- C99ReprType ] { +mirth:c99-repr }
def +C99Branch.resource-to-c99-repr [ +C99Branch |- Resource -- C99ReprType ] { +mirth:c99-repr }

def +C99Branch.pop-value-from-stack-type! [ +C99Branch StackType |- +C99Value ] {
    +mirth:force-cons?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2
    type-to-c99-repr pop-value!
}
def +C99Branch.pop-resource-from-stack-type! [ +C99Branch StackType |- +C99Resource ] {
    +mirth:force-with?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2
    resource-to-c99-repr pop-resource!
}

def +C99Branch.pop-value-label-from-stack-type! [ +C99Branch |- Label StackType -- StackType +C99Value ] {
    dip:dup +mirth:force-cons-label?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2 type-to-c99-repr
    rotl pop-value-label!
}

def +C99Branch.pop-resource-label-from-stack-type! [ +C99Branch |- Label StackType -- StackType +C99Resource ] {
    dip:dup +mirth:force-with-label?! unwrap("c99 error: tried to pop from invalid stack type" +mirth:fatal-error!) unpack2 resource-to-c99-repr
    rotl pop-resource-label!
}

def c99-prim! [ +C99Branch |- Atom Prim -- ] {
    { Id -> drop }
    { Drop ->
        dom pop-value-from-stack-type! drop
        drop-value!
    }
    { Dup ->
        dom pop-value-from-stack-type! drop
        dup-value! rdip:push-value! push-value!
    }
    { Swap ->
        dom
        pop-value-from-stack-type! >+b
        pop-value-from-stack-type! >+a
        drop
        +b> push-value!
        +a> push-value!
    }
    { RSwap ->
        dom
        pop-resource-from-stack-type! >+b
        pop-resource-from-stack-type! >+a
        drop
        +b> push-resource!
        +a> push-resource!
    }
    { Dip ->
        dup args single? unwrap(token "unexpected number of arguments to Dip" +mirth:emit-fatal-error!)
        swap dom pop-value-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-value!
    }
    { RDip ->
        dup args single? unwrap(token "unexpected number of arguments to RDip" +mirth:emit-fatal-error!)
        swap dom pop-resource-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-resource!
    }
    { If ->
        dup args pair? unwrap(token "unexpected number of arguments to If" +mirth:emit-fatal-error!)
        unpack2 C99ReprType.Bool pop-value! >+cond

        rotl +mirth:cod
        begin-branch-split!
        c99-line("if (" put +cond> C99ReprType.Bool consume-as put ") {" put)
        c99-nest:sub-branch(swap c99-arg-run!)
        c99-line("} else {" put)
        c99-nest:sub-branch(c99-arg-run!)
        c99-line("}" put)
        end-branch-split!
    }
    { While ->
        dup args pair? unwrap(token "unexpected number of arguments to While" +mirth:emit-fatal-error!)
        nip unpack2 over c99-arg-run!
        C99ReprType.Bool pop-value! push-value!
        refresh-branch! +stack(rdup >+knot)
        C99ReprType.Bool dup pop-value! consume-as
        c99-line("while (" put put ") {" put)
        c99-nest(
            refresh-branch!
            c99-arg-run!
            c99-arg-run!
            +knot> tie-knot!
        )
        c99-line("}" put)
        C99ReprType.Bool pop-value! rdrop
    }
    { Debug -> drop flush-cache! c99-line("trace_stack();" put) }
    { Panic ->
        drop
        C99ReprType.STR dup pop-value! consume-as
        c99-line("do_panic(" put put ");" put)
        +stack(rdrop +C99Stack.+Nil)
        False reachable!
    }
    { Run ->
        dup args empty? else(token "expected no arguments to prim-core-run" +mirth:emit-fatal-error!) drop
        C99ReprType.VAL pop-value! run-value!
    }

    { IntEq  -> drop "int_eq(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntLt  -> drop "int_lt(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntLe  -> drop "int_le(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntGt  -> drop "int_gt(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntGe  -> drop "int_ge(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntNe  -> drop "int_ne(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntAdd -> drop "int_add(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Int Some c99-binop! }
    { IntSub -> drop "int_sub(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Int Some c99-binop! }
    { IntMul -> drop "int_mul(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Int Some c99-binop! }
    { IntDivMod -> args "int_divmod" Prim.IntDivMod +mirth:type +c99:cname-type-to-c99-api c99-smart-call! }
    { IntToU64 -> drop "int_to_u64(" C99ReprType.Int ")" C99ReprType.U64 Some c99-unop! }
    { IntToI64 -> drop "int_to_i64(" C99ReprType.Int ")" C99ReprType.I64 Some c99-unop! }
    { IntToF32 -> drop "int_to_f32(" C99ReprType.Int ")" C99ReprType.F32 Some c99-unop! }
    { IntToF64 -> drop "int_to_f64(" C99ReprType.Int ")" C99ReprType.F64 Some c99-unop! }
    { IntToStr -> drop "int_to_str(" C99ReprType.Int ")" C99ReprType.STR Some c99-unop! }

    { U8Get  -> drop "*(uint8_t*)"  C99ReprType.PTR "" C99ReprType.U8  Some c99-unop! }
    { U8Set  -> drop "*(uint8_t*)"  C99ReprType.PTR " = " C99ReprType.U8  ";" True None c99-binop! }
    { U8ToU64 -> drop "(uint64_t)(" C99ReprType.U8 ")" C99ReprType.U64 Some c99-unop! }

    { U16Get -> drop "*(uint16_t*)" C99ReprType.PTR "" C99ReprType.U16 Some c99-unop! }
    { U16Set -> drop "*(uint16_t*)" C99ReprType.PTR " = " C99ReprType.U16 ";" True None c99-binop! }
    { U16ToU64 -> drop "(uint64_t)(" C99ReprType.U16 ")" C99ReprType.U64 Some c99-unop! }

    { U32Get -> drop "*(uint32_t*)" C99ReprType.PTR "" C99ReprType.U32 Some c99-unop! }
    { U32Set -> drop "*(uint32_t*)" C99ReprType.PTR " = " C99ReprType.U32 ";" True None c99-binop! }
    { U32ToU64 -> drop "(uint64_t)(" C99ReprType.U32 ")" C99ReprType.U64 Some c99-unop! }

    { U64Get -> drop "*(uint64_t*)" C99ReprType.PTR "" C99ReprType.U64 Some c99-unop! }
    { U64Set -> drop "*(uint64_t*)" C99ReprType.PTR " = " C99ReprType.U64 ";" True None c99-binop! }
    { U64Eq  -> drop "(" C99ReprType.U64 " == " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Lt  -> drop "(" C99ReprType.U64 " < "  C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Le  -> drop "(" C99ReprType.U64 " <= " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Gt  -> drop "(" C99ReprType.U64 " > "  C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Ge  -> drop "(" C99ReprType.U64 " >= " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Ne  -> drop "(" C99ReprType.U64 " != " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Add -> drop "(" C99ReprType.U64 " + " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Sub -> drop "(" C99ReprType.U64 " - " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Mul -> drop "(" C99ReprType.U64 " * " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Div -> drop "u64_div(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Mod -> drop "u64_mod(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64And -> drop "(" C99ReprType.U64 " & "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Xor -> drop "(" C99ReprType.U64 " ^ "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Or  -> drop "(" C99ReprType.U64 " | "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Shl -> drop "u64_shl(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Shr -> drop "u64_shr(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64ToInt -> drop "u64_to_int(" C99ReprType.U64 ")" C99ReprType.Int Some c99-unop! }
    { U64ToStr -> drop "u64_to_str(" C99ReprType.U64 ")" C99ReprType.STR Some c99-unop! }
    { U64ToU8  -> drop "(uint8_t)(" C99ReprType.U64 ")" C99ReprType.U8 Some c99-unop! }
    { U64ToU16 -> drop "(uint16_t)(" C99ReprType.U64 ")" C99ReprType.U16 Some c99-unop! }
    { U64ToU32 -> drop "(uint32_t)(" C99ReprType.U64 ")" C99ReprType.U32 Some c99-unop! }
    { U64ToI8  -> drop "(int8_t)(" C99ReprType.U64 ")" C99ReprType.I8 Some c99-unop! }
    { U64ToI16 -> drop "(int16_t)(" C99ReprType.U64 ")" C99ReprType.I16 Some c99-unop! }
    { U64ToI32 -> drop "(int32_t)(" C99ReprType.U64 ")" C99ReprType.I32 Some c99-unop! }
    { U64ToI64 -> drop "(int64_t)(" C99ReprType.U64 ")" C99ReprType.I64 Some c99-unop! }
    { U64ToF32 -> drop "(float)("   C99ReprType.U64 ")"  C99ReprType.F32 Some c99-unop! }
    { U64ToF64 -> drop "(double)("  C99ReprType.U64 ")"  C99ReprType.F64 Some c99-unop! }

    { I8Get  -> drop "*(int8_t*)"   C99ReprType.PTR "" C99ReprType.I8  Some c99-unop! }
    { I8Set  -> drop "*(int8_t*)"   C99ReprType.PTR " = " C99ReprType.I8  ";" True None c99-binop! }
    { I8ToI64 -> drop "(int64_t)(" C99ReprType.I8 ")" C99ReprType.I64 Some c99-unop! }

    { I16Get -> drop "*(int16_t*)"  C99ReprType.PTR "" C99ReprType.I16 Some c99-unop! }
    { I16Set -> drop "*(int16_t*)"  C99ReprType.PTR " = " C99ReprType.I16 ";" True None c99-binop! }
    { I16ToI64 -> drop "(int64_t)(" C99ReprType.I16 ")" C99ReprType.I64 Some c99-unop! }

    { I32Get -> drop "*(int32_t*)"  C99ReprType.PTR "" C99ReprType.I32 Some c99-unop! }
    { I32Set -> drop "*(int32_t*)"  C99ReprType.PTR " = " C99ReprType.I32 ";" True None c99-binop! }
    { I32ToI64 -> drop "(int64_t)(" C99ReprType.I32 ")" C99ReprType.I64 Some c99-unop! }

    { I64Get -> drop "*(int64_t*)"  C99ReprType.PTR "" C99ReprType.I64 Some c99-unop! }
    { I64Set -> drop "*(int64_t*)"  C99ReprType.PTR " = " C99ReprType.I64 ";" True None c99-binop! }
    { I64Eq  -> drop "(" C99ReprType.I64 " == " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Lt  -> drop "(" C99ReprType.I64 " < "  C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Le  -> drop "(" C99ReprType.I64 " <= " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Gt  -> drop "(" C99ReprType.I64 " > "  C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Ge  -> drop "(" C99ReprType.I64 " >= " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Ne  -> drop "(" C99ReprType.I64 " != " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Add -> drop "i64_add(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Sub -> drop "i64_sub(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Mul -> drop "i64_mul(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Div -> drop "i64_div(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Mod -> drop "i64_mod(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64ToInt -> drop "i64_to_int(" C99ReprType.I64 ")" C99ReprType.Int Some c99-unop! }
    { I64ToStr -> drop "i64_to_str("   C99ReprType.I64 ")" C99ReprType.STR Some c99-unop! }
    { I64ToU8  -> drop "(uint8_t)("  C99ReprType.I64 ")" C99ReprType.U8 Some c99-unop! }
    { I64ToU16 -> drop "(uint16_t)(" C99ReprType.I64 ")" C99ReprType.U16 Some c99-unop! }
    { I64ToU32 -> drop "(uint32_t)(" C99ReprType.I64 ")" C99ReprType.U32 Some c99-unop! }
    { I64ToU64 -> drop "(uint64_t)(" C99ReprType.I64 ")" C99ReprType.U64 Some c99-unop! }
    { I64ToI8  -> drop "(int8_t)("   C99ReprType.I64 ")" C99ReprType.I8 Some c99-unop! }
    { I64ToI16 -> drop "(int16_t)("  C99ReprType.I64 ")" C99ReprType.I16 Some c99-unop! }
    { I64ToI32 -> drop "(int32_t)("  C99ReprType.I64 ")" C99ReprType.I32 Some c99-unop! }
    { I64ToF32 -> drop "(float)("    C99ReprType.I64 ")"  C99ReprType.F32 Some c99-unop! }
    { I64ToF64 -> drop "(double)("   C99ReprType.I64 ")"  C99ReprType.F64 Some c99-unop! }

    # { PRIM_F32_SET -> drop "*(float*)"    C99ReprType.PTR " = " C99ReprType.F32 ";" True None c99-binop! }
    { F32Eq  -> drop "(" C99ReprType.F32 " == " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Lt  -> drop "(" C99ReprType.F32 " < "  C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Le  -> drop "(" C99ReprType.F32 " <= " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Gt  -> drop "(" C99ReprType.F32 " > "  C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Ge  -> drop "(" C99ReprType.F32 " >= " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Ne  -> drop "(" C99ReprType.F32 " != " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Add -> drop "(" C99ReprType.F32 " + "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Sub -> drop "(" C99ReprType.F32 " - "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Mul -> drop "(" C99ReprType.F32 " * "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Div -> drop "(" C99ReprType.F32 " / "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32ToInt -> drop "f32_to_int(" C99ReprType.F32 ")"  C99ReprType.Int Some c99-unop! }
    { F32ToF64 -> drop "(double)"  C99ReprType.F32 ""  C99ReprType.F64 Some c99-unop! }
    { F32ToStr -> drop "f32_to_str(" C99ReprType.F32 ")" C99ReprType.STR Some c99-unop! }

    { F32Get -> drop "*(float*)"  C99ReprType.PTR "" C99ReprType.F32 Some c99-unop! }
    { F32Set -> drop "*(float*)"  C99ReprType.PTR " = " C99ReprType.F32 ";" True None c99-binop! }

    # { PRIM_F64_SET -> drop "*(double*)"   C99ReprType.PTR " = " C99ReprType.F64 ";" True None c99-binop! }
    { F64Eq  -> drop "(" C99ReprType.F64 " == " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Lt  -> drop "(" C99ReprType.F64 " < "  C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Le  -> drop "(" C99ReprType.F64 " <= " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Gt  -> drop "(" C99ReprType.F64 " > "  C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Ge  -> drop "(" C99ReprType.F64 " >= " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Ne  -> drop "(" C99ReprType.F64 " != " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Add -> drop "(" C99ReprType.F64 " + "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Sub -> drop "(" C99ReprType.F64 " - "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Mul -> drop "(" C99ReprType.F64 " * "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Div -> drop "(" C99ReprType.F64 " / "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64ToInt -> drop "f64_to_int(" C99ReprType.F64 ")"  C99ReprType.Int Some c99-unop! }
    { F64ToF32 -> drop "(float)"   C99ReprType.F64 ""  C99ReprType.F32 Some c99-unop! }
    { F64ToStr -> drop "f64_to_str(" C99ReprType.F64 ")" C99ReprType.STR Some c99-unop! }

    { F64Get -> drop "*(double*)"  C99ReprType.PTR "" C99ReprType.F64 Some c99-unop! }
    { F64Set -> drop "*(double*)"  C99ReprType.PTR " = " C99ReprType.F64 ";" True None c99-binop! }

    { BoolTrue  -> drop C99ReprType.Bool push-value-expression!("true"  put) }
    { BoolFalse -> drop C99ReprType.Bool push-value-expression!("false" put) }
    { BoolAnd -> drop "(" C99ReprType.Bool " && " C99ReprType.Bool ")" False C99ReprType.Bool Some c99-binop! }
    { BoolOr  -> drop "(" C99ReprType.Bool " || " C99ReprType.Bool ")" False C99ReprType.Bool Some c99-binop! }
    { BoolNot -> drop "!" C99ReprType.Bool "" C99ReprType.Bool Some c99-unop! }

    { TupPack0 -> drop 0u C99ReprType.TUP push-value-expression!("NULL" put) }
    { TupPack1 -> drop 1u c99-tup-pack! }
    { TupPack2 -> drop 2u c99-tup-pack! }
    { TupPack3 -> drop 3u c99-tup-pack! }
    { TupPack4 -> drop 4u c99-tup-pack! }
    { TupPack5 -> drop 5u c99-tup-pack! }

    { TupUnpack0 -> drop 0u C99ReprType.TUP pop-value! drop-value! }
    { TupUnpack1 -> drop 1u c99-tup-unpack! }
    { TupUnpack2 -> drop 2u c99-tup-unpack! }
    { TupUnpack3 -> drop 3u c99-tup-unpack! }
    { TupUnpack4 -> drop 4u c99-tup-unpack! }
    { TupUnpack5 -> drop 5u c99-tup-unpack! }

    { MutGet    -> drop "mut_get(" C99ReprType.PTR ")" C99ReprType.VAL Some c99-unop! }
    { MutSet    -> drop "mut_set(" C99ReprType.VAL ", " C99ReprType.PTR ");" False None c99-binop! }
    { MutIsSet -> drop "mut_is_set(" C99ReprType.PTR ")" C99ReprType.Bool Some c99-unop! }

    { PtrGet -> drop "*(void**)"    C99ReprType.PTR "" C99ReprType.PTR Some c99-unop! }
    { PtrSet -> drop "*(void**)"    C99ReprType.PTR " = " C99ReprType.PTR ";" True None c99-binop! }
    { PtrNil -> drop C99ReprType.PTR push-value-expression!("(void*)0" put) }
    { PtrEq  -> drop "(" C99ReprType.PTR " == " C99ReprType.PTR ")" False C99ReprType.Bool Some c99-binop! }
    { PtrAdd -> drop "(void*)(" C99ReprType.I64 " + (char*)" C99ReprType.PTR ")" False C99ReprType.PTR Some c99-binop! }
    { PtrSize -> drop C99ReprType.U64 push-value-expression!("sizeof(void*)" put) }
    { PtrAlloc   -> drop "ptr_alloc(" C99ReprType.U64 ");" C99ReprType.PTR Some c99-unop! }
    { PtrRealloc -> drop "ptr_realloc(" C99ReprType.PTR "," C99ReprType.U64 ")" False C99ReprType.PTR Some  c99-binop! }
    { PtrFree    -> drop "free(" C99ReprType.PTR ");" None c99-unop! }
    { PtrCopy ->
        drop
        C99ReprType.PTR pop-value! >+dst
        C99ReprType.U64 pop-value! >+len
        C99ReprType.PTR pop-value! >+src
        c99-line (
            "ptr_copy(" put
                +src> C99ReprType.PTR consume-as put
            ", " put
                +len> C99ReprType.U64 consume-as put
            ", " put
                +dst> C99ReprType.PTR consume-as put
            ");" put
        )
    }
    { PtrFill ->
        drop
        C99ReprType.PTR pop-value! >+dst
        C99ReprType.U64 pop-value! >+len
        C99ReprType.U8  pop-value! >+val
        c99-line (
            "ptr_fill(" put
                +val> C99ReprType.U8  consume-as put
            ", " put
                +len> C99ReprType.U64 consume-as put
            ", " put
                +dst> C99ReprType.PTR consume-as put
            ");" put
        )
    }

    { StrCopy -> drop "str_make(" C99ReprType.PTR ", " C99ReprType.U64 ")" False C99ReprType.STR Some c99-binop! }
    { StrNumBytes -> drop "str_size(" C99ReprType.STR ")" C99ReprType.U64 Some c99-unop! }
    { StrBase      -> drop "str_base(" C99ReprType.STR ")" C99ReprType.PTR Some c99-unop! }
    { StrCat  -> drop "str_cat(" C99ReprType.STR ", " C99ReprType.STR ")" False C99ReprType.STR Some c99-binop! }
    { StrCmp  -> drop "str_cmp(" C99ReprType.STR ", " C99ReprType.STR ")" False C99ReprType.I64 Some c99-binop! }
    { StrEq   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") == 0)" False C99ReprType.Bool Some c99-binop! }
    { StrLt   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") < 0)"  False C99ReprType.Bool Some c99-binop! }
    { StrLe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") <= 0)" False C99ReprType.Bool Some c99-binop! }
    { StrGt   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") > 0)"  False C99ReprType.Bool Some c99-binop! }
    { StrGe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") >= 0)" False C99ReprType.Bool Some c99-binop! }
    { StrNe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") != 0)" False C99ReprType.Bool Some c99-binop! }

    { StrToF32 -> args "str_to_f32" Prim.StrToF32 +mirth:type +c99:cname-type-to-c99-api c99-smart-call! }
    { StrToF64 -> args "str_to_f64" Prim.StrToF64 +mirth:type +c99:cname-type-to-c99-api c99-smart-call! }

    { SysOs   -> drop C99ReprType.I64 push-value-expression!("RUNNING_OS" put) }
    { SysArch -> drop C99ReprType.I64 push-value-expression!("RUNNING_ARCH" put) }
    { SysArgc -> drop C99ReprType.U64 push-value-expression!("global_argc" put) }
    { SysArgv -> drop C99ReprType.PTR push-value-expression!("global_argv" put) }
}

def c99-tup-pack! [ +C99Branch |- Nat -- ] {
    None >tag
    List(repeat(Type.Ignore StackTypePart.Cons ;)) >parts
    c99-pack-tuple! turn-into-value! push-value!
}

def c99-tup-unpack! [ +C99Branch |- Nat -- ] {
    None >tag
    dup List(repeat(Type.Ignore StackTypePart.Cons ;)) >parts
    C99ReprType.TUP pop-value! turn-into-resource! c99-unpack-tuple!
}

def +C99Value.run-value! [ +C99Branch |- +C99Value -- ] {
    consume-as-VAL flush-cache!
    c99-line("run_value(" put put ");" put)
}

def c99-binop! [ +C99Branch |- Str C99ReprType Str C99ReprType Str Bool Maybe(C99ReprType) -- ] {
    >out-type >args-swapped
    >sfx >arg2-type >op >arg1-type >pfx

    args-swapped> if(
        arg1-type> dup pop-value! consume-as >arg1
        arg2-type> dup pop-value! consume-as >arg2,

        arg2-type> dup pop-value! consume-as >arg2
        arg1-type> dup pop-value! consume-as >arg1
    )

    out-type> match {
        { Some -> push-value-expression!(pfx> put arg1> put op> put arg2> put sfx> put) }
        { None -> c99-line(pfx> put arg1> put op> put arg2> put sfx> put) }
    }
}

def c99-unop! [ +C99Branch |- Str C99ReprType Str Maybe(C99ReprType) -- ] {
    >out-type >sfx >arg-type >pfx
    arg-type> dup pop-value! consume-as
    out-type> match {
        { Some -> push-value-expression!(pfx> put put sfx> put) }
        { None -> c99-line(pfx> put put sfx> put) }
    }
}

def c99-args-push! [ +C99Branch |- List(Arg) -- ] {
    for(c99-arg-push!)
}
def c99-arg-push! [ +C99Branch |- Arg -- ] {
    { Block -> c99-block-push! }
}
def c99-arg-run! [ +C99Branch |- Arg -- ] {
    { Block -> c99-block-run! }
}

def c99-block-run! [ +C99Branch |- Block -- ] {
    +mirth:arrow c99-codip-arrow!
}

def c99-pack-closure-vars! [ +C99Branch |- List(Var) -- ] {
    +mirth:filter(is-physical?) dup empty? if(
        drop,
        Type.Ignore StackTypePart.Cons
        over map(+mirth:type StackTypePart.Cons) cons >parts
        None >tag
        for(var-dup! push-value!)
        c99-pack-tuple!
        turn-into-value!
        push-value!
    )
}

def c99-unpack-closure-vars! [ +C99Branch |- List(Var) -- +closure:+Maybe(+C99Value) ] {
    +mirth:filter(is-physical?) dup empty? if(
        +None >+closure
        drop,
        C99ReprType.VAL pop-value! >+tup
        @+tup:rdup consume-as-TUP >tup
        1 >i
        for(
            dup +mirth:type type-to-c99-repr
            dup value-expression! (
                v-macro (
                    @tup put
                    "->cells[" put
                    @i >Str put
                    "]" put
                )
            )
            push-to-env!
            @i:1+
        )
        i> drop
        tup> drop
        +tup> +Some >+closure
    )
}

def c99-block-push! [ +C99Branch |- Block -- ] {
    dup +mirth:to-run-var match(
        Some -> nip c99-var-push!,
        None ->
            C99ReprType.FNPTR push-value-expression!("&" put dup +mirth:cname put)
            dup +mirth:free-vars c99-pack-closure-vars!
            drop
    )
}

def c99-var! [ +C99Branch |- Var -- ] {
    dup +mirth:auto-run? if(c99-var-run!, c99-var-push!)
}

def c99-var-run! [ +C99Branch |- Var -- ] {
    var-dup! run-value!
}

def c99-var-push! [ +C99Branch |- Var -- ] {
    var-dup! push-value!
}

def reverse-pop-values-to-env! [ +C99Branch |- List(Var) -- ] {
    { Nil -> id }
    { Cons ->
        over +mirth:type type-to-c99-repr pop-value!
        rdip(reverse-pop-values-to-env!)
        push-to-env!
    }
}

def pop-values-to-env! [ +C99Branch |- List(Var) -- ] {
    reverse reverse-pop-values-to-env!
}

def drop-env-var! [ +C99Branch |- Var -- ] {
    pop-from-env!
    = else("[c99] unexpected variable in environment when exiting scope" rdip:+mirth:fatal-error!)
    drop-value!
}

def drop-env-vars! [ +C99Branch |- List(Var) -- ] {
    reverse-for(drop-env-var!)
}

def c99-lambda! [ +C99Branch |- Lambda -- ] {
    dup params pop-values-to-env!
    dup body c99-arrow!
    params drop-env-vars!
}

def c99-match! [ +C99Branch |- Match -- ] {
    dup cases single? if?(
        nip c99-single-case!,

        dup +mirth:scrutinee-data?
        unwrap(token "non-uniform match, not supported at present" +mirth:emit-fatal-error!)
        pop-data! >+scrutinee
        dup cod begin-branch-split!
        c99-line("switch (" put @+scrutinee:peek-data-tag put ") {" put)
        c99-nest(
            dup cases for(@+scrutinee:rdup >+scrutinee c99-case!)
            +mirth:has-default-case? else(
                c99-line("default: {" put)
                c99-nest(
                    c99-line("do_panic(str_make(\"unexpected fallthrough in match\\n\", 32));" put)
                )
                c99-line("}" put)
            )
            +scrutinee> rdrop
        )
        c99-line("}" put)
        end-branch-split!
    )
}

def c99-single-case! [ +C99Branch |- Case -- ] {
    dup pattern is-default? if(
        body c99-arrow!,

    dup pattern single-tag? if?(
        c99-reverse-tag!
        body c99-arrow!,

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def c99-case! [ +C99BranchSplit |- Case +scrutinee:+C99Value/Resource -- ] {
    dup pattern is-default? if(
        c99-line("default: {" put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            body c99-arrow!
        )
        c99-line("} break;" put),

    dup pattern single-tag? if?(
        c99-line("case " put dup +mirth:value-show put "LL: { // " put dup +mirth(name >Str) put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            c99-reverse-tag!
            body c99-arrow!
        )
        c99-line("} break;" put),

        pattern token-start "c99 target -- don't know how to compile this pattern"
        +mirth:emit-fatal-error!
    ))
}

def Tag.word-cname-type [ +Mirth |- Tag -- Str ArrowType ] { sip:word-cname type }
def Tag.pat-cname-type [ +Mirth |- Tag -- Str ArrowType ] { sip:pat-cname type invert }
def Word.cname-type [ +Mirth |- Word -- Str ArrowType ] { sip:cname type }

field(Tag.~word-c99-api, Tag, C99API)
def Tag.word-c99-api [ +C99 |- Tag -- C99API ] {
    dup ~word-c99-api memoize(dup +mirth:word-cname-type cname-type-to-c99-api) nip
}

field(Tag.~pat-c99-api, Tag, C99API)
def Tag.pat-c99-api [ +C99 |- Tag -- C99API ] {
    dup ~pat-c99-api memoize(dup +mirth:pat-cname-type cname-type-to-c99-api) nip
}

field(Word.~c99-api, Word, C99API)
def Word.c99-api [ +C99 |- Word -- C99API ] {
    dup ~c99-api memoize(dup +mirth:cname-type cname-type-to-c99-api) nip
}

def c99-word-sigs! [ +C99 |- ] { Word.for(dup +needs(needed?) if(c99-word-sig!, drop)) }
def c99-word-sig! [ +C99 |- Word -- ] { c99-api c99-smart-sig! }

def c99-block-sigs! [ +C99 |- ] { Block.for(dup +needs(needed?) if(c99-block-sig!, drop)) }
def c99-block-sig! [ +C99 |- Block -- ] { c99-line(c99-block-sig-put ";" put) }

def c99-block-defs! [ +C99 |- ] { Block.for(dup +needs(needed?) if(c99-block-def!, drop)) }
def c99-block-def! [ +C99 |- Block -- ] {
    c99-line(dup c99-block-sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-block-enter!
        dup +mirth:arrow
        dup +mirth:free-vars c99-unpack-closure-vars!
        dup +mirth:type dom expose-stack-type!
        c99-arrow!
        +closure> +if(drop-value!, id)
        c99-block-exit!
    )
    c99-line("}" put)
}

def c99-block-sig-put [ +C99 |- Block -- ] { "static void " put +mirth:cname put " (void)" put }

def c99-block-enter! [ Block +C99 -- +C99Branch ] {
    options emit-debug-info if(
        c99-line("WORD_ENTER(" put
            dup +mirth:home match(
                Main -> drop "block",
                Word -> +mirth(name >Str) " block" cat,
            ) put-cstr ", " put
            dup +mirth(token module source-path) >Str put-cstr ", " put
            dup +mirth(token row) >Int >Str put ", " put
            dup +mirth(token col) >Int >Str put ");" put
        ) drop,
        drop
    )
    True >reachable
    List.Nil >env
    start-branch!
}

def c99-block-exit! [ Block +C99Branch -- +C99 ] {
    end-branch!
    reachable> drop
    env> drop
    options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def expose-stack-type! [ +C99Branch |- StackType -- ] {
    +mirth:expand match {
        { Cons -> type-to-c99-repr pop-value! rdip:expose-stack-type! push-value! }
        { With -> resource-to-c99-repr pop-resource! rdip:expose-stack-type! push-resource! }
        { ConsLabel ->
            >label type-to-c99-repr @label pop-value-label!
            rdip:expose-stack-type! label> push-value-label! }
        { WithLabel ->
            >label resource-to-c99-repr @label pop-resource-label!
            rdip:expose-stack-type! label> push-resource-label! }
        { _ -> drop }
    }
}

def c99-word-enter! [ +C99Branch |- Word -- ] {
    +c99:options emit-debug-info then(
        c99-line(
            "WORD_ENTER(" put
            dup +mirth(name >Str) put-cstr ", " put
            dup +mirth(body module source-path) >Str put-cstr ", " put
            dup +mirth(body row) >Int >Str put ", " put
            dup +mirth(body col) >Int >Str put ");" put
        )
    ) drop
}

def c99-word-exit! [ +C99Branch |- Word -- ] {
    +c99:options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def c99-word-defs! [ +C99 |- ] { Word.for(dup +needs(needed?) if(c99-word-def!, drop)) }
def c99-word-def! [ +C99 |- Word -- ] {
    dup c99-api c99-smart-def! (
        dup c99-word-enter!
        dup +mirth:arrow c99-arrow!
        dup c99-word-exit!
    )
    drop
}

def c99-field-defs! [ +C99 |- ] { Field.for(c99-field-def!) }
def c99-field-def! [ +C99 |- Field -- ] { c99-line("static FIELD " put +mirth:cname put " = {0};" put) }
def c99-field-call! [ +C99Branch |- Field -- ] {
    C99ReprType.U64 pop-value! >+index
    C99ReprType.PTR push-value-expression! (
        "field_mut(&" put
        +mirth:cname put
        ", " put
        +index> C99ReprType.U64 consume-as put
        ")" put
    )
}

def c99-main! [ +C99 |- Arrow -- ] {
    c99-line("int main (int argc, char** argv) {" put)
    reset-fresh-counter!
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        options emit-debug-info then(
            c99-line("WORD_ENTER(" put
                "\"<main>\", " put
                dup token-start +mirth(module source-path) >Str put-cstr ", " put
                dup token-start +mirth:row >Int >Str put ", " put
                dup token-start +mirth:col >Int >Str put ");" put)
        )
        True >reachable
        List.Nil >env
        start-branch!
        C99ReprType.I64 push-resource-expression!("0 /* The World! */" put)
        c99-arrow!
        end-branch!
        env> drop
        reachable> drop
        options emit-debug-info then(
            c99-line("WORD_EXIT;" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put)
}
