module mirth.c99

import std.prelude
import std.str
import std.path
import std.list
import std.byte
import std.maybe
import std.either
import std.file
import std.output

import mirth.mirth
import mirth.module
import mirth.location
import mirth.token
import mirth.name
import mirth.buffer
import mirth.arrow
import mirth.word
import mirth.table
import mirth.external
import mirth.tycon
import mirth.type
import mirth.data
import mirth.package
import mirth.prim
import mirth.var
import mirth.match
import mirth.elab
import mirth.need
import mirth.label
import mirth.def

#######
# C99 #
#######

struct C99_Options {
    output-path: Path
    emit-debug-info: Bool
}

struct +C99 {
    options: C99_Options
    depth: Nat
    fresh-counter: Nat
    put-enabled: Bool
    +needs: +Needs
    +output: +Output
}

def +C99.put      [ +Mirth +C99 |- Str --  ] { put-enabled if(+output:put, drop) }
def +C99.put-byte [ +Mirth +C99 |- Byte -- ] { put-enabled if(+output:put-byte, drop) }
def +C99.line     [ +Mirth +C99 |-         ] { put-enabled then(+output:line) }

def run-output-c99! [ +World +Mirth |- Arrow C99_Options -- ] {
    num-errors 0> if(
        "There were errors, so codegen stopped." rdip:trace
        panic-diagnostics!
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-field-defs!
        c99-data-defs!
        c99-tag-defs!
        c99-buffers!
        c99-external-blocks!
        c99-word-sigs!
        c99-block-sigs!
        c99-main!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    )
}

def c99-start! [ +World +Mirth Arrow |- C99_Options -- +C99 ] {
    >options
    0u >depth
    0u >fresh-counter
    True >put-enabled
    +Needs.New dup determine-arrow-needs! >+needs
    @options output-path create-file! +else(io-error!) +Output.start! >+output
    +C99
}

def c99-end! [ +World +Mirth |- +C99 -- ] {
    /+C99 +output> end! close-file! for(io-error!) ldrop
}

def +C99.reset-fresh-counter! [ +Mirth +C99 |- ] {
    0u fresh-counter!
}

def +C99.fresh-nat! [ +Mirth +C99 |- Nat ] {
    fresh-counter
    dup 1+ fresh-counter!
}

def +C99.with-fresh-counter(f) [ +Mirth +C99 |- ( *a -- *b ) *a Nat -- *b Nat ] {
    fresh-counter dip(fresh-counter! f fresh-counter) fresh-counter!
}

def +C99.fresh-name-on!       [ +Mirth +C99 |- Str -- Str ] { fresh-nat! >Str cat }
def +C99.fresh-name!          [ +Mirth +C99 |-        Str ] { "v" fresh-name-on! }
def +C99.fresh-resource-name! [ +Mirth +C99 |-        Str ] { "r" fresh-name-on! }

field(Tag.~word-cname, Tag, Str)
field(Tag.~pat-cname, Tag, Str)
field(Buffer.~cname, Buffer, Str)
field(Field.~cname, Field, Str)
field(External.~cname, External, Str)
field(Prim.~cname, Prim, Str)

def Tag.word-cname [ +Mirth |- Tag      -- Str ] { dup ~word-cname memoize(dup qname      Str("mtw_"  ; mangled;)) nip }
def Tag.pat-cname  [ +Mirth |- Tag      -- Str ] { dup ~pat-cname  memoize(dup qname      Str("mtp_"  ; mangled;)) nip }
def Buffer.cname   [ +Mirth |- Buffer   -- Str ] { dup ~cname      memoize(dup qname-hard Str("mbuf_" ; mangled;)) nip }
def Field.cname    [ +Mirth |- Field    -- Str ] { dup ~cname      memoize(dup qname-hard Str("mfld_" ; mangled;)) nip }
def External.cname [ +Mirth |- External -- Str ] { dup ~cname      memoize(dup qname-hard Str("mext_" ; mangled;)) nip }

embed-str(c99-header-str, "src/mirth.h")
def c99-header! [ +Mirth +C99 |- ] {
    "#define MIRTH_DEBUG " put
    options emit-debug-info if("1", "0") put line
    c99-header-str put line
}

def c99-buffers! [ +Mirth +C99 |- ] { Buffer.for(c99-buffer!) }
def c99-buffer! [ +Mirth +C99 |- Buffer -- ] {
    "static char " put
    dup cname put
    "[" put size >Str put "] = {0};" put line
}
def c99-buffer-call! [ +Mirth +C99Branch |- Buffer -- ] {
    C99ReprType.PTR push-value-expression!(cname put)
}

def c99-data-defs! [ +Mirth +C99 |- ] {
    Data.for(c99-repr prepare-type-sigs!)
    Data.for(c99-repr prepare-type-defs!)
}

def c99-tag-defs! [ +Mirth +C99 |- ] { Tag.for(c99-tag-def!) }
def c99-tag-def! [ +Mirth +C99 |- Tag -- ] {
    \tag @tag prefer-inline? else(
        @tag +needs:word-needed? then(
            @tag word-c99-api c99-smart-def!(
                @tag c99-tag-body!
            )
        )

        @tag +needs:pat-needed? then(
            @tag pat-c99-api c99-smart-def!(
                @tag c99-reverse-tag-body!
            )
        )
    )
}

def pop-stack-part-name! [ +Mirth +C99Branch |- StackTypePart -- Str ] {
    pop-stack-part! +for(consume,consume)
}

def pop-stack-part! [ +Mirth +C99Branch |- StackTypePart -- +C99Value/Resource ] {
    { ConsLabel -> dip:type-to-c99-repr pop-value-label! +C99Value/Resource.+Left }
    { WithLabel -> dip:resource-to-c99-repr pop-resource-label! +C99Value/Resource.+Right }
    { Cons -> type-to-c99-repr pop-value! +C99Value/Resource.+Left }
    { With -> resource-to-c99-repr pop-resource! +C99Value/Resource.+Right }
}

def c99-tag-body! [ +Mirth +C99Branch |- Tag -- ] {
    \tag @tag semi-transparent? if?(
        input pop-stack-part!
        @tag data C99ReprType.Data value/resource-repr!
        @tag outputs-resource? if(
            turn-into-resource! push-resource!,
            turn-into-value! push-value!
        ),

    @tag num-total-inputs 0= if(
        @tag data is-enum-or-unit? if(
            "" >pfx "" >sfx,
            "PTRMK(" >pfx ",0,0)" >sfx
            @tag c99-check-tag-value!
        )
        Str( pfx> ; @tag value-show ; "LL /* "; @tag name; " */" ; sfx> ; )
        @tag data C99ReprType.Data
        @tag outputs-resource? if(
            push-resource-expression!(put),
            push-value-expression!(put)
        ),

        @tag data c99-repr struct? if?(
            construct!,
            @tag c99-pack-tag!
        ) push-value/resource!
    ))
}

def C99ReprType.cast [ +Mirth |- Str C99ReprType -- Str ] {
    Str("((" ; underlying-c99-type ; ")(" ; ; "))" ;)
}

def push-stack-part-name! [ +Mirth +C99Branch |- Str StackTypePart -- ] {
    { ConsLabel -> dip(type-to-c99-repr dup >value-repr cast >value-name +C99Value) push-value-label! }
    { WithLabel -> dip(resource-to-c99-repr dup >resource-repr cast >resource-name +C99Resource) push-resource-label! }
    { Cons -> type-to-c99-repr dup >value-repr cast >value-name +C99Value push-value! }
    { With -> resource-to-c99-repr dup >resource-repr cast >resource-name +C99Resource push-resource! }
}

def push-stack-part! [ +Mirth +C99Branch |- +C99Value/Resource StackTypePart -- ] {
    { ConsLabel -> nip turn-into-value! push-value-label! }
    { WithLabel -> nip turn-into-resource! push-resource-label! }
    { Cons -> drop turn-into-value! push-value! }
    { With -> drop turn-into-resource! push-resource! }
}

def c99-reverse-tag-body! [ +Mirth +C99Branch |- Tag -- ] {
    \tag @tag semi-transparent? if?(
        @tag data pop-data!
        input dup c99-repr value/resource-repr!
        push-stack-part!,

    @tag num-total-inputs 0= if(
        @tag data pop-data! +C99Value/Resource.rdrop, # decref is unnecessary

        @tag data pop-data!
        @tag data c99-repr struct? if?(
            destruct!,
            @tag c99-unpack-tag!
        )
    ))
}

def +C99.tag-value-put [ +Mirth +C99 |- Tag -- ] {
    dup value-show put "LL /* " put name >Str put " */" put
}

def c99-check-tag-value! [ +Mirth |- Tag -- ] {
    dup value 0x0 0xFFFF in-range if(
        drop,
        Str("Constructor "; qname; " enum value is out of range for C99 tuple representation (must be between 0 and 0xFFFF inclusive).";) fatal-error!
    )
}

def c99-pack-tag! [ +Mirth +C99Branch |- Tag -- +C99Value/Resource ] {
    \tag
    @tag inputs >parts
    @tag Some >tag
    c99-pack-tuple!
    @tag outputs-resource? if(
        +C99Value/Resource.+Right,
        turn-into-value! +C99Value/Resource.+Left
    )
}

def c99-pack-tuple! [ +Mirth +C99Branch |- tag:Maybe(Tag) parts:List(StackTypePart) -- +C99Resource ] {
    @parts len >tuplen
    @tag for(c99-check-tag-value!)
    @tag if?(data C99ReprType.Data, C99ReprType.TUP) resource-expression!(
        "PTRMK(" put
        @tag if?(tag-value-put, "0" put)
        "," put
        "tup_new(" put @tuplen >Str put
        "),0)" put) >+tup
    Str("((TUP*)PTRPTR("; @+tup:resource-name ; "))";) \tup
    c99-line(@tup put "->size = " put @tuplen >Str put ";" put)
    tuplen> pred \i
    parts> reverse-for(
        match {
            { Cons -> type-to-c99-repr pop-value! consume-as-VAL }
            { With -> resource-to-c99-repr pop-resource! consume-as-VAL }
            { ConsLabel -> dip:type-to-c99-repr pop-value-label! consume-as-VAL }
            { WithLabel -> dip:resource-to-c99-repr pop-resource-label! consume-as-VAL }
        }
        c99-line(@tup put "->cells[" put @i >Str put "] = " put put ";" put)
        @i:pred
    )
    tag> drop
    +tup>
}

def c99-unpack-tag! [ +Mirth +C99Branch |- Tag +C99Value/Resource -- ] {
    >tag
    @tag inputs >parts
    @tag:Some
    turn-into-resource!
    c99-unpack-tuple!
}

def c99-unpack-tuple! [ +Mirth +C99Branch |- +C99Resource tag:Maybe(Tag) parts:List(StackTypePart) -- ] {
    tag> if?(data C99ReprType.Data, C99ReprType.TUP) consume-as \ptup
    Str("((TUP*)PTRPTR(" ; @ptup ; "))";) \tup
    0 \i
    parts> for(
        Str(@tup ; "->cells[" ; @i int; "]" ;)
        swap match {
            { Cons -> type-to-c99-repr dup push-value-expression!(v-macro(put)) }
            { With -> resource-to-c99-repr dup push-resource-expression!(v-macro(put)) }
            { ConsLabel -> dip(type-to-c99-repr dup value-expression!(v-macro(put))) push-value-label! }
            { WithLabel -> dip(resource-to-c99-repr dup resource-expression!(v-macro(put))) push-resource-label! }
        }
        @i:succ
    )
    c99-line("tup_decref_outer(" put @ptup put ");" put)
}

def c99-tag-label-index [ +Mirth +C99 |- Tag Label -- Nat ] {
    Some \label inputs dup len >i
    reverse-find(@i:pred label @label =)
    drop i>
}

def c99-tag-get-label! [ +Mirth +C99Branch |- TagField -- ] {
    /TagField
    type/resource> \fieldty
    @tag data C99ReprType.Data \tagrepr
    @tag semi-transparent? if(
        @fieldty match {
            { Left -> # field is value
                type-to-c99-repr \fieldrepr
                @tag outputs-resource? if(
                    # wrapper is resource
                    @tagrepr pop-resource!
                    dup-resource-as-value!
                    push-resource!,

                    # wrapper is value
                    @tagrepr pop-value!
                )
                @fieldrepr value-repr!
                push-value!
            }

            { Right -> # field and wrapper are both resources
                resource-to-c99-repr \fieldrepr
                @tagrepr pop-resource!
                @fieldrepr resource-repr!
                push-resource!
                C99ReprType.Void push-resource-expression!("0" put)
            }
        },

        @tag data pop-data! >+datavar
        @+datavar:rdup @tag data consume-as-data >datavar
        @fieldty match {
            { Left -> # field is value
                type-to-c99-repr value-expression!(
                    @datavar put "->m" put @label name mangled put
                ) keep-value! push-value!
                +datavar> +for(drop-value!, push-resource!)
            }
            { Right -> # field and data are resources
                resource-to-c99-repr push-resource-expression!(
                    @datavar put "->m" put @label name mangled put
                )
                +datavar> push-value/resource!
            }
        }
        datavar> drop
    )
    label> tag> drop2
}

def c99-tag-set-label! [ +Mirth +C99Branch |- TagField -- ] {
    /TagField
    type/resource> >fieldty
    @tag data C99ReprType.Data \tagrepr
    @tag semi-transparent? if(
        fieldty> match {
            { Left -> # field is value
                type-to-c99-repr \fieldrepr
                @tag data pop-data! +for(
                    drop-value!
                    @fieldrepr pop-value!
                    @tagrepr value-repr!
                    push-value!,

                    drop-resource-as-value!
                    @fieldrepr pop-value!
                    turn-into-resource!
                    @tagrepr resource-repr!
                    push-resource!
                )
            }
            { Right -> # field and wrapper are resource
                resource-to-c99-repr \fieldrepr
                C99ReprType.Void pop-resource! +C99Resource.rdrop # vacant wrapper is unit
                @fieldrepr pop-resource!
                @tagrepr resource-repr!
                push-resource!
            }
        },

        @tag data c99-repr struct? unwrap("Expected struct repr" fatal-error!) \struct-repr
        @tag data pop-data! >+datavar
        @fieldty match {
            { Left -> type-to-c99-repr dup dup pop-value! consume-as }
            { Right -> resource-to-c99-repr dup dup pop-resource! consume-as }
        } >fieldval \fieldrepr
        +datavar> +for (
            # field and data are both values
            @fieldrepr is-physical? if(
                consume >dataval
                @tag data C99ReprType.Data push-value-expression!(
                    @struct-repr cname put "_set_" put @label name mangled put "(" put
                    dataval> put
                    ", " put
                    fieldval> put
                    ")" put
                )
                fieldty> drop,

                fieldval> fieldty> drop2
                push-value!
            ),

            # data is resource
            >+datavar
            @+datavar:rdup @tag data consume-as-data >datavar
            fieldty> match {
                { Left -> # field is value
                    type-to-c99-repr \fieldrepr
                    @fieldrepr needs-refcounting? then (
                        @fieldrepr value-expression! (
                            @datavar put "->m" put @label name mangled put
                        ) drop-value!
                    )
                }
                { Right -> # field is resource
                    drop
                }
            }
            @fieldrepr is-physical? if(
                c99-line(
                    @datavar put "->m" put @label name mangled put " = " put
                    fieldval> put ";" put
                ),
                fieldval> drop
            )
            +datavar>
            push-resource!
            datavar> drop
        )
    )
    label> tag> drop2
}

def c99-table-to-index! [ +Mirth +C99Branch |- Table -- ] {
    C99ReprType.Table pop-value!
    C99ReprType.U64 value-repr!
    push-value!
}

def c99-table-from-index! [ +Mirth +C99Branch |- Table -- ] {
    C99ReprType.U64 pop-value!
    C99ReprType.Table value-repr!
    push-value!
}

def c99-external-blocks! [ +Mirth +C99 |- ] {
    ExternalBlock.for(c99-external-block!)
}
def c99-external-block! [ +Mirth +C99 |- ExternalBlock -- ] {
    parts for(match(
        EBPCode -> put line,
        EBPDef -> c99-external-def!
    ))
}

def External.cname-type [ +Mirth |- External -- Str ArrowType ] {
    dup cname swap type
}

field(External.~c99-api, External, C99API)
def External.c99-api [ +Mirth +C99 |- External -- C99API ] {
    dup ~c99-api memoize(dup cname-type cname-type-to-c99-api) nip
}
def c99-external-call! [ +Mirth +C99Branch |- List(Arg) External -- ] {
    +c99:c99-api c99-smart-call!
}

def c99-external-def! [ +Mirth +C99 |- External -- ] {
    >ext
    @ext ctype >cty

    @cty cod parts find(and(label? none?, ctype phantom? not)) >outty
    @outty if?(ctype, "void" CType.Void) cname put " " put
    @ext symbol put

    " (" put
    @cty dom parts filter(ctype phantom? not)
    match(
        Nil -> "void" put,
        _ -> for(ctype cname put, ", " put)
    )
    ");" put line

    @ext c99-api c99-smart-def! (
        @cty dom parts
        @ext type dom parts reverse \dom-parts
        dup len >arg-index
        reverse-for(
            @dom-parts:uncons unwrap("external unexpected domain" fatal-error!)
            pop-stack-part! dup ctype to-ctype-expr >expr
            dup ctype phantom? if(
                expr> drop,
                c99-line(
                    dup ctype cname put
                    " " put
                    dup c99-arg-name put
                    " = (" put
                    dup ctype cname put
                    ")(" put
                    expr> put
                    ");" put
                )
            )
            drop
            @arg-index:pred
        )

        c99-line(
            @outty for(ctype cname put " Y = " put)
            @ext symbol put "(" put

            1u !arg-index
            @cty dom parts filter-some(
                dup ctype phantom? if(drop None, c99-arg-name Some)
                @arg-index:1+
            )
            for(put, ", " put)
            ");" put
        )

        @ext type cod parts \cod-parts
        @cty cod parts for(
            dup ctype phantom? if(drop "0", label? if?(name mangled, "Y"))
            @cod-parts:uncons unwrap("external unexpected codomain" fatal-error!)
            push-stack-part-name!
        )
    )

    arg-index> drop
    ext> cty> outty> drop3
}

def CTypeStackPart.c99-arg-name [ +Mirth +C99 |- arg-index:Nat CTypeStackPart -- arg-index:Nat Str ] {
    label? if?(
        name mangled,
        Str("X" ; @arg-index int;)
    )
}

def CType.>C99ReprType [ CType -- C99ReprType ] {
    { UInt  -> drop C99ReprType.U64 }
    { Int   -> drop C99ReprType.I64 }
    { F32   -> drop C99ReprType.F32 }
    { F64   -> drop C99ReprType.F64 }
    { Ptr   -> drop C99ReprType.PTR }
    { FnPtr -> drop C99ReprType.FNPTR }
    { Void  -> drop C99ReprType.Void }
}

def to-ctype-expr [ +Mirth |- +C99Value/Resource CType -- Str ] {
    { FnPtr -> drop C99ReprType.FNPTR consume-as }
    { _ -> drop consume }
}


def CTypeStackPart.c99-ctype-pop [ +Mirth +C99Branch StackType |- CTypeStackPart -- Str ] {
    { Cons -> drop pop-value-from-stack-type! consume }
    { With -> drop pop-resource-from-stack-type! consume }
    { ConsLabel -> nip swap pop-value-label-from-stack-type! consume }
    { WithLabel -> nip swap pop-resource-label-from-stack-type! consume }
}

def CTypeStackPart.c99-ctype-push [ +Mirth +C99Branch List(StackTypePart) |- Str CTypeStackPart -- ] {
    { Cons -> >C99ReprType dup push-value-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { With -> >C99ReprType dup push-resource-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { ConsLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
    { WithLabel -> dip(>C99ReprType dup) push-label-expression!("(" put underlying-c99-type put ")(" put put ")" put) }
}

def +C99.indent [ +Mirth +C99 |- ] { depth repeat("\t" put) }
def +C99.c99-nest(f) [ +Mirth +C99 |- (*a -- *b) *a -- *b ] { depth:succ f depth:pred }
def +C99.c99-line(f) [ +Mirth +C99 |- (*a -- *b) *a -- *b ] {
    indent f line
}
def +C99.c99-line-if(f) [ +Mirth +C99 |- (*a -- *b) *a Bool -- *b ] {
    put-enabled(tuck and)
    dip:c99-line(f)
    put-enabled!
}

def +C99Branch.c99-line(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a -- *b ] {
    reachable +c99:c99-line-if(f)
}
def +C99Branch.c99-line-if(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a Bool -- *b ] {
    reachable and +c99:c99-line-if(f)
}
def +C99Branch.c99-nest(f) [ +Mirth +C99Branch |- (*a -- *b) *a -- *b ] {
    +c99:depth:succ f +c99:depth:pred
}

data C99APIArgSource {
    Value
    ValueLabel [ Label ]
    Resource
    ResourceLabel [ Label ]
}

data C99APIArgMode {
    In
    Out
    InOut
    Branch
}

def C99APIArgMode.mode-arg-prefix {
    { In     -> "in_"    }
    { Out    -> "out_"   }
    { InOut  -> "inout_" }
    { Branch -> "branch_"  }
}

struct C99APIArg {
    arg-mode: C99APIArgMode
    arg-source: C99APIArgSource
    arg-repr: C99ReprType
    arg-name: Str
}

def C99APIArg.is-physical? [ +Mirth |- C99APIArg -- Bool ] {
    arg-repr is-physical?
}

def C99APIArg.is-physical-value? [ +Mirth |- C99APIArg -- Bool ] {
    dup is-physical? if(
        arg-source match {
            { Value -> True }
            { ValueLabel -> drop False }
            { _ -> drop False }
        },
        drop False
    )
}

def C99APIArg.pop-consume! [ +Mirth +C99Branch |- C99APIArg -- Str ] {
    sip(arg-repr dup) arg-source match {
        { Value -> pop-value! consume-as }
        { Resource -> pop-resource! turn-into-value! consume-as }
        { ValueLabel -> pop-value-label! consume-as }
        { ResourceLabel -> pop-resource-label! turn-into-value! consume-as }
    }
}

def C99APIArg.pop-consume-physical! [ +Mirth +C99Branch |- C99APIArg -- Maybe(Str) ] {
    sip:pop-consume!
    is-physical? if(
        Some,
        drop None
    )
}

def C99APIArg.pop-to-reserved! [ +Mirth +C99Branch |- C99APIArg -- ] {
    dup pop-consume-physical! if?(
        c99-line(swap arg-name put " = " put put ";" put),
        drop
    )
}

def C99APIArg.push-to! [ +Mirth +C99Branch |- Str C99APIArg -- ] {
    sip:arg-repr arg-source match {
        { Value -> push-value-expression!(put) }
        { Resource -> push-resource-expression!(put) }
        { ValueLabel -> push-label-expression!(put) }
        { ResourceLabel -> push-label-expression!(put) }
    }
}

def C99APIArg.push-api-arg! [ +Mirth +C99Branch |- C99APIArg -- ] {
    /C99APIArg
    arg-name> >value-name
    arg-repr> >value-repr
    arg-mode> drop
    +C99Value
    arg-source> match {
        { Value -> push-value! }
        { ValueLabel -> push-value-label! }
        { Resource -> turn-into-resource! push-resource! }
        { ResourceLabel -> turn-into-resource! push-resource-label! }
    }
}

struct C99API {
    cname: Str
    type: ArrowType
    in-params: List(C99APIArg)
    out-params-1: List(C99APIArg)
    return-param: Maybe(C99APIArg)
    out-params-2: List(C99APIArg)
    must-flush: Bool
    doesnt-return: Bool
}

def name-arg-prefix [ +Mirth |- Name -- Str ] {
    mangled "_" cat
}

def type-arg-prefix [ +Mirth |- Type -- Str ] {
    { Meta -> expand-if(type-arg-prefix, drop "") }
    { Var -> name name-arg-prefix }
    { Table -> name name-arg-prefix }
    { Data -> name name-arg-prefix }
    { DataPartial -> .data name name-arg-prefix }
    { App -> drop type-arg-prefix }
    { Mut -> dip("Mut") type-arg-prefix cat }
    { Prim -> match {
        { KIND -> "KIND_" }
        { TYPE -> "TYPE_" }
        { STACK -> "STACK_" }
        { RESOURCE -> "RESOURCE_" }
        { Bool -> "Bool_" }
        { Int -> "Int_" }
        { Nat -> "Nat_" }
        { U8  -> "U8_" }
        { U16 -> "U16_" }
        { U32 -> "U32_" }
        { U64 -> "U64_" }
        { I8  -> "I8_" }
        { I16 -> "I16_" }
        { I32 -> "I32_" }
        { I64 -> "I64_" }
        { F32 -> "F32_" }
        { F64 -> "F64_" }
        { Ptr -> "Ptr_" }
        { Str -> "Str_" }
        { Array -> "Array_" }
        { World -> "World_" }
        { Debug -> "Debug_" }
    } }
    { _ -> drop "_" }
}

def fresh-arg-name! [ +Mirth +C99 arg-mode:C99APIArgMode arg-repr:C99ReprType |- Type -- Str ] {
    @arg-repr is-physical? if(
        dip(@arg-mode mode-arg-prefix) type-arg-prefix cat fresh-name-on!,
        drop "0"
    )
}

def cons-fresh-arg! [ +Mirth +C99 arg-mode:C99APIArgMode |- List(C99APIArg) Type C99APIArgSource -- List(C99APIArg) ] {
    >arg-source
    dup c99-repr >arg-repr
    fresh-arg-name! >arg-name
    @arg-mode >arg-mode
    C99APIArg swap cons
}

def +C99.stack-type-to-c99-api-params-aux [ +Mirth +C99 arg-mode:C99APIArgMode |- StackType -- must-flush:Bool List(C99APIArg) ] {
    { Unit -> False >must-flush List.Nil }
    { Error -> True >must-flush List.Nil }
    { Ignore -> True >must-flush List.Nil }
    { Meta ->
        expand-if(
            >StackType stack-type-to-c99-api-params-aux,
            drop True >must-flush List.Nil
        )
    }
    { Var -> drop True >must-flush List.Nil }
    { Cons -> C99APIArgSource.Value dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { With -> C99APIArgSource.Resource dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { ConsLabel -> C99APIArgSource.ValueLabel dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
    { WithLabel -> C99APIArgSource.ResourceLabel dip:>Type dip2:stack-type-to-c99-api-params-aux cons-fresh-arg! }
}

def +C99.stack-type-to-c99-api-params [ +Mirth +C99 |- StackType C99APIArgMode -- must-flush:Bool List(C99APIArg) ] {
    \arg-mode
    +C99.stack-type-to-c99-api-params-aux reverse
}

def +C99.cname-type-to-c99-api [ +Mirth +C99 |- Str ArrowType -- C99API ] {
    >type >cname
    1u with-fresh-counter (
        @type dom C99APIArgMode.In  stack-type-to-c99-api-params >in-params
        @type cod C99APIArgMode.Out stack-type-to-c99-api-params
        split-at(is-physical-value?) uncons
        >out-params-2 >return-param >out-params-1
    ) drop
    must-flush> must-flush> or >must-flush
    @type cod linear-base-var? if?(
        @type dom linear-base-var? if?(
            <>,
            drop False
        ),
        False
    ) >doesnt-return
    @doesnt-return not @must-flush:and
    C99API
}

def C99APIArg.reserve-as-new-value! [ +Mirth +C99Branch |- C99APIArg -- C99APIArg ] {
    dup is-physical? if(
        dup arg-repr new-value!
        consume swap arg-name!,
        "0" swap arg-name!
    )
}

def C99APIArg.reserve-as-is! [ +Mirth +C99Branch |- C99APIArg -- ] {
    dup \arg is-physical? then(
        c99-line(
            @arg arg-repr underlying-c99-type put " " put
            @arg arg-name put ";" put
        )
    )
}

def C99APIArg.reserve-new-expression! [ +Mirth +C99Branch |- Str C99APIArg -- C99APIArg ] {
    >arg
    +c99:fresh-name! @arg:arg-name!
    c99-line (
        @arg arg-repr underlying-c99-type put " " put
        @arg arg-name put " = " put
        put ";" put
    )
    arg>
}

def c99-smart-call! [ +Mirth +C99Branch |- List(Arg) C99API -- ] {
    >api
    c99-args-push!
    @api in-params reverse map(pop-consume-physical!) reverse >popped-inputs
    @api must-flush then(flush-cache!)
    @api out-params-1 map(reserve-as-new-value!) >reserved-outputs-1
    @api out-params-2 map(reserve-as-new-value!) >reserved-outputs-2
    Str(
        @api cname ; "(" ;
        "" >sep
        popped-inputs> for:for(sep> ; ", " >sep ;)
        @reserved-outputs-1 @reserved-outputs-2 cat for(
            dup is-physical?
            if(sep> ; ", " >sep "&" ; arg-name ;, drop)
        )
        sep> drop
        ")" ;
    )
    @api return-param if?(
        @api doesnt-return if(
            swap c99-line("(void)" put put ";" put) Some,
            reserve-new-expression! Some
        ),
        c99-line(put ";" put) None
    ) >reserved-return
    api> doesnt-return not reachable:and
    reserved-outputs-1> for(push-api-arg!)
    reserved-return>    for(push-api-arg!)
    reserved-outputs-2> for(push-api-arg!)
}

def +C99.smart-sig-put [ +Mirth +C99 |- C99API -- ] {
    >api
    "static " put
    @api return-param if?(
        arg-repr underlying-c99-type put,
        "void" put
    )
    " " put
    @api cname put
    " (" put
    "" >sep
    @api in-params filter(is-physical?) for(
        sep> put ", " >sep
        dup arg-repr underlying-c99-type put
        " " put arg-name put
    )
    @api out-params-1 @api out-params-2 cat filter(is-physical?) for(
        sep> put ", " >sep
        dup arg-repr underlying-c99-type put
        " *" put arg-name put
    )
    sep> empty? then("void" put)
    ")" put
    api> drop
}

def c99-smart-sig! [ +Mirth +C99 |- C99API -- ] {
    c99-line(smart-sig-put ";" put)
}

def c99-api-enter! [ +Mirth |- +C99 C99API -- +C99Branch ] {
    >api
    @api in-params len
    @api out-params-1 len +
    @api out-params-2 len +
    @api return-param then(1+)
    1+ fresh-counter!
    True >reachable
    List.Nil >env
    start-branch!
    @api in-params for(push-api-arg!)
    api> drop
}

def c99-api-exit! [ +Mirth |- +C99Branch C99API -- +C99 ] {
    \api
    @api out-params-2 reverse-for(
        dup pop-consume-physical! if?(
            swap arg-name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    @api return-param map(pop-consume!)
    @api out-params-1 reverse-for(
        dup pop-consume-physical! if?(
            swap arg-name c99-line("*" put put " = " put put ";" put),
            drop
        )
    )
    end-branch!
    reachable> if(
        for(c99-line("return " put put ";" put)),
        drop @api return-param for(
            arg-repr dummy-value
            c99-line("return " put put "; /* unreachable */" put)
        )
    )
    env> drop
}

def c99-smart-def! (f) [ (+Mirth +C99Branch |- *a -- *b) +Mirth +C99 |- *a C99API -- *b ] {
    c99-line(dup smart-sig-put " {" put)
    c99-nest(
        dup dip(c99-api-enter! f)
        c99-api-exit!
    )
    c99-line("}" put)
}

def c99-codip-arrow! [ +Mirth +C99Branch |- Arrow -- ] {
    dup type /ArrowType
    cod> split-parts >cod-parts >cod-base
    dom> split-parts >dom-parts >dom-base
    cod-base> unit? dom-base> unit? and if(
        dom-parts> dip-parts( +stack(+C99Stack.+Nil) )
        c99-arrow!
        cod-parts> dip-parts(
            +stack(+C99Stack.rdrop)
        ),

        cod-parts> dom-parts> drop2
        c99-arrow!
    )
}

def +C99Branch.dip-parts(f) [ +Mirth +C99Branch |- (*a -- *b) *a List(StackTypePart) -- *b ] {
    pop-stack!
    rdip (f)
    push-stack!
}

||| Pop stack parts (right-to-left) into a separate stack cache.
def +C99Branch.pop-stack! [ +Mirth +C99Branch |- List(StackTypePart) -- +C99Stack ] {
    +C99Stack.+Nil reverse-for(pop-stack-part-to-stack!)
}

||| Pop a part from branch to separate stack.
def +C99Stack.pop-stack-part-to-stack! [ +Mirth +C99Branch +C99Stack |- StackTypePart -- ] {
    { Cons -> rdip(type-to-c99-repr pop-value!) rswap +C99Stack.+Cons }
    { With -> rdip(resource-to-c99-repr pop-resource!) rswap +C99Stack.+With }
    { ConsLabel -> rdip(dip:type-to-c99-repr tuck pop-value-label!) rswap +C99Stack.+ConsLabel }
    { WithLabel -> rdip(dip:resource-to-c99-repr tuck pop-resource-label!) rswap +C99Stack.+WithLabel }
}

def +C99Stack.reverse-cat! [ +Mirth |- +C99Stack +C99Stack -- +C99Stack ] {
    while ( match {
        { +Nil -> +C99Stack.+Nil False }
        { +Cons -> rswap rdip:+C99Stack.+Cons True }
        { +With -> rswap rdip:+C99Stack.+With True }
        { +ConsLabel -> rswap rdip:+C99Stack.+ConsLabel True }
        { +WithLabel -> rswap rdip:+C99Stack.+WithLabel True }
    } ) +C99Stack.rdrop
}

||| Push stack onto branch, right to left.
def +C99Stack.push-stack! [ +Mirth +C99Branch |- +C99Stack -- ] {
    rswap +stack(rswap reverse-cat!)
}

def c99-arrow! [ +Mirth +C99Branch |- Arrow -- ] { atoms for(c99-atom!) }
def c99-atom! [ +Mirth +C99Branch |- Atom -- ] {
    +c99:options emit-debug-info and(dup op show-in-stack-trace?) then(
        +c99:c99-line("WORD_ATOM(" put
            dup token row >Int >Str put ", " put
            dup token col >Int >Str put ", " put
            dup token name? if?(>Str, "") put-cstr
            ");" put
        )
    )
    dup op
    c99-atom-op!
}

def Op.show-in-stack-trace? [ +Mirth |- Op -- Bool ] {
    { Push -> drop False }
    { Word -> prefer-inline? not }
    { External -> drop True }
    { Buffer -> drop False }
    { Field -> drop False }
    { Tag -> drop False }
    { Prim -> drop True }
    { Match -> drop False }
    { Lambda -> drop False }
    { Var -> drop False }
    { BlockPush -> drop False }
    { BlockRun -> drop False }
    { LabelPush -> drop False }
    { LabelPop -> drop False }
    { LabelPushR -> drop False }
    { LabelPopR -> drop False }
    { DataGetEnumValue -> drop False }
    { DataFromEnumValue -> drop False }
    { DataGetLabel -> drop False }
    { DataSetLabel -> drop False }
    { TableToIndex -> drop False }
    { TableFromIndex -> drop False }
}

def c99-atom-op! [ +Mirth +C99Branch |- Atom Op -- ] {
    { Push -> nip c99-push-value! }
    { Word          -> dip:args c99-word! }
    { External      -> dip:args c99-external-call! }
    { Buffer        -> nip c99-buffer-call! }
    { Field         -> nip c99-field-call! }
    { Tag           -> dip:args c99-tag-call! }
    { Prim          -> c99-prim! }
    { Match         -> nip c99-match! }
    { Lambda        -> nip c99-lambda! }
    { Var           -> nip c99-var! }
    { BlockPush     -> nip c99-block-push! }
    { BlockRun      -> nip c99-block-run! }
    { LabelPush     -> c99-label-push! }
    { LabelPop      -> c99-label-pop! }
    { LabelPushR    -> c99-label-push-r! }
    { LabelPopR     -> c99-label-pop-r! }
    { DataGetEnumValue -> nip c99-get-enum-value! }
    { DataFromEnumValue -> nip c99-from-enum-value! }
    { DataGetLabel  -> c99-tag-get-label! drop }
    { DataSetLabel  -> c99-tag-set-label! drop }
    { TableToIndex -> c99-table-to-index! drop }
    { TableFromIndex -> c99-table-from-index! drop }
}

def c99-push-value! [ +Mirth +C99Branch |- PushValue -- ] {
    { Str -> c99-str! }
    { Int -> c99-int! }
    { Nat -> c99-nat! }
    { U8  -> C99ReprType.U8  push-value-expression!(>Nat >Str put) }
    { U16 -> C99ReprType.U16 push-value-expression!(>Nat >Str put) }
    { U32 -> C99ReprType.U32 push-value-expression!(>Nat >Str put) }
    { U64 -> C99ReprType.U64 push-value-expression!(>Nat >Str put "ULL" put) }
    { I8  -> C99ReprType.I8  push-value-expression!(>Int >Str put) }
    { I16 -> C99ReprType.I16 push-value-expression!(>Int >Str put) }
    { I32 -> C99ReprType.I32 push-value-expression!(
        dup I32.Min = if(drop "INT32_MIN" put, >Int >Str put)) }
    { I64 -> C99ReprType.I64 push-value-expression!(
        dup I64.Min = if(drop "INT64_MIN" put, >Int >Str put "LL" put)) }
    { F32 -> C99ReprType.F32 push-value-expression!(>Str put) }
    { F64 -> C99ReprType.F64 push-value-expression!(>Str put) }
}

def c99-get-enum-value! [ +Mirth +C99Branch |- Data -- ] {
    pop-data!
    C99ReprType.I64 push-value-expression!( peek-data-tag put )
    +for(drop-value!, push-resource!)
}

def c99-from-enum-value! [ +Mirth +C99Branch |- Data -- ] {
    dup is-enum? else("from-enum-value-unsafe on non-enum data type" fatal-error!)
    dup is-resource? then("from-enum-value-unsafe on resource" fatal-error!)
    C99ReprType.I64 pop-value!
    C99ReprType.Data value-repr!
    push-value!
}

def c99-word! [ +Mirth +C99Branch |- List(Arg) Word -- ] {
    dup prefer-inline? if(
        dip:c99-args-push!
        arrow c99-codip-arrow!,
        +c99:c99-api c99-smart-call!
    )
}

field(Tag.~value-show, Tag, Str)
def Tag.value-show [ +Mirth |- Tag -- Str ] { dup ~value-show memoize(dup value >Str) nip }

def c99-tag-call! [ +Mirth +C99Branch |- List(Arg) Tag -- ] {
    dup prefer-inline? if(
        nip c99-tag-body!,
        +c99:word-c99-api c99-smart-call!
    )
}

def c99-reverse-tag! [ +Mirth +C99Branch |- Tag -- ] {
    dup prefer-inline? if(
        c99-reverse-tag-body!,
        dip:List.Nil +c99:pat-c99-api c99-smart-call!
    )
}

def c99-label-defs! [ +Mirth +C99 |- ] { Label.for( dup +needs(needed?) if(c99-label-def!, drop) ) }
def c99-label-def! [ +Mirth +C99 |- Label -- ] { "static STACK lbl_" put name mangled put " = {0};" put line }

def push-value-label-direct! [ +Mirth +C99Branch |- Label +C99Value -- ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-value-label! [ +Mirth +C99Branch |- Label +C99Value -- ] {
    rswap +stack(rswap +C99Stack.+ConsLabel)
}
def push-resource-label-direct! [ +Mirth +C99Branch |- Label +C99Resource -- ] {
    consume-as-VAL swap
    c99-line("lpush(&lbl_" put name mangled put ", " put put ");" put)
}
def push-resource-label! [ +Mirth +C99Branch |- Label +C99Resource -- ] {
    rswap +stack(rswap +C99Stack.+WithLabel)
}

def pop-value-label-direct! [ +Mirth +C99Branch |- C99ReprType Label -- +C99Value ] {
    \label
    dup >value-repr is-physical? if(
        +c99:fresh-name! >value-name
        c99-line(
            @value-repr underlying-c99-type put " " put
            @value-name put " = " put
            @value-repr v-macro("lpop(&lbl_" put @label name mangled put ")" put)
            ";" put
        ),
        "0" >value-name
        c99-line("lpop(&lbl_" put @label name mangled put ");" put)
    )
    +C99Value
}

def pop-resource-label-direct! [ +Mirth +C99Branch |- C99ReprType Label -- +C99Resource ] {
    \label
    dup >resource-repr is-physical? if(
        +c99:fresh-resource-name! >resource-name
        c99-line(
            @resource-repr underlying-c99-type put " " put
            @resource-name put " = " put
            @resource-repr v-macro("lpop(&lbl_" put @label name mangled put ")" put)
            ";" put
        ),
        "0" >resource-name
        c99-line("lpop(&lbl_" put @label name mangled put ");" put)
    )
    +C99Resource
}

def c99-label-push! [ +Mirth +C99Branch |- Atom Label -- ] {
    swap dom pop-value-from-stack-type! drop
    push-value-label!
}
def c99-label-push-r! [ +Mirth +C99Branch |- Atom Label -- ] {
    swap dom pop-resource-from-stack-type! drop
    push-resource-label!
}
def c99-label-pop! [ +Mirth +C99Branch |- Atom Label -- ] {
    swap dom pop-value-label-from-stack-type! drop
    push-value!
}
def c99-label-pop-r! [ +Mirth +C99Branch |- Atom Label -- ] {
    swap dom pop-resource-label-from-stack-type! drop
    push-resource!
}

def c99-f64! [ +Mirth +C99Branch |- F64 -- ] {
    C99ReprType.F64 push-value-expression!(>Str put)
}

def Int.I63Min [ Int ] { -0x4000_0000_0000_0000 }
def Int.I63Max [ Int ] {  0x3FFF_FFFF_FFFF_FFFF }
def Int.in-i63-range? [ Int -- Bool ] { Int.I63Min Int.I63Max in-range }
def Int.c99-radixes [ Int -- List(U32) ] {
    List(
        while(
            0x1_0000_0000 divmod >U32-wrap dup ;
            0x8000_0000u32 and 0= if(dup 0 <>, dup -1 <>)
        )
        drop
    )
}

def c99-int/nat! [ +Mirth +C99Branch |- Int C99ReprType -- ] {
    >value-repr dup in-i63-range? if(
        value-repr> push-value-expression!("WRAP_I63(" put >Str put "LL)" put),

        c99-radixes >rad
        @rad len >Str >size
        +c99:fresh-name! >name
        c99-line(
            "static struct BIG_S(" put @size put ") " put @name put
            " = { .refs=100, .cap=" put @size put ", .size=" put size> put
            ", .radix={" put rad> for( str:hex; put "," put ) "} };" put
        )
        c99-line(@name put ".refs++;" put)

        Str("WRAP_BIG(&" ; name> ; ")";) >value-name
        +C99Value push-value!
    )
}
def c99-int! [ +Mirth +C99Branch |- Int -- ] {      C99ReprType.Int c99-int/nat! }
def c99-nat! [ +Mirth +C99Branch |- Nat -- ] { >Int C99ReprType.Nat c99-int/nat! }

def c99-str! [ +Mirth +C99Branch |- Str -- ] {
    C99ReprType.STR new-value! >+str
    dup num-bytes 4090 bytes > if(
        c99-line("STRLIT(" put @+str:rdup consume put "," put)
        c99-nest(
            c99-line(dup put-cstr-long "," put)
            c99-line(dup num-bytes >Str put)
        )
        c99-line(");" put),

        c99-line("STRLIT(" put
            @+str:rdup consume put ", " put
            dup put-cstr ", " put
            dup num-bytes >Str put ");" put)
    ) drop

    +str> push-value!
}

def +C99.put-cstr-long [ +Mirth +C99 |- Str -- ] {
    False >avoid-hexdigit
    Byte.BQUOTE put-byte
    Byte.BNUL swap bytes-for(
        swap Byte.BLF = then(
            Byte.BQUOTE put-byte
            line indent
            Byte.BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    Byte.BQUOTE put-byte
    avoid-hexdigit> drop2
}

def +C99.put-cstr [ +Mirth +C99 |- Str -- ] {
    False >avoid-hexdigit
    Byte.BQUOTE put-byte bytes-for(c99-string-byte!) Byte.BQUOTE put-byte
    avoid-hexdigit> drop
}

def c99-string-byte! [ +Mirth +C99 avoid-hexdigit:Bool |- Byte -- ] {
    { B'\' ->   "\\\\" put False !avoid-hexdigit }
    { BQUOTE -> "\\\"" put False !avoid-hexdigit }
    { BHT ->    "\\t"  put False !avoid-hexdigit }
    { BLF ->    "\\n"  put False !avoid-hexdigit }
    { BCR ->    "\\r"  put False !avoid-hexdigit }
    { _ ->
        dup Byte.BSPACE Byte.B'~' in-range
        and(dup is-hexdigit @avoid-hexdigit and not) if(
            put-byte
            False !avoid-hexdigit,
            "\\x" put to-hexdigits dip(put-byte) put-byte
            True !avoid-hexdigit
        )
    }
}

data C99DataRepr {
    Unit   [ C99DataUnitRepr   ]  ### single tag, no field
    Enum   [ C99DataEnumRepr   ]  ### multiple tags, no fields
    Field  [ C99DataFieldRepr  ]  ### single tag, single-field data
    Struct [ C99DataStructRepr ]  ### single tag, multiple field data
    Sum    [ C99DataSumRepr    ]  ### multiple tags, some fields
    --
    def is-unit?    { Unit   -> drop True, _ -> drop False }
    def is-enum?    { Enum   -> drop True, _ -> drop False }
    def is-field?   { Field  -> drop True, _ -> drop False }
    def is-struct?  { Struct -> drop True, _ -> drop False }
    def is-sum?     { Sum    -> drop True, _ -> drop False }

    def unit?       { Unit   -> Some, _ -> drop None }
    def enum?       { Enum   -> Some, _ -> drop None }
    def field?      { Field  -> Some, _ -> drop None }
    def struct?     { Struct -> Some, _ -> drop None }
    def sum?        { Sum    -> Some, _ -> drop None }

    def need-refcounting? {
        { Unit   -> needs-refcounting? }
        { Enum   -> needs-refcounting? }
        { Field  -> needs-refcounting? }
        { Struct -> needs-refcounting? }
        { Sum    -> needs-refcounting? }
    }

    def underlying-c99-type [ +Mirth |- C99DataRepr -- Str ] {
        { Unit   -> underlying-c99-type }
        { Enum   -> underlying-c99-type }
        { Field  -> underlying-c99-type }
        { Struct -> underlying-c99-type }
        { Sum    -> underlying-c99-type }
    }

    def v-macro-prefix-suffix [ +Mirth |- C99DataRepr -- Str Str ] {
        { Unit   -> v-macro-prefix-suffix }
        { Enum   -> v-macro-prefix-suffix }
        { Field  -> v-macro-prefix-suffix }
        { Struct -> v-macro-prefix-suffix }
        { Sum    -> v-macro-prefix-suffix }
    }

    def mk-macro [ +Mirth |- Str C99DataRepr -- Str ] {
        { Unit   -> mk-macro }
        { Enum   -> mk-macro }
        { Field  -> mk-macro }
        { Struct -> mk-macro }
        { Sum    -> mk-macro }
    }

    def get-data-tag [ +Mirth |- Str C99DataRepr -- Str ] {
        { Unit   -> get-data-tag }
        { Enum   -> get-data-tag }
        { Field  -> get-data-tag }
        { Struct -> get-data-tag }
        { Sum    -> get-data-tag }
    }

    def prepare-type-sigs! [ +Mirth +C99 |- C99DataRepr -- ] {
        { Unit   -> prepare-type-sigs! }
        { Enum   -> prepare-type-sigs! }
        { Field  -> prepare-type-sigs! }
        { Struct -> prepare-type-sigs! }
        { Sum    -> prepare-type-sigs! }
    }

    def prepare-type-defs! [ +Mirth +C99 |- C99DataRepr -- ] {
        { Unit   -> prepare-type-defs! }
        { Enum   -> prepare-type-defs! }
        { Field  -> prepare-type-defs! }
        { Struct -> prepare-type-defs! }
        { Sum    -> prepare-type-defs! }
    }
}

struct C99DataUnitRepr {
    tag: Tag
    --
    def needs-refcounting? { drop False }
    def underlying-c99-type { drop "void" }
    def v-macro-prefix-suffix { drop "" "" }
    def mk-macro { drop }
    def get-data-tag { nip tag value-show "LL" cat }
    def prepare-type-sigs! [ +Mirth +C99 |- C99DataUnitRepr -- ] { drop }
    def prepare-type-defs! [ +Mirth +C99 |- C99DataUnitRepr -- ] { drop }
}

struct C99DataEnumRepr {
    data: Data
    --
    def needs-refcounting? { drop False }
    def underlying-c99-type { drop "int64_t" }
    def v-macro-prefix-suffix { drop "VI64(" ")" }
    def mk-macro { drop Str( "MKI64(" ; ; ")" ; ) }
    def get-data-tag { drop }
    def prepare-type-sigs! [ +Mirth +C99 |- C99DataEnumRepr -- ] { drop }
    def prepare-type-defs! [ +Mirth +C99 |- C99DataEnumRepr -- ] { drop }
}

struct C99DataFieldRepr {
    tag: Tag
    input: StackTypePart
    c99-repr: C99ReprType
    --
    def needs-refcounting? { c99-repr needs-refcounting? }
    def underlying-c99-type { c99-repr underlying-c99-type }
    def v-macro-prefix-suffix { c99-repr v-macro-prefix-suffix }
    def mk-macro { c99-repr mk-macro }
    def get-data-tag { nip tag value-show "LL" cat }
    def prepare-type-sigs! [ +Mirth +C99 |- C99DataFieldRepr -- ] { drop }
    def prepare-type-defs! [ +Mirth +C99 |- C99DataFieldRepr -- ] { drop }
}

struct C99DataStructRepr {
    tag: Tag
    cname: Str
    fields: List(C99DataStructField)
    --

    def Make [ +Mirth |- Tag -- C99DataStructRepr ] {
        >tag
        @tag only-tag? if(@tag data cname, @tag qname mangled) >cname
        @tag inputs c99-inputs-to-struct-fields >fields
        C99DataStructRepr
    }

    def data [ +Mirth |- C99DataStructRepr -- Data ] { tag data }

    def needs-refcounting? { drop True }
    def underlying-c99-type [ +Mirth |- C99DataStructRepr -- Str ] {
        Str("struct "; cname ; "*";)
    }
    def v-macro-prefix-suffix [ +Mirth |- C99DataStructRepr -- Str Str ] {
        Str( "V_" ; cname ; "(" ; ) ")"
    }
    def mk-macro [ +Mirth |- Str C99DataStructRepr -- Str ] {
        Str( "MK_" ; cname ; "(" ; ; ")" ; )
    }
    def get-data-tag { nip tag value-show "LL" cat }
    def prepare-type-sigs! [ +Mirth +C99 |- C99DataStructRepr -- ] {
        \self
        c99-line("struct " put @self cname put " { " put)
        c99-nest(
            c99-line("REFS refs;" put)
            @self fields for(
                \field
                @field is-physical? then(
                    c99-line(
                        @field c99-repr underlying-c99-type put " "
                        put @field cname put ";" put
                    )
                )
            )
        )
        c99-line("};" put)
        c99-line(
            "MKTYPE_REFS(" put
            "TYPE_" put @self cname put "," put
            @self tag data name >Str put-cstr "," put
            @self cname put "," put
            "sizeof(void*),);" put
        )
        c99-line(
            "#define TAG_" put @self cname put
            " (REFS_FLAG | (TAG)&TYPE_" put @self cname put ")" put
        )
        c99-line(
            "#define MK_" put @self cname put "(x) " put
            "((VAL){.tag=TAG_" put @self cname put ", .data.ptr=(x)})" put
        )
        c99-line(
            "#define V_" put @self cname put "(v) " put
            "((struct " put @self cname put "*)((v).data.ptr))" put
        )
    }
    def prepare-type-defs! [ +Mirth +C99 |- C99DataStructRepr -- ] {
        \self
        c99-line(
            "gen_peek_poke(" put
            @self cname put "," put
            "MK_" put @self cname put "," put
            "V_" put @self cname put "," put
            "ptrs)" put
        )
        c99-line("static void " put @self cname put "_free (VAL vself) {" put)
        c99-nest(
            c99-line("ASSERT(vself.tag == TAG_" put @self cname put ");" put)
            c99-line(@self underlying-c99-type put " self = vself.data.ptr;" put)
            @self fields for(
                \field
                @field c99-repr needs-refcounting? then(
                    c99-line(
                        "decref(" put
                        Str("self->" ; @field cname ;)
                        @field c99-repr mk-macro put
                        ");" put
                    )
                )
            )
            c99-line("free(self);" put)
        )
        c99-line("}" put)

        c99-line("static void " put @self cname put "_trace_ (VAL vself, int fd) {" put)
        c99-nest(
            Str("<" ; @self data name >Str ; ">" ;) \msg
            c99-line("write(fd, " put @msg put-cstr ", " put @msg num-bytes >Str put ");" put)
        )
        c99-line("}" put)

        @self fields for( \field
            @field label? filter(
                drop
                @self data is-resource? not
                @field is-resource? not and
                @field is-physical? and
            ) for ( \label
                c99-line(
                    "static " put @self underlying-c99-type put " " put
                    @self cname put "_set_" put @label name mangled put
                    "(" put @self underlying-c99-type put " self, " put
                        @field c99-repr underlying-c99-type put " x" put
                    ") {" put
                )
                c99-nest(
                    c99-line("if (self->refs == 1) {" put )
                    c99-nest(
                        @field c99-repr needs-refcounting? then(
                            c99-line(
                                "decref(" put
                                Str("self->" ; @field cname ;)
                                @field c99-repr mk-macro put
                                ");" put
                            )
                        )
                        c99-line("self->" put @field cname put " = x;" put)
                        c99-line("return self;" put)
                    )
                    c99-line("}" put)
                    c99-line(@self underlying-c99-type put " self2 = calloc(1, sizeof * self2);" put)
                    c99-line("ASSERT(self2); memcpy(self2, self, sizeof * self2);" put)
                    @self fields for(\field2
                        @field cname @field2 cname = if(
                            c99-line("self2->" put @field cname put " = x;" put),
                            @field2 c99-repr needs-refcounting? then(
                                c99-line(
                                    "incref(" put
                                    Str("self2->"; @field2 cname ;)
                                    @field2 c99-repr mk-macro put
                                    ");" put
                                )
                            )
                        )
                    )
                    c99-line("self->refs--;" put)
                    c99-line("return self2;" put)
                )
                c99-line("}" put)
            )
        )
    }

    def construct! [ +Mirth +C99Branch |- C99DataStructRepr -- +C99Value/Resource ] {
        \self
        +c99:fresh-name! \struct-ptr
        c99-line(
            "struct " put @self cname put "* " put
            @struct-ptr put " = " put
            "calloc(1, sizeof *" put @struct-ptr put ");" put
        )
        c99-line("ASSERT(" put @struct-ptr put ");" put)
        c99-line(@struct-ptr put "->refs = 1;" put)
        @self fields reverse-for(
            \field
            @field input pop-stack-part! consume \expr
            @field is-physical? then(
                c99-line(
                    @struct-ptr put "->" put @field cname put " = " put
                    @expr put ";" put
                )
            )
        )
        @struct-ptr >value-name
        @self data C99ReprType.Data >value-repr +C99Value
        @self data is-resource? if(
            turn-into-resource! +C99Value/Resource.+Right,
            +C99Value/Resource.+Left
        )
    }
    def destruct! [ +Mirth +C99Branch |- C99DataStructRepr +C99Value/Resource -- ] {
        \self
        +c99:fresh-name! \struct-val
        consume \struct-ptr
        c99-line(
            "struct " put @self cname put " " put
            @struct-val put " = " put
            "*" put @struct-ptr put ";" put
        )
        @self fields for(
            \field
            @field is-physical? if(Str(@struct-val ; "." ; @field cname ;), "0") >value-name
            @field c99-repr >value-repr
            +C99Value +C99Value/Resource.+Left
            @field input push-stack-part!
        )
        c99-line("if (!--(" put @struct-ptr put "->refs)) {" put)
        c99-nest:c99-line("free(" put @struct-ptr put ");" put)
        c99-line("} else {" put)
        c99-nest(
            @self fields for(
                \field
                @field c99-repr needs-refcounting? then(
                    c99-line(
                        "incref(" put
                        Str( @struct-val ; "." ; @field cname ; )
                        @field c99-repr mk-macro put
                        ");" put
                    )
                )
            )
        )
        c99-line("}" put)
    }
}

struct C99DataStructField {
    input: StackTypePart
    c99-repr: C99ReprType
    cname: Str
    --
    def is-physical? [ +Mirth |- C99DataStructField -- Bool ] { c99-repr is-physical? }
    def is-resource? [ +Mirth |- C99DataStructField -- Bool ] { input type/resource is-right? }
    def label? [ +Mirth |- C99DataStructField -- Maybe(Label) ] { input label }
}

def c99-inputs-to-struct-fields [ +Mirth |- List(StackTypePart) -- List(C99DataStructField) ] {
    0 \i
    L0 \names
    L0 \fields
    reverse-for(
        dup >input
        match {
            { Cons -> sip:c99-repr tycon? if?(name mangled, @i >Str @i:1+) }
            { With -> sip:c99-repr tycon? if?(name mangled, @i >Str @i:1+) }
            { ConsLabel -> dip:c99-repr name mangled }
            { WithLabel -> dip:c99-repr name mangled }
        }
        \name >c99-repr
        0 \j
        @names for(@name = then(@j:1+))
        "m" @j 0> if(@name "_" cat @j >Str cat, @name) cat >cname
        C99DataStructField @fields:cons
    )
    @fields
}

struct C99DataSumRepr {
    data: Data
    --
    def needs-refcounting? { drop True }
    def underlying-c99-type [ +Mirth |- C99DataSumRepr -- Str ] { drop "PTUP" }
    def v-macro-prefix-suffix { drop "VTUP(" ")" }
    def mk-macro { drop Str( "MKTUP(" ; ; ")" ; ) }
    def get-data-tag { drop Str( "PTREXTRA("  ; ; ")" ; ) }
    def prepare-type-sigs! [ +Mirth +C99 |- C99DataSumRepr -- ] { drop }
    def prepare-type-defs! [ +Mirth +C99 |- C99DataSumRepr -- ] { drop }
}

def StackTypePart.c99-repr [ +Mirth |- StackTypePart -- C99ReprType ] {
    { Cons -> c99-repr } { ConsLabel -> drop c99-repr }
    { With -> c99-repr } { WithLabel -> drop c99-repr }
}

def SemiTransparentData.c99-repr [ +Mirth |- SemiTransparentData -- C99ReprType ] {
    input c99-repr
}

field(+Mirth |- Data.c99-repr, Data, C99DataRepr,
    @self unit? if?(
        >tag
        C99DataUnitRepr C99DataRepr.Unit,
    @self is-enum? if(
        @self >data
        C99DataEnumRepr C99DataRepr.Enum,
    @self semi-transparent? if?(
        /SemiTransparentData
        @input type/resource either(c99-repr,c99-repr) >c99-repr
        C99DataFieldRepr C99DataRepr.Field,
    @self single-tag? if?(
        C99DataStructRepr.Make C99DataRepr.Struct,
        @self >data
        C99DataSumRepr C99DataRepr.Sum
    ))))
)

data C99ReprType {
    0 Void

    VAL
    STR
    ARR
    TUP
    Int Nat

    I64 I32 I16 I8
    U64 U32 U16 U8
    F64 F32
    Bool
    PTR
    FNPTR

    Table [ Table ]
    Data  [ Data ]
    --
    def = [ C99ReprType C99ReprType -- Bool ] {
        { Void  -> match { Void  -> True, _ -> drop False } }
        { VAL   -> match { VAL   -> True, _ -> drop False } }
        { STR   -> match { STR   -> True, _ -> drop False } }
        { ARR   -> match { ARR   -> True, _ -> drop False } }
        { TUP   -> match { TUP   -> True, _ -> drop False } }
        { Int   -> match { Int   -> True, _ -> drop False } }
        { Nat   -> match { Nat   -> True, _ -> drop False } }
        { I64   -> match { I64   -> True, _ -> drop False } }
        { I32   -> match { I32   -> True, _ -> drop False } }
        { I16   -> match { I16   -> True, _ -> drop False } }
        { I8    -> match { I8    -> True, _ -> drop False } }
        { U64   -> match { U64   -> True, _ -> drop False } }
        { U32   -> match { U32   -> True, _ -> drop False } }
        { U16   -> match { U16   -> True, _ -> drop False } }
        { U8    -> match { U8    -> True, _ -> drop False } }
        { F64   -> match { F64   -> True, _ -> drop False } }
        { F32   -> match { F32   -> True, _ -> drop False } }
        { Bool  -> match { Bool  -> True, _ -> drop False } }
        { PTR   -> match { PTR   -> True, _ -> drop False } }
        { FNPTR -> match { FNPTR -> True, _ -> drop False } }
        { Table -> swap match { Table -> swap =, _ -> drop2 False } }
        { Data  -> swap match { Data -> swap =, _ -> drop2 False } }
    }
    def table? [ C99ReprType -- Maybe(Table) ] { Table -> Some, _ -> drop None }
    def data?  [ C99ReprType -- Maybe(Data ) ] { Data  -> Some, _ -> drop None }
    def is-void? [ C99ReprType -- Bool ] { Void -> True, _ -> drop False }
    def is-unit? [ +Mirth |- C99ReprType -- Bool ] {
        { Void -> True }
        { Data -> c99-repr is-unit? }
        { _ -> drop False }
    }
    def is-physical? [ +Mirth |- C99ReprType -- Bool ] { is-unit? not }

    def needs-refcounting? [ +Mirth |- C99ReprType -- Bool ] {
        { VAL -> True }
        { STR -> True }
        { ARR -> True }
        { TUP -> True }
        { Int -> True }
        { Nat -> True }
        { Table -> drop False}
        { Data -> c99-repr need-refcounting? }

        { Void -> False }
        { I64 -> False } { I32 -> False } { I16 -> False } { I8 -> False }
        { U64 -> False } { U32 -> False } { U16 -> False } { U8 -> False }
        { F64 -> False } { F32 -> False }
        { Bool -> False }
        { PTR -> False }
        { FNPTR -> False }
    }

    def is-int-like? [ C99ReprType -- Bool ] {
        { I64 -> True } { I32 -> True } { I16 -> True } { I8 -> True }
        { U64 -> True } { U32 -> True } { U16 -> True } { U8 -> True }
        { Bool -> True }
        { _ -> drop False }
    }

    def get-data-tag [ +Mirth |- Str C99ReprType -- Str ] {
        { I64 -> } { I32 -> } { I16 -> } { I8 -> }
        { U64 -> } { U32 -> } { U16 -> } { U8 -> }
        { Bool -> }
        { Data -> c99-repr get-data-tag }
        { Nat -> "get-data-tag on Nat" fatal-error! }
        { Int -> "get-data-tag on Int" fatal-error! }
        { Table -> "get-data-tag on Table" fatal-error! }
        { Void -> "get-data-tag on Void" fatal-error! }
        { VAL -> "get-data-tag on VAL" fatal-error! }
        { STR -> "get-data-tag on STR" fatal-error! }
        { ARR -> "get-data-tag on ARR" fatal-error! }
        { TUP -> "get-data-tag on TUP" fatal-error! }
        { PTR -> "get-data-tag on PTR" fatal-error! }
        { FNPTR -> "get-data-tag on FNPTR" fatal-error! }
        { F64 -> "get-data-tag on F64" fatal-error! }
        { F32 -> "get-data-tag on F32" fatal-error! }
        { _ -> "get-data-tag on unknown repr" fatal-error! }
    }

    def is-float-like? [ C99ReprType -- Bool ] {
        { F64 -> True } { F32 -> True }
        { _ -> drop False }
    }

    def dummy-value [ C99ReprType -- Str ] {
        { VAL   -> "(VAL){0}"    }
        { STR   -> "NULL"        }
        { ARR   -> "NULL"        }
        { Void  -> "0"           }
        { Int   -> "WRAP_I63(0)" }
        { Nat   -> "WRAP_I63(0)" }
        { I64   -> "0"           }
        { I32   -> "0"           }
        { I16   -> "0"           }
        { I8    -> "0"           }
        { U64   -> "0"           }
        { U32   -> "0"           }
        { U16   -> "0"           }
        { U8    -> "0"           }
        { F64   -> "0.0"         }
        { F32   -> "0.0"         }
        { Bool  -> "0"           }
        { PTR   -> "NULL"        }
        { FNPTR -> "NULL"        }
        { TUP   -> "NULL"        }
        { Table -> drop "0"      }
        { Data  -> drop "0"      }
    }

    def underlying-c99-type [ +Mirth |- C99ReprType -- Str ] {
        { Void  -> "void"     }
        { VAL   -> "VAL"      }
        { STR   -> "STR*"     }
        { ARR   -> "ARR*"     }
        { Int   -> "INT"      }
        { Nat   -> "INT"      }
        { I64   -> "int64_t"  }
        { I32   -> "int32_t"  }
        { I16   -> "int16_t"  }
        { I8    -> "int8_t"   }
        { U64   -> "uint64_t" }
        { U32   -> "uint32_t" }
        { U16   -> "uint16_t" }
        { U8    -> "uint8_t"  }
        { F64   -> "double"   }
        { F32   -> "float"    }
        { Bool  -> "bool"     }
        { PTR   -> "void*"    }
        { FNPTR -> "FNPTR"    }
        { TUP   -> "PTUP"     }
        { Table -> drop "uint64_t" }
        { Data  -> c99-repr underlying-c99-type }
    }

    def v-macro(f) [ +Mirth +C99 |- (*a -- *b) *a C99ReprType -- *b ] {
        v-macro-prefix-suffix
        dip(put f) put
    }

    def v-macro-prefix-suffix [ +Mirth |- C99ReprType -- Str Str ] {
        { VAL   -> "" "" }
        { STR   -> "value_str(" ")" }
        { Int   -> "value_int(" ")" }
        { Nat   -> "value_nat(" ")" }
        { Void  -> "(" ", 0)" }
        { I64   -> "value_i64(" ")" }
        { I32   -> "value_i32(" ")" }
        { I16   -> "value_i16(" ")" }
        { I8    -> "value_i8(" ")" }
        { U64   -> "value_u64(" ")" }
        { U32   -> "value_u32(" ")" }
        { U16   -> "value_u16(" ")" }
        { U8    -> "value_u8(" ")" }
        { F64   -> "value_f64(" ")" }
        { F32   -> "value_f32(" ")" }
        { Bool  -> "value_bool(" ")" }
        { PTR   -> "value_ptr(" ")" }
        { FNPTR -> "value_fnptr(" ")" }
        { ARR   -> "value_arr(" ")" }
        { TUP   -> "value_tup(" ")" }
        { Table -> drop "value_u64(" ")" }
        { Data  -> c99-repr v-macro-prefix-suffix }
    }

    def mk-macro [ +Mirth |- Str C99ReprType -- Str ] {
        { VAL   -> id }
        { STR   -> Str( "MKSTR(" ; ; ")" ; ) }
        { Int   -> Str( "MKINT(" ; ; ")" ; ) }
        { Nat   -> Str( "MKNAT(" ; ; ")" ; ) }
        { Void  -> Str( "MKI64(" ; ; ")" ; ) }
        { I64   -> Str( "MKI64(" ; ; ")" ; ) }
        { I32   -> Str( "MKI32(" ; ; ")" ; ) }
        { I16   -> Str( "MKI16(" ; ; ")" ; ) }
        { I8    -> Str( "MKI8("  ; ; ")" ; ) }
        { U64   -> Str( "MKU64(" ; ; ")" ; ) }
        { U32   -> Str( "MKU32(" ; ; ")" ; ) }
        { U16   -> Str( "MKU16(" ; ; ")" ; ) }
        { U8    -> Str( "MKU8(" ; ; ")" ; ) }
        { F64   -> Str( "MKF64(" ; ; ")" ; ) }
        { F32   -> Str( "MKF32(" ; ; ")" ; ) }
        { Bool  -> Str( "MKBOOL(" ; ; ")" ; ) }
        { PTR   -> Str( "MKPTR(" ; ; ")" ; ) }
        { FNPTR -> Str( "MKFNPTR(" ; ; ")" ; ) }
        { ARR   -> Str( "MKARR(" ; ; ")" ; ) }
        { TUP   -> Str( "MKTUP(" ; ; ")" ; ) }
        { Table -> drop Str( "MKU64(" ; ; ")" ; ) }
        { Data  -> c99-repr mk-macro }
    }
}

def Resource.c99-repr [ +Mirth |- Resource -- C99ReprType ] {
    >Type c99-repr
}

def Type.c99-repr [ +Mirth |- Type -- C99ReprType ] {
    { Error -> C99ReprType.VAL }
    { Ignore -> C99ReprType.VAL }
    { Prim -> c99-repr }
    { Meta -> expand-if(c99-repr, drop C99ReprType.VAL) }
    { Hole -> drop C99ReprType.VAL }
    { Var -> drop C99ReprType.VAL }
    { Table -> C99ReprType.Table }
    { Data -> C99ReprType.Data }
    { DataPartial -> dup is-semi-transparent? if(drop C99ReprType.Void, .data C99ReprType.Data) }
    { Arrow -> drop C99ReprType.VAL }
    { Stack -> tuple-c99-repr }
    { App -> drop c99-repr }
    { Mut -> drop C99ReprType.PTR }
    { Value -> drop C99ReprType.VAL }
}

def StackType.tuple-c99-repr [ +Mirth |- StackType -- C99ReprType ] {
    split-parts swap match {
        { Unit -> len 0= if (C99ReprType.Void, C99ReprType.TUP) }
        { _ -> drop2 C99ReprType.TUP }
    }
}

def PrimType.c99-repr [ PrimType -- C99ReprType ] {
    { KIND -> C99ReprType.Void }
    { TYPE -> C99ReprType.Void }
    { STACK -> C99ReprType.Void }
    { RESOURCE -> C99ReprType.Void }
    { Bool -> C99ReprType.Bool }
    { Int -> C99ReprType.Int }
    { Nat -> C99ReprType.Nat }
    { U8  -> C99ReprType.U8  }
    { U16 -> C99ReprType.U16 }
    { U32 -> C99ReprType.U32 }
    { U64 -> C99ReprType.U64 }
    { I8  -> C99ReprType.I8  }
    { I16 -> C99ReprType.I16 }
    { I32 -> C99ReprType.I32 }
    { I64 -> C99ReprType.I64 }
    { F32 -> C99ReprType.F32 }
    { F64 -> C99ReprType.F64 }
    { Str -> C99ReprType.STR }
    { Ptr -> C99ReprType.PTR }
    { Array -> C99ReprType.ARR }
    { World -> C99ReprType.Void }
    { Debug -> C99ReprType.Void }
}

struct +C99Value {
    value-repr: C99ReprType
    value-name: Str
}

def +C99Value.rdup [ +C99Value |- +C99Value ] {
    value-repr >value-repr
    value-name >value-name
    +C99Value
}

def +C99Value.rdrop [ +C99Value -- ] {
    /+C99Value
    value-repr> drop
    value-name> drop
}

def C99ReprType.new-value! [ +Mirth +C99Branch |- C99ReprType -- +C99Value ] {
    >value-repr
    +c99:fresh-name! >value-name
    c99-line(@value-repr underlying-c99-type put " " put
             @value-name put ";" put)
    +C99Value
}

def C99ReprType.pop-value-direct! [ +Mirth +C99Branch |- C99ReprType -- +C99Value ] {
    >value-repr
    @value-repr is-physical? if(
        +c99:fresh-name! >value-name
        c99-line(@value-repr underlying-c99-type put " " put
                @value-name put " = " put
                @value-repr v-macro ( "pop_value()" put ) ";" put),
        "0" >value-name
        c99-line("pop_value();" put)
    )
    +C99Value
}

||| Push a value with a certain repr type on the stack.
||| `f` must emit the C99 expression that calculates the value,
||| which must be of the underlying C99 repr type.
def C99ReprType.push-value-expression!(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a C99ReprType -- *b ] {
    value-expression!(f) push-value!
}

def C99ReprType.push-resource-expression!(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a C99ReprType -- *b ] {
    resource-expression!(f) push-resource!
}

def push-label-expression!(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a C99ReprType Label -- *b ] {
    dip:value-expression!(f)
    dup rdip:is-resource-label? if(
        turn-into-resource! push-resource-label!,
        push-value-label!
    )
}

def C99ReprType.value-expression!(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a C99ReprType -- *b +C99Value ] {
    dup >value-repr is-physical? dup
    if(+c99:fresh-name!, "0") >value-name
    c99-line-if(
        @value-repr underlying-c99-type put " " put
        @value-name put " = " put
        +C99Value rdip:f rswap ";" put
    ) rswap
}

def C99ReprType.resource-expression!(f) [ (+Mirth +C99 |- *a -- *b) +Mirth +C99Branch |- *a C99ReprType -- *b +C99Resource ] {
    dup >resource-repr is-physical? dup
    if(+c99:fresh-resource-name!, "0") >resource-name
    c99-line-if(
        @resource-repr underlying-c99-type put " " put
        @resource-name put " = " put
        +C99Resource rdip:f rswap ";" put
    ) rswap
}

def +C99Value.push-value-direct! [ +Mirth +C99Branch |- +C99Value -- ] {
    consume-as-VAL
    c99-line("push_value(" put put ");" put)
}

def +C99Value.consume [ +C99Value -- Str ] {
    /+C99Value value-repr> drop value-name>
}

def +C99Value.consume-as-VAL [ +Mirth |- +C99Value -- Str ] {
    /+C99Value value-name> value-repr> mk-macro
}

def +C99Value.consume-as-TUP [ +Mirth |- +C99Value -- Str ] {
    turn-into-resource! consume-as-TUP
}

def +C99Value.consume-as-data [ +Mirth |- +C99Value Data -- Str ] {
    C99ReprType.Data consume-as
}

def +C99Value.consume-as [ +Mirth |- C99ReprType +C99Value -- Str ] {
    { VAL -> consume-as-VAL }
    { Void -> rdrop "0" }
    { _ ->
        /+C99Value
        @value-repr match {
            { VAL -> Str( v-macro-prefix-suffix dip(; value-name> ;) ; ) }
            { _ ->
                over = if(
                    drop value-name>,
                    dup is-int-like? @value-repr is-int-like? and if(
                        Str( "((" ; underlying-c99-type ; ")" ; value-name> ; ")" ; ),
                        Str( "(\n#error \"attempted to cast " ; value-name> ; " to incompatible C99 repr type " ;
                            underlying-c99-type ; "\"\n" ; )
                    )
                )
            }
        }
        value-repr> drop
    }
}

def +C99Value.keep-value! [ +Mirth +C99Branch +C99Value |- ] {
    value-repr needs-refcounting? then(
        +C99Value.rdup consume-as-VAL +c99:c99-line("incref(" put put ");" put)
    )
}

def +C99Value.drop-value! [ +Mirth +C99Branch |- +C99Value -- ] {
    value-repr needs-refcounting? if(
        consume-as-VAL +c99:c99-line("decref(" put put ");" put),
        +C99Value.rdrop
    )
}

def +C99Value.dup-value! [ +Mirth +C99Branch +C99Value |- +C99Value ] {
    keep-value!
    rdup
}

def +C99Value.peek-data-tag [ +Mirth +C99Value |- Str ] {
    value-name value-repr get-data-tag
}

struct +C99Resource {
    resource-repr: C99ReprType
    resource-name: Str
}

def +C99Resource.rdup [ +C99Resource |- +C99Resource ] {
    resource-repr >resource-repr
    resource-name >resource-name
    +C99Resource
}

def +C99Resource.rdrop [ +C99Resource -- ] {
    consume drop
}

def +C99Value.turn-into-resource! [ +C99Value -- +C99Resource ] {
    /+C99Value
    value-repr> >resource-repr
    value-name> >resource-name
    +C99Resource
}

def +C99Resource.turn-into-value! [ +C99Resource -- +C99Value ] {
    /+C99Resource
    resource-repr> >value-repr
    resource-name> >value-name
    +C99Value
}

def +C99Resource.drop-resource-as-value! [ +Mirth +C99Branch |- +C99Resource -- ] {
    turn-into-value! drop-value!
}

def +C99Resource.dup-resource-as-value! [ +Mirth +C99Branch +C99Resource |- +C99Value ] {
    rdup turn-into-value! rswap rdip(dup-value! rdrop) rswap
}

def +C99Resource.consume [ +C99Resource -- Str ] {
    /+C99Resource
    resource-repr> drop
    resource-name>
}

def +C99Resource.consume-as [ +Mirth |- C99ReprType +C99Resource -- Str ] {
    turn-into-value! consume-as
}

def +C99Resource.consume-as-VAL [ +Mirth |- +C99Resource -- Str ] {
    /+C99Resource resource-name> resource-repr> mk-macro
}

def +C99Resource.consume-as-TUP [ +Mirth |- +C99Resource -- Str ] {
    /+C99Resource resource-repr> match {
        { VAL -> Str( "VTUP(" ; resource-name> ; ")" ; ) }
        { TUP -> resource-name> }
        { _ -> drop "c99: tried to consume non-tuple as tuple" panic! }
    }
}

def +C99Resource.consume-as-data [ +Mirth |- +C99Resource Data -- Str ] {
    C99ReprType.Data consume-as
}

def +C99Branch.pop-resource-direct! [ +Mirth +C99Branch |- C99ReprType -- +C99Resource ] {
    dup >resource-repr
    is-physical? if(
        +c99:fresh-resource-name! >resource-name
        c99-line(
            @resource-repr underlying-c99-type put " " put
            @resource-name put " = " put
            @resource-repr v-macro( "pop_resource()" put )
            ";" put
        ),
        "0" >resource-name
        c99-line("pop_resource();" put)
    )
    +C99Resource
}

def +C99Resource.push-resource-direct! [ +Mirth +C99Branch |- +C99Resource -- ] {
    consume-as-VAL
    c99-line("push_resource(" put put ");" put)
}

def +C99Resource.peek-data-tag [ +Mirth +C99Resource |- Str ] {
    resource-name resource-repr get-data-tag
}

def +C99Value.>Value/Resource { +Left +C99Value/Resource }
def +C99Resource.>Value/Resource { +Right +C99Value/Resource }
struct +C99Value/Resource {
    +Either(+C99Value, +C99Resource)
    --
    def +Left [ +C99Value -- +C99Value/Resource ] { +Either.+Left +C99Value/Resource }
    def +Right [ +C99Resource -- +C99Value/Resource ] { +Either.+Right +C99Value/Resource }
    def +for(f,g) { +C99Value/Resource -> +for(f,g) }
    def +map(f,g) { +C99Value/Resource -> +map(f,g) +C99Value/Resource }
    def rdup { +C99Value/Resource -> rdup +C99Value/Resource rdip:+C99Value/Resource }
    def rdrop { +C99Value/Resource -> rdrop }

    def push-value/resource! { +for(push-value!, push-resource!) }
    def peek-data-tag { +map(peek-data-tag, peek-data-tag) }
    def consume { +for(consume, consume) }
    def consume-as { +for(consume-as, consume-as) }
    def consume-as-VAL { +for(consume-as-VAL, consume-as-VAL) }
    def consume-as-TUP { +for(consume-as-TUP, consume-as-TUP) }
    def consume-as-data { +for(consume-as-data, consume-as-data) }
    def turn-into-value! { +for(id, turn-into-value!) }
    def turn-into-resource! { +for(turn-into-resource!, id) }
    def value/resource-name { +map(value-name, resource-name) }
    def value/resource-repr { +map(value-repr, resource-repr) }
    def value/resource-name! { +map(value-name!, resource-name!) }
    def value/resource-repr! { +map(value-repr!, resource-repr!) }
}

def +C99Branch.pop-data! [ +Mirth +C99Branch |- Data -- +C99Value/Resource ] {
    dup is-resource? if(
        C99ReprType.Data pop-resource! +Right +C99Value/Resource,
        C99ReprType.Data pop-value! +Left +C99Value/Resource
    )
}

def +C99Branch.refresh-branch! [ +Mirth |- +C99Branch -- +C99Branch ] {
    /+C99Branch
    +c99> +stack>
    refresh-all!
}

def +C99Stack.refresh-all! [ +Mirth |- +C99 +C99Stack reachable:Bool env:C99Env -- +C99Branch ] {
    { +Nil -> start-branch! }
    { +Cons ->
        >+x refresh-all!
        @+x:value-repr push-value-expression!(+x> consume put)
    }
    { +With ->
        >+x refresh-all!
        @+x:resource-repr push-resource-expression!(+x> consume put)
    }
    { +ConsLabel ->
        >+x refresh-all!
        @+x:value-repr swap push-label-expression!(+x> consume put)
    }
    { +WithLabel ->
        >+x refresh-all!
        @+x:resource-repr swap push-label-expression!(+x> consume put)
    }
}

def +C99Stack.tie-knot! [ +Mirth +C99Branch |- +C99Stack -- ] {
    { +Nil -> flush-cache! }
    { +Cons ->
        value-repr dup rdip2(pop-value! consume-as)
        value-name
        value-repr is-physical?
        c99-line-if(put " = " put put ";" put)
        tie-knot!
        push-value!
    }
    { +With ->
        resource-repr dup rdip2(pop-resource! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        c99-line-if(put " = " put put ";" put)
        tie-knot!
        push-resource!
    }
    { +ConsLabel -> >label
        value-repr dup rdip2(@label pop-value-label! consume-as)
        value-name
        value-repr is-physical?
        c99-line-if(put " = " put put ";" put)
        tie-knot!
        label> push-value-label!
    }
    { +WithLabel -> >label
        resource-repr dup rdip2(@label pop-resource-label! turn-into-value! consume-as)
        resource-name
        resource-repr is-physical?
        c99-line-if(put " = " put put ";" put)
        tie-knot!
        label> push-resource-label!
    }
}

data +C99Stack {
    +Nil
    +Cons [ +C99Stack +C99Value ]
    +With [ +C99Stack +C99Resource ]
    +ConsLabel [ +C99Stack +C99Value Label ]
    +WithLabel [ +C99Stack +C99Resource Label ]
}

def +C99Stack.pop-value? [ +C99Stack -- +Maybe(+C99Value) +C99Stack ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +Cons -> +Some rswap }
    { +With -> rdip:pop-value? +C99Stack.+With }
    { +ConsLabel -> rdip:pop-value? +C99Stack.+ConsLabel }
    { +WithLabel -> rdip:pop-value? +C99Stack.+WithLabel }
}

def +C99Stack.pop-resource? [ +C99Stack -- +Maybe(+C99Resource) +C99Stack ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +With -> +Some rswap }
    { +Cons -> rdip:pop-resource? +C99Stack.+Cons }
    { +ConsLabel -> rdip:pop-resource? +C99Stack.+ConsLabel }
    { +WithLabel -> rdip:pop-resource? +C99Stack.+WithLabel }
}

inline def +C99Value.top [ +C99Value |- ] { }
inline def +C99Resource.top [ +C99Resource |- ] { }

def +C99Stack.pop-value-label? [ +Mirth +C99Stack Label |- +Maybe(+C99Value) ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +Cons -> rdip:pop-value-label? +C99Stack.+Cons }
    { +With -> rdip:pop-value-label? +C99Stack.+With }
    { +WithLabel -> dip:rdip:pop-value-label? +C99Stack.+WithLabel }
    { +ConsLabel ->
        dup2 = if(
            drop +C99Value.top +Some,
            dip:pop-value-label? +C99Stack.+ConsLabel
        )
    }
}

def +C99Stack.pop-resource-label? [ +Mirth +C99Stack Label |- +Maybe(+C99Resource) ] {
    { +Nil -> +None +C99Stack.+Nil }
    { +Cons -> rdip:pop-resource-label? +C99Stack.+Cons }
    { +With -> rdip:pop-resource-label? +C99Stack.+With }
    { +ConsLabel -> dip:rdip:pop-resource-label? +C99Stack.+ConsLabel }
    { +WithLabel ->
        dup2 = if(
            drop +C99Resource.top +Some,
            dip:pop-resource-label? +C99Stack.+WithLabel
        )
    }
}

def +C99Stack.push-stack-direct! [ +Mirth +C99Branch |- +C99Stack -- ] {
    { +Nil -> }
    { +Cons -> rdip:push-stack-direct! push-value-direct! }
    { +With -> rdip:push-stack-direct! push-resource-direct! }
    { +ConsLabel -> rdip:push-stack-direct! push-value-label-direct! }
    { +WithLabel -> rdip:push-stack-direct! push-resource-label-direct! }
}

def +C99Stack.rdup [ +C99Stack -- +C99Stack +C99Stack ] {
    { +Nil -> +C99Stack.+Nil +C99Stack.+Nil }
    { +Cons -> rdip:rdup +C99Value.rdup rdip:rswap +C99Stack.+Cons rdip:+C99Stack.+Cons }
    { +With -> rdip:rdup +C99Resource.rdup rdip:rswap +C99Stack.+With rdip:+C99Stack.+With }
    { +ConsLabel -> dup rdip:rdup +C99Value.rdup rdip:rswap +C99Stack.+ConsLabel rdip:+C99Stack.+ConsLabel }
    { +WithLabel -> dup rdip:rdup +C99Resource.rdup rdip:rswap +C99Stack.+WithLabel rdip:+C99Stack.+WithLabel }
}

def +C99Stack.rdrop [ +C99Stack -- ] {
    { +Nil -> }
    { +Cons -> +C99Value.rdrop rdrop }
    { +With -> +C99Resource.rdrop rdrop }
    { +ConsLabel -> drop +C99Value.rdrop rdrop }
    { +WithLabel -> drop +C99Resource.rdrop rdrop }
}

struct +C99BranchSplit {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    branch-split-target: List(C99APIArg)
    reachable-in: Bool
    reachable-out: Bool
}

def +C99Branch.begin-branch-split! [ +Mirth |- StackType +C99Branch -- +C99BranchSplit ] {
    C99APIArgMode.Branch +c99:stack-type-to-c99-api-params >branch-split-target
    must-flush> drop
    @branch-split-target for(reserve-as-is!)
    /+C99Branch
    reachable> >reachable-in
    False >reachable-out
    +C99BranchSplit
}
def +C99BranchSplit.end-branch-split! [ +Mirth |- +C99BranchSplit -- +C99Branch ] {
    /+C99BranchSplit
    +stack> rdrop
    reachable-in> drop
    reachable-out> >reachable
    +c99> start-branch!
    branch-split-target> for(push-api-arg!)
}

def +C99BranchSplit.sub-branch(f) [ (+Mirth +C99Branch |- *a -- *b) +Mirth +C99BranchSplit |- *a -- *b ] {
    +stack(rdup >+stack) branch-split-target
    reachable-in >reachable
    env >env
    +c99(
        >+c99 +C99Branch dip:f
        reverse-for(pop-to-reserved!)
        end-branch!
    )
    env> drop
    reachable> reachable-out:or
}

def +C99BranchSplit.c99-line(f) { reachable-in +c99:c99-line-if(f) }
def +C99BranchSplit.c99-line-if(f) { reachable-in and +c99:c99-line-if(f) }
def +C99BranchSplit.c99-nest(f) { +c99:depth:1+ f +C99BranchSplit.+c99:depth:pred }

struct C99Var {
    var-var: Var
    value-name: Str
    value-repr: C99ReprType
}

def +C99Branch.var-lookup [ +Mirth +C99Branch |- Var -- Maybe(C99Var) ] {
    env lookup(var-var =)
}

def +C99Branch.var-get! [ +Mirth +C99Branch |- Var -- +C99Value ] {
    var-lookup unwrap("[c99] variable unexpectedly missing from environment" fatal-error!)
    /C99Var var-var> drop
    +C99Value
}

def +C99Branch.var-dup! [ +Mirth +C99Branch |- Var -- +C99Value ] {
    var-get! dup-value! rdrop
}

def +C99Value.push-to-env! [ +Mirth +C99Branch |- Var +C99Value -- ] {
    >var-var /+C99Value C99Var env:cons
}

def +C99Branch.pop-from-env! [ +Mirth +C99Branch |- -- Var +C99Value ] {
    env:uncons unwrap("[c99] variable environment unexpectedly empty" fatal-error!)
    /C99Var +C99Value var-var>
}

def-type(C99Env, List(C99Var))

||| This resource represents a single active branch.
struct +C99Branch {
    +c99: +C99
    +stack: +C99Stack
    env: C99Env
    reachable: Bool
}

def +C99.start-branch! [ +Mirth |- +C99 reachable:Bool env:C99Env -- +C99Branch ] {
    >+c99 +C99Stack.+Nil >+stack +C99Branch
}

def +C99Branch.end-branch! [ +Mirth |- +C99Branch -- +C99 reachable:Bool env:C99Env ] {
    +stack(+C99Stack.+Nil) rswap push-stack-direct!
    /+C99Branch +c99> +stack> rdrop
}

def +C99Branch.flush-cache! [ +Mirth +C99Branch |- ] {
    end-branch!
    start-branch!
}

def +C99Branch.pop-value! [ +Mirth +C99Branch |- C99ReprType -- +C99Value ] {
    +stack(pop-value?) rswap match {
        { +Some -> convert-value! }
        { +None -> pop-value-direct! }
    }
}

def +C99Branch.pop-value-label! [ +Mirth +C99Branch |- C99ReprType Label -- +C99Value ] {
    +stack(pop-value-label?) rswap match {
        { +Some -> drop convert-value! }
        { +None -> pop-value-label-direct! }
    }
}

def +C99Branch.pop-resource! [ +Mirth +C99Branch |- C99ReprType -- +C99Resource ] {
    +stack(pop-resource?) rswap match {
        { +Some -> convert-resource! }
        { +None -> pop-resource-direct! }
    }
}

def +C99Branch.pop-resource-label! [ +Mirth +C99Branch |- C99ReprType Label -- +C99Resource ] {
    +stack(pop-resource-label?) rswap match {
        { +Some -> drop convert-resource! }
        { +None -> pop-resource-label-direct! }
    }
}

def +C99Value.push-value! [ +Mirth +C99Branch |- +C99Value -- ] {
    rswap +stack(rswap +C99Stack.+Cons)
}

def +C99Resource.push-resource! [ +Mirth +C99Branch |- +C99Resource -- ] {
    rswap +stack(rswap +C99Stack.+With)
}

def +C99Value.convert-value! [ +Mirth +C99Value |- C99ReprType -- ] {
    { VAL -> }
    { _ -> dup +C99Value.rdup consume-as value-name! value-repr! }
}
def +C99Resource.convert-resource! [ +Mirth +C99Resource |- C99ReprType -- ] {
    { VAL -> }
    { _ -> dup +C99Resource.rdup consume-as resource-name! resource-repr! }
}

def +C99Branch.type-to-c99-repr [ +Mirth +C99Branch |- Type -- C99ReprType ] { c99-repr }
def +C99Branch.resource-to-c99-repr [ +Mirth +C99Branch |- Resource -- C99ReprType ] { c99-repr }

def +C99Branch.pop-value-from-stack-type! [ +Mirth +C99Branch StackType |- +C99Value ] {
    force-cons?! unwrap("c99 error: tried to pop from invalid stack type" fatal-error!) unpack2
    type-to-c99-repr pop-value!
}
def +C99Branch.pop-resource-from-stack-type! [ +Mirth +C99Branch StackType |- +C99Resource ] {
    force-with?! unwrap("c99 error: tried to pop from invalid stack type" fatal-error!) unpack2
    resource-to-c99-repr pop-resource!
}

def +C99Branch.pop-value-label-from-stack-type! [ +Mirth +C99Branch |- Label StackType -- StackType +C99Value ] {
    dip:dup force-cons-label?! unwrap("c99 error: tried to pop from invalid stack type" fatal-error!) unpack2 type-to-c99-repr
    rotl pop-value-label!
}

def +C99Branch.pop-resource-label-from-stack-type! [ +Mirth +C99Branch |- Label StackType -- StackType +C99Resource ] {
    dip:dup force-with-label?! unwrap("c99 error: tried to pop from invalid stack type" fatal-error!) unpack2 resource-to-c99-repr
    rotl pop-resource-label!
}

def c99-prim! [ +Mirth +C99Branch |- Atom Prim -- ] {
    { Id -> drop }
    { Drop ->
        dom pop-value-from-stack-type! drop
        drop-value!
    }
    { Dup ->
        dom pop-value-from-stack-type! drop
        dup-value! rdip:push-value! push-value!
    }
    { Swap ->
        dom
        pop-value-from-stack-type! >+b
        pop-value-from-stack-type! >+a
        drop
        +b> push-value!
        +a> push-value!
    }
    { RSwap ->
        dom
        pop-resource-from-stack-type! >+b
        pop-resource-from-stack-type! >+a
        drop
        +b> push-resource!
        +a> push-resource!
    }
    { Dip ->
        dup args single? unwrap(token "unexpected number of arguments to Dip" emit-fatal-error!)
        swap dom pop-value-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-value!
    }
    { RDip ->
        dup args single? unwrap(token "unexpected number of arguments to RDip" emit-fatal-error!)
        swap dom pop-resource-from-stack-type! drop >+dipped
        c99-arg-run!
        +dipped> push-resource!
    }
    { If ->
        dup args pair? unwrap(token "unexpected number of arguments to If" emit-fatal-error!)
        unpack2 C99ReprType.Bool pop-value! >+cond

        rotl cod
        begin-branch-split!
        c99-line("if (" put +cond> C99ReprType.Bool consume-as put ") {" put)
        c99-nest:sub-branch(swap c99-arg-run!)
        c99-line("} else {" put)
        c99-nest:sub-branch(c99-arg-run!)
        c99-line("}" put)
        end-branch-split!
    }
    { While ->
        dup args pair? unwrap(token "unexpected number of arguments to While" emit-fatal-error!)
        nip unpack2 over c99-arg-run!
        C99ReprType.Bool pop-value! push-value!
        refresh-branch! +stack(rdup >+knot)
        C99ReprType.Bool dup pop-value! consume-as
        c99-line("while (" put put ") {" put)
        c99-nest(
            refresh-branch!
            c99-arg-run!
            c99-arg-run!
            +knot> tie-knot!
        )
        c99-line("}" put)
        C99ReprType.Bool pop-value! +C99Value.rdrop
    }
    { DebugMode ->
        dup args single? unwrap(token "unexpected number of arguments to prim-debug-mode" emit-fatal-error!) \f
        cod begin-branch-split!
        c99-line("if (MIRTH_DEBUG) {" put)
        c99-nest:sub-branch(
            C99ReprType.Void push-resource-expression!("0" put)
            @f c99-arg-run!
            C99ReprType.Void pop-resource! +C99Resource.rdrop
        )
        c99-line("} else {" put)
        c99-nest:sub-branch(id)
        c99-line("}" put)
        end-branch-split!
    }
    { DebugTrace ->
        drop
        C99ReprType.STR pop-value!
        +C99Value.rdup C99ReprType.STR consume-as \msg
        c99-line("write(2, " put @msg put "->data, " put @msg put "->size);" put)
        drop-value!
    }
    { DebugTraceValue ->
        drop
        C99ReprType.VAL pop-value!
        +C99Value.rdup consume-as-VAL \val
        c99-line("value_trace_(" put @val put ", 2);" put)
        drop-value!
    }
    { DebugTraceResource ->
        drop
        C99ReprType.Void pop-resource! >+debug
        C99ReprType.VAL pop-resource!
        +C99Resource.rdup consume-as-VAL \val
        c99-line("value_trace_(" put @val put ", 2);" put)
        push-resource!
        +debug> push-resource!
    }
    { DebugTraceStack ->
        drop flush-cache! c99-line("trace_stack();" put)
    }
    { DebugGetNumRefs ->
        drop
        C99ReprType.VAL pop-value! +C99Value.rdup consume-as-VAL \v
        C99ReprType.U64 push-value-expression!(
            "HAS_REFS(" put @v put ") ? VREFS(" put @v put ")-1 : 0" put
        )
        drop-value!
    }
    { DebugGetIdentity ->
        drop
        C99ReprType.VAL pop-value! +C99Value.rdup consume-as-VAL \v
        C99ReprType.U64 push-value-expression!(@v put ".data.u64" put)
        drop-value!
    }

    { Panic ->
        drop
        C99ReprType.STR dup pop-value! consume-as
        c99-line("do_panic(" put put ");" put)
        +stack(+C99Stack.rdrop +C99Stack.+Nil)
        False reachable!
    }
    { Run ->
        dup args empty? else(token "expected no arguments to prim-core-run" emit-fatal-error!) drop
        C99ReprType.VAL pop-value! run-value!
    }

    { IntEq  -> drop "int_eq(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntLt  -> drop "int_lt(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntLe  -> drop "int_le(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntGt  -> drop "int_gt(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntGe  -> drop "int_ge(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntNe  -> drop "int_ne(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Bool Some c99-binop! }
    { IntAdd -> drop "int_add(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Int Some c99-binop! }
    { IntSub -> drop "int_sub(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Int Some c99-binop! }
    { IntMul -> drop "int_mul(" C99ReprType.Int ", " C99ReprType.Int ")" False C99ReprType.Int Some c99-binop! }
    { IntDivMod -> args "int_divmod" Prim.IntDivMod type +c99:cname-type-to-c99-api c99-smart-call! }
    { IntToU64 -> drop "int_to_u64(" C99ReprType.Int ")" C99ReprType.U64 Some c99-unop! }
    { IntToI64 -> drop "int_to_i64(" C99ReprType.Int ")" C99ReprType.I64 Some c99-unop! }
    { IntToF32 -> drop "int_to_f32(" C99ReprType.Int ")" C99ReprType.F32 Some c99-unop! }
    { IntToF64 -> drop "int_to_f64(" C99ReprType.Int ")" C99ReprType.F64 Some c99-unop! }
    { IntToStr -> drop "int_to_str(" C99ReprType.Int ")" C99ReprType.STR Some c99-unop! }
    { IntToNat -> drop "" C99ReprType.Int "" C99ReprType.Nat Some c99-unop! }
    { NatToInt -> drop "" C99ReprType.Nat "" C99ReprType.Int Some c99-unop! }

    { U8Get  -> drop "*(uint8_t*)"  C99ReprType.PTR "" C99ReprType.U8  Some c99-unop! }
    { U8Set  -> drop "*(uint8_t*)"  C99ReprType.PTR " = " C99ReprType.U8  ";" True None c99-binop! }
    { U8ToU64 -> drop "(uint64_t)(" C99ReprType.U8 ")" C99ReprType.U64 Some c99-unop! }

    { U16Get -> drop "*(uint16_t*)" C99ReprType.PTR "" C99ReprType.U16 Some c99-unop! }
    { U16Set -> drop "*(uint16_t*)" C99ReprType.PTR " = " C99ReprType.U16 ";" True None c99-binop! }
    { U16ToU64 -> drop "(uint64_t)(" C99ReprType.U16 ")" C99ReprType.U64 Some c99-unop! }

    { U32Get -> drop "*(uint32_t*)" C99ReprType.PTR "" C99ReprType.U32 Some c99-unop! }
    { U32Set -> drop "*(uint32_t*)" C99ReprType.PTR " = " C99ReprType.U32 ";" True None c99-binop! }
    { U32ToU64 -> drop "(uint64_t)(" C99ReprType.U32 ")" C99ReprType.U64 Some c99-unop! }

    { U64Get -> drop "*(uint64_t*)" C99ReprType.PTR "" C99ReprType.U64 Some c99-unop! }
    { U64Set -> drop "*(uint64_t*)" C99ReprType.PTR " = " C99ReprType.U64 ";" True None c99-binop! }
    { U64Eq  -> drop "(" C99ReprType.U64 " == " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Lt  -> drop "(" C99ReprType.U64 " < "  C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Le  -> drop "(" C99ReprType.U64 " <= " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Gt  -> drop "(" C99ReprType.U64 " > "  C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Ge  -> drop "(" C99ReprType.U64 " >= " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Ne  -> drop "(" C99ReprType.U64 " != " C99ReprType.U64 ")" False C99ReprType.Bool Some c99-binop! }
    { U64Add -> drop "(" C99ReprType.U64 " + " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Sub -> drop "(" C99ReprType.U64 " - " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Mul -> drop "(" C99ReprType.U64 " * " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Div -> drop "u64_div(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Mod -> drop "u64_mod(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64And -> drop "(" C99ReprType.U64 " & "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Xor -> drop "(" C99ReprType.U64 " ^ "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Or  -> drop "(" C99ReprType.U64 " | "  C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Shl -> drop "u64_shl(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64Shr -> drop "u64_shr(" C99ReprType.U64 ", " C99ReprType.U64 ")" False C99ReprType.U64 Some c99-binop! }
    { U64ToInt -> drop "u64_to_int(" C99ReprType.U64 ")" C99ReprType.Int Some c99-unop! }
    { U64ToStr -> drop "u64_to_str(" C99ReprType.U64 ")" C99ReprType.STR Some c99-unop! }
    { U64ToU8  -> drop "(uint8_t)(" C99ReprType.U64 ")" C99ReprType.U8 Some c99-unop! }
    { U64ToU16 -> drop "(uint16_t)(" C99ReprType.U64 ")" C99ReprType.U16 Some c99-unop! }
    { U64ToU32 -> drop "(uint32_t)(" C99ReprType.U64 ")" C99ReprType.U32 Some c99-unop! }
    { U64ToI8  -> drop "(int8_t)(" C99ReprType.U64 ")" C99ReprType.I8 Some c99-unop! }
    { U64ToI16 -> drop "(int16_t)(" C99ReprType.U64 ")" C99ReprType.I16 Some c99-unop! }
    { U64ToI32 -> drop "(int32_t)(" C99ReprType.U64 ")" C99ReprType.I32 Some c99-unop! }
    { U64ToI64 -> drop "(int64_t)(" C99ReprType.U64 ")" C99ReprType.I64 Some c99-unop! }
    { U64ToF32 -> drop "(float)("   C99ReprType.U64 ")"  C99ReprType.F32 Some c99-unop! }
    { U64ToF64 -> drop "(double)("  C99ReprType.U64 ")"  C99ReprType.F64 Some c99-unop! }

    { I8Get  -> drop "*(int8_t*)"   C99ReprType.PTR "" C99ReprType.I8  Some c99-unop! }
    { I8Set  -> drop "*(int8_t*)"   C99ReprType.PTR " = " C99ReprType.I8  ";" True None c99-binop! }
    { I8ToI64 -> drop "(int64_t)(" C99ReprType.I8 ")" C99ReprType.I64 Some c99-unop! }

    { I16Get -> drop "*(int16_t*)"  C99ReprType.PTR "" C99ReprType.I16 Some c99-unop! }
    { I16Set -> drop "*(int16_t*)"  C99ReprType.PTR " = " C99ReprType.I16 ";" True None c99-binop! }
    { I16ToI64 -> drop "(int64_t)(" C99ReprType.I16 ")" C99ReprType.I64 Some c99-unop! }

    { I32Get -> drop "*(int32_t*)"  C99ReprType.PTR "" C99ReprType.I32 Some c99-unop! }
    { I32Set -> drop "*(int32_t*)"  C99ReprType.PTR " = " C99ReprType.I32 ";" True None c99-binop! }
    { I32ToI64 -> drop "(int64_t)(" C99ReprType.I32 ")" C99ReprType.I64 Some c99-unop! }

    { I64Get -> drop "*(int64_t*)"  C99ReprType.PTR "" C99ReprType.I64 Some c99-unop! }
    { I64Set -> drop "*(int64_t*)"  C99ReprType.PTR " = " C99ReprType.I64 ";" True None c99-binop! }
    { I64Eq  -> drop "(" C99ReprType.I64 " == " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Lt  -> drop "(" C99ReprType.I64 " < "  C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Le  -> drop "(" C99ReprType.I64 " <= " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Gt  -> drop "(" C99ReprType.I64 " > "  C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Ge  -> drop "(" C99ReprType.I64 " >= " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Ne  -> drop "(" C99ReprType.I64 " != " C99ReprType.I64 ")" False C99ReprType.Bool Some c99-binop! }
    { I64Add -> drop "i64_add(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Sub -> drop "i64_sub(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Mul -> drop "i64_mul(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Div -> drop "i64_div(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64Mod -> drop "i64_mod(" C99ReprType.I64 ", " C99ReprType.I64 ")" False C99ReprType.I64 Some c99-binop! }
    { I64ToInt -> drop "i64_to_int(" C99ReprType.I64 ")" C99ReprType.Int Some c99-unop! }
    { I64ToStr -> drop "i64_to_str("   C99ReprType.I64 ")" C99ReprType.STR Some c99-unop! }
    { I64ToU8  -> drop "(uint8_t)("  C99ReprType.I64 ")" C99ReprType.U8 Some c99-unop! }
    { I64ToU16 -> drop "(uint16_t)(" C99ReprType.I64 ")" C99ReprType.U16 Some c99-unop! }
    { I64ToU32 -> drop "(uint32_t)(" C99ReprType.I64 ")" C99ReprType.U32 Some c99-unop! }
    { I64ToU64 -> drop "(uint64_t)(" C99ReprType.I64 ")" C99ReprType.U64 Some c99-unop! }
    { I64ToI8  -> drop "(int8_t)("   C99ReprType.I64 ")" C99ReprType.I8 Some c99-unop! }
    { I64ToI16 -> drop "(int16_t)("  C99ReprType.I64 ")" C99ReprType.I16 Some c99-unop! }
    { I64ToI32 -> drop "(int32_t)("  C99ReprType.I64 ")" C99ReprType.I32 Some c99-unop! }
    { I64ToF32 -> drop "(float)("    C99ReprType.I64 ")"  C99ReprType.F32 Some c99-unop! }
    { I64ToF64 -> drop "(double)("   C99ReprType.I64 ")"  C99ReprType.F64 Some c99-unop! }

    { F32Eq  -> drop "(" C99ReprType.F32 " == " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Lt  -> drop "(" C99ReprType.F32 " < "  C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Le  -> drop "(" C99ReprType.F32 " <= " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Gt  -> drop "(" C99ReprType.F32 " > "  C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Ge  -> drop "(" C99ReprType.F32 " >= " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Ne  -> drop "(" C99ReprType.F32 " != " C99ReprType.F32 ")" False C99ReprType.Bool Some c99-binop! }
    { F32Add -> drop "(" C99ReprType.F32 " + "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Sub -> drop "(" C99ReprType.F32 " - "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Mul -> drop "(" C99ReprType.F32 " * "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32Div -> drop "(" C99ReprType.F32 " / "  C99ReprType.F32 ")" False C99ReprType.F32  Some c99-binop! }
    { F32ToInt -> drop "f32_to_int(" C99ReprType.F32 ")"  C99ReprType.Int Some c99-unop! }
    { F32ToF64 -> drop "(double)"  C99ReprType.F32 ""  C99ReprType.F64 Some c99-unop! }
    { F32ToStr -> drop "f32_to_str(" C99ReprType.F32 ")" C99ReprType.STR Some c99-unop! }
    { F32Get -> drop "*(float*)"  C99ReprType.PTR "" C99ReprType.F32 Some c99-unop! }
    { F32Set -> drop "*(float*)"  C99ReprType.PTR " = " C99ReprType.F32 ";" True None c99-binop! }

    { F64Eq  -> drop "(" C99ReprType.F64 " == " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Lt  -> drop "(" C99ReprType.F64 " < "  C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Le  -> drop "(" C99ReprType.F64 " <= " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Gt  -> drop "(" C99ReprType.F64 " > "  C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Ge  -> drop "(" C99ReprType.F64 " >= " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Ne  -> drop "(" C99ReprType.F64 " != " C99ReprType.F64 ")" False C99ReprType.Bool Some c99-binop! }
    { F64Add -> drop "(" C99ReprType.F64 " + "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Sub -> drop "(" C99ReprType.F64 " - "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Mul -> drop "(" C99ReprType.F64 " * "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64Div -> drop "(" C99ReprType.F64 " / "  C99ReprType.F64 ")" False C99ReprType.F64  Some c99-binop! }
    { F64ToInt -> drop "f64_to_int(" C99ReprType.F64 ")"  C99ReprType.Int Some c99-unop! }
    { F64ToF32 -> drop "(float)"   C99ReprType.F64 ""  C99ReprType.F32 Some c99-unop! }
    { F64ToStr -> drop "f64_to_str(" C99ReprType.F64 ")" C99ReprType.STR Some c99-unop! }
    { F64Get -> drop "*(double*)"  C99ReprType.PTR "" C99ReprType.F64 Some c99-unop! }
    { F64Set -> drop "*(double*)"  C99ReprType.PTR " = " C99ReprType.F64 ";" True None c99-binop! }

    { BoolTrue  -> drop C99ReprType.Bool push-value-expression!("true"  put) }
    { BoolFalse -> drop C99ReprType.Bool push-value-expression!("false" put) }
    { BoolAnd -> drop "(" C99ReprType.Bool " && " C99ReprType.Bool ")" False C99ReprType.Bool Some c99-binop! }
    { BoolOr  -> drop "(" C99ReprType.Bool " || " C99ReprType.Bool ")" False C99ReprType.Bool Some c99-binop! }
    { BoolNot -> drop "!" C99ReprType.Bool "" C99ReprType.Bool Some c99-unop! }

    { TupPack0 -> drop C99ReprType.Void push-value-expression!("NULL" put) }
    { TupPack1 -> drop 1u c99-tup-pack! }
    { TupPack2 -> drop 2u c99-tup-pack! }
    { TupPack3 -> drop 3u c99-tup-pack! }
    { TupPack4 -> drop 4u c99-tup-pack! }
    { TupPack5 -> drop 5u c99-tup-pack! }

    { TupUnpack0 -> drop C99ReprType.Void pop-value! drop-value! }
    { TupUnpack1 -> drop 1u c99-tup-unpack! }
    { TupUnpack2 -> drop 2u c99-tup-unpack! }
    { TupUnpack3 -> drop 3u c99-tup-unpack! }
    { TupUnpack4 -> drop 4u c99-tup-unpack! }
    { TupUnpack5 -> drop 5u c99-tup-unpack! }

    { MutGet    -> drop "mut_get(" C99ReprType.PTR ")" C99ReprType.VAL Some c99-unop! }
    { MutSet    -> drop "mut_set(" C99ReprType.VAL ", " C99ReprType.PTR ");" False None c99-binop! }
    { MutIsSet -> drop "mut_is_set(" C99ReprType.PTR ")" C99ReprType.Bool Some c99-unop! }

    { PtrGet -> drop "*(void**)"    C99ReprType.PTR "" C99ReprType.PTR Some c99-unop! }
    { PtrSet -> drop "*(void**)"    C99ReprType.PTR " = " C99ReprType.PTR ";" True None c99-binop! }
    { PtrNil -> drop C99ReprType.PTR push-value-expression!("(void*)0" put) }
    { PtrEq  -> drop "(" C99ReprType.PTR " == " C99ReprType.PTR ")" False C99ReprType.Bool Some c99-binop! }
    { PtrAdd -> drop "(void*)(" C99ReprType.I64 " + (char*)" C99ReprType.PTR ")" False C99ReprType.PTR Some c99-binop! }
    { PtrSize -> drop C99ReprType.U64 push-value-expression!("sizeof(void*)" put) }
    { PtrAlloc   -> drop "ptr_alloc(" C99ReprType.U64 ");" C99ReprType.PTR Some c99-unop! }
    { PtrRealloc -> drop "ptr_realloc(" C99ReprType.PTR "," C99ReprType.U64 ")" False C99ReprType.PTR Some  c99-binop! }
    { PtrFree    -> drop "free(" C99ReprType.PTR ");" None c99-unop! }
    { PtrCopy ->
        drop
        C99ReprType.PTR pop-value! >+dst
        C99ReprType.U64 pop-value! >+len
        C99ReprType.PTR pop-value! >+src
        c99-line (
            "ptr_copy(" put
                +src> C99ReprType.PTR consume-as put
            ", " put
                +len> C99ReprType.U64 consume-as put
            ", " put
                +dst> C99ReprType.PTR consume-as put
            ");" put
        )
    }
    { PtrFill ->
        drop
        C99ReprType.PTR pop-value! >+dst
        C99ReprType.U64 pop-value! >+len
        C99ReprType.U8  pop-value! >+val
        c99-line (
            "ptr_fill(" put
                +val> C99ReprType.U8  consume-as put
            ", " put
                +len> C99ReprType.U64 consume-as put
            ", " put
                +dst> C99ReprType.PTR consume-as put
            ");" put
        )
    }

    { StrCopy -> drop "str_make(" C99ReprType.PTR ", " C99ReprType.U64 ")" False C99ReprType.STR Some c99-binop! }
    { StrNumBytes -> drop "str_size(" C99ReprType.STR ")" C99ReprType.U64 Some c99-unop! }
    { StrBase      -> drop "str_base(" C99ReprType.STR ")" C99ReprType.PTR Some c99-unop! }
    { StrCat  -> drop "str_cat(" C99ReprType.STR ", " C99ReprType.STR ")" False C99ReprType.STR Some c99-binop! }
    { StrCmp  -> drop "str_cmp(" C99ReprType.STR ", " C99ReprType.STR ")" False C99ReprType.I64 Some c99-binop! }
    { StrEq   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") == 0)" False C99ReprType.Bool Some c99-binop! }
    { StrLt   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") < 0)"  False C99ReprType.Bool Some c99-binop! }
    { StrLe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") <= 0)" False C99ReprType.Bool Some c99-binop! }
    { StrGt   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") > 0)"  False C99ReprType.Bool Some c99-binop! }
    { StrGe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") >= 0)" False C99ReprType.Bool Some c99-binop! }
    { StrNe   -> drop "(str_cmp(" C99ReprType.STR ", " C99ReprType.STR ") != 0)" False C99ReprType.Bool Some c99-binop! }
    { StrToF32     -> args "str_to_f32"   Prim.StrToF32     type +c99:cname-type-to-c99-api c99-smart-call! }
    { StrToF64     -> args "str_to_f64"   Prim.StrToF64     type +c99:cname-type-to-c99-api c99-smart-call! }
    { StrToArray   -> args "str_to_arr"   Prim.StrToArray   type +c99:cname-type-to-c99-api c99-smart-call! }

    { ArrayNil    -> drop C99ReprType.ARR push-value-expression!("NULL" put) }
    { ArrayNew    -> args "arr_new"    Prim.ArrayNew    type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayExpand -> args "arr_expand" Prim.ArrayExpand type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayThaw   -> args "arr_thaw"   Prim.ArrayThaw   type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayBase   -> args "arr_base"   Prim.ArrayBase   type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayLen    -> args "arr_len"    Prim.ArrayLen    type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayGet    -> args "arr_get"    Prim.ArrayGet    type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArraySet    -> args "arr_set"    Prim.ArraySet    type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayPush   -> args "arr_push"   Prim.ArrayPush   type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayPop    -> args "arr_pop"    Prim.ArrayPop    type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayCat    -> args "arr_cat"    Prim.ArrayCat    type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArraySlice  -> args "arr_slice"  Prim.ArraySlice  type +c99:cname-type-to-c99-api c99-smart-call! }
    { ArrayToStr  -> args "arr_to_str" Prim.ArrayToStr  type +c99:cname-type-to-c99-api c99-smart-call! }

    { SysOs   -> drop C99ReprType.I64 push-value-expression!("RUNNING_OS" put) }
    { SysArch -> drop C99ReprType.I64 push-value-expression!("RUNNING_ARCH" put) }
    { SysArgc -> drop C99ReprType.U64 push-value-expression!("global_argc" put) }
    { SysArgv -> drop C99ReprType.PTR push-value-expression!("global_argv" put) }
}

def c99-tup-pack! [ +Mirth +C99Branch |- Nat -- ] {
    None >tag
    List(repeat(Type.Ignore StackTypePart.Cons ;)) >parts
    c99-pack-tuple! turn-into-value! push-value!
}

def c99-tup-unpack! [ +Mirth +C99Branch |- Nat -- ] {
    None >tag
    List(repeat(Type.Ignore StackTypePart.Cons ;)) >parts
    C99ReprType.TUP pop-value! turn-into-resource! c99-unpack-tuple!
}

def +C99Value.run-value! [ +Mirth +C99Branch |- +C99Value -- ] {
    consume-as-VAL flush-cache!
    c99-line("run_value(" put put ");" put)
}

def c99-binop! [ +Mirth +C99Branch |- Str C99ReprType Str C99ReprType Str Bool Maybe(C99ReprType) -- ] {
    >out-type >args-swapped
    >sfx >arg2-type >op >arg1-type >pfx

    args-swapped> if(
        arg1-type> dup pop-value! consume-as >arg1
        arg2-type> dup pop-value! consume-as >arg2,

        arg2-type> dup pop-value! consume-as >arg2
        arg1-type> dup pop-value! consume-as >arg1
    )

    out-type> match {
        { Some -> push-value-expression!(pfx> put arg1> put op> put arg2> put sfx> put) }
        { None -> c99-line(pfx> put arg1> put op> put arg2> put sfx> put) }
    }
}

def c99-unop! [ +Mirth +C99Branch |- Str C99ReprType Str Maybe(C99ReprType) -- ] {
    >out-type >sfx >arg-type >pfx
    arg-type> dup pop-value! consume-as
    out-type> match {
        { Some -> push-value-expression!(pfx> put put sfx> put) }
        { None -> c99-line(pfx> put put sfx> put) }
    }
}

def c99-args-push! [ +Mirth +C99Branch |- List(Arg) -- ] {
    for(c99-arg-push!)
}
def c99-arg-push! [ +Mirth +C99Branch |- Arg -- ] {
    { Block -> c99-block-push! }
}
def c99-arg-run! [ +Mirth +C99Branch |- Arg -- ] {
    { Block -> c99-block-run! }
}

def c99-block-run! [ +Mirth +C99Branch |- Block -- ] {
    arrow c99-codip-arrow!
}

def c99-pack-closure-vars! [ +Mirth +C99Branch |- List(Var) -- ] {
    filter(is-physical?) dup empty? if(
        drop,
        Type.Ignore StackTypePart.Cons
        over map(type StackTypePart.Cons) cons >parts
        None >tag
        for(var-dup! push-value!)
        c99-pack-tuple!
        turn-into-value!
        push-value!
    )
}

def c99-unpack-closure-vars! [ +Mirth +C99Branch |- List(Var) -- +closure:+Maybe(+C99Value) ] {
    filter(is-physical?) dup empty? if(
        +None >+closure
        drop,
        C99ReprType.TUP pop-value! >+tup
        @+tup:rdup consume-as-TUP >tup
        1 >i
        for(
            dup type type-to-c99-repr
            dup value-expression! (
                v-macro (
                    "((TUP*)PTRPTR(" put
                    @tup put
                    "))->cells[" put
                    @i >Str put
                    "]" put
                )
            )
            push-to-env!
            @i:1+
        )
        i> drop
        tup> drop
        +tup> +Some >+closure
    )
}

def c99-block-push! [ +Mirth +C99Branch |- Block -- ] {
    dup to-run-var match(
        Some -> nip c99-var-push!,
        None ->
            C99ReprType.FNPTR push-value-expression!("&" put dup cname put)
            dup free-vars c99-pack-closure-vars!
            drop
    )
}

def c99-var! [ +Mirth +C99Branch |- Var -- ] {
    dup auto-run? if(c99-var-run!, c99-var-push!)
}

def c99-var-run! [ +Mirth +C99Branch |- Var -- ] {
    var-dup! run-value!
}

def c99-var-push! [ +Mirth +C99Branch |- Var -- ] {
    var-dup! push-value!
}

def reverse-pop-values-to-env! [ +Mirth +C99Branch |- List(Var) -- ] {
    { Nil -> id }
    { Cons ->
        over type type-to-c99-repr pop-value!
        rdip(reverse-pop-values-to-env!)
        push-to-env!
    }
}

def pop-values-to-env! [ +Mirth +C99Branch |- List(Var) -- ] {
    reverse reverse-pop-values-to-env!
}

def drop-env-var! [ +Mirth +C99Branch |- Var -- ] {
    pop-from-env!
    = else("[c99] unexpected variable in environment when exiting scope" fatal-error!)
    drop-value!
}

def drop-env-vars! [ +Mirth +C99Branch |- List(Var) -- ] {
    reverse-for(drop-env-var!)
}

def c99-lambda! [ +Mirth +C99Branch |- Lambda -- ] {
    dup params pop-values-to-env!
    dup body c99-arrow!
    params drop-env-vars!
}

def c99-match! [ +Mirth +C99Branch |- Match -- ] {
    dup cases single? if?(
        nip c99-single-case!,

        dup scrutinee-data?
        unwrap(token "non-uniform match, not supported at present" emit-fatal-error!)
        \data
        @data pop-data! >+scrutinee



        dup cod begin-branch-split!
        c99-line("switch (" put @+scrutinee:peek-data-tag put ") {" put)
        c99-nest(
            dup cases for(@+scrutinee:rdup >+scrutinee c99-case!)
            has-default-case? else(
                c99-line("default: {" put)
                c99-nest(
                    c99-line("do_panic(str_make(\"unexpected fallthrough in match\\n\", 32));" put)
                )
                c99-line("}" put)
            )
            +scrutinee> rdrop
        )
        c99-line("}" put)
        end-branch-split!
    )
}

def c99-single-case! [ +Mirth +C99Branch |- Case -- ] {
    dup pattern is-default? if(
        body c99-arrow!,

    dup pattern single-tag? if?(
        c99-reverse-tag!
        body c99-arrow!,

        pattern token-start "c99 target -- don't know how to compile this pattern"
        emit-fatal-error!
    ))
}

def c99-case! [ +Mirth +C99BranchSplit |- Case +scrutinee:+C99Value/Resource -- ] {
    dup pattern is-default? if(
        c99-line("default: {" put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            body c99-arrow!
        )
        c99-line("} break;" put),

    dup pattern single-tag? if?(
        c99-line("case " put dup value-show put "LL: { // " put dup name >Str put)
        c99-nest:sub-branch(
            +scrutinee> push-value/resource!
            c99-reverse-tag!
            body c99-arrow!
        )
        c99-line("} break;" put),

        pattern token-start "c99 target -- don't know how to compile this pattern"
        emit-fatal-error!
    ))
}

def Tag.word-cname-type [ +Mirth |- Tag -- Str ArrowType ] { sip:word-cname type }
def Tag.pat-cname-type  [ +Mirth |- Tag -- Str ArrowType ] { sip:pat-cname type invert }
def Word.cname-type     [ +Mirth |- Word -- Str ArrowType ] { sip:cname type }

field(Tag.~word-c99-api, Tag, C99API)
def Tag.word-c99-api [ +Mirth +C99 |- Tag -- C99API ] {
    dup ~word-c99-api memoize(dup word-cname-type cname-type-to-c99-api) nip
}

field(Tag.~pat-c99-api, Tag, C99API)
def Tag.pat-c99-api [ +Mirth +C99 |- Tag -- C99API ] {
    dup ~pat-c99-api memoize(dup pat-cname-type cname-type-to-c99-api) nip
}

field(Word.~c99-api, Word, C99API)
def Word.c99-api [ +Mirth +C99 |- Word -- C99API ] {
    dup ~c99-api memoize(dup cname-type cname-type-to-c99-api) nip
}

def c99-word-sigs! [ +Mirth +C99 |- ] { Word.for(dup +needs(needed?) if(c99-word-sig!, drop)) }
def c99-word-sig!  [ +Mirth +C99 |- Word -- ] { c99-api c99-smart-sig! }

def c99-block-sigs! [ +Mirth +C99 |- ] { Block.for(dup +needs(needed?) if(c99-block-sig!, drop)) }
def c99-block-sig!  [ +Mirth +C99 |- Block -- ] { c99-line(c99-block-sig-put ";" put) }

def c99-block-defs! [ +Mirth +C99 |- ] { Block.for(dup +needs(needed?) if(c99-block-def!, drop)) }
def c99-block-def!  [ +Mirth +C99 |- Block -- ] {
    c99-line(dup c99-block-sig-put " {" put)
    reset-fresh-counter!
    c99-nest(
        dup c99-block-enter!
        dup arrow
        dup free-vars c99-unpack-closure-vars!
        dup type dom expose-stack-type!
        c99-arrow!
        +closure> +if(drop-value!, id)
        c99-block-exit!
    )
    c99-line("}" put)
}

def c99-block-sig-put [ +Mirth +C99 |- Block -- ] { "static void " put cname put " (void)" put }

def c99-block-enter! [ +Mirth |- Block +C99 -- +C99Branch ] {
    options emit-debug-info if(
        c99-line("WORD_ENTER(" put
            dup home match(
                Main -> drop "block",
                Word -> name >Str " block" cat,
            ) put-cstr ", " put
            dup token module source-path >Str put-cstr ", " put
            dup token row >Int >Str put ", " put
            dup token col >Int >Str put ");" put
        ) drop,
        drop
    )
    True >reachable
    List.Nil >env
    start-branch!
}

def c99-block-exit! [ +Mirth |- Block +C99Branch -- +C99 ] {
    end-branch!
    reachable> drop
    env> drop
    options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def expose-stack-type! [ +Mirth +C99Branch |- StackType -- ] {
    expand match {
        { Cons -> type-to-c99-repr pop-value! rdip:expose-stack-type! push-value! }
        { With -> resource-to-c99-repr pop-resource! rdip:expose-stack-type! push-resource! }
        { ConsLabel ->
            >label type-to-c99-repr @label pop-value-label!
            rdip:expose-stack-type! label> push-value-label! }
        { WithLabel ->
            >label resource-to-c99-repr @label pop-resource-label!
            rdip:expose-stack-type! label> push-resource-label! }
        { _ -> drop }
    }
}

def c99-word-enter! [ +Mirth +C99Branch |- Word -- ] {
    +c99:options emit-debug-info then(
        c99-line(
            "WORD_ENTER(" put
            dup name >Str put-cstr ", " put
            dup body module source-path >Str put-cstr ", " put
            dup body row >Int >Str put ", " put
            dup body col >Int >Str put ");" put
        )
    ) drop
}

def c99-word-exit! [ +Mirth +C99Branch |- Word -- ] {
    +c99:options emit-debug-info if(
        c99-line("WORD_EXIT;" put) drop,
        drop
    )
}

def c99-word-defs! [ +Mirth +C99 |- ] { Word.for(dup +needs(needed?) if(c99-word-def!, drop)) }
def c99-word-def!  [ +Mirth +C99 |- Word -- ] {
    dup c99-api c99-smart-def! (
        dup c99-word-enter!
        dup arrow c99-arrow!
        dup c99-word-exit!
    )
    drop
}

def c99-field-defs! [ +Mirth +C99 |- ] { Field.for(c99-field-def!) }
def c99-field-def!  [ +Mirth +C99 |- Field -- ] { c99-line("static FIELD " put cname put " = {0};" put) }
def c99-field-call! [ +Mirth +C99Branch |- Field -- ] {
    dup index-type type-to-c99-repr \indexrepr
    @indexrepr pop-value! >+index
    C99ReprType.PTR push-value-expression! (
        "field_mut(&" put
        cname put
        ", " put
        +index> consume put
        ")" put
    )
}

def c99-main! [ +Mirth +C99 |- Arrow -- ] {
    c99-line("int main (int argc, char** argv) {" put)
    reset-fresh-counter!
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        options emit-debug-info then(
            c99-line("WORD_ENTER(" put
                "\"<main>\", " put
                dup token-start module source-path >Str put-cstr ", " put
                dup token-start row >Int >Str put ", " put
                dup token-start col >Int >Str put ");" put)
        )
        True \reachable
        List.Nil \env
        start-branch!
        C99ReprType.Void push-resource-expression!("0" put)
        c99-arrow!
        end-branch!
        options emit-debug-info then(
            c99-line("WORD_EXIT;" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put)
}
