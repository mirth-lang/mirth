module mirth.def

import std.prelude
import std.maybe
import std.list
import std.str

import mirth.mirth
import mirth.name
import mirth.alias
import mirth.buffer
import mirth.data
import mirth.external
import mirth.module
import mirth.package
import mirth.prim
import mirth.table
import mirth.token
import mirth.tycon
import mirth.type
import mirth.typedef
import mirth.variable
import mirth.word
import mirth.macro

data Def {
    DefAlias [ Alias ]
    DefModule [ Module ]
    DefPackage [ Package ]
    DefData [ Data ]
    DefTable [ Table ]
    DefType [ TypeDef ]
    DefTag [ Tag ]
    DefPrim [ Prim ]
    DefWord [ Word ]
    DefBuffer [ Buffer ]
    DefVariable [ Variable ]
    DefExternal [ External ]
    DefField [ Field ]
    DefMacro [ Macro ]
    --

    def package? { DefPackage -> Maybe.Some, _ -> drop Maybe.None }
    def module? { DefModule -> Maybe.Some, _ -> drop Maybe.None }
    def alias? { DefAlias -> Maybe.Some, _ -> drop Maybe.None }
    def data? { DefData -> Maybe.Some, _ -> drop Maybe.None }
    def table? { DefTable -> Maybe.Some, _ -> drop Maybe.None }
    def typedef? { DefType -> Maybe.Some, _ -> drop Maybe.None }
    def tag? { DefTag -> Maybe.Some, _ -> drop Maybe.None }
    def prim? { DefPrim -> Maybe.Some, _ -> drop Maybe.None }
    def word? { DefWord -> Maybe.Some, _ -> drop Maybe.None }
    def buffer? { DefBuffer -> Maybe.Some, _ -> drop Maybe.None }
    def variable? { DefVariable -> Maybe.Some, _ -> drop Maybe.None }
    def external? { DefExternal -> Maybe.Some, _ -> drop Maybe.None }
    def field? { DefField -> Maybe.Some, _ -> drop Maybe.None }
    def macro? { DefMacro -> Maybe.Some, _ -> drop Maybe.None }

    def == [ Def Def -- Bool ] {
        { DefPackage -> Maybe.Some swap package? == }
        { DefModule -> Maybe.Some swap module? == }
        { DefAlias -> Maybe.Some swap alias? == }
        { DefData -> Maybe.Some swap data? == }
        { DefTable -> Maybe.Some swap table? == }
        { DefType -> Maybe.Some swap typedef? == }
        { DefTag -> Maybe.Some swap tag? == }
        { DefPrim -> Maybe.Some swap prim? == }
        { DefWord -> Maybe.Some swap word? == }
        { DefBuffer -> Maybe.Some swap buffer? == }
        { DefVariable -> Maybe.Some swap variable? == }
        { DefExternal -> Maybe.Some swap external? == }
        { DefField -> Maybe.Some swap field? == }
        { DefMacro -> Maybe.Some swap macro? == }
    }

    def typecheck! [ +Mirth Def -- +Mirth ] {
        { DefPackage -> drop }
        { DefModule -> drop }
        { DefAlias -> target typecheck! }
        { DefData -> drop }
        { DefTable -> drop }
        { DefType -> target drop }
        { DefTag -> type drop }
        { DefPrim -> drop }
        { DefWord -> dup type drop arrow drop }
        { DefBuffer -> drop }
        { DefVariable -> type drop }
        { DefExternal -> type drop }
        { DefField -> type drop }
        { DefMacro -> drop }
    }

    def callable? [ +Mirth Def -- +Mirth Bool ] {
        { DefAlias -> ~target try-force! has(callable?) }
        { DefPackage -> drop Bool.False }
        { DefModule -> drop Bool.False }
        { DefBuffer -> drop Bool.True }
        { DefPrim -> drop Bool.True }
        { DefData -> drop Bool.False }
        { DefTable -> drop Bool.False }
        { DefType -> drop Bool.False }
        { DefExternal -> drop Bool.True }
        { DefWord -> drop Bool.True }
        { DefField -> drop Bool.True }
        { DefTag -> drop Bool.True }
        { DefVariable -> drop Bool.True }
        { DefMacro -> action callable? }
    }

    def defines-a-type? [ +Mirth Def -- +Mirth Bool ] {
        { DefAlias -> ~target try-force! has(defines-a-type?) }
        { DefPackage -> drop Bool.False }
        { DefModule -> drop Bool.False }
        { DefBuffer -> drop Bool.False }
        { DefPrim -> drop Bool.False }
        { DefData -> drop Bool.True }
        { DefTable -> drop Bool.True }
        { DefType -> drop Bool.True }
        { DefExternal -> drop Bool.False }
        { DefWord -> drop Bool.False }
        { DefField -> drop Bool.False }
        { DefTag -> drop Bool.False }
        { DefVariable -> drop Bool.False }
        { DefMacro -> drop Bool.False }
    }

    def exposed-tycon? [ +Mirth Def -- +Mirth Maybe(Tycon) ] {
        { DefAlias -> ~target try-force! bind(exposed-tycon?) }
        { DefPackage -> drop Maybe.None }
        { DefModule -> drop Maybe.None }
        { DefData -> Tycon.TYCON_DATA Maybe.Some }
        { DefTable -> Tycon.TYCON_TABLE Maybe.Some }
        { DefType -> target tycon? }
        { DefBuffer -> drop Maybe.None }
        { DefPrim -> drop Maybe.None }
        { DefExternal -> drop Maybe.None }
        { DefWord -> drop Maybe.None }
        { DefField -> drop Maybe.None }
        { DefTag -> drop Maybe.None }
        { DefVariable -> drop Maybe.None }
        { DefMacro -> drop Maybe.None }
    }

    def head? [ Def -- Maybe(Token) ] {
        { DefAlias -> head Maybe.Some }
        { DefPackage -> drop Maybe.None }
        { DefModule -> start Maybe.Some }
        { DefData -> head? }
        { DefTable -> head Maybe.Some }
        { DefType -> head? }
        { DefBuffer -> drop Maybe.None }
        { DefPrim -> drop Maybe.None }
        { DefExternal -> head Maybe.Some }
        { DefWord -> head Maybe.Some }
        { DefField -> head Maybe.Some }
        { DefTag -> .data head? }
        { DefVariable -> head Maybe.Some }
        { DefMacro -> head? }
    }

    def defining-module? [ Def -- Maybe(Module) ] {
        head? map(.module)
    }

    def same-resolved? [ +Mirth Def Def -- +Mirth Bool ] {
        on2(resolve) ==
    }

    def resolve [ +Mirth Def -- +Mirth Def ] {
        while-some(dup alias?, nip target)
    }

    def name [ Def -- Name ] {
        { DefAlias -> name }
        { DefPackage -> name }
        { DefModule -> name }
        { DefBuffer -> name }
        { DefPrim -> name }
        { DefData -> name }
        { DefTable -> name }
        { DefType -> name }
        { DefExternal -> name }
        { DefWord -> name }
        { DefField -> name }
        { DefTag -> name }
        { DefVariable -> name }
        { DefMacro -> name }
    }

    def arity [ Def -- Int ] {
        { DefAlias -> arity }
        { DefPackage -> drop 0 }
        { DefModule -> drop 0 }
        { DefBuffer -> drop 0 }
        { DefPrim -> arity }
        { DefData -> arity }
        { DefTable -> drop 0 }
        { DefType -> drop 0 }
        { DefExternal -> arity }
        { DefWord -> arity >Int }
        { DefField -> drop 0 }
        { DefTag -> drop 0 }
        { DefVariable -> drop 0 }
        { DefMacro -> arity }
    }

    def qname-soft [ +Mirth Def -- +Mirth Maybe(QName) ] {
        { DefAlias -> qname-soft }
        { DefPackage -> qname Maybe.Some }
        { DefModule -> qname Maybe.Some }
        { DefBuffer -> qname Maybe.Some }
        { DefPrim -> qname Maybe.Some }
        { DefData -> qname-soft }
        { DefTable -> qname-soft }
        { DefType -> qname-soft }
        { DefExternal -> qname-soft }
        { DefWord -> qname-soft }
        { DefField -> qname-soft }
        { DefTag -> qname Maybe.Some }
        { DefVariable -> qname Maybe.Some }
        { DefMacro -> qname-soft }
    }

    def qname-hard [ +Mirth Def -- +Mirth QName ] {
        { DefAlias -> qname-hard }
        { DefPackage -> qname }
        { DefModule -> qname }
        { DefBuffer -> qname }
        { DefPrim -> qname }
        { DefData -> qname-hard }
        { DefTable -> qname-hard }
        { DefType -> qname-hard }
        { DefExternal -> qname-hard }
        { DefWord -> qname-hard }
        { DefField -> qname-hard }
        { DefTag -> qname }
        { DefVariable -> qname }
        { DefMacro -> qname-hard }
    }

    def as-namespace? [ +Mirth Def -- +Mirth Maybe(Namespace) ] {
        { DefAlias -> ~target try-force! bind(as-namespace?) }
        { DefPackage -> Namespace.NAMESPACE_PACKAGE Maybe.Some }
        { DefModule -> Namespace.NAMESPACE_MODULE Maybe.Some }
        { DefData -> Tycon.TYCON_DATA Namespace.NAMESPACE_TYCON Maybe.Some }
        { DefTable -> Tycon.TYCON_TABLE Namespace.NAMESPACE_TYCON Maybe.Some }
        { DefType -> target tycon? map(Namespace.NAMESPACE_TYCON) }
        { DefWord -> Namespace.NAMESPACE_WORD Maybe.Some }
        { _ -> drop Maybe.None }
    }

    def register [ +Mirth Def -- +Mirth ] {
        dup qname-soft for(
            dup undefined-soft? else(
                >Str "qualified name already has definition: " swap cat fatal-error!
            ) drop
        )
        dup name ~defs modify(List.Cons)
    }
}
