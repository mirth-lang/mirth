module(prelude/common)

trip : a -- a a a
trip = dup dup

rotr : a b c -- c a b
rotr = swap dip(swap)

rotl : a b c -- b c a
rotl = dip(swap) swap

over : a b -- a b a
over = dip(dup) swap

tuck : a b -- b a b
tuck = dup dip(swap)

nip : a b -- b
nip = dip(drop)

dup2 : a b -- a b a b
dup2 = over over

dup3 : a b c -- a b c a b c
dup3 = dip(dup2) dup dip(rotr)

drop2 : a b --
drop2 = drop drop

drop3 : a b c --
drop3 = drop drop drop

def-type(Byte, U8)
def-type(Char, U8)
def-type(Str, Ptr)
def-type(Size, Int)
def-type(Offset, Int)

cast : a -- b
cast = prim.unsafe.cast

Int->Ptr : Int -- Ptr
Int->Ptr = cast

Ptr->Int : Ptr -- Int
Ptr->Int = cast

U8_MAX : Int
U8_MAX = 0xFF

U16_MAX : Int
U16_MAX = 0xFFFF

U32_MAX : Int
U32_MAX = 0xFFFFFFFF

I8_MAX : Int
I8_MAX = 0x7F

I16_MAX : Int
I16_MAX = 0x7FFF

I32_MAX : Int
I32_MAX = 0x7FFFFFFF


U8_MIN : Int
U8_MIN = 0

U16_MIN : Int
U16_MIN = 0

U32_MIN : Int
U32_MIN = 0

I8_MIN : Int
I8_MIN = -0x80

I16_MIN : Int
I16_MIN = -0x8000

I32_MIN : Int
I32_MIN = -0x80000000

not : Bool -- Bool
not = false ==

!= : a a -- Bool
!= = == not

> : Int Int -- Bool
> = swap <

>= : Int Int -- Bool
>= = swap <=

0= : Int -- Bool
0= = 0 ==

0< : Int -- Bool
0< = 0 <

1+ : Int -- Int
1+ = 1 +

1- : Int -- Int
1- = 1 -

max : Int Int -- Int
max = dup2 < if(nip, drop)

min : Int Int -- Int
min = dup2 < if(drop, nip)

square : Int -- Int
square = dup *

nonzero : Int -- Bool
nonzero = 0 !=

ptr+ : Int Ptr -- Ptr
ptr+ = prim.unsafe.ptr+

ptr@ : Ptr -- Ptr
ptr@ = @ Int->Ptr

ptr! : Ptr Ptr --
ptr! = dip(Ptr->Int) !

ptrs : Size -- Size
ptrs = prim.unsafe.|ptr| *

ptr@@ : Offset Ptr -- Ptr
ptr@@ = dip(ptrs) ptr+ ptr@

ptr!! : Ptr Offset Ptr --
ptr!! = dip(ptrs) ptr+ ptr!

u8@@ : Offset Ptr -- Byte
u8@@ = ptr+ u8@

u8!! : Byte Offset Ptr --
u8!! = ptr+ u8!

ints : Size -- Size
ints = 8 *

@@ : Offset Ptr -- Int
@@ = dip(ints) ptr+ @

!! : Int Offset Ptr --
!! = dip(ints) ptr+ !

in-range : Int Int Int -- Bool
in-range = dip(over dip(>=)) <= &&

Int->U8 : Int -- U8
Int->U8 =
    dup U8_MIN U8_MAX in-range if(
        cast,
        "Int->U8 failed: out of bounds" panic!
    )

Int->U16 : Int -- U16
Int->U16 =
    dup U16_MIN U16_MAX in-range if(
        cast,
        "Int->U16 failed: out of bounds" panic!
    )

Int->U32 : Int -- U32
Int->U32 =
    dup U32_MIN U32_MAX in-range if(
        cast,
        ??
        "Int->U32 failed: out of bounds" panic!
    )

Int->U64 : Int -- U64
Int->U64 = cast

Int->I8 : Int -- I8
Int->I8 =
    dup I8_MIN I8_MAX in-range if(
        cast,
        "Int->I8 failed: out of bounds" panic!
    )

Int->I16 : Int -- I16
Int->I16 =
    dup I16_MIN I16_MAX in-range if(
        cast,
        "Int->I16 failed: out of bounds" panic!
    )

Int->I32 : Int -- I32
Int->I32 =
    dup I32_MIN I32_MAX in-range if(
        cast,
        "Int->I32 failed: out of bounds" panic!
    )

Int->I64 : Int -- I64
Int->I64 = cast

U8->Int : U8 -- Int
U8->Int = cast

U16->Int : U16 -- Int
U16->Int = cast

U32->Int : U32 -- Int
U32->Int = cast

U64->Int : U64 -- Int
U64->Int = cast

I8->Int : I8 -- Int
I8->Int = cast

I16->Int : I16 -- Int
I16->Int = cast

I32->Int : I32 -- Int
I32->Int = cast

I64->Int : I64 -- Int
I64->Int = cast

negate : Int -- Int
negate = -1 *

abs : Int -- Int
abs = dup 0< if(negate, id)

def-type(OS, Int)

UNKNOWN : OS
UNKNOWN = 0

WIN32 : OS
WIN32 = 1

LINUX : OS
LINUX = 2

MACOS : OS
MACOS = 3

###########
# STRINGS #
###########

# TODO: UTF8 support
str-head : Str -- U8
str-head = u8@

# TODO: UTF8 support
str-tail : Str -- Str
str-tail = 1 swap ptr+

str-length : Str -- Int
str-length =
    0 swap while(
        str-null? not,
        dip(1+) str-tail
    ) drop

str-null : Str -- Bool
str-null = u8@ U8->Int 0=

str-null? : Str -- Str Bool
str-null? = dup str-null

str-copy! : Str Str --
str-copy! = (
    while( over u8@ U8->Int nonzero,
        over u8@ over u8!
        dip(str-tail) str-tail
    )
    dip(drop 0 Int->U8) u8!
)

STR_BUF_SIZE : Int
STR_BUF_SIZE = 0x1000
buffer(STR_BUF, 0x1000)
buffer(STR_BUF_LEN, 8)

str-buf-length? : Int +StrBuf
str-buf-length? = STR_BUF_LEN @

str-buf-length! : Int -- +StrBuf
str-buf-length! = (
    dup STR_BUF_LEN !
    dip(0 Int->U8) str-buf-u8!
)

str-buf-u8@ : Offset -- U8 +StrBuf
str-buf-u8@ = STR_BUF u8@@

str-buf-u8! : U8 Offset -- +StrBuf
str-buf-u8! = STR_BUF u8!!

str-buf-empty? : Bool +StrBuf
str-buf-empty? = str-buf-length? 0=

str-buf-full? : Bool +StrBuf
str-buf-full? = str-buf-length? 1+ STR_BUF_SIZE >=

str-buf-clear! : +StrBuf
str-buf-clear! = 0 str-buf-length!

str-buf-push! : U8 -- +StrBuf
str-buf-push! =
    str-buf-full? if(
        "str-buf-push! but STR_BUF is already full" panic!,
        str-buf-length? str-buf-u8!
        str-buf-length? 1+ str-buf-length!
    )

||| Append the given string into STR_BUF. If the string is
||| too large it gets truncated.
str-buf-push-str! : Str -- +StrBuf
str-buf-push-str! =
    while(
        str-buf-full? if(false, dup u8@ U8->Int nonzero),
        dup u8@ str-buf-push!
        str-tail
    ) drop

||| Set the STR_BUF to a given string. If the string is
||| too large it gets truncated.
str-buf! : Str -- +StrBuf
str-buf! = str-buf-clear! str-buf-push-str!

# TODO UTF8 support?
str-buf-char! : Char -- +StrBuf
str-buf-char! = 0 str-buf-u8! 1 str-buf-length!

to-digit : Int -- U8
to-digit = 10 % 48 + Int->U8

||| Put integer into STR_BUF.
str-buf-int! : Int -- +StrBuf
str-buf-int! =
    dup 0= if(
        drop "0" str-buf!,
        dup dip(
            abs
            str-buf-clear!
            while(dup nonzero, dup to-digit str-buf-push! 10 /) drop
        ) 0 < if(45 Int->U8 str-buf-push!, id)
        str-buf-reverse!
    )

||| Swap two bytes in STR_BUF.
str-buf-swap-u8! : Int Int -- +StrBuf
str-buf-swap-u8! = (
    dup2 swap
    dip(dip(dip(str-buf-u8@)))
    dip(str-buf-u8@)
    str-buf-u8! str-buf-u8!
)

||| Reverse contents of STR_BUF bytewise.
str-buf-reverse! : +StrBuf
str-buf-reverse! = (
    0 str-buf-length? 1-
    while(dup2 <,
        dup2 str-buf-swap-u8!
        dip(1+) 1-
    )
    drop2
)

||| Are two strings equal?
str-eq : Str Str -- Bool
str-eq =
    str-null? if(
        drop str-null,
        dup2 str-head swap str-head == if(
            str-tail swap str-tail str-eq,
            drop2 false
        )
    )

||| Are two strings equal? Preserve pointers.
str-eq? : Str Str -- Str Str Bool
str-eq? = dup2 str-eq

##########
# TUPLES #
##########

||| Return the "nil" pack, i.e. null.
||| Attempts to uncons "nil" will result in a panic.
pack-nil : [*a]
pack-nil = prim.pack.nil cast

||| Is this a nil pack?
pack-nil? : [*a] -- [*a] Bool
pack-nil? = dup pack-nil ==

||| Construct a tuple by appending an element.
pack-cons : [*a] b -- [*a b]
pack-cons = prim.pack.cons

||| Deconstruct a tuple by splitting it at its last element.
pack-uncons : [*a b] -- [*a] b
pack-uncons =
    pack-nil? if(
        "attempted to uncons nil" panic!,
        prim.pack.uncons
    )

def(pack0, [], pack-nil)
def(pack1, a -- [a], dip(pack0) pack-cons)
def(pack2, a b -- [a b], dip(pack1) pack-cons)
def(pack3, a b c -- [a b c], dip(pack2) pack-cons)
def(pack4, a b c d -- [a b c d], dip(pack3) pack-cons)
def(pack5, a b c d e -- [a b c d e], dip(pack4) pack-cons)

def(unpack0, [] --, drop)
def(unpack1, [a] -- a, pack-uncons dip(unpack0))
def(unpack2, [a b] -- a b, pack-uncons dip(unpack1))
def(unpack3, [a b c] -- a b c, pack-uncons dip(unpack2))
def(unpack4, [a b c d] -- a b c d, pack-uncons dip(unpack3))
def(unpack5, [a b c d e] -- a b c d e, pack-uncons dip(unpack4))

def(.0, [*a b] -- b, pack-uncons nip)
def(.1, [*a b c] -- b, pack-uncons drop .0)
def(.2, [*a b c d] -- b, pack-uncons drop .1)
def(.3, [*a b c d e] -- b, pack-uncons drop .2)
def(.4, [*a b c d e f] -- b, pack-uncons drop .3)

def(.0?, [*a b] -- [*a b] b, dup .0)
def(.1?, [*a b c] -- [*a b c] b, dup .1)
def(.2?, [*a b c d] -- [*a b c d] b, dup .2)
def(.3?, [*a b c d e] -- [*a b c d e] b, dup .3)
def(.4?, [*a b c d e f] -- [*a b c d e f] b, dup .4)

def(.0!, [*a b] b -- [*a b], dip(pack-uncons drop) pack-cons)
def(.1!, [*a b c] b  -- [*a b c], dip(pack-uncons) swap dip(.0!) pack-cons)
def(.2!, [*a b c d] b  -- [*a b c d], dip(pack-uncons) swap dip(.1!) pack-cons)
def(.3!, [*a b c d e] b  -- [*a b c d e], dip(pack-uncons) swap dip(.2!) pack-cons)
def(.4!, [*a b c d e f] b  -- [*a b c d e f], dip(pack-uncons) swap dip(.3!) pack-cons)

#########
# LISTS #
#########

nominal(List(t), [])
def(list->pack, List(t) -- [List(t) t], cast)
def(pack->list, [List(t) t] -- List(t), cast)
def(nil, List(t), pack-nil pack->list)
def(nil?, List(t) -- List(t) Bool, dup nil ==)
def(cons, List(t) t -- List(t), pack2 pack->list)
def(uncons, List(t) -- List(t) t,
    nil? if(
        "uncons on nil value" panic!,
        list->pack unpack2
    ))
def(head, List(t) -- t, uncons nip)
def(tail, List(t) -- List(t), uncons drop)
def(length, List(t) -- Int,
    0 swap
    while(nil? not, dip(1+) tail)
    drop)
def(length?, List(t) -- List(t) Int, dup length)

######
# IO #
######

def(panic!, *a Str -- *b +IO,
    "panic: " str-trace! str-trace-ln! 1 posix-exit!)

nominal(File, Int)
def(File->Int, File -- Int, cast)
def(Int->File, Int -- File, cast)
def(|File|, Size, 8)
def(file@, Ptr -- File, @ Int->File)
def(file!, File Ptr --, dip(File->Int) !)

def(stdin,  File, 0 Int->File)
def(stdout, File, 1 Int->File)
def(stderr, File, 2 Int->File)

def(str-write!, Str File -- +IO,
    File->Int swap dup str-length posix-write!)

def(str-print!, Str -- +IO, stdout str-write!)
def(str-trace!, Str -- +IO, stderr str-write!)
def(str-print-sp!, Str -- +IO, str-print! print-sp!)
def(str-trace-sp!, Str -- +IO, str-trace! trace-sp!)
def(str-print-ln!, Str -- +IO, str-print! print-ln!)
def(str-trace-ln!, Str -- +IO, str-trace! trace-ln!)

def(print-ln!, +IO, 10 Int->U8 print-char!)
def(trace-ln!, +IO, 10 Int->U8 trace-char!)
def(print-sp!, +IO, 32 Int->U8 print-char!)
def(trace-sp!, +IO, 32 Int->U8 trace-char!)
def(trace-quote!, +IO, 34 Int->U8 trace-char!)

def(str-buf-write!, File -- +StrBuf, File->Int STR_BUF str-buf-length? posix-write!)
def(str-buf-print!, +StrBuf, stdout str-buf-write!)
def(str-buf-trace!, +StrBuf, stderr str-buf-write!)
def(str-buf-read!, File -- +IO,
    File->Int str-buf-clear!
    STR_BUF STR_BUF_SIZE 1- posix-read!
    dup 0< if(
        "str-buf-read! failed" panic!,
        str-buf-length!
    ))
def(str-buf-input!, -- +IO, stdin str-buf-read!)

def(print-char!, Char -- +IO, str-buf-char! str-buf-print!)
def(trace-char!, Char -- +IO, str-buf-char! str-buf-trace!)

def(int-write!, Int File -- +IO, dip(str-buf-int!) str-buf-write!)
def(int-print!, Int -- +IO, stdout int-write!)
def(int-trace!, Int -- +IO, stderr int-write!)
def(int-print-sp!, Int -- +IO, int-print! print-sp!)
def(int-trace-sp!, Int -- +IO, int-trace! trace-sp!)
def(int-print-ln!, Int -- +IO, int-print! print-ln!)
def(int-trace-ln!, Int -- +IO, int-trace! trace-ln!)

def(open-file!, Str -- File +IO,
    0 0 posix-open!
    dup 0 < if("Failed to open file!" panic!, Int->File))

def(create-file!, Str -- File +IO,
    O_WRONLY|O_CREAT|O_TRUNC
    0x1B6
        # this is the default mode for creating a file
        # on unix, 666 in octal, i.e. owner can
        # read+write, everyone can read
    posix-open!
    dup 0 < if("Failed to create file!" panic!, Int->File))

def(O_WRONLY|O_CREAT|O_TRUNC, Int,
    RUNNING_OS MACOS == if(
        0x601, # O_WRONLY = 0x1, O_CREAT = 0x200, O_TRUNC = 0x400
    RUNNING_OS LINUX == if(
        0x241, # O_WRONLY = 0x1, O_CREAT = 0x40, O_TRUNC = 0x200
    RUNNING_OS WIN32 == if(
        0x301, # O_WRONLY = 0x1, O_CREAT|O_TRUNC = 0x300
        "O_WRONLY|O_CREAT|O_TRUNC not known for os" panic!
    ))))

def(close-file!, File -- +IO,
    File->Int posix-close!
    0 < if("failed to close file" panic!, id))
