module(prelude/common)

trip : a -- a a a
trip = dup dup

rotr : a b c -- c a b
rotr = swap dip(swap)

rotl : a b c -- b c a
rotl = dip(swap) swap

over : a b -- a b a
over = dip(dup) swap

tuck : a b -- b a b
tuck = dup dip(swap)

nip : a b -- b
nip = dip(drop)

dup2 : a b -- a b a b
dup2 = over over

dup3 : a b c -- a b c a b c
dup3 = dip(dup2) dup dip(rotr)

drop2 : a b --
drop2 = drop drop

drop3 : a b c --
drop3 = drop drop drop

def-type(Byte, U8)
def-type(Char, U8)
def-type(Str, Ptr)
def-type(Size, Int)
def-type(Offset, Int)

cast : a -- b
cast = prim.unsafe.cast

Int->Ptr : Int -- Ptr
Int->Ptr = cast

Ptr->Int : Ptr -- Int
Ptr->Int = cast

U8_MAX : Int
U8_MAX = 0xFF

U16_MAX : Int
U16_MAX = 0xFFFF

U32_MAX : Int
U32_MAX = 0xFFFFFFFF

I8_MAX : Int
I8_MAX = 0x7F

I16_MAX : Int
I16_MAX = 0x7FFF

I32_MAX : Int
I32_MAX = 0x7FFFFFFF


U8_MIN : Int
U8_MIN = 0

U16_MIN : Int
U16_MIN = 0

U32_MIN : Int
U32_MIN = 0

I8_MIN : Int
I8_MIN = -0x80

I16_MIN : Int
I16_MIN = -0x8000

I32_MIN : Int
I32_MIN = -0x80000000

not : Bool -- Bool
not = false ==

!= : a a -- Bool
!= = == not

> : Int Int -- Bool
> = swap <

>= : Int Int -- Bool
>= = swap <=

0= : Int -- Bool
0= = 0 ==

0< : Int -- Bool
0< = 0 <

1+ : Int -- Int
1+ = 1 +

1- : Int -- Int
1- = 1 -

max : Int Int -- Int
max = dup2 < if(nip, drop)

min : Int Int -- Int
min = dup2 < if(drop, nip)

square : Int -- Int
square = dup *

nonzero : Int -- Bool
nonzero = 0 !=

ptr+ : Int Ptr -- Ptr
ptr+ = prim.unsafe.ptr+

ptrs : Size -- Size
ptrs = prim.unsafe.|ptr| *

ptr@@ : Offset Ptr -- Ptr
ptr@@ = dip(ptrs) ptr+ ptr@

ptr!! : Ptr Offset Ptr --
ptr!! = dip(ptrs) ptr+ ptr!

u8@@ : Offset Ptr -- Byte
u8@@ = ptr+ u8@

u8!! : Byte Offset Ptr --
u8!! = ptr+ u8!

ints : Size -- Size
ints = 8 *

int@@ : Offset Ptr -- Int
int@@ = dip(ints) ptr+ int@

int!! : Int Offset Ptr --
int!! = dip(ints) ptr+ int!

in-range : Int Int Int -- Bool
in-range = dip(over dip(>=)) <= &&

Int->U8 : Int -- U8
Int->U8 =
    dup U8_MIN U8_MAX in-range if(
        cast,
        "Int->U8 failed: out of bounds" panic!
    )

Int->U16 : Int -- U16
Int->U16 =
    dup U16_MIN U16_MAX in-range if(
        cast,
        "Int->U16 failed: out of bounds" panic!
    )

Int->U32 : Int -- U32
Int->U32 =
    dup U32_MIN U32_MAX in-range if(
        cast,
        ??
        "Int->U32 failed: out of bounds" panic!
    )

Int->U64 : Int -- U64
Int->U64 = cast

Int->I8 : Int -- I8
Int->I8 =
    dup I8_MIN I8_MAX in-range if(
        cast,
        "Int->I8 failed: out of bounds" panic!
    )

Int->I16 : Int -- I16
Int->I16 =
    dup I16_MIN I16_MAX in-range if(
        cast,
        "Int->I16 failed: out of bounds" panic!
    )

Int->I32 : Int -- I32
Int->I32 =
    dup I32_MIN I32_MAX in-range if(
        cast,
        "Int->I32 failed: out of bounds" panic!
    )

Int->I64 : Int -- I64
Int->I64 = cast

U8->Int : U8 -- Int
U8->Int = cast

U16->Int : U16 -- Int
U16->Int = cast

U32->Int : U32 -- Int
U32->Int = cast

U64->Int : U64 -- Int
U64->Int = cast

I8->Int : I8 -- Int
I8->Int = cast

I16->Int : I16 -- Int
I16->Int = cast

I32->Int : I32 -- Int
I32->Int = cast

I64->Int : I64 -- Int
I64->Int = cast

negate : Int -- Int
negate = -1 *

abs : Int -- Int
abs = dup 0< if(negate, id)

def-type(OS, Int)

UNKNOWN : OS
UNKNOWN = 0

WIN32 : OS
WIN32 = 1

LINUX : OS
LINUX = 2

MACOS : OS
MACOS = 3

###########
# STRINGS #
###########

# TODO: UTF8 support
str-head : Str -- U8
str-head = u8@

# TODO: UTF8 support
str-tail : Str -- Str
str-tail = 1 swap ptr+

str-length : Str -- Int
str-length =
    0 swap while(
        str-null? not,
        dip(1+) str-tail
    ) drop

str-null : Str -- Bool
str-null = u8@ U8->Int 0=

str-null? : Str -- Str Bool
str-null? = dup str-null

str-copy! : Str Str --
str-copy! = (
    while( over u8@ U8->Int nonzero,
        over u8@ over u8!
        dip(str-tail) str-tail
    )
    dip(drop 0 Int->U8) u8!
)

STR_BUF_SIZE : Int
STR_BUF_SIZE = 0x1000
buffer(STR_BUF, 0x1000)
buffer(STR_BUF_LEN, 8)

str-buf-length? : Int +StrBuf
str-buf-length? = STR_BUF_LEN int@

str-buf-length! : Int -- +StrBuf
str-buf-length! = (
    dup STR_BUF_LEN int!
    dip(0 Int->U8) str-buf-u8!
)

str-buf-u8@ : Offset -- U8 +StrBuf
str-buf-u8@ = STR_BUF u8@@

str-buf-u8! : U8 Offset -- +StrBuf
str-buf-u8! = STR_BUF u8!!

str-buf-empty? : Bool +StrBuf
str-buf-empty? = str-buf-length? 0=

str-buf-full? : Bool +StrBuf
str-buf-full? = str-buf-length? 1+ STR_BUF_SIZE >=

str-buf-clear! : +StrBuf
str-buf-clear! = 0 str-buf-length!

str-buf-push! : U8 -- +StrBuf
str-buf-push! =
    str-buf-full? if(
        "str-buf-push! but STR_BUF is already full" panic!,
        str-buf-length? str-buf-u8!
        str-buf-length? 1+ str-buf-length!
    )

||| Append the given string into STR_BUF. If the string is
||| too large it gets truncated.
str-buf-push-str! : Str -- +StrBuf
str-buf-push-str! =
    while(
        str-buf-full? if(false, dup u8@ U8->Int nonzero),
        dup u8@ str-buf-push!
        str-tail
    ) drop

||| Set the STR_BUF to a given string. If the string is
||| too large it gets truncated.
str-buf! : Str -- +StrBuf
str-buf! = str-buf-clear! str-buf-push-str!

# TODO UTF8 support?
str-buf-char! : Char -- +StrBuf
str-buf-char! = 0 str-buf-u8! 1 str-buf-length!

to-digit : Int -- U8
to-digit = 10 % 48 + Int->U8

||| Put integer into STR_BUF.
str-buf-int! : Int -- +StrBuf
str-buf-int! =
    dup 0= if(
        drop "0" str-buf!,
        dup dip(
            abs
            str-buf-clear!
            while(dup nonzero, dup to-digit str-buf-push! 10 /) drop
        ) 0 < if(45 Int->U8 str-buf-push!, id)
        str-buf-reverse!
    )

||| Swap two bytes in STR_BUF.
str-buf-swap-u8! : Int Int -- +StrBuf
str-buf-swap-u8! = (
    dup2 swap
    dip(dip(dip(str-buf-u8@)))
    dip(str-buf-u8@)
    str-buf-u8! str-buf-u8!
)

||| Reverse contents of STR_BUF bytewise.
str-buf-reverse! : +StrBuf
str-buf-reverse! = (
    0 str-buf-length? 1-
    while(dup2 <,
        dup2 str-buf-swap-u8!
        dip(1+) 1-
    )
    drop2
)

||| Are two strings equal?
str-eq : Str Str -- Bool
str-eq =
    str-null? if(
        drop str-null,
        dup2 str-head swap str-head == if(
            str-tail swap str-tail str-eq,
            drop2 false
        )
    )

||| Are two strings equal? Preserve pointers.
str-eq? : Str Str -- Str Str Bool
str-eq? = dup2 str-eq

##########
# TUPLES #
##########

||| Return the "nil" pack, i.e. null.
||| Attempts to uncons "nil" will result in a panic.
pack-nil : [*a]
pack-nil = prim.pack.nil cast

||| Is this a nil pack?
pack-nil? : [*a] -- [*a] Bool
pack-nil? = dup pack-nil ==

||| Construct a tuple by appending an element.
pack-cons : [*a] b -- [*a b]
pack-cons = prim.pack.cons

||| Deconstruct a tuple by splitting it at its last element.
pack-uncons : [*a b] -- [*a] b
pack-uncons =
    pack-nil? if(
        "attempted to uncons nil" panic!,
        prim.pack.uncons
    )

pack0 : []
pack0 = pack-nil

pack1 : a -- [a]
pack1 = dip(pack0) pack-cons

pack2 : a b -- [a b]
pack2 = dip(pack1) pack-cons

pack3 : a b c -- [a b c]
pack3 = dip(pack2) pack-cons

pack4 : a b c d -- [a b c d]
pack4 = dip(pack3) pack-cons

pack5 : a b c d e -- [a b c d e]
pack5 = dip(pack4) pack-cons

unpack0 : [] --
unpack0 = drop

unpack1 : [a] -- a
unpack1 = pack-uncons nip

unpack2 : [a b] -- a b
unpack2 = pack-uncons dip(unpack1)

unpack3 : [a b c] -- a b c
unpack3 = pack-uncons dip(unpack2)

unpack4 : [a b c d] -- a b c d
unpack4 = pack-uncons dip(unpack3)

unpack5 : [a b c d e] -- a b c d e
unpack5 = pack-uncons dip(unpack4)

.0 : [*a b] -- b
.0 = pack-uncons nip

.1 : [*a b c] -- b
.1 = pack-uncons drop .0

.2 : [*a b c d] -- b
.2 = pack-uncons drop .1

.3 : [*a b c d e] -- b
.3 = pack-uncons drop .2

.4 : [*a b c d e f] -- b
.4 = pack-uncons drop .3

.0? : [*a b] -- [*a b] b
.0? = dup .0

.1? : [*a b c] -- [*a b c] b
.1? = dup .1

.2? : [*a b c d] -- [*a b c d] b
.2? = dup .2

.3? : [*a b c d e] -- [*a b c d e] b
.3? = dup .3

.4? : [*a b c d e f] -- [*a b c d e f] b
.4? = dup .4

.0! : [*a b] b -- [*a b]
.0! = dip(pack-uncons drop) pack-cons

.1! : [*a b c] b -- [*a b c]
.1! = dip(pack-uncons) swap dip(.0!) pack-cons

.2! : [*a b c d] b -- [*a b c d]
.2! = dip(pack-uncons) swap dip(.1!) pack-cons

.3! : [*a b c d e] b -- [*a b c d e]
.3! = dip(pack-uncons) swap dip(.2!) pack-cons

.4! : [*a b c d e f] b -- [*a b c d e f]
.4! = dip(pack-uncons) swap dip(.3!) pack-cons

#########
# LISTS #
#########

nominal(List(t), [])

list->pack : List(t) -- [List(t) t]
list->pack = cast

pack->list : [List(t) t] -- List(t)
pack->list = cast

nil : List(t)
nil = pack-nil pack->list

nil? : List(t) -- List(t) Bool
nil? = list->pack pack-nil? dip(pack->list)

cons : List(t) t -- List(t)
cons = pack2 pack->list

uncons : List(t) -- List(t) t
uncons =
    nil? if(
        "uncons on nil list" panic!,
        list->pack unpack2
    )

head : List(t) -- t
head = uncons nip

head? : List(t) -- List(t) t
head? = dup head

tail : List(t) -- List(t)
tail = uncons drop

tail? : List(t) -- List(t) List(t)
tail? = dup tail

length : List(t) -- Int
length =
    0 swap while(
        nil? not,
        dip(1+) tail
    ) drop

length? : List(t) -- List(t) Int
length? = dup length

######
# IO #
######

panic! : *a Str -- *b
panic! = "panic: " str-trace! str-trace-ln! 1 posix-exit!

nominal(File, Int)

File->Int : File -- Int
File->Int = File.unwrap

Int->File : Int -- File
Int->File = File.wrap

file@ : Ptr -- File
file@ = int@ Int->File

file! : File Ptr --
file! = dip(File->Int) int!

stdin : File
stdin = 0 Int->File

stdout : File
stdout = 1 Int->File

stderr : File
stderr = 2 Int->File

str-write! : Str File -- +IO
str-write! = File->Int swap dup str-length posix-write!

str-print! : Str -- +IO
str-print! = stdout str-write!

str-trace! : Str -- +IO
str-trace! = stderr str-write!

str-print-ln! : Str -- +IO
str-print-ln! = str-print! print-ln!

str-trace-ln! : Str -- +IO
str-trace-ln! = str-trace! trace-ln!

print-ln! : +IO
print-ln! = "\n" str-print!

trace-ln! : +IO
trace-ln! = "\n" str-trace!

str-buf-write! : File -- +StrBuf +IO
str-buf-write! = File->Int STR_BUF str-buf-length? posix-write!

str-buf-print! : +StrBuf +IO
str-buf-print! = stdout str-buf-write!

str-buf-trace! : +StrBuf +IO
str-buf-trace! = stderr str-buf-write!

str-buf-read! : File -- +IO
str-buf-read! = (
    File->Int str-buf-clear!
    STR_BUF STR_BUF_SIZE 1- posix-read!
    dup 0< if(
        "str-buf-read! failed" panic!,
        str-buf-length!
    )
)

str-buf-input! : -- +IO
str-buf-input! = stdin str-buf-read!

print-char! : Char -- +IO
print-char! = str-buf-char! str-buf-print!

trace-char! : Char -- +IO
trace-char! = str-buf-char! str-buf-trace!

int-write! : Int File -- +IO
int-write! = dip(str-buf-int!) str-buf-write!

int-print! : Int -- +IO
int-print! = stdout int-write!

int-trace! : Int -- +IO
int-trace! = stderr int-write!

int-print-ln! : Int -- +IO
int-print-ln! = int-print! print-ln!

int-trace-ln! : Int -- +IO
int-trace-ln! = int-trace! trace-ln!

open-file! : Str -- File +IO
open-file! = (
    0 0 posix-open!
    dup 0 < if(
        "Failed to open file!" panic!,
        Int->File
    )
)

create-file! : Str -- File +IO
create-file! = (
    O_WRONLY|O_CREAT|O_TRUNC
    0x1B6
        # this is the default mode for creating a file
        # on unix, 666 in octal, i.e. owner can
        # read+write, everyone can read
        #  ---- NB: this is inaccurate . . .
    posix-open!
    dup 0 < if(
        "Failed to create file!" panic!,
        Int->File
    )
)

O_WRONLY|O_CREAT|O_TRUNC : Int
O_WRONLY|O_CREAT|O_TRUNC =
    RUNNING_OS MACOS == if(
        0x601, # O_WRONLY = 0x1, O_CREAT = 0x200, O_TRUNC = 0x400
    RUNNING_OS LINUX == if(
        0x241, # O_WRONLY = 0x1, O_CREAT = 0x40, O_TRUNC = 0x200
    RUNNING_OS WIN32 == if(
        0x301, # O_WRONLY = 0x1, O_CREAT|O_TRUNC = 0x300
        "O_WRONLY|O_CREAT|O_TRUNC not known for os" panic!
    )))

close-file! : File -- +IO
close-file! = (
    File->Int posix-close!
    0 < if(
        "failed to close file." panic!,
        id
    )
)
