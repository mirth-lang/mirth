module(mirth.data)

import(std.prelude)
import(std.list)
import(std.maybe)
import(std.either)

import(mirth.var)
import(mirth.type)
import(mirth.token)
import(mirth.name)
import(mirth.def)
import(mirth.label)
import(mirth.tycon)
import(mirth.word)
import(mirth.mirth)

table(Data)
field(Data.~head?, Data, Maybe(Token))
field(Data.~qname, Data, QName)
field(Data.~arity, Data, Int)
field(Data.~params, Data, Prop(List(Var)))
field(Data.~tags, Data, List(Tag))
field(Data.~ctype?, Data, Prop(Maybe(CType)))

def(Data.head?, Data -- Maybe(Token), ~head? @)
def(Data.qname, Data -- QName, ~qname @)
def(Data.namespace, Data -- Namespace, qname namespace)
def(Data.name, Data -- Name, qname name)
def(Data.arity, Data -- Int, ~arity @)
def(Data.params, +Mirth Data -- +Mirth List(Var), ~params force!)
def(Data.tags, Data -- List(Tag), ~tags @)
def(Data.ctype?, Data +Mirth -- Maybe(CType) +Mirth, ~ctype? force!)

def(TYPE_BOOL, +Mirth -- +Mirth Type, builtin bool TData)
def(TYPE_U64, +Mirth -- +Mirth Type, builtin u64 TData)
def(TYPE_U32, +Mirth -- +Mirth Type, builtin u32 TData)
def(TYPE_U16, +Mirth -- +Mirth Type, builtin u16 TData)
def(TYPE_U8,  +Mirth -- +Mirth Type, builtin u8  TData)
def(TYPE_I64, +Mirth -- +Mirth Type, builtin i64 TData)
def(TYPE_I32, +Mirth -- +Mirth Type, builtin i32 TData)
def(TYPE_I16, +Mirth -- +Mirth Type, builtin i16 TData)
def(TYPE_I8,  +Mirth -- +Mirth Type, builtin i8  TData)

def(make-prim-data!, +Mirth Str Int Data List(Tag) Maybe(CType) -- +Mirth,
    over2 DataCType prop over2 ~ctype? !
    dip(
        dip(QName.prim)
        tuck ~qname !
        dup DefData register
    )
    { +Mirth Data List(Tag) }
    dup for(dip(over) ~data !)
    over ~tags !
    { +Mirth Data }
    0 over ~arity !
    L0 over DataParams prop over ~params !
    None over ~head? !
    drop)

def(make-prim-tag!, +Mirth Str Int List(Type) Tag -- +Mirth,
    dip(sip(len) TT)
    sip(Ctx0 rotr .data TData T1 T->) sip(TagType prop2) sip(~ctx-type !)
    sip(~num-type-inputs !)
    sip(L0 swap ~label-inputs !)
    sip(0 >Nat swap ~num-resource-inputs !)
    sip(dip(>Nat) ~value !)
    sip(.data swap 0 data-word-qname) tuck ~qname !
    DefTag register)

def(init-data!, +Mirth -- +Mirth,
    "Bool" 0 builtin bool builtin true builtin false L2 "_Bool" IntLike Some make-prim-data!
    "False" 0 L0 builtin false make-prim-tag!
    "True" 1 L0 builtin true make-prim-tag!

    "U64" 0 builtin u64 builtin mk-u64 L1 "uint64_t" IntLike Some make-prim-data!
    "Int>U64-unsafe" 0 TYPE_INT L1 builtin mk-u64 make-prim-tag!

    "U32" 0 builtin u32 builtin mk-u32 L1 "uint32_t" IntLike Some make-prim-data!
    "Int>U32-unsafe" 0 TYPE_INT L1 builtin mk-u32 make-prim-tag!

    "U16" 0 builtin u16 builtin mk-u16 L1 "uint16_t" IntLike Some make-prim-data!
    "Int>U16-unsafe" 0 TYPE_INT L1 builtin mk-u16 make-prim-tag!

    "U8"  0 builtin u8  builtin mk-u8  L1 "uint8_t" IntLike Some make-prim-data!
    "Int>U8-unsafe"  0 TYPE_INT L1 builtin mk-u8 make-prim-tag!

    "I64" 0 builtin i64 builtin mk-i64 L1 "int64_t" IntLike Some make-prim-data!
    "Int>I64-unsafe" 0 TYPE_INT L1 builtin mk-i64 make-prim-tag!

    "I32" 0 builtin i32 builtin mk-i32 L1 "int32_t" IntLike Some make-prim-data!
    "Int>I32-unsafe" 0 TYPE_INT L1 builtin mk-i32 make-prim-tag!

    "I16" 0 builtin i16 builtin mk-i16 L1 "int16_t" IntLike Some make-prim-data!
    "Int>I16-unsafe" 0 TYPE_INT L1 builtin mk-i16 make-prim-tag!

    "I8"  0 builtin i8  builtin mk-i8  L1 "int8_t" IntLike Some make-prim-data!
    "Int>I8-unsafe"  0 TYPE_INT L1 builtin mk-i8 make-prim-tag!)

def(data-qname, Data Name Int -- QName,
    >arity >name TYCON_DATA NAMESPACE_TYCON >namespace MKQNAME)

def(data-word-qname, Data Str Int -- QName,
    dip(>Name) data-qname)

########
# DATA #
########

def(Data.==, Data Data -- Bool, both(index) ==)
def(Data.num-tags, Data -- Nat, tags len)

||| Adds constructor to data type, and gives tag its rank.
def(Data.add-tag!, Tag Data --,
    dup2 num-tags swap ~value !
    dup tags rotr dip(List.snoc) ~tags !)

field(Data.~is-unit?, Data, Bool)
def(Data.is-unit?, Data -- Bool,
    dup ~is-unit? memoize(
        dup tags /L1 and-some(num-total-inputs 0=)
    ) nip)

field(Data.~is-enum?, Data, Bool)
def(Data.is-enum?, Data -- Bool,
    dup ~is-enum? memoize(
        dup is-unit? not and(
            dup tags all(dup num-total-inputs 0=)
        )
    ) nip)

field(Data.~is-transparent?, Data, Bool)
def(Data.is-transparent?, Data -- Bool,
    dup ~is-transparent? memoize(
        dup is-resource? if(
            dup tags /L1 match(
                Some -> dup num-resource-inputs 1 >Nat == swap num-total-inputs 1 >Nat == &&,
                None -> False,
            ),
            dup tags /L1 match(
                Some -> dup num-type-inputs 1 >Nat == swap num-total-inputs 1 >Nat == &&,
                None -> False
            )
        )
    ) nip)

field(Data.~is-resource?, Data, Bool)
def(Data.is-resource?, Data -- Bool,
    dup ~is-resource? memoize(
        dup name could-be-resource-con
    ) nip)

def(Data.is-value-type?, Data -- Bool,
    is-resource? not)

def(Data.full-type, +Mirth Data -- +Mirth Type/Resource,
    dup sip:TData params for(TVar TApp)
    swap is-value-type? if(
        Left,
        RESOURCE Right
    ))

#######
# TAG #
#######

table(Tag)
field(Tag.~data, Tag, Data)
field(Tag.~qname, Tag, QName)
field(Tag.~value, Tag, Nat)
field(Tag.~label-inputs, Tag, List(Label))
field(Tag.~num-type-inputs, Tag, Nat)
field(Tag.~num-resource-inputs, Tag, Nat)
field(Tag.~sig?, Tag, Maybe(Token))
field(Tag.~ctx-type, Tag, Prop([Ctx ArrowType]))
field(Tag.~untag, Tag, Maybe(Word))

def(Tag.data, Tag -- Data, ~data @)
def(Tag.qname, Tag -- QName, ~qname @)
def(Tag.name, Tag -- Name, qname name)
def(Tag.value, Tag -- Nat, ~value @)
def(Tag.label-inputs, Tag -- List(Label), ~label-inputs @)
def(Tag.num-type-inputs, Tag -- Nat, ~num-type-inputs @)
def(Tag.num-resource-inputs, Tag -- Nat, ~num-resource-inputs @)
def(Tag.sig?, Tag -- Maybe(Token), ~sig? @)
def(Tag.ctx-type, +Mirth Tag -- +Mirth Ctx ArrowType, ~ctx-type force! unpack2)
def(Tag.ctx, +Mirth Tag -- +Mirth Ctx, ctx-type drop)
def(Tag.type, +Mirth Tag -- +Mirth ArrowType, ctx-type nip)
def(Tag.untag, Tag -- Maybe(Word), ~untag @)

def(Tag.label-inputs-from-sig, Tag -- List(Label),
    sig? if-some(run-tokens filter(dup could-be-sig-label?) map(name? unwrap Label.new!), L0))

def(Tag.num-type-inputs-from-sig, Tag -- Nat,
    dup sig? if-some(
        run-length
        over num-resource-inputs-from-sig -
        swap label-inputs-from-sig len -,
        drop 0 >Nat
    ))

def(Tag.num-resource-inputs-from-sig, Tag -- Nat,
    sig? if-some(
        run-tokens filter(dup could-be-sig-label? not) filter-some(name?)
        filter(dup could-be-resource-var or(dup could-be-resource-con))
        len,
        0 >Nat
    ))

field(Tag.~num-label-inputs, Tag, Nat)
def(Tag.num-label-inputs, Tag -- Nat,
    dup ~num-label-inputs memoize(
        dup label-inputs len
    ) nip)

def(Tag.num-total-inputs, Tag -- Nat,
    >tag
    @tag num-label-inputs
    @tag num-type-inputs +
    tag> num-resource-inputs +)

def(Tag.is-transparent?, Tag -- Bool,
    .data is-transparent?)

def(Tag.outputs-resource?, Tag -- Bool,
    .data is-resource?)

def(Tag.==, Tag Tag -- Bool, both(index) ==)

def(Tag.prefer-inline?, Tag -- Bool,
    dup .data is-transparent?
    or(dup num-total-inputs 0=)
    nip)

#
# Partial Data
#

||| DataPartial represents a data type with missing parts.
||| In general, it could represent missing fields, missing tags, etc.
||| For now, all we need to represent is a single missing field.
data(DataPartial, DataPartial ->
    data:Data field:Label)

def(DataPartial.==, DataPartial DataPartial -- Bool,
    /DataPartial /DataPartial
    data> data> ==
    field> field> == &&)
