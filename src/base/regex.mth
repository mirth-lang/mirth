# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import base/char
import base/str
import base/nat
import base/maybe

export base/regex
  type Regex
  type Maybe(t)
  regexMatch : Str Regex -- Maybe(Nat)
end

export base/regex+
  type Regex
  type Maybe(t)
  fail : Regex
  lit  : Str -- Regex
  cls  : Str -- Regex
  seq2 : Regex Regex -- Regex
  seq3 : Regex Regex Regex -- Regex
  seq4 : Regex Regex Regex Regex -- Regex
  alt2 : Regex Regex -- Regex
  alt3 : Regex Regex Regex -- Regex
  alt4 : Regex Regex Regex Regex -- Regex
  star : Regex -- Regex
  plus : Regex -- Regex
  regexMatch : Str Regex -- Maybe(Nat)
end

data Regex
  fail : Regex
  lit  : Str -- Regex
  cls  : Str -- Regex
  seq2 : Regex Regex -- Regex
  alt2 : Regex Regex -- Regex
  star : Regex -- Regex
end

plus : Regex -- Regex
plus = dup star seq2

seq3 = seq2 seq2
seq4 = seq3 seq2
alt3 = alt2 alt2
alt4 = alt3 alt2

fail? : Regex -- Regex Bool
fail? =
  match(
    fail -> fail true,
    lit  -> lit  false,
    cls  -> strnull? dip(cls),
    seq2 -> or?(dip?(fail?), fail?) dip(seq2),
    alt2 -> and?(dip?(fail?), fail?) dip(alt2),
    star -> star false
  )

eps? : Regex -- Regex Bool
eps? =
  match(
    fail -> fail false,
    lit  -> strnull? dip(lit),
    cls  -> cls false,
    seq2 -> and?(dip?(eps?), eps?) dip(seq2),
    alt2 -> or?(dip?(eps?), eps?) dip(alt2),
    star -> star true
  )

seq2' : Regex Regex -- Regex
seq2' =
  cond(
    dip?(fail?) -> drop2 fail,
    fail? -> drop2 fail,
    seq2
  )

alt2' : Regex Regex -- Regex
alt2' =
  cond(
    fail? -> drop,
    dip?(fail?) -> nip,
    alt2
  )

star' : Regex -- Regex
star' =
  cond(
    fail? -> drop "" lit,
    star
  )

derive : Char Regex -- Regex
derive =
  match(
    fail -> drop fail,
    lit -> n1 strbreak dip(str->char chareq) swap if(lit, drop fail),
    cls -> strelem if("" lit, fail),
    seq2 ->
      dip?(eps?) if(
        dup3 nip dip2(dip(derive) seq2') derive alt2',
        dip(derive) seq2'
      ),
    alt2 -> dip(over) dip2(derive) derive alt2',
    star -> dup dip(derive) star' seq2'
  )

regexMatchAux : Maybe(Nat) Nat Str Regex -- Maybe(Nat)
regexMatchAux =
  cond(
    fail? -> drop3,
    dip?(strnull?) -> eps? if(drop2 nip Some, drop3),
    eps? if(dip2(nip dup dip(Some)), id)
    dip2(n1+ pnat) dip(n1 strbreak swap str->char)
    derive regexMatchAux
  )

regexMatch : Str Regex -- Maybe(Nat)
regexMatch = dip2(None n0) regexMatchAux

fail regexMatch == drop None
"foobar" "foo" lit regexMatch == 3 znat Some
"foobar" "foo" cls regexMatch == n1 Some
"foobar" "foo" lit "bar" lit seq2 regexMatch == 6 znat Some
"foobar" "f" lit "foo" lit alt2 regexMatch == 3 znat Some
"foobar" "foo" lit star regexMatch == 3 znat Some
"foobar" "food" lit star regexMatch == n0 Some
"foobar" "food" lit regexMatch == None

"abc" "ab" cls star regexMatch == 2 znat Some
