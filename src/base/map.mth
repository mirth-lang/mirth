# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import base/int
import base/nat
import base/pos
import base/list
import base/maybe
import base/sexp
import base/set

export base/map
  type Nat
  type Maybe(t)
  type Sexp

  type Map(k,v)
  type Set(k)

  Map.generate : List(Pack(k v)) -- Map(k,v)
  mapFromList : List(Pack(k v)) -- Map(k,v)
  mapNil : Map(k,v)
  mapSingle : k v -- Map(k,v)
  mapSet : Map(k,v) k v -- Map(k,v)
  mapGet : Map(k,v) k -- Maybe(v)
  mapHas : Map(k,v) k -- Bool
  mapLen : Map(k,v) -- Nat
  mapNil? : Map(k,v) -- Map(k,v) Bool
  mapGet? : Map(k,v) k -- Map(k,v) k Maybe(v)
  mapHas? : Map(k,v) k -- Map(k,v) k Bool
  mapLen? : Map(k,v) -- Map(k,v) Nat

  mapMap(f: a -- b) : Map(k,a) -- Map(k,b)
  mapKeys : Map(k,v) -- Set(k)

  mapFor(f: *a k v -- *a) : *a Map(k,v) -- *a
  map->sexp(k->sexp: k -- Sexp, v->sexp: v -- Sexp) : Map(k,v) -- Sexp
end

data Map(k,v)
  MapNil : Map(k,v)
  MapLeaf : k v Int -- Map(k,v)
  MapNode : Map(k,v) Map(k,v) -- Map(k,v)
end

mapNil = MapNil

Map.generate = mapFromList
mapFromList = dip(MapNil) for(unpack2 mapSet)

hash : k -- Int
hash = _prim_unsafe_hash

moveLeafDown : k v Int -- Map(k,v)
moveLeafDown =
  p2 z/% n0 n= if(
    MapLeaf MapNil MapNode,
    MapLeaf MapNil swap MapNode
  )

mapSetAux : k v Int Map(k,v) -- Map(k,v)
mapSetAux =
  match(
    MapNil -> MapLeaf,
    MapLeaf -> dip2(over) rotl over z=
      if(
        drop3 MapLeaf,
        moveLeafDown mapSetAux
      ),
    MapNode ->
      dip2(p2 z/%) rotl n0 n= if(
        dip(mapSetAux) MapNode,
        swap dip(mapSetAux) swap MapNode
      )
  )
mapSet = rotl dip(over hash) mapSetAux
mapSingle = over hash MapLeaf

mapGetAux : Int Map(k,v) -- Maybe(v)
mapGetAux =
  match(
    MapNil -> drop None,
    MapLeaf -> dip(rotl) z= if(nip Some, drop2 None),
    MapNode -> dip2(p2 z/%) rotl n0 n= if(drop, nip) mapGetAux
  )

mapGet = hash swap mapGetAux
mapHas = mapGet maybe(false, drop true)

dip(mapNil) mapGet == drop None
tuck dip(mapSet) mapGet == drop nip Some
dip(tuck dip(mapSet)) mapSet == dip2(drop) mapSet

mapLenAux : Nat Map(k,v) -- Nat
mapLen = dip(n0) mapLenAux
mapLenAux =
  match(
    MapNil -> id,
    MapLeaf -> drop3 n1+ pnat,
    MapNode -> dip(mapLenAux) mapLenAux
  )

MapNil mapLen == n0
MapLeaf mapLen == drop3 n1
MapNode mapLen == mapLen dip(mapLen) n+

mapNil? = match( MapNil -> MapNil true, _ -> false )
mapGet? = dup2 mapGet
mapHas? = dup2 mapHas
mapLen? = dup mapLen

mapNil? drop == id
mapLen? drop == id
mapGet? drop == id
mapHas? drop == id

mapMap(f) =
  match(
    MapNil -> MapNil,
    MapLeaf -> dip(f) MapLeaf,
    MapNode -> dip(mapMap(f)) mapMap(f) MapNode
  )

mapKeys = setFromMapKeys

mapFor(f) =
  match(
    MapNil -> id,
    MapLeaf -> drop f,
    MapNode -> dip(mapFor(f)) mapFor(f)
  )

map->sexp(k->sexp, v->sexp) = $(
  dip(nil)
  mapFor(
    dip2(nil)
    dip(k->sexp cons)
    v->sexp cons
    SexpList
    cons
  )
  SexpList
)
