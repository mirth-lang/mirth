module(mirth.input)

import(prelude)
import(platform.posix)
import(data.byte)

#########
# Input #
#########

var(input-isopen, Bool)
var(input-length, Size)
var(input-offset, Size)
var(input-handle, File)
buffer(INPUT_BUFFER, 0x2010) # a little wiggle room for boundary chars
def(INPUT_BUFFER_SIZE, Size, 0x2000)

def(input-start!, File --,
    input-handle !
    0 input-length !
    0 input-offset !
    T input-isopen !
    input-fill-buffer!)

def(input-end!, --,
    input-isopen @ if(
        input-handle @ close-file!,
        id
    )
    stdin input-handle !
    0 input-length !
    0 input-offset !
    F input-isopen !)

def(input-done?, Bool,
    input-isopen @ not)

def(input-fill-buffer!, --,
    assert!(input-isopen @, "attempted to fill input buffer when file is closed")
    input-handle @ File->Int
    INPUT_BUFFER
    INPUT_BUFFER_SIZE
    posix-read!
    expect!(dup 0>=, "failed to read from file")
    dup 0> if(
        input-length !
        0 input-offset !,
        drop
        input-end!
    ))

# Return the current char in the input buffer.
# Panics if file is exhausted.
def(input-peek, Byte,
    input-isopen @ if(
        input-offset @ INPUT_BUFFER .offset(@Byte),
        "error: attempted to read input buffer when file is already closed" panic!
    ))

# Move to next char in input buffer.
# Panics if file is exhausted.
def(input-move!, --,
    input-isopen @ if(
        input-offset @ 1+ input-offset !
        input-prepare-for-more!,
        "error: attempted to move input buffer when file is already closed" panic!
    ))

||| Refill input buffer.
def(input-prepare-for-more!, --,
    input-offset @
    input-length @ >= if(
        input-fill-buffer!,
        id
    ))
