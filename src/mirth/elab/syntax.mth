module(mirth/elab/syntax)

###############
# Token Types #
###############

||| Is this the end of a module?
token-is-module-end? : Token -- Token Bool
token-is-module-end? = token-type? TOKEN_NONE ==

||| Is this a token to stop running at?
token-run-end? : Token -- Token Bool
token-run-end? =
    dup Token->Int num-tokens@ >= if(
        true,
    token-type? TOKEN_NONE == if(
        true,
    token-type? TOKEN_NEWLINE == if(
        true,
    token-type? TOKEN_COMMA == if(
        true,
        token-is-right-enclosure?
    ))))

||| Does the token refer to this primitive? Preserves the token.
token-prim=? : Token Prim -- Token Bool
token-prim=? = dip(dup) token-prim=

||| Does the token refer to this primitive?
token-prim= : Token Prim -- Bool
token-prim= =
    dip(token-is-name?) swap if(
        dip(token-name@) name-prim=,
        drop2 false
    )

||| Is this a newline token?
token-is-newline? : Token -- Token Bool
token-is-newline? = token-type? TOKEN_NEWLINE ==

||| Skip all the newlines.
token-skip-newlines : Token -- Token
token-skip-newlines = while(token-is-newline?, token-succ)

###################
# Type Signatures #
###################

token-is-dashes : Token -- Bool
token-is-dashes = PRIM_DASHES token-prim=

token-is-dashes? : Token -- Token Bool
token-is-dashes? = dup token-is-dashes

sig-is-stack-end? : Token -- Token Bool
sig-is-stack-end? =
    token-is-dashes? if(
        true,
        token-run-end?
    )

sig-is-stack-end2? : Token -- Token Bool
sig-is-stack-end2? =
    sig-is-stack-end? if(
        true,
        sig-token-is-effect-con?
    )

sig-next-stack-end : Token -- Token
sig-next-stack-end = while(sig-is-stack-end? not, token-next)

sig-has-dashes : Token -- Bool
sig-has-dashes = sig-next-stack-end token-is-dashes

sig-has-dashes? : Token -- Token Bool
sig-has-dashes? = dup sig-has-dashes

sig-arity : Token -- Int Int
sig-arity =
    sig-has-dashes? if(
        sig-count-types
        token-next
        sig-count-types
        drop,

        sig-count-types
        drop 0 swap
    )

sig-count-types : Token -- Int Token
sig-count-types =
    0 swap while(sig-is-stack-end? not,
        sig-token-is-type? if(dip(1+), id)
        token-next
    )

sig-token-is-type? : Token -- Token Bool
sig-token-is-type? =
    token-is-name? if(
        token-name? name-could-be-type,
        false
    )

sig-token-is-type-con? : Token -- Token Bool
sig-token-is-type-con? =
    token-is-name? if(
        token-name? name-could-be-type-con,
        false
    )

sig-token-is-type-hole? : Token -- Token Bool
sig-token-is-type-hole? =
    token-is-name? if(
        token-name? name-is-type-hole,
        false
    )

token-is-underscore? : Token -- Token Bool
token-is-underscore? =
    token-is-name? if(
        token-name? name-is-underscore,
        false
    )

sig-token-is-type-var? : Token -- Token Bool
sig-token-is-type-var? =
    token-is-name? if(
        token-name? name-could-be-type-var,
        false
    )

sig-token-is-stack-var? : Token -- Token Bool
sig-token-is-stack-var? =
    token-is-name? if(
        token-name? name-could-be-stack-var,
        false
    )

sig-token-is-effect-con? : Token -- Token Bool
sig-token-is-effect-con? =
    token-is-name? if(
        token-name? name-could-be-effect-con,
        false
    )

sig-skip-dashes : Token -- Token
sig-skip-dashes =
    sig-has-dashes? if(
        sig-next-stack-end token-next,
        id
    )

##############
# BARE DECLS #
##############

token-could-be-word-sig? : Token -- Token Bool
token-could-be-word-sig? =
    token-type? TOKEN_NAME == if(
        dup token-next PRIM_COLON token-prim=? nip,
        false
    )

# TODO eventually figure out how to deal w/ pattern matching...
token-could-be-word-def? : Token -- Token Bool
token-could-be-word-def? =
    token-type? TOKEN_NAME == if(
        dup token-next PRIM_DEFINE token-prim=? nip,
        false
    )
