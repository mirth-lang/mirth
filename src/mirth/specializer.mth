||| The specializer tries to remove higher-order words by specializing them with their arguments.
||| This should be especially doable in Mirth because local variables are less of an issue.
module(mirth.specializer)

import(std.prelude)
import(std.list)
import(std.maybe)
import(std.lazy)
import(std.map)
import(std.str)

import(mirth.word)
import(mirth.arrow)
import(mirth.match)
import(mirth.type)
import(mirth.elab)
import(mirth.name)
import(mirth.var)
import(mirth.ctx)

def(run-specializer!, Arrow -- Arrow,
    +SPCheck.begin! check-arrow! loop! end!)

field(Word.~sp-checked, Word, Bool)
field(Block.~sp-checked, Block, Bool)

data(+SPCheck, SPCHECK -> checklist:List(SPCheckItem))

def(+SPCheck.begin!, -- +SPCheck, L0 >checklist SPCHECK)
def(+SPCheck.end!, +SPCheck --, SPCHECK -> checklist> drop)
def(+SPCheck.loop!, +SPCheck -- +SPCheck,
    while-some(checklist:uncons?, do-item-check!))

data(SPCheckItem,
    SPCHECK_WORD -> Word,
    SPCHECK_BLOCK -> Block)

def(+SPCheck.do-item-check!, SPCheckItem +SPCheck -- +SPCheck,
    SPCHECK_WORD -> dup dip(arrow check-arrow! ready) ~arrow !,
    SPCHECK_BLOCK -> dup dip(arrow check-arrow! ready) ~arrow !)

def(+SPCheck.check-arrow!, Arrow +SPCheck -- Arrow +SPCheck,
    atoms:flatmap(check-atom!))

def(+SPCheck.check-atom!, Atom +SPCheck -- List(Atom) +SPCheck,
    dup op match(
        OP_NONE -> L1,
        OP_PRIM -> check-prim-atom!,
        OP_WORD -> check-word-atom!,
        OP_EXTERNAL -> drop L1,
        OP_BUFFER -> drop L1,
        OP_VARIABLE -> drop L1,
        OP_FIELD -> drop L1,
        OP_INT -> drop L1,
        OP_STR -> drop L1,
        OP_TAG -> drop L1,
        OP_MATCH -> check-match! OP_MATCH swap op! L1,
        OP_LAMBDA -> check-lambda! OP_LAMBDA swap op! L1,
        OP_VAR -> drop L1,
        OP_BLOCK -> push-check-block! L1,
        OP_COERCE -> drop L1,
        OP_LABEL_PUSH -> drop L1,
        OP_LABEL_POP -> drop L1,
        OP_DATA_GET_LABEL -> drop2 L1,
        OP_DATA_SET_LABEL -> drop2 L1,
    ))

def(+SPCheck.check-arg!, Arg +SPCheck -- +SPCheck,
    ARG_BLOCK -> push-check-block!)
def(+SPCheck.check-prim-atom!, Atom Prim +SPCheck -- List(Atom) +SPCheck,
    drop dup args for(check-arg!) L1)
def(+SPCheck.check-word-atom!, Atom Word +SPCheck -- List(Atom) +SPCheck,
    over args >List+ match(
        NONE -> push-check-word! L1,
        SOME ->
            dup for(check-arg!)
            dup map(free-vars) any(dup any(dup is-physical?)) if(
                # too complicated, let's skip it
                drop2 L1,

                # boot up the specializer for real!
                SPKEY swap specialize-word!
                # dup push-check-word!
                swap ab-build-over-atom!(ab-word!) atoms
            )
        )
    )

def(+SPCheck.check-match!, Match +SPCheck -- Match +SPCheck,
    cases:map(check-case!))
def(+SPCheck.check-case!, Case +SPCheck -- Case +SPCheck,
    body:check-arrow!)
def(+SPCheck.check-lambda!, Lambda +SPCheck -- Lambda +SPCheck,
    body:check-arrow!)

def(+SPCheck.push-check-word!, Word +SPCheck -- +SPCheck,
    dup ~sp-checked @? unwrap-or(F) if(
        drop,
        T over ~sp-checked !
        SPCHECK_WORD checklist:cons
    ))
def(+SPCheck.push-check-block!, Block +SPCheck -- +SPCheck,
    dup ~sp-checked @? unwrap-or(F) if(
        drop,
        T over ~sp-checked !
        SPCHECK_BLOCK checklist:cons
    ))

def(ab-build-over-atom!(f), (*a +AB -- *b +AB) *a Atom -- *b Arrow,
    /ATOM
    ctx>
    dom> cod> T->
    token> home>
    subst> op> args> drop3
    ab-build-hom!(dip(f)))

data(SPKey, SPKEY -> List+(Arg))
def(SPKey.==, SPKey SPKey -- Bool, both(/SPKEY) ==(==))
def(SPKey.>Str, SPKey -- Str,
    SPKEY -> Str("(" ; dip:"" for(dip:; >Str ; ",") drop ")" ;))
def(SPKey.>Name, SPKey -- Name,
    >Str >Name)

data(+SPSynth, +SPSynth ->
    spkey:SPKey spword:Word +AB)

field(Word.~sp-synthed, Word, Map(SPKey,Word))
def(Word.sp-synthed, Word -- Map(SPKey,Word),
    ~sp-synthed @? unwrap-or(Map.empty))

field(Block.~sp-synthed, Block, Map(SPKey,Block))
def(Block.sp-synthed, Block -- Map(SPKey,Block),
    ~sp-synthed @? unwrap-or(Map.empty))

||| Specialize a word to a particular list of arguments.
||| Those other arguments are pushed on the stack.
def(specialize-word!, SPKey Word -- Word,
    \(k w ->
        w head >head
        NONE >sig
        w body >body
        w NAMESPACE_WORD k >Name QNAME0 >qname
        0 >arity
        Word.new! \(w' ->
            k >key w' >value KVPAIR
            w sp-synthed insert w ~sp-synthed !
            k w delay2(
                ctx-type specialize-ctx-type pack2
            ) w' ~ctx-type !
            k w w' delay3(ab-build-word-arrow!(dip(
                # synth-specialized-word!
                dip(/SPKEY for(/ARG_BLOCK OP_BLOCK ab-op!))
                ab-word! # TODO actually do the thing here

            ))) w' ~arrow !
            w'
        )
    ))

def(specialize-ctx-type, SPKey Ctx ArrowType -- Ctx ArrowType,
    nip dip:SUBST_NIL freshen-sig nip swap
    /SPKEY
    dup first token GAMMA >gamma
    dip:SUBST_NIL nip
    dip(ArrowType.unpack swap) reverse-for(
        dip(force-cons?!
            unwrap-or("unexpected domain in specialize-ctx-type" panic!)
            unpack2)
        dip2(gamma> dup >gamma)
        /ARG_BLOCK type TMorphism unify! drop2
    )
    gamma> drop
    swap T->
    dip:CTX0 rigidify-sig!)

# def(synth-specialized-word!, SPKey Word +AB -- +AB,
#     dup >spword dip(>spkey)
#     arrow /L1 unwrap-or("unexpected shape for synth-specialized-word!" panic!)
#     op match(
#         OP_LAMBDA ->
#             dup params
#             spkey> dup >spkey /SPKEY len
#             assert!(
#                 dup params len
#                 spkey> dup >spkey /SPKEY len ==,
#                 "wrong number of lambda params in synth-specialized-word!"
#             )

#             map2()
#     ))
