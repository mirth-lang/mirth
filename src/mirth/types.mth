
module(mirth/types)
import(mirth/names)

def(init-types!, --,
    0 NUM_METAS !
    0 NUM_TENSOR_TYPES !
    0 NUM_MORPHISM_TYPES !
    0 NUM_NOMINALS !
    TYPE_INT PRIM_INT Prim->Name name-type!
    TYPE_PTR PRIM_PTR Prim->Name name-type!
    TYPE_U8 PRIM_U8 Prim->Name name-type!
    TYPE_U16 PRIM_U16 Prim->Name name-type!
    TYPE_U32 PRIM_U32 Prim->Name name-type!
    TYPE_U64 PRIM_U64 Prim->Name name-type!
    TYPE_I8 PRIM_I8 Prim->Name name-type!
    TYPE_I16 PRIM_I16 Prim->Name name-type!
    TYPE_I32 PRIM_I32 Prim->Name name-type!
    TYPE_I64 PRIM_I64 Prim->Name name-type!)

def(test-types!, --,
    test-sorts!)

###########
# Context #
###########

# A context for types and terms.
nominal(Ctx, Int) # index into context array
def(Ctx->Int, Ctx -- Int, cast)
def(Int->Ctx, Int -- Ctx, cast)

def(|Ctx|, Size, 8)
def(ctx@, Ptr -- Ctx, @ Int->Ctx)
def(ctx!, Ctx Ptr --, dip(Ctx->Int) !)
def(MAX_CTX, Size, 0x1000)
def(CTX_SIZE, Size, 32)

quad def-static-buffer(NUM_CTX)

MAX_CTX |Ctx| * def-static-buffer(CTX_PREV)
def(ctx-prev&, Ctx -- Ptr, Ctx->Int |Ctx| * CTX_PREV +)
def(ctx-prev@, Ctx -- Ctx, ctx-prev& ctx@)
def(ctx-prev!, Ctx Ctx --, ctx-prev& ctx!)

MAX_CTX |Name| * def-static-buffer(CTX_NAME)
def(ctx-name&, Ctx -- Ptr, Ctx->Int |Name| * CTX_NAME +)
def(ctx-name@, Ctx -- Name, ctx-name& name@)
def(ctx-name!, Name Ctx --, ctx-name& name!)

def(|Sort|, Size, 8)
MAX_CTX |Sort| * def-static-buffer(CTX_SORT)
def(ctx-sort&, Ctx -- Ptr, Ctx->Int |Sort| * CTX_SORT +)
def(ctx-sort@, Ctx -- Sort, ctx-sort& sort@)
def(ctx-sort!, Sort Ctx --, ctx-sort& sort!)

def(ctx-alloc!, Ctx,
    NUM_CTX @ dup 1+ NUM_CTX !
    dup MAX_CTX >= if(
        "compiler error: ran out of space for contexts, increase MAX_CTX" panic!,
        1+ Int->Ctx
    ))
def(ctx-new!, Ctx Name Sort -- Ctx,
    ctx-alloc!
    tuck ctx-sort!
    tuck ctx-name!
    tuck ctx-prev!)

def(ctx-empty, Ctx, 0 Int->Ctx)
def(ctx-is-empty, Ctx -- Bool, Ctx->Int 0 =)
def(ctx-is-empty?, Ctx -- Ctx Bool, dup ctx-is-empty)

def(ctx-has-name?, Name Ctx -- Name Ctx Bool, dup2 ctx-has-name)
def(ctx-has-name, Name Ctx -- Bool,
    ctx-is-empty? if(
        drop2 0,
        dup ctx-name@ dip(over) = if(
            drop2 1,
            ctx-prev@ ctx-has-name
        )
    ))

def(ctx-lookup-sort?, Name Ctx -- Name Ctx Sort, dup2 ctx-lookup-sort)
def(ctx-lookup-sort, Name Ctx -- Sort,
    ctx-is-empty? if(
        drop2 SORT_ERROR,

        dup ctx-name@ dip(over) = if(
            ctx-sort@ nip,
            ctx-prev@ ctx-lookup-sort
        )
    ))

def(ctx-trace!, Ctx -- +IO,
    ctx-is-empty? if(
        drop,

        dup ctx-prev@
        ctx-is-empty? if(
            drop,
            ctx-trace! ", " str-trace!
        )

        dup ctx-sort@
        sort-is-implicit if(
            "'" str-trace!,
            id
        )

        dup ctx-name@
        name-load! str-buf-trace!

        ctx-sort@
        sort-is-word? if(
            ": " str-trace!
            sort-word-type type-trace-sig!,

        sort-is-value? if(
            ": " str-trace!
            sort-value-type type-trace!,

            drop
        ))
    ))

def(ctx-length?, Ctx -- Ctx Size, dup ctx-length)
def(ctx-length, Ctx -- Size,
    0 swap
    while(ctx-is-empty? not,
        dip(1+) ctx-prev@
    )
    drop)

def(ctx-lookup, Ctx Name -- Int Bool,
    over ctx-is-empty if(
        drop2 0 0,
        over ctx-name@ over = if(
            drop ctx-length 1- 1,
            dip(ctx-prev@) ctx-lookup
        )
    ))

#########
# Subst #
#########

nominal(Subst, U32)
def(Subst->Int, Subst -- Int, cast)
def(Int->Subst, Int -- Subst, cast)
def(|Subst|, Size, 8)
def(subst@, Ptr -- Subst, int@ Int->Subst)
def(subst!, Subst Ptr --, dip(Subst->Int) int!)

def(SUBST_BUF_SIZE, Size, 1 18 <<)
quad def-static-buffer(SUBST_BUF_LEN)
SUBST_BUF_SIZE u32s def-static-buffer(SUBST_BUF)

def(subst-alloc!, Ctx -- Subst,
    ctx-length?
    SUBST_BUF_LEN @ tuck
    + 1+ SUBST_BUF_LEN !
    dip(Ctx->Int Int->U32) tuck SUBST_BUF u32!! Int->Subst)

def(subst-ctx@, Subst -- Ctx,
    Subst->Int SUBST_BUF u32@@ U32->Int Int->Ctx)

def(subst-ctx?, Subst -- Subst Ctx,
    dup subst-ctx@)

def(subst-item&, Subst Name -- Ptr,
    dip(subst-ctx?) ctx-lookup if(
        1+ swap Subst->Int + u32s SUBST_BUF +,
        drop2 0 Int->Ptr
    ))

def(subst-lookup, Subst Name -- Type Bool,
    subst-item& dup if(
        u32@ dup if(
            U32->Int 1- Int->Type 1,
            drop TYPE_ERROR 0
        ),
        drop TYPE_ERROR 0
    ))

def(subst-unify!, Subst Name Type -- Type,
    dip(tuck subst-item& dup) swap if(
        over u32@ dup if(
            U32->Int 1- Int->Type type-unify! nip,
            drop dup dip(Type->Int 1+ Int->U32 swap u32!)
        ) nip,
        "compiler warning: weird subst-unify! case -- tell Sofia" elab-emit-warning!
        dip(drop TVar) type-unify!
        # variable not in subst context -- must be a bound variable
    ))

#########
# Sorts #
#########

nominal(Sort, Int)
def(Sort->Int, Sort -- Int, cast)
def(Int->Sort, Int -- Sort, cast)
def(sort@, Ptr -- Sort, @ Int->Sort)
def(sort!, Sort Ptr --, dip(Sort->Int) !)

def(SORT_ERROR, Sort, 0 Int->Sort)

def(SORT_FLAG_SHIFT, Int, 60)
def(SORT_FLAG_MASK, Int, 0xF SORT_FLAG_SHIFT <<)
def(SORT_FLAG_IMPLICIT, Int, 0x1 SORT_FLAG_SHIFT <<)

def(SORT_TAG_SHIFT, Int, 56)
def(SORT_TAG_MASK, Int, 0xF SORT_TAG_SHIFT <<)

def(SORT_TAG_ERROR,  Int, 0)
def(SORT_TAG_TYPE,   Int, 0x1 SORT_TAG_SHIFT <<)
def(SORT_TAG_STACK,  Int, 0x2 SORT_TAG_SHIFT <<)
def(SORT_TAG_EFFECT, Int, 0x3 SORT_TAG_SHIFT <<)
def(SORT_TAG_WORD,   Int, 0x4 SORT_TAG_SHIFT <<)
def(SORT_TAG_VALUE,  Int, 0x5 SORT_TAG_SHIFT <<)

def(sort-tag, Sort -- Int, Sort->Int SORT_TAG_MASK &)

def(sort-is-error, Sort -- Bool, Sort->Int 0 =)
def(sort-is-implicit, Sort -- Bool, Sort->Int SORT_FLAG_IMPLICIT & 0 >)
def(sort-is-explicit, Sort -- Bool, sort-is-implicit not)
def(sort-is-type, Sort -- Bool, sort-tag SORT_TAG_TYPE =)
def(sort-is-stack, Sort -- Bool, sort-tag SORT_TAG_STACK =)
def(sort-is-effect, Sort -- Bool, sort-tag SORT_TAG_EFFECT =)
def(sort-is-word, Sort -- Bool, sort-tag SORT_TAG_WORD =)
def(sort-is-value, Sort -- Bool, sort-tag SORT_TAG_VALUE =)

def(sort-is-error?, Sort -- Sort Bool, dup sort-is-error)
def(sort-is-implicit?, Sort -- Sort Bool, dup sort-is-implicit)
def(sort-is-explicit?, Sort -- Sort Bool, dup sort-is-explicit)
def(sort-is-type?, Sort -- Sort Bool, dup sort-is-type)
def(sort-is-stack?, Sort -- Sort Bool, dup sort-is-stack)
def(sort-is-effect?, Sort -- Sort Bool, dup sort-is-effect)
def(sort-is-word?, Sort -- Sort Bool, dup sort-is-word)
def(sort-is-value?, Sort -- Sort Bool, dup sort-is-value)

def(SORT_PAYLOAD_MASK, Int, 1 24 << 1-)

# Get type for word sort. Panic if not a word sort.
def(sort-word-type, Sort -- Type,
    sort-is-word? if(
        Sort->Int SORT_PAYLOAD_MASK & Int->Type,
        "compiler error: attempted to get sort word sig for non-word sort" panic!
        drop TYPE_ERROR
    ))
def(sort-word-type?, Sort -- Sort Type, dup sort-word-type)

# Get type for value sort. Panic if not a value sort.
def(sort-value-type, Sort -- Type,
    sort-is-value? if(
        Sort->Int SORT_PAYLOAD_MASK & Int->Type,
        "compiler error: attempted to get sort value type for non-type sort" panic!
        drop TYPE_ERROR
    ))
def(sort-value-type?, Sort -- Sort Type, dup sort-value-type)

# Check that two sorts have the same category.
def(sort-match, Sort Sort -- Bool,
    sort-is-type? if(
        drop sort-is-type,
    sort-is-stack? if(
        drop sort-is-stack,
    sort-is-effect? if(
        drop sort-is-effect,
    sort-is-word? if(
        drop sort-is-word,
    sort-is-value? if(
        drop sort-is-value,
        "unknown sort category" panic! drop2 0
    ))))))

# Sort constructors.
def(SImplicit, Sort -- Sort, Sort->Int SORT_FLAG_IMPLICIT | Int->Sort)
def(SType, Sort, SORT_TAG_TYPE Int->Sort)
def(SStack, Sort, SORT_TAG_STACK Int->Sort)
def(SEffect, Sort, SORT_TAG_EFFECT Int->Sort)
def(SWord, Type -- Sort, Type->Int SORT_TAG_WORD | Int->Sort)
def(SValue, Type -- Sort, Type->Int SORT_TAG_VALUE | Int->Sort)

# Unit tests for sort.
def(test-sorts!, --,

    SType
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!1
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!0
        drop
    SType SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!1
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!0
        drop
    SStack
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!0
        sort-is-stack? !!1
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!0
        drop
    SStack SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!0
        sort-is-stack? !!1
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!0
        drop
    SEffect
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!1
        sort-is-word? !!0
        sort-is-value? !!0
        drop
    SEffect SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!1
        sort-is-word? !!0
        sort-is-value? !!0
        drop
    TYPE_ERROR SWord
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!1
        sort-is-value? !!0
        sort-word-type? TYPE_ERROR !!=
        drop
    TYPE_ERROR SWord SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!1
        sort-is-value? !!0
        sort-word-type? TYPE_ERROR !!=
        drop
    TYPE_INT SWord
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!1
        sort-is-value? !!0
        sort-word-type? TYPE_INT !!=
        drop
    TYPE_INT SWord SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!1
        sort-is-value? !!0
        sort-word-type? TYPE_INT !!=
        drop
    TYPE_ERROR SValue
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!1
        sort-value-type? TYPE_ERROR !!=
        drop
    TYPE_ERROR SValue SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!1
        sort-value-type? TYPE_ERROR !!=
        drop
    TYPE_INT SValue
        sort-is-implicit? !!0
        sort-is-explicit? !!1
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!1
        sort-value-type? TYPE_INT !!=
        drop
    TYPE_INT SValue SImplicit
        sort-is-implicit? !!1
        sort-is-explicit? !!0
        sort-is-type? !!0
        sort-is-stack? !!0
        sort-is-effect? !!0
        sort-is-word? !!0
        sort-is-value? !!1
        sort-value-type? TYPE_INT !!=
        drop
)

#########
# Types #
#########

nominal(Type, Int) # actually U56
def(Type->Int, Type -- Int, cast)
def(Int->Type, Int -- Type, cast)
def(|Type|, Size, 8)
def(type@, Ptr -- Type, int@ Int->Type)
def(type!, Type Ptr --, dip(Type->Int) int!)
def(type@@, Int Ptr -- Type, dip(|Type| *) + type@)
def(type!!, Type Int Ptr --, dip(|Type| *) + type!)

def(TYPE_TAG_SHIFT, Int, 48) # top 8 bits are tag
def(TYPE_TAG_MASK, Int, 0xF TYPE_TAG_SHIFT <<)
def(TYPE_TAG_PRIM, Int, 0 TYPE_TAG_SHIFT <<)
def(TYPE_TAG_VAR, Int, 1 TYPE_TAG_SHIFT <<)
def(TYPE_TAG_META, Int, 2 TYPE_TAG_SHIFT <<)
def(TYPE_TAG_TENSOR, Int, 3 TYPE_TAG_SHIFT <<)
def(TYPE_TAG_MORPHISM, Int, 4 TYPE_TAG_SHIFT <<)
def(TYPE_TAG_NOMINAL, Int, 5 TYPE_TAG_SHIFT <<)

def(TYPE_VALUE_MASK, Int, 1 TYPE_TAG_SHIFT << 1-)

def(TPrim, Int -- Type, TYPE_TAG_PRIM | Int->Type)
def(TVar, Name -- Type, Name->Int TYPE_TAG_VAR | Int->Type) # dangerous...
def(TMeta, MetaVar -- Type,
    MetaVar->Int TYPE_TAG_META | Int->Type)
def(TTensor, TensorType -- Type,
    TensorType->Int TYPE_TAG_TENSOR | Int->Type)
def(TMorphism, MorphismType -- Type,
    MorphismType->Int TYPE_TAG_MORPHISM | Int->Type)
def(TNominal, Nominal -- Type,
    Nominal->Int TYPE_TAG_NOMINAL | Int->Type)

def(type-tag, Type -- Int, Type->Int TYPE_TAG_MASK &)
def(type-is-prim, Type -- Bool, type-tag TYPE_TAG_PRIM =)
def(type-is-var, Type -- Bool, type-tag TYPE_TAG_VAR =)
def(type-is-meta, Type -- Bool, type-tag TYPE_TAG_META =)
def(type-is-tensor, Type -- Bool, type-tag TYPE_TAG_TENSOR =)
def(type-is-morphism, Type -- Bool, type-tag TYPE_TAG_MORPHISM =)
def(type-is-nominal, Type -- Bool, type-tag TYPE_TAG_NOMINAL =)
def(type-is-prim?, Type -- Type Bool, dup type-is-prim)
def(type-is-var?, Type -- Type Bool, dup type-is-var)
def(type-is-meta?, Type -- Type Bool, dup type-is-meta)
def(type-is-tensor?, Type -- Type Bool, dup type-is-tensor)
def(type-is-morphism?, Type -- Type Bool, dup type-is-morphism)
def(type-is-nominal?, Type -- Type Bool, dup type-is-nominal)

def(type-is-stack-var, Type -- Bool,
    type-is-var? if(
        type-get-var name-could-be-stack-var,
        drop 0
    ))
def(type-is-stack-var?, Type -- Type Bool, dup type-is-stack-var)

def(type-get-value, Type -- Int, Type->Int TYPE_VALUE_MASK &)
def(type-get-var, Type -- Name,
    type-is-var? not if(
        "compiler error: tried to get var value on non-var type" panic!,
        type-get-value Int->Name
    ))
def(type-get-meta, Type -- MetaVar,
    type-is-meta? not if(
        "compiler error: tried to get meta value on non-meta type" panic!,
        type-get-value Int->MetaVar
    ))
def(type-get-tensor, Type -- TensorType,
    type-is-tensor? not if(
        "compiler error: tried to get tensor value on non-tensor type" panic!,
        type-get-value Int->TensorType
    ))
def(type-get-morphism, Type -- MorphismType,
    type-is-morphism? not if(
        "compiler error: tried to get morphism value on non-morphism type" panic!,
        type-get-value Int->MorphismType
    ))
def(type-get-nominal, Type -- Nominal,
    type-is-nominal? not if(
        "compiler error: tried to get nominal value on non-nominal type" panic!,
        type-get-value Int->Nominal
    ))

def(TYPE_ERROR, Type, 0 TPrim)
def(TYPE_INT, Type, 1 TPrim) # generic integer type for integer literals
def(TYPE_PTR, Type, 2 TPrim) # generic pointer type (e.g. void*)
def(TYPE_U8, Type, 3 TPrim) # fixed width integer type -- unsigned 8 bit
def(TYPE_U16, Type, 4 TPrim) # fixed width integer type -- unsigned 16 bit
def(TYPE_U32, Type, 5 TPrim) # fixed width integer type -- unsigned 32 bit
def(TYPE_U64, Type, 6 TPrim) # fixed width integer type -- unsigned 64 bit
def(TYPE_I8, Type, 7 TPrim) # fixed width integer type -- signed 8 bit
def(TYPE_I16, Type, 8 TPrim) # fixed width integer type -- signed 16 bit
def(TYPE_I32, Type, 9 TPrim) # fixed width integer type -- signed 32 bit
def(TYPE_I64, Type, 10 TPrim) # fixed width integer type -- signed 64 bit
def(TYPE_UNIT, Type, 11 TPrim) # unit type, also used for empty stack

def(type-expand, Type -- Type,
    type-is-meta? if(
        type-get-meta meta-expand,

        id
    ))

def(type-subst, Subst Type -- Subst Type,
    type-expand
    type-is-prim? if(
        id,
    type-is-meta? if(
        id, # maybe panic instead?
    type-is-var? if(
        type-get-var
        dup2 subst-lookup if(
            nip,
            drop TVar
        ),

    type-is-tensor? if(
        type-get-tensor
        tensor-type-subst
        TTensor,

    type-is-morphism? if(
        type-get-morphism
        morphism-type-subst
        TMorphism,

    type-is-nominal? if(
        id, # no type args yet.

        "type-subst: unknown type" panic!
    )))))))


# Unify two types. Raises an elaboration error if unification is impossible.
def(type-unify!, Type Type -- Type,
    dip(type-expand) type-expand

    dup2 = if(
        drop, # types are equal

    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    over TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    swap type-is-meta? if(
        type-get-meta meta-unify!,

    swap type-is-meta? if(
        type-get-meta meta-unify!,

    type-is-prim? if( # other than TYPE_ERROR, primitive types need to be exact matches.
        "failed to unify types" elab-emit-error! # FIXME: improve error messages
        drop2 TYPE_ERROR,

    type-is-var? if( # type variables need to be exact matches.
        "failed to unify types" elab-emit-error! # FIXME: improve error messages
        drop2 TYPE_ERROR,

    type-is-tensor? if(
        type-get-tensor swap
        type-is-tensor? if(
            type-get-tensor swap
            tensor-type-unify! TTensor,

            "failed to unify types" elab-emit-error!  # FIXME: improve error messages
            drop2 TYPE_ERROR
        ),

    type-is-morphism? if(
        type-get-morphism swap
        type-is-morphism? if(
            type-get-morphism swap
            morphism-type-unify! TMorphism,

            "failed to unify types" elab-emit-error! # FIXME: improve error messages
            drop2 TYPE_ERROR
        ),

    type-is-nominal? if( # nominals need to be exact matches (for now)
        "failed to unify types" elab-emit-error! # FIXME: improve error messages
        drop2 TYPE_ERROR,

        "type-unify: unknown type" panic! drop
    )))))))))))

def(type-has-meta?, MetaVar Type -- MetaVar Type Bool,
    dup2 type-has-meta)

def(type-has-meta, MetaVar Type -- Bool,
    type-is-prim? if(
        drop2 0,

    type-is-var? if(
        drop2 0,

    type-is-meta? if(
        type-get-meta =,

    type-is-tensor? if(
        type-get-tensor tensor-type-has-meta,

    type-is-morphism? if(
        type-get-morphism morphism-type-has-meta,

    type-is-nominal? if(
        drop2 0,

        "type-has-meta: unknown type" panic! drop2 0
    )))))))


def(type-trace-sig!, Type -- +IO,
    dup TYPE_ERROR = if(
        "<ERROR>" str-trace! drop,

        type-get-morphism dup
        morphism-type-dom@
        dup TYPE_UNIT = if(
            drop,
            type-trace-stack!
            " " str-trace!
        )
        "--" str-trace!
        morphism-type-cod@
        dup TYPE_UNIT = if(
            drop,
            " " str-trace!
            type-trace-stack!
        )
    ))

def(type-trace-stack!, Type -- +IO,
    type-is-tensor? if(
        type-get-tensor dup
        tensor-type-fst@
        dup TYPE_UNIT = if(
            drop,
            type-trace-stack!
            " " str-trace!
        )
        tensor-type-snd@ type-trace!,

    type-is-stack-var? if(
        type-trace!,

        type-trace!
        " ." str-trace!
    )))

def(type-trace!, Type -- +IO,
    type-is-prim? if(
        type-trace-prim!,

    type-is-var? if(
        type-get-var name-load! str-buf-trace!,

    type-is-meta? if(
        type-get-meta "?" str-trace! MetaVar->Int int-trace!,

    type-is-tensor? if(
        "[" str-trace!
        type-trace-stack!
        "]" str-trace!,

    type-is-morphism? if(
        "[" str-trace!
        type-trace-sig!
        "]" str-trace!,

    type-is-nominal? if(
        type-get-nominal
        nominal-name@
        name-load!
        str-buf-trace!,

        "<UNKNOWN TYPE " str-trace! Type->Int int-trace! ">" str-trace!
    )))))))

def(type-trace-prim!, Type -- +IO,
    dup TYPE_ERROR = if(
        drop "ERROR" str-trace!,
    dup TYPE_UNIT = if(
        drop "[]" str-trace!,
    dup TYPE_INT = if(
        drop "Int" str-trace!,
    dup TYPE_PTR = if(
        drop "Ptr" str-trace!,
    dup TYPE_U8 = if(
        drop "U8" str-trace!,
    dup TYPE_U16 = if(
        drop "U16" str-trace!,
    dup TYPE_U32 = if(
        drop "U32" str-trace!,
    dup TYPE_U64 = if(
        drop "U64" str-trace!,
    dup TYPE_I8 = if(
        drop "I8" str-trace!,
    dup TYPE_I16 = if(
        drop "I16" str-trace!,
    dup TYPE_I32 = if(
        drop "I32" str-trace!,
    dup TYPE_I64 = if(
        drop "I64" str-trace!,
        "<UNKNOWN PRIMITIVE TYPE " str-trace! Type->Int int-trace! ">" str-trace!
    )))))))))))))

##################
# Meta-var Types #
##################

nominal(MetaVar, Int)
def(Int->MetaVar, Int -- MetaVar, cast)
def(MetaVar->Int, MetaVar -- Int, cast)

def(MAX_METAS, Size, 1 20 <<)
quad def-static-buffer(NUM_METAS)

def(meta-alloc!, MetaVar,
    NUM_METAS @ dup 1+ NUM_METAS !
    dup MAX_METAS >= if(
        "compiler error: ran out of meta variables, increase MAX_METAS" panic!,
        Int->MetaVar
        0 over meta-value!
    ))

MAX_METAS 8 * def-static-buffer(META_VALUE)
def(meta-value&, MetaVar -- Ptr, MetaVar->Int 8 * META_VALUE +)
def(meta-value@, MetaVar -- Int, meta-value& int@)
def(meta-value!, Int MetaVar --, meta-value& int!)

def(meta-is-defined, MetaVar -- Bool, meta-value@ 0 =)
def(meta-is-defined?, MetaVar -- MetaVar Bool, dup meta-is-defined)

def(meta-type@, MetaVar -- Type,
    meta-is-defined? not if(
        "compiler error: called meta-type@ on undefined meta-var" panic!,
        meta-value@ 1- Int->Type
    ))
def(meta-type!, Type MetaVar --,
    dip(Type->Int 1+) meta-value!)

def(meta-expand, MetaVar -- Type,
    meta-is-defined? if(
        dup meta-type@ type-expand tuck meta-type!,
        TMeta
    ))

def(meta-unify!, Type MetaVar -- Type,
    meta-is-defined? if(
        meta-expand type-unify!,

    swap
    type-has-meta? if(
        "failed to unify types" elab-emit-error!
        drop
        TYPE_ERROR swap meta-type!
        TYPE_ERROR,

        swap dip(dup)
        meta-type!
    )))

################
# Tensor Types #
################

nominal(TensorType, Int)
def(Int->TensorType, Int -- TensorType, cast)
def(TensorType->Int, TensorType -- Int, cast)

def(MAX_TENSOR_TYPES, Size, 1 20 <<)

quad def-static-buffer(NUM_TENSOR_TYPES)

def(tensor-type-alloc!, TensorType,
    NUM_TENSOR_TYPES @ dup 1+ NUM_TENSOR_TYPES !
    dup MAX_TENSOR_TYPES >= if(
        "compiler error: too many tensor types -- increase MAX_TENSOR_TYPES" panic!,
        Int->TensorType
    ))
def(tensor-type-new!, Type Type -- TensorType,
    tensor-type-alloc!
    dup dip(tensor-type-snd!)
    dup dip(tensor-type-fst!))

MAX_TENSOR_TYPES |Type| * def-static-buffer(TENSOR_TYPE_FST)
def(tensor-type-fst&, TensorType -- Ptr, TensorType->Int |Type| * TENSOR_TYPE_FST +)
def(tensor-type-fst@, TensorType -- Type, tensor-type-fst& type@)
def(tensor-type-fst!, Type TensorType --, tensor-type-fst& type!)

MAX_TENSOR_TYPES |Type| * def-static-buffer(TENSOR_TYPE_SND)
def(tensor-type-snd&, TensorType -- Ptr, TensorType->Int |Type| * TENSOR_TYPE_SND +)
def(tensor-type-snd@, TensorType -- Type, tensor-type-snd& type@)
def(tensor-type-snd!, Type TensorType --, tensor-type-snd& type!)

def(tensor-type-unify!, TensorType TensorType -- TensorType,
    over tensor-type-fst@ over tensor-type-fst@ type-unify! over tensor-type-fst!
    over tensor-type-snd@ over tensor-type-snd@ type-unify! over tensor-type-snd!
    nip)

def(tensor-type-unpack, TensorType -- Type Type,
    dup dip(tensor-type-fst@) tensor-type-snd@)

def(tensor-type-has-meta, MetaVar TensorType -- Bool,
    tensor-type-unpack
    dip(over) type-has-meta if(
        drop2 1,
        type-has-meta
    ))

def(tensor-type-subst, Subst TensorType -- Subst TensorType,
    id) # TODO

##################
# Morphism Types #
##################

nominal(MorphismType, Int)
def(Int->MorphismType, Int -- MorphismType, cast)
def(MorphismType->Int, MorphismType -- Int, cast)

def(MAX_MORPHISM_TYPES, Size, 1 20 <<)
def(MORPHISM_TYPE_SIZE, Size, |Type| 2 *)
quad def-static-buffer(NUM_MORPHISM_TYPES)

def(morphism-type-alloc!, MorphismType,
    NUM_MORPHISM_TYPES @ dup 1+ NUM_MORPHISM_TYPES !
    dup MAX_MORPHISM_TYPES >= if(
        "compiler error: too many morphism types -- increase MAX_MORPHISM_TYPES" panic!,
        Int->MorphismType
    ))
def(morphism-type-new!, Type Type -- MorphismType,
    morphism-type-alloc!
    dup dip(morphism-type-cod!)
    dup dip(morphism-type-dom!))

MAX_MORPHISM_TYPES |Type| * def-static-buffer(MORPHISM_TYPE_DOM)
def(morphism-type-dom&, MorphismType -- Ptr, MorphismType->Int |Type| * MORPHISM_TYPE_DOM +)
def(morphism-type-dom@, MorphismType -- Type, morphism-type-dom& type@)
def(morphism-type-dom!, Type MorphismType --, morphism-type-dom& type!)

MAX_MORPHISM_TYPES |Type| * def-static-buffer(MORPHISM_TYPE_COD)
def(morphism-type-cod&, MorphismType -- Ptr, MorphismType->Int |Type| * MORPHISM_TYPE_COD +)
def(morphism-type-cod@, MorphismType -- Type, morphism-type-cod& type@)
def(morphism-type-cod!, Type MorphismType --, morphism-type-cod& type!)

def(morphism-type-unify!, MorphismType MorphismType -- MorphismType,
    over morphism-type-dom@ over morphism-type-dom@ type-unify! over morphism-type-dom!
    over morphism-type-cod@ over morphism-type-cod@ type-unify! over morphism-type-cod!
    nip)

def(morphism-type-unpack, MorphismType -- Type Type,
    dup dip(morphism-type-dom@) morphism-type-cod@)

def(morphism-type-has-meta, MetaVar MorphismType -- Bool,
    morphism-type-unpack
    dip(over) type-has-meta if(
        drop2 1,
        type-has-meta
    ))

def(morphism-type-subst, Subst MorphismType -- Subst MorphismType,
    id) # TODO

############################################
# TyConApp -- A TyCon applied to arguments #
############################################

nominal(TyConApp, Int) # 48 bits [0-19: offset args, 20-27: num args, 28-47: tycon]
def(TyConApp->Int, TyConApp -- Int, cast)
def(Int->TyConApp, Int -- TyConApp, cast)

def(TYCONAPP_MAX_ARGS, Size, 1 20 <<)
quad def-static-buffer(TYCONAPP_NUM_ARGS)
TYCONAPP_MAX_ARGS |Type| * def-static-buffer(TYCONAPP_ARGS)

def(tyconapp-alloc!, TyCon Int -- TyConApp,
    dup 0 > if(
        dup TYCONAPP_NUM_ARGS @ tuck +
        dup TYCONAPP_MAX_ARGS > if(
            "compiler error: TYCONAPP_NUM_ARGS > TYCONAPP_MAX_ARGS" panic! drop,
            TYCONAPP_NUM_ARGS !
        ),
        drop 0 0
    )
    dip(20 <<) | dip(TyCon->Int 28 <<) | Int->TyConApp)

def(tyconapp-tycon, TyConApp -- TyCon, TyConApp->Int 28 >> Int->TyCon)
def(tyconapp-args-len, TyConApp -- Int, TyConApp->Int 20 >> 0xFF &)
def(tyconapp-args-ptr, TyConApp -- Ptr, TyConApp->Int 0xFFFFF & TYCONAPP_ARGS +)

def(tyconapp-arg&, Int TyConApp -- Ptr,
    dup2 tyconapp-args-len >= if(
        "compiler error: attempted to get out-of-bounds TyConApp arg" panic! drop,
        dip(|Type| *) tyconapp-args-ptr +
    ))
def(tyconapp-arg@, Int TyConApp -- Type, tyconapp-arg& type@)
def(tyconapp-arg!, Type Int TyConApp --, tyconapp-arg& type!)
def(tyconapp-arg0!, Type TyConApp --, dip(0) tyconapp-arg!)
def(tyconapp-arg1!, Type TyConApp --, dip(1) tyconapp-arg!)
def(tyconapp-arg2!, Type TyConApp --, dip(2) tyconapp-arg!)
def(tyconapp-arg3!, Type TyConApp --, dip(3) tyconapp-arg!)
def(tyconapp-arg0@, TyConApp -- Type, dip(0) tyconapp-arg@)
def(tyconapp-arg1@, TyConApp -- Type, dip(1) tyconapp-arg@)
def(tyconapp-arg2@, TyConApp -- Type, dip(2) tyconapp-arg@)
def(tyconapp-arg3@, TyConApp -- Type, dip(3) tyconapp-arg@)
def(tyconapp-arg0?, TyConApp -- TyConApp Type, dup tyconapp-arg0@)
def(tyconapp-arg1?, TyConApp -- TyConApp Type, dup tyconapp-arg1@)
def(tyconapp-arg2?, TyConApp -- TyConApp Type, dup tyconapp-arg2@)
def(tyconapp-arg3?, TyConApp -- TyConApp Type, dup tyconapp-arg3@)



##############################
# TyCon -- Type Constructors #
##############################

nominal(TyCon, Int)
def(Int->TyCon, Int -- TyCon, cast)
def(TyCon->Int, TyCon -- Int, cast)


############
# Nominals #
############

nominal(Nominal, Int)
def(Int->Nominal, Int -- Nominal, cast)
def(Nominal->Int, Nominal -- Int, cast)

def(MAX_NOMINALS, Size,  1 20 <<)
quad def-static-buffer(NUM_NOMINALS)

MAX_NOMINALS |Type| * def-static-buffer(NOMINAL_TYPE)
def(nominal-type&, Nominal -- Ptr, Nominal->Int |Type| * NOMINAL_TYPE +)
def(nominal-type@, Nominal -- Type, nominal-type& type@)
def(nominal-type!, Type Nominal --, nominal-type& type!)

MAX_NOMINALS |Name| * def-static-buffer(NOMINAL_NAME)
def(nominal-name&, Nominal -- Ptr, Nominal->Int |Name| * NOMINAL_NAME +)
def(nominal-name@, Nominal -- Name, nominal-type& name@)
def(nominal-name!, Name Nominal --, nominal-type& name!)

def(nominal-alloc!, Size,
    NUM_NOMINALS @ dup 1+ NUM_NOMINALS !
    dup MAX_NOMINALS >= if(
        "NUM_NOMINALS" panic!,
        id
    ))

def(nominal-new!, Name Type -- Nominal,
    nominal-alloc!
    tuck nominal-type!
    tuck nominal-name!)
