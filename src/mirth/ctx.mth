module(mirth/ctx)
import(mirth/var)

###########
# Context #
###########

# A context for types and terms.
nominal(Ctx, Int) # index into context array
def(Ctx->Int, Ctx -- Int, cast)
def(Int->Ctx, Int -- Ctx, cast)
def(|Ctx|, Size, 2)
def(ctx@, Ptr -- Ctx, u16@ U16->Int Int->Ctx)
def(ctx!, Ctx Ptr --, dip(Ctx->Int Int->U16) u16!)

def(MAX_CTX, Size, 0x4000)
quad def-static-buffer(NUM_CTX)

MAX_CTX |Ctx| * def-static-buffer(CTX_PREV)
def(ctx-prev&, Ctx -- Ptr, Ctx->Int |Ctx| * CTX_PREV +)
def(ctx-prev@, Ctx -- Ctx, ctx-prev& ctx@)
def(ctx-prev!, Ctx Ctx --, ctx-prev& ctx!)

MAX_CTX |Var| * def-static-buffer(CTX_VAR)
def(ctx-var&, Ctx -- Ptr, Ctx->Int |Var| * CTX_VAR +)
def(ctx-var@, Ctx -- Var, ctx-var& var@)
def(ctx-var!, Var Ctx --, ctx-var& var!)

def(ctx-name@, Ctx -- Name, ctx-var@ var-name@)

def(|Sort|, Size, 8)
MAX_CTX |Sort| * def-static-buffer(CTX_SORT)
def(ctx-sort&, Ctx -- Ptr, Ctx->Int |Sort| * CTX_SORT +)
def(ctx-sort@, Ctx -- Sort, ctx-sort& sort@)
def(ctx-sort!, Sort Ctx --, ctx-sort& sort!)

def(ctx-alloc!, Ctx,
    NUM_CTX @ dup 1+ NUM_CTX !
    dup MAX_CTX >= if(
        "compiler error: ran out of space for contexts, increase MAX_CTX" panic!,
        1+ Int->Ctx
    ))
def(ctx-new!, Ctx Var -- Ctx,
    ctx-alloc!
    tuck ctx-var!
    tuck ctx-prev!)

def(ctx-empty, Ctx, 0 Int->Ctx)
def(ctx-is-empty, Ctx -- Bool, Ctx->Int 0 =)
def(ctx-is-empty?, Ctx -- Ctx Bool, dup ctx-is-empty)

def(ctx-has-name?, Name Ctx -- Name Ctx Bool, dup2 ctx-has-name)
def(ctx-has-name, Name Ctx -- Bool,
    ctx-is-empty? if(
        drop2 0,
        dup ctx-name@ dip(over) = if(
            drop2 1,
            ctx-prev@ ctx-has-name
        )
    ))

def(ctx-lookup?, Name Ctx -- Name Ctx Var, dup2 ctx-lookup)
def(ctx-lookup, Name Ctx -- Var,
    ctx-is-empty? if(
        drop2 VAR_ERROR,

        dup ctx-var@ dip(over) = if(
            ctx-var@ nip,
            ctx-prev@ ctx-lookup
        )
   ))

def(ctx-trace!, Ctx -- +IO,
    ctx-is-empty? if(
        drop,

        dup ctx-prev@
        ctx-is-empty? if(
            drop,
            ctx-trace! ", " str-trace!
        )

        dup ctx-sort@
        sort-is-implicit if(
            "'" str-trace!,
            id
        )

        dup ctx-name@
        name-load! str-buf-trace!

        ctx-sort@
        sort-is-word? if(
            ": " str-trace!
            sort-word-type type-trace-sig!,

        sort-is-value? if(
            ": " str-trace!
            sort-value-type type-trace!,

            drop
        ))
    ))

def(ctx-length?, Ctx -- Ctx Size, dup ctx-length)
def(ctx-length, Ctx -- Size,
    0 swap
    while(ctx-is-empty? not,
        dip(1+) ctx-prev@
    )
    drop)

# def(ctx-lookup, Ctx Name -- Int Bool,
#     over ctx-is-empty if(
#         drop2 0 0,
#         over ctx-name@ over = if(
#             drop ctx-length 1- 1,
#             dip(ctx-prev@) ctx-lookup
#         )
#     ))
