module(mirth/codegen)
import(prelude)
import(mirth/data/token)
import(mirth/data/name)
import(mirth/data/buffer)
import(mirth/data/arrow)

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)
buffer(CODEGEN_FILE, 8)
buffer(CODEGEN_LENGTH, 8)
buffer(CODEGEN_BUF, 0x2000)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE file@)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE file!)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH int@)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH int!)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ File->Int CODEGEN_BUF codegen-length@
        posix-write! dup 0 < if(
            "error: codegen write failed" panic!,
            codegen-length@ < if(
                "error: codegen write wrote fewer bytes than expected" panic!,
                0 codegen-length!
            )
        ),
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup str-head U8->Int nonzero, dup str-head .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    stdout codegen-file!
    0 codegen-length!)

def(run-output-c99!, Arrow Path -- +IO,
    num-errors@ 0 > if(
        drop2,

        make-output-path Path->Str
        create-file! codegen-start!
            # FIXME: implement and use create-binary-file!
            # instead of create-file! here ... perhaps
        c99-emit-header!
        c99-emit-prims!
        c99-emit-tags!
        c99-emit-buffers!
        c99-emit-externals!
        c99-emit-word-sigs!
        c99-emit-block-sigs!
        c99-emit-word-defs!
        c99-emit-block-defs!
        c99-emit-main!
        codegen-end!
    ))

buffer(C99_DEPTH, 8)
def(c99-depth@, -- Int +Codegen, C99_DEPTH int@)
def(c99-depth!, Int -- +Codegen, C99_DEPTH int!)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, int-show .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! .)

def(.w, Name -- +IO, "static void mw" . .name " (void)" .)
def(.p, Prim -- +IO, prim-name@ .w)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WINDOWS 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>" ;
    "#include <stdbool.h>" ;;

    "typedef uint8_t u8;" ;
    "typedef uint16_t u16;" ;
    "typedef uint32_t u32;" ;
    "typedef uint64_t u64;" ;
    "typedef int8_t i8;" ;
    "typedef int16_t i16;" ;
    "typedef int32_t i32;" ;
    "typedef int64_t i64;" ;
    "typedef uintptr_t usize;" ;;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern void* calloc(usize, usize);" ;
    "extern void* realloc(void*, usize);" ;
    "extern void* memset(void*, int, usize);" ;
    "extern void* memcpy(void*, const void*, usize);" ;
    "extern void free(void*);" ;
    "extern usize strlen(const char*);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;

    "typedef enum value_tag_t {" ;
    "   VT_U64 = 0x00," ; # u64
    "   VT_U32 = 0x01," ; # u32 u32
    "   VT_U21 = 0x02," ; # u21 u21 u21
    "   VT_U16 = 0x03," ; # u16 u16 u16 u16
    "   VT_C16 = 0x04," ; # c16 u16 u16 u16
    "   VT_C21 = 0x05," ; # c21 u21 u21
    "   VT_C32 = 0x06," ; # c32 u32
    "   VT_C64 = 0x07," ; # c64
    "} value_tag_t;" ;;

    "typedef void (*fnptr)(void);" ;;

    "typedef union value_payload_t {" ;
    "    void* vp_ptr;" ;
    "    u8 vp_u8;" ;
    "    u16 vp_u16;" ;
    "    u32 vp_u32;" ;
    "    u64 vp_u64;" ;
    "    i8 vp_i8;" ;
    "    i16 vp_i16;" ;
    "    i32 vp_i32;" ;
    "    i64 vp_i64;" ;
    "    bool vp_bool;" ;
    "    fnptr vp_fnptr;" ;
    "} value_payload_t;" ;;

    "typedef struct value_t {" ;
    "   value_payload_t payload;" ;
    "   value_tag_t tag; " ;
    "} value_t; " ;;

    "typedef struct cell_t {" ;
    "   u32 refs;" ; # reference count
    "   bool freecdr;" ; # call "free" on cdr
    "   value_t car;" ;
    "   value_t cdr;" ;
    "} cell_t;" ;;

    "#define STACK_SIZE 0x1000" ;
    "static usize stack_counter = STACK_SIZE;" ;
    "static value_t stack [STACK_SIZE] = {0};" ;;

    "#define HEAP_SIZE 0x80000" ;
    "#define HEAP_MASK 0x7FFFF" ;
    "static usize heap_next = 1;" ;
    "static usize heap_count = 0;" ;
    "static cell_t heap [HEAP_SIZE] = {0};" ;;

    "static int global_argc;" ;
    "static char** global_argv;" ;;
    )

def(c99-emit-buffers!, +IO,
    Buffer.for(c99-emit-buffer!) .lf)

def(c99-emit-buffer!, Buffer -- +IO,
    " static u8 b" . buffer-name? .name "[" . buffer-size? .n "] = {0};" ;
    " static void mw" . buffer-name? .name " (void) { push_ptr((void*)b" . buffer-name@ .name "); }" ;)

def(c99-emit-tags!, +IO,
    Tag.for(c99-emit-tag!) .lf)

def(c99-emit-tag!, Tag -- +IO,
    "static void mw" . tag-name? .name " (void) {" ;
    tag-is-transparent? if(
        drop,
        tag-num-inputs? 0 == if(
            "    push_u64(" . tag-value@ .n "LL);" ;,

            "    value_t car = pop_value();" ;
            tag-num-inputs? 1-
            while(dup 0 >, "    car = mkcell(car, pop_value());" ;  1-) drop
            "    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = " . tag-value@ .n "LL } };" ;
            "    car = mkcell(car, tag);" ;
            "    push_value(car);" ;
        )
    )
    "}" ;;)

def(c99-emit-prims!, +IO,
    "static usize get_cell_index (value_t v) {" ;
    "    switch (v.tag) {" ;
    "        case VT_C64: return (usize)v.payload.vp_u64;" ;
    "        case VT_C32: return (usize)(v.payload.vp_u64 >> 32);" ;
    "        case VT_C21: return (usize)(v.payload.vp_u64 >> 42);" ;
    "        case VT_C16: return (usize)(v.payload.vp_u64 >> 48);" ;
    "        default: return 0;" ;
    "    }" ;
    "}" ;;

    "static void incref (value_t v) {" ;
    "    usize cell_index = get_cell_index(v);" ;
    "    if (cell_index) {" ;
    "        cell_t *cell = heap + cell_index;" ;
    "        cell->refs++;" ;
    "    }" ;
    "}" ;;

    "static void decref (value_t v) { " ;
    "    usize cell_index;" ;
    "    while ((cell_index = get_cell_index(v))) {" ;
    "        cell_t *cell = heap + cell_index;" ;
    "        if (cell->refs >= 1) {" ;
    "            cell->refs--;" ;
    "            if (cell->refs == 0) {" ;
    "                value_t car = cell->car;" ;
    "                value_t cdr = cell->cdr;" ;
    "                bool freecdr = cell->freecdr;" ;
    "                cell->freecdr = false;" ;
    "                cell->car.tag = 0; cell->car.payload.vp_u64 = 0;" ;
    "                cell->cdr.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" ;
    "                heap_next = cell_index;" ;
    "                heap_count--;" ;
    "                if (freecdr && cell->cdr.tag == VT_U64) {" ;
    "                    free(cdr.payload.vp_ptr);" ;
    "                } else {" ;
    "                    decref(cdr);" ;
    "                }" ;
    "                v = car;" ;
    "            } else {" ;
    "                break;" ;
    "            }" ;
    "        } else {" ;
    "            break;" ;
    "        }" ;
    "    }" ;
    "}" ;;

    ||| Decrement reference after a cons. This is equivalent to:
    |||     incref(car), incref(cdr), decref(cell)
    ||| but it avoids unnecessary increfs/decrefs on the car/cdr.
    "static void decref_for_uncons (value_t v) { " ;
    "    usize cell_index = get_cell_index(v);" ;
    "    cell_t *cell = heap + cell_index;" ;
    "    if (cell->refs >= 1) {" ;
    "        cell->refs--;" ;
    "        if (cell->refs == 0) {" ;
    "            cell->cdr.tag = 0; cell->car.payload.vp_u64 = 0;" ;
    "            cell->car.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" ;
    "            heap_next = cell_index;" ;
    "            heap_count--;" ;
    "        } else {" ;
    "            incref(cell->car);" ;
    "            incref(cell->cdr);" ;
    "        }" ;
    "    }" ;
    "}" ;;


    "static void value_uncons(value_t val, value_t* car, value_t* cdr) {" ;
    "    switch (val.tag) {" ;
    "        case VT_U64: {" ;
    "            value_t nil = { 0 };" ;
    "            *car = nil;" ;
    "            *cdr = val;" ;
    "        } break;" ;
    "        case VT_U32: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFFFFFF;" ;
    "            u64 hi = vv >> 32;" ;
    "            car->tag = VT_U64; car->payload.vp_u64 = hi;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C64: {" ;
    "            cell_t* cell = heap + val.payload.vp_u64;" ;
    "            *car = cell->car;" ;
    "            *cdr = cell->cdr;" ;
    "        } break;" ;
    "        case VT_C32: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFFFFFF;" ;
    "            u64 hi = vv >> 32;" ;
    "            car->tag = VT_C64; car->payload.vp_u64 = hi;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_U21: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0x1FFFFF;" ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" ;
    "            car->tag = VT_U32;" ;
    "            car->payload.vp_u64 = (hi << 32) | md;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C21: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0x1FFFFF;" ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" ;
    "            car->tag = VT_C32;" ;
    "            car->payload.vp_u64 = (hi << 32) | md;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_U16: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFF;" ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" ;
    "            car->tag = VT_U21;" ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C16: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFF;" ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" ;
    "            car->tag = VT_C21;" ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "    }" ;
    "}" ;;

    "static value_t pop_value (void) {" ;
    "    if (stack_counter >= STACK_SIZE) {" ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    "        exit(1);" ;
    "    }" ;
    "    return stack[stack_counter++];" ;
    "}" ;;

    "static bool value_has_ptr_offset (value_t v) {" ;
    "    if (v.tag == VT_C64) {" ;
    "        usize cell_index = (usize)v.payload.vp_u64;" ;
    "        struct cell_t * cell = heap + cell_index;" ;
    "        return !cell->freecdr;" ;
    "    } else {" ;
    "        return v.tag != VT_U64;" ;
    "    }" ;
    "}" ;;

    "static u64 value_ptr_size (value_t v) {" ;
    "    if (v.payload.vp_u64 == 0) {" ;
    "        return 0;" ;
    "    } else if (v.tag == VT_U64) {" ;
    "        return strlen(v.payload.vp_ptr) + 1;" ;
    "    } else if (value_has_ptr_offset(v)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        value_t car2, cdr2;" ;
    "        value_uncons(car, &car2, &cdr2);" ;
    "        u64 size = car2.payload.vp_u64;" ;
    "        u64 offset = cdr.payload.vp_u64;" ;
    "        if (size >= offset) {" ;
    "            return offset - size;" ;
    "        } else {" ;
    "            return 0;" ;
    "        }" ;
    "    } else {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        return car.payload.vp_u64;" ;
    "    }" ;
    "}" ;;

    "static void* value_ptr_base (value_t v) {" ;
    "    if (value_has_ptr_offset(v)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        value_t car2, cdr2;" ;
    "        value_uncons(car, &car2, &cdr2);" ;
    "        return cdr2.payload.vp_ptr;" ;
    "    } else {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        return cdr.payload.vp_ptr;" ;
    "    }" ;
    "}" ;;

    "static i64 value_ptr_offset (value_t v) {" ;
    "    if (value_has_ptr_offset(v)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        return cdr.payload.vp_i64;" ;
    "    } else {" ;
    "        return 0;" ;
    "    }" ;
    "}" ;;

    "static void* value_ptr (value_t v) {" ;
    "    char* ptr = value_ptr_base(v);" ;
    "    i64 offset = value_ptr_offset(v);" ;
    "    return (void*)(ptr + offset);" ;
    "}" ;;

    "static fnptr pop_fnptr (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_fnptr;" ;
    "}" ;;
    "static u8 pop_u8 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u8;" ;
    "}" ;;
    "static u16 pop_u16 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u16;" ;
    "}" ;;
    "static u32 pop_u32 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u32;" ;
    "}" ;;
    "static u64 pop_u64 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u64;" ;
    "}" ;;
    "static i8 pop_i8 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i8;" ;
    "}" ;;
    "static i16 pop_i16 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i16;" ;
    "}" ;;
    "static i32 pop_i32 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i32;" ;
    "}" ;;
    "static i64 pop_i64 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i64;" ;
    "}" ;;
    "static bool pop_bool (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_bool;" ;
    "}" ;;

    "static void push_value (value_t v) {" ;
    "    if (stack_counter < 1) {" ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
    "        exit(1);" ;
    "    }" ;
    "    stack[--stack_counter] = v;" ;
    "}" ;;
    "static void push_ptr (void* x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_ptr = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_fnptr (fnptr x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_fnptr = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_u8 (u8 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u8 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_u16 (u16 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u16 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_u32 (u32 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u32 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_u64 (u64 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_i8 (i8 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i8 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_i16 (i16 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i16 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_i32 (i32 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i32 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_i64 (i64 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_i64 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "static void push_bool (bool x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_bool = x;" ;
    "    push_value(v);" ;
    "}" ;;
    # create a cons cell, while taking ownership of car and cdr's refs
    "static value_t mkcell (value_t car, value_t cdr) {" ;
    "    if ((car.payload.vp_u64 == 0) && (cdr.tag == VT_U64))" ;
    "        return cdr;" ;
    "    if (cdr.tag == VT_U64) {" ;
    "        switch (car.tag) {" ;
    "            case VT_U64: {" ;
    "                u64 x0 = car.payload.vp_u64;" ;
    "                u64 x1 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U32;" ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C64: {" ;
    "                u64 x0 = car.payload.vp_u64;" ;
    "                u64 x1 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C32;" ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_U32: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" ;
    "                u64 x2 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U21;" ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C32: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" ;
    "                u64 x2 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C21;" ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_U21: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" ;
    "                u64 x3 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFLL;" ;
    "                u64 y2 = x2 & 0xFFFFLL;" ;
    "                u64 y3 = x3 & 0xFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U16;" ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C21: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" ;
    "                u64 x3 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFLL;" ;
    "                u64 y2 = x2 & 0xFFFFLL;" ;
    "                u64 y3 = x3 & 0xFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C16;" ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            default: break;" ;
    "        }" ;
    "    }" ;
    "    if (heap_count >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 cell_index = heap_next;" ;
    "    cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->freecdr = false;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_C64;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;

    "static value_t mkcell_freecdr (value_t car, value_t cdr) {" ;
    "    if (heap_count >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 cell_index = heap_next;" ;
    "    cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->freecdr = true;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_C64;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;


    "static void do_pack_uncons() {" ;
    "    value_t car, cdr, val;" ;
    "    val = pop_value();" ;
    "    value_uncons(val, &car, &cdr);" ;
    "    push_value(car); push_value(cdr);" ;
    "    if (val.tag == VT_C64) {" ;
    "        decref_for_uncons(val);" ;
    "    }" ;
    "}" ;;

    "static i64 get_value_tag(value_t v) {" ;
    "    switch (v.tag) {" ;
    "        case VT_C64: {" ;
    "            cell_t *c = heap + v.payload.vp_u64;" ;
    "            if (c->cdr.tag == VT_U64) return c->cdr.payload.vp_i64;" ;
    "            return 0;" ;
    "        } break;" ;
    "        case VT_U64: {" ;
    "            return v.payload.vp_i64;" ;
    "        } break;" ;
    "        case VT_U32: {" ;
    "            return v.payload.vp_u64 & 0xFFFFFFFF;" ;
    "        } break;" ;
    "        case VT_C32: {" ;
    "            return v.payload.vp_u64 & 0xFFFFFFFF;" ;
    "        } break;" ;
    "        case VT_U21: {" ;
    "            return v.payload.vp_u64 & 0x1FFFFF;" ;
    "        } break;" ;
    "        case VT_C21: {" ;
    "            return v.payload.vp_u64 & 0x1FFFFF;" ;
    "        } break;" ;
    "        case VT_U16: {" ;
    "            return v.payload.vp_u64 & 0xFFFF;" ;
    "        } break;" ;
    "        case VT_C16: {" ;
    "            return v.payload.vp_u64 & 0xFFFF;" ;
    "        } break;" ;
    "    }" ;
    "    return 0;" ;
    "}" ;;

    "static u64 get_top_data_tag() {" ;
    "    return get_value_tag(stack[stack_counter]);" ;
    "}" ;;

    "static int value_cmp(value_t v1, value_t v2) {" ;
    "    while(1) {" ;
    "        i64 t1 = get_value_tag(v1);" ;
    "        i64 t2 = get_value_tag(v2);" ;
    "        if (t1 < t2) return -1;" ;
    "        if (t1 > t2) return 1;" ;
    "        if ((v1.tag == VT_U64) && (v2.tag == VT_U64)) return 0;" ;
    "        value_t v1car, v1cdr, v2car, v2cdr;" ;
    "        value_uncons(v1, &v1car, &v1cdr);" ;
    "        value_uncons(v2, &v2car, &v2cdr);" ;
    "        int cdrcmp = value_cmp(v1cdr, v2cdr);" ;
    "        if (cdrcmp != 0) return cdrcmp;" ;
    "        v1 = v1car; v2 = v2car;" ;
    "    }" ;
    "}" ;;

    "static void do_run() {" ;
    "    do_pack_uncons();" ;
    "    fnptr fp = pop_fnptr();" ;
    "    fp();" ;
    "}" ;;

    PRIM_CORE_ID .p " {" ;
    "}" ;;

    PRIM_CORE_DUP .p " {" ;
    "    value_t v = pop_value();" ;
    "    incref(v);" ;
    "    push_value(v); push_value(v);" ;
    "}" ;;

    "static void do_drop() {" ;
    "    value_t v = pop_value();" ;
    "    decref(v);" ;
    "}" ;;

    PRIM_CORE_DROP .p " { do_drop(); }" ;;

    "static void do_swap() {" ;
    "    value_t x = pop_value();" ;
    "    value_t y = pop_value();" ;
    "    push_value(x); push_value(y);" ;
    "}" ;;

    PRIM_CORE_SWAP .p " { do_swap(); }" ;;

    PRIM_CORE_DIP .p " {" ;
    "    value_t f = pop_value();" ;
    "    value_t x = pop_value();" ;
    "    push_value(f);" ;
    "    do_run();" ;
    "    push_value(x);" ;
    "}" ;;

    PRIM_CORE_IF .p " {" ;
    "    value_t then_branch = pop_value();" ;
    "    value_t else_branch = pop_value();" ;
    "    bool b = pop_bool();" ;
    "    if (b) {" ;
    "        push_value(then_branch);" ;
    "        decref(else_branch);" ;
    "    } else {" ;
    "        push_value(else_branch);" ;
    "        decref(then_branch);" ;
    "    }" ;
    "    do_run();" ;
    "}" ;;

    PRIM_CORE_WHILE .p " {" ;
    "    value_t cond = pop_value();" ;
    "    value_t body = pop_value();" ;
    "    while(1) {" ;
    "        push_value(cond); incref(cond); do_run();" ;
    "        bool b = pop_bool();" ;
    "        if (!b) break;" ;
    "        push_value(body); incref(body); do_run();" ;
    "    }" ;
    "    decref(cond); decref(body);" ;
    "}" ;;

    PRIM_INT_ADD .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(x + y);" ;
    "}" ;;

    PRIM_INT_SUB .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y - x);" ;
    "}" ;;

    PRIM_INT_MUL .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(x * y);" ;
    "}" ;;

    PRIM_INT_DIV .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(y / x);" ;
    "}" ;;

    PRIM_INT_MOD .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(y % x);" ;
    "}" ;;

    PRIM_VALUE_EQ .p " {" ;
    "    value_t v2 = pop_value();" ;
    "    value_t v1 = pop_value();" ;
    "    push_bool(value_cmp(v1, v2) == 0);" ;
    "    decref(v1); decref(v2);" ;
    "}" ;;

    PRIM_VALUE_LT .p " {" ;
    "    value_t v2 = pop_value();" ;
    "    value_t v1 = pop_value();" ;
    "    push_bool(value_cmp(v1, v2) < 0);" ;
    "    decref(v1); decref(v2);" ;
    "}" ;;

    PRIM_VALUE_LE .p " {" ;
    "    value_t v2 = pop_value();" ;
    "    value_t v1 = pop_value();" ;
    "    push_bool(value_cmp(v1, v2) <= 0);" ;
    "    decref(v1); decref(v2);" ;
    "}" ;;

    PRIM_INT_AND .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y & x);" ;
    "}" ;;

    PRIM_INT_OR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y | x);" ;
    "}" ;;

    PRIM_INT_XOR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y ^ x);" ;
    "}" ;;

    PRIM_INT_SHL .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y << x);" ;
    "}" ;;

    PRIM_INT_SHR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y >> x);" ;
    "}" ;;

    PRIM_POSIX_WRITE .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    value_t vp = pop_value();" ;
    "    void* p = value_ptr(vp);" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)write(f, p, n));" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_POSIX_READ .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    value_t vp = pop_value();" ;
    "    void* p = value_ptr(vp);" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)read(f,p,n));" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_POSIX_OPEN .p " {" ;
    "    int m = (int)pop_i64();" ;
    "    int f = (int)pop_i64();" ;
    "    value_t vp = pop_value();" ;
    "    void* p = value_ptr(vp);" ;
    "    push_i64((i64)open(p,f,m));" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_POSIX_CLOSE .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    push_i64((i64)close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .p " {" ;
    "    #ifdef MIRTH_WINDOWS" ;
    "    pop_value(); pop_value(); pop_value(); pop_value();" ;
    "    usize b = (usize)pop_u64();" ;
    "    pop_value();" ;
    "    push_ptr(malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop_i64();" ;
    "    int e = (int)pop_i64();" ;
    "    int d = (int)pop_i64();" ;
    "    int c = (int)pop_i64();" ;
    "    usize b = (usize)pop_u64();" ;
    "    value_t va = pop_value();" ;
    "    void* a = value_ptr(va);" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push_ptr(p);" ;
    "    decref(va);" ;
    "    #endif" ;
    "}" ;;

    "static void do_debug() {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x; i64 y;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {" ;
    "        cp = c+30;" ;
    "        x = stack[i].payload.vp_i64;" ;
    "        n = 1;" ;
    "        y = x; if (x < 0) { x = -x; }" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        if (y < 0) { *cp-- = '-'; n++; } " ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_CORE_DEBUG .p " {" ;
    "   do_debug();" ;
    "}" ;;

    PRIM_VALUE_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    value_t* p = value_ptr(vp);" ;
    "    value_t v = *p;" ;
    "    push_value(v);" ;
    "    incref(v);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_VALUE_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    value_t* p = value_ptr(vp);" ;
    "    value_t v = pop_value();" ;
    "    value_t old_v = *p;" ;
    "    *p = v;" ;
    "    decref(old_v);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_INT_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i64* p = value_ptr(vp);" ;
    "    push_i64(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_INT_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i64* p = value_ptr(vp);" ;
    "    *p = (i64)pop_i64();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_PTR_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    void** p = value_ptr(vp);" ;
    "    push_ptr(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_PTR_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    value_t vx = pop_value();" ;
    "    void** p = value_ptr(vp);" ;
    "    *p = value_ptr(vx);" ;
    "    decref(vp); decref(vx);" ;
    "}" ;;

    PRIM_U8_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u8* p = value_ptr(vp);" ;
    "    push_u8(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U8_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u8* p = value_ptr(vp);" ;
    "    *p = pop_u8();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U16_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u16* p = value_ptr(vp);" ;
    "    push_u16(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U16_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u16* p = value_ptr(vp);" ;
    "    *p = pop_u16();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U32_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u32* p = value_ptr(vp);" ;
    "    push_u32(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U32_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u32* p = value_ptr(vp);" ;
    "    *p = pop_u32();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U64_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u64* p = value_ptr(vp);" ;
    "    push_u64(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_U64_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    u64* p = value_ptr(vp);" ;
    "    *p = pop_u64();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I8_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i8* p = value_ptr(vp);" ;
    "    push_i8(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I8_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i8* p = value_ptr(vp);" ;
    "    *p = pop_i8();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I16_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i16* p = value_ptr(vp);" ;
    "    push_i16(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I16_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i16* p = value_ptr(vp);" ;
    "    *p = pop_i16();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I32_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i32* p = value_ptr(vp);" ;
    "    push_i32(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I32_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i32* p = value_ptr(vp);" ;
    "    *p = pop_i32();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I64_GET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i64* p = value_ptr(vp);" ;
    "    push_i64(*p);" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_I64_SET .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i64* p = value_ptr(vp);" ;
    "    *p = pop_i64();" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_SYS_OS .p " {" ;
    "#if defined(MIRTH_WINDOWS)" ;
    "    push_u64(" . OS_WINDOWS cast .n ");" ;
    "#elif defined(MIRTH_LINUX)" ;
    "    push_u64(" . OS_LINUX cast .n ");" ;
    "#elif defined(MIRTH_MACOS)" ;
    "    push_u64(" . OS_MACOS cast .n ");" ;
    "#else" ;
    "    push_u64(" . OS_UNKNOWN cast .n ");" ;
    "#endif" ;
    "}" ;;

    PRIM_VALUE_CAST .p " { }" ;;

    PRIM_CORE_RUN .p " {" ;
    "    do_run();" ;
    "}" ;;

    PRIM_PTR_ADD .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i64 y = pop_i64();" ;
    "    if (vp.tag == VT_U64) {" ;
    "        push_i64(y + vp.payload.vp_i64);" ;
    "    } else if (value_has_ptr_offset(vp)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(vp, &car, &cdr);" ;
    "        cdr.payload.vp_i64 += y;" ;
    "        push_value(mkcell(car, cdr));" ;
    "    } else {" ;
    "        value_t vy = { .tag = VT_U64, .payload = { .vp_i64 = y } };" ;
    "        push_value(mkcell(vp, vy));" ;
    "    }" ;
    "}" ;

    PRIM_BOOL_TRUE .p " {" ;
    "    push_bool(true);" ;
    "}" ;

    PRIM_BOOL_FALSE .p " {" ;
    "    push_bool(false);" ;
    "}" ;;

    PRIM_BOOL_AND .p " {" ;
    "    bool x = pop_bool();" ;
    "    bool y = pop_bool();" ;
    "    push_bool(y && x);" ;
    "}" ;

    PRIM_BOOL_OR .p " {" ;
    "    bool x = pop_bool();" ;
    "    bool y = pop_bool();" ;
    "    push_bool(y || x);" ;
    "}" ;;

    PRIM_SYS_ARGC .p " {" ;
    "    push_i64(global_argc);" ;
    "}" ;

    PRIM_SYS_ARGV .p " {" ;
    "    push_ptr(global_argv);" ;
    "}" ;;

    PRIM_PTR_SIZE .p " {" ;
    "    push_u64((u64)sizeof(void*));" ;
    "}" ;;

    PRIM_PTR_ALLOC .p " {" ;
    "    i64 psize = pop_i64();" ;
    "    if (psize > 0) {" ;
    "        usize size = (usize)psize;" ;
    "        void* ptr = calloc(1,size);" ;
    "        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };" ;
    "        value_t vptr = { .tag = VT_U64, .payload = { .vp_ptr = ptr } };" ;
    "        value_t v = mkcell_freecdr(vsize, vptr);" ;
    "        push_value(v);" ;
    "    } else {" ;
    "        push_u64(0);" ;
    "    }" ;
    "}" ;;

    "static void* alloc_but_copy (usize dstn, void* src, usize srcn) {" ;
    "    void* dst = calloc(1,dstn);" ;
    "    if (src) {" ;
    "        usize cpyn = (dstn > srcn) ? srcn : dstn;" ;
    "        memcpy(dst, src, cpyn);" ;
    "    }" ;
    "    return dst;" ;
    "}" ;

    PRIM_PTR_REALLOC .p " {" ;
    "    i64 psize = pop_i64();" ;
    "    value_t vptr = pop_value();" ;
    "    if (psize <= 0) { " ;
    "        decref(vptr);" ;
    "        push_u64(0);" ;
    "        return;" ;
    "    }" ;
    "    usize new_size = (usize)psize;" ;
    "    if ((vptr.tag == VT_C64) && !value_has_ptr_offset(vptr)) {" ; # destructive realloc
    "       usize cell_index = get_cell_index(vptr);" ;
    "       cell_t *cell = heap + cell_index;" ;
    "       usize old_size = (usize)cell->car.payload.vp_u64;" ;
    "       void* old_ptr = cell->cdr.payload.vp_ptr;" ;
    "       void* new_ptr = realloc(old_ptr, new_size);" ;
    "       cell->car.payload.vp_i64 = psize;" ;
    "       cell->cdr.payload.vp_ptr = new_ptr;" ;
    "       if (old_size < new_size) {" ;
    "           memset((char*)new_ptr + old_size, 0, new_size - old_size);" ;
    "       }" ;
    "       push_value(vptr);" ;
    "    } else {" ; # nondestructive "realloc"
    "        void* old_ptr = value_ptr(vptr);" ;
    "        usize old_size = (usize)value_ptr_size(vptr);" ;
    "        void* new_ptr = alloc_but_copy(new_size, old_ptr, old_size);" ;
    "        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };" ;
    "        value_t vnew = { .tag = VT_U64, .payload = { .vp_ptr = new_ptr } };" ;
    "        value_t v = mkcell_freecdr(vsize, vnew);" ;
    "        push_value(v);" ;
    "        decref(vptr);" ;
    "    }" ;
    "}" ;;

    PRIM_PTR_NUMBYTES .p " {" ;
    "    value_t v = pop_value();" ;
    "    push_i64(value_ptr_size(v));" ;
    "    decref(v);" ;
    "}" ;;

    PRIM_PACK_NIL .p " {" ;
    "    value_t v = {0};" ;
    "    push_value(v);" ;
    "}" ;;

    "static void do_pack_cons() {" ;
    "    value_t cdr = pop_value();" ;
    "    value_t car = pop_value();" ;
    "    push_value(mkcell(car, cdr));" ;
    "}" ;;

    PRIM_PACK_CONS .p " {" ;
    "    do_pack_cons();" ;
    "}" ;;

    PRIM_PACK_UNCONS .p " {" ;
    "    do_pack_uncons();" ;
    "}" ;;
    )

def(c99-emit-externals!, +IO,
    External.for(c99-emit-external!) .lf)

def(c99-emit-external!, External -- +IO,
    external-sig? sig-arity
    dup 2 >= if(
        "can't declare external with multiple return values" panic!,

        dup 1 >= if(
            "i64 " .,
            "void " .
        )
    )

    dip2(external-name? .name)

    " (" .
    over dup nonzero if(
        "i64" .
        1- while(dup nonzero,
            ", i64" .
            1-
        ) drop,
        drop
    ) ");" ;

    "static void mw" . dip2(external-name? .name) " (void) {" ;
    over while(dup nonzero,
        "    i64 x" . dup .n " = pop_i64();" ;
        1-
    ) drop
    dup nonzero if("    push_i64(", "    ") .
    dip2(external-name? .name)
    "(" .
    dip(dup nonzero if(
        "x1" .
        dup 1-
        while(dup nonzero,
            ", x" .
            dup2 - 1+ .n
            1-
        ) drop,
        id
    ))
    ")" .
    dup nonzero if(");", " ;") ;
    "}" ;

    drop3)

def(c99-emit-arrow!, Arrow -- +IO,
    c99-depth++
    arrow-atoms@ for(c99-emit-atom!)
    c99-depth--)

c99-emit-atom! : Atom -- +IO,
c99-emit-atom! =
    atom-op? match(
        OP_NONE -> drop,
        OP_INT ->
            nip
            "    push_i64(" . .n "LL);" ;,
        OP_STR ->
            nip c99-emit-string!,
        OP_WORD ->
            dip(atom-args@ c99-emit-args-push!)
            "    mw" . word-name@ .name "();" ;,
        OP_EXTERNAL ->
            dip(atom-args@ c99-emit-args-push!) # this is probably never desirable
            "    mw" . external-name@ .name "();" ;,
        OP_BUFFER ->
            nip buffer-name@
            "    mw" . .name "();" ;,
        OP_TAG ->
            nip tag-name@
            "    mw" . .name "();" ;,
        OP_PRIM ->
            dip(atom-args@) c99-emit-prim!,
        OP_MATCH ->
            nip c99-emit-match!,
        OP_LAMBDA ->
            nip c99-emit-lambda!,
        OP_VAR ->
            nip c99-emit-var!,
        OP_BLOCK ->
            nip c99-emit-block-push!,
    )

c99-emit-string! : Str -- +IO
c99-emit-string! = (
    "    push_ptr(\"" .
    str-for(c99-emit-string-char!)
    "\");" ;
)

c99-emit-string-char! : Char -- +IO
c99-emit-string-char! =
    is-backslash? if(
        drop "\\\\" .,
    is-quote? if(
        drop "\\\"" .,
    dup U8->Int 32 127 in-range if(
        .b,
    dup U8->Int 9 == if(
        drop "\\t" .,
    dup U8->Int 10 == if(
        drop "\\n" .,
    dup U8->Int 13 == if(
        drop "\\r" .,
        "unexpected character in c99 string" panic!
    ))))))

c99-emit-prim! : List(Arg) Prim -- +IO
c99-emit-prim! =
    match(
        PRIM_CORE_DIP ->
            match(
                L1 ->
                    "    { value_t d" . .d " = pop_value();" ;
                    c99-emit-arg-run!
                    "      push_value(d" . .d "); }" ;,
                _ ->
                    PRIM_CORE_DIP c99-emit-prim-default!
            ),

        PRIM_CORE_IF ->
            match(
                L2 ->
                    "    if (pop_u64()) {" ;
                    dip(c99-emit-arg-run!)
                    "    } else {" ;
                    c99-emit-arg-run!
                    "    }" ;,
                _ ->
                    PRIM_CORE_IF c99-emit-prim-default!
            ),

        PRIM_CORE_WHILE ->
            match(
                L2 ->
                    "    while(1) {" ;
                    dip(c99-emit-arg-run!)
                    "    if (!pop_u64()) break;" ;
                    c99-emit-arg-run!
                    "    }" ;,

                _ ->
                    PRIM_CORE_WHILE c99-emit-prim-default!
            ),

        _ -> c99-emit-prim-default!
    )

c99-emit-prim-default! : List(Arg) Prim -- +IO
c99-emit-prim-default! = (
    dip(c99-emit-args-push!)
    "    mw" . prim-name@ .name "();" ;
)

c99-emit-args-push! : List(Arg) -- +IO
c99-emit-args-push! = reverse-for(c99-emit-arg-push!)

c99-emit-arg-push! : Arg -- +IO
c99-emit-arg-push! =
    match(
        ARG_BLOCK -> c99-emit-block-push!,
        ARG_VAR_RUN -> c99-emit-var-push!,
    )

c99-emit-arg-run! : Arg -- +IO
c99-emit-arg-run! =
    match(
        ARG_BLOCK -> block-arrow@ c99-emit-arrow!,
        ARG_VAR_RUN -> c99-emit-var!,
    )

def(.var-val, Var -- +IO, "var_" . var-name? .name "_" . Var->Int .n)

def(c99-pack-ctx!, Ctx -- +IO,
    "    push_u64(0);" ;
    ctx-physical-vars for(
        c99-emit-var-push!
        "    do_pack_cons();" ;
    ))

def(c99-unpack-ctx!, Ctx -- +IO,
    ctx-physical-vars reverse-for(
        "    do_pack_uncons();" ;
        "    value_t " . .var-val " = pop_value();" ;
        )
    "    do_drop();" ;
    )

def(c99-decref-ctx!, Ctx -- +IO,
    ctx-physical-vars reverse-for(
        "    decref(" . .var-val ");" ;
    ))

def(c99-emit-block-push!, Block -- +IO,
    true over block-needed!
    block-arrow? arrow-ctx@ c99-pack-ctx!
    "    push_fnptr(&" . .block ");" ;
    "    do_pack_cons();" ;
    )

def(c99-emit-var!, Var -- +IO,
    var-auto-run? dip(c99-emit-var-push!)
    if("    do_run();" ;, id))

def(c99-emit-var-push!, Var -- +IO,
    "    push_value(" . dup .var-val ");" ;
    "    incref(" . .var-val ");" ;
    )

def(c99-emit-lambda!, Lambda -- +IO,
    "    {" ;
    lambda-params? reverse-for(
        "    value_t " . .var-val " = pop_value();" ;
        )
    lambda-body? c99-emit-arrow!
    lambda-params@ reverse-for(
        "    decref(" . .var-val ");" ;
        )
    "    }" ;)

def(c99-emit-match!, Match -- +IO,
    match-is-transparent? if(
        match-cases? first match(
            NONE -> match-token@
                "codegen: unexpected number of cases in transparent match" emit-fatal-error!,
            SOME ->
                case-body@ c99-emit-arrow! drop
        ),

        "    switch (get_top_data_tag()) {" ;
        match-cases? for(c99-emit-case!)
        match-has-default-case if(
            id,
            "    default: write(2, \"unexpected fallthrough in match\\n\", 32); do_debug(); exit(99);" ;
        )
        "    }" ;
    ))

def(c99-emit-case!, Case -- +IO,
    case-pattern? c99-emit-pattern!
    case-body@ c99-emit-arrow!
    "    break;" ;)

def(c99-emit-pattern!, Pattern -- +IO,
    match(
        PATTERN_UNDERSCORE ->
            "    default:" ; ,

        PATTERN_TAG ->
            "    case " . tag-value? .n "LL:" ;
            tag-num-inputs? nip
            dup 0 > if(
                "    do_pack_uncons(); do_drop();" ;
                while(dup 1 >,
                    "    do_pack_uncons(); do_swap();" ;
                    1-)
                drop,
                drop "    do_drop();" ;
            )
    ))

def(c99-emit-word-sigs!, +IO,
    Word.for(c99-emit-word-sig!) .lf)

def(c99-emit-word-sig!, Word -- +IO,
    " static void mw" . word-name@ .name " (void);" ;)

def(c99-emit-block-sigs!, +IO,
    Block.for(c99-emit-block-sig!) .lf)

def(c99-emit-block-sig!, Block -- +IO,
    " static void " . .block " (void);" ;)

def(c99-emit-block-defs!, +IO,
    Block.for(c99-emit-block-def!) .lf)

def(c99-emit-block-def!, Block -- +IO,
    block-needed? if(
        "static void " . dup .block " (void) {" ;
        block-arrow@
        arrow-ctx? c99-unpack-ctx!
        dup c99-emit-arrow!
        arrow-ctx@ c99-decref-ctx!
        "}" ;,

        drop
    ))

def(.block, Block -- +IO,
    "mb_" .
    block-arrow? arrow-token-start@
    is-nil? if(
        drop cast .n,
        token-module? module-name@ .name "_" .
        token-row? Row->Int .n "_" .
        token-col@ Col->Int .n
        drop
    ))

def(c99-emit-word-defs!, +IO,
    Word.for(c99-emit-word-def!))

def(c99-emit-word-def!, Word -- +IO,
    word-name? .w "{" ;
    word-arrow@ c99-emit-arrow!
    "}" ;;)

def(c99-emit-main!, Arrow -- +IO,
    "int main (int argc, char** argv) {" ;
    "    global_argc = argc;" ;
    "    global_argv = argv;" ;
    c99-emit-arrow!
    "    return 0;" ;
    "}" ;
    )
