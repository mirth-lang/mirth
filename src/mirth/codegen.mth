module(mirth/codegen)
import(prelude)
import(mirth/data/token)
import(mirth/data/name)
import(mirth/data/word)
import(mirth/data/external)
import(mirth/data/buffer)
import(mirth/data/arrow)
import(mirth/data/data)

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)
buffer(CODEGEN_FILE, 8)
buffer(CODEGEN_LENGTH, 8)
buffer(CODEGEN_BUF, 0x2000)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE file@)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE file!)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH int@)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH int!)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ File->Int CODEGEN_BUF codegen-length@
        posix-write! dup 0 < if(
            "error: codegen write failed" panic!,
            codegen-length@ < if(
                "error: codegen write wrote fewer bytes than expected" panic!,
                0 codegen-length!
            )
        ),
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup u8@ U8->Int nonzero, dup u8@ .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    stdout codegen-file!
    0 codegen-length!)

def(run-output-c99!, Arrow Path -- +IO,
    num-errors@ 0 > if(
        drop2,

        load-output-path!
        STR_BUF create-file! codegen-start!
            # FIXME: implement and use create-binary-file!
            # instead of create-file! here ... perhaps
        c99-emit-header!
        c99-emit-strings!
        c99-emit-prims!
        c99-emit-tags!
        c99-emit-buffers!
        c99-emit-externals!
        c99-emit-word-sigs!
        c99-emit-word-defs!
        c99-emit-main!
        codegen-end!
    ))

buffer(C99_DEPTH, 8)
def(c99-depth@, -- Int +Codegen, C99_DEPTH int@)
def(c99-depth!, Int -- +Codegen, C99_DEPTH int!)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, str-buf-int! STR_BUF .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! STR_BUF .)

def(.w, Name -- +IO,
    "void mw" . .name " (void)" .)
def(.p, Prim -- +IO, prim-name@ .w)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WIN32 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdio.h>" ;
    "#include <stdint.h>";
    "#include <stdbool.h>";;

    "typedef uint8_t u8;";
    "typedef uint16_t u16;";
    "typedef uint32_t u32;";
    "typedef uint64_t u64;";
    "typedef int8_t i8;";
    "typedef int16_t i16;";
    "typedef int32_t i32;";
    "typedef int64_t i64;";
    "typedef uintptr_t usize;";;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;

    "typedef enum value_tag_t {" ;
    "   VT_U64 = 0x00," ; # u64
    "   VT_U32 = 0x01," ; # u32 u32
    "   VT_U21 = 0x02," ; # u21 u21 u21
    "   VT_U16 = 0x03," ; # u16 u16 u16 u16
    "   VT_C16 = 0x04," ; # c16 u16 u16 u16
    "   VT_C21 = 0x05," ; # c21 u21 u21
    "   VT_C32 = 0x06," ; # c32 u32
    "   VT_C64 = 0x07," ; # c64
    "} value_tag_t;" ;;

    "typedef union value_payload_t {" ;
    "    void* vp_ptr;" ;
    "    u8 vp_u8;" ;
    "    u16 vp_u16;" ;
    "    u32 vp_u32;" ;
    "    u64 vp_u64;" ;
    "    i8 vp_i8;" ;
    "    i16 vp_i16;" ;
    "    i32 vp_i32;" ;
    "    i64 vp_i64;" ;
    "    bool vp_bool;" ;
    "} value_payload_t;" ;;

    "typedef struct value_t {" ;
    "   value_payload_t payload;" ;
    "   value_tag_t tag; ";
    "} value_t; " ;;

    "typedef struct cell_t {" ;
    "   u32 refs;" ; # reference count
    "   value_t car;" ;
    "   value_t cdr;" ;
    "} cell_t;" ;;

    "#define STACK_SIZE 0x1000" ;
    "static volatile usize stack_counter = STACK_SIZE;" ;
    "static volatile value_t stack [STACK_SIZE] = {0};" ;;

    "#define HEAP_SIZE 0x80000" ;
    "#define HEAP_MASK 0x7FFFF" ;
    "static volatile usize heap_next = 1;" ;
    "static volatile usize heap_count = 0;" ;
    "static volatile cell_t heap [HEAP_SIZE] = {0};" ;;

    "int global_argc;" ;
    "char** global_argv;" ;;
    )

def(c99-emit-strings!, +IO,
    "#define STRINGS_SIZE " . strings-size@ .n "" ;
    "static const char strings[STRINGS_SIZE] = { " ;
    0
    while(dup strings-size@ <,
        dup STRINGS_BUF u8@@ U8->Int dup .n "," . nonzero
        if(id, .lf)
        1+
    ) drop
    "};" ;;)

def(c99-emit-buffers!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-buffer!
        1+)
    .lf drop)

def(c99-emit-buffer!, Name -- +IO,
    name-is-buffer? if(
        " volatile u8 b" . dup .name "[" . dup name-buffer@ buffer-size@ .n "] = {0};" ;
        " void mw" . dup .name " (void) { push_ptr((void*)b" . .name "); }" ;  ,
        drop
    ))

def(c99-emit-tags!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-tag!
        1+)
    drop)

def(c99-emit-tag!, Name -- +IO,
    name-is-tag? if(
        "void mw" . dup .name " (void) {" ;

        name-tag@ tag-num-inputs? 0 == if(
            "    push_u64(" . tag-value@ .n "LL);" ;,

            "    value_t car = pop_value();" ;
            tag-num-inputs? 1-
            while(dup 0 >, "    car = mkcell(car, pop_value());" ;  1-) drop
            "    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = " . tag-value@ .n "LL } };" ;
            "    car = mkcell(car, tag);" ;
            "    push_value(car);" ;
        )
        "}" ;;,
        drop
    ))

def(c99-emit-prims!, +IO,
    "static usize get_cell_index (value_t v) {" ;
    "    switch (v.tag) {" ;
    "        case VT_C64: return (usize)v.payload.vp_u64;" ;
    "        case VT_C32: return (usize)(v.payload.vp_u64 >> 32);" ;
    "        case VT_C21: return (usize)(v.payload.vp_u64 >> 42);" ;
    "        case VT_C16: return (usize)(v.payload.vp_u64 >> 48);" ;
    "        default: return 0;" ;
    "    }" ;
    "}" ;;

    "void decref (value_t v) { " ;
    "    usize cell_index;" ;
    "    while ((cell_index = get_cell_index(v))) {" ;
    "        volatile cell_t *cell = heap + cell_index;";
    "        if (cell->refs >= 1) {";
    "            cell->refs--;" ;
    "            if (cell->refs == 0) {" ;
    "                value_t car = cell->car;" ;
    "                value_t cdr = cell->cdr;" ;
    "                cell->car.tag = 0; cell->car.payload.vp_u64 = 0;" ;
    "                cell->cdr.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" ;
    "                heap_next = cell_index;" ;
    "                heap_count--;" ;
    "                decref(cdr);" ;
    "                v = car;" ;
    "            } else {" ;
    "                break;" ;
    "            }" ;
    "        } else {" ;
    "            break;" ;
    "        }" ;
    "    }" ;
    "}" ;;

    "void incref (value_t v) {" ;
    "    usize cell_index = get_cell_index(v);" ;
    "    if (cell_index) {" ;
    "        volatile cell_t *cell = heap + cell_index;" ;
    "        cell->refs++;" ;
    "    }" ;
    "}" ;;

    "value_t pop_value (void) {" ;
    "    if (stack_counter >= STACK_SIZE) {" ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    "        exit(1);" ;
    "    }" ;
    "    return stack[stack_counter++];" ;
    "}" ;;
    "void* pop_ptr (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_ptr;" ;
    "}";;
    "u8 pop_u8 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u8;" ;
    "}";;
    "u16 pop_u16 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u16;" ;
    "}";;
    "u32 pop_u32 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u32;" ;
    "}";;
    "u64 pop_u64 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u64;" ;
    "}";;
    "i8 pop_i8 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i8;" ;
    "}";;
    "i16 pop_i16 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i16;" ;
    "}";;
    "i32 pop_i32 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i32;" ;
    "}";;
    "i64 pop_i64 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i64;" ;
    "}" ;;
    "bool pop_bool (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_bool;" ;
    "}" ;;

    "void push_value (value_t v) {" ;
    "    if (stack_counter < 1) {" ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
    "        exit(1);" ;
    "    }" ;
    "    stack[--stack_counter] = v;" ;
    "}" ;;
    "void push_ptr (void* x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_ptr = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u8 (u8 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u8 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u16 (u16 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u16 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u32 (u32 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u32 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u64 (u64 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i8 (i8 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i8 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i16 (i16 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i16 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i32 (i32 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i32 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i64 (i64 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_i64 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_bool (bool x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_bool = x;" ;
    "    push_value(v);" ;
    "}" ;;
    # create a cons cell, while taking ownership of car and cdr's refs
    "value_t mkcell (value_t car, value_t cdr) {" ;
    "    if ((car.payload.vp_u64 == 0) && (cdr.tag == VT_U64))" ;
    "        return cdr;" ;
    "    if (cdr.tag == VT_U64) {" ;
    "        switch (car.tag) {" ;
    "            case VT_U64: {" ;
    "                u64 x0 = car.payload.vp_u64;" ;
    "                u64 x1 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U32;" ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C64: {" ;
    "                u64 x0 = car.payload.vp_u64;" ;
    "                u64 x1 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C32;" ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_U32: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" ;
    "                u64 x2 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U21;" ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C32: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" ;
    "                u64 x2 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C21;" ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_U21: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" ;
    "                u64 x3 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFLL;" ;
    "                u64 y2 = x2 & 0xFFFFLL;" ;
    "                u64 y3 = x3 & 0xFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U16;" ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C21: {" ;
#    "                fprintf(stderr, \"turbo mode!\\n\");" ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" ;
    "                u64 x3 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFLL;" ;
    "                u64 y2 = x2 & 0xFFFFLL;" ;
    "                u64 y3 = x3 & 0xFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C16;" ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            default: break;" ;
    "        }" ;
    "    }" ;
    "    if (heap_count >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 cell_index = heap_next;" ;
    "    volatile cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_C64;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;

    "void value_uncons(value_t val, value_t* car, value_t* cdr) {" ;
    "    switch (val.tag) {" ;
    "        case VT_U64: {" ;
    "            value_t nil = { 0 };" ;
    "            *car = nil;" ;
    "            *cdr = val;" ;
    "        } break;" ;
    "        case VT_U32: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFFFFFF;" ;
    "            u64 hi = vv >> 32;" ;
    "            car->tag = VT_U64; car->payload.vp_u64 = hi;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C64: {" ;
    "            volatile cell_t* cell = heap + val.payload.vp_u64;" ;
    "            *car = cell->car;" ;
    "            *cdr = cell->cdr;" ;
    "        } break;" ;
    "        case VT_C32: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFFFFFF;" ;
    "            u64 hi = vv >> 32;" ;
    "            car->tag = VT_C64; car->payload.vp_u64 = hi;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_U21: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0x1FFFFF;" ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" ;
    "            car->tag = VT_U32;" ;
    "            car->payload.vp_u64 = (hi << 32) | md;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C21: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0x1FFFFF;" ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" ;
    "            car->tag = VT_C32;" ;
    "            car->payload.vp_u64 = (hi << 32) | md;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_U16: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFF;" ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" ;
    "            car->tag = VT_U21;" ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C16: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFF;" ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" ;
    "            car->tag = VT_C21;" ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "    }" ;
    "}" ;;

    "void do_pack_uncons() {" ;
    "    value_t car, cdr, val;" ;
    "    val = pop_value();" ;
    "    value_uncons(val, &car, &cdr);" ;
    "    push_value(car); push_value(cdr);" ;
    "    if (val.tag == VT_C64) {" ;
    "        incref(car); incref(cdr); decref(val);" ;
    "    }" ;
    "}" ;;

    "i64 get_value_tag(value_t v) {" ;
    "    switch (v.tag) {" ;
    "        case VT_C64: {" ;
    "            volatile cell_t *c = heap + v.payload.vp_u64;" ;
    "            if (c->cdr.tag == VT_U64) return c->cdr.payload.vp_i64;" ;
    "            return 0;" ;
    "        } break;" ;
    "        case VT_U64: {" ;
    "            return v.payload.vp_i64;" ;
    "        } break;" ;
    "        case VT_U32: {" ;
    "            return v.payload.vp_u64 & 0xFFFFFFFF;" ;
    "        } break;" ;
    "        case VT_C32: {" ;
    "            return v.payload.vp_u64 & 0xFFFFFFFF;" ;
    "        } break;" ;
    "        case VT_U21: {" ;
    "            return v.payload.vp_u64 & 0x1FFFFF;" ;
    "        } break;" ;
    "        case VT_C21: {" ;
    "            return v.payload.vp_u64 & 0x1FFFFF;" ;
    "        } break;" ;
    "        case VT_U16: {" ;
    "            return v.payload.vp_u64 & 0xFFFF;" ;
    "        } break;" ;
    "        case VT_C16: {" ;
    "            return v.payload.vp_u64 & 0xFFFF;" ;
    "        } break;" ;
    "    }" ;
    "    return 0;" ;
    "}" ;;

    "u64 get_top_data_tag() {" ;
    "    return get_value_tag(stack[stack_counter]);" ;
    "}" ;;

    "int value_cmp(value_t v1, value_t v2) {" ;
    "    while(1) {" ;
    "        i64 t1 = get_value_tag(v1);" ;
    "        i64 t2 = get_value_tag(v2);" ;
    "        if (t1 < t2) return -1;" ;
    "        if (t1 > t2) return 1;" ;
    "        if ((v1.tag == VT_U64) && (v2.tag == VT_U64)) return 0;" ;
    "        value_t v1car, v1cdr, v2car, v2cdr;" ;
    "        value_uncons(v1, &v1car, &v1cdr);" ;
    "        value_uncons(v2, &v2car, &v2cdr);" ;
    "        int cdrcmp = value_cmp(v1cdr, v2cdr);" ;
    "        if (cdrcmp != 0) return cdrcmp;" ;
    "        v1 = v1car; v2 = v2car;" ;
    "    }" ;
    "}" ;;

    PRIM_ID .p " {" ;
    "}" ;;

    PRIM_DUP .p " {" ;
    "    value_t v = pop_value();" ;
    "    incref(v);" ;
    "    push_value(v); push_value(v);" ;
    "}" ;;

    "void do_drop() {" ;
    "    value_t v = pop_value();" ;
    "    decref(v);" ;
    "}" ;;

    PRIM_DROP .p " { do_drop(); }" ;;

    "void do_swap() {" ;
    "    value_t x = pop_value();" ;
    "    value_t y = pop_value();" ;
    "    push_value(x); push_value(y);" ;
    "}" ;;

    PRIM_SWAP .p " { do_swap(); }" ;;

    PRIM_INT_ADD .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(x + y);" ;
    "}" ;;

    PRIM_INT_SUB .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y - x);" ;
    "}" ;;

    PRIM_INT_MUL .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(x * y);" ;
    "}" ;;

    PRIM_INT_DIV .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(y / x);" ;
    "}" ;;

    PRIM_INT_MOD .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(y % x);" ;
    "}" ;;

    PRIM_EQ .p " {" ;
    "    value_t v2 = pop_value();" ;
    "    value_t v1 = pop_value();" ;
    "    push_bool(value_cmp(v1, v2) == 0);" ;
    "    decref(v1); decref(v2);" ;
    "}" ;;

    PRIM_LT .p " {" ;
    "    value_t v2 = pop_value();" ;
    "    value_t v1 = pop_value();" ;
    "    push_bool(value_cmp(v1, v2) < 0);" ;
    "    decref(v1); decref(v2);" ;
    "}" ;;

    PRIM_LE .p " {" ;
    "    value_t v2 = pop_value();" ;
    "    value_t v1 = pop_value();" ;
    "    push_bool(value_cmp(v1, v2) <= 0);" ;
    "    decref(v1); decref(v2);" ;
    "}" ;;

    PRIM_INT_AND .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y & x);" ;
    "}" ;;

    PRIM_INT_OR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y | x);" ;
    "}" ;;

    PRIM_INT_XOR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y ^ x);" ;
    "}" ;;

    PRIM_INT_SHL .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y << x);" ;
    "}" ;;

    PRIM_INT_SHR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y >> x);" ;
    "}" ;;

    PRIM_POSIX_WRITE .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)write(f, p, n));" ;
    "}" ;;

    PRIM_POSIX_READ .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)read(f,p,n));" ;
    "}" ;;

    PRIM_POSIX_OPEN .p " {" ;
    "    int m = (int)pop_i64();" ;
    "    int f = (int)pop_i64();" ;
    "    void* p = pop_ptr();" ;
    "    push_i64((i64)open(p,f,m));" ;
    "}" ;;

    PRIM_POSIX_CLOSE .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    push_i64((i64)close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .p " {" ;
    "    #ifdef MIRTH_WIN32" ;
    "    pop_value(); pop_value(); pop_value(); pop_value();" ;
    "    usize b = (usize)pop_u64();" ;
    "    pop_value();" ;
    "    push_ptr(malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop_i64();" ;
    "    int e = (int)pop_i64();" ;
    "    int d = (int)pop_i64();" ;
    "    int c = (int)pop_i64();" ;
    "    usize b = (usize)pop_u64();" ;
    "    void* a = pop_ptr();" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push_ptr(p);" ;
    "    #endif" ;
    "}" ;;

    "void do_debug() {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x; i64 y;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {" ;
    "        cp = c+30;" ;
    "        x = stack[i].payload.vp_i64;" ;
    "        n = 1;" ;
    "        y = x; if (x < 0) { x = -x; }" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        if (y < 0) { *cp-- = '-'; n++; } " ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_DEBUG .p " {" ;
    "   do_debug();" ;
    "}" ;;

    PRIM_MEM_GET_VALUE .p " {" ;
    "    value_t* p = pop_ptr();" ;
    "    value_t v = *p;" ;
    "    push_value(v);" ;
    "    incref(v);" ;
    "}" ;;

    PRIM_MEM_SET_VALUE .p " {" ;
    "    value_t* p = pop_ptr();" ;
    "    value_t v = pop_value();" ;
    "    value_t old_v = *p;" ;
    "    *p = v;" ;
    "    decref(old_v);" ;
    "}" ;;

    PRIM_MEM_GET_INT .p " {" ;
    "    i64* p = pop_ptr();" ;
    "    push_i64(*p);" ;
    "}" ;;

    PRIM_MEM_SET_INT .p " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = (i64)pop_i64();" ;
    "}" ;;

    PRIM_MEM_GET_PTR .p " {" ;
    "    void** p = pop_ptr();" ;
    "    push_ptr(*p);" ;
    "}" ;;

    PRIM_MEM_SET_PTR .p " {" ;
    "    void** x = pop_ptr();" ;
    "    *x = pop_ptr();" ;
    "}" ;;

    PRIM_MEM_GET_U8 .p " {" ;
    "    u8* x = pop_ptr();" ;
    "    push_u8(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U8 .p " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U16 .p " {" ;
    "    u16* x = pop_ptr();" ;
    "    push_u16(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U16 .p " {" ;
    "    u16* x = pop_ptr();" ;
    "    *x = pop_u16();" ;
    "}" ;;

    PRIM_MEM_GET_U32 .p " {" ;
    "    u32* x = pop_ptr();" ;
    "    push_u32(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U32 .p " {" ;
    "    u32* x = pop_ptr();" ;
    "    *x = pop_u32();" ;
    "}" ;;

    PRIM_MEM_GET_U64 .p " {" ;
    "    u64* x = pop_ptr();" ;
    "    push_u64(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U64 .p " {" ;
    "    u64* x = pop_ptr();" ;
    "    *x = pop_u64();" ;
    "}" ;;

    PRIM_MEM_GET_I8 .p " {" ;
    "    i8* x = pop_ptr();" ;
    "    push_i8(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I8 .p " {" ;
    "    i8* x = pop_ptr();" ;
    "    *x = pop_i8();" ;
    "}" ;;

    PRIM_MEM_GET_I16 .p " {" ;
    "    i16* x = pop_ptr();" ;
    "    push_i16(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I16 .p " {" ;
    "    i16* x = pop_ptr();" ;
    "    *x = pop_i16();" ;
    "}" ;;

    PRIM_MEM_GET_I32 .p " {" ;
    "    i32* x = pop_ptr();" ;
    "    push_i32(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I32 .p " {" ;
    "    i32* x = pop_ptr();" ;
    "    *x = pop_i32();" ;
    "}" ;;

    PRIM_MEM_GET_I64 .p " {" ;
    "    i64* x = pop_ptr();" ;
    "    push_i64(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I64 .p " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = pop_i64();" ;
    "}" ;;

    PRIM_SYS_OS .p " {" ;
    "#if defined(MIRTH_WIN32)" ;
    "    push_u64(" . WIN32 .n ");" ;
    "#elif defined(MIRTH_LINUX)" ;
    "    push_u64(" . LINUX .n ");" ;
    "#elif defined(MIRTH_MACOS)" ;
    "    push_u64(" . MACOS .n ");" ;
    "#else" ;
    "    push_u64(" . UNKNOWN .n ");" ;
    "#endif" ;
    "}" ;;

    PRIM_CAST .p " { }" ;;

    PRIM_PTR_ADD .p " {" ;
    "   u8* x = pop_ptr();" ;
    "   i64 y = pop_i64();" ;
    "   push_ptr(x + y);" ;
    "}" ;;

    PRIM_BOOL_TRUE .p " {" ;
    "    push_bool(true);";
    "}" ;

    PRIM_BOOL_FALSE .p " {" ;
    "    push_bool(false);";
    "}" ;;

    PRIM_BOOL_AND .p " {" ;
    "    bool x = pop_bool();" ;
    "    bool y = pop_bool();" ;
    "    push_bool(y && x);" ;
    "}" ;

    PRIM_BOOL_OR .p " {" ;
    "    bool x = pop_bool();" ;
    "    bool y = pop_bool();" ;
    "    push_bool(y || x);" ;
    "}" ;;

    PRIM_SYS_ARGC .p " {" ;
    "    push_i64(global_argc);";
    "}" ;

    PRIM_SYS_ARGV .p " {" ;
    "    push_ptr(global_argv);";
    "}" ;;

    PRIM_PTR_SIZE .p " {" ;
    "    push_u64((u64)sizeof(void*));";
    "}" ;;

    PRIM_PACK_NIL .p " {" ;
    "    value_t v = {0};" ;
    "    push_value(v);" ;
    "}" ;;

    "void do_pack_cons() {" ;
    "    value_t cdr = pop_value();" ;
    "    value_t car = pop_value();" ;
    "    push_value(mkcell(car, cdr));" ;
    "}" ;;

    PRIM_PACK_CONS .p " {" ;
    "    do_pack_cons();" ;
    "}" ;;

    PRIM_PACK_UNCONS .p " {" ;
    "    do_pack_uncons();" ;
    "}" ;;
    )

def(c99-emit-externals!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-external!
        1+)
    .lf drop)

def(name-sig@, Name -- Token,
    name-is-word? if(
        name-word@ word-sig@,

    name-is-external? if(
        name-external@ external-sig@,

        "compiler error: attempted to get name-sig for non-word, non-external name" panic!
    )))

def(name-sig?, Name -- Name Token, dup name-sig@)

def(c99-emit-external!, Name -- +IO,
    name-is-external? if(
        name-sig? sig-arity
        dup 2 >= if(
            "can't declare external with multiple return values" panic!,

            dup 1 >= if(
                "i64 " .,
                "void " .
            )
        )
        dip(dip(dup .name))
        " (" .
        over dup nonzero if(
            "i64" .
            1- while(dup nonzero,
                ", i64" .
                1-
            ) drop,
            drop
        ) ");" ;

        " void mw" . dip(dip(dup .name)) " (void) {" ;
        over while(dup nonzero,
            "    i64 x" . dup .n " = pop_i64();" ;
            1-
        ) drop
        dup nonzero if("    push_i64(", "    ") .
        dip(dip(dup .name))
        "(" .
        dip(dup nonzero if(
            "x1" .
            dup 1-
            while(dup nonzero,
                ", x" .
                dup2 - 1+ .n
                1-
            ) drop,
            id
        ))
        ")" .
        dup nonzero if(");", ";") ;
        "}" ;

        drop3,

        drop
    ))

def(c99-emit-word-sigs!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-word-sig!
        1+
    )
    "" ;
    drop)

def(c99-emit-arrow!, Arrow -- +IO,
    c99-depth++
    while(is-nil? not,
        dup c99-emit-arrow-op!
        arrow-next@)
    drop
    c99-depth--)

c99-emit-arrow-op! : Arrow -- +IO,
c99-emit-arrow-op! =
    arrow-op? match(
        OP_NONE -> drop,
        OP_INT ->
            nip
            "    push_i64(" . .n "LL);" ;,
        OP_STR ->
            nip StrLit->Int
            "    push_ptr((void*)(strings + " . .n "));" ;,
            # FIXME: just push a string literal.
        OP_WORD ->
            nip word-name@
            "    mw" . .name "();" ;,
        OP_EXTERNAL ->
            nip external-name@
            "    mw" . .name "();" ;,
        OP_BUFFER ->
            nip buffer-name@
            "    mw" . .name "();" ;,
        OP_TAG ->
            nip tag-name@
            "    mw" . .name "();" ;,
        OP_PRIM ->
            dup PRIM_DIP == if(
                drop arrow-args@ unL1
                "    { value_t d" . .d " = pop_value();" ;
                Arg->Arrow c99-emit-arrow!
                "      push_value(d" . .d "); }" ;,

            dup PRIM_IF == if(
                drop arrow-args@ unL2
                "    if (pop_u64()) {" ;
                dip(Arg->Arrow c99-emit-arrow!)
                "    } else {" ;
                Arg->Arrow c99-emit-arrow!
                "    }" ;,

            dup PRIM_WHILE == if(
                drop arrow-args@ unL2
                "    while(1) {" ;
                dip(Arg->Arrow c99-emit-arrow!)
                "    if (!pop_u64()) break;" ;
                Arg->Arrow c99-emit-arrow!
                "    }" ;,

                nip
                "    mw" . prim-name@ .name "();" ;
            ))),
        OP_MATCH ->
            nip c99-emit-match!,
    )

def(c99-emit-match!, Match -- +IO,
    "    switch (get_top_data_tag()) {" ;
    match-cases? while(is-cons?,
        uncons dip(c99-emit-case!)
    ) drop
    match-has-default-case if(
        id,
        "    default: fprintf(stderr, \"unexpected fallthrough in match\\n\"); do_debug(); exit(99);" ;
    )
    "    }" ;)

def(c99-emit-case!, Case -- +IO,
    case-pattern? c99-emit-pattern!
    case-body@ c99-emit-arrow!
    "    break;" ;)

def(c99-emit-pattern!, Pattern -- +IO,
    match(
        PATTERN_UNDERSCORE ->
            "    default:" ; ,

        PATTERN_TAG ->
            "    case " . tag-value? .n "LL:" ;
            tag-num-inputs? nip
            dup 0 > if(
                "    do_pack_uncons(); do_drop();" ;
                while(dup 1 >,
                    "    do_pack_uncons(); do_swap();" ;
                    1-)
                drop,
                drop "    do_drop();" ;
            )
    ))

def(c99-emit-word-sig!, Name -- +IO,
    name-is-word? if(
        " void mw" . .name " (void);" ;,
        drop
    ))

def(c99-emit-word-defs!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-word-def!
        1+)
    drop)

def(c99-emit-word-def!, Name -- +IO,
    name-is-word? if(
        dup .w "{" ;
        name-word@ word-arrow@ c99-emit-arrow!
        "}" ;;,
        drop
    ))

def(c99-emit-main!, Arrow -- +IO,
    "int main (int argc, char** argv) {" ;
    "    global_argc = argc;";
    "    global_argv = argv;";
    c99-emit-arrow!
#    "    fprintf(stderr, \"heap count = 0x%lX\\n\", heap_count);" ;
    "    return 0;" ;
    "}" ;
    )
