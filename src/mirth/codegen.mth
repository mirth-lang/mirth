module(mirth/codegen)
import(prelude)
import(mirth/data/token)
import(mirth/data/name)
import(mirth/data/word)
import(mirth/data/external)
import(mirth/data/buffer)
import(mirth/data/arrow)
import(mirth/data/data)
import(mirth/elab/syntax)

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)
buffer(CODEGEN_FILE, 8)
buffer(CODEGEN_LENGTH, 8)
buffer(CODEGEN_BUF, 0x2000)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE file@)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE file!)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH int@)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH int!)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ File->Int CODEGEN_BUF codegen-length@ posix-write!
        0 codegen-length!,
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup u8@ U8->Int nonzero, dup u8@ .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    stdout codegen-file!
    0 codegen-length!)

def(run-output-c99!, Arrow Path -- +IO,
    num-errors@ 0 > if(
        drop2,

        load-output-path!
        STR_BUF create-file! codegen-start!
            # FIXME: implement and use create-binary-file!
            # instead of create-file! here ... perhaps
        c99-emit-header!
        c99-emit-strings!
        c99-emit-prims!
        c99-emit-tags!
        c99-emit-buffers!
        c99-emit-externals!
        c99-emit-word-sigs!
        c99-emit-word-defs!
        c99-emit-main!
        codegen-end!
    ))

buffer(C99_DEPTH, 8)
def(c99-depth@, -- Int +Codegen, C99_DEPTH int@)
def(c99-depth!, Int -- +Codegen, C99_DEPTH int!)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, str-buf-int! STR_BUF .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! STR_BUF .)

def(.w, Name -- +IO,
    "void mw" . .name " (void)" .)
def(.p, Prim -- +IO, prim-name@ .w)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WIN32 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>";
    "#include <stdbool.h>";;

    "typedef uint8_t u8;";
    "typedef uint16_t u16;";
    "typedef uint32_t u32;";
    "typedef uint64_t u64;";
    "typedef int8_t i8;";
    "typedef int16_t i16;";
    "typedef int32_t i32;";
    "typedef int64_t i64;";
    "typedef uintptr_t usize;";;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;

    "typedef enum value_tag_t {" ;
    "   VT_NONE = 0," ;
    "   VT_PTR  = 1," ;
    "   VT_BOOL = 2," ;
    "   VT_CELL = 3," ;
    "   VT_I64  = 0x10," ;
    "   VT_I32  = 0x11," ;
    "   VT_I16  = 0x12," ;
    "   VT_I8   = 0x13," ;
    "   VT_U64  = 0x14," ;
    "   VT_U32  = 0x15," ;
    "   VT_U16  = 0x16," ;
    "   VT_U8   = 0x17," ;
    "} value_tag_t;" ;;

    "typedef union value_payload_t {" ;
    "    void* vp_ptr;" ;
    "    u8 vp_u8;" ;
    "    u16 vp_u16;" ;
    "    u32 vp_u32;" ;
    "    u64 vp_u64;" ;
    "    i8 vp_i8;" ;
    "    i16 vp_i16;" ;
    "    i32 vp_i32;" ;
    "    i64 vp_i64;" ;
    "    bool vp_bool;" ;
    "} value_payload_t;" ;;

    "typedef struct value_t {" ;
    "   value_payload_t payload;" ;
    "   value_tag_t tag; ";
    "} value_t; " ;;

    "typedef struct cell_t {" ;
    "   u32 refs;" ; # reference count
    "   value_t car;" ;
    "   value_t cdr;" ;
    "} cell_t;" ;;

    "#define STACK_SIZE 0x1000" ;
    "static volatile usize stack_counter = STACK_SIZE;" ;
    "static volatile value_t stack [STACK_SIZE] = {0};" ;;

    "#define HEAP_SIZE 0x80000" ;
    "#define HEAP_MASK 0x7FFFF" ;
    "static volatile usize heap_next = 1;" ;
    "static volatile usize heap_count = 0;" ;
    "static volatile cell_t heap [HEAP_SIZE] = {0};" ;;

    "int global_argc;" ;
    "char** global_argv;" ;;
    )

def(c99-emit-strings!, +IO,
    "#define STRINGS_SIZE " . strings-size@ .n "" ;
    "static const char strings[STRINGS_SIZE] = { " ;
    0
    while(dup strings-size@ <,
        dup STRINGS_BUF u8@@ U8->Int dup .n "," . nonzero
        if(id, .lf)
        1+
    ) drop
    "};" ;;)

def(c99-emit-buffers!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-buffer!
        1+)
    .lf drop)

def(c99-emit-buffer!, Name -- +IO,
    name-is-buffer? if(
        " volatile u8 b" . dup .name "[" . dup name-buffer@ buffer-size@ .n "] = {0};" ;
        " void mw" . dup .name " (void) { push_ptr((void*)b" . .name "); }" ;  ,
        drop
    ))

def(c99-emit-tags!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-tag!
        1+)
    drop)

def(c99-emit-tag!, Name -- +IO,
    name-is-tag? if(
        "void mw" . dup .name " (void) {" ;
        "    value_t car = {0};" ;
        name-tag@
        tag-num-inputs? while(dup 0 >, "    car = mkcell(car, pop_value());" ;  1-) drop
        "    value_t tag = { .tag = VT_I64, .payload = { .vp_i64 = " . cast .n "LL } };" ;
        "    car = mkcell(car, tag);" ;
        "    push_value(car);" ;
        "}" ;;,
        drop
    ))

def(c99-emit-prims!, +IO,
    "void decref (value_t v) { " ;
    "    while (v.tag == VT_CELL) {" ;
    "        usize cell_index = (usize)v.payload.vp_u64;";
    "        volatile cell_t *cell = heap + cell_index;";
    "        if (cell->refs >= 1) {";
    "            cell->refs--;" ;
    "            if (cell->refs == 0) {" ;
    "                value_t car = cell->car;" ;
    "                value_t cdr = cell->cdr;" ;
    "                cell->car.tag = 0; cell->car.payload.vp_u64 = 0;" ;
    "                cell->cdr.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" ;
    "                heap_next = cell_index;" ;
    "                heap_count--;" ;
    "                decref(cdr);" ;
    "                v = car;" ;
    "            } else {" ;
    "                break;" ;
    "            }" ;
    "        } else {" ;
    "            break;" ;
    "        }" ;
    "    }" ;
    "}" ;;

    "void incref (value_t v) {" ;
    "    if (v.tag == VT_CELL) {" ;
    "        volatile cell_t *cell = heap + (usize)v.payload.vp_u64;" ;
    "        cell->refs++;" ;
    "    }" ;
    "}" ;;

    # create a cons cell, while taking ownership of car and cdr's refs
    "value_t mkcell (value_t car, value_t cdr) {" ;
    "    if ((car.tag == VT_NONE) && (car.payload.vp_u64 == 0) && (cdr.tag != VT_CELL))" ;
    "        return cdr;" ;
    "    if (heap_count >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 cell_index = heap_next;" ;
    "    volatile cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_CELL;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;

    "value_t pop_value (void) {" ;
    "    if (stack_counter >= STACK_SIZE) {" ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    "        exit(1);" ;
    "    }" ;
    "    return stack[stack_counter++];" ;
    "}" ;;
    "void* pop_ptr (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_ptr;" ;
    "}";;
    "u8 pop_u8 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u8;" ;
    "}";;
    "u16 pop_u16 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u16;" ;
    "}";;
    "u32 pop_u32 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u32;" ;
    "}";;
    "u64 pop_u64 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_u64;" ;
    "}";;
    "i8 pop_i8 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i8;" ;
    "}";;
    "i16 pop_i16 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i16;" ;
    "}";;
    "i32 pop_i32 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i32;" ;
    "}";;
    "i64 pop_i64 (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_i64;" ;
    "}" ;;
    "bool pop_bool (void) {" ;
    "    value_t v = pop_value();" ;
    "    return v.payload.vp_bool;" ;
    "}" ;;

    "void push_value (value_t v) {" ;
    "    if (stack_counter < 1) {" ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
    "        exit(1);" ;
    "    }" ;
    "    stack[--stack_counter] = v;" ;
    "}" ;;
    "void push_ptr (void* x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_PTR;" ;
    "    v.payload.vp_ptr = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u8 (u8 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U8;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u8 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u16 (u16 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U16;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u16 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u32 (u32 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U32;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_u32 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_u64 (u64 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_U64;" ;
    "    v.payload.vp_u64 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i8 (i8 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_I8;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i8 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i16 (i16 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_I16;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i16 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i32 (i32 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_I32;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_i32 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_i64 (i64 x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_I64;" ;
    "    v.payload.vp_i64 = x;" ;
    "    push_value(v);" ;
    "}" ;;
    "void push_bool (bool x) {" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_BOOL;" ;
    "    v.payload.vp_u64 = 0;" ;
    "    v.payload.vp_bool = x;" ;
    "    push_value(v);" ;
    "}" ;;

    "u64 get_top_data_tag() {" ;
    "    value_t v = pop_value();" ;
    "    u64 result = 0;" ;
    "    if (v.tag == VT_CELL) {" ;
    "        cell_t c = heap[v.payload.vp_u64];" ;
    "        result = c.cdr.payload.vp_u64;" ;
    "    } else {" ;
    "        result = v.payload.vp_u64;" ;
    "    }" ;
    "    push_value(v);" ;
    "    return result;" ;
    "}" ;;

    PRIM_ID .p " {" ;
    "}" ;;

    PRIM_DUP .p " {" ;
    "    value_t v = pop_value();" ;
    "    incref(v);" ;
    "    push_value(v); push_value(v);" ;
    "}" ;;

    "void do_drop() {" ;
    "    value_t v = pop_value();" ;
    "    decref(v);" ;
    "}" ;;

    PRIM_DROP .p " { do_drop(); }" ;;

    "void do_swap() {" ;
    "    value_t x = pop_value();" ;
    "    value_t y = pop_value();" ;
    "    push_value(x); push_value(y);" ;
    "}" ;;

    PRIM_SWAP .p " { do_swap(); }" ;;

    PRIM_INT_ADD .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(x + y);" ;
    "}" ;;

    PRIM_INT_SUB .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y - x);" ;
    "}" ;;

    PRIM_INT_MUL .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(x * y);" ;
    "}" ;;

    PRIM_INT_DIV .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(y / x);" ;
    "}" ;;

    PRIM_INT_MOD .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_i64(y % x);" ;
    "}" ;;

    PRIM_EQUALS .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_bool(x == y);" ;
    "}" ;;

    PRIM_INT_LT .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_bool(y < x);" ;
    "}" ;;

    PRIM_INT_LE .p " {" ;
    "    i64 x = pop_i64();" ;
    "    i64 y = pop_i64();" ;
    "    push_bool(y <= x);" ;
    "}" ;;

    PRIM_INT_AND .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y & x);" ;
    "}" ;;

    PRIM_INT_OR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y | x);" ;
    "}" ;;

    PRIM_INT_XOR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y ^ x);" ;
    "}" ;;

    PRIM_INT_SHL .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y << x);" ;
    "}" ;;

    PRIM_INT_SHR .p " {" ;
    "    u64 x = pop_u64();" ;
    "    u64 y = pop_u64();" ;
    "    push_u64(y >> x);" ;
    "}" ;;

    PRIM_POSIX_WRITE .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop_i64();" ;
    "    write(f, p, n);" ; # TODO: push return code
    "}" ;;

    PRIM_POSIX_READ .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)read(f,p,n));" ;
    "}" ;;

    PRIM_POSIX_OPEN .p " {" ;
    "    int m = (int)pop_i64();" ;
    "    int f = (int)pop_i64();" ;
    "    void* p = pop_ptr();" ;
    "    push_i64((i64)open(p,f,m));" ;
    "}" ;;

    PRIM_POSIX_CLOSE .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    push_i64((i64)close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .p " {" ;
    "    #ifdef MIRTH_WIN32" ;
    "    pop_value(); pop_value(); pop_value(); pop_value();" ;
    "    usize b = (usize)pop_u64();" ;
    "    pop_value();" ;
    "    push_ptr(malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop_i64();" ;
    "    int e = (int)pop_i64();" ;
    "    int d = (int)pop_i64();" ;
    "    int c = (int)pop_i64();" ;
    "    usize b = (usize)pop_u64();" ;
    "    void* a = pop_ptr();" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push_ptr(p);" ;
    "    #endif" ;
    "}" ;;

    PRIM_DEBUG .p " {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x; i64 y;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {" ;
    "        cp = c+30;" ;
    "        x = stack[i].payload.vp_i64;" ;
    "        n = 1;" ;
    "        y = x; if (x < 0) { x = -x; }" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        if (y < 0) { *cp-- = '-'; n++; } " ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_MEM_GET_VALUE .p " {" ;
    "    value_t* p = pop_ptr();" ;
    "    value_t v = *p;" ;
    "    push_value(v);" ;
    "}" ;;

    PRIM_MEM_SET_VALUE .p " {" ;
    "    value_t* p = pop_ptr();" ;
    "    value_t v = pop_value();" ;
    "    value_t old_v = *p;" ;
    "    *p = v;" ;
    "    decref(old_v);" ;
    "}" ;;

    PRIM_MEM_GET_INT .p " {" ;
    "    i64* p = pop_ptr();" ;
    "    push_i64(*p);" ;
    "}" ;;

    PRIM_MEM_SET_INT .p " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = (i64)pop_i64();" ;
    "}" ;;

    PRIM_MEM_GET_PTR .p " {" ;
    "    void** p = pop_ptr();" ;
    "    push_ptr(*p);" ;
    "}" ;;

    PRIM_MEM_SET_PTR .p " {" ;
    "    void** x = pop_ptr();" ;
    "    *x = pop_ptr();" ;
    "}" ;;

    PRIM_MEM_GET_U8 .p " {" ;
    "    u8* x = pop_ptr();" ;
    "    push_u8(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U8 .p " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U16 .p " {" ;
    "    u16* x = pop_ptr();" ;
    "    push_u16(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U16 .p " {" ;
    "    u16* x = pop_ptr();" ;
    "    *x = pop_u16();" ;
    "}" ;;

    PRIM_MEM_GET_U32 .p " {" ;
    "    u32* x = pop_ptr();" ;
    "    push_u32(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U32 .p " {" ;
    "    u32* x = pop_ptr();" ;
    "    *x = pop_u32();" ;
    "}" ;;

    PRIM_MEM_GET_U64 .p " {" ;
    "    u64* x = pop_ptr();" ;
    "    push_u64(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U64 .p " {" ;
    "    u64* x = pop_ptr();" ;
    "    *x = pop_u64();" ;
    "}" ;;

    PRIM_MEM_GET_I8 .p " {" ;
    "    i8* x = pop_ptr();" ;
    "    push_i8(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I8 .p " {" ;
    "    i8* x = pop_ptr();" ;
    "    *x = pop_i8();" ;
    "}" ;;

    PRIM_MEM_GET_I16 .p " {" ;
    "    i16* x = pop_ptr();" ;
    "    push_i16(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I16 .p " {" ;
    "    i16* x = pop_ptr();" ;
    "    *x = pop_i16();" ;
    "}" ;;

    PRIM_MEM_GET_I32 .p " {" ;
    "    i32* x = pop_ptr();" ;
    "    push_i32(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I32 .p " {" ;
    "    i32* x = pop_ptr();" ;
    "    *x = pop_i32();" ;
    "}" ;;

    PRIM_MEM_GET_I64 .p " {" ;
    "    i64* x = pop_ptr();" ;
    "    push_i64(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I64 .p " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = pop_i64();" ;
    "}" ;;

    PRIM_SYS_OS .p " {" ;
    "#if defined(MIRTH_WIN32)" ;
    "    push_u64(" . WIN32 .n ");" ;
    "#elif defined(MIRTH_LINUX)" ;
    "    push_u64(" . LINUX .n ");" ;
    "#elif defined(MIRTH_MACOS)" ;
    "    push_u64(" . MACOS .n ");" ;
    "#else" ;
    "    push_u64(" . UNKNOWN .n ");" ;
    "#endif" ;
    "}" ;;

    PRIM_CAST .p " { }" ;;

    PRIM_PTR_ADD .p " {" ;
    "   u8* x = pop_ptr();" ;
    "   i64 y = pop_i64();" ;
    "   push_ptr(x + y);" ;
    "}" ;;

    PRIM_BOOL_TRUE .p " {" ;
    "    push_bool(true);";
    "}" ;

    PRIM_BOOL_FALSE .p " {" ;
    "    push_bool(false);";
    "}" ;;

    PRIM_BOOL_AND .p " {" ;
    "    bool x = pop_bool();" ;
    "    bool y = pop_bool();" ;
    "    push_bool(y && x);" ;
    "}" ;

    PRIM_BOOL_OR .p " {" ;
    "    bool x = pop_bool();" ;
    "    bool y = pop_bool();" ;
    "    push_bool(y || x);" ;
    "}" ;;

    PRIM_SYS_ARGC .p " {" ;
    "    push_i64(global_argc);";
    "}" ;

    PRIM_SYS_ARGV .p " {" ;
    "    push_ptr(global_argv);";
    "}" ;;

    PRIM_PTR_SIZE .p " {" ;
    "    push_u64((u64)sizeof(void*));";
    "}" ;;

    PRIM_PACK_NIL .p " {" ;
    "    value_t v = {0};" ;
    "    push_value(v);" ;
    "}" ;;

    "void do_pack_cons() {" ;
    "    value_t cdr = pop_value();" ;
    "    value_t car = pop_value();" ;
    "    push_value(mkcell(car, cdr));" ;
    "}" ;;

    PRIM_PACK_CONS .p " {" ;
    "    do_pack_cons();" ;
    "}" ;;

    "void do_pack_uncons() {" ;
    "    value_t val = pop_value();" ;
    "    if (val.tag != VT_CELL) {" ;
    "        value_t nil = { 0 };" ;
    "        push_value(nil);" ;
    "        push_value(val);" ;
    "        return;" ;
    "    }" ;
    "    volatile cell_t* cell = heap + val.payload.vp_u64;" ;
    "    value_t car = cell->car;" ;
    "    value_t cdr = cell->cdr;" ;
    "    incref(car); incref(cdr); decref(val);" ;
    "    push_value(car); push_value(cdr);" ;
    "}" ;;

    PRIM_PACK_UNCONS .p " {" ;
    "    do_pack_uncons();" ;
    "}" ;;
    )

def(c99-emit-externals!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-external!
        1+)
    .lf drop)

def(name-sig@, Name -- Token,
    name-is-word? if(
        name-word@ word-sig@,

    name-is-external? if(
        name-external@ external-sig@,

        "compiler error: attempted to get name-sig for non-word, non-external name" panic!
    )))

def(name-sig?, Name -- Name Token, dup name-sig@)

def(c99-emit-external!, Name -- +IO,
    name-is-external? if(
        name-sig? sig-arity
        dup 2 >= if(
            "can't declare external with multiple return values" panic!,

            dup 1 >= if(
                "i64 " .,
                "void " .
            )
        )
        dip(dip(dup .name))
        " (" .
        over dup nonzero if(
            "i64" .
            1- while(dup nonzero,
                ", i64" .
                1-
            ) drop,
            drop
        ) ");" ;

        " void mw" . dip(dip(dup .name)) " (void) {" ;
        over while(dup nonzero,
            "    i64 x" . dup .n " = pop_i64();" ;
            1-
        ) drop
        dup nonzero if("    push_i64(", "    ") .
        dip(dip(dup .name))
        "(" .
        dip(dup nonzero if(
            "x1" .
            dup 1-
            while(dup nonzero,
                ", x" .
                dup2 - 1+ .n
                1-
            ) drop,
            id
        ))
        ")" .
        dup nonzero if(");", ";") ;
        "}" ;

        drop3,

        drop
    ))

def(c99-emit-word-sigs!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-word-sig!
        1+
    )
    "" ;
    drop)

def(c99-emit-arrow!, Arrow -- +IO,
    c99-depth++
    while(arrow-is-nil? not,
        dup c99-emit-arrow-op!
        arrow-next@)
    drop
    c99-depth--)

def(c99-emit-arrow-op!, Arrow -- +IO,

    OP_NONE arrow-op=? if(
        drop,

    OP_INT arrow-op=? if(
        arrow-op-int@
        "    push_i64(" . .n "LL);" ;,

    OP_STR arrow-op=? if(
        arrow-op-str@ StrLit->Int
        "    push_ptr((void*)(strings + " . .n "));" ;, # FIXME: just push a string literal.

    OP_WORD arrow-op=? if(
        arrow-op-word@ word-name@
        "    mw" . .name "();" ;,

    OP_EXTERNAL arrow-op=? if(
        arrow-op-external@ external-name@
        "    mw" . .name "();" ;,

    OP_BUFFER arrow-op=? if(
        arrow-op-buffer@ buffer-name@
        "    mw" . .name "();" ;,

    OP_TAG arrow-op=? if(
        arrow-op-tag@ tag-name@
        "    mw" . .name "();" ;,

    OP_PRIM arrow-op=? if(
        arrow-op-prim?
        dup PRIM_DIP == if(
            drop arrow-args-1
            "    { value_t d" . .d " = pop_value();" ;
            Arg->Arrow c99-emit-arrow!
            "      push_value(d" . .d "); }" ;,

        dup PRIM_IF == if(
            drop arrow-args-2
            "    if (pop_u64()) {" ;
            dip(Arg->Arrow c99-emit-arrow!)
            "    } else {" ;
            Arg->Arrow c99-emit-arrow!
            "    }" ;,

        dup PRIM_WHILE == if(
            drop arrow-args-2
            "    while(1) {" ;
            dip(Arg->Arrow c99-emit-arrow!)
            "    if (!pop_u64()) break;" ;
            Arg->Arrow c99-emit-arrow!
            "    }" ;,

            nip
            "    mw" . prim-name@ .name "();" ;
        ))),

    OP_MATCH arrow-op=? if(
        arrow-op-match@ c99-emit-match!,

        arrow-token@ "compiler error: Unknown arrow op in c99-emit-arrow-op!" emit-fatal-error!
    ))))))))))

def(c99-emit-match!, Match -- +IO,
    "    switch (get_top_data_tag()) {" ;
    match-cases@ while(case-is-nil? not,
        dup c99-emit-case! case-next@
    ) drop
    "    }" ;)

def(c99-emit-case!, Case -- +IO,
    case-pattern? c99-emit-pattern!
    case-body@ c99-emit-arrow!
    "    break;" ;)

def(c99-emit-pattern!, Pattern -- +IO,
    pattern-is-underscore? if(
        drop
        "    default:" ; ,

        Pattern->Tag
        "    case " . dup Tag->Int .n "LL:" ;
        tag-num-inputs? nip
        dup 0 > if(
            "    do_pack_uncons(); do_drop();" ;
            while(dup 1 >,
                "    do_pack_uncons(); do_swap();" ;
                1-)
            drop,
            drop "    do_drop();" ;
        )
    ))

def(c99-emit-word-sig!, Name -- +IO,
    name-is-word? if(
        " void mw" . .name " (void);" ;,
        drop
    ))

def(c99-emit-word-defs!, +IO,
    0
    while(dup num-names@ <=,
        dup Int->Name c99-emit-word-def!
        1+)
    drop)

def(c99-emit-word-def!, Name -- +IO,
    name-is-word? if(
        dup .w "{" ;
        name-word@ word-arrow@ c99-emit-arrow!
        "}" ;;,
        drop
    ))

def(c99-emit-main!, Arrow -- +IO,

    "int main (int argc, char** argv) {" ;
    "    global_argc = argc;";
    "    global_argv = argv;";
    c99-emit-arrow!
    "    return 0;" ;
    "}" ;
    )
