module(mirth.codegen)
import(prelude)
import(data.stack)
import(mirth.data.token)
import(mirth.data.name)
import(mirth.data.buffer)
import(mirth.data.arrow)
import(mirth.data.word)
import(mirth.data.table)

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x100)
var(codegen-file, File)
var(codegen-length, Size)
buffer(CODEGEN_BUF, 0x100)

def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length @ 4 + CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length @ 0 > if(
        codegen-file @ File->Int CODEGEN_BUF codegen-length @
        posix-write! dup 0 < if(
            "error: codegen write failed" panic!,
            codegen-length @ < if(
                "error: codegen write wrote fewer bytes than expected" panic!,
                0 codegen-length !
            )
        ),
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length @ dup 1+ codegen-length ! codegen-u8!)

def(.c, Char -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    dup codegen-length @ CODEGEN_BUF ptr+ char!
    char-width codegen-length @ + codegen-length !)

def(., Str -- +Codegen,
    dup Str->Ptr swap str-size
    dup codegen-length @ + CODEGEN_BUF_SIZE > if(
        codegen-flush!
        while(dup CODEGEN_BUF_SIZE >,
            over CODEGEN_BUF_SIZE CODEGEN_BUF prim.ptr.copy
            CODEGEN_BUF_SIZE codegen-length !
            codegen-flush!
            dip(CODEGEN_BUF_SIZE swap ptr+)
            CODEGEN_BUF_SIZE -
        )
        dup codegen-length ! CODEGEN_BUF prim.ptr.copy,

        dup dip(codegen-length @ CODEGEN_BUF ptr+ prim.ptr.copy)
        codegen-length @ + codegen-length !
    ))

def(codegen-start!, File -- +Codegen,
    codegen-file ! 0 codegen-length !)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file @ close-file!
    stdout codegen-file !
    0 codegen-length !)

def(run-output-c99!, Arrow Path -- +IO,
    num-errors @ 0 > if(
        drop2,

        make-output-path Path->Str
        create-file! codegen-start!
            # FIXME: implement and use create-binary-file!
            # instead of create-file! here ... perhaps
        c99-emit-header!
        c99-emit-prims!
        c99-emit-tags!
        c99-emit-buffers!
        c99-emit-variables!
        c99-emit-externals!
        c99-emit-word-sigs!
        c99-emit-block-sigs!
        c99-emit-field-sigs!
        c99-emit-main!
        c99-emit-needs!
        codegen-end!
    ))

var(c99-depth, Int)
def(c99-depth++, +Codegen, c99-depth @ 1+ c99-depth !)
def(c99-depth--, +Codegen, c99-depth @ 1- c99-depth !)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, int-show .)
def(.d, +Codegen, c99-depth @ .n)
def(.name, Name -- +Codegen, name-mangle! .)

def(.w, Name -- +IO, "static void mw" . .name " (void)" .)
def(.p, Prim -- +IO, prim-name@ .w)
def(.pm, Prim -- +IO, "#define mw" . prim-name@ .name "() " .)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WINDOWS 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>" ;
    "#include <stdbool.h>" ;;

    "typedef uint8_t u8;" ;
    "typedef uint16_t u16;" ;
    "typedef uint32_t u32;" ;
    "typedef uint64_t u64;" ;
    "typedef int8_t i8;" ;
    "typedef int16_t i16;" ;
    "typedef int32_t i32;" ;
    "typedef int64_t i64;" ;
    "typedef uintptr_t usize;" ;;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern void* calloc(usize, usize);" ;
    "extern void* realloc(void*, usize);" ;
    "extern void* memset(void*, int, usize);" ;
    "extern void* memcpy(void*, const void*, usize);" ;
    "extern void free(void*);" ;
    "extern usize strlen(const char*);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern int strcmp(const char*, const char*);" ;
    "extern void exit(int);" ;;

    "typedef enum value_tag_t {" ;
    "   VT_U64 = 0x00," ; # u64
    "   VT_U32 = 0x01," ; # u32 u32
    "   VT_U21 = 0x02," ; # u21 u21 u21
    "   VT_U16 = 0x03," ; # u16 u16 u16 u16
    "   VT_C16 = 0x90," ; # c16 u16 u16 u16
    "   VT_C21 = 0x96," ; # c21 u21 u21
    "   VT_C32 = 0xA0," ; # c32 u32
    "   VT_C64 = 0xC0," ; # c64
    "} value_tag_t;" ;;

    "typedef void (*fnptr)(void);" ;;

    "typedef union value_payload_t {" ;
    "    void* vp_ptr;" ;
    "    u8 vp_u8;" ;
    "    u16 vp_u16;" ;
    "    u32 vp_u32;" ;
    "    u64 vp_u64;" ;
    "    i8 vp_i8;" ;
    "    i16 vp_i16;" ;
    "    i32 vp_i32;" ;
    "    i64 vp_i64;" ;
    "    bool vp_bool;" ;
    "    fnptr vp_fnptr;" ;
    "} value_payload_t;" ;;

    "typedef struct value_t {" ;
    "   value_payload_t payload;" ;
    "   value_tag_t tag; " ;
    "} value_t; " ;;

    "typedef struct cell_t {" ;
    "   u32 refs;" ; # reference count
    "   bool freecdr;" ; # call "free" on cdr
    "   value_t car;" ;
    "   value_t cdr;" ;
    "} cell_t;" ;;

    "#define STACK_SIZE 0x1000" ;
    "static usize stack_counter = STACK_SIZE;" ;
    "static value_t stack [STACK_SIZE] = {0};" ;;

    "#define HEAP_SIZE 0x80000" ;
    "#define HEAP_MASK 0x7FFFF" ;
    "static usize heap_next = 1;" ;
    "static usize heap_count = 0;" ;
    "static cell_t heap [HEAP_SIZE] = {0};" ;;

    "static int global_argc;" ;
    "static char** global_argv;" ;;
    )

def(c99-emit-buffers!, +IO,
    Buffer.for(c99-emit-buffer!) .lf)

def(c99-emit-buffer!, Buffer -- +IO,
    "static u8 b" . buffer-name? .name "[" . buffer-size? .n "] = {0};" ;
    "#define mw" . buffer-name? .name "() push_ptr((void*)b" . buffer-name@ .name ")" ;)

def(c99-emit-variables!, --,
    Variable.for(c99-emit-variable!) .lf)

def(c99-emit-variable!, Variable --,
    "void mw" . variable-name? .name "() {" ;
    "  static value_t v = {0};" ;
    "  if (!v.payload.vp_u64) { value_t nil={0}; v = mkcell_raw(nil,nil); }" ;
    "  incref(v); push_value(v);" ;
    "}" ;
    drop)

def(c99-emit-tags!, +IO,
    Tag.for(c99-emit-tag!) .lf)

def(c99-emit-tag!, Tag -- +IO,
    tag-is-transparent? if(
        "#define mw" . tag-name@ .name "() 0" ; ,

    tag-num-inputs? 0 == if(
        "#define mw" . tag-name? .name "() push_u64(" . tag-value@ .n ")" ;,

        "static void mw" . tag-name? .name " (void) {" ;
        "    value_t car = pop_value();" ;
        tag-num-inputs? 1-
        while(dup 0 >, "    car = mkcell(car, pop_value());" ;  1-) drop
        "    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = " . tag-value@ .n "LL } };" ;
        "    car = mkcell(car, tag);" ;
        "    push_value(car);" ;
        "}" ;
    )))

# def(c99-emit-tag!, Tag -- +IO,
#     "static void mw" . tag-name? .name " (void) {" ;
#     tag-is-transparent? if(
#         drop,
#         tag-num-inputs? 0 == if(
#             "    push_u64(" . tag-value@ .n "LL);" ;,

#             "    value_t car = pop_value();" ;
#             tag-num-inputs? 1-
#             while(dup 0 >, "    car = mkcell(car, pop_value());" ;  1-) drop
#             "    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = " . tag-value@ .n "LL } };" ;
#             "    car = mkcell(car, tag);" ;
#             "    push_value(car);" ;
#         )
#     )
#     "}" ;;)

def(c99-emit-prims!, +IO,
    "#define get_cell_index(v) ((usize)(((v).tag & 0x80) ? ((v).payload.vp_u64 >> (0xC0 - (u64)((v).tag))) : 0))" ;;

    # "static usize get_cell_index (value_t v) {" ;
    # "    switch (v.tag) {" ;
    # "        case VT_C64: return (usize)v.payload.vp_u64;" ;
    # "        case VT_C32: return (usize)(v.payload.vp_u64 >> 32);" ;
    # "        case VT_C21: return (usize)(v.payload.vp_u64 >> 42);" ;
    # "        case VT_C16: return (usize)(v.payload.vp_u64 >> 48);" ;
    # "        default: return 0;" ;
    # "    }" ;
    # "}" ;;

    "#define incref(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) heap[i].refs++; }while(0)" ;;

    # "static void incref (value_t v) {" ;
    # "    usize cell_index = get_cell_index(v);" ;
    # "    if (cell_index) {" ;
    # "        cell_t *cell = heap + cell_index;" ;
    # "        cell->refs++;" ;
    # "    }" ;
    # "}" ;;

    "#define decref(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) { if(heap[i].refs) { heap[i].refs--; if (heap[i].refs == 0) heap_free(i); } }} while(0)" ;;

    "static void heap_free(usize i) {" ;
    "    cell_t *cell = heap + i;" ;
    "    cell_t contents = *cell;" ;
    "    memset(cell, 0, sizeof(cell_t));" ;
    "    cell->cdr.payload.vp_u64 = heap_next;" ;
    "    heap_next = i;" ;
    "    heap_count--;" ;
    "    if (contents.freecdr) { free(contents.cdr.payload.vp_ptr); }" ;
    "    else { decref(contents.cdr); }" ;
    "    decref(contents.car);" ;
    "}" ;;

#     "static void decref (value_t v) { " ;
#     "    usize cell_index;" ;
#     "    while ((cell_index = get_cell_index(v))) {" ;
#     "        cell_t *cell = heap + cell_index;" ;
#     "        if (cell->refs >= 1) {" ;
#     "            cell->refs--; break;" ;
# #     "            if (cell->refs == 0) {" ;
# #     "                value_t car = cell->car;" ;
# #     "                value_t cdr = cell->cdr;" ;
# #     "                bool freecdr = cell->freecdr;" ;
# #     "                cell->freecdr = false;" ;
# #     "                cell->car.tag = 0; cell->car.payload.vp_u64 = 0;" ;
# #     "                cell->cdr.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" ;
# #     "                heap_next = cell_index;" ;
# #     "                heap_count--;" ;
# #     "                if (freecdr && cell->cdr.tag == VT_U64) {" ;
# #     "                    free(cdr.payload.vp_ptr);" ;
# #     "                } else {" ;
# # #    "                    decref(cdr);" ;
# #     "                }" ;
# # #    "                v = car;" ;
# #     "                break;" ;

#     # "            } else {" ;
#     # "                break;" ;
#     # "            }" ;
#     "        } else {" ;
#     "            break;" ;
#     "        }" ;
#     "    }" ;
#     "}" ;;

    ||| Decrement reference after a cons. This is equivalent to:
    |||     incref(car), incref(cdr), decref(cell)
    ||| but it avoids unnecessary increfs/decrefs on the car/cdr.
    "#define decref_for_uncons(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) { if (heap[i].refs) { heap[i].refs--; if (heap[i].refs == 0) { memset(heap+i, 0, sizeof(cell_t)); heap[i].cdr.payload.vp_u64 = heap_next; heap_next = i; heap_count--; } else { cell_t cell = heap[i]; incref(cell.car); incref(cell.cdr); } } } } while(0)" ;

    # "static void decref_for_uncons (value_t v) { " ;
    # "    usize cell_index = get_cell_index(v);" ;
    # "    cell_t *cell = heap + cell_index;" ;
    # "    if (cell->refs >= 1) {" ;
    # "        cell->refs--;" ;
    # "        if (cell->refs == 0) {" ;
    # "            cell->cdr.tag = 0; cell->car.payload.vp_u64 = 0;" ;
    # "            cell->car.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" ;
    # "            heap_next = cell_index;" ;
    # "            heap_count--;" ;
    # "        } else {" ;
    # "            incref(cell->car);" ;
    # "            incref(cell->cdr);" ;
    # "        }" ;
    # "    }" ;
    # "}" ;;


    "static void value_uncons(value_t val, value_t* car, value_t* cdr) {" ;
    "    switch (val.tag) {" ;
    "        case VT_U64: {" ;
    "            value_t nil = { 0 };" ;
    "            *car = nil;" ;
    "            *cdr = val;" ;
    "        } break;" ;
    "        case VT_U32: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFFFFFF;" ;
    "            u64 hi = vv >> 32;" ;
    "            car->tag = VT_U64; car->payload.vp_u64 = hi;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C64: {" ;
    "            cell_t* cell = heap + val.payload.vp_u64;" ;
    "            *car = cell->car;" ;
    "            *cdr = cell->cdr;" ;
    "        } break;" ;
    "        case VT_C32: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFFFFFF;" ;
    "            u64 hi = vv >> 32;" ;
    "            car->tag = VT_C64; car->payload.vp_u64 = hi;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_U21: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0x1FFFFF;" ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" ;
    "            car->tag = VT_U32;" ;
    "            car->payload.vp_u64 = (hi << 32) | md;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C21: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0x1FFFFF;" ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" ;
    "            car->tag = VT_C32;" ;
    "            car->payload.vp_u64 = (hi << 32) | md;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_U16: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFF;" ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" ;
    "            car->tag = VT_U21;" ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "        case VT_C16: {" ;
    "            u64 vv = val.payload.vp_u64;" ;
    "            u64 lo = vv & 0xFFFF;" ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" ;
    "            car->tag = VT_C21;" ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" ;
    "        } break;" ;
    "    }" ;
    "}" ;;


    # "static value_t pop_value (void) {" ;
    # "    if (stack_counter >= STACK_SIZE) {" ;
    # "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    # "        exit(1);" ;
    # "    }" ;
    # "    return stack[stack_counter++];" ;
    # "}" ;;

    "static bool value_has_ptr_offset (value_t v) {" ;
    "    if (v.tag == VT_C64) {" ;
    "        usize cell_index = (usize)v.payload.vp_u64;" ;
    "        struct cell_t * cell = heap + cell_index;" ;
    "        return !cell->freecdr;" ;
    "    } else {" ;
    "        return v.tag != VT_U64;" ;
    "    }" ;
    "}" ;;

    "static u64 value_ptr_size (value_t v) {" ;
    "    if (v.payload.vp_u64 == 0) {" ;
    "        return 0;" ;
    "    } else if (v.tag == VT_U64) {" ;
    "        return strlen(v.payload.vp_ptr);" ;
    "    } else if (value_has_ptr_offset(v)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        value_t car2, cdr2;" ;
    "        value_uncons(car, &car2, &cdr2);" ;
    "        u64 size = car2.payload.vp_u64;" ;
    "        u64 offset = cdr.payload.vp_u64;" ;
    "        if (size >= offset) {" ;
    "            return offset - size;" ;
    "        } else {" ;
    "            return 0;" ;
    "        }" ;
    "    } else {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        return car.payload.vp_u64;" ;
    "    }" ;
    "}" ;;

    "static void* value_ptr_base (value_t v) {" ;
    "    if (value_has_ptr_offset(v)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        value_t car2, cdr2;" ;
    "        value_uncons(car, &car2, &cdr2);" ;
    "        return cdr2.payload.vp_ptr;" ;
    "    } else {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        return cdr.payload.vp_ptr;" ;
    "    }" ;
    "}" ;;

    "static i64 value_ptr_offset (value_t v) {" ;
    "    if (value_has_ptr_offset(v)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(v, &car, &cdr);" ;
    "        return cdr.payload.vp_i64;" ;
    "    } else {" ;
    "        return 0;" ;
    "    }" ;
    "}" ;;


    "static void* value_ptr (value_t v) {" ;
    "    usize cell_index; cell_t* cell; usize offset;" ;
    "    switch (v.tag) {" ;
    "        case VT_U64: return v.payload.vp_ptr;" ;
    "        case VT_C64: " ;
    "            cell_index = (usize)v.payload.vp_u64;" ;
    "            cell = heap + cell_index;" ;
    "            if (cell->freecdr) {" ;
    "                return cell->cdr.payload.vp_ptr;" ;
    "            } else {" ;
    "                offset = (usize)cell->cdr.payload.vp_u64;" ;
    "                cell_index = (usize)cell->car.payload.vp_u64;" ;
    "                break;" ;
    "            }" ;
    "       case VT_C32: " ;
    "            offset = (usize)v.payload.vp_u32;" ;
    "            cell_index = (usize)(v.payload.vp_u64 >> 32);" ;
    "            break;" ;
    "       default: " ;
    "            return (void*)0;" ;
    "    }" ;
    "    cell = heap + cell_index;" ;
    "    if (cell->freecdr) {" ;
    "        char* base = cell->cdr.payload.vp_ptr;" ;
    "        return (void*)(base + offset);" ;
    "    }" ;
    "    return (void*)0;" ;
    "}" ;;

    "#define pop_value() (stack[stack_counter++])" ;
    "#define pop_fnptr() (pop_value().payload.vp_fnptr)" ;
    "#define pop_u8() (pop_value().payload.vp_u8)" ;
    "#define pop_u16() (pop_value().payload.vp_u16)" ;
    "#define pop_u32() (pop_value().payload.vp_u32)" ;
    "#define pop_u64() (pop_value().payload.vp_u64)" ;
    "#define pop_i8() (pop_value().payload.vp_i8)" ;
    "#define pop_i16() (pop_value().payload.vp_i16)" ;
    "#define pop_i32() (pop_value().payload.vp_i32)" ;
    "#define pop_i64() (pop_value().payload.vp_i64)" ;
    "#define pop_bool() (pop_value().payload.vp_bool)" ;
    "#define pop_rawptr() (pop_value().payload.vp_ptr)" ;

    "#define push_value(v) stack[--stack_counter] = (v)" ;
    "#define push_u64(v) do { stack[--stack_counter].tag = VT_U64; stack[stack_counter].payload.vp_u64 = (v); } while(0)" ;
    "#define push_i64(v) do { stack[--stack_counter].tag = VT_U64; stack[stack_counter].payload.vp_i64 = (v); } while(0)" ;
    "#define push_ptr(v) push_u64((u64)(v))" ;
    "#define push_fnptr(v) push_u64((u64)(v))" ;
    "#define push_bool(b) push_u64((u64)((bool)(b)))" ;
    "#define push_u8(b) push_u64((u64)(b))" ;
    "#define push_u16(b) push_u64((u64)(b))" ;
    "#define push_u32(b) push_u64((u64)(b))" ;
    "#define push_i8(b) push_i64((i64)(b))" ;
    "#define push_i16(b) push_i64((i64)(b))" ;
    "#define push_i32(b) push_i64((i64)(b))" ;
    "#define push_rawptr(v) push_u64((u64)(void*)(v))" ;

    # create a cons cell, while taking ownership of car and cdr's refs
    "static value_t mkcell (value_t car, value_t cdr) {" ;
    "    if ((car.payload.vp_u64 == 0) && (cdr.tag == VT_U64))" ;
    "        return cdr;" ;
    "    if (cdr.tag == VT_U64) {" ;
    "        switch (car.tag) {" ;
    "            case VT_U64: {" ;
    "                u64 x0 = car.payload.vp_u64;" ;
    "                u64 x1 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U32;" ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C64: {" ;
    "                u64 x0 = car.payload.vp_u64;" ;
    "                u64 x1 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C32;" ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_U32: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" ;
    "                u64 x2 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U21;" ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C32: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" ;
    "                u64 x2 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C21;" ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_U21: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" ;
    "                u64 x3 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFLL;" ;
    "                u64 y2 = x2 & 0xFFFFLL;" ;
    "                u64 y3 = x3 & 0xFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_U16;" ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            case VT_C21: {" ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" ;
    "                u64 x3 = cdr.payload.vp_u64;" ;
    "                u64 y0 = x0 & 0xFFFFLL;" ;
    "                u64 y1 = x1 & 0xFFFFLL;" ;
    "                u64 y2 = x2 & 0xFFFFLL;" ;
    "                u64 y3 = x3 & 0xFFFFLL;" ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" ;
    "                    value_t r;" ;
    "                    r.tag = VT_C16;" ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" ;
    "                    return r;" ;
    "                }" ;
    "            } break;" ;
    "            default: break;" ;
    "        }" ;
    "    }" ;
    "    if (heap_count >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 cell_index = heap_next;" ;
    "    cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->freecdr = false;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_C64;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;

    "static value_t mkcell_raw (value_t car, value_t cdr) {" ;
    "    u64 cell_index = heap_next;" ;
    "    cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->freecdr = false;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_C64;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;

    "static value_t mkcell_freecdr (value_t car, value_t cdr) {" ;
    "    if (heap_count >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 cell_index = heap_next;" ;
    "    cell_t *cell = heap + cell_index;" ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" ;
    "    if (cell_index >= HEAP_SIZE - 1) {" ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" ;
    "        exit(1);" ;
    "    }" ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" ;
    "    heap_count++;" ;
    "    cell->refs = 1;" ;
    "    cell->freecdr = true;" ;
    "    cell->car = car;" ;
    "    cell->cdr = cdr;" ;
    "    value_t v = {0};" ;
    "    v.tag = VT_C64;" ;
    "    v.payload.vp_u64 = cell_index;" ;
    "    return v;" ;
    "}" ;;

    # "#define do_pack_uncons() do{ value_t dpucar, dpucdr, dpuval=pop_value(); value_uncons(dpuval, &dpucar, &dpucdr); push_value(dpucar); push_value(dpucdr); if(dpuval.tag == VT_C64) { decref_for_uncons(dpuval); } }while(0)" ;

    "static void do_pack_uncons(void) {" ;
    "    value_t car, cdr, val;" ;
    "    val = pop_value();" ;
    "    value_uncons(val, &car, &cdr);" ;
    "    push_value(car); push_value(cdr);" ;
    "    if (val.tag == VT_C64) {" ;
    "        decref_for_uncons(val);" ;
    "    }" ;
    "}" ;;

    "#define get_value_tag(v) (((v).tag == VT_U64) ? (v).payload.vp_i64 : (((v).tag == VT_C64) ? (heap[(v).payload.vp_u64].cdr.payload.vp_i64) : (i64)((v).payload.vp_u64 & 0xFFFF)))" ;

    # "static i64 get_value_tag_hard(value_t v) {" ;
    # "    switch (v.tag) {" ;
    # "        case VT_C64: {" ;
    # "            cell_t *c = heap + v.payload.vp_u64;" ;
    # "            if (c->cdr.tag == VT_U64) return c->cdr.payload.vp_i64;" ;
    # "            return 0;" ;
    # "        } break;" ;
    # "        case VT_U64: {" ;
    # "            return v.payload.vp_i64;" ;
    # "        } break;" ;
    # "        case VT_U32: {" ;
    # "            return v.payload.vp_u64 & 0xFFFFFFFF;" ;
    # "        } break;" ;
    # "        case VT_C32: {" ;
    # "            return v.payload.vp_u64 & 0xFFFFFFFF;" ;
    # "        } break;" ;
    # "        case VT_U21: {" ;
    # "            return v.payload.vp_u64 & 0x1FFFFF;" ;
    # "        } break;" ;
    # "        case VT_C21: {" ;
    # "            return v.payload.vp_u64 & 0x1FFFFF;" ;
    # "        } break;" ;
    # "        case VT_U16: {" ;
    # "            return v.payload.vp_u64 & 0xFFFF;" ;
    # "        } break;" ;
    # "        case VT_C16: {" ;
    # "            return v.payload.vp_u64 & 0xFFFF;" ;
    # "        } break;" ;
    # "    }" ;
    # "    return 0;" ;
    # "}" ;;

    "#define get_top_data_tag() (get_value_tag(stack[stack_counter]))" ;

    # "static u64 get_top_data_tag() {" ;
    # "    return get_value_tag(stack[stack_counter]);" ;
    # "}" ;;

    "#define value_cmp(v1,v2) ((((v1).tag == VT_U64) && ((v2).tag == VT_U64)) ? ((v1).payload.vp_i64 - (v2).payload.vp_i64) : value_cmp_hard((v1), (v2)))" ;;

    "static i64 value_cmp_hard(value_t v1, value_t v2) {" ;
    "    while(1) {" ;
    "        i64 t1 = get_value_tag(v1);" ;
    "        i64 t2 = get_value_tag(v2);" ;
    "        if (t1 < t2) return -1;" ;
    "        if (t1 > t2) return 1;" ;
    "        if ((v1.tag == VT_U64) && (v2.tag == VT_U64)) return 0;" ;
    "        value_t v1car, v1cdr, v2car, v2cdr;" ;
    "        value_uncons(v1, &v1car, &v1cdr);" ;
    "        value_uncons(v2, &v2car, &v2cdr);" ;
    "        i64 cdrcmp = value_cmp(v1cdr, v2cdr);" ;
    "        if (cdrcmp != 0) return cdrcmp;" ;
    "        v1 = v1car; v2 = v2car;" ;
    "    }" ;
    "}" ;;

    "#define value_eq(v1,v2) (((v1).tag == (v2).tag) && (((v1).payload.vp_u64 == (v2).payload.vp_u64) || (((v1).tag & 0x80) && value_eq_hard((v1),(v2)))))" ;;

    "static bool value_eq_hard(value_t v1, value_t v2) {" ;
    "    usize c1_index, c2_index; cell_t *c1, *c2;" ;
    "    while (1) {" ;
    "        if (v1.tag != v2.tag) return false;" ;
    "        if (v1.payload.vp_u64 == v2.payload.vp_u64) return true;" ;
    "        switch (v1.tag) {" ;
    "            case VT_U64: return false;" ;
    "            case VT_U32: return false;" ;
    "            case VT_U21: return false;" ;
    "            case VT_U16: return false;" ;
    "            case VT_C64:" ;
    "               c1_index = (usize)v1.payload.vp_u64;" ;
    "               c2_index = (usize)v2.payload.vp_u64;" ;
    "               break;" ;
    "            case VT_C32:";
    "               if (v1.payload.vp_u32 != v2.payload.vp_u32) return false;" ;
    "               c1_index = (usize)(v1.payload.vp_u64 >> 32);" ;
    "               c2_index = (usize)(v2.payload.vp_u64 >> 32);" ;
    "               break;" ;
    "            case VT_C21:";
    "               if (  (v1.payload.vp_u64 & 0x03FFFFFFFFFF)" ;
    "                  != (v2.payload.vp_u64 & 0x03FFFFFFFFFF)) return false;" ;
    "               c1_index = (usize)(v1.payload.vp_u64 >> 42);" ;
    "               c2_index = (usize)(v2.payload.vp_u64 >> 42);" ;
    "               break;" ;
    "            case VT_C16:";
    "               if (  (v1.payload.vp_u64 & 0xFFFFFFFFFFFF)" ;
    "                  != (v2.payload.vp_u64 & 0xFFFFFFFFFFFF)) return false;" ;
    "               c1_index = (usize)(v1.payload.vp_u64 >> 48);" ;
    "               c2_index = (usize)(v2.payload.vp_u64 >> 48);" ;
    "               break;" ;
    "        }" ;
    "        c1 = heap + c1_index;" ;
    "        c2 = heap + c2_index;" ;
    "        if (!value_eq(c1->cdr, c2->cdr)) return false;" ;
    "        v1 = c1->car; v2 = c2->car;" ;
    "    }" ;
    "}" ;;

    "#define do_run() do { do_pack_uncons(); fnptr fp = pop_fnptr(); fp(); } while(0)" ;
    # "static void do_run() {" ;
    # "    do_pack_uncons();" ;
    # "    fnptr fp = pop_fnptr();" ;
    # "    fp();" ;
    # "}" ;;

    PRIM_CORE_ID .pm "0" ;
    PRIM_CORE_DUP .pm "do{ value_t v = stack[stack_counter]; push_value(v); incref(v); } while(0)" ;;
    "#define do_drop() decref(pop_value())" ;
    PRIM_CORE_DROP .pm "do_drop()" ;;
    "#define do_swap() do{ value_t x = stack[stack_counter]; stack[stack_counter] = stack[stack_counter+1]; stack[stack_counter+1] = x; } while(0)" ;
    PRIM_CORE_SWAP .pm "do_swap()" ;;

    PRIM_CORE_DIP .p " {" ;
    "    value_t f = pop_value();" ;
    "    value_t x = pop_value();" ;
    "    push_value(f);" ;
    "    do_run();" ;
    "    push_value(x);" ;
    "}" ;;

    PRIM_CORE_IF .p " {" ;
    "    value_t then_branch = pop_value();" ;
    "    value_t else_branch = pop_value();" ;
    "    bool b = pop_bool();" ;
    "    if (b) {" ;
    "        push_value(then_branch);" ;
    "        decref(else_branch);" ;
    "    } else {" ;
    "        push_value(else_branch);" ;
    "        decref(then_branch);" ;
    "    }" ;
    "    do_run();" ;
    "}" ;;

    PRIM_CORE_WHILE .p " {" ;
    "    value_t cond = pop_value();" ;
    "    value_t body = pop_value();" ;
    "    while(1) {" ;
    "        push_value(cond); incref(cond); do_run();" ;
    "        bool b = pop_bool();" ;
    "        if (!b) break;" ;
    "        push_value(body); incref(body); do_run();" ;
    "    }" ;
    "    decref(cond); decref(body);" ;
    "}" ;;

    PRIM_INT_ADD .pm "do { stack[stack_counter+1].payload.vp_u64 += stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_INT_SUB .pm "do { stack[stack_counter+1].payload.vp_u64 -= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_INT_MUL .pm "do { stack[stack_counter+1].payload.vp_i64 *= stack[stack_counter].payload.vp_i64; stack_counter++; } while(0)" ;
    PRIM_INT_DIV .pm "do { i64 a = stack[stack_counter+1].payload.vp_i64; i64 b = stack[stack_counter].payload.vp_i64; i64 r = a % b; i64 q = a / b; if (((a < 0) ^ (b < 0)) && r) q--; stack_counter++; stack[stack_counter].payload.vp_i64 = q; } while(0)" ;
    PRIM_INT_MOD .pm "do { i64 a = stack[stack_counter+1].payload.vp_i64; i64 b = stack[stack_counter].payload.vp_i64; i64 r = a % b; if (((a < 0) ^ (b < 0)) && r) r += b; stack_counter++; stack[stack_counter].payload.vp_i64 = r; } while(0)" ;
    PRIM_INT_AND .pm "do { stack[stack_counter+1].payload.vp_u64 &= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_INT_OR .pm "do { stack[stack_counter+1].payload.vp_u64 |= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_INT_XOR .pm "do { stack[stack_counter+1].payload.vp_u64 ^= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_INT_SHL .pm "do { stack[stack_counter+1].payload.vp_u64 <<= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_INT_SHR .pm "do { stack[stack_counter+1].payload.vp_u64 >>= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;

    PRIM_VALUE_EQ .pm " do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_eq(v1, v2)); decref(v1); decref(v2); } while(0)" ;;
    PRIM_VALUE_LT .pm " do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_cmp(v1, v2) < 0); decref(v1); decref(v2); } while(0)" ;;
    PRIM_VALUE_LE .pm " do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_cmp(v1, v2) <= 0); decref(v1); decref(v2); } while(0)" ;;

    # PRIM_VALUE_EQ .p " {" ;
    # "    value_t v2 = pop_value();" ;
    # "    value_t v1 = pop_value();" ;
    # "    push_bool(value_eq(v1, v2));" ;
    # "    decref(v1); decref(v2);" ;
    # "}" ;;

    # PRIM_VALUE_LT .p " {" ;
    # "    value_t v2 = pop_value();" ;
    # "    value_t v1 = pop_value();" ;
    # "    push_bool(value_cmp(v1, v2) < 0);" ;
    # "    decref(v1); decref(v2);" ;
    # "}" ;;

    # PRIM_VALUE_LE .p " {" ;
    # "    value_t v2 = pop_value();" ;
    # "    value_t v1 = pop_value();" ;
    # "    push_bool(value_cmp(v1, v2) <= 0);" ;
    # "    decref(v1); decref(v2);" ;
    # "}" ;;

    PRIM_POSIX_WRITE .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    value_t vp = pop_value();" ;
    "    void* p = value_ptr(vp);" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)write(f, p, n));" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_POSIX_READ .p " {" ;
    "    usize n = (usize)pop_u64();" ;
    "    value_t vp = pop_value();" ;
    "    void* p = value_ptr(vp);" ;
    "    int f = (int)pop_i64();" ;
    "    push_i64((i64)read(f,p,n));" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_POSIX_OPEN .p " {" ;
    "    int m = (int)pop_i64();" ;
    "    int f = (int)pop_i64();" ;
    "    value_t vp = pop_value();" ;
    "    void* p = value_ptr(vp);" ;
    "    push_i64((i64)open(p,f,m));" ;
    "    decref(vp);" ;
    "}" ;;

    PRIM_POSIX_CLOSE .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    push_i64((i64)close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .p " {" ;
    "    int x = (int)pop_i64();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .p " {" ;
    "    #ifdef MIRTH_WINDOWS" ;
    "    pop_value(); pop_value(); pop_value(); pop_value();" ;
    "    usize b = (usize)pop_u64();" ;
    "    pop_value();" ;
    "    push_ptr(malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop_i64();" ;
    "    int e = (int)pop_i64();" ;
    "    int d = (int)pop_i64();" ;
    "    int c = (int)pop_i64();" ;
    "    usize b = (usize)pop_u64();" ;
    "    value_t va = pop_value();" ;
    "    void* a = value_ptr(va);" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push_ptr(p);" ;
    "    decref(va);" ;
    "    #endif" ;
    "}" ;;

    "static void do_debug(void) {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x; i64 y;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {" ;
    "        cp = c+30;" ;
    "        x = stack[i].payload.vp_i64;" ;
    "        n = 1;" ;
    "        y = x; if (x < 0) { x = -x; }" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        if (y < 0) { *cp-- = '-'; n++; } " ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_CORE_DEBUG .pm "do_debug()" ;;

    # PRIM_VALUE_GET .p " {" ;
    # "    value_t vp = pop_value();" ;
    # "    value_t* p = value_ptr(vp);" ;
    # "    value_t v = *p;" ;
    # "    push_value(v);" ;
    # "    incref(v);" ;
    # "    decref(vp);" ;
    # "}" ;;

    PRIM_VALUE_GET .pm "do { value_t vp = pop_value(); value_t* p = value_ptr(vp); push_value(*p); incref(*p); decref(vp); } while(0)" ;
    PRIM_INT_GET .pm "do { value_t vp = pop_value(); i64* p = value_ptr(vp); push_i64(*p); decref(vp); } while(0)" ;
    PRIM_PTR_GET .pm "do { value_t vp = pop_value(); void** p = value_ptr(vp); push_ptr(*p); decref(vp); } while(0)" ;
    PRIM_U8_GET .pm "do { value_t vp = pop_value(); u8* p = value_ptr(vp); push_u8(*p); decref(vp); } while(0)" ;
    PRIM_U16_GET .pm "do { value_t vp = pop_value(); u16* p = value_ptr(vp); push_u16(*p); decref(vp); } while(0)" ;
    PRIM_U32_GET .pm "do { value_t vp = pop_value(); u32* p = value_ptr(vp); push_u32(*p); decref(vp); } while(0)" ;
    PRIM_U64_GET .pm "do { value_t vp = pop_value(); u64* p = value_ptr(vp); push_u64(*p); decref(vp); } while(0)" ;
    PRIM_I8_GET .pm "do { value_t vp = pop_value(); i8* p = value_ptr(vp); push_i8(*p); decref(vp); } while(0)" ;
    PRIM_I16_GET .pm "do { value_t vp = pop_value(); i16* p = value_ptr(vp); push_i16(*p); decref(vp); } while(0)" ;
    PRIM_I32_GET .pm "do { value_t vp = pop_value(); i32* p = value_ptr(vp); push_i32(*p); decref(vp); } while(0)" ;
    PRIM_I64_GET .pm "do { value_t vp = pop_value(); i64* p = value_ptr(vp); push_i64(*p); decref(vp); } while(0)" ;

    PRIM_INT_SET .pm "do { value_t vp = pop_value(); i64* p = value_ptr(vp); *p = pop_i64(); decref(vp); } while(0)" ;
    PRIM_U8_SET .pm "do { value_t vp = pop_value(); u8* p = value_ptr(vp); *p = pop_u8(); decref(vp); } while(0)" ;
    PRIM_U16_SET .pm "do { value_t vp = pop_value(); u16* p = value_ptr(vp); *p = pop_u16(); decref(vp); } while(0)" ;
    PRIM_U32_SET .pm "do { value_t vp = pop_value(); u32* p = value_ptr(vp); *p = pop_u32(); decref(vp); } while(0)" ;
    PRIM_U64_SET .pm "do { value_t vp = pop_value(); u64* p = value_ptr(vp); *p = pop_u64(); decref(vp); } while(0)" ;
    PRIM_I8_SET .pm "do { value_t vp = pop_value(); i8* p = value_ptr(vp); *p = pop_i8(); decref(vp); } while(0)" ;
    PRIM_I16_SET .pm "do { value_t vp = pop_value(); i16* p = value_ptr(vp); *p = pop_i16(); decref(vp); } while(0)" ;
    PRIM_I32_SET .pm "do { value_t vp = pop_value(); i32* p = value_ptr(vp); *p = pop_i32(); decref(vp); } while(0)" ;
    PRIM_I64_SET .pm "do { value_t vp = pop_value(); i64* p = value_ptr(vp); *p = pop_i64(); decref(vp); } while(0)" ;
    PRIM_PTR_SET .pm "do { value_t vp = pop_value(); value_t vx = pop_value(); void** p = value_ptr(vp); *p = value_ptr(vx); decref(vp); decref(vx); } while(0)" ;
    PRIM_VALUE_SET .pm "do { value_t vp = pop_value(); value_t vx = pop_value(); value_t* p = value_ptr(vp); value_t old = *p; *p = vx; decref(old); decref(vp); } while(0)" ;

    "#if defined(MIRTH_WINDOWS)" ;
    PRIM_SYS_OS .pm "push_u64(" . OS_WINDOWS OS->Int .n ")" ;
    "#elif defined(MIRTH_LINUX)" ;
    PRIM_SYS_OS .pm "push_u64(" . OS_LINUX OS->Int .n ")" ;
    "#elif defined(MIRTH_MACOS)" ;
    PRIM_SYS_OS .pm "push_u64(" . OS_MACOS OS->Int .n ")" ;
    "#else" ;
    PRIM_SYS_OS .pm "push_u64(" . OS_UNKNOWN OS->Int .n ")" ;
    "#endif" ;;

    PRIM_UNSAFE_CAST .pm "0" ;;
    PRIM_CORE_RUN .pm "do_run()" ;;

    PRIM_PTR_ADD .p " {" ;
    "    value_t vp = pop_value();" ;
    "    i64 y = pop_i64();" ;
    "    if (vp.tag == VT_U64) {" ;
    "        push_i64(y + vp.payload.vp_i64);" ;
    "    } else if (value_has_ptr_offset(vp)) {" ;
    "        value_t car, cdr;" ;
    "        value_uncons(vp, &car, &cdr);" ;
    "        cdr.payload.vp_i64 += y;" ;
    "        push_value(mkcell(car, cdr));" ;
    "    } else {" ;
    "        value_t vy = { .tag = VT_U64, .payload = { .vp_i64 = y } };" ;
    "        push_value(mkcell(vp, vy));" ;
    "    }" ;
    "}" ;

    PRIM_BOOL_TRUE .pm "push_bool(true)" ;
    PRIM_BOOL_FALSE .pm "push_bool(false)" ;
    PRIM_BOOL_AND .pm "do { stack[stack_counter+1].payload.vp_u64 = stack[stack_counter+1].payload.vp_u64 && stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;
    PRIM_BOOL_OR .pm "do { stack[stack_counter+1].payload.vp_u64 = stack[stack_counter+1].payload.vp_u64 || stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)" ;

    PRIM_SYS_ARGC .pm "push_i64(global_argc)" ;
    PRIM_SYS_ARGV .pm "push_ptr(global_argv)" ;
        PRIM_PTR_SIZE .pm "push_u64((u64)sizeof(void*))" ;

    PRIM_PTR_ALLOC .p " {" ;
    "    i64 psize = pop_i64();" ;
    "    if (psize > 0) {" ;
    "        usize size = (usize)psize;" ;
    "        void* ptr = calloc(1,size);" ;
    "        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };" ;
    "        value_t vptr = { .tag = VT_U64, .payload = { .vp_ptr = ptr } };" ;
    "        value_t v = mkcell_freecdr(vsize, vptr);" ;
    "        push_value(v);" ;
    "    } else {" ;
    "        push_u64(0);" ;
    "    }" ;
    "}" ;;

    "static void* alloc_but_copy (usize dstn, void* src, usize srcn) {" ;
    "    void* dst = calloc(1,dstn);" ;
    "    if (src) {" ;
    "        usize cpyn = (dstn > srcn) ? srcn : dstn;" ;
    "        memcpy(dst, src, cpyn);" ;
    "    }" ;
    "    return dst;" ;
    "}" ;

    PRIM_PTR_REALLOC .p " {" ;
    "    i64 psize = pop_i64();" ;
    "    value_t vptr = pop_value();" ;
    "    if (psize <= 0) { " ;
    "        decref(vptr);" ;
    "        push_u64(0);" ;
    "        return;" ;
    "    }" ;
    "    usize new_size = (usize)psize;" ;
    "    if ((vptr.tag == VT_C64) && !value_has_ptr_offset(vptr)) {" ; # destructive realloc
    "       usize cell_index = get_cell_index(vptr);" ;
    "       cell_t *cell = heap + cell_index;" ;
    "       usize old_size = (usize)cell->car.payload.vp_u64;" ;
    "       void* old_ptr = cell->cdr.payload.vp_ptr;" ;
    "       void* new_ptr = realloc(old_ptr, new_size);" ;
    "       cell->car.payload.vp_i64 = psize;" ;
    "       cell->cdr.payload.vp_ptr = new_ptr;" ;
    "       if (old_size < new_size) {" ;
    "           memset((char*)new_ptr + old_size, 0, new_size - old_size);" ;
    "       }" ;
    "       push_value(vptr);" ;
    "    } else {" ; # nondestructive "realloc"
    "        void* old_ptr = value_ptr(vptr);" ;
    "        usize old_size = (usize)value_ptr_size(vptr);" ;
    "        void* new_ptr = alloc_but_copy(new_size, old_ptr, old_size);" ;
    "        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };" ;
    "        value_t vnew = { .tag = VT_U64, .payload = { .vp_ptr = new_ptr } };" ;
    "        value_t v = mkcell_freecdr(vsize, vnew);" ;
    "        push_value(v);" ;
    "        decref(vptr);" ;
    "    }" ;
    "}" ;;

    PRIM_PTR_COPY .p " {" ;
    "    value_t vdst = pop_value();" ;
    "    i64 ilen = pop_i64();" ;
    "    value_t vsrc = pop_value();" ;
    "    void* src = value_ptr(vsrc);" ;
    "    void* dst = value_ptr(vdst);" ;
    "    if (src && dst && (ilen > 0)) {" ;
    "        memcpy(dst, src, (usize)ilen);" ;
    "    }" ;
    "    decref(vsrc);" ;
    "    decref(vdst);" ;
    "}" ;;

    PRIM_PTR_FILL .p " {" ;
    "    value_t vdst = pop_value();" ;
    "    i64 ilen = pop_i64();" ;
    "    i64 val = pop_i64();" ;
    "    void* dst = value_ptr(vdst);" ;
    "    if (dst && (ilen > 0)) {" ;
    "        memset(dst, (int)val, (usize)ilen);" ;
    "    }" ;
    "    decref(vdst);" ;
    "}" ;;

    PRIM_PTR_RAW .pm "do { usize i = stack_counter; push_ptr(value_ptr(stack[i])); } while(0)" ;

    # PRIM_STR_EQ .pm "do { value_t vptr1 = pop_value(); value_t vptr2 = pop_value(); const char* ptr1 = value_ptr(vptr1); const char* ptr2 = value_ptr(vptr2); bool result = (!ptr1 || !ptr2) ? (ptr1 == ptr2) : strcmp(ptr1,ptr2) == 0; push_bool(result); decref(vptr1); decref(vptr2); } while(0)" ;

    PRIM_STR_EQ .p "{" ;
    "    value_t vptr1 = pop_value();" ;
    "    value_t vptr2 = pop_value();" ;
    "    const char* ptr1 = value_ptr(vptr1);" ;
    "    const char* ptr2 = value_ptr(vptr2);" ;
    "    bool result = (!ptr1 || !ptr2) ? (ptr1 == ptr2) : strcmp(ptr1,ptr2) == 0;" ;
    "    push_bool(result);" ;
    "    decref(vptr1); decref(vptr2);" ;
    "}" ;;

    PRIM_STR_ALLOC .p "{" ;
    "    i64 psize = pop_i64();" ;
    "    push_i64(psize + 4);" ;
    "    mwprim_2E_ptr_2E_alloc();" ;
    "}" ;;

    PRIM_STR_BASE .pm "0" ;;

    PRIM_STR_SIZE .pm "do { value_t v = stack[stack_counter]; if (!v.payload.vp_u64) { push_u64(0); } else if (v.tag == VT_U64) { push_u64((u64)strlen(v.payload.vp_ptr)); } else { push_i64(value_ptr_size(v)-4); }  } while(0)" ;;

    "#define do_pack_cons() do { value_t cdr = pop_value(); value_t car = pop_value(); push_value(mkcell(car,cdr)); } while(0)" ;
    PRIM_PACK_NIL .pm " push_u64(0)" ;
    PRIM_PACK_CONS .pm "do_pack_cons();" ;
    PRIM_PACK_UNCONS .pm "do_pack_uncons();" ;;

    PRIM_MUT_NEW .pm "do { value_t car = pop_value(); value_t cdr = { 0 }; push_value(mkcell_raw(car,cdr)); } while(0)" ;
    PRIM_MUT_GET .pm "do { do_pack_uncons(); pop_value(); } while(0)" ;
    PRIM_MUT_SET .pm "do { value_t cellval = pop_value(); value_t newval = pop_value(); push_value(cellval); usize cellidx = get_cell_index(cellval); if (cellidx) { cell_t* cell = heap + cellidx; value_t oldval = cell->car; cell->car = newval; decref(oldval); } else { decref(newval); } } while(0)" ;;
    )

def(c99-emit-externals!, +IO,
    External.for(c99-emit-external!) .lf)

def(c99-emit-external!, External -- +IO,
    external-sig? sig-arity
    dup 2 >= if(
        "can't declare external with multiple return values" panic!,

        dup 1 >= if(
            "i64 " .,
            "void " .
        )
    )

    dip2(external-name? .name)

    " (" .
    over dup 0> if(
        "i64" .
        1- while(dup 0>,
            ", i64" .
            1-
        ) drop,
        drop "void" .
    ) ");" ;

    "static void mw" . dip2(external-name? .name) " (void) {" ;
    over while(dup 0>,
        "    i64 x" . dup .n " = pop_i64();" ;
        1-
    ) drop
    dup 0> if("    push_i64(", "    ") .
    dip2(external-name? .name)
    "(" .
    dip(dup 0> if(
        "x1" .
        dup 1-
        while(dup 0>,
            ", x" .
            dup2 - 1+ .n
            1-
        ) drop,
        id
    ))
    ")" .
    dup 0> if(");", " ;") ;
    "}" ;

    drop3)

def(c99-emit-arrow!, Arrow -- +IO,
    c99-depth++
    arrow-atoms@ for(c99-emit-atom!)
    c99-depth--)

def(c99-emit-atom!, Atom -- +IO,
    atom-op? match(
        OP_NONE -> drop,
        OP_INT ->
            nip
            "    push_i64(" . .n "LL);" ;,
        OP_STR ->
            nip c99-emit-string!,
        OP_WORD ->
            need-word!
            dip(atom-args@ c99-emit-args-push!)
            "    mw" . word-name@ .name "();" ;,
        OP_FIELDWORD ->
            need-fieldword!
            nip fieldword-name@
            "    mw" . .name "();" ;,

        OP_EXTERNAL ->
            dip(atom-args@ c99-emit-args-push!) # this is probably never desirable
            "    mw" . external-name@ .name "();" ;,
        OP_BUFFER ->
            nip buffer-name@
            "    mw" . .name "();" ;,
        OP_VARIABLE ->
            nip variable-name@
            "    mw" . .name "();" ;,
        OP_TAG ->
            nip tag-name@
            "    mw" . .name "();" ;,
        OP_PRIM ->
            dip(atom-args@) c99-emit-prim!,
        OP_MATCH ->
            nip c99-emit-match!,
        OP_LAMBDA ->
            nip c99-emit-lambda!,
        OP_VAR ->
            nip c99-emit-var!,
        OP_BLOCK ->
            nip c99-emit-block-push!,
    ))

def(c99-emit-string!, Str --,
    "    push_ptr(\"" .
    str-for(c99-emit-string-char!)
    "\\0\\0\\0\");" ; # wide sentinel is desirable
    )

def(c99-emit-string-char!, Char --,
    is-backslash? if(
        drop "\\\\" .,
    is-quote? if(
        drop "\\\"" .,
    dup Char->Int 32 127 in-range if(
        .c,
    dup Char->Int 9 == if(
        drop "\\t" .,
    dup Char->Int 10 == if(
        drop "\\n" .,
    dup Char->Int 13 == if(
        drop "\\r" .,

        char-bytes for(
            "\\x" . dup
            U8->Int 4 >> hexdigit .c
            U8->Int 0xF & hexdigit .c
        )
#        "unexpected character in c99 string" panic!
    )))))))

def(c99-emit-prim!, List(Arg) Prim --,
    match(
        PRIM_CORE_DIP ->
            match(
                L1 ->
                    "    { value_t d" . .d " = pop_value();" ;
                    c99-emit-arg-run!
                    "      push_value(d" . .d "); }" ;,
                _ ->
                    PRIM_CORE_DIP c99-emit-prim-default!
            ),

        PRIM_CORE_IF ->
            match(
                L2 ->
                    "    if (pop_u64()) {" ;
                    dip(c99-emit-arg-run!)
                    "    } else {" ;
                    c99-emit-arg-run!
                    "    }" ;,
                _ ->
                    PRIM_CORE_IF c99-emit-prim-default!
            ),

        PRIM_CORE_WHILE ->
            match(
                L2 ->
                    "    while(1) {" ;
                    dip(c99-emit-arg-run!)
                    "    if (!pop_u64()) break;" ;
                    c99-emit-arg-run!
                    "    }" ;,

                _ ->
                    PRIM_CORE_WHILE c99-emit-prim-default!
            ),

        _ -> c99-emit-prim-default!
    ))

def(c99-emit-prim-default!, List(Arg) Prim --,
    dip(c99-emit-args-push!)
    "    mw" . prim-name@ .name "();" ;)

def(c99-emit-args-push!, List(Arg) --,
    reverse-for(c99-emit-arg-push!))

def(c99-emit-arg-push!, Arg --,
    match(
        ARG_BLOCK -> c99-emit-block-push!,
        ARG_VAR_RUN -> c99-emit-var-push!,
    ))

def(c99-emit-arg-run!, Arg --,
    match(
        ARG_BLOCK -> block-arrow@ c99-emit-arrow!,
        ARG_VAR_RUN -> c99-emit-var!,
    ))

def(.var-val, Var -- +IO, "var_" . var-name? .name "_" . Var.id .n)

def(c99-pack-ctx!, Ctx -- +IO,
    "    push_u64(0);" ;
    ctx-physical-vars for(
        c99-emit-var-push!
        "    do_pack_cons();" ;
    ))

def(c99-unpack-ctx!, Ctx -- +IO,
    ctx-physical-vars reverse-for(
        "    do_pack_uncons();" ;
        "    value_t " . .var-val " = pop_value();" ;
        )
    "    do_drop();" ;
    )

def(c99-decref-ctx!, Ctx -- +IO,
    ctx-physical-vars reverse-for(
        "    decref(" . .var-val ");" ;
    ))

data(Need,
    NEED_BLOCK -> Block,
    NEED_WORD -> Word,
    NEED_FIELD -> Field)
var(c99-need-stack, Stack(Need))

field(c99-word-needed, Word, Bool)
def(need-word!, Word -- Word,
    c99-word-needed? if(
        id,
        true over c99-word-needed!
        dup NEED_WORD c99-need-stack stack-push
    ))

def(need-block!, Block -- Block,
    block-needed? if(
        id,
        true over block-needed!
        dup NEED_BLOCK c99-need-stack stack-push
    ))

field(c99-field-needed, Field, Bool)
def(need-field!, Field -- Field,
    c99-field-needed? if(
        id,
        true over c99-field-needed!
        dup NEED_FIELD c99-need-stack stack-push
    ))
def(need-fieldword!, FieldWord -- FieldWord,
    dup unFIELDWORD drop need-field! drop)

def(c99-emit-needs!, --,
    while-some(c99-need-stack stack-pop, c99-emit-need!))

def(c99-emit-need!, Need --,
    match(
        NEED_WORD -> c99-emit-word-def!,
        NEED_BLOCK -> c99-emit-block-def!,
        NEED_FIELD -> c99-emit-field-def!,
    ))

def(c99-emit-block-push!, Block -- +IO,
    need-block!
    block-arrow? arrow-ctx@ c99-pack-ctx!
    "    push_fnptr(&" . .block ");" ;
    "    do_pack_cons();" ;
    )

def(c99-emit-var!, Var -- +IO,
    var-auto-run? dip(c99-emit-var-push!)
    if("    do_run();" ;, id))

def(c99-emit-var-push!, Var -- +IO,
    "    push_value(" . dup .var-val ");" ;
    "    incref(" . .var-val ");" ;
    )

def(c99-emit-lambda!, Lambda -- +IO,
    "    {" ;
    lambda-params? reverse-for(
        "    value_t " . Param->Var .var-val " = pop_value();" ;
        )
    lambda-body? c99-emit-arrow!
    lambda-params@ reverse-for(
        "    decref(" . Param->Var .var-val ");" ;
        )
    "    }" ;)

def(c99-emit-match!, Match -- +IO,
    match-is-transparent? if(
        match-cases? first match(
            NONE -> match-token@
                "codegen: unexpected number of cases in transparent match" emit-fatal-error!,
            SOME ->
                case-body@ c99-emit-arrow! drop
        ),

        "    switch (get_top_data_tag()) {" ;
        match-cases? for(c99-emit-case!)
        match-has-default-case? if(
            id,
            "    default: write(2, \"unexpected fallthrough in match\\n\", 32); do_debug(); exit(99);" ;
        )
        drop
        "    }" ;
    ))

def(c99-emit-case!, Case -- +IO,
    case-pattern? c99-emit-pattern!
    case-body@ c99-emit-arrow!
    "    break;" ;)

def(c99-emit-pattern!, Pattern -- +IO,
    match(
        PATTERN_UNDERSCORE ->
            "    default:" ; ,

        PATTERN_TAG ->
            "    case " . tag-value? .n "LL:" ;
            tag-num-inputs? nip
            dup 0 > if(
                "    do_pack_uncons(); do_drop();" ;
                while(dup 1 >,
                    "    do_pack_uncons(); do_swap();" ;
                    1-)
                drop,
                drop "    do_drop();" ;
            )
    ))

def(c99-emit-word-sigs!, +IO,
    Word.for(c99-emit-word-sig!) .lf)

def(c99-emit-word-sig!, Word -- +IO,
    false over c99-word-needed!
    false over c99-word-emitted!
    " static void mw" . word-name@ .name " (void);" ;)

def(c99-emit-block-sigs!, +IO,
    Block.for(c99-emit-block-sig!) .lf)

def(c99-emit-block-sig!, Block -- +IO,
    false over block-needed!
    false over c99-block-emitted!
    " static void " . .block " (void);" ;)

def(c99-emit-field-sigs!, +IO,
    Field.for(c99-emit-field-sig!) .lf)

def(c99-emit-field-sig!, Field -- +IO,
    false over c99-field-needed!
    false over c99-field-emitted!
    " static void mw" . field-name? "@" name-cat! .name " (void);" ;
    " static void mw" . field-name? "?" name-cat! .name " (void);" ;
    " static void mw" . field-name@ "!" name-cat! .name " (void);" ;)

def(c99-emit-block-defs!, +IO,
    Block.for(c99-emit-block-def!) .lf)

field(c99-block-emitted, Block, Bool)
def(c99-emit-block-def!, Block -- +IO,
    block-needed? if(
        c99-block-emitted? if(
            drop,

            true over c99-block-emitted!
            "static void " . dup .block " (void) {" ;
            block-arrow@
            arrow-ctx? c99-unpack-ctx!
            dup c99-emit-arrow!
            arrow-ctx@ c99-decref-ctx!
            "}" ;
        ),
        drop
    ))

def(.block, Block -- +IO,
    "mb_" .
    block-arrow? arrow-home? is-nil? if(
        drop2 Block.id .n,
        word-name@ .name "_" .
        arrow-homeidx@ .n drop
    ))

field(c99-word-emitted, Word, Bool)
def(c99-emit-word-def!, Word -- +IO,
    c99-word-needed? if(
        c99-word-emitted? if(
            drop,

            true over c99-word-emitted!
            word-name? .w "{" ;
            word-arrow@ force c99-emit-arrow!
            "}" ;;
        ),
        drop
    ))

field(c99-field-emitted, Field, Bool)
def(c99-emit-field-def!, Field -- +IO,
    c99-field-needed? if(
        c99-field-emitted? if(
            drop,

            true over c99-field-emitted!
            "static value_t* fieldptr_" . field-name? .name " (usize i) {" ;
            "    static struct value_t * p;" ;
            "    static usize n = 0; " ;
            "    if (i >= n) {" ;
            "        usize new_n = n+1;" ;
            "        while (i >= new_n) new_n *= 2;" ;
            "        p = realloc(p, sizeof(struct value_t) * new_n);" ;
            "        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));" ;
            "        n = new_n;" ;
            "    }" ;
            "    return p+i;" ;
            "}" ;;
            field-name? "@" name-cat! .w "{" ;
            "    usize index = (usize)pop_u64();" ;
            "    value_t v = *fieldptr_" . field-name? .name "(index);" ;
            "    incref(v); push_value(v);" ;
            "}" ;
            field-name? "?" name-cat! .w "{" ;
            "    mwdup();" ;
            "    usize index = (usize)pop_u64();" ;
            "    value_t v = *fieldptr_" . field-name? .name "(index);" ;
            "    incref(v); push_value(v);" ;
            "}" ;

            field-name? "!" name-cat! .w "{" ;
            "    usize index = (usize)pop_u64();" ;
            "    value_t newvalue = pop_value();" ;
            "    value_t* p = fieldptr_" . field-name? .name "(index);" ;
            "    value_t oldvalue = *p;" ;
            "    *p = newvalue;" ;
            "    decref(oldvalue);" ;
            "}" ;;

            drop
        ),
        drop
    ))

def(c99-emit-main!, Arrow -- +IO,
    "int main (int argc, char** argv) {" ;
    "    global_argc = argc;" ;
    "    global_argv = argv;" ;
    c99-emit-arrow!
    "    return 0;" ;
    "}" ;
    )
