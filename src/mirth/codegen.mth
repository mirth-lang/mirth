module(mirth.codegen)
import(prelude)
import(platform.posix)
import(data.str)
import(data.stack)
import(data.path)
import(data.list)
import(data.lazy)
import(data.byte)
import(data.maybe)
import(mirth.data.error)
import(mirth.data.module)
import(mirth.data.location)
import(mirth.data.token)
import(mirth.data.name)
import(mirth.data.buffer)
import(mirth.data.arrow)
import(mirth.data.word)
import(mirth.data.table)
import(mirth.data.variable)
import(mirth.data.external)
import(mirth.data.constant)
import(mirth.data.ctx)
import(mirth.data.type)
import(mirth.data.prim)
import(mirth.data.var)
import(mirth.elab)

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)
var(codegen-file, File)
var(codegen-length, Size)
buffer(CODEGEN_BUF, 0x2000)
data(Need,
    NEED_WORD -> Word,
    NEED_BLOCK -> Block)

var(needs-stack, Stack(Need))
field(word-needed, Word, Bool)
field(block-needed, Block, Bool)
def(reset-needs!, --,
    Block.for(F swap block-needed !)
    Word.for(F swap word-needed !)
    needs-stack stack-reset!)
def(for-needed-words(f), (*a Word -- *a) *a -- *a,
    Word.for(dup word-needed @ if(f, drop)))
def(for-needed-blocks(f), (*a Block -- *a) *a -- *a,
    Block.for(dup block-needed @ if(f, drop)))

def(need-block, Block --,
    dup block-needed @ if(
        drop,
        T over block-needed !
        NEED_BLOCK needs-stack stack-push!
    ))
def(need-word, Word --,
    dup word-needed @ if(
        drop,
        T over word-needed !
        NEED_WORD needs-stack stack-push!
    ))

def(determine-arrow-needs!, Arrow --,
    need-arrow-run determine-transitive-needs!)
def(determine-transitive-needs!, --,
    while-some(needs-stack stack-pop!, match(
        NEED_BLOCK -> need-block-run,
        NEED_WORD -> word-arrow force! need-arrow-run,
    )))

def(need-arrow-run, Arrow --,
    arrow-atoms @ for(need-atom-run))
def(need-atom-run, Atom --,
    sip(atom-args @) atom-op @ match(
        OP_NONE -> drop,
        OP_INT -> drop2,
        OP_STR -> drop2,
        OP_CONSTANT -> drop2,
        OP_WORD -> need-word need-args-push,
        OP_EXTERNAL -> drop need-args-push,
        OP_BUFFER -> drop need-args-push,
        OP_VARIABLE -> drop need-args-push,
        OP_FIELD -> drop need-args-push,
        OP_TAG -> drop need-args-push,
        OP_PRIM -> need-prim,
        OP_MATCH -> nip need-match,
        OP_LAMBDA -> nip need-lambda,
        OP_VAR -> drop2,
        OP_BLOCK -> nip need-block-push
    ))
def(need-args-push, List(Arg) --, for(need-arg-push))
def(need-arg-push, Arg --, ARG_BLOCK -> need-block-push)
def(need-arg-run, Arg --, ARG_BLOCK -> need-block-run)

def(need-prim, List(Arg) Prim --,
    PRIM_CORE_DIP ->
        match(
            L1 -> need-arg-run,
            _ -> need-args-push
        ),
    PRIM_CORE_IF ->
        match(
            L2 -> dip(need-arg-run) need-arg-run,
            _ -> need-args-push
        ),
    PRIM_CORE_WHILE ->
        match(
            L2 -> dip(need-arg-run) need-arg-run,
            _ -> need-args-push
        ),
    _ -> drop need-args-push)

def(need-match, Match --, match-cases @ for(case-body @ need-arrow-run))
def(need-lambda, Lambda --, lambda-body @ need-arrow-run)

def(need-block-push, Block --,
    dup block-to-run-var match(
        SOME -> drop2,
        NONE -> need-block
    ))
def(need-block-run, Block --,
    block-arrow force! need-arrow-run)

def(codegen-full?, Bool,
    codegen-length @ 4 + CODEGEN_BUF_SIZE int>=)

def(codegen-flush!, --,
    codegen-length @ 0 int> if(
        codegen-file @ File->Int CODEGEN_BUF codegen-length @
        posix-write!
        expect!(dup 0 int>, "codegen write failed")
        expect!(dup codegen-length @ int==, "codegen wrote fewer bytes than expected")
        drop
        0 codegen-length !,
        id
    ))

def(.b, Byte --,
    Byte->U8
    codegen-full? if(codegen-flush!, id)
    codegen-length modify(dup 1+)
    CODEGEN_BUF u8!!)

def(., Str --,
    dup prim-str-base over str-num-bytes
    dup codegen-length @ + CODEGEN_BUF_SIZE int> if(
        codegen-flush!
        while(dup CODEGEN_BUF_SIZE int>,
            over CODEGEN_BUF_SIZE CODEGEN_BUF prim-ptr-copy
            CODEGEN_BUF_SIZE codegen-length !
            codegen-flush!
            dip(CODEGEN_BUF_SIZE swap ptr+)
            CODEGEN_BUF_SIZE -
        )
        dup codegen-length ! CODEGEN_BUF prim-ptr-copy,

        sip(codegen-length @ CODEGEN_BUF ptr+ prim-ptr-copy)
        codegen-length modify(+)
    ) drop)

def(codegen-start!, File --,
    codegen-file ! 0 codegen-length !)

def(codegen-end!, --,
    codegen-flush!
    codegen-file @ close-file!
    stdout codegen-file !
    0 codegen-length !)

def(run-output-c99!, Arrow Path --,
    num-errors @ 0 int> if(
        drop2,

        reset-needs!
        over determine-arrow-needs!

        0 c99-depth !
        make-output-path Path->Str
        create-file! codegen-start!
        c99-header!
        c99-tags!
        c99-buffers!
        c99-variables!
        c99-externals!
        c99-word-sigs!
        c99-block-sigs!
        c99-field-sigs!
        c99-main!
        c99-field-defs!
        c99-word-defs!
        c99-block-defs!
        codegen-end!
    ))

var(c99-depth, Int)

def(.lf, --, BLF .b)
def(;, Str --, . .lf)
def(;;, Str --, . .lf .lf)
def(.n, Int --, int-to-str .)
def(.name, Name --, name-mangle! .)

def(.w, Name --, "static void mw_" . .name " (void)" .)
def(.p, Prim --, prim-name @ .w)
def(.pm, Prim --, "#define mw_" . prim-name @ .name "() " .)

embed-str(c99-header-str, "src/mirth/mirth.h")
def(c99-header!, --, c99-header-str . .lf)

def(c99-buffers!, --, Buffer.for(c99-buffer!) .lf)
def(c99-buffer!, Buffer --,
    dup buffer-name @ .w " {" ;
    "    static uint8_t b[" . dup buffer-size @ .n "] = {0};" ;
    "    push_ptr(&b);" ;
    "}" ;
    drop)

def(c99-variables!, --, Variable.for(c99-variable!) .lf)
def(c99-variable!, Variable --,
    "void mw_" . variable-name @ .name "() {" ;
    "    static VAL v = {0};" ;
    "    push_ptr(&v);" ;
    "}" ;)

def(c99-tags!, --, Tag.for(c99-tag!) .lf)
def(c99-tag!, Tag --,
    dup tag-name @ .w " {" ;
    tag-is-transparent? if(
        drop,
        tag-num-inputs? 0 int== if(
            "    push_u64(" . tag-value @ .n "LL);" ;,

            "    VAL car = pop_value();" ;
            tag-num-inputs? 1- repeat("    car = mkcons(car, pop_value());" ;)
            "    VAL tag = MKU64(" . tag-value @ .n "LL);" ;
            "    car = mkcons(car, tag);" ;
            "    push_value(car);" ;
        )
    )
    "}" ;)

def(c99-externals!, --,
    External.for(c99-external!) .lf)

def(c99-external!, External --,
    dup external-sig @ sig-arity
    dup 2 int>= if(
        "can't declare external with multiple return values" panic!,

        dup 1 int>= if(
            "int64_t " .,
            "void " .
        )
    )

    dip2(dup external-name @ name-str @ .)

    " (" .
    over dup 0> if("int64_t" . 1- repeat(", int64_t" .), drop "void" .)
    ");" ;

    "static void mw_" . dip2(dup external-name @ .name) " (void) {" ;
    over countdown("    int64_t x" . .n " = pop_i64();" ;)
    dup 0> if("    push_i64(", "    ") .
    dip2(dup external-name @ name-str @ .)
    "(" .
    dip(dup 0> if(
        dup 1- dup count("x" . .n ", " .) "x" . .n,
        id
    ))
    ")" .
    dup 0> if(");", ";") ;
    "}" ;
    drop3)

def(c99-nest(f), (*a -- *b) *a -- *b,
    c99-depth modify(1+)
    f
    c99-depth modify(1-))

def(c99-indent, --, c99-depth @ repeat("    " .))
def(c99-line(f), (*a -- *b) *a -- *b, c99-indent f .lf)

def(c99-call!, List(Arg) Name --,
    dip(c99-args-push!)
    c99-line("mw_" . .name "();" .))

def(c99-arrow!, Arrow --,
    arrow-atoms @ for(c99-atom!))

def(c99-atom!, Atom --,
    c99-line("WORD_ATOM(" .
        dup atom-token @ token-row @ Row->Int .n ", " .
        dup atom-token @ token-col @ Col->Int .n ", " .
        dup atom-token @ token-is-name? if(
            token-name@ name-str @ .str,
            drop "\"\"" .)
        ");" .)
    sip(atom-args @) atom-op @
    c99-args-op!)

def(c99-args-op!, List(Arg) Op --,
    OP_NONE     -> drop,
    OP_INT      -> nip c99-int!,
    OP_STR      -> nip c99-str!,
    OP_CONSTANT -> nip c99-constant!,
    OP_WORD     -> dup need-word word-name @ c99-call!,
    OP_EXTERNAL -> external-name @ c99-call!,
    OP_BUFFER   -> buffer-name   @ c99-call!,
    OP_VARIABLE -> variable-name @ c99-call!,
    OP_FIELD    -> field-name    @ c99-call!,
    OP_TAG      -> tag-name      @ c99-call!,
    OP_PRIM     -> c99-prim!,
    OP_MATCH    -> nip c99-match!,
    OP_LAMBDA   -> nip c99-lambda!,
    OP_VAR      -> nip c99-var!,
    OP_BLOCK    -> nip c99-block-push!)

def(c99-int!, Int --,
    c99-line("push_i64(" . .n "LL);" .))

def(c99-str!, Str --,
    c99-line("{" .)
    c99-nest(
        c99-line("static bool vready = false;" .)
        c99-line("static VAL v;" .)
        c99-line("if (! vready) {" .)
        c99-nest(
            dup str-num-bytes 4090 int> if(
                "static uint8_t b[] = {" .
                c99-nest(
                    c99-indent dup str-bytes-for(
                        Byte->Int dup .n "," .
                        10 int== if(.lf c99-indent, id)
                    ) .lf
                )
                c99-line("};" .)
                c99-line("v = mkstr((char*)b, " . dup str-num-bytes .n ");" .),
                c99-line("v = mkstr(" . dup .str ", " . dup str-num-bytes .n ");" .)
            )
            c99-line("vready = true;" .)
        )
        c99-line("}" .)
        c99-line("push_value(v);" .)
        c99-line("incref(v);" .)
    )
    c99-line("}" .)
    drop)

def(.str, Str --, "\"" . str-bytes-for(c99-string-byte!) "\"" .)

def(c99-string-byte!, Byte --,
    B'\' -> "\\\\" .,
    BQUOTE -> "\\\"" .,
    BHT -> "\\t" ., 
    BLF -> "\\n" .,
    BCR -> "\\r" .,
    _ -> 
        dup BSPACE B'~' byte-in-range if(
            .b,
            "\\x" . byte-to-hexdigits dip(.b) .b
        )
    )

def(c99-constant!, Constant --,
    constant-value @ c99-value!)

def(c99-value!, Value --,
    VALUE_INT -> c99-int!,
    VALUE_STR -> c99-str!,
    VALUE_BLOCK -> c99-block-push!)

def(c99-prim!, List(Arg) Prim --,
    PRIM_CORE_DIP ->
        match(
            L1 ->
                c99-line("{" .)
                c99-nest(
                    c99-line("VAL d" . c99-depth @ .n " = pop_value();" .)
                    c99-arg-run!
                    c99-line("push_value(d" . c99-depth @ .n ");" .)
                )
                c99-line("}" .),
            _ ->
                PRIM_CORE_DIP c99-prim-default!
        ),

    PRIM_CORE_IF ->
        match(
            L2 ->
                c99-line("if (pop_u64()) {" .)
                c99-nest(swap c99-arg-run!)
                c99-line("} else {" .)
                c99-nest(c99-arg-run!)
                c99-line("}" .),
            _ ->
                PRIM_CORE_IF c99-prim-default!
        ),

    PRIM_CORE_WHILE ->
        match(
            L2 ->
                c99-line("while(1) {" .)
                c99-nest(
                    swap c99-arg-run!
                    c99-line("if (! pop_u64()) break;" .)
                    c99-arg-run!
                )
                c99-line("}" .),

            _ ->
                PRIM_CORE_WHILE c99-prim-default!
        ),

    _ -> c99-prim-default!)

def(c99-prim-default!, List(Arg) Prim --,
    prim-name @ c99-call!)

def(c99-args-push!, List(Arg) --,
    for(c99-arg-push!))

def(c99-arg-push!, Arg --,
    ARG_BLOCK -> c99-block-push!)

def(c99-arg-run!, Arg --,
    ARG_BLOCK -> c99-block-run!)

def(c99-block-run!, Block --,
    block-arrow force! c99-arrow!)

def(.var, Var --, "var_" . var-name @ .name)
def(.param, Param --, Param->Var .var)

def(c99-pack-ctx!, Ctx --,
    c99-line("push_u64(0);" .)
    ctx-physical-vars for(
        c99-var-push!
        c99-line("mw_prim_pack_cons();" .)
    ))

def(c99-unpack-ctx!, Ctx --,
    ctx-physical-vars reverse-for(
        c99-line("mw_prim_pack_uncons();" .)
        c99-line("VAL " . .var " = pop_value();" .)
    )
    c99-line("mw_prim_drop();" .))

def(c99-decref-ctx!, Ctx --,
    ctx-physical-vars reverse-for(
        c99-line("decref(" . .var ");" .)
    ))

def(c99-block-push!, Block --,
    dup block-to-run-var match(
        SOME -> nip c99-var-push!,
        NONE ->
            dup need-block
            dup block-arrow force! arrow-ctx @ c99-pack-ctx!
            c99-line("push_fnptr(&" . .block ");" .)
            c99-line("mw_prim_pack_cons();" .)
    ))

def(c99-var!, Var --,
    dup var-auto-run @ if(c99-var-run!, c99-var-push!))

def(c99-var-run!, Var --,
    c99-line("incref(" . dup .var ");" .)
    c99-line("run_value(" . dup .var ");" .)
    drop)

def(c99-var-push!, Var --,
    c99-line("incref(" . dup .var ");" .)
    c99-line("push_value(" . dup .var ");" .)
    drop)

def(c99-lambda!, Lambda --,
    c99-line("{" .)
    c99-nest(
        dup lambda-params @ reverse-for(
            c99-line("VAL " . .param " = pop_value();" .)
        )
        dup lambda-body @ c99-arrow!
        lambda-params @ reverse-for(
            c99-line("decref(" . .param ");" .)
        )
    )
    c99-line("}" .))

def(c99-match!, Match --,
    match-is-transparent? if(
        dup match-cases @ first match(
            NONE -> match-token @
                "codegen: unexpected number of cases in transparent match" emit-fatal-error!,
            SOME ->
                case-body @ c99-arrow! drop
        ),

        c99-line("switch (get_top_data_tag()) {" .)
        c99-nest(
            dup match-cases @ for(c99-case!)
            match-has-default-case? if(
                id,
                c99-line("default: write(2, \"unexpected fallthrough in match\\n\", 32); mw_prim_debug(); exit(99);" .)
            )
            drop
        )
        c99-line("}").
    ))

def(c99-case!, Case --,
    dup case-pattern @ c99-pattern!
    c99-nest(
        case-body @ c99-arrow!
        c99-line("break;" .)
    ))

def(c99-pattern!, Pattern --,
    PATTERN_UNDERSCORE ->
        c99-line("default:" .),

    PATTERN_TAG ->
        c99-line("case " . dup tag-value @ .n "LL:" .)
        c99-nest(
            tag-num-inputs? nip dup 0 int> if(
                c99-line("mw_prim_pack_uncons(); mw_prim_drop();" .)
                1- repeat(c99-line("mw_prim_pack_uncons(); mw_prim_swap();" .)),
                drop c99-line("mw_prim_drop();" .)
            )
        )
    )

def(c99-word-sigs!, --, for-needed-words(c99-word-sig!) .lf)
def(c99-word-sig!, Word --,
    c99-line("static void mw_" . word-name @ .name " (void);" .))

def(c99-block-sigs!, --, for-needed-blocks(c99-block-sig!) .lf)
def(c99-block-sig!, Block --,
    c99-line("static void " . .block " (void);" .))

def(c99-field-sigs!, --, Field.for(c99-field-sig!) .lf)
def(c99-field-sig!, Field --,
    c99-line("static void mw_" . field-name @ .name " (void);" .))

def(c99-block-enter!, Block --,
    c99-line("WORD_ENTER(" .
        dup .block ", " .
        dup block-arrow force! arrow-home @ match(
            NONE -> "block",
            SOME -> word-name @ name-str @ " block" str-cat,
        ) .str ", " .
        dup block-token @ token-module @ module-source-path Path->Str .str ", " .
        dup block-token @ token-row @ Row->Int .n ", " .
        dup block-token @ token-col @ Col->Int .n ");" . )
    drop)

def(c99-block-exit!, Block --,
    c99-line("WORD_EXIT(" . .block ");" .))

def(c99-block-defs!, --, for-needed-blocks(c99-block-def!) .lf)
def(c99-block-def!, Block --,
    c99-line("static void " . dup .block " (void) {" .)
    c99-nest(
        dup c99-block-enter!
        dup block-arrow force!
        dup arrow-ctx @ c99-unpack-ctx!
        dup c99-arrow!
        arrow-ctx @ c99-decref-ctx!
        c99-block-exit!
    )
    c99-line("}" .) .lf)

def(.block, Block -- ,
    "mb_" .
    dup block-arrow force! dup arrow-home @ match(
        NONE -> drop Block.id .n,
        SOME ->
            word-name @ .name "_" .
            arrow-homeidx @ .n drop
    ))

def(c99-word-enter!, Word --,
    c99-line("WORD_ENTER(" .
        "mw_" . dup word-name @ .name ", " .
        dup word-name @ name-str @ .str ", " .
        dup word-body @ token-module @ module-source-path Path->Str .str ", " .
        dup word-body @ token-row @ Row->Int .n ", " .
        dup word-body @ token-col @ Col->Int .n ");" . )
    drop)

def(c99-word-exit!, Word --,
    c99-line("WORD_EXIT(" .
        "mw_" . dup word-name @ .name ");" .)
    drop)

def(c99-word-defs!, --, for-needed-words(c99-word-def!) .lf)
def(c99-word-def!, Word --,
    c99-line(dup word-name @ .w "{" .)
    c99-nest(
        dup c99-word-enter!
        dup word-arrow force! c99-arrow!
        dup c99-word-exit!
    )
    c99-line("}" .)
    drop)

def(c99-field-defs!, --, Field.for(c99-field-def!) .lf)
def(c99-field-def!, Field --,
    "static VAL* fieldptr_" . dup field-name @ .name " (size_t i) {" ;
    "    static struct VAL * p = 0;";
    "    size_t m = " . TABLE_MAX_SIZE .n ";" ;
    "    if (! p) { p = calloc(m, sizeof *p); }" ;
    "    if (i>=m) { write(2,\"table too big\\n\",14); exit(123); }" ;
    "    return p+i;" ;
    "}" ;;  # TODO make this more flexible wrt table size
            # note it's important to have stability,
            # so we can't just realloc as we used to.
    dup field-name @ .w "{" ;
    "    size_t index = (size_t)pop_u64();" ;
    "    VAL *v = fieldptr_" . dup field-name @ .name "(index);" ;
    "    push_ptr(v);" ;
    "}" ;;

    drop)

def(c99-main!, Arrow --,
    c99-line("int main (int argc, char** argv) {" .)
    c99-nest(
        c99-line("global_argc = argc;" .)
        c99-line("global_argv = argv;" .)
        c99-line("WORD_ENTER(" .
            "(void(*)(void))0, " .
            "\"<main>\", " .
            dup arrow-token-start @ token-module @
                module-source-path Path->Str .str ", " .
            dup arrow-token-start @ token-row @ Row->Int .n ", " .
            dup arrow-token-start @ token-col @ Col->Int .n ");" .)
        c99-arrow!
        c99-line("WORD_EXIT((void(*)(void))0);" .)
        c99-line("return 0;" .)
    )
    c99-line("}" .))
