module(mirth/codegen)
import(prelude)
import(mirth/data/token)
import(mirth/data/name)
import(mirth/data/word)
import(mirth/data/external)
import(mirth/data/buffer)
import(mirth/data/arrow)

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)
buffer(CODEGEN_FILE, 8)
buffer(CODEGEN_LENGTH, 8)
buffer(CODEGEN_BUF, 0x2000)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE file@)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE file!)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH int@)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH int!)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ File->Int CODEGEN_BUF codegen-length@
        posix-write! dup 0 < if(
            "error: codegen write failed" caststr panic!,
            codegen-length@ < if(
                "error: codegen write wrote fewer bytes than expected" caststr panic!,
                0 codegen-length!
            )
        ),
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup str-head U8->Int nonzero, dup str-head .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    stdout codegen-file!
    0 codegen-length!)

def(run-output-c99!, Arrow Path -- +IO,
    num-errors@ 0 > if(
        drop2,

        load-output-path!
        STR_BUF Ptr->Str create-file! codegen-start!
            # FIXME: implement and use create-binary-file!
            # instead of create-file! here ... perhaps
        c99-emit-header!
        c99-emit-strings!
        c99-emit-prims!
        c99-emit-tags!
        c99-emit-buffers!
        c99-emit-externals!
        c99-emit-word-sigs!
        c99-emit-block-sigs!
        c99-emit-word-defs!
        c99-emit-block-defs!
        c99-emit-main!
        codegen-end!
    ))

buffer(C99_DEPTH, 8)
def(c99-depth@, -- Int +Codegen, C99_DEPTH int@)
def(c99-depth!, Int -- +Codegen, C99_DEPTH int!)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, str-buf-int! STR_BUF Ptr->Str .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! STR_BUF Ptr->Str .)

def(.w, Name -- +IO, "static void mw" caststr . .name " (void)" caststr .)
def(.p, Prim -- +IO, prim-name@ .w)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" caststr ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" caststr ;
    "#define MIRTH_WINDOWS 1" caststr ;
    "#elif defined(__linux__)" caststr ;
    "#define MIRTH_LINUX 1" caststr ;
    "#elif defined(__APPLE__)" caststr ;
    "#define MIRTH_MACOS 1" caststr ;
    "#else" caststr ;
    "#error \"Platform not supported.\"" caststr ;
    "#endif" caststr ;;

    "#include <stdint.h>" caststr ;
    "#include <stdbool.h>" caststr ;;

    "typedef uint8_t u8;" caststr ;
    "typedef uint16_t u16;" caststr ;
    "typedef uint32_t u32;" caststr ;
    "typedef uint64_t u64;" caststr ;
    "typedef int8_t i8;" caststr ;
    "typedef int16_t i16;" caststr ;
    "typedef int32_t i32;" caststr ;
    "typedef int64_t i64;" caststr ;
    "typedef uintptr_t usize;" caststr ;;

    "extern void* mmap(void*, int, int, int, int, int);" caststr ;
    "extern void* malloc(usize);" caststr ;
    "extern void* calloc(usize, usize);" caststr ;
    "extern void free(void*);" caststr ;
    "extern usize strlen(const char*);" caststr ;
    "extern int read(int, void*, usize);" caststr ;
    "extern int write(int, void*, usize);" caststr ;
    "extern int close(int);" caststr ;
    "extern int open(void*, int, int);" caststr ;
    "extern void exit(int);" caststr ;;

    "typedef enum value_tag_t {" caststr ;
    "   VT_U64 = 0x00," caststr ; # u64
    "   VT_U32 = 0x01," caststr ; # u32 u32
    "   VT_U21 = 0x02," caststr ; # u21 u21 u21
    "   VT_U16 = 0x03," caststr ; # u16 u16 u16 u16
    "   VT_C16 = 0x04," caststr ; # c16 u16 u16 u16
    "   VT_C21 = 0x05," caststr ; # c21 u21 u21
    "   VT_C32 = 0x06," caststr ; # c32 u32
    "   VT_C64 = 0x07," caststr ; # c64
    "} value_tag_t;" caststr ;;

    "typedef void (*fnptr)(void);" caststr ;;

    "typedef union value_payload_t {" caststr ;
    "    void* vp_ptr;" caststr ;
    "    u8 vp_u8;" caststr ;
    "    u16 vp_u16;" caststr ;
    "    u32 vp_u32;" caststr ;
    "    u64 vp_u64;" caststr ;
    "    i8 vp_i8;" caststr ;
    "    i16 vp_i16;" caststr ;
    "    i32 vp_i32;" caststr ;
    "    i64 vp_i64;" caststr ;
    "    bool vp_bool;" caststr ;
    "    fnptr vp_fnptr;" caststr ;
    "} value_payload_t;" caststr ;;

    "typedef struct value_t {" caststr ;
    "   value_payload_t payload;" caststr ;
    "   value_tag_t tag; " caststr ;
    "} value_t; " caststr ;;

    "typedef struct cell_t {" caststr ;
    "   u32 refs;" caststr ; # reference count
    "   bool freecdr;" caststr ; # call "free" on cdr
    "   value_t car;" caststr ;
    "   value_t cdr;" caststr ;
    "} cell_t;" caststr ;;

    "#define STACK_SIZE 0x1000" caststr ;
    "static usize stack_counter = STACK_SIZE;" caststr ;
    "static value_t stack [STACK_SIZE] = {0};" caststr ;;

    "#define HEAP_SIZE 0x80000" caststr ;
    "#define HEAP_MASK 0x7FFFF" caststr ;
    "static usize heap_next = 1;" caststr ;
    "static usize heap_count = 0;" caststr ;
    "static cell_t heap [HEAP_SIZE] = {0};" caststr ;;

    "static int global_argc;" caststr ;
    "static char** global_argv;" caststr ;;
    )

def(c99-emit-strings!, +IO,
    "#define STRINGS_SIZE " caststr . strings-size@ .n "" caststr ;
    "static const char strings[STRINGS_SIZE] = { " caststr ;
    0
    while(dup strings-size@ <,
        dup STRINGS_BUF u8@@ U8->Int dup .n "," caststr . nonzero
        if(id, .lf)
        1+
    ) drop
    "};" caststr ;;)

def(c99-emit-buffers!, +IO,
    1
    while(dup Buffer.NUM int@ <=,
        dup Int->Buffer c99-emit-buffer!
        1+)
    .lf drop)

def(c99-emit-buffer!, Buffer -- +IO,
    " static u8 b" caststr . buffer-name? .name "[" caststr . buffer-size? .n "] = {0};" caststr ;
    " static void mw" caststr . buffer-name? .name " (void) { push_ptr((void*)b" caststr . buffer-name@ .name "); }" caststr ;)

def(c99-emit-tags!, +IO,
    1
    while(dup Tag.NUM int@ <=,
        dup Int->Tag c99-emit-tag!
        1+)
    drop)

def(c99-emit-tag!, Tag -- +IO,
    "static void mw" caststr . tag-name? .name " (void) {" caststr ;
    tag-is-transparent? if(
        drop,
        tag-num-inputs? 0 == if(
            "    push_u64(" caststr . tag-value@ .n "LL);" caststr ;,

            "    value_t car = pop_value();" caststr ;
            tag-num-inputs? 1-
            while(dup 0 >, "    car = mkcell(car, pop_value());" caststr ;  1-) drop
            "    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = " caststr . tag-value@ .n "LL } };" caststr ;
            "    car = mkcell(car, tag);" caststr ;
            "    push_value(car);" caststr ;
        )
    )
    "}" caststr ;;)

def(c99-emit-prims!, +IO,
    "static usize get_cell_index (value_t v) {" caststr ;
    "    switch (v.tag) {" caststr ;
    "        case VT_C64: return (usize)v.payload.vp_u64;" caststr ;
    "        case VT_C32: return (usize)(v.payload.vp_u64 >> 32);" caststr ;
    "        case VT_C21: return (usize)(v.payload.vp_u64 >> 42);" caststr ;
    "        case VT_C16: return (usize)(v.payload.vp_u64 >> 48);" caststr ;
    "        default: return 0;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static void incref (value_t v) {" caststr ;
    "    usize cell_index = get_cell_index(v);" caststr ;
    "    if (cell_index) {" caststr ;
    "        cell_t *cell = heap + cell_index;" caststr ;
    "        cell->refs++;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static void decref (value_t v) { " caststr ;
    "    usize cell_index;" caststr ;
    "    while ((cell_index = get_cell_index(v))) {" caststr ;
    "        cell_t *cell = heap + cell_index;" caststr ;
    "        if (cell->refs >= 1) {" caststr ;
    "            cell->refs--;" caststr ;
    "            if (cell->refs == 0) {" caststr ;
    "                value_t car = cell->car;" caststr ;
    "                value_t cdr = cell->cdr;" caststr ;
    "                bool freecdr = cell->freecdr;" caststr ;
    "                cell->freecdr = false;" caststr ;
    "                cell->car.tag = 0; cell->car.payload.vp_u64 = 0;" caststr ;
    "                cell->cdr.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" caststr ;
    "                heap_next = cell_index;" caststr ;
    "                heap_count--;" caststr ;
    "                if (freecdr && cell->cdr.tag == VT_U64) {" caststr ;
    "                    free(cdr.payload.vp_ptr);" caststr ;
    "                } else {" caststr ;
    "                    decref(cdr);" caststr ;
    "                }" caststr ;
    "                v = car;" caststr ;
    "            } else {" caststr ;
    "                break;" caststr ;
    "            }" caststr ;
    "        } else {" caststr ;
    "            break;" caststr ;
    "        }" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    ||| Decrement reference after a cons. This is equivalent to:
    |||     incref(car), incref(cdr), decref(cell)
    ||| but it avoids unnecessary increfs/decrefs on the car/cdr.
    "static void decref_for_uncons (value_t v) { " caststr ;
    "    usize cell_index = get_cell_index(v);" caststr ;
    "    cell_t *cell = heap + cell_index;" caststr ;
    "    if (cell->refs >= 1) {" caststr ;
    "        cell->refs--;" caststr ;
    "        if (cell->refs == 0) {" caststr ;
    "            cell->cdr.tag = 0; cell->car.payload.vp_u64 = 0;" caststr ;
    "            cell->car.tag = 0; cell->cdr.payload.vp_u64 = heap_next;" caststr ;
    "            heap_next = cell_index;" caststr ;
    "            heap_count--;" caststr ;
    "        } else {" caststr ;
    "            incref(cell->car);" caststr ;
    "            incref(cell->cdr);" caststr ;
    "        }" caststr ;
    "    }" caststr ;
    "}" caststr ;;


    "static void value_uncons(value_t val, value_t* car, value_t* cdr) {" caststr ;
    "    switch (val.tag) {" caststr ;
    "        case VT_U64: {" caststr ;
    "            value_t nil = { 0 };" caststr ;
    "            *car = nil;" caststr ;
    "            *cdr = val;" caststr ;
    "        } break;" caststr ;
    "        case VT_U32: {" caststr ;
    "            u64 vv = val.payload.vp_u64;" caststr ;
    "            u64 lo = vv & 0xFFFFFFFF;" caststr ;
    "            u64 hi = vv >> 32;" caststr ;
    "            car->tag = VT_U64; car->payload.vp_u64 = hi;" caststr ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" caststr ;
    "        } break;" caststr ;
    "        case VT_C64: {" caststr ;
    "            cell_t* cell = heap + val.payload.vp_u64;" caststr ;
    "            *car = cell->car;" caststr ;
    "            *cdr = cell->cdr;" caststr ;
    "        } break;" caststr ;
    "        case VT_C32: {" caststr ;
    "            u64 vv = val.payload.vp_u64;" caststr ;
    "            u64 lo = vv & 0xFFFFFFFF;" caststr ;
    "            u64 hi = vv >> 32;" caststr ;
    "            car->tag = VT_C64; car->payload.vp_u64 = hi;" caststr ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" caststr ;
    "        } break;" caststr ;
    "        case VT_U21: {" caststr ;
    "            u64 vv = val.payload.vp_u64;" caststr ;
    "            u64 lo = vv & 0x1FFFFF;" caststr ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" caststr ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" caststr ;
    "            car->tag = VT_U32;" caststr ;
    "            car->payload.vp_u64 = (hi << 32) | md;" caststr ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" caststr ;
    "        } break;" caststr ;
    "        case VT_C21: {" caststr ;
    "            u64 vv = val.payload.vp_u64;" caststr ;
    "            u64 lo = vv & 0x1FFFFF;" caststr ;
    "            u64 md = (vv >> 21) & 0x1FFFFF;" caststr ;
    "            u64 hi = (vv >> 42) & 0x1FFFFF;" caststr ;
    "            car->tag = VT_C32;" caststr ;
    "            car->payload.vp_u64 = (hi << 32) | md;" caststr ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" caststr ;
    "        } break;" caststr ;
    "        case VT_U16: {" caststr ;
    "            u64 vv = val.payload.vp_u64;" caststr ;
    "            u64 lo = vv & 0xFFFF;" caststr ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" caststr ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" caststr ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" caststr ;
    "            car->tag = VT_U21;" caststr ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" caststr ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" caststr ;
    "        } break;" caststr ;
    "        case VT_C16: {" caststr ;
    "            u64 vv = val.payload.vp_u64;" caststr ;
    "            u64 lo = vv & 0xFFFF;" caststr ;
    "            u64 y2 = (vv >> 16) & 0xFFFF;" caststr ;
    "            u64 y1 = (vv >> 32) & 0xFFFF;" caststr ;
    "            u64 y0 = (vv >> 48) & 0xFFFF;" caststr ;
    "            car->tag = VT_C21;" caststr ;
    "            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" caststr ;
    "            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;" caststr ;
    "        } break;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static value_t pop_value (void) {" caststr ;
    "    if (stack_counter >= STACK_SIZE) {" caststr ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" caststr ;
    "        exit(1);" caststr ;
    "    }" caststr ;
    "    return stack[stack_counter++];" caststr ;
    "}" caststr ;;

    "static bool value_has_ptr_offset (value_t v) {" caststr ;
    "    if (v.tag == VT_C64) {" caststr ;
    "        usize cell_index = (usize)v.payload.vp_u64;" caststr ;
    "        struct cell_t * cell = heap + cell_index;" caststr ;
    "        return !cell->freecdr;" caststr ;
    "    } else {" caststr ;
    "        return v.tag != VT_U64;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static u64 value_ptr_size (value_t v) {" caststr ;
    "    if (v.payload.vp_u64 == 0) {" caststr ;
    "        return 0;" caststr ;
    "    } else if (v.tag == VT_U64) {" caststr ;
    "        return strlen(v.payload.vp_ptr) + 1;" caststr ;
    "    } else if (value_has_ptr_offset(v)) {" caststr ;
    "        value_t car, cdr;" caststr ;
    "        value_uncons(v, &car, &cdr);" caststr ;
    "        value_t car2, cdr2;" caststr ;
    "        value_uncons(car, &car2, &cdr2);" caststr ;
    "        return car2.payload.vp_u64;" caststr ;
    "    } else {" caststr ;
    "        value_t car, cdr;" caststr ;
    "        value_uncons(v, &car, &cdr);" caststr ;
    "        return car.payload.vp_u64;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static void* value_ptr_base (value_t v) {" caststr ;
    "    if (value_has_ptr_offset(v)) {" caststr ;
    "        value_t car, cdr;" caststr ;
    "        value_uncons(v, &car, &cdr);" caststr ;
    "        value_t car2, cdr2;" caststr ;
    "        value_uncons(car, &car2, &cdr2);" caststr ;
    "        return cdr2.payload.vp_ptr;" caststr ;
    "    } else {" caststr ;
    "        value_t car, cdr;" caststr ;
    "        value_uncons(v, &car, &cdr);" caststr ;
    "        return cdr.payload.vp_ptr;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static i64 value_ptr_offset (value_t v) {" caststr ;
    "    if (value_has_ptr_offset(v)) {" caststr ;
    "        value_t car, cdr;" caststr ;
    "        value_uncons(v, &car, &cdr);" caststr ;
    "        return cdr.payload.vp_i64;" caststr ;
    "    } else {" caststr ;
    "        return 0;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static void* value_ptr (value_t v) {" caststr ;
    "    char* ptr = value_ptr_base(v);" caststr ;
    "    i64 offset = value_ptr_offset(v);" caststr ;
    "    return (void*)(ptr + offset);" caststr ;
    "}" caststr ;;

    "static fnptr pop_fnptr (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_fnptr;" caststr ;
    "}" caststr ;;
    "static u8 pop_u8 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_u8;" caststr ;
    "}" caststr ;;
    "static u16 pop_u16 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_u16;" caststr ;
    "}" caststr ;;
    "static u32 pop_u32 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_u32;" caststr ;
    "}" caststr ;;
    "static u64 pop_u64 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_u64;" caststr ;
    "}" caststr ;;
    "static i8 pop_i8 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_i8;" caststr ;
    "}" caststr ;;
    "static i16 pop_i16 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_i16;" caststr ;
    "}" caststr ;;
    "static i32 pop_i32 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_i32;" caststr ;
    "}" caststr ;;
    "static i64 pop_i64 (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_i64;" caststr ;
    "}" caststr ;;
    "static bool pop_bool (void) {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    return v.payload.vp_bool;" caststr ;
    "}" caststr ;;

    "static void push_value (value_t v) {" caststr ;
    "    if (stack_counter < 1) {" caststr ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" caststr ;
    "        exit(1);" caststr ;
    "    }" caststr ;
    "    stack[--stack_counter] = v;" caststr ;
    "}" caststr ;;
    "static void push_ptr (void* x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_ptr = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_fnptr (fnptr x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_fnptr = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_u8 (u8 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_u8 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_u16 (u16 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_u16 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_u32 (u32 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_u32 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_u64 (u64 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_i8 (i8 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_i8 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_i16 (i16 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_i16 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_i32 (i32 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_i32 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_i64 (i64 x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_i64 = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    "static void push_bool (bool x) {" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_U64;" caststr ;
    "    v.payload.vp_u64 = 0;" caststr ;
    "    v.payload.vp_bool = x;" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;
    # create a cons cell, while taking ownership of car and cdr's refs
    "static value_t mkcell (value_t car, value_t cdr) {" caststr ;
    "    if ((car.payload.vp_u64 == 0) && (cdr.tag == VT_U64))" caststr ;
    "        return cdr;" caststr ;
    "    if (cdr.tag == VT_U64) {" caststr ;
    "        switch (car.tag) {" caststr ;
    "            case VT_U64: {" caststr ;
    "                u64 x0 = car.payload.vp_u64;" caststr ;
    "                u64 x1 = cdr.payload.vp_u64;" caststr ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" caststr ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" caststr ;
    "                if ((x0 == y0) && (x1 == y1)) {" caststr ;
    "                    value_t r;" caststr ;
    "                    r.tag = VT_U32;" caststr ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" caststr ;
    "                    return r;" caststr ;
    "                }" caststr ;
    "            } break;" caststr ;
    "            case VT_C64: {" caststr ;
    "                u64 x0 = car.payload.vp_u64;" caststr ;
    "                u64 x1 = cdr.payload.vp_u64;" caststr ;
    "                u64 y0 = x0 & 0xFFFFFFFFLL;" caststr ;
    "                u64 y1 = x1 & 0xFFFFFFFFLL;" caststr ;
    "                if ((x0 == y0) && (x1 == y1)) {" caststr ;
    "                    value_t r;" caststr ;
    "                    r.tag = VT_C32;" caststr ;
    "                    r.payload.vp_u64 = (y0 << 32) | y1;" caststr ;
    "                    return r;" caststr ;
    "                }" caststr ;
    "            } break;" caststr ;
    "            case VT_U32: {" caststr ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" caststr ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" caststr ;
    "                u64 x2 = cdr.payload.vp_u64;" caststr ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" caststr ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" caststr ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" caststr ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" caststr ;
    "                    value_t r;" caststr ;
    "                    r.tag = VT_U21;" caststr ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" caststr ;
    "                    return r;" caststr ;
    "                }" caststr ;
    "            } break;" caststr ;
    "            case VT_C32: {" caststr ;
    "                u64 x0 = car.payload.vp_u64 >> 32;" caststr ;
    "                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;" caststr ;
    "                u64 x2 = cdr.payload.vp_u64;" caststr ;
    "                u64 y0 = x0 & 0x1FFFFFLL;" caststr ;
    "                u64 y1 = x1 & 0x1FFFFFLL;" caststr ;
    "                u64 y2 = x2 & 0x1FFFFFLL;" caststr ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {" caststr ;
    "                    value_t r;" caststr ;
    "                    r.tag = VT_C21;" caststr ;
    "                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;" caststr ;
    "                    return r;" caststr ;
    "                }" caststr ;
    "            } break;" caststr ;
    "            case VT_U21: {" caststr ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" caststr ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" caststr ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" caststr ;
    "                u64 x3 = cdr.payload.vp_u64;" caststr ;
    "                u64 y0 = x0 & 0xFFFFLL;" caststr ;
    "                u64 y1 = x1 & 0xFFFFLL;" caststr ;
    "                u64 y2 = x2 & 0xFFFFLL;" caststr ;
    "                u64 y3 = x3 & 0xFFFFLL;" caststr ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" caststr ;
    "                    value_t r;" caststr ;
    "                    r.tag = VT_U16;" caststr ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" caststr ;
    "                    return r;" caststr ;
    "                }" caststr ;
    "            } break;" caststr ;
    "            case VT_C21: {" caststr ;
    "                u64 x0 = car.payload.vp_u64 >> 42;" caststr ;
    "                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;" caststr ;
    "                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;" caststr ;
    "                u64 x3 = cdr.payload.vp_u64;" caststr ;
    "                u64 y0 = x0 & 0xFFFFLL;" caststr ;
    "                u64 y1 = x1 & 0xFFFFLL;" caststr ;
    "                u64 y2 = x2 & 0xFFFFLL;" caststr ;
    "                u64 y3 = x3 & 0xFFFFLL;" caststr ;
    "                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {" caststr ;
    "                    value_t r;" caststr ;
    "                    r.tag = VT_C16;" caststr ;
    "                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;" caststr ;
    "                    return r;" caststr ;
    "                }" caststr ;
    "            } break;" caststr ;
    "            default: break;" caststr ;
    "        }" caststr ;
    "    }" caststr ;
    "    if (heap_count >= HEAP_SIZE - 1) {" caststr ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" caststr ;
    "        exit(1);" caststr ;
    "    }" caststr ;
    "    u64 cell_index = heap_next;" caststr ;
    "    cell_t *cell = heap + cell_index;" caststr ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" caststr ;
    "    if (cell_index >= HEAP_SIZE - 1) {" caststr ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" caststr ;
    "        exit(1);" caststr ;
    "    }" caststr ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" caststr ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" caststr ;
    "    heap_count++;" caststr ;
    "    cell->refs = 1;" caststr ;
    "    cell->freecdr = false;" caststr ;
    "    cell->car = car;" caststr ;
    "    cell->cdr = cdr;" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_C64;" caststr ;
    "    v.payload.vp_u64 = cell_index;" caststr ;
    "    return v;" caststr ;
    "}" caststr ;;

    "static value_t mkcell_freecdr (value_t car, value_t cdr) {" caststr ;
    "    if (heap_count >= HEAP_SIZE - 1) {" caststr ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" caststr ;
    "        exit(1);" caststr ;
    "    }" caststr ;
    "    u64 cell_index = heap_next;" caststr ;
    "    cell_t *cell = heap + cell_index;" caststr ;
    "    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }" caststr ;
    "    if (cell_index >= HEAP_SIZE - 1) {" caststr ;
    "        write(2, \"HEAP OVERFLOW\\n\", 14);" caststr ;
    "        exit(1);" caststr ;
    "    }" caststr ;
    "    u64 saved_index = cell->cdr.payload.vp_u64;" caststr ;
    "    heap_next = (usize)(saved_index ? saved_index : cell_index+1);" caststr ;
    "    heap_count++;" caststr ;
    "    cell->refs = 1;" caststr ;
    "    cell->freecdr = true;" caststr ;
    "    cell->car = car;" caststr ;
    "    cell->cdr = cdr;" caststr ;
    "    value_t v = {0};" caststr ;
    "    v.tag = VT_C64;" caststr ;
    "    v.payload.vp_u64 = cell_index;" caststr ;
    "    return v;" caststr ;
    "}" caststr ;;


    "static void do_pack_uncons() {" caststr ;
    "    value_t car, cdr, val;" caststr ;
    "    val = pop_value();" caststr ;
    "    value_uncons(val, &car, &cdr);" caststr ;
    "    push_value(car); push_value(cdr);" caststr ;
    "    if (val.tag == VT_C64) {" caststr ;
    "        decref_for_uncons(val);" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static i64 get_value_tag(value_t v) {" caststr ;
    "    switch (v.tag) {" caststr ;
    "        case VT_C64: {" caststr ;
    "            cell_t *c = heap + v.payload.vp_u64;" caststr ;
    "            if (c->cdr.tag == VT_U64) return c->cdr.payload.vp_i64;" caststr ;
    "            return 0;" caststr ;
    "        } break;" caststr ;
    "        case VT_U64: {" caststr ;
    "            return v.payload.vp_i64;" caststr ;
    "        } break;" caststr ;
    "        case VT_U32: {" caststr ;
    "            return v.payload.vp_u64 & 0xFFFFFFFF;" caststr ;
    "        } break;" caststr ;
    "        case VT_C32: {" caststr ;
    "            return v.payload.vp_u64 & 0xFFFFFFFF;" caststr ;
    "        } break;" caststr ;
    "        case VT_U21: {" caststr ;
    "            return v.payload.vp_u64 & 0x1FFFFF;" caststr ;
    "        } break;" caststr ;
    "        case VT_C21: {" caststr ;
    "            return v.payload.vp_u64 & 0x1FFFFF;" caststr ;
    "        } break;" caststr ;
    "        case VT_U16: {" caststr ;
    "            return v.payload.vp_u64 & 0xFFFF;" caststr ;
    "        } break;" caststr ;
    "        case VT_C16: {" caststr ;
    "            return v.payload.vp_u64 & 0xFFFF;" caststr ;
    "        } break;" caststr ;
    "    }" caststr ;
    "    return 0;" caststr ;
    "}" caststr ;;

    "static u64 get_top_data_tag() {" caststr ;
    "    return get_value_tag(stack[stack_counter]);" caststr ;
    "}" caststr ;;

    "static int value_cmp(value_t v1, value_t v2) {" caststr ;
    "    while(1) {" caststr ;
    "        i64 t1 = get_value_tag(v1);" caststr ;
    "        i64 t2 = get_value_tag(v2);" caststr ;
    "        if (t1 < t2) return -1;" caststr ;
    "        if (t1 > t2) return 1;" caststr ;
    "        if ((v1.tag == VT_U64) && (v2.tag == VT_U64)) return 0;" caststr ;
    "        value_t v1car, v1cdr, v2car, v2cdr;" caststr ;
    "        value_uncons(v1, &v1car, &v1cdr);" caststr ;
    "        value_uncons(v2, &v2car, &v2cdr);" caststr ;
    "        int cdrcmp = value_cmp(v1cdr, v2cdr);" caststr ;
    "        if (cdrcmp != 0) return cdrcmp;" caststr ;
    "        v1 = v1car; v2 = v2car;" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    "static void do_run() {" caststr ;
    "    do_pack_uncons();" caststr ;
    "    fnptr fp = pop_fnptr();" caststr ;
    "    fp();" caststr ;
    "}" caststr ;;

    PRIM_CORE_ID .p " {" caststr ;
    "}" caststr ;;

    PRIM_CORE_DUP .p " {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    incref(v);" caststr ;
    "    push_value(v); push_value(v);" caststr ;
    "}" caststr ;;

    "static void do_drop() {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    decref(v);" caststr ;
    "}" caststr ;;

    PRIM_CORE_DROP .p " { do_drop(); }" caststr ;;

    "static void do_swap() {" caststr ;
    "    value_t x = pop_value();" caststr ;
    "    value_t y = pop_value();" caststr ;
    "    push_value(x); push_value(y);" caststr ;
    "}" caststr ;;

    PRIM_CORE_SWAP .p " { do_swap(); }" caststr ;;

    PRIM_CORE_DIP .p " {" caststr ;
    "    value_t f = pop_value();" caststr ;
    "    value_t x = pop_value();" caststr ;
    "    push_value(f);" caststr ;
    "    do_run();" caststr ;
    "    push_value(x);" caststr ;
    "}" caststr ;;

    PRIM_CORE_IF .p " {" caststr ;
    "    value_t then_branch = pop_value();" caststr ;
    "    value_t else_branch = pop_value();" caststr ;
    "    bool b = pop_bool();" caststr ;
    "    if (b) {" caststr ;
    "        push_value(then_branch);" caststr ;
    "        decref(else_branch);" caststr ;
    "    } else {" caststr ;
    "        push_value(else_branch);" caststr ;
    "        decref(then_branch);" caststr ;
    "    }" caststr ;
    "    do_run();" caststr ;
    "}" caststr ;;

    PRIM_CORE_WHILE .p " {" caststr ;
    "    value_t cond = pop_value();" caststr ;
    "    value_t body = pop_value();" caststr ;
    "    while(1) {" caststr ;
    "        push_value(cond); incref(cond); do_run();" caststr ;
    "        bool b = pop_bool();" caststr ;
    "        if (!b) break;" caststr ;
    "        push_value(body); incref(body); do_run();" caststr ;
    "    }" caststr ;
    "    decref(cond); decref(body);" caststr ;
    "}" caststr ;;

    PRIM_INT_ADD .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(x + y);" caststr ;
    "}" caststr ;;

    PRIM_INT_SUB .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(y - x);" caststr ;
    "}" caststr ;;

    PRIM_INT_MUL .p " {" caststr ;
    "    i64 x = pop_i64();" caststr ;
    "    i64 y = pop_i64();" caststr ;
    "    push_i64(x * y);" caststr ;
    "}" caststr ;;

    PRIM_INT_DIV .p " {" caststr ;
    "    i64 x = pop_i64();" caststr ;
    "    i64 y = pop_i64();" caststr ;
    "    push_i64(y / x);" caststr ;
    "}" caststr ;;

    PRIM_INT_MOD .p " {" caststr ;
    "    i64 x = pop_i64();" caststr ;
    "    i64 y = pop_i64();" caststr ;
    "    push_i64(y % x);" caststr ;
    "}" caststr ;;

    PRIM_VALUE_EQ .p " {" caststr ;
    "    value_t v2 = pop_value();" caststr ;
    "    value_t v1 = pop_value();" caststr ;
    "    push_bool(value_cmp(v1, v2) == 0);" caststr ;
    "    decref(v1); decref(v2);" caststr ;
    "}" caststr ;;

    PRIM_VALUE_LT .p " {" caststr ;
    "    value_t v2 = pop_value();" caststr ;
    "    value_t v1 = pop_value();" caststr ;
    "    push_bool(value_cmp(v1, v2) < 0);" caststr ;
    "    decref(v1); decref(v2);" caststr ;
    "}" caststr ;;

    PRIM_VALUE_LE .p " {" caststr ;
    "    value_t v2 = pop_value();" caststr ;
    "    value_t v1 = pop_value();" caststr ;
    "    push_bool(value_cmp(v1, v2) <= 0);" caststr ;
    "    decref(v1); decref(v2);" caststr ;
    "}" caststr ;;

    PRIM_INT_AND .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(y & x);" caststr ;
    "}" caststr ;;

    PRIM_INT_OR .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(y | x);" caststr ;
    "}" caststr ;;

    PRIM_INT_XOR .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(y ^ x);" caststr ;
    "}" caststr ;;

    PRIM_INT_SHL .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(y << x);" caststr ;
    "}" caststr ;;

    PRIM_INT_SHR .p " {" caststr ;
    "    u64 x = pop_u64();" caststr ;
    "    u64 y = pop_u64();" caststr ;
    "    push_u64(y >> x);" caststr ;
    "}" caststr ;;

    PRIM_POSIX_WRITE .p " {" caststr ;
    "    usize n = (usize)pop_u64();" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    void* p = value_ptr(vp);" caststr ;
    "    int f = (int)pop_i64();" caststr ;
    "    push_i64((i64)write(f, p, n));" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_POSIX_READ .p " {" caststr ;
    "    usize n = (usize)pop_u64();" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    void* p = value_ptr(vp);" caststr ;
    "    int f = (int)pop_i64();" caststr ;
    "    push_i64((i64)read(f,p,n));" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_POSIX_OPEN .p " {" caststr ;
    "    int m = (int)pop_i64();" caststr ;
    "    int f = (int)pop_i64();" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    void* p = value_ptr(vp);" caststr ;
    "    push_i64((i64)open(p,f,m));" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_POSIX_CLOSE .p " {" caststr ;
    "    int x = (int)pop_i64();" caststr ;
    "    push_i64((i64)close(x));" caststr ;
    "}" caststr ;;

    PRIM_POSIX_EXIT .p " {" caststr ;
    "    int x = (int)pop_i64();" caststr ;
    "    exit(x);" caststr ;
    "}" caststr ;;

    PRIM_POSIX_MMAP .p " {" caststr ;
    "    #ifdef MIRTH_WINDOWS" caststr ;
    "    pop_value(); pop_value(); pop_value(); pop_value();" caststr ;
    "    usize b = (usize)pop_u64();" caststr ;
    "    pop_value();" caststr ;
    "    push_ptr(malloc(b));" caststr ;
    "    #else" caststr ;
    "    int f = (int)pop_i64();" caststr ;
    "    int e = (int)pop_i64();" caststr ;
    "    int d = (int)pop_i64();" caststr ;
    "    int c = (int)pop_i64();" caststr ;
    "    usize b = (usize)pop_u64();" caststr ;
    "    value_t va = pop_value();" caststr ;
    "    void* a = value_ptr(va);" caststr ;
    "    void* p = mmap(a,b,c,d,e,f);" caststr ;
    "    push_ptr(p);" caststr ;
    "    decref(va);" caststr ;
    "    #endif" caststr ;
    "}" caststr ;;

    "static void do_debug() {" caststr ;
    "    write(2, \"??\", 2);" caststr ;
    "    char c[32] = {0};" caststr ;
    "    char* cp;" caststr ;
    "    usize n;" caststr ;
    "    i64 x; i64 y;" caststr ;
    "    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {" caststr ;
    "        cp = c+30;" caststr ;
    "        x = stack[i].payload.vp_i64;" caststr ;
    "        n = 1;" caststr ;
    "        y = x; if (x < 0) { x = -x; }" caststr ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" caststr ;
    "        if (y < 0) { *cp-- = '-'; n++; } " caststr ;
    "        *cp = ' ';" caststr ;
    "        write(2, cp, n);" caststr ;
    "    }" caststr ;
    "    write(2, \"\\n\", 1);" caststr ;
    "}" caststr ;;

    PRIM_CORE_DEBUG .p " {" caststr ;
    "   do_debug();" caststr ;
    "}" caststr ;;

    PRIM_VALUE_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    value_t* p = value_ptr(vp);" caststr ;
    "    value_t v = *p;" caststr ;
    "    push_value(v);" caststr ;
    "    incref(v);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_VALUE_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    value_t* p = value_ptr(vp);" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    value_t old_v = *p;" caststr ;
    "    *p = v;" caststr ;
    "    decref(old_v);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_INT_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i64* p = value_ptr(vp);" caststr ;
    "    push_i64(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_INT_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i64* p = value_ptr(vp);" caststr ;
    "    *p = (i64)pop_i64();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_PTR_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    void** p = value_ptr(vp);" caststr ;
    "    push_ptr(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_PTR_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    value_t vx = pop_value();" caststr ;
    "    void** p = value_ptr(vp);" caststr ;
    "    *p = value_ptr(vx);" caststr ;
    "    decref(vp); decref(vx);" caststr ;
    "}" caststr ;;

    PRIM_U8_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u8* p = value_ptr(vp);" caststr ;
    "    push_u8(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U8_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u8* p = value_ptr(vp);" caststr ;
    "    *p = pop_u8();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U16_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u16* p = value_ptr(vp);" caststr ;
    "    push_u16(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U16_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u16* p = value_ptr(vp);" caststr ;
    "    *p = pop_u16();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U32_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u32* p = value_ptr(vp);" caststr ;
    "    push_u32(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U32_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u32* p = value_ptr(vp);" caststr ;
    "    *p = pop_u32();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U64_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u64* p = value_ptr(vp);" caststr ;
    "    push_u64(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_U64_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    u64* p = value_ptr(vp);" caststr ;
    "    *p = pop_u64();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I8_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i8* p = value_ptr(vp);" caststr ;
    "    push_i8(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I8_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i8* p = value_ptr(vp);" caststr ;
    "    *p = pop_i8();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I16_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i16* p = value_ptr(vp);" caststr ;
    "    push_i16(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I16_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i16* p = value_ptr(vp);" caststr ;
    "    *p = pop_i16();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I32_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i32* p = value_ptr(vp);" caststr ;
    "    push_i32(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I32_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i32* p = value_ptr(vp);" caststr ;
    "    *p = pop_i32();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I64_GET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i64* p = value_ptr(vp);" caststr ;
    "    push_i64(*p);" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_I64_SET .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i64* p = value_ptr(vp);" caststr ;
    "    *p = pop_i64();" caststr ;
    "    decref(vp);" caststr ;
    "}" caststr ;;

    PRIM_SYS_OS .p " {" caststr ;
    "#if defined(MIRTH_WINDOWS)" caststr ;
    "    push_u64(" caststr . OS_WINDOWS cast .n ");" caststr ;
    "#elif defined(MIRTH_LINUX)" caststr ;
    "    push_u64(" caststr . OS_LINUX cast .n ");" caststr ;
    "#elif defined(MIRTH_MACOS)" caststr ;
    "    push_u64(" caststr . OS_MACOS cast .n ");" caststr ;
    "#else" caststr ;
    "    push_u64(" caststr . OS_UNKNOWN cast .n ");" caststr ;
    "#endif" caststr ;
    "}" caststr ;;

    PRIM_VALUE_CAST .p " { }" caststr ;;

    PRIM_CORE_RUN .p " {" caststr ;
    "    do_run();" caststr ;
    "}" caststr ;;

    PRIM_PTR_ADD .p " {" caststr ;
    "    value_t vp = pop_value();" caststr ;
    "    i64 y = pop_i64();" caststr ;
    "    if (vp.tag == VT_U64) {" caststr ;
    "        push_i64(y + vp.payload.vp_i64);" caststr ;
    "    } else if (value_has_ptr_offset(vp)) {" caststr ;
    "        value_t car, cdr;" caststr ;
    "        value_uncons(vp, &car, &cdr);" caststr ;
    "        cdr.payload.vp_i64 += y;" caststr ;
    "        push_value(mkcell(car, cdr));" caststr ;
    "    } else {" caststr ;
    "        value_t vy = { .tag = VT_U64, .payload = { .vp_i64 = y } };" caststr ;
    "        push_value(mkcell(vp, vy));" caststr ;
    "    }" caststr ;
    "}" caststr ;

    PRIM_BOOL_TRUE .p " {" caststr ;
    "    push_bool(true);" caststr ;
    "}" caststr ;

    PRIM_BOOL_FALSE .p " {" caststr ;
    "    push_bool(false);" caststr ;
    "}" caststr ;;

    PRIM_BOOL_AND .p " {" caststr ;
    "    bool x = pop_bool();" caststr ;
    "    bool y = pop_bool();" caststr ;
    "    push_bool(y && x);" caststr ;
    "}" caststr ;

    PRIM_BOOL_OR .p " {" caststr ;
    "    bool x = pop_bool();" caststr ;
    "    bool y = pop_bool();" caststr ;
    "    push_bool(y || x);" caststr ;
    "}" caststr ;;

    PRIM_SYS_ARGC .p " {" caststr ;
    "    push_i64(global_argc);" caststr ;
    "}" caststr ;

    PRIM_SYS_ARGV .p " {" caststr ;
    "    push_ptr(global_argv);" caststr ;
    "}" caststr ;;

    PRIM_PTR_SIZE .p " {" caststr ;
    "    push_u64((u64)sizeof(void*));" caststr ;
    "}" caststr ;;

    PRIM_PTR_ALLOC .p " {" caststr ;
    "    i64 psize = pop_i64();" caststr ;
    "    if (psize > 0) {" caststr ;
    "        usize size = (usize)psize;" caststr ;
    "        void* ptr = calloc(1,size);" caststr ;
    "        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };" caststr ;
    "        value_t vptr = { .tag = VT_U64, .payload = { .vp_ptr = ptr } };" caststr ;
    "        value_t v = mkcell_freecdr(vsize, vptr);" caststr ;
    "        push_value(v);" caststr ;
    "    } else {" caststr ;
    "        push_u64(0);" caststr ;
    "    }" caststr ;
    "}" caststr ;;

    PRIM_PTR_NUMBYTES .p " {" caststr ;
    "    value_t v = pop_value();" caststr ;
    "    push_i64(value_ptr_size(v));" caststr ;
    "    decref(v);" caststr ;
    "}" caststr ;;

    PRIM_PACK_NIL .p " {" caststr ;
    "    value_t v = {0};" caststr ;
    "    push_value(v);" caststr ;
    "}" caststr ;;

    "static void do_pack_cons() {" caststr ;
    "    value_t cdr = pop_value();" caststr ;
    "    value_t car = pop_value();" caststr ;
    "    push_value(mkcell(car, cdr));" caststr ;
    "}" caststr ;;

    PRIM_PACK_CONS .p " {" caststr ;
    "    do_pack_cons();" caststr ;
    "}" caststr ;;

    PRIM_PACK_UNCONS .p " {" caststr ;
    "    do_pack_uncons();" caststr ;
    "}" caststr ;;
    )

def(c99-emit-externals!, +IO,
    1
    while(dup External.NUM int@ <=,
        dup Int->External c99-emit-external!
        1+)
    .lf drop)

def(c99-emit-external!, External -- +IO,
    external-sig? sig-arity
    dup 2 >= if(
        "can't declare external with multiple return values" caststr panic!,

        dup 1 >= if(
            "i64 " caststr .,
            "void " caststr .
        )
    )

    dip2(external-name? .name)

    " (" caststr .
    over dup nonzero if(
        "i64" caststr .
        1- while(dup nonzero,
            ", i64" caststr .
            1-
        ) drop,
        drop
    ) ");" caststr ;

    "static void mw" caststr . dip2(external-name? .name) " (void) {" caststr ;
    over while(dup nonzero,
        "    i64 x" caststr . dup .n " = pop_i64();" caststr ;
        1-
    ) drop
    dup nonzero if("    push_i64(", "    ") caststr .
    dip2(external-name? .name)
    "(" caststr .
    dip(dup nonzero if(
        "x1" caststr .
        dup 1-
        while(dup nonzero,
            ", x" caststr .
            dup2 - 1+ .n
            1-
        ) drop,
        id
    ))
    ")" caststr .
    dup nonzero if(");", " caststr ;") caststr ;
    "}" caststr ;

    drop3)

def(c99-emit-arrow!, Arrow -- +IO,
    c99-depth++
    while(is-nil? not,
        dup c99-emit-arrow-op!
        arrow-next@)
    drop
    c99-depth--)

c99-emit-arrow-op! : Arrow -- +IO,
c99-emit-arrow-op! =
    arrow-op? match(
        OP_NONE -> drop,
        OP_INT ->
            nip
            "    push_i64(" caststr . .n "LL);" caststr ;,
        OP_STR ->
            nip StrLit->Int
            "    push_ptr((void*)(strings + " caststr . .n "));" caststr ;,
            # TODO: just push a string literal.
        OP_WORD ->
            dip(arrow-args@ c99-emit-args-push!)
            "    mw" caststr . word-name@ .name "();" caststr ;,
        OP_EXTERNAL ->
            dip(arrow-args@ c99-emit-args-push!) # this is probably never desirable
            "    mw" caststr . external-name@ .name "();" caststr ;,
        OP_BUFFER ->
            nip buffer-name@
            "    mw" caststr . .name "();" caststr ;,
        OP_TAG ->
            nip tag-name@
            "    mw" caststr . .name "();" caststr ;,
        OP_PRIM ->
            c99-emit-arrow-op-prim!,
        OP_MATCH ->
            nip c99-emit-match!,
        OP_LAMBDA ->
            nip c99-emit-lambda!,
        OP_VAR ->
            nip c99-emit-var!,
        OP_BLOCK ->
            nip c99-emit-block-push!,
    )

c99-emit-arrow-op-prim! : Arrow Prim -- +IO
c99-emit-arrow-op-prim! =
    dip(arrow-args@) match(
        PRIM_CORE_DIP ->
            match(
                L1 ->
                    "    { value_t d" caststr . .d " = pop_value();" caststr ;
                    c99-emit-arg-run!
                    "      push_value(d" caststr . .d "); }" caststr ;,
                _ ->
                    PRIM_CORE_DIP c99-emit-arrow-op-prim-default!
            ),

        PRIM_CORE_IF ->
            match(
                L2 ->
                    "    if (pop_u64()) {" caststr ;
                    dip(c99-emit-arg-run!)
                    "    } else {" caststr ;
                    c99-emit-arg-run!
                    "    }" caststr ;,
                _ ->
                    PRIM_CORE_IF c99-emit-arrow-op-prim-default!
            ),

        PRIM_CORE_WHILE ->
            match(
                L2 ->
                    "    while(1) {" caststr ;
                    dip(c99-emit-arg-run!)
                    "    if (!pop_u64()) break;" caststr ;
                    c99-emit-arg-run!
                    "    }" caststr ;,

                _ ->
                    PRIM_CORE_WHILE c99-emit-arrow-op-prim-default!
            ),

        _ -> c99-emit-arrow-op-prim-default!
    )

c99-emit-arrow-op-prim-default! : List(Arg) Prim -- +IO
c99-emit-arrow-op-prim-default! = (
    dip(c99-emit-args-push!)
    "    mw" caststr . prim-name@ .name "();" caststr ;
)

c99-emit-args-push! : List(Arg) -- +IO
c99-emit-args-push! = reverse-for(c99-emit-arg-push!)

c99-emit-arg-push! : Arg -- +IO
c99-emit-arg-push! =
    match(
        ARG_BLOCK -> c99-emit-block-push!,
        ARG_VAR_RUN -> c99-emit-var-push!,
    )

c99-emit-arg-run! : Arg -- +IO
c99-emit-arg-run! =
    match(
        ARG_BLOCK -> block-arrow@ c99-emit-arrow!,
        ARG_VAR_RUN -> c99-emit-var!,
    )

def(.var-val, Var -- +IO, "var_" caststr . var-name? .name "_" caststr . Var->Int .n)
def(.var-ref, Var -- +IO, "ref_" caststr . var-name? .name "_" caststr . Var->Int .n)

def(c99-pack-ctx!, Ctx -- +IO,
    "    push_u64(0);" caststr ;
    ctx-physical-vars for(
        c99-emit-var-push!
        "    do_pack_cons();" caststr ;
    ))

def(c99-unpack-ctx!, Ctx -- +IO,
    ctx-physical-vars reverse-for(
        "    do_pack_uncons();" caststr ;
        "    value_t " caststr . dup .var-val " = pop_value();" caststr ;
        "    bool " caststr . .var-ref " = false;" caststr ;
        )
    "    do_drop();" caststr ;
    )

def(c99-decref-ctx!, Ctx -- +IO,
    ctx-physical-vars reverse-for(
        "    if (!" caststr . dup .var-ref ")" caststr ;
        "        decref(" caststr . .var-val ");" caststr ;
    ))

def(c99-emit-block-push!, Block -- +IO,
    true over block-needed!
    block-arrow? arrow-ctx@ c99-pack-ctx!
    "    push_fnptr(&" caststr . .block ");" caststr ;
    "    do_pack_cons();" caststr ;
    )

def(c99-emit-var!, Var -- +IO,
    var-auto-run? dip(c99-emit-var-push!)
    if("    do_run();" caststr ;, id))

def(c99-emit-var-push!, Var -- +IO,
    "    push_value(" caststr . dup .var-val ");" caststr ;
    "    if (" caststr . dup .var-ref  ")" caststr ;
    "        incref(" caststr . dup .var-val ");" caststr ;
    "    else" caststr ;
    "        " caststr . .var-ref " = true;" caststr ;
    )

def(c99-emit-lambda!, Lambda -- +IO,
    "    {" caststr ;
    lambda-params? reverse-for(
        "    value_t " caststr . dup .var-val " = pop_value();" caststr ;
        "    bool " caststr . .var-ref " = false;" caststr ;
        )
    lambda-body? c99-emit-arrow!
    lambda-params@ reverse-for(
        "    if (!" caststr . dup .var-ref ")" caststr ;
        "        decref(" caststr . .var-val ");" caststr ;
        )
    "    }" caststr ;)

def(c99-emit-match!, Match -- +IO,
    match-is-transparent? if(
        match-cases? first match(
            NONE -> match-token@
                "codegen: unexpected number of cases in transparent match" caststr emit-fatal-error!,
            SOME ->
                case-body@ c99-emit-arrow! drop
        ),

        "    switch (get_top_data_tag()) {" caststr ;
        match-cases? for(c99-emit-case!)
        match-has-default-case if(
            id,
            "    default: write(2, \"unexpected fallthrough in match\\n\", 32); do_debug(); exit(99);" caststr ;
        )
        "    }" caststr ;
    ))

def(c99-emit-case!, Case -- +IO,
    case-pattern? c99-emit-pattern!
    case-body@ c99-emit-arrow!
    "    break;" caststr ;)

def(c99-emit-pattern!, Pattern -- +IO,
    match(
        PATTERN_UNDERSCORE ->
            "    default:" caststr ; ,

        PATTERN_TAG ->
            "    case " caststr . tag-value? .n "LL:" caststr ;
            tag-num-inputs? nip
            dup 0 > if(
                "    do_pack_uncons(); do_drop();" caststr ;
                while(dup 1 >,
                    "    do_pack_uncons(); do_swap();" caststr ;
                    1-)
                drop,
                drop "    do_drop();" caststr ;
            )
    ))

def(c99-emit-word-sigs!, +IO,
    1
    while(dup Word.NUM int@ <=,
        dup Int->Word c99-emit-word-sig!
        1+
    )
    drop .lf)

def(c99-emit-word-sig!, Word -- +IO,
    " static void mw" caststr . word-name@ .name " (void);" caststr ;)

def(c99-emit-block-sigs!, +IO,
    1
    while(dup Block.NUM int@ <=,
        dup Int->Block c99-emit-block-sig!
        1+
    )
    drop .lf)

def(c99-emit-block-sig!, Block -- +IO,
    " static void " caststr . .block " (void);" caststr ;)

def(c99-emit-block-defs!, +IO,
    1
    while(dup Block.NUM int@ <=,
        dup Int->Block c99-emit-block-def!
        1+
    )
    drop .lf)

def(c99-emit-block-def!, Block -- +IO,
    block-needed? if(
        "static void " caststr . dup .block " (void) {" caststr ;
        block-arrow@
        arrow-ctx? c99-unpack-ctx!
        dup c99-emit-arrow!
        arrow-ctx@ c99-decref-ctx!
        "}" caststr ;,

        drop
    ))

def(.block, Block -- +IO,
    block-arrow@ arrow-token@ "mb_" caststr .
    token-module? module-name@ .name "_" caststr .
    token-row? Row->Int .n "_" caststr .
    token-col@ Col->Int .n)

def(c99-emit-word-defs!, +IO,
    1
    while(dup Word.NUM int@ <=,
        dup Int->Word c99-emit-word-def! 1+)
    drop)

def(c99-emit-word-def!, Word -- +IO,
    word-name? .w "{" caststr ;
    word-arrow@ c99-emit-arrow!
    "}" caststr ;;)

def(c99-emit-main!, Arrow -- +IO,
    "int main (int argc, char** argv) {" caststr ;
    "    global_argc = argc;" caststr ;
    "    global_argv = argv;" caststr ;
    c99-emit-arrow!
    "    return 0;" caststr ;
    "}" caststr ;
    )
