module(mirth.codegen)
import(prelude)
import(platform.posix)
import(data.str)
import(data.stack)
import(data.path)
import(data.list)
import(data.lazy)
import(data.byte)
import(data.maybe)
import(mirth.data.error)
import(mirth.data.module)
import(mirth.data.location)
import(mirth.data.token)
import(mirth.data.name)
import(mirth.data.buffer)
import(mirth.data.arrow)
import(mirth.data.word)
import(mirth.data.table)
import(mirth.data.variable)
import(mirth.data.external)
import(mirth.data.constant)
import(mirth.data.ctx)
import(mirth.data.type)
import(mirth.data.data)
import(mirth.data.prim)
import(mirth.data.var)
import(mirth.data.match)
import(mirth.elab)

#########
# NEEDS #
#########

data(Need,
    NEED_WORD -> Word,
    NEED_BLOCK -> Block)

var(needs-stack, Stack(Need))
field(word-needed, Word, Bool)
field(block-needed, Block, Bool)
def(reset-needs!, --,
    Block.for(F swap block-needed !)
    Word.for(F swap word-needed !)
    needs-stack reset!)
def(for-needed-words(f), (*a Word -- *a) *a -- *a,
    Word.for(dup word-needed @ if(f, drop)))
def(for-needed-blocks(f), (*a Block -- *a) *a -- *a,
    Block.for(dup block-needed @ if(f, drop)))

def(need-block, Block --,
    dup block-needed @ if(
        drop,
        T over block-needed !
        NEED_BLOCK needs-stack push!
    ))
def(need-word, Word --,
    dup word-needed @ if(
        drop,
        T over word-needed !
        NEED_WORD needs-stack push!
    ))

def(determine-arrow-needs!, Arrow --,
    need-arrow-run determine-transitive-needs!)
def(determine-transitive-needs!, --,
    while-some(needs-stack pop!, match(
        NEED_BLOCK -> need-block-run,
        NEED_WORD -> arrow need-arrow-run,
    )))

def(need-arrow-run, Arrow --, atoms for(need-atom-run))
def(need-atom-run, Atom --,
    sip(args) op match(
        OP_NONE -> drop,
        OP_INT -> drop2,
        OP_STR -> drop2,
        OP_CONSTANT -> drop2,
        OP_WORD -> need-word need-args-push,
        OP_EXTERNAL -> drop need-args-push,
        OP_BUFFER -> drop need-args-push,
        OP_VARIABLE -> drop need-args-push,
        OP_FIELD -> drop need-args-push,
        OP_TAG -> drop need-args-push,
        OP_PRIM -> need-prim,
        OP_MATCH -> nip need-match,
        OP_LAMBDA -> nip need-lambda,
        OP_VAR -> drop2,
        OP_BLOCK -> nip need-block-push
    ))
def(need-args-push, List(Arg) --, for(need-arg-push))
def(need-arg-push, Arg --, ARG_BLOCK -> need-block-push)
def(need-arg-run, Arg --, ARG_BLOCK -> need-block-run)

def(need-prim, List(Arg) Prim --,
    PRIM_CORE_DIP ->
        match(
            L1 -> need-arg-run,
            _ -> need-args-push
        ),
    PRIM_CORE_RDIP ->
        match(
            L1 -> need-arg-run,
            _ -> need-args-push
        ),
    PRIM_CORE_IF ->
        match(
            L2 -> dip(need-arg-run) need-arg-run,
            _ -> need-args-push
        ),
    PRIM_CORE_WHILE ->
        match(
            L2 -> dip(need-arg-run) need-arg-run,
            _ -> need-args-push
        ),
    _ -> drop need-args-push)

def(need-match, Match --, cases for(body need-arrow-run))
def(need-lambda, Lambda --, body need-arrow-run)

def(need-block-push, Block --,
    dup block-to-run-var match(
        SOME -> drop2,
        NONE -> need-block
    ))
def(need-block-run, Block --, arrow need-arrow-run)

###########
# Codegen #
###########

data(+C99, MKC99 -> File Int Str)
def(+C99/MKC99, +C99 -- File Int Str, MKC99 -> id)

def(+C99.depth@, +C99 -- Int +C99, /MKC99 over dip(MKC99))
def(+C99.depth!, Int +C99 -- +C99, dip(/MKC99 nip) swap MKC99)
def(Str+C99., Str +C99 -- +C99,
    dip(/MKC99) cat
    dup num-bytes dip(MKC99)
    512 > then(codegen-flush!))

def(Int+C99.n, Int +C99 -- +C99, int-to-str .)
def(Byte+C99.b, Byte +C99 -- +C99, to-ascii-str unwrap .)

def(codegen-start!, Path -- +C99,
    >Str create-file! 0 "" MKC99)

def(codegen-flush!, +C99 -- +C99,
    /MKC99 dip(over) write! "" MKC99)

def(codegen-end!, +C99 --,
    codegen-flush!
    /MKC99 drop2 close-file!)

def(run-output-c99!, Arrow Path --,
    num-errors @ 0> if(
        drop2,

        reset-needs!
        over determine-arrow-needs!

        to-output-path
        codegen-start!
        c99-header!
        c99-tags!
        c99-buffers!
        c99-variables!
        c99-externals!
        c99-word-sigs!
        c99-block-sigs!
        c99-field-sigs!
        c99-main!
        c99-field-defs!
        c99-word-defs!
        c99-block-defs!
        codegen-end!
    ))

def(+C99.lf, +C99 -- +C99, "\n" .)
def(Str+C99;, Str +C99 -- +C99, . .lf)
def(Str+C99;;, Str +C99 -- +C99, . .lf .lf)
def(Name+C99.name, Name +C99 -- +C99, mangled .)
def(Name+C99.w, Name +C99 -- +C99, "static void mw_" . .name " (void)" .)
def(Prim+C99.p, Prim +C99 -- +C99, name .w)
def(Prim+C99.pm, Prim +C99 -- +C99, "#define mw_" . name .name "() " .)

embed-str(c99-header-str, "src/mirth/mirth.h")
def(c99-header!, +C99 -- +C99, c99-header-str . .lf)

def(c99-buffers!, +C99 -- +C99, Buffer.for(c99-buffer!) .lf)
def(c99-buffer!, Buffer +C99 -- +C99,
    dup name .w " {" ;
    "    static uint8_t b[" . dup size .n "] = {0};" ;
    "    push_ptr(&b);" ;
    "}" ;
    drop)

def(c99-variables!, +C99 -- +C99, Variable.for(c99-variable!) .lf)
def(c99-variable!, Variable +C99 -- +C99,
    "void mw_" . name .name "() {" ;
    "    static VAL v = {0};" ;
    "    push_ptr(&v);" ;
    "}" ;)

def(c99-tags!, +C99 -- +C99, Tag.for(c99-tag!) .lf)
def(c99-tag!, Tag +C99 -- +C99,
    dup name .w " {" ;
    dup is-transparent? if(
        id,
        "    VAL tag = MKU64(" . dup value .n "LL);" ;
        "    VAL car = (" .
        dup num-type-inputs repeat(
            "pop_value());" ;
            "    car = mkcons(car, " .
        )
        dup num-resource-inputs repeat(
            "pop_resource());" ;
            "    car = mkcons(car, " .
        )
        "tag);" ;
        dup outputs-resource? if(
            "    push_resource(car);" ; ,
            "    push_value(car);" ; ,
        )
    )
    "}" ;

    "void co_" . dup name .name "() {" ;
    dup is-transparent? if(
        id,
        dup outputs-resource? if(
            "    VAL car = pop_resource();" ; ,
            "    VAL car = pop_value();" ;
        )
        "    VAL cdr;" ;
        "    decref("
        over num-resource-inputs repeat(
            "    value_uncons_c(car, &car, &cdr);" ;
            . "cdr);" ;
            "    push_resource("
        )
        over num-type-inputs repeat(
            "    value_uncons_c(car, &car, &cdr);" ;
            . "cdr);" ;
            "    push_value("
        )
        . "car);" ;
    )
    "}" ;

    drop)

def(c99-externals!, +C99 -- +C99,
    External.for(c99-external!) .lf)

def(c99-external!, External +C99 -- +C99,
    dup sig sig-arity
    dup 2 >= if(
        "can't declare external with multiple return values" panic!,

        dup 1 >= if(
            "int64_t " .,
            "void " .
        )
    )

    dip2(dup name >Str .)

    " (" .
    over dup 0> if("int64_t" . 1- repeat(", int64_t" .), drop "void" .)
    ");" ;

    "static void mw_" . dip2(dup name .name) " (void) {" ;
    over countdown("    int64_t x" . .n " = pop_i64();" ;)
    dup 0> if("    push_i64(", "    ") .
    dip2(dup name >Str .)
    "(" .
    dip(dup 0> if(
        dup 1- dup count("x" . .n ", " .) "x" . .n,
        id
    ))
    ")" .
    dup 0> if(");", ";") ;
    "}" ;
    drop3)

def(c99-nest(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99,
    depth@ 1+ depth!
    f
    depth@ 1- depth!)

def(c99-indent, +C99 -- +C99, depth@ repeat("    " .))
def(c99-line(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99, c99-indent f .lf)

def(c99-call!, List(Arg) Name +C99 -- +C99,
    dip(c99-args-push!)
    c99-line("mw_" . .name "();" .))

def(c99-arrow!, Arrow +C99 -- +C99, atoms for(c99-atom!))
def(c99-atom!, Atom +C99 -- +C99,
    c99-line("WORD_ATOM(" .
        dup token row >Int .n ", " .
        dup token col >Int .n ", " .
        dup token name? if-some(>Str, "") .str
        ");" .)
    sip(args) op
    c99-args-op!)

def(c99-args-op!, List(Arg) Op +C99 -- +C99,
    OP_NONE     -> drop,
    OP_INT      -> nip c99-int!,
    OP_STR      -> nip c99-str!,
    OP_CONSTANT -> nip c99-constant!,
    OP_WORD     -> name c99-call!,
    OP_EXTERNAL -> name c99-call!,
    OP_BUFFER   -> name c99-call!,
    OP_VARIABLE -> name c99-call!,
    OP_FIELD    -> name c99-call!,
    OP_TAG      -> name c99-call!,
    OP_PRIM     -> c99-prim!,
    OP_MATCH    -> nip c99-match!,
    OP_LAMBDA   -> nip c99-lambda!,
    OP_VAR      -> nip c99-var!,
    OP_BLOCK    -> nip c99-block-push!)

def(c99-int!, Int +C99 -- +C99,
    c99-line("push_i64(" . .n "LL);" .))

def(c99-str!, Str +C99 -- +C99,
    c99-line("{" .)
    c99-nest(
        c99-line("static bool vready = false;" .)
        c99-line("static VAL v;" .)
        c99-line("if (! vready) {" .)
        c99-nest(
            dup num-bytes 4090 > if(
                "static uint8_t b[] = {" .
                c99-nest(
                    c99-indent dup str-bytes-for(
                        >Int dup .n "," .
                        10 = if(.lf c99-indent, id)
                    ) .lf
                )
                c99-line("};" .)
                c99-line("v = mkstr((char*)b, " . dup num-bytes .n ");" .),
                c99-line("v = mkstr(" . dup .str ", " . dup num-bytes .n ");" .)
            )
            c99-line("vready = true;" .)
        )
        c99-line("}" .)
        c99-line("push_value(v);" .)
        c99-line("incref(v);" .)
    )
    c99-line("}" .)
    drop)

def(.str, Str +C99 -- +C99, "\"" . str-bytes-for(c99-string-byte!) "\"" .)

def(c99-string-byte!, +C99 Byte -- +C99,
    B'\' -> "\\\\" .,
    BQUOTE -> "\\\"" .,
    BHT -> "\\t" .,
    BLF -> "\\n" .,
    BCR -> "\\r" .,
    _ ->
        dup BSPACE B'~' in-range if(
            .b,
            "\\x" . to-hexdigits dip(.b) .b
        )
    )

def(c99-constant!, Constant +C99 -- +C99,
    value c99-value!)

def(c99-value!, Value +C99 -- +C99,
    VALUE_INT -> c99-int!,
    VALUE_STR -> c99-str!,
    VALUE_BLOCK -> c99-block-push!)

def(c99-prim!, +C99 List(Arg) Prim -- +C99,
    PRIM_CORE_DIP ->
        match(
            L1 ->
                c99-line("{" .)
                c99-nest(
                    c99-line("VAL d" . depth@ .n " = pop_value();" .)
                    c99-arg-run!
                    c99-line("push_value(d" . depth@ .n ");" .)
                )
                c99-line("}" .),
            _ ->
                PRIM_CORE_DIP c99-prim-default!
        ),

    PRIM_CORE_RDIP ->
        match(
            L1 ->
                c99-line("{" .)
                c99-nest(
                    c99-line("VAL d" . depth@ .n " = pop_resource();" .)
                    c99-arg-run!
                    c99-line("push_resource(d" . depth@ .n ");" .)
                )
                c99-line("}" .),
            _ ->
                PRIM_CORE_RDIP c99-prim-default!
        ),

    PRIM_CORE_IF ->
        match(
            L2 ->
                c99-line("if (pop_u64()) {" .)
                c99-nest(swap c99-arg-run!)
                c99-line("} else {" .)
                c99-nest(c99-arg-run!)
                c99-line("}" .),
            _ ->
                PRIM_CORE_IF c99-prim-default!
        ),

    PRIM_CORE_WHILE ->
        match(
            L2 ->
                c99-line("while(1) {" .)
                c99-nest(
                    swap c99-arg-run!
                    c99-line("if (! pop_u64()) break;" .)
                    c99-arg-run!
                )
                c99-line("}" .),

            _ ->
                PRIM_CORE_WHILE c99-prim-default!
        ),

    _ -> c99-prim-default!)

def(c99-prim-default!, List(Arg) Prim +C99 -- +C99,
    name c99-call!)

def(c99-args-push!, List(Arg) +C99 -- +C99,
    for(c99-arg-push!))

def(c99-arg-push!, Arg +C99 -- +C99,
    ARG_BLOCK -> c99-block-push!)

def(c99-arg-run!, Arg +C99 -- +C99,
    ARG_BLOCK -> c99-block-run!)

def(c99-block-run!, Block +C99 -- +C99,
    arrow c99-arrow!)

def(Var+C99.var, Var +C99 -- +C99, "var_" . name .name)
def(Param+C99.param, Param +C99 -- +C99, >Var .var)

def(c99-pack-ctx!, Ctx +C99 -- +C99,
    c99-line("push_u64(0);" .)
    physical-vars for(
        c99-var-push!
        c99-line("mw_prim_pack_cons();" .)
    ))

def(c99-unpack-ctx!, Ctx +C99 -- +C99,
    physical-vars reverse-for(
        c99-line("mw_prim_pack_uncons();" .)
        c99-line("VAL " . .var " = pop_value();" .)
    )
    c99-line("mw_prim_drop();" .))

def(c99-decref-ctx!, Ctx +C99 -- +C99,
    physical-vars reverse-for(
        c99-line("decref(" . .var ");" .)
    ))

def(c99-block-push!, Block +C99 -- +C99,
    dup block-to-run-var match(
        SOME -> nip c99-var-push!,
        NONE ->
            dup ctx c99-pack-ctx!
            c99-line("push_fnptr(&" . .block ");" .)
            c99-line("mw_prim_pack_cons();" .)
    ))

def(c99-var!, Var +C99 -- +C99,
    dup auto-run? if(c99-var-run!, c99-var-push!))

def(c99-var-run!, Var +C99 -- +C99,
    c99-line("incref(" . dup .var ");" .)
    c99-line("run_value(" . dup .var ");" .)
    drop)

def(c99-var-push!, Var +C99 -- +C99,
    c99-line("incref(" . dup .var ");" .)
    c99-line("push_value(" . dup .var ");" .)
    drop)

def(c99-lambda!, Lambda +C99 -- +C99,
    c99-line("{" .)
    c99-nest(
        dup params reverse-for(
            c99-line("VAL " . .param " = pop_value();" .)
        )
        dup body c99-arrow!
        params reverse-for(
            c99-line("decref(" . .param ");" .)
        )
    )
    c99-line("}" .))

def(c99-match!, Match +C99 -- +C99,
    dup is-transparent? if(
        cases first unwrap body c99-arrow!,

        dup scrutinee-data?
        unwrap-or(token "non-uniform match, not supported at present" emit-fatal-error!)
        is-resource? if(
            c99-line("switch (get_top_resource_data_tag()) {" .),
            c99-line("switch (get_top_data_tag()) {" .)
        )
        c99-nest(
            dup cases for(c99-case!)
            has-default-case? else(
                c99-line("default: write(2, \"unexpected fallthrough in match\\n\", 32); mw_prim_debug(); exit(99);" .)
            )
        )
        c99-line("}").
    ))

def(c99-case!, Case +C99 -- +C99,
    dup pattern c99-pattern!
    c99-nest(
        body c99-arrow!
        c99-line("break;" .)
    ))

def(c99-pattern!, Pattern +C99 -- +C99,
    PATTERN_UNDERSCORE ->
        c99-line("default:" .),

    PATTERN_TAG ->
        c99-line("case " . dup value .n "LL:" .)
        c99-nest(
            c99-line("co_" . name .name "();" .)
        )
    )

def(c99-word-sigs!, +C99 -- +C99, for-needed-words(c99-word-sig!) .lf)
def(c99-word-sig!, Word +C99 -- +C99,
    c99-line("static void mw_" . name .name " (void);" .))

def(c99-block-sigs!, +C99 -- +C99, for-needed-blocks(c99-block-sig!) .lf)
def(c99-block-sig!, Block +C99 -- +C99,
    c99-line("static void " . .block " (void);" .))

def(c99-field-sigs!, +C99 -- +C99, Field.for(c99-field-sig!) .lf)
def(c99-field-sig!, Field +C99 -- +C99,
    c99-line("static void mw_" . name .name " (void);" .))

def(c99-block-enter!, Block +C99 -- +C99,
    c99-line("WORD_ENTER(" .
        dup .block ", " .
        dup arrow home match(
            NONE -> "block",
            SOME -> name >Str " block" cat,
        ) .str ", " .
        dup token .module source-path >Str .str ", " .
        dup token row >Int .n ", " .
        dup token col >Int .n ");" . )
    drop)

def(c99-block-exit!, Block +C99 -- +C99,
    c99-line("WORD_EXIT(" . .block ");" .))

def(c99-block-defs!, +C99 -- +C99, for-needed-blocks(c99-block-def!) .lf)
def(c99-block-def!, Block +C99 -- +C99,
    c99-line("static void " . dup .block " (void) {" .)
    c99-nest(
        dup c99-block-enter!
        dup arrow
        dup ctx c99-unpack-ctx!
        dup c99-arrow!
        ctx c99-decref-ctx!
        c99-block-exit!
    )
    c99-line("}" .) .lf)

def(Block+C99.block, Block +C99 -- +C99,
    "mb_" .
    dup arrow dup home match(
        NONE -> drop Block.id .n,
        SOME ->
            name .name "_" .
            homeidx .n drop
    ))

def(c99-word-enter!, Word +C99 -- +C99,
    c99-line("WORD_ENTER(" .
        "mw_" . dup name .name ", " .
        dup name >Str .str ", " .
        dup body .module source-path >Str .str ", " .
        dup body row >Int .n ", " .
        dup body col >Int .n ");" . )
    drop)

def(c99-word-exit!, Word +C99 -- +C99,
    c99-line("WORD_EXIT(" .
        "mw_" . dup name .name ");" .)
    drop)

def(c99-word-defs!, +C99 -- +C99, for-needed-words(c99-word-def!) .lf)
def(c99-word-def!, Word +C99 -- +C99,
    c99-line(dup name .w "{" .)
    c99-nest(
        dup c99-word-enter!
        dup arrow c99-arrow!
        dup c99-word-exit!
    )
    c99-line("}" .)
    drop)

def(c99-field-defs!, +C99 -- +C99, Field.for(c99-field-def!) .lf)
def(c99-field-def!, Field +C99 -- +C99,
    "static VAL* fieldptr_" . dup name .name " (size_t i) {" ;
    "    static struct VAL * p = 0;";
    "    size_t m = " . TABLE_MAX_SIZE .n ";" ;
    "    if (! p) { p = calloc(m, sizeof *p); }" ;
    "    if (i>=m) { write(2,\"table too big\\n\",14); exit(123); }" ;
    "    return p+i;" ;
    "}" ;;  # TODO make this more flexible wrt table size
            # note it's important to have stability,
            # so we can't just realloc as we used to.
    dup name .w "{" ;
    "    size_t index = (size_t)pop_u64();" ;
    "    VAL *v = fieldptr_" . dup name .name "(index);" ;
    "    push_ptr(v);" ;
    "}" ;;

    drop)

def(c99-main!, Arrow +C99 -- +C99,
    c99-line("int main (int argc, char** argv) {" .)
    c99-nest(
        c99-line("global_argc = argc;" .)
        c99-line("global_argv = argv;" .)
        c99-line("WORD_ENTER(" .
            "(void(*)(void))0, " .
            "\"<main>\", " .
            dup token-start .module source-path >Str .str ", " .
            dup token-start row >Int .n ", " .
            dup token-start col >Int .n ");" .)
        c99-arrow!
        c99-line("WORD_EXIT((void(*)(void))0);" .)
        c99-line("return 0;" .)
    )
    c99-line("}" .))
