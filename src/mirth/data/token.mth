module(mirth/data/token)
import(mirth/data/common)
import(mirth/data/name)
import(mirth/data/string)
import(mirth/data/location)
import(mirth/data/error)

##########
# Tokens #
##########

def(num-tokens@, Int, Token.NUM int@)

def(MAX_TOKENS, Size, 0x10000)
def(|Token|, Size, 2)
def(Token->U16, Token -- U16, Token->Int Int->U16)
def(U16->Token, U16 -- Token, U16->Int Int->Token)
def(Token->Int, Token -- Int, cast)
def(Int->Token, Int -- Token, cast)
def(token@, Ptr -- Token, u16@ U16->Token)
def(token!, Token Ptr --, dip(Token->U16) u16!)

def(token-alloc!, Token,
    Token.alloc!
    TOKEN_NONE over token-value!)

def(token-is-int?, Token -- Token Bool,
    token-value? match(TOKEN_INT -> drop true, _ -> drop false))
def(token-is-str?, Token -- Token Bool,
    token-value? match(TOKEN_STR -> drop true, _ -> drop false))
def(token-is-name?, Token -- Token Bool,
    token-value? match(TOKEN_NAME -> drop true, _ -> drop false))

token-is-lbracket? : Token -- Token Bool
token-is-lbracket? =
    token-value? match(TOKEN_LBRACKET -> drop true, _ -> drop false)

token-is-comma? : Token -- Token Bool
token-is-comma? =
    token-value? match(TOKEN_COMMA -> true, _ -> drop false)

token-is-lparen? : Token -- Token Bool
token-is-lparen? =
    token-value? match(TOKEN_LPAREN -> drop true, _ -> drop false)

token-is-rparen? : Token -- Token Bool
token-is-rparen? =
    token-value? match(TOKEN_RPAREN -> drop true, _ -> drop false)

token-is-lbrace? : Token -- Token Bool
token-is-lbrace? =
    token-value? match(TOKEN_LBRACE -> drop true, _ -> drop false)

||| Is this a newline token?
token-is-newline? : Token -- Token Bool
token-is-newline? =
    token-value? match(
        TOKEN_NEWLINE -> true,
        _ -> drop false
    )

||| Get token name value, or raise a fatal error.
token-name@ : Token -- Name
token-name@ =
    token-value? match(
        TOKEN_NAME -> nip,
        _ -> drop "expected name" emit-fatal-error!
    )

||| Get token name value, or raise a fatal error.
token-name? : Token -- Token Name
token-name? = dup token-name@


||| Get token string literal, or raise a fatal error.
token-strlit@ : Token -- StrLit
token-strlit@ =
    token-value? match(
        TOKEN_STR -> nip,
        _ -> drop "expected string" emit-fatal-error!
    )

||| Get token string literal, or raise a fatal error.
token-strlit? : Token -- Token StrLit
token-strlit? = dup token-strlit@

||| Get token integer, or raise a fatal error.
token-int@ : Token -- Int
token-int@ =
    token-value? match(
        TOKEN_INT -> nip,
        _ -> drop "expected int" emit-fatal-error!
    )

||| Get token integer, or raise a fatal error.
token-int? : Token -- Token Int
token-int? = dup token-int@

||| Is this an arg ending (COMMA, RPAREN, RBRACKET, RBRACE)?
def(token-is-arg-end?, Token -- Token Bool,
    token-value? match(
        TOKEN_COMMA -> true,
        TOKEN_RPAREN -> drop true,
        TOKEN_RBRACKET -> drop true,
        TOKEN_RBRACE -> drop true,
        _ -> drop false
    ))

def(token-is-left-enclosure?, Token -- Token Bool,
    token-value? match(
        TOKEN_LPAREN -> drop true,
        TOKEN_LBRACKET -> drop true,
        TOKEN_LBRACE -> drop true,
        _ -> drop false
    ))

def(token-is-right-enclosure?, Token -- Token Bool,
    token-value? match(
        TOKEN_RPAREN -> drop true,
        TOKEN_RBRACKET -> drop true,
        TOKEN_RBRACE -> drop true,
        _ -> drop false
    ))

def(token-location, Token -- Location,
    token-module? swap
    token-row? swap
    token-col@
    location-pack)
def(token-location?, Token -- Token Location,
    dup token-location)

# def(token-trace!, Token -- +IO,
#     token-location? location-trace!
#     ": " str-trace!
#     dup Token->Int int-trace! " " str-trace!
#     token-value@ match(
#         TOKEN_INT ->
#             "INT " str-trace! int-trace!,
#         TOKEN_STR ->
#             "STR \"" str-trace!
#             StrLit->Str int-trace!
#             "\"" str-trace!,
#     ))

# def(show-tokens!, --,
#     0
#     while(dup num-tokens@ <,
#         dup Int->Token token-trace! 1+)
#     drop)

# Get next token, without respecting nesting or arguments.
def(token-succ, Token -- Token,
    Token->Int 1+ Int->Token)

# Get prev token, without respecting nesting or arguments.
def(token-pred, Token -- Token,
    Token->Int 1- Int->Token)

# Get next token, respecting nesting of tokens and arguments.
def(token-next, Token -- Token,
    token-value? match(
        TOKEN_LPAREN -> nip token-succ,
        TOKEN_LBRACKET -> nip token-succ,
        TOKEN_LBRACE -> nip token-succ,
        TOKEN_NAME ->
            drop token-succ
            token-value? match(
                TOKEN_LPAREN -> nip token-succ,
                _ -> drop
            ),
        _ -> drop token-succ
    ))

# Get prev token, respecting nesting of tokens and arguments.
def(token-prev, Token -- Token,
    token-pred token-value? match(
        TOKEN_RBRACKET -> nip,
        TOKEN_RBRACE -> nip,
        TOKEN_RPAREN ->
            nip dup token-pred token-is-name? if(
                nip,
                drop
            ),
        _ -> drop
    ))

# Get closest arg ending (COMMA, RPAREN or RBRACKET),
# while respecting the nesting of tokens.
def(token-next-arg-end, Token -- Token,
    while(token-is-arg-end? not, token-next))


def(token-has-args?, Token -- Token Bool,
    token-is-name? if(
        dup token-succ token-is-lparen? nip,
        false
    ))


||| Get number of arguments or number of components in enclosed token.
def(token-num-args, Token -- Int,
    token-is-name? if(token-has-args? if(token-succ, id), id)
    token-is-left-enclosure? if(
        dip(0)
        while(token-is-right-enclosure? not,
            dip(1+) token-succ token-next-arg-end)
        drop,
        drop 0
    ))

def(token-num-args?, Token -- Token Int,
    dup token-num-args)

||| Verify that token has 0 args, and return them.
||| Emits a fatal error if arity is wrong.
def(token-args-0, Token --,
    token-num-args? 0 == if(
        drop,
        "expected no args" emit-fatal-error!
    ))

||| Verify that token has 1 arg, and return it.
||| Emits a fatal error if arity is wrong.
def(token-args-1, Token -- Token,
    token-num-args? 1 == if(
        token-is-name? if(token-succ, id)
        token-succ,
        token-num-args? 1 < if(
            "expected 1 arg, got none" emit-fatal-error!,
            "expected 1 arg, got too many" emit-fatal-error!
        )
    ))

||| Verify that token has 2 args, and return them.
||| Emits a fatal error if arity is wrong.
def(token-args-2, Token -- Token Token,
    token-num-args? 2 == if(
        token-is-name? if(token-succ, id)
        token-succ
        dup token-next-arg-end token-succ,

        token-num-args? 2 < if(
            "expected 2 args, got too few" emit-fatal-error!,
            "expected 2 args, got too many" emit-fatal-error!
        )
    ))

||| Verify that token has 3 args, and return them.
||| Emits a fatal error if arity is wrong.
def(token-args-3, Token -- Token Token Token,
    token-num-args? 3 == if(
        token-is-name? if(token-succ, id)
        token-succ
        dup token-next-arg-end token-succ
        dup token-next-arg-end token-succ,

        token-num-args? 3 < if(
            "expected 3 args, got too few" emit-fatal-error!,
            "expected 3 args, got too many" emit-fatal-error!
        )
    ))

def(emit-warning!, Token Str -- +IO, dip(token-location) emit-warning-at!)
def(emit-error!, Token Str -- +IO, dip(token-location) emit-error-at!)
def(emit-fatal-error!, *a Token Str -- *b +IO, dip(token-location) emit-fatal-error-at!)
