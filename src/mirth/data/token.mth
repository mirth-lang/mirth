module(mirth.data.token)
import(mirth.data.name)
import(mirth.data.location)
import(mirth.data.error)
import(data.list)

##########
# Tokens #
##########

# mirth/data/token
data(TokenValue,
    TOKEN_NONE,
    TOKEN_COMMA,
    TOKEN_LPAREN_OPEN,
    TOKEN_LPAREN -> Token,
    TOKEN_RPAREN -> Token,
    TOKEN_LSQUARE_OPEN,
    TOKEN_LSQUARE -> Token,
    TOKEN_RSQUARE -> Token,
    TOKEN_LCURLY_OPEN,
    TOKEN_LCURLY -> Token,
    TOKEN_RCURLY -> Token,
    TOKEN_INT -> Int,
    TOKEN_STR -> Str,
    TOKEN_NAME -> Name)
field(token-value, Token, TokenValue)
field(token-module, Token, Module)
field(token-row, Token, Row)
field(token-col, Token, Col)

def(token-alloc!, Token,
    Token.alloc!
    TOKEN_NONE over token-value !)

def(token-is-int?, Token -- Token Bool,
    dup token-value @ match(TOKEN_INT -> drop true, _ -> drop false))
def(token-is-str?, Token -- Token Bool,
    dup token-value @ match(TOKEN_STR -> drop true, _ -> drop false))
def(token-is-name?, Token -- Token Bool,
    dup token-value @ match(TOKEN_NAME -> drop true, _ -> drop false))
def(token-is-comma?, Token -- Token Bool,
    dup token-value @ match(TOKEN_COMMA -> true, _ -> drop false))
def(token-is-arrow?, Token -- Token Bool,
    PRIM_SYNTAX_ARROW token-prim=?)
def(token-is-dashes?, Token -- Token Bool,
    PRIM_SYNTAX_DASHES token-prim=?)
def(token-is-lparen-open?, Token -- Token Bool,
    dup token-value @ match(TOKEN_LPAREN_OPEN -> true, _ -> drop false))
def(token-is-lparen?, Token -- Token Bool,
    dup token-value @ match(TOKEN_LPAREN -> drop true, _ -> drop false))
def(token-is-rparen?, Token -- Token Bool,
    dup token-value @ match(TOKEN_RPAREN -> drop true, _ -> drop false))
def(token-is-lsquare-open?, Token -- Token Bool,
    dup token-value @ match(TOKEN_LSQUARE_OPEN -> true, _ -> drop false))
def(token-is-lsquare?, Token -- Token Bool,
    dup token-value @ match(TOKEN_LSQUARE -> drop true, _ -> drop false))
def(token-is-rsquare?, Token -- Token Bool,
    dup token-value @ match(TOKEN_RSQUARE -> drop true, _ -> drop false))
def(token-is-lcurly-open?, Token -- Token Bool,
    dup token-value @ match(TOKEN_LCURLY_OPEN -> true, _ -> drop false))
def(token-is-lcurly?, Token -- Token Bool,
    dup token-value @ match(TOKEN_LCURLY -> drop true, _ -> drop false))
def(token-is-rcurly?, Token -- Token Bool,
    dup token-value @ match(TOKEN_RCURLY -> drop true, _ -> drop false))

||| Get token name value, or raise a fatal error.
def(token-name@, Token -- Name,
    dup token-value @ match(
        TOKEN_NAME -> nip,
        _ -> drop "expected name" emit-fatal-error!
    ))

||| Get token name value, or raise a fatal error.
def(token-name?, Token -- Token Name,
    dup token-name@)

||| Get token string literal, or raise a fatal error.
def(token-str@, Token -- Str,
    dup token-value @ match(
        TOKEN_STR -> nip,
        _ -> drop "expected string" emit-fatal-error!
    ))

||| Get token string literal, or raise a fatal error.
def(token-str?, Token -- Token Str,
    dup token-str@)

||| Get token integer, or raise a fatal error.
def(token-int@, Token -- Int,
    dup token-value @ match(
        TOKEN_INT -> nip,
        _ -> drop "expected int" emit-fatal-error!
    ))

||| Get token integer, or raise a fatal error.
def(token-int?, Token -- Token Int,
    dup token-int@)

||| Is this an arg ending (COMMA, RPAREN, RSQUARE, RCURLY)?
def(token-is-arg-end?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_COMMA -> true,
        TOKEN_RPAREN -> drop true,
        TOKEN_RSQUARE -> drop true,
        TOKEN_RCURLY -> drop true,
        _ -> drop false
    ))

def(token-is-left-enclosure?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_LPAREN -> drop true,
        TOKEN_LSQUARE -> drop true,
        TOKEN_LCURLY -> drop true,
        _ -> drop false
    ))

def(token-is-right-enclosure?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_RPAREN -> drop true,
        TOKEN_RSQUARE -> drop true,
        TOKEN_RCURLY -> drop true,
        _ -> drop false
    ))

def(token-location, Token -- Location,
    dup token-module @ swap
    dup token-row @ swap
    token-col @
    location-pack)
def(token-location?, Token -- Token Location,
    dup token-location)

# Get next token, without respecting nesting or arguments.
def(token-succ, Token -- Token, Token.succ)

# Get prev token, without respecting nesting or arguments.
def(token-pred, Token -- Token, Token.pred)

# Get next token, respecting nesting of tokens and arguments.
def(token-next, Token -- Token,
    dup token-value @ match(
        TOKEN_LPAREN -> nip token-succ,
        TOKEN_LSQUARE -> nip token-succ,
        TOKEN_LCURLY -> nip token-succ,
        TOKEN_NAME ->
            drop token-succ
            dup token-value @ match(
                TOKEN_LPAREN -> nip token-succ,
                _ -> drop
            ),
        _ -> drop token-succ
    ))

# Get prev token, respecting nesting of tokens and arguments.
def(token-prev, Token -- Token,
    token-pred dup token-value @ match(
        TOKEN_RSQUARE -> nip,
        TOKEN_RCURLY -> nip,
        TOKEN_RPAREN ->
            nip dup token-pred token-is-name? if(
                nip,
                drop
            ),
        _ -> drop
    ))

# Get closest arg ending (COMMA, RPAREN or RSQUARE),
# while respecting the nesting of tokens.
def(token-next-arg-end, Token -- Token,
    while(token-is-arg-end? not, token-next))


def(token-has-args?, Token -- Token Bool,
    token-is-name? if(
        dup token-succ token-is-lparen? nip,
        token-is-lparen?
    ))


||| Get number of arguments or number of components in enclosed token.
def(token-num-args, Token -- Int,
    token-is-name? if(token-has-args? if(token-succ, id), id)
    token-is-left-enclosure? if(
        dip(0)
        while(token-is-right-enclosure? not,
            dip(1+) token-succ token-next-arg-end)
        drop,
        drop 0
    ))

def(token-num-args?, Token -- Token Int,
    dup token-num-args)

||| Verify that token has 0 args, and return them.
||| Emits a fatal error if arity is wrong.
def(token-args-0, Token --,
    token-num-args? 0 == if(
        drop,
        "expected no args" emit-fatal-error!
    ))

||| Verify that token has 1 arg, and return it.
||| Emits a fatal error if arity is wrong.
def(token-args-1, Token -- Token,
    token-num-args? 1 == if(
        token-is-name? if(token-succ, id)
        token-succ,
        token-num-args? 1 < if(
            "expected 1 arg, got none" emit-fatal-error!,
            "expected 1 arg, got too many" emit-fatal-error!
        )
    ))

||| Verify that token has 2 args, and return them.
||| Emits a fatal error if arity is wrong.
def(token-args-2, Token -- Token Token,
    token-num-args? 2 == if(
        token-is-name? if(token-succ, id)
        token-succ
        dup token-next-arg-end token-succ,

        token-num-args? 2 < if(
            "expected 2 args, got too few" emit-fatal-error!,
            "expected 2 args, got too many" emit-fatal-error!
        )
    ))

||| Verify that token has 3 args, and return them.
||| Emits a fatal error if arity is wrong.
def(token-args-3, Token -- Token Token Token,
    token-num-args? 3 == if(
        token-is-name? if(token-succ, id)
        token-succ
        dup token-next-arg-end token-succ
        dup token-next-arg-end token-succ,

        token-num-args? 3 < if(
            "expected 3 args, got too few" emit-fatal-error!,
            "expected 3 args, got too many" emit-fatal-error!
        )
    ))

||| Get List of token args.
def(token-args, Token -- List(Token),
    token-has-args? if(
        token-is-name? if(token-succ, id)
        L0 swap while (
            token-is-args-end? not,
            token-succ sip(snoc)
            token-next-arg-end
        ) drop,
        drop L0
    ))

||| Check if we're at the end of the last argument.
||| A trailing comma is ignored.
def(token-is-args-end?, Token -- Token Bool,
    dup token-is-comma? if(token-succ,id)
    token-is-right-enclosure? nip)

||| Get List+ of token args.
||| Emits a fatal error if token has no args,
def(token-args+, Token -- List+(Token),
    dup token-args List->List+ match(
        NONE -> "expected args" emit-fatal-error!,
        SOME -> nip
    ))

||| Get one arg plus a nonempty list of the rest.
def(token-args-2+, Token -- Token List+(Token),
    dup token-args dup len 2 >= if(nip,
        drop "expected 2+ args" emit-fatal-error!)
    List->List+ unwrap uncons
    List->List+ unwrap)

def(emit-warning!, Token Str --,
    dip(token-location) emit-warning-at!)
def(emit-error!, Token Str --,
    dip(token-location) emit-error-at!)
def(emit-fatal-error!, *a Token Str -- *b,
    dip(token-location) emit-fatal-error-at!)

###############
# Token Types #
###############

||| Is this the end of a module?
def(token-is-module-end?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NONE -> true,
        _ -> drop false
    ))

||| Is this a token to stop running at?
def(token-run-end?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NONE -> true,
        TOKEN_COMMA -> true,
        TOKEN_RPAREN -> drop true,
        TOKEN_RSQUARE -> drop true,
        TOKEN_RCURLY -> drop true,
        _ -> drop false
    ))

def(token-run, Token -- List(Token),
    collect-while(token-run-end? not, sip(token-next)) nip)

def(token-run-has-arrow, Token -- Bool,
    token-run any(token-is-arrow?))

def(token-run-has-dashes, Token -- Bool,
    token-run any(token-is-dashes?))

###################
# Type Signatures #
###################

def(sig-is-stack-end?, Token -- Token Bool,
    token-is-dashes? if(
        true,
        token-run-end?
    ))

def(sig-is-stack-end2?, Token -- Token Bool,
    sig-is-stack-end? if(
        true,
        sig-token-is-effect-con?
    ))

def(sig-next-stack-end, Token -- Token,
    while(sig-is-stack-end? not, token-next))

def(sig-has-dashes, Token -- Bool,
    sig-next-stack-end token-is-dashes? nip)

def(sig-has-dashes?, Token -- Token Bool,
    dup sig-has-dashes)

def(sig-arity, Token -- Int Int,
    sig-has-dashes? if(
        sig-count-types
        token-next
        sig-count-types
        drop,

        sig-count-types
        drop 0 swap
    ))

def(sig-count-types, Token -- Int Token,
    0 swap while(sig-is-stack-end? not,
        sig-token-is-type? if(dip(1+), id)
        token-next
    ))

def(sig-token-is-type?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-could-be-type,
        _ -> drop false
    ))

def(sig-token-is-type-con?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-could-be-type-con,
        _ -> drop false
    ))

def(sig-token-is-type-hole?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-is-type-hole,
        _ -> drop false
    ))

def(token-is-underscore?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-is-underscore,
        _ -> drop false
    ))

def(sig-token-is-type-var?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-could-be-type-var,
        _ -> drop false
    ))
def(token-is-param-name?, Token -- Token Bool,
    sig-token-is-type-var?)

def(sig-token-is-stack-var?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-could-be-stack-var,
        _ -> drop false
    ))

def(sig-token-is-effect-con?, Token -- Token Bool,
    dup token-value @ match(
        TOKEN_NAME -> name-could-be-effect-con,
        _ -> drop false
    ))

def(sig-skip-dashes, Token -- Token,
    sig-has-dashes? if(
        sig-next-stack-end token-next,
        id
    ))
