
module(mirth/data/type)
import(mirth/data/common)
import(mirth/data/name)
import(mirth/data/var)

def(def-type!, Type Str --, name-new! name-type!)

def(init-types!, --,
    TYPE_INT "Int" def-type!
    TYPE_PTR "Ptr" def-type!
    TYPE_U8 "U8" def-type!
    TYPE_U16 "U16" def-type!
    TYPE_U32 "U32" def-type!
    TYPE_U64 "U64" def-type!
    TYPE_I8 "I8" def-type!
    TYPE_I16 "I16" def-type!
    TYPE_I32 "I32" def-type!
    TYPE_I64 "I64" def-type!
    TYPE_BOOL "Bool" def-type!)

#########
# Types #
#########

def(NameValue->Type, NameValue -- Type,
    match(
        DEF_TYPE -> id,
        _ -> "attempted to get type value from non-type name" panic!
    ))
def(Type->NameValue, Type -- NameValue, DEF_TYPE)
def(name-type!, Type Name --, dip(Type->NameValue) name-value!)
def(name-type@, Name -- Type, name-value@ NameValue->Type)
def(name-is-table?, Name -- Name Bool,
    name-is-type? if(
        dup name-type@ type-is-table,
        false
    ))

def(T*, Type Type -- Type, TTensor)
def(T->, Type Type -- Type, TMorphism)

def(T0, Type, TYPE_UNIT)
def(T1, Type -- Type, dip(T0) T*)
def(T2, Type Type -- Type, dip(T1) T*)
def(T3, Type Type Type -- Type, dip(T2) T*)
def(T4, Type Type Type Type -- Type, dip(T3) T*)
def(T5, Type Type Type Type Type -- Type, dip(T4) T*)
def(T6, Type Type Type Type Type Type -- Type, dip(T5) T*)

def(type-is-error, Type -- Bool, match(TYPE_ERROR -> true, _ -> drop false))
def(type-is-dont-care, Type -- Bool, match(TYPE_DONT_CARE -> true, _ -> drop false))
def(type-is-prim, Type -- Bool, match(TPrim -> drop true, _ -> drop false))
def(type-is-var, Type -- Bool, match(TVar -> drop true, _ -> drop false))
def(type-is-meta, Type -- Bool, match(TMeta -> drop true, _ -> drop false))
def(type-is-tensor, Type -- Bool, match(TTensor -> drop2 true, _ -> drop false))
def(type-is-morphism, Type -- Bool, match(TMorphism -> drop2 true, _ -> drop false))
def(type-is-table, Type -- Bool, match(TTable -> drop true, _ -> drop false))
def(type-is-hole, Type -- Bool, match(THole -> drop true, _ -> drop false))
def(type-is-app, Type -- Bool, match(TApp -> drop2 true, _ -> drop false))
def(type-is-data, Type -- Bool, match(TData -> drop true, _ -> drop false))

def(type-is-error?, Type -- Type Bool, dup type-is-error)
def(type-is-dont-care?, Type -- Type Bool, dup type-is-dont-care)
def(type-is-prim?, Type -- Type Bool, dup type-is-prim)
def(type-is-var?, Type -- Type Bool, dup type-is-var)
def(type-is-meta?, Type -- Type Bool, dup type-is-meta)
def(type-is-tensor?, Type -- Type Bool, dup type-is-tensor)
def(type-is-morphism?, Type -- Type Bool, dup type-is-morphism)
def(type-is-table?, Type -- Type Bool, dup type-is-table)
def(type-is-hole?, Type -- Type Bool, dup type-is-hole)
def(type-is-app?, Type -- Type Bool, dup type-is-app)
def(type-is-data?, Type -- Type Bool, dup type-is-data)

def(type-is-stack-var, Type -- Bool,
    type-is-var? if(
        type-get-var var-name@ name-could-be-stack-var,
        drop false
    ))
def(type-is-stack-var?, Type -- Type Bool, dup type-is-stack-var)

def(type-get-prim, Type -- PrimType,
    match(
        TPrim -> id,
        _ -> "compiler error: tried to get prim value on non-prim type" panic!,
    ))
def(type-get-var, Type -- Var,
    match(
        TVar -> id,
        _ -> "compiler error: tried to get var value on non-var type" panic!,
    ))
def(type-get-meta, Type -- MetaVar,
    match(
        TMeta -> id,
        _ -> "compiler error: tried to get meta value on non-meta type" panic!,
    ))
def(type-get-tensor, Type -- Type Type,
    match(
        TTensor -> id,
        _ -> "compiler error: tried to get tensor value on non-tensor type" panic!,
    ))
def(type-get-morphism, Type -- Type Type,
    match(
        TMorphism -> id,
        _ ->  "compiler error: tried to get morphism value on non-morphism type" panic!,
    ))
def(type-get-table, Type -- Table,
    match(
        TTable -> id,
        _ -> "compiler error: tried to get table value on non-table type" panic!,
    ))
def(type-get-hole, Type -- Name,
    match(
        THole -> id,
        _ -> "compiler error: tried to get hole name value on non-hole type" panic!,
    ))
def(type-get-app, Type -- Type Type,
    match(
        TApp -> id,
        _ -> "compiler error: tried to get app type value on non-app type" panic!,
    ))
def(type-get-data, Type -- Data,
    match(
        TData -> id,
        _ -> "compiler error: tried to get data type value on non-data type" panic!,
    ))

def(TYPE_TYPE, Type, PRIM_TYPE_TYPE TPrim) # type of types
def(TYPE_STACK, Type, PRIM_TYPE_STACK TPrim) # type of stack types
def(TYPE_EFFECT, Type, PRIM_TYPE_EFFECT TPrim) # type of effect types
def(TYPE_BOOL, Type, PRIM_TYPE_BOOL TPrim) # bool type
def(TYPE_INT, Type, PRIM_TYPE_INT TPrim) # generic integer type for integer literals
def(TYPE_PTR, Type, PRIM_TYPE_PTR TPrim) # generic pointer type (e.g. void*)
def(TYPE_U8, Type, PRIM_TYPE_U8 TPrim) # fixed width integer type -- unsigned 8 bit
def(TYPE_U16, Type, PRIM_TYPE_U16 TPrim) # fixed width integer type -- unsigned 16 bit
def(TYPE_U32, Type, PRIM_TYPE_U32 TPrim) # fixed width integer type -- unsigned 32 bit
def(TYPE_U64, Type, PRIM_TYPE_U64 TPrim) # fixed width integer type -- unsigned 64 bit
def(TYPE_I8, Type, PRIM_TYPE_I8 TPrim) # fixed width integer type -- signed 8 bit
def(TYPE_I16, Type, PRIM_TYPE_I16 TPrim) # fixed width integer type -- signed 16 bit
def(TYPE_I32, Type, PRIM_TYPE_I32 TPrim) # fixed width integer type -- signed 32 bit
def(TYPE_I64, Type, PRIM_TYPE_I64 TPrim) # fixed width integer type -- signed 64 bit

def(type-expand, Type -- Type,
    match(
        TMeta -> meta-expand,
        # TODO: expand/compute app type if this is reasonable
        _ -> id
    ))

# high level version of type-get-tensor that introduces metavars if needed
def(type-expand-tensor, Type -- Type Type,
    type-expand
    type-is-error? if(
        drop TYPE_ERROR TYPE_ERROR,

    type-is-meta? if( # undefined metavar -- introduce a tensor type
        meta-alloc! TMeta
        meta-alloc! TMeta
        TTensor
        swap type-unify!
        type-get-tensor,

        type-get-tensor
    )))

# high level version of type-get-morphism that introduces metavars if needed
def(type-expand-morphism, Type -- Type Type,
    type-expand
    type-is-meta? if( # undefined metavar -- introduce a morphism type
        meta-alloc! TMeta
        meta-alloc! TMeta
        TMorphism
        swap type-unify!
        type-get-morphism,

        type-get-morphism
    ))

buffer(ELAB_TOKEN, 8)
def(elab-token@, -- Token +Elab, ELAB_TOKEN token@)
def(elab-token!, Token -- +Elab, ELAB_TOKEN token!)
def(elab-emit-warning!, Str -- +Elab, dip(elab-token@) emit-warning!)
def(elab-emit-error!, Str -- +Elab, dip(elab-token@) emit-error!)
def(elab-emit-fatal-error!, *a Str -- *b +Elab, dip(elab-token@) emit-fatal-error!)

# Raise a type unification error.
def(type-unify-failed!, Type Type -- Type +Elab,
    elab-token@ token-location location-trace!
    ": error: Failed to unify " str-trace!
    dip(type-trace!)
    " with " str-trace!
    type-trace!
    trace-ln!
    TYPE_ERROR
    num-errors++)

# Unify two types. Raises an elaboration error if unification is impossible.
def(type-unify!, Type Type -- Type +Elab,
    dip(type-expand) type-expand

    dup type-is-hole if(
        type-get-hole
        type-hole-unify!,

    over type-is-hole if(
        swap
        type-get-hole
        type-hole-unify!,

    dup type-is-dont-care if(
        drop,

    over type-is-dont-care if(
        nip,

    dup2 == if(
        drop, # types are equal

    dup type-is-error if(
        drop2 TYPE_ERROR,

    over type-is-error if(
        drop2 TYPE_ERROR,

    dup type-is-meta if(
        type-get-meta meta-unify!,

    over type-is-meta if(
        swap type-get-meta meta-unify!,

    type-is-prim? if( # other than TYPE_ERROR, primitive types need to be exact matches.
        swap type-is-prim? if(
            type-get-prim swap type-get-prim
            type-prim-unify!,
            swap type-unify-failed!
        ),

    type-is-var? if( # type variables need to be exact matches.
        swap type-is-var? if(
            type-get-var swap type-get-var
            type-var-unify!,
            swap type-unify-failed!
        ),

    type-is-data? if( # data types neet to be exact matches
        swap type-is-data? if(
            type-get-data swap type-get-data
            type-data-unify!,
            swap type-unify-failed!
        ),

    type-is-table? if( # table types need to be exact matches
        swap type-is-table? if(
            type-get-table swap type-get-table
            type-table-unify!,
            swap type-unify-failed!
        ),

    type-is-tensor? if(
        swap
        type-is-tensor? if(
            swap
            dip(type-get-tensor)
            type-get-tensor dip(swap)
            type-unify! dip(type-unify!)
            TTensor,

            type-unify-failed!
        ),

    type-is-morphism? if(
        swap
        type-is-morphism? if(
            swap
            dip(type-get-morphism)
            type-get-morphism dip(swap)
            type-unify! dip(type-unify!)
            TMorphism,

            type-unify-failed!
        ),

    type-is-app? if(
        swap
        type-is-app? if(
            swap
            dip(type-get-app)
            type-get-app dip(swap)
            type-unify! dip(type-unify!)
            TApp,

            type-unify-failed!
        ),

    # TODO: unify param types

        type-unify-failed!
    )))))))))))))))))

def(type-prim-unify!, PrimType PrimType -- Type,
    dup2 == if(
        drop TPrim,
        dip(TPrim) TPrim type-unify-failed!
    ))
def(type-data-unify!, Data Data -- Type,
    dup2 == if(
        drop TData,
        dip(TData) TData type-unify-failed!
    ))
def(type-table-unify!, Table Table -- Type,
    dup2 == if(
        drop TTable,
        dip(TTable) TTable type-unify-failed!
    ))
def(type-var-unify!, Var Var -- Type,
    dup2 == if(
        drop TVar,
        dip(TVar) TVar type-unify-failed!
    ))

def(type-has-meta?, MetaVar Type -- MetaVar Type Bool,
    dup2 type-has-meta)

def(type-has-meta, MetaVar Type -- Bool,
    type-expand type-is-error? if(
        drop2 false,
        match(
            TYPE_ERROR -> drop false,
            TYPE_DONT_CARE -> drop false,
            TYPE_UNIT -> drop false,
            TPrim -> drop2 false,
            TVar -> drop2 false,
            THole -> drop2 false,
            TMeta -> ==,
            TTensor -> dip(type-has-meta? nip) swap if(drop2 true, type-has-meta),
            TMorphism -> dip(type-has-meta? nip) swap if(drop2 true, type-has-meta),
            TApp -> dip(type-has-meta? nip) swap if(drop2 true, type-has-meta),
            TData -> drop2 false,
            TTable -> drop2 false,
        )
    ))

def(type-trace-sig!, Type -- +IO,
    type-is-error? if(
        "<ERROR>" str-trace! drop,

        type-get-morphism swap
        dup TYPE_UNIT == if(
            drop,
            type-trace-stack!
            " " str-trace!
        )
        "--" str-trace!
        dup TYPE_UNIT == if(
            drop,
            " " str-trace!
            type-trace-stack!
        )
    ))

def(type-trace-stack!, Type -- +IO,
    type-is-tensor? if(
        type-get-tensor swap
        dup TYPE_UNIT == if(
            drop,
            type-trace-stack!
            " " str-trace!
        )
        type-trace!,

    type-is-stack-var? if(
        type-trace!,

        type-trace!
        " ." str-trace!
    )))

def(type-trace!, Type -- +IO,
    type-is-error? if(
        drop "ERROR" str-trace!,
        match(
            TYPE_ERROR -> "ERROR" str-trace!,
            TYPE_DONT_CARE -> "_" str-trace!,
            TYPE_UNIT -> "[]" str-trace!,
            TPrim -> type-trace-prim!,
            TVar -> var-name@ name-load! str-buf-trace!,
            TMeta -> "?" str-trace! MetaVar->Int int-trace!,
            TTensor -> "[" str-trace! TTensor type-trace-stack! "]" str-trace!,
            TMorphism -> "[" str-trace! TMorphism type-trace-sig! "]" str-trace!,
            TData -> data-name@ name-load! str-buf-trace!,
            TTable -> table-name@ name-load! str-buf-trace!,
            THole -> name-load! str-buf-trace!,
            TApp -> app-type-trace!
        )
    ))

def(type-trace-prim!, PrimType -- +IO,
    match(
        PRIM_TYPE_TYPE -> "<TYPE>",
        PRIM_TYPE_STACK -> "<STACK>",
        PRIM_TYPE_EFFECT -> "<EFFECT>",
        PRIM_TYPE_BOOL -> "BOOL",
        PRIM_TYPE_INT -> "Int",
        PRIM_TYPE_PTR -> "Ptr",
        PRIM_TYPE_U8 -> "U8",
        PRIM_TYPE_U16 -> "U16",
        PRIM_TYPE_U32 -> "U32",
        PRIM_TYPE_U64 -> "U64",
        PRIM_TYPE_I8 -> "I8",
        PRIM_TYPE_I16 -> "I16",
        PRIM_TYPE_I32 -> "I32",
        PRIM_TYPE_I64 -> "I64",
    ) str-trace!)

||| Freshen a type signature in preparation for type sig application.
def(type-freshen-sig, Subst Type -- Subst Type,
    type-sig-needs-fresh-stack-rest? if(
        type-freshen-sig-aux,

        type-freshen
    ))

def(type-sig-needs-fresh-stack-rest?, Type -- Type Bool,
    dup type-expand-morphism drop
    while(type-expand type-is-tensor?, type-get-tensor drop)
    TYPE_UNIT ==)

def(type-freshen-sig-aux, Subst Type -- Subst Type,
    meta-alloc! TMeta rotr
    type-expand-morphism
    dip(type-freshen-sig-stack) swap
    dip(type-freshen-sig-stack) swap
    T-> dip(nip))

def(type-freshen-sig-stack, Type Subst Type -- Type Subst Type,
    type-expand
    type-is-tensor? if(
        type-get-tensor
        dip(type-freshen-sig-stack) swap
        dip(type-freshen) swap
        T*,
        drop over
    ))

def(type-freshen, Subst Type -- Subst Type,
    type-freshen-aux drop)

def(type-freshen-aux, Subst Type -- Subst Type Bool,
    type-expand

    type-is-var? if(
        type-var-freshen,

    type-is-tensor? if(
        type-get-tensor
        dip(type-freshen-aux) rotr
        dip(dip(type-freshen-aux) swap) &&
        dip(swap TTensor),

    type-is-morphism? if(
        type-get-morphism
        dip(type-freshen-aux) rotr
        dip(dip(type-freshen-aux) swap) &&
        dip(swap TMorphism),

    type-is-app? if(
        type-get-app
        dip(type-freshen-aux) rotr
        dip(dip(type-freshen-aux) swap) &&
        dip(swap TApp),

        true
    )))))

def(type-var-freshen, Subst Type -- Subst Type Bool,
    type-get-var
    swap subst-has-var? if(
        tuck subst-get-var,
        meta-alloc! TMeta dup
        dip(rotr subst-new!)
    )
    false)

def(type-arity, Type -- Int,
    type-expand
    type-is-data? if(
        type-get-data data-arity@,

        drop 0
    ))

||| Get head of type.
def(type-head, Type -- Type,
    type-expand
    while(
        type-is-app?,
        type-get-app drop type-expand
    ))

##################
# Meta-var Types #
##################

def(Int->MetaVar, Int -- MetaVar, cast)
def(MetaVar->Int, MetaVar -- Int, cast)

def(meta-alloc!, MetaVar,
    MetaVar.alloc!
    dup MetaVar->Int MetaVar.MAX >= if(
        "compiler error: ran out of meta variables, increase MAX_METAS" panic!,
        id
    ))

def(meta-type!, Type MetaVar --, true over meta-is-defined! meta-type-raw!)
def(meta-type@, MetaVar -- Type,
    meta-is-defined? not if(
        "attempted to access undefined metavar" panic!,
        meta-type-raw@
    ))

def(meta-expand, MetaVar -- Type,
    meta-is-defined? if(
        dup dip(meta-type@ type-expand dup) meta-type!,
        TMeta
    ))

def(meta-unify!, Type MetaVar -- Type,
    meta-is-defined? if(
        meta-expand type-unify!,

    swap
    type-has-meta? if(
        swap TMeta type-unify-failed!,

        swap dip(dup)
        meta-type!
    )))

########
# Data #
########

def(Data->Int, Data -- Int, cast)
def(Int->Data, Int -- Data, cast)

##############
# Type Holes #
##############

def(type-hole-unify!, Type Name -- Type,
    dup 0 Int->Name == if(
        drop,
        THole type-trace!
        " ~ " str-trace!
        dup type-trace!
        trace-ln!
    ))

##########
# Tables #
##########

def(Table->Int, Table -- Int, cast)
def(Int->Table, Int -- Table, cast)

def(table-alloc!, Table,
    Table.alloc!
    dup Table->Int Table.MAX >= if(
        "compiler error: NUM_TABLES >= MAX_TABLES" panic!,
        id
    ))

##########
# Params #
##########

def(type-max-num-params, Type -- Int,
    type-expand
    type-is-meta? if(
        drop 1000000, # infinity params
    type-is-morphism? if(
        type-get-morphism drop 0 swap
        while(type-expand type-is-tensor?,
            type-get-tensor type-expand
            type-is-morphism? if(
                drop dip(1+),
            type-is-meta? if(
                drop dip(1+),
                drop2 TYPE_UNIT
            )))
        type-is-meta? if(
            drop 1000000 +, # infinity params
            drop
        ),
        drop 0
    )))

def(type-expand-params, Type Int -- List(Type) Type,
    dup 0 > if(
        swap type-expand-morphism
        dip(
            swap nil rotr
            while(dup 0 >, 1-
                dip(
                    type-expand-tensor
                    swap dip(snoc)
                )) drop
        ) T->,

        drop nil swap
    ))

############
# APP TYPE #
############

def(app-type-trace!, Type Type --,
    app-type-trace-open! ")" str-trace!)

def(app-type-trace-open!, Type Type --,
    swap
    type-is-app? if(
        type-get-app
        app-type-trace-open!
        ", " str-trace!
        type-trace!,

        type-trace!
        "(" str-trace!
        type-trace!
    ))

#########
# Subst #
#########

unSUBST : Subst -- Map(Var, Type)
unSUBST = match(SUBST -> id)

subst-nil : Subst
subst-nil = nil

subst-is-nil : Subst -- Bool
subst-is-nil = is-nil

subst-is-nil? : Subst -- Subst Bool
subst-is-nil? = is-nil?

subst-new! : Type Var Subst -- Subst
subst-new! = unSUBST rotr pack2 map-insert SUBST

subst-has-var : Var Subst -- Bool
subst-has-var = unSUBST swap map-has

subst-has-var? : Var Subst -- Var Subst Bool
subst-has-var? = dup2 subst-has-var

subst-get-var : Var Subst -- Type
subst-get-var =
    unSUBST swap map-lookup match(
        NONE -> TYPE_ERROR,
        SOME -> id
    )

subst-get-var? : Var Subst -- Var Subst Type
subst-get-var? = dup2 subst-get-var

||| If variable is in subst, unify new type with type in subst.
||| Otherwise, create larger subst with new binding.
subst-match-var : Type Var Subst -- Subst
subst-match-var =
    subst-has-var? if(
        dup dip(subst-get-var type-unify! drop),
        subst-new!
    )
