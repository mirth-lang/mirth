
module(mirth/data/type)
import(mirth/data/common)
import(mirth/data/name)
import(mirth/data/var)

def(def-type!, Type Str --, name-new! name-type!)

def(init-types!, --,
    TYPE_INT "Int" def-type!
    TYPE_PTR "Ptr" def-type!
    TYPE_U8 "U8" def-type!
    TYPE_U16 "U16" def-type!
    TYPE_U32 "U32" def-type!
    TYPE_U64 "U64" def-type!
    TYPE_I8 "I8" def-type!
    TYPE_I16 "I16" def-type!
    TYPE_I32 "I32" def-type!
    TYPE_I64 "I64" def-type!
    TYPE_BOOL "Bool" def-type!)

#########
# Types #
#########

def(NameValue->Type, NameValue -- Type,
    match(
        DEF_TYPE -> id,
        _ -> "attempted to get type value from non-type name" panic!
    ))
def(Type->NameValue, Type -- NameValue, DEF_TYPE)
def(name-type!, Type Name --, dip(Type->NameValue) name-value!)
def(name-type@, Name -- Type, name-value@ NameValue->Type)
def(name-is-table?, Name -- Name Bool,
    name-is-type? if(
        dup name-type@ type-is-table,
        false
    ))

def(T*, Type Type -- Type, TTensor)
def(T->, Type Type -- Type, TMorphism)

def(T0, Type, TYPE_UNIT)
def(T1, Type -- Type, dip(T0) T*)
def(T2, Type Type -- Type, dip(T1) T*)
def(T3, Type Type Type -- Type, dip(T2) T*)
def(T4, Type Type Type Type -- Type, dip(T3) T*)
def(T5, Type Type Type Type Type -- Type, dip(T4) T*)
def(T6, Type Type Type Type Type Type -- Type, dip(T5) T*)

def(type-is-error, Type -- Bool, match(TYPE_ERROR -> true, _ -> drop false))
def(type-is-dont-care, Type -- Bool, match(TYPE_DONT_CARE -> true, _ -> drop false))
def(type-is-prim, Type -- Bool, match(TPrim -> drop true, _ -> drop false))
def(type-is-var, Type -- Bool, match(TVar -> drop true, _ -> drop false))
def(type-is-meta, Type -- Bool, match(TMeta -> drop true, _ -> drop false))
def(type-is-tensor, Type -- Bool, match(TTensor -> drop2 true, _ -> drop false))
def(type-is-morphism, Type -- Bool, match(TMorphism -> drop2 true, _ -> drop false))
def(type-is-table, Type -- Bool, match(TTable -> drop true, _ -> drop false))
def(type-is-hole, Type -- Bool, match(THole -> drop true, _ -> drop false))
def(type-is-app, Type -- Bool, match(TApp -> drop2 true, _ -> drop false))
def(type-is-data, Type -- Bool, match(TData -> drop true, _ -> drop false))

def(type-is-error?, Type -- Type Bool, dup type-is-error)
def(type-is-dont-care?, Type -- Type Bool, dup type-is-dont-care)
def(type-is-prim?, Type -- Type Bool, dup type-is-prim)
def(type-is-var?, Type -- Type Bool, dup type-is-var)
def(type-is-meta?, Type -- Type Bool, dup type-is-meta)
def(type-is-tensor?, Type -- Type Bool, dup type-is-tensor)
def(type-is-morphism?, Type -- Type Bool, dup type-is-morphism)
def(type-is-table?, Type -- Type Bool, dup type-is-table)
def(type-is-hole?, Type -- Type Bool, dup type-is-hole)
def(type-is-app?, Type -- Type Bool, dup type-is-app)
def(type-is-data?, Type -- Type Bool, dup type-is-data)

def(type-is-stack-var, Type -- Bool,
    type-is-var? if(
        type-get-var var-name@ name-could-be-stack-var,
        drop false
    ))
def(type-is-stack-var?, Type -- Type Bool, dup type-is-stack-var)

def(type-get-prim, Type -- PrimType,
    match(
        TPrim -> id,
        _ -> "compiler error: tried to get prim value on non-prim type" panic!,
    ))
def(type-get-var, Type -- Var,
    match(
        TVar -> id,
        _ -> "compiler error: tried to get var value on non-var type" panic!,
    ))
def(type-get-meta, Type -- MetaVar,
    match(
        TMeta -> id,
        _ -> "compiler error: tried to get meta value on non-meta type" panic!,
    ))
def(type-get-tensor, Type -- Type Type,
    match(
        TTensor -> id,
        _ -> "compiler error: tried to get tensor value on non-tensor type" panic!,
    ))
def(type-get-morphism, Type -- Type Type,
    match(
        TMorphism -> id,
        _ ->  "compiler error: tried to get morphism value on non-morphism type" panic!,
    ))
def(type-get-table, Type -- Table,
    match(
        TTable -> id,
        _ -> "compiler error: tried to get table value on non-table type" panic!,
    ))
def(type-get-hole, Type -- Name,
    match(
        THole -> id,
        _ -> "compiler error: tried to get hole name value on non-hole type" panic!,
    ))
def(type-get-app, Type -- Type Type,
    match(
        TApp -> id,
        _ -> "compiler error: tried to get app type value on non-app type" panic!,
    ))
def(type-get-data, Type -- Data,
    match(
        TData -> id,
        _ -> "compiler error: tried to get data type value on non-data type" panic!,
    ))

def(TYPE_TYPE, Type, PRIM_TYPE_TYPE TPrim) # type of types
def(TYPE_STACK, Type, PRIM_TYPE_STACK TPrim) # type of stack types
def(TYPE_EFFECT, Type, PRIM_TYPE_EFFECT TPrim) # type of effect types
def(TYPE_BOOL, Type, PRIM_TYPE_BOOL TPrim) # bool type
def(TYPE_INT, Type, PRIM_TYPE_INT TPrim) # generic integer type for integer literals
def(TYPE_PTR, Type, PRIM_TYPE_PTR TPrim) # generic pointer type (e.g. void*)
def(TYPE_U8, Type, PRIM_TYPE_U8 TPrim) # fixed width integer type -- unsigned 8 bit
def(TYPE_U16, Type, PRIM_TYPE_U16 TPrim) # fixed width integer type -- unsigned 16 bit
def(TYPE_U32, Type, PRIM_TYPE_U32 TPrim) # fixed width integer type -- unsigned 32 bit
def(TYPE_U64, Type, PRIM_TYPE_U64 TPrim) # fixed width integer type -- unsigned 64 bit
def(TYPE_I8, Type, PRIM_TYPE_I8 TPrim) # fixed width integer type -- signed 8 bit
def(TYPE_I16, Type, PRIM_TYPE_I16 TPrim) # fixed width integer type -- signed 16 bit
def(TYPE_I32, Type, PRIM_TYPE_I32 TPrim) # fixed width integer type -- signed 32 bit
def(TYPE_I64, Type, PRIM_TYPE_I64 TPrim) # fixed width integer type -- signed 64 bit

def(type-expand, Type -- Type,
    match(
        TMeta -> meta-expand,
        # TODO: expand/compute app type if this is reasonable
        _ -> id
    ))

# high level version of type-get-tensor that introduces metavars if needed
def(type-expand-tensor, Type -- Type Type,
    type-expand
    type-is-error? if(
        drop TYPE_ERROR TYPE_ERROR,

    type-is-meta? if( # undefined metavar -- introduce a tensor type
        meta-alloc! TMeta
        meta-alloc! TMeta
        TTensor
        swap type-unify!
        type-get-tensor,

        type-get-tensor
    )))

# high level version of type-get-morphism that introduces metavars if needed
def(type-expand-morphism, Type -- Type Type,
    type-expand
    type-is-meta? if( # undefined metavar -- introduce a morphism type
        meta-alloc! TMeta
        meta-alloc! TMeta
        TMorphism
        swap type-unify!
        type-get-morphism,

        type-get-morphism
    ))

buffer(ELAB_TOKEN, 8)
def(elab-token@, -- Token +Elab, ELAB_TOKEN token@)
def(elab-token!, Token -- +Elab, ELAB_TOKEN token!)
def(elab-emit-warning!, Str -- +Elab, dip(elab-token@) emit-warning!)
def(elab-emit-error!, Str -- +Elab, dip(elab-token@) emit-error!)
def(elab-emit-fatal-error!, *a Str -- *b +Elab, dip(elab-token@) emit-fatal-error!)

# Raise a type unification error.
def(type-unify-failed!, Type Type -- Type +Elab,
    elab-token@ token-location location-trace!
    ": error: Failed to unify " str-trace!
    dip(type-trace!)
    " with " str-trace!
    type-trace!
    trace-ln!
    TYPE_ERROR
    num-errors++)

# Unify two types. Raises an elaboration error if unification is impossible.
def(type-unify!, Type Type -- Type +Elab,
    dip(type-expand) type-expand

    dup type-is-hole if(
        type-get-hole
        type-hole-unify!,

    over type-is-hole if(
        swap
        type-get-hole
        type-hole-unify!,

    dup type-is-dont-care if(
        drop,

    over type-is-dont-care if(
        nip,

    dup2 == if(
        drop, # types are equal

    dup type-is-error if(
        drop2 TYPE_ERROR,

    over type-is-error if(
        drop2 TYPE_ERROR,

    dup type-is-meta if(
        type-get-meta meta-unify!,

    over type-is-meta if(
        swap type-get-meta meta-unify!,

    type-is-prim? if( # other than TYPE_ERROR, primitive types need to be exact matches.
        swap type-is-prim? if(
            type-get-prim swap type-get-prim
            type-prim-unify!,
            swap type-unify-failed!
        ),

    type-is-var? if( # type variables need to be exact matches.
        swap type-is-var? if(
            type-get-var swap type-get-var
            type-var-unify!,
            swap type-unify-failed!
        ),

    type-is-data? if( # data types neet to be exact matches
        swap type-is-data? if(
            type-get-data swap type-get-data
            type-data-unify!,
            swap type-unify-failed!
        ),

    type-is-table? if( # table types need to be exact matches
        swap type-is-table? if(
            type-get-table swap type-get-table
            type-table-unify!,
            swap type-unify-failed!
        ),

    type-is-tensor? if(
        swap
        type-is-tensor? if(
            swap
            dip(type-get-tensor)
            type-get-tensor dip(swap)
            type-unify! dip(type-unify!)
            TTensor,

            type-unify-failed!
        ),

    type-is-morphism? if(
        swap
        type-is-morphism? if(
            swap
            dip(type-get-morphism)
            type-get-morphism dip(swap)
            type-unify! dip(type-unify!)
            TMorphism,

            type-unify-failed!
        ),

    type-is-app? if(
        swap
        type-is-app? if(
            swap
            dip(type-get-app)
            type-get-app dip(swap)
            type-unify! dip(type-unify!)
            TApp,

            type-unify-failed!
        ),

    # TODO: unify param types

        type-unify-failed!
    )))))))))))))))))

def(type-prim-unify!, PrimType PrimType -- Type,
    dup2 == if(
        drop TPrim,
        dip(TPrim) TPrim type-unify-failed!
    ))
def(type-data-unify!, Data Data -- Type,
    dup2 == if(
        drop TData,
        dip(TData) TData type-unify-failed!
    ))
def(type-table-unify!, Table Table -- Type,
    dup2 == if(
        drop TTable,
        dip(TTable) TTable type-unify-failed!
    ))
def(type-var-unify!, Var Var -- Type,
    dup2 == if(
        drop TVar,
        dip(TVar) TVar type-unify-failed!
    ))

def(type-has-meta?, MetaVar Type -- MetaVar Type Bool,
    dup2 type-has-meta)

def(type-has-meta, MetaVar Type -- Bool,
    type-expand type-is-error? if(
        drop2 false,
        match(
            TYPE_ERROR -> drop false,
            TYPE_DONT_CARE -> drop false,
            TYPE_UNIT -> drop false,
            TPrim -> drop2 false,
            TVar -> drop2 false,
            THole -> drop2 false,
            TMeta -> ==,
            TTensor -> dip(type-has-meta? nip) swap if(drop2 true, type-has-meta),
            TMorphism -> dip(type-has-meta? nip) swap if(drop2 true, type-has-meta),
            TApp -> dip(type-has-meta? nip) swap if(drop2 true, type-has-meta),
            TData -> drop2 false,
            TTable -> drop2 false,
        )
    ))

def(type-trace-sig!, Type -- +IO,
    type-is-error? if(
        "<ERROR>" str-trace! drop,

        type-get-morphism swap
        dup TYPE_UNIT == if(
            drop,
            type-trace-stack!
            " " str-trace!
        )
        "--" str-trace!
        dup TYPE_UNIT == if(
            drop,
            " " str-trace!
            type-trace-stack!
        )
    ))

def(type-trace-stack!, Type -- +IO,
    type-is-tensor? if(
        type-get-tensor swap
        dup TYPE_UNIT == if(
            drop,
            type-trace-stack!
            " " str-trace!
        )
        type-trace!,

    type-is-stack-var? if(
        type-trace!,

        type-trace!
        " ." str-trace!
    )))

def(type-trace!, Type -- +IO,
    type-is-error? if(
        drop "ERROR" str-trace!,
        match(
            TYPE_ERROR -> "ERROR" str-trace!,
            TYPE_DONT_CARE -> "_" str-trace!,
            TYPE_UNIT -> "[]" str-trace!,
            TPrim -> type-trace-prim!,
            TVar -> var-name@ name-load! str-buf-trace!,
            TMeta -> "?" str-trace! MetaVar->Int int-trace!,
            TTensor -> "[" str-trace! TTensor type-trace-stack! "]" str-trace!,
            TMorphism -> "[" str-trace! TMorphism type-trace-sig! "]" str-trace!,
            TData -> data-name@ name-load! str-buf-trace!,
            TTable -> table-name@ name-load! str-buf-trace!,
            THole -> name-load! str-buf-trace!,
            TApp -> app-type-trace!
        )
    ))

def(type-trace-prim!, PrimType -- +IO,
    match(
        PRIM_TYPE_TYPE -> "<TYPE>",
        PRIM_TYPE_STACK -> "<STACK>",
        PRIM_TYPE_EFFECT -> "<EFFECT>",
        PRIM_TYPE_BOOL -> "BOOL",
        PRIM_TYPE_INT -> "Int",
        PRIM_TYPE_PTR -> "Ptr",
        PRIM_TYPE_U8 -> "U8",
        PRIM_TYPE_U16 -> "U16",
        PRIM_TYPE_U32 -> "U32",
        PRIM_TYPE_U64 -> "U64",
        PRIM_TYPE_I8 -> "I8",
        PRIM_TYPE_I16 -> "I16",
        PRIM_TYPE_I32 -> "I32",
        PRIM_TYPE_I64 -> "I64",
    ) str-trace!)

||| Freshen a type signature in preparation for type sig application.
def(type-freshen-sig, Subst Type -- Subst Type,
    type-sig-needs-fresh-stack-rest? if(
        type-freshen-sig-aux,

        type-freshen
    ))

def(type-sig-needs-fresh-stack-rest?, Type -- Type Bool,
    dup type-expand-morphism drop
    while(type-expand type-is-tensor?, type-get-tensor drop)
    TYPE_UNIT ==)

def(type-freshen-sig-aux, Subst Type -- Subst Type,
    meta-alloc! TMeta rotr
    type-expand-morphism
    dip(type-freshen-sig-stack) swap
    dip(type-freshen-sig-stack) swap
    T-> dip(nip))

def(type-freshen-sig-stack, Type Subst Type -- Type Subst Type,
    type-expand
    type-is-tensor? if(
        type-get-tensor
        dip(type-freshen-sig-stack) swap
        dip(type-freshen) swap
        T*,
        drop over
    ))

def(type-freshen, Subst Type -- Subst Type,
    type-freshen-aux drop)

def(type-freshen-aux, Subst Type -- Subst Type Bool,
    type-expand

    type-is-var? if(
        type-var-freshen,

    type-is-tensor? if(
        type-get-tensor
        dip(type-freshen-aux) rotr
        dip(dip(type-freshen-aux) swap) &&
        dip(swap TTensor),

    type-is-morphism? if(
        type-get-morphism
        dip(type-freshen-aux) rotr
        dip(dip(type-freshen-aux) swap) &&
        dip(swap TMorphism),

    type-is-app? if(
        type-get-app
        dip(type-freshen-aux) rotr
        dip(dip(type-freshen-aux) swap) &&
        dip(swap TApp),

        true
    )))))

def(type-var-freshen, Subst Type -- Subst Type Bool,
    type-get-var
    swap subst-has-var? if(
        tuck subst-get-var,
        meta-alloc! TMeta dup
        dip(rotr subst-new!)
    )
    false)

def(type-arity, Type -- Int,
    type-expand
    type-is-data? if(
        type-get-data data-arity@,

        drop 0
    ))

||| Get head of type.
def(type-head, Type -- Type,
    type-expand
    while(
        type-is-app?,
        type-get-app drop type-expand
    ))

def(type-can-have-field?, Type -- Type Bool,
    dup match(
        TApp -> drop type-can-have-field? nip,
        TData -> data-is-enum? nip,
        TTable -> drop true,
        _ -> drop false
    ))

def(type-max-count, Type -- Int,
    match(
        TApp -> drop type-max-count,
        TData ->
            data-is-enum? if(
                data-tags@ len,
                "compiler error: cant determine max count for non-enum data type" panic!
            ),
        TTable -> table-max-count@,
        _ -> "compiler error: cant determine max count for non-fieldable type" panic!
    ))

##################
# Meta-var Types #
##################

def(Int->MetaVar, Int -- MetaVar, cast)
def(MetaVar->Int, MetaVar -- Int, cast)

def(meta-alloc!, MetaVar,
    MetaVar.alloc!
    dup MetaVar->Int MetaVar.MAX >= if(
        "compiler error: ran out of meta variables, increase MAX_METAS" panic!,
        id
    ))

def(meta-type!, Type MetaVar --, true over meta-is-defined! meta-type-raw!)
def(meta-type@, MetaVar -- Type,
    meta-is-defined? not if(
        "attempted to access undefined metavar" panic!,
        meta-type-raw@
    ))

def(meta-expand, MetaVar -- Type,
    meta-is-defined? if(
        dup dip(meta-type@ type-expand dup) meta-type!,
        TMeta
    ))

def(meta-unify!, Type MetaVar -- Type,
    meta-is-defined? if(
        meta-expand type-unify!,

    swap
    type-has-meta? if(
        swap TMeta type-unify-failed!,

        swap dip(dup)
        meta-type!
    )))

########
# Data #
########

def(Data->Int, Data -- Int, cast)
def(Int->Data, Int -- Data, cast)

##############
# Type Holes #
##############

def(type-hole-unify!, Type Name -- Type,
    dup 0 Int->Name == if(
        drop,
        THole type-trace!
        " ~ " str-trace!
        dup type-trace!
        trace-ln!
    ))

##########
# Tables #
##########

def(Table->Int, Table -- Int, cast)
def(Int->Table, Int -- Table, cast)

def(table-alloc!, Table,
    Table.alloc!
    dup Table->Int Table.MAX >= if(
        "compiler error: NUM_TABLES >= MAX_TABLES" panic!,
        id
    ))

##########
# Params #
##########

def(type-max-num-params, Type -- Int,
    type-expand
    type-is-meta? if(
        drop 1000000, # infinity params
    type-is-morphism? if(
        type-get-morphism drop 0 swap
        while(type-expand type-is-tensor?,
            type-get-tensor type-expand
            type-is-morphism? if(
                drop dip(1+),
            type-is-meta? if(
                drop dip(1+),
                drop2 TYPE_UNIT
            )))
        type-is-meta? if(
            drop 1000000 +, # infinity params
            drop
        ),
        drop 0
    )))

def(type-expand-params, Type Int -- List(Type) Type,
    dup 0 > if(
        swap type-expand-morphism
        dip(
            swap nil rotr
            while(dup 0 >, 1-
                dip(
                    type-expand-tensor
                    swap dip(snoc)
                )) drop
        ) T->,

        drop nil swap
    ))

############
# APP TYPE #
############

def(app-type-trace!, Type Type --,
    app-type-trace-open! ")" str-trace!)

def(app-type-trace-open!, Type Type --,
    swap
    type-is-app? if(
        type-get-app
        app-type-trace-open!
        ", " str-trace!
        type-trace!,

        type-trace!
        "(" str-trace!
        type-trace!
    ))

#########
# Subst #
#########

unSUBST : Subst -- Map(Var, Type)
unSUBST = match(SUBST -> id)

subst-nil : Subst
subst-nil = nil

subst-is-nil : Subst -- Bool
subst-is-nil = is-nil

subst-is-nil? : Subst -- Subst Bool
subst-is-nil? = is-nil?

subst-new! : Type Var Subst -- Subst
subst-new! = unSUBST rotr pack2 map-insert SUBST

subst-has-var : Var Subst -- Bool
subst-has-var = unSUBST swap map-has

subst-has-var? : Var Subst -- Var Subst Bool
subst-has-var? = dup2 subst-has-var

subst-get-var : Var Subst -- Type
subst-get-var =
    unSUBST swap map-lookup match(
        NONE -> TYPE_ERROR,
        SOME -> id
    )

subst-get-var? : Var Subst -- Var Subst Type
subst-get-var? = dup2 subst-get-var

||| If variable is in subst, unify new type with type in subst.
||| Otherwise, create larger subst with new binding.
subst-match-var : Type Var Subst -- Subst
subst-match-var =
    subst-has-var? if(
        dup dip(subst-get-var type-unify! drop),
        subst-new!
    )



#######
# TAG #
#######

NameValue->Tag : NameValue -- Tag
NameValue->Tag =
    match(
        DEF_TAG -> id,
        _ -> "attempted to get tag value from non-tag name" panic!
    )

Tag->NameValue : Tag -- NameValue
Tag->NameValue = DEF_TAG

Int->Tag : Int -- Tag
Int->Tag = cast

name-tag! : Tag Name --
name-tag! = dip(Tag->NameValue) name-value!

name-tag@ : Name -- Tag
name-tag@ = name-value@ NameValue->Tag

name-tag? : Name -- Name Tag
name-tag? = dup name-tag@

tag-num-inputs? : Tag -- Tag Int
tag-num-inputs? =
    # TODO: this should actually be calculated & stored during elaboration based on the type
    tag-has-sig? if(
        tag-sig? 0 swap
        while(token-run-end? not, token-next dip(1+)) drop,
        0
    )

########
# DATA #
########

data-num-tags : Data -- Int
data-num-tags = data-tags@ len

||| Adds constructor to data type, and gives tag its rank.
data-add-tag! : Tag Data -- +Mirth
data-add-tag! = (
    dup2 data-num-tags swap tag-value!
    data-tags? rotr dip(snoc) data-tags!
)

data-is-enum? : Data -- Data Bool
data-is-enum? = data-tags? all?(tag-num-inputs? 0 ==) nip

#########
# MATCH #
#########

match-is-empty? : Match -- Match Bool
match-is-empty? = match-cases? is-nil

match-num-cases? : Match -- Match Int
match-num-cases? = match-cases? len

match-add-case! : Match Case -- Match
match-add-case! =
    dip(match-cases?) cases-cover-case? if(
        case-token@ "Case is unreachable." emit-error! drop,
        snoc over match-cases!
    )

match-has-default-case : Match -- Bool
match-has-default-case = match-cases@ cases-have-default-case

match-has-default-case? : Match -- Match Bool
match-has-default-case? = dup match-has-default-case

||| Get type we're matching over.
match-scrutinee-type? : Match -- Match Type
match-scrutinee-type? = match-dom? type-expand-tensor nip

||| Is this a pattern match over a "data" type?
match-scrutinee-is-data? : Match -- Match Bool
match-scrutinee-is-data? = match-scrutinee-type? type-head type-is-data

||| Get "data" associated with scrutinee.
match-scrutinee-data? : Match -- Match Data
match-scrutinee-data? = match-scrutinee-type? type-head type-get-data

########
# CASE #
########

cases-cover-case? : List(Case) Case -- List(Case) Case Bool
cases-cover-case? = dup2 cases-cover-case

cases-cover-case : List(Case) Case -- Bool
cases-cover-case =
    over is-nil if(
        drop2 false,
        dip(unsnoc) case-is-covered? if(
            drop3 true,
            nip cases-cover-case
        )
    )

case-is-covered? : Case Case -- Case Case Bool
case-is-covered? = dup2 case-is-covered

case-is-covered : Case Case -- Bool
case-is-covered = dip(case-pattern@) case-pattern@ pattern-is-covered

cases-have-default-case : List(Case) -- Bool
cases-have-default-case =
    is-nil? if(
        drop false,
        unsnoc case-is-default-case if(
            drop true,
            cases-have-default-case
        )
    )

case-is-default-case? : Case -- Case Bool
case-is-default-case? = dup case-is-default-case

case-is-default-case : Case -- Bool
case-is-default-case = case-pattern@ pattern-is-underscore

###########
# PATTERN #
###########

Tag->Pattern : Tag -- Pattern
Tag->Pattern = PATTERN_TAG

Pattern->Tag : Pattern -- Tag
Pattern->Tag =
    match(
        PATTERN_TAG -> id,
        PATTERN_UNDERSCORE ->
            "compiler error: tried to call Pattern->Tag on underscore pattern" panic!,
    )

pattern-is-underscore : Pattern -- Bool
pattern-is-underscore = PATTERN_UNDERSCORE ==

pattern-is-underscore? : Pattern -- Pattern Bool
pattern-is-underscore? = dup pattern-is-underscore

pattern-is-covered : Pattern Pattern -- Bool
pattern-is-covered = swap pattern-is-underscore? if(drop2 true, ==)

pattern-is-covered? : Pattern Pattern -- Pattern Pattern Bool
pattern-is-covered? = dup2 pattern-is-covered
