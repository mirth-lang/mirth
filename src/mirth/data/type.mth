
module(mirth.data.type)

import(prelude)
import(platform.posix)
import(data.maybe)
import(data.list)
import(data.lazy)
import(mirth.data.ctx)
import(mirth.data.name)
import(mirth.data.token)
import(mirth.data.arrow)
import(mirth.data.location)
import(mirth.data.def)
import(mirth.data.var)
import(mirth.data.table)
import(mirth.data.error)

data(Type,
    TYPE_ERROR,
    TYPE_DONT_CARE,
    TPrim -> PrimType,
    TMeta -> MetaVar,
    THole -> Name,
    TVar -> Var,
    TTable -> Table,
    TData -> Data,
    TTensor -> Type Type,
    TMorphism -> Type Type,
    TApp -> Type Type,
    TMut -> Type,
    TValue -> Value)

data(Value,
    VALUE_INT -> Int,
    VALUE_STR -> Str,
    VALUE_BLOCK -> Block)

data(PrimType,
    PRIM_TYPE_UNIT,
    PRIM_TYPE_TYPE,
    PRIM_TYPE_STACK,
    PRIM_TYPE_EFFECT,
    PRIM_TYPE_INT,
    PRIM_TYPE_PTR,
    PRIM_TYPE_STR)

def(prim-type-is-physical, PrimType -- Bool,
    PRIM_TYPE_TYPE -> F,
    PRIM_TYPE_STACK -> F,
    PRIM_TYPE_EFFECT -> F,
    _ -> drop T)


||| Get the top type constructor name. 
def(stack-last-tycon-name, Type -- Maybe(Name),
    stack-last-type bind(type-tycon-name))

||| Get the known type constructor names for a stack type.
def(stack-tycon-names, Type -- List(Name),
    L0 swap stack-types for(type-tycon-name for(snoc)))

||| Get the known types on the stack.
def(stack-types, Type -- List(Type),
    TMeta -> meta-expand-if(stack-types, drop L0),
    TTensor -> dip(stack-types) snoc,
    _ -> drop L0)

||| Get last type on the stack, if known.
def(stack-last-type, Type -- Maybe(Type),
    TMeta -> meta-expand-if(stack-last-type, drop NONE),
    TTensor -> nip SOME,
    _ -> drop NONE)

||| Get type constructor name for a type, if possible.
def(type-tycon-name, Type -- Maybe(Name),
    TYPE_ERROR -> NONE,
    TYPE_DONT_CARE -> NONE,
    TPrim -> prim-type-tycon-name,
    TMeta -> meta-expand-if(type-tycon-name, drop NONE),
    THole -> drop NONE,
    TVar -> drop NONE,
    TTable -> table-name @ SOME,
    TData -> data-name @ SOME,
    TMorphism -> drop2 NONE,
    TTensor -> drop2 NONE,
    TApp -> drop type-tycon-name,
    TMut -> type-tycon-name,
    TValue -> value-tycon-name)

||| Get primitive type constructor name.
def(prim-type-tycon-name, PrimType -- Maybe(Name),
    PRIM_TYPE_TYPE -> NONE,
    PRIM_TYPE_STACK -> NONE,
    PRIM_TYPE_EFFECT -> NONE,
    PRIM_TYPE_INT -> "Int" name-new! SOME,
    PRIM_TYPE_STR -> "Str" name-new! SOME,
    PRIM_TYPE_PTR -> "Ptr" name-new! SOME,
    PRIM_TYPE_UNIT -> NONE)
    
||| Get value type constructor name.
def(value-tycon-name, Value -- Maybe(Name),
    VALUE_INT -> drop "Int" name-new! SOME,
    VALUE_STR -> drop "Str" name-new! SOME,
    VALUE_BLOCK -> drop NONE)

def(PrimType->Int, PrimType -- Int, prim-unsafe-cast)
def(prim-type==, PrimType PrimType -- Bool, both(PrimType->Int) =)

table(MetaVar)
table(Data)
table(Tag)

field(meta-type, MetaVar, Maybe(Type))

field(data-header, Data, Maybe(Token))
field(data-name, Data, Name)
field(data-arity, Data, Int)
field(data-tags, Data, List(Tag))

field(tag-data, Tag, Data)
field(tag-name, Tag, Name)
field(tag-value, Tag, Int)
field(tag-num-inputs, Tag, Int)
field(tag-sig, Tag, Maybe(Token))
field(tag-ctx-type, Tag, Lazy([Ctx Type]))

def(def-type!, Type Str --, dip(DEF_TYPE) name-new! ~Def !)

var(DATA_BOOL, Data)
var(TAG_T, Tag)
var(TAG_F, Tag)
def(TYPE_BOOL, Type, DATA_BOOL @ TData)

var(DATA_U64, Data) var(TAG_U64, Tag)
var(DATA_U32, Data) var(TAG_U32, Tag)
var(DATA_U16, Data) var(TAG_U16, Tag)
var(DATA_U8, Data) var(TAG_U8, Tag)
var(DATA_I64, Data) var(TAG_I64, Tag)
var(DATA_I32, Data) var(TAG_I32, Tag)
var(DATA_I16, Data) var(TAG_I16, Tag)
var(DATA_I8, Data) var(TAG_I8, Tag)
def(TYPE_U64, Type, DATA_U64 @ TData)
def(TYPE_U32, Type, DATA_U32 @ TData)
def(TYPE_U16, Type, DATA_U16 @ TData)
def(TYPE_U8, Type, DATA_U8 @ TData)
def(TYPE_I64, Type, DATA_I64 @ TData)
def(TYPE_I32, Type, DATA_I32 @ TData)
def(TYPE_I16, Type, DATA_I16 @ TData)
def(TYPE_I8, Type, DATA_I8 @ TData)

def(init-data!, Str Mut(Data) List(Mut(Tag)) --,
    dip(dip(Data.alloc! dup) !)
    map(dip(Tag.alloc! dup) !)
    { Str Data List(Tag) }
    dip(
        dip(name-new!) 
        dup2 data-name !
        tuck TData DEF_TYPE swap ~Def !
    )
    { Data List(Tag) }
    dup for(dip(over) tag-data !)
    over data-tags !
    { Data }
    0 over data-arity !
    NONE over data-header !
    drop)

def(init-tag!, Str Int Int Type Mut(Tag) --,
    @
    sip(ctx-empty rotr tag-data @ TData T1 T-> pack2 LAZY_READY) sip(tag-ctx-type !)
    sip(tag-num-inputs !)
    sip(tag-value !)
    dip(name-new!) dup2 tag-name !
    DEF_TAG swap ~Def !)

def(init-types!, --,
    "Bool" DATA_BOOL TAG_F TAG_T L2 init-data!
    "F" 0 0 T0 TAG_F init-tag!
    "T" 1 0 T0 TAG_T init-tag!

    "U64" DATA_U64 TAG_U64 L1 init-data! "Int>U64-unsafe" 0 1 TYPE_INT T1 TAG_U64 init-tag!
    "U32" DATA_U32 TAG_U32 L1 init-data! "Int>U32-unsafe" 0 1 TYPE_INT T1 TAG_U32 init-tag!
    "U16" DATA_U16 TAG_U16 L1 init-data! "Int>U16-unsafe" 0 1 TYPE_INT T1 TAG_U16 init-tag!
    "U8"  DATA_U8  TAG_U8  L1 init-data! "Int>U8-unsafe"  0 1 TYPE_INT T1 TAG_U8  init-tag!
    "I64" DATA_I64 TAG_I64 L1 init-data! "Int>I64-unsafe" 0 1 TYPE_INT T1 TAG_I64 init-tag!
    "I32" DATA_I32 TAG_I32 L1 init-data! "Int>I32-unsafe" 0 1 TYPE_INT T1 TAG_I32 init-tag!
    "I16" DATA_I16 TAG_I16 L1 init-data! "Int>I16-unsafe" 0 1 TYPE_INT T1 TAG_I16 init-tag!
    "I8"  DATA_I8  TAG_I8  L1 init-data! "Int>I8-unsafe"  0 1 TYPE_INT T1 TAG_I8  init-tag!

    TYPE_INT "Int" def-type!
    TYPE_PTR "Ptr" def-type!
    TYPE_STR "Str" def-type!)

#########
# Types #
#########

def(T*, Type Type -- Type, TTensor)
def(T->, Type Type -- Type, TMorphism)

def(T0, Type, TYPE_UNIT)
def(T1, Type -- Type, dip(T0) T*)
def(T2, Type Type -- Type, dip(T1) T*)
def(T3, Type Type Type -- Type, dip(T2) T*)
def(T4, Type Type Type Type -- Type, dip(T3) T*)
def(T5, Type Type Type Type Type -- Type, dip(T4) T*)
def(T6, Type Type Type Type Type Type -- Type, dip(T5) T*)

# def(type-is-error, Type -- Bool, match(TYPE_ERROR -> T, _ -> drop F))
# def(type-is-dont-care, Type -- Bool, match(TYPE_DONT_CARE -> T, _ -> drop F))
# def(type-is-prim, Type -- Bool, match(TPrim -> drop T, _ -> drop F))
# def(type-is-var, Type -- Bool, match(TVar -> drop T, _ -> drop F))
# def(type-is-meta, Type -- Bool, match(TMeta -> drop T, _ -> drop F))
# def(type-is-tensor, Type -- Bool, match(TTensor -> drop2 T, _ -> drop F))
def(type-is-morphism, Type -- Bool,
    TMorphism -> drop2 T,
    _ -> drop F)
# def(type-is-table, Type -- Bool, match(TTable -> drop T, _ -> drop F))
# def(type-is-hole, Type -- Bool, match(THole -> drop T, _ -> drop F))
# def(type-is-app, Type -- Bool, match(TApp -> drop2 T, _ -> drop F))
# def(type-is-data, Type -- Bool, match(TData -> drop T, _ -> drop F))

def(type-is-unit, Type -- Bool,
    TPrim -> match(
        PRIM_TYPE_UNIT -> T,
        _ -> drop F
    ),
    _ -> drop F)

def(type-equals-meta, MetaVar Type -- Bool,
    TMeta -> meta==,
    _ -> drop2 F)

# def(type-is-error?, Type -- Type Bool, dup type-is-error)
# def(type-is-dont-care?, Type -- Type Bool, dup type-is-dont-care)
# def(type-is-prim?, Type -- Type Bool, dup type-is-prim)
# def(type-is-var?, Type -- Type Bool, dup type-is-var)
# def(type-is-meta?, Type -- Type Bool, dup type-is-meta)
# def(type-is-tensor?, Type -- Type Bool, dup type-is-tensor)
def(type-is-morphism?, Type -- Type Bool, dup type-is-morphism)
# def(type-is-table?, Type -- Type Bool, dup type-is-table)
# def(type-is-hole?, Type -- Type Bool, dup type-is-hole)
# def(type-is-app?, Type -- Type Bool, dup type-is-app)
# def(type-is-data?, Type -- Type Bool, dup type-is-data)

def(type-is-physical, Type -- Bool,
    TMeta -> meta-expand-if(type-is-physical,
        "unbound meta at type-is-physical" panic!),
    TPrim -> prim-type-is-physical,
    _ -> drop T)

def(TYPE_TYPE, Type, PRIM_TYPE_TYPE TPrim) # type of types
def(TYPE_STACK, Type, PRIM_TYPE_STACK TPrim) # type of stack types
def(TYPE_EFFECT, Type, PRIM_TYPE_EFFECT TPrim) # type of effect types
def(TYPE_UNIT, Type, PRIM_TYPE_UNIT TPrim) # unit type
def(TYPE_INT, Type, PRIM_TYPE_INT TPrim) # generic integer type for integer literals
def(TYPE_PTR, Type, PRIM_TYPE_PTR TPrim) # generic pointer type (e.g. void*)
def(TYPE_STR, Type, PRIM_TYPE_STR TPrim) # string pointer (just a pointer but nominally)
# def(TYPE_U8, Type, PRIM_TYPE_U8 TPrim) # fixed width integer type -- unsigned 8 bit
# def(TYPE_U16, Type, PRIM_TYPE_U16 TPrim) # fixed width integer type -- unsigned 16 bit
# def(TYPE_U32, Type, PRIM_TYPE_U32 TPrim) # fixed width integer type -- unsigned 32 bit
# def(TYPE_U64, Type, PRIM_TYPE_U64 TPrim) # fixed width integer type -- unsigned 64 bit
# def(TYPE_I8, Type, PRIM_TYPE_I8 TPrim) # fixed width integer type -- signed 8 bit
# def(TYPE_I16, Type, PRIM_TYPE_I16 TPrim) # fixed width integer type -- signed 16 bit
# def(TYPE_I32, Type, PRIM_TYPE_I32 TPrim) # fixed width integer type -- signed 32 bit
# def(TYPE_I64, Type, PRIM_TYPE_I64 TPrim) # fixed width integer type -- signed 64 bit

def(type-expand, Type -- Type,
    TMeta -> meta-expand,
    _ -> id)

data(Gamma, GAMMA -> Token)
def(gamma-token@, Gamma -- Token, GAMMA -> id)
def(gamma-token?, Gamma -- Gamma Token, dup gamma-token@)

# Raise a type unification error.
def(type-unify-failed!, Gamma Type Type -- Gamma Type,
    dip2(gamma-token? token-location location-trace!)
    ": error: Failed to unify " trace!
    dip(type-trace!)
    " with " trace!
    type-trace!
    line-trace!
    TYPE_ERROR
    num-errors modify(1+))

# Unify two types. Raises an elaboration error if unification is impossible.
def(type-unify!, Gamma Type Type -- Gamma Type,
    swap type-expand match(
        TYPE_ERROR -> drop TYPE_ERROR,
        TYPE_DONT_CARE -> id,
        THole -> type-hole-unify!,
        TMeta ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TMeta,
                THole -> dip(TMeta) type-hole-unify!,
                _ -> swap meta-unify!,
            ),
        TVar ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TVar,
                THole -> dip(TVar) type-hole-unify!,
                TMeta -> dip(TVar) meta-unify!,
                TVar -> type-var-unify!,
                _ -> dip(TVar) type-unify-failed!,
            ),
        TPrim ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TPrim,
                THole -> dip(TPrim) type-hole-unify!,
                TMeta -> dip(TPrim) meta-unify!,
                TValue -> dip(TPrim) type-value-unify!,
                TPrim -> type-prim-unify!,
                _ -> dip(TPrim) type-unify-failed!,
            ),
        TData ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TData,
                THole -> dip(TData) type-hole-unify!,
                TMeta -> dip(TData) meta-unify!,
                TValue -> dip(TData) type-value-unify!,
                TData -> type-data-unify!,
                _ -> dip(TData) type-unify-failed!,
            ),
        TTable ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TTable,
                THole -> dip(TTable) type-hole-unify!,
                TMeta -> dip(TTable) meta-unify!,
                TValue -> dip(TTable) type-value-unify!,
                TTable -> type-table-unify!,
                _ -> dip(TTable) type-unify-failed!,
            ),
        TTensor ->
            rotl type-expand match(
                TYPE_ERROR -> drop2 TYPE_ERROR,
                TYPE_DONT_CARE -> TTensor,
                THole -> dip(TTensor) type-hole-unify!,
                TMeta -> dip(TTensor) meta-unify!,
                TValue -> dip(TTensor) type-value-unify!,
                TTensor -> type-unify-pair! TTensor,
                _ -> dip(TTensor) type-unify-failed!,
            ),
        TMorphism ->
            rotl type-expand match(
                TYPE_ERROR -> drop2 TYPE_ERROR,
                TYPE_DONT_CARE -> TMorphism,
                THole -> dip(TMorphism) type-hole-unify!,
                TMeta -> dip(TMorphism) meta-unify!,
                TValue -> dip(TMorphism) type-value-unify!,
                TMorphism -> type-unify-pair! TMorphism,
                _ -> dip(TMorphism) type-unify-failed!,
            ),
        TApp ->
            rotl type-expand match(
                TYPE_ERROR -> drop2 TYPE_ERROR,
                TYPE_DONT_CARE -> TApp,
                THole -> dip(TApp) type-hole-unify!,
                TMeta -> dip(TApp) meta-unify!,
                TValue -> dip(TApp) type-value-unify!,
                TApp -> type-unify-pair! TApp,
                _ -> dip(TApp) type-unify-failed!,
            ),
        TValue ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TValue,
                THole -> dip(TValue) type-hole-unify!,
                TMeta -> dip(TValue) meta-unify!, # this might be bad?
                TValue -> value-unify!,
                _ -> value-type-unify!
            ),
        TMut ->
            swap type-expand match(
                TYPE_ERROR -> drop TYPE_ERROR,
                TYPE_DONT_CARE -> TMut,
                THole -> dip(TMut) type-hole-unify!,
                TMeta -> dip(TMut) meta-unify!,
                TValue -> dip(TMut) type-value-unify!,
                TMut -> type-unify! TMut,
                _ -> dip(TMut) type-unify-failed!,
            ),
    ))

def(value-unify!, Gamma Value Value -- Gamma Type,
    swap match(
        VALUE_INT -> swap match(
            VALUE_INT -> dup2 = if(drop VALUE_INT TValue, drop2 TYPE_INT),
            VALUE_STR ->
                drop2 gamma-token?
                "Can't unify int value with string value."
                emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 gamma-token?
                "Can't unify int value with block."
                emit-error! TYPE_ERROR,
        ),

        VALUE_STR -> swap match(
            VALUE_STR -> dup2 = if(drop VALUE_STR TValue, drop2 TYPE_STR),
            VALUE_INT ->
                drop2 gamma-token?
                "Can't unify string value with int value."
                emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 gamma-token?
                "Can't unify string value with block."
                emit-error! TYPE_ERROR,
        ),

        VALUE_BLOCK -> swap match(
            VALUE_BLOCK ->
                dup2 = if(
                    drop VALUE_BLOCK TValue,
                    block-infer-type!
                    block-unify-type!
                ),
            VALUE_INT ->
                drop2 gamma-token?
                "Can't unify block with int value."
                emit-error! TYPE_ERROR,
            VALUE_STR ->
                drop2 gamma-token?
                "Can't unify block with string value."
                emit-error! TYPE_ERROR
        ),
    ))

def(type-value-unify!, Gamma Type Value -- Gamma Type,
    match(
        VALUE_INT -> drop TYPE_INT type-unify!,
        VALUE_STR -> drop TYPE_STR type-unify!,
        VALUE_BLOCK -> swap block-unify-type!, # technically inaccurate?
    ))

def(value-type-unify!, Gamma Value Type -- Gamma Type,
    swap match(
        VALUE_INT -> drop TYPE_INT swap type-unify!,
        VALUE_STR -> drop TYPE_STR swap type-unify!,
        VALUE_BLOCK -> swap block-unify-type!,
    ))

def(Arrow.type, Arrow -- Type, dup >dom swap >cod T->)
def(block-infer-type!, Block -- Type, >arrow type)

def(type-unify-pair!, Gamma Type Type Type Type -- Gamma Type Type,
    dip(swap dip(type-unify! swap)) type-unify! dip(swap))

def(type-prim-unify!, Gamma PrimType PrimType -- Gamma Type,
    dup2 prim-type== if(
        drop TPrim,
        dip(TPrim) TPrim type-unify-failed!
    ))
def(type-data-unify!, Gamma Data Data -- Gamma Type,
    dup2 data== if(
        drop TData,
        dip(TData) TData type-unify-failed!
    ))
def(type-table-unify!, Gamma Table Table -- Gamma Type,
    dup2 table== if(
        drop TTable,
        dip(TTable) TTable type-unify-failed!
    ))
def(type-var-unify!, Gamma Var Var -- Gamma Type,
    dup2 var== if(
        drop TVar,
        dip(TVar) TVar type-unify-failed!
    ))

def(type-has-meta?, MetaVar Type -- MetaVar Type Bool,
    dup2 type-has-meta)

def(type-has-meta, MetaVar Type -- Bool,
    TMeta -> meta-has-meta,
    TYPE_ERROR -> drop F,
    TYPE_DONT_CARE -> drop F,
    TPrim -> drop2 F,
    TVar -> drop2 F,
    THole -> drop2 F,
    TTensor -> type2-has-meta,
    TMorphism -> type2-has-meta,
    TApp -> type2-has-meta,
    TData -> drop2 F,
    TTable -> drop2 F,
    TValue -> value-type-has-meta,
    TMut -> type-has-meta)

def(type2-has-meta, MetaVar Type Type -- Bool,
    over2 swap type-has-meta if(drop2 T, type-has-meta))

def(meta-has-meta, MetaVar MetaVar -- Bool,
    dup meta-type @ match(
        NONE -> meta==,
        SOME -> nip type-has-meta
    ))

def(value-type-has-meta, MetaVar Value -- Bool,
    value-as-type type-has-meta)

def(type-trace-sig!, Type --,
    TMeta -> meta-expand-if(type-trace-sig!, meta-trace!),
    TYPE_ERROR -> "<ERROR>" trace!,
    TMorphism ->
        swap
        type-trace-stack-dom!
        "--" trace!
        type-trace-stack-cod!,
    _ -> type-trace-stack!)

def(type-trace-stack-dom!, Type --,
    type-expand dup type-is-unit if(
        drop,
        type-trace-stack!
        " " trace!
    ))

def(type-trace-stack-cod!, Type --,
    type-expand dup type-is-unit if(
        drop,
        " " trace!
        type-trace-stack!
    ))

def(type-trace-stack!, Type --,
    TMeta -> meta-expand-if(type-trace-stack!, meta-trace!),
    TTensor -> swap type-trace-stack-dom! type-trace!,
    TVar ->
        var-name @
        dup trace!
        could-be-stack-var
        if(id, " ." trace!),
    _ -> type-trace!)

def(type-trace!, Type --,
    TYPE_ERROR -> "<ERROR>" trace!,
    TYPE_DONT_CARE -> "_" trace!,
    TPrim -> type-trace-prim!,
    TVar -> var-name @ trace!,
    TMeta -> meta-trace!,
    TTensor -> "[" trace! TTensor type-trace-stack! "]" trace!,
    TMorphism -> "[" trace! TMorphism type-trace-sig! "]" trace!,
    TData -> data-name @ trace!,
    TTable -> table-name @ trace!,
    THole -> trace!,
    TApp -> app-type-trace!,
    TValue -> value-as-type type-trace!,
    TMut -> "!" trace! type-trace!,
    )

def(value-as-type, Value -- Type,
    match(
        VALUE_INT -> drop PRIM_TYPE_INT TPrim,
        VALUE_STR -> drop PRIM_TYPE_STR TPrim,
        VALUE_BLOCK -> sip(>dom) >cod T->
    ))

def(type-trace-prim!, PrimType --,
    match(
        PRIM_TYPE_TYPE -> "<TYPE>",
        PRIM_TYPE_STACK -> "<STACK>",
        PRIM_TYPE_EFFECT -> "<EFFECT>",
        PRIM_TYPE_UNIT -> "[]",
        PRIM_TYPE_INT -> "Int",
        PRIM_TYPE_PTR -> "Ptr",
        PRIM_TYPE_STR -> "Str",
    ) trace!)

||| Replace the stack rest with a metavar, if it's unit.
def(type-semifreshen-sig, Type -- Type,
    dup type-sig-needs-fresh-stack-rest if(
        type-semifreshen-sig-aux,
        id
    ))

def(type-semifreshen-sig-aux, Type -- Type,
    TMeta -> meta-expand-if(type-semifreshen-sig-aux, TMeta),
    TMorphism ->
        meta-alloc! TMeta rotr
        dip(type-semifreshen-sig-stack) swap
        dip(type-semifreshen-sig-stack) swap
        TMorphism nip,
    _ -> id)

def(type-semifreshen-sig-stack, Type Type -- Type Type,
    TMeta -> meta-expand-if(type-semifreshen-sig-stack, TMeta),
    TTensor -> dip(type-semifreshen-sig-stack) TTensor,
    TPrim ->
        match(
            PRIM_TYPE_UNIT -> dup,
            _ -> TPrim
        ),
    _ -> id)

||| Freshen a type signature in preparation for type sig application.
def(type-freshen-sig, Subst Type -- Subst Type,
    dup type-sig-needs-fresh-stack-rest if(
        type-freshen-sig-aux,
        type-freshen
    ))

def(type-stack-rest, Type -- Type,
    TMeta -> meta-expand-if(type-stack-rest, TMeta),
    TTensor -> drop type-stack-rest,
    _ -> id)

def(type-sig-needs-fresh-stack-rest, Type -- Bool,
    TMeta -> meta-expand-if(type-sig-needs-fresh-stack-rest, drop F),
    TMorphism ->
        type-stack-rest type-is-unit if(
            type-stack-rest type-is-unit,
            drop F
        ),
    _ -> drop F)

def(type-freshen-sig-aux, Subst Type -- Subst Type,
    TMeta -> meta-expand-if(type-freshen-sig-aux, TMeta),
    TMorphism ->
        meta-alloc! TMeta rot4r
        dip(type-freshen-sig-stack) swap
        dip(type-freshen-sig-stack) swap
        TMorphism dip(nip),
    _ -> type-freshen)

def(type-freshen-sig-stack, Type Subst Type -- Type Subst Type,
    TMeta -> meta-expand-if(type-freshen-sig-stack, meta-freshen),
    TTensor ->
        dip(type-freshen-sig-stack) swap
        dip(type-freshen) swap
        TTensor,
    TPrim ->
        match(
            PRIM_TYPE_UNIT -> over,
            _ -> TPrim
        ),
    _ -> type-freshen)

def(type-freshen, Subst Type -- Subst Type,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TData -> TData,
    TTable -> TTable,
    TValue -> TValue, # no need to freshen values
    TVar -> type-var-freshen,
    TMeta -> meta-freshen,
    TTensor -> type-pair-freshen TTensor,
    TMorphism -> type-pair-freshen TMorphism,
    TApp -> type-pair-freshen TApp,
    TMut -> type-freshen TMut,
    )

def(type-pair-freshen, Subst Type Type -- Subst Type Type,
    dip(type-freshen swap) type-freshen dip(swap))

def(meta-freshen, Subst MetaVar -- Subst Type,
    meta-expand-if(type-freshen, drop meta-alloc! TMeta))

def(type-var-freshen, Subst Var -- Subst Type,
    swap subst-has-var? if(
        tuck subst-get-var,
        meta-alloc! TMeta dup
        dip(rotr subst-new!)
    ))

def(type-rigidify-sig!, Ctx Type -- Ctx Type,
    TMeta ->
        meta-expand-or-update!(
            meta-alloc! TMeta
            meta-alloc! TMeta TMorphism
        ) type-rigidify-sig!,
    _ -> type-rigidify!)

def(type-rigidify-stack!, Ctx Type -- Ctx Type,
    TMeta ->
        meta-expand-or-update!(
            ctx-make-fresh-stack-type-var! TVar
        ) type-rigidify-stack!,
    TTensor ->
        dip(type-rigidify-stack!) swap
        dip(type-rigidify!) swap
        TTensor,
    TVar -> TVar,
    _ -> type-rigidify!)

def(type-rigidify!, Ctx Type -- Ctx Type,
    TMeta ->
        meta-expand-or-update!(
            ctx-make-fresh-type-var! TVar
        ) type-rigidify!,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TVar -> TVar,
    TTable -> TTable,
    TData -> TData,
    TApp ->
        dip(type-rigidify!) swap
        dip(type-rigidify!) swap
        TApp,
    TTensor ->
        dip(type-rigidify-stack!) swap
        dip(type-rigidify!) swap
        TTensor,
    TMorphism ->
        dip(type-rigidify-stack!) swap
        dip(type-rigidify-stack!) swap
        TMorphism,
    TValue ->
        type-rigidify-value!,
    TMut ->
        type-rigidify! TMut)

def(type-rigidify-value!, Ctx Value -- Ctx Type,
    VALUE_INT -> VALUE_INT TValue,
    VALUE_STR -> VALUE_STR TValue,
    VALUE_BLOCK -> >arrow type type-rigidify-sig!)

def(type-arity, Type -- Int,
    TMeta -> meta-expand-if(type-arity, drop 0),
    TData -> data-arity @,
    TApp -> drop type-arity 1-,
    _ -> drop 0)

||| Get head of type.
def(type-head, Type -- Type,
    TMeta -> meta-expand-if(type-head, TMeta),
    TApp -> drop type-head,
    _ -> id)

||| For types that can have a field associated with them,
||| get the number of values n, where the type's values
||| range from 0 to (n-1). This should not be too large.
|||
||| Do NOT return SOME(n) unless the type has values 0..n-1
def(type-max-count, Type -- Maybe(Int),
    TMeta -> meta-expand-if(type-max-count, drop NONE),
    TApp -> drop type-max-count,
    TTable -> table-max-count @ 1+ SOME,
    TData ->
        data-is-enum? if(
            data-tags @ len SOME,
            drop NONE
        ),
    _ -> drop NONE)

##################
# Meta-var Types #
##################

def(meta-trace!, MetaVar --,
    dup meta-type @ match(
        NONE -> "?" trace! MetaVar.id trace!,
        SOME -> nip type-trace!
    ))
def(meta-alloc!, MetaVar,
    MetaVar.alloc!
    NONE over meta-type !)
def(meta-expand-if(f,g), (*a Type -- *b, *a MetaVar -- *b) *a MetaVar -- *b,
    dup meta-type @ match(
        NONE -> g,
        SOME -> type-expand tuck SOME swap meta-type ! f
    ))
def(meta-expand, MetaVar -- Type,
    meta-expand-if(id, TMeta))
def(meta-unify!, Gamma Type MetaVar -- Gamma Type,
    dup meta-type @ match(
        SOME -> nip type-unify!,
        NONE -> dup2 swap type-equals-meta if(
            drop,
            swap type-has-meta? if(
                swap TMeta type-unify-failed!,
                tuck SOME swap meta-type !
            )
        )
    ))
def(meta-expand-or-update!(f), (*a -- *a Type) *a MetaVar -- *a Type,
    dup meta-type @ match(
        NONE -> dip(f dup SOME) meta-type !,
        SOME -> nip
    ))

def(meta==, MetaVar MetaVar -- Bool, both(MetaVar.id) =)

##############
# Type Holes #
##############

def(type-hole-unify!, Type Name -- Type,
    THole type-trace!
    " ~ " trace!
    dup type-trace!
    line-trace!)

##########
# Params #
##########

def(type-max-num-params, Type -- Int,
    TMeta -> meta-expand-if(type-max-num-params, drop 0),
    TMorphism -> drop type-num-morphisms-on-top,
    _ -> drop 0)

def(type-num-morphisms-on-top, Type -- Int,
    TMeta -> meta-expand-if(type-num-morphisms-on-top, drop 0),
    TTensor -> type-is-morphism if(type-num-morphisms-on-top 1+, drop 0),
    _ -> drop 0)

############
# APP TYPE #
############

def(app-type-trace!, Type Type --,
    app-type-trace-open! ")" trace!)

def(app-type-trace-open!, Type Type --,
    swap match(
        TApp ->
            app-type-trace-open!
            ", " trace!
            type-trace!,
        _ ->
            type-trace!
            "(" trace!
            type-trace!
    ))

#########
# Subst #
#########

# mirth/data/type
data(Subst,
    SUBST_NIL,
    SUBST_CON -> Subst Type Var)

def(subst-nil, Subst, SUBST_NIL)
def(subst-is-nil, Subst -- Bool, SUBST_NIL -> T, _ -> drop F)
def(subst-new!, Type Var Subst -- Subst, rotr SUBST_CON)
def(subst-has-var, Var Subst -- Bool,
    SUBST_NIL -> drop F,
    SUBST_CON -> nip over2 var== if(drop2 T, subst-has-var))
def(subst-has-var?, Var Subst -- Var Subst Bool,
    dup2 subst-has-var)
def(subst-get-var, Var Subst -- Type,
    SUBST_NIL -> drop TYPE_ERROR,
    SUBST_CON -> over3 var== if(dip(drop2), drop subst-get-var))
def(subst-get-var?, Var Subst -- Var Subst Type,
    dup2 subst-get-var)

||| If variable is in subst, unify new type with type in subst.
||| Otherwise, create larger subst with new binding.
def(subst-match-var, Gamma Type Var Subst -- Gamma Subst,
    subst-has-var? if(
        sip(subst-get-var type-unify! drop),
        subst-new!
    ))

#######
# TAG #
#######

def(tag-num-inputs-from-sig, Tag -- Tag Int,
    # TODO: this should actually be calculated & stored during elaboration based on the type
    dup tag-sig @ match(
        NONE -> 0,
        SOME ->
            0 swap
            while(token-run-end? not,
                token-next dip(1+))
            drop
    ))

def(tag-is-transparent?, Tag -- Tag Bool,
    dup tag-data @ data-is-transparent)

def(tag==, Tag Tag -- Bool, both(Tag.id) =)

########
# DATA #
########

def(data==, Data Data -- Bool, both(Data.id) =)
def(data-num-tags, Data -- Int, data-tags @ len)

||| Adds constructor to data type, and gives tag its rank.
def(data-add-tag!, Tag Data --,
    dup2 data-num-tags swap tag-value !
    dup data-tags @ rotr dip(snoc) data-tags !)

def(data-is-enum?, Data -- Data Bool,
    dup data-tags @ all?(dup tag-num-inputs @ 0=) nip)

def(data-is-transparent, Data -- Bool,
    data-tags @ match(
        L1 -> tag-num-inputs @ 1 =,
        _ -> drop F
    ))
