
module(mirth.data.type)

import(prelude)
import(platform.posix)
import(data.maybe)
import(data.list)
import(data.lazy)
import(mirth.data.ctx)
import(mirth.data.name)
import(mirth.data.token)
import(mirth.data.arrow)
import(mirth.data.location)
import(mirth.data.def)
import(mirth.data.var)
import(mirth.data.table)
import(mirth.data.error)
import(mirth.data.data)

data(Type,
    TYPE_ERROR,
    TYPE_DONT_CARE,
    TPrim -> PrimType,
    TMeta -> MetaVar,
    THole -> Name,
    TVar -> Var,
    TTable -> Table,
    TData -> Data,
    TTensor -> Type Type,
    TMorphism -> ArrowType,
    TApp -> Type Type,
    TMut -> Type,
    TValue -> Value)

data(Value,
    VALUE_INT -> Int,
    VALUE_STR -> Str,
    VALUE_BLOCK -> Block)

data(PrimType,
    PRIM_TYPE_UNIT,
    PRIM_TYPE_TYPE,
    PRIM_TYPE_STACK,
    PRIM_TYPE_EFFECT,
    PRIM_TYPE_INT,
    PRIM_TYPE_PTR,
    PRIM_TYPE_STR)

def(PrimType.is-physical?, PrimType -- Bool,
    PRIM_TYPE_TYPE -> F,
    PRIM_TYPE_STACK -> F,
    PRIM_TYPE_EFFECT -> F,
    _ -> drop T)

||| Get the top type constructor name.
def(Type.stack-last-tycon-name, Type -- Maybe(Name),
    stack-last-type bind(tycon-name))

||| Get the known type constructor names for a stack type.
def(Type.stack-tycon-names, Type -- List(Name),
    L0 swap stack-types for(tycon-name for(snoc)))

||| Get the known types on the stack.
def(Type.stack-types, Type -- List(Type),
    TMeta -> expand-if(stack-types, drop L0),
    TTensor -> dip(stack-types) snoc,
    _ -> drop L0)

||| Get last type on the stack, if known.
def(Type.stack-last-type, Type -- Maybe(Type),
    TMeta -> expand-if(stack-last-type, drop NONE),
    TTensor -> nip SOME,
    _ -> drop NONE)

||| Get type constructor name for a type, if possible.
def(Type.tycon-name, Type -- Maybe(Name),
    TYPE_ERROR -> NONE,
    TYPE_DONT_CARE -> NONE,
    TPrim -> tycon-name,
    TMeta -> expand-if(tycon-name, drop NONE),
    THole -> drop NONE,
    TVar -> drop NONE,
    TTable -> name SOME,
    TData -> name SOME,
    TMorphism -> drop NONE,
    TTensor -> drop2 NONE,
    TApp -> drop tycon-name,
    TMut -> tycon-name,
    TValue -> tycon-name)

||| Get primitive type constructor name.
def(PrimType.tycon-name, PrimType -- Maybe(Name),
    PRIM_TYPE_TYPE -> NONE,
    PRIM_TYPE_STACK -> NONE,
    PRIM_TYPE_EFFECT -> NONE,
    PRIM_TYPE_INT -> "Int" >Name SOME,
    PRIM_TYPE_STR -> "Str" >Name SOME,
    PRIM_TYPE_PTR -> "Ptr" >Name SOME,
    PRIM_TYPE_UNIT -> NONE)

||| Get value type constructor name.
def(Value.tycon-name, Value -- Maybe(Name),
    VALUE_INT -> drop "Int" >Name SOME,
    VALUE_STR -> drop "Str" >Name SOME,
    VALUE_BLOCK -> drop NONE)

def(PrimType>Int, PrimType -- Int, prim-unsafe-cast)
def(PrimType=, PrimType PrimType -- Bool, both(>Int) =)

def(def-type!, Type Str --, dip(DEF_TYPE) >Name ~Def !)

def(init-types!, --,
    TYPE_INT "Int" def-type!
    TYPE_PTR "Ptr" def-type!
    TYPE_STR "Str" def-type!
    init-data!)

#########
# Types #
#########

def(T*, Type Type -- Type, TTensor)
def(T->, Type Type -- Type, ARROW_TYPE TMorphism)

def(T0, Type, TYPE_UNIT)
def(T1, Type -- Type, dip(T0) T*)
def(T2, Type Type -- Type, dip(T1) T*)
def(T3, Type Type Type -- Type, dip(T2) T*)
def(T4, Type Type Type Type -- Type, dip(T3) T*)
def(T5, Type Type Type Type Type -- Type, dip(T4) T*)
def(T6, Type Type Type Type Type Type -- Type, dip(T5) T*)

# def(type-is-error, Type -- Bool, match(TYPE_ERROR -> T, _ -> drop F))
# def(type-is-dont-care, Type -- Bool, match(TYPE_DONT_CARE -> T, _ -> drop F))
# def(type-is-prim, Type -- Bool, match(TPrim -> drop T, _ -> drop F))
# def(type-is-var, Type -- Bool, match(TVar -> drop T, _ -> drop F))
# def(type-is-meta, Type -- Bool, match(TMeta -> drop T, _ -> drop F))
# def(type-is-tensor, Type -- Bool, match(TTensor -> drop2 T, _ -> drop F))
# def(type-is-table, Type -- Bool, match(TTable -> drop T, _ -> drop F))
# def(type-is-hole, Type -- Bool, match(THole -> drop T, _ -> drop F))
# def(type-is-app, Type -- Bool, match(TApp -> drop2 T, _ -> drop F))
# def(type-is-data, Type -- Bool, match(TData -> drop T, _ -> drop F))

def(Type.error?, Type -- Bool, expand match(TYPE_ERROR -> T, _ -> drop F))
def(Type.morphism?, Type -- Maybe(ArrowType), expand match(TMorphism -> SOME, _ -> drop NONE))
def(Type.prim?, Type -- Maybe(PrimType), expand match(TPrim -> SOME, _ -> drop NONE))
def(Type.data?, Type -- Maybe(Data),
    type-head match(TData -> SOME, _ -> drop NONE)) # TODO fix this
def(Type.mut?, Type -- Maybe(Type),
    expand match(TMut -> SOME, _ -> drop NONE))

def(Type.unit?, Type -- Bool, PRIM_TYPE_UNIT swap =prim)
def(Type=prim, PrimType Type -- Bool, prim? if-some(=, drop F))
def(Type=meta, MetaVar Type -- Bool,
    TMeta -> =,
    _ -> drop2 F)

def(Type.is-physical?, Type -- Bool,
    TMeta -> expand-if(is-physical?, "unbound meta at Type.is-physical?" panic!),
    TPrim -> is-physical?,
    _ -> drop T)

def(TYPE_TYPE, Type, PRIM_TYPE_TYPE TPrim) # type of types
def(TYPE_STACK, Type, PRIM_TYPE_STACK TPrim) # type of stack types
def(TYPE_EFFECT, Type, PRIM_TYPE_EFFECT TPrim) # type of effect types
def(TYPE_UNIT, Type, PRIM_TYPE_UNIT TPrim) # unit type
def(TYPE_INT, Type, PRIM_TYPE_INT TPrim) # generic integer type for integer literals
def(TYPE_PTR, Type, PRIM_TYPE_PTR TPrim) # generic pointer type (e.g. void*)
def(TYPE_STR, Type, PRIM_TYPE_STR TPrim) # string pointer (just a pointer but nominally)
# def(TYPE_U8, Type, PRIM_TYPE_U8 TPrim) # fixed width integer type -- unsigned 8 bit
# def(TYPE_U16, Type, PRIM_TYPE_U16 TPrim) # fixed width integer type -- unsigned 16 bit
# def(TYPE_U32, Type, PRIM_TYPE_U32 TPrim) # fixed width integer type -- unsigned 32 bit
# def(TYPE_U64, Type, PRIM_TYPE_U64 TPrim) # fixed width integer type -- unsigned 64 bit
# def(TYPE_I8, Type, PRIM_TYPE_I8 TPrim) # fixed width integer type -- signed 8 bit
# def(TYPE_I16, Type, PRIM_TYPE_I16 TPrim) # fixed width integer type -- signed 16 bit
# def(TYPE_I32, Type, PRIM_TYPE_I32 TPrim) # fixed width integer type -- signed 32 bit
# def(TYPE_I64, Type, PRIM_TYPE_I64 TPrim) # fixed width integer type -- signed 64 bit

def(Type.expand, Type -- Type,
    TMeta -> expand,
    _ -> id)

data(Gamma, GAMMA -> Token)
def(Gamma.token, Gamma -- Token, GAMMA -> id)

||| Raise a type unification error.
def(Type.unify-failed!, Gamma Type Type -- Gamma Type,
    over2 token location trace!
    ": error: Failed to unify " trace!
    dip(trace!)
    " with " trace!
    trace!
    line-trace!
    TYPE_ERROR
    num-errors modify(1+))

||| Unify types directly, without regard to metavariables and other metatypes.
def(Type.unify-simple!, Gamma Type Type -- Gamma Type,
    TVar -> swap match(TVar -> unify!, _ -> dip(TVar) unify-failed!),
    TPrim -> swap match(TPrim -> unify!, _ -> dip(TPrim) unify-failed!),
    TData -> swap match(TData -> unify!, _ -> dip(TData) unify-failed!),
    TTable -> swap match(TTable -> unify!, _ -> dip(TTable) unify-failed!),
    TTensor -> rotl match(TTensor -> unify2! TTensor, _ -> dip(TTensor) unify-failed!),
    TMorphism -> swap match(TMorphism -> unify! TMorphism, _ -> dip(TMorphism) unify-failed!),
    TApp -> rotl match(TApp -> unify2! TApp, _ -> dip(TApp) unify-failed!),
    TMut -> swap match(TMut -> unify! TMut, _ -> dip(TMut) unify-failed!),
    _ -> unify-failed!)

||| Unify expanded types.
def(Type.unify-aux!, Gamma Type Type -- Gamma Type,
    TYPE_ERROR -> drop TYPE_ERROR,
    TYPE_DONT_CARE -> id,
    THole -> type-hole-unify!,
    TMeta ->
        swap match(
            TYPE_ERROR -> drop TYPE_ERROR,
            TYPE_DONT_CARE -> TMeta,
            THole -> dip(TMeta) type-hole-unify!,
            TMeta -> dip(TMeta) unify!,
            TValue -> dip(TMeta) unify-type!,
            _ -> swap unify!,
        ),
    TValue ->
        swap match(
            TYPE_ERROR -> drop TYPE_ERROR,
            TYPE_DONT_CARE -> TValue,
            THole -> dip(TValue) type-hole-unify!,
            TMeta -> dip(TValue) unify!,
            TValue -> unify!,
            _ -> swap unify-type!
        ),
    _ ->
        swap match(
            TYPE_ERROR -> drop TYPE_ERROR,
            TYPE_DONT_CARE -> id,
            THole -> type-hole-unify!,
            TMeta -> unify!,
            TValue -> unify-type!,
            _ -> unify-simple!
        )
    )

||| Unify two types. Raises a unification error if unification is impossible.
def(Type.unify!, Gamma Type Type -- Gamma Type,
    both(expand) unify-aux!)

def(Value.unify!, Gamma Value Value -- Gamma Type,
    swap match(
        VALUE_INT -> swap match(
            VALUE_INT -> dup2 = if(drop VALUE_INT TValue, drop2 TYPE_INT),
            VALUE_STR ->
                drop2 dup token
                "Can't unify int value with string value."
                emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 dup token
                "Can't unify int value with block."
                emit-error! TYPE_ERROR,
        ),

        VALUE_STR -> swap match(
            VALUE_STR -> dup2 = if(drop VALUE_STR TValue, drop2 TYPE_STR),
            VALUE_INT ->
                drop2 dup token
                "Can't unify string value with int value."
                emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 dup token
                "Can't unify string value with block."
                emit-error! TYPE_ERROR,
        ),

        VALUE_BLOCK -> swap match(
            VALUE_BLOCK ->
                dup2 = if(
                    drop VALUE_BLOCK TValue,
                    arrow type block-unify-type!
                ),
            VALUE_INT ->
                drop2 dup token
                "Can't unify block with int value."
                emit-error! TYPE_ERROR,
            VALUE_STR ->
                drop2 dup token
                "Can't unify block with string value."
                emit-error! TYPE_ERROR
        ),
    ))

def(Value.unify-type!, Gamma Type Value -- Gamma Type,
    VALUE_INT -> drop TYPE_INT unify!,
    VALUE_STR -> drop TYPE_STR unify!,
    VALUE_BLOCK -> swap block-unify-type!)


def(Type.unify2!, Gamma Type Type Type Type -- Gamma Type Type,
    dip(swap dip(unify! swap)) unify! dip(swap))

def(PrimType.unify!, Gamma PrimType PrimType -- Gamma Type,
    dup2 = if(drop TPrim, both(TPrim) unify-failed!))
def(Data.unify!, Gamma Data Data -- Gamma Type,
    dup2 = if(drop TData, both(TData) unify-failed!))
def(Table.unify!, Gamma Table Table -- Gamma Type,
    dup2 = if(drop TTable, both(TTable) unify-failed!))
def(Var.unify!, Gamma Var Var -- Gamma Type,
    dup2 = if(drop TVar, both(TVar) unify-failed!))

def(Type.has-meta?, MetaVar Type -- Bool,
    TMeta -> has-meta?,
    TYPE_ERROR -> drop F,
    TYPE_DONT_CARE -> drop F,
    TPrim -> drop2 F,
    TVar -> drop2 F,
    THole -> drop2 F,
    TTensor -> has-meta2?,
    TMorphism -> has-meta?,
    TApp -> has-meta2?,
    TData -> drop2 F,
    TTable -> drop2 F,
    TValue -> has-meta?,
    TMut -> has-meta?)

def(Type.has-meta2?, MetaVar Type Type -- Bool,
    dip(over) has-meta? if(drop2 T, has-meta?))

def(Value.has-meta?, MetaVar Value -- Bool,
    type has-meta?)

def(Type.trace-sig!, Type --,
    TMeta -> expand-if(trace-sig!, trace!),
    TYPE_ERROR -> "<ERROR>" trace!,
    TMorphism -> trace!,
    _ -> trace-stack!)

def(Type.trace-stack-dom!, Type --,
    expand dup unit? if(
        drop,
        trace-stack!
        " " trace!
    ))

def(Type.trace-stack-cod!, Type --,
    expand dup unit? if(
        drop,
        " " trace!
        trace-stack!
    ))

def(Type.trace-stack!, Type --,
    TMeta -> expand-if(trace-stack!, trace!),
    TTensor -> swap trace-stack-dom! trace!,
    TVar -> dup trace! is-stack? else(" ." trace!),
    _ -> trace!)

def(Type.trace!, Type --,
    TYPE_ERROR -> "<ERROR>" trace!,
    TYPE_DONT_CARE -> "_" trace!,
    TPrim -> trace!,
    TVar -> trace!,
    TMeta -> trace!,
    TTensor -> "[" trace! TTensor trace-stack! "]" trace!,
    TMorphism -> "[" trace! TMorphism trace-sig! "]" trace!,
    TData -> name trace!,
    TTable -> name trace!,
    THole -> trace!,
    TApp -> trace-app!,
    TValue -> type trace!,
    TMut -> "Mut(" trace! trace! ")" trace!)

def(Value.type, Value -- Type,
    VALUE_INT -> drop PRIM_TYPE_INT TPrim,
    VALUE_STR -> drop PRIM_TYPE_STR TPrim,
    VALUE_BLOCK -> type)

def(PrimType.trace!, PrimType --,
    match(
        PRIM_TYPE_TYPE -> "<TYPE>",
        PRIM_TYPE_STACK -> "<STACK>",
        PRIM_TYPE_EFFECT -> "<EFFECT>",
        PRIM_TYPE_UNIT -> "[]",
        PRIM_TYPE_INT -> "Int",
        PRIM_TYPE_PTR -> "Ptr",
        PRIM_TYPE_STR -> "Str",
    ) trace!)

||| Replace the stack rest with a metavar, if it's unit.
def(Type.semifreshen-sig, Type -- Type,
    dup sig-needs-fresh-stack-rest? if(
        semifreshen-sig-aux,
        id
    ))

def(Type.semifreshen-sig-aux, Type -- Type,
    TMeta -> expand-if(semifreshen-sig-aux, TMeta),
    TMorphism -> semifreshen-sig-aux TMorphism,
    _ -> id)

def(Type.semifreshen-sig-stack, Type Type -- Type Type,
    TMeta -> expand-if(semifreshen-sig-stack, TMeta),
    TTensor -> dip(semifreshen-sig-stack) TTensor,
    TPrim ->
        match(
            PRIM_TYPE_UNIT -> dup,
            _ -> TPrim
        ),
    _ -> id)

||| Freshen a type signature in preparation for type sig application.
def(Type.freshen-sig, Subst Type -- Subst Type,
    dup sig-needs-fresh-stack-rest? if(
        freshen-sig-aux,
        freshen
    ))

def(Type.stack-rest, Type -- Type,
    TMeta -> expand-if(stack-rest, TMeta),
    TTensor -> drop stack-rest,
    _ -> id)

def(Type.sig-needs-fresh-stack-rest?, Type -- Bool,
    TMeta -> expand-if(sig-needs-fresh-stack-rest?, drop F),
    TMorphism -> needs-fresh-stack-rest?,
    _ -> drop F)

def(Type.freshen-sig-aux, Subst Type -- Subst Type,
    TMeta -> expand-if(freshen-sig-aux, TMeta),
    TMorphism -> freshen-sig-aux TMorphism,
    _ -> freshen)

def(Type.freshen-sig-stack, Type Subst Type -- Type Subst Type,
    TMeta -> expand-if(freshen-sig-stack, freshen),
    TTensor ->
        dip(freshen-sig-stack) swap
        dip(freshen) swap
        TTensor,
    TPrim ->
        match(
            PRIM_TYPE_UNIT -> over,
            _ -> TPrim
        ),
    _ -> freshen)

||| Replace free type vars and free metavars with brand new metavars.
def(Type.freshen, Subst Type -- Subst Type,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TData -> TData,
    TTable -> TTable,
    TValue -> TValue, # no need to freshen values
    TVar -> freshen,
    TMeta -> freshen,
    TTensor -> freshen2 TTensor,
    TMorphism -> freshen TMorphism,
    TApp -> freshen2 TApp,
    TMut -> freshen TMut,
    )

def(Type.freshen2, Subst Type Type -- Subst Type Type,
    dip(freshen swap) freshen dip(swap))

def(MetaVar.freshen, Subst MetaVar -- Subst Type,
    expand-if(freshen, drop MetaVar.new! TMeta))

def(Var.freshen, Subst Var -- Subst Type,
    swap dup2 has-var? if(
        tuck get-var,
        MetaVar.new! TMeta dup
        dip(rotr cons)
    ))

def(Type.rigidify-sig!, Ctx Type -- Ctx Type,
    TMeta ->
        expand-or-update!(
            MetaVar.new! TMeta
            MetaVar.new! TMeta T->
        ) rigidify-sig!,
    _ -> rigidify!)

def(Type.rigidify-stack!, Ctx Type -- Ctx Type,
    TMeta ->
        expand-or-update!(
            fresh-stack-type-var! TVar
        ) rigidify-stack!,
    TTensor ->
        dip(rigidify-stack!) swap
        dip(rigidify!) swap
        TTensor,
    TVar -> TVar,
    _ -> rigidify!)

||| Replace unbound metavars with new vars, adding them to context.
def(Type.rigidify!, Ctx Type -- Ctx Type,
    TMeta ->
        expand-or-update!(
            fresh-type-var! TVar
        ) rigidify!,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TVar -> TVar,
    TTable -> TTable,
    TData -> TData,
    TApp ->
        dip(rigidify!) swap
        dip(rigidify!) swap
        TApp,
    TTensor ->
        dip(rigidify-stack!) swap
        dip(rigidify!) swap
        TTensor,
    TMorphism -> rigidify! TMorphism,
    TValue -> rigidify!,
    TMut -> rigidify! TMut)

def(Value.rigidify!, Ctx Value -- Ctx Type,
    VALUE_INT -> VALUE_INT TValue,
    VALUE_STR -> VALUE_STR TValue,
    VALUE_BLOCK -> arrow type rigidify-sig!)

||| How many types does this type take as an argument?
def(Type.arity, Type -- Int,
    TMeta -> expand-if(arity, drop 0),
    TData -> arity,
    TApp -> drop arity 1-,
    _ -> drop 0)

||| Get head of type.
def(type-head, Type -- Type,
    TMeta -> expand-if(type-head, TMeta),
    TApp -> drop type-head,
    _ -> id)

||| For types that can have a field associated with them,
||| get the number of values n, where the type's values
||| range from 0 to (n-1). This should not be too large.
|||
||| Do NOT return SOME(n) unless the type has values 0..n-1
def(type-max-count, Type -- Maybe(Int),
    TMeta -> expand-if(type-max-count, drop NONE),
    TApp -> drop type-max-count,
    TTable -> max-count 1+ SOME,
    TData ->
        dup is-enum? if(
            num-tags SOME,
            drop NONE
        ),
    _ -> drop NONE)

##################
# Meta-var Types #
##################

table(MetaVar)
field(MetaVar~type?, MetaVar, Maybe(Type))
def(MetaVar.type?, MetaVar -- Maybe(Type), ~type? @)

def(MetaVar.has-meta?, MetaVar MetaVar -- Bool,
    dup type? match(
        NONE -> =,
        SOME -> nip has-meta?
    ))

def(MetaVar.trace!, MetaVar --,
    dup type? match(
        NONE -> "?" trace! MetaVar.id trace!,
        SOME -> nip trace!
    ))
def(MetaVar.new!, MetaVar,
    MetaVar.alloc!
    NONE over ~type? !)

def(MetaVar.expand-if(f,g), (*a Type -- *b, *a MetaVar -- *b) *a MetaVar -- *b,
    dup type? match(
        NONE -> g,
        SOME -> expand tuck SOME swap ~type? ! f
    ))
def(MetaVar.expand, MetaVar -- Type,
    expand-if(id, TMeta))
def(MetaVar.unify!, Gamma Type MetaVar -- Gamma Type,
    dup type? match(
        SOME -> nip unify!,
        NONE -> dup2 swap =meta if(
            drop,
            swap dup2 has-meta? if(
                swap TMeta unify-failed!,
                tuck SOME swap ~type? !
            )
        )
    ))
def(MetaVar.expand-or-update!(f), (*a -- *a Type) *a MetaVar -- *a Type,
    dup type? match(
        NONE -> dip(f dup SOME) ~type? !,
        SOME -> nip
    ))

def(MetaVar=, MetaVar MetaVar -- Bool, both(.id) =)

##############
# Type Holes #
##############

def(type-hole-unify!, Type Name -- Type,
    THole trace!
    " ~ " trace!
    dup trace!
    line-trace!)

##########
# Params #
##########

def(Type.max-num-params, Type -- Int,
    TMeta -> expand-if(max-num-params, drop 0),
    TMorphism -> unpack drop num-morphisms-on-top,
    _ -> drop 0)

def(Type.num-morphisms-on-top, Type -- Int,
    TMeta -> expand-if(num-morphisms-on-top, drop 0),
    TTensor -> morphism? .if(num-morphisms-on-top 1+, drop 0),
    _ -> drop 0)

############
# APP TYPE #
############

def(Type.trace-app!, Type Type --,
    trace-app-open! ")" trace!)

def(Type.trace-app-open!, Type Type --,
    swap expand match(
        TApp ->
            trace-app-open!
            ", " trace!
            trace!,
        _ ->
            trace!
            "(" trace!
            trace!
    ))

##############
# ARROW TYPE #
##############

data(ArrowType, ARROW_TYPE -> Type Type)
def(ArrowType.unpack, ArrowType -- Type Type, ARROW_TYPE -> id)
def(ArrowType.unify!, Gamma ArrowType ArrowType -- Gamma ArrowType,
    dip(unpack) unpack unify2! ARROW_TYPE)
def(ArrowType.has-meta?, MetaVar ArrowType -- Bool,
    unpack has-meta2?)

def(ArrowType.trace!, ArrowType --,
    unpack swap
    trace-stack-dom!
    "--" trace!
    trace-stack-cod!)

def(ArrowType.semifreshen-sig-aux, ArrowType -- ArrowType,
    MetaVar.new! TMeta swap unpack
    dip(semifreshen-sig-stack) swap
    dip(semifreshen-sig-stack) swap
    ARROW_TYPE nip)

def(ArrowType.needs-fresh-stack-rest?, ArrowType -- Bool,
    unpack stack-rest unit? if(
        stack-rest unit?,
        drop F
    ))

def(ArrowType.freshen-sig-aux, Subst ArrowType -- Subst ArrowType,
    MetaVar.new! TMeta rotr unpack
    dip(freshen-sig-stack) swap
    dip(freshen-sig-stack) swap
    ARROW_TYPE dip(nip))

def(ArrowType.freshen, Subst ArrowType -- Subst ArrowType,
    unpack freshen2 ARROW_TYPE)

def(ArrowType.rigidify!, Ctx ArrowType -- Ctx ArrowType,
    unpack
    dip(rigidify-stack!) swap
    dip(rigidify-stack!) swap
    ARROW_TYPE)

#########
# Subst #
#########

# mirth/data/type
data(Subst,
    SUBST_NIL,
    SUBST_CON -> Subst Type Var)

def(Subst.nil?, Subst -- Bool, SUBST_NIL -> T, _ -> drop F)
def(Subst.con?, Subst -- Maybe([Subst Type Var]),
    SUBST_CON -> pack3 SOME,
    _ -> drop NONE)

def(Subst.nil, Subst, SUBST_NIL)
def(Subst.cons, Type Var Subst -- Subst, rotr SUBST_CON)
def(Subst.has-var?, Var Subst -- Bool,
    SUBST_NIL -> drop F,
    SUBST_CON -> nip over2 = if(drop2 T, has-var?))
def(Subst.get-var, Var Subst -- Type,
    SUBST_NIL -> drop TYPE_ERROR,
    SUBST_CON -> over3 = if(dip(drop2), drop get-var))

||| If variable is in subst, unify new type with type in subst.
||| Otherwise, create larger subst with new binding.
def(Subst.match-var, Gamma Type Var Subst -- Gamma Subst,
    dup2 has-var? if(
        sip(get-var unify! drop),
        cons
    ))
