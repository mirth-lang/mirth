module(mirth.data.name)

import(prelude)
import(platform.posix)
import(data.char)
import(data.str)
import(data.list)
import(data.lazy)

#########
# Names #
#########

# mirth/data/name
data(Def,
    DEF_NONE,
    DEF_ALIAS -> Name,
    DEF_MODULE -> Module,
    DEF_TYPE -> Type,
    DEF_TAG -> Tag,
    DEF_PRIM -> Prim,
    DEF_WORD -> Word,
    DEF_BUFFER -> Buffer,
    DEF_VARIABLE -> Variable,
    DEF_CONSTANT -> Value,
    DEF_EXTERNAL -> External,
    DEF_FIELD -> Field)
table(Name)
field(name-str, Name, Str)
field(name-def, Name, Def)
field(name-module, Name, Maybe(Module)) # where this name is defined
field(name-mangled, Name, Lazy(Str))
def(name-is-nil, Name -- Bool, Name.id 0 ==)

def(name-debug!, Name --,
    dup name-str @ str-trace!
    "[" str-trace! Name.id int-trace! "] " str-trace!)


data(Hash, HASH -> Int)
def(Hash->Int, Hash -- Int, HASH -> id)
def(Int->Hash, Int -- Hash, HASH_MAX % HASH)

def(HASH_MAX, Int, 0x10000)
buffer(HASH_BUF,   0x80000)
def(hash-name@, Hash -- Maybe(Name),
    Hash->Int HASH_BUF int@@
    dup 0= if(drop NONE, Name.from-id SOME))
def(hash-name!, Name Hash --, dip(Name.id) Hash->Int HASH_BUF int!!)

||| Get hash for string.
def(hash, Str -- Hash,
    0 swap str-for(Char->Int 17 * over 7 << ^ swap 27 >> ^)
    Int->Hash)

def(name-hash, Name -- Hash, name-str @ hash)
def(next-hash, Hash -- Hash, Hash->Int 1+ Int->Hash)

def(name-keep-going?, Str Hash -- Str Hash Bool,
    dup hash-name@ match(
        NONE -> false,
        SOME -> name-str @ over2 <>
    ))

def(name-new!, Str -- Name,
    dup hash
    while(name-keep-going?, next-hash)
    dup hash-name@ match(
        NONE ->
            Name.alloc!
            tuck swap hash-name!
            tuck name-str !
            DEF_NONE over name-def !
            NONE over name-module !
            dup delay(name-mangle-compute!) over name-mangled !,
        SOME ->
            dip(drop2)
    ))

||| Add string to name, creating new name.
def(name-cat!, Name Str -- Name,
    dip(name-str @) str-cat name-new!)

def(name-trace!, Name --,
    name-str @ str-trace!)

def(name-print!, Name --,
    name-str @ str-print!)

def(name-head, Name -- Char,
    name-str @ str-slice str-slice-head)
def(name-tail-head, Name -- Char,
    name-str @ str-slice str-slice-tail str-slice-head)

def(name-could-be-type, Name -- Bool,
    name-head is-alpha)

def(name-could-be-type-var, Name -- Bool,
    name-head is-lower)

def(name-could-be-type-con, Name -- Bool,
    name-head is-upper)

def(name-is-type-hole, Name -- Bool,
    dup name-head is-question-mark
    swap name-tail-head dup is-nul swap is-lower || &&)

def(name-is-underscore, Name -- Bool,
    dup name-head is-underscore
    swap name-tail-head is-nul &&)

def(name-could-be-stack-var, Name -- Bool,
    dup name-head is-asterisk
    swap name-tail-head is-lower &&)

def(name-could-be-effect-con, Name -- Bool,
    dup name-head is-plus
    swap name-tail-head is-lower &&)

def(name-print-mangled!, Name --,
    name-mangled force! str-print!)

def(name-mangle!, Name -- Str,
    name-mangled force!)

def(name-mangle-compute!, Name -- Str,
    name-str @ str-transduce(
        dup is-alpha if( TS_CHAR,
        dup is-digit if( TS_CHAR,
        dup is-underscore if( TS_CHAR,
        dup is-dash if( drop underscore TS_CHAR,
            char-hexdigits underscore swap cons underscore snoc TS_PUSH
        ))))
    ))

||| Turn character into a sequence of hex digits, in the order they
||| appear in UTF8 encoding.
def(char-hexdigits, Char -- List(Char),
    Char->Int
    char-hexdigits-first
    while(dup 0 >, char-hexdigits-next)
    drop)

def(char-hexdigits-first, Int -- List(Char) Int,
    dip(L0) char-hexdigits-next)

def(char-hexdigits-next, List(Char) Int -- List(Char) Int,
    sip(0xF & hexdigit) 4 >>
    sip(0xF & hexdigit) 4 >>
    dip(swap dip(snoc) snoc))

def(hexdigit, Int -- Char,
    dup 10 >= if(
        55 + Int->Char,
        48 + Int->Char
    ))

########
# Defs #
########

def(name-undefined?, Name -- Name Bool, dup name-def @ DEF_NONE ==)
def(name-defined?, Name -- Name Bool, name-undefined? not)
