module(mirth.data.name)

import(prelude)
import(platform.posix)
import(data.byte)
import(data.str)
import(data.list)
import(data.lazy)
import(data.maybe)
import(mirth.data.def)

#########
# Names #
#########

table(Name)
field(name-str, Name, Str)
field(name-def, Name, Def)
field(name-mangled, Name, Lazy(Str))

def(name==, Name Name -- Bool, both(Name.id) =)

def(name-debug!, Name --,
    dup name-str @ str-trace!
    "[" str-trace! Name.id int-trace! "] " str-trace!)

data(Hash, HASH -> Int)
def(Hash->Int, Hash -- Int, HASH -> id)
def(Int->Hash, Int -- Hash, HASH_MAX % HASH)

def(HASH_MAX, Int, 0x10000)
buffer(HASH_BUF,   0x80000)
def(hash-name@, Hash -- Maybe(Name),
    Hash->Int HASH_BUF @@I64 >Int
    dup 0= if(drop NONE, Name.from-id SOME))
def(hash-name!, Name Hash --,
    dip(Name.id >I64)
    Hash->Int HASH_BUF !!I64)

||| Get hash for string.
def(hash, Str -- Hash,
    0 swap str-bytes-for(Byte->Int 17 * over 7 << ^ swap 27 >> ^)
    Int->Hash)

def(name-hash, Name -- Hash, name-str @ hash)
def(next-hash, Hash -- Hash, Hash->Int 1+ Int->Hash)

def(name-keep-going?, Str Hash -- Str Hash Bool,
    dup hash-name@ match(
        NONE -> F,
        SOME -> name-str @ over2 <>
    ))

def(name-search, Str -- Maybe(Name),
    dup hash
    while(name-keep-going?, next-hash)
    nip hash-name@)

def(name-new!, Str -- Name,
    dup hash
    while(name-keep-going?, next-hash)
    dup hash-name@ match(
        NONE ->
            Name.alloc!
            tuck swap hash-name!
            tuck name-str !
            DEF_NONE over name-def !
            dup delay(name-mangle-compute!) over name-mangled !,
        SOME ->
            dip(drop2)
    ))

||| Add string to name, creating new name.
def(name-cat!, Name Str -- Name,
    dip(name-str @) str-cat name-new!)

def(name-trace!, Name --,
    name-str @ str-trace!)

def(name-print!, Name --,
    name-str @ str-print!)

def(name-head, Name -- Byte,
    name-str @ with-str-data(1 >= if(@Byte, drop BNUL)))
def(name-tail-head, Name -- Byte,
    name-str @ with-str-data(2 >= if(dip(1) .offset-unsafe @Byte, drop BNUL)))

def(name-could-be-type, Name -- Bool,
    name-head byte-is-alpha)

def(name-could-be-type-var, Name -- Bool,
    name-head byte-is-lower)

def(name-could-be-type-con, Name -- Bool,
    name-head byte-is-upper)

def(name-is-type-hole, Name -- Bool,
    dup name-head B'?' byte==
    swap name-tail-head dup BNUL byte== swap byte-is-lower || &&)

def(name-is-underscore, Name -- Bool,
    dup name-head B'_' byte==
    swap name-tail-head BNUL byte== &&)

def(name-could-be-stack-var, Name -- Bool,
    dup name-head B'*' byte==
    swap name-tail-head byte-is-lower &&)

def(name-could-be-effect-con, Name -- Bool,
    dup name-head B'+' byte==
    swap name-tail-head byte-is-lower &&)

def(name-print-mangled!, Name --,
    name-mangled force! str-print!)

def(name-mangle!, Name -- Str,
    name-mangled force!)

def(name-mangle-compute!, Name -- Str,
    build-str!(name-str @ str-bytes-for(
        dup byte-is-alnum if(
            str-buf-push-byte!,
            dup B'-' byte== if(
                drop B'_' str-buf-push-byte!,
                B'_' str-buf-push-byte!
                byte-to-hexdigits dip(str-buf-push-byte!) str-buf-push-byte!
                B'_' str-buf-push-byte!
            )
        )
    )))

def(name-could-be-relative, Name -- Bool,
    name-head byte-is-overload-trigger)

########
# Defs #
########

def(name-undefined?, Name -- Name Bool, dup name-def @ match(DEF_NONE -> T, _ -> drop F))
def(name-defined?, Name -- Name Bool, name-undefined? not)
