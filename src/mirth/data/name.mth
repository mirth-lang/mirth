module(mirth/data/name)
import(mirth/data/common)
import(mirth/data/char)

#########
# Names #
#########

def(Int->Name, Int -- Name, cast)
def(Name->Int, Name -- Int, cast)

table(Hash)
field(hash-name, Hash, Name)
def(Int->Hash, Int -- Hash, cast)
def(Hash->Int, Hash -- Int, cast)

def(NAME_HASH_MAX, Size, 0x7FFF)

||| Get hash for string.
def(hash, Str -- Hash,
    0 swap
    while(str-is-empty? not,
        dup str-tail
        dip(str-head U8->Int 5 * swap 18 * ^))
    drop
    NAME_HASH_MAX &
    Int->Hash)

def(name-hash, Name -- Hash, name-str@ hash)
def(next-hash, Hash -- Hash, Hash->Int 1+ NAME_HASH_MAX & Int->Hash)

def(name-keep-going?, Str Hash -- Str Hash Bool,
    hash-name? is-nil? if(
        drop false,
        dip(over) name-str@ str-eq not
    ))


def(name-new!, Str -- Name,
    dup hash
    while(name-keep-going?, next-hash)
    hash-name? is-nil? if(
        drop Name.alloc!
        tuck swap hash-name!
        tuck name-str!,
        nip nip
    ))

||| Add string to name, creating new name.
name-cat! : Name Str -- Name
name-cat! = dip(name-str@) str-cat name-new!

name-trace! : Name -- +IO
name-trace! = name-str@ str-trace!

name-print! : Name -- +IO
name-print! = name-str@ str-print!

def(name-could-be-type, Name -- Bool,
    name-str@ str-head is-alpha? nip)

def(name-could-be-type-var, Name -- Bool,
    name-str@ str-could-be-type-var)

def(str-could-be-type-var, Str -- Bool,
    str-head is-lower? nip)

def(name-could-be-type-con, Name -- Bool,
    name-str@ str-head is-upper? nip)

def(name-is-type-hole, Name -- Bool,
    name-str@ dup str-head is-question-mark? nip if(
        str-tail str-is-empty? if(
            drop true,
            str-could-be-type-var),
        drop false
    ))

def(name-is-underscore, Name -- Bool,
    name-str@ dup str-head is-underscore? nip if(
        str-tail str-is-empty,
        drop false
    ))

def(name-could-be-stack-var, Name -- Bool,
    name-str@ dup str-head is-asterisk? nip if(
        str-tail str-could-be-type-var,
        drop false
    ))

def(name-could-be-effect-con, Name -- Bool,
    name-str@ dup str-head is-plus-sign? nip if(
        str-tail str-head is-upper? nip,
        drop false
    ))

def(name-print-mangled!, Name -- +IO,
    name-mangle! str-print!)

def(name-mangle!, Name -- Str,
    build-str!(
        name-str@
        while(str-is-empty? not,
            dup str-head str-buf-push-mangled!
            str-tail)
        drop
    ))

def(str-buf-push-mangled!, Char -- +StrBuf,
    is-nul? if(
        drop,

    is-alpha? if(
        str-buf-push!,

    is-digit? if(
        str-buf-push!,

    is-dash? if(
        drop
        underscore str-buf-push!, # technically bad but looks nice for now

    is-underscore? if(
        str-buf-push!, # technically bad but looks nice for now

        underscore str-buf-push!
        str-buf-push-hexdigits!
        underscore str-buf-push!
    ))))))

def(str-buf-push-hexdigits!, Char -- +StrBuf,
    U8->Int dup
    16 / Int->U8 str-buf-push-hexdigit!
    16 % Int->U8 str-buf-push-hexdigit!)

def(str-buf-push-hexdigit!, Char -- +StrBuf,
    U8->Int dup 10 >= if(
        55 + Int->U8 str-buf-push!,
        48 + Int->U8 str-buf-push!
    ))

########
# Defs #
########

def(name-undefined?, Name -- Name Bool,
    name-value? match(DEF_NONE -> true, _ -> drop false))
def(name-defined?, Name -- Name Bool, name-undefined? not)

name-word! : Word Name --
name-buffer! : Buffer Name --
name-type! : Type Name --
name-external! : External Name --
name-module! : Module Name --
name-prim! : Prim Name --
name-tag! : Tag Name --

name-word! = dip(DEF_WORD) name-value!
name-buffer! = dip(DEF_BUFFER) name-value!
name-type! = dip(DEF_TYPE) name-value!
name-external! = dip(DEF_EXTERNAL) name-value!
name-module! = dip(DEF_MODULE) name-value!
name-prim! = dip(DEF_PRIM) name-value!
name-tag! = dip(DEF_TAG) name-value!
