module(mirth/data/table)
import(mirth/data/common)
import(mirth/data/buffer)
import(mirth/data/type)

#########
# TABLE #
#########

def(TABLE_MAX_SIZE, Int, 0x20000)

def(table-new!, Name -- Table,
    table-alloc!
    dup2 TTable swap name-type!
    tuck table-name!

    TABLE_MAX_SIZE over table-max-count!

    # Table.MAX
    table-name? ".MAX" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    TYPE_UNIT
    TYPE_UNIT TYPE_INT TTensor
    TMorphism
    over word-type!
    true over word-sig-is-checked!

    TABLE_MAX_SIZE arrow-new-int!
    over word-arrow!
    true swap word-body-is-checked!

    # Table.NUM
    table-name? ".NUM" name-cat!
    8 buffer-alloc!
    over table-num-buffer!

    # Table.for
    table-name? ".for" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    \(t w ->

        "a" name-new! var-new-implicit!
        "x" name-new! var-new!
        \(a x ->
            TYPE_STACK a var-type!
            ctx-empty a ctx-new!
            w word-ctx!

            a TVar a TVar t TTable T* a TVar T-> T*
            a TVar T->
            w word-type!

            true w word-sig-is-checked!
            true w word-body-is-checked!

            a TVar t TTable T* a TVar T-> x var-type!
            true x var-auto-run!

            Lambda.alloc!
            x L1 over lambda-params!

            1 arrow-new-int!
            dup2 swap lambda-body!

            PRIM_CORE_WHILE arrow-push-prim!
                PRIM_CORE_DUP arrow-new-prim!
                dup block-new! ARG_BLOCK swap
                t table-num-buffer@ arrow-push-buffer!
                PRIM_INT_GET arrow-push-prim!
                PRIM_VALUE_LE arrow-push-prim!
                drop

                PRIM_CORE_DUP arrow-new-prim!
                dup block-new! ARG_BLOCK swap
                PRIM_CORE_DIP arrow-push-prim!
                    x ARG_VAR_RUN
                L1 over arrow-args!
                1 arrow-push-int!
                PRIM_INT_ADD arrow-push-prim!
                drop
            L2 over arrow-args!

            PRIM_CORE_DROP arrow-push-prim!
            drop

            arrow-new-lambda!
            w word-arrow!)

        t)

    # Table.alloc!
    table-name? ".alloc!" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    over dip(T0) TTable T1 T->
    over word-type!
    true over word-sig-is-checked!

    # TODO: perform bounds check in Table.alloc!
    over table-num-buffer@ dup
    dip(
        arrow-new-buffer!
        dup2 swap word-arrow!
        PRIM_INT_GET arrow-push-prim!
        1 arrow-push-int!
        PRIM_INT_ADD arrow-push-prim!
        PRIM_CORE_DUP arrow-push-prim!
    )
    arrow-push-buffer!
    PRIM_INT_SET arrow-push-prim!
    drop true swap word-body-is-checked!)

#########
# FIELD #
#########

def(Field->Int, Field -- Int, cast)
def(field-alloc!, Field, Field.alloc!)
def(field-new!, Name Type Type Int -- Field,
    dip(
        field-alloc!
        tuck field-type!
        tuck field-table!
        tuck field-name!

        # define the buffer for the field
        field-name? "-buffer" name-cat!
    )
    16 * buffer-alloc! over field-buffer!

    # field&
    field-name? "&" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    over field-table@
    TYPE_UNIT swap TTensor
    TYPE_UNIT TYPE_PTR TTensor
    TMorphism
    over word-type!
    true over word-sig-is-checked!

    # FIXME: need a better arrow-building inteface that tracks types
    #  i.e. a better elaborator API.
    16 arrow-new-int!
    dup2 swap word-arrow!
    PRIM_INT_MUL arrow-push-prim!
    dip(over field-buffer@) swap arrow-push-buffer!
    PRIM_PTR_ADD arrow-push-prim!
    drop true over word-body-is-checked!
    over field-word-ptr!

    # field!
    field-name? "!" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    over field-table?
    dip(field-type@ dip(TYPE_UNIT) TTensor) TTensor
    TYPE_UNIT TMorphism
    over word-type!
    true over word-sig-is-checked!

    over field-word-ptr@ arrow-new-word!
    dup2 swap word-arrow!
    PRIM_VALUE_SET arrow-push-prim!
    drop true swap word-body-is-checked!

    # field@
    field-name? "@" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    over field-table? swap field-type@
    dip(TYPE_UNIT swap TTensor)
    TYPE_UNIT swap TTensor
    TMorphism
    over word-type!
    true over word-sig-is-checked!

    over field-word-ptr@ arrow-new-word!
    dup2 swap word-arrow!
    PRIM_VALUE_GET arrow-push-prim!
    drop true swap word-body-is-checked!

    # field?
    field-name? "?" name-cat!
    Word.alloc!
    dup2 swap name-word!
    tuck word-name!

    over field-table? swap field-type@
    dip(TYPE_UNIT swap TTensor)
    dip(dup) TTensor
    TMorphism
    over word-type!
    true over word-sig-is-checked!

    over field-word-ptr@
    dip(
        PRIM_CORE_DUP arrow-new-prim!
        dup2 swap word-arrow!
    )
    arrow-push-word!
    PRIM_VALUE_GET arrow-push-prim!
    drop true swap word-body-is-checked!)

############
### test ###
############
table(TestTable)
def(TestTable.MAX', Size, TestTable.MAX)
def(TestTable.NUM', Ptr, TestTable.NUM)
def(TestTable.alloc!', TestTable, TestTable.alloc!)

field(test-table-int, TestTable, Int)
def(test-table-int-buffer', Ptr, test-table-int-buffer)
def(test-table-int&', TestTable -- Ptr, test-table-int&)
def(test-table-int@', TestTable -- Int, test-table-int@)
def(test-table-int!', Int TestTable --, test-table-int!)
