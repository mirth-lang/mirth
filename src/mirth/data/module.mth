module(mirth.data.module)

import(prelude)
import(data.path)
import(data.str)
import(data.list)
import(data.byte)
import(mirth.data.name)

# mirth/data/module
table(Module)
field(module-name, Module, Name)
field(module-path, Module, Path)
field(module-start, Module, Token)
field(module-end, Module, Token)
field(module-imports, Module, List(Module))

def(module-cmp, Module Module -- Comparison, dip(Module.id) Module.id int-cmp)
def(module==, Module Module -- Bool, dip(Module.id) Module.id int==)
def(module<=, Module Module -- Bool, dip(Module.id) Module.id int<=)
def(module<, Module Module -- Bool, dip(Module.id) Module.id int<)

def(module-new!, Path -- Module,
    Module.alloc!
    L0 over module-imports !
    tuck module-path !)

||| ( module1 module2 -- ) Add module2 as import to module1.
||| This does not check if the import is strictly necessary.
def(module-add-import!, Module Module --,
    swap module-imports modify(cons))

||| Get source path associated with module.
def(module-source-path, Module -- Path,
    dup Module.nil module== if(
        drop "<generated>" Str->Path,
        module-path @ make-source-path
    ))

def(module-path-from-name, Name -- Path,
    build-str!(
        name-str @ str-bytes-for(
            dup B'.' byte== if(
                drop B'/',
                dup byte-is-upper if(byte-to-lower, id)
            )
            str-buf-push-byte!
        )
        ".mth" str-buf-push-str!
    ) Str->Path)

||| ( module1 module2 -- bool ) Check whether module1 is visible in module2.
def(module-visible-in-module, Module Module -- Bool,
    dup2 module== if(
        drop2 T, # Module is always visible to itself.
        module-imports @ any(dup2 module==) nip
    ))
