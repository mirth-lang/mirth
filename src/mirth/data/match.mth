module(mirth.data.match)
import(prelude)
import(data.maybe)
import(data.list)
import(mirth.data.type)
import(mirth.data.data)
import(mirth.data.token)

#########
# MATCH #
#########

# mirth/data/type
table(Match)
field(match-ctx, Match, Ctx)
field(match-dom, Match, Type)
field(match-cod, Match, Type)
field(match-token, Match, Token) # where the diagnostics go
field(match-body, Match, Token) # where the cases start
field(match-cases, Match, List(Case))

table(Case)
field(case-match, Case, Match)
field(case-token, Case, Token)
field(case-pattern, Case, Pattern)
field(case-subst, Case, Subst)
field(case-mid, Case, Type)
field(case-body, Case, Arrow)

def(match-add-case!, Match Case -- Match,
    dip(dup match-cases @) cases-cover-case? if(
        case-token @ "Case is unreachable." emit-error! drop,
        snoc over match-cases !
    ))

def(match-is-exhaustive?, Match -- Match Bool,
    match-has-default-case? if(
        T,
        match-scrutinee-data? match(
            SOME ->
                num-tags
                over match-cases @ len =,
            NONE ->
                T # presume exhaustiveness
        )
    ))

def(match-has-default-case?, Match -- Match Bool,
    dup match-cases @ cases-have-default-case)

||| Get type we're matching over.
def(match-scrutinee-type?, Match -- Match Maybe(Type),
    dup match-dom @ type-expand match(
        TTensor -> nip SOME,
        _ -> drop NONE
    ))

||| Get "data" associated with scrutinee.
def(match-scrutinee-data?, Match -- Match Maybe(Data),
    match-scrutinee-type? bind(
        type-head match(
            TData -> SOME,
            _ -> drop NONE
        )
    ))

def(match-is-transparent?, Match -- Match Bool,
    match-scrutinee-data? match(
        SOME -> is-transparent?,
        NONE -> F
    ))

########
# CASE #
########

def(cases-cover-case?, List(Case) Case -- List(Case) Case Bool,
    dup2 cases-cover-case)

def(cases-cover-case, List(Case) Case -- Bool,
    swap any(dup2 case-is-covered) nip)

||| Ask whether the second case covers the first case already.
def(case-is-covered, Case Case -- Bool,
    dip(case-pattern @) case-pattern @ pattern-is-covered)

def(cases-have-default-case, List(Case) -- Bool,
    any(dup case-is-default-case))

def(case-is-default-case, Case -- Bool,
    case-pattern @ pattern-is-underscore)

###########
# PATTERN #
###########

data(Pattern,
    PATTERN_UNDERSCORE,
    PATTERN_TAG -> Tag)

def(pattern-is-underscore, Pattern -- Bool,
    PATTERN_UNDERSCORE -> T,
    PATTERN_TAG -> drop F)

def(pattern-equals-tag, Tag Pattern -- Bool,
    PATTERN_TAG -> =,
    PATTERN_UNDERSCORE -> drop F)

def(pattern==, Pattern Pattern -- Bool,
    PATTERN_UNDERSCORE -> pattern-is-underscore,
    PATTERN_TAG -> swap pattern-equals-tag)

||| Asks whether the second pattern already
||| covers the case of the first pattern.
def(pattern-is-covered, Pattern Pattern -- Bool,
    PATTERN_UNDERSCORE -> drop T,
    PATTERN_TAG -> swap pattern-equals-tag)
