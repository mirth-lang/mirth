module(mirth.data.word)
import(data.map)
import(mirth.data.var)

data InlineKey
    IK_NIL
    IK_BLOCK -> InlineKey Block
end

table(Word)
field(word-name, Word, Name)
field(word-sig, Word, Token)
field(word-body, Word, Token)
field(word-ctx, Word, Ctx)
field(word-type, Word, Type)
field(word-arrow, Word, Arrow)
field(word-sig-is-checked, Word, Bool)
field(word-body-is-checked, Word, Bool)
field(word-body-is-checking, Word, Bool)
field(word-inline-map, Word, Map(InlineKey, Word))
field(word-inlining, Word, Bool)

word-can-inline-block-arg? : Word -- Word Bool
word-can-inline-block-arg? =
    dup try-elab-word-body! match(
        NONE -> false,
        SOME ->
            arrow-atoms@ match(
                L1 -> atom-op@ match(
                    OP_LAMBDA ->
                        lambda-params@ last match(
                            NONE -> false,
                            SOME -> is-inlinable-block-param
                        ),
                    _ -> drop false
                ),
                _ -> drop false
            )
    )

is-inlinable-block-param : Param -- Bool
is-inlinable-block-param = unPARAM var-auto-run? nip

inline-key-from-blocks : List(Block) -- InlineKey
inline-key-from-blocks = IK_NIL swap for(IK_BLOCK)

word-inline : Word InlineKey -- Maybe(Word)
word-inline =
    over word-inline-map@ over map-lookup match(
        SOME -> dip(drop2) SOME,
        NONE ->
            over word-inlining@ if(
                drop2 NONE,
                over true over word-inlining! dip(
                    word-inline-aux SOME
                ) false swap word-inlining!
            )
    )

word-inline-name? : Word InlineKey -- Word InlineKey Name
word-inline-name? = (
    over word-name@ name-str@
    over inline-key-suffix
    str-cat name-new!
)

inline-key-suffix : InlineKey -- Str
inline-key-suffix = inline-key-suffix-parts str-concat

inline-key-suffix-parts : InlineKey -- List(Str)
inline-key-suffix-parts =
    match(
        IK_NIL -> "]" L1,
        IK_BLOCK -> dip(inline-key-suffix-parts "[B") cast int-show "]" L3 cat,
    )

inline-key-blocks : InlineKey -- List(Block)
inline-key-blocks =
    match(
        IK_NIL -> L0,
        IK_BLOCK -> dip(inline-key-blocks) snoc
    )

word-inline-ctx-type? : Word InlineKey -- Word InlineKey Ctx Type
word-inline-ctx-type? = ctx-empty TYPE_ERROR
    # TODO actually compute a type ... may need a substitution?
    # ... or get the ctx and type from the atom? That sounds better.

word-inline-aux : Word InlineKey -- Word
word-inline-aux = (
    Word.alloc!
    dip(word-inline-name?) tuck dup2 word-name! swap name-word!
    dip(word-inline-ctx-type?) tuck word-type! tuck word-ctx!
    true over word-sig-is-checked!
    dup3 dip2(word-inline-map?) swap pack2 map-insert swap word-inline-map!
    ab-build-word!(
        swap word-arrow@ arrow-atoms@ match(
            L1 -> atom-op@ match(
                OP_LAMBDA -> word-inline-outer-lambda!,
                _ -> "unexpected in word-inline-aux (1)" panic!
            ),
            _ -> "unexpected in word-inline-aux (2)" panic!
        )
    )
)

word-inline-outer-lambda! : InlineKey Lambda -- +AB
word-inline-outer-lambda! = (
    lambda-params? dip(lambda-body@ arrow-atoms@ swap)
    swap build-inline-map!
    rotr is-nil? if(
        # consumed all params, so build stuff directly
        drop inline-atoms!,

        # did not consume all params, so wrap everything in a lambda
        ab-lambda!(inline-atoms!)
    ) drop
)

inline-atoms! : InlineMap List(Atom) -- InlineMap
inline-atoms! = for(inline-atom!)

inline-atom! : InlineMap Atom -- InlineMap
inline-atom! = (
    TYPE_ERROR ab-type! # a crutch
    tuck atom-args@ reverse-for(inline-arg!) swap atom-op@ inline-op!
)

inline-arg! : InlineMap Arg -- InlineMap
inline-arg! =
    match(
        ARG_VAR_RUN -> inline-var-push!,
        ARG_BLOCK -> inline-block!
    )

inline-var-push! : InlineMap Var -- InlineMap
inline-var-push! =
    dup2 map-lookup match(
        NONE -> ab-block!(ab-var!), # this is fine, see block-to-arg
        SOME -> nip OP_BLOCK ab-op!
    )

inline-block! : InlineMap Block -- InlineMap
inline-block! = ab-block!(block-arrow@ arrow-atoms@ inline-atoms!)

inline-op! : InlineMap Op -- InlineMap
inline-op! =
    match(
        OP_LAMBDA -> inline-lambda!,
        OP_MATCH -> inline-match!,
        OP_VAR -> inline-var-op!,
        _ -> ab-op!
    )

inline-var-op! : InlineMap Var -- InlineMap
inline-var-op! =
    dup2 map-lookup match(
        NONE -> ab-var!,
        SOME -> nip block-arrow@ arrow-atoms@ for(ab-atom!) # is this ok?
    )

inline-lambda! : InlineMap Lambda -- InlineMap
inline-lambda! =
    lambda-params? ab-lambda!(
        lambda-body@ arrow-atoms@ inline-atoms!
    )

inline-match! : InlineMap Match -- InlineMap
inline-match! = (
    match-cases@ map(inline-case!)
    Match.alloc! tuck match-cases!
    OP_MATCH ab-op!
)

inline-case! : InlineMap Case -- InlineMap Case
inline-case! = (
    tuck case-body@ arrow-atoms@
    ab-ctx@ TYPE_ERROR ab-token@ ab-build!(
        inline-atoms!
    )
    Case.alloc!
    tuck case-body!
    dip(swap case-pattern@) tuck case-pattern!
)

def-type(InlineMap, Map(Var, Block))

build-inline-map! : List(Param) InlineKey -- List(Param) InlineMap +AB
build-inline-map! =
    swap List->List+ match(
        NONE ->
            inline-key-blocks for(OP_BLOCK ab-op!)
            L0 map-empty,
        SOME ->
            unsnoc Param->Var var-auto-run? if(
                rotl match(
                    IK_NIL ->
                        Var->Param snoc map-empty,
                    IK_BLOCK ->
                        dip(swap dip(build-inline-map!))
                        swap pack2 map-insert
                ),
                Var->Param snoc swap inline-key-blocks for(OP_BLOCK ab-op!)
                map-empty
            )
    )
