module(mirth.data.word)
import(data.map)

data InlineKey
    IK_NIL
    IK_BLOCK -> InlineKey Block
end

table(Word)
field(word-name, Word, Name)
field(word-sig, Word, Token)
field(word-body, Word, Token)
field(word-ctx, Word, Ctx)
field(word-type, Word, Type)
field(word-arrow, Word, Arrow)
field(word-sig-is-checked, Word, Bool)
field(word-body-is-checked, Word, Bool)
field(word-inline-map, Word, Map(InlineKey, Word))
field(word-inlining, Word, Bool)

word-can-inline-block-arg? : Word -- Word Bool
word-can-inline-block-arg? =
    word-body-is-checked? if(
        word-arrow? arrow-atoms@ match(
            L1 -> atom-op@ match(
                OP_LAMBDA ->
                    lambda-params@ last match(
                        NONE -> false,
                        SOME -> unPARAM var-auto-run? nip
                    ),
                _ -> drop false
            ),
            _ -> drop false
        ),
        false
    )

||| How many block params are inlinable for this word.
word-num-inlinable-block-params : Word -- Int
word-num-inlinable-block-params =
    word-body-is-checked? if(
        word-arrow@ arrow-atoms@ match(
            L1 -> atom-op@ match(
                OP_LAMBDA -> lambda-params@ params-num-inlinable-block-params,
                _ -> drop 0
            ),
            _ -> drop 0
        ),
        drop 0
    )

||| Number of inlinable block params counting from last.
params-num-inlinable-block-params : List(Param) -- Int
params-num-inlinable-block-params =
    0 swap while(is-nil? not,
        List->List+ match(
            NONE -> L0,
            SOME ->
                unsnoc is-inlinable-block-param if(
                    dip(1+),
                    drop L0
                )
        )
    ) drop

is-inlinable-block-param : Param -- Bool
is-inlinable-block-param = unPARAM var-auto-run? nip

inline-key-from-blocks : List(Block) -- InlineKey
inline-key-from-blocks = IK_NIL swap for(IK_BLOCK)

word-inline : Word InlineKey -- Maybe(Word)
word-inline =
    over word-inline-map@ over map-lookup match(
        SOME -> dip(drop2) SOME,
        NONE ->
            over word-inlining@ if(
                drop2 NONE,
                over true over word-inlining! dip(
                    word-inline-aux SOME
                ) false swap word-inlining!
            )
    )

word-inline-name? : Word InlineKey -- Word InlineKey Name
word-inline-name? = (
    over word-name@ name-str@
    over inline-key-suffix
    str-cat name-new!
)

inline-key-suffix : InlineKey -- Str
inline-key-suffix = inline-key-suffix-parts str-concat

inline-key-suffix-parts : InlineKey -- List(Str)
inline-key-suffix-parts =
    match(
        IK_NIL -> "]" L1,
        IK_BLOCK -> dip(inline-key-suffix-parts "[B") cast int-show "]" L3 cat,
    )

inline-key-blocks : InlineKey -- List(Block)
inline-key-blocks =
    match(
        IK_NIL -> L0,
        IK_BLOCK -> dip(inline-key-blocks) snoc
    )

word-inline-ctx-type? : Word InlineKey -- Word InlineKey Ctx Type
word-inline-ctx-type? = ctx-empty TYPE_ERROR
    # TODO actually compute a type ... may need a substitution?
    # ... or get the ctx and type from the atom? That sounds better.

word-inline-aux : Word InlineKey -- Word
word-inline-aux = (
    Word.alloc!
    dip(word-inline-name?) tuck dup2 word-name! swap name-word!
    dip(word-inline-ctx-type?) tuck word-type! tuck word-ctx!
    true over word-sig-is-checked!
    dup3 dip2(word-inline-map?) swap pack2 map-insert swap word-inline-map!
    ab-build-word!(
        inline-key-blocks for(OP_BLOCK ab-op!)
        word-arrow@ arrow-atoms@ for(ab-atom!) # these types are also not correct...
    )
)
