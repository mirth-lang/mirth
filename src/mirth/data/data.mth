module(mirth/data/data)
import(mirth/data/name)
import(mirth/elab/syntax)

#######
# TAG #
#######

NameValue->Tag : NameValue -- Tag
NameValue->Tag =
    match(
        DEF_TAG -> id,
        _ -> "attempted to get tag value from non-tag name" panic!
    )

Tag->NameValue : Tag -- NameValue
Tag->NameValue = DEF_TAG

name-tag! : Tag Name --
name-tag! = dip(Tag->NameValue) name-value!

name-tag@ : Name -- Tag
name-tag@ = name-value@ NameValue->Tag

name-tag? : Name -- Name Tag
name-tag? = dup name-tag@

tag-nil : Tag
tag-nil = 0 cast

tag-is-nil : Tag -- Bool
tag-is-nil = tag-nil ==

tag-is-nil? : Tag -- Tag Bool
tag-is-nil? = dup tag-is-nil

tag-num-inputs? : Tag -- Tag Int
tag-num-inputs? =
    # TODO: this should actually be calculated & stored during elaboration based on the type
    tag-has-sig? if(
        tag-sig? 0 swap
        while(token-run-end? not, token-next dip(1+)) drop,
        0
    )

########
# DATA #
########

data-num-tags : Data -- Int
data-num-tags = (
    0 swap data-tags@
    while(
        tag-is-nil? not,
        dip(1+) tag-next@
    )
    drop
)

data-add-tag! : Tag Data -- +Mirth
data-add-tag! =
    data-tags? tag-is-nil if(
        0 swap dip(over tag-value!) data-tags!,
        1 swap data-tags@ { Tag Int Tag }
        while(tag-next? tag-is-nil not, tag-next@ dip(1+))
        dip(over tag-value!) tag-next!
    )

#########
# MATCH #
#########

match-is-empty? : Match -- Match Bool
match-is-empty? = match-cases? is-nil

match-num-cases? : Match -- Match Int
match-num-cases? = match-cases? len

match-add-case! : Match Case -- Match
match-add-case! = dip(match-cases?) snoc over match-cases!

match-has-default-case : Match -- Bool
match-has-default-case = match-cases@ cases-have-default-case

match-has-default-case? : Match -- Match Bool
match-has-default-case? = dup match-has-default-case

||| Get type we're matching over.
match-scrutinee-type? : Match -- Match Type
match-scrutinee-type? = match-dom? type-expand-tensor nip

||| Is this a pattern match over a "data" type?
match-scrutinee-is-data? : Match -- Match Bool
match-scrutinee-is-data? = match-scrutinee-type? type-head type-is-data

||| Get "data" associated with scrutinee.
match-scrutinee-data? : Match -- Match Data
match-scrutinee-data? = match-scrutinee-type? type-head type-get-data

########
# CASE #
########

case-is-covered : Case Case -- Bool
case-is-covered = dip(case-pattern@) case-pattern@ pattern-is-covered

case-is-covered? : Case Case -- Case Case Bool
case-is-covered? = dup2 case-is-covered

cases-have-default-case : List(Case) -- Bool
cases-have-default-case =
    is-nil? if(
        drop false,
        unsnoc case-is-default-case if(
            drop true,
            cases-have-default-case
        )
    )

case-is-default-case? : Case -- Case Bool
case-is-default-case? = dup case-is-default-case

case-is-default-case : Case -- Bool
case-is-default-case = case-pattern@ pattern-is-underscore

###########
# PATTERN #
###########

Tag->Pattern : Tag -- Pattern
Tag->Pattern = PATTERN_TAG

Pattern->Tag : Pattern -- Tag
Pattern->Tag =
    match(
        PATTERN_TAG -> id,
        PATTERN_UNDERSCORE ->
            "compiler error: tried to call Pattern->Tag on underscore pattern" panic!,
    )

pattern-is-underscore : Pattern -- Bool
pattern-is-underscore = PATTERN_UNDERSCORE ==

pattern-is-underscore? : Pattern -- Pattern Bool
pattern-is-underscore? = dup pattern-is-underscore

pattern-is-covered : Pattern Pattern -- Bool
pattern-is-covered = swap pattern-is-underscore? if(drop2 true, ==)

pattern-is-covered? : Pattern Pattern -- Pattern Pattern Bool
pattern-is-covered? = dup2 pattern-is-covered
