module(mirth/data/arrow)
import(mirth/data/common)
import(mirth/data/prim)

##########
# ARROWS #
##########

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation.

# Originally this type was called Morphism but that's hard to spell and
# to type repeatedly so now it's called Arrow :-)

#######
# ARG #
#######

||| Add arg to atom.
atom-arg-add! : Atom Arg -- Atom
atom-arg-add! = dip(atom-args?) snoc over atom-args!

||| Add arg to last atom of arrow.
||| Will panic if arrow has no atoms.
arrow-arg-add! : Arrow Arg -- Arrow
arrow-arg-add! =
    over arrow-atoms@ last match(
        NONE -> "arrow-arg-add! on empty arrow" panic!,
        SOME -> swap atom-arg-add! drop
    )

||| Add atom to arrow.
arrow-atom-add! : Arrow Atom -- Arrow
arrow-atom-add! = dip(arrow-atoms?) snoc over arrow-atoms!

#########
# BLOCK #
#########

block-new! : Arrow -- Block
block-new! = Block.alloc! tuck block-arrow!

####################################
# Helpers for constructing arrows. #
####################################
# TODO: Use an effect, or something, to elaborate these with types.

atom-new-lambda! : Lambda -- Atom
atom-new-lambda! = OP_LAMBDA Atom.alloc! tuck atom-op!

atom-new-int! : Int -- Atom
atom-new-int! = OP_INT Atom.alloc! tuck atom-op!

atom-new-buffer! : Buffer -- Atom
atom-new-buffer! = OP_BUFFER Atom.alloc! tuck atom-op!

atom-new-external! : External -- Atom
atom-new-external! = OP_EXTERNAL Atom.alloc! tuck atom-op!

atom-new-prim! : Prim -- Atom
atom-new-prim! = OP_PRIM Atom.alloc! tuck atom-op!

atom-new-word! : Word -- Atom
atom-new-word! = OP_WORD Atom.alloc! tuck atom-op!

arrow-new-lambda! : Lambda -- Arrow
arrow-new-lambda! = Arrow.alloc! swap arrow-push-lambda!

arrow-new-int! : Int -- Arrow
arrow-new-int! = Arrow.alloc! swap arrow-push-int!

arrow-new-buffer! : Buffer -- Arrow
arrow-new-buffer! = Arrow.alloc! swap arrow-push-buffer!

arrow-new-external! : External -- Arrow
arrow-new-external! = Arrow.alloc! swap arrow-push-external!

arrow-new-prim! : Prim -- Arrow
arrow-new-prim! = Arrow.alloc! swap arrow-push-prim!

arrow-new-word! : Word -- Arrow
arrow-new-word! = Arrow.alloc! swap arrow-push-word!

arrow-push-lambda! : Arrow Lambda -- Arrow
arrow-push-lambda! = atom-new-lambda! arrow-atom-add!

arrow-push-int! : Arrow Int -- Arrow
arrow-push-int! = atom-new-int! arrow-atom-add!

arrow-push-buffer! : Arrow Buffer -- Arrow
arrow-push-buffer! = atom-new-buffer! arrow-atom-add!

arrow-push-external! : Arrow External -- Arrow
arrow-push-external! = atom-new-external! arrow-atom-add!

arrow-push-prim! : Arrow Prim -- Arrow
arrow-push-prim! = atom-new-prim! arrow-atom-add!

arrow-push-word! : Arrow Word -- Arrow
arrow-push-word! = atom-new-word! arrow-atom-add!
