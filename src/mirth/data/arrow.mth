module(mirth/data/arrow)
import(mirth/data/subst)
import(mirth/data/common)
import(mirth/data/word)
import(mirth/data/prim)

##########
# ARROWS #
##########

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation, but, to reduce indirection,
# we represent it as a flat sequence.

# Originally this type was called Morphism but that's hard to spell and
# to type repeatedly so now they're called Arrow :-)

ARROW_NIL : Arrow
ARROW_NIL = 0 cast

arrow-is-nil? : Arrow -- Arrow Bool
arrow-is-nil? = dup ARROW_NIL ==

arrow-alloc! : Arrow
arrow-alloc! = Arrow.alloc!

OP_NONE : Op
OP_PRIM : Op
OP_WORD : Op
OP_EXTERNAL : Op
OP_BUFFER : Op
OP_INT : Op
OP_STR : Op

OP_NONE = 0 cast
OP_PRIM = 1 cast
OP_WORD = 2 cast
OP_EXTERNAL = 3 cast
OP_BUFFER = 4 cast
OP_INT = 5 cast
OP_STR = 6 cast

arrow-op=? : Arrow Op -- Arrow Bool
arrow-op=? = dip(arrow-op?) ==

arrow-op-prim! : Prim Arrow --
arrow-op-prim! = (
    OP_PRIM over arrow-op!
    dip(Prim->Int) arrow-op-value!
)

arrow-op-prim@ : Arrow -- Prim
arrow-op-prim@ =
    OP_PRIM arrow-op=? if(
        arrow-op-value@ Int->Prim,
        "compiler error: attempted to get prim associated with non-prim arrow" panic!
    )

arrow-op-prim? : Arrow -- Arrow Prim
arrow-op-prim? = dup arrow-op-prim@

arrow-op-word! : Word Arrow --
arrow-op-word! = (
    OP_WORD over arrow-op!
    dip(Word->Int) arrow-op-value!
)

arrow-op-word@ : Arrow -- Word
arrow-op-word@ =
    OP_WORD arrow-op=? if(
        arrow-op-value@ Int->Word,
        "compiler error: attempted to get word associated with non-word arrow" panic!
    )

arrow-op-word? : Arrow -- Arrow Word
arrow-op-word? = dup arrow-op-word@

arrow-op-external! : External Arrow --
arrow-op-external! = (
    OP_EXTERNAL over arrow-op!
    dip(External->Int) arrow-op-value!
)

arrow-op-external@ : Arrow -- External
arrow-op-external@ =
    OP_EXTERNAL arrow-op=? if(
        arrow-op-value@ Int->External,
        "compiler error: attempted to get external associated with non-external arrow" panic!
    )

arrow-op-external? : Arrow -- Arrow External
arrow-op-external? = dup arrow-op-external@

arrow-op-buffer! : Buffer Arrow --
arrow-op-buffer! = (
    OP_BUFFER over arrow-op!
    dip(Buffer->Int) arrow-op-value!
)

arrow-op-buffer@ : Arrow -- Buffer
arrow-op-buffer@ =
    OP_BUFFER arrow-op=? if(
        arrow-op-value@ Int->Buffer,
        "compiler error: attempted to get external associated with non-external arrow" panic!
    )

arrow-op-buffer? : Arrow -- Arrow Buffer
arrow-op-buffer? = dup arrow-op-buffer@

arrow-op-int! : Int Arrow --
arrow-op-int! = (
    OP_INT over arrow-op!
    arrow-op-value!
)

arrow-op-int@ : Arrow -- Int
arrow-op-int@ =
    OP_INT arrow-op=? if(
        arrow-op-value@,
        "compiler error: attempted to get int associated with non-int arrow" panic!
    )

arrow-op-int? : Arrow -- Arrow Int
arrow-op-int? = dup arrow-op-int@

arrow-op-str! : StrLit Arrow --
arrow-op-str! = (
    OP_STR over arrow-op!
    dip(StrLit->Int) arrow-op-value!
)

arrow-op-str@ : Arrow -- StrLit
arrow-op-str@ =
    OP_STR arrow-op=? if(
        arrow-op-value@ Int->StrLit,
        "compiler error: attempted to get str associated with non-str arrow" panic!
    )

arrow-op-str? : Arrow -- Arrow StrLit
arrow-op-str? = dup arrow-op-str@

#######
# ARG #
#######

Arrow->Arg : Arrow -- Arg
Arrow->Arg = Arg.wrap

Arg->Arrow : Arg -- Arrow
Arg->Arrow = Arg.unwrap

########
# ARGS #
########

def(Int->Args, Int -- Args, cast)
def(Args->Int, Args -- Int, cast)
def(args@, Ptr -- Args, @ Int->Args)
def(args!, Args Ptr --, dip(Args->Int) !)
def(args-alloc!, Args, Args.alloc!)

def(ARGS_NIL, Args, 0 Int->Args)
def(args-is-nil, Args -- Bool, ARGS_NIL ==)
def(args-is-nil?, Args -- Args Bool, dup args-is-nil)

def(args-len, Args -- Int,
    0 swap while(args-is-nil? not, dip(1+) args-tail@) drop)

# Get pointer to last args var in args list.
def(arrow-args-last&, Arrow -- Ptr,
    arrow-args& while(
        dup args@ args-is-nil not,
        args@ args-tail&
    ))

def(arrow-arg-add!, Arrow Arg -- Arrow,
    args-alloc! tuck args-head!
    over arrow-args-last& args!)

def(arrow-args-0, Arrow --,
    arrow-args?
    args-len 0 == if(
        drop,
        arrow-token@ "compiler error: expected no args in arrow" emit-fatal-error!
    ))

def(arrow-args-1, Arrow -- Arg,
    arrow-args?
    args-len 1 == if(
        arrow-args@ args-head@,
        arrow-token@ "compiler error: expected 1 arg in arrow" emit-fatal-error!
    ))

def(arrow-args-2, Arrow -- Arg Arg,
    arrow-args?
    args-len 2 == if(
        arrow-args@ args-head? swap
        args-tail@ args-head@,

        arrow-token@ "compiler error: expected 2 args in arrow" emit-fatal-error!
    ))

####################################
# Helpers for constructing arrows. #
####################################

def(arrow-new-int!, Int -- Arrow,  arrow-alloc! tuck arrow-op-int!)
def(arrow-new-buffer!, Buffer -- Arrow, arrow-alloc! tuck arrow-op-buffer!)
def(arrow-new-external!, External -- Arrow, arrow-alloc! tuck arrow-op-external!)
def(arrow-new-prim!, Prim -- Arrow, arrow-alloc! tuck arrow-op-prim!)
def(arrow-new-word!, Word -- Arrow,  arrow-alloc! tuck arrow-op-word!)

def(arrow-push-int!, Arrow Int -- Arrow, arrow-new-int! tuck swap arrow-next!)
def(arrow-push-buffer!, Arrow Buffer -- Arrow, arrow-new-buffer! tuck swap arrow-next!)
def(arrow-push-external!, Arrow External -- Arrow, arrow-new-external! tuck swap arrow-next!)
def(arrow-push-prim!, Arrow Prim -- Arrow, arrow-new-prim! tuck swap arrow-next!)
def(arrow-push-word!, Arrow Word -- Arrow, arrow-new-word! tuck swap arrow-next!)
