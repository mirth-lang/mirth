module(mirth.data.arrow)
import(mirth.data.type)

##########
# ARROWS #
##########

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation.

# Originally this type was called Morphism but that's hard to spell and
# to type repeatedly so now it's called Arrow :-)


# mirth/data/arrow
table(Atom)
table(Arrow)
table(Lambda)
table(Block)

data(Arg,
    ARG_BLOCK -> Block,
    ARG_VAR_RUN -> Var)

data(Op,
    OP_NONE,
    OP_PRIM -> Prim,
    OP_WORD -> Word,
    OP_FIELDWORD -> FieldWord,
    OP_EXTERNAL -> External,
    OP_BUFFER -> Buffer,
    OP_INT -> Int,
    OP_STR -> Str,
    OP_TAG -> Tag,
    OP_MATCH -> Match,
    OP_LAMBDA -> Lambda,
    OP_VAR -> Var,
    OP_BLOCK -> Block)

data(Param, PARAM -> Var)
def(unPARAM, Param -- Var, match(PARAM -> id))
def(Var->Param, Var -- Param, PARAM)
def(Param->Var, Param -- Var, match(PARAM -> id))

field(arrow-token-start, Arrow, Token)
field(arrow-token-end, Arrow, Token)
field(arrow-home, Arrow, Word)
field(arrow-ctx, Arrow, Ctx)
field(arrow-dom, Arrow, Type)
field(arrow-cod, Arrow, Type)
field(arrow-atoms, Arrow, List(Atom))

field(atom-token, Atom, Token)
field(atom-ctx, Atom, Ctx)
field(atom-op, Atom, Op)
field(atom-args, Atom, List(Arg))
field(atom-dom, Atom, Type)
field(atom-cod, Atom, Type)
field(atom-subst, Atom, Subst)

field(lambda-token, Lambda, Token)
field(lambda-outer-ctx, Lambda, Ctx)
field(lambda-inner-ctx, Lambda, Ctx)
field(lambda-dom, Lambda, Type)
field(lambda-mid, Lambda, Type)
field(lambda-cod, Lambda, Type)
field(lambda-params, Lambda, List(Param))
field(lambda-body, Lambda, Arrow)

field(block-deferred, Block, Bool)
field(block-forcing, Block, Bool)
field(block-ctx, Block, Ctx)
field(block-token, Block, Token)
field(block-arrow-raw, Block, Arrow)
field(block-needed, Block, Bool)

#######
# ARG #
#######

||| Add arg to atom.
def(atom-arg-add!, Atom Arg -- Atom,
    dip(atom-args?) snoc over atom-args!)

||| Add arg to last atom of arrow.
||| Will panic if arrow has no atoms.
def(arrow-arg-add!, Arrow Arg -- Arrow,
    over arrow-atoms@ last match(
        NONE -> "arrow-arg-add! on empty arrow" panic!,
        SOME -> swap atom-arg-add! drop
    ))

||| Add atom to arrow.
def(arrow-atom-add!, Arrow Atom -- Arrow,
    dip(arrow-atoms?) snoc over arrow-atoms!)

#########
# BLOCK #
#########

def(block-new!, Arrow -- Block,
    Block.alloc!
    over arrow-ctx@ over block-ctx!
    over arrow-token-start@ over block-token!
    tuck block-arrow-raw!)

def(block-new-deferred!, Ctx Token -- Block,
    Block.alloc!
    true over block-deferred!
    tuck block-token!
    tuck block-ctx!)

def(block-arrow@, Block -- Arrow,
    dup block-force!
    block-arrow-raw@)

def(block-arrow?, Block -- Block Arrow,
    dup block-arrow@)

def(block-force!, Block --,
    block-deferred? if(
        block-forcing? if(
            block-token@
            "Recursive type detected for block."
            emit-fatal-error!,

            true over block-forcing!

            block-ctx? over block-token@
            dip(meta-alloc! TMeta)
            ab-build!(elab-atoms!)
            over block-arrow-raw!
            false swap block-deferred!
        ),
        drop
    ))

def(block-unify-type!, Gamma Block Type -- Gamma Type,
    swap block-deferred? if(
        block-forcing? if(
            block-token@
            "Recursive type detected for block."
            emit-fatal-error!,

            block-unify-type-aux!
        ),
        block-arrow-raw@ arrow-type swap type-unify!
    ))

def(block-unify-type-aux!, Gamma Type Block -- Gamma Type,
    true over block-forcing!
    dip(over gamma-token@ elab-expand-morphism! drop)
    rotr dip(
        dip(block-ctx? over block-token@) swap
        ab-build!(elab-atoms!)

        dup2 swap block-arrow-raw!
        dip(false swap block-deferred!)
        arrow-cod@
    )
    type-unify!)

# block-force-type! : Block Type --
#     block-deferred? if(
#         drop,
#     )

#     dip(block-token@)

#     ab-build!(elab-atoms!)

#########
# MATCH #
#########

# mirth/data/type
table(Match)
table(Case)
data(Pattern, PATTERN_UNDERSCORE, PATTERN_TAG -> Tag)

field(match-ctx, Match, Ctx)
field(match-dom, Match, Type)
field(match-cod, Match, Type)
field(match-token, Match, Token)
field(match-cases, Match, List(Case))
field(case-match, Case, Match)
field(case-token, Case, Token)
field(case-pattern, Case, Pattern)
field(case-subst, Case, Subst)
field(case-mid, Case, Type)
field(case-body, Case, Arrow)

def(match-add-case!, Match Case -- Match,
    dip(match-cases?) cases-cover-case? if(
        case-token@ "Case is unreachable." emit-error! drop,
        snoc over match-cases!
    ))

def(match-is-exhaustive?, Match -- Match Bool,
    match-has-default-case? if(
        true,
        match-scrutinee-data? match(
            SOME ->
                data-num-tags
                over match-cases@ len ==,
            NONE ->
                true # presume exhaustiveness
        )
    ))

def(match-has-default-case?, Match -- Match Bool,
    match-cases? cases-have-default-case)

||| Get type we're matching over.
def(match-scrutinee-type?, Match -- Match Maybe(Type),
    match-dom? type-expand match(
        TTensor -> nip SOME,
        _ -> drop NONE
    ))

||| Get "data" associated with scrutinee.
def(match-scrutinee-data?, Match -- Match Maybe(Data),
    match-scrutinee-type? maybe-bind(
        type-head match(
            TData -> SOME,
            _ -> drop NONE
        )
    ))

def(match-is-transparent?, Match -- Match Bool,
    match-scrutinee-data? match(
        SOME -> data-is-transparent,
        NONE -> false
    ))

########
# CASE #
########

def(cases-cover-case?, List(Case) Case -- List(Case) Case Bool,
    dup2 cases-cover-case)

def(cases-cover-case, List(Case) Case -- Bool,
    swap any(dup2 case-is-covered) nip)

||| Ask whether the second case covers the first case already.
def(case-is-covered, Case Case -- Bool,
    dip(case-pattern@) case-pattern@ pattern-is-covered)

def(cases-have-default-case, List(Case) -- Bool,
    any(dup case-is-default-case))

def(case-is-default-case, Case -- Bool,
    case-pattern@ PATTERN_UNDERSCORE ==)

###########
# PATTERN #
###########

||| Asks whether the second pattern already
||| covers the case of the first pattern.
def(pattern-is-covered, Pattern Pattern -- Bool,
    dup PATTERN_UNDERSCORE == if(drop2 true, ==))
