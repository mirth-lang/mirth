module(mirth/data/arrow)
import(mirth/data/common)
import(mirth/data/word)
import(mirth/data/prim)

##########
# ARROWS #
##########

# Each Mirth word is represented by a morphism in some category
# (or some class of categories). We provide special support for
# the morphisms of symmetric monoidal category theory, since we
# want to manipulate multiple pieces of data, like a string diagram,
# but we do not assume commutativity (i.e. that dip(f) g == g dip(f)),
# so that we can more easily represent computational effects like IO.
# As such, we actually provide special support for premonoidal
# categories, and we're really working with ordered string diagrams.

# The representation, for now, involves building up morphisms as a
# sequence of atomic morphisms. Atomic morphisms are morphisms that
# can't be broken down into a composition. These include calling
# words, primitives, control flow, and literal values. This is a
# nested intermediate representation.

# Originally this type was called Morphism but that's hard to spell and
# to type repeatedly so now it's called Arrow :-)

ARROW_NIL : Arrow
ARROW_NIL = 0 cast

arrow-is-nil? : Arrow -- Arrow Bool
arrow-is-nil? = dup ARROW_NIL ==

arrow-alloc! : Arrow
arrow-alloc! = (
    Arrow.alloc!
    OP_NONE over arrow-op!
)

arrow-op-prim! : Prim Arrow --
arrow-op-prim! = dip(OP_PRIM) arrow-op!

arrow-op-word! : Word Arrow --
arrow-op-word! = dip(OP_WORD) arrow-op!

arrow-op-tag! :  Tag Arrow --
arrow-op-tag! = dip(OP_TAG) arrow-op!

arrow-op-match! : Match Arrow --
arrow-op-match! = dip(OP_MATCH) arrow-op!

arrow-op-external! : External Arrow --
arrow-op-external! = dip(OP_EXTERNAL) arrow-op!

arrow-op-buffer! : Buffer Arrow --
arrow-op-buffer! = dip(OP_BUFFER) arrow-op!

arrow-op-int! : Int Arrow --
arrow-op-int! = dip(OP_INT) arrow-op!

arrow-op-str! : StrLit Arrow --
arrow-op-str! = dip(OP_STR) arrow-op!

#######
# ARG #
#######

Arrow->Arg : Arrow -- Arg
Arrow->Arg = ARG_ARROW

Arg->Arrow : Arg -- Arrow
Arg->Arrow = match(ARG_ARROW -> id)

########
# ARGS #
########

Int->Args : Int -- Args
Int->Args = cast

Args->Int : Args -- Int
Args->Int = cast

args@ : Ptr -- Args
args@ = value@

args! : Args Ptr --
args! = value!

args-alloc! : Args
args-alloc! = Args.alloc!

ARGS_NIL : Args
ARGS_NIL = 0 Int->Args

args-is-nil : Args -- Bool
args-is-nil = ARGS_NIL ==

args-is-nil? : Args -- Args Bool
args-is-nil? = dup args-is-nil

args-len : Args -- Int
args-len = 0 swap while(args-is-nil? not, dip(1+) args-tail@) drop

arrow-args-last& : Arrow -- Ptr
arrow-args-last& =
    arrow-args& while(
        dup args@ args-is-nil not,
        args@ args-tail&
    )

arrow-arg-add! : Arrow Arg -- Arrow
arrow-arg-add! = (
    args-alloc!
    tuck args-head!
    over arrow-args-last& args!
)

arrow-args-0 : Arrow --
arrow-args-0 =
    arrow-args? args-len 0 == if(
        drop,
        arrow-token@ "compiler error: expected no args in arrow"
        emit-fatal-error!
    )

arrow-args-1 : Arrow -- Arg
arrow-args-1 =
    arrow-args? args-len 1 == if(
        arrow-args@ args-head@,
        arrow-token@ "compiler error: expected 1 arg in arrow"
        emit-fatal-error!
    )

arrow-args-2 : Arrow -- Arg Arg
arrow-args-2 =
    arrow-args? args-len 2 == if(
        arrow-args@ args-head? swap
        args-tail@ args-head@,
        arrow-token@ "compiler error: expected 2 args in arrow"
        emit-fatal-error!
    )

####################################
# Helpers for constructing arrows. #
####################################
# TODO: Use an effect, or something, to elaborate these with types.

arrow-new-int! : Int -- Arrow
arrow-new-int! = (
    arrow-alloc!
    tuck arrow-op-int!
)

arrow-new-buffer! : Buffer -- Arrow
arrow-new-buffer! = (
    arrow-alloc!
    tuck arrow-op-buffer!
)

arrow-new-external! : External -- Arrow
arrow-new-external! = (
    arrow-alloc!
    tuck arrow-op-external!
)

arrow-new-prim! : Prim -- Arrow
arrow-new-prim! = (
    arrow-alloc!
    tuck arrow-op-prim!
)

arrow-new-word! : Word -- Arrow
arrow-new-word! = (
    arrow-alloc!
    tuck arrow-op-word!
)

arrow-push! : Arrow Arrow -- Arrow
arrow-push! = dup dip(swap arrow-next!)

arrow-push-int! : Arrow Int -- Arrow
arrow-push-int! = arrow-new-int! arrow-push!

arrow-push-buffer! : Arrow Buffer -- Arrow
arrow-push-buffer! = arrow-new-buffer! arrow-push!

arrow-push-external! : Arrow External -- Arrow
arrow-push-external! = arrow-new-external! arrow-push!

arrow-push-prim! : Arrow Prim -- Arrow
arrow-push-prim! = arrow-new-prim! arrow-push!

arrow-push-word! : Arrow Word -- Arrow
arrow-push-word! = arrow-new-word! arrow-push!
