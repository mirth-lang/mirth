module(mirth.lexer)

import(prelude)
import(platform.posix)
import(data.char)
import(data.stack)
import(data.path)
import(data.str)
import(mirth.data.location)
import(mirth.data.name)
import(mirth.data.token)
import(mirth.data.error)
import(mirth.data.module)
import(mirth.input)

#########
# LEXER #
#########

var(lexer-module, Module)
var(lexer-row, Row)
var(lexer-col, Col)
var(lexer-stack, Stack(Token))

def(run-lexer!, Path -- Module,
    module-new! lexer-module !

    lexer-module @ module-source-path
    Path->Str open-file! input-start!

    1 Int->Row lexer-row !
    1 Int->Col lexer-col !
    STACK_NIL lexer-stack !

    token-alloc!

    while(lexer-done? not, lexer-next!)

    input-end!

    lexer-stack stack-pop! match(
        NONE -> TOKEN_NONE lexer-emit!,
        SOME -> "Mismatched left parenthesis." emit-fatal-error!
    )

    token-alloc! lexer-module @ module-end !
    token-succ lexer-module @ module-start !

    lexer-module @)


# Is the lexer done?
def(lexer-done?, Bool, input-done?)

# Create a token, and add it to the token buffer,
# returning the new token.
def(lexer-make!, TokenValue -- Token,
    token-alloc!
    tuck token-value !
    lexer-module @ over token-module !
    lexer-row @ over token-row !
    lexer-col @ over token-col !)

# Create a token, and add it to the token buffer.
def(lexer-emit!, TokenValue --, lexer-make! drop)

# Lex the next token.
def(lexer-next!, --,
    lexer-peek

    char-valid? not if(
        "invalid character" lexer-emit-fatal-error!,

    dup is-name-char if(
        drop
        lexer-emit-name!,

    dup is-newline if(
        drop
        lexer-newline!,

    dup is-whitespace if(
        drop,

    dup is-pound if(
        drop
        lexer-skip-comment!,

    dup is-comma if(
        drop
        TOKEN_COMMA lexer-emit!,

    dup is-lparen if(
        drop
        lexer-emit-lparen!,

    dup is-rparen if(
        drop
        lexer-emit-rparen!,

    dup is-lsquare if(
        drop
        lexer-emit-lsquare!,

    dup is-rsquare if(
        drop
        lexer-emit-rsquare!,

    dup is-lcurly if(
        drop
        lexer-emit-lcurly!,

    dup is-rcurly if(
        drop
        lexer-emit-rcurly!,

    dup is-quote if(
        drop
        lexer-emit-string!,

        "unrecognized token" lexer-emit-fatal-error!
    )))))))))))

    lexer-move!)))

def(lexer-newline!, --,
    lexer-row modify(Row->Int 1+ Int->Row)
    0 Int->Col lexer-col !)

def(lexer-emit-lparen!, --,
    TOKEN_LPAREN_OPEN lexer-make!
    lexer-stack stack-push!)
def(lexer-emit-rparen!, --,
    lexer-stack stack-pop! match(
        NONE -> "Mismatched right parenthesis." lexer-emit-fatal-error!,
        SOME -> token-is-lparen-open? if(
            dup TOKEN_RPAREN lexer-make!
            TOKEN_LPAREN swap token-value !,
            "Mismatched right parenthesis." lexer-emit-fatal-error!
        )
    ))

def(lexer-emit-lsquare!, --,
    TOKEN_LSQUARE_OPEN lexer-make!
    lexer-stack stack-push!)
def(lexer-emit-rsquare!, --,
    lexer-stack stack-pop! match(
        NONE -> "Mismatched right square bracket." lexer-emit-fatal-error!,
        SOME -> token-is-lsquare-open? if(
            dup TOKEN_RSQUARE lexer-make!
            TOKEN_LSQUARE swap token-value !,
            "Mismatched right square bracket." lexer-emit-fatal-error!
        )
    ))

def(lexer-emit-lcurly!, --,
    TOKEN_LCURLY_OPEN lexer-make!
    lexer-stack stack-push!)
def(lexer-emit-rcurly!, --,
    lexer-stack stack-pop! match(
        NONE -> "Mismatched right curly brace." lexer-emit-fatal-error!,
        SOME -> token-is-lcurly-open? if(
            dup TOKEN_RCURLY lexer-make!
            TOKEN_LCURLY swap token-value !,
            "Mismatched right curly brace." lexer-emit-fatal-error!
        )
    ))

def(lexer-emit-name!, --,
    str-buf-clear!

    lexer-module @
    lexer-row @
    lexer-col @

    lexer-peek while(dup is-name-char,
        char-valid? if(
            str-buf-push-char!
            lexer-move!
            lexer-peek,

            "invalid character" lexer-emit-fatal-error!
        )
    )
    drop

    str-buf-is-doc-start? if(
        drop3
        lexer-skip-doc!,
        # TODO: save the doc in the token-doc field for the next token

        str-buf-is-int? if(
            str-buf-int? TOKEN_INT,
            str-buf-dup! name-new! TOKEN_NAME
        )

        token-alloc!
        tuck token-value !
        tuck token-col !
        tuck token-row !
        token-module !
    ))

def(str-buf-is-doc-start?, Bool,
    str-buf-length? 3 == and(
        0 str-buf-char@ is-pipe
        and(1 str-buf-char@ is-pipe)
        and(2 str-buf-char@ is-pipe)
    ))

def(str-buf-is-arrow?, Bool,
    str-buf-length? 2 == and(
        0 str-buf-char@ is-dash
        1 str-buf-char@ is-gt &&
    ))

def(str-buf-is-dashes?, Bool,
    str-buf-length? 2 == if(
        0 str-buf-char@ is-dash
        1 str-buf-char@ is-dash &&,
        false
    ))

def(str-buf-is-equal?, Bool,
    str-buf-length? 1 == if(
        0 str-buf-char@ is-eq,
        false
    ))

def(str-buf-is-int?, Bool,
    str-buf-is-dec-int? if(true, str-buf-is-hex-int?))

def(str-buf-is-dec-int?, Bool,
    0 # number of digits
    0 # current index
    dup str-buf-char@ is-sign if(
        1+,
        id
    )
    while(dup str-buf-char@ is-digit,
        dip(1+) 1+)
    swap 1 >= if(
        str-buf-length? ==,
        drop false
    ))

def(is-zero-char, Char -- Bool, Char->Int 48 ==)
def(is-xX-char, Char -- Bool, Char->Int dup 88 == dip(120 ==) ||)

def(str-buf-is-hex-int?, Bool,
    0 # number of digits
    0 # current index
    dup str-buf-char@ is-sign if(
        1+,
        id
    )
    dup str-buf-char@ is-zero-char if(
        1+
        dup str-buf-char@ is-xX-char if(
            1+
            while(dup str-buf-char@ is-hexdigit, dip(1+) 1+)
            swap 1 >= if(
                str-buf-length? ==,
                drop false
            ),

            drop2 false
        ),

        drop2 false
    ))

def(str-buf-int?, Int,
    str-buf-is-dec-int? if(
        str-buf-dec-int?,
        str-buf-hex-int?
    ))

def(str-buf-dec-int?, Int,
    1 # sign multiplier
    0 # accumulated value
    0 # current index
    dup str-buf-char@ dup is-sign if(
        is-dash if(
            dip2(drop -1),
            id
        )
        1+,
        drop
    )
    while(dup str-buf-length? <,
        sip(
            str-buf-char@ Char->Int
            dip(10 *) 48 - +
        )
        1+)
    drop *)

def(str-buf-hex-int?, Int,
    1 # sign multiplier
    0 # accumulated value
    0 # current index
    dup str-buf-char@ dup is-sign if(
        is-minus if(
            dip2(drop -1),
            id
        )
        1+,
        drop
    )
    2 + # skip 0x prefix
    while(dup str-buf-length? <,
        sip(
            str-buf-char@
            dip(16 *) hexdigit-value +
        )
        1+)
    drop *)

def(hexdigit-value, Char -- Int,
    dup is-digit if(
        Char->Int 48 -,
        dup is-upper-hexdigit if(
            Char->Int 55 -,
            Char->Int 87 -
        )
    ))

def(lexer-emit-string!, --,
    str-buf-clear!
    TOKEN_NONE lexer-make!

    lexer-move!
    lexer-peek while(dup is-string-end not,
        char-valid? if(
            lexer-push-string-char!
            lexer-move!
            lexer-peek,

            "invalid character in string literal" lexer-emit-fatal-error!
        )
    )
    drop

    str-buf-dup! TOKEN_STR
    swap token-value !)

def(lexer-push-string-char!, Char --,
    dup is-backslash if(
        drop lexer-move! lexer-peek

        dup is-newline if(
            drop,

        dup is-n if(
            drop 10 Int->Char str-buf-push-char!,

        dup is-r if(
            drop 13 Int->Char str-buf-push-char!,

        dup is-t if(
            drop 9 Int->Char str-buf-push-char!,

        dup is-quote if(
            str-buf-push-char!,

        dup is-backslash if(
            str-buf-push-char!,

            str-buf-push-char!

            "Unknown character escape sequence."
            lexer-emit-warning!

        )))))),

        str-buf-push-char!
    ))

def(lexer-skip-comment!, --,
    while(lexer-comment-end? not, lexer-move!)
    lexer-peek dup is-newline if(lexer-newline!, id) drop)

def(lexer-skip-doc!, --, while(lexer-comment-end? not, lexer-move!))

def(lexer-comment-end?, Bool,
    lexer-done? if(
        true,
        lexer-peek dup is-newline nip
    ))

def(lexer-peek, Char, input-peek)
def(lexer-move!, --, input-move!
    lexer-col modify(Col->Int 1+ Int->Col))

def(lexer-location, Location,
    lexer-module @ lexer-row @ lexer-col @ location-pack)

def(lexer-emit-warning!, Str --, dip(lexer-location) emit-warning-at!)
def(lexer-emit-error!, Str --, dip(lexer-location) emit-error-at!)
def(lexer-emit-fatal-error!, *a Str -- *b, dip(lexer-location) emit-fatal-error-at!)
