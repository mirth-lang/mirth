module(mirth.lexer)

import(prelude)
import(platform.posix)
import(data.byte)
import(data.stack)
import(data.path)
import(data.str)
import(mirth.data.location)
import(mirth.data.name)
import(mirth.data.token)
import(mirth.data.error)
import(mirth.data.module)
import(mirth.input)

#########
# LEXER #
#########

var(lexer-module, Module)
var(lexer-row, Row)
var(lexer-col, Col)
var(lexer-stack, Stack(Token))

def(run-lexer!, Path -- Module,
    module-new! lexer-module !

    lexer-module @ module-source-path
    Path->Str open-file! input-start!

    1 Int->Row lexer-row !
    1 Int->Col lexer-col !
    STACK_NIL lexer-stack !

    token-alloc!

    while(lexer-done? not, lexer-next!)

    input-end!

    lexer-stack stack-pop! match(
        NONE -> TOKEN_NONE lexer-emit!,
        SOME -> "Mismatched left parenthesis." emit-fatal-error!
    )

    token-alloc! lexer-module @ module-end !
    token-succ lexer-module @ module-start !

    lexer-module @)


# Is the lexer done?
def(lexer-done?, Bool, input-done?)

# Create a token, and add it to the token buffer,
# returning the new token.
def(lexer-make!, TokenValue -- Token,
    token-alloc!
    tuck token-value !
    lexer-module @ over token-module !
    lexer-row @ over token-row !
    lexer-col @ over token-col !)

# Create a token, and add it to the token buffer.
def(lexer-emit!, TokenValue --, lexer-make! drop)

# Lex the next token.
def(lexer-next!, --, lexer-peek match(
    BLF -> lexer-newline! lexer-move!,
    BSPACE -> lexer-move!,
    BHT -> lexer-move!,
    BVT -> lexer-move!,
    BCR -> lexer-move!,
    BHASH -> lexer-skip-comment! lexer-move!,
    BCOMMA -> TOKEN_COMMA lexer-emit! lexer-move!,
    BLPAREN -> lexer-emit-lparen! lexer-move!,
    BRPAREN -> lexer-emit-rparen! lexer-move!,
    BLSQUARE -> lexer-emit-lsquare! lexer-move!,
    BRSQUARE -> lexer-emit-rsquare! lexer-move!,
    BLCURLY -> lexer-emit-lcurly! lexer-move!,
    BRCURLY -> lexer-emit-rcurly! lexer-move!,
    BQUOTE -> lexer-emit-string! lexer-move!,
    _ -> byte-is-name-byte if(
        lexer-emit-name!,
        "Unrecognized byte." lexer-emit-fatal-error!
    )))

def(lexer-newline!, --,
    lexer-row modify(Row->Int 1+ Int->Row)
    0 Int->Col lexer-col !)

def(lexer-emit-lparen!, --,
    TOKEN_LPAREN_OPEN lexer-make!
    lexer-stack stack-push!)
def(lexer-emit-rparen!, --,
    lexer-stack stack-pop! match(
        NONE -> "Mismatched right parenthesis." lexer-emit-fatal-error!,
        SOME -> token-is-lparen-open? if(
            dup TOKEN_RPAREN lexer-make!
            TOKEN_LPAREN swap token-value !,
            "Mismatched right parenthesis." lexer-emit-fatal-error!
        )
    ))

def(lexer-emit-lsquare!, --,
    TOKEN_LSQUARE_OPEN lexer-make!
    lexer-stack stack-push!)
def(lexer-emit-rsquare!, --,
    lexer-stack stack-pop! match(
        NONE -> "Mismatched right square bracket." lexer-emit-fatal-error!,
        SOME -> token-is-lsquare-open? if(
            dup TOKEN_RSQUARE lexer-make!
            TOKEN_LSQUARE swap token-value !,
            "Mismatched right square bracket." lexer-emit-fatal-error!
        )
    ))

def(lexer-emit-lcurly!, --,
    TOKEN_LCURLY_OPEN lexer-make!
    lexer-stack stack-push!)
def(lexer-emit-rcurly!, --,
    lexer-stack stack-pop! match(
        NONE -> "Mismatched right curly brace." lexer-emit-fatal-error!,
        SOME -> token-is-lcurly-open? if(
            dup TOKEN_RCURLY lexer-make!
            TOKEN_LCURLY swap token-value !,
            "Mismatched right curly brace." lexer-emit-fatal-error!
        )
    ))

def(lexer-emit-name!, --,
    str-buf-clear!

    lexer-module @
    lexer-row @
    lexer-col @

    lexer-peek while(dup byte-is-name-byte,
        str-buf-push-byte!
        lexer-move!
        lexer-peek)
    drop

    str-buf-is-doc-start? if(
        drop3
        lexer-skip-doc!,
        # TODO: save the doc in the token-doc field for the next token

        str-buf-is-int? if(
            str-buf-int? TOKEN_INT,
            str-buf-dup! name-new! TOKEN_NAME
        )

        token-alloc!
        tuck token-value !
        tuck token-col !
        tuck token-row !
        token-module !
    ))

def(str-buf-is-doc-start?, Bool,
    str-buf-length? 3 == if(
        0 str-buf-byte@ B'|' ==
        1 str-buf-byte@ B'|' == &&
        2 str-buf-byte@ B'|' == &&,
        false
    ))

def(str-buf-is-arrow?, Bool,
    str-buf-length? 2 == and(
        0 str-buf-byte@ B'-' ==
        1 str-buf-byte@ B'>' == &&
    ))

def(str-buf-is-dashes?, Bool,
    str-buf-length? 2 == if(
        0 str-buf-byte@ B'-' ==
        1 str-buf-byte@ B'-' == &&,
        false
    ))

def(str-buf-is-int?, Bool,
    str-buf-is-dec-int? if(true, str-buf-is-hex-int?))

def(str-buf-is-dec-int?, Bool,
    0 # number of digits
    0 # current index
    dup str-buf-byte@ byte-is-sign if(1+, id)
    while(dup str-buf-byte@ byte-is-digit, dip(1+) 1+)
    swap 1 >= if(str-buf-length? ==, drop false))

def(str-buf-is-hex-int?, Bool,
    0 # number of digits
    0 # current index
    dup str-buf-byte@ byte-is-sign if(
        1+,
        id
    )
    dup str-buf-byte@ B'0' == if(
        1+
        dup str-buf-byte@ B'x' == if(
            1+
            while(dup str-buf-byte@ byte-is-hexdigit, dip(1+) 1+)
            swap 1 >= if(
                str-buf-length? ==,
                drop false
            ),

            drop2 false
        ),

        drop2 false
    ))

def(str-buf-int?, Int,
    str-buf-is-dec-int? if(
        str-buf-dec-int?,
        str-buf-hex-int?
    ))

def(byte-sign-multiplier, Byte -- Int,
    B'-' -> -1,
    B'+' -> +1,
    _ -> drop "unexpected byte in byte-sign-multiplier" panic!)

||| process int sign and return initial state for rest of int lexing.
||| returns: (sign multiplier) (accumulated value == 0) (str-buf index)
def(str-buf-int-sign, -- Int Int Int,
    0 str-buf-byte@ match(
        B'-' -> -1 0 1,
        B'+' -> +1 0 1,
        _ -> drop +1 0 0,
    ))

def(str-buf-dec-int?, Int,
    str-buf-int-sign
    while(dup str-buf-length? <,
        sip(
            str-buf-byte@ Byte->Int
            dip(10 *) 48 - +
        )
        1+)
    drop *)

def(str-buf-hex-int?, Int,
    str-buf-int-sign 2 + # skip 0x prefix
    while(dup str-buf-length? <,
        sip(
            str-buf-byte@
            dip(16 *) hexdigit-value +
        )
        1+)
    drop *)

def(hexdigit-value, Byte -- Int,
    dup byte-is-digit if(
        Byte->Int 48 -,
        Byte->Int 55 -
    ))

def(lexer-emit-string!, --,
    str-buf-clear!
    TOKEN_NONE lexer-make!

    lexer-move!
    lexer-peek while(dup byte-is-string-end not,
        lexer-push-string-byte!
        lexer-move!
        lexer-peek
    )
    drop

    str-buf-dup! TOKEN_STR
    swap token-value !)

def(lexer-push-string-byte!, Byte --,
    B'\' -> lexer-move! lexer-peek lexer-push-string-escape-byte!,
    _ -> str-buf-push-byte!)

def(lexer-push-string-escape-byte!, Byte --,
    BLF -> id,
    B'n' -> BLF str-buf-push-byte!,
    B'r' -> BCR str-buf-push-byte!,
    B't' -> BHT str-buf-push-byte!,
    B'\' -> B'\' str-buf-push-byte!,
    BQUOTE -> BQUOTE str-buf-push-byte!,
    _ -> str-buf-push-byte!
    "Unknown character escape sequence." lexer-emit-warning!)

def(lexer-skip-comment!, --,
    while(lexer-comment-end? not, lexer-move!)
    lexer-peek dup BLF == if(lexer-newline!, id) drop)

def(lexer-skip-doc!, --, while(lexer-comment-end? not, lexer-move!))

def(lexer-comment-end?, Bool,
    lexer-done? if(
        true,
        lexer-peek dup BLF == nip
    ))

def(lexer-peek, Byte, input-peek)
def(lexer-move!, --, input-move!
    lexer-col modify(Col->Int 1+ Int->Col))

def(lexer-location, Location,
    lexer-module @ lexer-row @ lexer-col @ location-pack)

def(lexer-emit-warning!, Str --, dip(lexer-location) emit-warning-at!)
def(lexer-emit-error!, Str --, dip(lexer-location) emit-error-at!)
def(lexer-emit-fatal-error!, *a Str -- *b, dip(lexer-location) emit-fatal-error-at!)
