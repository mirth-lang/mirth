module(mirth.need)

import(std.prelude)
import(std.list)
import(std.maybe)
import(std.stack)
import(std.set)
import(mirth.arrow)
import(mirth.word)
import(mirth.match)

########
# NEED #
########

data(Need,
    NEED_WORD -> Word,
    NEED_BLOCK -> Block)

def(Need.>Int, Need -- Int,
    NEED_WORD  -> index 2*,
    NEED_BLOCK -> index 2* 1+)

#########
# NEEDS #
#########

data(+Needs, +NEEDS -> Stack(Need) +Set(Need))
def(-NEEDS, +Needs -- Stack(Need) +Set(Need), +NEEDS -> id)
def(+Needs.~Stack(f), (*a Stack(Need) -- *b Stack(Need)) *a +Needs -- *b +Needs,
    -NEEDS rdip(f) +NEEDS)
def(+Needs.~Set(f), (*a +Set(Need) -- *b +Set(Need)) *a +Needs -- *b +Needs,
    -NEEDS dip(f) +NEEDS)

def(+Needs.new, -- +Needs, STACK_NIL +Set.new(Need.>Int) +NEEDS)
def(+Needs.rdrop, +Needs --, -NEEDS rdrop drop)

def(for-needed-words(f), (*a Word -- *a) *a +Needs -- *a +Needs,
    Word.for(dup needed? if(rdip(f), drop)))
def(for-needed-blocks(f), (*a Block -- *a) *a +Needs -- *a +Needs,
    Block.for(dup needed? if(rdip(f), drop)))

def(Need.needed?, Need +Needs -- Bool +Needs, ~Set(member?))
def(Word.needed?, Word +Needs -- Bool +Needs, NEED_WORD needed?)
def(Block.needed?, Block +Needs -- Bool +Needs, NEED_BLOCK needed?)

def(+Needs.need!, Need +Needs -- +Needs,
    dup needed? else(
        dup ~Set(insert!)
        dup ~Stack(STACK_CONS)
        expect!(dup needed?, "needed? fail")
    ) drop)
def(+Needs.need-word!, Word +Needs -- +Needs, NEED_WORD need!)
def(+Needs.need-block!, Block +Needs -- +Needs, NEED_BLOCK need!)

def(+Needs.determine-arrow-needs!, Arrow +Needs -- +Needs,
    run-arrow! determine-transitive-needs!)
def(+Needs.determine-transitive-needs!, +Needs -- +Needs,
    while-some(~Stack(uncons), run-need!))

def(+Needs.run-need!, Need +Needs -- +Needs,
    NEED_BLOCK -> run-block!,
    NEED_WORD -> run-word!)

def(+Needs.run-arg!, Arg +Needs -- +Needs,
    ARG_BLOCK -> run-block!)
def(+Needs.run-block!, Block +Needs -- +Needs, arrow run-arrow!)
def(+Needs.run-word!, Word +Needs -- +Needs, arrow run-arrow!)
def(+Needs.run-arrow!, Arrow +Needs -- +Needs, atoms for(run-atom!))
def(+Needs.run-atom!, Atom +Needs -- +Needs, sip(args) op run-op!)
def(+Needs.run-op!, List(Arg) Op +Needs -- +Needs,
    OP_NONE -> drop,
    OP_INT -> drop2,
    OP_STR -> drop2,
    OP_WORD -> need-word! push-args!,
    OP_EXTERNAL -> drop push-args!,
    OP_BUFFER -> drop push-args!,
    OP_VARIABLE -> drop push-args!,
    OP_FIELD -> drop push-args!,
    OP_TAG -> drop push-args!,
    OP_PRIM -> run-prim!,
    OP_MATCH -> nip run-match!,
    OP_LAMBDA -> nip run-lambda!,
    OP_VAR -> drop2,
    OP_BLOCK -> nip push-block!,
    OP_COERCE -> drop2,
    OP_LABEL_PUSH -> drop2,
    OP_LABEL_POP -> drop2,
    OP_DATA_GET_LABEL -> drop3,
    OP_DATA_SET_LABEL -> drop3)
def(+Needs.run-prim!, List(Arg) Prim +Needs -- +Needs,
    PRIM_CORE_DIP -> match(L1 -> run-arg!, _ -> push-args!),
    PRIM_CORE_RDIP -> match(L1 -> run-arg!, _ -> push-args!),
    PRIM_CORE_IF -> match(L2 -> dip(run-arg!) run-arg!, _ -> push-args!),
    PRIM_CORE_WHILE -> match(L2 -> dip(run-arg!) run-arg!, _ -> push-args!),
    _ -> drop push-args!)
def(+Needs.run-match!, Match +Needs -- +Needs, cases for(run-case!))
def(+Needs.run-case!, Case +Needs -- +Needs, body run-arrow!)
def(+Needs.run-lambda!, Lambda +Needs -- +Needs, body run-arrow!)

def(+Needs.push-args!, List(Arg) +Needs -- +Needs, for(push-arg!))
def(+Needs.push-arg!, Arg +Needs -- +Needs,
    ARG_BLOCK -> push-block!)
def(+Needs.push-block!, Block +Needs -- +Needs,
    dup to-run-var match(
        SOME -> drop2,
        NONE -> need-block!
    ))
