module(mirth.main)

import(std.prelude)
import(std.path)
import(std.str)
import(std.list)
import(std.byte)
import(std.maybe)

import(args.parse)
import(args.types)
import(args.state)

import(posix.posix)
import(posix.file)

import(mirth.package)
import(mirth.error)
import(mirth.prim)
import(mirth.word)
import(mirth.type)
import(mirth.name)
import(mirth.def)
import(mirth.lexer)
import(mirth.elab)
import(mirth.ctx)
import(mirth.c99)

def(init!, --,
    init-errors!
    init-types!
    init-prims!)

table(Arguments)
field(Arguments.~input-file, Arguments, Path)
field(Arguments.~output-file, Arguments, Maybe(Path))
field(Arguments.~entry-point, Arguments, Maybe(Str))
field(Arguments.~packages, Arguments, List([Str Path]))
field(Arguments.~emit-debug-info, Arguments, Bool)

def(Arguments.new,
        emit-debug-info:Bool
        input-file:Path
        output-file:Maybe(Path)
        entry-point:Maybe(Str)
        packages:List([Str Path]) -- Arguments,
    Arguments.alloc!
    packages> over ~packages !
    entry-point> over ~entry-point !
    input-file> over ~input-file !
    output-file> over ~output-file !
    emit-debug-info> over ~emit-debug-info !)

def(Arguments.unpack, Arguments --
        emit-debug-info:Bool
        input-file:Path
        output-file:Maybe(Path)
        entry-point:Maybe(Str)
        packages:List([Str Path]),
    dup ~packages @ >packages
    dup ~input-file @ >input-file
    dup ~output-file @ >output-file
    dup ~entry-point @ >entry-point
    dup ~emit-debug-info @ >emit-debug-info
    drop)

||| Create a default initialized arguments table
||| Since the input file is always required we don't need it to be Maybe(Path)
def(Arguments.default, -- Arguments,
    F >emit-debug-info
    "mirth.mth" >Path >input-file
    NONE >output-file
    "main" SOME >entry-point
    L0 >packages
    Arguments.new)

||| Pretty print the contents of the arguments struct
def(Arguments.show, Arguments -- Str,
    unpack
    "Arguments { "
    "output-file: " cat output-file> if-some(>Str, "(none)") cat
    ", input-file: " cat input-file> >Str cat
    ", entry-point: " cat entry-point> unwrap-or("(none)") cat
    ", emit-debug-info: " cat emit-debug-info> if("yes", "no") cat
    ", packages: " cat "[" packages> for(dip(cat) unpack2 dip(cat ":" cat) >Str cat " ") drop "]" cat
    " }" cat)

########
# Main #
########

def(compile!, Arguments +World -- +World,
    unpack
    "Compiling " trace!
    input-file> dup >Str trace-ln! >input-file
    packages> for(
      unpack2 swap >Name Package.new-or-set-path! drop
    )
    input-file> run-lexer!
    "Building." trace-ln!

    elab-module!
    typecheck-everything!

    entry-point> map(
        dip(dup NAMESPACE_MODULE) >Name QNAME0
        elab-entry-point
    ) nip

    num-errors @ 0> if(
        num-errors @ trace!
        " errors." trace-ln!
        1 posix-exit!,
  	    "No errors." trace-ln!
    )

    match(
        SOME ->
            "Codegen." trace-ln!
            output-file> unwrap >output-path
            C99_Options.make run-output-c99!,
        NONE ->
            "Skipping Codegen." trace-ln!
            emit-debug-info> drop
            output-file> drop
    ))

def(parse-package-def, Str -- [Str Path],
  dip(BCOLON) str-split-byte match(
    L2 -> >Path pack2,
    _ -> drop "Invalid package path definition" panic!
  )
)

def(compiler-parse-args, +ArgumentParser(Arguments) Arguments Maybe(Str) ArgpOptionType -- +ArgumentParser(Arguments) Arguments,
    SHORT -> match(
        B'o' -> unwrap >Path SOME over ~output-file !,
        B'e' -> unwrap SOME over ~entry-point !,
        B'c' -> drop NONE over ~entry-point !,
        B'p' -> unwrap parse-package-def over ~packages @ cons over ~packages !,
        _ -> drop drop UNKNOWN_ARG SOME state error! state!
    ),
    POSITIONAL -> state positional-index 0= if(
        unwrap >Path over ~input-file !,
        drop TOO_MANY_ARGS SOME state error! state!
    ),
    LONG_ONLY -> dup "debug" == if(
        drop2 T over ~emit-debug-info !,
        drop2 UNKNOWN_ARG SOME state error! state!
    ),
    END ->
        state positional-index 1 < then(
            TOO_FEW_ARGS SOME state error! state!
        )
        state arguments ~output-file @ match(
            SOME -> drop,
            # If we have an entry point we need to have an output file currently
            NONE -> state arguments ~entry-point @ match (
                SOME -> drop "output-file" MISSING_ARG SOME state error! state!,
                NONE ->
            )
        )
        drop,
    _ -> drop drop UNKNOWN_ARG SOME state error! state!)

def(main, +World -- +World,
    init!

    Arguments.default
    LIST(
        "output-file" SOME
        B'o' SHORT
        "OUTPUT_FILE" SOME
        "Test argument" SOME
        NONE ArgpOption.new ;

        "compile-only" SOME
        B'c' SHORT
        NONE
        "Compile code without running codegen step" SOME
        NONE ArgpOption.new ;

        "entry-point" SOME
        B'e' SHORT
        "ENTRY_POINT" SOME
        "Custom entry point word for compilation" SOME
        NONE ArgpOption.new ;

	"package" SOME
	B'p' SHORT
	"(PACKAGE:PATH)*" SOME
	"Package locations" SOME
	NONE ArgpOption.new ;

        "debug" SOME
        "debug" LONG_ONLY
        NONE
        "Emit debugging information during codegen" SOME
        NONE ArgpOption.new ;
    ) >options
    [ compiler-parse-args ] SOME >parser
    "input-file" SOME >args-doc
    "Mirth Compiler" >doc
    ArgumentParser.new

    parse-args match(
        RIGHT -> ,
        LEFT -> show panic!
    )

    compile!)
