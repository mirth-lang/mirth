module(mirth.main)

import(std.prelude)
import(std.path)
import(std.str)
import(std.list)
import(std.byte)
import(std.maybe)

import(args.parse)
import(args.types)
import(args.state)

import(posix.posix)
import(posix.file)

import(mirth.package)
import(mirth.error)
import(mirth.prim)
import(mirth.word)
import(mirth.type)
import(mirth.name)
import(mirth.def)
import(mirth.lexer)
import(mirth.elab)
import(mirth.ctx)
import(mirth.c99)

def(init!, --,
    init-errors!
    init-types!
    init-prims!)

table(Arguments)
field(Arguments.~input-file, Arguments, Path)
field(Arguments.~output-file, Arguments, Maybe(Path))
field(Arguments.~entry-point, Arguments, Maybe(Str))
field(Arguments.~packages, Arguments, List([Str Path]))

# Helpers to read table fields
def(Arguments.input-file, Arguments -- Path, ~input-file @)
def(Arguments.output-file, Arguments -- Maybe(Path), ~output-file @)
def(Arguments.entry-point, Arguments -- Maybe(Str), ~entry-point @)

def(Arguments.new, Path Maybe(Path) Maybe(Str) List([Str Path]) -- Arguments,
    Arguments.alloc!
    dup dip(~packages !)
    dup dip(~entry-point !)
    dup dip(~output-file !)
    dup dip(~input-file !))

||| Create a default initialized arguments table
||| Since the input file is always required we don't need it to be Maybe(Path)
def(Arguments.default, -- Arguments,
    "mirth.mth" >Path
    NONE
    "main" SOME
    L0
    Arguments.new)

||| Pretty print the contents of the arguments struct
def(Arguments.show, Arguments -- Str,
    "Arguments { "
    "output-file: " cat over output-file map(>Str) unwrap-or("(none)") cat
    ", input-file: " cat over input-file >Str cat
    ", entry-point: " cat over entry-point unwrap-or("(none)") cat
    " }" cat nip)

########
# Main #
########

def(compile!, Arguments +World -- +World,
    "Compiling " trace!
    dup input-file >Str trace-ln!

    dup ~packages @ for(
      unpack2 swap >Name Package.new-or-set-path! drop
    )

    dup input-file run-lexer!

    "Building." trace-ln!

    elab-module!
    typecheck-everything!

    over entry-point map(
        dip(dup NAMESPACE_MODULE) >Name QNAME
        elab-entry-point
    ) nip

    num-errors @ 0> if(
        num-errors @ trace!
        " errors." trace-ln!
        1 posix-exit!,
  	    "No errors." trace-ln!
    )

    match(
        SOME ->
            "Codegen." trace-ln!
            swap output-file unwrap run-output-c99!,
        NONE ->
            "Skipping Codegen." trace-ln! drop
    ))

def(Str.find, Str Str -- Maybe(Offset),
  swap thaw str-buf-find freeze drop
)

def(Str.substr-after, Offset Str -- Str,
  dip(1+)
  dup num-bytes over2 >Size -
  swap unsafe(str-slice)
)

def(Str.substr-before, Offset Str -- Str,
  swap >Size 0 >Offset swap rotl unsafe(str-slice)
)

def(Str.split-at, Offset Str -- [Str Str],
  dup2 substr-after dip(substr-before) pack2
)

def(parse-package-def, Str -- Maybe([Str Path]),
  dup ":" find match(
    SOME -> swap split-at unpack2 >Path pack2 SOME,
    NONE -> drop NONE
  )
)

def(compiler-parse-args, +ArgumentParser(Arguments) Arguments Maybe(Str) ArgpOptionType -- +ArgumentParser(Arguments) Arguments,
    OPTION_SHORT -> match(
        B'o' -> unwrap >Path SOME over ~output-file !,
        B'e' -> unwrap SOME over ~entry-point !,
        B'c' -> drop NONE over ~entry-point !,
	B'p' -> unwrap parse-package-def unwrap over ~packages @ cons over ~packages !,
        _ -> drop drop UNKNOWN_ARG SOME state current-error! state!
    ),
    OPTION_POSITIONAL -> state current-positional-arg 0= if(
        unwrap >Path over ~input-file !,
        drop TOO_MANY_ARGS SOME state current-error! state!
    ),
    OPTION_END ->
        state current-positional-arg 1 < then(
            TOO_FEW_ARGS SOME state current-error! state!
        )
        state arguments ~output-file @ match(
            SOME -> drop,
            # If we have an entry point we need to have an output file currently
            NONE -> state arguments ~entry-point @ match (
                SOME -> drop "output-file" MISSING_ARG SOME state current-error! state!,
                NONE ->
            )
        )
        drop,
    _ -> drop drop UNKNOWN_ARG SOME state current-error! state!)

def(main, +World -- +World,
    init!

    Arguments.default

    LIST(
        "output-file" SOME
        B'o' OPTION_SHORT
        "OUTPUT_FILE" SOME
        "Test argument" SOME
        NONE ArgpOption.new ;

        "compile-only" SOME
        B'c' OPTION_SHORT
        NONE
        "Compile code without running codegen step" SOME
        NONE ArgpOption.new ;

        "entry-point" SOME
        B'e' OPTION_SHORT
        "ENTRY_POINT" SOME
        "Custom entry point word for compilation" SOME
        NONE ArgpOption.new ;

	"package" SOME
	B'p' OPTION_SHORT
	"(PACKAGE:PATH)*" SOME
	"Package locations" SOME
	NONE ArgpOption.new ;
    )
    [ compiler-parse-args ] SOME
    "input-file" SOME
    "Mirth Compiler"
    ArgumentParser.new

    parse-args match(
        RIGHT -> ,
        LEFT -> show panic!
    )

    compile!)
