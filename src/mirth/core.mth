
import base/int
import base/nat
import base/str
import base/map
import base/list
import base/maybe
import base/result
import base/unsafe

import mirth/loc

export mirth/core
  type L(t)
  type CSort
  type CArity
  type CSym
  type CVar
  type CHole
  type CPrim
  type CHead
  type CTerm

  CSStack : CSort
  CSType : CSort
  CSValue : CSort
  CSWord : CSort
  csortIsStack? : CSort -- CSort Bool
  csortIsType? : CSort -- CSort Bool
  csortIsValue? : CSort -- CSort Bool
  csortIsWord? : CSort -- CSort Bool
  csort= : CSort CSort -- Bool
  csort->str : CSort -- Str

  MkCArity : List(CSort) CSort -- CArity
  CA0(a: CSort) : CArity
  CA1(a: CSort, b: CSort) : CArity
  CA2(a: CSort, b: CSort, c: CSort) : CArity
  CA3(a: CSort, b: CSort, c: CSort, d: CSort) : CArity
  unCArity : CArity -- List(CSort) CSort
  caritySort : CArity -- CSort
  carityArgs : CArity -- List(CSort)
  carity= : CArity CArity -- Bool
  carity->str : CArity -- Str

  MkCSym : CArity Str -- CSym
  unCSym : CSym -- CArity Str
  csymArity : CSym -- CArity
  csymSort : CSym -- CSort
  csym= : CSym CSym -- Bool
  csym->str : CSym -- Str

  MkCVar : CSort Str -- CVar
  unCVar : CVar -- CSort Str
  cvarArity : CVar -- CArity
  cvarSort : CVar -- CSort
  cvar= : CVar CVar -- Bool
  cvar->str : CVar -- Str

  MkCHole : CSort Int -- CHole
  unCHole : CHole -- CSort Int
  choleArity : CHole -- CArity
  choleSort : CHole -- CSort
  chole= : CHole CHole -- Bool
  chole->str : CHole -- Str

  CHSym : CSym -- CHead
  CHVar : CVar -- CHead
  CHHole : CHole -- CHead
  CHPrim : CPrim -- CHead
  cheadGetSym : CHead -- Maybe(CSym)
  cheadGetVar : CHead -- Maybe(CVar)
  cheadGetHole : CHead -- Maybe(CHole)
  cheadGetPrim : CHead -- Maybe(CPrim)
  cheadArity : CHead -- CArity
  cheadSort : CHead -- CSort
  chead= : CHead CHead -- Bool
  chead->str : CHead -- Str

  MkCTerm : CHead List(CTerm) -- CTerm
  unCTerm : CTerm -- CHead List(CTerm)
  ctermHead : CTerm -- CHead
  ctermArgs : CTerm -- List(CTerm)
  ctermSort : CTerm -- CSort
  cterm= : CTerm CTerm -- Bool
  cterm->str : CTerm -- Str

  CPSNil : CPrim
  CPSCons : CPrim
  CPTInt : CPrim
  CPTStr : CPrim
  CPTBool : CPrim
  CPTList : CPrim
  CPTPack : CPrim
  CPVInt : Int -- CPrim
  CPVStr : Str -- CPrim
  CPVBool : Bool -- CPrim
  CPVListNil : CPrim
  CPVListCons : CPrim
  CPVPackNil : CPrim
  CPVPackCons : CPrim
  CPWId : CPrim
  CPWCp : CPrim
  CPWDip : CPrim
  CPWDup : CPrim
  CPWDrop : CPrim
  CPWSwap : CPrim
  CPWPush : CPrim
  cprimBuiltinTypes : Map(Str, CPrim)
  cprimBuiltinWords : Map(Str, CPrim)
  cprimArity : CPrim -- CArity
  cprimSort : CPrim -- CSort
  cprim= : CPrim CPrim -- Bool
  cprim->str : CPrim -- Str
end


||| Syntactic sorts.
data CSort
  CSStack : CSort
  CSType : CSort
  CSValue : CSort
  CSWord : CSort
end

csortIsStack? : CSort -- CSort Bool
csortIsStack? = dup match(CSStack -> true, _ -> drop false)

csortIsType? : CSort -- CSort Bool
csortIsType? = dup match(CSType -> true, _ -> drop false)

csortIsValue? : CSort -- CSort Bool
csortIsValue? = dup match(CSValue -> true, _ -> drop false)

csortIsWord? : CSort -- CSort Bool
csortIsWord? = dup match(CSWord -> true, _ -> drop false)

csort= : CSort CSort -- Bool
csort= =
  match(
    CSStack -> csortIsStack? nip,
    CSType -> csortIsType? nip,
    CSValue -> csortIsValue? nip,
    CSWord -> csortIsWord? nip
  )

csort->str : CSort -- Str
csort->str =
  match(
    CSStack -> "stack",
    CSType -> "type",
    CSValue -> "value",
    CSWord -> "word"
  )

csort->carity : CSort -- CArity
csort->carity = dip(nil) MkCArity


||| Operator arity.
data CArity
  MkCArity : List(CSort) CSort -- CArity
end

CA0(a: CSort) : CArity
CA1(a: CSort, b: CSort) : CArity
CA2(a: CSort, b: CSort, c: CSort) : CArity
CA3(a: CSort, b: CSort, c: CSort, d: CSort) : CArity
CA0(a) = nil a MkCArity
CA1(a,b) = nil a cons b MkCArity
CA2(a,b,c) = nil a cons b cons c MkCArity
CA3(a,b,c,d) = nil a cons b cons c cons d MkCArity

unCArity : CArity -- List(CSort) CSort
unCArity = match(MkCArity -> id)

caritySort : CArity -- CSort
caritySort = unCArity nip

carityArgs : CArity -- List(CSort)
carityArgs = unCArity drop

carity= : CArity CArity -- Bool
carity= = $(
  dip(unCArity) unCArity dip(swap)
  dip2(list=(csort=)) csort= and
)

carity->str : CArity -- Str
carity->str = dip("") unCArity dip(for(csort->str " -> " <> <>)) csort->str <>


data CSym
  MkCSym : CArity Str -- CSym
end

unCSym : CSym -- CArity Str
unCSym = match(MkCSym -> id)

csymArity : CSym -- CArity
csymArity = unCSym drop

csymSort : CSym -- CSort
csymSort = csymArity caritySort

csym= : CSym CSym -- Bool
csym= = dip(unCSym) unCSym dip(swap) dip2(carity=) streq and

csym->str : CSym -- Str
csym->str = unCSym nip


data CVar
  MkCVar : CSort Str -- CVar
end

unCVar : CVar -- CSort Str
unCVar = match(MkCVar -> id)

cvarSort : CVar -- CSort
cvarSort = unCVar drop

cvarArity : CVar -- CArity
cvarArity = cvarSort csort->carity

cvar= : CVar CVar -- Bool
cvar= = dip(unCVar) unCVar dip(swap) dip2(csort=) streq and

cvar->str : CVar -- Str
cvar->str = unCVar nip


data CHole
  MkCHole : CSort Int -- CHole
end

unCHole : CHole -- CSort Int
unCHole = match(MkCHole -> id)

choleSort : CHole -- CSort
choleSort = unCHole drop

choleArity : CHole -- CArity
choleArity = choleSort csort->carity

chole= : CHole CHole -- Bool
chole= = dip(unCHole) unCHole dip(swap) dip2(csort=) z= and

chole->str : CHole -- Str
chole->str = dip("?") unCHole nip int->str <>


data CHead
  CHSym : CSym -- CHead
  CHVar : CVar -- CHead
  CHHole : CHole -- CHead
  CHPrim : CPrim -- CHead
end

cheadGetSym : CHead -- Maybe(CSym)
cheadGetSym = match(CHSym -> some, _ -> drop none)

cheadGetVar : CHead -- Maybe(CVar)
cheadGetVar = match(CHVar -> some, _ -> drop none)

cheadGetHole : CHead -- Maybe(CHole)
cheadGetHole = match(CHHole -> some, _ -> drop none)

cheadGetPrim : CHead -- Maybe(CPrim)
cheadGetPrim = match(CHPrim -> some, _ -> drop none)

cheadArity : CHead -- CArity
cheadArity =
  match(
    CHSym -> csymArity,
    CHVar -> cvarArity,
    CHHole -> choleArity,
    CHPrim -> cprimArity
  )

cheadSort : CHead -- CSort
cheadSort = cheadArity caritySort

chead= : CHead CHead -- Bool
chead= =
  match(
    CHSym -> swap cheadGetSym maybe(drop false, swap csym=),
    CHVar -> swap cheadGetVar maybe(drop false, swap cvar=),
    CHHole -> swap cheadGetHole maybe(drop false, swap chole=),
    CHPrim -> swap cheadGetPrim maybe(drop false, swap cprim=)
  )

chead->str : CHead -- Str
chead->str =
  match(
    CHSym -> csym->str,
    CHVar -> cvar->str,
    CHHole -> chole->str,
    CHPrim -> cprim->str
  )


data CTerm
  MkCTerm : CHead List(CTerm) -- CTerm
end

unCTerm : CTerm -- CHead List(CTerm)
unCTerm = match(MkCTerm -> id)

ctermHead : CTerm -- CHead
ctermHead = unCTerm drop

ctermArgs : CTerm -- List(CTerm)
ctermArgs = unCTerm nip

ctermSort : CTerm -- CSort
ctermSort = ctermHead cheadSort

cterm= : CTerm CTerm -- Bool
cterm= = $(
  dip(unCTerm) unCTerm dip(swap)
  dip2(chead=) rotl if(
    list=(cterm=),
    drop2 false
  )
)

cterm->str : CTerm -- Str
cterm->str = $(
  unCTerm dip(chead->str)
  lmatchL(id,
    dip2("(" <>)
    dip(cterm->str <>)
    for(dip(", ") cterm->str <> <>)
    ")" <>
  )
)


##############
# Primitives #
##############

||| Primitive operators.
data CPrim
  # Built-in Stacks
  CPSNil : CPrim
  CPSCons : CPrim

  # Built-in Types
  CPTInt : CPrim
  CPTStr : CPrim
  CPTBool : CPrim
  CPTList : CPrim
  CPTPack : CPrim

  # Built-in Values
  CPVInt : Int -- CPrim
  CPVStr : Str -- CPrim
  CPVBool : Bool -- CPrim
  CPVListNil : CPrim
  CPVListCons : CPrim
  CPVPackNil : CPrim
  CPVPackCons : CPrim

  # Built-in Words
  CPWId : CPrim
  CPWCp : CPrim
  CPWDip : CPrim
  CPWDup : CPrim
  CPWDrop : CPrim
  CPWPush : CPrim
  CPWSwap : CPrim
  CPWPackMap : CPrim
  CPWPackPack2 : CPrim
  CPWPackUnpack2 : CPrim
  CPWBoolIf : CPrim
  CPWBoolTrue : CPrim
  CPWBoolFalse : CPrim
  CPWIntAdd : CPrim
  CPWIntSub : CPrim
  CPWIntMul : CPrim
  CPWIntDiv : CPrim
  CPWIntMod : CPrim
  CPWIntLt : CPrim
  CPWIntEq : CPrim
  CPWStrCat : CPrim
  CPWStrBreak : CPrim
  CPWStrLen : CPrim
  CPWStrFromCodepoint : CPrim
  CPWStrToCodepoint : CPrim
  CPWStrElem : CPrim
  CPWStrReMatch : CPrim
  CPWListNil : CPrim
  CPWListCons : CPrim
  CPWListCat : CPrim
  CPWListLen : CPrim
  CPWListAt : CPrim
  CPWListBreak : CPrim
  CPWListMap : CPrim
  CPWListFor : CPrim
  CPWUnsafePanic : CPrim
  CPWUnsafeTrace : CPrim
  CPWUnsafePrint : CPrim
  CPWUnsafeListDir : CPrim
  CPWUnsafeWalk : CPrim
  CPWUnsafeIsDir : CPrim
  CPWUnsafeIsFile : CPrim
  CPWUnsafeRead : CPrim
  CPWUnsafeWrite : CPrim
  CPWUnsafeAppend : CPrim
  CPWUnsafeDelete : CPrim
  CPWUnsafeCoerce : CPrim
  CPWUnsafeHash : CPrim
  CPWUnsafeEnvGet : CPrim
  CPWUnsafeEnvSet : CPrim
  CPWUnsafeExit : CPrim
end

cprim->str : CPrim -- Str
cprim->str =
  match(
    CPSNil -> "CPSNil",
    CPSCons -> "CPSCons",
    CPTInt -> "CPTInt",
    CPTStr -> "CPTStr",
    CPTBool -> "CPTBool",
    CPTList -> "CPTList",
    CPTPack -> "CPTPack",
    CPVInt -> drop "CPVInt",
    CPVStr -> drop "CPVStr",
    CPVBool -> drop "CPVBool",
    CPVListNil -> "CPVListNil",
    CPVListCons -> "CPVListCons",
    CPVPackNil -> "CPVPackNil",
    CPVPackCons -> "CPVPackCons",
    CPWId -> "CPWId",
    CPWCp -> "CPWCp",
    CPWDip -> "CPWDip",
    CPWDup -> "CPWDup",
    CPWDrop -> "CPWDrop",
    CPWSwap -> "CPWSwap",
    CPWPush -> "CPWPush",
    CPWPackMap -> "CPWPackMap",
    CPWPackPack2 -> "CPWPackPack2",
    CPWPackUnpack2 -> "CPWPackUnpack2",
    CPWBoolIf -> "CPWBoolIf",
    CPWBoolTrue -> "CPWBoolTrue",
    CPWBoolFalse -> "CPWBoolFalse",
    CPWIntAdd -> "CPWIntAdd",
    CPWIntSub -> "CPWIntSub",
    CPWIntMul -> "CPWIntMul",
    CPWIntDiv -> "CPWIntDiv",
    CPWIntMod -> "CPWIntMod",
    CPWIntLt -> "CPWIntLt",
    CPWIntEq -> "CPWIntEq",
    CPWStrCat -> "CPWStrCat",
    CPWStrBreak -> "CPWStrBreak",
    CPWStrLen -> "CPWStrLen",
    CPWStrFromCodepoint -> "CPWStrFromCodepoint",
    CPWStrToCodepoint -> "CPWStrToCodepoint",
    CPWStrElem -> "CPWStrElem",
    CPWStrReMatch -> "CPWStrReMatch",
    CPWListNil -> "CPWListNil",
    CPWListCons -> "CPWListCons",
    CPWListCat -> "CPWListCat",
    CPWListLen -> "CPWListLen",
    CPWListAt -> "CPWListAt",
    CPWListBreak -> "CPWListBreak",
    CPWListMap -> "CPWListMap",
    CPWListFor -> "CPWListFor",
    CPWUnsafePanic -> "CPWUnsafePanic",
    CPWUnsafeTrace -> "CPWUnsafeTrace",
    CPWUnsafePrint -> "CPWUnsafePrint",
    CPWUnsafeListDir -> "CPWUnsafeListDir",
    CPWUnsafeWalk -> "CPWUnsafeWalk",
    CPWUnsafeIsDir -> "CPWUnsafeIsDir",
    CPWUnsafeIsFile -> "CPWUnsafeIsFile",
    CPWUnsafeRead -> "CPWUnsafeRead",
    CPWUnsafeWrite -> "CPWUnsafeWrite",
    CPWUnsafeAppend -> "CPWUnsafeAppend",
    CPWUnsafeDelete -> "CPWUnsafeDelete",
    CPWUnsafeCoerce -> "CPWUnsafeCoerce",
    CPWUnsafeHash -> "CPWUnsafeHash",
    CPWUnsafeEnvGet -> "CPWUnsafeEnvGet",
    CPWUnsafeEnvSet -> "CPWUnsafeEnvSet",
    CPWUnsafeExit -> "CPWUnsafeExit"
  )

cprim= : CPrim CPrim -- Bool
cprim= = dip(cprim->str) cprim->str streq

cprimBuiltinTypes : Map(Str, CPrim)
cprimBuiltinTypes = $(
  mapNil
  "Int" CPTInt mapSet
  "Str" CPTStr mapSet
  "Bool" CPTBool mapSet
  "List" CPTList mapSet
  "Pack" CPTPack mapSet
)

cprimBuiltinWords : Map(Str, CPrim)
cprimBuiltinWords = $(
  mapNil
  "_prim_id" CPWId mapSet
  "_prim_cp" CPWCp mapSet
  "_prim_dup" CPWDup mapSet
  "_prim_drop" CPWDrop mapSet
  "_prim_swap" CPWSwap mapSet
  "_prim_dip" CPWDip mapSet
  "_prim_bool_true" CPWBoolTrue mapSet
  "_prim_bool_false" CPWBoolFalse mapSet
  "_prim_bool_if" CPWBoolIf mapSet
  "_prim_int_add" CPWIntAdd mapSet
  "_prim_int_sub" CPWIntSub mapSet
  "_prim_int_mul" CPWIntMul mapSet
  "_prim_int_div" CPWIntDiv mapSet
  "_prim_int_mod" CPWIntMod mapSet
  "_prim_int_lt" CPWIntLt mapSet
  "_prim_int_eq" CPWIntEq mapSet
  "_prim_str_cat" CPWStrCat mapSet
  "_prim_str_break" CPWStrBreak mapSet
  "_prim_str_len" CPWStrLen mapSet
  "_prim_str_to_codepoint" CPWStrToCodepoint mapSet
  "_prim_str_from_codepaint" CPWStrFromCodepoint mapSet
  "_prim_str_elem" CPWStrElem mapSet
  "_prim_str_rematch" CPWStrReMatch mapSet
  "_prim_tuple_intuple" CPWPackMap mapSet
  "_prim_tuple_pack2" CPWPackPack2 mapSet
  "_prim_tuple_unpack2" CPWPackUnpack2 mapSet
  "_prim_list_nil" CPWListNil mapSet
  "_prim_list_cons" CPWListCons mapSet
  "_prim_list_cat" CPWListCat mapSet
  "_prim_list_len" CPWListLen mapSet
  "_prim_list_at" CPWListAt mapSet
  "_prim_list_break" CPWListBreak mapSet
  "_prim_list_map" CPWListMap mapSet
  "_prim_list_for" CPWListFor mapSet
  "_prim_unsafe_panic" CPWUnsafePanic mapSet
  "_prim_unsafe_trace" CPWUnsafeTrace mapSet
  "_prim_unsafe_print" CPWUnsafePrint mapSet
  "_prim_unsafe_listdir" CPWUnsafeListDir mapSet
  "_prim_unsafe_walk" CPWUnsafeWalk mapSet
  "_prim_unsafe_isdir" CPWUnsafeIsDir mapSet
  "_prim_unsafe_isfile" CPWUnsafeIsFile mapSet
  "_prim_unsafe_read" CPWUnsafeRead mapSet
  "_prim_unsafe_write" CPWUnsafeWrite mapSet
  "_prim_unsafe_append" CPWUnsafeAppend mapSet
  "_prim_unsafe_deletefile" CPWUnsafeDelete mapSet
  "_prim_unsafe_coerce" CPWUnsafeCoerce mapSet
  "_prim_unsafe_hash" CPWUnsafeHash mapSet
  "_prim_unsafe_env_get" CPWUnsafeEnvGet mapSet
  "_prim_unsafe_env_set" CPWUnsafeEnvSet mapSet
  "_prim_unsafe_exit" CPWUnsafeExit mapSet
)

cprimArity : CPrim -- CArity
cprimArity =
  match(
    CPSNil -> CA0(CSStack),
    CPSCons -> CA2(CSStack, CSValue, CSStack),
    CPTInt -> CA0(CSType),
    CPTStr -> CA0(CSType),
    CPTBool -> CA0(CSType),
    CPTList -> CA1(CSType, CSType),
    CPTPack -> CA1(CSStack, CSType),
    CPVInt -> drop CA0(CSValue),
    CPVStr -> drop CA0(CSValue),
    CPVBool -> drop CA0(CSValue),
    CPVListNil -> CA0(CSValue),
    CPVListCons -> CA2(CSValue, CSValue, CSValue),
    CPVPackNil -> CA0(CSValue),
    CPVPackCons -> CA2(CSValue, CSValue, CSValue),
    CPWId -> CA0(CSWord),
    CPWCp -> CA2(CSWord, CSWord, CSWord),
    CPWDip -> CA1(CSWord, CSWord),
    CPWDup -> CA0(CSWord),
    CPWDrop -> CA0(CSWord),
    CPWSwap -> CA0(CSWord),
    CPWPush -> CA1(CSValue, CSWord),
    CPWPackMap -> CA1(CSWord, CSWord),
    CPWPackPack2 -> CA0(CSWord),
    CPWPackUnpack2 -> CA0(CSWord),
    CPWBoolTrue -> CA0(CSWord),
    CPWBoolFalse -> CA0(CSWord),
    CPWBoolIf -> CA2(CSWord, CSWord, CSWord),
    CPWIntAdd -> CA0(CSWord),
    CPWIntSub -> CA0(CSWord),
    CPWIntMul -> CA0(CSWord),
    CPWIntDiv -> CA0(CSWord),
    CPWIntMod -> CA0(CSWord),
    CPWIntLt -> CA0(CSWord),
    CPWIntEq -> CA0(CSWord),
    CPWStrCat -> CA0(CSWord),
    CPWStrBreak -> CA0(CSWord),
    CPWStrLen -> CA0(CSWord),
    CPWStrFromCodepoint -> CA0(CSWord),
    CPWStrToCodepoint -> CA0(CSWord),
    CPWStrElem -> CA0(CSWord),
    CPWStrReMatch -> CA0(CSWord),
    CPWListNil -> CA0(CSWord),
    CPWListCons -> CA0(CSWord),
    CPWListCat -> CA0(CSWord),
    CPWListLen -> CA0(CSWord),
    CPWListAt -> CA0(CSWord),
    CPWListBreak -> CA0(CSWord),
    CPWListMap -> CA1(CSWord, CSWord),
    CPWListFor -> CA1(CSWord, CSWord),
    CPWUnsafePanic -> CA0(CSWord),
    CPWUnsafeTrace -> CA0(CSWord),
    CPWUnsafePrint -> CA0(CSWord),
    CPWUnsafeListDir -> CA0(CSWord),
    CPWUnsafeWalk -> CA0(CSWord),
    CPWUnsafeIsDir -> CA0(CSWord),
    CPWUnsafeIsFile -> CA0(CSWord),
    CPWUnsafeRead -> CA0(CSWord),
    CPWUnsafeWrite -> CA0(CSWord),
    CPWUnsafeAppend -> CA0(CSWord),
    CPWUnsafeDelete -> CA0(CSWord),
    CPWUnsafeCoerce -> CA0(CSWord),
    CPWUnsafeHash -> CA0(CSWord),
    CPWUnsafeEnvGet -> CA0(CSWord),
    CPWUnsafeEnvSet -> CA0(CSWord),
    CPWUnsafeExit -> CA0(CSWord)
  )

cprimSort : CPrim -- CSort
cprimSort = cprimArity caritySort

#######################
# STRONGLY TYPED CORE #
#######################

type CStack
type CType
type CValue
type CWord

ctermGetStack : CTerm -- Maybe(CStack)
ctermGetType  : CTerm -- Maybe(CType)
ctermGetValue : CTerm -- Maybe(CValue)
ctermGetWord  : CTerm -- Maybe(CWord)

cstack->cterm : CStack -- CTerm
ctype->cterm : CType -- CTerm
cvalue->cterm : CValue -- CTerm
cword->cterm : CWord -- CTerm

data CStack
  MkCStack : CTerm -- CStack
end

ctermGetStack : CTerm -- Maybe(CStack)
ctermGetStack = dup ctermSort CSStack csort= if(MkCStack some, drop none)

cterm->cstack : CTerm -- CStack
cterm->cstack =
  dup ctermGetStack maybe(
    dip("cterm->cstack: not a stack type: ") cterm->str <> unsafe_panic,
    nip
  )

cstack->cterm : CStack -- CTerm
cstack->cterm = match(MkCStack -> id)

CSVar : Str -- CStack
CSVar = dip(CSStack) MkCVar CHVar nil MkCTerm MkCStack

CSHole : Int -- CStack
CSHole = dip(CSStack) MkCHole CHHole nil MkCTerm MkCStack

CSNil : CStack
CSNil = CPSNil CHPrim nil MkCTerm MkCStack

CSCons : CStack CType -- CStack
CSCons = dip2(CPSCons CHPrim nil) dip(cstack->cterm cons) ctype->cterm cons MkCTerm MkCStack

data CType
  MkCType : CTerm -- CType
end

ctermGetType : CTerm -- Maybe(CType)
ctermGetType = dup ctermSort CSType csort= if(MkCType some, drop none)

cterm->ctype : CTerm -- CType
cterm->ctype =
  dup ctermGetType maybe(
    dip("cterm->ctype: not a value type: ") cterm->str <> unsafe_panic,
    nip
  )

ctype->cterm : CType -- CTerm
ctype->cterm = match(MkCType -> id)

CTVar : Str -- CType
CTVar = dip(CSType) MkCVar CHVar nil MkCTerm MkCType

CTHole : Int -- CType
CTHole = dip(CSType) MkCHole CHHole nil MkCTerm MkCType

CTInt : CType
CTInt = CPTInt CHPrim nil MkCTerm MkCType

CTStr : CType
CTStr = CPTStr CHPrim nil MkCTerm MkCType

CTBool : CType
CTBool = CPTBool CHPrim nil MkCTerm MkCType

CTList : CType -- CType
CTList = dip(CPTList CHPrim nil) ctype->cterm cons MkCTerm MkCType

CTPack : CStack -- CType
CTPack = dip(CPTPack CHPrim nil) cstack->cterm cons MkCTerm MkCType

data CKind
  CKStack : CKind
  CKType : CKind
  CKValue : CType -- CKind
  CKWord : CStack CStack -- CKind
end

data CSig
  MkCSig : List(CKind) CKind -- CSig
end

[ : List(t)
[ = nil

; : List(t) t -- List(t)
; = cons

] : List(t) t -- List(t)
] = cons

[] : List(t)
[] = nil

CKWord00 : CKind
CKWord01 : CType -- CKind
CKWord10 : CType -- CKind
CKWord11 : CType CType -- CKind
CKWord12 : CType CType CType -- CKind
CKWord20 : CType CType -- CKind
CKWord21 : CType CType CType -- CKind
CKWord22 : CType CType CType CType -- CKind

CKWord00 = 0 CSHole 0 CSHole CKWord
CKWord01 = dip(0 CSHole 0 CSHole) CSCons CKWord
CKWord10 = dip(0 CSHole) CSCons 0 CSHole CKWord
CKWord11 = dip2(0 CSHole) dip(CSCons 0 CSHole) CSCons CKWord
CKWord12 = dip3(0 CSHole) dip2(CSCons 0 CSHole) dip(CSCons) CSCons CKWord
CKWord20 = dip2(0 CSHole) dip(CSCons) CSCons 0 CSHole CKWord
CKWord21 = dip3(0 CSHole) dip2(CSCons) dip(CSCons 0 CSHole) CSCons CKWord
CKWord22 = dip4(0 CSHole) dip3(CSCons) dip2(CSCons 0 CSHole) dip(CSCons) CSCons CKWord

cprimSig : CPrim -- CSig
cprimSig =
  match(
    CPSNil -> [] CKStack,
    CPSCons -> [ CKStack ; CKType ] CKStack,

    CPTInt -> [] CKType,
    CPTStr -> [] CKType,
    CPTBool -> [] CKType,
    CPTList -> [ CKType ] CKType,
    CPTPack -> [ CKStack ] CKType,

    CPVInt -> drop [] CTInt CKValue,
    CPVStr -> drop [] CTStr CKValue,
    CPVBool -> drop [] CTBool CKValue,
    CPVListNil -> [] 0 CTHole CTList CKValue,
    CPVListCons ->
      [ 0 CTHole CTList CKValue
      ; 0 CTHole CKValue
      ] 0 CTHole CTList CKValue,
    CPVPackNil  -> [] CSNil CTPack CKValue,
    CPVPackCons ->
      [ 0 CSHole CTPack CKValue
      ; 1 CTHole CKValue
      ] 0 CSHole 1 CTHole CSCons CTPack CKValue,

    CPWId -> [] CKWord00,
    CPWCp ->
      [ 0 CSHole 1 CSHole CKWord
      ; 1 CSHole 2 CSHole CKWord
      ] 0 CSHole 2 CSHole CKWord,
    CPWDip ->
      [ 0 CSHole 1 CSHole CKWord
      ] 0 CSHole 2 CTHole CSCons
        1 CSHole 2 CTHole CSCons CKWord,
    CPWDup ->  [] 1 CTHole dup dup CKWord12,
    CPWDrop -> [] 1 CTHole CKWord10,
    CPWSwap -> [] 1 CTHole 2 CTHole dup2 swap CKWord22,
    CPWPush -> [ 1 CTHole CKValue ] 1 CTHole CKWord01,

    CPWPackMap ->
      [ 1 CSHole 2 CSHole CKWord
      ] 1 CSHole CTPack 2 CSHole CTPack CKWord11,
    CPWPackPack2 ->
      [] 1 CTHole 2 CTHole
         CSNil 1 CTHole CSCons 2 CTHole CSCons CTPack
         CKWord21,
    CPWPackUnpack2 ->
      [] CSNil 1 CTHole CSCons 2 CTHole CSCons CTPack
         1 CTHole 2 CTHole CKWord12,

    CPWBoolIf ->
      [ 0 CSHole 1 CSHole CKWord
      ; 0 CSHole 1 CSHole CKWord
      ] 0 CSHole CTBool CSCons 1 CSHole CKWord,
    CPWBoolTrue -> [] CTBool CKWord01,
    CPWBoolFalse -> [] CTBool CKWord01,

    CPWIntAdd -> [] CTInt CTInt CTInt CKWord21,
    CPWIntSub -> [] CTInt CTInt CTInt CKWord21,
    CPWIntMul -> [] CTInt CTInt CTInt CKWord21,
    CPWIntDiv -> [] CTInt CTInt CTInt CKWord21,
    CPWIntMod -> [] CTInt CTInt CTInt CKWord21,
    CPWIntLt -> [] CTInt CTInt CTBool CKWord21,
    CPWIntEq -> [] CTInt CTInt CTBool CKWord21,
    CPWStrCat -> [] CTStr CTStr CTStr CKWord21,
    CPWStrBreak -> [] CTInt CTStr CTStr CTStr CKWord22,
    CPWStrLen -> [] CTStr CTInt CKWord11,
    CPWStrFromCodepoint -> [] CTInt CTStr CKWord11,
    CPWStrToCodepoint -> [] CTStr CTInt CKWord11,
    CPWStrElem -> [] CTStr CTStr CTBool CKWord21,
    CPWStrReMatch -> [] CTStr CTStr CTInt CTBool CKWord22,
    CPWListNil -> [] 1 CTHole CTList CKWord01,
    CPWListCons -> [] 1 CTHole CTList 1 CTHole 1 CTHole CTList CKWord21,
    CPWListCat -> [] 1 CTHole CTList dup dup CKWord21,
    CPWListLen -> [] 1 CTHole CTList CTInt CKWord11,
    CPWListAt -> [] 1 CTHole CTList CTInt 1 CTHole CKWord21,
    CPWListBreak -> [] 1 CTHole CTList dup dup dip2(CTInt) CKWord22,
    CPWListMap -> [ 1 CTHole 2 CTHole CKWord11 ] 1 CTHole CTList 2 CTHole CTList CKWord11,
    CPWListFor -> [ 1 CTHole CKWord10 ] 1 CTHole CTList CKWord10,
    CPWUnsafePanic -> [] 0 CSHole CTStr CSCons 1 CSHole CKWord,
    CPWUnsafeTrace -> [] CTStr CKWord10,
    CPWUnsafePrint -> [] CTStr CKWord10,
    CPWUnsafeListDir -> [] CTStr CTStr CTList CKWord11,
    CPWUnsafeWalk ->
      [] CTStr CSNil CTStr CSCons CTStr CTList CSCons CTStr CTList CSCons CTPack CKWord11,
    CPWUnsafeIsDir -> [] CTStr CTBool CKWord11,
    CPWUnsafeIsFile -> [] CTStr CTBool CKWord11,
    CPWUnsafeRead -> [] CTStr CTStr CKWord11,
    CPWUnsafeWrite -> [] CTStr CTStr CKWord20,
    CPWUnsafeAppend -> [] CTStr CTStr CKWord20,
    CPWUnsafeDelete -> [] CTStr CKWord10,
    CPWUnsafeCoerce -> [] 0 CSHole 1 CSHole CKWord,
    CPWUnsafeHash -> [] 1 CTHole CTInt CKWord11,
    CPWUnsafeEnvGet -> [] CTStr 1 CTHole CKWord11,
    CPWUnsafeEnvSet -> [] 1 CTHole CTStr CKWord20,
    CPWUnsafeExit -> [] 0 CSHole CTInt CSCons 1 CSHole CKWord
  ) MkCSig


