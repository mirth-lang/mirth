
import base/int
import base/nat
import base/str
import base/map
import base/set
import base/list
import base/list/syntax
import base/maybe
import base/result
import base/unsafe

import mirth/loc

export mirth/core
  type L(t)
  type CSort
  type CArity
  type CSym
  type CVar
  type CHole
  type CPrim
  type CHead
  type CTerm
  type CStack
  type CType
  type CValue
  type CWord
  type CKind
  type CBind
  type CSig
  type CCons
  type CData
  type CCase
  type CMatch
  type CBody
  type CDef
  type CSymKey
  type CVarKey
  type CHoleKey
  type CEnv
  type CBinds
  type CFresh
  type CCtx

  CSStack : CSort
  CSType : CSort
  CSValue : CSort
  CSWord : CSort
  csortIsStack? : CSort -- CSort Bool
  csortIsType? : CSort -- CSort Bool
  csortIsValue? : CSort -- CSort Bool
  csortIsWord? : CSort -- CSort Bool
  csort= : CSort CSort -- Bool
  csort->str : CSort -- Str

  MkCArity : List(CSort) CSort -- CArity
  CA0(a: CSort) : CArity
  CA1(a: CSort, b: CSort) : CArity
  CA2(a: CSort, b: CSort, c: CSort) : CArity
  CA3(a: CSort, b: CSort, c: CSort, d: CSort) : CArity
  unCArity : CArity -- List(CSort) CSort
  caritySort : CArity -- CSort
  carityArgs : CArity -- List(CSort)
  carity= : CArity CArity -- Bool
  carity->str : CArity -- Str

  MkCSym : CSig Str -- CSym
  unCSym : CSym -- CSig Str
  csymSig : CSym -- CSig
  csymKind : CSym -- CKind
  csymArity : CSym -- CArity
  csymSort : CSym -- CSort
  csym= : CSym CSym -- Bool
  csym->str : CSym -- Str

  MkCVar : CKind Str -- CVar
  unCVar : CVar -- CKind Str
  cvarSig : CVar -- CSig
  cvarKind : CVar -- CKind
  cvarArity : CVar -- CArity
  cvarSort : CVar -- CSort
  cvar= : CVar CVar -- Bool
  cvar->str : CVar -- Str

  MkCHole : CKind Nat -- CHole
  unCHole : CHole -- CKind Nat
  choleSig : CHole -- CSig
  choleKind : CHole -- CKind
  choleArity : CHole -- CArity
  choleSort : CHole -- CSort
  chole= : CHole CHole -- Bool
  chole->str : CHole -- Str

  cprimBuiltinTypes : Map(Str, CPrim)
  cprimBuiltinWords : Map(Str, CPrim)
  cprimArity : CPrim -- CArity
  cprimSort : CPrim -- CSort
  cprimKind : CPrim -- CKind
  cprimSig : CPrim -- CSig
  cprim= : CPrim CPrim -- Bool
  cprim->str : CPrim -- Str

  CHSym : CSym -- CHead
  CHVar : CVar -- CHead
  CHHole : CHole -- CHead
  CHPrim : CPrim -- CHead
  cheadMatch(
    onSym: *a CSym -- *b,
    onVar: *a CVar -- *b,
    onHole: *a CHole -- *b,
    onPrim: *a CPrim -- *b
  ) : *a CHead -- *b
  cheadGetSym : CHead -- Maybe(CSym)
  cheadGetVar : CHead -- Maybe(CVar)
  cheadGetHole : CHead -- Maybe(CHole)
  cheadGetPrim : CHead -- Maybe(CPrim)
  cheadSig : CHead -- CSig
  cheadKind : CHead -- CKind
  cheadClosed : CHead -- Bool
  cheadClosed? : CHead -- CHead Bool
  cheadArity : CHead -- CArity
  cheadSort : CHead -- CSort
  cheadVars : CHead -- Set(CVar)
  cheadHoles : CHead -- Set(CHole)
  chead= : CHead CHead -- Bool
  chead->str : CHead -- Str

  MkCTerm : CHead List(CTerm) -- CTerm
  unCTerm : CTerm -- CHead List(CTerm)
  ctermGetHole : CTerm -- Maybe(CHole)
  ctermHead : CTerm -- CHead
  ctermArgs : CTerm -- List(CTerm)
  ctermSort : CTerm -- CSort
  ctermVars : CTerm -- Set(CVar)
  ctermHoles : CTerm -- Set(CHole)
  cterm= : CTerm CTerm -- Bool
  cterm->str : CTerm -- Str

  CSVar : CVar -- CStack # panics
  CSHole : CHole -- CStack # panics
  CSVar' : Str -- CStack
  CSHole' : Int -- CStack
  CSNil : CStack
  CSCons : CStack CType -- CStack
  ctermGetStack : CTerm -- Maybe(CStack)
  cterm->cstack : CTerm -- CStack # panics
  cstack->cterm : CStack -- CTerm
  cstack->str : CStack -- Str

  CTVar : CVar -- CType # panics
  CTHole : CHole -- CType # panics
  CTSym : CSym List(CTerm) -- CType # panics
  CTPrim : CPrim List(CTerm) -- CType # panics
  CTVar' : Str -- CType
  CTHole' : Int -- CType
  CTInt : CType
  CTStr : CType
  CTBool : CType
  CTList : CType -- CType
  CTPack : CStack -- CType
  CTPack2 : CType CType -- CType
  CTPack3 : CType CType CType -- CType
  ctermGetType : CTerm -- Maybe(CType)
  cterm->ctype : CTerm -- CType # panics
  ctype->cterm : CType -- CTerm
  ctype->str : CType -- Str

  CVVar : CVar -- CValue #panics
  CVSym : CSym List(CTerm) -- CValue #panics
  CVHole : CHole -- CValue #panics
  CVInt : Int -- CValue
  CVStr : Str -- CValue
  CVBool : Bool -- CValue
  CVListNil : CValue
  CVListCons : CValue CValue -- CValue
  CVPackNil : CValue
  CVPackCons : CValue CValue -- CValue
  ctermGetValue : CTerm -- Maybe(CValue)
  cterm->cvalue : CTerm -- CValue #panics
  cvalue->cterm : CValue -- CTerm
  cvalue->str : CValue -- Str

  CWVar : CVar -- CWord #panics
  CWSym : CSym List(CTerm) -- CWord #panics
  CWHole : CHole -- CWord #panics
  CWPrim : CPrim List(CTerm) -- CWord #panics
  CWId : CWord
  CWCp : CWord CWord -- CWord
  ctermGetWord : CTerm -- Maybe(CWord)
  cterm->cword : CTerm -- CWord #panics
  cword->cterm : CWord -- CTerm
  cword->str : CWord -- Str

  CKStack : CKind
  CKType : CKind
  CKValue : CType -- CKind
  CKWord : CStack CStack -- CKind
  CKWord00 : CKind
  CKWord01 : CType -- CKind
  CKWord10 : CType -- CKind
  CKWord11 : CType CType -- CKind
  CKWord12 : CType CType CType -- CKind
  CKWord20 : CType CType -- CKind
  CKWord21 : CType CType CType -- CKind
  CKWord22 : CType CType CType CType -- CKind
  ckindSort : CKind -- CSort
  ckindVars : CKind -- Set(CVar)
  ckindHoles : CKind -- Set(CHole)

  CBImplicit : CVar -- CBind
  CBExplicit : CVar -- CBind
  CBAnonymous : CKind -- CBind
  cbindIsImplicit : CBind -- Bool
  cbindIsExplicit : CBind -- Bool
  cbindIsAnonymous : CBind -- Bool
  cbindVar : CBind -- Maybe(CVar)
  cbindKind : CBind -- CKind
  cbindSort : CBind -- CSort

  MkCSig : List(CBind) CKind -- CSig
  MkCSig' : List(CKind) CKind -- CSig
  unCSig : CSig -- List(CBind) CKind
  csigNil : CKind -- CSig
  csigKind : CSig -- CKind
  csigArgs : CSig -- List(CBind)
  csigSort : CSig -- CSort
  csigArity : CSig -- CArity

  MkCCons : CSym List(CBind) List(CType) CType -- CCons
  unCCons : CCons -- CSym List(CBind) List(CType) CType
  cconsSym : CCons -- CSym
  cconsArgs : CCons -- List(CBind)
  cconsInputs : CCons -- List(CType)
  cconsOutput : CCons -- CType
  ccons->str : CCons -- Str

  MkCData : List(CCons) -- CData
  unCData : CData -- List(CCons)

  MkCCase : CCons List(CBind) CWord -- CCase
  unCCase : CCase -- CCons List(CBind) CWord
  ccaseCons : CCase -- CCons
  ccaseArgs : CCase -- List(CBind)
  ccaseBody : CCase -- CWord
  ccase->str : CCase -- Str

  MkCMatch : List(CCase) Maybe(CTerm) -- CMatch
  unCMatch : CMatch -- List(CCase) Maybe(CTerm)
  cmatchCases : CMatch -- List(CCase)
  cmatchDefault : CMatch -- Maybe(CTerm)

  CBTerm : CTerm -- CBody
  CBData : CData -- CBody
  CBCons : CCons -- CBody
  CBMatch : CMatch -- CBody
  cbodyMatch(
    onTerm: *a CTerm -- *b,
    onData: *a CData -- *b,
    onCons: *a CCons -- *b,
    onMatch: *a CMatch -- *b
  ) : *a CBody -- *b

  MkCDef : CSym Maybe(CBody) -- CDef
  unCDef : CDef -- CSym Maybe(CBody)
  cdefSym : CDef -- CSym
  cdefSig : CDef -- CSig
  cdefArity : CDef -- CArity
  cdefKind : CDef -- CKind
  cdefSort : CDef -- CSort
  cdefBody : CDef -- Maybe(CBody)
  cdef->str : CDef -- Str

  MkCSymKey : CArity Str -- CSymKey
  csym->csymkey : CSym -- CSymKey

  MkCVarKey : CSort Str -- CVarKey
  cvar->cvarkey : CVar -- CVarKey

  MkCHoleKey : CSort Nat -- CHoleKey
  chole->cholekey : CHole -- CHoleKey

  MkCEnv : Map(CSymKey, CDef) -- CEnv
  unCEnv : CEnv -- Map(CSymKey, CDef)
  cenvDefs : CEnv -- Map(CSymKey, CDef)
  cenvNil : CEnv
  cenvGet : CEnv CSym -- Maybe(CDef)
  cenvSet : CEnv CDef -- CEnv
  cenvAdd : CEnv CDef -- Result(Str, CEnv)
  cenv->str : CEnv -- Str

  MkCBinds : Map(CVarKey, CBind) -- CBinds
  unCBinds : CBinds -- Map(CVarKey, CBind)
  cbindsNil : CBinds
  cbindsGet : CBinds CVar -- Maybe(CBind)
  cbindsGetKind : CBinds CVar -- Maybe(CKind)
  cbindsGet? : CBinds CVar -- CBinds CVar Maybe(CBind)
  cbindsGetKind? : CBinds CVar -- CBinds CVar Maybe(CKind)
  cbindsAdd : CBinds CBind -- Result(Str, CBinds)
  cbindsAddMany : CBinds List(CBind) -- Result(Str, CBinds)

  MkCFresh : Map(CHoleKey, CTerm) Nat -- CFresh
  unCFresh : CFresh -- Map(CHoleKey, CTerm) Nat
  cfreshNil : CFresh
  cfreshNext : CFresh -- CFresh Nat
  cfreshReserve : CFresh Nat -- CFresh
  cfreshGet : CFresh CHole -- Maybe(CTerm)
  cfreshGet? : CFresh CHole -- CFresh CHole Maybe(CTerm)
  cfreshSet : CFresh CHole CTerm -- CFresh

  MkCCtx : CEnv CBinds CFresh -- CCtx
  cctxNil : CEnv -- CCtx
  cctxAdd : CCtx CBind -- Result(Str, CCtx)
  cctxAddMany : CCtx List(CBind) -- Result(Str, CCtx)
  cctxGet : CCtx CVar -- Maybe(CBind)
  cctxGetKind : CCtx CVar -- Maybe(CKind)
  cctxGet? : CCtx CVar -- CCtx CVar Maybe(CBind)
  cctxGetKind? : CCtx CVar -- CCtx CVar Maybe(CKind)
  cctxFreshNat : CCtx -- CCtx Nat
  cctxReserve : CCtx Nat -- CCtx
  cctxGetHole : CCtx CHole -- Maybe(CTerm)
  cctxGetHole? : CCtx CHole -- CCtx CHole Maybe(CTerm)
  cctxSetHole : CCtx CHole CTerm -- CCtx

end

||| Syntactic sorts.
data CSort
  CSStack : CSort
  CSType : CSort
  CSValue : CSort
  CSWord : CSort
end

csortIsStack? : CSort -- CSort Bool
csortIsStack? = dup match(CSStack -> true, _ -> drop false)

csortIsType? : CSort -- CSort Bool
csortIsType? = dup match(CSType -> true, _ -> drop false)

csortIsValue? : CSort -- CSort Bool
csortIsValue? = dup match(CSValue -> true, _ -> drop false)

csortIsWord? : CSort -- CSort Bool
csortIsWord? = dup match(CSWord -> true, _ -> drop false)

csort= : CSort CSort -- Bool
csort= =
  match(
    CSStack -> csortIsStack? nip,
    CSType -> csortIsType? nip,
    CSValue -> csortIsValue? nip,
    CSWord -> csortIsWord? nip
  )

csort->str : CSort -- Str
csort->str =
  match(
    CSStack -> "stack",
    CSType -> "type",
    CSValue -> "value",
    CSWord -> "word"
  )

csort->carity : CSort -- CArity
csort->carity = dip(nil) MkCArity

||| Operator arity.
data CArity
  MkCArity : List(CSort) CSort -- CArity
end

CA0(a: CSort) : CArity
CA1(a: CSort, b: CSort) : CArity
CA2(a: CSort, b: CSort, c: CSort) : CArity
CA3(a: CSort, b: CSort, c: CSort, d: CSort) : CArity
CA0(a) = nil a MkCArity
CA1(a,b) = nil a cons b MkCArity
CA2(a,b,c) = nil a cons b cons c MkCArity
CA3(a,b,c,d) = nil a cons b cons c cons d MkCArity

unCArity : CArity -- List(CSort) CSort
unCArity = match(MkCArity -> id)

caritySort : CArity -- CSort
caritySort = unCArity nip

carityArgs : CArity -- List(CSort)
carityArgs = unCArity drop

carity= : CArity CArity -- Bool
carity= = $(
  dip(unCArity) unCArity dip(swap)
  dip2(list=(csort=)) csort= and
)

carity->str : CArity -- Str
carity->str = dip("") unCArity dip(for(csort->str " -> " <> <>)) csort->str <>

data CSym
  MkCSym : CSig Str -- CSym
end

unCSym : CSym -- CSig Str
unCSym = match(MkCSym -> id)

||| Get the sym's sig. This is not context-dependent.
csymSig : CSym -- CSig
csymSig = unCSym drop

||| Get the sym's kind. This is not context-dependent.
csymKind : CSym -- CKind
csymKind = csymSig csigKind

csymArity : CSym -- CArity
csymArity = csymSig csigArity

csymSort : CSym -- CSort
csymSort = csymKind ckindSort

csym= : CSym CSym -- Bool
csym= = dip(csym->str) csym->str streq

csym->str : CSym -- Str
csym->str = unCSym nip

data CVar
  MkCVar : CKind Str -- CVar
end

unCVar : CVar -- CKind Str
unCVar = match(MkCVar -> id)

||| Get the var's sig. This is context-dependent.
cvarSig : CVar -- CSig
cvarSig = cvarKind csigNil

||| Get the var's kind. This is context-dependent.
cvarKind : CVar -- CKind
cvarKind = unCVar drop

cvarSort : CVar -- CSort
cvarSort = cvarKind ckindSort

cvarArity : CVar -- CArity
cvarArity = cvarSig csigArity

cvar= : CVar CVar -- Bool
cvar= = dip(cvar->str) cvar->str streq # Maybe should compare kinds as well? Seems dangerous.

cvar->str : CVar -- Str
cvar->str = unCVar nip

data CHole
  MkCHole : CKind Nat -- CHole
end

unCHole : CHole -- CKind Nat
unCHole = match(MkCHole -> id)

choleNat : CHole -- Nat
choleNat = unCHole nip

||| Get the hole's kind. This is context-dependent.
choleSig : CHole -- CSig
choleSig = choleKind csigNil

||| Get the hole's kind. This is context-dependent.
choleKind : CHole -- CKind
choleKind = unCHole drop

choleSort : CHole -- CSort
choleSort = choleKind ckindSort

choleArity : CHole -- CArity
choleArity = choleSig csigArity

chole= : CHole CHole -- Bool
chole= = dip(choleNat) choleNat n=

chole->str : CHole -- Str
chole->str = dip("?") choleNat nat->str <>

data CHead
  CHSym : CSym -- CHead
  CHVar : CVar -- CHead
  CHHole : CHole -- CHead
  CHPrim : CPrim -- CHead
end

cheadMatch(
  onSym: *a CSym -- *b,
  onVar: *a CVar -- *b,
  onHole: *a CHole -- *b,
  onPrim: *a CPrim -- *b
) : *a CHead -- *b
cheadMatch(onSym, onVar, onHole, onPrim) =
  match(
    CHSym -> onSym,
    CHVar -> onVar,
    CHHole -> onHole,
    CHPrim -> onPrim
  )

cheadGetSym : CHead -- Maybe(CSym)
cheadGetSym = match(CHSym -> some, _ -> drop none)

cheadGetVar : CHead -- Maybe(CVar)
cheadGetVar = match(CHVar -> some, _ -> drop none)

cheadGetHole : CHead -- Maybe(CHole)
cheadGetHole = match(CHHole -> some, _ -> drop none)

cheadGetPrim : CHead -- Maybe(CPrim)
cheadGetPrim = match(CHPrim -> some, _ -> drop none)

cheadVars : CHead -- Set(CVar)
cheadVars = cheadClosed? if(drop setNil, dup dip(cheadGetVar maybe->set) cheadKind ckindVars setUnion)

cheadHoles : CHead -- Set(CHole)
cheadHoles = cheadClosed? if(drop setNil, dup dip(cheadGetHole maybe->set) cheadKind ckindHoles setUnion)

||| Get the head's sig. This is context-dependent only for CVars and CHoles.
||| See `cheadClosed` below.
cheadSig : CHead -- CSig
cheadSig =
  match(
    CHSym -> csymSig,
    CHVar -> cvarSig,
    CHHole -> choleSig,
    CHPrim -> cprimSig
  )

||| True only if the head or the head's sig are not context-dependent.
cheadClosed : CHead -- Bool
cheadClosed =
  match(
    CHSym -> drop true,
    CHVar -> drop false,
    CHHole -> drop false,
    CHPrim -> drop true
  )

cheadClosed? : CHead -- CHead Bool
cheadClosed? = dup cheadClosed

cheadKind : CHead -- CKind
cheadKind = cheadSig csigKind

cheadArity : CHead -- CArity
cheadArity = cheadSig csigArity

cheadSort : CHead -- CSort
cheadSort = cheadSig csigSort

chead= : CHead CHead -- Bool
chead= =
  match(
    CHSym -> swap cheadGetSym maybe(drop false, swap csym=),
    CHVar -> swap cheadGetVar maybe(drop false, swap cvar=),
    CHHole -> swap cheadGetHole maybe(drop false, swap chole=),
    CHPrim -> swap cheadGetPrim maybe(drop false, swap cprim=)
  )

chead->str : CHead -- Str
chead->str =
  match(
    CHSym -> csym->str,
    CHVar -> cvar->str,
    CHHole -> chole->str,
    CHPrim -> cprim->str
  )

data CTerm
  MkCTerm : CHead List(CTerm) -- CTerm
end

unCTerm : CTerm -- CHead List(CTerm)
unCTerm = match(MkCTerm -> id)

ctermHead : CTerm -- CHead
ctermHead = unCTerm drop

ctermArgs : CTerm -- List(CTerm)
ctermArgs = unCTerm nip

ctermSort : CTerm -- CSort
ctermSort = ctermHead cheadSort

ctermGetHole : CTerm -- Maybe(CHole)
ctermGetHole = ctermHead cheadGetHole

ctermGetVar : CTerm -- Maybe(CVar)
ctermGetVar = ctermHead cheadGetVar

ctermGetSym : CTerm -- Maybe(CSym)
ctermGetSym = ctermHead cheadGetSym

ctermGetPrim : CTerm -- Maybe(CPrim)
ctermGetPrim = ctermHead cheadGetPrim

ctermVars : CTerm -- Set(CVar)
ctermVars = unCTerm dip(cheadVars) for(ctermVars setUnion)

ctermHoles : CTerm -- Set(CHole)
ctermHoles = unCTerm dip(cheadHoles) for(ctermHoles setUnion)

cterm= : CTerm CTerm -- Bool
cterm= = $(
  dip(unCTerm) unCTerm dip(swap)
  dip2(chead=) rotl if(
    list=(cterm=),
    drop2 false
  )
)

cterm->str : CTerm -- Str
cterm->str = $(
  unCTerm dip(chead->str)
  lmatchL(id,
    dip2("(" <>)
    dip(cterm->str <>)
    for(dip(", ") cterm->str <> <>)
    ")" <>
  )
)

##############
# Primitives #
##############

||| Primitive operators.
data CPrim
  # Built-in Stacks
  CPSNil : CPrim
  CPSCons : CPrim

  # Built-in Types
  CPTInt : CPrim
  CPTStr : CPrim
  CPTBool : CPrim
  CPTList : CPrim
  CPTPack : CPrim

  # Built-in Values
  CPVInt : Int -- CPrim
  CPVStr : Str -- CPrim
  CPVBool : Bool -- CPrim
  CPVListNil : CPrim
  CPVListCons : CPrim
  CPVPackNil : CPrim
  CPVPackCons : CPrim

  # Built-in Words
  CPWId : CPrim
  CPWCp : CPrim
  CPWDip : CPrim
  CPWDup : CPrim
  CPWDrop : CPrim
  CPWPush : CPrim
  CPWSwap : CPrim
  CPWPackMap : CPrim
  CPWPackPack2 : CPrim
  CPWPackUnpack2 : CPrim
  CPWBoolIf : CPrim
  CPWBoolTrue : CPrim
  CPWBoolFalse : CPrim
  CPWIntAdd : CPrim
  CPWIntSub : CPrim
  CPWIntMul : CPrim
  CPWIntDiv : CPrim
  CPWIntMod : CPrim
  CPWIntLt : CPrim
  CPWIntEq : CPrim
  CPWStrCat : CPrim
  CPWStrBreak : CPrim
  CPWStrLen : CPrim
  CPWStrFromCodepoint : CPrim
  CPWStrToCodepoint : CPrim
  CPWStrElem : CPrim
  CPWStrReMatch : CPrim
  CPWListNil : CPrim
  CPWListCons : CPrim
  CPWListCat : CPrim
  CPWListLen : CPrim
  CPWListAt : CPrim
  CPWListBreak : CPrim
  CPWListMap : CPrim
  CPWListFor : CPrim
  CPWUnsafePanic : CPrim
  CPWUnsafeTrace : CPrim
  CPWUnsafePrint : CPrim
  CPWUnsafeListDir : CPrim
  CPWUnsafeWalk : CPrim
  CPWUnsafeIsDir : CPrim
  CPWUnsafeIsFile : CPrim
  CPWUnsafeRead : CPrim
  CPWUnsafeWrite : CPrim
  CPWUnsafeAppend : CPrim
  CPWUnsafeDelete : CPrim
  CPWUnsafeCoerce : CPrim
  CPWUnsafeHash : CPrim
  CPWUnsafeEnvGet : CPrim
  CPWUnsafeEnvSet : CPrim
  CPWUnsafeExit : CPrim
end

cprim->str : CPrim -- Str
cprim->str =
  match(
    CPSNil -> "CPSNil",
    CPSCons -> "CPSCons",
    CPTInt -> "CPTInt",
    CPTStr -> "CPTStr",
    CPTBool -> "CPTBool",
    CPTList -> "CPTList",
    CPTPack -> "CPTPack",
    CPVInt -> drop "CPVInt",
    CPVStr -> drop "CPVStr",
    CPVBool -> drop "CPVBool",
    CPVListNil -> "CPVListNil",
    CPVListCons -> "CPVListCons",
    CPVPackNil -> "CPVPackNil",
    CPVPackCons -> "CPVPackCons",
    CPWId -> "CPWId",
    CPWCp -> "CPWCp",
    CPWDip -> "CPWDip",
    CPWDup -> "CPWDup",
    CPWDrop -> "CPWDrop",
    CPWSwap -> "CPWSwap",
    CPWPush -> "CPWPush",
    CPWPackMap -> "CPWPackMap",
    CPWPackPack2 -> "CPWPackPack2",
    CPWPackUnpack2 -> "CPWPackUnpack2",
    CPWBoolIf -> "CPWBoolIf",
    CPWBoolTrue -> "CPWBoolTrue",
    CPWBoolFalse -> "CPWBoolFalse",
    CPWIntAdd -> "CPWIntAdd",
    CPWIntSub -> "CPWIntSub",
    CPWIntMul -> "CPWIntMul",
    CPWIntDiv -> "CPWIntDiv",
    CPWIntMod -> "CPWIntMod",
    CPWIntLt -> "CPWIntLt",
    CPWIntEq -> "CPWIntEq",
    CPWStrCat -> "CPWStrCat",
    CPWStrBreak -> "CPWStrBreak",
    CPWStrLen -> "CPWStrLen",
    CPWStrFromCodepoint -> "CPWStrFromCodepoint",
    CPWStrToCodepoint -> "CPWStrToCodepoint",
    CPWStrElem -> "CPWStrElem",
    CPWStrReMatch -> "CPWStrReMatch",
    CPWListNil -> "CPWListNil",
    CPWListCons -> "CPWListCons",
    CPWListCat -> "CPWListCat",
    CPWListLen -> "CPWListLen",
    CPWListAt -> "CPWListAt",
    CPWListBreak -> "CPWListBreak",
    CPWListMap -> "CPWListMap",
    CPWListFor -> "CPWListFor",
    CPWUnsafePanic -> "CPWUnsafePanic",
    CPWUnsafeTrace -> "CPWUnsafeTrace",
    CPWUnsafePrint -> "CPWUnsafePrint",
    CPWUnsafeListDir -> "CPWUnsafeListDir",
    CPWUnsafeWalk -> "CPWUnsafeWalk",
    CPWUnsafeIsDir -> "CPWUnsafeIsDir",
    CPWUnsafeIsFile -> "CPWUnsafeIsFile",
    CPWUnsafeRead -> "CPWUnsafeRead",
    CPWUnsafeWrite -> "CPWUnsafeWrite",
    CPWUnsafeAppend -> "CPWUnsafeAppend",
    CPWUnsafeDelete -> "CPWUnsafeDelete",
    CPWUnsafeCoerce -> "CPWUnsafeCoerce",
    CPWUnsafeHash -> "CPWUnsafeHash",
    CPWUnsafeEnvGet -> "CPWUnsafeEnvGet",
    CPWUnsafeEnvSet -> "CPWUnsafeEnvSet",
    CPWUnsafeExit -> "CPWUnsafeExit"
  )

cprim= : CPrim CPrim -- Bool
cprim= = dip(cprim->str) cprim->str streq

cprimBuiltinTypes : Map(Str, CPrim)
cprimBuiltinTypes = $(
  mapNil
  "Int" CPTInt mapSet
  "Str" CPTStr mapSet
  "Bool" CPTBool mapSet
  "List" CPTList mapSet
  "Pack" CPTPack mapSet
)

cprimBuiltinWords : Map(Str, CPrim)
cprimBuiltinWords = $(
  mapNil
  "_prim_id" CPWId mapSet
  "_prim_cp" CPWCp mapSet
  "_prim_dup" CPWDup mapSet
  "_prim_drop" CPWDrop mapSet
  "_prim_swap" CPWSwap mapSet
  "_prim_dip" CPWDip mapSet
  "_prim_bool_true" CPWBoolTrue mapSet
  "_prim_bool_false" CPWBoolFalse mapSet
  "_prim_bool_if" CPWBoolIf mapSet
  "_prim_int_add" CPWIntAdd mapSet
  "_prim_int_sub" CPWIntSub mapSet
  "_prim_int_mul" CPWIntMul mapSet
  "_prim_int_div" CPWIntDiv mapSet
  "_prim_int_mod" CPWIntMod mapSet
  "_prim_int_lt" CPWIntLt mapSet
  "_prim_int_eq" CPWIntEq mapSet
  "_prim_str_cat" CPWStrCat mapSet
  "_prim_str_break" CPWStrBreak mapSet
  "_prim_str_len" CPWStrLen mapSet
  "_prim_str_to_codepoint" CPWStrToCodepoint mapSet
  "_prim_str_from_codepaint" CPWStrFromCodepoint mapSet
  "_prim_str_elem" CPWStrElem mapSet
  "_prim_str_rematch" CPWStrReMatch mapSet
  "_prim_tuple_intuple" CPWPackMap mapSet
  "_prim_tuple_pack2" CPWPackPack2 mapSet
  "_prim_tuple_unpack2" CPWPackUnpack2 mapSet
  "_prim_list_nil" CPWListNil mapSet
  "_prim_list_cons" CPWListCons mapSet
  "_prim_list_cat" CPWListCat mapSet
  "_prim_list_len" CPWListLen mapSet
  "_prim_list_at" CPWListAt mapSet
  "_prim_list_break" CPWListBreak mapSet
  "_prim_list_map" CPWListMap mapSet
  "_prim_list_for" CPWListFor mapSet
  "_prim_unsafe_panic" CPWUnsafePanic mapSet
  "_prim_unsafe_trace" CPWUnsafeTrace mapSet
  "_prim_unsafe_print" CPWUnsafePrint mapSet
  "_prim_unsafe_listdir" CPWUnsafeListDir mapSet
  "_prim_unsafe_walk" CPWUnsafeWalk mapSet
  "_prim_unsafe_isdir" CPWUnsafeIsDir mapSet
  "_prim_unsafe_isfile" CPWUnsafeIsFile mapSet
  "_prim_unsafe_read" CPWUnsafeRead mapSet
  "_prim_unsafe_write" CPWUnsafeWrite mapSet
  "_prim_unsafe_append" CPWUnsafeAppend mapSet
  "_prim_unsafe_deletefile" CPWUnsafeDelete mapSet
  "_prim_unsafe_coerce" CPWUnsafeCoerce mapSet
  "_prim_unsafe_hash" CPWUnsafeHash mapSet
  "_prim_unsafe_env_get" CPWUnsafeEnvGet mapSet
  "_prim_unsafe_env_set" CPWUnsafeEnvSet mapSet
  "_prim_unsafe_exit" CPWUnsafeExit mapSet
)

cprimSort : CPrim -- CSort
cprimSort = cprimArity caritySort

cprimArity : CPrim -- CArity
cprimArity = cprimSig csigArity

cprimKind : CPrim -- CKind
cprimKind = cprimSig csigKind

S0 : CStack
S1 : CStack
S2 : CStack
S3 : CStack
S4 : CStack

T0 : CType
T1 : CType
T2 : CType
T3 : CType
T4 : CType

BS0 : CBind
BS1 : CBind
BS2 : CBind
BS3 : CBind
BS4 : CBind

BT0 : CBind
BT1 : CBind
BT2 : CBind
BT3 : CBind
BT4 : CBind

S0 = "S0" CSVar'
S1 = "S1" CSVar'
S2 = "S2" CSVar'
S3 = "S3" CSVar'
S4 = "S4" CSVar'

T0 = "T0" CTVar'
T1 = "T1" CTVar'
T2 = "T2" CTVar'
T3 = "T3" CTVar'
T4 = "T4" CTVar'

BS0 = CKStack "S0" MkCVar CBImplicit
BS1 = CKStack "S1" MkCVar CBImplicit
BS2 = CKStack "S2" MkCVar CBImplicit
BS3 = CKStack "S3" MkCVar CBImplicit
BS4 = CKStack "S4" MkCVar CBImplicit

BT0 = CKType "T0" MkCVar CBImplicit
BT1 = CKType "T1" MkCVar CBImplicit
BT2 = CKType "T2" MkCVar CBImplicit
BT3 = CKType "T3" MkCVar CBImplicit
BT4 = CKType "T4" MkCVar CBImplicit

cprimSig : CPrim -- CSig
cprimSig =
  match(
    CPSNil -> [] [] CKStack,
    CPSCons -> [] [ CKStack ; CKType ] CKStack,

    CPTInt -> [] [] CKType,
    CPTStr -> [] [] CKType,
    CPTBool -> [] [] CKType,
    CPTList -> [] [ CKType ] CKType,
    CPTPack -> [] [ CKStack ] CKType,

    CPVInt -> drop [] [] CTInt CKValue,
    CPVStr -> drop [] [] CTStr CKValue,
    CPVBool -> drop [] [] CTBool CKValue,
    CPVListNil -> [ BT0 ] [] T0 CTList CKValue,
    CPVListCons ->
      [ BT0 ]
      [ T0 CTList CKValue
      ; T0 CKValue
      ] T0 CTList CKValue,
    CPVPackNil  -> [] [] CSNil CTPack CKValue,
    CPVPackCons ->
      [ BS0 ; BT0 ]
      [ S0 CTPack CKValue
      ; T0 CKValue
      ] S0 T0 CSCons CTPack CKValue,

    CPWId -> [] [] CKWord00,
    CPWCp ->
      [ BS0 ; BS1 ; BS2 ]
      [ S0 S1 CKWord
      ; S1 S2 CKWord
      ] S0 S2 CKWord,
    CPWDip ->
      [ BS0 ; BS1 ; BT2 ]
      [ S0 S1 CKWord
      ] S0 T2 CSCons S1 T2 CSCons CKWord,
    CPWDup ->  [ BT1 ] [] T1 T1 T1 CKWord12,
    CPWDrop -> [ BT1 ] [] T1 CKWord10,
    CPWSwap -> [ BT1 ; BT2 ] [] T1 T2 T2 T1 CKWord22,
    CPWPush -> [ BT1 ] [ T1 CKValue ] T1 CKWord01,

    CPWPackMap ->
      [ BS0 ; BS1 ]
      [ S0 S1 CKWord
      ] S0 CTPack S1 CTPack CKWord11,
    CPWPackPack2 ->
      [ BT1 ; BT2 ]
      [] T1 T2 T1 T2 CTPack2 CKWord21,
    CPWPackUnpack2 ->
      [ BT1 ; BT2 ]
      [] T1 T2 CTPack2 T1 T2 CKWord12,

    CPWBoolIf ->
      [ BS0 ; BS1 ]
      [ S0 S1 CKWord
      ; S0 S1 CKWord
      ] S0 CTBool CSCons S1 CKWord,
    CPWBoolTrue -> [] [] CTBool CKWord01,
    CPWBoolFalse -> [] [] CTBool CKWord01,

    CPWIntAdd -> [] [] CTInt CTInt CTInt CKWord21,
    CPWIntSub -> [] [] CTInt CTInt CTInt CKWord21,
    CPWIntMul -> [] [] CTInt CTInt CTInt CKWord21,
    CPWIntDiv -> [] [] CTInt CTInt CTInt CKWord21,
    CPWIntMod -> [] [] CTInt CTInt CTInt CKWord21,
    CPWIntLt -> [] [] CTInt CTInt CTBool CKWord21,
    CPWIntEq -> [] [] CTInt CTInt CTBool CKWord21,
    CPWStrCat -> [] [] CTStr CTStr CTStr CKWord21,
    CPWStrBreak -> [] [] CTInt CTStr CTStr CTStr CKWord22,
    CPWStrLen -> [] [] CTStr CTInt CKWord11,
    CPWStrFromCodepoint -> [] [] CTInt CTStr CKWord11,
    CPWStrToCodepoint -> [] [] CTStr CTInt CKWord11,
    CPWStrElem -> [] [] CTStr CTStr CTBool CKWord21,
    CPWStrReMatch -> [] [] CTStr CTStr CTInt CTBool CKWord22,
    CPWListNil -> [ BT1 ] [] T1 CTList CKWord01,
    CPWListCons -> [ BT1 ] [] T1 CTList T1 T1 CTList CKWord21,
    CPWListCat -> [ BT1 ] [] T1 CTList dup dup CKWord21,
    CPWListLen -> [ BT1 ] [] T1 CTList CTInt CKWord11,
    CPWListAt -> [ BT1 ] [] T1 CTList CTInt T1 CKWord21,
    CPWListBreak -> [ BT1 ] [] T1 CTList CTInt T1 CTList T1 CTList CKWord22,
    CPWListMap -> [ BT1 ; BT2 ] [ T1 T2 CKWord11 ] T1 CTList T2 CTList CKWord11,
    CPWListFor -> [ BS0 ; BT1 ] [ S0 T1 CSCons S0 CKWord ] S0 T1 CTList CSCons S0 CKWord,
    CPWUnsafePanic -> [ BS0 ; BS1 ] [] S0 CTStr CSCons S1 CKWord,
    CPWUnsafeTrace -> [] [] CTStr CKWord10,
    CPWUnsafePrint -> [] [] CTStr CKWord10,
    CPWUnsafeListDir -> [] [] CTStr CTStr CTList CKWord11,
    CPWUnsafeWalk ->
      [] [] CTStr CTStr CTStr CTList CTStr CTList CTPack3 CTList CKWord11,
    CPWUnsafeIsDir -> [] [] CTStr CTBool CKWord11,
    CPWUnsafeIsFile -> [] [] CTStr CTBool CKWord11,
    CPWUnsafeRead -> [] [] CTStr CTStr CKWord11,
    CPWUnsafeWrite -> [] [] CTStr CTStr CKWord20,
    CPWUnsafeAppend -> [] [] CTStr CTStr CKWord20,
    CPWUnsafeDelete -> [] [] CTStr CKWord10,
    CPWUnsafeCoerce -> [ BS0 ; BS1 ] [] S0 S1 CKWord,
    CPWUnsafeHash -> [ BT1 ] [] T1 CTInt CKWord11,
    CPWUnsafeEnvGet -> [ BT1 ] [] CTStr T1 CKWord11,
    CPWUnsafeEnvSet -> [ BT1 ] [] T1 CTStr CKWord20,
    CPWUnsafeExit -> [ BS0 ; BS1 ] [] S0 CTInt CSCons S1 CKWord
  ) dip(map(CBAnonymous) ++) MkCSig

#######################
# STRONGLY TYPED CORE #
#######################

data CStack
  MkCStack : CTerm -- CStack
end

ctermGetStack : CTerm -- Maybe(CStack)
ctermGetStack = dup ctermSort CSStack csort= if(MkCStack some, drop none)

cterm->cstack : CTerm -- CStack
cterm->cstack =
  dup ctermGetStack maybe(
    dip("cterm->cstack: not a stack type: ") cterm->str <> unsafe_panic,
    nip
  )

cstack->cterm : CStack -- CTerm
cstack->cterm = match(MkCStack -> id)

cstack->str : CStack -- Str
cstack->str = cstack->cterm cterm->str

CSVar : CVar -- CStack
CSVar = CHVar nil MkCTerm cterm->cstack

CSHole : CHole -- CStack
CSHole = CHHole nil MkCTerm cterm->cstack

CSVar' : Str -- CStack
CSVar' = dip(CKStack) MkCVar CHVar nil MkCTerm MkCStack

CSHole' : Int -- CStack
CSHole' = dip(CKStack) znat MkCHole CHHole nil MkCTerm MkCStack

CSNil : CStack
CSNil = CPSNil CHPrim nil MkCTerm MkCStack

CSCons : CStack CType -- CStack
CSCons = dip2(CPSCons CHPrim nil) dip(cstack->cterm cons) ctype->cterm cons MkCTerm MkCStack

data CType
  MkCType : CTerm -- CType
end

ctermGetType : CTerm -- Maybe(CType)
ctermGetType = dup ctermSort CSType csort= if(MkCType some, drop none)

cterm->ctype : CTerm -- CType
cterm->ctype =
  dup ctermGetType maybe(
    dip("cterm->ctype: not a value type: ") cterm->str <> unsafe_panic,
    nip
  )

ctype->cterm : CType -- CTerm
ctype->cterm = match(MkCType -> id)

ctype->str : CType -- Str
ctype->str = ctype->cterm cterm->str

CTVar : CVar -- CType
CTVar = CHVar nil MkCTerm cterm->ctype

CTHole : CHole -- CType
CTHole = CHHole nil MkCTerm cterm->ctype

CTSym : CSym List(CTerm) -- CType
CTSym = dip(CHSym) MkCTerm cterm->ctype

CTPrim : CPrim List(CTerm) -- CType
CTPrim = dip(CHPrim) MkCTerm cterm->ctype

CTVar' : Str -- CType
CTVar' = dip(CKType) MkCVar CHVar nil MkCTerm MkCType

CTHole' : Int -- CType
CTHole' = dip(CKType) znat MkCHole CHHole nil MkCTerm MkCType

CTInt : CType
CTInt = CPTInt CHPrim nil MkCTerm MkCType

CTStr : CType
CTStr = CPTStr CHPrim nil MkCTerm MkCType

CTBool : CType
CTBool = CPTBool CHPrim nil MkCTerm MkCType

CTList : CType -- CType
CTList = dip(CPTList CHPrim nil) ctype->cterm cons MkCTerm MkCType

CTPack : CStack -- CType
CTPack = dip(CPTPack CHPrim nil) cstack->cterm cons MkCTerm MkCType

CTPack2 : CType CType -- CType
CTPack2 = dip2(CSNil) dip(CSCons) CSCons CTPack

CTPack3 : CType CType CType -- CType
CTPack3 = dip3(CSNil) dip2(CSCons) dip(CSCons) CSCons CTPack

data CValue
  MkCValue : CTerm -- CValue
end

ctermGetValue : CTerm -- Maybe(CValue)
ctermGetValue = dup ctermSort CSValue csort= if(MkCValue some, drop none)

cterm->cvalue : CTerm -- CValue
cterm->cvalue =
  dup ctermGetValue maybe(
    dip("cterm->cvalue: not a value type: ") cterm->str <> unsafe_panic,
    nip
  )

cvalue->cterm : CValue -- CTerm
cvalue->cterm = match(MkCValue -> id)

cvalue->str : CValue -- Str
cvalue->str = cvalue->cterm cterm->str

CVVar : CVar -- CValue
CVVar = CHVar nil MkCTerm cterm->cvalue

CVHole : CHole -- CValue
CVHole = CHHole nil MkCTerm cterm->cvalue

CVSym : CSym List(CTerm) -- CValue
CVSym = dip(CHSym) MkCTerm cterm->cvalue

CVInt : Int -- CValue
CVInt = CPVInt CHPrim nil MkCTerm MkCValue

CVStr : Str -- CValue
CVStr = CPVStr CHPrim nil MkCTerm MkCValue

CVBool : Bool -- CValue
CVBool = CPVBool CHPrim nil MkCTerm MkCValue

CVListNil : CValue
CVListNil = CPVListNil CHPrim nil MkCTerm MkCValue

CVListCons : CValue CValue -- CValue
CVListCons = dip2(CPVListCons CHPrim nil) dip(cvalue->cterm cons) cvalue->cterm cons MkCTerm MkCValue

CVPackNil : CValue
CVPackNil = CPVPackNil CHPrim nil MkCTerm MkCValue

CVPackCons : CValue CValue -- CValue
CVPackCons = dip2(CPVPackCons CHPrim nil) dip(cvalue->cterm cons) cvalue->cterm cons MkCTerm MkCValue

data CWord
  MkCWord : CTerm -- CWord
end

ctermGetWord : CTerm -- Maybe(CWord)
ctermGetWord = dup ctermSort CSWord csort= if(MkCWord some, drop none)

cterm->cword : CTerm -- CWord
cterm->cword =
  dup ctermGetWord maybe(
    dip("cterm->cword: not a value type: ") cterm->str <> unsafe_panic,
    nip
  )

cword->cterm : CWord -- CTerm
cword->cterm = match(MkCWord -> id)

cword->str : CWord -- Str
cword->str = cword->cterm cterm->str

CWVar : CVar -- CWord
CWVar = CHVar nil MkCTerm cterm->cword

CWHole : CHole -- CWord
CWHole = CHHole nil MkCTerm cterm->cword

CWSym : CSym List(CTerm) -- CWord
CWSym = dip(CHSym) MkCTerm cterm->cword

CWPrim : CPrim List(CTerm) -- CWord
CWPrim = dip(CHPrim) MkCTerm cterm->cword

CWId : CWord
CWId = CPWId CHPrim nil MkCTerm MkCWord

CWCp : CWord CWord -- CWord
CWCp = dip2(CPWCp CHPrim nil) dip(cword->cterm cons) cword->cterm cons MkCTerm MkCWord

data CKind
  CKStack : CKind
  CKType : CKind
  CKValue : CType -- CKind
  CKWord : CStack CStack -- CKind
end

CKWord00 : CKind
CKWord01 : CType -- CKind
CKWord10 : CType -- CKind
CKWord11 : CType CType -- CKind
CKWord12 : CType CType CType -- CKind
CKWord20 : CType CType -- CKind
CKWord21 : CType CType CType -- CKind
CKWord22 : CType CType CType CType -- CKind

CKWord00 = CSNil CSNil CKWord
CKWord01 = dip(CSNil CSNil) CSCons CKWord
CKWord10 = dip(CSNil) CSCons CSNil CKWord
CKWord11 = dip2(CSNil) dip(CSCons CSNil) CSCons CKWord
CKWord12 = dip3(CSNil) dip2(CSCons CSNil) dip(CSCons) CSCons CKWord
CKWord20 = dip2(CSNil) dip(CSCons) CSCons CSNil CKWord
CKWord21 = dip3(CSNil) dip2(CSCons) dip(CSCons CSNil) CSCons CKWord
CKWord22 = dip4(CSNil) dip3(CSCons) dip2(CSCons CSNil) dip(CSCons) CSCons CKWord

ckindSort : CKind -- CSort
ckindSort =
  match(
    CKStack -> CSStack,
    CKType -> CSType,
    CKValue -> drop CSValue,
    CKWord -> drop2 CSWord
  )

ckindVars : CKind -- Set(CVar)
ckindVars =
  match(
    CKStack -> setNil,
    CKType -> setNil,
    CKValue -> ctype->cterm ctermVars,
    CKWord -> both(cstack->cterm ctermVars) setUnion
  )

ckindHoles : CKind -- Set(CHole)
ckindHoles =
  match(
    CKStack -> setNil,
    CKType -> setNil,
    CKValue -> ctype->cterm ctermHoles,
    CKWord -> both(cstack->cterm ctermHoles) setUnion
  )

data CBind
  CBImplicit : CVar -- CBind
  CBExplicit : CVar -- CBind
  CBAnonymous : CKind -- CBind
end

cbindVar : CBind -- Maybe(CVar)
cbindVar =
  match(
    CBImplicit -> some,
    CBExplicit -> some,
    CBAnonymous -> drop none
  )

cbindKind : CBind -- CKind
cbindKind =
  match(
    CBImplicit -> cvarKind,
    CBExplicit -> cvarKind,
    CBAnonymous -> id
  )

cbindSort : CBind -- CSort
cbindSort = cbindKind ckindSort

cbindIsImplicit : CBind -- Bool
cbindIsImplicit =
  match(
    CBImplicit -> drop true,
    _ -> drop false
  )

cbindIsExplicit : CBind -- Bool
cbindIsExplicit =
  match(
    CBExplicit -> drop true,
    _ -> drop false
  )

cbindIsAnonymous : CBind -- Bool
cbindIsAnonymous =
  match(
    CBAnonymous -> drop true,
    _ -> drop false
  )

data CSig
  MkCSig : List(CBind) CKind -- CSig
end

MkCSig' : List(CKind) CKind -- CSig
MkCSig' = dip(map(CBAnonymous)) MkCSig

unCSig : CSig -- List(CBind) CKind
unCSig = match(MkCSig -> id)

csigNil : CKind -- CSig
csigNil = dip(nil) MkCSig

csigKind : CSig -- CKind
csigKind = unCSig nip

csigArgs : CSig -- List(CBind)
csigArgs = unCSig drop

csigSort : CSig -- CSort
csigSort = csigKind ckindSort

csigArity : CSig -- CArity
csigArity = unCSig dip(map(cbindSort)) ckindSort MkCArity

data CCons
  MkCCons : CSym List(CBind) List(CType) CType -- CCons
end

unCCons : CCons -- CSym List(CBind) List(CType) CType
unCCons = match(MkCCons -> id)

cconsSym : CCons -- CSym
cconsSym = unCCons drop3

cconsArgs : CCons -- List(CBind)
cconsArgs = unCCons drop2 nip

cconsInputs : CCons -- List(CType)
cconsInputs = unCCons drop dip(drop2)

cconsOutput : CCons -- CType
cconsOutput = unCCons dip(drop3)

ccons->str : CCons -- Str
ccons->str = cconsSym csym->str # TODO: improve

data CData
  MkCData : List(CCons) -- CData
end

unCData : CData -- List(CCons)
unCData = match(MkCData -> id)

data CCase
  MkCCase : CCons List(CBind) CWord -- CCase
end

unCCase : CCase -- CCons List(CBind) CWord
unCCase = match(MkCCase -> id)

ccaseCons : CCase -- CCons
ccaseCons = unCCase drop2

ccaseArgs : CCase -- List(CBind)
ccaseArgs = unCCase drop nip

ccaseBody : CCase -- CWord
ccaseBody = unCCase dip(drop2)

ccase->str : CCase -- Str
ccase->str = ccaseCons ccons->str " -> _" <>  # TODO: improve

data CMatch
  MkCMatch : List(CCase) Maybe(CTerm) -- CMatch
end

unCMatch : CMatch -- List(CCase) Maybe(CTerm)
unCMatch = match(MkCMatch -> id)

cmatchCases : CMatch -- List(CCase)
cmatchCases = unCMatch drop

cmatchDefault : CMatch -- Maybe(CTerm)
cmatchDefault = unCMatch nip

data CBody
  CBTerm : CTerm -- CBody
  CBData : CData -- CBody
  CBCons : CCons -- CBody
  CBMatch : CMatch -- CBody
end

cbodyMatch(
  onTerm: *a CTerm -- *b,
  onData: *a CData -- *b,
  onCons: *a CCons -- *b,
  onMatch: *a CMatch -- *b
) : *a CBody -- *b

cbodyMatch(onTerm, onData, onCons, onMatch) =
  match(
    CBTerm -> onTerm,
    CBData -> onData,
    CBCons -> onCons,
    CBMatch -> onMatch
  )

data CDef
  MkCDef : CSym Maybe(CBody) -- CDef
end

unCDef : CDef -- CSym Maybe(CBody)
unCDef = match(MkCDef -> id)

cdefSym : CDef -- CSym
cdefSym = unCDef drop

cdefSig : CDef -- CSig
cdefSig = cdefSym csymSig

cdefBody : CDef -- Maybe(CBody)
cdefBody = unCDef nip

cdefArity : CDef -- CArity
cdefArity = cdefSig csigArity

cdefKind : CDef -- CKind
cdefKind = cdefSig csigKind

cdefSort : CDef -- CSort
cdefSort = cdefSig csigSort

cdef->str : CDef -- Str
cdef->str = cdefSym csym->str " = _" <> # TODO : improve

data CSymKey
  MkCSymKey : CArity Str -- CSymKey
end

csym->csymkey : CSym -- CSymKey
csym->csymkey = unCSym dip(csigArity) MkCSymKey

data CVarKey
  MkCVarKey : CSort Str -- CVarKey
end

cvar->cvarkey : CVar -- CVarKey
cvar->cvarkey = unCVar dip(ckindSort) MkCVarKey

data CHoleKey
  MkCHoleKey : CSort Nat -- CHoleKey
end

chole->cholekey : CHole -- CHoleKey
chole->cholekey = unCHole dip(ckindSort) MkCHoleKey

data CEnv
  MkCEnv : Map(CSymKey, CDef) -- CEnv
end

unCEnv : CEnv -- Map(CSymKey, CDef)
unCEnv = match(MkCEnv -> id)

cenvDefs : CEnv -- Map(CSymKey, CDef)
cenvDefs = unCEnv

cenvNil : CEnv
cenvNil = mapNil MkCEnv

cenvGet : CEnv CSym -- Maybe(CDef)
cenvGet = dip(unCEnv) csym->csymkey mapGet

cenvSet : CEnv CDef -- CEnv
cenvSet = dip(unCEnv) dup dip(cdefSym csym->csymkey) mapSet MkCEnv

cenvAdd : CEnv CDef -- Result(Str, CEnv)
cenvAdd = cenvSet ok # TODO: improve

cenv->str : CEnv -- Str
cenv->str = dip("") unCEnv mapFor(nip cdef->str "\n" <> <>)

data CBinds
  MkCBinds : Map(CVarKey, CBind) -- CBinds
end

unCBinds : CBinds -- Map(CVarKey, CBind)
unCBinds = match(MkCBinds -> id)

cbindsNil : CBinds
cbindsNil = mapNil MkCBinds

cbindsGet : CBinds CVar -- Maybe(CBind)
cbindsGet = dip(unCBinds) cvar->cvarkey mapGet

cbindsGetKind : CBinds CVar -- Maybe(CKind)
cbindsGetKind = cbindsGet mmap(cbindKind)

cbindsGet? : CBinds CVar -- CBinds CVar Maybe(CBind)
cbindsGet? = dup2 cbindsGet

cbindsGetKind? : CBinds CVar -- CBinds CVar Maybe(CKind)
cbindsGetKind? = dup2 cbindsGetKind

cbindsSet : CBinds CBind -- CBinds
cbindsSet = dup cbindVar maybe(drop, cvar->cvarkey dip2(unCBinds) swap mapSet MkCBinds)

cbindsAdd : CBinds CBind -- Result(Str, CBinds)
cbindsAdd = cbindsSet ok # TODO: improve (to prevent shadowing)

cbindsAddMany : CBinds List(CBind) -- Result(Str, CBinds)
cbindsAddMany = dip(ok) for(rpure rbind2(cbindsAdd))

data CFresh
  MkCFresh : Map(CHoleKey, CTerm) Nat -- CFresh
end

unCFresh : CFresh -- Map(CHoleKey, CTerm) Nat
unCFresh = match(MkCFresh -> id)

cfreshNil : CFresh
cfreshNil = mapNil n0 MkCFresh

cfreshNext : CFresh -- CFresh Nat
cfreshNext = unCFresh n1+ pnat dup dip(MkCFresh)

cfreshReserve : CFresh Nat -- CFresh
cfreshReserve = dip(unCFresh) nmax MkCFresh

cfreshGet : CFresh CHole -- Maybe(CTerm)
cfreshGet = dip(unCFresh drop) chole->cholekey mapGet

cfreshGet? : CFresh CHole -- CFresh CHole Maybe(CTerm)
cfreshGet? = dup2 cfreshGet

cfreshSet : CFresh CHole CTerm -- CFresh
cfreshSet = dip2(unCFresh swap) dip(chole->cholekey) mapSet swap MkCFresh

data CCtx
  MkCCtx : CEnv CBinds CFresh -- CCtx
end

unCCtx : CCtx -- CEnv CBinds CFresh
unCCtx = match(MkCCtx -> id)

cctxEnv : CCtx -- CEnv
cctxEnv = unCCtx drop2

cctxBinds : CCtx -- CBinds
cctxBinds = unCCtx drop nip

cctxFresh : CCtx -- CFresh
cctxFresh = unCCtx dip(drop2)

cctxNil : CEnv -- CCtx
cctxNil = cbindsNil cfreshNil MkCCtx

cctxAdd : CCtx CBind -- Result(Str, CCtx)
cctxAdd = dip(unCCtx swap dip(rpure2)) cbindsAdd rmap3(swap MkCCtx)

cctxAddMany : CCtx List(CBind) -- Result(Str, CCtx)
cctxAddMany = dip(ok) for(rpure rbind2(cctxAdd))

cctxGet : CCtx CVar -- Maybe(CBind)
cctxGet = dip(cctxBinds) cbindsGet

cctxGetKind : CCtx CVar -- Maybe(CKind)
cctxGetKind = dip(cctxBinds) cbindsGetKind

cctxGet? : CCtx CVar -- CCtx CVar Maybe(CBind)
cctxGet? = dup2 cctxGet

cctxGetKind? : CCtx CVar -- CCtx CVar Maybe(CKind)
cctxGetKind? = dup2 cctxGetKind

cctxFreshNat : CCtx -- CCtx Nat
cctxFreshNat = unCCtx cfreshNext dip(MkCCtx)

cctxReserve : CCtx Nat -- CCtx
cctxReserve = dip(unCCtx) cfreshReserve MkCCtx

cctxGetHole : CCtx CHole -- Maybe(CTerm)
cctxGetHole = dip(cctxFresh) cfreshGet

cctxGetHole? : CCtx CHole -- CCtx CHole Maybe(CTerm)
cctxGetHole? = dup2 cctxGetHole

cctxSetHole : CCtx CHole CTerm -- CCtx
cctxSetHole = dip2(unCCtx) cfreshSet MkCCtx

##################
# HOLE EXPANSION #
##################

cheadExpandHoles : CCtx CHead -- CCtx CHead
ctermExpandHoles : CCtx CTerm -- CCtx CTerm
ckindExpandHoles : CCtx CKind -- CCtx CKind

||| Expand the holes in a head's kind, if it's not a closed head.
||| Note we don't expand a head that is a hole here, we only expand
||| holes in the head's kind. For the former, see `ctermExpandHeadHoles`.
cheadExpandHoles : CCtx CHead -- CCtx CHead
cheadExpandHoles =
  match(
    CHHole -> unCHole dip(ckindExpandHoles) MkCHole CHHole,
    CHVar -> unCVar dip(ckindExpandHoles) MkCVar CHVar,
    _ -> id # the rest are closed heads
  )

||| Expand out a term's head if it's a defined hole.
||| Guaranteed to preserve term's sort, and its type
||| if the ctx and term are in agreement on hole kinds.
ctermExpandHeadHoles : CCtx CTerm -- CCtx CTerm
ctermExpandHeadHoles =
  unCTerm dip(cheadExpandHoles) swap match(
    CHHole ->
      swap dip(cctxGetHole?) swap maybe(
        dip(CHHole) MkCTerm,
        dip(drop2) ctermExpandHeadHoles
      ),
    _ -> swap MkCTerm
  )

||| Expand a term's defined holes fully.
||| Guaranteed to preserve term's sort, and its type
||| if the ctx and term are in agreement on hole kinds.
ctermExpandHoles : CCtx CTerm -- CCtx CTerm
ctermExpandHoles = ctermExpandHeadHoles unCTerm dip'(formap(ctermExpandHoles)) MkCTerm

||| Expand a kind's holes.
ckindExpandHoles : CCtx CKind -- CCtx CKind
ckindExpandHoles =
  match(
    CKStack -> CKStack,
    CKType -> CKType,
    CKValue -> ctype->cterm ctermExpandHoles cterm->ctype CKValue,
    CKWord -> both(cstack->cterm) dip(ctermExpandHoles) dip'(ctermExpandHoles) both(cterm->cstack) CKWord
  )

###############
# UNIFICATION #
###############

ctermUnify : CCtx CTerm CTerm -- CCtx Result(Str, CTerm)
ctermUnifyList : CCtx List(CTerm) List(CTerm) -- CCtx Result(Str, List(CTerm))
ctermUnifyNonHoles : CCtx CTerm CTerm -- CCtx Result(Str, CTerm)
ctermUnifyUndefinedHole : CCtx CTerm CHole -- CCtx Result(Str, CTerm)

||| Unify a term with an undefined hole. (Do not call this
||| with a defined hole on the RHS.)
ctermUnifyUndefinedHole : CCtx CTerm CHole -- CCtx Result(Str, CTerm)
ctermUnifyUndefinedHole =
  dup2 CHHole nil MkCTerm cterm= if(
    # case where the term is the hole
    drop ok,

    dip(ctermExpandHoles dup ctermHoles) setHas? if(
      # case where the term contains the hole, so unification must fail
      nip dip2("Cannot unify ") dip(cterm->str <> " with " <>) chole->str <> err,

      # case where unification happens
      nip swap dup dip(cctxSetHole) ok
    )
  )

ctermUnifyList : CCtx List(CTerm) List(CTerm) -- CCtx Result(Str, List(CTerm))
ctermUnifyList =
  dup2 list=(drop2 true) if(
    dip2(nil ok) zip for(swap result(nip err, dip(unpack2 ctermUnify) ok swap rmap2(cons))),
    drop2 "Arity mismatch between unification terms." err
  )

||| Unify two non-hole terms. (Do not call this with holes.)
ctermUnifyNonHoles : CCtx CTerm CTerm -- CCtx Result(Str, CTerm)
ctermUnifyNonHoles =
  # TODO: Expand neutral terms before comparing heads.
  dup2 both(ctermHead) chead= if(
    dip(ctermArgs) unCTerm swap dip(ctermUnifyList) ok rmap2(swap MkCTerm),
    dip2("Cannot unify ") dip(cterm->str <> " with " <>) cterm->str <> err
  )

||| Unify two terms.
ctermUnify : CCtx CTerm CTerm -- CCtx Result(Str, CTerm)
ctermUnify = $(
  dip(ctermExpandHeadHoles) dip'(ctermExpandHeadHoles)
  dup ctermGetHole maybe(
    over ctermGetHole maybe(
      ctermUnifyNonHoles,
      dip2(drop) ctermUnifyUndefinedHole
    ),
    nip ctermUnifyUndefinedHole
  )
)

