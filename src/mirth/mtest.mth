# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import base/io
import base/path
import base/unsafe
import base/nat
import base/str
import base/list
import base/result
import mirth/loc
import mirth/mod
import mirth/token
import mirth/lexer
import mirth/syntax
import mirth/parser
import mirth/elab

||| Integration & Golden Tests for the Mirth compiler.
export mirth/mtest
  runTests : Bool -- Int +IO
end

||| Initialize the test environment.
initTestEnv : Bool -- +IO
initTestEnv = $(
  unsafe_env_set("UPDATE_TESTS")
  n0 unsafe_env_set("NUM_FAILED")
)

||| Should golden tests be updated?
shouldUpdate? : -- Bool +IO
shouldUpdate? = unsafe_env_get("UPDATE_TESTS")

||| Get number of failed tests.
getNumFailed : Nat +IO
getNumFailed = unsafe_env_get("NUM_FAILED")

||| Increment number of failed tests.
incNumFailed : +IO
incNumFailed = getNumFailed n1+ pnat unsafe_env_set("NUM_FAILED")

||| A test has failed.
testFailed : Str -- +IO
testFailed = dip("FAILED: ") <> trace incNumFailed

||| Directory of test files relative to compiler project root.
testDir : Path
testDir = "test" str->path

||| Is this a mirth file, based on the extension?
isMirthFile? : Path -- Path Bool
isMirthFile? = pathHasExtension?("mth")

||| Drop the ".mth" extension.
dropMirthExtension : Path -- Path
dropMirthExtension = path->str 4 znat strdropR str->path

||| Get EXPECTED path for given extension.
expectedPath(x: Str) : Mod -- Path
expectedPath(x) = mod->path dropMirthExtension "EXPECTED" <.> x <.>

||| Get ACTUAL path for given extension.
actualPath(x: Str) : Mod -- Path
actualPath(x) = mod->path dropMirthExtension "ACTUAL" <.> x <.>

||| Add newline at the end if it's missing. Generally
||| it's more convenient to deal with files that have
||| newlines.
addMissingNewline : Str -- Str
addMissingNewline = dip("\n") strsuffix? if(nip, swap <>)

||| Expect a file to exists and have the correct contents.
||| Overwrite the test if the env flag "UPDATE_TESTS" is set.
||| Increments "NUM_FAILED" env flag if test fails.
expect(x: Str) : Mod Str -- Mod +IO
expect(x) = $(
  addMissingNewline # Add newline for convenience
  over actualPath(x) deletefile # Delete any leftover ACTUAL files.
  over expectedPath(x)
  cond(
    isdir? -> # EXPECTED file is a directory?!
      path->str dip("Unexpected directory found at ") <> testFailed
      drop,

    shouldUpdate? -> # Update EXPECTED file instead of testing.
      write,

    isfile? not -> # EXPECTED file is missing.
      path->str dip("Missing file ") <> testFailed
      over actualPath(x) write,

    dup2 read streq not -> # EXPECTED does not match actual output.
      path->str dip("File ") <> " does not match test output" <> testFailed
      over actualPath(x) write,

    # Test Passed!
    drop2
  )
)

||| Expect a certain file to be missing.
||| Deletes the file if the env flag "UPDATE_TESTS" is set.
expectNo(x: Str) : Mod -- Mod +IO
expectNo(x) = $(
  dup expectedPath(x)
  cond(
    isdir? -> # File is a directory?!
      path->str dip("Unexpected directory found at ") <> testFailed,

    isfile? -> # File exists.
      shouldUpdate? if(
        deletefile,
        dip("File ") path->str <> " should not exist." <> testFailed
      ),

    # Test passed.
    drop
  )
)

||| Check that a lexer error was expected.
expectLexerError : Mod LexerError -- +IO
expectLexerError = $(
  dip(expectNo("tokens"))
  lexerError->str expect("lexer-error") drop
)

||| Check that a lexer success was expected.
expectLexerSuccess : Mod List(L(Token)) -- +IO
expectLexerSuccess = $(
  dip(expectNo("lexer-error"))
  map(unL dip(locSet->str) token->str <>) unlines expect("tokens") drop
)

||| Check that a parser error was expected.
expectSyntaxError : Mod SyntaxError -- +IO
expectSyntaxError = $(
  dip(expectNo("syntax"))
  syntaxError->str expect("syntax-error") drop
)

||| Check that a parser success was expected.
expectParserSuccess : Mod L(Module) -- +IO
expectParserSuccess = $(
  dip(expectNo("syntax-error"))
  getL module->str expect("syntax") drop
)

||| Check that an elaborator error was expected.
expectElabError : Mod List(EError) List(EWarning) -- +IO
expectElabError = $(
  dip2(expectNo("elab"))
  dip(map(eerror->str) unlines expect("elab-error"))
  nil? if(
    drop expectNo("elab-warning"),
    map(ewarning->str) unlines expect("elab-warning")
  ) drop
)

||| Check that an elaborator success was expected.
expectElabSuccess : Mod EModule List(EWarning) -- +IO
expectElabSuccess = $(
  dip2(expectNo("elab-error"))
  dip(emodule->str expect("elab"))
  nil? if(
    drop expectNo("elab-warning"),
    map(ewarning->str) unlines expect("elab-warning")
  ) drop
)


||| Run golden test on single Mirth file.
runGoldenTestFile : Path -- +IO
runGoldenTestFile = $(
  pathMod
  dup mod->path read
  dip(dup) tokenize result(
    expectLexerError,
    dup2 expectLexerSuccess
    parseModule runParser result(
      expectSyntaxError,
      dup2 expectParserSuccess
      dip(dup) runElabModule eresult(
        expectElabError,
        expectElabSuccess
      )
    )
  )
)

||| Run the golden tests.
runGoldenTests : -- +IO
runGoldenTests =
  testDir listfiles filter(isMirthFile?) for(runGoldenTestFile)

||| Run all the compiler tests.
runTests : Bool -- Int +IO
runTests = initTestEnv runGoldenTests getNumFailed nint

