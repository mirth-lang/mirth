module(mirth.elab)

import(std.prelude)
import(std.str)
import(std.lazy)
import(std.list)
import(std.maybe)
import(std.either)
import(std.path)
import(std.byte)

import(posix.posix)
import(posix.file)

import(mirth.name)
import(mirth.def)
import(mirth.token)
import(mirth.data)
import(mirth.ctx)
import(mirth.external)
import(mirth.word)
import(mirth.var)
import(mirth.buffer)
import(mirth.variable)
import(mirth.table)
import(mirth.tycon)
import(mirth.type)
import(mirth.typedef)
import(mirth.var)
import(mirth.arrow)
import(mirth.word)
import(mirth.prim)
import(mirth.module)
import(mirth.package)
import(mirth.alias)
import(mirth.match)
import(mirth.lexer)
import(mirth.label)

####################
# Type Elaboration #
####################

data(TypeElab, TYPE_ELAB -> Bool Ctx)
def(type-elab-default, TypeElab, F CTX0 TYPE_ELAB)
def(type-elab-stack-assertion, Ctx -- TypeElab, dip(T) TYPE_ELAB)
def(type-elab-holes-allowed, TypeElab -- Bool, TYPE_ELAB -> drop)
def(type-elab-ctx, TypeElab -- Ctx, TYPE_ELAB -> nip)
def(type-elab-ctx?, TypeElab -- TypeElab Ctx, dup type-elab-ctx)
def(type-elab-ctx-replace, TypeElab Ctx -- TypeElab,
    swap match(TYPE_ELAB -> drop swap TYPE_ELAB))

def(elab-type-sig!, TypeElab Token -- TypeElab ArrowType Token,
    dup run-end? then(dup "expected type signature" emit-error!)
    elab-type-sig-params! dip(swap)
    elab-type-stack! dip(swap)
    dup sig-dashes? if(
        next elab-type-stack! dip(swap),
        dip(T0 rotr))
    dup run-end? else(dup "expected right paren or comma" emit-error!)
    dip(rot4r dip(swap for(T*)) T->))

def(elab-type-sig-params!, TypeElab Token -- TypeElab List(Type) Token,
    dup lparen? .if(
        dup next dip(
            L0 rotr args
            for(elab-type-sig! drop >Type swap dip(snoc))
            swap
        ),
        L0 swap
    ))

def(elab-type-stack!, TypeElab Token -- TypeElab StackType Token,
    dup sig-stack-var? if(
        elab-stack-var! dip(STVar),
        dip(T0)
    )
    elab-type-stack-rest!)

def(elab-type-stack-rest!, TypeElab StackType Token -- TypeElab StackType Token,
    while(dup sig-stack-end? not,
        swap dip(elab-type-atom!) swap
        dip(swap cons)
    ))

def(elab-type-arg!, TypeElab Token -- TypeElab Type Token,
    elab-type-atom!
    swap match(
        STPCons -> swap,
        STPConsLabel -> drop2 "Expected type, not label." emit-fatal-error!,
        STPWith -> drop "Expected type, not resource." emit-fatal-error!,
    )
    dup arg-end? else(
        "Unexpected token after type." emit-fatal-error!
    ))

data(StackTypePart,
    STPCons -> Type,
    STPConsLabel -> Type Label,
    STPWith -> Resource)

def(StackTypePart.cons, StackType StackTypePart -- StackType,
    STPCons -> STCons,
    STPConsLabel -> STConsLabel,
    STPWith -> STWith)

def(elab-type-atom!, TypeElab Token -- TypeElab StackTypePart Token,
    dup could-be-sig-label? if(
        elab-stack-label! dip(STPConsLabel),

    dup sig-type-var? if(
        elab-type-var! dip(TVar STPCons),

    dup sig-type-con? if(
        elab-type-con! dip(STPCons),

    dup sig-resource-var? if(
        elab-resource-var! dip(TVar RESOURCE STPWith),

    dup sig-resource-con? if(
        elab-resource-con! dip(STPWith),

    dup pat-underscore? if(
        elab-type-dont-care! dip(STPCons),

    dup sig-type-hole? if(
        elab-type-hole! dip(STPCons),

    dup lsquare? .if(
        elab-type-quote! dip(STPCons),

        dup "Expected type, got unknown token." emit-error!
        dip(TYPE_ERROR STPCons) next
    )))))))))

def(elab-stack-label!, TypeElab Token -- TypeElab Type Label Token,
    sip(args-1 elab-type-atom! drop) swap
    match(STPCons -> id, _ -> drop dup args-1 "Expected type" emit-error! TYPE_ERROR)
    swap sip(name? unwrap Label.new!) next)

def(elab-stack-var!, TypeElab Token -- TypeElab Var Token,
    TYPE_STACK elab-implicit-var!)

def(elab-type-var!, TypeElab Token -- TypeElab Var Token,
    TYPE_TYPE elab-implicit-var!)

def(elab-resource-var!, TypeElab Token -- TypeElab Var Token,
    TYPE_RESOURCE elab-implicit-var!)

def(elab-implicit-var!, TypeElab Token Type -- TypeElab Var Token,
    dip2(type-elab-ctx?) over
    dip2(name? unwrap dup2 swap lookup)
    rotl match(
        SOME ->
            rotr dip2(nip dup type)
            elab-type-unify! nip,
        NONE ->
            dip(
                swap Var.new!
                sip(Ctx.new)
            )
    )
    next
    dip2(type-elab-ctx-replace))

def(elab-type-con!, TypeElab Token -- TypeElab Type Token,
    dup name? unwrap >Str "Mut" == if(
        tuck args-1 elab-type-arg! drop TMut
        rotl next,

        dup name? unwrap defs find(dup defines-a-type?) match(
            SOME -> match(
                DEF_DATA -> TData,
                DEF_TABLE -> TTable,
                DEF_TYPEDEF -> target,
                _ -> drop dup "Not a type." emit-error! TYPE_ERROR
            ),
            NONE -> dup "Unknown type." emit-error! TYPE_ERROR
        )

        dup error? else(
            over num-args
            over arity == if(
                elab-type-args!,
                drop dup "Wrong number of argumets for type." emit-error! TYPE_ERROR
            )
        )
        swap next
    ))

def(elab-resource-con!, TypeElab Token -- TypeElab Resource Token,
    elab-type-con! dip(RESOURCE))

def(elab-type-args!, TypeElab Token Type -- TypeElab Token Type,
    over has-args? if(
        dip(tuck) swap succ
        while(dup args-end? not,
            succ swap
            dip(elab-type-arg!) swap
            dip(swap TApp))
        drop dip(swap),

        id
    ))

def(elab-type-hole!, TypeElab Token -- TypeElab Type Token,
    over type-elab-holes-allowed if(
        dup args-0
        dup name? unwrap THole
        swap next,
        "type holes are not allowed here" emit-fatal-error!
    ))

def(elab-type-dont-care!, TypeElab Token -- TypeElab Type Token,
    over type-elab-holes-allowed if(
        dup args-0
        TYPE_DONT_CARE
        swap next,
        "underscore is not allowed here" emit-fatal-error!
    ))

def(elab-type-quote!, TypeElab Token -- TypeElab Type Token,
    args-1 dup sig-has-dashes? if(
        elab-type-sig! dip(>Type),
        elab-type-stack! dip(>Type)
    ) next)

def(elab-type-unify!, Type Type Token -- Type Token,
    sip(GAMMA rotr unify! nip))
def(elab-stack-type-unify!, StackType StackType Token -- StackType Token,
    sip(GAMMA rotr unify! nip))

def(elab-simple-type-arg!, Token -- Type,
    dip(type-elab-default) elab-type-arg! drop nip)

####################
# Word Elaboration #
####################

data(+AB, MKAB -> arrow:Arrow)
def(ab-arrow@, +AB -- +AB Arrow, arrow)
def(ab-token@, +AB -- +AB Token, arrow token-end)
def(ab-token!, +AB Token -- +AB, arrow:token-end!)
def(ab-type@, +AB -- +AB StackType, arrow cod)
def(ab-type!, +AB StackType -- +AB, arrow:cod!)
def(ab-ctx@, +AB -- +AB Ctx, arrow ctx)
def(ab-home@, +AB -- +AB Home, arrow home)

def(ab-build!(f), (*a +AB -- *b +AB) *a Ctx StackType Token Home -- *b Arrow,
    >home
    dup >token-start >token-end
    dup >dom >cod
    >ctx L0 >atoms
    ARROW >arrow MKAB
    f /MKAB arrow>)

||| Like ab-build! but takes a morphism type to build
||| instead of just the domain. The codomain is placed
||| on the stack for (in)convenience. (You can ignore it with dip.)
def(ab-build-hom!(f), (*a StackType +AB -- *b StackType +AB) *a Ctx ArrowType Token Home -- *b Arrow,
    dip2(unpack rotr)
    ab-build!(f ab-unify-type!))
def(ab-build-word-arrow!(f), (*a StackType +AB -- *b StackType +AB) *a Word -- *b Arrow,
    sip(ctx-type) sip(body) HOME_WORD ab-build-hom!(f))
def(ab-build-word!(f), (*a +AB -- *b +AB) *a Word -- *b Word,
    sip(ab-build-word-arrow!(dip(f)) ready)
    tuck ~arrow !)

def(ab-unify-type!, StackType +AB -- +AB,
    dip(ab-token@ GAMMA ab-type@) unify! ab-type! drop)

def(ab-atom!, Atom +AB -- +AB,
    dup token ab-token!
    # atom-dom? ab-unify-type!     # moved to ab-expand-opsig!
        # ^ a sanity check to make sure
        # atom dom matches ab-arrow cod
    dup cod ab-type!
    arrow:atoms(swap ab-optimized-snoc!))

||| Add an atom to a list of atoms .. smartly.
def(ab-optimized-snoc!, List(Atom) Atom -- List(Atom),
    while(dip?(atoms-has-last-block?) and(atom-accepts-args?),
        swap atoms-turn-last-block-to-arg swap)
    snoc)

def(atom-accepts-args?, Atom -- Atom Bool,
    dup op match(
        OP_WORD -> dip(dup args len >Int) arity <,
        OP_PRIM ->
            match(
                PRIM_CORE_DIP -> dup args len 1 >Nat <,
                PRIM_CORE_RDIP -> dup args len 1 >Nat <,
                PRIM_CORE_IF -> dup args len 2 >Nat <,
                PRIM_CORE_WHILE -> dup args len 2 >Nat <,
                _ -> drop F
            ),
        _ -> drop F
    ))

def(atoms-has-last-block?, List(Atom) -- List(Atom) Bool,
    dup last match(
        NONE -> F,
        SOME ->
            op match(
                OP_BLOCK -> drop T,
                _ -> drop F
            )
    ))

def(atoms-turn-last-block-to-arg, Atom List(Atom) -- Atom List(Atom),
   >List+ match(
        NONE -> L0,
        SOME ->
            unsnoc dup op match(
                OP_BLOCK ->
                    { Atom List(Atom) Atom Block }
                    dip(dom rotl dom!)
                    { List(Atom) Atom Block }
                    ARG_BLOCK swap args:cons
                    swap,
                _ -> drop snoc
            )
    ))

def(ab-op!, Op +AB -- +AB,
    ab-ctx@ >ctx
    ab-token@ >token
    ab-home@ >home
    dup >op
    elab-op-fresh-sig! dip:>subst
    ab-expand-opsig! >cod >dom
    L0 >args ATOM ab-atom!)

def(ab-expand-opsig!, OpSig +AB -- StackType StackType +AB,
    OPSIG_ID -> ab-type@ dup,
    OPSIG_PUSH -> dip(ab-type@ dup) STCons,
    OPSIG_APPLY ->
        dip(ab-type@) unpack
        dip(ab-token@ elab-stack-type-unify! drop))

def(ab-int!, Int +AB -- +AB, OP_INT ab-op!)
def(ab-str!, Str +AB -- +AB, OP_STR ab-op!)
def(ab-buffer!, Buffer +AB -- +AB, OP_BUFFER ab-op!)
def(ab-variable!, Variable +AB -- +AB, OP_VARIABLE ab-op!)
def(ab-field!, Field +AB -- +AB, OP_FIELD ab-op!)
def(ab-var!, Var +AB -- +AB, OP_VAR ab-op!)
def(ab-tag!, Tag +AB -- +AB, OP_TAG ab-op!)
def(ab-prim!, Prim +AB -- +AB,
    dup ~type mut-is-set if(
        OP_PRIM ab-op!,
        ab-token@ "prim does not have type" emit-fatal-error!
    ))
def(ab-word!, Word +AB -- +AB, OP_WORD ab-op!)
def(ab-external!, External +AB -- +AB, OP_EXTERNAL ab-op!)
def(ab-coerce!, Coerce +AB -- +AB, OP_COERCE ab-op!)
def(ab-label-push!, Label +AB -- +AB, OP_LABEL_PUSH ab-op!)
def(ab-label-pop!, Label +AB -- +AB, OP_LABEL_POP ab-op!)

def(ab-block-at!(f), (*a +AB -- *b +AB) *a Token +AB -- *b +AB,
    ab-ctx@ MetaVar.new! STMeta rotl ab-home@ rdip(ab-build!(f))
    Block.new! OP_BLOCK ab-op!)

def(ab-block!(f), (*a +AB -- *b +AB) *a +AB -- *b +AB,
    ab-token@ ab-block-at!(f))

def(ab-dip!(f), (*a +AB -- *b +AB) *a +AB -- *b +AB,
    ab-block!(f) PRIM_CORE_DIP ab-prim!)

def(ab-rdip!(f), (*a +AB -- *b +AB) *a +AB -- *b +AB,
    ab-block!(f) PRIM_CORE_RDIP ab-prim!)

def(ab-if!(f,g), (*a +AB -- *b +AB, *b +AB -- *c +AB) *a +AB -- *c +AB,
    ab-block!(f) ab-block!(g) PRIM_CORE_IF ab-prim!)

def(ab-while!(f,g), (*a +AB -- *b +AB, *b +AB -- *c +AB) *a +AB -- *c +AB,
    ab-block!(f) ab-block!(g) PRIM_CORE_WHILE ab-prim!)

def(ab-lambda!(f), (*a +AB -- *b +AB) *a List(Param) +AB -- *b +AB,
    dip(ab-token@) ab-lambda-at!(f))
def(ab-lambda-at!(f), (*a +AB -- *b +AB) *a Token List(Param) +AB -- *b +AB,
    dup dip(
        dip(ab-ctx@ ab-type@) reverse-for(
            swap dip(>Var dup dip(Ctx.new))
            ab-token@ elab-expand-tensor!
            dip(rotl type) elab-type-unify! drop2
        )
        rotl ab-home@ rdip(ab-build!(f))
    )
    >params >body
    ab-ctx@ >outer-ctx
    ab-type@ >dom
    ab-token@ >token
    LAMBDA OP_LAMBDA ab-op!)

data(OpSig,
    OPSIG_ID,
    OPSIG_PUSH -> Type,
    OPSIG_APPLY -> ArrowType)

def(elab-op-fresh-sig!, Op -- Subst OpSig,
    Subst.nil swap match(
        OP_NONE -> OPSIG_ID,
        OP_INT -> VALUE_INT TValue OPSIG_PUSH,
        OP_STR -> VALUE_STR TValue OPSIG_PUSH,
        OP_BUFFER -> drop TYPE_PTR OPSIG_PUSH,
        OP_VARIABLE -> type TMut OPSIG_PUSH,
        OP_TAG -> type freshen-sig OPSIG_APPLY,
        OP_WORD -> type freshen-sig OPSIG_APPLY,
        OP_PRIM -> type freshen-sig OPSIG_APPLY,
        OP_EXTERNAL -> type freshen-sig OPSIG_APPLY,
        OP_FIELD -> type freshen-sig OPSIG_APPLY,
        OP_BLOCK -> elab-block-sig!,
        OP_VAR -> elab-var-sig!,
        OP_MATCH -> elab-match-sig!,
        OP_LAMBDA -> elab-lambda-sig!,
        OP_COERCE -> elab-coerce-sig!,
        OP_LABEL_PUSH -> elab-label-push-sig!,
        OP_LABEL_POP -> elab-label-pop-sig!,
        OP_DATA_GET_LABEL -> data-get-label-type freshen-sig OPSIG_APPLY,
        OP_DATA_SET_LABEL -> data-set-label-type freshen-sig OPSIG_APPLY,
    ))

def(elab-coerce-sig!, Coerce -- OpSig,
    COERCE_UNSAFE ->
        MetaVar.new! STMeta dup
        MetaVar.new! TMeta T* swap
        MetaVar.new! TMeta T* T-> OPSIG_APPLY)

def(elab-block-sig!, Block -- OpSig,
    VALUE_BLOCK TValue OPSIG_PUSH)

def(elab-match-sig!, Match -- OpSig,
    sip(dom) cod T-> OPSIG_APPLY)

def(elab-lambda-sig!, Lambda -- OpSig,
    sip(dom) cod T-> OPSIG_APPLY)

def(elab-var-sig!, Var -- OpSig,
    dup auto-run? if(
        type morphism? unwrap semifreshen-sig OPSIG_APPLY,
        type OPSIG_PUSH
    ))

def(elab-label-push-sig!, Label -- OpSig,
    dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2)
    STConsLabel dip(STCons) T-> OPSIG_APPLY)

def(elab-label-pop-sig!, Label -- OpSig,
    dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2)
    STConsLabel dip(STCons) swap T-> OPSIG_APPLY)

def(elab-arrow!, Ctx ArrowType Token Home -- Arrow,
    dip2(unpack) elab-arrow-hom!)

def(elab-arrow-hom!, Ctx StackType StackType Token Home -- Arrow,
    rotl dip(
        elab-arrow-fwd!
        dup token-end GAMMA
        over cod
    )
    unify! drop2)

def(elab-arrow-fwd!, Ctx StackType Token Home -- Arrow,
    ab-build!(elab-atoms!))

def(elab-atoms!, +AB -- +AB,
    while(
        ab-token@ run-end? not,
        elab-atom! ab-token@ next ab-token!
    ))

def(elab-atom!, +AB -- +AB,
    ab-token@ value match(
        TOKEN_NAME -> ab-token@ num-args elab-atom-name!,
        TOKEN_DNAME -> ab-token@ num-args elab-atom-dname!,
        TOKEN_INT -> ab-int!,
        TOKEN_STR -> ab-str!,
        TOKEN_LSQUARE -> drop elab-atom-block!,
        TOKEN_LCURLY -> drop elab-atom-assert!,
        TOKEN_LABEL_PUSH -> ab-label-push!,
        TOKEN_LABEL_POP -> ab-label-pop!,
        _ -> ab-token@ "Unexpected token in elab-atom!" emit-fatal-error!
    ))

def(elab-atom-block!, +AB -- +AB,
    ab-token@ args-1 elab-block-at!)

def(elab-block-at!, Token +AB -- +AB,
    ab-ctx@ swap ab-home@ Block.new-deferred!(
        dup ctx swap
        dup dom swap
        dup cod swap
        dup token swap
        home
        elab-arrow-hom!
    ) OP_BLOCK ab-op!)

def(elab-args!, +AB -- +AB,
    ab-token@ args for(elab-block-at!))

def(elab-no-args!, +AB -- +AB,
    ab-token@ args-0)

||| ( qname +AB -- bool +AB ) Return whether qname is imported in the current module,
||| meaning it can be referred to without qualification.
def(elab-qname-is-imported?, QName +AB -- Bool +AB,
    # TODO: implement finer grained control over what is imported.
    dup namespace match(
        NAMESPACE_MODULE -> nip elab-module-is-visible,
        NAMESPACE_TYCON -> elab-tycon-is-visible and(dup def? bind(tag?) some?) nip,
        _ -> drop2 F
    ))

def(arity-compatible?, Int Int -- Bool,
    dup -1 == dip(==) ||)

def(elab-atom-name!, Name Int +AB -- +AB,
    over ab-ctx@ lookup match(
        SOME -> dip:drop2 elab-args! ab-var!,
        NONE ->
            over defs map(qname) filter(dup2 arity arity-compatible?) filter(dup elab-qname-is-imported?)
            over2 can-be-relative? then(dip(dup2 elab-relative-name-candidates!) swap cat) nip
            match(
                L0 -> dip(ab-token@ "unknown name: ") >Str cat emit-fatal-error!,
                L1 -> nip elab-atom-qname!,
                _ -> nip dip(ab-token@) elab-ambiguous-name-error!
            )
    ))

def(elab-atom-dname!, DName Int +AB -- +AB,
    over root? match(
        SOME -> drop elab-atom-nonrelative-dname!,
        NONE -> swap parts match(
            L1+ -> swap elab-atom-relative-name!,
            _ -> ab-token@ "relative name has too many parts" emit-fatal-error!
        )
    ))

def(elab-atom-nonrelative-dname!, DName Int +AB -- +AB,
    dip2(ab-token@) elab-qname-from-nonrelative-dname elab-atom-qname!)

def(elab-relative-name-candidates!, Name Int +AB -- List(QName) +AB,
    NAMESPACE_ROOT >namespace >arity >name MKQNAME >template
    L0 L0
    ab-type@ top-tycon? for(snoc)
    ab-type@ top-resource-tycon? for(snoc)
    for(
        NAMESPACE_TYCON template> dup >template namespace!
        -1 over arity! L2 cat
    )
    template> drop
    filter(dup defined?))

def(elab-atom-relative-name!, Name Int +AB -- +AB,
    dup2 elab-relative-name-candidates! match(
        L0 -> drop dip(ab-token@ "unknown relative name: ") >Str cat emit-fatal-error!,
        L1 -> dip:drop2 elab-atom-qname!,
        _ -> nip dip(ab-token@) elab-ambiguous-name-error!
    ))

def(elab-ambiguous-name-error!, *a Token List(QName) -- *b,
    dip("name is ambiguous, can't decide between:")
    for(dip(" " cat) >Str cat) emit-fatal-error!)

def(elab-atom-qname!, QName +AB -- +AB,
    dup def? match(
        NONE -> dip(ab-token@ "unknown name: ") >Str cat emit-fatal-error!,
        SOME ->
            ab-token@ over def-visible-from-token? else(over elab-atom-not-visible!)
            nip elab-atom-def!
    ))

def(elab-needs-dot, Str -- Bool,
    first-byte if-some(is-alnum, F))

def(elab-combine-prefix, Str Str -- Str,
    over elab-needs-dot then("." cat) swap cat)

def(elab-combine-prefixes, List+(Str) Maybe(Str) -- List+(Str),
    if-some(
        over map(over elab-combine-prefix) nip cat+,
        id
    ))

def(elab-word-search, Str -- List(Def),
    Name.search match(
        NONE -> L0,
        SOME -> defs filter(dup callable?)
    ))

def(elab-name-candidates, Name +AB -- List(Def) +AB,
   >Str L1+
    ab-type@ top-resource-tycon? map(name >Str) elab-combine-prefixes
    ab-type@ top-tycon? map(name >Str) elab-combine-prefixes
    flatmap(elab-word-search))

def(elab-def-is-visible, Def +AB -- Bool +AB, qname elab-qname-is-visible)
def(elab-qname-is-visible, QName +AB -- Bool +AB, namespace elab-namespace-is-visible)
def(elab-namespace-is-visible, Namespace +AB -- Bool +AB,
    NAMESPACE_ROOT -> F,
    NAMESPACE_PACKAGE -> drop F,
    NAMESPACE_MODULE -> elab-module-is-visible,
    NAMESPACE_TYCON -> elab-tycon-is-visible,
    NAMESPACE_WORD -> drop F)

def(elab-tycon-is-visible, Tycon +AB -- Bool +AB,
    qname elab-qname-is-visible) # FIXME
def(elab-module-is-visible, Module +AB -- Bool +AB,
    ab-token@ .module visible)

def(elab-stack-type-is-fine?, +AB -- Bool +AB,
    ab-type@ expand match(
        STACK_TYPE_ERROR -> F,
        _ -> drop T
    ))

def(elab-atom-def!, Def +AB -- +AB,
    DEF_ALIAS -> target elab-atom-def!,
    DEF_BUFFER -> elab-no-args! ab-buffer!,
    DEF_VARIABLE -> elab-no-args! ab-variable!,
    DEF_EXTERNAL -> elab-no-args! ab-external!,
    DEF_FIELD -> elab-no-args! ab-field!,
    DEF_WORD -> elab-args! ab-word!,
    DEF_TAG -> elab-args! ab-tag!,
    DEF_PRIM -> elab-prim!,
    _ -> qname name elab-atom-unknown-word!)

def(elab-atom-unknown-word!, Name +AB -- +AB,
    elab-stack-type-is-fine? if(
        dip(ab-token@ "Unknown word: ") >Str cat emit-error!,
        drop
    ) STACK_TYPE_ERROR ab-type!)

def(elab-atom-not-visible!, QName +AB -- +AB,
    dip(ab-token@ "Word not visible: ") >Str cat emit-error!)

def(elab-prim!, Prim +AB -- +AB,
    match(
        PRIM_CORE_MATCH -> elab-atom-match!,
        PRIM_CORE_LAMBDA -> elab-atom-lambda!,
        _ -> elab-args! ab-prim!
    ))

def(elab-atom-assert!, +AB -- +AB,
    ab-token@ GAMMA
    ab-ctx@ type-elab-stack-assertion
    ab-token@ args-1 elab-type-stack!
    drop nip ab-type@ swap unify! drop2)

def(elab-atom-match!, +AB -- +AB,
    MetaVar.new! STMeta >cod
    ab-token@ args+ first >body
    elab-match-at!)

||| Elaborate a match body within AB. Takes the output stack type,
||| and the token for the body of the match, from the stack. Takes
||| the rest from the AB environment.
def(elab-match-at!, cod:StackType body:Token +AB -- +AB,
    ab-match!(
        elab-match-cases!
        elab-match-exhaustive!
    ))

||| Elaborate match cases.
def(elab-match-cases!, +Match -- +Match,
    body while(dup args-end? not, elab-match-case!) drop)

||| Elaborate match case based on starting token.
def(elab-match-case!, Token +Match -- Token +Match,
    dup run-arrow? unwrap-or("expected arrow end" emit-fatal-error!)
    dup2 == then("expected pattern" emit-fatal-error!)
    dup2 prev == else("multi-part pattern not supported" emit-fatal-error!)
    dip:pat-tokens sip:prev succ +Match.case!(
        elab-pattern!,
        elab-atoms!
        ab-token@ dup comma? then(succ)
    ))

def(Token.pat-tokens, Token -- List(Token),
    run-tokens take-while(dup pat-arrow? not))
def(List.take-while(p), (*a t -- *a t Bool) *a List(t) -- *a List(t),
    dip:T filter(swap dip:p && tuck) nip) # TODO improve

def(elab-pattern!, List(Token) +Pattern -- +Pattern,
    reverse-for(elab-pattern-atom!))

def(elab-pattern-atom!, Token +Pattern -- +Pattern,
    dup pat-underscore? if(
        drop +Pattern.underscore!,

    dup name? if-some(
        # TODO type-directed tag resolution
        defs find-some(tag?) match(
            NONE -> "Unknown constructor." emit-fatal-error!,
            SOME -> nip +Pattern.tag!
        ),

        "Expected constructor name." emit-fatal-error!
    )))

def(ab-match!(f),
        (*a +Match -- *b +Match)
        *a cod:StackType body:Token +AB -- *b +AB,
    ab-ctx@ >ctx
    ab-type@ >dom
    ab-token@ >token
    ab-home@ >home
    L0 >cases
    rdip(+MATCH f freeze) OP_MATCH ab-op!)

def(+Match.case!(mkpat,mkbod),
        (*a +Pattern -- *b +Pattern,
         *b +AB -- *c +AB)
        *a Token Token +Match -- *c +Match,

    dip(
        home >home dup >token-start >token-end
        ctx dup >outer-ctx >inner-ctx
        L0 >saved dom dup >mid >cod L0 >atoms
        PATTERN rdip(thaw mkpat freeze)
    ) swap \(pat ->
        pat inner-ctx
        pat Pattern.dom +Match.cod T->
        rotl
        +Match.home
        rdip(ab-build-hom!(dip(mkbod)))
        >body
        pat >pattern
        CASE add-case
    ))

def(elab-expand-tensor!, StackType Token -- StackType Type Token,
    >tok force-cons?! match(
        SOME -> unpack2 tok>,
        NONE -> STACK_TYPE_ERROR TYPE_ERROR tok> dup "expected tuple type" emit-error!
    ))

def(elab-lambda-param?, Token -- Token Maybe(Param),
    dup pattern-var? if(
        dup args-0 sip:next
        dip(MetaVar.new! TMeta) name? unwrap Var.new! >Param SOME,
    dup lsquare?
    and(dup succ pattern-var?)
    and(dup succ succ rsquare? >Bool) if(
        dup succ args-0 sip:next
        dip(MetaVar.new! STMeta MetaVar.new! STMeta T-> TMorphism)
        succ name? unwrap Var.new-auto-run! >Param SOME,
        NONE
    )))

def(elab-atom-lambda!, +AB -- +AB,
    ab-token@ args-1
    collect(elab-lambda-param?)
    dip(expect-token-arrow succ)
    ab-lambda-at!(elab-atoms!))

||| Check that a match is exhaustive.
def(elab-match-exhaustive!, +Match -- +Match,
    freeze dup is-exhaustive? else(
        dup token "Pattern match not exhaustive." emit-error!
    ) thaw)

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def(elab-module!, Module +World -- Module +World,
    dup start
    elab-module-header!
    while(dup module-end? not, elab-module-decl!)
    drop)

def(elab-module-package-name, Token -- Package Name,
    dup dname? unwrap-or("Expected module name. (1)" emit-fatal-error!) over args-0
    dup root? unwrap-or(drop "Expected module name. (2)" emit-fatal-error!)
    swap parts match(L1+ -> , _ -> drop2 "Expected module name. (3)" emit-fatal-error!)
    dip(Package.find-or-new! nip))

def(elab-module-qname, Token -- QName,
    elab-module-package-name dip(NAMESPACE_PACKAGE) QNAME0)

||| Check that the `module(M)` statement exists and save the name.
def(elab-module-header!, Token -- Token,
    # dup token-name@ name-str @ str-trace-ln!
    dup module-header? if(
        sip(next) args-1 dup elab-module-package-name
        over2 .module
        tuck ~name !
        tuck ~package !
        dup qname defined? then(drop "Module name already taken." emit-fatal-error!)
        dup DEF_MODULE register
        check-module-path,

        dup "Expected module header." emit-fatal-error!
    ))

def(check-module-path, Token Module --,
    sip(path) qname to-module-path dup2 == else(
        "expected module name to match path\n" swap >Str cat "\n" cat swap >Str cat emit-fatal-error!
    ) drop3)

||| Elaborate a declaration. Returns the next token.
def(elab-module-decl!, Token +World -- Token +World,
    dup name? unwrap-or("unknown declaration" emit-fatal-error!)
    defs find-some(prim?) unwrap-or("unknown declaration" emit-fatal-error!)
    match(
        PRIM_SYNTAX_IMPORT -> elab-module-import!,
        PRIM_SYNTAX_ALIAS -> elab-alias!,
        PRIM_SYNTAX_DEF -> elab-def!,
        PRIM_SYNTAX_DEF_MISSING -> elab-def-missing!,
        PRIM_SYNTAX_DEF_TYPE -> elab-def-type!,
        PRIM_SYNTAX_DEF_EXTERNAL -> elab-def-external!,
        PRIM_SYNTAX_BUFFER -> elab-buffer!,
        PRIM_SYNTAX_VARIABLE -> elab-variable!,
        PRIM_SYNTAX_TABLE -> elab-table!,
        PRIM_SYNTAX_FIELD -> elab-field!,
        PRIM_SYNTAX_DATA -> elab-data!,
        PRIM_SYNTAX_EMBED_STR -> elab-embed-str!,
        _ -> drop "unknown declaration" emit-fatal-error!
    ))

def(load-module, Token QName +World -- Token Module +World,
    dup def? match(
        SOME -> module? unwrap-or(drop "module name already taken" emit-fatal-error!) nip,
        NONE ->
            to-module-path run-lexer!
            elab-module!
                # TODO: avoid elaborating here,
                # use a single loop to dispatch top-level module elaboration.
    ))

||| Elaborate `import(M)` statement. Return token after import.
def(elab-module-import!, Token +World -- Token +World,
    sip(next)
    args-1 dup elab-module-qname
    load-module dip(.module) add-import!)

||| Elaborate a data definition `data(T, ..)`
def(elab-data!, Token -- Token,
    sip(
        Data.alloc!
        L0 over ~tags !
        swap args+
        uncons dip(elab-data-header!)
        for(elab-data-tag!)
        elab-data-done!
    ) next)

||| Get the header, name, arity for a data type.
def(elab-data-header!, Data Token -- Data,
    dup2 SOME swap ~head? !
    dup sig-type-con? or(dup sig-resource-con?) else("Expected type name." emit-fatal-error!)
    dup2 elab-def-qname-undefined
    over ~qname !
    dup DEF_DATA register
    # TODO check header args are well-formed / elaborate them properly
    dip(num-args) ~arity !)

||| Get a tag associated with a data type.
||| This looks like either "TAG" or "TAG -> TYPE1 .. TYPEN".
def(elab-data-tag!, Data Token -- Data,
    dup2 name? unwrap-or(drop "Expected constructor name." emit-fatal-error!)
    0 data-qname
    Tag.alloc!
    NONE over ~untag !
    tuck ~qname !
    dup DEF_TAG register
    { Data Token Tag }
    dip(over) dup2 ~data !
    tuck dip(add-tag!)
    { Data Token Tag }
    swap succ
    dup pat-arrow? if(
        succ SOME over ~sig? !,
    dup run-end? if(
        drop NONE over ~sig? !,
        "Expected arrow, comma, or right paren." emit-fatal-error!
    ))
    { Data Tag }
    dup delay(
        type-elab-default
        over .data head? unwrap elab-type-atom! drop dip(T0) cons
        dip(T0 rotl sig? for(
            elab-type-stack-rest!
            dup run-end? else("syntax error" emit-fatal-error!) drop
        ))
        T-> dip(type-elab-ctx) pack2
    )
    over ~ctx-type !
    sip(num-type-inputs-from-sig) sip(~num-type-inputs !)
    sip(num-resource-inputs-from-sig) sip(~num-resource-inputs !)
    sip(label-inputs-from-sig) sip(~label-inputs !)

    dup outputs-resource? not
    over num-resource-inputs 0> && then(
        sig? unwrap run-tokens find(
            dup sig-resource-con? or(dup sig-resource-var?)
        ) unwrap "Value type cannot contain resource." emit-fatal-error!
    )

    drop)

def(data-word-new!, Data Str Int -- Word,
    dup >arity
    dip2(dup head? unwrap dup >body >head)
    data-word-qname >qname
    NONE >sig
    Word.new!)

def(elab-data-done!, Data --,
    \(dat ->
        dat is-enum? then(
            dat "tag" 0 data-word-new! \(tag ->
                CTX0 dat TData T1 TYPE_INT T1 T-> ready2 tag ~ctx-type !
                tag ab-build-word!(
                    COERCE_UNSAFE ab-coerce!
                ) drop
            )

            dat "from-tag-unsafe" 0 data-word-new! \(ftag ->
                CTX0 TYPE_INT T1 dat TData T1 T-> ready2 ftag ~ctx-type !
                ftag ab-build-word!(
                    COERCE_UNSAFE ab-coerce!
                ) drop
            )
        )

        dat tags match(
            L1 -> \(tag ->
                dat "/" tag name >Str cat 0 data-word-new! \(untag ->
                    tag delay(ctx-type unpack swap T-> pack2) untag ~ctx-type !
                    untag delay(ab-build-word-arrow!(
                        untag type cod >cod
                        dat head? unwrap >body
                        ab-match!(
                            dat head? unwrap dup
                            case!(tag +Pattern.tag!, id)
                       )
                    )) untag ~arrow !
                    untag SOME tag ~untag !
                    tag create-projectors!
                )
            ),
            _ -> drop
        )
    ))

||| Return the tag's output type or resource in context.
def(Tag.output-type, Tag -- Either(Type,Resource),
    dup type cod expand match(
        STCons -> LEFT dip(drop2),
        STWith -> RIGHT dip(drop2),
        _ -> drop dip("Unexpected output type for constructor ") qname >Str cat panic!
    ))

||| Return the input type for a tag along a given label.
def(Tag.project-input-label, Label Tag -- Maybe(Type),
    type dom force-cons-label?! map(unpack2 nip))

def(data-get-label-type, Tag Label -- ArrowType,
    \(tag lbl ->
        T0 tag output-type T*+
        lbl tag project-input-label unwrap T1
        tag .data is-resource? then(tag output-type T*+)
        T->
    ))

def(data-set-label-type, Tag Label -- ArrowType,
    \(tag lbl ->
        lbl tag project-input-label unwrap T1 tag output-type T*+
        T0 tag output-type T*+
        T->
    ))

def(create-projectors!, Tag --,
    dup .data over .untag unwrap \(tag dat untag ->
    tag label-inputs reverse-for(\(lbl -> dat lbl name 0 data-qname undefined? then(
        dat lbl >Str 0 data-word-new!
        dat lbl >Str "!" cat 0 data-word-new!
        dat lbl >Str 1 data-word-new! \(lbl_get lbl_set lbl_lens ->
            delay0(
                tag ctx
                tag lbl data-get-label-type
                pack2
            ) lbl_get ~ctx-type !
            lbl_get delay(ab-build-word-arrow!(
                tag lbl OP_DATA_GET_LABEL ab-op!
            )) lbl_get ~arrow !

            delay0(
                tag ctx
                tag lbl data-set-label-type
                pack2
            ) lbl_set ~ctx-type !
            lbl_set delay(ab-build-word-arrow!(
                tag lbl OP_DATA_SET_LABEL ab-op!
            )) lbl_set ~arrow !

            delay0(
                TYPE_STACK "*x" >Name Var.new!
                TYPE_STACK "*y" >Name Var.new!
                lbl tag project-input-label unwrap
                tag output-type \(sx sy lblty datty ->
                    tag ctx /CTX sx sy L2 cat CTX
                    sx STVar datty T*+
                        sx STVar lblty T*
                        sy STVar lblty T* T-> TMorphism T*
                    sy STVar datty T*+
                    T-> pack2
                )
            ) lbl_lens ~ctx-type !
            lbl_lens delay(ab-build-word-arrow!(
                dat is-resource? if(
                    lbl_get ab-word!
                    ab-rdip!(
                        PRIM_CORE_SWAP ab-prim!
                        PRIM_CORE_RUN ab-prim!
                    )
                    lbl_set ab-word!,

                    PRIM_CORE_SWAP ab-prim!
                    PRIM_CORE_DUP ab-prim!
                    ab-dip!(
                        lbl_get ab-word!
                        PRIM_CORE_SWAP ab-prim!
                        PRIM_CORE_RUN ab-prim!
                    )
                    lbl_set ab-word!
                )
            )) lbl_lens ~arrow !
        )
    )))))

def(expect-token-arrow, Token -- Token,
    dup pat-arrow? else("Expected arrow." emit-fatal-error!))

||| Break apart the arguments for `def` into three categories:
|||     - head: the name of the definition, plus params
|||     - sig: the type signature
|||     - body: a nonempty list of body arguments
def(token-def-args, Token -- Token Token List+(Token),
    dup args dup len 3 >Nat < then(drop "def expects at least three arguments" emit-fatal-error!) nip
    >List+ unwrap uncons
    >List+ unwrap uncons
    >List+ unwrap)

||| Elaborate an alias `alias(w1,w2)`
def(elab-alias!, Token -- Token,
    sip(next) args-2 swap
    dup elab-def-qname-undefined dup \(aliasqname ->
    over next arg-end? else(over "expected comma after alias name" emit-fatal-error!)
    rotl dup name-or-dname? unwrap-or("expected alias target, which must be a name" emit-fatal-error!)
    over args-0 over succ arg-end? else(over "expected end of argument after alias target" emit-fatal-error!)
    pack2 delay(
        unpack2 match(
            LEFT ->
                defs filter(dup2 def-visible-from-token?) match(
                    L0 -> "unknown alias target" emit-fatal-error!,
                    L1 -> ,
                    _ -> map(qname) elab-ambiguous-name-error!
                ),
            RIGHT ->
                dip(dup) aliasqname arity elab-qname-from-nonrelative-dname
                dup def? unwrap-or(dip("undefined alias target ") >Str cat emit-fatal-error!) nip
        )
        dup2 def-visible-from-token? else(
            dip("alias target is not visible")
            defining-module? for(dip(", need to import " cat) qname >Str cat)
            emit-fatal-error!
        )
        match(
            DEF_ALIAS ->
                # Detect circular aliases, e.g. `alias(x, y) alias(y, x)`,
                # and avoid storing alias chains (so each alias points to its ultimate target directly).
                ~target force-or!("alias points to itself, circular aliases not allowed." emit-fatal-error!) nip,
            _ -> nip,
        )
    )
    Alias.new! drop))

||| Elaborate a missing word definition `def-missing(w,t,b...)`
def(elab-def-missing!, Token -- Token,
    dup args len 3 >Nat < then("def-missing expects at least three arguments" emit-fatal-error!)
    dup succ succ elab-def-qname defined? if(next, elab-def!))

||| Elaborate a word definition `def(w, t, b...)`.
def(elab-def!, Token -- Token,
    sip(next) token-def-args
    uncons is-empty or(dup run-arrow? >Bool) else("expected match case" emit-fatal-error!) >body
    SOME >sig
    dup >head
    dup num-args >arity
    elab-def-qname-undefined >qname
    Word.new!

    dup delay(
        type-elab-default
        over sig unwrap-or(over head "need word signature" emit-fatal-error!)
        elab-type-sig! drop dip(type-elab-ctx)
        pack2 nip
    ) over ~ctx-type !
    dup delay(elab-def-params!) over ~params !
    dup delay(
        dup ab-build-word-arrow!(
            swap params dup is-empty if(
                drop elab-def-body!,
                ab-lambda!(elab-def-body!)
            )
        )
    ) swap ~arrow !)

||| Elaborate a word's parameters from its type and declaration.
def(elab-def-params!, Word -- List(Param),
    L0 over type
    rotl head dip(unpack) nip
    args reverse-for(
        dup sig-param-name? else("expected parameter name" emit-fatal-error!)
        dup succ dup run-end? if(drop, "expected right paren or comma" emit-fatal-error!)
        elab-expand-tensor!
        over morphism? else(
            "need function type for param" emit-fatal-error!)
        name? unwrap Var.new-auto-run!
        PARAM rotr dip(cons)
    ) drop)

||| Elaborate the body of a `def`. Takes the codomain from the stack,
||| and the rest from the AB environment.
def(elab-def-body!, StackType +AB -- StackType +AB,
    ab-token@ run-arrow? if(
        dup >cod ab-token@ >body elab-match-at!,
        elab-atoms!
    ))

||| Elaborate an external declaration `def-external(w, t)` or `def-external(w -> sym, t)`
def(elab-def-external!, Token -- Token,
    sip(next) args-2
    over dup elab-def-qname-undefined
    swap succ dup comma? if(
        drop dup name,
        expect-token-arrow succ
        dup name? unwrap-or("expected external symbol name" emit-fatal-error!) nip
    ) >Str swap

    External.alloc!
    tuck ~qname !
    tuck ~symbol !
    tuck ~sig !
    tuck ~head !
    dup delay(
        type-elab-default swap sig
        elab-type-sig! drop dip(type-elab-ctx) pack2
    ) over ~ctx-type !
    DEF_EXTERNAL register)

||| Elaborate a type definition `def-type(t1, t2)`.
def(elab-def-type!, Token -- Token,
    sip(next) args-2
    swap dup sig-type-con? else("expected type constructor" emit-fatal-error!)
    dup elab-def-qname-undefined
    dip(SOME) rotl elab-simple-type-arg! TypeDef.new! drop)

||| Elaborate a buffer definition `buffer(B, size)`.
def(elab-buffer!, Token -- Token,
    sip(next) args-2
    swap dup elab-def-qname-undefined
    rotl dup int? unwrap-or("expected buffer size" emit-fatal-error!) nip
   >Size Buffer.new! drop)

||| Elaborate a var declaration `var(v, type)`.
def(elab-variable!, Token -- Token,
    sip(next) args-2
    swap dup elab-def-qname-undefined
    rotl delay(elab-simple-type-arg!)
    Variable.new! drop)

||| Elaborate a table definition `table(T)`.
def(elab-table!, Token -- Token,
    sip(next) args-1
    dup sig-type-con? else("expected type name" emit-fatal-error!)
    dup args-0
    dup succ arg-end? else(succ "expected end of argument after table name" emit-fatal-error!)
    dup elab-def-qname-undefined
    table-new! drop)

||| Create entry point based on word name.
def(elab-entry-point, QName +World -- Arrow +World,
    dup def? bind(word?) unwrap-or(
        dup dip(
            namespace module? unwrap start
            "can't find entry point "
        ) >Str cat
        emit-fatal-error!
    ) nip { Word +World }
    dup dip(CTX0 T0 RESOURCE_WORLD T+ T0 RESOURCE_WORLD T+ T->)
    head dup HOME_MAIN ab-build-hom!(
        dip(ab-word!)
    ))

||| Embed a file as a string, embed-str(name, "path").
||| The path is relative to compiler's cwd, not source root.
def(elab-embed-str!, Token +World -- Token +World,
    sip:next args-2 swap
    dup >head elab-def-qname-undefined >qname
    dup >body NONE >sig 0 >arity
    dup str? unwrap-or("expected source path" emit-fatal-error!)
    >Path open-file! .read-file! close-file! nip >contents
    Word.new!
    CTX0 T0 TYPE_STR T1 T-> ready2 over ~ctx-type !
    ab-build-word!(contents> ab-str!) drop)

||| Ensure that everything so far has been typechecked.
def(typecheck-everything!, --,
    Name.for(defs for(typecheck!))
    Block.for(typecheck!))

#########
# TABLE #
#########

def(TABLE_MAX_COUNT, Nat, 0x10000 >Nat)

def(table-qname, Table Str Int -- QName,
    >arity >Name >name TYCON_TABLE NAMESPACE_TYCON >namespace MKQNAME)

def(table-word-new!, Table Str Int -- Word,
    over2 head dup >head >body NONE >sig
    dup >arity table-qname >qname Word.new!)

def(table-new!, Token QName -- Table,
    Table.alloc!
    tuck ~qname !
    tuck ~head !
    TABLE_MAX_COUNT over ~max-count !
    dup DEF_TABLE register

    # Table.MAX
    dup "MAX" 0 table-word-new!

    L0 CTX
    T0 TYPE_INT T1 T->
    ready2 over ~ctx-type !

    ab-build-word!(
        dup head ab-token!
        TABLE_MAX_COUNT >Int ab-int!
    ) drop

    # Table.nil
    dup "nil" 0 table-word-new!

    L0 CTX
    T0 over3 TTable T1 T->
    ready2 over ~ctx-type !

    ab-build-word!(
        dup head ab-token!
        0 ab-int!
        COERCE_UNSAFE ab-coerce!
    ) drop

    # Table.NUM
    dup head
    over "NUM" 0 table-qname
    8 >Size Buffer.new!
    over ~num-buffer !

    # Table.index
    dup "index" 0 table-word-new!

    L0 CTX
    over2 TTable T1 TYPE_INT T1 T->
    ready2 over ~ctx-type !

    ab-build-word! (
        dup head ab-token!
        COERCE_UNSAFE ab-coerce!
    ) drop

    # Table.from-index
    dup "from-index" 0 table-word-new!

    L0 CTX
    over2 TTable T1 TYPE_INT T1 swap T->
    ready2 over ~ctx-type !

    ab-build-word! (
        dup head ab-token!
        COERCE_UNSAFE ab-coerce!
    ) drop

    # Table.succ
    dup "succ" 0 table-word-new!

    L0 CTX
    over2 TTable T1 dup T->
    ready2 over ~ctx-type !

    ab-build-word! (
        dup head ab-token!
        COERCE_UNSAFE ab-coerce!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        dup num-buffer ab-buffer!
        PRIM_U64_GET ab-prim!
        COERCE_UNSAFE ab-coerce!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        PRIM_INT_MOD ab-prim!
        COERCE_UNSAFE ab-coerce!
    ) drop

    # Table.pred
    dup "pred" 0 table-word-new!

    L0 CTX
    over2 TTable T1 dup T->
    ready2 over ~ctx-type !

    ab-build-word! (
        dup head ab-token!
        COERCE_UNSAFE ab-coerce!
        PRIM_CORE_DUP ab-prim!
        0 ab-int!
        PRIM_INT_EQ ab-prim!
        ab-if!(
            ,
            1 ab-int!
            PRIM_INT_SUB ab-prim!
        )
        COERCE_UNSAFE ab-coerce!
    ) drop

    # Table.for

    dup "for" 1 table-word-new!
    TYPE_STACK "*a" >Name Var.new! dup STVar
    \(t w va a -> a t TTable T* a T-> >Type "x" >Name Var.new-auto-run!
    \(x ->
        va CTX1
        a a t TTable T* a T-> >Type T* a T->
        ready2 w ~ctx-type !

        w ab-build-word! (
            t head ab-token!
            x >Param L1 ab-lambda! (
                1 ab-int!
                ab-while! (
                    PRIM_CORE_DUP ab-prim!
                    t num-buffer ab-buffer!
                    PRIM_U64_GET ab-prim!
                    COERCE_UNSAFE ab-coerce!
                    1 ab-int!
                    PRIM_INT_ADD ab-prim!
                    PRIM_INT_LT ab-prim!,

                    PRIM_CORE_DUP ab-prim!
                    ab-dip! (
                        COERCE_UNSAFE ab-coerce!
                        x ab-var!
                    )
                    1 ab-int!
                    PRIM_INT_ADD ab-prim!
                )
                PRIM_CORE_DROP ab-prim!
            )
        ) drop

    t))

    # Table.alloc!
    dup "alloc!" 0 table-word-new!

    L0 CTX
    T0 over3 TTable T1 T->
    ready2 over ~ctx-type !

    ab-build-word! (
        dup head ab-token!
        dup num-buffer ab-buffer!
        PRIM_U64_GET ab-prim!
        COERCE_UNSAFE ab-coerce!
        1 ab-int!
        PRIM_INT_ADD ab-prim!
        PRIM_CORE_DUP ab-prim!
        COERCE_UNSAFE ab-coerce!
        dup num-buffer ab-buffer!
        PRIM_U64_SET ab-prim!
        COERCE_UNSAFE ab-coerce!
    )
    drop
    )

#########
# FIELD #
#########

def(elab-qname-from-nonrelative-dname, Token DName Int -- QName,
    over root? unwrap-or(drop2 "relative name not allowed" emit-fatal-error!)
    dup could-be-type-or-resource-con if(
        rotl parts match(
            L1+ -> rotl elab-tycon-qname,
            _ -> drop3 "type-qualified name has too many parts" emit-fatal-error!
        ),
        rotr dip(parts cons+) elab-absolute-qname
    ))

def(module-visible-from-token?, Token Module -- Bool,
    swap .module visible)

def(def-visible-from-token?, Token Def -- Bool,
    defining-module? match(
        NONE -> drop T,
        SOME -> module-visible-from-token?
    ))

def(elab-tycon, Token Name -- Tycon,
    dup defs find-some(
        over2 over def-visible-from-token? if(
            exposed-tycon?,
            drop NONE
        )
    )
    unwrap-or("unknown type constructor: " swap >Str cat emit-fatal-error!)
    dip(drop2))

def(elab-tycon-qname, Token Name Name Int -- QName,
    >arity >name elab-tycon NAMESPACE_TYCON >namespace MKQNAME)

def(elab-absolute-namespace, Token List(Name) -- Namespace,
    NAMESPACE_ROOT swap for(
        QNAME0 dup def? unwrap-or("unknown namespace: " swap >Str cat emit-fatal-error!)
        match(
            DEF_PACKAGE -> NAMESPACE_PACKAGE,
            DEF_MODULE -> NAMESPACE_MODULE,
            _ -> exposed-tycon? unwrap-or("invalid namespace: " swap >Str cat emit-fatal-error!) NAMESPACE_TYCON,
        ) nip
    ) nip)

def(elab-absolute-qname, Token List+(Name) Int -- QName,
    >arity unsnoc >name
    elab-absolute-namespace >namespace MKQNAME)

||| Elaborate the qname for a word definition.
||| Generally speaking this is going to use the module namespace.
def(elab-def-qname, Token -- QName,
    dup name-or-dname? unwrap-or("expected name" emit-fatal-error!)
    match(
        LEFT -> >name dup .module NAMESPACE_MODULE >namespace num-args >arity MKQNAME,
        RIGHT -> over num-args elab-qname-from-nonrelative-dname
    ))

||| Same as `elab-def-qname` but raises an error if the qname is already defined.
def(elab-def-qname-undefined, Token -- QName,
    dup elab-def-qname
    dup defined? then(drop "name already defined" emit-fatal-error!)
    nip)

||| Elaborate a field definition `field(f, T1, T2)`.
def(elab-field!, Token -- Token,
    sip(next) args-3
    rotl dup elab-def-qname-undefined
    field-new! drop)

def(field-new!, Token Token Token QName -- Field,
    Field.alloc!
    tuck ~qname !
    tuck ~head !
    swap delay(elab-simple-type-arg!) over ~value-type !
    swap delay(elab-simple-type-arg!) over ~index-type !
    dup DEF_FIELD register)
