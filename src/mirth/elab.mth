
import base/unit
import base/maybe
import base/result
import base/list
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax

export mirth/elab
  type Map(k,v)
  type Result(a,b)

  type EEnv
  type EError
  type EWarning
  type EMonad(t)
  type EResult(t)

  type ESym
  type ETerm
  type EEffect
  type EStack
  type EType
  type EKind
  type EBind
  type ECtx
  type EParams
  type EDefs
  type EInterface
  type EModule
  type EPackage

  emRun : EEnv EMonad(t) -- EEnv EResult(t)
  emFail : Str -- EMonad(a)
  emPure : a -- EMonad(a)
  emPure2 : a b -- EMonad(a) EMonad(b)
  emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
  emMap(f: a -- b) : EMonad(a) -- EMonad(b)
  emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
  emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
  emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emThen(f: EMonad(b)) : EMonad(a) -- EMonad(b)
  emThen2(f: EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emThen3(f: EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emThen4(f: EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)

  runElabModule : Mod L(Module) -- EResult(EModule)
  runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)

  eerror->str : EError -- Str
  ewarning->str : EWarning -- Str
  emodule->str : EModule -- Str

  eresult(
    f: *a List(EError) List(EWarning) -- *b,
    g: *a t List(EWarning) -- *b
  ) : *a EResult(t) -- *b
end

||| Error during elaboration.
data EError
  MkEError : L(Str) -- EError
end

unEError : EError -- L(Str)
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError unL dip(locSet->str) <>


||| Warning during elaboration.
data EWarning
  MkEWarning : L(Str) -- EWarning
end

unEWarning : EWarning -- L(Str)
unEWarning = match(MkEWarning -> id)

ewarning->str : EWarning -- Str
ewarning->str = unEWarning unL dip(locSet->str) <>


data EResult(t)
  ERErr : List(EError) List(EWarning) -- EResult(t)
  EROk : t List(EWarning) -- EResult(t)
end

eresult(f,g) =
  match(
    ERErr -> f,
    EROk -> g
  )

erPure : t -- EResult(t)
erPure = nil EROk

erFail : EError -- EResult(t)
erFail = lpure nil ERErr

erWarn : EWarning -- EResult(Unit)
erWarn = dip(unit) lpure EROk

erMap(f: *c a -- *c b) : *c EResult(a) -- *c EResult(b)
erMap(f) = eresult(ERErr, dip(f) EROk)

erMap2(f: a b -- c) : EResult(a) EResult(b) -- EResult(c)
erMap2(f) =
  swap eresult(
    rotl eresult(
      dip(swap) dip2(++) ++ ERErr,
      nip ++ ERErr
    ),
    rotl eresult(
      dip3(drop) dip(swap) ++ ERErr,
      dip(swap) dip2(f) ++ EROk
    )
  )

erBind(f: a -- EResult(b)) : EResult(a) -- EResult(b)
erBind(f) =
  eresult(
    ERErr,
    swap f eresult(
      dip(swap) ++ ERErr,
      dip(swap) ++ EROk
    )
  )


||| Elaboration monad.
data EMonad(t)
  MkEMonad(f: EEnv m -- EEnv EResult(t)) : m -- EMonad(t)
end

emUse(f: EEnv a -- EEnv b) : a -- EMonad(b)
emUse(f) = MkEMonad(f erPure)

emGet(f: EEnv -- EEnv b) : EMonad(b)
emGet(f) = unit emUse(drop f)

emPut(f: EEnv t -- EEnv) : t -- EMonad(Unit)
emPut(f) = emUse(f unit)

emRun : EEnv EMonad(t) -- EEnv EResult(t)
emRun = match(MkEMonad(f) -> f)

emPure : a -- EMonad(a)
emPure = MkEMonad(erPure)

emFail : Str -- EMonad(a)
emFail = MkEMonad(pureL MkEError erFail)

emPure2 : a b -- EMonad(a) EMonad(b)
emPure2 = dip(emPure) emPure

emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
emPure3 = dip(emPure2) emPure

emMap(f: a -- b) : EMonad(a) -- EMonad(b)
emMap(f) = MkEMonad(emRun erMap(f))

emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
emMap2(f) =
  pack2 MkEMonad(
    unpack2
    dip(emRun) swap
    dip(emRun) swap
    erMap2(f)
  )

emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emMap3(f) = emMap2(pack2) emMap2(unpack2 f)

emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emMap4(f) = emMap2(pack2) emMap3(unpack2 f)

emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
emBind(f) =
  MkEMonad(
    emRun eresult(
      ERErr,
      dip(unit) EROk
      dip(f emRun)
      swap erMap2(nip)
    )
  )

emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emBind2(f) = emMap2(pack2) emBind(unpack2 f)

emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emBind3(f) = emMap3(pack3) emBind(unpack3 f)

emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emBind4(f) = emMap4(pack4) emBind(unpack4 f)

emThen(f: EMonad(b)) : EMonad(a) -- EMonad(b)
emThen(f) = emBind(drop f)

emThen2(f: EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emThen2(f) = emBind2(drop2 f)

emThen3(f: EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emThen3(f) = emBind3(drop3 f)

emThen4(f: EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emThen4(f) = emBind4(drop4 f)

emUnit : EMonad(Unit)
emUnit = unit emPure

emVoid : EMonad(a) -- EMonad(Unit)
emVoid = emMap(drop unit)

emVoid2 : EMonad(a) EMonad(b) -- EMonad(Unit)
emVoid2 = emMap2(drop2 unit)

emVoid3 : EMonad(a) EMonad(b) EMonad(c) -- EMonad(Unit)
emVoid3 = emMap3(drop3 unit)

emVoid4 : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(Unit)
emVoid4 = emMap4(drop4 unit)

###############
# Elaboration #
###############

data ESym
  MkESym : Pkg Mod Name -- ESym
end

data EParams
  MkEParams : EParams
end

unEParams : EParams --
unEParams = match(MkEParams -> id)

eparamsNil : EParams
eparamsNil = MkEParams

eparams->sexp : EParams -- Sexp
eparams->sexp = unEParams nil sexpList

data EEffect
  EEVar : Name -- EEffect
  EESym : ESym -- EEffect
  EENil : EEffect
end

data EStack
  ESVar : Name -- EStack
  ESNil : EStack
  ESCons : EStack EType -- EStack
end

data EType
  ETVar : Name -- EType
  ETSym : ESym List(EType) -- EType
end

data EWord
  EWId : EWord
  EWCp : EWord EWord -- EWord
  EWSwap : EWord
  EWDrop : EWord
  EWDup : EWord
  EWDip : EWord -- EWord
end


||| A type definition.
data ETypeDef
  MkETypeDef : EParams -- ETypeDef
end

unETypeDef : ETypeDef -- EParams
unETypeDef = match(MkETypeDef -> id)

etypedef->sexp : ETypeDef -- Sexp
etypedef->sexp = unETypeDef sexp1("type", eparams->sexp)

etypedefMerge : Name ETypeDef ETypeDef -- Name EMonad(ETypeDef)
etypedefMerge = drop emPure # TODO


||| A word definition.
data EWordDef
  MkEWordDef : EWordDef
end

unEWordDef : EWordDef --
unEWordDef = match(MkEWordDef -> id)

eworddef->sexp : EWordDef -- Sexp
eworddef->sexp = unEWordDef "word" sexpAtom

eworddefMerge : Name EWordDef EWordDef -- Name EMonad(EWordDef)
eworddefMerge = drop emPure # TODO


||| A definition.
data EDef
  EDType : ETypeDef -- EDef
  EDWord : EWordDef -- EDef
end

edef->sexp : EDef -- Sexp
edef->sexp =
  match(
    EDType -> etypedef->sexp,
    EDWord -> eworddef->sexp
  )

edefMerge : Name EDef EDef -- Name EMonad(EDef)
edefMerge =
  swap match(
    EDType ->
      swap match(
        EDType -> etypedefMerge emMap(EDType),
        EDWord -> drop2 "Cannot redefine word " over name->str <> " as type." <> emFail
      ),
    EDWord ->
      swap match(
        EDType -> drop2 "Cannot redefine type " over name->str <> " as word." <> emFail,
        EDWord -> eworddefMerge emMap(EDWord)
      )
    )




||| A set of definitions in a single scope.
data EDefs
  MkEDefs : Map(Name, EDef) -- EDefs
end

unEDefs : EDefs -- Map(Name, EDef)
unEDefs = match(MkEDefs -> id)

edefsNil : EDefs
edefsNil = mapNil MkEDefs

edefsGet : EDefs Name -- Maybe(EDef)
edefsGet = dip(unEDefs) mapGet

||| Set or overwrite a definition. Does not attempt to merge.
edefsSet : EDefs Name EDef -- EDefs
edefsSet = dip2(unEDefs) mapSet MkEDefs

edefsSingle : Name EDef -- EDefs
edefsSingle = dip2(edefsNil) edefsSet

||| Add a definition
edefsAdd : EDefs Name EDef -- EMonad(EDefs)
edefsAdd =
  dip2(unEDefs) dip(mapGet?) swap maybe(
    mapSet MkEDefs emPure,
    swap edefMerge dip(emPure2)
    emMap3(mapSet MkEDefs)
  )

edefsMerge : EDefs EDefs -- EMonad(EDefs)
edefsMerge = dip(emPure) unEDefs mapFor(emPure2 emBind3(edefsAdd))

edefs->sexp : EDefs -- Sexp
edefs->sexp = unEDefs map->sexp(name->sexp, edef->sexp)


||| A single interface.
data EInterface
  MkEInterface : Interface EDefs -- EInterface
end

unEInterface : EInterface -- Interface EDefs
unEInterface = match(MkEInterface -> id)

einterfaceNil : Interface -- EInterface
einterfaceNil = edefsNil MkEInterface

einterfaceInterface : EInterface -- Interface
einterfaceInterface = unEInterface drop

einterfaceDefs : EInterface -- EDefs
einterfaceDefs = unEInterface nip

einterfaceUseDefs(f: EDefs a -- EDefs b) : EInterface a -- EInterface b
einterfaceUseDefs(f) = dip(unEInterface) f dip(MkEInterface)

einterfaceGetDef : EInterface Name -- Maybe(EDef)
einterfaceGetDef = einterfaceUseDefs(dip(dup) edefsGet) nip

einterfaceAddDefs : EInterface EDefs -- EMonad(EInterface)
einterfaceAddDefs = dip(unEInterface dip(emPure)) edefsMerge emMap2(MkEInterface)

einterfaceAddDef : EInterface Name EDef -- EMonad(EInterface)
einterfaceAddDef = edefsSingle einterfaceAddDefs

||| Merge two interfaces. Assumes both interfaces have the same name.
einterfaceMerge : EInterface EInterface -- EMonad(EInterface)
einterfaceMerge = dip(unEInterface dip(emPure)) einterfaceDefs edefsMerge emMap2(MkEInterface)

einterface->sexp : EInterface -- Sexp
einterface->sexp = unEInterface sexp2("interface", interface->sexp, edefs->sexp)


||| A module's imports, i.e. a set of interfaces.
data EImports
  MkEImports : Set(Interface) -- EImports
end

unEImports : EImports -- Set(Interface)
unEImports = match(MkEImports -> id)

eimportsNil : EImports
eimportsNil = setNil MkEImports

eimportsAdd : EImports Interface -- EImports
eimportsAdd = dip(unEImports) setAdd MkEImports

eimportsHas : EImports Interface -- Bool
eimportsHas = dip(unEImports) setHas

eimports->sexp : EImports -- Sexp
eimports->sexp = unEImports set->sexp(interface->sexp)


||| A module's exports, i.e. a map of interface definitions.
data EExports
  MkEExports : Map(Interface, EInterface) -- EExports
end

unEExports : EExports -- Map(Interface, EInterface)
unEExports = match(MkEExports -> id)

eexportsNil : EExports
eexportsNil = mapNil MkEExports

eexportsAdd : EExports EInterface -- EMonad(EExports)
eexportsAdd =
  dip(unEExports) dup dip(einterfaceInterface mapGet?) swap maybe(
    mapSet MkEExports emPure,
    swap einterfaceMerge dip(emPure2) emMap3(mapSet MkEExports)
  )

eexportsMerge : EExports EExports -- EMonad(EExports)
eexportsMerge = dip(emPure) unEExports mapFor(nip emPure emBind2(eexportsAdd))

eexports->sexp : EExports -- Sexp
eexports->sexp = unEExports map->sexp(interface->sexp, einterface->sexp)


||| A single Mirth module.
data EModule
  MkEModule : Mod EImports EExports EDefs -- EModule
end

unEModule : EModule -- Mod EImports EExports EDefs
unEModule = match(MkEModule -> id)

emoduleMod : EModule -- Mod
emoduleMod = unEModule drop3

emoduleExports : EModule -- EExports
emoduleExports = unEModule drop dip(drop2)

emoduleUseImports(f: EImports a -- EImports b) : EModule a -- EModule b
emoduleUseImports(f) = dip(unEModule) dip2''(f) dip(MkEModule)

emoduleUseExports(f: EExports a -- EExports b) : EModule a -- EModule b
emoduleUseExports(f) = dip(unEModule) dip'(f) dip(MkEModule)

emoduleUseDefs(f: EDefs a -- EDefs b) : EModule a -- EModule b
emoduleUseDefs(f) = dip(unEModule) f dip(MkEModule)

emoduleGetDef : EModule Name -- Maybe(EDef)
emoduleGetDef = emoduleUseDefs(dip(dup) edefsGet) nip

emoduleAddDefs : EModule EDefs -- EMonad(EModule)
emoduleAddDefs = dip(unEModule dip(emPure3)) edefsMerge emMap4(MkEModule)

emoduleAddDef : EModule Name EDef -- EMonad(EModule)
emoduleAddDef = edefsSingle emoduleAddDefs

emoduleNil : Mod -- EModule
emoduleNil = eimportsNil eexportsNil edefsNil MkEModule

emoduleAddInterface : EModule EInterface -- EMonad(EModule)
emoduleAddInterface = $(
  dip(unEModule) tuck
  dip4(emPure2)
  dip2(eexportsAdd)
  einterfaceDefs edefsMerge
  emMap4(MkEModule)
)

emodule->sexp : EModule -- Sexp
emodule->sexp = unEModule sexp4("module", mod->sexp, eimports->sexp, eexports->sexp, edefs->sexp)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str


||| A Mirth package, i.e. a collection of modules and interfaces.
data EPackage
  MkEPackage : Pkg EExports Map(Mod, EModule) -- EPackage
end

unEPackage : EPackage -- Pkg EExports Map(Mod, EModule)
unEPackage = match(MkEPackage -> id)

epackageNil : Pkg -- EPackage
epackageNil = eexportsNil mapNil MkEPackage

epackage->sexp : EPackage -- Sexp
epackage->sexp = unEPackage nip sexp2("package", pkg->sexp, map->sexp(mod->sexp, emodule->sexp))

epackageAddModule : EPackage EModule -- EMonad(EPackage)
epackageAddModule = $(
  dip(unEPackage dip2(emPure))
  dup dip(emoduleExports swap dip(eexportsMerge))
  dup dip(emoduleMod) mapSet emPure
  emMap3(MkEPackage)
)


||| Elaboration World -- The collection of loaded packages and modules.
||| This should be unchanged during module elaboration.
data EWorld
  MkEWorld : Map(Pkg, EPackage) -- EWorld
end

unEWorld : EWorld -- Map(Pkg, EPackage)
unEWorld = match(MkEWorld -> id)

eworldNil : EWorld
eworldNil = mapNil MkEWorld


||| Elaboration Focus -- The current package/module/interface being
||| elaborated. This should be unchanged during expression elaboration.
data EFocus
  MkEFocus : Maybe(EPackage) Maybe(EModule) Maybe(EInterface) -- EFocus
end

unEFocus : EFocus -- Maybe(EPackage) Maybe(EModule) Maybe(EInterface)
unEFocus = match(MkEFocus -> id)

efocusNil : EFocus
efocusNil = none none none MkEFocus

efocusGetDef : EFocus Name -- Maybe(EDef)
efocusGetDef =
  swap unEFocus dip2(drop) maybe(
    maybe(drop none, swap emoduleGetDef),
    nip swap einterfaceGetDef
  )

efocusAddDefs : EFocus EDefs -- EMonad(EFocus)
efocusAddDefs = $(
  dip(unEFocus dip2(emPure))
  swap maybe(
    swap maybe(
      drop2 "Compiler Error: efocusAddDefs: Not in module or interface." emFail,
      swap emoduleAddDefs emMap2(some none MkEFocus)
    ),
    swap einterfaceAddDefs dip(emPure) emMap3(some MkEFocus)
  )
)

efocusAddDef : EFocus Name EDef -- EMonad(EFocus)
efocusAddDef = edefsSingle efocusAddDefs

||| Create an empty package focus for a Pkg.
efocusNilPkg : Pkg -- EFocus
efocusNilPkg = epackageNil some none none MkEFocus

||| Create an empty module focus for a Mod, for testing purposes.
efocusNilMod : Mod -- EFocus
efocusNilMod =  dip(none) emoduleNil some none MkEFocus

efocusUsePackage(f: Maybe(EPackage) a -- Maybe(EPackage) b) : EFocus a -- EFocus b
efocusUseModule(f: Maybe(EModule) a -- Maybe(EModule) b) : EFocus a -- EFocus b
efocusUseInterface(f: Maybe(EInterface) a -- Maybe(EInterface) b) : EFocus a -- EFocus b

efocusUsePackage(f) = dip(unEFocus) dip2''(f) dip(MkEFocus)
efocusUseModule(f) = dip(unEFocus) dip'(f) dip(MkEFocus)
efocusUseInterface(f) = dip(unEFocus) f dip(MkEFocus)

||| Additional info associated with a binding.
data EMeta(t)
  ||| Binding represents a rigid variable, i.e. we can't instantiate
  ||| during unification. The Bool controls whether the variable
  ||| was passed implicitly or explicitly.
  EMRigid : Bool -- EMeta(t)

  ||| Binding represents a plastic variable, i.e. we can instantiate
  ||| it once during unification. The Maybe(t) represents the value
  ||| it was instantiated to, if it was, and Set(Name) represents
  ||| the set of rigid free variables that are allowed in the
  ||| instantiated value
  EMPlastic : Set(Name) Maybe(t) -- EMeta(t)
end

emetaIsRigid : EMeta(t) -- Bool
emetaIsRigid =
  match(
    EMRigid -> drop true,
    EMPlastic -> drop2 false
  )

data EBind
  EBStack : EMeta(EStack) -- EBind
  EBType : EMeta(EType) -- EBind
  EBEffect : EMeta(EEffect) -- EBind
  EBWord : EStack EStack EEffect EMeta(EWord) -- EBind
end

ebindIsRigid : EBind -- Bool
ebindIsRigid =
  match(
    EBStack -> emetaIsRigid,
    EBType -> emetaIsRigid,
    EBEffect -> emetaIsRigid,
    EBWord -> dip(drop3) emetaIsRigid
  )

ebindIsPlastic : EBind -- Bool
ebindIsPlastic = ebindIsRigid not


data EBinds
  MkEBinds : Map(Name, EBind) -- EBinds
end

unEBinds : EBinds -- Map(Name, EBind)
unEBinds = match(MkEBinds -> id)

ebindsNil : EBinds
ebindsNil = mapNil MkEBinds

ebindsGet : EBinds Name -- Maybe(EBind)
ebindsGet = dip(unEBinds) mapGet

ebindsSet : EBinds Name EBind -- EBinds
ebindsSet = dip2(unEBinds) mapSet MkEBinds


||| Local Scope
data ECtx
  MkECtx : EBinds Maybe(EStack) -- ECtx
end

unECtx : ECtx -- EBinds Maybe(EStack)
unECtx = match(MkECtx -> id)

ectxNil : ECtx
ectxNil = ebindsNil none MkECtx

ectxNilWithImplicits : ECtx
ectxNilWithImplicits = ectxNil # TODO

ectxUseBinds(f: EBinds a -- EBinds b) : ECtx a -- ECtx b
ectxUseBinds(f) = dip(unECtx) dip'(f) dip(MkECtx)

ectxUseStack(f: Maybe(EStack) a -- Maybe(EStack) b) : ECtx a -- ECtx b
ectxUseStack(f) = dip(unECtx) f dip(MkECtx)

ectxVars : ECtx -- Set(Name)
ectxVars = unECtx drop unEBinds mapKeys

||| Environment -- The current scope and metavariables.
data ELocal
  MkELocal : ECtx LocSet Nat -- ELocal
end

unELocal : ELocal -- ECtx LocSet Nat
unELocal = match(MkELocal -> id)

elocalNil : ELocal
elocalNil =  ectxNil locSetNull n0 MkELocal

elocalFreshNat : ELocal -- ELocal Nat
elocalFreshNat = unELocal dup dip(n1+ pnat MkELocal)

elocalUseCtx(f: ECtx a -- ECtx b) : ELocal a -- ELocal b
elocalUseCtx(f) = dip(unELocal) dip2''(f) dip(MkELocal)

elocalUseLoc(f: LocSet a -- LocSet b) : ELocal a -- ELocal b
elocalUseLoc(f) = dip(unELocal) dip'(f) dip(MkELocal)



||| Elaboration Environment
data EEnv
  MkEEnv : EWorld EFocus ELocal -- EEnv
end

unEEnv : EEnv -- EWorld EFocus ELocal
unEEnv = match(MkEEnv -> id)

eenvNil : EEnv
eenvNil = eworldNil efocusNil elocalNil MkEEnv

eenvUseWorld(f: EWorld a -- EWorld b) : EEnv a -- EEnv b
eenvUseWorld(f) = dip(unEEnv) dip2''(f) dip(MkEEnv)

eenvUseFocus(f: EFocus a -- EFocus b) : EEnv a -- EEnv b
eenvUseFocus(f) = dip(unEEnv) dip'(f) dip(MkEEnv)

eenvUseLocal(f: ELocal a -- ELocal b) : EEnv a -- EEnv b
eenvUseLocal(f) = dip(unEEnv) f dip(MkEEnv)

eenvFreshNat : EEnv -- EEnv Nat
eenvFreshNat = unit eenvUseLocal(drop elocalFreshNat)

emFreshNat : EMonad(Nat)
emFreshNat = emGet(eenvFreshNat)

emFreshName : EMonad(Name)
emFreshName = emFreshNat emMap(dip("?") nat->str <> mkName)

emGetCtx : EMonad(ECtx)
emGetCtx = unit emUse(eenvUseLocal(elocalUseCtx(drop dup)))

emGetBind : Name -- EMonad(Maybe(EBind))
emGetBind = emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(dip(dup) ebindsGet))))

emSetBind : Name EBind -- EMonad(Unit)
emSetBind = pack2 emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(unpack2 ebindsSet unit))))

emFreshType : EMonad(EType)
emFreshType = $(
  emFreshName emGetCtx
  emBind2(
    dip(dup)
    dip2(ETVar emPure)
    ectxVars none EMPlastic EBType emSetBind
    emMap2(drop)
  )
)


emFor(f: a b -- EMonad(a)) : a List(b) -- EMonad(a)
emFor(f) = lmatchL(emPure, dip(f) emPure emBind2(emFor(f)))

emForB(f: a b -- EMonad(a)) : EMonad(a) List(b) -- EMonad(a)
emForB(f) = emPure emBind2(emFor(f))

emList(f: a -- EMonad(b)) : List(a) -- EMonad(List(b))
emList(f) = dip(nil) emFor(dip(emPure) f emMap2(consR))

emFor_(f: a -- EMonad(Unit)) : List(a) -- EMonad(Unit)
emFor_(f) = dip(unit emPure) for(f emVoid2)

elabL(f: a -- EMonad(b)) : L(a) -- EMonad(b)
elabL(f) = getL f # TODO: Keep track of current location within EEnv.

elabL2(f: a b -- EMonad(c)) : a L(b) -- EMonad(c)
elabL2(f) = unL dip(swap) pack2 mkL elabL(unpack2 f)

elabL3(f: a b c -- EMonad(d)) : a b L(c) -- EMonad(d)
elabL3(f) = unL dip(rotr) pack3 mkL elabL(unpack3 f)

emGetFocus : EMonad(EFocus)
emGetFocus = unit emUse(eenvUseFocus(drop dup))

emSetFocus : EFocus -- EMonad(Unit)
emSetFocus = emUse(eenvUseFocus(nip unit))

emGetFocusPackage : EMonad(EPackage)
emGetFocusPackage = $(
  unit emUse(eenvUseFocus(efocusUsePackage(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusPackage: Not in package." emFail,
    emPure
  ))
)

emGetFocusModule : EMonad(EModule)
emGetFocusModule = $(
  unit emUse(eenvUseFocus(efocusUseModule(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusModule: Not in module." emFail,
    emPure
  ))
)

emGetFocusInterface : EMonad(EInterface)
emGetFocusInterface = $(
  unit emUse(eenvUseFocus(efocusUseInterface(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusInterface: Not in module." emFail,
    emPure
  ))
)

emSetFocusPackage : EPackage -- EMonad(Unit)
emSetFocusPackage = emUse(eenvUseFocus(efocusUsePackage(nip some unit)))

emSetFocusModule : EModule -- EMonad(Unit)
emSetFocusModule = emUse(eenvUseFocus(efocusUseModule(nip some unit)))

emSetFocusInterface : EInterface -- EMonad(Unit)
emSetFocusInterface = emUse(eenvUseFocus(efocusUseInterface(nip some unit)))

emDropFocusPackage : EMonad(Unit)
emDropFocusPackage = unit emUse(eenvUseFocus(efocusUsePackage(dip(drop none))))

emDropFocusModule : EMonad(Unit)
emDropFocusModule = unit emUse(eenvUseFocus(efocusUseModule(dip(drop none))))

emDropFocusInterface : EMonad(Unit)
emDropFocusInterface = unit emUse(eenvUseFocus(efocusUseInterface(dip(drop none))))

emSaveFocusModule : EMonad(Unit)
emSaveFocusModule = $(
  emGetFocusPackage emGetFocusModule
  emBind2(epackageAddModule) emBind(emSetFocusPackage)
  emThen(emDropFocusModule)
)

emSaveFocusInterface : EMonad(Unit)
emSaveFocusInterface = $(
  emGetFocusModule emGetFocusInterface
  emBind2(emoduleAddInterface) emBind(emSetFocusModule)
  emThen(emDropFocusInterface)
)


emSetCtx : ECtx -- EMonad(Unit)
emSetCtx = emUse(eenvUseLocal(elocalUseCtx(nip unit)))

emGetDef : Name -- EMonad(Maybe(EDef))
emGetDef = emUse(eenvUseFocus(dip(dup) efocusGetDef))

emAddDefs : EDefs -- EMonad(Unit)
emAddDefs = dip(emGetFocus) emPure emBind2(efocusAddDefs) emBind(emSetFocus)

emAddDef : Name EDef -- EMonad(Unit)
emAddDef = edefsSingle emAddDefs

elabLModuleHead : Mod L(Module) -- EMonad(Unit)
elabLModule : Mod L(Module) -- EMonad(Unit)
elabLImport : L(Import) -- EMonad(Unit)
elabLExport : L(Export) -- EMonad(Unit)
elabLSig : L(Sig) -- EMonad(Unit)
elabLDecl : L(Decl) -- EMonad(Unit)
elabLTypeSig : L(TypeSig) -- EMonad(Unit)
elabLDataDef : L(DataDef) -- EMonad(Unit)
elabLWordSig : L(WordSig) -- EMonad(Unit)
elabLWordDef : L(WordDef) -- EMonad(Unit)
elabLAssertion : L(Assertion) -- EMonad(Unit)

elabLParams : L(Params) -- EMonad(EParams)

elabPackage : Pkg Map(Mod, L(Module)) -- EMonad(Unit)
elabModuleHead : Mod Module -- EMonad(Unit)
elabModule : Mod Module -- EMonad(Unit)
elabImport : Import -- EMonad(Unit)
elabExport : Export -- EMonad(Unit)
elabSig : Sig -- EMonad(Unit)
elabDecl : Decl -- EMonad(Unit)
elabTypeSig : TypeSig -- EMonad(Unit)
elabDataDef : DataDef -- EMonad(Unit)
elabWordSig : WordSig -- EMonad(Unit)
elabWordDef : WordDef -- EMonad(Unit)
elabAssertion : Assertion -- EMonad(Unit)

elabParams : Params -- EMonad(EParams)

elabLModuleHead = elabL2(elabModule)
elabLModule = elabL2(elabModule)
elabLImport = elabL(elabImport)
elabLExport = elabL(elabExport)
elabLDecl = elabL(elabDecl)
elabLSig = elabL(elabSig)
elabLTypeSig = elabL(elabTypeSig)
elabLDataDef = elabL(elabDataDef)
elabLWordSig = elabL(elabWordSig)
elabLWordDef = elabL(elabWordDef)
elabLAssertion = elabL(elabAssertion)
elabLParams = elabL(elabParams)

elabPackage = $(
  dip(epackageNil emSetFocusPackage emDropFocusModule emDropFocusInterface emVoid3)
  dup dip(mapFor(elabLModuleHead emSaveFocusModule emVoid3))
  mapFor(elabLModule emSaveFocusModule emVoid3)
)

elabModuleHead = $(
  dip(emoduleNil emSetFocusModule)
  unModule drop
  dip(getL emFor_(elabLImport))
  getL emFor_(elabLExport emSaveFocusInterface emVoid2)
  emDropFocusInterface
  emVoid4
)

elabModule = $(
  dip(emoduleNil emSetFocusModule)
  unModule
  dip2(getL emFor_(elabLImport))
  dip(getL emFor_(elabLExport emSaveFocusInterface emVoid2))
  getL emFor_(elabLDecl)
  emVoid4
)

elabImport = unImport elabL(
  dip(emGetFocusModule) emPure
  emBind2(emoduleUseImports(eimportsAdd unit) drop emSetFocusModule)
)

elabExport = $(
  dup dip(exportInterface getL einterfaceNil emSetFocusInterface)
  exportSigs emFor_(elabLSig)
  emVoid2
)

elabDecl =
  matchDecl(
    elabLTypeSig,
    elabLDataDef,
    elabLWordSig,
    elabLWordDef,
    elabLAssertion
  )

elabSig =
  matchSig(
    elabLTypeSig,
    elabLWordSig,
    elabLAssertion
  )

emWith(f: a -- EMonad(b), getX : EMonad(x), setX : x -- EMonad(Unit)) : a x -- EMonad(b)
emWith(f, getX, setX) = $(
  dip(f getX) setX rotl
  emBind3(nip dip(setX) emPure emMap2(nip))
)

emWithCtx(f: a -- EMonad(b)) : a ECtx -- EMonad(b)
emWithCtx(f) = emWith(f, emGetCtx, emSetCtx)

elabTypeSig = $(
  dup dip(typeSigName getL emPure)
  ectxNilWithImplicits emWithCtx(typeSigParams elabLParams)
  emBind2(MkETypeDef EDType emAddDef)
)

elabDataDef = drop emUnit
elabWordSig = drop emUnit
elabWordDef = drop emUnit
elabAssertion = drop emUnit

elabParams = drop MkEParams emPure # TODO

runElabModule : Mod L(Module) -- EResult(EModule)
runElabModule = $(
  elabLModule emThen(emGetFocusModule)
  dip(eenvNil) emRun nip
)

runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)
runElabPackage = $(
  elabPackage emThen(emGetFocusPackage)
  dip(eenvNil) emRun nip
)

