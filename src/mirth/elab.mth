
import base/unit
import base/maybe
import base/result
import base/list
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax

export mirth/elab
  type Map(k,v)
  type Result(a,b)

  type EEnv
  type EError
  type EMonad(t)

  type ESym
  type ETerm
  type EEffect
  type EStack
  type EType
  type EKind
  type EBind
  type ECtx
  type EParams
  type EDefs
  type EInterface
  type EModule
  type EPackage


  emRun : EEnv EMonad(t) -- EEnv Result(EError,t)
  emFail : Str -- EMonad(a)
  emPure : a -- EMonad(a)
  emPure2 : a b -- EMonad(a) EMonad(b)
  emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
  emMap(f: a -- b) : EMonad(a) -- EMonad(b)
  emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
  emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
  emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emThen(f: EMonad(b)) : EMonad(a) -- EMonad(b)
  emThen2(f: EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emThen3(f: EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emThen4(f: EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)


  runElabModule : Mod L(Module) -- Result(EError, EModule)
  runElabPackage : Pkg Map(Mod, L(Module)) -- Result(EError, EPackage)

  eerror->str : EError -- Str
  emodule->str : EModule -- Str

end

||| Elaborator error.
data EError
  MkEError : Str -- EError
end

unEError : EError -- Str
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError

||| Elaboration monad.
data EMonad(t)
  MkEMonad(f: EEnv m -- EEnv Result(EError, t)) : m -- EMonad(t)
end

emUse(f: EEnv a -- EEnv b) : a -- EMonad(b)
emUse(f) = MkEMonad(f ok)

emGet(f: EEnv -- EEnv b) : EMonad(b)
emGet(f) = unit emUse(drop f)

emPut(f: EEnv t -- EEnv) : t -- EMonad(Unit)
emPut(f) = emUse(f unit)

emRun : EEnv EMonad(t) -- EEnv Result(EError, t)
emRun = match(MkEMonad(f) -> f)

emPure : a -- EMonad(a)
emPure = MkEMonad(ok)

emFail : Str -- EMonad(a)
emFail = MkEMonad(MkEError err)

emPure2 : a b -- EMonad(a) EMonad(b)
emPure2 = dip(emPure) emPure

emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
emPure3 = dip(emPure2) emPure

emMap(f: a -- b) : EMonad(a) -- EMonad(b)
emMap(f) = MkEMonad(emRun rmap(f))

emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
emMap2(f) =
  pack2 MkEMonad(
    unpack2 dip(emRun) swap
    result(nip err,
      dip(emRun) swap
      result(nip err, f ok)
    )
  )

emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emMap3(f) = emMap2(pack2) emMap2(unpack2 f)

emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emMap4(f) = emMap2(pack2) emMap3(unpack2 f)

emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
emBind(f) = MkEMonad(emRun result(err, f emRun))

emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emBind2(f) = emMap2(pack2) emBind(unpack2 f)

emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emBind3(f) = emMap3(pack3) emBind(unpack3 f)

emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emBind4(f) = emMap4(pack4) emBind(unpack4 f)

emThen(f: EMonad(b)) : EMonad(a) -- EMonad(b)
emThen(f) = emBind(drop f)

emThen2(f: EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emThen2(f) = emBind2(drop2 f)

emThen3(f: EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emThen3(f) = emBind3(drop3 f)

emThen4(f: EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emThen4(f) = emBind4(drop4 f)

emUnit : EMonad(Unit)
emUnit = unit emPure

emVoid : EMonad(a) -- EMonad(Unit)
emVoid = emMap(drop unit)

emVoid2 : EMonad(a) EMonad(b) -- EMonad(Unit)
emVoid2 = emMap2(drop2 unit)

emVoid3 : EMonad(a) EMonad(b) EMonad(c) -- EMonad(Unit)
emVoid3 = emMap3(drop3 unit)

emVoid4 : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(Unit)
emVoid4 = emMap4(drop4 unit)

###############
# Elaboration #
###############

data ESym
  MkESym : Pkg Mod Name -- ESym
end

data EParams
  MkEParams : EParams
end

unEParams : EParams --
unEParams = match(MkEParams -> id)

eparamsNil : EParams
eparamsNil = MkEParams

eparams->sexp : EParams -- Sexp
eparams->sexp = unEParams nil sexpList

data EEffect
  EEVar : Name -- EEffect
  EESym : ESym -- EEffect
  EENil : EEffect
end

data EStack
  ESVar : Name -- EStack
  ESNil : EStack
  ESCons : EStack EType -- EStack
end

data EType
  ETVar : Name -- EType
  ETSym : ESym List(EType) -- EType
end

data EWord
  EWId : EWord
  EWCp : EWord EWord -- EWord
  EWSwap : EWord
  EWDrop : EWord
  EWDup : EWord
  EWDip : EWord -- EWord
end


||| A type definition.
data ETypeDef
  MkETypeDef : EParams -- ETypeDef
end

unETypeDef : ETypeDef -- EParams
unETypeDef = match(MkETypeDef -> id)

etypedef->sexp : ETypeDef -- Sexp
etypedef->sexp = unETypeDef sexp1("type", eparams->sexp)


||| A word definition.
data EWordDef
  MkEWordDef : EWordDef
end

unEWordDef : EWordDef --
unEWordDef = match(MkEWordDef -> id)

eworddef->sexp : EWordDef -- Sexp
eworddef->sexp = unEWordDef "word" sexpAtom


||| A definition.
data EDef
  EDType : ETypeDef -- EDef
  EDWord : EWordDef -- EDef
end

edef->sexp : EDef -- Sexp
edef->sexp =
  match(
    EDType -> etypedef->sexp,
    EDWord -> eworddef->sexp
  )


||| A set of definitions in a single scope.
data EDefs
  MkEDefs : Map(Name, EDef) -- EDefs
end

unEDefs : EDefs -- Map(Name, EDef)
unEDefs = match(MkEDefs -> id)

edefsNil : EDefs
edefsNil = mapNil MkEDefs

edefsGet : EDefs Name -- Maybe(EDef)
edefsGet = dip(unEDefs) mapGet

edefsSet : EDefs Name EDef -- EDefs
edefsSet = dip2(unEDefs) mapSet MkEDefs

edefs->sexp : EDefs -- Sexp
edefs->sexp = unEDefs map->sexp(name->sexp, edef->sexp)


||| A single interface.
data EInterface
  MkEInterface : Interface EDefs -- EInterface
end

unEInterface : EInterface -- Interface EDefs
unEInterface = match(MkEInterface -> id)

einterfaceNil : Interface -- EInterface
einterfaceNil = edefsNil MkEInterface

einterfaceInterface : EInterface -- Interface
einterfaceInterface = unEInterface drop

einterfaceUseDefs(f: EDefs a -- EDefs b) : EInterface a -- EInterface b
einterfaceUseDefs(f) = dip(unEInterface) f dip(MkEInterface)

einterfaceGetDef : EInterface Name -- Maybe(EDef)
einterfaceGetDef = einterfaceUseDefs(dip(dup) edefsGet) nip

einterfaceSetDef : EInterface Name EDef -- EInterface
einterfaceSetDef = pack2 einterfaceUseDefs(unpack2 edefsSet unit) drop

einterface->sexp : EInterface -- Sexp
einterface->sexp = unEInterface sexp2("interface", interface->sexp, edefs->sexp)


||| A module's imports, i.e. a set of interfaces.
data EImports
  MkEImports : Set(Interface) -- EImports
end

unEImports : EImports -- Set(Interface)
unEImports = match(MkEImports -> id)

eimportsNil : EImports
eimportsNil = setNil MkEImports

eimportsAdd : EImports Interface -- EImports
eimportsAdd = dip(unEImports) setAdd MkEImports

eimportsHas : EImports Interface -- Bool
eimportsHas = dip(unEImports) setHas

eimports->sexp : EImports -- Sexp
eimports->sexp = unEImports set->sexp(interface->sexp)


||| A module's exports, i.e. a map of interface definitions.
data EExports
  MkEExports : Map(Interface, EInterface) -- EExports
end

unEExports : EExports -- Map(Interface, EInterface)
unEExports = match(MkEExports -> id)

eexportsNil : EExports
eexportsNil = mapNil MkEExports

eexportsMerge : EExports EExports -- EExports
eexportsMerge = dip(unEExports) unEExports mapFor(mapSet) MkEExports
  # TODO merge gracefully

eexportsAdd : EExports EInterface -- EExports
eexportsAdd = dip(unEExports) dup dip(einterfaceInterface) mapSet MkEExports

eexports->sexp : EExports -- Sexp
eexports->sexp = unEExports map->sexp(interface->sexp, einterface->sexp)


||| A single Mirth module.
data EModule
  MkEModule : Mod EImports EExports EDefs -- EModule
end

unEModule : EModule -- Mod EImports EExports EDefs
unEModule = match(MkEModule -> id)

emoduleMod : EModule -- Mod
emoduleMod = unEModule drop3

emoduleExports : EModule -- EExports
emoduleExports = unEModule drop dip(drop2)

emoduleUseImports(f: EImports a -- EImports b) : EModule a -- EModule b
emoduleUseImports(f) = dip(unEModule) dip2''(f) dip(MkEModule)

emoduleUseExports(f: EExports a -- EExports b) : EModule a -- EModule b
emoduleUseExports(f) = dip(unEModule) dip'(f) dip(MkEModule)

emoduleUseDefs(f: EDefs a -- EDefs b) : EModule a -- EModule b
emoduleUseDefs(f) = dip(unEModule) f dip(MkEModule)

emoduleGetDef : EModule Name -- Maybe(EDef)
emoduleGetDef = emoduleUseDefs(dip(dup) edefsGet) nip

emoduleSetDef : EModule Name EDef -- EModule
emoduleSetDef = pack2 emoduleUseDefs(unpack2 edefsSet unit) drop

emoduleNil : Mod -- EModule
emoduleNil = eimportsNil eexportsNil edefsNil MkEModule

emoduleAddInterface : EModule EInterface -- EModule
emoduleAddInterface = emoduleUseExports(eexportsAdd unit) drop

emodule->sexp : EModule -- Sexp
emodule->sexp = unEModule sexp4("module", mod->sexp, eimports->sexp, eexports->sexp, edefs->sexp)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str


||| A Mirth package, i.e. a collection of modules and interfaces.
data EPackage
  MkEPackage : Pkg EExports Map(Mod, EModule) -- EPackage
end

unEPackage : EPackage -- Pkg EExports Map(Mod, EModule)
unEPackage = match(MkEPackage -> id)

epackageNil : Pkg -- EPackage
epackageNil = eexportsNil mapNil MkEPackage

epackage->sexp : EPackage -- Sexp
epackage->sexp = unEPackage nip sexp2("package", pkg->sexp, map->sexp(mod->sexp, emodule->sexp))

epackageAddModule : EPackage EModule -- EPackage
epackageAddModule = $(
  dip(unEPackage)
  dup dip(emoduleExports swap dip(eexportsMerge))
  dup dip(emoduleMod) mapSet
  MkEPackage
)


||| Elaboration World -- The collection of loaded packages and modules.
||| This should be unchanged during module elaboration.
data EWorld
  MkEWorld : Map(Pkg, EPackage) -- EWorld
end

unEWorld : EWorld -- Map(Pkg, EPackage)
unEWorld = match(MkEWorld -> id)

eworldNil : EWorld
eworldNil = mapNil MkEWorld


||| Elaboration Focus -- The current package/module/interface being
||| elaborated. This should be unchanged during expression elaboration.
data EFocus
  MkEFocus : Maybe(EPackage) Maybe(EModule) Maybe(EInterface) -- EFocus
end

unEFocus : EFocus -- Maybe(EPackage) Maybe(EModule) Maybe(EInterface)
unEFocus = match(MkEFocus -> id)

efocusNil : EFocus
efocusNil = none none none MkEFocus

efocusGetDef : EFocus Name -- Maybe(EDef)
efocusGetDef =
  swap unEFocus dip2(drop) maybe(
    maybe(drop none, swap emoduleGetDef),
    nip swap einterfaceGetDef
  )

||| Set def. If impossible, returns original EFocus and some error.
efocusSetDef : EFocus Name EDef -- EFocus Maybe(Str)
efocusSetDef =
  dip2(unEFocus) rotl maybe(
    rotl maybe(
      drop2 none none MkEFocus "Compiler Error: efocusSetDef: Not in module or interface." some,
      rotr emoduleSetDef some none MkEFocus none
    ),
    rotr einterfaceSetDef some MkEFocus none
  )


||| Create an empty package focus for a Pkg.
efocusNilPkg : Pkg -- EFocus
efocusNilPkg = epackageNil some none none MkEFocus

||| Create an empty module focus for a Mod, for testing purposes.
efocusNilMod : Mod -- EFocus
efocusNilMod =  dip(none) emoduleNil some none MkEFocus

efocusUsePackage(f: Maybe(EPackage) a -- Maybe(EPackage) b) : EFocus a -- EFocus b
efocusUseModule(f: Maybe(EModule) a -- Maybe(EModule) b) : EFocus a -- EFocus b
efocusUseInterface(f: Maybe(EInterface) a -- Maybe(EInterface) b) : EFocus a -- EFocus b

efocusUsePackage(f) = dip(unEFocus) dip2''(f) dip(MkEFocus)
efocusUseModule(f) = dip(unEFocus) dip'(f) dip(MkEFocus)
efocusUseInterface(f) = dip(unEFocus) f dip(MkEFocus)

||| Additional info associated with a binding.
data EMeta(t)
  ||| Binding represents a rigid variable, i.e. we can't instantiate
  ||| during unification. The Bool controls whether the variable
  ||| was passed implicitly or explicitly.
  EMRigid : Bool -- EMeta(t)

  ||| Binding represents a plastic variable, i.e. we can instantiate
  ||| it once during unification. The Maybe(t) represents the value
  ||| it was instantiated to, if it was, and Set(Name) represents
  ||| the set of rigid free variables that are allowed in the
  ||| instantiated value
  EMPlastic : Set(Name) Maybe(t) -- EMeta(t)
end

emetaIsRigid : EMeta(t) -- Bool
emetaIsRigid =
  match(
    EMRigid -> drop true,
    EMPlastic -> drop2 false
  )

data EBind
  EBStack : EMeta(EStack) -- EBind
  EBType : EMeta(EType) -- EBind
  EBEffect : EMeta(EEffect) -- EBind
  EBWord : EStack EStack EEffect EMeta(EWord) -- EBind
end

ebindIsRigid : EBind -- Bool
ebindIsRigid =
  match(
    EBStack -> emetaIsRigid,
    EBType -> emetaIsRigid,
    EBEffect -> emetaIsRigid,
    EBWord -> dip(drop3) emetaIsRigid
  )

ebindIsPlastic : EBind -- Bool
ebindIsPlastic = ebindIsRigid not


data EBinds
  MkEBinds : Map(Name, EBind) -- EBinds
end

unEBinds : EBinds -- Map(Name, EBind)
unEBinds = match(MkEBinds -> id)

ebindsNil : EBinds
ebindsNil = mapNil MkEBinds

ebindsGet : EBinds Name -- Maybe(EBind)
ebindsGet = dip(unEBinds) mapGet

ebindsSet : EBinds Name EBind -- EBinds
ebindsSet = dip2(unEBinds) mapSet MkEBinds


||| Local Scope
data ECtx
  MkECtx : EBinds Maybe(EStack) -- ECtx
end

unECtx : ECtx -- EBinds Maybe(EStack)
unECtx = match(MkECtx -> id)

ectxNil : ECtx
ectxNil = ebindsNil none MkECtx

ectxNilWithImplicits : ECtx
ectxNilWithImplicits = ectxNil # TODO

ectxUseBinds(f: EBinds a -- EBinds b) : ECtx a -- ECtx b
ectxUseBinds(f) = dip(unECtx) dip'(f) dip(MkECtx)

ectxUseStack(f: Maybe(EStack) a -- Maybe(EStack) b) : ECtx a -- ECtx b
ectxUseStack(f) = dip(unECtx) f dip(MkECtx)

ectxVars : ECtx -- Set(Name)
ectxVars = unECtx drop unEBinds mapKeys

||| Environment -- The current scope and metavariables.
data ELocal
  MkELocal : ECtx LocSet Nat -- ELocal
end

unELocal : ELocal -- ECtx LocSet Nat
unELocal = match(MkELocal -> id)

elocalNil : ELocal
elocalNil =  ectxNil locSetNull n0 MkELocal

elocalFreshNat : ELocal -- ELocal Nat
elocalFreshNat = unELocal dup dip(n1+ pnat MkELocal)

elocalUseCtx(f: ECtx a -- ECtx b) : ELocal a -- ELocal b
elocalUseCtx(f) = dip(unELocal) dip2''(f) dip(MkELocal)

elocalUseLoc(f: LocSet a -- LocSet b) : ELocal a -- ELocal b
elocalUseLoc(f) = dip(unELocal) dip'(f) dip(MkELocal)



||| Elaboration Environment
data EEnv
  MkEEnv : EWorld EFocus ELocal -- EEnv
end

unEEnv : EEnv -- EWorld EFocus ELocal
unEEnv = match(MkEEnv -> id)

eenvNil : EEnv
eenvNil = eworldNil efocusNil elocalNil MkEEnv

eenvUseWorld(f: EWorld a -- EWorld b) : EEnv a -- EEnv b
eenvUseWorld(f) = dip(unEEnv) dip2''(f) dip(MkEEnv)

eenvUseFocus(f: EFocus a -- EFocus b) : EEnv a -- EEnv b
eenvUseFocus(f) = dip(unEEnv) dip'(f) dip(MkEEnv)

eenvUseLocal(f: ELocal a -- ELocal b) : EEnv a -- EEnv b
eenvUseLocal(f) = dip(unEEnv) f dip(MkEEnv)

eenvFreshNat : EEnv -- EEnv Nat
eenvFreshNat = unit eenvUseLocal(drop elocalFreshNat)

emFreshNat : EMonad(Nat)
emFreshNat = emGet(eenvFreshNat)

emFreshName : EMonad(Name)
emFreshName = emFreshNat emMap(dip("?") nat->str <> mkName)

emGetCtx : EMonad(ECtx)
emGetCtx = unit emUse(eenvUseLocal(elocalUseCtx(drop dup)))

emGetBind : Name -- EMonad(Maybe(EBind))
emGetBind = emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(dip(dup) ebindsGet))))

emSetBind : Name EBind -- EMonad(Unit)
emSetBind = pack2 emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(unpack2 ebindsSet unit))))

emFreshType : EMonad(EType)
emFreshType = $(
  emFreshName emGetCtx
  emBind2(
    dip(dup)
    dip2(ETVar emPure)
    ectxVars none EMPlastic EBType emSetBind
    emMap2(drop)
  )
)


emFor(f: a b -- EMonad(a)) : a List(b) -- EMonad(a)
emFor(f) = lmatchL(emPure, dip(f) emPure emBind2(emFor(f)))

emForB(f: a b -- EMonad(a)) : EMonad(a) List(b) -- EMonad(a)
emForB(f) = emPure emBind2(emFor(f))

emList(f: a -- EMonad(b)) : List(a) -- EMonad(List(b))
emList(f) = dip(nil) emFor(dip(emPure) f emMap2(consR))

emFor_(f: a -- EMonad(Unit)) : List(a) -- EMonad(Unit)
emFor_(f) = dip(unit emPure) for(f emVoid2)

elabL(f: a -- EMonad(b)) : L(a) -- EMonad(b)
elabL(f) = getL f # TODO: Keep track of current location within EEnv.

elabL2(f: a b -- EMonad(c)) : a L(b) -- EMonad(c)
elabL2(f) = unL dip(swap) pack2 mkL elabL(unpack2 f)

elabL3(f: a b c -- EMonad(d)) : a b L(c) -- EMonad(d)
elabL3(f) = unL dip(rotr) pack3 mkL elabL(unpack3 f)

emGetFocus : EMonad(EFocus)
emGetFocus = unit emUse(eenvUseFocus(drop dup))

emSetFocus : EFocus -- EMonad(Unit)
emSetFocus = emUse(eenvUseFocus(nip unit))

emGetFocusPackage : EMonad(EPackage)
emGetFocusPackage = $(
  unit emUse(eenvUseFocus(efocusUsePackage(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusPackage: Not in package." emFail,
    emPure
  ))
)

emGetFocusModule : EMonad(EModule)
emGetFocusModule = $(
  unit emUse(eenvUseFocus(efocusUseModule(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusModule: Not in module." emFail,
    emPure
  ))
)

emGetFocusInterface : EMonad(EInterface)
emGetFocusInterface = $(
  unit emUse(eenvUseFocus(efocusUseInterface(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusInterface: Not in module." emFail,
    emPure
  ))
)

emSetFocusPackage : EPackage -- EMonad(Unit)
emSetFocusPackage = emUse(eenvUseFocus(efocusUsePackage(nip some unit)))

emSetFocusModule : EModule -- EMonad(Unit)
emSetFocusModule = emUse(eenvUseFocus(efocusUseModule(nip some unit)))

emSetFocusInterface : EInterface -- EMonad(Unit)
emSetFocusInterface = emUse(eenvUseFocus(efocusUseInterface(nip some unit)))

emDropFocusPackage : EMonad(Unit)
emDropFocusPackage = unit emUse(eenvUseFocus(efocusUsePackage(dip(drop none))))

emDropFocusModule : EMonad(Unit)
emDropFocusModule = unit emUse(eenvUseFocus(efocusUseModule(dip(drop none))))

emDropFocusInterface : EMonad(Unit)
emDropFocusInterface = unit emUse(eenvUseFocus(efocusUseInterface(dip(drop none))))

emSaveFocusModule : EMonad(Unit)
emSaveFocusModule = $(
  emGetFocusPackage emGetFocusModule
  emBind2(epackageAddModule emSetFocusPackage)
  emThen(emDropFocusModule)
)

emSaveFocusInterface : EMonad(Unit)
emSaveFocusInterface = $(
  emGetFocusModule emGetFocusInterface
  emBind2(emoduleAddInterface emSetFocusModule)
  emThen(emDropFocusInterface)
)

emSetCtx : ECtx -- EMonad(Unit)
emSetCtx = emUse(eenvUseLocal(elocalUseCtx(nip unit)))

emGetDef : Name -- EMonad(Maybe(EDef))
emGetDef = emUse(eenvUseFocus(dip(dup) efocusGetDef))

emSetDef : Name EDef -- EMonad(Unit)
emSetDef = pack2 emUse(eenvUseFocus(unpack2 efocusSetDef)) emBind(maybe(emUnit, emFail))

elabLModuleHead : Mod L(Module) -- EMonad(Unit)
elabLModule : Mod L(Module) -- EMonad(Unit)
elabLImport : L(Import) -- EMonad(Unit)
elabLExport : L(Export) -- EMonad(Unit)
elabLSig : L(Sig) -- EMonad(Unit)
elabLDecl : L(Decl) -- EMonad(Unit)
elabLTypeSig : L(TypeSig) -- EMonad(Unit)
elabLDataDef : L(DataDef) -- EMonad(Unit)
elabLWordSig : L(WordSig) -- EMonad(Unit)
elabLWordDef : L(WordDef) -- EMonad(Unit)
elabLAssertion : L(Assertion) -- EMonad(Unit)

elabLParams : L(Params) -- EMonad(EParams)

elabPackage : Pkg Map(Mod, L(Module)) -- EMonad(Unit)
elabModuleHead : Mod Module -- EMonad(Unit)
elabModule : Mod Module -- EMonad(Unit)
elabImport : Import -- EMonad(Unit)
elabExport : Export -- EMonad(Unit)
elabSig : Sig -- EMonad(Unit)
elabDecl : Decl -- EMonad(Unit)
elabTypeSig : TypeSig -- EMonad(Unit)
elabDataDef : DataDef -- EMonad(Unit)
elabWordSig : WordSig -- EMonad(Unit)
elabWordDef : WordDef -- EMonad(Unit)
elabAssertion : Assertion -- EMonad(Unit)

elabParams : Params -- EMonad(EParams)

elabLModule = elabL2(elabModule)
elabLImport = elabL(elabImport)
elabLExport = elabL(elabExport)
elabLDecl = elabL(elabDecl)
elabLSig = elabL(elabSig)
elabLTypeSig = elabL(elabTypeSig)
elabLDataDef = elabL(elabDataDef)
elabLWordSig = elabL(elabWordSig)
elabLWordDef = elabL(elabWordDef)
elabLAssertion = elabL(elabAssertion)
elabLParams = elabL(elabParams)

elabPackage = $(
  dip(epackageNil emSetFocusPackage emDropFocusModule emDropFocusInterface emVoid3)
  dup dip(mapFor(elabLModuleHead emSaveFocusModule emVoid3))
  mapFor(elabLModule emSaveFocusModule emVoid3)
)

elabModuleHead = $(
  dip(emoduleNil emSetFocusModule)
  unModule drop
  dip(getL emFor_(elabLImport))
  getL emFor_(elabLExport emSaveFocusInterface emVoid2)
  emDropFocusInterface
  emVoid4
)

elabModule = $(
  dip(emoduleNil emSetFocusModule)
  unModule
  dip2(getL emFor_(elabLImport))
  dip(getL emFor_(elabLExport emSaveFocusInterface emVoid2))
  getL emFor_(elabLDecl)
  emVoid4
)

elabImport = unImport elabL(
  dip(emGetFocusModule) emPure
  emBind2(emoduleUseImports(eimportsAdd unit) drop emSetFocusModule)
)

elabExport = $(
  dup dip(exportInterface getL einterfaceNil emSetFocusInterface)
  exportSigs emFor_(elabLSig)
  emVoid2
)

elabDecl =
  matchDecl(
    elabLTypeSig,
    elabLDataDef,
    elabLWordSig,
    elabLWordDef,
    elabLAssertion
  )

elabSig =
  matchSig(
    elabLTypeSig,
    elabLWordSig,
    elabLAssertion
  )

emWith(f: a -- EMonad(b), getX : EMonad(x), setX : x -- EMonad(Unit)) : a x -- EMonad(b)
emWith(f, getX, setX) = $(
  dip(f getX) setX rotl
  emBind3(nip dip(setX) emPure emMap2(nip))
)

emWithCtx(f: a -- EMonad(b)) : a ECtx -- EMonad(b)
emWithCtx(f) = emWith(f, emGetCtx, emSetCtx)

elabTypeSig = $(
  dup dip(
    typeSigName getL dup
    dip(emPure)
    emGetDef
  )

  ectxNilWithImplicits emWithCtx(
    typeSigParams elabLParams
  )

  emBind3(
    swap maybe(
      MkETypeDef EDType emSetDef,
      drop3 emUnit #TODO
    )
  )
)

elabDataDef = drop emUnit
elabWordSig = drop emUnit
elabWordDef = drop emUnit
elabAssertion = drop emUnit

elabParams = drop MkEParams emPure # TODO

runElabModule : Mod L(Module) -- Result(EError, EModule)
runElabModule = $(
  elabLModule emThen(emGetFocusModule)
  dip(eenvNil) emRun nip
)

runElabPackage : Pkg Map(Mod, L(Module)) -- Result(EError, EPackage)
runElabPackage = $(
  elabPackage emThen(emGetFocusPackage)
  dip(eenvNil) emRun nip
)

