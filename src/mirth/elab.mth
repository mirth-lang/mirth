
import base/unit
import base/maybe
import base/result
import base/list
import base/list/syntax
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set
import base/exception
import base/var

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax
import mirth/core

export mirth/elab
    type Map(k,v)
    type Result(a,b)
    type Pkg
    type Mod
    type Module
    type L(t)

    type EResult(t)
    type EError
    type EWarning
    type EModule
    type EPackage

    runElabModule : Mod L(Module) -- EResult(EModule)
    runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)

    eerror->str : EError -- Str
    ewarning->str : EWarning -- Str
    emodule->str : EModule -- Str

    eresult(
        f: *a List(EError) List(EWarning) -- *b,
        g: *a t List(EWarning) -- *b
    ) : *a EResult(t) -- *b
end

export mirth/elab/data
    type EResult(t)
    type EError
    type EWarning
    type EPackage
    type EModule
    type EDef
    type ETypeDef
    type EDataDef
    type EDataConDef
    type EWordDef
    type EPrimDef
    type ETestDef
    type ETypeParam
    type EWordParam
    type ETypeName
    type EWordName
    type EBind
    type EWordType
    type EStackType
    type EType
    type ETypePrim
    type EWord
    type EWordAtom
    type EWordPrim
    type EWordMatch
    type EWordMatchCase
    type EDocs

    ERErr : List(EError) List(EWarning) -- EResult(t)
    EROk : t List(EWarning) -- EResult(t)
    eresult(
        f: *a List(EError) List(EWarning) -- *b,
        g: *a t List(EWarning) -- *b
    ) : *a EResult(t) -- *b

    MkEError : L(Str) -- EError
    eerror->str : EError -- Str

    MkEWarning : L(Str) -- EWarning
    ewarning->str : EWarning -- Str

    MkEPackage : Pkg -- EPackage
    epackage->sexp : EPackage -- Sexp
    epackage->str : EPackage -- Str

    MkEModule : Mod -- EModule
    emodule->sexp : EModule -- Sexp
    emodule->str : EModule -- Str

    EDType : ETypeDef -- EDef
    EDWord : EWordDef -- EDef
    edef(
        onTypeDef: *a ETypeDef -- *b,
        onWordDef: *a EWordDef -- *b
    ) : *a EDef -- *b
    edef->sexp : EDef -- Sexp
    edef->str : EDef -- Str

    EBStackType : EBind
    EBType : EBind
    EBWord : EWordType -- EBind
    ebind->sexp : EBind -- Sexp
    ebind->str : EBind -- Str

    MkETypeDef : EDocs ETypeName List(ETypeParam) Maybe(EDataDef) -- ETypeDef
    etypedef->sexp : ETypeDef -- Sexp
    etypedef->str : ETypeDef -- Str

    MkEDataDef : List(EDataConDef) -- EDataDef
    edatadef->sexp : EDataDef -- Sexp
    edatadef->str : EDataDef -- Str

    MkEDataConDef : EDocs EWordName List(EWordParam) List(EType) -- EDataConDef
    edatacondef->sexp : EDataConDef -- Sexp
    edatacondef->str : EDataConDef -- Str

    MkEWordDef : EDocs List(EWordParam) EWordType Maybe(EWord) -- EWordDef
    eworddef->sexp : EWordDef -- Sexp
    eworddef->str : EWordDef -- Str

    MkEWordParam : Name EWordType -- EWordParam
    ewordparam->sexp : EWordParam -- Sexp
    ewordparam->str : EWordParam -- Str

    MkEPrimDef : EPrimDef
    eprimdef->sexp : EPrimDef -- Sexp
    eprimdef->str : EPrimDef -- Str

    MkETestDef : ETestDef
    etestdef->sexp : ETestDef -- Sexp
    etestdef->str : ETestDef -- Str

    MkETypeParam : Name -- ETypeParam
    unETypeParam : ETypeParam -- Name
    etypeparam->sexp : ETypeParam -- Sexp
    etypeparam->str : ETypeParam -- Str

    MkETypeName : Name -- ETypeName
    unETypeName : ETypeName -- Name
    etypename->sexp : ETypeName -- Sexp
    etypename->str : ETypeName -- Str

    MkEWordName : Name -- EWordName
    ewordname->sexp : EWordName -- Sexp
    ewordname->str : EWordName -- Str

    MkEWordType : EStackType EStackType -- EWordType
    ewordtype->sexp : EWordType -- Sexp
    ewordtype->str : EWordType -- Str

    ESNil : EStackType
    ESVar : Name -- EStackType
    ESCons : EStackType EType -- EStackType
    estacktype->sexp : EStackType -- Sexp
    estacktype->str : EStackType -- Str

    ETVar : Name -- EType
    ETCall : ETypeName List(EType) -- EType
    ETPrim : ETypePrim List(EType) -- EType
    ETPack : EStackType -- EType
    etype->sexp : EType -- Sexp
    etype->str : EType -- Str

    ETPBool : ETypePrim
    ETPInt : ETypePrim
    ETPStr : ETypePrim
    ETPList : ETypePrim
    etypeprim->sexp : ETypePrim -- Sexp
    etypeprim->str : ETypePrim -- Str
    isTypePrimName? : Name -- Name Bool

    MkEWord : List(EWordAtom) -- EWord
    eword->sexp : EWord -- Sexp
    eword->str : EWord -- Str

    EWAVar : Name -- EWordAtom
    EWACall : EWordName List(EWord) -- EWordAtom
    EWAPrim : EWordPrim List(EWord) -- EWordAtom
    EWAMatch : EWordMatch -- EWordAtom
    ewordatom->sexp : EWordAtom -- Sexp
    ewordatom->str : EWordAtom -- Str

    EWPDip : EWordPrim
    EWPDup : EWordPrim
    EWPDrop : EWordPrim
    EWPSwap : EWordPrim
    ewordprim->sexp : EWordPrim -- Sexp
    ewordprim->str : EWordPrim -- Str

    MkEWordMatch : List(EWordMatchCase) -- EWordMatch
    ewordmatch->sexp : EWordMatch -- Sexp
    ewordmatch->str : EWordMatch -- Str

    MkEWordMatchCase : Maybe(EWordName) EWord -- EWordMatchCase
    ewordmatchcase->sexp : EWordMatchCase -- Sexp
    ewordmatchcase->str : EWordMatchCase -- Str

    MkEDocs : List(Str) -- EDocs
    edocsNull? : EDocs -- EDocs Bool
    edocs->sexp : EDocs -- Sexp
    edocs->str : EDocs -- Str
end

export mirth/elab/effect
    type L(t)

    type +Elab
    type EResult(t)
    type EError
    type EWarning
    type EModule
    type EPackage
    type ETypeDef
    type EDataDef
    type EDataConDef
    type EWordDef
    type ETestDef
    type ETypeParam
    type EDocs

    runElab(f: a -- b +Elab) : a -- EResult(b)
    runElab2(f: a1 a2 -- b +Elab) : a1 a2 -- EResult(b)
    elabL(f: *a x -- *b +Elab) : *a L(x) -- *b +Elab
    easkL : x -- L(x) +Elab
    efail : *a Str -- *b +Elab
    ewarn : Str -- +Elab

    elabPackage : Pkg Map(Mod, L(Module)) -- EPackage +Elab
    elabModule : Mod L(Module) -- EModule +Elab
    elabDecl : L(Decl) -- EDef +Elab
    elabSig : L(Sig) -- EDef +Elab
    elabTypeSig : L(TypeSig) -- ETypeDef +Elab
    elabDataDef : L(DataDef) -- ETypeDef +Elab
    elabDataConDef : L(Sig) -- EDataConDef +Elab
    elabWordSig : L(WordSig) -- EWordDef +Elab
    elabWordDef : L(WordDef) -- EWordDef +Elab
    elabAssertion : L(Assertion) -- ETestDef +Elab

    elabTypeName : L(Name) -- ETypeName +Elab
    elabWordName : L(Name) -- EWordName +Elab
    elabTypeParams : L(Params) -- List(ETypeParam) +Elab
    elabTypeParam : L(Param) -- ETypeParam +Elab
    elabWordParams : L(Params) -- List(EWordParam) +Elab
    elabWordParam : L(Param) -- EWordParam +Elab

    elabWordType : L(Type) -- EWordType +Elab
    elabStackType : L(Expr) -- EStackType +Elab
    elabStackTypeVar : L(Name) -- EStackType +Elab
    elabType : L(Atom) -- EType +Elab
    elabTypeFromWord : L(Word) -- EType +Elab
    elabTypeVar : L(Name) -- EType +Elab
    elabTypePack : L(Args) -- EStackType +Elab
    elabTypePrim : L(Name) -- ETypePrim List(ETypeParam) +Elab
    elabTypeCall : L(Name) -- ETypeName List(ETypeParam) +Elab
    elabTypeArgs : List(ETypeParam) L(Args) -- List(EType) +Elab
    elabTypeArg : L(Expr) -- EType +Elab

    elabDocs : Maybe(L(Docs)) -- EDocs +Elab
end

##########################
## High-level Interface ##
##########################

runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)
runElabPackage = runElab2(elabPackage)

runElabModule : Mod L(Module) -- EResult(EModule)
runElabModule = runElab2(elabModule)

#################
## Elaboration ##
#################

type +Elab

ELOCSET : Var(LocSet)
ELOCSET = "ELOCSET" MkVar

EWARNINGS : Var(List(EWarning))
EWARNINGS = "EWARNINGS" MkVar

EDEFS : Var(Map(Name, EDef))
EDEFS = "EDEFS" MkVar

EBINDS : Var(Map(Name, EBind))
EBINDS = "ECTX" MkVar

ElabError : Exception(List(EError))
ElabError = "ElabError" MkException

runElab(f: a -- b +Elab) : a -- EResult(b)
runElab(f) =
    nil EWARNINGS vlocal(
    locSetNull ELOCSET vlocal(
    mapNil EDEFS vlocal(
    mapNil EBINDS vlocal(
        catch(ElabError, f)
        dip(EWARNINGS vget) result(
            swap ERErr,
            swap EROk
        )
    ))))

runElab2(f: a1 a2 -- b +Elab) : a1 a2 -- EResult(b)
runElab2(f) = pack2 runElab(unpack2 f)

||| Elaborate each item in a list, and aggregate the errors
||| instead of short-circuiting.
elabList(f: a -- b +Elab) : List(a) -- List(b) +Elab
elabList(f) =
    dip(nil Ok) for(
        catch(ElabError, f) swap result(
            swap result(
                ++ Err,
                drop Err
            ),
            swap result(
                nip Err,
                cons Ok
            )
        )
    ) result(throw(ElabError), id)

elabL(f: *a x -- *b +Elab) : *a L(x) -- *b +Elab
elabL(f) = unL swap ELOCSET vlocal(f)

easkL : x -- L(x) +Elab
easkL = dip(ELOCSET vget) mkL

efail : *a Str -- *b +Elab
efail = easkL MkEError lpure throw(ElabError)

ewarn : Str -- +Elab
ewarn = easkL MkEWarning EWARNINGS vuse(swap cons)

askDef : Name -- Maybe(EDef) +Elab
askDef = dip(EDEFS vget) mapGet

askDef? : Name -- Name Maybe(EDef) +Elab
askDef? = dup askDef

setDef : Name EDef -- +Elab
setDef = EDEFS vuse(rotr mapSet)

isBound : Name -- Bool +Elab
isBound = dip(EBINDS vget) mapHas

isBound? : Name -- Name Bool +Elab
isBound? = dup isBound

askBind : Name -- Maybe(EBind) +Elab
askBind = dip(EBINDS vget) mapGet

askBind? : Name -- Name Maybe(EBind) +Elab
askBind? = dup askBind

addBind : Name EBind -- +Elab
addBind =
    over dip(EBINDS vget) mapHas if(
        "duplicate name binding" efail,
        EBINDS vuse(rotr mapSet)
    )

resetBinds : +Elab
resetBinds = mapNil EBINDS vset

saveBinds(f: *a -- *b +Elab) : *a -- *b +Elab
saveBinds(f) = EBINDS vget EBINDS vlocal(f)

data EResult(t)
    ERErr : List(EError) List(EWarning) -- EResult(t)
    EROk : t List(EWarning) -- EResult(t)
end

eresult(f,g) = match(ERErr -> f, EROk -> g)

data EError
    MkEError : L(Str) -- EError
end

unEError : EError -- L(Str)
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError unL dip(locSet->str) <>

data EWarning
    MkEWarning : L(Str) -- EWarning
end

unEWarning : EWarning -- L(Str)
unEWarning = match(MkEWarning -> id)

ewarning->str : EWarning -- Str
ewarning->str = unEWarning unL dip(locSet->str) <>

data EPackage
    MkEPackage : Pkg -- EPackage
end

unEPackage : EPackage -- Pkg
unEPackage = match(MkEPackage -> id)

epackage->sexp : EPackage -- Sexp
epackage->sexp = unEPackage sexp1("package", pkg->sexp)

epackage->str : EPackage -- Str
epackage->str = epackage->sexp sexp->str

elabPackage : Pkg Map(Mod, L(Module)) -- EPackage +Elab
elabPackage = drop MkEPackage

data EModule
    MkEModule : Mod -- EModule
end

unEModule : EModule -- Mod
unEModule = match(MkEModule -> id)

emodule->sexp : EModule -- Sexp
emodule->sexp = unEModule sexp1("module", mod->sexp)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str

elabModule : Mod L(Module) -- EModule +Elab
elabModule = drop MkEModule

data EDef
    EDType : ETypeDef -- EDef
    EDWord : EWordDef -- EDef
end

edef(
    onTypeDef: *a ETypeDef -- *b,
    onWordDef: *a EWordDef -- *b
) : *a EDef -- *b

edef(onTypeDef, onWordDef) =
    match(
        EDType -> onTypeDef,
        EDWord -> onWordDef
    )

edef->sexp : EDef -- Sexp
edef->sexp =
    match(
        EDType -> etypedef->sexp,
        EDWord -> eworddef->sexp
    )

edef->str : EDef -- Str
edef->str = edef->sexp sexp->str

elabDecl : L(Decl) -- EDef
elabDecl = "not yet implemented" efail

elabSig : L(Sig) -- EDef
elabSig = "not yet implemented" efail

data EBind
    EBStackType : EBind
    EBType : EBind
    EBWord : EWordType -- EBind
end

ebind->sexp : EBind -- Sexp
ebind->sexp =
    match(
        EBStackType -> sexp0("bind-stack-type"),
        EBType -> sexp0("bind-type"),
        EBWord -> sexp1("bind-word", ewordtype->sexp)
    )

ebind->str : EBind -- Str
ebind->str = ebind->sexp sexp->str

data ETypeDef
    MkETypeDef : EDocs ETypeName List(ETypeParam) Maybe(EDataDef) -- ETypeDef
end

unETypeDef : ETypeDef -- EDocs ETypeName List(ETypeParam) Maybe(EDataDef)
unETypeDef = match(MkETypeDef -> id)

etypedef->edocs : ETypeDef -- EDocs
etypedef->edocs = unETypeDef drop3

etypedef->etypename : ETypeDef -- ETypeName
etypedef->etypename = unETypeDef drop2 nip

etypedef->etypeparams : ETypeDef -- List(ETypeParam)
etypedef->etypeparams = unETypeDef drop dip(drop2)

etypedef->edatadef : ETypeDef -- Maybe(EDataDef)
etypedef->edatadef = unETypeDef dip(drop3)

etypedef->sexp : ETypeDef -- Sexp
etypedef->sexp = unETypeDef sexp4("type", edocs->sexp, etypename->sexp,
    list->sexp(etypeparam->sexp), maybe->sexp(edatadef->sexp))

etypedef->str : ETypeDef -- Str
etypedef->str = etypedef->sexp sexp->str

etypedefSetDocs : ETypeDef EDocs -- ETypeDef
etypedefSetDocs = swap unETypeDef dip3(drop) MkETypeDef

etypedefSetDataDef : ETypeDef EDataDef -- ETypeDef
etypedefSetDataDef = dip(unETypeDef drop) Some MkETypeDef

mergeTypeDef : ETypeDef ETypeDef -- ETypeDef +Elab
mergeTypeDef =
    cond(
        dup2 both(etypedef->etypename unETypeName) nameeq not ->
            "compiler error: attempted to merge type defs with different names" efail,
        dup2 both(etypedef->etypeparams len) n= not ->
            etypedef->etypename unETypeName
            dip("type ") name->str <>
            " already declared with different number of parameters" <> efail,
        dup2 both(etypedef->etypeparams) list=(both(unETypeParam) nameeq) not ->
            etypedef->etypename unETypeName
            dip("type ") name->str <>
            " already declared with different parameter names" <> efail,
        dup2 both(etypedef->edatadef isSome) and ->
            etypedef->etypename unETypeName
            dip("type ") name->str <>
            " already defined" efail,
        save(etypedef->edocs edocsNull? if(drop, etypedefSetDocs))
        etypedef->edatadef maybe(id, etypedefSetDataDef)
    )

addTypeDef : ETypeDef -- +Elab
addTypeDef = $(
    dup etypedef->etypename unETypeName
    askDef? maybe(
        swap EDType setDef,
        match(
            EDType ->
                dip(swap) mergeTypeDef EDType setDef,
            EDWord ->
                swap dip("type ") name->str <>
                " already defined as word" <> efail
        )
    )
)

elabTypeSig : L(TypeSig) -- ETypeDef +Elab
elabTypeSig =
    elabL(
        resetBinds
        unTypeSig
        dip2(elabDocs)
        dip(elabTypeName)
        elabTypeParams
        None
        MkETypeDef
        dup addTypeDef
    )

elabDataDef : L(DataDef) -- ETypeDef +Elab
elabDataDef =
    elabL(
        resetBinds
        unDataDef
        dip3(elabDocs)
        dip2(elabTypeName)
        dip(elabTypeParams)
        dip(dup3 None MkETypeDef addTypeDef)
            # ^ add type signature before elaborating constructors
        elabList(elabDataConDef) MkEDataDef Some
        MkETypeDef
        dup addTypeDef
    )

data EDataDef
    MkEDataDef : List(EDataConDef) -- EDataDef
end

unEDataDef : EDataDef -- List(EDataConDef)
unEDataDef = match(MkEDataDef -> id)

edatadef->sexp : EDataDef -- Sexp
edatadef->sexp = unEDataDef sexp1("data-def", list->sexp(edatacondef->sexp))

edatadef->str : EDataDef -- Str
edatadef->str = edatadef->sexp sexp->str

data EDataConDef
    MkEDataConDef : EDocs EWordName List(EWordParam) List(EType) -- EDataConDef
end

unEDataConDef : EDataConDef -- EDocs EWordName List(EWordParam) List(EType)
unEDataConDef = match(MkEDataConDef -> id)

edatacondef->sexp : EDataConDef -- Sexp
edatacondef->sexp = unEDataConDef sexp4("data-con", edocs->sexp, ewordname->sexp,
    list->sexp(ewordparam->sexp), list->sexp(etype->sexp))

edatacondef->str : EDataConDef -- Str
edatacondef->str = edatacondef->sexp sexp->str

elabDataConDef : L(Sig) -- EDataConDef +Elab
elabDataConDef = "not yet implemented" efail

data ETypeParam
    MkETypeParam : Name -- ETypeParam
end

unETypeParam : ETypeParam -- Name
unETypeParam = match(MkETypeParam -> id)

etypeparam->sexp : ETypeParam -- Sexp
etypeparam->sexp = unETypeParam name->str SexpAtom

etypeparam->str : ETypeParam -- Str
etypeparam->str = unETypeParam name->str

elabTypeParams : L(Params) -- List(ETypeParam) +Elab
elabTypeParams = elabL(unParams elabList(elabTypeParam))

elabTypeParam : L(Param) -- ETypeParam +Elab
elabTypeParam =
    elabL(
        unParam
        dip(elabL(unParams null if(id, "unsupported: higher order type parameters" efail)))
        maybe(id, elabL("unsupported: type parameters of word sort" efail))
        elabL(
            cond(
                isStarVarName? ->
                    "unsupported: type parameters of stack sort" efail,
                isPlusVarName? ->
                    "unsupported: type parameters of effect sort" efail,
                isVarName? ->
                    dup EBType addBind
                    MkETypeParam,
                "invalid variable name" efail
            )
        )
    )

data EWordParam
    MkEWordParam : Name EWordType -- EWordParam
end

unEWordParam : EWordParam -- Name EWordType
unEWordParam = match(MkEWordParam -> id)

ewordparam->sexp : EWordParam -- Sexp
ewordparam->sexp = unEWordParam sexp2("word-param", name->sexp, ewordtype->sexp)

ewordparam->str : EWordParam -- Str
ewordparam->str = ewordparam->sexp sexp->str

elabWordParams : L(Params) -- List(EWordParam) +Elab
elabWordParams = elabL(unParams elabList(elabWordParam))

elabWordParam : L(Param) -- EWordParam +Elab
elabWordParam =
    elabL(
        unParam
        dip(elabL(unParams null if(id, "unsupported: higher order word parameters" efail)))
        maybe("unsupported: word parameters of type or stack type sort" efail, elabWordType)
        swap elabL(
            isVarName? if(
                swap dup2 EBWord addBind MkEWordParam,
                "invalid variable name" efail
            )
        )
    )


data ETypeName
    MkETypeName : Name -- ETypeName
end

unETypeName : ETypeName -- Name
unETypeName = match(MkETypeName -> id)

etypename->sexp : ETypeName -- Sexp
etypename->sexp = unETypeName name->sexp

etypename->str : ETypeName -- Str
etypename->str = unETypeName name->str

elabTypeName : L(Name) -- ETypeName +Elab
elabTypeName =
    elabL(
        cond(
            isConName? -> MkETypeName,
            isPlusConName? -> MkETypeName,
            "invalid type name" efail
        )
    )

data EWordName
    MkEWordName : Name -- EWordName
end

unEWordName : EWordName -- Name
unEWordName = match(MkEWordName -> id)

ewordname->sexp : EWordName -- Sexp
ewordname->sexp = unEWordName name->sexp

ewordname->str : EWordName -- Str
ewordname->str = unEWordName name->str

elabWordName : L(Name) -- EWordName +Elab
elabWordName = elabL(MkEWordName)

data EWordDef
    MkEWordDef : EDocs List(EWordParam) EWordType Maybe(EWord) -- EWordDef
end

unEWordDef : EWordDef -- EDocs List(EWordParam) EWordType Maybe(EWord)
unEWordDef = match(MkEWordDef -> id)

eworddef->sexp : EWordDef -- Sexp
eworddef->sexp = unEWordDef sexp4("word", edocs->sexp,
    list->sexp(ewordparam->sexp), ewordtype->sexp, maybe->sexp(eword->sexp))

eworddef->str : EWordDef -- Str
eworddef->str = eworddef->sexp sexp->str

elabWordSig : L(WordSig) -- EWordDef +Elab
elabWordSig = "not yet implemented" efail

elabWordDef : L(WordDef) -- EWordDef +Elab
elabWordDef = "not yet implemented" efail

data EPrimDef
    MkEPrimDef : EPrimDef
end

unEPrimDef : EPrimDef --
unEPrimDef = match(MkEPrimDef -> id)

eprimdef->sexp : EPrimDef -- Sexp
eprimdef->sexp = unEPrimDef sexp0("prim")

eprimdef->str : EPrimDef -- Str
eprimdef->str = eprimdef->sexp sexp->str

data ETestDef
    MkETestDef : ETestDef
end

unETestDef : ETestDef --
unETestDef = match(MkETestDef -> id)

etestdef->sexp : ETestDef -- Sexp
etestdef->sexp = unETestDef sexp0("test")

etestdef->str : ETestDef -- Str
etestdef->str = etestdef->sexp sexp->str

elabAssertion : L(Assertion) -- ETestDef +Elab
elabAssertion = "not yet implemented" efail

data EWordType
    MkEWordType : EStackType EStackType -- EWordType
end

unEWordType : EWordType -- EStackType EStackType
unEWordType = match(MkEWordType -> id)

ewordtype->sexp : EWordType -- Sexp
ewordtype->sexp = unEWordType sexp2("word-type",
    estacktype->sexp, estacktype->sexp)

ewordtype->str : EWordType -- Str
ewordtype->str = ewordtype->sexp sexp->str

elabWordType : L(Type) -- EWordType +Elab
elabWordType =
    elabL(
        unType
        dip(elabStackType)
        elabStackType # TODO: strip effects
        MkEWordType
    )

data EStackType
    ESNil : EStackType
    ESVar : Name -- EStackType
    ESCons : EStackType EType -- EStackType
end

estacktype->sexp : EStackType -- Sexp
estacktype->sexp =
    match(
        ESNil -> sexp0("stack-nil"),
        ESVar -> sexp1("stack-var", name->sexp),
        ESCons -> sexp2("stack-cons", estacktype->sexp, etype->sexp)
    )

estacktype->str : EStackType -- Str
estacktype->str = estacktype->sexp sexp->str

elabStackType : L(Expr) -- EStackType +Elab
elabStackType =
    elabL(
        unExpr
        lmatchL(
            ESNil,
            dip(elabL(matchAtom(
                elabL(
                    unWord over getL isStarVarName if(
                        elabL(unArgs null
                            if(id, "expected no args to stack type variable" efail)
                        )
                        elabStackTypeVar,
                        mkWord easkL atomWord easkL elabType dip(ESNil) ESCons
                    )
                ),
                elabL("expected type, got int" efail),
                elabL("expected type, got str" efail)
            ))) for(elabType ESCons)
        )
    )

elabStackTypeVar : L(Name) -- EStackType +Elab
elabStackTypeVar =
    elabL(
        askBind? maybe(
            dup EBStackType addBind ESVar,
            match(
                EBStackType ->
                    ESVar,
                EBType ->
                    "expected stack type variable but got type variable" efail,
                EBWord ->
                    "expected stack type variable but got word variable" efail
            )
        )
    )

data EType
    ETVar : Name -- EType
    ETCall : ETypeName List(EType) -- EType
    ETPrim : ETypePrim List(EType) -- EType
    ETPack : EStackType -- EType
end

etype->sexp : EType -- Sexp
etype->sexp =
    match(
        ETVar -> sexp1("type-var", name->sexp),
        ETCall -> sexp2("type-call", etypename->sexp, list->sexp(etype->sexp)),
        ETPrim -> sexp2("type-prim", etypeprim->sexp, list->sexp(etype->sexp)),
        ETPack -> sexp1("type-pack", estacktype->sexp)
    )

etype->str : EType -- Str
etype->str = etype->sexp sexp->str

elabType : L(Atom) -- EType +Elab
elabType =
    elabL(matchAtom(
        elabTypeFromWord,
        elabL("expected type, got int" efail),
        elabL("expected type, got str" efail)
    ))

elabTypeFromWord : L(Word) -- EType +Elab
elabTypeFromWord =
    elabL(
        unWord
        cond(
            dip?(getL?(isVarName?)) ->
               elabL(unArgs null if(id, "expected no args to type variable" efail))
               elabTypeVar,
            dip?(getL?(isConName?)) ->
                cond(
                    dip?(getL?(dup name->str "Pack" streq)) ->
                        nip elabTypePack ETPack,
                    dip?(getL?(isTypePrimName?)) ->
                        dip(elabTypePrim) elabTypeArgs ETPrim,
                    dip(elabTypeCall) elabTypeArgs ETCall
                ),
            dip?(getL?(isStarVarName?)) ->
                drop elabL("expected type but got stack type variable" efail),
            dip?(getL?(isPlusVarName?)) ->
                drop elabL("expected type but got effect type variable" efail),
            dip?(getL?(isPlusConName?)) ->
                drop elabL("expected type but got effect name" efail),
            drop elabL("expected type but got unknown atom" efail)
        )
    )

elabTypeVar : L(Name) -- EType +Elab
elabTypeVar =
    elabL(
        askBind? maybe(
            dup EBType addBind ETVar,
            match(
                EBType ->
                    ETVar,
                EBStackType ->
                    "expected type variable but got stack type variable" efail,
                EBWord ->
                    "expected type variable but got word variable" efail
            )
        )
    )

elabTypePack : L(Args) -- EStackType +Elab
elabTypePack =
    elabL(
        unArgs lmatchL(
            ESNil,
            lmatchL(
                elabStackType,
                "expected only one argument to Pack type" efail
            )
        )
    )

elabTypeCall : L(Name) -- ETypeName List(ETypeParam) +Elab
elabTypeCall =
    elabL(
        askDef? maybe(
            dip("use of undeclared type ") name->str <> efail,
            match(
                EDType ->
                    nip unETypeDef drop dip2(drop),
                EDWord ->
                    drop dip("expected type but got word ") name->str <> efail
            )
        )
    )

elabTypeArgs : List(ETypeParam) L(Args) -- List(EType) +Elab
elabTypeArgs =
    elabL(
        unArgs
        dup2 dip(len) len dup2 n= if(
            drop2 nip elabList(elabTypeArg),
            dip2("expected ")
            dip(nat->str <> " args but got " <>)
            nat->str <> " args" <> efail
        )
    )

elabTypeArg : L(Expr) -- EType +Elab
elabTypeArg =
    elabL(
        unExpr
        lmatchL(
            "expected a type but got an empty arg" efail,
            lmatchL(
                elabType,
                "expected a single type but got more than one" efail
            )
        )
    )

data ETypePrim
    ETPBool : ETypePrim
    ETPInt : ETypePrim
    ETPStr : ETypePrim
    ETPList : ETypePrim
end

etypeprim->sexp : ETypePrim -- Sexp
etypeprim->sexp =
    match(
        ETPBool -> sexp0("Bool"),
        ETPInt -> sexp0("Int"),
        ETPStr -> sexp0("Str"),
        ETPList -> sexp0("List")
    )

etypeprim->str : ETypePrim -- Str
etypeprim->str = etypeprim->sexp sexp->str

isTypePrimName? : Name -- Name Bool
isTypePrimName? =
    cond(
        dup name->str "Bool" streq -> true,
        dup name->str "Int" streq -> true,
        dup name->str "Str" streq -> true,
        dup name->str "List" streq -> true,
        false
    )

elabTypePrim : L(Name) -- ETypePrim List(ETypeParam) +Elab
elabTypePrim =
    elabL(
        cond(
            dup name->str "Bool" streq -> drop ETPBool [],
            dup name->str "Int" streq -> drop ETPInt [],
            dup name->str "Str" streq -> drop ETPStr [],
            dup name->str "List" streq -> drop ETPList [ "t" mkName MkETypeParam ],
            "unknown type primitive" efail
        )
    )

data EWord
    MkEWord : List(EWordAtom) -- EWord
end

unEWord : EWord -- List(EWordAtom)
unEWord = match(MkEWord -> id)

eword->sexp : EWord -- Sexp
eword->sexp = unEWord list->sexp(ewordatom->sexp)

eword->str : EWord -- Str
eword->str = eword->sexp sexp->str

data EWordAtom
    EWAVar : Name -- EWordAtom
    EWACall : EWordName List(EWord) -- EWordAtom
    EWAPrim : EWordPrim List(EWord) -- EWordAtom
    EWAMatch : EWordMatch -- EWordAtom
end

ewordatom->sexp : EWordAtom -- Sexp
ewordatom->sexp =
    match(
        EWAVar -> sexp1("word-var", name->sexp),
        EWACall -> sexp2("word-call", ewordname->sexp, list->sexp(eword->sexp)),
        EWAPrim -> sexp2("word-prim", ewordprim->sexp, list->sexp(eword->sexp)),
        EWAMatch -> sexp1("word-match", ewordmatch->sexp)
    )

ewordatom->str : EWordAtom -- Str
ewordatom->str = ewordatom->sexp sexp->str

data EWordPrim
    EWPDip : EWordPrim
    EWPDup : EWordPrim
    EWPDrop : EWordPrim
    EWPSwap : EWordPrim
end

ewordprim->sexp : EWordPrim -- Sexp
ewordprim->sexp =
    match(
        EWPDip -> sexp0("dip"),
        EWPDup -> sexp0("dup"),
        EWPDrop -> sexp0("drop"),
        EWPSwap -> sexp0("swap")
    )

ewordprim->str : EWordPrim -- Str
ewordprim->str = ewordprim->sexp sexp->str

data EWordMatch
    MkEWordMatch : List(EWordMatchCase) -- EWordMatch
end

unEWordMatch : EWordMatch -- List(EWordMatchCase)
unEWordMatch = match(MkEWordMatch -> id)

ewordmatch->sexp : EWordMatch -- Sexp
ewordmatch->sexp = unEWordMatch list->sexp(ewordmatchcase->sexp)

ewordmatch->str : EWordMatch -- Str
ewordmatch->str = ewordmatch->sexp sexp->str

data EWordMatchCase
    MkEWordMatchCase : Maybe(EWordName) EWord -- EWordMatchCase
end

unEWordMatchCase : EWordMatchCase -- Maybe(EWordName) EWord
unEWordMatchCase = match(MkEWordMatchCase -> id)

ewordmatchcase->sexp : EWordMatchCase -- Sexp
ewordmatchcase->sexp = unEWordMatchCase sexp2("case",
    maybe->sexp(ewordname->sexp), eword->sexp)

ewordmatchcase->str : EWordMatchCase -- Str
ewordmatchcase->str = ewordmatchcase->sexp sexp->str

data EDocs
    MkEDocs : List(Str) -- EDocs
end

unEDocs : EDocs -- List(Str)
unEDocs = match(MkEDocs -> id)

edocsNull : EDocs -- Bool
edocsNull = unEDocs null

edocsNull? : EDocs -- EDocs Bool
edocsNull? = dup edocsNull

edocs->sexp : EDocs -- Sexp
edocs->sexp = unEDocs list->sexp(SexpAtom)

edocs->str : EDocs -- Str
edocs->str = edocs->sexp sexp->str

elabDocs : Maybe(L(Docs)) -- EDocs +Elab
elabDocs = maybe(nil, getL unDocs) MkEDocs
