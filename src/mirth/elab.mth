module(mirth/elab)
import(mirth/data/name)
import(mirth/data/token)
import(mirth/data/type)
import(mirth/data/table)
import(mirth/data/ctx)

####################
# Type Elaboration #
####################

data(HolesAllowed, ALLOW_HOLES, FORBID_HOLES)
def(HolesAllowed->Bool, HolesAllowed -- Bool, ALLOW_HOLES ==)

data(TypeElab, TYPE_ELAB -> HolesAllowed Ctx)
def(type-elab-default, TypeElab, FORBID_HOLES ctx-empty TYPE_ELAB)
def(type-elab-stack-assertion, Ctx -- TypeElab, dip(ALLOW_HOLES) TYPE_ELAB)
def(type-elab-holes-allowed?, TypeElab -- TypeElab HolesAllowed,
    dup match(TYPE_ELAB -> drop))
def(type-elab-ctx, TypeElab -- Ctx,
    match(TYPE_ELAB -> nip))
def(type-elab-ctx?, TypeElab -- TypeElab Ctx, dup type-elab-ctx)
def(type-elab-ctx!, TypeElab Ctx -- TypeElab,
    swap match(TYPE_ELAB -> drop swap TYPE_ELAB))

def(elab-type-sig!, TypeElab Token -- TypeElab Type Token,
    elab-type-stack!
    token-is-dashes? if(
        token-next
        swap dip(elab-type-stack!) swap,
        dip(TYPE_UNIT))
    dip(swap TMorphism)
    ) # TODO: elaborate effect type too

def(elab-type-stack!, TypeElab Token -- TypeElab Type Token,
    sig-token-is-stack-var? if(
        elab-stack-var! dip(TVar),
        dip(TYPE_UNIT)
    )
    elab-type-stack-rest!)

def(elab-type-stack-rest!, TypeElab Type Token -- TypeElab Type Token,
    while(sig-is-stack-end2? not,
        swap dip(elab-type-atom!) swap
        dip(swap TTensor)
    ))

def(elab-type-arg!, TypeElab Token -- TypeElab Type Token,
    elab-type-atom!
    token-is-arg-end? if(
        id,
        "Unexpected token after type." emit-fatal-error!
    ))

def(elab-type-atom!, TypeElab Token -- TypeElab Type Token,
    sig-token-is-type-var? if(
        elab-type-var! dip(TVar),

    sig-token-is-type-con? if(
        elab-type-con!,

    token-is-underscore? if(
        elab-type-dont-care!,

    sig-token-is-type-hole? if(
        elab-type-hole!,

    token-is-lsquare? if(
        elab-type-quote!,

        dup "Expected type, got unknown token." emit-error!
        dip(TYPE_ERROR) token-next
    ))))))

def(elab-stack-var!, TypeElab Token -- TypeElab Var Token,
    TYPE_STACK elab-implicit-var!)

def(elab-type-var!, TypeElab Token -- TypeElab Var Token,
    TYPE_TYPE elab-implicit-var!)

def(elab-implicit-var!, TypeElab Token Type -- TypeElab Var Token,
    dip2(type-elab-ctx?) over
    dip2(token-name@ dup2 swap ctx-lookup)
    rotl match(
        SOME ->
            rotr dip2(nip var-type?)
            elab-type-unify! nip,
        NONE ->
            dip(
                dip(var-new-implicit!)
                over var-type!
                dup dip(ctx-new!)
            )
    )
    token-next
    dip2(type-elab-ctx!))

def(elab-type-con!, TypeElab Token -- TypeElab Type Token,
    token-name? name-value@ match(
        DEF_TYPE ->
            over token-num-args
            over type-arity == if(
                elab-type-args!,

                drop dup
                "Wrong number of arguments for type." emit-error!
                TYPE_ERROR
            ),
        DEF_NONE ->
            dup "Unknown type." emit-error! TYPE_ERROR,
        _ ->
            drop dup "Not a type." emit-error! TYPE_ERROR
    )
    swap token-next)

def(elab-type-args!, TypeElab Token Type -- TypeElab Token Type,
    dip(token-has-args?) swap if(
        dip(tuck) swap token-succ
        while(token-is-right-enclosure? not,
            token-succ swap
            dip(elab-type-arg!) swap
            dip(swap TApp))
        drop dip(swap),

        id
    ))

def(elab-type-hole!, TypeElab Token -- TypeElab Type Token,
    dip(type-elab-holes-allowed?) swap HolesAllowed->Bool if(
        token-has-args? if(
            dup "Types with args not yet supported." emit-error! TYPE_ERROR,
            token-name? THole)
        swap token-next,
        "type holes are not allowed here" emit-fatal-error!
    ))

def(elab-type-dont-care!, TypeElab Token -- TypeElab Type Token,
    dip(type-elab-holes-allowed?) swap HolesAllowed->Bool if(
        token-has-args? if(
            dup "Types with args not yet supported." emit-error! TYPE_ERROR,
            TYPE_DONT_CARE)
        swap token-next,
        "type don't care is not allowed here" emit-fatal-error!
    ))

def(elab-type-quote!, TypeElab Token -- TypeElab Type Token,
    token-args-1
    sig-has-dashes? if(
        elab-type-sig!,
        elab-type-stack!
    )
    token-next)

def(elab-type-unify!, Type Type Token -- Type Token,
    dup dip(GAMMA rotr type-unify! nip))

def(elab-simple-type-arg!, Token -- Type,
    dip(type-elab-default) elab-type-arg! drop nip)

####################
# Word Elaboration #
####################

# data WordElab
#     WORD_ELAB -> [ Ctx Type Token List(WordAtom) ]
# end

# data WordBlock
#     WORD_BODY -> List(WordAtom)
# end

# data WordAtom
#     WORD_ATOM -> Op List(Arg)
# end

# data WordArg
#     WORD_ARG_BLK -> WordBlock
#     WORD_ARG_RUN -> Var
# end

# def(word-elab-pack, [ Ctx Type Token List(WordAtom) ] -- WordElab, WORD_ELAB)
# def(word-elab-unpack, WordElab -- [ Ctx Type Token List(WordAtom) ], match(WORD_ELAB -> id))

# def(word-elab-ctx!, WordElab Ctx -- WordElab,
#     dip(word-elab-unpack) .3! word-elab-pack)
# def(word-elab-stack!, WordElab Type -- WordElab,
#     dip(word-elab-unpack) .2! word-elab-pack)
# def(word-elab-token!, WordElab Token -- WordElab,
#     dip(word-elab-unpack) .1! word-elab-pack)
# def(word-elab-atoms!, WordElab List(WordAtom) -- WordElab,
#     dip(word-elab-unpack) .0! word-elab-pack)

# def(word-elab-ctx@, WordElab -- Ctx, word-elab-unpack .3)
# def(word-elab-stack@, WordElab -- Type, word-elab-unpack .2)
# def(word-elab-token@, WordElab -- Token, word-elab-unpack .1)
# def(word-elab-atoms@, WordElab -- List(WordAtom), word-elab-unpack .0)

# def(word-elab-ctx?, WordElab -- WordElab Ctx, dup word-elab-ctx@)
# def(word-elab-stack?, WordElab -- WordElab Type, dup word-elab-stack@)
# def(word-elab-token?, WordElab -- WordElab Token, dup word-elab-token@)
# def(word-elab-atoms?, WordElab -- WordElab List(WordAtom), dup word-elab-atoms@)

# def(word-elab-gamma?, WordElab -- WordElab Gamma,
#     word-elab-token? GAMMA)
# def(word-elab-unify!, WordElab Type Type -- WordElab Type,
#     dip2(word-elab-gamma?) type-unify! nip)
# def(word-elab-expand-tensor!, WordElab Type -- WordElab Type Type,
#     type-expand match(
#         TYPE_ERROR ->
#             TYPE_ERROR TYPE_ERROR,
#         TTensor ->
#             id,
#         _ ->
#             meta-alloc! TMeta
#             meta-alloc! TMeta
#             dup2 dip2(T* word-elab-unify! drop)
#     ))
# def(word-elab-expand-morphism!, WordElab Type -- WordElab Type Type,
#     type-expand match(
#         TYPE_ERROR ->
#             TYPE_ERROR TYPE_ERROR,
#         TMorphism ->
#             id,
#         _ ->
#             meta-alloc! TMeta
#             meta-alloc! TMeta
#             dup2 dip2(T-> word-elab-unify! drop)
#     ))
# def(word-elab-pop-type!, WordElab -- WordElab Type,
#     word-elab-stack? word-elab-expand-tensor!
#     dip(word-elab-stack!))
# def(word-elab-push-type!, WordElab Type -- WordElab,
#     dip(word-elab-stack?) T* word-elab-stack!)

# def(word-elab-warning!, WordElab Str -- WordElab,
#     dip(word-elab-token?) emit-warning!)
# def(word-elab-error!, WordElab Str -- WordElab,
#     dip(word-elab-token?) emit-error!
#     TYPE_ERROR word-elab-stack!)
# def(word-elab-fatal-error!, *a WordElab Str -- *b,
#     dip(word-elab-token@) emit-fatal-error!)

# def(word-elab-token-next!, WordElab -- WordElab,
#     word-elab-token? token-next word-elab-token!)
# def(word-elab-token-succ!, WordElab -- WordElab,
#     word-elab-token? token-succ word-elab-token!)

# def(word-elab-token-args-1!, WordElab -- WordElab Token,
#     word-elab-token?
#     dup token-num-args 1 == if(
#         token-args-1,
#         drop "expected 1 argument" word-elab-fatal-error!
#     ))

# def(word-elab-push-atom!, WordElab WordAtom -- WordElab,
#     dip(word-elab-atoms?) snoc word-elab-atoms!)

# def(word-elab-run, WordElab -- WordElab,
#     while(word-elab-done? not, word-elab-step))
# def(word-elab-done?, WordElab -- WordElab Bool,
#     word-elab-token? token-run-end? nip)
# def(word-elab-step, WordElab -- WordElab,
#     word-elab-token? token-value@ match(
#         TOKEN_INT -> word-elab-int!,
#         TOKEN_STR -> word-elab-str!,
#         TOKEN_NAME -> word-elab-name!,
#         TOKEN_LSQUARE -> drop word-elab-block!,
#         TOKEN_LCURLY -> drop word-elab-assertion!,
#         _ -> drop "unexpected token during word elaboration" word-elab-fatal-error!
#     ) word-elab-token-next!)

# def(word-elab-int!, WordElab Int -- WordElab,
#     OP_INT L0 WORD_ATOM word-elab-push-atom!
#     TYPE_INT word-elab-push-type!)

# def(word-elab-str!, WordElab StrLit -- WordElab,
#     OP_STR L0 WORD_ATOM word-elab-push-atom!
#     TYPE_PTR word-elab-push-type!)

# def(word-elab-assertion!, WordElab -- WordElab,
#     word-elab-token-args-1! drop) # TODO

# def(word-elab-block!, WordElab -- WordElab,
#     word-elab-token-args-1!
#     drop TYPE_ERROR word-elab-push-type!) # TODO

# def(word-elab-name!, WordElab Name -- WordElab,
#     drop TYPE_ERROR word-elab-stack!) #TODO


def(elab-tag-sig!, Tag -- Type +Elab,
    elab-tag-ctx-sig! nip)

def(elab-tag-ctx!, Tag -- Ctx +Elab,
    elab-tag-ctx-sig! drop)

def(elab-tag-ctx-sig!, Tag -- Ctx Type +Elab,
    tag-sig-is-checked? if(
        tag-type-raw? dip(tag-ctx@),

        type-elab-default over

        { Tag TypeElab Tag }
        tag-data@ data-header@ elab-type-atom! drop T1
        { Tag TypeElab Type }
        dip(
            over tag-has-sig?
            if(
                tag-sig@ T0 swap elab-type-stack-rest!
                token-run-end? if(drop, "syntax error" emit-fatal-error!),

                drop T0
            )
        )
        { Tag TypeElab Type Type }
        T-> dip(type-elab-ctx)
        { Tag Ctx Type }
        dup2 dip2(
            rotl
            tuck tag-type-raw!
            tuck tag-ctx!
            true swap tag-sig-is-checked!
        )
    ))


def(elab-external-sig!, External -- Type +Elab,
    elab-external-ctx-sig! nip)

def(elab-external-ctx!, External -- Ctx +Elab,
    elab-external-ctx-sig! drop)

def(elab-external-ctx-sig!, External -- Ctx Type +Elab,
    external-sig-is-checked? if(
        external-type? dip(external-ctx@),

        external-sig?
        dip(type-elab-default)
        elab-type-sig! drop dip(type-elab-ctx)
        dup2 dip2(
            rotl
            tuck external-type!
            tuck external-ctx!
            true swap external-sig-is-checked!
        )
    ))

def(elab-word-sig!, Word -- Type +Elab,
    elab-word-ctx-sig! nip)

def(elab-word-ctx!, Word -- Ctx +Elab,
    elab-word-ctx-sig! drop)

def(elab-word-ctx-sig!, Word -- Ctx Type +Elab,
    word-sig-is-checked? if(
        word-type? dip(word-ctx@),

        word-sig?
        dip(type-elab-default)
        elab-type-sig! drop dip(type-elab-ctx)
        dup2 dip2(
            rotl
            tuck word-type!
            tuck word-ctx!
            true swap word-sig-is-checked!
        )
    ))

def(elab-word-body!, Word -- Arrow +Elab,
    word-body-is-checked? if(
        word-arrow@,

    word-has-body? if(
        dup dip(elab-word-ctx-sig!)
        dup dip(word-body@ elab-arrow!)
        dup2 word-arrow!
        true swap word-body-is-checked!,

        word-sig@ token-prev token-prev # not very good :-/
        "Missing word definition."
        emit-fatal-error!
    )))

def(elab-arrow!, Ctx Type Token -- Arrow,
    elab-expand-morphism! elab-arrow-hom!)

def(elab-arrow-hom!, Ctx Type Type Token -- Arrow,
    swap dip(elab-arrow-fwd! arrow-dom? swap arrow-token@)
    swap elab-type-unify! drop2)

def(elab-arrow-fwd!, Ctx Type Token -- Arrow Arrow,
    Arrow.alloc!
    tuck arrow-token!
    tuck arrow-dom!
    tuck arrow-ctx!
    dup
    while(elab-arrow-done? not,
        elab-arrow-step!))

||| Is this arrow at the end of a run?
def(elab-arrow-done?, Arrow -- Arrow Bool,
    arrow-token? token-run-end? nip)

||| From the {ctx, dom, token} fields, elaborate the
||| arrow's {op, arg, next} fields, returning
||| the next arrow with {ctx, dom, token} set.
def(elab-arrow-step!, Arrow -- Arrow,
    dup elab-arrow-op!
    Arrow.alloc! tuck arrow-dom!
    dip(arrow-token? token-next) tuck arrow-token!
    dip(arrow-ctx?) tuck arrow-ctx!
    tuck dip(arrow-next!))

||| From the {ctx, dom, token} fields, elaborate the
||| arrow's {op, arg} fields, returning the
||| codomain of the operation.
def(elab-arrow-op!, Arrow -- Type,
    arrow-token? token-value@ match(
        TOKEN_NAME -> elab-arrow-op-name!,
        TOKEN_INT -> elab-arrow-op-int!,
        TOKEN_STR -> elab-arrow-op-str!,
        TOKEN_LSQUARE -> drop arrow-token? elab-arrow-op-block!,
        TOKEN_LCURLY -> drop arrow-token? elab-arrow-op-stack-assertion!,
        _ ->
            drop arrow-token?
            "Unexpected token in elab-arrow-op!"
            emit-fatal-error!
    ))

def(elab-arrow-op-name!, Arrow Name -- Type,
    over arrow-ctx@ dip(dup) ctx-lookup match(
        NONE ->
            name-value@ match(
                DEF_BUFFER -> elab-arrow-op-buffer!,
                DEF_EXTERNAL -> elab-arrow-op-external!,
                DEF_WORD -> elab-arrow-op-word!,
                DEF_PRIM -> elab-arrow-op-prim!,
                DEF_TAG -> elab-arrow-op-tag!,
                _ -> drop arrow-token@ "Unknown word." emit-error! TYPE_ERROR
            ),
        SOME ->
            nip elab-arrow-op-var!
    ))

def(elab-arrow-op-block!, Arrow Token -- Type,
    dip(arrow-ctx?) meta-alloc! TMeta tuck
    dip(token-args-1
        Block.alloc! dip(elab-arrow!)
        tuck block-arrow!
        OP_BLOCK over arrow-op!
        arrow-dom@)
    type-expand T*)

def(elab-arrow-op-var!, Arrow Var -- Type,
    dup2 OP_VAR swap arrow-op!
    var-auto-run? if(
        # run var
        var-type@ elab-arrow-op-apply-semifresh!,

        # push var
        dip(arrow-dom@) var-type@ T*
    ))

def(elab-arrow-op-int!, Arrow Int -- Type,
    OP_INT over arrow-op!
    arrow-dom@ TYPE_INT T*)

def(elab-arrow-op-str!, Arrow StrLit -- Type,
    OP_STR over arrow-op!
    arrow-dom@ TYPE_STR T*)

def(elab-arrow-op-buffer!, Arrow Buffer -- Type,
    OP_BUFFER over arrow-op!
    arrow-dom@ TYPE_PTR T*)

def(elab-arrow-op-stack-assertion!, Arrow Token -- Type,
    dip(arrow-ctx? type-elab-stack-assertion)
    token-succ elab-type-stack!
    drop nip
    over arrow-token@
    dip2(arrow-dom@ dup)
    elab-type-unify! drop2)

def(elab-arrow-op-external!, Arrow External -- Type,
    dup2 OP_EXTERNAL swap arrow-op!
    elab-external-sig! elab-arrow-op-apply-fresh!)

def(elab-arrow-op-word!, Arrow Word -- Type,
    dup2 OP_WORD swap arrow-op!
    elab-word-sig! elab-arrow-op-apply-fresh!)

def(elab-arrow-op-tag!, Arrow Tag -- Type,
    dup2 OP_TAG swap arrow-op!
    elab-tag-sig! elab-arrow-op-apply-fresh!)

def(elab-arrow-op-prim!, Arrow Prim -- Type,
    dup PRIM_CORE_MATCH == if(
        drop elab-arrow-op-match!,

    dup PRIM_CORE_LAMBDA == if(
        drop elab-arrow-op-lambda!,

    prim-type? is-nil if(
        drop arrow-token@ "compiler error: prim type missing" emit-fatal-error!,

        dup2 OP_PRIM swap arrow-op!
        prim-type@ elab-arrow-op-apply-fresh!
    ))))

def(elab-arrow-op-lambda!, Arrow -- Type,
    Lambda.alloc!
    dup2 OP_LAMBDA swap arrow-op!
    over arrow-ctx@ over lambda-outer-ctx!
    over arrow-dom@ over lambda-dom!
    dip(arrow-token@) tuck lambda-token!
    elab-lambda!)

def(elab-lambda!, Lambda -- Type,
    elab-lambda-params!
    elab-lambda-body!
    lambda-cod@)

def(elab-expand-tensor!, Type Token -- Type Type Token,
    dip2(meta-alloc! TMeta meta-alloc! TMeta dup2 T*)
    elab-type-unify! nip dip(dip(type-expand) type-expand))

def(elab-expand-morphism!, Type Token -- Type Type Token,
    dip2(meta-alloc! TMeta meta-alloc! TMeta dup2 T->)
    elab-type-unify! nip dip(dip(type-expand) type-expand))

def(elab-lambda-pop-from-mid!, Lambda Token -- Lambda Type Token,
    dip(lambda-mid?)
    elab-expand-tensor!
    dip2(over lambda-mid!))

def(token-is-lambda-param?, Token -- Token Bool,
    sig-token-is-type-var? if(
        token-has-args? not,
    token-is-lsquare? if(
        dup true
        dip(token-succ sig-token-is-type-var?) &&
        dip(token-succ token-is-rsquare?) &&
        nip,
        false
    )))

def(elab-lambda-params!, Lambda -- Lambda,
    lambda-outer-ctx? over lambda-inner-ctx!
    lambda-dom? over lambda-mid!
    lambda-token? token-args-1
    while(token-is-lambda-param?, token-next)
    expect-token-arrow token-prev
    while(token-is-lambda-param?,
        elab-lambda-pop-from-mid! dup dip(
            sig-token-is-type-var? if(
                token-name@ var-new! tuck var-type!,

                token-succ dip(type-expand type-is-morphism?) swap if(
                    token-name@ var-new!
                    true over var-auto-run!
                    tuck var-type!,

                    "block pattern on non-block argument" emit-fatal-error!
                )
            )
            dip(lambda-params?) dup dip(swap cons over lambda-params!)
            dip(lambda-inner-ctx?) ctx-new! over lambda-inner-ctx!
        )
        token-prev)
    drop)
def(elab-lambda-body!, Lambda -- Lambda,
    lambda-token? token-args-1
    while(token-is-lambda-param?, token-next) token-succ
    dip(lambda-mid? dip(lambda-inner-ctx?))
    elab-arrow-fwd!
    dip(over lambda-body!)
    arrow-dom@ over lambda-cod!)

def(elab-arrow-op-match!, Arrow -- Type,
    Match.alloc!
    dup2 OP_MATCH swap arrow-op!
    over arrow-ctx@ over match-ctx!
    over arrow-dom@ over match-dom!
    dip(arrow-token@) tuck match-token!
    meta-alloc! TMeta over match-cod!
    elab-match!)

||| Elaborate `match(...)` expression.
def(elab-match!, Match -- Type,
    elab-match-cases!
    elab-match-exhaustive!
    match-cod@)

||| Check that match is exhaustive.
def(elab-match-exhaustive!, Match -- Match,
    match-has-default-case? if(
        id,
        match-scrutinee-data? match(
            SOME ->
                data-num-tags dip(match-num-cases?) < if(
                    match-token? "Pattern match not exhaustive." emit-error!,
                    # TODO -- print missing patterns.
                    id
                ),
            NONE ->
                id
        )
    ))

||| Elaborate match cases.
def(elab-match-cases!, Match -- Match,
    match-token? token-has-args? if(
        token-succ token-succ
        while(token-is-rparen? not, elab-match-case!)
        drop,
        "match expects an arg" emit-fatal-error!
    ))

||| Elaborate a single match case `pattern -> body ,`
def(elab-match-case!, Match Token -- Match Token,
    Case.alloc!
    dup2 case-token!
    swap dip(dup2 case-match!)
    elab-case-pattern!
    expect-token-arrow token-succ
    elab-case-body!
    dip(match-add-case!)
    token-is-comma? if(token-succ, id))

||| Elaborate case pattern.
def(elab-case-pattern!, Case Token -- Case Token,
    token-is-underscore? if(
        # set case pattern
        dip(PATTERN_UNDERSCORE over case-pattern!)

        # set case mid
        dip(case-match? match-dom@ TYPE_DONT_CARE TYPE_DONT_CARE T*)
        elab-type-unify! dip(over case-mid!)

        # advance token
        token-succ,

    token-is-name? if(
        token-name? name-value@ match(
            DEF_TAG -> { Case Token Tag }

                # set case pattern
                dup PATTERN_TAG rotr
                dip2(over case-pattern!)

                # set case mid
                dip2(case-match? match-dom@) { Case Type Token Tag }
                elab-tag-sig! subst-nil swap type-freshen-sig
                { Case Type Token Subst Type }
                rotr dip(
                    elab-expand-morphism!
                    dip2(swap) elab-type-unify! nip
                    dip(over case-mid!)
                )
                swap dip(over case-subst!)

                # advance token
                token-succ,

            DEF_NONE ->
                "Unknown constructor." emit-fatal-error!,

            _ ->
                drop "Not a constructor." emit-fatal-error!
        ),

        "Expected constructor name." emit-fatal-error!
    )))

||| Elaborate case body.
def(elab-case-body!, Case Token -- Case Token,
    dip(case-mid? dip(case-match? match-ctx@)) elab-arrow-fwd!
    arrow-token? dip(arrow-dom@) { Case Arrow Type Token }
    dip2(over case-body!) { Case Type Token }
    dip2(case-match? match-cod@) elab-type-unify! nip)

||| Apply a type signature after freshening to get a codomain.
def(elab-arrow-op-apply-fresh!, Arrow Type -- Type,
    subst-nil swap type-freshen-sig
    dip(over arrow-subst!)
    elab-arrow-op-apply!)

||| Same as elab-arrow-op-apply! but it uses a fresh stack var
||| if the morphism has unit type.
def(elab-arrow-op-apply-semifresh!, Arrow Type -- Type,
    type-semifreshen-sig
    elab-arrow-op-apply!)

||| Apply a type signature to get a codomain.
def(elab-arrow-op-apply!, Arrow Type -- Type,
    type-expand

    over arrow-token@ token-num-args
    over type-max-num-params > if(
        over arrow-token@
        "Too many arguments." emit-fatal-error!
        drop2 TYPE_ERROR, # TODO: improve error message

    over arrow-token@ dup token-num-args
    elab-expand-params! drop
    dip(swap dip(elab-arrow-unify-dom!))
    dip(elab-arrow-op-args! drop)))

def(elab-expand-params!, Type Token Int -- List(Type) Type Type Token,
    dip(elab-expand-morphism! dip(swap))
    elab-expand-tensors!
    dip(rotr swap))

def(elab-expand-tensors!, Type Token Int -- Type List(Type) Token,
    dup 0 > if(
        dip(elab-expand-tensor!) rotl
        dip(1- elab-expand-tensors!) rotr
        dip(cons),
        drop nil swap
    ))

||| Unify a type with the dom of an arrow, returning the original arrow.
def(elab-arrow-unify-dom!, Arrow Type -- Arrow,
    over arrow-dom? swap arrow-token@ elab-type-unify! drop2)

||| Elaborate the args of an arrow.
def(elab-arrow-op-args!, Arrow List(Type) -- Arrow,
    dip(arrow-token? token-succ)
    for(dip(token-succ) elab-arrow-arg!) drop)

||| Elaborate one arg of a given type, move token to the end of the argument.
def(elab-arrow-arg!, Arrow Token Type -- Arrow Token,
    over token-is-name? dip(token-succ token-is-arg-end? nip) && if(
        dup3 drop token-name@
        dip(arrow-ctx@) swap ctx-lookup
        match(
            SOME ->
                var-auto-run? if(
                    elab-arrow-arg-var-run!,
                    drop elab-arrow-arg-block!
                ),
            NONE -> elab-arrow-arg-block!
        ),
        elab-arrow-arg-block!
    ))

||| Elaborate ARG_BLOCK argument, move token to the end of the argument.
def(elab-arrow-arg-block!, Arrow Token Type -- Arrow Token,
    over dip2(over arrow-ctx@)
    Block.alloc! dip(elab-arrow!)
    tuck block-arrow! ARG_BLOCK
    swap token-next-arg-end
    dip(arrow-arg-add!))

||| Elaborate ARG_VAR_RUN argument, move token to the end of the argument.
def(elab-arrow-arg-var-run!, Arrow Token Type Var -- Arrow Token,
    dup dip(var-type@ rotl elab-type-unify! nip)
    swap token-next-arg-end
    dip(ARG_VAR_RUN arrow-arg-add!))

######################
# Module Elaboration #
######################

||| Elaborate all of a module.
def(elab-module!, Module -- Module +Mirth,
    module-start?
    token-skip-newlines
    elab-module-header!
    elab-module-imports!
    elab-module-decls!
    typecheck-everything!
    drop)

||| Check that the `module(M)` statement exists and save the name.
def(elab-module-header!, Module Token -- Module Token +Mirth,
    PRIM_SYNTAX_MODULE token-prim=? if(
        dup2 elab-module-name! token-next,
        dup "Expected module header." emit-error!
    )
    token-skip-newlines)

||| Check & save the module name from the module header `module(M)`.
def(elab-module-name!, Module Token -- +Mirth,
    token-args-1 token-is-name? if(
        token-name?
        name-defined? if(
            drop "Module name already taken." emit-fatal-error!,
            dip(swap)
            dup2 swap module-name!
            dup2 name-module!

            # check module name matches module path
            name-load! ".mth" str-buf-push-str!
            module-path@ Path->Str STR_BUF Ptr->Str str-eq if(
                drop,
                "Module name should match path." emit-error!
            )
        ),
        "Expected module name." emit-fatal-error!
    ))


||| Elaborate module imports. Return token after imports.
def(elab-module-imports!, Module Token -- Module Token +Mirth,
    while(PRIM_SYNTAX_IMPORT token-prim=?, elab-module-import!))

||| Elaborate `import(M)` statement. Return token after import.
def(elab-module-import!, Module Token -- Module Token +Mirth,
    dup dip(token-next)
    token-args-1 token-value? match(
        TOKEN_NAME ->
            name-value? match(
                DEF_MODULE ->
                    drop3,
                    # module is already loaded (TODO: add import to a list)

                DEF_NONE ->
                    name-load! ".mth" str-buf-push-str!
                    STR_BUF Ptr->Str Str->Path run-lexer!
                    elab-module! drop2,
                    # elab the imported module (TODO: add import to a list)

                _ ->
                    drop2 "module name already taken" emit-fatal-error!
            ),
        _ ->
            drop "expected module name" emit-fatal-error!
    )
    token-skip-newlines)

||| Elaborate the rest of the module.
def(elab-module-decls!, Module Token -- Module Token +Mirth,
    while(token-is-module-end? not, elab-module-decl!))

||| Elaborate a declaration. Returns the next token.
def(elab-module-decl!, Module Token -- Module Token +Mirth,
    PRIM_SYNTAX_DEF token-prim=? if( elab-def!,
    PRIM_SYNTAX_DEF_EXTERNAL token-prim=? if( elab-def-external!,
    PRIM_SYNTAX_DEF_TYPE token-prim=? if( elab-def-type!,
    PRIM_SYNTAX_BUFFER token-prim=? if( elab-buffer!,
    PRIM_SYNTAX_TABLE token-prim=? if( elab-table!,
    PRIM_SYNTAX_FIELD token-prim=? if( elab-field!,
    PRIM_SYNTAX_TARGET_C99 token-prim=? if(elab-target-c99!,
    PRIM_SYNTAX_DATA token-prim=? if( elab-data!,
    token-could-be-word-sig? if(elab-decl-word-sig!,
    token-could-be-word-def? if(elab-decl-word-def!,
    "unknown declaration" emit-fatal-error!))))))))))
    token-skip-newlines)

||| Elaborate a data definition `data T ... end` or `data(T, ...)`
def(elab-data!, Module Token -- Module Token +Mirth,
    Data.alloc! swap
    elab-data-header!
    elab-data-tags!)

||| Get the header, name, arity for a data type. Doesn't move the Token.
def(elab-data-header!, Module Data Token -- Module Data Token +Mirth,
    dup2 token-has-args? if(
        token-succ token-succ,
        token-succ
    )
    dup2 swap data-header!
    sig-token-is-type-con? if(
        token-name?
        name-undefined? if(
            dip(over)
            dup2 swap data-name!
            dip(TData) name-type!,
            drop "Name already defined." emit-fatal-error!
        ),
        drop2 "Expected type name." emit-fatal-error!
    )

    token-has-args? if(
        # TODO check arguments are well-formed / elaborate them properly
        token-num-args swap data-arity!,
        drop2
    ))

||| Get the tags (i.e. constructors) associated with a data type.
||| Moves the Token to after the data declaration.
def(elab-data-tags!, Module Data Token -- Module Token +Mirth,
    token-has-args? if(
        token-succ token-succ token-next
        token-is-rparen? if(
            token-succ,
        token-is-comma? if(
            token-succ
            elab-data-tags-body!
            expect-token-rparen token-succ,
            "Expected comma or right parenthesis." emit-fatal-error!
        )),

        token-succ token-next
        expect-token-newline token-skip-newlines
        elab-data-tags-body!
        expect-token-end token-succ
    )
    nip)

expect-token-comma : Token -- Token
expect-token-comma = token-is-comma? if(id, "Expected comma." emit-fatal-error!)

expect-token-rparen : Token -- Token
expect-token-rparen = token-is-rparen? if(id, "Expected right parenthesis." emit-fatal-error!)

expect-token-newline : Token -- Token
expect-token-newline = token-is-newline? if(id, "Expected newline." emit-fatal-error!)

expect-token-end : Token -- Token
expect-token-end = PRIM_SYNTAX_END token-prim=? if(id, "Expected 'end'" emit-fatal-error!)

expect-token-arrow : Token -- Token
expect-token-arrow = token-is-arrow? if(id, "Expected arrow." emit-fatal-error!)

||| Get the tags (i.e. constructors) associated with a data type,
||| from inside the data declaration, one at a time. Moves the Token
||| to just after the last tag.
elab-data-tags-body! : Module Data Token -- Module Data Token
elab-data-tags-body! = while(elab-data-tags-done? not, elab-data-tag!)

elab-data-tags-done? : Token -- Token Bool
elab-data-tags-done? = token-is-rparen? if(true, PRIM_SYNTAX_END token-prim=?)

||| Get a tag associated with a data type.
||| This looks like either "TAG" or "TAG -> TYPE1 ... TYPEN".
||| Moves the Token to after the tag declaration.
elab-data-tag! : Module Data Token -- Module Data Token +Mirth
elab-data-tag! = (
    token-is-name? if(
        token-name? name-undefined? if(
            Tag.alloc!
            dup2 swap name-tag!
            tuck tag-name!,
            drop "Name already defined. (Overlapping tags not yet supported.)" emit-fatal-error!
        )
        { Module Data Token Tag }
        dip(over) dup2 tag-data!
        tuck dip(data-add-tag!)
        { Module Data Token Tag }
        swap token-succ
        token-is-arrow? if(
            dip(true over tag-has-sig!)
            token-succ tuck dip(tag-sig!)
            while(token-run-end? not, token-next),
        token-run-end? if(
            nip,
            "Expected arrow, comma, right paren, or newline." emit-fatal-error!
        ))
        { Module Data Token },

        "Expected constructor name." emit-fatal-error!
    )
    token-is-comma? if(token-succ, id)
    token-skip-newlines
)

||| Elaborate a word definition `def(w, t, b)`.
def(elab-def!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-3
    rotl token-is-name? if(
        token-name?
        name-undefined? if(
            nip
            word-alloc!
            dup2 swap name-word!
            dup dip(word-name!)
            dup dip(word-body!)
            word-sig!,

            drop "word already defined" emit-fatal-error!
        ),
        "expected word name" emit-fatal-error!
    ))

||| Elaborate a word signature "foo : Bar -- Baz"
def(elab-decl-word-sig!, Module Token -- Module Token +Mirth,
    token-name? name-undefined? if(
        word-alloc! tuck
        dup2 word-name!
        swap name-word!
        dip(token-next token-succ dup) word-sig!
        while(token-is-newline? not, token-next) token-skip-newlines,

        drop "word already defined" emit-fatal-error!
    ))

||| Elaborate a word definition "foo = bar"
def(elab-decl-word-def!, Module Token -- Module Token +Mirth,
    token-name? name-value@ match(
        DEF_WORD ->
            word-has-body? if(
                drop "word already defined" emit-fatal-error!,
                dip(token-next token-succ
                    token-is-lparen? if(token-succ, token-skip-newlines)
                    dup) word-body!
                while(token-is-newline? not, token-next) token-skip-newlines
            ),
        DEF_NONE ->
            "missing word signature" emit-fatal-error!,
        _ ->
            drop "name already defined, not a word" emit-fatal-error!
    ))

||| Elaborate an external declaration `def-external(w, t)`
def(elab-def-external!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap token-is-name? if(
        token-name? name-undefined? if(
            nip
            external-alloc!
            dup2 swap name-external!
            tuck external-name!
            external-sig!,

            drop "word already defined" emit-fatal-error!
        ),
        "expected word name" emit-fatal-error!
    ))

||| Elaborate a type definition `def-type(t1, t2)`.
def(elab-def-type!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap sig-token-is-type-con? if(
        token-name? name-undefined? if(
            nip swap
            elab-simple-type-arg!
            swap name-type!,

            drop "type already defined" emit-fatal-error!
        ),
        "expected type constructor" emit-fatal-error!
    ))

||| Elaborate a buffer definition `buffer(B, size)`.
def(elab-buffer!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap token-is-name? if(
        token-name? name-undefined? if(
            nip swap
            token-int@ buffer-alloc! drop,
            drop "buffer already defined" emit-fatal-error!
        ),
        "expected buffer name" emit-fatal-error!
    ))

||| Elaborate a table definition `table(T)`.
def(elab-table!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-1
    sig-token-is-type-con? if(
        token-name@ table-new! drop,
        "expected table name" emit-fatal-error!
    ))

||| Elaborate a field definition `field(f, T1, T2)`.
def(elab-field!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-3
    rotl token-value? match(
        TOKEN_NAME ->
            nip rotl dup elab-simple-type-arg!
            type-max-count? match(
                NONE -> drop "expected table type or enum" emit-fatal-error!,
                SOME ->
                    dip(nip rotl elab-simple-type-arg!)
                    field-new! drop,
            ),
        _ ->
            drop "expected field name" emit-fatal-error!
    ))

||| Elaborate C99 build target.
def(elab-target-c99!, Module Token -- Module Token +Mirth,
    typecheck-everything!

    dup dip(token-next) token-args-2
    dip(token-strlit@ StrLit->Str Str->Path)
    dip(ctx-empty T0 T0 T->)
    elab-arrow!
    swap run-output-c99!)

||| Ensure that everything so far has been typechecked.
def(typecheck-everything!, --,
    1
    while(dup num-names@ <=,
        dup Int->Name
        typecheck-name!
        1+)
    drop)

||| Typecheck name.
def(typecheck-name!, Name --,
    name-value@ match(
        DEF_NONE -> id,
        DEF_MODULE -> drop,
        DEF_BUFFER -> drop,
        DEF_PRIM -> drop,
        DEF_TYPE -> drop,
        DEF_EXTERNAL -> elab-external-sig! drop,
        DEF_WORD -> elab-word-body! drop,
        DEF_TAG -> elab-tag-sig! drop,
    ))
