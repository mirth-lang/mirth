
import base/unit
import base/maybe
import base/result
import base/list
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set
import base/exception
import base/var

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax
import mirth/core

export mirth/elab
    type Map(k,v)
    type Result(a,b)
    type Pkg
    type Mod
    type Module
    type L(t)

    type EResult(t)
    type EError
    type EWarning
    type EModule
    type EPackage

    runElabModule : Mod L(Module) -- EResult(EModule)
    runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)

    eerror->str : EError -- Str
    ewarning->str : EWarning -- Str
    emodule->str : EModule -- Str

    eresult(
        f: *a List(EError) List(EWarning) -- *b,
        g: *a t List(EWarning) -- *b
    ) : *a EResult(t) -- *b
end

export mirth/elab/data
    type EResult(t)
    type EError
    type EWarning
    type EPackage
    type EModule
    type EDef
    type ETypeDef
    type EWordDef
    type EPrimDef
    type ETestDef
    type ETypeParam
    type ETypeName
    type EDocs

    ERErr : List(EError) List(EWarning) -- EResult(t)
    EROk : t List(EWarning) -- EResult(t)
    eresult(
        f: *a List(EError) List(EWarning) -- *b,
        g: *a t List(EWarning) -- *b
    ) : *a EResult(t) -- *b

    MkEError : L(Str) -- EError
    eerror->str : EError -- Str

    MkEWarning : L(Str) -- EWarning
    ewarning->str : EWarning -- Str

    MkEPackage : Pkg -- EPackage
    epackage->sexp : EPackage -- Sexp
    epackage->str : EPackage -- Str

    MkEModule : Mod -- EModule
    emodule->sexp : EModule -- Sexp
    emodule->str : EModule -- Str

    EDType : ETypeDef -- EDef
    EDWord : EWordDef -- EDef
    EDPrim : EPrimDef -- EDef
    EDTest : ETestDef -- EDef
    edef(
        onTypeDef: *a ETypeDef -- *b,
        onWordDef: *a EWordDef -- *b,
        onPrimDef: *a EPrimDef -- *b,
        onTestDef: *a ETestDef -- *b
    ) : *a EDef -- *b
    edef->sexp : EDef -- Sexp
    edef->str : EDef -- Str

    MkETypeDef : EDocs ETypeName List(ETypeParam) -- ETypeDef
    etypedef->sexp : ETypeDef -- Sexp
    etypedef->str : ETypeDef -- Str

    MkEWordDef : EWordDef
    eworddef->sexp : EWordDef -- Sexp
    eworddef->str : EWordDef -- Str

    MkEPrimDef : EPrimDef
    eprimdef->sexp : EPrimDef -- Sexp
    eprimdef->str : EPrimDef -- Str

    MkETestDef : ETestDef
    etestdef->sexp : ETestDef -- Sexp
    etestdef->str : ETestDef -- Str

    MkETypeParam : Name -- ETypeParam
    etypeparam->sexp : ETypeParam -- Sexp
    etypeparam->str : ETypeParam -- Str

    MkETypeName : Name -- ETypeName
    etypename->sexp : ETypeName -- Sexp
    etypename->str : ETypeName -- Str

    MkEDocs : List(Str) -- EDocs
    edocs->sexp : EDocs -- Sexp
    edocs->str : EDocs -- Str
end

export mirth/elab/effect
    type L(t)

    type +Elab
    type EResult(t)
    type EError
    type EWarning
    type EModule
    type EPackage
    type ETypeDef
    type EWordDef
    type ETestDef
    type ETypeParam

    runElab(f: a -- b +Elab) : a -- EResult(b)
    runElab2(f: a1 a2 -- b +Elab) : a1 a2 -- EResult(b)
    elabL(f: *a x -- *b +Elab) : *a L(x) -- *b +Elab
    easkL : x -- L(x) +Elab
    efail : *a Str -- *b +Elab
    ewarn : Str -- +Elab

    elabPackage : Pkg Map(Mod, L(Module)) -- EPackage +Elab
    elabModule : Mod L(Module) -- EModule +Elab
    elabDecl : L(Decl) -- EDef +Elab
    elabSig : L(Sig) -- EDef +Elab
    elabTypeSig : L(TypeSig) -- ETypeDef +Elab
    elabDataDef : L(DataDef) -- ETypeDef +Elab
    elabWordSig : L(WordSig) -- EWordDef +Elab
    elabWordDef : L(WordDef) -- EWordDef +Elab
    elabAssertion : L(Assertion) -- ETestDef +Elab
    elabTypeParams : L(Params) -- List(ETypeParam) +Elab
    elabTypeParam : L(Param) -- ETypeParam +Elab
end

##########################
## High-level Interface ##
##########################

runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)
runElabPackage = runElab2(elabPackage)

runElabModule : Mod L(Module) -- EResult(EModule)
runElabModule = runElab2(elabModule)

#################
## Elaboration ##
#################

type +Elab

ELOCSET : Var(LocSet)
ELOCSET = "ELOCSET" MkVar

EWARNINGS : Var(List(EWarning))
EWARNINGS = "EWARNINGS" MkVar

EDEFS : Var(Map(Name, EDef))
EDEFS = "EDEFS" MkVar

ElabError : Exception(List(EError))
ElabError = "ElabError" MkException

runElab(f: a -- b +Elab) : a -- EResult(b)
runElab(f) =
    nil EWARNINGS vlocal(
    locSetNull ELOCSET vlocal(
        catch(ElabError, f)
        dip(EWARNINGS vget) result(
            swap ERErr,
            swap EROk
        )
    ))

runElab2(f: a1 a2 -- b +Elab) : a1 a2 -- EResult(b)
runElab2(f) = pack2 runElab(unpack2 f)

||| Elaborate each item in a list, and aggregate the errors
||| instead of short-circuiting.
elabList(f: a -- b +Elab) : List(a) -- List(b) +Elab
elabList(f) =
    dip(nil Ok) for(
        catch(ElabError, f) swap result(
            swap result(
                ++ Err,
                drop Err
            ),
            swap result(
                nip Err,
                cons Ok
            )
        )
    ) result(throw(ElabError), id)

elabL(f: *a x -- *b +Elab) : *a L(x) -- *b +Elab
elabL(f) = unL swap ELOCSET vlocal(f)

easkL : x -- L(x) +Elab
easkL = dip(ELOCSET vget) mkL

efail : *a Str -- *b +Elab
efail = easkL MkEError lpure throw(ElabError)

ewarn : Str -- +Elab
ewarn = easkL MkEWarning EWARNINGS vuse(swap cons)


data EResult(t)
    ERErr : List(EError) List(EWarning) -- EResult(t)
    EROk : t List(EWarning) -- EResult(t)
end

eresult(f,g) = match(ERErr -> f, EROk -> g)

data EError
    MkEError : L(Str) -- EError
end

unEError : EError -- L(Str)
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError unL dip(locSet->str) <>

data EWarning
    MkEWarning : L(Str) -- EWarning
end

unEWarning : EWarning -- L(Str)
unEWarning = match(MkEWarning -> id)

ewarning->str : EWarning -- Str
ewarning->str = unEWarning unL dip(locSet->str) <>

data EPackage
    MkEPackage : Pkg -- EPackage
end

unEPackage : EPackage -- Pkg
unEPackage = match(MkEPackage -> id)

epackage->sexp : EPackage -- Sexp
epackage->sexp = unEPackage sexp1("package", pkg->sexp)

epackage->str : EPackage -- Str
epackage->str = epackage->sexp sexp->str

elabPackage : Pkg Map(Mod, L(Module)) -- EPackage +Elab
elabPackage = drop MkEPackage

data EModule
    MkEModule : Mod -- EModule
end

unEModule : EModule -- Mod
unEModule = match(MkEModule -> id)

emodule->sexp : EModule -- Sexp
emodule->sexp = unEModule sexp1("module", mod->sexp)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str

elabModule : Mod L(Module) -- EModule +Elab
elabModule = drop MkEModule

data EDef
    EDType : ETypeDef -- EDef
    EDWord : EWordDef -- EDef
    EDPrim : EPrimDef -- EDef
    EDTest : ETestDef -- EDef
end

edef(
    onTypeDef: *a ETypeDef -- *b,
    onWordDef: *a EWordDef -- *b,
    onPrimDef: *a EPrimDef -- *b,
    onTestDef: *a ETestDef -- *b
) : *a EDef -- *b

edef(onTypeDef, onWordDef, onPrimDef, onTestDef) =
    match(
        EDType -> onTypeDef,
        EDWord -> onWordDef,
        EDPrim -> onPrimDef,
        EDTest -> onTestDef
    )

edef->sexp : EDef -- Sexp
edef->sexp =
    match(
        EDType -> etypedef->sexp,
        EDWord -> eworddef->sexp,
        EDPrim -> eprimdef->sexp,
        EDTest -> etestdef->sexp
    )

edef->str : EDef -- Str
edef->str = edef->sexp sexp->str

elabDecl : L(Decl) -- EDef
elabDecl = "not yet implemented" efail

elabSig : L(Sig) -- EDef
elabSig = "not yet implemented" efail

data ETypeDef
    MkETypeDef : EDocs ETypeName List(ETypeParam) -- ETypeDef
end

unETypeDef : ETypeDef -- EDocs ETypeName List(ETypeParam)
unETypeDef = match(MkETypeDef -> id)

etypedef->sexp : ETypeDef -- Sexp
etypedef->sexp = unETypeDef sexp3("type", edocs->sexp, etypename->sexp, list->sexp(etypeparam->sexp))

etypedef->str : ETypeDef -- Str
etypedef->str = etypedef->sexp sexp->str

elabTypeSig : L(TypeSig) -- ETypeDef +Elab
elabTypeSig = "not yet implemented" efail # TODO

elabDataDef : L(DataDef) -- ETypeDef +Elab
elabDataDef = "not yet implemented" efail

data ETypeParam
    MkETypeParam : Name -- ETypeParam
end

unETypeParam : ETypeParam -- Name
unETypeParam = match(MkETypeParam -> id)

etypeparam->sexp : ETypeParam -- Sexp
etypeparam->sexp = unETypeParam name->str SexpAtom

etypeparam->str : ETypeParam -- Str
etypeparam->str = unETypeParam name->str

EBOUNDVARS : Var(Set(Name))
EBOUNDVARS = "EBOUNDVARS" MkVar

isBound : Name -- Bool +Elab
isBound = dip(EBOUNDVARS vget) setHas

isBound? : Name -- Name Bool +Elab
isBound? = dup isBound

elabTypeParams : L(Params) -- List(ETypeParam) +Elab
elabTypeParams =
    elabL(setNil EBOUNDVARS vlocal(
        unParams map(
            elabTypeParam
            dup unETypeParam setSingle EBOUNDVARS vuse(setUnion)
        )
    ))

elabTypeParam : L(Param) -- ETypeParam +Elab
elabTypeParam =
    elabL(
        unParam
        dip(elabL(unParams null if(id, "unsupported: higher order type parameters" efail)))
        maybe(id, elabL("unsupported: type parameters of word sort" efail))
        elabL(
            cond(
                isStarVarName? ->
                    "unsupported: type parameters of stack sort" efail,
                isPlusVarName? ->
                    "unsupported: type parameters of effect sort" efail,
                isBound? ->
                    "duplicate bound variable name" efail,
                isVarName? ->
                    MkETypeParam,
                "invalid variable name" efail
            )
        )
    )

data ETypeName
    MkETypeName : Name -- ETypeName
end

unETypeName : ETypeName -- Name
unETypeName = match(MkETypeName -> id)

etypename->sexp : ETypeName -- Sexp
etypename->sexp = unETypeName name->str SexpAtom

etypename->str : ETypeName -- Str
etypename->str = unETypeName name->str

data EWordDef
    MkEWordDef : EWordDef
end

unEWordDef : EWordDef --
unEWordDef = match(MkEWordDef -> id)

eworddef->sexp : EWordDef -- Sexp
eworddef->sexp = unEWordDef sexp0("word")

eworddef->str : EWordDef -- Str
eworddef->str = eworddef->sexp sexp->str

elabWordSig : L(WordSig) -- EWordDef +Elab
elabWordSig = "not yet implemented" efail

elabWordDef : L(WordDef) -- EWordDef +Elab
elabWordDef = "not yet implemented" efail

data EPrimDef
    MkEPrimDef : EPrimDef
end

unEPrimDef : EPrimDef --
unEPrimDef = match(MkEPrimDef -> id)

eprimdef->sexp : EPrimDef -- Sexp
eprimdef->sexp = unEPrimDef sexp0("prim")

eprimdef->str : EPrimDef -- Str
eprimdef->str = eprimdef->sexp sexp->str

data ETestDef
    MkETestDef : ETestDef
end

unETestDef : ETestDef --
unETestDef = match(MkETestDef -> id)

etestdef->sexp : ETestDef -- Sexp
etestdef->sexp = unETestDef sexp0("test")

etestdef->str : ETestDef -- Str
etestdef->str = etestdef->sexp sexp->str

elabAssertion : L(Assertion) -- ETestDef +Elab
elabAssertion = "not yet implemented" efail

data EDocs
    MkEDocs : List(Str) -- EDocs
end

unEDocs : EDocs -- List(Str)
unEDocs = match(MkEDocs -> id)

edocs->sexp : EDocs -- Sexp
edocs->sexp = unEDocs list->sexp(SexpAtom)

edocs->str : EDocs -- Str
edocs->str = edocs->sexp sexp->str
