
import base/unit
import base/maybe
import base/result
import base/list
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax

export mirth/elab
  type Map(k,v)
  type Result(a,b)

  type EEnv
  type EError
  type EWarning
  type EMonad(t)
  type EResult(t)

  type ESym
  type ETerm
  type EEffect
  type EStack
  type EType
  type EKind
  type EBind
  type ECtx
  type EParams
  type EDefs
  type EInterface
  type EModule
  type EPackage

  emRun : EEnv EMonad(t) -- EEnv EResult(t)
  emFail : Str -- EMonad(a)
  emPure : a -- EMonad(a)
  emPure2 : a b -- EMonad(a) EMonad(b)
  emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
  emMap(f: a -- b) : EMonad(a) -- EMonad(b)
  emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
  emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
  emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emThen(f: EMonad(b)) : EMonad(a) -- EMonad(b)
  emThen2(f: EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emThen3(f: EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emThen4(f: EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)

  runElabModule : Mod L(Module) -- EResult(EModule)
  runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)

  eerror->str : EError -- Str
  ewarning->str : EWarning -- Str
  emodule->str : EModule -- Str

  eresult(
    f: *a List(EError) List(EWarning) -- *b,
    g: *a t List(EWarning) -- *b
  ) : *a EResult(t) -- *b
end

||| Error during elaboration.
data EError
  MkEError : L(Str) -- EError
end

unEError : EError -- L(Str)
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError unL dip(locSet->str) <>


||| Warning during elaboration.
data EWarning
  MkEWarning : L(Str) -- EWarning
end

unEWarning : EWarning -- L(Str)
unEWarning = match(MkEWarning -> id)

ewarning->str : EWarning -- Str
ewarning->str = unEWarning unL dip(locSet->str) <>


data EResult(t)
  ERErr : List(EError) List(EWarning) -- EResult(t)
  EROk : t List(EWarning) -- EResult(t)
end

eresult(f,g) =
  match(
    ERErr -> f,
    EROk -> g
  )

erPure : t -- EResult(t)
erPure = nil EROk

erFail : EError -- EResult(t)
erFail = lpure nil ERErr

erWarn : EWarning -- EResult(Unit)
erWarn = dip(unit) lpure EROk

erMap(f: *c a -- *c b) : *c EResult(a) -- *c EResult(b)
erMap(f) = eresult(ERErr, dip(f) EROk)

erMap2(f: a b -- c) : EResult(a) EResult(b) -- EResult(c)
erMap2(f) =
  swap eresult(
    rotl eresult(
      dip(swap) dip2(++) ++ ERErr,
      nip ++ ERErr
    ),
    rotl eresult(
      dip3(drop) dip(swap) ++ ERErr,
      dip(swap) dip2(f) ++ EROk
    )
  )

erBind(f: a -- EResult(b)) : EResult(a) -- EResult(b)
erBind(f) =
  eresult(
    ERErr,
    swap f eresult(
      dip(swap) ++ ERErr,
      dip(swap) ++ EROk
    )
  )


||| Elaboration monad.
data EMonad(t)
  MkEMonad(f: EEnv m -- EEnv EResult(t)) : m -- EMonad(t)
end

emUse(f: EEnv a -- EEnv b) : a -- EMonad(b)
emUse(f) = MkEMonad(f erPure)

emGet(f: EEnv -- EEnv b) : EMonad(b)
emGet(f) = unit emUse(drop f)

emPut(f: EEnv t -- EEnv) : t -- EMonad(Unit)
emPut(f) = emUse(f unit)

emRun : EEnv EMonad(t) -- EEnv EResult(t)
emRun = match(MkEMonad(f) -> f)

emPure : a -- EMonad(a)
emPure = MkEMonad(erPure)

emThrowError : EError -- EMonad(a)
emThrowError = MkEMonad(erFail)

emThrowWarning : EWarning -- EMonad(Unit)
emThrowWarning = MkEMonad(erWarn)

emGetLoc : EMonad(LocSet) # Defined below.

emPureL : a -- EMonad(L(a))
emPureL = dip(emGetLoc) emPure emMap2(mkL)

emFail : Str -- EMonad(a)
emFail = emPureL emBind(MkEError emThrowError)

emWarn : Str -- EMonad(Unit)
emWarn = emPureL emBind(MkEWarning emThrowWarning)

emPure2 : a b -- EMonad(a) EMonad(b)
emPure2 = dip(emPure) emPure

emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
emPure3 = dip(emPure2) emPure

emMap(f: a -- b) : EMonad(a) -- EMonad(b)
emMap(f) = MkEMonad(emRun erMap(f))

emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
emMap2(f) =
  pack2 MkEMonad(
    unpack2
    dip(emRun) swap
    dip(emRun) swap
    erMap2(f)
  )

emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emMap3(f) = emMap2(pack2) emMap2(unpack2 f)

emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emMap4(f) = emMap2(pack2) emMap3(unpack2 f)

emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
emBind(f) =
  MkEMonad(
    emRun eresult(
      ERErr,
      dip(unit) EROk
      dip(f emRun)
      swap erMap2(nip)
    )
  )

emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emBind2(f) = emMap2(pack2) emBind(unpack2 f)

emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emBind3(f) = emMap3(pack3) emBind(unpack3 f)

emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emBind4(f) = emMap4(pack4) emBind(unpack4 f)

emThen(f: EMonad(b)) : EMonad(a) -- EMonad(b)
emThen(f) = emBind(drop f)

emThen2(f: EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emThen2(f) = emBind2(drop2 f)

emThen3(f: EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emThen3(f) = emBind3(drop3 f)

emThen4(f: EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emThen4(f) = emBind4(drop4 f)

emUnit : EMonad(Unit)
emUnit = unit emPure

emVoid : EMonad(a) -- EMonad(Unit)
emVoid = emMap(drop unit)

emVoid2 : EMonad(a) EMonad(b) -- EMonad(Unit)
emVoid2 = emMap2(drop2 unit)

emVoid3 : EMonad(a) EMonad(b) EMonad(c) -- EMonad(Unit)
emVoid3 = emMap3(drop3 unit)

emVoid4 : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(Unit)
emVoid4 = emMap4(drop4 unit)

###############
# Elaboration #
###############

data ESym
  ESymType : Maybe(Pkg) Name -- ESym
  ESymWord : Maybe(Mod) Name -- ESym
end

esym->str : ESym -- Str
esym->str =
  match(
    ESymType -> dip(dip("T:") maybe(id, pkg->str <> ":" <>)) name->str <>,
    ESymWord -> dip(dip("w:") maybe(id, mod->str <> ":" <>)) name->str <>
  )

esym->sexp : ESym -- Sexp
esym->sexp = esym->str sexpAtom

data EParams
  MkEParams : EParams
end

unEParams : EParams --
unEParams = match(MkEParams -> id)

eparamsNil : EParams
eparamsNil = MkEParams

eparams->sexp : EParams -- Sexp
eparams->sexp = unEParams nil sexpList

||| Elaborated effect type.
data EEffect
  EEVar : Name -- EEffect
  EESym : ESym -- EEffect
  EENil : EEffect
end

||| Elaborated stack type.
data EStack
  ESVar : Name -- EStack
  ESNil : EStack
  ESCons : EStack EType -- EStack
end

||| Elaborated value type.
data EType
  ETVar : Name -- EType
  ETSym : ESym List(EType) -- EType
end

||| Elaborated word.
data EWord
  EWVar : Name List(EWord) -- EWord
  EWSym : ESym List(EWord) -- EWord
  EWId : EWord
  EWCp : EWord EWord -- EWord
  EWSwap : EWord
  EWDrop : EWord
  EWDup : EWord
  EWDip : EWord -- EWord
end

||| A type definition.
data ETypeDef
  MkETypeDef : ESym EParams -- ETypeDef
end

unETypeDef : ETypeDef -- ESym EParams
unETypeDef = match(MkETypeDef -> id)

etypedefSym : ETypeDef -- ESym
etypedefSym = unETypeDef drop

etypedef->sexp : ETypeDef -- Sexp
etypedef->sexp = unETypeDef sexp2("type", esym->sexp, eparams->sexp)

etypedefMerge(key->str: key -- Str) : key ETypeDef ETypeDef -- key EMonad(ETypeDef)
etypedefMerge(key->str) = drop emPure # TODO


||| A word definition.
data EWordDef
  MkEWordDef : ESym -- EWordDef
end

unEWordDef : EWordDef -- ESym
unEWordDef = match(MkEWordDef -> id)

eworddefSym : EWordDef -- ESym
eworddefSym = unEWordDef

eworddef->sexp : EWordDef -- Sexp
eworddef->sexp = unEWordDef sexp1("word", esym->sexp)

eworddefMerge(key->str: key -- Str) : key EWordDef EWordDef -- key EMonad(EWordDef)
eworddefMerge(key->str) = drop emPure # TODO


||| A definition.
data EDef
  EDType : ETypeDef -- EDef
  EDWord : EWordDef -- EDef
end

edefSym : EDef -- ESym
edefSym =
  match(
    EDType -> etypedefSym,
    EDWord -> eworddefSym
  )

edef->sexp : EDef -- Sexp
edef->sexp =
  match(
    EDType -> etypedef->sexp,
    EDWord -> eworddef->sexp
  )

edefMerge(key->str: key -- Str) : key EDef EDef -- key EMonad(EDef)
edefMerge(key->str) =
  swap match(
    EDType ->
      swap match(
        EDType -> etypedefMerge(key->str) emMap(EDType),
        EDWord -> drop2 "Cannot redefine word " over key->str <> " as type." <> emFail
      ),
    EDWord ->
      swap match(
        EDType -> drop2 "Cannot redefine type " over key->str <> " as word." <> emFail,
        EDWord -> eworddefMerge(key->str) emMap(EDWord)
      )
    )


||| A set of definitions, local to a module or interface.
data EDefs
  MkEDefs : Map(Name, EDef) -- EDefs
end

unEDefs : EDefs -- Map(Name, EDef)
unEDefs = match(MkEDefs -> id)

edefsLocals : EDefs -- Map(Name, EDef)
edefsLocals = unEDefs

edefsNil : EDefs
edefsNil = mapNil MkEDefs

edefsGet : EDefs Name -- Maybe(EDef)
edefsGet = dip(edefsLocals) mapGet

edefsSingle : Name EDef -- EDefs
edefsSingle = mapSingle MkEDefs

||| Add a definition
edefsAdd : EDefs Name EDef -- EMonad(EDefs)
edefsAdd =
  dip2(unEDefs) dip(mapGet?) swap maybe(
    mapSet MkEDefs emPure,
    swap edefMerge(name->str) dip(emPure2)
    emMap3(mapSet MkEDefs)
  )

edefsMerge : EDefs EDefs -- EMonad(EDefs)
edefsMerge = dip(emPure) unEDefs mapFor(emPure2 emBind3(edefsAdd))

edefs->sexp : EDefs -- Sexp
edefs->sexp = unEDefs map->sexp(name->sexp, edef->sexp)

||| All definitions.
data EGlobals
  MkEGlobals : Map(ESym, EDef) -- EGlobals
end

unEGlobals : EGlobals -- Map(ESym, EDef)
unEGlobals = match(MkEGlobals -> id)

eglobalsNil : EGlobals
eglobalsNil = mapNil MkEGlobals

eglobalsGet : EGlobals ESym -- Maybe(EDef)
eglobalsGet = dip(unEGlobals) mapGet

||| Add a global definition.
eglobalsAdd : EGlobals EDef -- EMonad(EGlobals)
eglobalsAdd =
  dip(unEGlobals) dup dip(edefSym mapGet?) swap maybe(
    mapSet MkEGlobals emPure,
    swap edefMerge(esym->str) dip(emPure2)
    emMap3(mapSet MkEGlobals)
  )

eglobalsAddDefs : EGlobals EDefs -- EMonad(EGlobals)
eglobalsAddDefs = dip(emPure) unEDefs mapFor(nip emPure emBind2(eglobalsAdd))

eglobalsMerge : EGlobals EGlobals -- EMonad(EGlobals)
eglobalsMerge = dip(emPure) unEGlobals mapFor(nip emPure emBind2(eglobalsAdd))

eglobals->sexp : EGlobals -- Sexp
eglobals->sexp = unEGlobals map->sexp(esym->sexp, edef->sexp)


||| A single interface.
data EInterface
  MkEInterface : Interface EDefs -- EInterface
end

unEInterface : EInterface -- Interface EDefs
unEInterface = match(MkEInterface -> id)

einterfaceNil : Interface -- EInterface
einterfaceNil = edefsNil MkEInterface

einterfaceInterface : EInterface -- Interface
einterfaceInterface = unEInterface drop

einterfaceDefs : EInterface -- EDefs
einterfaceDefs = unEInterface nip

einterfaceUseDefs(f: EDefs a -- EDefs b) : EInterface a -- EInterface b
einterfaceUseDefs(f) = dip(unEInterface) f dip(MkEInterface)

einterfaceGetDef : EInterface Name -- Maybe(EDef)
einterfaceGetDef = einterfaceUseDefs(dip(dup) edefsGet) nip

einterfaceAddDefs : EInterface EDefs -- EMonad(EInterface)
einterfaceAddDefs = dip(unEInterface dip(emPure)) edefsMerge emMap2(MkEInterface)

einterfaceAddDef : EInterface Name EDef -- EMonad(EInterface)
einterfaceAddDef = edefsSingle einterfaceAddDefs

||| Merge two interfaces. Assumes both interfaces have the same name.
einterfaceMerge : EInterface EInterface -- EMonad(EInterface)
einterfaceMerge = dip(unEInterface dip(emPure)) einterfaceDefs edefsMerge emMap2(MkEInterface)

einterface->sexp : EInterface -- Sexp
einterface->sexp = unEInterface sexp2("interface", interface->sexp, edefs->sexp)


||| A module's imports, i.e. a set of interfaces.
data EImports
  MkEImports : Set(Interface) -- EImports
end

unEImports : EImports -- Set(Interface)
unEImports = match(MkEImports -> id)

eimportsNil : EImports
eimportsNil = setNil MkEImports

eimportsAdd : EImports Interface -- EImports
eimportsAdd = dip(unEImports) setAdd MkEImports

eimportsHas : EImports Interface -- Bool
eimportsHas = dip(unEImports) setHas

eimports->sexp : EImports -- Sexp
eimports->sexp = unEImports set->sexp(interface->sexp)


||| A module's exports, i.e. a map of interface definitions.
data EExports
  MkEExports : Map(Interface, EInterface) -- EExports
end

unEExports : EExports -- Map(Interface, EInterface)
unEExports = match(MkEExports -> id)

eexportsNil : EExports
eexportsNil = mapNil MkEExports

eexportsAdd : EExports EInterface -- EMonad(EExports)
eexportsAdd =
  dip(unEExports) dup dip(einterfaceInterface mapGet?) swap maybe(
    mapSet MkEExports emPure,
    swap einterfaceMerge dip(emPure2) emMap3(mapSet MkEExports)
  )

eexportsMerge : EExports EExports -- EMonad(EExports)
eexportsMerge = dip(emPure) unEExports mapFor(nip emPure emBind2(eexportsAdd))

eexports->sexp : EExports -- Sexp
eexports->sexp = unEExports map->sexp(interface->sexp, einterface->sexp)


||| A single Mirth module.
data EModule
  MkEModule : Mod EImports EExports EDefs -- EModule
end

unEModule : EModule -- Mod EImports EExports EDefs
unEModule = match(MkEModule -> id)

emoduleMod : EModule -- Mod
emoduleMod = unEModule drop3

emoduleExports : EModule -- EExports
emoduleExports = unEModule drop dip(drop2)

emoduleUseImports(f: EImports a -- EImports b) : EModule a -- EModule b
emoduleUseImports(f) = dip(unEModule) dip2''(f) dip(MkEModule)

emoduleUseExports(f: EExports a -- EExports b) : EModule a -- EModule b
emoduleUseExports(f) = dip(unEModule) dip'(f) dip(MkEModule)

emoduleUseDefs(f: EDefs a -- EDefs b) : EModule a -- EModule b
emoduleUseDefs(f) = dip(unEModule) f dip(MkEModule)

emoduleGetDef : EModule Name -- Maybe(EDef)
emoduleGetDef = emoduleUseDefs(dip(dup) edefsGet) nip

emoduleAddDefs : EModule EDefs -- EMonad(EModule)
emoduleAddDefs = dip(unEModule dip(emPure3)) edefsMerge emMap4(MkEModule)

emoduleAddDef : EModule Name EDef -- EMonad(EModule)
emoduleAddDef = edefsSingle emoduleAddDefs

emoduleNil : Mod -- EModule
emoduleNil = eimportsNil eexportsNil edefsNil MkEModule

emoduleAddInterface : EModule EInterface -- EMonad(EModule)
emoduleAddInterface = $(
  dip(unEModule) tuck
  dip4(emPure2)
  dip2(eexportsAdd)
  einterfaceDefs edefsMerge
  emMap4(MkEModule)
)

emodule->sexp : EModule -- Sexp
emodule->sexp = unEModule sexp4("module", mod->sexp, eimports->sexp, eexports->sexp, edefs->sexp)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str


||| A Mirth package, i.e. a collection of modules and interfaces.
data EPackage
  MkEPackage : Pkg EExports Map(Mod, EModule) -- EPackage
end

unEPackage : EPackage -- Pkg EExports Map(Mod, EModule)
unEPackage = match(MkEPackage -> id)

epackagePkg : EPackage -- Pkg
epackagePkg = unEPackage drop2

epackageNil : Pkg -- EPackage
epackageNil = eexportsNil mapNil MkEPackage

epackage->sexp : EPackage -- Sexp
epackage->sexp = unEPackage nip sexp2("package", pkg->sexp, map->sexp(mod->sexp, emodule->sexp))

epackageAddModule : EPackage EModule -- EMonad(EPackage)
epackageAddModule = $(
  dip(unEPackage dip2(emPure))
  dup dip(emoduleExports swap dip(eexportsMerge))
  dup dip(emoduleMod) mapSet emPure
  emMap3(MkEPackage)
)


||| Elaboration World -- The collection of loaded packages,
||| and a repository of global definitions.
data EWorld
  MkEWorld : Map(Pkg, EPackage) EGlobals -- EWorld
end

unEWorld : EWorld -- Map(Pkg, EPackage) EGlobals
unEWorld = match(MkEWorld -> id)

eworldPackages : EWorld -- Map(Pkg, EPackage)
eworldPackages = unEWorld drop

eworldGlobals : EWorld -- EGlobals
eworldGlobals = unEWorld nip

eworldNil : EWorld
eworldNil = mapNil eglobalsNil MkEWorld

eworldGetDef : EWorld ESym -- Maybe(EDef)
eworldGetDef = dip(eworldGlobals) eglobalsGet

eworldAddDefs : EWorld EDefs -- EMonad(EWorld)
eworldAddDefs = dip(unEWorld) dip2(emPure) eglobalsAddDefs emMap2(MkEWorld)


||| Elaboration Focus -- The current package/module/interface being
||| elaborated. This should be unchanged during expression elaboration.
data EFocus
  MkEFocus : Maybe(EPackage) Maybe(EModule) Maybe(EInterface) -- EFocus
end

unEFocus : EFocus -- Maybe(EPackage) Maybe(EModule) Maybe(EInterface)
unEFocus = match(MkEFocus -> id)

efocusNil : EFocus
efocusNil = none none none MkEFocus

efocusGetDef : EFocus Name -- Maybe(EDef)
efocusGetDef =
  swap unEFocus dip2(drop) maybe(
    maybe(drop none, swap emoduleGetDef),
    nip swap einterfaceGetDef
  )

efocusAddDefs : EFocus EDefs -- EMonad(EFocus)
efocusAddDefs = $(
  dip(unEFocus dip2(emPure))
  swap maybe(
    swap maybe(
      drop2 "Compiler Error: efocusAddDefs: Not in module or interface." emFail,
      swap emoduleAddDefs emMap2(some none MkEFocus)
    ),
    swap einterfaceAddDefs dip(emPure) emMap3(some MkEFocus)
  )
)

efocusAddDef : EFocus Name EDef -- EMonad(EFocus)
efocusAddDef = edefsSingle efocusAddDefs

||| Create an empty package focus for a Pkg.
efocusNilPkg : Pkg -- EFocus
efocusNilPkg = epackageNil some none none MkEFocus

||| Create an empty module focus for a Mod, for testing purposes.
efocusNilMod : Mod -- EFocus
efocusNilMod =  dip(none) emoduleNil some none MkEFocus

efocusUsePackage(f: Maybe(EPackage) a -- Maybe(EPackage) b) : EFocus a -- EFocus b
efocusUseModule(f: Maybe(EModule) a -- Maybe(EModule) b) : EFocus a -- EFocus b
efocusUseInterface(f: Maybe(EInterface) a -- Maybe(EInterface) b) : EFocus a -- EFocus b

efocusUsePackage(f) = dip(unEFocus) dip2''(f) dip(MkEFocus)
efocusUseModule(f) = dip(unEFocus) dip'(f) dip(MkEFocus)
efocusUseInterface(f) = dip(unEFocus) f dip(MkEFocus)

efocusPkg : EFocus -- Maybe(Pkg)
efocusPkg = unEFocus drop2 mmap(epackagePkg)

efocusMod : EFocus -- Maybe(Mod)
efocusMod = unEFocus drop nip mmap(emoduleMod)

efocusTypeSym : EFocus Name -- ESym
efocusTypeSym = dip(efocusPkg) ESymType

efocusWordSym : EFocus Name -- ESym
efocusWordSym = dip(efocusMod) ESymWord

||| Additional info associated with a binding.
data EMeta(t)
  ||| Binding represents a rigid variable, i.e. we can't instantiate
  ||| during unification. The Bool controls whether the variable
  ||| was passed implicitly or explicitly.
  EMRigid : Bool -- EMeta(t)

  ||| Binding represents a plastic variable, i.e. we can instantiate
  ||| it once during unification. The Maybe(t) represents the value
  ||| it was instantiated to, if it was, and Set(Name) represents
  ||| the set of rigid free variables that are allowed in the
  ||| instantiated value
  EMPlastic : Set(Name) Maybe(t) -- EMeta(t)
end

emetaIsRigid : EMeta(t) -- Bool
emetaIsRigid =
  match(
    EMRigid -> drop true,
    EMPlastic -> drop2 false
  )

data EBind
  EBStack : EMeta(EStack) -- EBind
  EBType : EMeta(EType) -- EBind
  EBEffect : EMeta(EEffect) -- EBind
  EBWord : EStack EStack EEffect EMeta(EWord) -- EBind
end

ebindIsRigid : EBind -- Bool
ebindIsRigid =
  match(
    EBStack -> emetaIsRigid,
    EBType -> emetaIsRigid,
    EBEffect -> emetaIsRigid,
    EBWord -> dip(drop3) emetaIsRigid
  )

ebindIsPlastic : EBind -- Bool
ebindIsPlastic = ebindIsRigid not


data EBinds
  MkEBinds : Map(Name, EBind) -- EBinds
end

unEBinds : EBinds -- Map(Name, EBind)
unEBinds = match(MkEBinds -> id)

ebindsNil : EBinds
ebindsNil = mapNil MkEBinds

ebindsGet : EBinds Name -- Maybe(EBind)
ebindsGet = dip(unEBinds) mapGet

ebindsSet : EBinds Name EBind -- EBinds
ebindsSet = dip2(unEBinds) mapSet MkEBinds


||| Local Scope
data ECtx
  MkECtx : EBinds Maybe(EStack) -- ECtx
end

unECtx : ECtx -- EBinds Maybe(EStack)
unECtx = match(MkECtx -> id)

ectxNil : ECtx
ectxNil = ebindsNil none MkECtx

ectxNilWithImplicits : ECtx
ectxNilWithImplicits = ectxNil # TODO

ectxUseBinds(f: EBinds a -- EBinds b) : ECtx a -- ECtx b
ectxUseBinds(f) = dip(unECtx) dip'(f) dip(MkECtx)

ectxUseStack(f: Maybe(EStack) a -- Maybe(EStack) b) : ECtx a -- ECtx b
ectxUseStack(f) = dip(unECtx) f dip(MkECtx)

ectxVars : ECtx -- Set(Name)
ectxVars = unECtx drop unEBinds mapKeys

||| Environment -- The current scope and metavariables.
data ELocal
  MkELocal : ECtx LocSet Nat -- ELocal
end

unELocal : ELocal -- ECtx LocSet Nat
unELocal = match(MkELocal -> id)

elocalNil : ELocal
elocalNil =  ectxNil locSetNull n0 MkELocal

elocalFreshNat : ELocal -- ELocal Nat
elocalFreshNat = unELocal dup dip(n1+ pnat MkELocal)

elocalUseCtx(f: ECtx a -- ECtx b) : ELocal a -- ELocal b
elocalUseCtx(f) = dip(unELocal) dip2''(f) dip(MkELocal)

elocalUseLoc(f: LocSet a -- LocSet b) : ELocal a -- ELocal b
elocalUseLoc(f) = dip(unELocal) dip'(f) dip(MkELocal)



||| Elaboration Environment
data EEnv
  MkEEnv : EWorld EFocus ELocal -- EEnv
end

unEEnv : EEnv -- EWorld EFocus ELocal
unEEnv = match(MkEEnv -> id)

eenvNil : EEnv
eenvNil = eworldNil efocusNil elocalNil MkEEnv

eenvUseWorld(f: EWorld a -- EWorld b) : EEnv a -- EEnv b
eenvUseWorld(f) = dip(unEEnv) dip2''(f) dip(MkEEnv)

eenvUseFocus(f: EFocus a -- EFocus b) : EEnv a -- EEnv b
eenvUseFocus(f) = dip(unEEnv) dip'(f) dip(MkEEnv)

eenvUseLocal(f: ELocal a -- ELocal b) : EEnv a -- EEnv b
eenvUseLocal(f) = dip(unEEnv) f dip(MkEEnv)

###############
## UTILITIES ##
###############

emGetWorld : EMonad(EWorld)
emGetWorld = unit emUse(eenvUseWorld(drop dup))

emSetWorld : EWorld -- EMonad(Unit)
emSetWorld = emUse(eenvUseWorld(nip unit))

emGetFocus : EMonad(EFocus)
emGetFocus = unit emUse(eenvUseFocus(drop dup))

emSetFocus : EFocus -- EMonad(Unit)
emSetFocus = emUse(eenvUseFocus(nip unit))

emGetLocal : EMonad(ELocal)
emGetLocal = unit emUse(eenvUseLocal(drop dup))

emSetLocal : ELocal -- EMonad(Unit)
emSetLocal = emUse(eenvUseLocal(nip unit))

emFreshNat : EMonad(Nat)
emFreshNat = unit emUse(eenvUseLocal(drop elocalFreshNat))

emFreshName : EMonad(Name)
emFreshName = emFreshNat emMap(dip("?") nat->str <> mkName)



emWith(f: a -- EMonad(b), getX : EMonad(x), setX : x -- EMonad(Unit)) : a x -- EMonad(b)
emWith(f, getX, setX) = $(
  dip(f getX) setX rotl
  emBind3(nip dip(setX) emPure emMap2(nip))
)

emGetCtx : EMonad(ECtx)
emGetCtx = unit emUse(eenvUseLocal(elocalUseCtx(drop dup)))

emSetCtx : ECtx -- EMonad(Unit)
emSetCtx = emUse(eenvUseLocal(elocalUseCtx(nip unit)))

emWithCtx(f: a -- EMonad(b)) : a ECtx -- EMonad(b)
emWithCtx(f) = emWith(f, emGetCtx, emSetCtx)

emGetLoc : EMonad(LocSet)
emGetLoc = unit emUse(eenvUseLocal(elocalUseLoc(drop dup)))

emSetLoc : LocSet -- EMonad(Unit)
emSetLoc = emUse(eenvUseLocal(elocalUseLoc(nip unit)))

emWithLoc(f: a -- EMonad(b)) : a LocSet -- EMonad(b)
emWithLoc(f) = emWith(f, emGetLoc, emSetLoc)

emGetBind : Name -- EMonad(Maybe(EBind))
emGetBind = emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(dip(dup) ebindsGet))))

emSetBind : Name EBind -- EMonad(Unit)
emSetBind = pack2 emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(unpack2 ebindsSet unit))))

emFreshType : EMonad(EType)
emFreshType = $(
  emFreshName emGetCtx
  emBind2(
    dip(dup)
    dip2(ETVar emPure)
    ectxVars none EMPlastic EBType emSetBind
    emMap2(drop)
  )
)


emFor(f: a b -- EMonad(a)) : a List(b) -- EMonad(a)
emFor(f) = lmatchL(emPure, dip(f) emPure emBind2(emFor(f)))

emForB(f: a b -- EMonad(a)) : EMonad(a) List(b) -- EMonad(a)
emForB(f) = emPure emBind2(emFor(f))

emList(f: a -- EMonad(b)) : List(a) -- EMonad(List(b))
emList(f) = dip(nil) emFor(dip(emPure) f emMap2(consR))

emFor_(f: a -- EMonad(Unit)) : List(a) -- EMonad(Unit)
emFor_(f) = dip(unit emPure) for(f emVoid2)

emGetFocusPackage : EMonad(EPackage)
emGetFocusPackage = $(
  unit emUse(eenvUseFocus(efocusUsePackage(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusPackage: Not in package." emFail,
    emPure
  ))
)

emGetFocusModule : EMonad(EModule)
emGetFocusModule = $(
  unit emUse(eenvUseFocus(efocusUseModule(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusModule: Not in module." emFail,
    emPure
  ))
)

emGetFocusInterface : EMonad(EInterface)
emGetFocusInterface = $(
  unit emUse(eenvUseFocus(efocusUseInterface(drop dup)))
  emBind(maybe(
    "Compiler Error: emGetFocusInterface: Not in module." emFail,
    emPure
  ))
)

emSetFocusPackage : EPackage -- EMonad(Unit)
emSetFocusPackage = emUse(eenvUseFocus(efocusUsePackage(nip some unit)))

emSetFocusModule : EModule -- EMonad(Unit)
emSetFocusModule = emUse(eenvUseFocus(efocusUseModule(nip some unit)))

emSetFocusInterface : EInterface -- EMonad(Unit)
emSetFocusInterface = emUse(eenvUseFocus(efocusUseInterface(nip some unit)))

emDropFocusPackage : EMonad(Unit)
emDropFocusPackage = unit emUse(eenvUseFocus(efocusUsePackage(dip(drop none))))

emDropFocusModule : EMonad(Unit)
emDropFocusModule = unit emUse(eenvUseFocus(efocusUseModule(dip(drop none))))

emDropFocusInterface : EMonad(Unit)
emDropFocusInterface = unit emUse(eenvUseFocus(efocusUseInterface(dip(drop none))))

emSaveFocusModule : EMonad(Unit)
emSaveFocusModule = $(
  emGetFocusPackage emGetFocusModule
  emBind2(epackageAddModule) emBind(emSetFocusPackage)
  emThen(emDropFocusModule)
)

emSaveFocusInterface : EMonad(Unit)
emSaveFocusInterface = $(
  emGetFocusModule emGetFocusInterface
  emBind2(emoduleAddInterface) emBind(emSetFocusModule)
  emThen(emDropFocusInterface)
)


emGetDef : Name -- EMonad(Maybe(EDef))
emGetDef = emUse(eenvUseFocus(dip(dup) efocusGetDef))

emGetGlobal : ESym -- EMonad(Maybe(EDef))
emGetGlobal = emUse(eenvUseWorld(dip(dup) eworldGetDef))

emAddDefs : EDefs -- EMonad(Unit)
emAddDefs = $(
  emPure dup emUnit
  emGetFocus emBind3(nip swap efocusAddDefs emBind(emSetFocus))
  emGetWorld emBind3(nip swap eworldAddDefs emBind(emSetWorld))
)

emAddDef : Name EDef -- EMonad(Unit)
emAddDef = edefsSingle emAddDefs

emMkTypeSym : Name -- EMonad(ESym)
emMkTypeSym = emUse(eenvUseFocus(dip(dup) efocusTypeSym))

emMkWordSym : Name -- EMonad(ESym)
emMkWordSym = emUse(eenvUseFocus(dip(dup) efocusWordSym))


########################
## ACTUAL ELABORATION ##
########################

elabL(f: a -- EMonad(b)) : L(a) -- EMonad(b)
elabL(f) = unL swap emWithLoc(f)

elabL2(f: a b -- EMonad(c)) : a L(b) -- EMonad(c)
elabL2(f) = unL swap dip(pack2) emWithLoc(unpack2 f)

elabL3(f: a b c -- EMonad(d)) : a b L(c) -- EMonad(d)
elabL3(f) = unL swap dip(pack3) emWithLoc(unpack3 f)

elabLModuleHead : Mod L(Module) -- EMonad(Unit)
elabLModule : Mod L(Module) -- EMonad(Unit)
elabLImport : L(Import) -- EMonad(Unit)
elabLExport : L(Export) -- EMonad(Unit)
elabLSig : L(Sig) -- EMonad(Unit)
elabLDecl : L(Decl) -- EMonad(Unit)
elabLTypeSig : L(TypeSig) -- EMonad(Unit)
elabLDataDef : L(DataDef) -- EMonad(Unit)
elabLWordSig : L(WordSig) -- EMonad(Unit)
elabLWordDef : L(WordDef) -- EMonad(Unit)
elabLAssertion : L(Assertion) -- EMonad(Unit)

elabLParams : L(Params) -- EMonad(EParams)

elabPackage : Pkg Map(Mod, L(Module)) -- EMonad(Unit)
elabModuleHead : Mod Module -- EMonad(Unit)
elabModule : Mod Module -- EMonad(Unit)
elabImport : Import -- EMonad(Unit)
elabExport : Export -- EMonad(Unit)
elabSig : Sig -- EMonad(Unit)
elabDecl : Decl -- EMonad(Unit)
elabTypeSig : TypeSig -- EMonad(Unit)
elabDataDef : DataDef -- EMonad(Unit)
elabWordSig : WordSig -- EMonad(Unit)
elabWordDef : WordDef -- EMonad(Unit)
elabAssertion : Assertion -- EMonad(Unit)

elabParams : Params -- EMonad(EParams)

elabLModuleHead = elabL2(elabModule)
elabLModule = elabL2(elabModule)
elabLImport = elabL(elabImport)
elabLExport = elabL(elabExport)
elabLDecl = elabL(elabDecl)
elabLSig = elabL(elabSig)
elabLTypeSig = elabL(elabTypeSig)
elabLDataDef = elabL(elabDataDef)
elabLWordSig = elabL(elabWordSig)
elabLWordDef = elabL(elabWordDef)
elabLAssertion = elabL(elabAssertion)
elabLParams = elabL(elabParams)

elabPackage = $(
  dip(epackageNil emSetFocusPackage emDropFocusModule emDropFocusInterface emVoid3)
  dup dip(mapFor(elabLModuleHead emSaveFocusModule emVoid3))
  mapFor(elabLModule emSaveFocusModule emVoid3)
)

elabModuleHead = $(
  dip(emoduleNil emSetFocusModule)
  unModule drop
  dip(getL emFor_(elabLImport))
  getL emFor_(elabLExport emSaveFocusInterface emVoid2)
  emDropFocusInterface
  emVoid4
)

elabModule = $(
  dip(emoduleNil emSetFocusModule)
  unModule
  dip2(getL emFor_(elabLImport))
  dip(getL emFor_(elabLExport emSaveFocusInterface emVoid2))
  getL emFor_(elabLDecl)
  emVoid4
)

elabImport = unImport elabL(
  dip(emGetFocusModule) emPure
  emBind2(emoduleUseImports(eimportsAdd unit) drop emSetFocusModule)
)

elabExport = $(
  dup dip(exportInterface getL einterfaceNil emSetFocusInterface)
  exportSigs emFor_(elabLSig)
  emVoid2
)

elabDecl =
  matchDecl(
    elabLTypeSig,
    elabLDataDef,
    elabLWordSig,
    elabLWordDef,
    elabLAssertion
  )

elabSig =
  matchSig(
    elabLTypeSig,
    elabLWordSig,
    elabLAssertion
  )


elabTypeSig = $(
  dup dip(typeSigName getL dup dip(emPure) emMkTypeSym)
  ectxNilWithImplicits emWithCtx(typeSigParams elabLParams)
  emBind3(MkETypeDef EDType emAddDef)
)

elabDataDef = drop emUnit
elabWordSig = drop emUnit
elabWordDef = drop emUnit
elabAssertion = drop emUnit

elabParams = drop MkEParams emPure # TODO

runElabModule : Mod L(Module) -- EResult(EModule)
runElabModule = $(
  elabLModule emThen(emGetFocusModule)
  dip(eenvNil) emRun nip
)

runElabPackage : Pkg Map(Mod, L(Module)) -- EResult(EPackage)
runElabPackage = $(
  elabPackage emThen(emGetFocusPackage)
  dip(eenvNil) emRun nip
)

