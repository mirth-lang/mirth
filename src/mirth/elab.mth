module(mirth/elab)
import(mirth/data/name)
import(mirth/data/token)
import(mirth/data/type)

##############
# Elaborator #
##############

buffer(ELAB_TOKEN, 8)
def(elab-token@, -- Token +Elab, ELAB_TOKEN token@)
def(elab-token!, Token -- +Elab, ELAB_TOKEN token!)
def(elab-emit-warning!, Str -- +Elab, dip(elab-token@) emit-warning!)
def(elab-emit-error!, Str -- +Elab, dip(elab-token@) emit-error!)
def(elab-emit-fatal-error!, *a Str -- *b +Elab, dip(elab-token@) emit-fatal-error!)

buffer(ELAB_STACK, 8)
def(elab-stack@, -- Type +Elab, ELAB_STACK type@)
def(elab-stack!, Type -- +Elab, ELAB_STACK type!)

buffer(ELAB_CTX, 8)
def(elab-ctx@, -- Ctx +Elab, ELAB_CTX ctx@)
def(elab-ctx!, Ctx -- +Elab, ELAB_CTX ctx!)

####################
# Type Elaboration #
####################

def(elab-type-sig!, Ctx Token -- Ctx Type Token,
    elab-type-stack!
    token-is-dashes? if(
        token-next
        dip(swap) elab-type-stack!
        dip(dip(swap) morphism-type-new! TMorphism),

        dip(TYPE_UNIT swap morphism-type-new! TMorphism)
    )) # TODO: elaborate effect type too

def(elab-type-stack!, Ctx Token -- Ctx Type Token,
    sig-token-is-stack-var? if(
        elab-stack-var! dip(TVar),
        dip(TYPE_UNIT)
    )
    elab-type-stack-rest!)

def(elab-type-stack-rest!, Ctx Type Token -- Ctx Type Token,
    while(sig-is-stack-end2? not,
        dip(swap)
        elab-type-atom!
        dip(dip(swap) tensor-type-new! TTensor)
    ))

def(sig-is-stack-end2?, Token -- Token Bool,
    sig-is-stack-end? if(
        true,
        sig-token-is-effect-con?
    ))

def(elab-type-atom!, Ctx Token -- Ctx Type Token,
    sig-token-is-type-var? if(
        elab-type-var! dip(TVar),

    sig-token-is-type-con? if(
        elab-type-con!,

    token-is-lbracket? if(
        elab-type-quote!,

        dup "Expected type, got unknown token." emit-error!
        dip(TYPE_ERROR) token-next
    ))))

def(elab-stack-var!, Ctx Token -- Ctx Var Token,
    TYPE_STACK elab-implicit-var!)

def(elab-type-var!, Ctx Token -- Ctx Var Token,
    TYPE_TYPE elab-implicit-var!)

def(elab-implicit-var!, Ctx Token Type -- Ctx Var Token,
    over
    dip(dip(
        token-name@
        dup2 swap ctx-has-name
    ))
    rotl if(
        dip(dip(over ctx-lookup var-type?))
        elab-type-unify! nip,

        dip(
            dip(var-new-implicit!)
            over var-type!
            dup dip(ctx-new!)
        )
    )
    token-next)

def(elab-type-con!, Ctx Token -- Ctx Type Token,
    token-has-args? if(
        dup "Types with args not yet supported." emit-error! TYPE_ERROR,

        token-name?
        name-is-type? if(
            name-type@,

        name-undefined? if(
            drop dup "Unknown type." emit-error! TYPE_ERROR,
            drop dup "Not a type." emit-error! TYPE_ERROR
        ))
    )
    swap token-next)

def(elab-type-quote!, Ctx Token -- Ctx Type Token,
    token-bracket-arg
    sig-has-dashes? if(
        elab-type-sig!,
        elab-type-stack!
    )
    token-next)

def(elab-type-unify!, Type Type Token -- Type Token,
    elab-token@ dip(
        dup elab-token! dip(type-unify!)
    ) elab-token!)
    # TODO treat token as an input in type-unify

####################
# Word Elaboration #
####################

def(elab-external-sig!, External -- Type +Elab,
    elab-external-ctx-sig! nip)

def(elab-external-ctx!, External -- Ctx +Elab,
    elab-external-ctx-sig! drop)

def(elab-external-ctx-sig!, External -- Ctx Type +Elab,
    external-sig-is-checked? if(
        external-type? dip(external-ctx@),

        external-sig? ctx-empty swap
        elab-type-sig! drop dup2
        dip(dip(
            rotl
            tuck external-type!
            tuck external-ctx!
            external-sig-is-checked!
        ))
    ))

def(elab-word-sig!, Word -- Type +Elab,
    elab-word-ctx-sig! nip)

def(elab-word-ctx!, Word -- Ctx +Elab,
    elab-word-ctx-sig! drop)

def(elab-word-ctx-sig!, Word -- Ctx Type +Elab,
    word-sig-is-checked? if(
        word-type? dip(word-ctx@),

        word-sig? ctx-empty swap
        elab-type-sig! drop dup2
        dip(dip(
            rotl
            tuck word-type!
            tuck word-ctx!
            word-sig-is-checked!
        ))
    ))

def(elab-word-body!, Word -- Arrow +Elab,
    word-body-is-checked? if(
        word-arrow@,
        dup elab-word-sig! drop

        elab-ctx@ dip(
        elab-token@ dip(
        elab-stack@ dip(
            dup word-ctx@ elab-ctx!
            dup word-body@ elab-token!
            dup word-dom@ elab-stack!

            dup word-body@

            # dup token-location Col->Int 1- Int->Col location-trace!
            # ": warning: domain = " str-trace!
            # elab-stack@ type-trace! trace-ln!

            elab-arrow!

            over word-cod@

            # elab-token@ token-location location-trace!
            # ": warning: codomain = " str-trace!
            # dup type-trace! trace-ln!

            elab-stack@ type-unify! drop
            over word-body-is-checked!
            tuck swap word-arrow!
        ) elab-stack!
        ) elab-token!
        ) elab-ctx!
    ))

def(elab-stack-pop!, Type +Elab,
    elab-stack@
    type-expand
    dup TYPE_ERROR = if(
        dup,

    type-is-meta? if(
        type-expand-tensor tensor-type-unpack,

    type-is-tensor? if(
        type-get-tensor tensor-type-unpack,

        "(temporary?) stack underflow" elab-emit-warning!
        drop TYPE_ERROR TYPE_ERROR
    )))
    dip(elab-stack!))

def(elab-stack-pop2!, Type Type +Elab,
    elab-stack-pop! dip(elab-stack-pop!))

def(elab-stack-pop3!, Type Type Type +Elab,
    elab-stack-pop! dip(elab-stack-pop2!))

def(elab-stack-push!, Type -- +Elab,
    elab-stack@ swap tensor-type-new! TTensor elab-stack!)

def(elab-stack-push2!, Type Type -- +Elab,
    dip(elab-stack-push!) elab-stack-push!)

def(elab-stack-push3!, Type Type Type -- +Elab,
    dip(elab-stack-push2!) elab-stack-push!)

def(elab-token-next!, +Elab,
    elab-token@ token-next elab-token!)

def(elab-arrow!, Token -- Arrow +Elab,
    elab-token!
    elab-arrow-step! dup
    while(elab-token@ token-is-arg-end? nip not,
        elab-token-next!
        elab-arrow-step!
        dup dip(swap arrow-next!))
    drop)

def(elab-arrow-step!, Arrow +Elab,
    arrow-alloc!
    elab-stack@ over arrow-dom!
    elab-token@ over arrow-token!

    elab-token@
    token-is-arg-end? if(
        drop,
    token-is-int? if(
        token-int@ elab-arrow-step-int!,
    token-is-str? if(
        token-value@ TokenValue->Int Int->StrLit elab-arrow-step-str!, # TODO: fix this
    token-is-name? if(
        token-name@ elab-arrow-step-name!,
    token-is-lbrace? if(
        elab-arrow-step-stack-assertion!,
        drop "compiler error: unexpected token type" elab-emit-fatal-error!
    ))))))

def(elab-arrow-step-name!, Arrow Name -- Arrow +Elab,
    name-is-buffer? if(
        name-buffer@ elab-arrow-step-buffer!,
    name-is-external? if(
        name-external@ elab-arrow-step-external!,
    name-is-word? if(
        name-word@ elab-arrow-step-word!,
    name-is-prim? if(
        name-prim@ elab-arrow-step-prim!,

        drop
        "Unknown word" elab-emit-fatal-error!
        TYPE_ERROR elab-stack!
    )))))

def(elab-arrow-step-int!, Arrow Int -- Arrow +Elab,
    over arrow-op-int!
    TYPE_INT elab-stack-push!)

def(elab-arrow-step-str!, Arrow StrLit -- Arrow +Elab,
    over arrow-op-str!
    TYPE_PTR elab-stack-push!) # TODO: add primitive STR type?

def(elab-arrow-step-buffer!, Arrow Buffer -- Arrow +Elab,
    over arrow-op-buffer!
    TYPE_PTR elab-stack-push!)

def(elab-arrow-step-external!, Arrow External -- Arrow +Elab,
    dup2 swap arrow-op-external!
    elab-token@ token-args-0 # high order not yet supported
    elab-external-sig! elab-arrow-freshen-apply-sig-type!)

def(elab-arrow-step-word!, Arrow Word -- Arrow +Elab,
    dup2 swap arrow-op-word!
    elab-token@ token-args-0 # high order not yet supported
    elab-word-sig! elab-arrow-freshen-apply-sig-type!)

def(elab-arrow-step-stack-assertion!, Arrow Token -- Arrow +Elab,
    tuck
    token-brace-arg
    dip(elab-ctx@ dup)
    elab-type-stack! drop
    rotr swap dup2 = if(drop2,
        "stack assertion introduced new type variables:" elab-emit-warning!
        "\tbefore: " str-trace! ctx-trace! trace-ln!
        "\tafter:  " str-trace! ctx-trace! trace-ln!
        drop
        TYPE_ERROR
    )
    dup morphism-type-new! TMorphism
    elab-arrow-apply-sig-type!
    dip(elab-token!)
    )

def(elab-arrow-apply-sig-type!, Arrow Type -- Arrow +Elab,
    type-expand-morphism morphism-type-unpack swap
    type-expand
    while(type-is-tensor?,
        type-get-tensor
        tensor-type-unpack
        elab-stack-pop! type-unify! {Type} drop
        type-expand
    )
    dup TYPE_ERROR = if(
        dip(drop) elab-stack!,

    dup TYPE_UNIT = if( # save arrow codip depth ?
        drop
        elab-stack@ swap stack-type-concat elab-stack!,

        drop
        elab-stack!
    )))

def(elab-arrow-freshen-apply-sig-type!, Arrow Type -- Arrow +Elab,
    dip(SUBST_NIL) type-freshen drop
    nip # TODO save arrow subst
    elab-arrow-apply-sig-type!
)

def(stack-type-concat, Type Type -- Type,
    type-expand
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_UNIT = if(
        drop,

    type-is-tensor? if(
        type-get-tensor tensor-type-unpack dip(stack-type-concat)
        tensor-type-new! TTensor,

        "compiler error: expected stack type in stack-type-concat" elab-emit-fatal-error!
    ))))

def(elab??, +Elab,
    elab-token@ token-location location-trace! ": warning: stack = " str-trace!
    elab-stack@ type-trace! trace-ln!)

def(elab-arrow-step-prim!, Arrow Prim -- Arrow +Elab,
    dup2 swap arrow-op-prim!

    dup PRIM_DIP = if(
        drop elab-arrow-step-dip!,
    dup PRIM_IF = if(
        drop elab-arrow-step-if!,
    dup PRIM_WHILE = if(
        drop elab-arrow-step-while!,

    dup PRIM_DROP = if(
        drop elab-token@ token-args-0
        elab-stack-pop! drop,
    dup PRIM_SWAP = if(
        drop elab-token@ token-args-0
        elab-stack-pop2! swap elab-stack-push2!,
    dup PRIM_DUP = if(
        drop elab-token@ token-args-0
        elab-stack@
        dup TYPE_ERROR = if(
            drop,
            type-expand-tensor tensor-type-snd@ elab-stack-push!
        ),

    dup PRIM_INT_EQ = if(
        drop elab-token@ token-args-0
        elab-stack-pop2! elab= elab-stack-push!,


    dup PRIM_POSIX_EXIT = if(
        drop elab-token@ token-args-0
        elab-stack-pop! TYPE_INT type-unify! drop
        meta-alloc! TMeta elab-stack!,
    dup PRIM_DEBUG = if(
        drop elab-token@ token-args-0,

    dup PRIM_CAST = if(
        drop elab-token@ token-args-0
        elab-stack-pop! drop meta-alloc! TMeta elab-stack-push!,

        elab-token@ token-args-0
        prim-type@ elab-arrow-apply-sig-type!
    )))))))))))

def(elab-arrow-step-dip!, Arrow -- Arrow +Elab,
    elab-token@ dip(
    elab-stack-pop! dip(
        elab-token@ token-args-1
        elab-arrow! Arrow->Arg arrow-arg-add!
    ) elab-stack-push!
    ) elab-token!
    )

def(elab-arrow-step-if!, Arrow -- Arrow +Elab,
    elab-stack-pop! TYPE_BOOL type-unify! drop
    elab-token@ dup dip(
        token-args-2
        elab-stack@ dip(
            dip(elab-arrow! Arrow->Arg arrow-arg-add!)
        )
        elab-stack@ dip(
            elab-stack! elab-arrow! Arrow->Arg arrow-arg-add!
        )
    ) elab-token!
    elab-stack@ type-unify! drop)

def(elab-arrow-step-while!, Arrow -- Arrow +Elab,
    elab-token@ dip(
        elab-stack@ dip(
            elab-token@ token-args-2
            dip(elab-arrow! Arrow->Arg arrow-arg-add!)
            elab-stack-pop! TYPE_BOOL type-unify! drop
        )
        elab-stack@ type-unify! dip(
            elab-arrow! Arrow->Arg arrow-arg-add!
        )
        elab-stack@ type-unify!
        elab-stack!
    ) elab-token!)


# elab for =
def(elab=, Type Type -- Type, type-unify! drop TYPE_BOOL)

def(elab-posix-exit, Type -- +Elab,
    TYPE_INT expect1 drop) # TODO: set absurd flag

def(expect1, Type Type -- Bool +Elab,
    type-unify! TYPE_ERROR = not)


#############
# Type Sigs #
#############

def(token-is-dashes, Token -- Bool,
    token-type? TOKEN_NAME = if(
        token-name@ PRIM_DASHES prim-name@ =,
        drop false
    ))

def(token-is-dashes?, Token -- Token Bool,
    dup token-is-dashes)

def(sig-is-stack-end?, Token -- Token Bool,
    token-is-dashes? if(
        true,
        token-run-end?
    ))

def(sig-has-dashes, Token -- Bool,
    while(sig-is-stack-end? not, token-next)
    token-is-dashes)

def(sig-has-dashes?, Token -- Token Bool,
    dup sig-has-dashes)

def(sig-arity, Token -- Int Int,
    sig-has-dashes? if(
        sig-count-types
        token-next
        sig-count-types
        drop,

        dip(0)
        sig-count-types
        drop
    ))

def(sig-count-types, Token -- Int Token,
    dip(0)
    while(sig-is-stack-end? not,
        sig-token-is-type? if(dip(1+), id)
        token-next
    ))

def(sig-token-is-type?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type,
        false
    ))

def(sig-token-is-type-con?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type-con,
        false
    ))

def(sig-token-is-type-var?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type-var,
        false
    ))

def(sig-token-is-stack-var?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-stack-var,
        false
    ))

def(sig-token-is-effect-con?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-effect-con,
        false
    ))

def(sig-skip-dashes, Token -- Token,
    sig-has-dashes? if(
        while(token-is-dashes? not, token-next) token-next,
        id
    ))


#############
## ELAB V2 ##
#############

||| Elaborate all of a module.
def(elab-module!, Module -- Module +Mirth,
    module-start?
    elab-module-header!
    elab-module-imports!
    elab-module-decls!
    drop)

||| Check that the `module(M)` statement exists and save the name.
def(elab-module-header!, Module Token -- Module Token +Mirth,
    PRIM_MODULE token-prim=? if(
        dup2 elab-module-name! token-next,
        dup "Expected module header." emit-error!
    ))

||| Check & save the module name from the module header `module(M)`.
def(elab-module-name!, Module Token -- +Mirth,
    token-args-1 token-is-name? if(
        token-name?
        name-defined? if(
            drop "module name already taken" emit-fatal-error!,
            nip dup2 name-module!
            swap module-name!
        ),
        "expected module name" emit-fatal-error!
    ))


||| Elaborate module imports. Return token after imports.
def(elab-module-imports!, Module Token -- Module Token +Mirth,
    while(PRIM_IMPORT token-prim=?, elab-module-import!))

||| Elaborate `import(M)` statement. Return token after import.
def(elab-module-import!, Module Token -- Module Token +Mirth,
    dup dip(token-next)
    token-args-1 token-is-name? if(
        token-name?

        name-is-module? if(
            drop2, # module is already loaded (TODO: add import to a list)

        name-undefined? if(
            nip name-load! ".mth" str-buf-push-str!
            STR_BUF Str->Path run-lexer!
            elab-module! drop, # elab the imported module (TODO: add import to a list)

            drop "module name already taken" emit-fatal-error!
        )),
        "expected module name" emit-fatal-error!
    ))

||| Elaborate the rest of the module.
def(elab-module-decls!, Module Token -- Module Token +Mirth,
    while(token-is-module-end? not, elab-module-decl!))

||| Elaborate a declaration. Returns the next token.
def(elab-module-decl!, Module Token -- Module Token +Mirth,
    PRIM_DEF token-prim=? if( elab-def!,
    PRIM_DEF_EXTERNAL token-prim=? if( elab-def-external!,
    PRIM_DEF_TYPE token-prim=? if( elab-def-type!,
    PRIM_NOMINAL token-prim=? if( elab-nominal!,
    PRIM_BUFFER token-prim=? if( elab-buffer!,
    PRIM_TABLE token-prim=? if( elab-table!,
    PRIM_FIELD token-prim=? if( elab-field!,
    PRIM_TARGET_C99 token-prim=? if(elab-target-c99!,
    "unknown declaration" emit-fatal-error!)))))))))

||| Elaborate a word definition `def(w, t, b)`.
def(elab-def!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-3
    rotl token-type? TOKEN_NAME = if(
        token-name? name-undefined? if(
            nip
            word-alloc!
            dup2 swap name-word!
            dup dip(word-name!)
            dup dip(word-body!)
            word-sig!,

            drop "word already defined" emit-fatal-error!
        ),
        "expected word name" emit-fatal-error!
    ))

||| Elaborate an external declaration `def-external(w, t)`
def(elab-def-external!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap token-type? TOKEN_NAME = if(
        token-name? name-undefined? if(
            nip
            external-alloc!
            dup2 swap name-external!
            tuck external-name!
            external-sig!,

            drop "word already defined" emit-fatal-error!
        ),
        "expected word name" emit-fatal-error!
    ))

||| Elaborate a type definition `def-type(t1, t2)`.
def(elab-def-type!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap sig-token-is-type-con? if(
        token-name? name-undefined? if(
            nip swap
            sig-token-is-type-con? if(
                token-name?
                name-is-type? if(
                    name-type@ nip,
                    drop "Unknown type." emit-error!
                    TYPE_ERROR
                ),
                "Expected a type." emit-error!
                TYPE_ERROR
            )
            swap name-type!,

            drop "type already defined" emit-fatal-error!
        ),
        "expected type constructor" emit-fatal-error!
    ))

||| Elaborate a nominal type definition `nominal(t1, t2)`.
def(elab-nominal!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap sig-token-is-type-con? if(
        token-name? name-undefined? if(
            nip swap
            sig-token-is-type-con? if(
                token-name?
                name-is-type? if(
                    name-type@ nip,
                    drop "Unknown type." emit-error! TYPE_ERROR
                ),
                "Expected a type." emit-error! TYPE_ERROR
            )
            over dip(nominal-new! TNominal) name-type!,

            drop "type already defined" emit-fatal-error!
        ),
        "expected type constructor" emit-fatal-error!
    ))

||| Elaborate a buffer definition `buffer(B, size)`.
def(elab-buffer!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap token-type? TOKEN_NAME = if(
        token-name? name-undefined? if(
            nip swap
            token-type? TOKEN_INT = if(
                token-int@ buffer-alloc! drop,
                "expected buffer size" emit-fatal-error!
            ),
            drop "buffer already defined" emit-fatal-error!
        ),
        "expected buffer name" emit-fatal-error!
    ))

||| Elaborate a table definition `table(T)`.
def(elab-table!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-1
    sig-token-is-type-con? if(
        token-name@ table-new! drop,
        "expected table name" emit-fatal-error!
    ))

||| Elaborate a field definition `field(f, T1, T2)`.
def(elab-field!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-3
    rotl token-type? TOKEN_NAME = if(
        token-name@
        rotl token-type? TOKEN_NAME = if(
            token-name?
            name-is-table? if(
                nip name-type@ type-get-table
                rotl sig-token-is-type-con? if(
                    token-name?
                    name-is-type? if(
                        nip name-type@ field-new! drop,
                        drop "unknown field type" emit-fatal-error!
                    ),
                    "expected field type" emit-fatal-error!
                ),
                drop "unknown table name" emit-fatal-error!
            ),
            "expected table name" emit-fatal-error!
        ),
        "expected field name" emit-fatal-error!
    ))

||| Elaborate C99 build target.
def(elab-target-c99!, Module Token -- Module Token +Mirth,
    dup dip(token-next) token-args-2
    swap token-type? TOKEN_STR = if(
        token-str@ Str->Path run-output-c99!,
        "Expected relative C file path (a string)." emit-fatal-error!
    ))

||| Is this the end of a module?
def(token-is-module-end?, Token -- Token Bool,
    token-type? TOKEN_NONE =)

# Is this a token to stop running at?
def(token-run-end?, Token -- Token Bool +Mirth,
    dup Token->Int num-tokens@ >= if(
        true,
    token-type? TOKEN_NONE = if(
        true,
    token-type? TOKEN_COMMA = if(
        true,
    token-type? TOKEN_RPAREN = if(
        true,
    token-type? TOKEN_RBRACKET = if(
        true,
        token-type? TOKEN_RBRACE =
    ))))))

||| Does the token match the primitive?
def(token-prim=?, Token Prim -- Token Bool,
    dip(token-is-name?) swap if(
        dip(token-name?) prim-name@ =,
        drop false
    ))
