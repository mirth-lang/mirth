module(mirth.c99)

import(std.prelude)
import(std.str)
import(std.stack)
import(std.path)
import(std.list)
import(std.lazy)
import(std.byte)
import(std.maybe)

import(posix.file)
import(posix.output)

import(mirth.error)
import(mirth.module)
import(mirth.location)
import(mirth.token)
import(mirth.name)
import(mirth.buffer)
import(mirth.arrow)
import(mirth.word)
import(mirth.table)
import(mirth.variable)
import(mirth.external)
import(mirth.constant)
import(mirth.ctx)
import(mirth.tycon)
import(mirth.type)
import(mirth.data)
import(mirth.package)
import(mirth.prim)
import(mirth.var)
import(mirth.match)
import(mirth.elab)
import(mirth.need)
import(mirth.label)

#######
# C99 #
#######

data(OutputPath, OUTPUT_PATH -> Path)
def(OutputPath.>Str, OutputPath -- Str, OUTPUT_PATH -> >Str)
def(OutputPath.as-relative-path, OutputPath -- Path, OUTPUT_PATH -> )

data(EmitDebugInfo, EMIT_DEBUG_INFO -> Bool)
def(EmitDebugInfo.>Str, EmitDebugInfo -- Str, EMIT_DEBUG_INFO -> if("yes", "no"))
def(EmitDebugInfo.>Bool, EmitDebugInfo -- Bool, EMIT_DEBUG_INFO -> id)

data(C99_Options, C99_OPTIONS -> OutputPath EmitDebugInfo)
def(C99_Options.make, output-path:Path emit-debug-info:Bool -- C99_Options,
    output-path> OUTPUT_PATH
    emit-debug-info> EMIT_DEBUG_INFO
    C99_OPTIONS)
def(C99_Options.emit-debug-info, C99_Options -- EmitDebugInfo, C99_OPTIONS -> nip)
def(C99_Options.output-path, C99_Options -- OutputPath, C99_OPTIONS -> drop)

data(+C99, MKC99 -> C99_Options Nat +Needs +Output)

def(+C99.depth@, +C99 -- Nat +C99, /MKC99 dup dip(MKC99))
def(+C99.depth!, Nat +C99 -- +C99, dip(/MKC99 drop) MKC99)
def(+C99.options@, +C99 -- C99_Options +C99, /MKC99 over dip(MKC99))

def(+C99.emit-debug-info?, +C99 -- Bool +C99, options@ emit-debug-info >Bool)

def(+C99.~Needs(f), (*a +Needs -- *b +Needs) *a +C99 -- *b +C99,
    /MKC99 dip(dip(rdip(f))) MKC99)
def(+C99.~Output(f), (*a +Output -- *b +Output) *a +C99 -- *b +C99,
    /MKC99 dip(dip(rdip'(f))) MKC99)

def(+C99.put, Str +C99 -- +C99, ~Output(put))
def(+C99.put-byte, Byte +C99 -- +C99, ~Output(put-byte))
def(+C99.line, +C99 -- +C99, ~Output(line))

def(c99-start!, Arrow C99_Options +World -- Arrow +World +C99,
    dup output-path as-relative-path create-file! output-start!
    rdip(+Needs.new over determine-arrow-needs!)
    0 >Nat MKC99)

def(c99-end!, +World +C99 -- +World,
    /MKC99 drop2 rdip(rdrop) output-end! +File.close-file!)

def(run-output-c99!, Arrow C99_Options +World -- +World,
    num-errors @ 0> if(
        drop2,

        c99-start!
        c99-header!
        c99-label-defs!
        c99-tags!
        c99-buffers!
        c99-variables!
        c99-externals!
        c99-word-sigs!
        c99-block-sigs!
        c99-field-sigs!
        c99-main!
        c99-field-defs!
        c99-word-defs!
        c99-block-defs!
        c99-end!
    ))

def(Namespace.mangled, Namespace -- Str,
    NAMESPACE_ROOT -> "__root__",
    NAMESPACE_PACKAGE -> name mangled,
    NAMESPACE_MODULE -> qname mangled,
    NAMESPACE_TYCON -> qname mangled)
def(QName.mangled, QName -- Str, QNAME -> dip(mangled "_" cat) mangled cat)
def(+C99.sig-put, QName +C99 -- +C99, "static void mw_" put mangled put " (void)" put)
def(+C99.cosig-put, QName +C99 -- +C99, "static void mp_" put mangled put " (void)" put)

embed-str(c99-header-str, "src/mirth/mirth.h")
def(c99-header!, +C99 -- +C99,
    "#define MIRTH_DEBUG " put
    emit-debug-info? if("1", "0") put line
    c99-header-str put line)

def(c99-buffers!, +C99 -- +C99, Buffer.for(c99-buffer!))
def(c99-buffer!, Buffer +C99 -- +C99,
    dup qname sig-put " {" put line
    "\tstatic uint8_t b[" put dup size show put "] = {0};" put line
    "\tpush_ptr(&b);" put line
    "}" put line
    drop)

def(c99-variables!, +C99 -- +C99, Variable.for(c99-variable!))
def(c99-variable!, Variable +C99 -- +C99,
    qname sig-put " {" put line
    "\tstatic VAL v = {0};" put line
    "\tpush_ptr(&v);" put line
    "}" put line)

def(c99-tags!, +C99 -- +C99, Tag.for(c99-tag!))
def(c99-tag!, Tag +C99 -- +C99,
    dup qname sig-put " {" put line
    dup is-transparent? else(
        "\tVAL tag = MKU64(" put dup value show put "LL);" put line
        "\tVAL car = (" put
        dup num-type-inputs repeat(
            "pop_value());" put line
            "\tcar = mkcons(car, " put
        )
        dup num-resource-inputs repeat(
            "pop_resource());" put line
            "\tcar = mkcons(car, " put
        )
        dup label-inputs reverse-for(
            "lpop(&lbl_" put name mangled put "));" put line
            "\tcar = mkcons(car, " put
        )
        "tag);" put line
        dup outputs-resource? if(
            "\tpush_resource(car);",
            "\tpush_value(car);"
        ) put line
    )
    "}" put line

    dup qname cosig-put " {" put line
    dup is-transparent? else(
        dup outputs-resource? if(
            "\tVAL car = pop_resource();",
            "\tVAL car = pop_value();"
        ) put line
        dup num-resource-inputs over num-type-inputs + over label-inputs len + 0> then(
            "\tVAL cdr;" put line
        )
        "\tdecref("
        over label-inputs for(
            "\tvalue_uncons_c(car, &car, &cdr);" put line
            swap put "cdr);" put line
            "\tlpush(&lbl_" swap name mangled cat ", " cat
        )
        over num-resource-inputs repeat(
            "\tvalue_uncons_c(car, &car, &cdr);" put line
            put "cdr);" put line
            "\tpush_resource("
        )
        over num-type-inputs repeat(
            "\tvalue_uncons_c(car, &car, &cdr);" put line
            put "cdr);" put line
            "\tpush_value("
        )
        put "car);" put line
    )
    "}" put line

    drop)

def(c99-externals!, +C99 -- +C99,
    External.for(c99-external!))

def(c99-external!, External +C99 -- +C99,
    dup sig sig-arity
    dup 2 >Nat >= if(
        "can't declare external with multiple return values" panic!,

        dup 1 >Nat >= if(
            "int64_t ",
            "void "
        ) put
    )

    dip2(dup symbol put)

    " (" put
    over dup 0> if("int64_t" put 1- repeat(", int64_t" put), drop "void" put)
    ");" put line

    dip2(dup qname sig-put) " {" put line
    over countdown("\tint64_t x" put show put " = pop_i64();" put line)
    dup 0> if("\tpush_i64(", "\t") put
    dip2(dup symbol put)
    "(" put
    dip(dup 0> if(
        dup 1- dup count("x" put show put ", " put) "x" put show put,
        id
    ))
    ")" put
    dup 0> if(");", ";") put line
    "}" put line
    drop3)

def(c99-nest(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99,
    depth@ 1+ depth!
    f
    depth@ 1- depth!)

def(+C99.indent, +C99 -- +C99, depth@ repeat("\t" put))
def(c99-line(f), (*a +C99 -- *b +C99) *a +C99 -- *b +C99, indent f line)

def(c99-call!, List(Arg) QName +C99 -- +C99,
    dip(c99-args-push!)
    c99-line("mw_" put mangled put "();" put))

def(c99-arrow!, Arrow +C99 -- +C99, atoms for(c99-atom!))
def(c99-atom!, Atom +C99 -- +C99,
    emit-debug-info? then(
        c99-line("WORD_ATOM(" put
            dup token row >Int show put ", " put
            dup token col >Int show put ", " put
            dup token name? if-some(>Str, "") put-cstr
            ");" put
        )
    )
    sip(args) op
    c99-args-op!)

def(c99-args-op!, List(Arg) Op +C99 -- +C99,
    OP_NONE     -> drop,
    OP_INT      -> nip c99-int!,
    OP_STR      -> nip c99-str!,
    OP_CONSTANT -> nip c99-constant!,
    OP_WORD     -> qname c99-call!,
    OP_EXTERNAL -> qname c99-call!,
    OP_BUFFER   -> qname c99-call!,
    OP_VARIABLE -> qname c99-call!,
    OP_FIELD    -> qname c99-call!,
    OP_TAG      -> qname c99-call!,
    OP_PRIM     -> c99-prim!,
    OP_MATCH    -> nip c99-match!,
    OP_LAMBDA   -> nip c99-lambda!,
    OP_VAR      -> nip c99-var!,
    OP_BLOCK    -> nip c99-block-push!,
    OP_COERCE   -> drop2,
    OP_LABEL_PUSH -> nip c99-label-push!,
    OP_LABEL_POP  -> nip c99-label-pop!)

def(c99-label-defs!, +C99 -- +C99, Label.for(c99-label-def!))
def(c99-label-def!, Label +C99 -- +C99, "static VAL lbl_" put name mangled put " = {0};" put line)
def(c99-label-push!, Label +C99 -- +C99, c99-line("LPUSH(lbl_" put name mangled put ");" put))
def(c99-label-pop!, Label +C99 -- +C99, c99-line("LPOP(lbl_" put name mangled put ");" put))

def(c99-int!, Int +C99 -- +C99,
    c99-line("push_i64(" put show put "LL);" put))

def(c99-str!, Str +C99 -- +C99,
    c99-line("{" put)
    c99-nest(
        c99-line("static bool vready = false;" put)
        c99-line("static VAL v;" put)
        c99-line("if (! vready) {" put)
        c99-nest(
            dup num-bytes 4090 >Size > if(
                c99-line("v = mkstr(" put)
                c99-nest(
                    c99-line(dup put-cstr-long "," put)
                    c99-line(dup num-bytes show put)
                )
                c99-line(");" put),
                c99-line("v = mkstr(" put dup put-cstr ", " put dup num-bytes show put ");" put)
            )
            c99-line("vready = true;" put)
        )
        c99-line("}" put)
        c99-line("push_value(v);" put)
        c99-line("incref(v);" put)
    )
    c99-line("}" put)
    drop)

def(+C99.put-cstr-long, Str +C99 -- +C99,
    BQUOTE put-byte
    BNUL swap str-bytes-for(
        swap BLF == then(
            BQUOTE put-byte
            line indent
            BQUOTE put-byte
        )
        dup c99-string-byte!
    )
    BQUOTE put-byte
    drop
)

def(+C99.put-cstr, Str +C99 -- +C99,
    BQUOTE put-byte str-bytes-for(c99-string-byte!) BQUOTE put-byte)

def(c99-string-byte!, Byte +C99 -- +C99,
    B'\' -> "\\\\" put,
    BQUOTE -> "\\\"" put,
    BHT -> "\\t" put,
    BLF -> "\\n" put,
    BCR -> "\\r" put,
    _ ->
        dup BSPACE B'~' in-range if(
            put-byte,
            "\\x" put to-hexdigits dip(put-byte) put-byte
        )
    )

def(c99-constant!, Constant +C99 -- +C99,
    value c99-value!)

def(c99-value!, Value +C99 -- +C99,
    VALUE_INT -> c99-int!,
    VALUE_STR -> c99-str!,
    VALUE_BLOCK -> c99-block-push!)

def(c99-prim!, List(Arg) Prim +C99 -- +C99,
    PRIM_CORE_DIP ->
        match(
            L1 ->
                c99-line("{" put)
                c99-nest(
                    c99-line("VAL d" put depth@ show put " = pop_value();" put)
                    c99-arg-run!
                    c99-line("push_value(d" put depth@ show put ");" put)
                )
                c99-line("}" put),
            _ ->
                PRIM_CORE_DIP c99-prim-default!
        ),

    PRIM_CORE_RDIP ->
        match(
            L1 ->
                c99-line("{" put)
                c99-nest(
                    c99-line("VAL d" put depth@ show put " = pop_resource();" put)
                    c99-arg-run!
                    c99-line("push_resource(d" put depth@ show put ");" put)
                )
                c99-line("}" put),
            _ ->
                PRIM_CORE_RDIP c99-prim-default!
        ),

    PRIM_CORE_IF ->
        match(
            L2 ->
                c99-line("if (pop_u64()) {" put)
                c99-nest(swap c99-arg-run!)
                c99-line("} else {" put)
                c99-nest(c99-arg-run!)
                c99-line("}" put),
            _ ->
                PRIM_CORE_IF c99-prim-default!
        ),

    PRIM_CORE_WHILE ->
        match(
            L2 ->
                c99-line("while(1) {" put)
                c99-nest(
                    swap c99-arg-run!
                    c99-line("if (! pop_u64()) break;" put)
                    c99-arg-run!
                )
                c99-line("}" put),

            _ ->
                PRIM_CORE_WHILE c99-prim-default!
        ),

    _ -> c99-prim-default!)

def(c99-prim-default!, List(Arg) Prim +C99 -- +C99,
    qname c99-call!)

def(c99-args-push!, List(Arg) +C99 -- +C99,
    for(c99-arg-push!))

def(c99-arg-push!, Arg +C99 -- +C99,
    ARG_BLOCK -> c99-block-push!)

def(c99-arg-run!, Arg +C99 -- +C99,
    ARG_BLOCK -> c99-block-run!)

def(c99-block-run!, Block +C99 -- +C99,
    arrow c99-arrow!)

def(+C99.var-put, Var +C99 -- +C99, "var_" put name mangled put)
def(+C99.param-put, Param +C99 -- +C99, >Var var-put)

def(c99-pack-ctx!, Ctx +C99 -- +C99,
    c99-line("push_u64(0);" put)
    physical-vars for(
        c99-var-push!
        c99-line("mw_std_prim_prim_pack_cons();" put)
    ))

def(c99-unpack-ctx!, Ctx +C99 -- +C99,
    physical-vars reverse-for(
        c99-line("mw_std_prim_prim_pack_uncons();" put)
        c99-line("VAL " put var-put " = pop_value();" put)
    )
    c99-line("mw_std_prim_prim_drop();" put))

def(c99-decref-ctx!, Ctx +C99 -- +C99,
    physical-vars reverse-for(
        c99-line("decref(" put var-put ");" put)
    ))

def(c99-block-push!, Block +C99 -- +C99,
    dup to-run-var match(
        SOME -> nip c99-var-push!,
        NONE ->
            dup ctx c99-pack-ctx!
            c99-line("push_fnptr(&" put block-put ");" put)
            c99-line("mw_std_prim_prim_pack_cons();" put)
    ))

def(c99-var!, Var +C99 -- +C99,
    dup auto-run? if(c99-var-run!, c99-var-push!))

def(c99-var-run!, Var +C99 -- +C99,
    c99-line("incref(" put dup var-put ");" put)
    c99-line("run_value(" put dup var-put ");" put)
    drop)

def(c99-var-push!, Var +C99 -- +C99,
    c99-line("incref(" put dup var-put ");" put)
    c99-line("push_value(" put dup var-put ");" put)
    drop)

def(c99-lambda!, Lambda +C99 -- +C99,
    c99-line("{" put)
    c99-nest(
        dup params reverse-for(
            c99-line("VAL " put param-put " = pop_value();" put)
        )
        dup body c99-arrow!
        params reverse-for(
            c99-line("decref(" put param-put ");" put)
        )
    )
    c99-line("}" put))

def(c99-match!, Match +C99 -- +C99,
    dup is-transparent? if(
        cases first unwrap body c99-arrow!,

        dup scrutinee-data?
        unwrap-or(token "non-uniform match, not supported at present" emit-fatal-error!)
        is-resource? if(
            c99-line("switch (get_top_resource_data_tag()) {" put),
            c99-line("switch (get_top_data_tag()) {" put)
        )
        c99-nest(
            dup cases for(c99-case!)
            has-default-case? else(
                c99-line("default: write(2, \"unexpected fallthrough in match\\n\", 32); mw_std_prim_prim_debug(); exit(99);" put)
            )
        )
        c99-line("}" put)
    ))

def(c99-case!, Case +C99 -- +C99,
    dup pattern c99-pattern!
    c99-nest(
        body c99-arrow!
        c99-line("break;" put)
    ))

def(c99-pattern!, Pattern +C99 -- +C99,
    PATTERN_UNDERSCORE ->
        c99-line("default:" put),

    PATTERN_TAG ->
        c99-line("case " put dup value show put "LL:" put)
        c99-nest(
            c99-line("mp_" put qname mangled put "();" put)
        )
    )

def(c99-word-sigs!, +C99 -- +C99, Word.for(dup ~Needs(needed?) if(c99-word-sig!, drop)))
def(c99-word-sig!, Word +C99 -- +C99,
    c99-line("static void mw_" put qname mangled put " (void);" put))

def(c99-block-sigs!, +C99 -- +C99, Block.for(dup ~Needs(needed?) if(c99-block-sig!, drop)))
def(c99-block-sig!, Block +C99 -- +C99,
    c99-line("static void " put block-put " (void);" put))

def(c99-field-sigs!, +C99 -- +C99, Field.for(c99-field-sig!))
def(c99-field-sig!, Field +C99 -- +C99,
    c99-line("static void mw_" put qname mangled put " (void);" put))

def(c99-block-enter!, Block +C99 -- +C99,
    emit-debug-info? if(
        c99-line("WORD_ENTER(" put
            dup block-put ", " put
            dup home match(
                HOME_MAIN -> drop "block",
                HOME_WORD -> name >Str " block" cat,
            ) put-cstr ", " put
            dup token .module source-path >Str put-cstr ", " put
            dup token row >Int show put ", " put
            dup token col >Int show put ");" put
        ) drop,
        drop
    ))

def(c99-block-exit!, Block +C99 -- +C99,
    emit-debug-info? if(
        c99-line("WORD_EXIT(" put block-put ");" put),
        drop
    ))

def(c99-block-defs!, +C99 -- +C99, Block.for(dup ~Needs(needed?) if(c99-block-def!, drop)))
def(c99-block-def!, Block +C99 -- +C99,
    c99-line("static void " put dup block-put " (void) {" put)
    c99-nest(
        dup c99-block-enter!
        dup arrow
        dup ctx c99-unpack-ctx!
        dup c99-arrow!
        ctx c99-decref-ctx!
        c99-block-exit!
    )
    c99-line("}" put))

def(+C99.block-put, Block +C99 -- +C99,
    "mb_" put
    dup home match(
        HOME_MAIN -> "main_" put dip(arrow token-start index) index - show put,
        HOME_WORD -> dup qname mangled put "_" put dip(arrow) arrow both(token-start index) - show put
    ))

def(c99-word-enter!, Word +C99 -- +C99,
    emit-debug-info? if(
        c99-line(
            "WORD_ENTER(" put
            "mw_" put dup qname mangled put ", " put
            dup name >Str put-cstr ", " put
            dup body .module source-path >Str put-cstr ", " put
            dup body row >Int show put ", " put
            dup body col >Int show put ");" put
        ) drop,
        drop
    ))

def(c99-word-exit!, Word +C99 -- +C99,
    emit-debug-info? if(
        c99-line("WORD_EXIT(mw_" put qname mangled put ");" put),
        drop
    ))

def(c99-word-defs!, +C99 -- +C99, Word.for(dup ~Needs(needed?) if(c99-word-def!, drop)))
def(c99-word-def!, Word +C99 -- +C99,
    c99-line(dup qname sig-put " {" put)
    c99-nest(
        dup c99-word-enter!
        dup arrow c99-arrow!
        dup c99-word-exit!
    )
    c99-line("}" put)
    drop)

def(c99-field-defs!, +C99 -- +C99, Field.for(c99-field-def!))
def(c99-field-def!, Field +C99 -- +C99,
    "static VAL* fieldptr_" put dup qname mangled put " (size_t i) {" put line
    "\tstatic struct VAL * p = 0;" put line
    "\tsize_t m = " put TABLE_MAX_COUNT show put ";" put line
    "\tif (! p) { p = calloc(m, sizeof *p); }" put line
    "\tif (i>=m) { write(2,\"table too big\\n\",14); exit(123); }" put line
    "\treturn p+i;" put line
    "}" put line line
        # TODO make this more flexible wrt table size
        # note it's important to have stability,
        # so we can't just realloc as we used to.
    dup qname sig-put "{" put
    "\tsize_t index = (size_t)pop_u64();" put line
    "\tVAL *v = fieldptr_" put dup qname mangled put "(index);" put line
    "\tpush_ptr(v);" put line
    "}" put line line
    drop)

def(c99-main!, Arrow +C99 -- +C99,
    c99-line("int main (int argc, char** argv) {" put)
    c99-nest(
        c99-line("global_argc = argc;" put)
        c99-line("global_argv = argv;" put)
        c99-line("push_resource(MKU64(0));" put) # world
        emit-debug-info? then(
            c99-line("WORD_ENTER(" put
                "(void(*)(void))0, " put
                "\"<main>\", " put
                dup token-start .module source-path >Str put-cstr ", " put
                dup token-start row >Int show put ", " put
                dup token-start col >Int show put ");" put)
        )
        c99-arrow!
        emit-debug-info? then(
            c99-line("WORD_EXIT((void(*)(void))0);" put)
        )
        c99-line("return 0;" put)
    )
    c99-line("}" put))
