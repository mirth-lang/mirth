
module(mirth.type)

import(std.prelude)
import(std.maybe)
import(std.list)
import(std.str)
import(std.either)
import(std.world)
import(mirth.name)
import(mirth.token)
import(mirth.arrow)
import(mirth.location)
import(mirth.def)
import(mirth.var)
import(mirth.table)
import(mirth.tycon)
import(mirth.typedef)
import(mirth.mirth)
import(mirth.data)
import(mirth.label)

data Type {
    TYPE_ERROR
    TYPE_DONT_CARE
    TPrim [ PrimType ]
    TMeta [ MetaVar ]
    THole [ Name ]
    TVar  [ Var ]
    TTable [ Table ]
    TData [ Data ]
    TDataPartial [ DataPartial ]
    TTensor [ StackType ]
    TMorphism [ ArrowType ]
    TApp [ Type Type ]
    TMut [ Type ]
    TValue [ Value ]
}

data Value {
    VALUE_INT [ Int ]
    VALUE_F64 [ F64 ]
    VALUE_STR [ Str ]
    VALUE_BLOCK [ Block ]
}

data PrimType {
    PRIM_TYPE_TYPE
    PRIM_TYPE_STACK
    PRIM_TYPE_RESOURCE
    PRIM_TYPE_INT
    PRIM_TYPE_F32
    PRIM_TYPE_F64
    PRIM_TYPE_PTR
    PRIM_TYPE_STR
    PRIM_TYPE_WORLD
}

def PrimType.is-resource? [ PrimType -- Bool ] {
    { PRIM_TYPE_WORLD -> True }
    { _ -> drop False }
}

def PrimType.is-physical? [ PrimType -- Bool ] {
    { PRIM_TYPE_TYPE -> False }
    { PRIM_TYPE_STACK -> False }
    { PRIM_TYPE_RESOURCE -> False }
    { _ -> drop True }
}

||| Get type constructor name for a type, if possible.
def Type.tycon? [ Type -- Maybe(Tycon) ] {
    { TYPE_ERROR -> None }
    { TYPE_DONT_CARE -> None }
    { TPrim -> TYCON_PRIM Some }
    { TMeta -> expand-if(tycon?, drop None) }
    { THole -> drop None }
    { TVar -> drop None }
    { TTable -> TYCON_TABLE Some }
    { TData -> TYCON_DATA Some }
    { TDataPartial -> .data TYCON_DATA Some }
    { TMorphism -> drop None }
    { TTensor -> drop None }
    { TApp -> drop tycon? }
    { TMut -> tycon? }
    { TValue -> tycon? }
}

||| Get primitive type constructor name.
def PrimType.tycon-qname [ +Mirth PrimType -- +Mirth QName ] {
    { PRIM_TYPE_TYPE -> "TYPE" 0 QName.prim }
    { PRIM_TYPE_STACK -> "STACK" 0 QName.prim }
    { PRIM_TYPE_RESOURCE -> "Resource" 0 QName.prim }
    { PRIM_TYPE_INT -> "Int" 0 QName.prim }
    { PRIM_TYPE_F32 -> "F32" 0 QName.prim }
    { PRIM_TYPE_F64 -> "F64" 0 QName.prim }
    { PRIM_TYPE_STR -> "Str" 0 QName.prim }
    { PRIM_TYPE_PTR -> "Ptr" 0 QName.prim }
    { PRIM_TYPE_WORLD -> "+World" 0 QName.prim }
}

||| Get value type constructor name.
def Value.tycon? [ Value -- Maybe(Tycon) ] {
    { VALUE_INT -> drop PRIM_TYPE_INT TYCON_PRIM Some }
    { VALUE_F64 -> drop PRIM_TYPE_F64 TYCON_PRIM Some }
    { VALUE_STR -> drop PRIM_TYPE_STR TYCON_PRIM Some }
    { VALUE_BLOCK -> drop None }
}

def PrimType.>Int [ PrimType -- Int ] { PrimType.tag }
def PrimType.== [ PrimType PrimType -- Bool ] { both(>Int) == }

def +Mirth.def-prim-type! [ +Mirth PrimType -- +Mirth ] {
    dup tycon-qname >qname
    TPrim >type
    def-type!
}

def +Mirth.def-prim-type-alias! [ +Mirth PrimType Str -- +Mirth ] {
    >Name over tycon-qname .name! >qname
    TPrim >type
    def-type!
}

def +Mirth.init-types! [ +Mirth -- +Mirth ] {
    PRIM_TYPE_INT def-prim-type!
    PRIM_TYPE_F32 def-prim-type! PRIM_TYPE_F32 "Float32" def-prim-type-alias!
    PRIM_TYPE_F64 def-prim-type! PRIM_TYPE_F64 "Float64" def-prim-type-alias!
    PRIM_TYPE_PTR def-prim-type!
    PRIM_TYPE_STR def-prim-type!
    PRIM_TYPE_WORLD def-prim-type!
    init-data!
}

#########
# Types #
#########

def(T+, StackType Resource -- StackType, STWith)
def(T*, StackType Type -- StackType, STCons)
def(T*+, StackType Type/Resource -- StackType, match(Left -> T*, Right -> T+))
def(T->, StackType StackType -- ArrowType, ARROW_TYPE)

def(TT, List(Type) -- StackType, T0 swap for(T*))
def(T0, StackType, STACK_TYPE_UNIT)
def(T1, Type -- StackType, dip(T0) T*)
def(T2, Type Type -- StackType, dip(T1) T*)
def(T3, Type Type Type -- StackType, dip(T2) T*)
def(T4, Type Type Type Type -- StackType, dip(T3) T*)
def(T5, Type Type Type Type Type -- StackType, dip(T4) T*)
def(T6, Type Type Type Type Type Type -- StackType, dip(T5) T*)

# def(type-is-error, Type -- Bool, match(TYPE_ERROR -> True, _ -> drop False))
# def(type-is-dont-care, Type -- Bool, match(TYPE_DONT_CARE -> True, _ -> drop False))
# def(type-is-prim, Type -- Bool, match(TPrim -> drop True, _ -> drop False))
# def(type-is-var, Type -- Bool, match(TVar -> drop True, _ -> drop False))
# def(type-is-meta, Type -- Bool, match(TMeta -> drop True, _ -> drop False))
# def(type-is-tensor, Type -- Bool, match(TTensor -> drop2 True, _ -> drop False))
# def(type-is-table, Type -- Bool, match(TTable -> drop True, _ -> drop False))
# def(type-is-hole, Type -- Bool, match(THole -> drop True, _ -> drop False))
# def(type-is-app, Type -- Bool, match(TApp -> drop2 True, _ -> drop False))
# def(type-is-data, Type -- Bool, match(TData -> drop True, _ -> drop False))

def(Type.error?, Type -- Bool, expand match(TYPE_ERROR -> True, _ -> drop False))
def(Type.morphism?, Type -- Maybe(ArrowType), expand match(TMorphism -> Some, _ -> drop None))
def(Type.prim?, Type -- Maybe(PrimType), expand match(TPrim -> Some, _ -> drop None))

def(Type.tensor?, Type -- Maybe(StackType), expand match(TTensor -> Some, _ -> drop None))
def(Type.unit?, Type -- Bool, tensor? if-some(unit?, False))

def(Type.meta=, MetaVar Type -- Bool,
    TMeta -> ==,
    _ -> drop2 False)

def(Type.is-physical?, Type -- Bool,
    TMeta -> expand-if(is-physical?, "unbound meta at Type.is-physical?" panic!),
    TPrim -> is-physical?,
    _ -> drop True)

def(TYPE_UNIT, Type, STACK_TYPE_UNIT TTensor) # unit type
def(TYPE_TYPE, Type, PRIM_TYPE_TYPE TPrim) # type of types
def(TYPE_STACK, Type, PRIM_TYPE_STACK TPrim) # type of stack types
def(TYPE_RESOURCE, Type, PRIM_TYPE_RESOURCE TPrim) # type of (linear) resources
def(TYPE_INT, Type, PRIM_TYPE_INT TPrim) # generic integer type for integer literals
def(TYPE_F32, Type, PRIM_TYPE_F32 TPrim)
def(TYPE_F64, Type, PRIM_TYPE_F64 TPrim)
def(TYPE_PTR, Type, PRIM_TYPE_PTR TPrim) # generic pointer type (e.g. void*)
def(TYPE_STR, Type, PRIM_TYPE_STR TPrim) # string pointer (just a pointer but nominally)
# def(TYPE_U8, Type, PRIM_TYPE_U8 TPrim) # fixed width integer type -- unsigned 8 bit
# def(TYPE_U16, Type, PRIM_TYPE_U16 TPrim) # fixed width integer type -- unsigned 16 bit
# def(TYPE_U32, Type, PRIM_TYPE_U32 TPrim) # fixed width integer type -- unsigned 32 bit
# def(TYPE_U64, Type, PRIM_TYPE_U64 TPrim) # fixed width integer type -- unsigned 64 bit
# def(TYPE_I8, Type, PRIM_TYPE_I8 TPrim) # fixed width integer type -- signed 8 bit
# def(TYPE_I16, Type, PRIM_TYPE_I16 TPrim) # fixed width integer type -- signed 16 bit
# def(TYPE_I32, Type, PRIM_TYPE_I32 TPrim) # fixed width integer type -- signed 32 bit
# def(TYPE_I64, Type, PRIM_TYPE_I64 TPrim) # fixed width integer type -- signed 64 bit
def(TYPE_WORLD, Type, PRIM_TYPE_WORLD TPrim)
def(RESOURCE_WORLD, Resource, TYPE_WORLD Resource)

def(Type.expand, Type -- Type,
    TMeta -> expand,
    _ -> id)

data(+Gamma, +Gamma -> token: Token)
def(+Gamma.rdrop, +Gamma --, /+Gamma token> drop)

||| Raise a type unification error.
def(Type.unify-failed!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    Str("Failed to unify " ; dip:type; " with " ; type;) dip:token rdip:emit-error! TYPE_ERROR)

||| Unify types directly, without regard to metavariables and other metatypes.
def(Type.unify-simple!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    TVar -> swap match(TVar -> unify!, _ -> dip(TVar) unify-failed!),
    TPrim -> swap match(TPrim -> unify!, _ -> dip(TPrim) unify-failed!),
    TData -> swap match(TData -> unify!, _ -> dip(TData) unify-failed!),
    TDataPartial -> swap match(TDataPartial -> unify!, _ -> dip(TDataPartial) unify-failed!),
    TTable -> swap match(TTable -> unify!, _ -> dip(TTable) unify-failed!),
    TTensor -> swap match(TTensor -> unify! >Type, _ -> dip(TTensor) unify-failed!),
    TMorphism -> swap match(TMorphism -> unify! TMorphism, _ -> dip(TMorphism) unify-failed!),
    TApp -> rotl match(TApp -> unify2! TApp, _ -> dip(TApp) unify-failed!),
    TMut -> swap match(TMut -> unify! TMut, _ -> dip(TMut) unify-failed!),
    _ -> unify-failed!)

||| Unify expanded types.
def(Type.unify-aux!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    TYPE_ERROR -> unify-error!,
    TYPE_DONT_CARE -> id,
    THole -> type-hole-unify!,
    TMeta ->
        swap match(
            TYPE_ERROR -> unify-error!,
            TYPE_DONT_CARE -> TMeta,
            THole -> dip(TMeta) type-hole-unify!,
            TMeta -> dip(TMeta) unify!,
            TValue -> dip(TMeta) unify-type!,
            _ -> swap unify!,
        ),
    TValue ->
        swap match(
            TYPE_ERROR -> unify-error!,
            TYPE_DONT_CARE -> TValue,
            THole -> dip(TValue) type-hole-unify!,
            TMeta -> dip(TValue) unify!,
            TValue -> unify!,
            _ -> swap unify-type!
        ),
    _ ->
        swap match(
            TYPE_ERROR -> unify-error!,
            TYPE_DONT_CARE -> id,
            THole -> type-hole-unify!,
            TMeta -> unify!,
            TValue -> unify-type!,
            _ -> unify-simple!
        )
    )

||| Fill out any subterms/metavars with TYPE_ERROR.
def(Type.unify-error!, +Mirth +Gamma Type -- +Mirth +Gamma Type,
    expand match(
        TYPE_ERROR -> TYPE_ERROR,
        TYPE_DONT_CARE -> TYPE_ERROR,
        THole -> TYPE_ERROR swap type-hole-unify!,
        TMeta -> unify-error!,
        TValue -> unify-error!,
        TVar -> drop TYPE_ERROR,
        TPrim -> drop TYPE_ERROR,
        TData -> drop TYPE_ERROR,
        TDataPartial -> drop TYPE_ERROR,
        TTable -> drop TYPE_ERROR,
        TTensor -> unify-error! drop TYPE_ERROR,
        TMorphism -> unify-error! drop TYPE_ERROR,
        TApp -> dip(unify-error! drop) unify-error! drop TYPE_ERROR,
        TMut -> unify-error! drop TYPE_ERROR,
    ))

||| Unify two types. Raises a unification error if unification is impossible.
def(Type.unify!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    both(expand) unify-aux!)

def(Value.unify!, +Mirth +Gamma Value Value -- +Mirth +Gamma Type,
    swap match(
        VALUE_INT -> swap match(
            VALUE_INT -> dup2 == if(drop VALUE_INT TValue, drop2 TYPE_INT),
            VALUE_STR ->
                drop2 token
                "Can't unify int value with string value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_F64 ->
                drop2 token
                "Can't unify int value with float value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 token
                "Can't unify int value with block."
                rdip:emit-error! TYPE_ERROR,
        ),

        VALUE_STR -> swap match(
            VALUE_STR -> dup2 == if(drop VALUE_STR TValue, drop2 TYPE_STR),
            VALUE_INT ->
                drop2 token
                "Can't unify string value with int value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_F64 ->
                drop2 token
                "Can't unify string value with float value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 token
                "Can't unify string value with block."
                rdip:emit-error! TYPE_ERROR,
        ),

        VALUE_BLOCK -> swap match(
            VALUE_BLOCK ->
                dup2 == if(
                    drop VALUE_BLOCK TValue,
                    rdip:arrow type block-unify-type! >Type
                ),
            VALUE_INT ->
                drop2 token
                "Can't unify block with int value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_F64 ->
                drop2 token
                "Can't unify block with float value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_STR ->
                drop2 token
                "Can't unify block with string value."
                rdip:emit-error! TYPE_ERROR
        ),

        VALUE_F64 -> swap match(
            VALUE_F64 ->
                dup2 == if(
                    drop VALUE_F64 TValue,
                    drop2 TYPE_F64
                ),
            VALUE_INT ->
                drop2 token
                "Can't unify float value with int value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 token
                "Can't unify float value with block."
                rdip:emit-error! TYPE_ERROR,
            VALUE_STR ->
                drop2 token
                "Can't unify float value with string value."
                rdip:emit-error! TYPE_ERROR
        )))

def(Value.unify-type!, +Mirth +Gamma Type Value -- +Mirth +Gamma Type,
    VALUE_INT -> drop TYPE_INT unify!,
    VALUE_STR -> drop TYPE_STR unify!,
    VALUE_F64 -> drop TYPE_F64 unify!,
    VALUE_BLOCK -> swap unify-block!)

def(Value.unify-error!, +Mirth +Gamma Value -- +Mirth +Gamma Type,
    VALUE_INT -> drop TYPE_ERROR,
    VALUE_STR -> drop TYPE_ERROR,
    VALUE_F64 -> drop TYPE_ERROR,
    VALUE_BLOCK -> TYPE_ERROR unify-block!)

def(Type.unify-block!, +Mirth +Gamma Block Type -- +Mirth +Gamma Type,
    expand match(
        TYPE_ERROR -> STACK_TYPE_ERROR STACK_TYPE_ERROR T-> block-unify-type! drop TYPE_ERROR,
        TMeta -> over dip(dip(type >Type) unify! drop) rdip:arrow type >Type,
        TMorphism -> block-unify-type! >Type,
        _ -> dip(type >Type) unify!
    ))

def(Type.unify2!, +Mirth +Gamma Type Type Type Type -- +Mirth +Gamma Type Type,
    dip(swap) dip2(unify!) unify!)

def(PrimType.unify!, +Mirth +Gamma PrimType PrimType -- +Mirth +Gamma Type,
    dup2 == if(drop TPrim, both(TPrim) unify-failed!))
def(Data.unify!, +Mirth +Gamma Data Data -- +Mirth +Gamma Type,
    dup2 == if(drop TData, both(TData) unify-failed!))
def(DataPartial.unify!, +Mirth +Gamma DataPartial DataPartial -- +Mirth +Gamma Type,
    dup2 == if(drop TDataPartial, both(TDataPartial) unify-failed!))
def(Table.unify!, +Mirth +Gamma Table Table -- +Mirth +Gamma Type,
    dup2 == if(drop TTable, both(TTable) unify-failed!))

def(Type.has-meta?, MetaVar Type -- Bool,
    TMeta -> has-meta?,
    TYPE_ERROR -> drop False,
    TYPE_DONT_CARE -> drop False,
    TPrim -> drop2 False,
    TVar -> drop2 False,
    THole -> drop2 False,
    TTensor -> has-meta?,
    TMorphism -> has-meta?,
    TApp -> has-meta2?,
    TData -> drop2 False,
    TDataPartial -> drop2 False,
    TTable -> drop2 False,
    TValue -> has-meta?,
    TMut -> has-meta?)

def(Type.has-meta2?, MetaVar Type Type -- Bool,
    dip(over) has-meta? if(drop2 True, has-meta?))

def(Value.has-meta?, MetaVar Value -- Bool,
    type has-meta?)

def(Type.sig;, Type +Str -- +Str,
    TMeta -> expand-if(sig;, type;),
    TYPE_ERROR -> "<ERROR>" ;,
    TMorphism -> sig;,
    _ -> type;)

def(Type.type;, Type +Str -- +Str,
    TYPE_ERROR -> "<ERROR>" ;,
    TYPE_DONT_CARE -> "_" ;,
    TPrim -> type;,
    TVar -> type;,
    TMeta -> type;,
    TTensor -> "[" ; stack; "]" ;,
    TMorphism -> "[" ; sig; "]" ;,
    TData -> name >Str ;,
    TDataPartial -> dup .data name >Str ; "/" ; .field name >Str ;,
    TTable -> name >Str ;,
    THole -> >Str ;,
    TApp -> app-type;;,
    TValue -> type type;,
    TMut -> "Mut(" ; type; ")" ;)

def(Value.type, Value -- Type,
    VALUE_INT -> drop PRIM_TYPE_INT TPrim,
    VALUE_F64 -> drop PRIM_TYPE_F64 TPrim,
    VALUE_STR -> drop PRIM_TYPE_STR TPrim,
    VALUE_BLOCK -> type >Type)

def(PrimType.type;, +Str PrimType -- +Str,
    match(
        PRIM_TYPE_TYPE -> "<TYPE>",
        PRIM_TYPE_STACK -> "<STACK>",
        PRIM_TYPE_RESOURCE -> "<Resource>",
        PRIM_TYPE_INT -> "Int",
        PRIM_TYPE_F32 -> "F32",
        PRIM_TYPE_F64 -> "F64",
        PRIM_TYPE_PTR -> "Ptr",
        PRIM_TYPE_STR -> "Str",
        PRIM_TYPE_WORLD -> "+World",
    ) ;)

# ||| Freshen a type signature in preparation for type sig application.
# def(Type.freshen-sig, Subst Type -- Subst Type,
#     dup sig-needs-fresh-stack-rest? if(
#         freshen-sig-aux,
#         freshen
#     ))

# def(Type.sig-needs-fresh-stack-rest?, Type -- Bool,
#     TMeta -> expand-if(sig-needs-fresh-stack-rest?, drop False),
#     TMorphism -> needs-fresh-stack-rest?,
#     _ -> drop False)

# def(Type.freshen-sig-aux, Subst Type -- Subst Type,
#     TMeta -> expand-if(freshen-sig-aux, TMeta),
#     TMorphism -> freshen-sig-aux TMorphism,
#     _ -> freshen)

||| Replace free type vars and free metavars with brand new metavars.
def(Type.freshen, Subst Type -- Subst Type,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TData -> TData,
    TDataPartial -> TDataPartial,
    TTable -> TTable,
    TValue -> TValue, # no need to freshen values
    TVar -> freshen,
    TMeta -> freshen,
    TTensor -> freshen TTensor,
    TMorphism -> freshen TMorphism,
    TApp -> freshen2 TApp,
    TMut -> freshen TMut,
    )

def(Type.freshen2, Subst Type Type -- Subst Type Type,
    dip(freshen swap) freshen dip(swap))


||| Replace unbound metavars with new vars, adding them to context.
def(Type.rigidify!, +Mirth Ctx Type -- +Mirth Ctx Type,
    TMeta ->
        expand-or-update!(
            fresh-type-var! TVar
        ) rigidify!,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TVar -> TVar,
    TTable -> TTable,
    TData -> TData,
    TDataPartial -> TDataPartial,
    TApp ->
        dip(rigidify!) swap
        dip(rigidify!) swap
        TApp,
    TTensor -> rigidify! TTensor,
    TMorphism -> rigidify! TMorphism,
    TValue -> rigidify!,
    TMut -> rigidify! TMut)

def(Value.rigidify!, +Mirth Ctx Value -- +Mirth Ctx Type,
    VALUE_INT -> VALUE_INT TValue,
    VALUE_STR -> VALUE_STR TValue,
    VALUE_F64 -> VALUE_F64 TValue,
    VALUE_BLOCK -> arrow type rigidify! >Type)

||| How many types does this type take as an argument?
def(Type.arity, Type -- Int,
    TMeta -> expand-if(arity, drop 0),
    TData -> arity,
    TApp -> drop arity 1-,
    _ -> drop 0)

||| Get head of type.
def(type-head, Type -- Type,
    TMeta -> expand-if(type-head, TMeta),
    TApp -> drop type-head,
    _ -> id)

||| For types that can have a field associated with them,
||| get the number of values n, where the type's values
||| range from 0 to (n-1). This should not be too large.
|||
||| Do NOT return Some(n) unless the type has values 0..n-1
def(type-max-count, Type -- Maybe(Nat),
    TMeta -> expand-if(type-max-count, drop None),
    TApp -> drop type-max-count,
    TTable -> max-count 1+ Some,
    TData ->
        dup is-enum-or-unit? if(
            num-tags Some,
            drop None
        ),
    _ -> drop None)

def(Type.except-field, Label Tag Type -- Type,
    TMeta -> expand-if(except-field, "Type.except-field on metavar" panic!),
    TData -> >data drop >field DataPartial TDataPartial,
    TApp -> dip(except-field) TApp,
    _ -> "Type.except-field on unexpected type" panic!)

##################
# Meta-var Types #
##################

table(MetaVar)
field(MetaVar.~type?, MetaVar, Maybe(Type))
def(MetaVar.type?, MetaVar -- Maybe(Type), ~type? @)

def(MetaVar.has-meta?, MetaVar MetaVar -- Bool,
    dup type? match(
        None -> ==,
        Some -> nip has-meta?
    ))

def(MetaVar.type;, +Str MetaVar -- +Str,
    dup type? match(
        None -> "?" ; index show;,
        Some -> nip type;
    ))
def(MetaVar.new!, MetaVar,
    MetaVar.alloc!
    None over ~type? !)

inline (
    def(MetaVar.expand-if(f,g), (*a Type -- *b, *a MetaVar -- *b) *a MetaVar -- *b,
        dup type? match(
            None -> g,
            Some -> expand tuck Some swap ~type? ! f
        ))
)

def(MetaVar.expand, MetaVar -- Type,
    expand-if(id, TMeta))
def(MetaVar.unify!, +Mirth +Gamma Type MetaVar -- +Mirth +Gamma Type,
    dup type? match(
        Some -> nip unify!,
        None -> dup2 swap meta= if(
            drop,
            swap dup2 has-meta? if(
                swap TMeta unify-failed!,
                tuck Some swap ~type? !
            )
        )
    ))
def(MetaVar.unify-error!, +Mirth +Gamma MetaVar -- +Mirth +Gamma Type,
    dup type? match(
        Some -> nip unify-error!,
        None -> dip(TYPE_ERROR Some) ~type? ! TYPE_ERROR
    ))

inline (
    def(MetaVar.expand-or-update!(f), (*a -- *a Type) *a MetaVar -- *a Type,
        dup type? match(
            None -> dip(f dup Some) ~type? !,
            Some -> nip
        ))
)

def(MetaVar.==, MetaVar MetaVar -- Bool, both(index) ==)

def(MetaVar.freshen, Subst MetaVar -- Subst Type,
    expand-if(freshen, drop MetaVar.new! TMeta))

##############
# Type Holes #
##############

def(type-hole-unify!, +Mirth +Gamma Type Name -- +Mirth +Gamma Type,
    Str(THole type; " ~ "; dup type; "\n" ;) dip:token rdip:emit-info!)

############
# APP TYPE #
############

def(Type.app-type;;, +Str Type Type -- +Str,
    app-type-open;; ")" ;)

def(Type.app-type-open;;, +Str Type Type -- +Str,
    swap expand match(
        TApp -> app-type-open;; ", " ; type;,
        _ -> type; "(" ; type;
    ))

#################
# Resource TYPE #
#################

data(Resource, Resource -> Type)
def(Resource.>Type, Resource -- Type, Resource -> id)
def(Type.>Resource, Type -- Resource, Resource)
def(Resource.has-meta?, MetaVar Resource -- Bool, >Type has-meta?)
def(Resource.unify!, +Mirth +Gamma Resource Resource -- +Mirth +Gamma Resource,
    both(>Type) unify! >Resource)
def(Resource.unify-error!, +Mirth +Gamma Resource -- +Mirth +Gamma Resource,
    >Type unify-error! >Resource)
def(Resource.type;, +Str Resource -- +Str, >Type type;)
def(Resource.freshen, Subst Resource -- Subst Resource,
    >Type freshen >Resource)
def(Resource.rigidify!, +Mirth Ctx Resource -- +Mirth Ctx Resource,
    >Type rigidify! >Resource)

def(Resource.except-field, Label Tag Resource -- Resource,
    /Resource except-field Resource)

##############
# STACK TYPE #
##############

data(StackType,
    STACK_TYPE_ERROR,
    STACK_TYPE_DONT_CARE,
    STACK_TYPE_UNIT,
    STVar -> Var,
    STMeta -> MetaVar,
    STCons -> StackType Type,
    STConsLabel -> StackType Type Label,
    STWith -> StackType Resource,
    STWithLabel -> StackType Resource Label)

def(Type.>StackType, Type -- StackType,
    TYPE_ERROR -> STACK_TYPE_ERROR,
    TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE,
    TVar -> STVar,
    TMeta -> STMeta,
    TTensor -> id,
    _ -> "kind error! expected stack type, got regular type." panic!)

def(StackType.>Type, StackType -- Type,
    STACK_TYPE_ERROR -> TYPE_ERROR,
    STACK_TYPE_DONT_CARE -> TYPE_DONT_CARE,
    STVar -> TVar,
    STMeta -> TMeta,
    _ -> TTensor)

def(StackType.expand, StackType -- StackType,
    STMeta -> expand >StackType,
    _ -> id)

def(StackType.unit?, StackType -- Bool,
    expand match(
        STACK_TYPE_UNIT -> True,
        _ -> drop False
    ))

def-type(Type/Resource, Either(Type, Resource))

||| Split stack type into base, types, and resources.
def(StackType.split4, StackType -- StackType List([Type/Resource Label]) List(Type) List(Resource),
    L0 L0 L0 >labels >withses >conses
    while(
        expand match(
            STCons -> conses> Cons >conses True,
            STWith -> withses> Cons >withses True,
            STConsLabel -> dip:Left pack2 labels> Cons >labels True,
            STWithLabel -> dip:Right pack2 labels> Cons >labels True,
            _ -> False
        ), id
    ) labels> conses> withses>)

||| Get bottom of stack.
def(StackType.base, StackType -- StackType, split4 drop3)

||| Get types with labels on stack.
def(StackType.labels, StackType -- List([Type/Resource Label]), split4 drop2 nip)

||| Get types on stack.
def(StackType.types, StackType -- List(Type), split4 drop dip(drop2))

||| Get resources on stack.
def(StackType.resources, StackType -- List(Resource), split4 dip(drop3))

||| Check if the stack label appears and return the type/resource on top.
def(StackType.label-top?, Label StackType -- Maybe(Type/Resource),
    expand match(
        STCons -> drop label-top?,
        STWith -> drop label-top?,
        STConsLabel -> over3 over == if(drop dip:drop2 Left  Some, drop2 label-top?),
        STWithLabel -> over3 over == if(drop dip:drop2 Right Some, drop2 label-top?),
        _ -> drop2 None
    ))

||| Does the stack label exist and have a resource on top?
def(StackType.label-resource-top?, Label StackType -- Maybe(Resource),
    label-top? bind:right?)

||| Does the stack label exist and have a value type on top?
def(StackType.label-type-top?, Label StackType -- Maybe(Type),
    label-top? bind:left?)

||| Get top stack type if possible.
def(StackType.top-type?, StackType -- Maybe(Type),
    expand match(
        STWith -> drop top-type?,
        STCons -> nip Some,
        STConsLabel -> drop2 top-type?,
        STWithLabel -> drop2 top-type?,
        _ -> drop None
    ))

||| Get the top type constructor name.
def(StackType.top-tycon?, StackType -- Maybe(Tycon),
    top-type? bind(tycon?))

||| Get top resource if possible.
def(StackType.top-resource?, StackType -- Maybe(Resource),
    expand match(
        STWith -> nip Some,
        STCons -> drop top-resource?,
        STConsLabel -> drop2 top-resource?,
        STWithLabel -> drop2 top-resource?,
        _ -> drop None
    ))

||| Get the top resource name.
def(StackType.top-resource-tycon?, StackType -- Maybe(Tycon),
    top-resource? bind(>Type tycon?))

def(StackType.top-namespaces, StackType -- List(Namespace),
    LIST(
        dup top-tycon? for(NAMESPACE_TYCON ;)
        top-resource-tycon? for(NAMESPACE_TYCON ;)
    ))

def(StackType.top-types-are-fine?, StackType -- Bool,
    dup top-value-is-fine? and(dup top-resource-is-fine?) nip)

def(StackType.top-value-is-fine?, StackType -- Bool,
    expand match(
        STCons -> nip Type.error? not,
        STConsLabel -> drop2 top-value-is-fine?,
        STWith -> drop top-value-is-fine?,
        STWithLabel -> drop2 top-value-is-fine?,
        STMeta -> drop True,
        STVar -> drop True,
        STACK_TYPE_UNIT -> True,
        STACK_TYPE_ERROR -> False,
        STACK_TYPE_DONT_CARE -> False,
    ))

def(StackType.top-resource-is-fine?, StackType -- Bool,
    expand match(
        STCons -> drop top-resource-is-fine?,
        STConsLabel -> drop2 top-resource-is-fine?,
        STWith -> nip /Resource error? not,
        STWithLabel -> drop2 top-resource-is-fine?,
        STMeta -> drop True,
        STVar -> drop True,
        STACK_TYPE_UNIT -> True,
        STACK_TYPE_ERROR -> False,
        STACK_TYPE_DONT_CARE -> False,
    ))

def(StackType.has-meta?, MetaVar StackType -- Bool,
    expand match(
        STMeta -> ==,
        STACK_TYPE_ERROR -> drop False,
        STACK_TYPE_DONT_CARE -> drop False,
        STVar -> drop2 False,
        STACK_TYPE_UNIT -> drop False,
        STCons -> dip(over) has-meta? if(drop2 True, has-meta?),
        STConsLabel -> drop dip(over) has-meta? if(drop2 True, has-meta?),
        STWith -> dip(over) has-meta? if(drop2 True, has-meta?),
        STWithLabel -> drop dip(over) has-meta? if(drop2 True, has-meta?),
    ))

def(StackType.unify-failed!, +Mirth +Gamma StackType StackType -- +Mirth +Gamma StackType,
    both(>Type) unify-failed! >StackType)

def(StackType.unify!, +Mirth +Gamma StackType StackType -- +Mirth +Gamma StackType,
    swap expand match(
        STACK_TYPE_ERROR -> unify-error!,
        STACK_TYPE_DONT_CARE -> id,
        STMeta -> swap expand match(
            STACK_TYPE_ERROR -> STMeta unify-error!,
            STACK_TYPE_DONT_CARE -> STMeta,
            STMeta -> dip(TMeta) unify! >StackType,
            _ -> >Type swap unify! >StackType,
        ),
        STVar -> swap expand match(
            STACK_TYPE_ERROR -> drop STACK_TYPE_ERROR,
            STACK_TYPE_DONT_CARE -> STVar,
            STMeta -> dip(TVar) unify! >StackType,
            STVar -> unify! >StackType,
            _ -> dip(STVar) unify-failed!
        ),
        STACK_TYPE_UNIT -> expand match(
            STACK_TYPE_ERROR -> STACK_TYPE_ERROR,
            STMeta -> dip(STACK_TYPE_UNIT >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STACK_TYPE_UNIT,
            STACK_TYPE_UNIT -> STACK_TYPE_UNIT,
            _ -> STACK_TYPE_UNIT unify-failed!
        ),
        STCons -> rotl expand match(
            STACK_TYPE_ERROR -> STCons unify-error!,
            STMeta -> dip(STCons >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STCons,
            _ -> dup force-cons?! if-some(
                nip unpack2 dip(swap) dip2(unify!) unify! STCons,
                dip(STCons) unify-failed!
            )
        ),
        STWith -> rotl expand match(
            STACK_TYPE_ERROR -> STWith unify-error!,
            STMeta -> dip(STWith >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STWith,
            _ -> dup force-with?! if-some(
                nip unpack2 dip(swap) dip2(unify!) unify! STWith,
                dip(STWith) unify-failed!
            )
        ),
        STConsLabel -> rot4l expand match(
            STACK_TYPE_ERROR -> STConsLabel unify-error!,
            STMeta -> dip(STConsLabel >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STConsLabel,
            _ -> dup2 force-cons-label?! if-some(
                nip swap dip(unpack2 dip(swap) dip2(unify!) unify!) STConsLabel,
                dip(STConsLabel) unify-failed!
            )
        ),
        STWithLabel -> rot4l expand match(
            STACK_TYPE_ERROR -> STWithLabel unify-error!,
            STMeta -> dip(STWithLabel >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STWithLabel,
            _ -> dup2 force-with-label?! if-some(
                nip swap dip(unpack2 dip(swap) dip2(unify!) unify!) STWithLabel,
                dip(STWithLabel) unify-failed!
            )
        ),
    ))

def(StackType.unify-error!, +Mirth +Gamma StackType -- +Mirth +Gamma StackType,
    expand match(
        STACK_TYPE_ERROR -> STACK_TYPE_ERROR,
        STACK_TYPE_UNIT -> STACK_TYPE_ERROR,
        STACK_TYPE_DONT_CARE -> STACK_TYPE_ERROR,
        STMeta -> unify-error! >StackType,
        STVar -> drop STACK_TYPE_ERROR,
        STCons -> dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
        STWith -> dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
        STConsLabel -> drop dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
        STWithLabel -> drop dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
    ))

def(StackType.force-cons-label?!, Label StackType -- Maybe([StackType Type]),
    expand match(
        STACK_TYPE_ERROR -> drop STACK_TYPE_ERROR TYPE_ERROR pack2 Some,
        STACK_TYPE_DONT_CARE -> drop STACK_TYPE_DONT_CARE TYPE_DONT_CARE pack2 Some,
        STACK_TYPE_UNIT -> drop None,
        STVar -> drop2 None,
        STWith -> dip(force-cons-label?!) swap map(unpack2 dip(over STWith) pack2) nip,
        STCons -> dip(force-cons-label?!) swap map(unpack2 dip(over STCons) pack2) nip,
        STConsLabel ->
            over3 over == if(
                drop rotl drop pack2 Some,
                dip(dip(force-cons-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STWithLabel ->
            over3 over == if(
                drop4 None,
                dip(dip(force-cons-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STMeta ->
            dip(dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2) STConsLabel >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.force-with-label?!, Label StackType -- Maybe([StackType Resource]),
    expand match(
        STACK_TYPE_ERROR -> drop STACK_TYPE_ERROR TYPE_ERROR Resource pack2 Some,
        STACK_TYPE_DONT_CARE -> drop STACK_TYPE_DONT_CARE TYPE_DONT_CARE Resource pack2 Some,
        STACK_TYPE_UNIT -> drop None,
        STVar -> drop2 None,
        STWith -> dip(force-with-label?!) swap map(unpack2 dip(over STWith) pack2) nip,
        STCons -> dip(force-with-label?!) swap map(unpack2 dip(over STCons) pack2) nip,
        STConsLabel ->
            over3 over == if(
                drop4 None,
                dip(dip(force-with-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STWithLabel ->
            over3 over == if(
                drop rotl drop pack2 Some,
                dip(dip(force-with-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STMeta ->
            dip(dip(MetaVar.new! STMeta MetaVar.new! TMeta Resource dup2) STWithLabel >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.force-cons?!, StackType -- Maybe([StackType Type]),
    expand match(
        STACK_TYPE_ERROR -> STACK_TYPE_ERROR TYPE_ERROR pack2 Some,
        STACK_TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE TYPE_DONT_CARE pack2 Some,
        STACK_TYPE_UNIT -> None,
        STVar -> drop None,
        STCons -> pack2 Some,
        STWith -> swap force-cons?! map(unpack2 dip(over STWith) pack2) nip,
        STConsLabel -> rotl force-cons?! match(
            Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
            None -> drop2 None
        ),
        STWithLabel -> rotl force-cons?! match(
            Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
            None -> drop2 None
        ),
        STMeta ->
            dip(MetaVar.new! STMeta
                MetaVar.new! TMeta
                dup2 STCons >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.force-with?!, StackType -- Maybe([StackType Resource]),
    expand match(
        STACK_TYPE_ERROR -> STACK_TYPE_ERROR TYPE_ERROR Resource pack2 Some,
        STACK_TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE TYPE_DONT_CARE Resource pack2 Some,
        STACK_TYPE_UNIT -> None,
        STVar -> drop None,
        STWith -> pack2 Some,
        STCons -> swap force-with?! map(unpack2 dip(over STCons) pack2) nip,
        STConsLabel -> rotl force-with?! match(
            Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
            None -> drop2 None
        ),
        STWithLabel -> rotl force-with?! match(
            Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
            None -> drop2 None
        ),
        STMeta ->
            dip(MetaVar.new! STMeta
                MetaVar.new! TMeta Resource
                dup2 STWith >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.dom;, +Str StackType -- +Str,
    expand dup unit? if(drop, stack; " ";))

def(StackType.cod;, +Str StackType -- +Str,
    expand dup unit? if(drop, " "; stack;))

def(StackType.base;, +Str StackType -- +Str Bool,
    match(
        STACK_TYPE_UNIT -> False,
        STMeta -> "*" ; type; True,
        STVar -> dup is-stack? else("* ";) type; True,
        _ -> >Type "* "; type; True
    ))

def(StackType.stack;, +Str StackType -- +Str,
    split4
    dip3(base;)
    dip2(for(swap then(" " ;) unpack2 >Str ; ":" ; either(type;, type;) True))
    dip(for(swap then(" " ;) type; True))
    for(swap then(" " ;) type; True) drop)

def(StackType.semifreshen, StackType StackType -- StackType StackType,
    expand match(
        STACK_TYPE_UNIT -> dup,
        STCons -> dip(semifreshen) STCons,
        STWith -> dip(semifreshen) STWith,
        STConsLabel -> dip2(semifreshen) STConsLabel,
        STWithLabel -> dip2(semifreshen) STWithLabel,
        _ -> "expected unit-based stack in semifreshen!" panic!
    ))

def(StackType.freshen, Subst StackType -- Subst StackType,
    expand match(
        STACK_TYPE_UNIT -> STACK_TYPE_UNIT,
        STCons -> dip(freshen) swap dip(freshen) swap STCons,
        STWith -> dip(freshen) swap dip(freshen) swap STWith,
        STConsLabel -> dip(dip(freshen) swap dip(freshen) swap) STConsLabel,
        STWithLabel -> dip(dip(freshen) swap dip(freshen) swap) STWithLabel,
        _ -> >Type freshen >StackType
    ))

def(StackType.freshen-aux, StackType Subst StackType -- StackType Subst StackType,
    expand match(
        STACK_TYPE_UNIT -> over,
        STCons -> dip(freshen-aux) swap dip(freshen) swap STCons,
        STWith -> dip(freshen-aux) swap dip(freshen) swap STWith,
        STConsLabel -> dip(dip(freshen-aux) swap dip(freshen) swap) STConsLabel,
        STWithLabel -> dip(dip(freshen-aux) swap dip(freshen) swap) STWithLabel,
        _ -> >Type freshen >StackType
    ))

def(StackType.rigidify!, +Mirth Ctx StackType -- +Mirth Ctx StackType,
    STACK_TYPE_ERROR -> STACK_TYPE_ERROR,
    STACK_TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE,
    STACK_TYPE_UNIT -> STACK_TYPE_UNIT,
    STMeta -> expand-or-update!(fresh-stack-type-var! TVar) >StackType rigidify!,
    STVar -> STVar,
    STCons -> dip(rigidify!) swap dip(rigidify!) swap STCons,
    STConsLabel -> dip(dip(rigidify!) swap dip(rigidify!) swap) STConsLabel,
    STWith -> dip(rigidify!) swap dip(rigidify!) swap STWith,
    STWithLabel -> dip(dip(rigidify!) swap dip(rigidify!) swap) STWithLabel)

def(StackType.num-morphisms-on-top, StackType -- Nat,
    STMeta -> expand-if(>StackType num-morphisms-on-top, drop 0u),
    STCons -> morphism? .if(num-morphisms-on-top 1+, drop 0u),
    STWith -> drop num-morphisms-on-top,
    STConsLabel -> drop2 num-morphisms-on-top,
    STWithLabel -> drop2 num-morphisms-on-top,
    _ -> drop 0u)

##############
# Arrow TYPE #
##############

data(ArrowType, ARROW_TYPE -> StackType StackType)
def(ArrowType.>Type, ArrowType -- Type, TMorphism)
def ArrowType.invert [ ArrowType -- ArrowType ] { ARROW_TYPE -> swap ARROW_TYPE }

def(ArrowType.unpack, ArrowType -- StackType StackType, ARROW_TYPE -> id)
def(ArrowType.dom, ArrowType -- StackType, unpack drop)
def(ArrowType.cod, ArrowType -- StackType, unpack nip)
def(ArrowType.unify!, +Mirth +Gamma ArrowType ArrowType -- +Mirth +Gamma ArrowType,
    dip(unpack) unpack
    dip(swap dip(unify!)) rotl
    dip(unify!) swap
    ARROW_TYPE)
def(ArrowType.unify-error!, +Mirth +Gamma ArrowType -- +Mirth +Gamma ArrowType,
    unpack dip(unify-error!) dip'(unify-error!) ARROW_TYPE)
def(ArrowType.has-meta?, MetaVar ArrowType -- Bool,
    unpack dip(over) has-meta? if(drop2 True, has-meta?))

def(ArrowType.sig;, +Str ArrowType -- +Str,
    unpack swap dom; "--"; cod;)

||| Replace the stack rest with a metavar, if they're both unit.
def(ArrowType.semifreshen-sig, ArrowType -- ArrowType,
    dup needs-fresh-stack-rest? then(semifreshen-aux))

def(ArrowType.semifreshen-aux, ArrowType -- ArrowType,
    MetaVar.new! STMeta swap unpack
    dip(semifreshen) swap
    dip(semifreshen) swap
    ARROW_TYPE nip)

def(ArrowType.needs-fresh-stack-rest?, ArrowType -- Bool,
    unpack base unit? if(
        base unit?,
        drop False
    ))

def(ArrowType.freshen-sig, Subst ArrowType -- Subst ArrowType,
    dup needs-fresh-stack-rest? if(
        freshen-sig-aux,
        freshen
    ))

def(ArrowType.freshen-sig-aux, Subst ArrowType -- Subst ArrowType,
    MetaVar.new! STMeta rotr unpack
    dip(freshen-aux) swap
    dip(freshen-aux) swap
    ARROW_TYPE dip(nip))

def(ArrowType.freshen, Subst ArrowType -- Subst ArrowType,
    unpack
    dip(freshen) swap
    dip(freshen) swap
    ARROW_TYPE)

def(ArrowType.rigidify!, +Mirth Ctx ArrowType -- +Mirth Ctx ArrowType,
    unpack
    dip(rigidify!) swap
    dip(rigidify!) swap
    ARROW_TYPE)

def(ArrowType.rigidify-sig!, +Mirth Ctx ArrowType -- +Mirth Ctx ArrowType,
    rigidify!)
    # TODO check if both stack bases are the same metavar,
    # and that this metavar appears nowhere else in the sig,
    # and if so, unify that metavar with STACK_TYPE_UNIT.
    #   https://github.com/mirth-lang/mirth/issues/239

def(ArrowType.max-num-params, ArrowType -- Nat,
    dom num-morphisms-on-top)

#########
# Subst #
#########

# mirth/data/type
data(Subst,
    SUBST_NIL,
    SUBST_CON -> Subst Type Var)

def(Subst.nil?, Subst -- Bool, SUBST_NIL -> True, _ -> drop False)
def(Subst.con?, Subst -- Maybe([Subst Type Var]),
    SUBST_CON -> pack3 Some,
    _ -> drop None)

def(Subst.nil, Subst, SUBST_NIL)
def(Subst.cons, Type Var Subst -- Subst, rotr SUBST_CON)
def(Subst.has-var?, Var Subst -- Bool,
    SUBST_NIL -> drop False,
    SUBST_CON -> nip over2 == if(drop2 True, has-var?))
def(Subst.get-var, Var Subst -- Type,
    SUBST_NIL -> drop TYPE_ERROR,
    SUBST_CON -> over3 == if(dip(drop2), drop get-var))

||| If variable is in subst, unify new type with type in subst.
||| Otherwise, create larger subst with new binding.
def(Subst.match-var, +Mirth +Gamma Type Var Subst -- +Mirth +Gamma Subst,
    dup2 has-var? if(
        sip(get-var unify! drop),
        cons
    ))

####################
# Stack Type Parts #
####################

data StackTypeBase {
    STB_ERROR
    STB_DONT_CARE
    STB_UNIT
    STBVar [ Var ]
    STBMeta [ MetaVar ]
}

data StackTypePart {
    STPCons      [ Type ]
    STPConsLabel [ Type Label ]
    STPWith      [ Resource ]
    STPWithLabel [ Resource Label ]
}

def(StackTypePart.cons, StackType StackTypePart -- StackType,
    STPCons -> STCons,
    STPConsLabel -> STConsLabel,
    STPWith -> STWith,
    STPWithLabel -> STWithLabel)

def(StackType.split-parts, StackType -- StackTypeBase List(StackTypePart),
    L0 >parts
    while-right(
        match {
            { STACK_TYPE_ERROR -> STB_ERROR Left }
            { STACK_TYPE_DONT_CARE -> STB_DONT_CARE Left }
            { STACK_TYPE_UNIT -> STB_UNIT Left }
            { STVar -> STBVar Left }
            { STMeta -> expand-if(>StackType Right, STBMeta Left) }
            { STCons -> STPCons @parts:cons Right }
            { STConsLabel -> STPConsLabel @parts:cons Right }
            { STWith -> STPWith @parts:cons Right }
            { STWithLabel -> STPWithLabel @parts:cons Right }
        }
    )
    parts>)

def StackTypePart.type/resource [ StackTypePart -- Type/Resource ] {
    { STPCons -> Left  }
    { STPWith -> Right }
    { STPConsLabel -> drop Left  }
    { STPWithLabel -> drop Right }
}

def StackTypePart.label [ StackTypePart -- Maybe(Label) ] {
    { STPCons -> drop None }
    { STPWith -> drop None }
    { STPConsLabel -> nip Some }
    { STPWithLabel -> nip Some }
}


###########
# C Types #
###########

data(CType,
    IntLike -> Str,
    F32Like -> Str,
    F64Like -> Str,
    PtrLike -> Str,
    FnPtr   -> Str,
    Phantom)

def(CType.cname, CType -- Str,
    IntLike -> id,
    F32Like -> id,
    F64Like -> id,
    PtrLike -> id,
    FnPtr   -> id,
    Phantom -> "void")

def(CType.phantom?, CType -- Bool,
    Phantom -> True,
    _ -> drop False)

def(Resource.ctype, +Mirth Resource -- +Mirth CType,
    /Resource ctype)

def(Type.ctype, +Mirth Type -- +Mirth CType,
    dup ctype? if-some(
        nip,
        Str(type; " doesn't have a C representation.";) error!
        Phantom
    ))

def(Resource.ctype?, +Mirth Resource -- +Mirth Maybe(CType),
    /Resource ctype?)

def(Type.ctype?, +Mirth Type -- +Mirth Maybe(CType),
    expand match(
        TPrim -> ctype?,
        TData -> ctype?,
        TMorphism -> drop "FNPTR" FnPtr Some,
        TApp -> ctype? bind(over ctype1?) nip,
        _ -> drop None,
    ))

def(Type.ctype1?, +Mirth CType Type -- +Mirth Maybe(CType),
    expand match(
        TData -> ctype1?,
        _ -> drop2 None
    ))

def PrimType.ctype? [ +Mirth PrimType -- +Mirth Maybe(CType) ] {
    { PRIM_TYPE_PTR -> "void*" PtrLike Some }
    { PRIM_TYPE_WORLD -> Phantom Some }
    { PRIM_TYPE_F32 -> "float" F32Like Some }
    { PRIM_TYPE_F64 -> "double" F64Like Some }
    { _ -> drop None }
}

def(Data.ctype1?, +Mirth CType Data -- +Mirth Maybe(CType),
    dup builtin cptr == if(
        drop cname " *" cat PtrLike Some,

    dup builtin cconst == if(
        drop match(
            IntLike -> "const " swap cat IntLike Some,
            F32Like -> "const " swap cat F32Like Some,
            F64Like -> "const " swap cat F64Like Some,
            FnPtr   -> "const " swap cat FnPtr Some,
            PtrLike -> " const" cat PtrLike Some,
            Phantom -> Phantom Some,
        ),

    dup builtin crestrict == if(
        drop match(
            IntLike -> "restrict " swap cat IntLike Some,
            F32Like -> "restrict " swap cat F32Like Some,
            F64Like -> "restrict " swap cat F64Like Some,
            FnPtr   -> "restrict " swap cat FnPtr Some,
            PtrLike -> " restrict" cat PtrLike Some,
            Phantom -> Phantom Some,
        ),

    dup builtin cvolatile == if(
        drop match(
            IntLike -> "volatile " swap cat IntLike Some,
            F32Like -> "volatile " swap cat F32Like Some,
            F64Like -> "volatile " swap cat F64Like Some,
            FnPtr   -> "volatile " swap cat FnPtr Some,
            PtrLike -> " volatile" cat PtrLike Some,
            Phantom -> Phantom Some,
        ),

        drop2 None
    )))))

data(CTypeStackPart,
    CTSPCons      -> CType,
    CTSPConsLabel -> CType Label,
    CTSPWith      -> CType,
    CTSPWithLabel -> CType Label)

def(CTypeStackPart.ctype, CTypeStackPart -- CType,
    CTSPCons -> id, CTSPConsLabel -> drop,
    CTSPWith -> id, CTSPWithLabel -> drop)

def(CTypeStackPart.label?, CTypeStackPart -- Maybe(Label),
    CTSPCons -> drop None, CTSPConsLabel -> nip Some,
    CTSPWith -> drop None, CTSPWithLabel -> nip Some)

def(CTypeStackPart.resource?, CTypeStackPart -- Bool,
    CTSPCons -> drop False, CTSPConsLabel -> drop2 False,
    CTSPWith -> drop True,  CTSPWithLabel -> drop2 True)

data(CTypeStack, CTypeStack ->
    base?: Maybe(Var)
    parts: List(CTypeStackPart))

def(StackTypePart.ctype, StackTypePart +Mirth -- CTypeStackPart +Mirth,
    STPCons -> ctype CTSPCons,
    STPConsLabel -> dip(ctype) CTSPConsLabel,
    STPWith -> ctype CTSPWith,
    STPWithLabel -> dip(ctype) CTSPWithLabel)

def(StackTypePart.ctype?, StackTypePart +Mirth -- Maybe(CTypeStackPart) +Mirth,
    STPCons -> ctype? map(CTSPCons),
    STPConsLabel -> >x ctype? map(@x CTSPConsLabel) x> drop,
    STPWith -> ctype? map(CTSPWith),
    STPWithLabel -> >x ctype? map(@x CTSPWithLabel) x> drop)

def StackTypeBase.ctype? [ StackTypeBase +Mirth -- Maybe(Var) +Mirth ] {
    { STB_ERROR -> None }
    { STB_DONT_CARE -> None }
    { STB_UNIT -> None }
    { STBMeta -> drop None }
    { STBVar -> Some }
}

def(StackType.ctype, StackType +Mirth -- CTypeStack +Mirth,
    split-parts
    map(ctype) >parts
    ctype? >base?
    CTypeStack)

def(StackType.ctype?, StackType +Mirth -- Maybe(CTypeStack) +Mirth,
    split-parts all-some(ctype?) if-some(
        >parts
        ctype? >base?
        CTypeStack Some,

        drop None
    ))

data(CTypeArrow, CTypeArrow ->
    dom: CTypeStack
    cod: CTypeStack)

def(ArrowType.ctype, ArrowType +Mirth -- CTypeArrow +Mirth,
    unpack dip(ctype >dom) ctype >cod CTypeArrow)

def(ArrowType.ctype?, ArrowType +Mirth -- Maybe(CTypeArrow) +Mirth,
    unpack on2(ctype?) map2(>cod >dom CTypeArrow))
