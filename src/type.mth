
module(mirth.type)

import(std.prelude)
import(std.maybe)
import(std.list)
import(std.str)
import(std.either)
import(std.posix)
import(mirth.name)
import(mirth.token)
import(mirth.arrow)
import(mirth.location)
import(mirth.def)
import(mirth.var)
import(mirth.table)
import(mirth.tycon)
import(mirth.typedef)
import(mirth.mirth)
import(mirth.data)
import(mirth.label)

data(Type,
    TYPE_ERROR,
    TYPE_DONT_CARE,
    TPrim -> PrimType,
    TMeta -> MetaVar,
    THole -> Name,
    TVar -> Var,
    TTable -> Table,
    TData -> Data,
    TDataPartial -> DataPartial,
    TTensor -> StackType,
    TMorphism -> ArrowType,
    TApp -> Type Type,
    TMut -> Type,
    TValue -> Value)

data(Value,
    VALUE_INT -> Int,
    VALUE_STR -> Str,
    VALUE_BLOCK -> Block)

data(PrimType,
    PRIM_TYPE_TYPE,
    PRIM_TYPE_STACK,
    PRIM_TYPE_RESOURCE,
    PRIM_TYPE_INT,
    PRIM_TYPE_PTR,
    PRIM_TYPE_STR,
    PRIM_TYPE_WORLD,
    )

def(PrimType.is-physical?, PrimType -- Bool,
    PRIM_TYPE_TYPE -> False,
    PRIM_TYPE_STACK -> False,
    PRIM_TYPE_RESOURCE -> False,
    _ -> drop True)

||| Get type constructor name for a type, if possible.
def(Type.tycon?, Type -- Maybe(Tycon),
    TYPE_ERROR -> None,
    TYPE_DONT_CARE -> None,
    TPrim -> TYCON_PRIM Some,
    TMeta -> expand-if(tycon?, drop None),
    THole -> drop None,
    TVar -> drop None,
    TTable -> TYCON_TABLE Some,
    TData -> TYCON_DATA Some,
    TDataPartial -> .data TYCON_DATA Some,
    TMorphism -> drop None,
    TTensor -> drop None,
    TApp -> drop tycon?,
    TMut -> tycon?,
    TValue -> tycon?)

||| Get primitive type constructor name.
def(PrimType.tycon-qname, +Mirth PrimType -- +Mirth QName,
    PRIM_TYPE_TYPE -> "TYPE" 0 QName.prim,
    PRIM_TYPE_STACK -> "STACK" 0 QName.prim,
    PRIM_TYPE_RESOURCE -> "RESOURCE" 0 QName.prim,
    PRIM_TYPE_INT -> "Int" 0 QName.prim,
    PRIM_TYPE_STR -> "Str" 0 QName.prim,
    PRIM_TYPE_PTR -> "Ptr" 0 QName.prim,
    PRIM_TYPE_WORLD -> "+World" 0 QName.prim)

||| Get value type constructor name.
def(Value.tycon?, Value -- Maybe(Tycon),
    VALUE_INT -> drop PRIM_TYPE_INT TYCON_PRIM Some,
    VALUE_STR -> drop PRIM_TYPE_STR TYCON_PRIM Some,
    VALUE_BLOCK -> drop None)

def(PrimType.>Int, PrimType -- Int, PrimType.tag)
def(PrimType.==, PrimType PrimType -- Bool, both(>Int) ==)

def(def-prim-type!, +Mirth PrimType -- +Mirth,
    dip(None) dup tycon-qname swap TPrim TypeDef.new! drop)

def(init-types!, +Mirth -- +Mirth,
    PRIM_TYPE_INT def-prim-type!
    PRIM_TYPE_PTR def-prim-type!
    PRIM_TYPE_STR def-prim-type!
    PRIM_TYPE_WORLD def-prim-type!
    init-data!)

#########
# Types #
#########

def(T+, StackType Resource -- StackType, STWith)
def(T*, StackType Type -- StackType, STCons)
def(T*+, StackType Type/Resource -- StackType, match(Left -> T*, Right -> T+))
def(T->, StackType StackType -- ArrowType, ARROW_TYPE)

def(TT, List(Type) -- StackType, T0 swap for(T*))
def(T0, StackType, STACK_TYPE_UNIT)
def(T1, Type -- StackType, dip(T0) T*)
def(T2, Type Type -- StackType, dip(T1) T*)
def(T3, Type Type Type -- StackType, dip(T2) T*)
def(T4, Type Type Type Type -- StackType, dip(T3) T*)
def(T5, Type Type Type Type Type -- StackType, dip(T4) T*)
def(T6, Type Type Type Type Type Type -- StackType, dip(T5) T*)

# def(type-is-error, Type -- Bool, match(TYPE_ERROR -> True, _ -> drop False))
# def(type-is-dont-care, Type -- Bool, match(TYPE_DONT_CARE -> True, _ -> drop False))
# def(type-is-prim, Type -- Bool, match(TPrim -> drop True, _ -> drop False))
# def(type-is-var, Type -- Bool, match(TVar -> drop True, _ -> drop False))
# def(type-is-meta, Type -- Bool, match(TMeta -> drop True, _ -> drop False))
# def(type-is-tensor, Type -- Bool, match(TTensor -> drop2 True, _ -> drop False))
# def(type-is-table, Type -- Bool, match(TTable -> drop True, _ -> drop False))
# def(type-is-hole, Type -- Bool, match(THole -> drop True, _ -> drop False))
# def(type-is-app, Type -- Bool, match(TApp -> drop2 True, _ -> drop False))
# def(type-is-data, Type -- Bool, match(TData -> drop True, _ -> drop False))

def(Type.error?, Type -- Bool, expand match(TYPE_ERROR -> True, _ -> drop False))
def(Type.morphism?, Type -- Maybe(ArrowType), expand match(TMorphism -> Some, _ -> drop None))
def(Type.prim?, Type -- Maybe(PrimType), expand match(TPrim -> Some, _ -> drop None))

def(Type.tensor?, Type -- Maybe(StackType), expand match(TTensor -> Some, _ -> drop None))
def(Type.unit?, Type -- Bool, tensor? if-some(unit?, False))

def(Type.meta=, MetaVar Type -- Bool,
    TMeta -> ==,
    _ -> drop2 False)

def(Type.is-physical?, Type -- Bool,
    TMeta -> expand-if(is-physical?, "unbound meta at Type.is-physical?" panic!),
    TPrim -> is-physical?,
    _ -> drop True)

def(TYPE_UNIT, Type, STACK_TYPE_UNIT TTensor) # unit type
def(TYPE_TYPE, Type, PRIM_TYPE_TYPE TPrim) # type of types
def(TYPE_STACK, Type, PRIM_TYPE_STACK TPrim) # type of stack types
def(TYPE_RESOURCE, Type, PRIM_TYPE_RESOURCE TPrim) # type of (linear) resources
def(TYPE_INT, Type, PRIM_TYPE_INT TPrim) # generic integer type for integer literals
def(TYPE_PTR, Type, PRIM_TYPE_PTR TPrim) # generic pointer type (e.g. void*)
def(TYPE_STR, Type, PRIM_TYPE_STR TPrim) # string pointer (just a pointer but nominally)
# def(TYPE_U8, Type, PRIM_TYPE_U8 TPrim) # fixed width integer type -- unsigned 8 bit
# def(TYPE_U16, Type, PRIM_TYPE_U16 TPrim) # fixed width integer type -- unsigned 16 bit
# def(TYPE_U32, Type, PRIM_TYPE_U32 TPrim) # fixed width integer type -- unsigned 32 bit
# def(TYPE_U64, Type, PRIM_TYPE_U64 TPrim) # fixed width integer type -- unsigned 64 bit
# def(TYPE_I8, Type, PRIM_TYPE_I8 TPrim) # fixed width integer type -- signed 8 bit
# def(TYPE_I16, Type, PRIM_TYPE_I16 TPrim) # fixed width integer type -- signed 16 bit
# def(TYPE_I32, Type, PRIM_TYPE_I32 TPrim) # fixed width integer type -- signed 32 bit
# def(TYPE_I64, Type, PRIM_TYPE_I64 TPrim) # fixed width integer type -- signed 64 bit
def(TYPE_WORLD, Type, PRIM_TYPE_WORLD TPrim)
def(RESOURCE_WORLD, Resource, TYPE_WORLD RESOURCE)

def(Type.expand, Type -- Type,
    TMeta -> expand,
    _ -> id)

data(+Gamma, +Gamma -> token: Token)
def(+Gamma.rdrop, +Gamma --, /+Gamma token> drop)

||| Raise a type unification error.
def(Type.unify-failed!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    Str("Failed to unify " ; dip:type; " with " ; type;) dip:token rdip:emit-error! TYPE_ERROR)

||| Unify types directly, without regard to metavariables and other metatypes.
def(Type.unify-simple!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    TVar -> swap match(TVar -> unify!, _ -> dip(TVar) unify-failed!),
    TPrim -> swap match(TPrim -> unify!, _ -> dip(TPrim) unify-failed!),
    TData -> swap match(TData -> unify!, _ -> dip(TData) unify-failed!),
    TDataPartial -> swap match(TDataPartial -> unify!, _ -> dip(TDataPartial) unify-failed!),
    TTable -> swap match(TTable -> unify!, _ -> dip(TTable) unify-failed!),
    TTensor -> swap match(TTensor -> unify! >Type, _ -> dip(TTensor) unify-failed!),
    TMorphism -> swap match(TMorphism -> unify! TMorphism, _ -> dip(TMorphism) unify-failed!),
    TApp -> rotl match(TApp -> unify2! TApp, _ -> dip(TApp) unify-failed!),
    TMut -> swap match(TMut -> unify! TMut, _ -> dip(TMut) unify-failed!),
    _ -> unify-failed!)

||| Unify expanded types.
def(Type.unify-aux!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    TYPE_ERROR -> unify-error!,
    TYPE_DONT_CARE -> id,
    THole -> type-hole-unify!,
    TMeta ->
        swap match(
            TYPE_ERROR -> unify-error!,
            TYPE_DONT_CARE -> TMeta,
            THole -> dip(TMeta) type-hole-unify!,
            TMeta -> dip(TMeta) unify!,
            TValue -> dip(TMeta) unify-type!,
            _ -> swap unify!,
        ),
    TValue ->
        swap match(
            TYPE_ERROR -> unify-error!,
            TYPE_DONT_CARE -> TValue,
            THole -> dip(TValue) type-hole-unify!,
            TMeta -> dip(TValue) unify!,
            TValue -> unify!,
            _ -> swap unify-type!
        ),
    _ ->
        swap match(
            TYPE_ERROR -> unify-error!,
            TYPE_DONT_CARE -> id,
            THole -> type-hole-unify!,
            TMeta -> unify!,
            TValue -> unify-type!,
            _ -> unify-simple!
        )
    )

||| Fill out any subterms/metavars with TYPE_ERROR.
def(Type.unify-error!, +Mirth +Gamma Type -- +Mirth +Gamma Type,
    expand match(
        TYPE_ERROR -> TYPE_ERROR,
        TYPE_DONT_CARE -> TYPE_ERROR,
        THole -> TYPE_ERROR swap type-hole-unify!,
        TMeta -> unify-error!,
        TValue -> unify-error!,
        TVar -> drop TYPE_ERROR,
        TPrim -> drop TYPE_ERROR,
        TData -> drop TYPE_ERROR,
        TDataPartial -> drop TYPE_ERROR,
        TTable -> drop TYPE_ERROR,
        TTensor -> unify-error! drop TYPE_ERROR,
        TMorphism -> unify-error! drop TYPE_ERROR,
        TApp -> dip(unify-error! drop) unify-error! drop TYPE_ERROR,
        TMut -> unify-error! drop TYPE_ERROR,
    ))

||| Unify two types. Raises a unification error if unification is impossible.
def(Type.unify!, +Mirth +Gamma Type Type -- +Mirth +Gamma Type,
    both(expand) unify-aux!)

def(Value.unify!, +Mirth +Gamma Value Value -- +Mirth +Gamma Type,
    swap match(
        VALUE_INT -> swap match(
            VALUE_INT -> dup2 == if(drop VALUE_INT TValue, drop2 TYPE_INT),
            VALUE_STR ->
                drop2 token
                "Can't unify int value with string value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 token
                "Can't unify int value with block."
                rdip:emit-error! TYPE_ERROR,
        ),

        VALUE_STR -> swap match(
            VALUE_STR -> dup2 == if(drop VALUE_STR TValue, drop2 TYPE_STR),
            VALUE_INT ->
                drop2 token
                "Can't unify string value with int value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_BLOCK ->
                drop2 token
                "Can't unify string value with block."
                rdip:emit-error! TYPE_ERROR,
        ),

        VALUE_BLOCK -> swap match(
            VALUE_BLOCK ->
                dup2 == if(
                    drop VALUE_BLOCK TValue,
                    rdip:arrow type block-unify-type! >Type
                ),
            VALUE_INT ->
                drop2 token
                "Can't unify block with int value."
                rdip:emit-error! TYPE_ERROR,
            VALUE_STR ->
                drop2 token
                "Can't unify block with string value."
                rdip:emit-error! TYPE_ERROR
        ),
    ))

def(Value.unify-type!, +Mirth +Gamma Type Value -- +Mirth +Gamma Type,
    VALUE_INT -> drop TYPE_INT unify!,
    VALUE_STR -> drop TYPE_STR unify!,
    VALUE_BLOCK -> swap unify-block!)

def(Value.unify-error!, +Mirth +Gamma Value -- +Mirth +Gamma Type,
    VALUE_INT -> drop TYPE_ERROR,
    VALUE_STR -> drop TYPE_ERROR,
    VALUE_BLOCK -> TYPE_ERROR unify-block!)

def(Type.unify-block!, +Mirth +Gamma Block Type -- +Mirth +Gamma Type,
    expand match(
        TYPE_ERROR -> STACK_TYPE_ERROR STACK_TYPE_ERROR T-> block-unify-type! drop TYPE_ERROR,
        TMeta -> over dip(dip(type >Type) unify! drop) rdip:arrow type >Type,
        TMorphism -> block-unify-type! >Type,
        _ -> dip(type >Type) unify!
    ))

def(Type.unify2!, +Mirth +Gamma Type Type Type Type -- +Mirth +Gamma Type Type,
    dip(swap) dip2(unify!) unify!)

def(PrimType.unify!, +Mirth +Gamma PrimType PrimType -- +Mirth +Gamma Type,
    dup2 == if(drop TPrim, both(TPrim) unify-failed!))
def(Data.unify!, +Mirth +Gamma Data Data -- +Mirth +Gamma Type,
    dup2 == if(drop TData, both(TData) unify-failed!))
def(DataPartial.unify!, +Mirth +Gamma DataPartial DataPartial -- +Mirth +Gamma Type,
    dup2 == if(drop TDataPartial, both(TDataPartial) unify-failed!))
def(Table.unify!, +Mirth +Gamma Table Table -- +Mirth +Gamma Type,
    dup2 == if(drop TTable, both(TTable) unify-failed!))

def(Type.has-meta?, MetaVar Type -- Bool,
    TMeta -> has-meta?,
    TYPE_ERROR -> drop False,
    TYPE_DONT_CARE -> drop False,
    TPrim -> drop2 False,
    TVar -> drop2 False,
    THole -> drop2 False,
    TTensor -> has-meta?,
    TMorphism -> has-meta?,
    TApp -> has-meta2?,
    TData -> drop2 False,
    TDataPartial -> drop2 False,
    TTable -> drop2 False,
    TValue -> has-meta?,
    TMut -> has-meta?)

def(Type.has-meta2?, MetaVar Type Type -- Bool,
    dip(over) has-meta? if(drop2 True, has-meta?))

def(Value.has-meta?, MetaVar Value -- Bool,
    type has-meta?)

def(Type.sig;, Type +Str -- +Str,
    TMeta -> expand-if(sig;, type;),
    TYPE_ERROR -> "<ERROR>" ;,
    TMorphism -> sig;,
    _ -> type;)

def(Type.type;, Type +Str -- +Str,
    TYPE_ERROR -> "<ERROR>" ;,
    TYPE_DONT_CARE -> "_" ;,
    TPrim -> type;,
    TVar -> type;,
    TMeta -> type;,
    TTensor -> "[" ; stack; "]" ;,
    TMorphism -> "[" ; sig; "]" ;,
    TData -> name >Str ;,
    TDataPartial -> dup .data name >Str ; "/" ; .field name >Str ;,
    TTable -> name >Str ;,
    THole -> >Str ;,
    TApp -> app-type;;,
    TValue -> type type;,
    TMut -> "Mut(" ; type; ")" ;)

def(Value.type, Value -- Type,
    VALUE_INT -> drop PRIM_TYPE_INT TPrim,
    VALUE_STR -> drop PRIM_TYPE_STR TPrim,
    VALUE_BLOCK -> type >Type)

def(PrimType.type;, +Str PrimType -- +Str,
    match(
        PRIM_TYPE_TYPE -> "<TYPE>",
        PRIM_TYPE_STACK -> "<STACK>",
        PRIM_TYPE_RESOURCE -> "<RESOURCE>",
        PRIM_TYPE_INT -> "Int",
        PRIM_TYPE_PTR -> "Ptr",
        PRIM_TYPE_STR -> "Str",
        PRIM_TYPE_WORLD -> "+World"
    ) ;)

# ||| Freshen a type signature in preparation for type sig application.
# def(Type.freshen-sig, Subst Type -- Subst Type,
#     dup sig-needs-fresh-stack-rest? if(
#         freshen-sig-aux,
#         freshen
#     ))

# def(Type.sig-needs-fresh-stack-rest?, Type -- Bool,
#     TMeta -> expand-if(sig-needs-fresh-stack-rest?, drop False),
#     TMorphism -> needs-fresh-stack-rest?,
#     _ -> drop False)

# def(Type.freshen-sig-aux, Subst Type -- Subst Type,
#     TMeta -> expand-if(freshen-sig-aux, TMeta),
#     TMorphism -> freshen-sig-aux TMorphism,
#     _ -> freshen)

||| Replace free type vars and free metavars with brand new metavars.
def(Type.freshen, Subst Type -- Subst Type,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TData -> TData,
    TDataPartial -> TDataPartial,
    TTable -> TTable,
    TValue -> TValue, # no need to freshen values
    TVar -> freshen,
    TMeta -> freshen,
    TTensor -> freshen TTensor,
    TMorphism -> freshen TMorphism,
    TApp -> freshen2 TApp,
    TMut -> freshen TMut,
    )

def(Type.freshen2, Subst Type Type -- Subst Type Type,
    dip(freshen swap) freshen dip(swap))


||| Replace unbound metavars with new vars, adding them to context.
def(Type.rigidify!, +Mirth Ctx Type -- +Mirth Ctx Type,
    TMeta ->
        expand-or-update!(
            fresh-type-var! TVar
        ) rigidify!,
    TYPE_ERROR -> TYPE_ERROR,
    TYPE_DONT_CARE -> TYPE_DONT_CARE,
    TPrim -> TPrim,
    THole -> THole,
    TVar -> TVar,
    TTable -> TTable,
    TData -> TData,
    TDataPartial -> TDataPartial,
    TApp ->
        dip(rigidify!) swap
        dip(rigidify!) swap
        TApp,
    TTensor -> rigidify! TTensor,
    TMorphism -> rigidify! TMorphism,
    TValue -> rigidify!,
    TMut -> rigidify! TMut)

def(Value.rigidify!, +Mirth Ctx Value -- +Mirth Ctx Type,
    VALUE_INT -> VALUE_INT TValue,
    VALUE_STR -> VALUE_STR TValue,
    VALUE_BLOCK -> arrow type rigidify! >Type)

||| How many types does this type take as an argument?
def(Type.arity, Type -- Int,
    TMeta -> expand-if(arity, drop 0),
    TData -> arity,
    TApp -> drop arity 1-,
    _ -> drop 0)

||| Get head of type.
def(type-head, Type -- Type,
    TMeta -> expand-if(type-head, TMeta),
    TApp -> drop type-head,
    _ -> id)

||| For types that can have a field associated with them,
||| get the number of values n, where the type's values
||| range from 0 to (n-1). This should not be too large.
|||
||| Do NOT return Some(n) unless the type has values 0..n-1
def(type-max-count, Type -- Maybe(Nat),
    TMeta -> expand-if(type-max-count, drop None),
    TApp -> drop type-max-count,
    TTable -> max-count 1+ Some,
    TData ->
        dup is-enum? if(
            num-tags Some,
            drop None
        ),
    _ -> drop None)

def(Type.except-field, Label Tag Type -- Type,
    TMeta -> expand-if(except-field, "Type.except-field on metavar" panic!),
    TData -> >data drop >field DataPartial TDataPartial,
    TApp -> dip(except-field) TApp,
    _ -> "Type.except-field on unexpected type" panic!)

##################
# Meta-var Types #
##################

table(MetaVar)
field(MetaVar.~type?, MetaVar, Maybe(Type))
def(MetaVar.type?, MetaVar -- Maybe(Type), ~type? @)

def(MetaVar.has-meta?, MetaVar MetaVar -- Bool,
    dup type? match(
        None -> ==,
        Some -> nip has-meta?
    ))

def(MetaVar.type;, +Str MetaVar -- +Str,
    dup type? match(
        None -> "?" ; index show;,
        Some -> nip type;
    ))
def(MetaVar.new!, MetaVar,
    MetaVar.alloc!
    None over ~type? !)

def(MetaVar.expand-if(f,g), (*a Type -- *b, *a MetaVar -- *b) *a MetaVar -- *b,
    dup type? match(
        None -> g,
        Some -> expand tuck Some swap ~type? ! f
    ))
def(MetaVar.expand, MetaVar -- Type,
    expand-if(id, TMeta))
def(MetaVar.unify!, +Mirth +Gamma Type MetaVar -- +Mirth +Gamma Type,
    dup type? match(
        Some -> nip unify!,
        None -> dup2 swap meta= if(
            drop,
            swap dup2 has-meta? if(
                swap TMeta unify-failed!,
                tuck Some swap ~type? !
            )
        )
    ))
def(MetaVar.unify-error!, +Mirth +Gamma MetaVar -- +Mirth +Gamma Type,
    dup type? match(
        Some -> nip unify-error!,
        None -> dip(TYPE_ERROR Some) ~type? ! TYPE_ERROR
    ))
def(MetaVar.expand-or-update!(f), (*a -- *a Type) *a MetaVar -- *a Type,
    dup type? match(
        None -> dip(f dup Some) ~type? !,
        Some -> nip
    ))

def(MetaVar.==, MetaVar MetaVar -- Bool, both(index) ==)

def(MetaVar.freshen, Subst MetaVar -- Subst Type,
    expand-if(freshen, drop MetaVar.new! TMeta))

##############
# Type Holes #
##############

def(type-hole-unify!, Type Name -- Type,
    Str(THole type; " ~ "; dup type; "\n" ;) trace!)

############
# APP TYPE #
############

def(Type.app-type;;, +Str Type Type -- +Str,
    app-type-open;; ")" ;)

def(Type.app-type-open;;, +Str Type Type -- +Str,
    swap expand match(
        TApp -> app-type-open;; ", " ; type;,
        _ -> type; "(" ; type;
    ))

#################
# RESOURCE TYPE #
#################

data(Resource, RESOURCE -> Type)
def(Resource.>Type, Resource -- Type, RESOURCE -> id)
def(Type.>Resource, Type -- Resource, RESOURCE)
def(Resource.has-meta?, MetaVar Resource -- Bool, >Type has-meta?)
def(Resource.unify!, +Mirth +Gamma Resource Resource -- +Mirth +Gamma Resource,
    both(>Type) unify! >Resource)
def(Resource.unify-error!, +Mirth +Gamma Resource -- +Mirth +Gamma Resource,
    >Type unify-error! >Resource)
def(Resource.type;, +Str Resource -- +Str, >Type type;)
def(Resource.freshen, Subst Resource -- Subst Resource,
    >Type freshen >Resource)
def(Resource.rigidify!, +Mirth Ctx Resource -- +Mirth Ctx Resource,
    >Type rigidify! >Resource)

def(Resource.except-field, Label Tag Resource -- Resource,
    /RESOURCE except-field RESOURCE)

##############
# STACK TYPE #
##############

data(StackType,
    STACK_TYPE_ERROR,
    STACK_TYPE_DONT_CARE,
    STACK_TYPE_UNIT,
    STVar -> Var,
    STMeta -> MetaVar,
    STCons -> StackType Type,
    STConsLabel -> StackType Type Label,
    STWith -> StackType Resource,
    STWithLabel -> StackType Resource Label)

def(Type.>StackType, Type -- StackType,
    TYPE_ERROR -> STACK_TYPE_ERROR,
    TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE,
    TVar -> STVar,
    TMeta -> STMeta,
    TTensor -> id,
    _ -> "kind error! expected stack type, got regular type." panic!)

def(StackType.>Type, StackType -- Type,
    STACK_TYPE_ERROR -> TYPE_ERROR,
    STACK_TYPE_DONT_CARE -> TYPE_DONT_CARE,
    STVar -> TVar,
    STMeta -> TMeta,
    _ -> TTensor)

def(StackType.expand, StackType -- StackType,
    STMeta -> expand >StackType,
    _ -> id)

def(StackType.unit?, StackType -- Bool,
    expand match(
        STACK_TYPE_UNIT -> True,
        _ -> drop False
    ))

def-type(Type/Resource, Either(Type, Resource))

||| Split stack type into base, types, and resources.
def(StackType.split4, StackType -- StackType List([Type/Resource Label]) List(Type) List(Resource),
    L0 L0 L0 >labels >withses >conses
    while(
        expand match(
            STCons -> conses> Cons >conses True,
            STWith -> withses> Cons >withses True,
            STConsLabel -> dip:Left pack2 labels> Cons >labels True,
            STWithLabel -> dip:Right pack2 labels> Cons >labels True,
            _ -> False
        ), id
    ) labels> conses> withses>)

||| Get bottom of stack.
def(StackType.base, StackType -- StackType, split4 drop3)

||| Get types with labels on stack.
def(StackType.labels, StackType -- List([Type/Resource Label]), split4 drop2 nip)

||| Get types on stack.
def(StackType.types, StackType -- List(Type), split4 drop dip(drop2))

||| Get resources on stack.
def(StackType.resources, StackType -- List(Resource), split4 dip(drop3))

||| Check if the stack label appears and return the type/resource on top.
def(StackType.label-top?, Label StackType -- Maybe(Type/Resource),
    expand match(
        STCons -> drop label-top?,
        STWith -> drop label-top?,
        STConsLabel -> over3 over == if(drop dip:drop2 Left  Some, drop2 label-top?),
        STWithLabel -> over3 over == if(drop dip:drop2 Right Some, drop2 label-top?),
        _ -> drop2 None
    ))

||| Does the stack label exist and have a resource on top?
def(StackType.label-resource-top?, Label StackType -- Maybe(Resource),
    label-top? bind:right?)

||| Does the stack label exist and have a value type on top?
def(StackType.label-type-top?, Label StackType -- Maybe(Type),
    label-top? bind:left?)

||| Get top stack type if possible.
def(StackType.top-type?, StackType -- Maybe(Type),
    expand match(
        STWith -> drop top-type?,
        STCons -> nip Some,
        STConsLabel -> drop2 top-type?,
        STWithLabel -> drop2 top-type?,
        _ -> drop None
    ))

||| Get the top type constructor name.
def(StackType.top-tycon?, StackType -- Maybe(Tycon),
    top-type? bind(tycon?))

||| Get top resource if possible.
def(StackType.top-resource?, StackType -- Maybe(Resource),
    expand match(
        STWith -> nip Some,
        STCons -> drop top-resource?,
        STConsLabel -> drop2 top-resource?,
        STWithLabel -> drop2 top-resource?,
        _ -> drop None
    ))

||| Get the top resource name.
def(StackType.top-resource-tycon?, StackType -- Maybe(Tycon),
    top-resource? bind(>Type tycon?))

def(StackType.top-namespaces, StackType -- List(Namespace),
    LIST(
        dup top-tycon? for(NAMESPACE_TYCON ;)
        top-resource-tycon? for(NAMESPACE_TYCON ;)
    ))

def(StackType.top-types-are-fine?, StackType -- Bool,
    dup top-value-is-fine? and(dup top-resource-is-fine?) nip)

def(StackType.top-value-is-fine?, StackType -- Bool,
    expand match(
        STCons -> nip Type.error? not,
        STConsLabel -> drop2 top-value-is-fine?,
        STWith -> drop top-value-is-fine?,
        STWithLabel -> drop2 top-value-is-fine?,
        STMeta -> drop True,
        STVar -> drop True,
        STACK_TYPE_UNIT -> True,
        STACK_TYPE_ERROR -> False,
        STACK_TYPE_DONT_CARE -> False,
    ))

def(StackType.top-resource-is-fine?, StackType -- Bool,
    expand match(
        STCons -> drop top-resource-is-fine?,
        STConsLabel -> drop2 top-resource-is-fine?,
        STWith -> nip /RESOURCE error? not,
        STWithLabel -> drop2 top-resource-is-fine?,
        STMeta -> drop True,
        STVar -> drop True,
        STACK_TYPE_UNIT -> True,
        STACK_TYPE_ERROR -> False,
        STACK_TYPE_DONT_CARE -> False,
    ))

def(StackType.has-meta?, MetaVar StackType -- Bool,
    expand match(
        STMeta -> ==,
        STACK_TYPE_ERROR -> drop False,
        STACK_TYPE_DONT_CARE -> drop False,
        STVar -> drop2 False,
        STACK_TYPE_UNIT -> drop False,
        STCons -> dip(over) has-meta? if(drop2 True, has-meta?),
        STConsLabel -> drop dip(over) has-meta? if(drop2 True, has-meta?),
        STWith -> dip(over) has-meta? if(drop2 True, has-meta?),
        STWithLabel -> drop dip(over) has-meta? if(drop2 True, has-meta?),
    ))

def(StackType.unify-failed!, +Mirth +Gamma StackType StackType -- +Mirth +Gamma StackType,
    both(>Type) unify-failed! >StackType)

def(StackType.unify!, +Mirth +Gamma StackType StackType -- +Mirth +Gamma StackType,
    swap expand match(
        STACK_TYPE_ERROR -> unify-error!,
        STACK_TYPE_DONT_CARE -> id,
        STMeta -> swap expand match(
            STACK_TYPE_ERROR -> STMeta unify-error!,
            STACK_TYPE_DONT_CARE -> STMeta,
            STMeta -> dip(TMeta) unify! >StackType,
            _ -> >Type swap unify! >StackType,
        ),
        STVar -> swap expand match(
            STACK_TYPE_ERROR -> drop STACK_TYPE_ERROR,
            STACK_TYPE_DONT_CARE -> STVar,
            STMeta -> dip(TVar) unify! >StackType,
            STVar -> unify! >StackType,
            _ -> dip(STVar) unify-failed!
        ),
        STACK_TYPE_UNIT -> expand match(
            STACK_TYPE_ERROR -> STACK_TYPE_ERROR,
            STMeta -> dip(STACK_TYPE_UNIT >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STACK_TYPE_UNIT,
            STACK_TYPE_UNIT -> STACK_TYPE_UNIT,
            _ -> STACK_TYPE_UNIT unify-failed!
        ),
        STCons -> rotl expand match(
            STACK_TYPE_ERROR -> STCons unify-error!,
            STMeta -> dip(STCons >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STCons,
            _ -> dup force-cons?! if-some(
                nip unpack2 dip(swap) dip2(unify!) unify! STCons,
                dip(STCons) unify-failed!
            )
        ),
        STWith -> rotl expand match(
            STACK_TYPE_ERROR -> STWith unify-error!,
            STMeta -> dip(STWith >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STWith,
            _ -> dup force-with?! if-some(
                nip unpack2 dip(swap) dip2(unify!) unify! STWith,
                dip(STWith) unify-failed!
            )
        ),
        STConsLabel -> rot4l expand match(
            STACK_TYPE_ERROR -> STConsLabel unify-error!,
            STMeta -> dip(STConsLabel >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STConsLabel,
            _ -> dup2 force-cons-label?! if-some(
                nip swap dip(unpack2 dip(swap) dip2(unify!) unify!) STConsLabel,
                dip(STConsLabel) unify-failed!
            )
        ),
        STWithLabel -> rot4l expand match(
            STACK_TYPE_ERROR -> STWithLabel unify-error!,
            STMeta -> dip(STWithLabel >Type) unify! >StackType,
            STACK_TYPE_DONT_CARE -> STWithLabel,
            _ -> dup2 force-with-label?! if-some(
                nip swap dip(unpack2 dip(swap) dip2(unify!) unify!) STWithLabel,
                dip(STWithLabel) unify-failed!
            )
        ),
    ))

def(StackType.unify-error!, +Mirth +Gamma StackType -- +Mirth +Gamma StackType,
    expand match(
        STACK_TYPE_ERROR -> STACK_TYPE_ERROR,
        STACK_TYPE_UNIT -> STACK_TYPE_ERROR,
        STACK_TYPE_DONT_CARE -> STACK_TYPE_ERROR,
        STMeta -> unify-error! >StackType,
        STVar -> drop STACK_TYPE_ERROR,
        STCons -> dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
        STWith -> dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
        STConsLabel -> drop dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
        STWithLabel -> drop dip(unify-error! drop) unify-error! drop STACK_TYPE_ERROR,
    ))

def(StackType.force-cons-label?!, Label StackType -- Maybe([StackType Type]),
    expand match(
        STACK_TYPE_ERROR -> drop STACK_TYPE_ERROR TYPE_ERROR pack2 Some,
        STACK_TYPE_DONT_CARE -> drop STACK_TYPE_DONT_CARE TYPE_DONT_CARE pack2 Some,
        STACK_TYPE_UNIT -> drop None,
        STVar -> drop2 None,
        STWith -> dip(force-cons-label?!) swap map(unpack2 dip(over STWith) pack2) nip,
        STCons -> dip(force-cons-label?!) swap map(unpack2 dip(over STCons) pack2) nip,
        STConsLabel ->
            over3 over == if(
                drop rotl drop pack2 Some,
                dip(dip(force-cons-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STWithLabel ->
            over3 over == if(
                drop4 None,
                dip(dip(force-cons-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STMeta ->
            dip(dip(MetaVar.new! STMeta MetaVar.new! TMeta dup2) STConsLabel >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.force-with-label?!, Label StackType -- Maybe([StackType Resource]),
    expand match(
        STACK_TYPE_ERROR -> drop STACK_TYPE_ERROR TYPE_ERROR RESOURCE pack2 Some,
        STACK_TYPE_DONT_CARE -> drop STACK_TYPE_DONT_CARE TYPE_DONT_CARE RESOURCE pack2 Some,
        STACK_TYPE_UNIT -> drop None,
        STVar -> drop2 None,
        STWith -> dip(force-with-label?!) swap map(unpack2 dip(over STWith) pack2) nip,
        STCons -> dip(force-with-label?!) swap map(unpack2 dip(over STCons) pack2) nip,
        STConsLabel ->
            over3 over == if(
                drop4 None,
                dip(dip(force-with-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STWithLabel ->
            over3 over == if(
                drop rotl drop pack2 Some,
                dip(dip(force-with-label?!)) rotl match(
                    Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
                    None -> drop2 None
                )
            ),
        STMeta ->
            dip(dip(MetaVar.new! STMeta MetaVar.new! TMeta RESOURCE dup2) STWithLabel >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.force-cons?!, StackType -- Maybe([StackType Type]),
    expand match(
        STACK_TYPE_ERROR -> STACK_TYPE_ERROR TYPE_ERROR pack2 Some,
        STACK_TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE TYPE_DONT_CARE pack2 Some,
        STACK_TYPE_UNIT -> None,
        STVar -> drop None,
        STCons -> pack2 Some,
        STWith -> swap force-cons?! map(unpack2 dip(over STWith) pack2) nip,
        STConsLabel -> rotl force-cons?! match(
            Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
            None -> drop2 None
        ),
        STWithLabel -> rotl force-cons?! match(
            Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
            None -> drop2 None
        ),
        STMeta ->
            dip(MetaVar.new! STMeta
                MetaVar.new! TMeta
                dup2 STCons >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.force-with?!, StackType -- Maybe([StackType Resource]),
    expand match(
        STACK_TYPE_ERROR -> STACK_TYPE_ERROR TYPE_ERROR RESOURCE pack2 Some,
        STACK_TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE TYPE_DONT_CARE RESOURCE pack2 Some,
        STACK_TYPE_UNIT -> None,
        STVar -> drop None,
        STWith -> pack2 Some,
        STCons -> swap force-with?! map(unpack2 dip(over STCons) pack2) nip,
        STConsLabel -> rotl force-with?! match(
            Some -> unpack2 dip(rotr STConsLabel) pack2 Some,
            None -> drop2 None
        ),
        STWithLabel -> rotl force-with?! match(
            Some -> unpack2 dip(rotr STWithLabel) pack2 Some,
            None -> drop2 None
        ),
        STMeta ->
            dip(MetaVar.new! STMeta
                MetaVar.new! TMeta RESOURCE
                dup2 STWith >Type Some) ~type? !
            pack2 Some,
    ))

def(StackType.dom;, +Str StackType -- +Str,
    expand dup unit? if(drop, stack; " ";))

def(StackType.cod;, +Str StackType -- +Str,
    expand dup unit? if(drop, " "; stack;))

def(StackType.base;, +Str StackType -- +Str Bool,
    match(
        STACK_TYPE_UNIT -> False,
        STMeta -> "*" ; type; True,
        STVar -> dup is-stack? else("* ";) type; True,
        _ -> >Type "* "; type; True
    ))

def(StackType.stack;, +Str StackType -- +Str,
    split4
    dip3(base;)
    dip2(for(swap then(" " ;) unpack2 >Str ; ":" ; for(type;, type;) True))
    dip(for(swap then(" " ;) type; True))
    for(swap then(" " ;) type; True) drop)

def(StackType.semifreshen, StackType StackType -- StackType StackType,
    expand match(
        STACK_TYPE_UNIT -> dup,
        STCons -> dip(semifreshen) STCons,
        STWith -> dip(semifreshen) STWith,
        STConsLabel -> dip2(semifreshen) STConsLabel,
        STWithLabel -> dip2(semifreshen) STWithLabel,
        _ -> "expected unit-based stack in semifreshen!" panic!
    ))

def(StackType.freshen, Subst StackType -- Subst StackType,
    expand match(
        STACK_TYPE_UNIT -> STACK_TYPE_UNIT,
        STCons -> dip(freshen) swap dip(freshen) swap STCons,
        STWith -> dip(freshen) swap dip(freshen) swap STWith,
        STConsLabel -> dip(dip(freshen) swap dip(freshen) swap) STConsLabel,
        STWithLabel -> dip(dip(freshen) swap dip(freshen) swap) STWithLabel,
        _ -> >Type freshen >StackType
    ))

def(StackType.freshen-aux, StackType Subst StackType -- StackType Subst StackType,
    expand match(
        STACK_TYPE_UNIT -> over,
        STCons -> dip(freshen-aux) swap dip(freshen) swap STCons,
        STWith -> dip(freshen-aux) swap dip(freshen) swap STWith,
        STConsLabel -> dip(dip(freshen-aux) swap dip(freshen) swap) STConsLabel,
        STWithLabel -> dip(dip(freshen-aux) swap dip(freshen) swap) STWithLabel,
        _ -> >Type freshen >StackType
    ))

def(StackType.rigidify!, +Mirth Ctx StackType -- +Mirth Ctx StackType,
    STACK_TYPE_ERROR -> STACK_TYPE_ERROR,
    STACK_TYPE_DONT_CARE -> STACK_TYPE_DONT_CARE,
    STACK_TYPE_UNIT -> STACK_TYPE_UNIT,
    STMeta -> expand-or-update!(fresh-stack-type-var! TVar) >StackType rigidify!,
    STVar -> STVar,
    STCons -> dip(rigidify!) swap dip(rigidify!) swap STCons,
    STConsLabel -> dip(dip(rigidify!) swap dip(rigidify!) swap) STConsLabel,
    STWith -> dip(rigidify!) swap dip(rigidify!) swap STWith,
    STWithLabel -> dip(dip(rigidify!) swap dip(rigidify!) swap) STWithLabel)

def(StackType.num-morphisms-on-top, StackType -- Nat,
    STMeta -> expand-if(>StackType num-morphisms-on-top, drop 0 >Nat),
    STCons -> morphism? .if(num-morphisms-on-top 1+, drop 0 >Nat),
    STWith -> drop num-morphisms-on-top,
    STConsLabel -> drop2 num-morphisms-on-top,
    STWithLabel -> drop2 num-morphisms-on-top,
    _ -> drop 0 >Nat)

##############
# Arrow TYPE #
##############

data(ArrowType, ARROW_TYPE -> StackType StackType)
def(ArrowType.>Type, ArrowType -- Type, TMorphism)

def(ArrowType.unpack, ArrowType -- StackType StackType, ARROW_TYPE -> id)
def(ArrowType.dom, ArrowType -- StackType, unpack drop)
def(ArrowType.cod, ArrowType -- StackType, unpack nip)
def(ArrowType.unify!, +Mirth +Gamma ArrowType ArrowType -- +Mirth +Gamma ArrowType,
    dip(unpack) unpack
    dip(swap dip(unify!)) rotl
    dip(unify!) swap
    ARROW_TYPE)
def(ArrowType.unify-error!, +Mirth +Gamma ArrowType -- +Mirth +Gamma ArrowType,
    unpack dip(unify-error!) dip'(unify-error!) ARROW_TYPE)
def(ArrowType.has-meta?, MetaVar ArrowType -- Bool,
    unpack dip(over) has-meta? if(drop2 True, has-meta?))

def(ArrowType.sig;, +Str ArrowType -- +Str,
    unpack swap dom; "--"; cod;)

||| Replace the stack rest with a metavar, if they're both unit.
def(ArrowType.semifreshen-sig, ArrowType -- ArrowType,
    dup needs-fresh-stack-rest? then(semifreshen-aux))

def(ArrowType.semifreshen-aux, ArrowType -- ArrowType,
    MetaVar.new! STMeta swap unpack
    dip(semifreshen) swap
    dip(semifreshen) swap
    ARROW_TYPE nip)

def(ArrowType.needs-fresh-stack-rest?, ArrowType -- Bool,
    unpack base unit? if(
        base unit?,
        drop False
    ))

def(ArrowType.freshen-sig, Subst ArrowType -- Subst ArrowType,
    dup needs-fresh-stack-rest? if(
        freshen-sig-aux,
        freshen
    ))

def(ArrowType.freshen-sig-aux, Subst ArrowType -- Subst ArrowType,
    MetaVar.new! STMeta rotr unpack
    dip(freshen-aux) swap
    dip(freshen-aux) swap
    ARROW_TYPE dip(nip))

def(ArrowType.freshen, Subst ArrowType -- Subst ArrowType,
    unpack
    dip(freshen) swap
    dip(freshen) swap
    ARROW_TYPE)

def(ArrowType.rigidify!, +Mirth Ctx ArrowType -- +Mirth Ctx ArrowType,
    unpack
    dip(rigidify!) swap
    dip(rigidify!) swap
    ARROW_TYPE)

def(ArrowType.rigidify-sig!, +Mirth Ctx ArrowType -- +Mirth Ctx ArrowType,
    rigidify!)
    # TODO check if both stack bases are the same metavar,
    # and that this metavar appears nowhere else in the sig,
    # and if so, unify that metavar with STACK_TYPE_UNIT.
    #   https://github.com/mirth-lang/mirth/issues/239

def(ArrowType.max-num-params, ArrowType -- Nat,
    dom num-morphisms-on-top)

#########
# Subst #
#########

# mirth/data/type
data(Subst,
    SUBST_NIL,
    SUBST_CON -> Subst Type Var)

def(Subst.nil?, Subst -- Bool, SUBST_NIL -> True, _ -> drop False)
def(Subst.con?, Subst -- Maybe([Subst Type Var]),
    SUBST_CON -> pack3 Some,
    _ -> drop None)

def(Subst.nil, Subst, SUBST_NIL)
def(Subst.cons, Type Var Subst -- Subst, rotr SUBST_CON)
def(Subst.has-var?, Var Subst -- Bool,
    SUBST_NIL -> drop False,
    SUBST_CON -> nip over2 == if(drop2 True, has-var?))
def(Subst.get-var, Var Subst -- Type,
    SUBST_NIL -> drop TYPE_ERROR,
    SUBST_CON -> over3 == if(dip(drop2), drop get-var))

||| If variable is in subst, unify new type with type in subst.
||| Otherwise, create larger subst with new binding.
def(Subst.match-var, +Mirth +Gamma Type Var Subst -- +Mirth +Gamma Subst,
    dup2 has-var? if(
        sip(get-var unify! drop),
        cons
    ))
