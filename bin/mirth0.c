#define MIRTH_DEBUG 0
/* MIRTH HEADER */
// #line 3 "src/mirth/mirth.h"

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#define MIRTH_WINDOWS 1
#elif defined(__linux__)
#define MIRTH_LINUX 1
#elif defined(__APPLE__)
#define MIRTH_MACOS 1
#else
#error "Platform not supported."
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

extern void* malloc(size_t);
extern void* calloc(size_t, size_t);
extern void* realloc(void*, size_t);
extern void* memset(void*, int, size_t);
extern void* memcpy(void*, const void*, size_t);
extern int memcmp(const void*, const void*, size_t);
extern int strcmp(const char*, const char*);
extern size_t strlen(const char*);
extern void free(void*);
extern int read(int, void*, size_t);
extern int write(int, const char*, size_t);
extern int close(int);
extern int open(const char*, int, int);
extern void exit(int);

typedef uint16_t TAG;
#define REFS_FLAG 	 0x8000
#define TUP_FLAG 	 0x4000
#define TUP_LEN_MASK 0x3FFF
#define TUP_LEN_MAX  0x3FFF

#define TAG_INT 1
#define TAG_PTR 1
#define TAG_STR (2 | REFS_FLAG)
#define TAG_FNPTR 3
#define TAG_TUP_NIL TUP_FLAG
#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)
#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (n))

typedef uint32_t REFS;
typedef uint64_t USIZE;
typedef void (*FNPTR)(void);

typedef union DATA {
	USIZE usize;
	uint64_t u64;
	uint32_t u32;
	uint16_t u16;
	uint8_t u8;
	int64_t i64;
	int32_t i32;
	int16_t i16;
	int8_t i8;
	void* ptr;
	FNPTR fnptr;
	REFS* refs;
	struct TUP* tup;
	struct STR* str;
} DATA;

typedef struct VAL {
	DATA data;
	TAG tag;
} VAL;

#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))

#define VREFS(v)  (*(v).data.refs)
#define VINT(v)   ((v).data.i64)
#define VI64(v)   ((v).data.i64)
#define VU64(v)   ((v).data.u64)
#define VPTR(v)   ((v).data.ptr)
#define VFNPTR(v) ((v).data.fnptr)
#define VSTR(v)   ((v).data.str)
#define VTUP(v)   ((v).data.tup)
#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))

#define HAS_REFS(v) ((v).tag & REFS_FLAG)
#define IS_INT(v)   ((v).tag == TAG_INT)
#define IS_U64(v)   ((v).tag == TAG_INT)
#define IS_I64(v)   ((v).tag == TAG_INT)
#define IS_PTR(v)   ((v).tag == TAG_PTR)
#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)
#define IS_STR(v)   ((v).tag == TAG_STR)
#define IS_TUP(v)   ((v).tag & TUP_FLAG)
#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))

#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})
#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})
#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})
#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})
#define MKNIL_C	         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}
#define MKNIL      ((VAL)MKNIL_C)

typedef uint16_t TUPLEN;
typedef struct TUP {
	REFS refs;
	TUPLEN cap;
	TUPLEN size;
	VAL cells[];
} TUP;

typedef struct STR {
	REFS refs;
	USIZE cap;
	USIZE size;
	char data[];
} STR;

#define STACK_MAX 0x80000
static USIZE stack_counter = STACK_MAX;
static VAL stack [STACK_MAX] = {0};
static USIZE rstack_counter = STACK_MAX;
static VAL rstack [STACK_MAX] = {0};

static int global_argc;
static char** global_argv;

static void push_value(VAL v);
static void mp_prim_debug(void);
static void mp_prim_rdebug(void);

#if MIRTH_DEBUG
	typedef struct LOC {
		FNPTR fnptr;
		const char* word;
		const char* path;
		USIZE line, col;
		const char* atom;
	} LOC;
	static USIZE fstack_counter = 0;
	static LOC fstack [STACK_MAX] = {
		{
			.fnptr=(void(*)(void))0,
			.word="<word>",
			.path="<path>",
			.line=0, .col=0,
			.atom="<atom>"
		},
	};

	#define WORD_ENTER(_f,_w,_p,_l,_c) \
		do { \
			fstack[fstack_counter].fnptr = (_f); \
			fstack[fstack_counter].word = (_w); \
			fstack[fstack_counter].path = (_p); \
			fstack[fstack_counter].line = (_l); \
			fstack[fstack_counter].col = (_c); \
			fstack[fstack_counter].atom = ""; \
			fstack_counter++; \
		} while(0)

	#define WORD_ATOM(_l,_c,_n) \
		do { \
			if (fstack_counter > 0) { \
				fstack[fstack_counter-1].line = (_l); \
				fstack[fstack_counter-1].col = (_c); \
				fstack[fstack_counter-1].atom = (_n); \
			} \
		} while(0)

	#define WORD_EXIT(_f) \
		do { \
			if ((fstack_counter == 0) || (fstack[fstack_counter-1].fnptr != (_f))) { \
				TRACE("mismatched WORD_EXIT, expected " #_f "\n"); \
				exit(1); \
			} \
			fstack_counter--; \
		} while(0)
	#define PRIM_ENTER(_f,_w) WORD_ENTER(_f,_w,__FILE__,__LINE__,1)
	#define PRIM_EXIT(_f) WORD_EXIT(_f)
#else
	#define PRIM_ENTER(_f,_w)
	#define PRIM_EXIT(_f)
#endif

#define TRACE(x) write(2,x,strlen(x))
#define _STR(x) #x
#define STR(x) _STR(x)

#define EXPECT(test,msg) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			mp_prim_debug(); \
			mp_prim_rdebug(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT1(test,msg,v1) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			mp_prim_debug(); \
			mp_prim_rdebug(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT2(test,msg,v1,v2) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			push_value(v2); \
			mp_prim_debug(); \
			mp_prim_rdebug(); \
			exit(1); \
		} \
	} while(0)

#define ASSERT(test) \
	EXPECT(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")")
#define ASSERT1(test,v) \
	EXPECT1(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v)
#define ASSERT2(test,v1,v2) \
	EXPECT2(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v1, v2)

#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)
#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)
static void free_value(VAL v) {
	ASSERT(HAS_REFS(v));
	ASSERT(VREFS(v) == 0);
	ASSERT1(IS_TUP(v)||IS_STR(v), v);
	if (IS_TUP(v)) {
		TUP* tup = VTUP(v);
		ASSERT(tup);
		for (TUPLEN i = 0; i < tup->size; i++) {
			decref(tup->cells[i]);
		}
		free(tup);
	} else if (IS_STR(v)) {
		STR* str = VSTR(v);
		ASSERT(str);
		free(str);
	}
}

static void value_uncons(VAL val, VAL* tail, VAL* head) {
	if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		ASSERT1((len > 0) && tup, val);
		VAL tailval = MKTUP(tup, len-1);
		VAL headval = tup->cells[len-1];
		if (len == 1) {
			incref(headval);
			decref(val);
			tailval = MKNIL;
		} else {
			if (tup->refs == 1) {
				for (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }
				memset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));
				tup->size = len-1;
			} else {
				incref(headval);
			}
			if (len == 2) {
				VAL ptval = tup->cells[0];
				if (!IS_TUP(ptval)) {
					incref(ptval);
					decref(tailval);
					tailval = ptval;
				}
			}
		}
		*tail = tailval;
		*head = headval;
	} else {
		*tail = MKNIL;
		*head = val;
	}
}

static uint64_t value_u64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VU64(v);
}

static int64_t value_i64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VI64(v);
}

static void* value_ptr (VAL v) {
	ASSERT1(IS_PTR(v),v);
	return VPTR(v);
}

static FNPTR value_fnptr (VAL v) {
	ASSERT1(IS_FNPTR(v),v);
	return VFNPTR(v);
}

#define pop_u8() ((uint8_t)pop_u64())
#define pop_u16() ((uint16_t)pop_u64())
#define pop_u32() ((uint32_t)pop_u64())
#define pop_u64() (value_u64(pop_value()))
#define pop_i8() ((int8_t)pop_i64())
#define pop_i16() ((int16_t)pop_i64())
#define pop_i32() ((int32_t)pop_i64())
#define pop_i64() (value_i64(pop_value()))
#define pop_usize() (pop_u64())
#define pop_bool() (pop_u64())
#define pop_ptr() (value_ptr(pop_value()))
#define pop_fnptr() (value_fnptr(pop_value()))

#define push_u64(v) push_value(MKU64(v))
#define push_i64(v) push_value(MKI64(v))
#define push_usize(v) push_u64((uint64_t)(v))
#define push_bool(b) push_u64((uint64_t)((bool)(b)))
#define push_u8(b) push_u64((uint64_t)(b))
#define push_u16(b) push_u64((uint64_t)(b))
#define push_u32(b) push_u64((uint64_t)(b))
#define push_i8(b) push_i64((int64_t)(b))
#define push_i16(b) push_i64((int64_t)(b))
#define push_i32(b) push_i64((int64_t)(b))
#define push_ptr(p) push_value(MKPTR(p))
#define push_fnptr(p) push_value(MKFNPTR(p))

static void push_value(VAL x) {
	ASSERT(stack_counter > 0);
	stack[--stack_counter] = x;
}

static VAL top_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter];
}

static VAL pop_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter++];
}

static void push_resource(VAL x) {
	ASSERT(rstack_counter > 0);
	rstack[--rstack_counter] = x;
}

static VAL top_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter];
}

static VAL pop_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter++];
}

// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.
static TUP* tup_new (TUPLEN cap_hint) {
	if (cap_hint < 3) cap_hint = 3;
	if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
	TUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
	ASSERT(new_tup);
	new_tup->refs = 1;
	new_tup->cap = cap_hint;
	return new_tup;
}

// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.
// Consume old_tup and copy its elements over to the new tuple.
static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {
	ASSERT(old_tup);
	if (cap_hint < old_tup->size) cap_hint = old_tup->size;
	if (old_tup->refs == 1) {
		if (cap_hint < 3) cap_hint = 3;
		if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
		TUPLEN old_cap = old_tup->cap;
		TUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
		ASSERT(new_tup);
		if (old_cap < cap_hint) {
			memset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));
		}
		new_tup->cap = cap_hint;
		return new_tup;
	} else {
		TUP* new_tup = tup_new(cap_hint);
		for (TUPLEN i = 0; i < old_tup->size; i++) {
			VAL v = old_tup->cells[i];
			new_tup->cells[i] = v;
			incref(v);
		}
		new_tup->size = old_tup->size;
		old_tup->refs--;
		return new_tup;
	}
}

static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {
	if (IS_TUP(tail) && HAS_REFS(tail)) {
		TUPLEN tail_len = VTUPLEN(tail);
		TUP *tail_tup = VTUP(tail);
		ASSERT1(tail_tup, tail);
		ASSERT1(tail_len <= tail_tup->size, tail);
		if (tail_len < tail_tup->size) {
			ASSERT1(tail_tup->refs >= 1, tail);
			if (tail_tup->refs == 1) {
				decref(tail_tup->cells[tail_len]);
				tail_tup->cells[tail_len] = head;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				VAL *cmp = &tail_tup->cells[tail_len];
				if (VALEQ(*cmp, head)) {
					decref(head);
					return MKTUP(tail_tup, tail_len+1);
				} else {
					if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
					TUP* new_tup = tup_new(cap_hint);
					for (TUPLEN i = 0; i < tail_len; i++) {
						VAL v = tail_tup->cells[i];
						new_tup->cells[i] = v;
						incref(v);
					}
					new_tup->cells[tail_len] = head;
					new_tup->size = tail_len+1;
					tail_tup->refs--;
					return MKTUP(new_tup, tail_len+1);
				}
			}
		} else {
			ASSERT1(tail_len < TUP_LEN_MAX, tail);
			ASSERT1(tail_len <= tail_tup->cap, tail);
			if (tail_len < tail_tup->cap) {
				tail_tup->cells[tail_len] = head;
				tail_tup->size = tail_len+1;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
				TUP* new_tup = tup_resize(tail_tup, cap_hint);
				ASSERT(tail_len < new_tup->cap);
				new_tup->size = tail_len+1;
				new_tup->cells[tail_len] = head;
				return MKTUP(new_tup, tail_len+1);
			}
		}
	} else if (IS_TUP(tail)) { // cons onto nil
		ASSERT(IS_NIL(tail));
		if (IS_TUP(head)) {
			TUP* tup = tup_new(cap_hint);
			tup->size = 1;
			tup->cells[0] = head;
			return MKTUP(tup,1);
		} else { // non-tup value pretends to be unary tuple
			return head;
		}
	} else { // cons onto non-tup value pretending to be unary tuple
		TUP* tup = tup_new(cap_hint);
		tup->size = 2;
		tup->cells[0] = tail;
		tup->cells[1] = head;
		return MKTUP(tup,2);
	}
}
static VAL mkcons(VAL tail, VAL head) {
	VAL v = mkcons_hint(tail,head,3);
	return v;
}

static VAL lpop(VAL* stk) {
	VAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);
	*stk=lcar; return lcdr;
}
static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }
#define LPOP(v) push_value(lpop(&(v)))
#define LPUSH(v) lpush(&(v),pop_value())

static STR* str_alloc (USIZE cap) {
	ASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));
	EXPECT(str, "failed to allocate string");
	str->refs = 1;
	str->cap = cap;
	return str;
}

static VAL mkstr (const char* data, USIZE size) {
	ASSERT(data);
	ASSERT(size <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = str_alloc(size);
	str->size = size;
	memcpy(str->data, data, (size_t)size);
	return MKSTR(str);
}

static void do_uncons(void) {
	VAL val, tail, head;
	val = pop_value();
	value_uncons(val, &tail, &head);
	push_value(tail);
	push_value(head);
}

static USIZE get_data_tag(VAL v) {
	if (IS_TUP(v)) {
		ASSERT(VTUPLEN(v) > 0);
		return VU64(VTUP(v)->cells[0]);
	} else {
		return VU64(v);
	}
}

static USIZE get_top_data_tag(void) {
	return get_data_tag(top_value());
}

static USIZE get_top_resource_data_tag(void) {
	return get_data_tag(top_resource());
}

static int str_cmp_(STR* s1, STR* s2) {
	ASSERT(s1 && s2);
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	USIZE n = (n1 < n2 ? n1 : n2);
	ASSERT(n < SIZE_MAX);
	int r = memcmp(s1->data, s2->data, (size_t)n);
	if (r) return r;
	if (n1 < n2) return -1;
	if (n1 > n2) return 1;
	return 0;
}

static void run_value(VAL v) {
	if (IS_TUP(v)) {
		VAL h = VTUP(v)->cells[0];
		ASSERT(IS_FNPTR(h));
		push_value(v);
		VFNPTR(h)();
	} else {
		ASSERT(IS_FNPTR(v));
		VFNPTR(v)();
	}
}

static void mp_prim_id (void) {}
static void mp_prim_dup (void) {
	PRIM_ENTER(mp_prim_dup,"prim-dup");
	VAL v = top_value();
	push_value(v);
	incref(v);
	PRIM_EXIT(mp_prim_dup);
}
static void mp_prim_drop (void) {
	PRIM_ENTER(mp_prim_drop,"prim-drop");
	VAL v = pop_value();
	decref(v);
	PRIM_EXIT(mp_prim_drop);
}

static void mp_prim_swap (void) {
	PRIM_ENTER(mp_prim_swap,"prim-swap");
	VAL a = pop_value();
	VAL b = pop_value();
	push_value(a);
	push_value(b);
	PRIM_EXIT(mp_prim_swap);
}

static void mp_prim_rswap (void) {
	PRIM_ENTER(mp_prim_rswap,"prim-rswap");
	VAL a = pop_resource();
	VAL b = pop_resource();
	push_resource(a);
	push_resource(b);
	PRIM_EXIT(mp_prim_rswap);
}

static void mp_prim_int_add (void) {
	PRIM_ENTER(mp_prim_int_add,"prim-int-add");
	// TODO promote to bigint on overflow.
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	if (b >= 0) {
		EXPECT(a <= INT64_MAX - b, "integer overflow during addition (too positive)");
	} else {
		EXPECT(a >= INT64_MIN - b, "integer overflow during addition (too negative)");
	}
	push_i64(a + b);
	PRIM_EXIT(mp_prim_int_add);
}
static void mp_prim_int_sub (void) {
	PRIM_ENTER(mp_prim_int_sub,"prim-int-sub");
	// TODO promote to bigint on overflow
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	if (b >= 0) {
		EXPECT(a >= INT64_MIN + b, "integer overflow during subtraction (too negative)");
	} else {
		EXPECT(a <= INT64_MAX + b, "integer overflow during subtraction (too positive)");
	}
	push_i64(a - b);
	PRIM_EXIT(mp_prim_int_sub);
}
static void mp_prim_int_mul (void) {
	PRIM_ENTER(mp_prim_int_mul,"prim-int-mul");
	// TODO promote to bigint on overflow
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	// overflow checks for multiplication
	push_i64(a * b);
	PRIM_EXIT(mp_prim_int_mul);
}
static void mp_prim_int_div (void) {
	PRIM_ENTER(mp_prim_int_div,"prim-int-div");
	// TODO promote to bigint on overflow
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	EXPECT(b != 0, "divide by zero");
	EXPECT(!((b == -1) && (a == INT64_MIN)), "overflow during division");
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) q--;
	push_i64(q);
	PRIM_EXIT(mp_prim_int_div);
}
static void mp_prim_int_mod (void) {
	PRIM_ENTER(mp_prim_int_mod,"prim-int-mod");
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	EXPECT(b != 0, "divide by zero");
	if (b == -1) { push_i64(0); return; }
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) r += b;
	push_i64(r);
	PRIM_EXIT(mp_prim_int_mod);
}

static void mp_prim_int_and (void) {
	PRIM_ENTER(mp_prim_int_and,"prim-int-and");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64(a & b);
	PRIM_EXIT(mp_prim_int_and);
}
static void mp_prim_int_or (void) {
	PRIM_ENTER(mp_prim_int_or,"prim-int-or");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64(a | b);
	PRIM_EXIT(mp_prim_int_or);
}
static void mp_prim_int_xor (void) {
	PRIM_ENTER(mp_prim_int_xor,"prim-int-xor");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64(a ^ b);
	PRIM_EXIT(mp_prim_int_xor);
}
static void mp_prim_int_shl (void) {
	PRIM_ENTER(mp_prim_int_shl,"prim-int-shl");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64((b >= 64) ? 0 : (a << b));
	PRIM_EXIT(mp_prim_int_shl);
}
static void mp_prim_int_shr (void) {
	PRIM_ENTER(mp_prim_int_shr,"prim-int-shr");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64((b >= 64) ? 0 : (a >> b));
	PRIM_EXIT(mp_prim_int_shr);
}

static void mp_prim_int_eq (void) {
	PRIM_ENTER(mp_prim_int_eq,"prim-int-eq");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT1(IS_INT(a), a);
	ASSERT1(IS_INT(b), a);
	push_bool(VINT(a) == VINT(b));
	PRIM_EXIT(mp_prim_int_eq);
}
static void mp_prim_int_lt (void) {
	PRIM_ENTER(mp_prim_int_lt,"prim-int-lt");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT2(IS_INT(a) && IS_INT(b), a, b);
	push_bool(VINT(a) < VINT(b));
	PRIM_EXIT(mp_prim_int_lt);
}
static void mp_prim_str_cmp (void) {
	PRIM_ENTER(mp_prim_str_cmp,"prim-str-cmp");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT2(IS_STR(a) && IS_STR(b), a, b);
	int64_t cmp = str_cmp_(VSTR(a), VSTR(b));
	push_i64(cmp);
	decref(a); decref(b);
	PRIM_EXIT(mp_prim_str_cmp);
}

static void mp_prim_sys_argc (void) {
	PRIM_ENTER(mp_prim_sys_argc,"prim-sys-argc");
	push_i64(global_argc);
	PRIM_EXIT(mp_prim_sys_argc);
}
static void mp_prim_sys_argv (void) {
	PRIM_ENTER(mp_prim_sys_argv,"prim-sys-argv");
	push_ptr(global_argv);
	PRIM_EXIT(mp_prim_sys_argv);
}

static void mp_prim_posix_write (void) {
	PRIM_ENTER(mp_prim_posix_write,"prim-posix-write");
	USIZE n = pop_usize();
	VAL vp = pop_value();
	void* p = value_ptr(vp);
	int fd = (int)pop_i64();
	ASSERT(n <= SIZE_MAX);
	push_i64((int64_t)write(fd, p, (size_t)n));
	decref(vp);
	PRIM_EXIT(mp_prim_posix_write);
}
static void mp_prim_posix_read (void) {
	PRIM_ENTER(mp_prim_posix_read,"prim-posix-read");
	USIZE n = pop_usize();
	VAL vp = pop_value();
	void* p = value_ptr(vp);
	int fd = (int)pop_i64();
	ASSERT(n <= SIZE_MAX);
	push_i64((int64_t)read(fd, p, (size_t)n));
	decref(vp);
	PRIM_EXIT(mp_prim_posix_read);
}
static void mp_prim_posix_open (void) {
	PRIM_ENTER(mp_prim_posix_open,"prim-posix-open");
	int m = (int)pop_i64();
	int f = (int)pop_i64();
	VAL vp = pop_value();
	void* path = value_ptr(vp);
	push_i64((int64_t)open(path,f,m));
	decref(vp);
	PRIM_EXIT(mp_prim_posix_open);
}
static void mp_prim_posix_close (void) {
	PRIM_ENTER(mp_prim_posix_close,"prim-posix-close");
	int fd = (int)pop_i64();
	push_i64((int64_t)close(fd));
	PRIM_EXIT(mp_prim_posix_close);
}
static void mp_prim_posix_exit (void) {
	PRIM_ENTER(mp_prim_posix_exit,"prim-posix-exit");
	int x = (int)pop_i64();
	exit(x);
	PRIM_EXIT(mp_prim_posix_exit);
}

void int_repr(int64_t y, char** out_ptr, size_t *out_size) {
	static char c[32] = {0};
	memset(c, 0, 32);
	char* p = c+30;
	size_t n = 0;
	uint64_t x;
	if (y < 0) {
		if (y == INT64_MIN) {
			x = 1+(uint64_t)INT64_MAX;
		} else {
			x = (uint64_t)-y;
		}
	} else {
		x = (uint64_t)y;
	}
	do {
		*--p = '0' + (x % 10);
		x /= 10;
		n++;
	} while (x);
	if (y < 0) {
		*--p = '-';
		n++;
	}
	*out_ptr = p;
	*out_size = n;
}

void int_trace_(int64_t y, int fd) {
	char* p; size_t n;
	int_repr(y, &p, &n);
	write(fd, p, n);
}

void mp_prim_int_to_str(void) {
	PRIM_ENTER(mp_prim_int_to_str,"prim-int-to-str");
	int64_t x = pop_i64();
	bool cache = (0 <= x) && (x <= 255);
	static VAL scache[256] = {0};
	if (cache && scache[x].tag) {
		incref(scache[x]);
		push_value(scache[x]);
	} else {
		char* p; size_t n;
		int_repr(x,&p,&n);
		VAL out = mkstr(p,n);
		push_value(out);
		if (cache) {
			scache[x] = out;
			incref(out);
		}
	}
	PRIM_EXIT(mp_prim_int_to_str);
}

void str_trace_(STR* str, int fd) {
	ASSERT(str->size <= SIZE_MAX);
	write(fd, "\"", 1);
	write(fd, str->data, (size_t)str->size); // TODO handle escapes
	write(fd, "\"", 1);
}

void value_trace_(VAL val, int fd) {
	if (IS_INT(val)) {
		int_trace_(VINT(val), fd);
	} else if (IS_STR(val)) {
		str_trace_(VSTR(val), fd);
	} else if (IS_FNPTR(val)) {
		write(fd, "<fnptr>", 7);
	} else if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		if (VTUPLEN(val) == 0) {
			write(fd, "[]", 2);
		} else {
			write(fd, "[ ", 2);
			for(TUPLEN i = 0; i < len; i++) {
				if (i > 0) write(fd, " ", 1);
				value_trace_(tup->cells[i], fd);
			}
			write(fd, " ]", 2);
		}
	} else {
		TRACE("value cannot be traced");
		exit(1);
	}
}

static void mp_prim_debug (void) {
	TRACE("??");
	for (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {
		TRACE(" ");
		value_trace_(stack[i], 2);
	}
	TRACE("\n");
}

static void mp_prim_rdebug (void) {
	#if MIRTH_DEBUG
		TRACE("call stack:\n");
		for (USIZE i = fstack_counter; i --> 1;) {
			TRACE("    ");
			if (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {
				TRACE(fstack[i-1].atom);
				TRACE(" -> ");
			}
			TRACE(fstack[i].word);
			TRACE(" at ");
			TRACE(fstack[i-1].path);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].line, 2);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].col, 2);
			TRACE("\n");
		}
	#endif
}

static void mp_prim_panic(void) {
	// TODO: expect less of the stack, i.e. panic gracefully even if stack
	// is in a weird state ... this is panic! after all
	VAL v = pop_value();
	ASSERT(IS_STR(v));
	ASSERT(VSTR(v)->size < SIZE_MAX);
	write(2,VSTR(v)->data, (size_t)VSTR(v)->size);
	mp_prim_debug();
	mp_prim_rdebug();
	exit(1);
}

static void mp_prim_ptr_get (void) {
	PRIM_ENTER(mp_prim_ptr_get,"prim-ptr-get");
	VAL vp = pop_value();
	void **p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_ptr(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_ptr_get);
}

static void mp_prim_u8_get (void) {
	PRIM_ENTER(mp_prim_u8_get,"prim-u8-get");
	VAL vp = pop_value();
	uint8_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u8(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_u8_get);
}

static void mp_prim_u16_get (void) {
	PRIM_ENTER(mp_prim_u16_get,"prim-u16-get");
	VAL vp = pop_value();
	uint16_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u16(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_u16_get);
}

static void mp_prim_u32_get (void) {
	PRIM_ENTER(mp_prim_u32_get,"prim-u32-get");
	VAL vp = pop_value();
	uint32_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u32(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_u32_get);
}

static void mp_prim_u64_get (void) {
	PRIM_ENTER(mp_prim_u64_get,"prim-u64-get");
	VAL vp = pop_value();
	uint64_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u64(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_u64_get);
}

static void mp_prim_i8_get (void) {
	PRIM_ENTER(mp_prim_i8_get,"prim-i8-get");
	VAL vp = pop_value();
	int8_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i8(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_i8_get);
}

static void mp_prim_i16_get (void) {
	PRIM_ENTER(mp_prim_i16_get,"prim-i16-get");
	VAL vp = pop_value();
	int16_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i16(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_i16_get);
}

static void mp_prim_i32_get (void) {
	PRIM_ENTER(mp_prim_i32_get,"prim-i32-get");
	VAL vp = pop_value();
	int32_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i32(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_i32_get);
}

static void mp_prim_i64_get (void) {
	PRIM_ENTER(mp_prim_i64_get,"prim-i64-get");
	VAL vp = pop_value();
	int64_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i64(*p);
	decref(vp);
	PRIM_EXIT(mp_prim_i64_get);
}

static void mp_prim_int_set (void) {
	PRIM_ENTER(mp_prim_int_set,"prim-int-set");
	VAL vp = pop_value();
	int64_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i64();
	decref(vp);
	PRIM_EXIT(mp_prim_int_set);
}

static void mp_prim_ptr_set (void) {
	PRIM_ENTER(mp_prim_ptr_set,"prim-ptr-set");
	VAL vp = pop_value();
	void **p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_ptr();
	decref(vp);
	PRIM_EXIT(mp_prim_ptr_set);
}

static void mp_prim_u8_set (void) {
	PRIM_ENTER(mp_prim_u8_set,"prim-u8-set");
	VAL vp = pop_value();
	uint8_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u8();
	decref(vp);
	PRIM_EXIT(mp_prim_u8_set);
}

static void mp_prim_u16_set (void) {
	PRIM_ENTER(mp_prim_u16_set,"prim-u16-set");
	VAL vp = pop_value();
	uint16_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u16();
	decref(vp);
	PRIM_EXIT(mp_prim_u16_set);
}

static void mp_prim_u32_set (void) {
	PRIM_ENTER(mp_prim_u32_set,"prim-u32-set");
	VAL vp = pop_value();
	uint32_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u32();
	decref(vp);
	PRIM_EXIT(mp_prim_u32_set);
}

static void mp_prim_u64_set (void) {
	PRIM_ENTER(mp_prim_u64_set,"prim-u64-set");
	VAL vp = pop_value();
	uint64_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u64();
	decref(vp);
	PRIM_EXIT(mp_prim_u64_set);
}

static void mp_prim_i8_set (void) {
	PRIM_ENTER(mp_prim_i8_set,"prim-i8-set");
	VAL vp = pop_value();
	int8_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i8();
	decref(vp);
	PRIM_EXIT(mp_prim_i8_set);
}

static void mp_prim_i16_set (void) {
	PRIM_ENTER(mp_prim_i16_set,"prim-i16-set");
	VAL vp = pop_value();
	int16_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i16();
	decref(vp);
	PRIM_EXIT(mp_prim_i16_set);
}

static void mp_prim_i32_set (void) {
	PRIM_ENTER(mp_prim_i32_set,"prim-i32-set");
	VAL vp = pop_value();
	int32_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i32();
	decref(vp);
	PRIM_EXIT(mp_prim_i32_set);
}

static void mp_prim_i64_set (void) {
	PRIM_ENTER(mp_prim_i64_set,"prim-i64-set");
	VAL vp = pop_value();
	int64_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i64();
	decref(vp);
	PRIM_EXIT(mp_prim_i64_set);
}


#if defined(MIRTH_WINDOWS)
#define mp_prim_sys_os() push_u64(1)
#elif defined(MIRTH_LINUX)
#define mp_prim_sys_os() push_u64(2)
#elif defined(MIRTH_MACOS)
#define mp_prim_sys_os() push_u64(3)
#else
#define mp_prim_sys_os() push_u64(0)
#endif

static void mp_prim_run (void) {
	PRIM_ENTER(mp_prim_run,"prim-run");
	VAL f = pop_value();
	run_value(f);
	PRIM_EXIT(mp_prim_run);
}

static void mp_prim_ptr_nil (void) {
	PRIM_ENTER(mp_prim_ptr_nil,"prim-ptr-nil");
	push_ptr((void*)0);
	PRIM_EXIT(mp_prim_ptr_nil);
}
static void mp_prim_ptr_eq (void) {
	PRIM_ENTER(mp_prim_ptr_eq,"prim-ptr-eq");
	void* a = pop_ptr();
	void* b = pop_ptr();
	push_bool(a == b);
	PRIM_EXIT(mp_prim_ptr_eq);
}
static void mp_prim_ptr_add (void) {
	PRIM_ENTER(mp_prim_ptr_add,"prim-ptr-add");
	VAL vptr = pop_value();
	USIZE n = pop_usize();
	ASSERT1(IS_PTR(vptr), vptr);
	EXPECT(VPTR(vptr), "attempt to add to null pointer");
	char* ptr = (char*)VPTR(vptr);
	push_ptr(ptr + n);
	PRIM_EXIT(mp_prim_ptr_add);
}
#define mp_prim_ptr_size() push_u64((uint64_t)sizeof(void*))
static void mp_prim_ptr_alloc (void) {
	PRIM_ENTER(mp_prim_ptr_alloc,"prim-ptr-alloc");
	USIZE n = pop_usize();
	void* p = malloc((size_t)n);
	EXPECT(p, "failed to allocate buffer");
	push_ptr(p);
	PRIM_EXIT(mp_prim_ptr_alloc);
}
static void mp_prim_ptr_realloc (void) {
	PRIM_ENTER(mp_prim_ptr_realloc,"prim-ptr-realloc");
	USIZE n = pop_usize();
	void* p0 = pop_ptr();
	void* p1 = realloc(p0, (size_t)n);
	EXPECT(p1, "failed to reallocate buffer");
	push_ptr(p1);
	PRIM_EXIT(mp_prim_ptr_realloc);
}
static void mp_prim_ptr_free (void) {
	PRIM_ENTER(mp_prim_ptr_free,"prim-ptr-free");
	void* p = pop_ptr();
	free(p);
	PRIM_EXIT(mp_prim_ptr_free);
}

static void mp_prim_ptr_copy (void) {
	PRIM_ENTER(mp_prim_ptr_copy,"prim-ptr-copy");
	VAL vdst = pop_value();
	int64_t ilen = pop_i64();
	VAL vsrc = pop_value();
	ASSERT2(IS_PTR(vsrc) && IS_PTR(vdst), vsrc, vdst);
	void* src = value_ptr(vsrc);
	void* dst = value_ptr(vdst);
	if (src && dst && (ilen > 0)) {
		ASSERT((USIZE)ilen <= SIZE_MAX);
		memcpy(dst, src, (size_t)ilen);
	}
	PRIM_EXIT(mp_prim_ptr_copy);
}

static void mp_prim_ptr_fill (void) {
	PRIM_ENTER(mp_prim_ptr_fill,"prim-ptr-fill");
	VAL vdst = pop_value();
	ASSERT1(IS_PTR(vdst), vdst);
	int64_t ilen = pop_i64();
	uint64_t val = pop_u64();
	void* dst = value_ptr(vdst);
	if (dst && (ilen > 0)) {
		ASSERT((USIZE)ilen <= SIZE_MAX);
		memset(dst, (int)val, (size_t)ilen);
	}
	PRIM_EXIT(mp_prim_ptr_fill);
}

static void mp_prim_str_copy (void) {
	PRIM_ENTER(mp_prim_str_copy,"prim-str-copy");
	USIZE size = pop_usize();
	char* ptr = (char*)pop_ptr();
	ASSERT(size <= SIZE_MAX-sizeof(STR)-4);
	ASSERT(ptr);
	push_value(mkstr(ptr, size));
	PRIM_EXIT(mp_prim_str_copy);
}

static void mp_prim_str_cat (void) {
	PRIM_ENTER(mp_prim_str_cat,"prim-str-cat");
	VAL v2 = pop_value();
	VAL v1 = pop_value();
	ASSERT2(IS_STR(v1) && IS_STR(v2), v1, v2);
	STR* s1 = VSTR(v1);
	STR* s2 = VSTR(v2);
	USIZE m = s1->cap;
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	if ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {
		ASSERT(n2 <= SIZE_MAX);
		memcpy(s1->data + n1, s2->data, (size_t)n2);
		s1->size += n2;
		ASSERT(s1->size + 4 <= s1->cap);
		push_value(v1);
		decref(v2);
	} else {
		USIZE m2 = n1 + n2 + 4;
		if ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;
		STR* str = str_alloc(m2);
		str->size = n1+n2;
		ASSERT(n1 <= SIZE_MAX);
		ASSERT(n2 <= SIZE_MAX);
		memcpy(str->data, s1->data, (size_t)n1);
		memcpy(str->data+n1, s2->data, (size_t)n2);
		push_value(MKSTR(str));
		decref(v1);
		decref(v2);
	}
	PRIM_EXIT(mp_prim_str_cat);
}

static void mp_prim_str_base (void) {
	PRIM_ENTER(mp_prim_str_base,"prim-str-base");
	VAL vstr = pop_value();
	ASSERT1(IS_STR(vstr) && VSTR(vstr), vstr);
	push_ptr(VSTR(vstr)->data);
	decref(vstr);
	PRIM_EXIT(mp_prim_str_base);
}

static void mp_prim_str_num_bytes (void) {
	PRIM_ENTER(mp_prim_str_num_bytes,"prim-str-num-bytes");
	VAL v = pop_value();
	ASSERT(IS_STR(v) && VSTR(v));
	push_usize(VSTR(v)->size);
	decref(v);
	PRIM_EXIT(mp_prim_str_num_bytes);
}

static void mp_prim_pack_nil (void) {
	PRIM_ENTER(mp_prim_pack_nil,"prim-pack-nil");
	push_value(MKNIL);
	PRIM_EXIT(mp_prim_pack_nil);
}

static void mp_prim_pack_cons (void) {
	PRIM_ENTER(mp_prim_pack_cons,"prim-pack-cons");
	VAL cdr = pop_value();
	VAL car = pop_value();
	push_value(mkcons(car,cdr));
	PRIM_EXIT(mp_prim_pack_cons);
}

static void mp_prim_pack_uncons (void) {
	PRIM_ENTER(mp_prim_pack_uncons,"prim-pack-uncons");
	do_uncons();
	PRIM_EXIT(mp_prim_pack_uncons);
}

static void mp_prim_mut_get (void) {
	PRIM_ENTER(mp_prim_mut_get,"prim-mut-get");
	VAL mut = pop_value();
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL v = *(VAL*)VPTR(mut);
	EXPECT(v.tag, "tried to read uninitialized value");
	push_value(v);
	incref(v);
	PRIM_EXIT(mp_prim_mut_get);
}
static void mp_prim_mut_set (void) {
	PRIM_ENTER(mp_prim_mut_set,"prim-mut-set");
	VAL mut = pop_value();
	VAL newval = pop_value();
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL oldval = *(VAL*)VPTR(mut);
	*(VAL*)VPTR(mut) = newval;
	if (oldval.tag) {
		decref(oldval);
	}
	decref(mut);
	PRIM_EXIT(mp_prim_mut_set);
}
static void mp_prim_mut_is_set (void) {
	PRIM_ENTER(mp_prim_mut_is_set,"prim-mut-is-set");
	VAL mut = pop_value();
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL val = *(VAL*)VPTR(mut);
	push_bool(val.tag);
	decref(mut);
	PRIM_EXIT(mp_prim_mut_is_set);
}

/* GENERATED C99 */

static VAL lbl_emit_debug_info = MKNIL_C;
static VAL lbl_input_file = MKNIL_C;
static VAL lbl_output_file = MKNIL_C;
static VAL lbl_entry_point = MKNIL_C;
static VAL lbl_packages = MKNIL_C;
static VAL lbl_output_path = MKNIL_C;
static VAL lbl_name = MKNIL_C;
static VAL lbl_flag_type = MKNIL_C;
static VAL lbl_arg_doc = MKNIL_C;
static VAL lbl_doc = MKNIL_C;
static VAL lbl_group = MKNIL_C;
static VAL lbl_options = MKNIL_C;
static VAL lbl_parser = MKNIL_C;
static VAL lbl_args_doc = MKNIL_C;
static VAL lbl_argument_parser = MKNIL_C;
static VAL lbl_state = MKNIL_C;
static VAL lbl_index = MKNIL_C;
static VAL lbl_argv = MKNIL_C;
static VAL lbl_program_name = MKNIL_C;
static VAL lbl_argv_info = MKNIL_C;
static VAL lbl_parsing_3F_ = MKNIL_C;
static VAL lbl_option = MKNIL_C;
static VAL lbl_option_option = MKNIL_C;
static VAL lbl_arg = MKNIL_C;
static VAL lbl_arguments = MKNIL_C;
static VAL lbl_positional_index = MKNIL_C;
static VAL lbl_error = MKNIL_C;
static VAL lbl_namespace = MKNIL_C;
static VAL lbl_arity = MKNIL_C;
static VAL lbl_qname = MKNIL_C;
static VAL lbl_head = MKNIL_C;
static VAL lbl_body = MKNIL_C;
static VAL lbl_sig = MKNIL_C;
static VAL lbl_pattern = MKNIL_C;
static VAL lbl_token = MKNIL_C;
static VAL lbl_ctx = MKNIL_C;
static VAL lbl_cod = MKNIL_C;
static VAL lbl_subst = MKNIL_C;
static VAL lbl_op = MKNIL_C;
static VAL lbl_saved = MKNIL_C;
static VAL lbl_dom = MKNIL_C;
static VAL lbl_home = MKNIL_C;
static VAL lbl_cases = MKNIL_C;
static VAL lbl_token_start = MKNIL_C;
static VAL lbl_token_end = MKNIL_C;
static VAL lbl_outer_ctx = MKNIL_C;
static VAL lbl_inner_ctx = MKNIL_C;
static VAL lbl_mid = MKNIL_C;
static VAL lbl_atoms = MKNIL_C;
static VAL lbl_args = MKNIL_C;
static VAL lbl_params = MKNIL_C;
static VAL lbl_lexer_module = MKNIL_C;
static VAL lbl_lexer_row = MKNIL_C;
static VAL lbl_lexer_col = MKNIL_C;
static VAL lbl_lexer_stack = MKNIL_C;
static VAL lbl_lexer_last_token = MKNIL_C;
static VAL lbl_arrow = MKNIL_C;
static VAL lbl_template = MKNIL_C;
static VAL lbl_tok = MKNIL_C;
static VAL lbl_f = MKNIL_C;
static VAL lbl_contents = MKNIL_C;
static VAL lbl_checklist = MKNIL_C;
static VAL lbl_key = MKNIL_C;
static VAL lbl_value = MKNIL_C;
static VAL lbl_gamma = MKNIL_C;
static VAL lbl_spword = MKNIL_C;
static VAL lbl_spkey = MKNIL_C;
static VAL lbl_spmap = MKNIL_C;
static void mtw_L1_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_L1_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_L2_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(2LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_L2_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_L3_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(3LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_L3_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LCAT_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(4LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_LCAT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_L1_2B__1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_L1_2B__1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_L2_2B__1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_L2_2B__1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_L3_2B__1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(2LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_L3_2B__1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LCAT_2B__1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(3LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_LCAT_2B__1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_LIST_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 2));
}
static void mtp__2B_LIST_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_SOME_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_SOME_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_BUFFER_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 3));
}
static void mtp__2B_BUFFER_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_STR_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 2));
}
static void mtp__2B_STR_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LEFT_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_LEFT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_RIGHT_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_RIGHT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_ARGV_5F_INFO_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_program_name);
	tup->cells[1] = lpop(&lbl_argv);
	push_value(MKTUP(tup, 3));
}
static void mtw_CURRENT_5F_ARG_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_option_option);
	tup->cells[2] = lpop(&lbl_option);
	tup->cells[1] = lpop(&lbl_parsing_3F_);
	push_value(MKTUP(tup, 4));
}
static void mtw_STATE_1 (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_error);
	tup->cells[4] = lpop(&lbl_positional_index);
	tup->cells[3] = lpop(&lbl_arg);
	tup->cells[2] = lpop(&lbl_argv_info);
	tup->cells[1] = lpop(&lbl_arguments);
	push_value(MKTUP(tup, 6));
}
static void mtw_ArgumentParser_2 (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = lpop(&lbl_doc);
	tup->cells[3] = lpop(&lbl_args_doc);
	tup->cells[2] = lpop(&lbl_parser);
	tup->cells[1] = lpop(&lbl_options);
	push_value(MKTUP(tup, 5));
}
static void mtw__2B_ARGUMENTPARSER_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_state);
	tup->cells[1] = lpop(&lbl_argument_parser);
	push_resource(MKTUP(tup, 3));
}
static void mtp__2B_ARGUMENTPARSER_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_argument_parser, tup->cells[1]);
	lpush(&lbl_state, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_SHORT_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_SHORT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LONG_5F_ONLY_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_LONG_5F_ONLY_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_ArgpOption_2 (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_group);
	tup->cells[4] = lpop(&lbl_doc);
	tup->cells[3] = lpop(&lbl_arg_doc);
	tup->cells[2] = lpop(&lbl_flag_type);
	tup->cells[1] = lpop(&lbl_name);
	push_value(MKTUP(tup, 6));
}
static void mtw_MISSING_5F_ARG_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_MISSING_5F_ARG_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_INPUTOPEN_1 (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = pop_resource();
	tup->cells[3] = pop_resource();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 5));
}
static void mtp__2B_INPUTOPEN_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_resource(tup->cells[3]);
	push_resource(tup->cells[4]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_INPUT_5F_OPEN_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp__2B_INPUT_5F_OPEN_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_INPUT_5F_DONE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp__2B_INPUT_5F_DONE_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_FILE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 2));
}
static void mtp__2B_FILE_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LAZY_5F_READY_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_LAZY_5F_READY_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LAZY_5F_DELAY_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_LAZY_5F_DELAY_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LOCATION_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_LOCATION_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TYCON_5F_DATA_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TYCON_5F_DATA_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TYCON_5F_TABLE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TYCON_5F_TABLE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TYCON_5F_PRIM_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TYCON_5F_PRIM_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_MATCH_1 (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_cases);
	tup->cells[6] = lpop(&lbl_cod);
	tup->cells[5] = lpop(&lbl_dom);
	tup->cells[4] = lpop(&lbl_ctx);
	tup->cells[3] = lpop(&lbl_body);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 8));
}
static void mtp_MATCH_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_home, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_body, tup->cells[3]);
	lpush(&lbl_ctx, tup->cells[4]);
	lpush(&lbl_dom, tup->cells[5]);
	lpush(&lbl_cod, tup->cells[6]);
	lpush(&lbl_cases, tup->cells[7]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_MATCH_1 (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_cases);
	tup->cells[6] = lpop(&lbl_cod);
	tup->cells[5] = lpop(&lbl_dom);
	tup->cells[4] = lpop(&lbl_ctx);
	tup->cells[3] = lpop(&lbl_body);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_home);
	push_resource(MKTUP(tup, 8));
}
static void mtp__2B_MATCH_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_home, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_body, tup->cells[3]);
	lpush(&lbl_ctx, tup->cells[4]);
	lpush(&lbl_dom, tup->cells[5]);
	lpush(&lbl_cod, tup->cells[6]);
	lpush(&lbl_cases, tup->cells[7]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_CASE_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_body);
	tup->cells[1] = lpop(&lbl_pattern);
	push_value(MKTUP(tup, 3));
}
static void mtw_PATTERN_1 (void) {
	TUP* tup = tup_new(10);
	tup->size = 10;
	tup->cells[0] = MKU64(0LL);
	tup->cells[9] = lpop(&lbl_atoms);
	tup->cells[8] = lpop(&lbl_cod);
	tup->cells[7] = lpop(&lbl_mid);
	tup->cells[6] = lpop(&lbl_saved);
	tup->cells[5] = lpop(&lbl_inner_ctx);
	tup->cells[4] = lpop(&lbl_outer_ctx);
	tup->cells[3] = lpop(&lbl_token_end);
	tup->cells[2] = lpop(&lbl_token_start);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 10));
}
static void mtw__2B_PATTERN_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = lpop(&lbl_pattern);
	push_resource(MKTUP(tup, 2));
}
static void mtp__2B_PATTERN_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_pattern, tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_PATATOM_1 (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_op);
	tup->cells[6] = lpop(&lbl_subst);
	tup->cells[5] = lpop(&lbl_cod);
	tup->cells[4] = lpop(&lbl_dom);
	tup->cells[3] = lpop(&lbl_saved);
	tup->cells[2] = lpop(&lbl_ctx);
	tup->cells[1] = lpop(&lbl_token);
	push_value(MKTUP(tup, 8));
}
static void mtw_PATOP_5F_TAG_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_PATOP_5F_TAG_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_PRIM_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_PRIM_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_WORD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_WORD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_EXTERNAL_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_EXTERNAL_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_BUFFER_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_BUFFER_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_VARIABLE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_VARIABLE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_FIELD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_FIELD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_INT_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_INT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_STR_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_STR_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_TAG_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_TAG_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_MATCH_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_MATCH_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_LAMBDA_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_LAMBDA_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_VAR_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_VAR_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_BLOCK_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(13LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_BLOCK_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_RUN_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(14LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_RUN_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_COERCE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(15LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_COERCE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_LABEL_5F_PUSH_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(16LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_LABEL_5F_PUSH_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_LABEL_5F_POP_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(17LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OP_5F_LABEL_5F_POP_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_DATA_5F_GET_5F_LABEL_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(18LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_OP_5F_DATA_5F_GET_5F_LABEL_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OP_5F_DATA_5F_SET_5F_LABEL_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(19LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_OP_5F_DATA_5F_SET_5F_LABEL_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_HOME_5F_MAIN_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_HOME_5F_MAIN_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_HOME_5F_WORD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_HOME_5F_WORD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_ARROW_1 (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_atoms);
	tup->cells[6] = lpop(&lbl_cod);
	tup->cells[5] = lpop(&lbl_dom);
	tup->cells[4] = lpop(&lbl_ctx);
	tup->cells[3] = lpop(&lbl_token_end);
	tup->cells[2] = lpop(&lbl_token_start);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 8));
}
static void mtw_ATOM_1 (void) {
	TUP* tup = tup_new(9);
	tup->size = 9;
	tup->cells[0] = MKU64(0LL);
	tup->cells[8] = lpop(&lbl_subst);
	tup->cells[7] = lpop(&lbl_cod);
	tup->cells[6] = lpop(&lbl_dom);
	tup->cells[5] = lpop(&lbl_args);
	tup->cells[4] = lpop(&lbl_op);
	tup->cells[3] = lpop(&lbl_ctx);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 9));
}
static void mtp_ATOM_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_home, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_ctx, tup->cells[3]);
	lpush(&lbl_op, tup->cells[4]);
	lpush(&lbl_args, tup->cells[5]);
	lpush(&lbl_dom, tup->cells[6]);
	lpush(&lbl_cod, tup->cells[7]);
	lpush(&lbl_subst, tup->cells[8]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		incref(tup->cells[8]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LAMBDA_1 (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_body);
	tup->cells[4] = lpop(&lbl_params);
	tup->cells[3] = lpop(&lbl_dom);
	tup->cells[2] = lpop(&lbl_outer_ctx);
	tup->cells[1] = lpop(&lbl_token);
	push_value(MKTUP(tup, 6));
}
static void mtw_TPrim_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TPrim_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TMeta_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TMeta_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_THole_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_THole_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TVar_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TVar_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TTable_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TTable_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TData_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TData_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TTensor_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TTensor_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TMorphism_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TMorphism_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TApp_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(10LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_TApp_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TMut_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TMut_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TValue_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TValue_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_VALUE_5F_INT_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_VALUE_5F_INT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_VALUE_5F_STR_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_VALUE_5F_STR_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_VALUE_5F_BLOCK_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_VALUE_5F_BLOCK_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STVar_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_STVar_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STMeta_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_STMeta_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STCons_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(5LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_STCons_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STConsLabel_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(6LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_STConsLabel_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STWith_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(7LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_STWith_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_ARROW_5F_TYPE_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_ARROW_5F_TYPE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_SUBST_5F_CON_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(1LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_SUBST_5F_CON_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_LPAREN_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_LPAREN_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_RPAREN_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_RPAREN_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_LSQUARE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_LSQUARE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_RSQUARE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_RSQUARE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_LCURLY_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_LCURLY_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_RCURLY_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_RCURLY_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_LCOLON_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_LCOLON_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_RCOLON_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(13LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_RCOLON_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_INT_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(14LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_INT_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_STR_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(15LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_STR_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_NAME_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(16LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_NAME_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_DNAME_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(17LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_DNAME_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_LABEL_5F_PUSH_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(18LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_LABEL_5F_PUSH_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TOKEN_5F_LABEL_5F_POP_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(19LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_TOKEN_5F_LABEL_5F_POP_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_ALIAS_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_ALIAS_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_MODULE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_MODULE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_PACKAGE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_PACKAGE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_DATA_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_DATA_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_TABLE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_TABLE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_TYPEDEF_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_TYPEDEF_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_TAG_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_TAG_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_PRIM_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_PRIM_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_WORD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_WORD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_BUFFER_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_BUFFER_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_VARIABLE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_VARIABLE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_EXTERNAL_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_EXTERNAL_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DEF_5F_FIELD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_DEF_5F_FIELD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NAMESPACE_5F_PACKAGE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NAMESPACE_5F_PACKAGE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NAMESPACE_5F_MODULE_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NAMESPACE_5F_MODULE_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NAMESPACE_5F_TYCON_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NAMESPACE_5F_TYCON_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NAMESPACE_5F_WORD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NAMESPACE_5F_WORD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_MKQNAME_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_arity);
	tup->cells[2] = lpop(&lbl_name);
	tup->cells[1] = lpop(&lbl_namespace);
	push_value(MKTUP(tup, 4));
}
static void mtp_MKQNAME_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_namespace, tup->cells[1]);
	lpush(&lbl_name, tup->cells[2]);
	lpush(&lbl_arity, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_DNAME_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_DNAME_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STACK_5F_CONS_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_STACK_5F_CONS_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_LEXER_1 (void) {
	TUP* tup = tup_new(7);
	tup->size = 7;
	tup->cells[0] = MKU64(0LL);
	tup->cells[6] = lpop(&lbl_lexer_last_token);
	tup->cells[5] = lpop(&lbl_lexer_stack);
	tup->cells[4] = lpop(&lbl_lexer_col);
	tup->cells[3] = lpop(&lbl_lexer_row);
	tup->cells[2] = lpop(&lbl_lexer_module);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 7));
}
static void mtp_LEXER_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	lpush(&lbl_lexer_module, tup->cells[2]);
	lpush(&lbl_lexer_row, tup->cells[3]);
	lpush(&lbl_lexer_col, tup->cells[4]);
	lpush(&lbl_lexer_stack, tup->cells[5]);
	lpush(&lbl_lexer_last_token, tup->cells[6]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_TYPE_5F_ELAB_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_TYPE_5F_ELAB_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STPCons_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_STPCons_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STPConsLabel_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_STPConsLabel_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_STPWith_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_STPWith_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_MKAB_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = lpop(&lbl_arrow);
	push_resource(MKTUP(tup, 2));
}
static void mtp_MKAB_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_arrow, tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OPSIG_5F_PUSH_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OPSIG_5F_PUSH_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_OPSIG_5F_APPLY_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_OPSIG_5F_APPLY_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_KVPAIR_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_value);
	tup->cells[1] = lpop(&lbl_key);
	push_value(MKTUP(tup, 3));
}
static void mtw_SPCHECK_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = lpop(&lbl_checklist);
	push_resource(MKTUP(tup, 2));
}
static void mtp_SPCHECK_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_checklist, tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_SPCHECK_5F_WORD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_SPCHECK_5F_WORD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_SPCHECK_5F_BLOCK_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_SPCHECK_5F_BLOCK_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_SPSYNTH_1 (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = lpop(&lbl_spmap);
	tup->cells[3] = lpop(&lbl_spword);
	tup->cells[2] = lpop(&lbl_spkey);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 5));
}
static void mtp__2B_SPSYNTH_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	lpush(&lbl_spkey, tup->cells[2]);
	lpush(&lbl_spword, tup->cells[3]);
	lpush(&lbl_spmap, tup->cells[4]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_OUTPUT_1 (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = pop_resource();
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 4));
}
static void mtp__2B_OUTPUT_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_resource(tup->cells[2]);
	push_resource(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_SET_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 3));
}
static void mtp__2B_SET_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_resource(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NEED_5F_WORD_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NEED_5F_WORD_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NEED_5F_BLOCK_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NEED_5F_BLOCK_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NEED_5F_TAGW_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NEED_5F_TAGW_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_NEED_5F_TAGP_1 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_NEED_5F_TAGP_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw__2B_NEEDS_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 3));
}
static void mtp__2B_NEEDS_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_resource(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_C99_5F_OPTIONS_1 (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_C99_5F_OPTIONS_1 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_MKC99_1 (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = pop_resource();
	tup->cells[3] = pop_resource();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 5));
}
static void mtp_MKC99_1 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_resource(tup->cells[3]);
	push_resource(tup->cells[4]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_Arguments_2 (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_emit_debug_info);
	tup->cells[4] = lpop(&lbl_packages);
	tup->cells[3] = lpop(&lbl_entry_point);
	tup->cells[2] = lpop(&lbl_output_file);
	tup->cells[1] = lpop(&lbl_input_file);
	push_value(MKTUP(tup, 6));
}
static void mtp_Arguments_2 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_input_file, tup->cells[1]);
	lpush(&lbl_output_file, tup->cells[2]);
	lpush(&lbl_entry_point, tup->cells[3]);
	lpush(&lbl_packages, tup->cells[4]);
	lpush(&lbl_emit_debug_info, tup->cells[5]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mbuf_NUM_12 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_11 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_3 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_16 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_1 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_8 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_7 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_14 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_15 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_17 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_4 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_5 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_6 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_18 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_13 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_2 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_10 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_HASH_5F_BUF_1 (void) {
	static uint8_t b[524288] = {0};
	push_ptr(&b);
}
static void mbuf_NUM_9 (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mvar_prim_var_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_num_warnings_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_num_errors_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_BOOL_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_T_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_F_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_U64_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_U64_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_U32_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_U32_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_U16_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_U16_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_U8_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_U8_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_I64_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_I64_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_I32_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_I32_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_I16_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_I16_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_DATA_5F_I8_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar_TAG_5F_I8_1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
static void mvar__7E_prefer_inline_defs_3F__1 (void) {
	static VAL v = {0};
	push_ptr(&v);
}
int64_t stat (int64_t, int64_t);
static void mext_stat_1 (void) {
	int64_t x1 = pop_i64();
	int64_t x0 = pop_i64();
	push_i64(stat(x0, x1));
}
static void mw__2F_L1_1 (void);
static void mw_empty_3F__4 (void);
static void mw_L4_2B__1 (void);
static void mw_L5_2B__1 (void);
static void mw_L6_2B__1 (void);
static void mw__3E_List_2 (void);
static void mw__3E_List_2B__1 (void);
static void mw_is_empty_2 (void);
static void mw_len_1 (void);
static void mw_len_2 (void);
static void mw_cons_2B__1 (void);
static void mw_snoc_2B__1 (void);
static void mw_cons_2B__2 (void);
static void mw_cons_2 (void);
static void mw_snoc_2B__2B__1 (void);
static void mw_snoc_1 (void);
static void mw_uncons_2 (void);
static void mw_unsnoc_1 (void);
static void mw_cat_2 (void);
static void mw_cat_3 (void);
static void mw_cat_2B__1 (void);
static void mw_cat_2B__2 (void);
static void mw_cat_aux_1 (void);
static void mw_rebalance_1 (void);
static void mw_split_half_left_1 (void);
static void mw_split_half_right_1 (void);
static void mw_first_1 (void);
static void mw_last_1 (void);
static void mw_first_2 (void);
static void mw_last_2 (void);
static void mw_reverse_for_1 (void);
static void mw_reverse_for_2 (void);
static void mw__LIST_1 (void);
static void mw__3B__2 (void);
static void mw_uncons_3F__1 (void);
static void mw_none_3F__1 (void);
static void mw_some_3F__1 (void);
static void mw__3E_Bool_1 (void);
static void mw_unwrap_1 (void);
static void mw_zip_1 (void);
static void mw__2F__25__1 (void);
static void mw__26__26__1 (void);
static void mw__7C__7C__1 (void);
static void mw_not_1 (void);
static void mw_then_1 (void);
static void mw_else_1 (void);
static void mw__3E_OS_1 (void);
static void mw_RUNNING_5F_OS_1 (void);
static void mw_rotr_1 (void);
static void mw_rotl_1 (void);
static void mw_over_1 (void);
static void mw_over2_1 (void);
static void mw_over3_1 (void);
static void mw_tuck_1 (void);
static void mw_nip_1 (void);
static void mw_dup2_1 (void);
static void mw_dip2_1 (void);
static void mw_sip_1 (void);
static void mw_drop2_1 (void);
static void mw_drop3_1 (void);
static void mw_drop4_1 (void);
static void mw_rot4r_1 (void);
static void mw_rot4l_1 (void);
static void mw_U8_5F_MAX_1 (void);
static void mw_U8_5F_MIN_1 (void);
static void mw_is_eq_1 (void);
static void mw_is_le_1 (void);
static void mw_is_ne_1 (void);
static void mw__3E__1 (void);
static void mw__3E__3D__1 (void);
static void mw__3C__3D__1 (void);
static void mw__3C__3E__1 (void);
static void mw_compare_1 (void);
static void mw_in_range_1 (void);
static void mw_compare_2 (void);
static void mw__3D__3D__7 (void);
static void mw__3C__3E__2 (void);
static void mw_prim_int_succ_1 (void);
static void mw_prim_int_pred_1 (void);
static void mw_2_2A__1 (void);
static void mw_0_3D__1 (void);
static void mw_0_3C__1 (void);
static void mw_0_3E__1 (void);
static void mw_sizeof_1 (void);
static void mw__UNSAFE_1 (void);
static void mw_offset_1 (void);
static void mw__40_Ptr_1 (void);
static void mw__40_U8_1 (void);
static void mw__40_I64_1 (void);
static void mw__21_U8_1 (void);
static void mw__21_I64_1 (void);
static void mw_alloc_1 (void);
static void mw_realloc_1 (void);
static void mw_free_1 (void);
static void mw_copy_1 (void);
static void mw_fill_1 (void);
static void mw_erase_1 (void);
static void mw__3E_Int_7 (void);
static void mw__3E_Int_3 (void);
static void mw__3E_U8_unsafe_1 (void);
static void mw__3E_U8_3F__1 (void);
static void mw__3E_U8_1 (void);
static void mw__3E_I64_1 (void);
static void mw__7C__5 (void);
static void mw__26__5 (void);
static void mw__3E_Nat_unsafe_1 (void);
static void mw__3E_Nat_1 (void);
static void mw__3E_Int_8 (void);
static void mw__2B__2 (void);
static void mw___2 (void);
static void mw__2A__2 (void);
static void mw_1_2B__2 (void);
static void mw_1__2 (void);
static void mw_2_2A__2 (void);
static void mw__3D__3D__12 (void);
static void mw__3C__3 (void);
static void mw__3E__3 (void);
static void mw__3C__3D__3 (void);
static void mw__3E__3D__3 (void);
static void mw_0_3E__2 (void);
static void mw_0_3D__2 (void);
static void mw__3E_Size_2 (void);
static void mw__3E_Nat_7 (void);
static void mw__3E_Int_11 (void);
static void mw__3E_Size_1 (void);
static void mw__2B__4 (void);
static void mw___4 (void);
static void mw_1_2B__4 (void);
static void mw_1__4 (void);
static void mw_2_2A__3 (void);
static void mw__3D__3D__15 (void);
static void mw__3E__5 (void);
static void mw__3C__3D__5 (void);
static void mw__3E__3D__5 (void);
static void mw_0_3D__4 (void);
static void mw_0_3E__4 (void);
static void mw_max_5 (void);
static void mw_min_5 (void);
static void mw__3E_Offset_1 (void);
static void mw__3E_Int_10 (void);
static void mw__3E_Offset_2 (void);
static void mw__3E_Offset_3 (void);
static void mw__3E_Nat_6 (void);
static void mw__3E_Size_3 (void);
static void mw__2B__3 (void);
static void mw___3 (void);
static void mw_1_2B__3 (void);
static void mw_1__3 (void);
static void mw__3D__3D__14 (void);
static void mw__3E__4 (void);
static void mw__3C__4 (void);
static void mw__3E__3D__4 (void);
static void mw__3C__3D__4 (void);
static void mw_0_3C__2 (void);
static void mw_0_3E__3 (void);
static void mw_min_4 (void);
static void mw_pack1_1 (void);
static void mw_pack2_1 (void);
static void mw_pack3_1 (void);
static void mw_unpack1_1 (void);
static void mw_unpack2_1 (void);
static void mw_unpack3_1 (void);
static void mw__40__3F__1 (void);
static void mw_tag_5 (void);
static void mw_from_tag_unsafe_5 (void);
static void mw__3E_Int_12 (void);
static void mw__3E_Byte_1 (void);
static void mw__3E_U8_3 (void);
static void mw__3E_Byte_2 (void);
static void mw__40_Byte_1 (void);
static void mw__3D__3D__19 (void);
static void mw__3E__6 (void);
static void mw_in_range_2 (void);
static void mw_is_upper_1 (void);
static void mw_is_lower_1 (void);
static void mw_is_digit_1 (void);
static void mw_is_alpha_1 (void);
static void mw_is_alnum_1 (void);
static void mw_is_printable_1 (void);
static void mw_is_hexdigit_1 (void);
static void mw_to_str_unsafe_1 (void);
static void mw_to_ascii_str_1 (void);
static void mw_is_string_end_1 (void);
static void mw_to_hexdigits_1 (void);
static void mw_one_hexdigit_byte_1 (void);
static void mw_is_name_byte_1 (void);
static void mw_is_sign_1 (void);
static void mw__BUFFER_1 (void);
static void mw_new_2 (void);
static void mw_resize_21__1 (void);
static void mw_expand_21__1 (void);
static void mw_rdrop_2 (void);
static void mw_erase_span_21__1 (void);
static void mw_buffer_size_1 (void);
static void mw_buffer_base_1 (void);
static void mw_check_span_21__1 (void);
static void mw_check_span_align_21__1 (void);
static void mw__40_U8_2 (void);
static void mw__21_U8_2 (void);
static void mw__21_Byte_2 (void);
static void mw__21_Str_1 (void);
static void mw__40_Str_1 (void);
static void mw_num_bytes_1 (void);
static void mw_empty_3F__2 (void);
static void mw_copy_partial_21__1 (void);
static void mw_thaw_1 (void);
static void mw_freeze_1 (void);
static void mw_Str_2 (void);
static void mw__3B__1 (void);
static void mw_copy_2 (void);
static void mw_copy_cstr_1 (void);
static void mw_cstr_num_bytes_1 (void);
static void mw_dup_21__1 (void);
static void mw_num_bytes_3F__1 (void);
static void mw_last_byte_1 (void);
static void mw_byte_40__1 (void);
static void mw_byte_40__2 (void);
static void mw_push_byte_unsafe_21__1 (void);
static void mw_push_byte_ascii_21__1 (void);
static void mw_push_str_21__1 (void);
static void mw_show_1 (void);
static void mw_show_2 (void);
static void mw_show_4 (void);
static void mw_drop_bytes_1 (void);
static void mw_from_bytes_unsafe_1 (void);
static void mw_clamp_slice_offset_size_1 (void);
static void mw_slice_2 (void);
static void mw_slice_1 (void);
static void mw_offset_slice_1 (void);
static void mw_take_slice_1 (void);
static void mw_drop_slice_1 (void);
static void mw_split_byte_1 (void);
static void mw_split_byte_2 (void);
static void mw__3E_Path_1 (void);
static void mw__3E_Str_1 (void);
static void mw__3D__3D__16 (void);
static void mw_empty_3F__3 (void);
static void mw_join_with_1 (void);
static void mw_join_unix_1 (void);
static void mw__3E_File_1 (void);
static void mw__3E_Int_13 (void);
static void mw_STDOUT_1 (void);
static void mw_STDERR_1 (void);
static void mw_write_21__2 (void);
static void mw_slice_write_21__1 (void);
static void mw_print_21__2 (void);
static void mw_trace_21__2 (void);
static void mw_print_ln_21__2 (void);
static void mw_trace_ln_21__2 (void);
static void mw_line_print_21__1 (void);
static void mw_line_trace_21__1 (void);
static void mw_trace_21__4 (void);
static void mw_trace_21__1 (void);
static void mw_program_name_2 (void);
static void mw_argv_3 (void);
static void mw_option_option_2 (void);
static void mw_option_option_21__1 (void);
static void mw_parsing_3F__2 (void);
static void mw_parsing_3F__21__1 (void);
static void mw_error_3 (void);
static void mw_error_21__1 (void);
static void mw_positional_index_2 (void);
static void mw_positional_index_21__1 (void);
static void mw_arg_2 (void);
static void mw_arg_21__1 (void);
static void mw_argv_info_2 (void);
static void mw_arguments_2 (void);
static void mw_arguments_21__1 (void);
static void mw_init_1 (void);
static void mw_argv_4 (void);
static void mw_program_name_3 (void);
static void mw_parsing_3F__3 (void);
static void mw_parsing_3F__21__2 (void);
static void mw_option_option_3 (void);
static void mw_option_option_21__2 (void);
static void mw_args_doc_2 (void);
static void mw_parser_3 (void);
static void mw_options_2 (void);
static void mw__2F__2B_ARGUMENTPARSER_1 (void);
static void mw_state_3 (void);
static void mw_state_21__1 (void);
static void mw_argument_parser_2 (void);
static void mw_rdrop_4 (void);
static void mw_parser_1 (void);
static void mw_has_short_3F__1 (void);
static void mw_doc_2 (void);
static void mw_arg_doc_2 (void);
static void mw_flag_type_2 (void);
static void mw_name_21 (void);
static void mw_show_6 (void);
static void mw_print_usage_1 (void);
static void mw_print_usage_for_option_1 (void);
static void mw_check_short_flag_1 (void);
static void mw_check_long_flag_1 (void);
static void mw_parse_flags_1 (void);
static void mw_do_positional_option_1 (void);
static void mw_parse_args_1 (void);
static void mw_read_from_argv_1 (void);
static void mw_increment_index_1 (void);
static void mw_index_20 (void);
static void mw_argv_to_str_1 (void);
static void mw__INPUTOPEN_1 (void);
static void mw_length_40__1 (void);
static void mw_length_21__1 (void);
static void mw_offset_40__2 (void);
static void mw_offset_21__1 (void);
static void mw_INPUT_5F_BUFFER_5F_SIZE_1 (void);
static void mw_start_21__2 (void);
static void mw_stop_21__1 (void);
static void mw_end_21__2 (void);
static void mw_done_3F__1 (void);
static void mw_fill_buffer_21__1 (void);
static void mw_peek_1 (void);
static void mw_move_21__1 (void);
static void mw_prepare_for_more_21__1 (void);
static void mw_read_chunk_21__1 (void);
static void mw_read_file_21__1 (void);
static void mw__FILE_1 (void);
static void mw_file_descriptor_1 (void);
static void mw_open_file_21__1 (void);
static void mw_create_file_21__1 (void);
static void mw_O_5F_WRONLY_7C_O_5F_CREAT_7C_O_5F_TRUNC_1 (void);
static void mw_close_file_21__1 (void);
static void mw_unsafe_write_21__1 (void);
static void mw_unsafe_read_21__1 (void);
static void mw_read_file_21__2 (void);
static void mw_ready_1 (void);
static void mw_ready2_1 (void);
static void mw_delay_1 (void);
static void mw_delay0_1 (void);
static void mw_force_21__1 (void);
static void mw_index_14 (void);
static void mw_alloc_21__12 (void);
static void mw_name_14 (void);
static void mw__3E_Str_6 (void);
static void mw__3D__3D__34 (void);
static void mw_new_21__8 (void);
static void mw_index_13 (void);
static void mw_alloc_21__11 (void);
static void mw_package_2 (void);
static void mw_name_13 (void);
static void mw_qname_10 (void);
static void mw_path_3 (void);
static void mw_start_1 (void);
static void mw_imports_1 (void);
static void mw__3D__3D__33 (void);
static void mw_prim_4 (void);
static void mw_new_21__7 (void);
static void mw_add_import_21__1 (void);
static void mw_source_path_1 (void);
static void mw_visible_1 (void);
static void mw__3E_Row_1 (void);
static void mw__3E_Int_19 (void);
static void mw_trace_21__15 (void);
static void mw__3E_Col_1 (void);
static void mw__3E_Int_18 (void);
static void mw_trace_21__13 (void);
static void mw_unpack_2 (void);
static void mw_trace_21__14 (void);
static void mw_init_errors_21__1 (void);
static void mw_emit_warning_at_21__1 (void);
static void mw_emit_error_at_21__1 (void);
static void mw_emit_fatal_error_at_21__1 (void);
static void mw_index_5 (void);
static void mw_alloc_21__3 (void);
static void mw_name_4 (void);
static void mw_type_4 (void);
static void mw_auto_run_3F__1 (void);
static void mw__3D__3D__21 (void);
static void mw_trace_21__5 (void);
static void mw_is_stack_3F__1 (void);
static void mw_is_physical_3F__1 (void);
static void mw_new_21__3 (void);
static void mw_new_auto_run_21__1 (void);
static void mw__2F_CTX_1 (void);
static void mw__3E_Ctx_1 (void);
static void mw__3E_List_3 (void);
static void mw_CTX0_1 (void);
static void mw_CTX1_1 (void);
static void mw_CTX2_1 (void);
static void mw_CTX3_1 (void);
static void mw_new_4 (void);
static void mw_lookup_2 (void);
static void mw_len_3 (void);
static void mw_fresh_name_21__1 (void);
static void mw_fresh_stack_type_var_21__1 (void);
static void mw_fresh_type_var_21__1 (void);
static void mw_fresh_var_21__1 (void);
static void mw_alloc_21__16 (void);
static void mw_size_1 (void);
static void mw_qname_15 (void);
static void mw_name_18 (void);
static void mw_new_21__9 (void);
static void mw_index_3 (void);
static void mw_alloc_21__1 (void);
static void mw_qname_1 (void);
static void mw_name_2 (void);
static void mw_head_2 (void);
static void mw_sig_1 (void);
static void mw_body_1 (void);
static void mw_arity_1 (void);
static void mw_params_1 (void);
static void mw_arrow_2 (void);
static void mw_cname_1 (void);
static void mw_ctx_type_1 (void);
static void mw_type_2 (void);
static void mw_prefer_inline_3F__1 (void);
static void mw_new_21__1 (void);
static void mw__3D__3D__20 (void);
static void mw_index_10 (void);
static void mw_alloc_21__8 (void);
static void mw_head_5 (void);
static void mw_qname_6 (void);
static void mw_name_8 (void);
static void mw_num_buffer_1 (void);
static void mw__3D__3D__26 (void);
static void mw_alloc_21__7 (void);
static void mw_head_4 (void);
static void mw_qname_5 (void);
static void mw_name_7 (void);
static void mw_index_type_1 (void);
static void mw_value_type_1 (void);
static void mw_dom_2 (void);
static void mw_cod_2 (void);
static void mw_type_6 (void);
static void mw_qname_4 (void);
static void mw__3D__3D__24 (void);
static void mw_index_16 (void);
static void mw_alloc_21__14 (void);
static void mw_head_3F__3 (void);
static void mw_qname_13 (void);
static void mw_name_16 (void);
static void mw_arity_6 (void);
static void mw_tags_1 (void);
static void mw_TYPE_5F_BOOL_1 (void);
static void mw_TYPE_5F_U64_1 (void);
static void mw_TYPE_5F_U32_1 (void);
static void mw_TYPE_5F_U16_1 (void);
static void mw_TYPE_5F_U8_1 (void);
static void mw_TYPE_5F_I64_1 (void);
static void mw_TYPE_5F_I32_1 (void);
static void mw_TYPE_5F_I16_1 (void);
static void mw_TYPE_5F_I8_1 (void);
static void mw_make_prim_data_21__1 (void);
static void mw_make_prim_tag_21__1 (void);
static void mw_init_data_21__1 (void);
static void mw_data_qname_1 (void);
static void mw_data_word_qname_1 (void);
static void mw__3D__3D__35 (void);
static void mw_num_tags_1 (void);
static void mw_add_tag_21__1 (void);
static void mw_is_enum_3F__1 (void);
static void mw_is_transparent_3F__2 (void);
static void mw_is_resource_3F__2 (void);
static void mw_index_17 (void);
static void mw_alloc_21__15 (void);
static void mw_data_3 (void);
static void mw_qname_14 (void);
static void mw_name_17 (void);
static void mw_value_4 (void);
static void mw_label_inputs_1 (void);
static void mw_num_type_inputs_1 (void);
static void mw_num_resource_inputs_1 (void);
static void mw_sig_3F__1 (void);
static void mw_ctx_type_3 (void);
static void mw_ctx_11 (void);
static void mw_type_9 (void);
static void mw_untag_1 (void);
static void mw_label_inputs_from_sig_1 (void);
static void mw_num_type_inputs_from_sig_1 (void);
static void mw_num_resource_inputs_from_sig_1 (void);
static void mw_num_total_inputs_1 (void);
static void mw_is_transparent_3F__3 (void);
static void mw_outputs_resource_3F__1 (void);
static void mw__3D__3D__36 (void);
static void mw_prefer_inline_3F__2 (void);
static void mw_cases_4 (void);
static void mw_cases_21__2 (void);
static void mw_cod_6 (void);
static void mw_dom_6 (void);
static void mw_body_7 (void);
static void mw_token_6 (void);
static void mw_cases_2 (void);
static void mw_cases_21__1 (void);
static void mw_cod_4 (void);
static void mw_dom_4 (void);
static void mw_ctx_5 (void);
static void mw_body_3 (void);
static void mw_home_2 (void);
static void mw_thaw_2 (void);
static void mw_freeze_2 (void);
static void mw_body_5 (void);
static void mw_body_21__2 (void);
static void mw_pattern_4 (void);
static void mw_is_exhaustive_3F__1 (void);
static void mw_has_default_case_3F__1 (void);
static void mw_scrutinee_data_3F__1 (void);
static void mw_is_transparent_3F__1 (void);
static void mw_add_case_1 (void);
static void mw_case_redundant_3F__1 (void);
static void mw_covers_3F__1 (void);
static void mw_is_default_case_3F__1 (void);
static void mw_atoms_2 (void);
static void mw_atoms_21__1 (void);
static void mw_mid_2 (void);
static void mw_mid_21__1 (void);
static void mw_saved_2 (void);
static void mw_saved_21__1 (void);
static void mw_inner_ctx_3 (void);
static void mw_token_start_2 (void);
static void mw_dom_7 (void);
static void mw_thaw_3 (void);
static void mw_single_tag_3F__1 (void);
static void mw_is_default_3F__1 (void);
static void mw__2F__2B_PATTERN_1 (void);
static void mw_pattern_2 (void);
static void mw_pattern_21__1 (void);
static void mw_freeze_3 (void);
static void mw_op_2 (void);
static void mw_op_21__1 (void);
static void mw_underscore_21__1 (void);
static void mw_tag_21__1 (void);
static void mw_covers_3F__2 (void);
static void mw__2F_PATOP_5F_TAG_1 (void);
static void mw__2F_PATOP_5F_UNDERSCORE_1 (void);
static void mw_index_19 (void);
static void mw_alloc_21__17 (void);
static void mw__2F_ARG_5F_BLOCK_1 (void);
static void mw__2F_PARAM_1 (void);
static void mw__3E_Param_1 (void);
static void mw__3E_Var_1 (void);
static void mw_atoms_4 (void);
static void mw_atoms_21__2 (void);
static void mw_cod_12 (void);
static void mw_cod_21__5 (void);
static void mw_dom_11 (void);
static void mw_ctx_13 (void);
static void mw_token_end_4 (void);
static void mw_token_end_21__2 (void);
static void mw_token_start_4 (void);
static void mw_home_8 (void);
static void mw_type_11 (void);
static void mw__2F_ATOM_1 (void);
static void mw_cod_14 (void);
static void mw_dom_13 (void);
static void mw_dom_21__5 (void);
static void mw_args_4 (void);
static void mw_args_21__1 (void);
static void mw_op_4 (void);
static void mw_op_21__3 (void);
static void mw_token_11 (void);
static void mw_body_9 (void);
static void mw_body_21__4 (void);
static void mw_params_3 (void);
static void mw_dom_16 (void);
static void mw_cod_16 (void);
static void mw_ctx_16 (void);
static void mw_token_12 (void);
static void mw_dom_14 (void);
static void mw_cod_15 (void);
static void mw_home_11 (void);
static void mw_type_12 (void);
static void mw_arrow_5 (void);
static void mw_qname_16 (void);
static void mw__3D__3D__39 (void);
static void mw_new_21__10 (void);
static void mw_typecheck_21__2 (void);
static void mw_block_unify_type_21__1 (void);
static void mw_to_run_var_3 (void);
static void mw_to_run_var_1 (void);
static void mw_to_run_var_2 (void);
static void mw__3E_Str_9 (void);
static void mw__3D__3D__38 (void);
static void mw_free_vars_6 (void);
static void mw_free_vars_4 (void);
static void mw_free_vars_5 (void);
static void mw_free_vars_3 (void);
static void mw_free_vars_8 (void);
static void mw_free_vars_2 (void);
static void mw_free_vars_1 (void);
static void mw_free_vars_7 (void);
static void mw_token_9 (void);
static void mw_alloc_21__4 (void);
static void mw_head_3F__1 (void);
static void mw_qname_3 (void);
static void mw_target_1 (void);
static void mw_new_21__4 (void);
static void mw_tag_6 (void);
static void mw_is_physical_3F__2 (void);
static void mw_tycon_3F__1 (void);
static void mw_tycon_qname_1 (void);
static void mw_tycon_3F__2 (void);
static void mw__3E_Int_14 (void);
static void mw__3D__3D__23 (void);
static void mw_def_prim_type_21__1 (void);
static void mw_init_types_21__1 (void);
static void mw_T_2B__1 (void);
static void mw_T_2A__1 (void);
static void mw_T_2A__2B__1 (void);
static void mw_T__3E__1 (void);
static void mw_TT_1 (void);
static void mw_T0_1 (void);
static void mw_T1_1 (void);
static void mw_T2_1 (void);
static void mw_T3_1 (void);
static void mw_T4_1 (void);
static void mw_T5_1 (void);
static void mw_T6_1 (void);
static void mw_error_3F__1 (void);
static void mw_morphism_3F__1 (void);
static void mw_prim_3F__1 (void);
static void mw_meta_3D__1 (void);
static void mw_is_physical_3F__3 (void);
static void mw_TYPE_5F_TYPE_1 (void);
static void mw_TYPE_5F_STACK_1 (void);
static void mw_TYPE_5F_RESOURCE_1 (void);
static void mw_TYPE_5F_INT_1 (void);
static void mw_TYPE_5F_PTR_1 (void);
static void mw_TYPE_5F_STR_1 (void);
static void mw_TYPE_5F_WORLD_1 (void);
static void mw_RESOURCE_5F_WORLD_1 (void);
static void mw_expand_3 (void);
static void mw_token_2 (void);
static void mw_unify_failed_21__2 (void);
static void mw_unify_simple_21__1 (void);
static void mw_unify_aux_21__1 (void);
static void mw_unify_21__7 (void);
static void mw_unify_21__8 (void);
static void mw_unify_type_21__1 (void);
static void mw_unify_block_21__1 (void);
static void mw_unify2_21__1 (void);
static void mw_unify_21__4 (void);
static void mw_unify_21__10 (void);
static void mw_unify_21__9 (void);
static void mw_unify_21__1 (void);
static void mw_has_meta_3F__5 (void);
static void mw_has_meta2_3F__1 (void);
static void mw_has_meta_3F__6 (void);
static void mw_trace_sig_21__1 (void);
static void mw_trace_21__11 (void);
static void mw_type_5 (void);
static void mw_trace_21__8 (void);
static void mw_freshen_6 (void);
static void mw_freshen2_1 (void);
static void mw_freshen_1 (void);
static void mw_rigidify_21__4 (void);
static void mw_rigidify_21__5 (void);
static void mw_arity_2 (void);
static void mw_index_7 (void);
static void mw_alloc_21__5 (void);
static void mw_type_3F__1 (void);
static void mw_has_meta_3F__2 (void);
static void mw_trace_21__7 (void);
static void mw_new_21__5 (void);
static void mw_expand_1 (void);
static void mw_unify_21__3 (void);
static void mw__3D__3D__22 (void);
static void mw_freshen_3 (void);
static void mw_type_hole_unify_21__1 (void);
static void mw_trace_app_21__1 (void);
static void mw_trace_app_open_21__1 (void);
static void mw__3E_Type_2 (void);
static void mw__3E_Resource_1 (void);
static void mw_has_meta_3F__3 (void);
static void mw_unify_21__5 (void);
static void mw_trace_21__9 (void);
static void mw_freshen_4 (void);
static void mw_rigidify_21__2 (void);
static void mw__3E_StackType_1 (void);
static void mw__3E_Type_3 (void);
static void mw_expand_2 (void);
static void mw_unit_3F__1 (void);
static void mw_split4_1 (void);
static void mw_base_1 (void);
static void mw_top_type_3F__1 (void);
static void mw_top_tycon_3F__1 (void);
static void mw_top_resource_3F__1 (void);
static void mw_top_resource_tycon_3F__1 (void);
static void mw_has_meta_3F__4 (void);
static void mw_unify_failed_21__1 (void);
static void mw_unify_21__6 (void);
static void mw_force_cons_label_3F__21__1 (void);
static void mw_force_cons_3F__21__1 (void);
static void mw_force_with_3F__21__1 (void);
static void mw_trace_dom_21__1 (void);
static void mw_trace_cod_21__1 (void);
static void mw_trace_base_21__1 (void);
static void mw_trace_21__10 (void);
static void mw_semifreshen_1 (void);
static void mw_freshen_5 (void);
static void mw_freshen_aux_1 (void);
static void mw_rigidify_21__3 (void);
static void mw__3E_Type_1 (void);
static void mw_unpack_1 (void);
static void mw_dom_1 (void);
static void mw_cod_1 (void);
static void mw_unify_21__2 (void);
static void mw_has_meta_3F__1 (void);
static void mw_trace_21__6 (void);
static void mw_semifreshen_sig_1 (void);
static void mw_semifreshen_aux_1 (void);
static void mw_needs_fresh_stack_rest_3F__1 (void);
static void mw_freshen_sig_1 (void);
static void mw_freshen_sig_aux_1 (void);
static void mw_freshen_2 (void);
static void mw_rigidify_21__1 (void);
static void mw_rigidify_sig_21__1 (void);
static void mw_nil_6 (void);
static void mw_cons_3 (void);
static void mw_has_var_3F__1 (void);
static void mw_get_var_1 (void);
static void mw_qname_7 (void);
static void mw_name_9 (void);
static void mw_type_7 (void);
static void mw_arity_3 (void);
static void mw_def_prim_21__1 (void);
static void mw_ctx_type_21__1 (void);
static void mw_init_prims_21__1 (void);
static void mw_none_3F__3 (void);
static void mw_comma_3F__2 (void);
static void mw_lparen_open_3F__2 (void);
static void mw_lparen_3F__2 (void);
static void mw_lsquare_open_3F__2 (void);
static void mw_lsquare_3F__2 (void);
static void mw_rsquare_3F__2 (void);
static void mw_lcurly_open_3F__2 (void);
static void mw_lcolon_open_3F__2 (void);
static void mw_lcolon_3F__2 (void);
static void mw_lparen_or_lcolon_3F__2 (void);
static void mw_int_3F__3 (void);
static void mw_str_3F__2 (void);
static void mw_name_3F__3 (void);
static void mw_dname_3F__3 (void);
static void mw_name_or_dname_3F__2 (void);
static void mw_arg_end_3F__2 (void);
static void mw_left_enclosure_3F__2 (void);
static void mw_right_enclosure_3F__2 (void);
static void mw_sig_type_3F__2 (void);
static void mw_sig_type_con_3F__2 (void);
static void mw_sig_type_hole_3F__2 (void);
static void mw_sig_type_var_3F__2 (void);
static void mw_sig_param_name_3F__2 (void);
static void mw_sig_stack_var_3F__2 (void);
static void mw_sig_resource_var_3F__2 (void);
static void mw_sig_resource_con_3F__2 (void);
static void mw_sig_dashes_3F__2 (void);
static void mw_pat_arrow_3F__2 (void);
static void mw_pat_underscore_3F__2 (void);
static void mw_module_header_3F__2 (void);
static void mw_index_8 (void);
static void mw_succ_7 (void);
static void mw_pred_7 (void);
static void mw_alloc_21__6 (void);
static void mw__3D__3D__25 (void);
static void mw_value_3 (void);
static void mw_module_3 (void);
static void mw_col_1 (void);
static void mw_row_1 (void);
static void mw_none_3F__2 (void);
static void mw_comma_3F__1 (void);
static void mw_lparen_open_3F__1 (void);
static void mw_lparen_3F__1 (void);
static void mw_lsquare_open_3F__1 (void);
static void mw_lsquare_3F__1 (void);
static void mw_rsquare_3F__1 (void);
static void mw_lcurly_open_3F__1 (void);
static void mw_lcolon_open_3F__1 (void);
static void mw_lcolon_3F__1 (void);
static void mw_lparen_or_lcolon_3F__1 (void);
static void mw_int_3F__2 (void);
static void mw_str_3F__1 (void);
static void mw_name_3F__2 (void);
static void mw_dname_3F__2 (void);
static void mw_name_or_dname_3F__1 (void);
static void mw_arg_end_3F__1 (void);
static void mw_left_enclosure_3F__1 (void);
static void mw_right_enclosure_3F__1 (void);
static void mw_sig_type_3F__1 (void);
static void mw_sig_type_con_3F__1 (void);
static void mw_sig_type_hole_3F__1 (void);
static void mw_sig_type_var_3F__1 (void);
static void mw_sig_param_name_3F__1 (void);
static void mw_sig_stack_var_3F__1 (void);
static void mw_sig_resource_var_3F__1 (void);
static void mw_sig_resource_con_3F__1 (void);
static void mw_sig_dashes_3F__1 (void);
static void mw_pat_arrow_3F__1 (void);
static void mw_pat_underscore_3F__1 (void);
static void mw_module_header_3F__1 (void);
static void mw_alloc_none_21__1 (void);
static void mw_location_2 (void);
static void mw_next_1 (void);
static void mw_prev_1 (void);
static void mw_next_arg_end_1 (void);
static void mw_has_args_3F__1 (void);
static void mw_args_start_1 (void);
static void mw_could_be_sig_label_3F__1 (void);
static void mw_pattern_var_3F__1 (void);
static void mw_args_0_1 (void);
static void mw_args_1_1 (void);
static void mw_args_2_1 (void);
static void mw_args_3_1 (void);
static void mw_num_args_1 (void);
static void mw_args_2 (void);
static void mw_args_end_3F__1 (void);
static void mw_args_2B__1 (void);
static void mw_emit_error_21__1 (void);
static void mw_emit_fatal_error_21__1 (void);
static void mw_module_end_3F__1 (void);
static void mw_run_end_3F__1 (void);
static void mw_run_tokens_1 (void);
static void mw_run_length_1 (void);
static void mw_run_arrow_3F__1 (void);
static void mw_sig_stack_end_3F__1 (void);
static void mw_sig_next_stack_end_1 (void);
static void mw_sig_has_dashes_3F__1 (void);
static void mw_sig_arity_1 (void);
static void mw_sig_count_types_1 (void);
static void mw_alloc_21__18 (void);
static void mw_head_9 (void);
static void mw_qname_17 (void);
static void mw_target_2 (void);
static void mw_new_21__11 (void);
static void mw_alloc_21__13 (void);
static void mw_qname_11 (void);
static void mw_name_15 (void);
static void mw_symbol_1 (void);
static void mw_head_7 (void);
static void mw_sig_2 (void);
static void mw_ctx_type_2 (void);
static void mw_type_8 (void);
static void mw_alloc_21__2 (void);
static void mw_head_3 (void);
static void mw_qname_2 (void);
static void mw_name_3 (void);
static void mw_type_3 (void);
static void mw_new_21__2 (void);
static void mw_package_3F__2 (void);
static void mw_module_3F__2 (void);
static void mw_tag_3F__1 (void);
static void mw_prim_3F__2 (void);
static void mw_word_3F__1 (void);
static void mw_typecheck_21__1 (void);
static void mw_defines_a_type_3F__1 (void);
static void mw_exposed_tycon_3F__1 (void);
static void mw_head_3F__2 (void);
static void mw_defining_module_3F__1 (void);
static void mw_qname_12 (void);
static void mw_register_1 (void);
static void mw_def_index_1 (void);
static void mw_index_12 (void);
static void mw_from_index_10 (void);
static void mw_alloc_21__10 (void);
static void mw__3E_Str_3 (void);
static void mw_defs_1 (void);
static void mw_mangled_1 (void);
static void mw__3D__3D__30 (void);
static void mw__3E_Int_17 (void);
static void mw__3E_Hash_1 (void);
static void mw_HASH_5F_MAX_1 (void);
static void mw_hash_name_40__1 (void);
static void mw_hash_name_21__1 (void);
static void mw_hash_1 (void);
static void mw_next_2 (void);
static void mw_keep_going_3F__1 (void);
static void mw__3E_Name_1 (void);
static void mw_trace_21__12 (void);
static void mw_head_6 (void);
static void mw_tail_head_1 (void);
static void mw_can_be_relative_3F__1 (void);
static void mw_could_be_label_name_3F__1 (void);
static void mw_could_be_type_1 (void);
static void mw_could_be_pattern_var_3F__1 (void);
static void mw_could_be_type_var_1 (void);
static void mw_could_be_type_con_1 (void);
static void mw_is_type_hole_1 (void);
static void mw_is_underscore_1 (void);
static void mw_could_be_stack_var_1 (void);
static void mw_could_be_resource_var_1 (void);
static void mw_could_be_resource_con_1 (void);
static void mw_could_be_type_or_resource_con_1 (void);
static void mw_mangle_compute_21__1 (void);
static void mw__3D__3D__31 (void);
static void mw_compare_6 (void);
static void mw_qname_9 (void);
static void mw_module_3F__1 (void);
static void mw_prim_2 (void);
static void mw__3E_Str_4 (void);
static void mw__2F_MKQNAME_1 (void);
static void mw_arity_5 (void);
static void mw_arity_21__1 (void);
static void mw_name_12 (void);
static void mw_namespace_5 (void);
static void mw_namespace_21__1 (void);
static void mw_QNAME0_1 (void);
static void mw__3D__3D__32 (void);
static void mw__3C__3D__7 (void);
static void mw_compare_7 (void);
static void mw_def_3F__1 (void);
static void mw_defined_3F__1 (void);
static void mw_undefined_3F__1 (void);
static void mw_prim_3 (void);
static void mw__3E_Str_5 (void);
static void mw_to_module_path_1 (void);
static void mw_root_3F__1 (void);
static void mw_parts_1 (void);
static void mw_index_11 (void);
static void mw_alloc_21__9 (void);
static void mw_name_10 (void);
static void mw_qname_8 (void);
static void mw_path_2 (void);
static void mw_new_21__6 (void);
static void mw_new_or_set_path_21__1 (void);
static void mw_find_4 (void);
static void mw_find_or_new_21__1 (void);
static void mw__3D__3D__29 (void);
static void mw_head_1 (void);
static void mw_cons_1 (void);
static void mw_uncons_1 (void);
static void mw__2F_LEXER_1 (void);
static void mw_lexer_last_token_2 (void);
static void mw_lexer_last_token_21__1 (void);
static void mw_lexer_stack_2 (void);
static void mw_lexer_stack_21__1 (void);
static void mw_lexer_col_2 (void);
static void mw_lexer_col_21__1 (void);
static void mw_lexer_row_2 (void);
static void mw_lexer_row_21__1 (void);
static void mw_lexer_module_2 (void);
static void mw_lexer_stack_push_21__1 (void);
static void mw_lexer_stack_pop_21__1 (void);
static void mw_lexer_stack_drop_1 (void);
static void mw_lexer_stack_peek_1 (void);
static void mw_lexer_col_40__1 (void);
static void mw_lexer_row_40__1 (void);
static void mw_lexer_module_40__1 (void);
static void mw_run_lexer_21__1 (void);
static void mw_done_3F__2 (void);
static void mw_lexer_make_21__1 (void);
static void mw_lexer_emit_21__1 (void);
static void mw_lexer_next_21__1 (void);
static void mw_lexer_newline_21__1 (void);
static void mw_lexer_emit_lcolon_21__1 (void);
static void mw_lexer_close_colons_21__1 (void);
static void mw_lexer_prepare_for_atom_21__1 (void);
static void mw_lexer_prepare_for_args_21__1 (void);
static void mw_lexer_emit_lparen_21__1 (void);
static void mw_lexer_emit_rparen_21__1 (void);
static void mw_lexer_emit_lsquare_21__1 (void);
static void mw_lexer_emit_rsquare_21__1 (void);
static void mw_lexer_emit_lcurly_21__1 (void);
static void mw_lexer_emit_rcurly_21__1 (void);
static void mw_lexer_emit_name_21__1 (void);
static void mw_name_3F__1 (void);
static void mw_drop_last_byte_1 (void);
static void mw_label_token_3F__1 (void);
static void mw_dname_3F__1 (void);
static void mw_is_doc_start_3F__1 (void);
static void mw_is_int_3F__1 (void);
static void mw_is_dec_int_3F__1 (void);
static void mw_is_hex_int_3F__1 (void);
static void mw_is_oct_int_3F__1 (void);
static void mw_int_3F__1 (void);
static void mw_int_sign_1 (void);
static void mw_byte_sign_value_index_1 (void);
static void mw_dec_int_3F__1 (void);
static void mw_hex_int_3F__1 (void);
static void mw_oct_int_3F__1 (void);
static void mw_hexdigit_value_1 (void);
static void mw_lexer_emit_string_21__1 (void);
static void mw_lexer_push_string_byte_21__1 (void);
static void mw_lexer_push_string_escape_byte_21__1 (void);
static void mw_lexer_skip_comment_21__1 (void);
static void mw_lexer_skip_doc_21__1 (void);
static void mw_lexer_comment_end_3F__1 (void);
static void mw_lexer_peek_1 (void);
static void mw_lexer_move_21__1 (void);
static void mw_lexer_location_1 (void);
static void mw_lexer_emit_warning_21__1 (void);
static void mw_lexer_emit_fatal_error_21__1 (void);
static void mw_type_elab_default_1 (void);
static void mw_type_elab_stack_assertion_1 (void);
static void mw_type_elab_holes_allowed_1 (void);
static void mw_type_elab_ctx_1 (void);
static void mw_type_elab_ctx_3F__1 (void);
static void mw_type_elab_ctx_replace_1 (void);
static void mw_elab_type_sig_21__1 (void);
static void mw_elab_type_sig_params_21__1 (void);
static void mw_elab_type_stack_21__1 (void);
static void mw_elab_type_stack_rest_21__1 (void);
static void mw_elab_type_arg_21__1 (void);
static void mw_cons_4 (void);
static void mw_elab_type_atom_21__1 (void);
static void mw_elab_stack_label_21__1 (void);
static void mw_elab_stack_var_21__1 (void);
static void mw_elab_type_var_21__1 (void);
static void mw_elab_resource_var_21__1 (void);
static void mw_elab_implicit_var_21__1 (void);
static void mw_elab_type_con_21__1 (void);
static void mw_elab_resource_con_21__1 (void);
static void mw_elab_type_args_21__1 (void);
static void mw_elab_type_hole_21__1 (void);
static void mw_elab_type_dont_care_21__1 (void);
static void mw_elab_type_quote_21__1 (void);
static void mw_elab_type_unify_21__1 (void);
static void mw_elab_stack_type_unify_21__1 (void);
static void mw_elab_simple_type_arg_21__1 (void);
static void mw__2F_MKAB_1 (void);
static void mw_arrow_4 (void);
static void mw_arrow_21__1 (void);
static void mw_ab_token_40__1 (void);
static void mw_ab_token_21__1 (void);
static void mw_ab_type_40__1 (void);
static void mw_ab_type_21__1 (void);
static void mw_ab_ctx_40__1 (void);
static void mw_ab_home_40__1 (void);
static void mw_ab_build_21__1 (void);
static void mw_ab_build_hom_21__1 (void);
static void mw_ab_build_word_arrow_21__1 (void);
static void mw_ab_build_word_21__1 (void);
static void mw_ab_unify_type_21__1 (void);
static void mw_ab_atom_21__1 (void);
static void mw_ab_optimized_snoc_21__1 (void);
static void mw_atom_accepts_args_3F__1 (void);
static void mw_atoms_has_last_block_3F__1 (void);
static void mw_atoms_turn_last_block_to_arg_1 (void);
static void mw_ab_op_21__1 (void);
static void mw_ab_expand_opsig_21__1 (void);
static void mw_ab_int_21__1 (void);
static void mw_ab_str_21__1 (void);
static void mw_ab_buffer_21__1 (void);
static void mw_ab_variable_21__1 (void);
static void mw_ab_field_21__1 (void);
static void mw_ab_var_21__1 (void);
static void mw_ab_tag_21__1 (void);
static void mw_ab_prim_21__1 (void);
static void mw_ab_word_21__1 (void);
static void mw_ab_external_21__1 (void);
static void mw_ab_coerce_21__1 (void);
static void mw_ab_label_push_21__1 (void);
static void mw_ab_label_pop_21__1 (void);
static void mw_ab_block_at_21__1 (void);
static void mw_ab_block_21__1 (void);
static void mw_ab_dip_21__1 (void);
static void mw_ab_while_21__1 (void);
static void mw_ab_lambda_21__1 (void);
static void mw_ab_lambda_at_21__1 (void);
static void mw_elab_op_fresh_sig_21__1 (void);
static void mw_elab_coerce_sig_21__1 (void);
static void mw_elab_block_sig_21__1 (void);
static void mw_elab_match_sig_21__1 (void);
static void mw_elab_lambda_sig_21__1 (void);
static void mw_elab_var_sig_21__1 (void);
static void mw_elab_label_push_sig_21__1 (void);
static void mw_elab_label_pop_sig_21__1 (void);
static void mw_elab_arrow_hom_21__1 (void);
static void mw_elab_arrow_fwd_21__1 (void);
static void mw_elab_atoms_21__1 (void);
static void mw_elab_atom_21__1 (void);
static void mw_elab_atom_block_21__1 (void);
static void mw_elab_block_at_21__1 (void);
static void mw_elab_args_21__1 (void);
static void mw_elab_no_args_21__1 (void);
static void mw_elab_qname_is_imported_3F__1 (void);
static void mw_arity_compatible_3F__1 (void);
static void mw_elab_atom_name_21__1 (void);
static void mw_elab_atom_dname_21__1 (void);
static void mw_elab_atom_nonrelative_dname_21__1 (void);
static void mw_elab_relative_name_candidates_21__1 (void);
static void mw_elab_atom_relative_name_21__1 (void);
static void mw_elab_ambiguous_name_error_21__1 (void);
static void mw_elab_atom_qname_21__1 (void);
static void mw_elab_qname_is_visible_1 (void);
static void mw_elab_namespace_is_visible_1 (void);
static void mw_elab_tycon_is_visible_1 (void);
static void mw_elab_module_is_visible_1 (void);
static void mw_elab_stack_type_is_fine_3F__1 (void);
static void mw_elab_atom_def_21__1 (void);
static void mw_elab_atom_unknown_word_21__1 (void);
static void mw_elab_atom_not_visible_21__1 (void);
static void mw_elab_prim_21__1 (void);
static void mw_elab_atom_assert_21__1 (void);
static void mw_elab_atom_match_21__1 (void);
static void mw_elab_match_at_21__1 (void);
static void mw_elab_match_cases_21__1 (void);
static void mw_elab_match_case_21__1 (void);
static void mw_pat_tokens_1 (void);
static void mw_elab_pattern_21__1 (void);
static void mw_elab_pattern_atom_21__1 (void);
static void mw_ab_match_21__1 (void);
static void mw_case_21__1 (void);
static void mw_elab_expand_tensor_21__1 (void);
static void mw_elab_lambda_param_3F__1 (void);
static void mw_elab_atom_lambda_21__1 (void);
static void mw_elab_match_exhaustive_21__1 (void);
static void mw_elab_module_21__1 (void);
static void mw_elab_module_package_name_1 (void);
static void mw_elab_module_qname_1 (void);
static void mw_elab_module_header_21__1 (void);
static void mw_check_module_path_1 (void);
static void mw_elab_module_decl_21__1 (void);
static void mw_load_module_1 (void);
static void mw_elab_module_import_21__1 (void);
static void mw_elab_data_21__1 (void);
static void mw_elab_data_header_21__1 (void);
static void mw_elab_data_tag_21__1 (void);
static void mw_data_word_new_21__1 (void);
static void mw_elab_data_done_21__1 (void);
static void mw_output_type_1 (void);
static void mw_project_input_label_1 (void);
static void mw_data_get_label_type_1 (void);
static void mw_data_set_label_type_1 (void);
static void mw_create_projectors_21__1 (void);
static void mw_expect_token_arrow_1 (void);
static void mw_token_def_args_1 (void);
static void mw_elab_alias_21__1 (void);
static void mw_elab_def_missing_21__1 (void);
static void mw_prefer_inline_defs_3F__1 (void);
static void mw_elab_inline_21__1 (void);
static void mw_elab_def_21__1 (void);
static void mw_elab_def_params_21__1 (void);
static void mw_elab_def_body_21__1 (void);
static void mw_elab_def_external_21__1 (void);
static void mw_elab_def_type_21__1 (void);
static void mw_elab_buffer_21__1 (void);
static void mw_elab_variable_21__1 (void);
static void mw_elab_table_21__1 (void);
static void mw_elab_entry_point_1 (void);
static void mw_elab_embed_str_21__1 (void);
static void mw_typecheck_everything_21__1 (void);
static void mw_TABLE_5F_MAX_5F_COUNT_1 (void);
static void mw_table_qname_1 (void);
static void mw_table_word_new_21__1 (void);
static void mw_table_new_21__1 (void);
static void mw_elab_qname_from_nonrelative_dname_1 (void);
static void mw_module_visible_from_token_3F__1 (void);
static void mw_def_visible_from_token_3F__1 (void);
static void mw_elab_tycon_1 (void);
static void mw_elab_tycon_qname_1 (void);
static void mw_elab_absolute_namespace_1 (void);
static void mw_elab_absolute_qname_1 (void);
static void mw_elab_def_qname_1 (void);
static void mw_elab_def_qname_undefined_1 (void);
static void mw_elab_field_21__1 (void);
static void mw_field_new_21__1 (void);
static void mw_value_2 (void);
static void mw_key_2 (void);
static void mw_empty_1 (void);
static void mw_insert_1 (void);
static void mw_run_specializer_21__1 (void);
static void mw_checklist_2 (void);
static void mw_checklist_21__1 (void);
static void mw_begin_21__1 (void);
static void mw_end_21__3 (void);
static void mw_loop_21__1 (void);
static void mw_do_item_check_21__1 (void);
static void mw_check_arrow_21__1 (void);
static void mw_check_atom_21__1 (void);
static void mw_check_arg_21__1 (void);
static void mw_check_prim_atom_21__1 (void);
static void mw_check_word_atom_21__1 (void);
static void mw_check_match_21__1 (void);
static void mw_check_case_21__1 (void);
static void mw_check_lambda_21__1 (void);
static void mw_push_check_word_21__1 (void);
static void mw_push_check_block_21__1 (void);
static void mw__2F_SPKEY_1 (void);
static void mw__3D__3D__27 (void);
static void mw__3E_Str_2 (void);
static void mw__3E_Name_2 (void);
static void mw_sp_synthed_1 (void);
static void mw_specialize_word_21__1 (void);
static void mw_specialize_ctx_type_1 (void);
static void mw__2F__2B_SPSYNTH_1 (void);
static void mw_spmap_2 (void);
static void mw_synth_specialized_word_21__1 (void);
static void mw_synth_arrow_21__1 (void);
static void mw_synth_atom_21__1 (void);
static void mw_synth_arg_21__1 (void);
static void mw_synth_op_21__1 (void);
static void mw_synth_block_21__1 (void);
static void mw_synth_run_21__1 (void);
static void mw_synth_var_21__1 (void);
static void mw_synth_match_21__1 (void);
static void mw_synth_lambda_21__1 (void);
static void mw_OUTPUT_5F_BUFFER_5F_SIZE_1 (void);
static void mw__OUTPUT_1 (void);
static void mw_start_21__1 (void);
static void mw_end_21__1 (void);
static void mw_offset_40__1 (void);
static void mw_size_40__1 (void);
static void mw_size_21__1 (void);
static void mw_flush_21__1 (void);
static void mw_capacity_total_1 (void);
static void mw_capacity_remaining_1 (void);
static void mw_full_3F__1 (void);
static void mw_put_2 (void);
static void mw_put_byte_1 (void);
static void mw_line_2 (void);
static void mw__SET_1 (void);
static void mw_index_2 (void);
static void mw_SET_5F_INITIAL_5F_SIZE_1 (void);
static void mw_rdrop_1 (void);
static void mw_offset_mask_1 (void);
static void mw_member_3F__1 (void);
static void mw_insert_21__1 (void);
static void mw__3E_Int_16 (void);
static void mw__NEEDS_1 (void);
static void mw_new_3 (void);
static void mw_rdrop_3 (void);
static void mw_needed_3F__2 (void);
static void mw_needed_3F__1 (void);
static void mw_needed_3F__3 (void);
static void mw_word_needed_3F__1 (void);
static void mw_pat_needed_3F__1 (void);
static void mw_need_21__1 (void);
static void mw_need_word_21__1 (void);
static void mw_need_block_21__1 (void);
static void mw_need_tag_word_21__1 (void);
static void mw_need_tag_pat_21__1 (void);
static void mw_determine_arrow_needs_21__1 (void);
static void mw_determine_transitive_needs_21__1 (void);
static void mw_run_need_21__1 (void);
static void mw_run_arg_21__1 (void);
static void mw_run_block_21__1 (void);
static void mw_run_word_21__1 (void);
static void mw_run_arrow_21__1 (void);
static void mw_run_atom_21__1 (void);
static void mw_run_op_21__1 (void);
static void mw_run_prim_21__1 (void);
static void mw_run_match_21__1 (void);
static void mw_run_case_21__1 (void);
static void mw_run_lambda_21__1 (void);
static void mw_run_pattern_21__1 (void);
static void mw_run_patatom_21__1 (void);
static void mw_push_args_21__1 (void);
static void mw_push_arg_21__1 (void);
static void mw_push_block_21__1 (void);
static void mw_as_relative_path_1 (void);
static void mw__3E_Bool_2 (void);
static void mw_make_1 (void);
static void mw_emit_debug_info_3 (void);
static void mw_output_path_1 (void);
static void mw__2F_MKC99_1 (void);
static void mw_depth_40__1 (void);
static void mw_depth_21__1 (void);
static void mw_options_40__1 (void);
static void mw_emit_debug_info_3F__1 (void);
static void mw_put_3 (void);
static void mw_put_byte_2 (void);
static void mw_line_3 (void);
static void mw_c99_start_21__1 (void);
static void mw_c99_end_21__1 (void);
static void mw_run_output_c99_21__1 (void);
static void mw_cname_7 (void);
static void mw_word_cname_1 (void);
static void mw_pat_cname_1 (void);
static void mw_cname_6 (void);
static void mw_cname_2 (void);
static void mw_cname_3 (void);
static void mw_cname_5 (void);
static void mw_cname_4 (void);
static void mw_sig_put_1 (void);
static void mw_c99_header_str_1 (void);
static void mw_c99_header_21__1 (void);
static void mw_c99_buffers_21__1 (void);
static void mw_c99_buffer_21__1 (void);
static void mw_c99_variables_21__1 (void);
static void mw_c99_variable_21__1 (void);
static void mw_c99_tag_defs_21__1 (void);
static void mw_c99_tag_def_21__1 (void);
static void mw_c99_tag_label_index_1 (void);
static void mw_c99_tag_get_label_21__1 (void);
static void mw_c99_tag_set_label_21__1 (void);
static void mw_c99_externals_21__1 (void);
static void mw_c99_external_21__1 (void);
static void mw_c99_nest_1 (void);
static void mw_indent_1 (void);
static void mw_c99_line_1 (void);
static void mw_c99_call_21__1 (void);
static void mw_c99_arrow_21__1 (void);
static void mw_c99_atom_21__1 (void);
static void mw_c99_args_op_21__1 (void);
static void mw_c99_word_21__1 (void);
static void mw_value_show_1 (void);
static void mw_c99_tag_word_21__1 (void);
static void mw_c99_tag_case_pat_21__1 (void);
static void mw_c99_label_defs_21__1 (void);
static void mw_c99_label_def_21__1 (void);
static void mw_c99_label_push_21__1 (void);
static void mw_c99_label_pop_21__1 (void);
static void mw_c99_int_21__1 (void);
static void mw_c99_str_21__1 (void);
static void mw_put_cstr_long_1 (void);
static void mw_put_cstr_1 (void);
static void mw_c99_string_byte_21__1 (void);
static void mw_c99_prim_21__1 (void);
static void mw_c99_prim_default_21__1 (void);
static void mw_c99_args_push_21__1 (void);
static void mw_c99_arg_push_21__1 (void);
static void mw_c99_arg_run_21__1 (void);
static void mw_c99_block_run_21__1 (void);
static void mw_var_put_1 (void);
static void mw_param_put_1 (void);
static void mw_c99_pack_closure_vars_21__1 (void);
static void mw_c99_unpack_closure_vars_21__1 (void);
static void mw_c99_decref_closure_vars_21__1 (void);
static void mw_c99_block_push_21__1 (void);
static void mw_c99_var_21__1 (void);
static void mw_c99_var_run_21__1 (void);
static void mw_c99_var_push_21__1 (void);
static void mw_c99_lambda_21__1 (void);
static void mw_c99_match_21__1 (void);
static void mw_c99_case_21__1 (void);
static void mw_c99_pattern_21__1 (void);
static void mw_c99_word_sigs_21__1 (void);
static void mw_c99_word_sig_21__1 (void);
static void mw_c99_block_sigs_21__1 (void);
static void mw_c99_block_sig_21__1 (void);
static void mw_c99_field_sigs_21__1 (void);
static void mw_c99_field_sig_21__1 (void);
static void mw_c99_block_enter_21__1 (void);
static void mw_c99_block_exit_21__1 (void);
static void mw_c99_block_defs_21__1 (void);
static void mw_c99_block_def_21__1 (void);
static void mw_c99_word_enter_21__1 (void);
static void mw_c99_word_exit_21__1 (void);
static void mw_c99_word_defs_21__1 (void);
static void mw_c99_word_def_21__1 (void);
static void mw_c99_field_defs_21__1 (void);
static void mw_c99_field_def_21__1 (void);
static void mw_c99_main_21__1 (void);
static void mw_init_21__1 (void);
static void mw__2F_Arguments_1 (void);
static void mw_emit_debug_info_21__1 (void);
static void mw_packages_2 (void);
static void mw_packages_21__1 (void);
static void mw_entry_point_2 (void);
static void mw_entry_point_21__1 (void);
static void mw_output_file_2 (void);
static void mw_output_file_21__1 (void);
static void mw_input_file_2 (void);
static void mw_input_file_21__1 (void);
static void mw_default_1 (void);
static void mw_compile_21__1 (void);
static void mw_parse_package_def_1 (void);
static void mw_compiler_parse_args_1 (void);
static void mw_main_2 (void);
static void mw_filter_2_2225 (void);
static void mw_reverse_for_2_2226 (void);
static void mw_dip2_1_2226 (void);
static void mw_filter_3_2225 (void);
static void mw_for_3_2120 (void);
static void mw_reverse_find_some_2_2334 (void);
static void mw_find_some_aux2_1_2334 (void);
static void mw_filter_2_2215 (void);
static void mw_for_3_2216 (void);
static void mw_filter_3_2215 (void);
static void mw_reverse_for_2_2193 (void);
static void mw_dip2_1_2193 (void);
static void mw_reverse_for_2_2191 (void);
static void mw_dip2_1_2191 (void);
static void mw_find_some_2_2366 (void);
static void mw_find_some_aux2_1_2366 (void);
static void mw_find_some_2_2373 (void);
static void mw_find_some_aux2_1_2373 (void);
static void mw_for_3_2183 (void);
static void mw_filter_2_946 (void);
static void mw_filter_3_946 (void);
static void mw_find_some_2_2396 (void);
static void mw_find_some_aux2_1_2396 (void);
static void mw_for_3_736 (void);
static void mw_filter_2_1364 (void);
static void mw_find_some_2_2430 (void);
static void mw_find_some_aux2_1_2430 (void);
static void mw_filter_3_1364 (void);
static void mw_for_3_2119 (void);
static void mw_filter_2_2219 (void);
static void mw_reverse_for_2_2222 (void);
static void mw_dip2_1_2222 (void);
static void mw_filter_3_2219 (void);
static void mw_fold_2_2489 (void);
static void mw_filter_2_2496 (void);
static void mw_filter_3_2496 (void);
static void mw_find_some_2_2506 (void);
static void mw_find_some_aux2_1_2506 (void);
static void mw_map_4_1298 (void);
static void mw_filter_2_2525 (void);
static void mw_filter_3_2525 (void);
static void mw_find_some_2_2535 (void);
static void mw_find_some_aux2_1_2535 (void);
static void mw_filter_2_2541 (void);
static void mw_filter_3_2541 (void);
static void mw_find_some_2_2551 (void);
static void mw_find_some_aux2_1_2551 (void);
static void mw_map_4_1305 (void);
static void mw_fold_2_2568 (void);
static void mw_filter_2_2575 (void);
static void mw_filter_3_2575 (void);
static void mw_find_some_2_2585 (void);
static void mw_find_some_aux2_1_2585 (void);
static void mw_map_4_1303 (void);
static void mw_fold_2_2602 (void);
static void mw_filter_2_2609 (void);
static void mw_filter_3_2609 (void);
static void mw_find_some_2_2619 (void);
static void mw_find_some_aux2_1_2619 (void);
static void mw_map_4_1300 (void);
static void mw_for_3_2051 (void);
static void mw_reverse_for_2_2037 (void);
static void mw_dip2_1_2037 (void);
static void mw_for_3_2273 (void);
static void mw_for_3_2283 (void);
static void mw_for_3_2284 (void);
static void mw_for_3_2280 (void);
static void mw_dip_27__1_1897 (void);
static void mw_flatmap_2_1897 (void);
static void mw_map_4_1913 (void);
static void mw_for_3_1905 (void);
static void mw_map_4_1906 (void);
static void mw_for_3_165 (void);
static void mw_for_3_163 (void);
static void mw_for_3_160 (void);
static void mw_for_3_1952 (void);
static void mw_find_some_2_2799 (void);
static void mw_find_some_aux2_1_2799 (void);
static void mw_find_some_2_2808 (void);
static void mw_find_some_aux2_1_2808 (void);
static void mw_reverse_for_2_2817 (void);
static void mw_dip2_1_2817 (void);
static void mw_for_3_1963 (void);
static void mw_find_some_2_2834 (void);
static void mw_find_some_aux2_1_2834 (void);
static void mw_for_3_1238 (void);
static void mw_reverse_for_2_1966 (void);
static void mw_dip2_1_1966 (void);
static void mw_for_3_1954 (void);
static void mw_map_4_1945 (void);
static void mw_reverse_for_2_1938 (void);
static void mw_for_3_1925 (void);
static void mw_for_3_135 (void);
static void mw_find_some_2_2896 (void);
static void mw_find_some_aux2_1_2896 (void);
static void mw_find_some_2_2907 (void);
static void mw_find_some_aux2_1_2907 (void);
static void mw_find_some_2_2925 (void);
static void mw_find_some_aux2_1_2925 (void);
static void mw_find_some_2_2931 (void);
static void mw_find_some_aux2_1_2931 (void);
static void mw_for_3_1904 (void);
static void mw_for_3_181 (void);
static void mw_for_3_1891 (void);
static void mw_find_some_2_1886 (void);
static void mw_find_some_aux2_1_1886 (void);
static void mw_find_some_2_2994 (void);
static void mw_find_some_aux2_1_2994 (void);
static void mw_find_some_2_3018 (void);
static void mw_find_some_aux2_1_3018 (void);
static void mw_for_3_1798 (void);
static void mw_find_some_2_3029 (void);
static void mw_find_some_aux2_1_3029 (void);
static void mw_filter_2_1335 (void);
static void mw_map_4_1336 (void);
static void mw_filter_3_1335 (void);
static void mw_filter_some_1_1341 (void);
static void mw_filter_2_1342 (void);
static void mw_filter_3_1342 (void);
static void mw_filter_some_2_1341 (void);
static void mw_reverse_find_some_2_3075 (void);
static void mw_find_some_aux2_1_3075 (void);
static void mw_for_3_1511 (void);
static void mw_for_3_1515 (void);
static void mw_find_some_2_3092 (void);
static void mw_find_some_aux2_1_3092 (void);
static void mw_reverse_for_2_3158 (void);
static void mw_dip2_1_3158 (void);
static void mw_reverse_for_2_3168 (void);
static void mw_dip2_1_3168 (void);
static void mw_reverse_for_2_1710 (void);
static void mw_dip2_1_1710 (void);
static void mw_find_some_2_1718 (void);
static void mw_find_some_aux2_1_1718 (void);
static void mw_filter_2_3195 (void);
static void mw_filter_3_3195 (void);
static void mw_for_3_1653 (void);
static void mw_for_3_1664 (void);
static void mw_filter_2_1660 (void);
static void mw_filter_3_1660 (void);
static void mw_for_3_1659 (void);
static void mw_filter_2_1646 (void);
static void mw_filter_2_1647 (void);
static void mw_filter_3_1647 (void);
static void mw_filter_3_1646 (void);
static void mw_map_4_1645 (void);
static void mw_find_some_2_3244 (void);
static void mw_find_some_aux2_1_3244 (void);
static void mw_reverse_for_2_1864 (void);
static void mw_dip2_1_1864 (void);
static void mw_filter_2_1750 (void);
static void mw_map_4_1751 (void);
static void mw_filter_3_1750 (void);
static void mw_find_some_2_1735 (void);
static void mw_find_some_aux2_1_1735 (void);
static void mw_map_4_956 (void);
static void mw_for_3_152 (void);
static void mw_for_3_786 (void);
static void mw_for_3_304 (void);
static void mw_find_some_2_3317 (void);
static void mw_find_some_aux2_1_3317 (void);
static void mw_find_some_2_3326 (void);
static void mw_find_some_aux2_1_3326 (void);
static void mw_for_3_1039 (void);
static void mw_for_3_1315 (void);
static void mw_map_4_1311 (void);
static void mb_99 (void);
static void mb_169 (void);
static void mb_741 (void);
static void mb_931 (void);
static void mb_1587 (void);
static void mb_1588 (void);
static void mb_1590 (void);
static void mb_1591 (void);
static void mb_1593 (void);
static void mb_1594 (void);
static void mb_1624 (void);
static void mb_1638 (void);
static void mb_1652 (void);
static void mb_1708 (void);
static void mb_1749 (void);
static void mb_1767 (void);
static void mb_1770 (void);
static void mb_1771 (void);
static void mb_1786 (void);
static void mb_1791 (void);
static void mb_1813 (void);
static void mb_1828 (void);
static void mb_1831 (void);
static void mb_1832 (void);
static void mb_1833 (void);
static void mb_1834 (void);
static void mb_1835 (void);
static void mb_1836 (void);
static void mb_1839 (void);
static void mb_1840 (void);
static void mb_1841 (void);
static void mb_1842 (void);
static void mb_1843 (void);
static void mb_1844 (void);
static void mb_1845 (void);
static void mb_1846 (void);
static void mb_1847 (void);
static void mb_1848 (void);
static void mb_1849 (void);
static void mb_1850 (void);
static void mb_1851 (void);
static void mb_1855 (void);
static void mb_1880 (void);
static void mb_1881 (void);
static void mb_1882 (void);
static void mb_1883 (void);
static void mb_1884 (void);
static void mb_1894 (void);
static void mb_1895 (void);
static void mb_1924 (void);
static void mb_2029 (void);
static void mb_2031 (void);
static void mb_2032 (void);
static void mb_2043 (void);
static void mb_2044 (void);
static void mb_2074 (void);
static void mb_2077 (void);
static void mb_2080 (void);
static void mb_2081 (void);
static void mb_2085 (void);
static void mb_2086 (void);
static void mb_2087 (void);
static void mb_2095 (void);
static void mb_2785 (void);
static void mb_2879 (void);
static void mfld__7E_name_5 (void);
static void mfld__7E_package_1 (void);
static void mfld__7E_name_4 (void);
static void mfld__7E_path_2 (void);
static void mfld__7E_start_1 (void);
static void mfld__7E_end_1 (void);
static void mfld__7E_imports_1 (void);
static void mfld__7E_name_1 (void);
static void mfld__7E_type_2 (void);
static void mfld__7E_auto_run_3F__1 (void);
static void mfld__7E_head_6 (void);
static void mfld__7E_size_1 (void);
static void mfld__7E_qname_9 (void);
static void mfld__7E_qname_1 (void);
static void mfld__7E_head_1 (void);
static void mfld__7E_sig_1 (void);
static void mfld__7E_body_1 (void);
static void mfld__7E_arity_1 (void);
static void mfld__7E_ctx_type_1 (void);
static void mfld__7E_params_1 (void);
static void mfld__7E_arrow_1 (void);
static void mfld__7E_prefer_inline_3F__1 (void);
static void mfld__7E_cname_1 (void);
static void mfld__7E_head_4 (void);
static void mfld__7E_qname_5 (void);
static void mfld__7E_num_buffer_1 (void);
static void mfld__7E_max_count_1 (void);
static void mfld__7E_head_3 (void);
static void mfld__7E_qname_4 (void);
static void mfld__7E_index_type_1 (void);
static void mfld__7E_value_type_1 (void);
static void mfld__7E_head_3F__2 (void);
static void mfld__7E_qname_7 (void);
static void mfld__7E_arity_3 (void);
static void mfld__7E_tags_1 (void);
static void mfld__7E_data_1 (void);
static void mfld__7E_qname_8 (void);
static void mfld__7E_value_2 (void);
static void mfld__7E_label_inputs_1 (void);
static void mfld__7E_num_type_inputs_1 (void);
static void mfld__7E_num_resource_inputs_1 (void);
static void mfld__7E_sig_3F__1 (void);
static void mfld__7E_ctx_type_3 (void);
static void mfld__7E_untag_1 (void);
static void mfld__7E_ctx_2 (void);
static void mfld__7E_token_1 (void);
static void mfld__7E_home_1 (void);
static void mfld__7E_dom_1 (void);
static void mfld__7E_cod_1 (void);
static void mfld__7E_arrow_2 (void);
static void mfld__7E_qname_10 (void);
static void mfld__7E_free_vars_1 (void);
static void mfld__7E_head_3F__1 (void);
static void mfld__7E_qname_3 (void);
static void mfld__7E_target_1 (void);
static void mfld__7E_type_3F__1 (void);
static void mfld__7E_name_2 (void);
static void mfld__7E_ctx_1 (void);
static void mfld__7E_type_3 (void);
static void mfld__7E_decl_1 (void);
static void mfld__7E_arity_2 (void);
static void mfld__7E_value_1 (void);
static void mfld__7E_module_1 (void);
static void mfld__7E_row_1 (void);
static void mfld__7E_col_1 (void);
static void mfld__7E_head_7 (void);
static void mfld__7E_qname_11 (void);
static void mfld__7E_target_2 (void);
static void mfld__7E_qname_6 (void);
static void mfld__7E_symbol_1 (void);
static void mfld__7E_head_5 (void);
static void mfld__7E_sig_2 (void);
static void mfld__7E_ctx_type_2 (void);
static void mfld__7E_head_2 (void);
static void mfld__7E_qname_2 (void);
static void mfld__7E_type_1 (void);
static void mfld__7E_Str_1 (void);
static void mfld__7E_defs_1 (void);
static void mfld__7E_mangled_1 (void);
static void mfld__7E_label_1 (void);
static void mfld__7E_name_3 (void);
static void mfld__7E_path_1 (void);
static void mfld__7E_sp_checked_1 (void);
static void mfld__7E_sp_checked_2 (void);
static void mfld__7E_sp_synthed_1 (void);
static void mfld__7E_cname_7 (void);
static void mfld__7E_word_cname_1 (void);
static void mfld__7E_pat_cname_1 (void);
static void mfld__7E_cname_6 (void);
static void mfld__7E_cname_2 (void);
static void mfld__7E_cname_3 (void);
static void mfld__7E_cname_5 (void);
static void mfld__7E_cname_4 (void);
static void mfld__7E_value_show_1 (void);
int main (int argc, char** argv) {
	global_argc = argc;
	global_argv = argv;
	push_resource(MKU64(0));
	mw_main_2();
	return 0;
}
static void mfld__7E_name_5 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_package_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_name_4 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_path_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_start_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_end_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_imports_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_name_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_type_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_auto_run_3F__1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_6 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_size_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_9 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_sig_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_body_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_arity_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_ctx_type_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_params_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_arrow_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_prefer_inline_3F__1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_4 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_5 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_num_buffer_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_max_count_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_4 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_index_type_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_value_type_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_3F__2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_7 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_arity_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_tags_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_data_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_8 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_value_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_label_inputs_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_num_type_inputs_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_num_resource_inputs_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_sig_3F__1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_ctx_type_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_untag_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_ctx_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_token_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_home_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_dom_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cod_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_arrow_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_10 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_free_vars_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_3F__1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_target_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_type_3F__1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_name_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_ctx_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_type_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_decl_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_arity_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_value_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_module_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_row_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_col_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_7 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_11 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_target_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_6 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_symbol_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_5 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_sig_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_ctx_type_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_head_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_qname_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_type_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_Str_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_defs_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_mangled_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_label_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_name_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_path_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_sp_checked_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_sp_checked_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_sp_synthed_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_7 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_word_cname_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_pat_cname_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_6 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_2 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_3 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_5 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_cname_4 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld__7E_value_show_1 (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 131072;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mw__2F_L1_1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // L1
			mtp_L1_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_empty_3F__4 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_L4_2B__1 (void) {
	mtw_L2_2B__1();
	{
		VAL d2 = pop_value();
		mtw_L2_2B__1();
		push_value(d2);
	}
	push_i64(4LL);
	mw__3E_Nat_1();
	mtw_LCAT_2B__1();
}
static void mw_L5_2B__1 (void) {
	mtw_L3_2B__1();
	{
		VAL d2 = pop_value();
		mtw_L2_2B__1();
		push_value(d2);
	}
	push_i64(5LL);
	mw__3E_Nat_1();
	mtw_LCAT_2B__1();
}
static void mw_L6_2B__1 (void) {
	mtw_L3_2B__1();
	{
		VAL d2 = pop_value();
		mtw_L3_2B__1();
		push_value(d2);
	}
	push_i64(6LL);
	mw__3E_Nat_1();
	mtw_LCAT_2B__1();
}
static void mw__3E_List_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mtw_L1_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mtw_L2_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mtw_L3_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mtw_LCAT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3E_List_2B__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // L1
			mtp_L1_1();
			mtw_L1_2B__1();
			mtw_SOME_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mtw_L2_2B__1();
			mtw_SOME_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mtw_L3_2B__1();
			mtw_SOME_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mtw_LCAT_2B__1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_empty_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_len_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_i64(0LL);
			mw__3E_Nat_1();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mp_prim_drop();
			push_i64(1LL);
			mw__3E_Nat_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mw_drop2_1();
			push_i64(2LL);
			mw__3E_Nat_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_drop3_1();
			push_i64(3LL);
			mw__3E_Nat_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_len_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_drop();
			push_i64(1LL);
			mw__3E_Nat_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_drop2_1();
			push_i64(2LL);
			mw__3E_Nat_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_drop3_1();
			push_i64(3LL);
			mw__3E_Nat_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cons_2B__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mtw_L1_2B__1();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mtw_L2_2B__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_L4_2B__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mw_1_2B__2();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_cons_2B__2();
					push_value(d5);
				}
				mw_rebalance_1();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_snoc_2B__1 (void) {
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mtw_L1_2B__1();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mw_rotl_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_rot4l_1();
			mw_L4_2B__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mw_1_2B__2();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_snoc_2B__2B__1();
				mw_rebalance_1();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cons_2B__2 (void) {
	mw__3E_List_2();
	mw_cons_2B__1();
}
static void mw_cons_2 (void) {
	mw_cons_2B__1();
	mw__3E_List_2();
}
static void mw_snoc_2B__2B__1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_List_2();
		push_value(d2);
	}
	mw_snoc_2B__1();
}
static void mw_snoc_1 (void) {
	mw_snoc_2B__1();
	mw__3E_List_2();
}
static void mw_uncons_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			push_u64(0LL); // L0
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mtw_L1_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mtw_L2_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_uncons_2();
				push_value(d4);
			}
			mw_cat_3();
			mw__3E_List_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_unsnoc_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // L0
				push_value(d4);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mtw_L1_1();
				push_value(d4);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				mtw_L2_1();
				push_value(d4);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mw_unsnoc_1();
			{
				VAL d4 = pop_value();
				mw_cat_2B__1();
				mw__3E_List_2();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cat_2 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_cat_3();
			mw__3E_List_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cat_3 (void) {
	mp_prim_swap();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_swap();
			mw_cat_2B__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cat_2B__1 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_cat_2B__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cat_2B__2 (void) {
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			mw_cons_2B__2();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_rotl_1();
			switch (get_top_data_tag()) {
				case 0LL: // L1+
					mtp_L1_2B__1();
					mtw_L3_2B__1();
					break;
				case 1LL: // L2+
					mtp_L2_2B__1();
					mw_L4_2B__1();
					break;
				case 2LL: // L3+
					mtp_L3_2B__1();
					mw_L5_2B__1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_L2_2B__1();
						push_value(d6);
					}
					mw_cat_aux_1();
					break;
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rot4l_1();
			switch (get_top_data_tag()) {
				case 0LL: // L1+
					mtp_L1_2B__1();
					mw_L4_2B__1();
					break;
				case 1LL: // L2+
					mtp_L2_2B__1();
					mw_L5_2B__1();
					break;
				case 2LL: // L3+
					mtp_L3_2B__1();
					mw_L6_2B__1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_L3_2B__1();
						push_value(d6);
					}
					mw_cat_aux_1();
					break;
			}
			break;
		default:
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // L1+
					mtp_L1_2B__1();
					mw_snoc_2B__2B__1();
					break;
				default:
					mw_cat_aux_1();
					break;
			}
			break;
	}
}
static void mw_cat_aux_1 (void) {
	mw_rebalance_1();
	mw_dup2_1();
	{
		VAL d2 = pop_value();
		mw_len_2();
		push_value(d2);
	}
	mw_len_2();
	mw__2B__2();
	mtw_LCAT_2B__1();
}
static void mw_rebalance_1 (void) {
	mw_dup2_1();
	{
		VAL d2 = pop_value();
		mw_len_2();
		push_value(d2);
	}
	mw_len_2();
	mw_dup2_1();
	push_i64(6LL);
	mw__3E_Nat_1();
	mw__2A__2();
	mw__3E__3();
	if (pop_u64()) {
		mw_drop2_1();
		{
			VAL d3 = pop_value();
			mw_split_half_left_1();
			push_value(d3);
		}
		mw_cat_3();
		mw_rebalance_1();
	} else {
		{
			VAL d3 = pop_value();
			push_i64(6LL);
			mw__3E_Nat_1();
			mw__2A__2();
			push_value(d3);
		}
		mw__3C__3();
		if (pop_u64()) {
			mw_split_half_right_1();
			{
				VAL d4 = pop_value();
				mw_cat_2B__1();
				push_value(d4);
			}
			mw_rebalance_1();
		} else {
			mp_prim_id();
		}
	}
}
static void mw_split_half_left_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			push_u64(0LL); // L0
			{
				VAL d4 = pop_value();
				mtw_L1_2B__1();
				push_value(d4);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mtw_L1_1();
			{
				VAL d4 = pop_value();
				mtw_L1_2B__1();
				push_value(d4);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mtw_L1_1();
			{
				VAL d4 = pop_value();
				mtw_L2_2B__1();
				push_value(d4);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mw__3E_List_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_split_half_right_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mtw_L1_2B__1();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // L0
				push_value(d4);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mtw_L1_2B__1();
			{
				VAL d4 = pop_value();
				mtw_L1_1();
				push_value(d4);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mtw_L2_2B__1();
			{
				VAL d4 = pop_value();
				mtw_L1_1();
				push_value(d4);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw__3E_List_2();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_first_1 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_first_2();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_last_1 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_last_2();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_first_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_id();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_drop();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_drop2_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mw_drop2_1();
			mw_first_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_last_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_id();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mp_prim_drop();
				push_value(d4);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mw_nip_1();
			mw_last_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_for_1 (void) {
	{
		VAL var_f = pop_value();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				incref(var_f);
				run_value(var_f);
				break;
			case 2LL: // L2
				mtp_L2_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					incref(var_f);
					run_value(var_f);
					push_value(d5);
				}
				incref(var_f);
				run_value(var_f);
				break;
			case 3LL: // L3
				mtp_L3_1();
				mw_rotr_1();
				incref(var_f);
				push_value(var_f);
				mw_dip2_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					incref(var_f);
					run_value(var_f);
					push_value(d5);
				}
				incref(var_f);
				run_value(var_f);
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					incref(var_f);
					push_value(var_f);
					mw_reverse_for_2();
					push_value(d5);
				}
				incref(var_f);
				push_value(var_f);
				mw_reverse_for_2();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		decref(var_f);
	}
}
static void mw_reverse_for_2 (void) {
	{
		VAL var_f = pop_value();
		switch (get_top_data_tag()) {
			case 0LL: // L1+
				mtp_L1_2B__1();
				incref(var_f);
				run_value(var_f);
				break;
			case 1LL: // L2+
				mtp_L2_2B__1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					incref(var_f);
					run_value(var_f);
					push_value(d5);
				}
				incref(var_f);
				run_value(var_f);
				break;
			case 2LL: // L3+
				mtp_L3_2B__1();
				mw_rotr_1();
				incref(var_f);
				push_value(var_f);
				mw_dip2_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					incref(var_f);
					run_value(var_f);
					push_value(d5);
				}
				incref(var_f);
				run_value(var_f);
				break;
			case 3LL: // LCAT+
				mtp_LCAT_2B__1();
				mp_prim_drop();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					incref(var_f);
					push_value(var_f);
					mw_reverse_for_2();
					push_value(d5);
				}
				incref(var_f);
				push_value(var_f);
				mw_reverse_for_2();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		decref(var_f);
	}
}
static void mw__LIST_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +LIST
			mtp__2B_LIST_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3B__2 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +LIST
			mtp__2B_LIST_1();
			mp_prim_swap();
			mw_snoc_1();
			mtw__2B_LIST_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_uncons_3F__1 (void) {
	mp_prim_dup();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			mp_prim_swap();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mtw_SOME_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_none_3F__1 (void) {
	mw__3E_Bool_1();
	mw_not_1();
}
static void mw_some_3F__1 (void) {
	mw__3E_Bool_1();
}
static void mw__3E_Bool_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_unwrap_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("tried to unwrap NONE", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_zip_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_swap();
					mw_pack2_1();
					mtw_SOME_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__2F__25__1 (void) {
	mw_dup2_1();
	mp_prim_int_mod();
	{
		VAL d2 = pop_value();
		mp_prim_int_div();
		push_value(d2);
	}
}
static void mw__26__26__1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__7C__7C__1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_not_1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 0LL: // F
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_then_1 (void) {
	{
		VAL var_f = pop_value();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				incref(var_f);
				run_value(var_f);
				break;
			case 0LL: // F
				(void)pop_u64();
				mp_prim_id();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		decref(var_f);
	}
}
static void mw_else_1 (void) {
	{
		VAL var_f = pop_value();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				incref(var_f);
				run_value(var_f);
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		decref(var_f);
	}
}
static void mw__3E_OS_1 (void) {
	mp_prim_dup();
	push_i64(1LL);
	mp_prim_int_eq();
	if (pop_u64()) {
		mp_prim_drop();
		push_u64(1LL); // OS_WINDOWS
	} else {
		mp_prim_dup();
		push_i64(2LL);
		mp_prim_int_eq();
		if (pop_u64()) {
			mp_prim_drop();
			push_u64(2LL); // OS_LINUX
		} else {
			mp_prim_dup();
			push_i64(3LL);
			mp_prim_int_eq();
			if (pop_u64()) {
				mp_prim_drop();
				push_u64(3LL); // OS_MACOS
			} else {
				mp_prim_drop();
				push_u64(0LL); // OS_UNKNOWN
			}
		}
	}
}
static void mw_RUNNING_5F_OS_1 (void) {
	mp_prim_sys_os();
	mw__3E_OS_1();
}
static void mw_rotr_1 (void) {
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
}
static void mw_rotl_1 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
	mp_prim_swap();
}
static void mw_over_1 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		push_value(d2);
	}
	mp_prim_swap();
}
static void mw_over2_1 (void) {
	{
		VAL d2 = pop_value();
		mw_over_1();
		push_value(d2);
	}
	mp_prim_swap();
}
static void mw_over3_1 (void) {
	{
		VAL d2 = pop_value();
		mw_over2_1();
		push_value(d2);
	}
	mp_prim_swap();
}
static void mw_tuck_1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
}
static void mw_nip_1 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_drop();
		push_value(d2);
	}
}
static void mw_dup2_1 (void) {
	mw_over_1();
	mw_over_1();
}
static void mw_dip2_1 (void) {
	{
		VAL var_f = pop_value();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				incref(var_f);
				run_value(var_f);
				push_value(d4);
			}
			push_value(d3);
		}
		decref(var_f);
	}
}
static void mw_sip_1 (void) {
	{
		VAL var_f = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			incref(var_f);
			run_value(var_f);
			push_value(d3);
		}
		decref(var_f);
	}
}
static void mw_drop2_1 (void) {
	mp_prim_drop();
	mp_prim_drop();
}
static void mw_drop3_1 (void) {
	mp_prim_drop();
	mp_prim_drop();
	mp_prim_drop();
}
static void mw_drop4_1 (void) {
	mp_prim_drop();
	mp_prim_drop();
	mp_prim_drop();
	mp_prim_drop();
}
static void mw_rot4r_1 (void) {
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_rotr_1();
		push_value(d2);
	}
}
static void mw_rot4l_1 (void) {
	{
		VAL d2 = pop_value();
		mw_rotl_1();
		push_value(d2);
	}
	mp_prim_swap();
}
static void mw_U8_5F_MAX_1 (void) {
	push_i64(255LL);
}
static void mw_U8_5F_MIN_1 (void) {
	push_i64(0LL);
}
static void mw_is_eq_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // LT
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // EQ
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 2LL: // GT
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_le_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // LT
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 1LL: // EQ
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 2LL: // GT
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_ne_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // LT
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 1LL: // EQ
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 2LL: // GT
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3E__1 (void) {
	mp_prim_swap();
	mp_prim_int_lt();
}
static void mw__3E__3D__1 (void) {
	mp_prim_int_lt();
	mw_not_1();
}
static void mw__3C__3D__1 (void) {
	mp_prim_swap();
	mp_prim_int_lt();
	mw_not_1();
}
static void mw__3C__3E__1 (void) {
	mp_prim_int_eq();
	mw_not_1();
}
static void mw_compare_1 (void) {
	mw_dup2_1();
	mp_prim_int_eq();
	if (pop_u64()) {
		mw_drop2_1();
		push_u64(1LL); // EQ
	} else {
		mp_prim_int_lt();
		if (pop_u64()) {
			push_u64(0LL); // LT
		} else {
			push_u64(2LL); // GT
		}
	}
}
static void mw_in_range_1 (void) {
	{
		VAL d2 = pop_value();
		mw_over_1();
		{
			VAL d3 = pop_value();
			mw__3E__3D__1();
			push_value(d3);
		}
		push_value(d2);
	}
	mw__3C__3D__1();
	mw__26__26__1();
}
static void mw_compare_2 (void) {
	mp_prim_str_cmp();
	push_i64(0LL);
	mw_compare_1();
}
static void mw__3D__3D__7 (void) {
	mw_compare_2();
	mw_is_eq_1();
}
static void mw__3C__3E__2 (void) {
	mw_compare_2();
	mw_is_ne_1();
}
static void mw_prim_int_succ_1 (void) {
	push_i64(1LL);
	mp_prim_int_add();
}
static void mw_prim_int_pred_1 (void) {
	push_i64(1LL);
	mp_prim_int_sub();
}
static void mw_2_2A__1 (void) {
	push_i64(2LL);
	mp_prim_int_mul();
}
static void mw_0_3D__1 (void) {
	push_i64(0LL);
	mp_prim_int_eq();
}
static void mw_0_3C__1 (void) {
	push_i64(0LL);
	mp_prim_int_lt();
}
static void mw_0_3E__1 (void) {
	push_i64(0LL);
	mw__3E__1();
}
static void mw_sizeof_1 (void) {
	mp_prim_ptr_size();
	mw__3E_Size_1();
}
static void mw__UNSAFE_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +UNSAFE
			(void)pop_resource();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_offset_1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mp_prim_ptr_add();
}
static void mw__40_Ptr_1 (void) {
	mp_prim_ptr_get();
}
static void mw__40_U8_1 (void) {
	mp_prim_u8_get();
}
static void mw__40_I64_1 (void) {
	mp_prim_i64_get();
}
static void mw__21_U8_1 (void) {
	mp_prim_u8_set();
}
static void mw__21_I64_1 (void) {
	mp_prim_i64_set();
}
static void mw_alloc_1 (void) {
	mw__3E_Int_11();
	mp_prim_ptr_alloc();
}
static void mw_realloc_1 (void) {
	mw__3E_Int_11();
	mp_prim_ptr_realloc();
}
static void mw_free_1 (void) {
	mp_prim_ptr_free();
}
static void mw_copy_1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_11();
		push_value(d2);
	}
	mp_prim_ptr_copy();
}
static void mw_fill_1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_11();
		{
			VAL d3 = pop_value();
			mw__3E_Int_7();
			push_value(d3);
		}
		push_value(d2);
	}
	mp_prim_ptr_fill();
}
static void mw_erase_1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			push_i64(0LL);
			mw__3E_U8_1();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_fill_1();
}
static void mw__3E_Int_7 (void) {
	mp_prim_id();
}
static void mw__3E_Int_3 (void) {
	mp_prim_id();
}
static void mw__3E_U8_unsafe_1 (void) {
}
static void mw__3E_U8_3F__1 (void) {
	mp_prim_dup();
	mw_U8_5F_MIN_1();
	mw_U8_5F_MAX_1();
	mw_in_range_1();
	if (pop_u64()) {
		mtw_SOME_1();
	} else {
		mp_prim_drop();
		push_u64(0LL); // NONE
	}
}
static void mw__3E_U8_1 (void) {
	mw__3E_U8_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("U8 out of bounds", 16);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3E_I64_1 (void) {
}
static void mw__7C__5 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_7();
		push_value(d2);
	}
	mw__3E_Int_7();
	mp_prim_int_or();
	mw__3E_U8_unsafe_1();
}
static void mw__26__5 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_7();
		push_value(d2);
	}
	mw__3E_Int_7();
	mp_prim_int_and();
	mw__3E_U8_unsafe_1();
}
static void mw__3E_Nat_unsafe_1 (void) {
}
static void mw__3E_Nat_1 (void) {
	mp_prim_dup();
	mw_0_3C__1();
	mw_not_1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("tried to create negative Nat", 28);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
		mp_prim_panic();
	}
	mw__3E_Nat_unsafe_1();
}
static void mw__3E_Int_8 (void) {
	mp_prim_id();
}
static void mw__2B__2 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mp_prim_int_add();
	mw__3E_Nat_unsafe_1();
}
static void mw___2 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mp_prim_int_sub();
	mw__3E_Nat_1();
}
static void mw__2A__2 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mp_prim_int_mul();
	mw__3E_Nat_unsafe_1();
}
static void mw_1_2B__2 (void) {
	mw__3E_Int_8();
	mw_prim_int_succ_1();
	mw__3E_Nat_unsafe_1();
}
static void mw_1__2 (void) {
	mw__3E_Int_8();
	mw_prim_int_pred_1();
	mw__3E_Nat_1();
}
static void mw_2_2A__2 (void) {
	mw__3E_Int_8();
	mw_2_2A__1();
	mw__3E_Nat_unsafe_1();
}
static void mw__3D__3D__12 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mp_prim_int_eq();
}
static void mw__3C__3 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mp_prim_int_lt();
}
static void mw__3E__3 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mw__3E__1();
}
static void mw__3C__3D__3 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mw__3C__3D__1();
}
static void mw__3E__3D__3 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_8();
		push_value(d2);
	}
	mw__3E_Int_8();
	mw__3E__3D__1();
}
static void mw_0_3E__2 (void) {
	mw__3E_Int_8();
	mw_0_3E__1();
}
static void mw_0_3D__2 (void) {
	mw__3E_Int_8();
	mw_0_3D__1();
}
static void mw__3E_Size_2 (void) {
}
static void mw__3E_Nat_7 (void) {
	mp_prim_id();
}
static void mw__3E_Int_11 (void) {
	mw__3E_Nat_7();
	mw__3E_Int_8();
}
static void mw__3E_Size_1 (void) {
	mw__3E_Nat_1();
	mw__3E_Size_2();
}
static void mw__2B__4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Nat_7();
		push_value(d2);
	}
	mw__3E_Nat_7();
	mw__2B__2();
	mw__3E_Size_2();
}
static void mw___4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Nat_7();
		push_value(d2);
	}
	mw__3E_Nat_7();
	mw___2();
	mw__3E_Size_2();
}
static void mw_1_2B__4 (void) {
	mw__3E_Nat_7();
	mw_1_2B__2();
	mw__3E_Size_2();
}
static void mw_1__4 (void) {
	mw__3E_Nat_7();
	mw_1__2();
	mw__3E_Size_2();
}
static void mw_2_2A__3 (void) {
	mw__3E_Nat_7();
	mw_2_2A__2();
	mw__3E_Size_2();
}
static void mw__3D__3D__15 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Nat_7();
		push_value(d2);
	}
	mw__3E_Nat_7();
	mw__3D__3D__12();
}
static void mw__3E__5 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Nat_7();
		push_value(d2);
	}
	mw__3E_Nat_7();
	mw__3E__3();
}
static void mw__3C__3D__5 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Nat_7();
		push_value(d2);
	}
	mw__3E_Nat_7();
	mw__3C__3D__3();
}
static void mw__3E__3D__5 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Nat_7();
		push_value(d2);
	}
	mw__3E_Nat_7();
	mw__3E__3D__3();
}
static void mw_0_3D__4 (void) {
	mw__3E_Nat_7();
	mw_0_3D__2();
}
static void mw_0_3E__4 (void) {
	mw__3E_Nat_7();
	mw_0_3E__2();
}
static void mw_max_5 (void) {
	mw_dup2_1();
	mw__3E__3D__5();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		mw_nip_1();
	}
}
static void mw_min_5 (void) {
	mw_dup2_1();
	mw__3C__3D__5();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		mw_nip_1();
	}
}
static void mw__3E_Offset_1 (void) {
}
static void mw__3E_Int_10 (void) {
	mp_prim_id();
}
static void mw__3E_Offset_2 (void) {
	mw__3E_Int_8();
	mw__3E_Offset_1();
}
static void mw__3E_Offset_3 (void) {
	mw__3E_Nat_7();
	mw__3E_Offset_2();
}
static void mw__3E_Nat_6 (void) {
	mw__3E_Int_10();
	mw__3E_Nat_1();
}
static void mw__3E_Size_3 (void) {
	mw__3E_Nat_6();
	mw__3E_Size_2();
}
static void mw__2B__3 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mp_prim_int_add();
	mw__3E_Offset_1();
}
static void mw___3 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mp_prim_int_sub();
	mw__3E_Offset_1();
}
static void mw_1_2B__3 (void) {
	mw__3E_Int_10();
	mw_prim_int_succ_1();
	mw__3E_Offset_1();
}
static void mw_1__3 (void) {
	mw__3E_Int_10();
	mw_prim_int_pred_1();
	mw__3E_Offset_1();
}
static void mw__3D__3D__14 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mp_prim_int_eq();
}
static void mw__3E__4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mw__3E__1();
}
static void mw__3C__4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mp_prim_int_lt();
}
static void mw__3E__3D__4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mw__3E__3D__1();
}
static void mw__3C__3D__4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_10();
	mw__3C__3D__1();
}
static void mw_0_3C__2 (void) {
	mw__3E_Int_10();
	mw_0_3C__1();
}
static void mw_0_3E__3 (void) {
	mw__3E_Int_10();
	mw_0_3E__1();
}
static void mw_min_4 (void) {
	mw_dup2_1();
	mw__3C__3D__4();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		mw_nip_1();
	}
}
static void mw_pack1_1 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_pack_nil();
		push_value(d2);
	}
	mp_prim_pack_cons();
}
static void mw_pack2_1 (void) {
	{
		VAL d2 = pop_value();
		mw_pack1_1();
		push_value(d2);
	}
	mp_prim_pack_cons();
}
static void mw_pack3_1 (void) {
	{
		VAL d2 = pop_value();
		mw_pack2_1();
		push_value(d2);
	}
	mp_prim_pack_cons();
}
static void mw_unpack1_1 (void) {
	mp_prim_pack_uncons();
	mw_nip_1();
}
static void mw_unpack2_1 (void) {
	mp_prim_pack_uncons();
	{
		VAL d2 = pop_value();
		mw_unpack1_1();
		push_value(d2);
	}
}
static void mw_unpack3_1 (void) {
	mp_prim_pack_uncons();
	{
		VAL d2 = pop_value();
		mw_unpack2_1();
		push_value(d2);
	}
}
static void mw__40__3F__1 (void) {
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
		mtw_SOME_1();
	} else {
		mp_prim_drop();
		push_u64(0LL); // NONE
	}
}
static void mw_tag_5 (void) {
}
static void mw_from_tag_unsafe_5 (void) {
}
static void mw__3E_Int_12 (void) {
	mw_tag_5();
}
static void mw__3E_Byte_1 (void) {
	mp_prim_dup();
	push_i64(0LL);
	push_i64(255LL);
	mw_in_range_1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("Int->Byte out of range", 22);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("assertion failed: ", 18);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_swap();
		mp_prim_str_cat();
		mp_prim_panic();
	}
	mw_from_tag_unsafe_5();
}
static void mw__3E_U8_3 (void) {
	mw__3E_Int_12();
	mw__3E_U8_1();
}
static void mw__3E_Byte_2 (void) {
	mw__3E_Int_7();
	mw__3E_Byte_1();
}
static void mw__40_Byte_1 (void) {
	mw__40_U8_1();
	mw__3E_Byte_2();
}
static void mw__3D__3D__19 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_12();
		push_value(d2);
	}
	mw__3E_Int_12();
	mp_prim_int_eq();
}
static void mw__3E__6 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_12();
		push_value(d2);
	}
	mw__3E_Int_12();
	mw__3E__1();
}
static void mw_in_range_2 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw__3E_Int_12();
			push_value(d3);
		}
		mw__3E_Int_12();
		push_value(d2);
	}
	mw__3E_Int_12();
	mw_in_range_1();
}
static void mw_is_upper_1 (void) {
	push_u64(65LL); // B'A'
	push_u64(90LL); // B'Z'
	mw_in_range_2();
}
static void mw_is_lower_1 (void) {
	push_u64(97LL); // B'a'
	push_u64(122LL); // B'z'
	mw_in_range_2();
}
static void mw_is_digit_1 (void) {
	push_u64(48LL); // B'0'
	push_u64(57LL); // B'9'
	mw_in_range_2();
}
static void mw_is_alpha_1 (void) {
	mp_prim_dup();
	mw_is_upper_1();
	if (pop_u64()) {
		mp_prim_drop();
		push_u64(1LL); // T
	} else {
		mw_is_lower_1();
	}
}
static void mw_is_alnum_1 (void) {
	mp_prim_dup();
	mw_is_digit_1();
	if (pop_u64()) {
		mp_prim_drop();
		push_u64(1LL); // T
	} else {
		mw_is_alpha_1();
	}
}
static void mw_is_printable_1 (void) {
	push_u64(33LL); // B'!'
	push_u64(126LL); // B'~'
	mw_in_range_2();
}
static void mw_is_hexdigit_1 (void) {
	switch (get_top_data_tag()) {
		case 48LL: // B'0'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 49LL: // B'1'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 50LL: // B'2'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 51LL: // B'3'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 52LL: // B'4'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 53LL: // B'5'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 54LL: // B'6'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 55LL: // B'7'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 56LL: // B'8'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 57LL: // B'9'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 65LL: // B'A'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 66LL: // B'B'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 67LL: // B'C'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 68LL: // B'D'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 69LL: // B'E'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 70LL: // B'F'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_to_str_unsafe_1 (void) {
	mtw_L1_1();
	mw_from_bytes_unsafe_1();
}
static void mw_to_ascii_str_1 (void) {
	mp_prim_dup();
	push_u64(0LL); // BNUL
	push_u64(127LL); // BDEL
	mw_in_range_2();
	if (pop_u64()) {
		mw_to_str_unsafe_1();
		mtw_SOME_1();
	} else {
		mp_prim_drop();
		push_u64(0LL); // NONE
	}
}
static void mw_is_string_end_1 (void) {
	switch (get_top_data_tag()) {
		case 34LL: // BQUOTE
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 10LL: // BLF
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 0LL: // BNUL
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_to_hexdigits_1 (void) {
	mw__3E_Int_12();
	mp_prim_dup();
	push_i64(4LL);
	mp_prim_int_shr();
	mw_one_hexdigit_byte_1();
	mp_prim_swap();
	push_i64(15LL);
	mp_prim_int_and();
	mw_one_hexdigit_byte_1();
}
static void mw_one_hexdigit_byte_1 (void) {
	mp_prim_dup();
	push_i64(9LL);
	mw__3E__1();
	if (pop_u64()) {
		push_i64(55LL);
	} else {
		push_i64(48LL);
	}
	mp_prim_int_add();
	mw__3E_Byte_1();
}
static void mw_is_name_byte_1 (void) {
	switch (get_top_data_tag()) {
		case 40LL: // BLPAREN
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 41LL: // BRPAREN
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 91LL: // BLSQUARE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 93LL: // BRSQUARE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 123LL: // BLCURLY
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 125LL: // BRCURLY
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 44LL: // BCOMMA
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 34LL: // BQUOTE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 58LL: // BCOLON
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 127LL: // BDEL
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		default:
			push_u64(32LL); // BSPACE
			mw__3E__6();
			break;
	}
}
static void mw_is_sign_1 (void) {
	switch (get_top_data_tag()) {
		case 45LL: // B'-'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 43LL: // B'+'
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw__BUFFER_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +BUFFER
			mtp__2B_BUFFER_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_new_2 (void) {
	mp_prim_dup();
	mp_prim_dup();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_alloc_1();
	mw__UNSAFE_1();
	mtw__2B_BUFFER_1();
	push_i64(0LL);
	mw__3E_Offset_1();
	mp_prim_swap();
	mw_erase_span_21__1();
}
static void mw_resize_21__1 (void) {
	mw__BUFFER_1();
	{
		VAL d2 = pop_value();
		mw_over_1();
		mp_prim_dup();
		push_value(d2);
	}
	mp_prim_swap();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_realloc_1();
	mw__UNSAFE_1();
	mtw__2B_BUFFER_1();
	mw_dup2_1();
	mw__3E__3D__5();
	if (pop_u64()) {
		mw_tuck_1();
		mw___4();
		{
			VAL d3 = pop_value();
			mw__3E_Offset_3();
			push_value(d3);
		}
		mw_erase_span_21__1();
	} else {
		mw_drop2_1();
	}
}
static void mw_expand_21__1 (void) {
	mp_prim_dup();
	mw_buffer_size_1();
	mw__3E__5();
	if (pop_u64()) {
		mw_buffer_size_1();
		mw_2_2A__3();
		mw_max_5();
		mw_resize_21__1();
	} else {
		mp_prim_drop();
	}
}
static void mw_rdrop_2 (void) {
	mw__BUFFER_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_free_1();
	mw__UNSAFE_1();
	mp_prim_drop();
}
static void mw_erase_span_21__1 (void) {
	mw_dup2_1();
	mw_check_span_21__1();
	mp_prim_swap();
	mw_buffer_base_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_1();
	mw_erase_1();
	mw__UNSAFE_1();
}
static void mw_buffer_size_1 (void) {
	mw__BUFFER_1();
	mw_over_1();
	{
		VAL d2 = pop_value();
		mtw__2B_BUFFER_1();
		push_value(d2);
	}
}
static void mw_buffer_base_1 (void) {
	mw__BUFFER_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mtw__2B_BUFFER_1();
		push_value(d2);
	}
}
static void mw_check_span_21__1 (void) {
	mw_over_1();
	mw_0_3C__2();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mw_dup2_1();
		mw__3E_Offset_3();
		mw__2B__3();
		mw_buffer_size_1();
		mw__3E_Offset_3();
		mw__3E__4();
	}
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("memory access out of bounds", 27);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_drop2_1();
}
static void mw_check_span_align_21__1 (void) {
	mw_dup2_1();
	mw_check_span_21__1();
	{
		VAL d2 = pop_value();
		mw__3E_Int_10();
		push_value(d2);
	}
	mw__3E_Int_11();
	mp_prim_int_mod();
	mw_0_3D__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("memory access unaligned", 23);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__40_U8_2 (void) {
	mp_prim_dup();
	push_i64(1LL);
	mw__3E_Size_1();
	mw_check_span_align_21__1();
	mw_buffer_base_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_1();
	mw__40_U8_1();
	mw__UNSAFE_1();
}
static void mw__21_U8_2 (void) {
	mp_prim_dup();
	push_i64(1LL);
	mw__3E_Size_1();
	mw_check_span_align_21__1();
	mw_buffer_base_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_1();
	mw__21_U8_1();
	mw__UNSAFE_1();
}
static void mw__21_Byte_2 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_U8_3();
		push_value(d2);
	}
	mw__21_U8_2();
}
static void mw__21_Str_1 (void) {
	mw_dup2_1();
	mp_prim_swap();
	mw_num_bytes_1();
	mw_check_span_21__1();
	mw_buffer_base_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_1();
	mw_copy_partial_21__1();
	mp_prim_drop();
	mw__UNSAFE_1();
}
static void mw__40_Str_1 (void) {
	mw_dup2_1();
	mw_check_span_21__1();
	mw_buffer_base_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_offset_1();
		push_value(d2);
	}
	mw_copy_2();
	mw__UNSAFE_1();
}
static void mw_num_bytes_1 (void) {
	mp_prim_str_num_bytes();
	mw__3E_Size_1();
}
static void mw_empty_3F__2 (void) {
	mw_num_bytes_1();
	mw_0_3D__4();
}
static void mw_copy_partial_21__1 (void) {
	mp_prim_swap();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw_rotl_1();
		mw_dup2_1();
		{
			VAL d3 = pop_value();
			mw__3E_Offset_3();
			push_value(d3);
		}
		mw_offset_1();
		{
			VAL d3 = pop_value();
			mw_copy_1();
			push_value(d3);
		}
		push_value(d2);
	}
	mp_prim_drop();
}
static void mw_thaw_1 (void) {
	mtw__2B_STR_1();
}
static void mw_freeze_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +STR
			mtp__2B_STR_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_Str_2 (void) {
	{
		VAL var_f = pop_value();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("", 0);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_thaw_1();
		incref(var_f);
		run_value(var_f);
		mw_freeze_1();
		decref(var_f);
	}
}
static void mw__3B__1 (void) {
	mw_push_str_21__1();
}
static void mw_copy_2 (void) {
	mw__3E_Int_11();
	mp_prim_str_copy();
}
static void mw_copy_cstr_1 (void) {
	mp_prim_dup();
	mw_cstr_num_bytes_1();
	mw_copy_2();
}
static void mw_cstr_num_bytes_1 (void) {
	mp_prim_dup();
	push_i64(0LL);
	mw__3E_Size_1();
	mp_prim_swap();
	while(1) {
		mp_prim_dup();
		mw__40_U8_1();
		mw__3E_Int_7();
		mw_0_3E__1();
		if (! pop_u64()) break;
		{
			VAL d3 = pop_value();
			mw_1_2B__4();
			push_i64(1LL);
			mw__3E_Offset_1();
			push_value(d3);
		}
		mw_offset_1();
	}
	mp_prim_drop();
	mw_nip_1();
}
static void mw_dup_21__1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +STR
			mtp__2B_STR_1();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mtw__2B_STR_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_num_bytes_3F__1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +STR
			mtp__2B_STR_1();
			mp_prim_dup();
			mw_num_bytes_1();
			{
				VAL d4 = pop_value();
				mtw__2B_STR_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_last_byte_1 (void) {
	mw_num_bytes_3F__1();
	mw__3E_Offset_3();
	mp_prim_dup();
	mw_0_3E__3();
	if (pop_u64()) {
		mw_1__3();
		mw_byte_40__1();
	} else {
		mp_prim_drop();
		push_u64(0LL); // BNUL
	}
}
static void mw_byte_40__1 (void) {
	mw_dup_21__1();
	mw_byte_40__2();
}
static void mw_byte_40__2 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Offset_3();
		mw_over2_1();
		mw__3C__3D__4();
		if (pop_u64()) {
			mw_drop2_1();
			push_u64(0LL); // BNUL
		} else {
			push_resource(MKU64(0LL)); // +UNSAFE
			mw_offset_1();
			mw__40_Byte_1();
			mw__UNSAFE_1();
		}
		push_value(d2);
	}
	mp_prim_drop();
}
static void mw_push_byte_unsafe_21__1 (void) {
	mw_to_str_unsafe_1();
	mw_push_str_21__1();
}
static void mw_push_byte_ascii_21__1 (void) {
	mw_to_ascii_str_1();
	mw_unwrap_1();
	mw_push_str_21__1();
}
static void mw_push_str_21__1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +STR
			mtp__2B_STR_1();
			mp_prim_swap();
			mp_prim_str_cat();
			mtw__2B_STR_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_show_1 (void) {
	mp_prim_int_to_str();
}
static void mw_show_2 (void) {
	mw__3E_Int_8();
	mw_show_1();
}
static void mw_show_4 (void) {
	mw__3E_Int_11();
	mw_show_1();
}
static void mw_drop_bytes_1 (void) {
	mw_dup2_1();
	mw_num_bytes_1();
	mw__3E__3D__5();
	if (pop_u64()) {
		mw_drop2_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("", 0);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	} else {
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mp_prim_str_base();
				push_value(d4);
			}
			mw_num_bytes_1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mp_prim_swap();
			mw___4();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3E_Offset_3();
					push_value(d5);
				}
				mw_offset_1();
				push_value(d4);
			}
			mw_copy_2();
			push_value(d3);
		}
		mp_prim_drop();
	}
}
static void mw_from_bytes_unsafe_1 (void) {
	mp_prim_dup();
	mw_len_1();
	mw__3E_Size_2();
	mw_new_2();
	{
		VAL d2 = pop_value();
		push_i64(0LL);
		mw__3E_Offset_1();
		push_value(d2);
	}
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw__3E_U8_3();
			mw_over_1();
			mw__21_U8_2();
			mw_1_2B__3();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw__3E_U8_3();
				mw_over_1();
				mw__21_U8_2();
				mw_1_2B__3();
				push_value(d4);
			}
			mw__3E_U8_3();
			mw_over_1();
			mw__21_U8_2();
			mw_1_2B__3();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3E_U8_3();
					mw_over_1();
					mw__21_U8_2();
					mw_1_2B__3();
					push_value(d5);
				}
				mw__3E_U8_3();
				mw_over_1();
				mw__21_U8_2();
				mw_1_2B__3();
				push_value(d4);
			}
			mw__3E_U8_3();
			mw_over_1();
			mw__21_U8_2();
			mw_1_2B__3();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_736();
				push_value(d4);
			}
			mw_for_3_736();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_drop();
	mw_buffer_base_1();
	mw_buffer_size_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_copy_2();
	mw__UNSAFE_1();
	mw_rdrop_2();
}
static void mw_clamp_slice_offset_size_1 (void) {
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_tuck_1();
		mw__3E_Offset_3();
		mw_min_4();
		mw_tuck_1();
		mw__3E_Size_3();
		mw___4();
		push_value(d2);
	}
	mw_min_5();
}
static void mw_slice_2 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mp_prim_swap();
		{
			VAL d3 = pop_value();
			mw_clamp_slice_offset_size_1();
			push_value(d3);
		}
		mp_prim_swap();
		{
			VAL d3 = pop_value();
			mw_offset_1();
			push_value(d3);
		}
		mw_copy_2();
		push_value(d2);
	}
	mp_prim_drop();
}
static void mw_slice_1 (void) {
	{
		VAL d2 = pop_resource();
		mw_dup_21__1();
		push_resource(d2);
	}
	mw_slice_2();
}
static void mw_offset_slice_1 (void) {
	mw_dup2_1();
	mw__3C__4();
	if (pop_u64()) {
		mw_over_1();
		mw___3();
		mw__3E_Size_3();
		mw_slice_1();
	} else {
		mw_drop2_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("", 0);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	}
}
static void mw_take_slice_1 (void) {
	push_i64(0LL);
	mw__3E_Offset_1();
	mp_prim_swap();
	mw_slice_1();
}
static void mw_drop_slice_1 (void) {
	{
		VAL d2 = pop_resource();
		mw_num_bytes_3F__1();
		push_resource(d2);
	}
	mw_slice_1();
}
static void mw_split_byte_1 (void) {
	push_u64(0LL); // L0
	push_i64(0LL);
	mw__3E_Offset_1();
	mp_prim_dup();
	while(1) {
		mp_prim_dup();
		mw_num_bytes_3F__1();
		mw__3E_Offset_3();
		mw__3C__4();
		if (! pop_u64()) break;
		mw_over3_1();
		mw_over_1();
		mw_byte_40__1();
		mw__3D__3D__19();
		if (pop_u64()) {
			mw_tuck_1();
			push_resource(MKU64(0LL)); // +UNSAFE
			mw_offset_slice_1();
			mw__UNSAFE_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_snoc_1();
				push_value(d4);
			}
			mw_1_2B__3();
			mp_prim_dup();
		} else {
			mw_1_2B__3();
		}
	}
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_slice_1();
	mw__UNSAFE_1();
	mw_snoc_2B__1();
	mw_nip_1();
}
static void mw_split_byte_2 (void) {
	mw_thaw_1();
	mw_split_byte_1();
	mw_freeze_1();
	mp_prim_drop();
	mw__3E_List_2();
}
static void mw__3E_Path_1 (void) {
}
static void mw__3E_Str_1 (void) {
	mp_prim_id();
}
static void mw__3D__3D__16 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Str_1();
		push_value(d2);
	}
	mw__3E_Str_1();
	mw__3D__3D__7();
}
static void mw_empty_3F__3 (void) {
	mw__3E_Str_1();
	mw_empty_3F__2();
}
static void mw_join_with_1 (void) {
	mw_over2_1();
	mw_empty_3F__3();
	if (pop_u64()) {
		{
			VAL d3 = pop_value();
			mw_drop2_1();
			push_value(d3);
		}
	} else {
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw__3E_Str_1();
				push_value(d4);
			}
			push_value(d3);
		}
		{
			VAL d3 = pop_value();
			mp_prim_str_cat();
			push_value(d3);
		}
		mw__3E_Str_1();
		mp_prim_str_cat();
		mw__3E_Path_1();
	}
}
static void mw_join_unix_1 (void) {
	{
		VAL d2 = pop_value();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("/", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		push_value(d2);
	}
	mw_join_with_1();
}
static void mw__3E_File_1 (void) {
}
static void mw__3E_Int_13 (void) {
	mp_prim_id();
}
static void mw_STDOUT_1 (void) {
	push_i64(1LL);
	mw__3E_File_1();
}
static void mw_STDERR_1 (void) {
	push_i64(2LL);
	mw__3E_File_1();
}
static void mw_write_21__2 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw_slice_write_21__1();
		push_value(d2);
	}
	mp_prim_drop();
}
static void mw_slice_write_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw__3E_Int_13();
			push_value(d3);
		}
		push_value(d2);
	}
	mw__3E_Int_11();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_posix_write();
		push_value(d2);
	}
	mp_prim_dup();
	push_i64(0LL);
	mw__3E__3D__1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("write failed", 12);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mw_dup2_1();
	mp_prim_int_eq();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("write output fewer bytes than expected", 38);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mw_drop2_1();
}
static void mw_print_21__2 (void) {
	{
		VAL d2 = pop_value();
		mw_STDOUT_1();
		push_value(d2);
	}
	mw_write_21__2();
}
static void mw_trace_21__2 (void) {
	{
		VAL d2 = pop_value();
		mw_STDERR_1();
		push_value(d2);
	}
	mw_write_21__2();
}
static void mw_print_ln_21__2 (void) {
	mw_print_21__2();
	mw_line_print_21__1();
}
static void mw_trace_ln_21__2 (void) {
	mw_trace_21__2();
	mw_line_trace_21__1();
}
static void mw_line_print_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\n", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_21__2();
}
static void mw_line_trace_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\n", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
}
static void mw_trace_21__4 (void) {
	mw__3E_Str_1();
	mw_trace_21__2();
}
static void mw_trace_21__1 (void) {
	mw_show_1();
	mw_trace_21__2();
}
static void mw_program_name_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_argv_3 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_option_option_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_option_option_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(4);
		tup->size = 4;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = u;
		decref(v);
		push_value(MKTUP(tup,4));
	}
}
static void mw_parsing_3F__2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_parsing_3F__21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(4);
		tup->size = 4;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = u;
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		decref(v);
		push_value(MKTUP(tup,4));
	}
}
static void mw_error_3 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_error_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = u;
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_positional_index_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_positional_index_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = u;
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_arg_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_arg_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = u;
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_argv_info_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_arguments_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_arguments_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = u;
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_init_1 (void) {
	mw_argv_to_str_1();
	LPUSH(lbl_argv);
	push_i64(0LL);
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_read_from_argv_1();
	mw__UNSAFE_1();
	LPUSH(lbl_program_name);
	mtw_ARGV_5F_INFO_1();
	LPUSH(lbl_argv_info);
	push_u64(0LL); // F
	LPUSH(lbl_parsing_3F_);
	push_u64(0LL); // NONE
	LPUSH(lbl_option);
	push_u64(0LL); // NONE
	LPUSH(lbl_option_option);
	mtw_CURRENT_5F_ARG_1();
	LPUSH(lbl_arg);
	LPUSH(lbl_arguments);
	push_i64(0LL);
	LPUSH(lbl_positional_index);
	push_u64(0LL); // NONE
	LPUSH(lbl_error);
	mtw_STATE_1();
}
static void mw_argv_4 (void) {
	mw_argv_info_2();
	mw_argv_3();
}
static void mw_program_name_3 (void) {
	mw_argv_info_2();
	mw_program_name_2();
}
static void mw_parsing_3F__3 (void) {
	mw_arg_2();
	mw_parsing_3F__2();
}
static void mw_parsing_3F__21__2 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_arg_2();
		mw_parsing_3F__21__1();
		push_value(d2);
	}
	mw_arg_21__1();
}
static void mw_option_option_3 (void) {
	mw_arg_2();
	mw_option_option_2();
}
static void mw_option_option_21__2 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_arg_2();
		mw_option_option_21__1();
		push_value(d2);
	}
	mw_arg_21__1();
}
static void mw_args_doc_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 5, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_parser_3 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 5, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_options_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 5, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw__2F__2B_ARGUMENTPARSER_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +ARGUMENTPARSER
			mtp__2B_ARGUMENTPARSER_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_state_3 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	push_value(u);
}
static void mw_state_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL* p = &VTUP(v)->cells[2];
	VAL t = *p; *p = u; decref(t);
}
static void mw_argument_parser_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	push_value(u);
}
static void mw_rdrop_4 (void) {
	mw__2F__2B_ARGUMENTPARSER_1();
	LPOP(lbl_argument_parser);
	mp_prim_drop();
	LPOP(lbl_state);
	mp_prim_drop();
}
static void mw_parser_1 (void) {
	mw_argument_parser_2();
	mw_parser_3();
}
static void mw_has_short_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // SHORT
			mtp_SHORT_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_doc_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_arg_doc_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_flag_type_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_name_21 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_show_6 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NO_ARGS_PARSED
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Failed to parse any CLI arguments", 33);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 2LL: // MISSING_ARG
			mtp_MISSING_5F_ARG_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Missing argument: Need ", 23);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_swap();
			mp_prim_str_cat();
			break;
		case 1LL: // MISSING_ARGUMENT_VALUE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Missing associated value for flag option", 40);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 3LL: // TOO_MANY_ARGS
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Too many positional arguments passed", 36);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 4LL: // TOO_FEW_ARGS
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Too few positional arguments passed", 35);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 5LL: // UNKNOWN_ARG
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Got an unknown option", 21);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_print_usage_1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Usage:", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_ln_21__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("  ", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_21__2();
	mw_state_3();
	mw_program_name_3();
	mw_print_21__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" [options] ", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_21__2();
	mw_argument_parser_2();
	mw_args_doc_2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_print_21__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_ln_21__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_ln_21__2();
	mw_argument_parser_2();
	mw_options_2();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_print_usage_for_option_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_print_usage_for_option_1();
				push_value(d4);
			}
			mw_print_usage_for_option_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_print_usage_for_option_1();
					push_value(d5);
				}
				mw_print_usage_for_option_1();
				push_value(d4);
			}
			mw_print_usage_for_option_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_786();
				push_value(d4);
			}
			mw_for_3_786();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_ln_21__2();
}
static void mw_print_usage_for_option_1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("  ", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_21__2();
	mp_prim_dup();
	mw_flag_type_2();
	switch (get_top_data_tag()) {
		case 0LL: // SHORT
			mtp_SHORT_1();
			mp_prim_dup();
			mw_is_printable_1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("-", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_print_21__2();
					mp_prim_dup();
					mw_to_str_unsafe_1();
					mw_print_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_drop();
			break;
		default:
			mp_prim_drop();
			break;
	}
	mp_prim_dup();
	mw_flag_type_2();
	mw_has_short_3F__1();
	if (pop_u64()) {
		mp_prim_dup();
		mw_name_21();
		mw_some_3F__1();
	} else {
		push_u64(0LL); // F
	}
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("  ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	}
	mw_print_21__2();
	mp_prim_dup();
	mw_name_21();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("--", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_print_21__2();
			mw_print_21__2();
			mp_prim_dup();
			mw_arg_doc_2();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("=", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_print_21__2();
					mw_print_21__2();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_doc_2();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\t", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_print_21__2();
			mw_print_21__2();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_print_ln_21__2();
	mp_prim_drop();
}
static void mw_check_short_flag_1 (void) {
	mw_over_1();
	mw_flag_type_2();
	switch (get_top_data_tag()) {
		case 0LL: // SHORT
			mtp_SHORT_1();
			push_i64(0LL);
			mw__3E_Offset_1();
			mw_rotl_1();
			mw_byte_40__2();
			mw__3D__3D__19();
			break;
		default:
			mp_prim_drop();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_check_long_flag_1 (void) {
	mw_over_1();
	mw_name_21();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw__3D__3D__7();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_parse_flags_1 (void) {
	mp_prim_dup();
	mw_num_bytes_1();
	push_i64(2LL);
	mw__3E_Size_1();
	mw__3E__3D__5();
	if (pop_u64()) {
		push_i64(1LL);
		mw__3E_Offset_1();
		mw_over_1();
		mw_byte_40__2();
		push_u64(45LL); // B'-'
		mw__3D__3D__19();
	} else {
		push_u64(0LL); // F
	}
	if (pop_u64()) {
		push_i64(2LL);
		mw__3E_Size_1();
		mw_over_1();
		push_resource(MKU64(0LL)); // +UNSAFE
		mw_drop_bytes_1();
		mw__UNSAFE_1();
		mw_argument_parser_2();
		mw_options_2();
		mw__3E_List_2B__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_find_some_2_3326();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_swap();
		mp_prim_drop();
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_dup();
				mw_arg_doc_2();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						push_u64(1LL); // T
						mw_state_3();
						mw_parsing_3F__21__2();
						mw_state_21__1();
						mp_prim_drop();
						mtw_SOME_1();
						mw_state_3();
						mw_option_option_21__2();
						mw_state_21__1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mw_flag_type_2();
						mw_state_3();
						mw_arguments_2();
						mp_prim_swap();
						push_u64(0LL); // NONE
						mp_prim_swap();
						mw_parser_1();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_run();
								mw_state_3();
								mw_arguments_21__1();
								mw_state_21__1();
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								mp_prim_drop();
								mp_prim_drop();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_u64(0LL); // NONE
				break;
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(5LL); // UNKNOWN_ARG
				mtw_SOME_1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
	} else {
		push_i64(1LL);
		mw__3E_Size_1();
		mw_over_1();
		push_resource(MKU64(0LL)); // +UNSAFE
		mw_drop_bytes_1();
		mw__UNSAFE_1();
		mw_argument_parser_2();
		mw_options_2();
		mw__3E_List_2B__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_find_some_2_3317();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_swap();
		mp_prim_drop();
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_dup();
				mw_arg_doc_2();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						push_u64(1LL); // T
						mw_state_3();
						mw_parsing_3F__21__2();
						mw_state_21__1();
						mp_prim_drop();
						mtw_SOME_1();
						mw_state_3();
						mw_option_option_21__2();
						mw_state_21__1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mw_flag_type_2();
						mw_state_3();
						mw_arguments_2();
						mp_prim_swap();
						push_u64(0LL); // NONE
						mp_prim_swap();
						mw_parser_1();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_run();
								mw_state_3();
								mw_arguments_21__1();
								mw_state_21__1();
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								mp_prim_drop();
								mp_prim_drop();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_u64(0LL); // NONE
				break;
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(5LL); // UNKNOWN_ARG
				mtw_SOME_1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
	}
	mp_prim_swap();
	mp_prim_drop();
}
static void mw_do_positional_option_1 (void) {
	mw_state_3();
	mw_arguments_2();
	mp_prim_swap();
	mtw_SOME_1();
	push_u64(2LL); // POSITIONAL
	mw_parser_1();
	mw_unwrap_1();
	mp_prim_run();
	mw_state_3();
	mw_arguments_21__1();
	mw_state_21__1();
	push_u64(0LL); // NONE
	mw_state_3();
	mw_positional_index_2();
	mw_prim_int_succ_1();
	mw_state_3();
	mw_positional_index_21__1();
	mw_state_21__1();
}
static void mw_parse_args_1 (void) {
	LPUSH(lbl_argument_parser);
	mw_init_1();
	LPUSH(lbl_state);
	mtw__2B_ARGUMENTPARSER_1();
	mw_state_3();
	mw_argv_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mp_prim_dup();
			mw_num_bytes_1();
			push_i64(1LL);
			mw__3E_Size_1();
			mw__3E__5();
			if (pop_u64()) {
				push_i64(0LL);
				mw__3E_Offset_1();
				mw_over_1();
				mw_byte_40__2();
				push_u64(45LL); // B'-'
				mw__3D__3D__19();
				if (pop_u64()) {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mp_prim_drop();
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(0LL); // F
										mw_state_3();
										mw_parsing_3F__21__2();
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(1LL); // MISSING_ARGUMENT_VALUE
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
					} else {
						mw_parse_flags_1();
					}
				} else {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_state_3();
										mw_arguments_2();
										mp_prim_swap();
										mtw_SOME_1();
										mw_state_3();
										mw_option_option_3();
										mw_unwrap_1();
										mw_flag_type_2();
										mw_parser_1();
										mw_unwrap_1();
										mp_prim_run();
										mw_state_3();
										{
											VAL d11 = pop_resource();
											mw_arguments_21__1();
											push_resource(d11);
										}
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(5LL); // UNKNOWN_ARG
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_u64(0LL); // F
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_parsing_3F__21__2();
							push_resource(d7);
						}
						mw_state_21__1();
					} else {
						mw_do_positional_option_1();
					}
				}
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_num_bytes_1();
				push_i64(1LL);
				mw__3E_Size_1();
				mw__3E__5();
				if (pop_u64()) {
					push_i64(0LL);
					mw__3E_Offset_1();
					mw_over_1();
					mw_byte_40__2();
					push_u64(45LL); // B'-'
					mw__3D__3D__19();
					if (pop_u64()) {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mp_prim_drop();
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											push_u64(1LL); // MISSING_ARGUMENT_VALUE
											mtw_SOME_1();
											break;
										case 0LL: // NONE
											(void)pop_u64();
											push_u64(0LL); // F
											mw_state_3();
											mw_parsing_3F__21__2();
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									push_u64(1LL); // MISSING_ARGUMENT_VALUE
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
						} else {
							mw_parse_flags_1();
						}
					} else {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											mw_state_3();
											mw_arguments_2();
											mp_prim_swap();
											mtw_SOME_1();
											mw_state_3();
											mw_option_option_3();
											mw_unwrap_1();
											mw_flag_type_2();
											mw_parser_1();
											mw_unwrap_1();
											mp_prim_run();
											mw_state_3();
											{
												VAL d12 = pop_resource();
												mw_arguments_21__1();
												push_resource(d12);
											}
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										case 0LL: // NONE
											(void)pop_u64();
											mp_prim_drop();
											push_u64(5LL); // UNKNOWN_ARG
											mtw_SOME_1();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									mp_prim_drop();
									push_u64(5LL); // UNKNOWN_ARG
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							push_u64(0LL); // F
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_parsing_3F__21__2();
								push_resource(d8);
							}
							mw_state_21__1();
						} else {
							mw_do_positional_option_1();
						}
					}
				} else {
					mp_prim_drop();
					push_u64(0LL); // NONE
				}
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mtw_SOME_1();
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_error_21__1();
							push_resource(d7);
						}
						mw_state_21__1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_num_bytes_1();
			push_i64(1LL);
			mw__3E_Size_1();
			mw__3E__5();
			if (pop_u64()) {
				push_i64(0LL);
				mw__3E_Offset_1();
				mw_over_1();
				mw_byte_40__2();
				push_u64(45LL); // B'-'
				mw__3D__3D__19();
				if (pop_u64()) {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mp_prim_drop();
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(0LL); // F
										mw_state_3();
										mw_parsing_3F__21__2();
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(1LL); // MISSING_ARGUMENT_VALUE
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
					} else {
						mw_parse_flags_1();
					}
				} else {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_state_3();
										mw_arguments_2();
										mp_prim_swap();
										mtw_SOME_1();
										mw_state_3();
										mw_option_option_3();
										mw_unwrap_1();
										mw_flag_type_2();
										mw_parser_1();
										mw_unwrap_1();
										mp_prim_run();
										mw_state_3();
										{
											VAL d11 = pop_resource();
											mw_arguments_21__1();
											push_resource(d11);
										}
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(5LL); // UNKNOWN_ARG
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_u64(0LL); // F
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_parsing_3F__21__2();
							push_resource(d7);
						}
						mw_state_21__1();
					} else {
						mw_do_positional_option_1();
					}
				}
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_num_bytes_1();
					push_i64(1LL);
					mw__3E_Size_1();
					mw__3E__5();
					if (pop_u64()) {
						push_i64(0LL);
						mw__3E_Offset_1();
						mw_over_1();
						mw_byte_40__2();
						push_u64(45LL); // B'-'
						mw__3D__3D__19();
						if (pop_u64()) {
							mw_state_3();
							mw_parsing_3F__3();
							if (pop_u64()) {
								mp_prim_drop();
								mw_state_3();
								mw_option_option_3();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mw_arg_doc_2();
										switch (get_top_data_tag()) {
											case 1LL: // SOME
												mtp_SOME_1();
												mp_prim_drop();
												push_u64(1LL); // MISSING_ARGUMENT_VALUE
												mtw_SOME_1();
												break;
											case 0LL: // NONE
												(void)pop_u64();
												push_u64(0LL); // F
												mw_state_3();
												mw_parsing_3F__21__2();
												mw_state_21__1();
												push_u64(0LL); // NONE
												break;
											default:
												push_value(mkstr("unexpected fallthrough in match\n", 32)); 
												mp_prim_panic();
										}
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
							} else {
								mw_parse_flags_1();
							}
						} else {
							mw_state_3();
							mw_parsing_3F__3();
							if (pop_u64()) {
								mw_state_3();
								mw_option_option_3();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mw_arg_doc_2();
										switch (get_top_data_tag()) {
											case 1LL: // SOME
												mtp_SOME_1();
												mp_prim_drop();
												mw_state_3();
												mw_arguments_2();
												mp_prim_swap();
												mtw_SOME_1();
												mw_state_3();
												mw_option_option_3();
												mw_unwrap_1();
												mw_flag_type_2();
												mw_parser_1();
												mw_unwrap_1();
												mp_prim_run();
												mw_state_3();
												{
													VAL d13 = pop_resource();
													mw_arguments_21__1();
													push_resource(d13);
												}
												mw_state_21__1();
												push_u64(0LL); // NONE
												break;
											case 0LL: // NONE
												(void)pop_u64();
												mp_prim_drop();
												push_u64(5LL); // UNKNOWN_ARG
												mtw_SOME_1();
												break;
											default:
												push_value(mkstr("unexpected fallthrough in match\n", 32)); 
												mp_prim_panic();
										}
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								push_u64(0LL); // F
								mw_state_3();
								{
									VAL d9 = pop_resource();
									mw_parsing_3F__21__2();
									push_resource(d9);
								}
								mw_state_21__1();
							} else {
								mw_do_positional_option_1();
							}
						}
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							mtw_SOME_1();
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_error_21__1();
								push_resource(d8);
							}
							mw_state_21__1();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					push_value(d5);
				}
				mp_prim_dup();
				mw_num_bytes_1();
				push_i64(1LL);
				mw__3E_Size_1();
				mw__3E__5();
				if (pop_u64()) {
					push_i64(0LL);
					mw__3E_Offset_1();
					mw_over_1();
					mw_byte_40__2();
					push_u64(45LL); // B'-'
					mw__3D__3D__19();
					if (pop_u64()) {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mp_prim_drop();
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											push_u64(1LL); // MISSING_ARGUMENT_VALUE
											mtw_SOME_1();
											break;
										case 0LL: // NONE
											(void)pop_u64();
											push_u64(0LL); // F
											mw_state_3();
											mw_parsing_3F__21__2();
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									push_u64(1LL); // MISSING_ARGUMENT_VALUE
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
						} else {
							mw_parse_flags_1();
						}
					} else {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											mw_state_3();
											mw_arguments_2();
											mp_prim_swap();
											mtw_SOME_1();
											mw_state_3();
											mw_option_option_3();
											mw_unwrap_1();
											mw_flag_type_2();
											mw_parser_1();
											mw_unwrap_1();
											mp_prim_run();
											mw_state_3();
											{
												VAL d12 = pop_resource();
												mw_arguments_21__1();
												push_resource(d12);
											}
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										case 0LL: // NONE
											(void)pop_u64();
											mp_prim_drop();
											push_u64(5LL); // UNKNOWN_ARG
											mtw_SOME_1();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									mp_prim_drop();
									push_u64(5LL); // UNKNOWN_ARG
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							push_u64(0LL); // F
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_parsing_3F__21__2();
								push_resource(d8);
							}
							mw_state_21__1();
						} else {
							mw_do_positional_option_1();
						}
					}
				} else {
					mp_prim_drop();
					push_u64(0LL); // NONE
				}
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mtw_SOME_1();
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_error_21__1();
							push_resource(d7);
						}
						mw_state_21__1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_num_bytes_1();
			push_i64(1LL);
			mw__3E_Size_1();
			mw__3E__5();
			if (pop_u64()) {
				push_i64(0LL);
				mw__3E_Offset_1();
				mw_over_1();
				mw_byte_40__2();
				push_u64(45LL); // B'-'
				mw__3D__3D__19();
				if (pop_u64()) {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mp_prim_drop();
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(0LL); // F
										mw_state_3();
										mw_parsing_3F__21__2();
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(1LL); // MISSING_ARGUMENT_VALUE
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
					} else {
						mw_parse_flags_1();
					}
				} else {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_state_3();
										mw_arguments_2();
										mp_prim_swap();
										mtw_SOME_1();
										mw_state_3();
										mw_option_option_3();
										mw_unwrap_1();
										mw_flag_type_2();
										mw_parser_1();
										mw_unwrap_1();
										mp_prim_run();
										mw_state_3();
										{
											VAL d11 = pop_resource();
											mw_arguments_21__1();
											push_resource(d11);
										}
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(5LL); // UNKNOWN_ARG
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_u64(0LL); // F
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_parsing_3F__21__2();
							push_resource(d7);
						}
						mw_state_21__1();
					} else {
						mw_do_positional_option_1();
					}
				}
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_304();
				push_value(d4);
			}
			mw_for_3_304();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_state_3();
	mw_parsing_3F__3();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			push_u64(1LL); // MISSING_ARGUMENT_VALUE
			mtw_SOME_1();
			mw_state_3();
			mw_error_21__1();
			mw_state_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_state_3();
	mw_arguments_2();
	push_u64(0LL); // NONE
	push_u64(3LL); // END
	mw_parser_1();
	mw_unwrap_1();
	mp_prim_run();
	mw_state_3();
	{
		VAL d2 = pop_resource();
		mw_arguments_21__1();
		push_resource(d2);
	}
	mw_state_21__1();
	mw_state_3();
	mw_arguments_2();
	mw_state_3();
	mw_error_3();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mtw_LEFT_1();
			mp_prim_swap();
			mp_prim_drop();
			mw_print_usage_1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mtw_RIGHT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_rdrop_4();
}
static void mw_read_from_argv_1 (void) {
	mw_sizeof_1();
	mw__3E_Int_11();
	mp_prim_int_mul();
	mw__3E_Size_1();
	mw__3E_Offset_3();
	mp_prim_sys_argv();
	mw_offset_1();
	mw__40_Ptr_1();
	mw_copy_cstr_1();
}
static void mw_increment_index_1 (void) {
	LPOP(lbl_index);
	mw_prim_int_succ_1();
	LPUSH(lbl_index);
}
static void mw_index_20 (void) {
	LPOP(lbl_index);
	mp_prim_dup();
	LPUSH(lbl_index);
}
static void mw_argv_to_str_1 (void) {
	push_u64(0LL); // L0
	mtw__2B_LIST_1();
	push_i64(1LL);
	LPUSH(lbl_index);
	while(1) {
		mp_prim_sys_argc();
		mw_index_20();
		mw__3E__1();
		if (! pop_u64()) break;
		mw_index_20();
		push_resource(MKU64(0LL)); // +UNSAFE
		mw_read_from_argv_1();
		mw__UNSAFE_1();
		mw__3B__2();
		mw_increment_index_1();
	}
	LPOP(lbl_index);
	mp_prim_drop();
	mw__LIST_1();
}
static void mw__INPUTOPEN_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +INPUTOPEN
			mtp__2B_INPUTOPEN_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_length_40__1 (void) {
	mw__INPUTOPEN_1();
	mw_over_1();
	{
		VAL d2 = pop_value();
		mtw__2B_INPUTOPEN_1();
		push_value(d2);
	}
}
static void mw_length_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw__INPUTOPEN_1();
		mp_prim_swap();
		mp_prim_drop();
		push_value(d2);
	}
	mp_prim_swap();
	mtw__2B_INPUTOPEN_1();
}
static void mw_offset_40__2 (void) {
	mw__INPUTOPEN_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mtw__2B_INPUTOPEN_1();
		push_value(d2);
	}
}
static void mw_offset_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw__INPUTOPEN_1();
		mp_prim_drop();
		push_value(d2);
	}
	mtw__2B_INPUTOPEN_1();
}
static void mw_INPUT_5F_BUFFER_5F_SIZE_1 (void) {
	push_i64(8192LL);
	mw__3E_Size_1();
}
static void mw_start_21__2 (void) {
	mw_INPUT_5F_BUFFER_5F_SIZE_1();
	mw_new_2();
	push_i64(0LL);
	mw__3E_Size_1();
	push_i64(0LL);
	mw__3E_Offset_1();
	mtw__2B_INPUTOPEN_1();
	mw_fill_buffer_21__1();
}
static void mw_stop_21__1 (void) {
	mw_end_21__2();
	mtw__2B_INPUT_5F_DONE_1();
}
static void mw_end_21__2 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +INPUT_OPEN
			mtp__2B_INPUT_5F_OPEN_1();
			mw__INPUTOPEN_1();
			mw_rdrop_2();
			mw_drop2_1();
			break;
		case 1LL: // +INPUT_DONE
			mtp__2B_INPUT_5F_DONE_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_done_3F__1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +INPUT_OPEN
			mtp__2B_INPUT_5F_OPEN_1();
			push_u64(0LL); // F
			mtw__2B_INPUT_5F_OPEN_1();
			break;
		case 1LL: // +INPUT_DONE
			mtp__2B_INPUT_5F_DONE_1();
			push_u64(1LL); // T
			mtw__2B_INPUT_5F_DONE_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_fill_buffer_21__1 (void) {
	mw__INPUTOPEN_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_rswap();
			{
				VAL d4 = pop_resource();
				mw_buffer_base_1();
				mw_buffer_size_1();
				push_resource(d4);
			}
			mp_prim_rswap();
			push_value(d3);
		}
		push_value(d2);
	}
	mtw__2B_INPUTOPEN_1();
	mw__INPUTOPEN_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_resource();
				mw_unsafe_read_21__1();
				push_resource(d4);
			}
			push_value(d3);
		}
		push_value(d2);
	}
	mtw__2B_INPUTOPEN_1();
	mp_prim_dup();
	mw_0_3E__4();
	if (pop_u64()) {
		mw_length_21__1();
		push_i64(0LL);
		mw__3E_Offset_1();
		mw_offset_21__1();
		mtw__2B_INPUT_5F_OPEN_1();
	} else {
		mp_prim_drop();
		mtw__2B_INPUT_5F_OPEN_1();
		mw_stop_21__1();
	}
}
static void mw_peek_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +INPUT_OPEN
			mtp__2B_INPUT_5F_OPEN_1();
			mw_offset_40__2();
			mw__INPUTOPEN_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_rswap();
					{
						VAL d6 = pop_resource();
						mw__40_U8_2();
						mw__3E_Byte_2();
						push_resource(d6);
					}
					mp_prim_rswap();
					push_value(d5);
				}
				push_value(d4);
			}
			mtw__2B_INPUTOPEN_1();
			mtw__2B_INPUT_5F_OPEN_1();
			break;
		case 1LL: // +INPUT_DONE
			mtp__2B_INPUT_5F_DONE_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("error: no more input", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_move_21__1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +INPUT_OPEN
			mtp__2B_INPUT_5F_OPEN_1();
			mw_offset_40__2();
			mw_1_2B__3();
			mw_offset_21__1();
			mw_prepare_for_more_21__1();
			break;
		case 1LL: // +INPUT_DONE
			mtp__2B_INPUT_5F_DONE_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("error: no more input", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_prepare_for_more_21__1 (void) {
	mw_offset_40__2();
	mw_length_40__1();
	mw__3E_Offset_3();
	mw__3E__3D__4();
	if (pop_u64()) {
		mw_fill_buffer_21__1();
	} else {
		mtw__2B_INPUT_5F_OPEN_1();
	}
}
static void mw_read_chunk_21__1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +INPUT_OPEN
			mtp__2B_INPUT_5F_OPEN_1();
			mw_offset_40__2();
			mw_length_40__1();
			mw_offset_40__2();
			mw__3E_Int_10();
			mw__3E_Size_1();
			mw___4();
			mw__INPUTOPEN_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_rswap();
					{
						VAL d6 = pop_resource();
						mw__40_Str_1();
						push_resource(d6);
					}
					mp_prim_rswap();
					push_value(d5);
				}
				push_value(d4);
			}
			mtw__2B_INPUTOPEN_1();
			mw_fill_buffer_21__1();
			mtw_SOME_1();
			break;
		case 1LL: // +INPUT_DONE
			mtp__2B_INPUT_5F_DONE_1();
			push_u64(0LL); // NONE
			mtw__2B_INPUT_5F_DONE_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_read_file_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_read_chunk_21__1();
	while(1) {
		mp_prim_dup();
		mw_some_3F__1();
		if (! pop_u64()) break;
		mw_unwrap_1();
		mp_prim_str_cat();
		mw_read_chunk_21__1();
	}
	mp_prim_drop();
}
static void mw__FILE_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +FILE
			mtp__2B_FILE_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_file_descriptor_1 (void) {
	mw__FILE_1();
	mp_prim_dup();
	mtw__2B_FILE_1();
}
static void mw_open_file_21__1 (void) {
	mw__3E_Str_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Offset_3();
		mw_over_1();
		push_resource(MKU64(0LL)); // +UNSAFE
		mw_offset_1();
		mw__40_U8_1();
		mw__UNSAFE_1();
		mw__3E_Int_7();
		mw_0_3D__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("tried to use string as cstring, but no null terminator", 54);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_panic();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		push_i64(0LL);
		push_i64(0LL);
		mp_prim_posix_open();
		push_value(d2);
	}
	mp_prim_drop();
	mp_prim_dup();
	mw_0_3E__1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("failed to open file", 19);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mtw__2B_FILE_1();
}
static void mw_create_file_21__1 (void) {
	mw__3E_Str_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Offset_3();
		mw_over_1();
		push_resource(MKU64(0LL)); // +UNSAFE
		mw_offset_1();
		mw__40_U8_1();
		mw__UNSAFE_1();
		mw__3E_Int_7();
		mw_0_3D__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("tried to use string as cstring, but no null terminator", 54);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_panic();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_O_5F_WRONLY_7C_O_5F_CREAT_7C_O_5F_TRUNC_1();
		push_i64(438LL);
		mp_prim_posix_open();
		push_value(d2);
	}
	mp_prim_drop();
	mp_prim_dup();
	mw_0_3E__1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("failed to create file", 21);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mtw__2B_FILE_1();
}
static void mw_O_5F_WRONLY_7C_O_5F_CREAT_7C_O_5F_TRUNC_1 (void) {
	mw_RUNNING_5F_OS_1();
	switch (get_top_data_tag()) {
		case 3LL: // OS_MACOS
			(void)pop_u64();
			push_i64(1537LL);
			break;
		case 2LL: // OS_LINUX
			(void)pop_u64();
			push_i64(577LL);
			break;
		case 1LL: // OS_WINDOWS
			(void)pop_u64();
			push_i64(769LL);
			break;
		case 0LL: // OS_UNKNOWN
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("O_WRONLY|O_CREAT|O_TRUNC on unknown os", 38);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_close_file_21__1 (void) {
	mw__FILE_1();
	mp_prim_posix_close();
	mp_prim_dup();
	mw_0_3C__1();
	mw_not_1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("failed to close file", 20);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mp_prim_drop();
}
static void mw_unsafe_write_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_file_descriptor_1();
			push_value(d3);
		}
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw__3E_Int_11();
		mp_prim_posix_write();
		push_value(d2);
	}
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_0_3C__1();
		mw_not_1();
		if (pop_u64()) {
			mp_prim_id();
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("write failed", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
		}
		mw__3E_Size_1();
		push_value(d2);
	}
	mw_dup2_1();
	mw__3D__3D__15();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("write output fewer bytes than expected", 38);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mw_drop2_1();
}
static void mw_unsafe_read_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_file_descriptor_1();
			push_value(d3);
		}
		push_value(d2);
	}
	mw__3E_Int_11();
	mp_prim_posix_read();
	mp_prim_dup();
	mw_0_3C__1();
	mw_not_1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("read failed", 11);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
	mw__3E_Size_1();
}
static void mw_read_file_21__2 (void) {
	mw_start_21__2();
	mw_read_file_21__1();
	mw_end_21__2();
}
static void mw_ready_1 (void) {
	mtw_LAZY_5F_READY_1();
}
static void mw_ready2_1 (void) {
	mw_pack2_1();
	mtw_LAZY_5F_READY_1();
}
static void mw_delay_1 (void) {
	{
		VAL var_f = pop_value();
		incref(var_f);
		push_value(var_f);
		mtw_LAZY_5F_DELAY_1();
		decref(var_f);
	}
}
static void mw_delay0_1 (void) {
	{
		VAL var_f = pop_value();
		push_i64(0LL);
		push_fnptr(&mb_931);
		incref(var_f);
		push_value(var_f);
		mp_prim_pack_cons();
		mw_delay_1();
		decref(var_f);
	}
}
static void mw_force_21__1 (void) {
	mp_prim_dup();
	mp_prim_mut_get();
	switch (get_top_data_tag()) {
		case 0LL: // LAZY_READY
			mtp_LAZY_5F_READY_1();
			mw_nip_1();
			break;
		case 1LL: // LAZY_DELAY
			mtp_LAZY_5F_DELAY_1();
			mw_rotl_1();
			push_u64(2LL); // LAZY_WAIT
			mw_over_1();
			mp_prim_mut_set();
			{
				VAL d4 = pop_value();
				mp_prim_run();
				mp_prim_dup();
				mtw_LAZY_5F_READY_1();
				push_value(d4);
			}
			mp_prim_mut_set();
			break;
		case 2LL: // LAZY_WAIT
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("attempted to force already running thunk", 40);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_index_14 (void) {
}
static void mw_alloc_21__12 (void) {
	mbuf_NUM_12();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_12();
	mp_prim_u64_set();
}
static void mw_name_14 (void) {
	mfld__7E_name_5();
	mp_prim_mut_get();
}
static void mw__3E_Str_6 (void) {
	mw_name_14();
	mw__3E_Str_3();
}
static void mw__3D__3D__34 (void) {
	{
		VAL d2 = pop_value();
		mw_index_14();
		push_value(d2);
	}
	mw_index_14();
	mp_prim_int_eq();
}
static void mw_new_21__8 (void) {
	mp_prim_dup();
	mfld__7E_label_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			mw_alloc_21__12();
			mw_dup2_1();
			mfld__7E_name_5();
			mp_prim_mut_set();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_index_13 (void) {
}
static void mw_alloc_21__11 (void) {
	mbuf_NUM_11();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_11();
	mp_prim_u64_set();
}
static void mw_package_2 (void) {
	mfld__7E_package_1();
	mp_prim_mut_get();
}
static void mw_name_13 (void) {
	mfld__7E_name_4();
	mp_prim_mut_get();
}
static void mw_qname_10 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_package_2();
		mtw_NAMESPACE_5F_PACKAGE_1();
		push_value(d2);
	}
	mw_name_13();
	mw_QNAME0_1();
}
static void mw_path_3 (void) {
	mfld__7E_path_2();
	mp_prim_mut_get();
}
static void mw_start_1 (void) {
	mfld__7E_start_1();
	mp_prim_mut_get();
}
static void mw_imports_1 (void) {
	mfld__7E_imports_1();
	mp_prim_mut_get();
}
static void mw__3D__3D__33 (void) {
	{
		VAL d2 = pop_value();
		mw_index_13();
		push_value(d2);
	}
	mw_index_13();
	mp_prim_int_eq();
}
static void mw_prim_4 (void) {
	mvar_prim_var_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			mw_alloc_21__11();
			push_u64(0LL); // L0
			mw_over_1();
			mfld__7E_imports_1();
			mp_prim_mut_set();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<prim>", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3E_Path_1();
			mw_over_1();
			mfld__7E_path_2();
			mp_prim_mut_set();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("std", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3E_Name_1();
			mw_find_or_new_21__1();
			mw_over_1();
			mfld__7E_package_1();
			mp_prim_mut_set();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("prim", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3E_Name_1();
			mw_over_1();
			mfld__7E_name_4();
			mp_prim_mut_set();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
}
static void mw_new_21__7 (void) {
	mw_alloc_21__11();
	mw_prim_4();
	mtw_L1_1();
	mw_over_1();
	mfld__7E_imports_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_path_2();
	mp_prim_mut_set();
}
static void mw_add_import_21__1 (void) {
	mp_prim_swap();
	mfld__7E_imports_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_mut_get();
		mw_cons_2();
		push_value(d2);
	}
	mp_prim_mut_set();
}
static void mw_source_path_1 (void) {
	mw_path_3();
}
static void mw_visible_1 (void) {
	mw_dup2_1();
	mw__3D__3D__33();
	if (pop_u64()) {
		mw_drop2_1();
		push_u64(1LL); // T
	} else {
		mw_imports_1();
		mw__3E_List_2B__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_find_some_2_2994();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_some_3F__1();
		mw_nip_1();
	}
}
static void mw__3E_Row_1 (void) {
}
static void mw__3E_Int_19 (void) {
	mp_prim_id();
}
static void mw_trace_21__15 (void) {
	mw__3E_Int_19();
	mw_trace_21__1();
}
static void mw__3E_Col_1 (void) {
}
static void mw__3E_Int_18 (void) {
	mp_prim_id();
}
static void mw_trace_21__13 (void) {
	mw__3E_Int_18();
	mw_trace_21__1();
}
static void mw_unpack_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // LOCATION
			mtp_LOCATION_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_trace_21__14 (void) {
	mw_unpack_2();
	mw_rotr_1();
	mp_prim_swap();
	mw_source_path_1();
	mw_trace_21__4();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(":", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mw_trace_21__15();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(":", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mw_trace_21__13();
}
static void mw_init_errors_21__1 (void) {
	push_i64(0LL);
	mvar_num_errors_1();
	mp_prim_mut_set();
	push_i64(0LL);
	mvar_num_warnings_1();
	mp_prim_mut_set();
}
static void mw_emit_warning_at_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_trace_21__14();
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(": warning: ", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mw_trace_ln_21__2();
	mvar_num_warnings_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_mut_get();
		mw_prim_int_succ_1();
		push_value(d2);
	}
	mp_prim_mut_set();
}
static void mw_emit_error_at_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_trace_21__14();
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(": error: ", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mw_trace_ln_21__2();
	mvar_num_errors_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_mut_get();
		mw_prim_int_succ_1();
		push_value(d2);
	}
	mp_prim_mut_set();
}
static void mw_emit_fatal_error_at_21__1 (void) {
	mw_emit_error_at_21__1();
	push_i64(1LL);
	mp_prim_posix_exit();
}
static void mw_index_5 (void) {
}
static void mw_alloc_21__3 (void) {
	mbuf_NUM_3();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_3();
	mp_prim_u64_set();
}
static void mw_name_4 (void) {
	mfld__7E_name_1();
	mp_prim_mut_get();
}
static void mw_type_4 (void) {
	mfld__7E_type_2();
	mp_prim_mut_get();
}
static void mw_auto_run_3F__1 (void) {
	mfld__7E_auto_run_3F__1();
	mp_prim_mut_get();
}
static void mw__3D__3D__21 (void) {
	{
		VAL d2 = pop_value();
		mw_index_5();
		push_value(d2);
	}
	mw_index_5();
	mp_prim_int_eq();
}
static void mw_trace_21__5 (void) {
	mw_name_4();
	mw_trace_21__12();
}
static void mw_is_stack_3F__1 (void) {
	mw_type_4();
	mw_prim_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			push_u64(1LL); // PRIM_TYPE_STACK
			mw__3D__3D__23();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_physical_3F__1 (void) {
	mw_type_4();
	mw_is_physical_3F__3();
}
static void mw_new_21__3 (void) {
	mw_alloc_21__3();
	mw_tuck_1();
	mfld__7E_name_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_type_2();
	mp_prim_mut_set();
	push_u64(0LL); // F
	mw_over_1();
	mfld__7E_auto_run_3F__1();
	mp_prim_mut_set();
}
static void mw_new_auto_run_21__1 (void) {
	mw_new_21__3();
	push_u64(1LL); // T
	mw_over_1();
	mfld__7E_auto_run_3F__1();
	mp_prim_mut_set();
}
static void mw__2F_CTX_1 (void) {
}
static void mw__3E_Ctx_1 (void) {
}
static void mw__3E_List_3 (void) {
	mp_prim_id();
}
static void mw_CTX0_1 (void) {
	push_u64(0LL); // L0
}
static void mw_CTX1_1 (void) {
	mtw_L1_1();
}
static void mw_CTX2_1 (void) {
	mtw_L2_1();
}
static void mw_CTX3_1 (void) {
	mtw_L3_1();
}
static void mw_new_4 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_List_3();
		push_value(d2);
	}
	mw_snoc_1();
	mw__3E_Ctx_1();
}
static void mw_lookup_2 (void) {
	mw__3E_List_3();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_reverse_find_some_2_3075();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
}
static void mw_len_3 (void) {
	mw__3E_List_3();
	mw_len_1();
}
static void mw_fresh_name_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("_x", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_over_1();
	mw_len_3();
	mw_show_2();
	mp_prim_str_cat();
	mw__3E_Name_1();
}
static void mw_fresh_stack_type_var_21__1 (void) {
	{
		VAL d2 = pop_value();
		push_u64(1LL); // PRIM_TYPE_STACK
		mtw_TPrim_1();
		push_value(d2);
	}
	mw_fresh_var_21__1();
}
static void mw_fresh_type_var_21__1 (void) {
	{
		VAL d2 = pop_value();
		push_u64(0LL); // PRIM_TYPE_TYPE
		mtw_TPrim_1();
		push_value(d2);
	}
	mw_fresh_var_21__1();
}
static void mw_fresh_var_21__1 (void) {
	mw_fresh_name_21__1();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
	mw_new_21__3();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_new_4();
		push_value(d2);
	}
}
static void mw_alloc_21__16 (void) {
	mbuf_NUM_16();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_16();
	mp_prim_u64_set();
}
static void mw_size_1 (void) {
	mfld__7E_size_1();
	mp_prim_mut_get();
}
static void mw_qname_15 (void) {
	mfld__7E_qname_9();
	mp_prim_mut_get();
}
static void mw_name_18 (void) {
	mw_qname_15();
	mw_name_12();
}
static void mw_new_21__9 (void) {
	mw_alloc_21__16();
	mw_tuck_1();
	mfld__7E_size_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_qname_9();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_6();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_BUFFER_1();
	mw_register_1();
}
static void mw_index_3 (void) {
}
static void mw_alloc_21__1 (void) {
	mbuf_NUM_1();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_1();
	mp_prim_u64_set();
}
static void mw_qname_1 (void) {
	mfld__7E_qname_1();
	mp_prim_mut_get();
}
static void mw_name_2 (void) {
	mw_qname_1();
	mw_name_12();
}
static void mw_head_2 (void) {
	mfld__7E_head_1();
	mp_prim_mut_get();
}
static void mw_sig_1 (void) {
	mfld__7E_sig_1();
	mp_prim_mut_get();
}
static void mw_body_1 (void) {
	mfld__7E_body_1();
	mp_prim_mut_get();
}
static void mw_arity_1 (void) {
	mfld__7E_arity_1();
	mp_prim_mut_get();
}
static void mw_params_1 (void) {
	mfld__7E_params_1();
	mw_force_21__1();
}
static void mw_arrow_2 (void) {
	mfld__7E_arrow_1();
	mw_force_21__1();
}
static void mw_cname_1 (void) {
	mp_prim_dup();
	mfld__7E_cname_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mw_", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_2();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_WORD_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_ctx_type_1 (void) {
	mfld__7E_ctx_type_1();
	mw_force_21__1();
	mw_unpack2_1();
}
static void mw_type_2 (void) {
	mw_ctx_type_1();
	mw_nip_1();
}
static void mw_prefer_inline_3F__1 (void) {
	mfld__7E_prefer_inline_3F__1();
	mw__40__3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_new_21__1 (void) {
	mw_alloc_21__1();
	LPOP(lbl_qname);
	mw_over_1();
	mfld__7E_qname_1();
	mp_prim_mut_set();
	LPOP(lbl_head);
	mw_over_1();
	mfld__7E_head_1();
	mp_prim_mut_set();
	LPOP(lbl_body);
	mw_over_1();
	mfld__7E_body_1();
	mp_prim_mut_set();
	LPOP(lbl_arity);
	mw_over_1();
	mfld__7E_arity_1();
	mp_prim_mut_set();
	LPOP(lbl_sig);
	mw_over_1();
	mfld__7E_sig_1();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_WORD_1();
	mw_register_1();
}
static void mw__3D__3D__20 (void) {
	{
		VAL d2 = pop_value();
		mw_index_3();
		push_value(d2);
	}
	mw_index_3();
	mp_prim_int_eq();
}
static void mw_index_10 (void) {
}
static void mw_alloc_21__8 (void) {
	mbuf_NUM_8();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_8();
	mp_prim_u64_set();
}
static void mw_head_5 (void) {
	mfld__7E_head_4();
	mp_prim_mut_get();
}
static void mw_qname_6 (void) {
	mfld__7E_qname_5();
	mp_prim_mut_get();
}
static void mw_name_8 (void) {
	mw_qname_6();
	mw_name_12();
}
static void mw_num_buffer_1 (void) {
	mfld__7E_num_buffer_1();
	mp_prim_mut_get();
}
static void mw__3D__3D__26 (void) {
	{
		VAL d2 = pop_value();
		mw_index_10();
		push_value(d2);
	}
	mw_index_10();
	mp_prim_int_eq();
}
static void mw_alloc_21__7 (void) {
	mbuf_NUM_7();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_7();
	mp_prim_u64_set();
}
static void mw_head_4 (void) {
	mfld__7E_head_3();
	mp_prim_mut_get();
}
static void mw_qname_5 (void) {
	mfld__7E_qname_4();
	mp_prim_mut_get();
}
static void mw_name_7 (void) {
	mw_qname_5();
	mw_name_12();
}
static void mw_index_type_1 (void) {
	mfld__7E_index_type_1();
	mw_force_21__1();
}
static void mw_value_type_1 (void) {
	mfld__7E_value_type_1();
	mw_force_21__1();
}
static void mw_dom_2 (void) {
	mw_index_type_1();
	mw_T1_1();
}
static void mw_cod_2 (void) {
	mw_value_type_1();
	mtw_TMut_1();
	mw_T1_1();
}
static void mw_type_6 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_dom_2();
		push_value(d2);
	}
	mw_cod_2();
	mw_T__3E__1();
}
static void mw_qname_4 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYCON_DATA
			mtp_TYCON_5F_DATA_1();
			mw_qname_13();
			break;
		case 1LL: // TYCON_TABLE
			mtp_TYCON_5F_TABLE_1();
			mw_qname_6();
			break;
		case 2LL: // TYCON_PRIM
			mtp_TYCON_5F_PRIM_1();
			mw_tycon_qname_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3D__3D__24 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYCON_DATA
			mtp_TYCON_5F_DATA_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // TYCON_DATA
					mtp_TYCON_5F_DATA_1();
					mw__3D__3D__35();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		case 1LL: // TYCON_TABLE
			mtp_TYCON_5F_TABLE_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // TYCON_TABLE
					mtp_TYCON_5F_TABLE_1();
					mw__3D__3D__26();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		case 2LL: // TYCON_PRIM
			mtp_TYCON_5F_PRIM_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 2LL: // TYCON_PRIM
					mtp_TYCON_5F_PRIM_1();
					mw__3D__3D__23();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_index_16 (void) {
}
static void mw_alloc_21__14 (void) {
	mbuf_NUM_14();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_14();
	mp_prim_u64_set();
}
static void mw_head_3F__3 (void) {
	mfld__7E_head_3F__2();
	mp_prim_mut_get();
}
static void mw_qname_13 (void) {
	mfld__7E_qname_7();
	mp_prim_mut_get();
}
static void mw_name_16 (void) {
	mw_qname_13();
	mw_name_12();
}
static void mw_arity_6 (void) {
	mfld__7E_arity_3();
	mp_prim_mut_get();
}
static void mw_tags_1 (void) {
	mfld__7E_tags_1();
	mp_prim_mut_get();
}
static void mw_TYPE_5F_BOOL_1 (void) {
	mvar_DATA_5F_BOOL_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_U64_1 (void) {
	mvar_DATA_5F_U64_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_U32_1 (void) {
	mvar_DATA_5F_U32_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_U16_1 (void) {
	mvar_DATA_5F_U16_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_U8_1 (void) {
	mvar_DATA_5F_U8_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_I64_1 (void) {
	mvar_DATA_5F_I64_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_I32_1 (void) {
	mvar_DATA_5F_I32_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_I16_1 (void) {
	mvar_DATA_5F_I16_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_TYPE_5F_I8_1 (void) {
	mvar_DATA_5F_I8_1();
	mp_prim_mut_get();
	mtw_TData_1();
}
static void mw_make_prim_data_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_alloc_21__14();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
		push_value(d2);
	}
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // L1
			mtp_L1_1();
			{
				VAL d4 = pop_value();
				mw_alloc_21__15();
				mp_prim_dup();
				push_value(d4);
			}
			mp_prim_mut_set();
			mtw_L1_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_alloc_21__15();
					mp_prim_dup();
					push_value(d5);
				}
				mp_prim_mut_set();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_alloc_21__15();
					mp_prim_dup();
					push_value(d5);
				}
				mp_prim_mut_set();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_alloc_21__15();
						mp_prim_dup();
						push_value(d6);
					}
					mp_prim_mut_set();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_alloc_21__15();
						mp_prim_dup();
						push_value(d6);
					}
					mp_prim_mut_set();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_alloc_21__15();
						mp_prim_dup();
						push_value(d6);
					}
					mp_prim_mut_set();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1311();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1311();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_prim_3();
			push_value(d3);
		}
		mw_tuck_1();
		mfld__7E_qname_7();
		mp_prim_mut_set();
		mp_prim_dup();
		mtw_DEF_5F_DATA_1();
		mw_register_1();
		push_value(d2);
	}
	mp_prim_dup();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mfld__7E_data_1();
			mp_prim_mut_set();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_over_1();
					push_value(d5);
				}
				mfld__7E_data_1();
				mp_prim_mut_set();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mfld__7E_data_1();
			mp_prim_mut_set();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_over_1();
						push_value(d6);
					}
					mfld__7E_data_1();
					mp_prim_mut_set();
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					mw_over_1();
					push_value(d5);
				}
				mfld__7E_data_1();
				mp_prim_mut_set();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mfld__7E_data_1();
			mp_prim_mut_set();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1315();
				push_value(d4);
			}
			mw_for_3_1315();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_over_1();
	mfld__7E_tags_1();
	mp_prim_mut_set();
	push_i64(0LL);
	mw_over_1();
	mfld__7E_arity_3();
	mp_prim_mut_set();
	push_u64(0LL); // NONE
	mw_over_1();
	mfld__7E_head_3F__2();
	mp_prim_mut_set();
	mp_prim_drop();
}
static void mw_make_prim_tag_21__1 (void) {
	mp_prim_mut_get();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_len_1();
			push_value(d3);
		}
		mw_TT_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_CTX0_1();
		mw_rotr_1();
		mw_data_3();
		mtw_TData_1();
		mw_T1_1();
		mw_T__3E__1();
		mw_pack2_1();
		mtw_LAZY_5F_READY_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mfld__7E_ctx_type_3();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mfld__7E_num_type_inputs_1();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		push_u64(0LL); // L0
		mp_prim_swap();
		mfld__7E_label_inputs_1();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		push_i64(0LL);
		mw__3E_Nat_1();
		mp_prim_swap();
		mfld__7E_num_resource_inputs_1();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw__3E_Nat_1();
			push_value(d3);
		}
		mfld__7E_value_2();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_data_3();
		mp_prim_swap();
		push_i64(0LL);
		mw_data_word_qname_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_qname_8();
	mp_prim_mut_set();
	mtw_DEF_5F_TAG_1();
	mw_register_1();
}
static void mw_init_data_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Bool", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_BOOL_1();
	mvar_TAG_5F_F_1();
	mvar_TAG_5F_T_1();
	mtw_L2_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("F", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	push_u64(0LL); // L0
	mvar_TAG_5F_F_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("T", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(1LL);
	push_u64(0LL); // L0
	mvar_TAG_5F_T_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("U64", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_U64_1();
	mvar_TAG_5F_U64_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>U64-unsafe", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_U64_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("U32", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_U32_1();
	mvar_TAG_5F_U32_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>U32-unsafe", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_U32_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("U16", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_U16_1();
	mvar_TAG_5F_U16_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>U16-unsafe", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_U16_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("U8", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_U8_1();
	mvar_TAG_5F_U8_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>U8-unsafe", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_U8_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("I64", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_I64_1();
	mvar_TAG_5F_I64_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>I64-unsafe", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_I64_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("I32", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_I32_1();
	mvar_TAG_5F_I32_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>I32-unsafe", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_I32_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("I16", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_I16_1();
	mvar_TAG_5F_I16_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>I16-unsafe", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_I16_1();
	mw_make_prim_tag_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("I8", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mvar_DATA_5F_I8_1();
	mvar_TAG_5F_I8_1();
	mtw_L1_1();
	mw_make_prim_data_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Int>I8-unsafe", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_TYPE_5F_INT_1();
	mtw_L1_1();
	mvar_TAG_5F_I8_1();
	mw_make_prim_tag_21__1();
}
static void mw_data_qname_1 (void) {
	LPUSH(lbl_arity);
	LPUSH(lbl_name);
	mtw_TYCON_5F_DATA_1();
	mtw_NAMESPACE_5F_TYCON_1();
	LPUSH(lbl_namespace);
	mtw_MKQNAME_1();
}
static void mw_data_word_qname_1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Name_1();
		push_value(d2);
	}
	mw_data_qname_1();
}
static void mw__3D__3D__35 (void) {
	{
		VAL d2 = pop_value();
		mw_index_16();
		push_value(d2);
	}
	mw_index_16();
	mp_prim_int_eq();
}
static void mw_num_tags_1 (void) {
	mw_tags_1();
	mw_len_1();
}
static void mw_add_tag_21__1 (void) {
	mw_dup2_1();
	mw_num_tags_1();
	mp_prim_swap();
	mfld__7E_value_2();
	mp_prim_mut_set();
	mp_prim_dup();
	mw_tags_1();
	mw_rotr_1();
	{
		VAL d2 = pop_value();
		mw_snoc_1();
		push_value(d2);
	}
	mfld__7E_tags_1();
	mp_prim_mut_set();
}
static void mw_is_enum_3F__1 (void) {
	mw_tags_1();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_3018();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_none_3F__1();
}
static void mw_is_transparent_3F__2 (void) {
	mp_prim_dup();
	mw_is_resource_3F__2();
	if (pop_u64()) {
		mp_prim_drop();
		push_u64(0LL); // F
	} else {
		mw_tags_1();
		switch (get_top_data_tag()) {
			case 1LL: // L1
				mtp_L1_1();
				mp_prim_dup();
				mw_num_type_inputs_1();
				push_i64(1LL);
				mw__3E_Nat_1();
				mw__3D__3D__12();
				mp_prim_swap();
				mw_num_total_inputs_1();
				push_i64(1LL);
				mw__3E_Nat_1();
				mw__3D__3D__12();
				mw__26__26__1();
				break;
			default:
				mp_prim_drop();
				push_u64(0LL); // F
				break;
		}
	}
}
static void mw_is_resource_3F__2 (void) {
	mw_name_16();
	mw_could_be_resource_con_1();
}
static void mw_index_17 (void) {
}
static void mw_alloc_21__15 (void) {
	mbuf_NUM_15();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_15();
	mp_prim_u64_set();
}
static void mw_data_3 (void) {
	mfld__7E_data_1();
	mp_prim_mut_get();
}
static void mw_qname_14 (void) {
	mfld__7E_qname_8();
	mp_prim_mut_get();
}
static void mw_name_17 (void) {
	mw_qname_14();
	mw_name_12();
}
static void mw_value_4 (void) {
	mfld__7E_value_2();
	mp_prim_mut_get();
}
static void mw_label_inputs_1 (void) {
	mfld__7E_label_inputs_1();
	mp_prim_mut_get();
}
static void mw_num_type_inputs_1 (void) {
	mfld__7E_num_type_inputs_1();
	mp_prim_mut_get();
}
static void mw_num_resource_inputs_1 (void) {
	mfld__7E_num_resource_inputs_1();
	mp_prim_mut_get();
}
static void mw_sig_3F__1 (void) {
	mfld__7E_sig_3F__1();
	mp_prim_mut_get();
}
static void mw_ctx_type_3 (void) {
	mfld__7E_ctx_type_3();
	mw_force_21__1();
	mw_unpack2_1();
}
static void mw_ctx_11 (void) {
	mw_ctx_type_3();
	mp_prim_drop();
}
static void mw_type_9 (void) {
	mw_ctx_type_3();
	mw_nip_1();
}
static void mw_untag_1 (void) {
	mfld__7E_untag_1();
	mp_prim_mut_get();
}
static void mw_label_inputs_from_sig_1 (void) {
	mw_sig_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_run_tokens_1();
			mw_filter_2_1335();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					push_u64(0LL); // L0
					break;
				case 1LL: // L1
					mtp_L1_1();
					mw_name_3F__2();
					mw_unwrap_1();
					mw_new_21__8();
					mtw_L1_1();
					break;
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw_name_3F__2();
						mw_unwrap_1();
						mw_new_21__8();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw_name_3F__2();
						mw_unwrap_1();
						mw_new_21__8();
						push_value(d6);
					}
					mp_prim_swap();
					mtw_L2_1();
					break;
				case 3LL: // L3
					mtp_L3_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_name_3F__2();
							mw_unwrap_1();
							mw_new_21__8();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_name_3F__2();
							mw_unwrap_1();
							mw_new_21__8();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_name_3F__2();
							mw_unwrap_1();
							mw_new_21__8();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					mtw_L3_1();
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_map_4_1336();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_map_4_1336();
							push_value(d7);
						}
						mp_prim_swap();
						push_value(d6);
					}
					mtw_LCAT_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_num_type_inputs_from_sig_1 (void) {
	mp_prim_dup();
	mw_sig_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_run_length_1();
			mw_over_1();
			mw_num_resource_inputs_from_sig_1();
			mw___2();
			mp_prim_swap();
			mw_label_inputs_from_sig_1();
			mw_len_1();
			mw___2();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			push_i64(0LL);
			mw__3E_Nat_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_num_resource_inputs_from_sig_1 (void) {
	mw_sig_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_run_tokens_1();
			mw_filter_some_1_1341();
			mw_filter_2_1342();
			mw_len_1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			push_i64(0LL);
			mw__3E_Nat_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_num_total_inputs_1 (void) {
	mp_prim_dup();
	mw_label_inputs_1();
	mw_len_1();
	mw_over_1();
	mw_num_type_inputs_1();
	mw__2B__2();
	mp_prim_swap();
	mw_num_resource_inputs_1();
	mw__2B__2();
}
static void mw_is_transparent_3F__3 (void) {
	mw_data_3();
	mw_is_transparent_3F__2();
}
static void mw_outputs_resource_3F__1 (void) {
	mw_data_3();
	mw_is_resource_3F__2();
}
static void mw__3D__3D__36 (void) {
	{
		VAL d2 = pop_value();
		mw_index_17();
		push_value(d2);
	}
	mw_index_17();
	mp_prim_int_eq();
}
static void mw_prefer_inline_3F__2 (void) {
	mp_prim_dup();
	mw_data_3();
	mw_is_transparent_3F__2();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mp_prim_dup();
		mw_num_total_inputs_1();
		mw_0_3D__2();
	}
	mw_nip_1();
}
static void mw_cases_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[7];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_cases_21__2 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[7];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(8);
		tup->size = 8;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = u;
		decref(v);
		push_value(MKTUP(tup,8));
	}
}
static void mw_cod_6 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[6];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_dom_6 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_body_7 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_token_6 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_cases_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[7];
	incref(u);
	push_value(u);
}
static void mw_cases_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL* p = &VTUP(v)->cells[7];
	VAL t = *p; *p = u; decref(t);
}
static void mw_cod_4 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[6];
	incref(u);
	push_value(u);
}
static void mw_dom_4 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	push_value(u);
}
static void mw_ctx_5 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	push_value(u);
}
static void mw_body_3 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	push_value(u);
}
static void mw_home_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	push_value(u);
}
static void mw_thaw_2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // MATCH
			mtp_MATCH_1();
			mtw__2B_MATCH_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_freeze_2 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +MATCH
			mtp__2B_MATCH_1();
			mtw_MATCH_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_body_5 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_body_21__2 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(3);
		tup->size = 3;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = u;
		decref(v);
		push_value(MKTUP(tup,3));
	}
}
static void mw_pattern_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_is_exhaustive_3F__1 (void) {
	mp_prim_dup();
	mw_has_default_case_3F__1();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mp_prim_dup();
		mw_scrutinee_data_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				mw_num_tags_1();
				mw_over_1();
				mw_cases_4();
				mw_len_1();
				mw__3D__3D__12();
				break;
			case 0LL: // NONE
				(void)pop_u64();
				mp_prim_dup();
				mw_cases_4();
				mw_len_1();
				mw_0_3E__2();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
	}
	mw_nip_1();
}
static void mw_has_default_case_3F__1 (void) {
	mw_cases_4();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_2366();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_some_3F__1();
}
static void mw_scrutinee_data_3F__1 (void) {
	mw_cases_4();
	mw_filter_2_1364();
	mp_prim_dup();
	mw_first_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_pattern_4();
			mw_single_tag_3F__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_data_3();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_swap();
			mw__3E_List_2B__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_find_some_2_2430();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_none_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_transparent_3F__1 (void) {
	mw_cases_4();
	mw__2F_L1_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_pattern_4();
			mw_atoms_2();
			mw__2F_L1_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_op_2();
			switch (get_top_data_tag()) {
				case 1LL: // PATOP_TAG
					mtp_PATOP_5F_TAG_1();
					mw_data_3();
					mw_is_transparent_3F__2();
					break;
				case 0LL: // PATOP_UNDERSCORE
					(void)pop_u64();
					push_u64(1LL); // T
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_add_case_1 (void) {
	mp_prim_dup();
	mw_case_redundant_3F__1();
	if (pop_u64()) {
		mw_pattern_4();
		mw_token_start_2();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("Case is unreachable.", 20);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_emit_error_21__1();
	} else {
		mw_cases_2();
		{
			VAL d3 = pop_resource();
			mp_prim_swap();
			mw_snoc_1();
			push_resource(d3);
		}
		mw_cases_21__1();
	}
}
static void mw_case_redundant_3F__1 (void) {
	mw_cases_2();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_2834();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_some_3F__1();
	mw_nip_1();
}
static void mw_covers_3F__1 (void) {
	{
		VAL d2 = pop_value();
		mw_pattern_4();
		push_value(d2);
	}
	mw_pattern_4();
	mw_covers_3F__2();
}
static void mw_is_default_case_3F__1 (void) {
	mw_pattern_4();
	mw_is_default_3F__1();
}
static void mw_atoms_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	VAL u = VTUP(v)->cells[9];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_atoms_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[9];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(10);
		tup->size = 10;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
		tup->cells[9] = u;
		decref(v);
		push_value(MKTUP(tup,10));
	}
}
static void mw_mid_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	VAL u = VTUP(v)->cells[7];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_mid_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[7];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(10);
		tup->size = 10;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = u;
		tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
		tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
		decref(v);
		push_value(MKTUP(tup,10));
	}
}
static void mw_saved_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	VAL u = VTUP(v)->cells[6];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_saved_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[6];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(10);
		tup->size = 10;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = u;
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
		tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
		decref(v);
		push_value(MKTUP(tup,10));
	}
}
static void mw_inner_ctx_3 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_token_start_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 10, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_dom_7 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_mid_2();
		push_value(d2);
	}
	mw_saved_2();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mtw_STCons_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mtw_STCons_1();
				push_value(d4);
			}
			mtw_STCons_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mtw_STCons_1();
					push_value(d5);
				}
				mtw_STCons_1();
				push_value(d4);
			}
			mtw_STCons_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1238();
				push_value(d4);
			}
			mw_for_3_1238();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_thaw_3 (void) {
	LPUSH(lbl_pattern);
	mtw__2B_PATTERN_1();
}
static void mw_single_tag_3F__1 (void) {
	mw_atoms_2();
	mw__2F_L1_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_op_2();
			mw__2F_PATOP_5F_TAG_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_default_3F__1 (void) {
	mw_atoms_2();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_2373();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_none_3F__1();
}
static void mw__2F__2B_PATTERN_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +PATTERN
			mtp__2B_PATTERN_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_pattern_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 2, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	push_value(u);
}
static void mw_pattern_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 2, v);
	VAL* p = &VTUP(v)->cells[1];
	VAL t = *p; *p = u; decref(t);
}
static void mw_freeze_3 (void) {
	mw__2F__2B_PATTERN_1();
	LPOP(lbl_pattern);
}
static void mw_op_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[7];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_op_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // PATOP_UNDERSCORE
			(void)pop_u64();
			mw_underscore_21__1();
			break;
		case 1LL: // PATOP_TAG
			mtp_PATOP_5F_TAG_1();
			mw_tag_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_underscore_21__1 (void) {
	mw_pattern_2();
	mw_token_start_2();
	LPUSH(lbl_token);
	mw_pattern_2();
	mw_inner_ctx_3();
	LPUSH(lbl_ctx);
	mw_pattern_2();
	mw_mid_2();
	LPUSH(lbl_cod);
	push_u64(0LL); // SUBST_NIL
	LPUSH(lbl_subst);
	push_u64(0LL); // PATOP_UNDERSCORE
	LPUSH(lbl_op);
	mw_pattern_2();
	mw_mid_2();
	mw_force_cons_3F__21__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_pattern_2();
			mw_token_start_2();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("pattern expects something on stack", 34);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_error_21__1();
			push_u64(0LL); // STACK_TYPE_ERROR
			push_u64(0LL); // TYPE_ERROR
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_unpack2_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_pattern_2();
	{
		VAL d2 = pop_resource();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_saved_2();
			mw_cons_2();
			push_value(d3);
		}
		mw_saved_21__1();
		push_resource(d2);
	}
	mw_pattern_21__1();
	mtw_L1_1();
	LPUSH(lbl_saved);
	mp_prim_dup();
	LPUSH(lbl_dom);
	mw_pattern_2();
	{
		VAL d2 = pop_resource();
		mw_mid_21__1();
		push_resource(d2);
	}
	mw_pattern_21__1();
	mtw_PATATOM_1();
	mw_pattern_2();
	{
		VAL d2 = pop_resource();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_atoms_2();
			mw_cons_2();
			push_value(d3);
		}
		mw_atoms_21__1();
		push_resource(d2);
	}
	mw_pattern_21__1();
}
static void mw_tag_21__1 (void) {
	mp_prim_dup();
	mtw_PATOP_5F_TAG_1();
	LPUSH(lbl_op);
	push_u64(0LL); // L0
	LPUSH(lbl_saved);
	mw_pattern_2();
	mw_token_start_2();
	LPUSH(lbl_token);
	mw_pattern_2();
	mw_inner_ctx_3();
	LPUSH(lbl_ctx);
	{
		VAL d2 = pop_value();
		push_u64(0LL); // SUBST_NIL
		push_value(d2);
	}
	mw_type_9();
	mw_freshen_sig_1();
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mw_pattern_2();
		mw_token_start_2();
		mw_pattern_2();
		mw_mid_2();
		push_value(d2);
	}
	mw_unify_21__6();
	LPUSH(lbl_cod);
	mp_prim_drop();
	mp_prim_dup();
	LPUSH(lbl_dom);
	mw_pattern_2();
	{
		VAL d2 = pop_resource();
		mw_mid_21__1();
		push_resource(d2);
	}
	mw_pattern_21__1();
	LPUSH(lbl_subst);
	mtw_PATATOM_1();
	mw_pattern_2();
	{
		VAL d2 = pop_resource();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_atoms_2();
			mw_cons_2();
			push_value(d3);
		}
		mw_atoms_21__1();
		push_resource(d2);
	}
	mw_pattern_21__1();
}
static void mw_covers_3F__2 (void) {
	{
		VAL d2 = pop_value();
		mw_atoms_2();
		mw__2F_L1_1();
		push_value(d2);
	}
	mw_atoms_2();
	mw__2F_L1_1();
	mw_zip_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_unpack2_1();
			mw_op_2();
			switch (get_top_data_tag()) {
				case 0LL: // PATOP_UNDERSCORE
					(void)pop_u64();
					mp_prim_drop();
					push_u64(1LL); // T
					break;
				case 1LL: // PATOP_TAG
					mtp_PATOP_5F_TAG_1();
					mp_prim_swap();
					mw_op_2();
					switch (get_top_data_tag()) {
						case 0LL: // PATOP_UNDERSCORE
							(void)pop_u64();
							mp_prim_drop();
							push_u64(0LL); // F
							break;
						case 1LL: // PATOP_TAG
							mtp_PATOP_5F_TAG_1();
							mw__3D__3D__36();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__2F_PATOP_5F_TAG_1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // PATOP_TAG
			mtp_PATOP_5F_TAG_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw__2F_PATOP_5F_UNDERSCORE_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // PATOP_UNDERSCORE
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_index_19 (void) {
}
static void mw_alloc_21__17 (void) {
	mbuf_NUM_17();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_17();
	mp_prim_u64_set();
}
static void mw__2F_ARG_5F_BLOCK_1 (void) {
}
static void mw__2F_PARAM_1 (void) {
}
static void mw__3E_Param_1 (void) {
}
static void mw__3E_Var_1 (void) {
}
static void mw_atoms_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[7];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_atoms_21__2 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[7];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(8);
		tup->size = 8;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = u;
		decref(v);
		push_value(MKTUP(tup,8));
	}
}
static void mw_cod_12 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[6];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_cod_21__5 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[6];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(8);
		tup->size = 8;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = u;
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		decref(v);
		push_value(MKTUP(tup,8));
	}
}
static void mw_dom_11 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_ctx_13 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_token_end_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_token_end_21__2 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(8);
		tup->size = 8;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = u;
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		decref(v);
		push_value(MKTUP(tup,8));
	}
}
static void mw_token_start_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_home_8 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 8, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_type_11 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_dom_11();
		push_value(d2);
	}
	mw_cod_12();
	mw_T__3E__1();
}
static void mw__2F_ATOM_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // ATOM
			mtp_ATOM_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cod_14 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	VAL u = VTUP(v)->cells[7];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_dom_13 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	VAL u = VTUP(v)->cells[6];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_dom_21__5 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[6];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(9);
		tup->size = 9;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = u;
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
		decref(v);
		push_value(MKTUP(tup,9));
	}
}
static void mw_args_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_args_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(9);
		tup->size = 9;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = u;
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
		decref(v);
		push_value(MKTUP(tup,9));
	}
}
static void mw_op_4 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_op_21__3 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(9);
		tup->size = 9;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = u;
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
		tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
		tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
		decref(v);
		push_value(MKTUP(tup,9));
	}
}
static void mw_token_11 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 9, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_body_9 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_body_21__4 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = u;
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_params_3 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_dom_16 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_cod_16 (void) {
	mw_body_9();
	mw_cod_12();
}
static void mw_ctx_16 (void) {
	mfld__7E_ctx_2();
	mp_prim_mut_get();
}
static void mw_token_12 (void) {
	mfld__7E_token_1();
	mp_prim_mut_get();
}
static void mw_dom_14 (void) {
	mfld__7E_dom_1();
	mp_prim_mut_get();
}
static void mw_cod_15 (void) {
	mfld__7E_cod_1();
	mp_prim_mut_get();
}
static void mw_home_11 (void) {
	mfld__7E_home_1();
	mp_prim_mut_get();
}
static void mw_type_12 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_dom_14();
		push_value(d2);
	}
	mw_cod_15();
	mw_T__3E__1();
}
static void mw_arrow_5 (void) {
	mfld__7E_arrow_2();
	mw_force_21__1();
}
static void mw_qname_16 (void) {
	mp_prim_dup();
	mfld__7E_qname_10();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mp_prim_dup();
			mw_home_11();
			switch (get_top_data_tag()) {
				case 0LL: // HOME_MAIN
					mtp_HOME_5F_MAIN_1();
					mw_module_3();
					mtw_NAMESPACE_5F_MODULE_1();
					mp_prim_swap();
					mw_arrow_5();
					mw_token_start_4();
					mw_index_8();
					mw_show_1();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("entry@", 6);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						push_value(d6);
					}
					mp_prim_str_cat();
					mw__3E_Name_1();
					mw_QNAME0_1();
					break;
				case 1LL: // HOME_WORD
					mtp_HOME_5F_WORD_1();
					mp_prim_dup();
					mtw_NAMESPACE_5F_WORD_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_arrow_5();
							push_value(d7);
						}
						mw_arrow_2();
						{
							VAL d7 = pop_value();
							mw_token_start_4();
							mw_index_8();
							push_value(d7);
						}
						mw_token_start_4();
						mw_index_8();
						mp_prim_int_sub();
						mw_show_1();
						mw__3E_Name_1();
						push_value(d6);
					}
					mp_prim_swap();
					mw_QNAME0_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw__3D__3D__39 (void) {
	{
		VAL d2 = pop_value();
		mw_index_19();
		push_value(d2);
	}
	mw_index_19();
	mp_prim_int_eq();
}
static void mw_new_21__10 (void) {
	mw_alloc_21__17();
	mw_over_1();
	mw_home_8();
	mw_over_1();
	mfld__7E_home_1();
	mp_prim_mut_set();
	mw_over_1();
	mw_ctx_13();
	mw_over_1();
	mfld__7E_ctx_2();
	mp_prim_mut_set();
	mw_over_1();
	mw_token_start_4();
	mw_over_1();
	mfld__7E_token_1();
	mp_prim_mut_set();
	mw_over_1();
	mw_dom_11();
	mw_over_1();
	mfld__7E_dom_1();
	mp_prim_mut_set();
	mw_over_1();
	mw_cod_12();
	mw_over_1();
	mfld__7E_cod_1();
	mp_prim_mut_set();
	mw_tuck_1();
	{
		VAL d2 = pop_value();
		mw_ready_1();
		push_value(d2);
	}
	mfld__7E_arrow_2();
	mp_prim_mut_set();
}
static void mw_typecheck_21__2 (void) {
	mw_arrow_5();
	mp_prim_drop();
}
static void mw_block_unify_type_21__1 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_type_12();
		push_value(d2);
	}
	mw_rotl_1();
	{
		VAL d2 = pop_value();
		mw_unify_21__2();
		mp_prim_drop();
		push_value(d2);
	}
	mw_arrow_5();
	mw_type_11();
}
static void mw_to_run_var_3 (void) {
	mw_arrow_5();
	mw_to_run_var_1();
}
static void mw_to_run_var_1 (void) {
	mw_atoms_4();
	switch (get_top_data_tag()) {
		case 1LL: // L1
			mtp_L1_1();
			mw_to_run_var_2();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_to_run_var_2 (void) {
	mw_op_4();
	switch (get_top_data_tag()) {
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mp_prim_dup();
			mw_auto_run_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw__3E_Str_9 (void) {
	mw_qname_16();
	mw__3E_Str_5();
}
static void mw__3D__3D__38 (void) {
	{
		VAL d2 = pop_value();
		mw__2F_ARG_5F_BLOCK_1();
		push_value(d2);
	}
	mw__2F_ARG_5F_BLOCK_1();
	mw__3D__3D__39();
}
static void mw_free_vars_6 (void) {
	mp_prim_dup();
	mfld__7E_free_vars_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_arrow_5();
			mw_free_vars_4();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_free_vars_4 (void) {
	mw_atoms_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_free_vars_5();
			mtw_L1_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_free_vars_5();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_5();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_5();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_5();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_5();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1298();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1298();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_fold_2_2489();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_free_vars_5 (void) {
	mp_prim_dup();
	mw_args_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_free_vars_3();
			mtw_L1_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_free_vars_3();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_3();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1300();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1300();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_fold_2_2602();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_swap();
	mw_op_4();
	mw_free_vars_8();
	mw_over_1();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		mp_prim_swap();
		mw_filter_2_2525();
		mw_nip_1();
		push_value(d2);
	}
	mw_cat_2();
}
static void mw_free_vars_3 (void) {
	mw_free_vars_6();
}
static void mw_free_vars_8 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // OP_NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // OP_PRIM
			mtp_OP_5F_PRIM_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 2LL: // OP_WORD
			mtp_OP_5F_WORD_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 3LL: // OP_EXTERNAL
			mtp_OP_5F_EXTERNAL_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 4LL: // OP_BUFFER
			mtp_OP_5F_BUFFER_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 5LL: // OP_VARIABLE
			mtp_OP_5F_VARIABLE_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 6LL: // OP_FIELD
			mtp_OP_5F_FIELD_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 7LL: // OP_INT
			mtp_OP_5F_INT_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 8LL: // OP_STR
			mtp_OP_5F_STR_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 9LL: // OP_TAG
			mtp_OP_5F_TAG_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 10LL: // OP_MATCH
			mtp_OP_5F_MATCH_1();
			mw_free_vars_2();
			break;
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mw_free_vars_7();
			break;
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mtw_L1_1();
			break;
		case 13LL: // OP_BLOCK
			mtp_OP_5F_BLOCK_1();
			mw_free_vars_6();
			break;
		case 14LL: // OP_RUN
			mtp_OP_5F_RUN_1();
			mw_free_vars_6();
			break;
		case 15LL: // OP_COERCE
			mtp_OP_5F_COERCE_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 16LL: // OP_LABEL_PUSH
			mtp_OP_5F_LABEL_5F_PUSH_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 17LL: // OP_LABEL_POP
			mtp_OP_5F_LABEL_5F_POP_1();
			mp_prim_drop();
			push_u64(0LL); // L0
			break;
		case 18LL: // OP_DATA_GET_LABEL
			mtp_OP_5F_DATA_5F_GET_5F_LABEL_1();
			mw_drop2_1();
			push_u64(0LL); // L0
			break;
		case 19LL: // OP_DATA_SET_LABEL
			mtp_OP_5F_DATA_5F_SET_5F_LABEL_1();
			mw_drop2_1();
			push_u64(0LL); // L0
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_free_vars_2 (void) {
	mw_cases_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_free_vars_1();
			mtw_L1_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_free_vars_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1303();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1303();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_fold_2_2568();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_free_vars_1 (void) {
	mw_body_5();
	mw_free_vars_4();
}
static void mw_free_vars_7 (void) {
	mp_prim_dup();
	mw_body_9();
	mw_free_vars_4();
	mp_prim_swap();
	mw_params_3();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw__2F_PARAM_1();
			mtw_L1_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw__2F_PARAM_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__2F_PARAM_1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1305();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1305();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_swap();
	mw_filter_2_2541();
	mw_nip_1();
}
static void mw_token_9 (void) {
	mw_token_12();
}
static void mw_alloc_21__4 (void) {
	mbuf_NUM_4();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_4();
	mp_prim_u64_set();
}
static void mw_head_3F__1 (void) {
	mfld__7E_head_3F__1();
	mp_prim_mut_get();
}
static void mw_qname_3 (void) {
	mfld__7E_qname_3();
	mp_prim_mut_get();
}
static void mw_target_1 (void) {
	mfld__7E_target_1();
	mp_prim_mut_get();
}
static void mw_new_21__4 (void) {
	mw_alloc_21__4();
	mw_tuck_1();
	mfld__7E_target_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_qname_3();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_3F__1();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_TYPEDEF_1();
	mw_register_1();
}
static void mw_tag_6 (void) {
}
static void mw_is_physical_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // PRIM_TYPE_TYPE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // PRIM_TYPE_STACK
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 2LL: // PRIM_TYPE_RESOURCE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		default:
			mp_prim_drop();
			push_u64(1LL); // T
			break;
	}
}
static void mw_tycon_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mtw_TYCON_5F_PRIM_1();
			mtw_SOME_1();
			break;
		case 3LL: // TMeta
			mtp_TMeta_1();
			mp_prim_dup();
			mw_type_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_expand_3();
					mw_tuck_1();
					mtw_SOME_1();
					mp_prim_swap();
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
					mw_tycon_3F__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 4LL: // THole
			mtp_THole_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 5LL: // TVar
			mtp_TVar_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 6LL: // TTable
			mtp_TTable_1();
			mtw_TYCON_5F_TABLE_1();
			mtw_SOME_1();
			break;
		case 7LL: // TData
			mtp_TData_1();
			mtw_TYCON_5F_DATA_1();
			mtw_SOME_1();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			mp_prim_drop();
			mw_tycon_3F__1();
			break;
		case 11LL: // TMut
			mtp_TMut_1();
			mw_tycon_3F__1();
			break;
		case 12LL: // TValue
			mtp_TValue_1();
			mw_tycon_3F__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_tycon_qname_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // PRIM_TYPE_TYPE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("TYPE", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		case 1LL: // PRIM_TYPE_STACK
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("STACK", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		case 2LL: // PRIM_TYPE_RESOURCE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("RESOURCE", 8);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		case 3LL: // PRIM_TYPE_INT
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Int", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		case 5LL: // PRIM_TYPE_STR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Str", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		case 4LL: // PRIM_TYPE_PTR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Ptr", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		case 6LL: // PRIM_TYPE_WORLD
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("+World", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_i64(0LL);
			mw_prim_3();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_tycon_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // VALUE_INT
			mtp_VALUE_5F_INT_1();
			mp_prim_drop();
			push_u64(3LL); // PRIM_TYPE_INT
			mtw_TYCON_5F_PRIM_1();
			mtw_SOME_1();
			break;
		case 1LL: // VALUE_STR
			mtp_VALUE_5F_STR_1();
			mp_prim_drop();
			push_u64(5LL); // PRIM_TYPE_STR
			mtw_TYCON_5F_PRIM_1();
			mtw_SOME_1();
			break;
		case 2LL: // VALUE_BLOCK
			mtp_VALUE_5F_BLOCK_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3E_Int_14 (void) {
	mw_tag_6();
}
static void mw__3D__3D__23 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Int_14();
		push_value(d2);
	}
	mw__3E_Int_14();
	mp_prim_int_eq();
}
static void mw_def_prim_type_21__1 (void) {
	{
		VAL d2 = pop_value();
		push_u64(0LL); // NONE
		push_value(d2);
	}
	mp_prim_dup();
	mw_tycon_qname_1();
	mp_prim_swap();
	mtw_TPrim_1();
	mw_new_21__4();
	mp_prim_drop();
}
static void mw_init_types_21__1 (void) {
	push_u64(3LL); // PRIM_TYPE_INT
	mw_def_prim_type_21__1();
	push_u64(4LL); // PRIM_TYPE_PTR
	mw_def_prim_type_21__1();
	push_u64(5LL); // PRIM_TYPE_STR
	mw_def_prim_type_21__1();
	push_u64(6LL); // PRIM_TYPE_WORLD
	mw_def_prim_type_21__1();
	mw_init_data_21__1();
}
static void mw_T_2B__1 (void) {
	mtw_STWith_1();
}
static void mw_T_2A__1 (void) {
	mtw_STCons_1();
}
static void mw_T_2A__2B__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // LEFT
			mtp_LEFT_1();
			mw_T_2A__1();
			break;
		case 1LL: // RIGHT
			mtp_RIGHT_1();
			mw_T_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_T__3E__1 (void) {
	mtw_ARROW_5F_TYPE_1();
}
static void mw_TT_1 (void) {
	mw_T0_1();
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_T_2A__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_T_2A__1();
					push_value(d5);
				}
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1039();
				push_value(d4);
			}
			mw_for_3_1039();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_T0_1 (void) {
	push_u64(2LL); // STACK_TYPE_UNIT
}
static void mw_T1_1 (void) {
	{
		VAL d2 = pop_value();
		mw_T0_1();
		push_value(d2);
	}
	mw_T_2A__1();
}
static void mw_T2_1 (void) {
	{
		VAL d2 = pop_value();
		mw_T1_1();
		push_value(d2);
	}
	mw_T_2A__1();
}
static void mw_T3_1 (void) {
	{
		VAL d2 = pop_value();
		mw_T2_1();
		push_value(d2);
	}
	mw_T_2A__1();
}
static void mw_T4_1 (void) {
	{
		VAL d2 = pop_value();
		mw_T3_1();
		push_value(d2);
	}
	mw_T_2A__1();
}
static void mw_T5_1 (void) {
	{
		VAL d2 = pop_value();
		mw_T4_1();
		push_value(d2);
	}
	mw_T_2A__1();
}
static void mw_T6_1 (void) {
	{
		VAL d2 = pop_value();
		mw_T5_1();
		push_value(d2);
	}
	mw_T_2A__1();
}
static void mw_error_3F__1 (void) {
	mw_expand_3();
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_morphism_3F__1 (void) {
	mw_expand_3();
	switch (get_top_data_tag()) {
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_prim_3F__1 (void) {
	mw_expand_3();
	switch (get_top_data_tag()) {
		case 2LL: // TPrim
			mtp_TPrim_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_meta_3D__1 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mw__3D__3D__22();
			break;
		default:
			mw_drop2_1();
			push_u64(0LL); // F
			break;
	}
}
static void mw_is_physical_3F__3 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mp_prim_dup();
			mw_type_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unbound meta at Type.is-physical?", 33);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_panic();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_expand_3();
					mw_tuck_1();
					mtw_SOME_1();
					mp_prim_swap();
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
					mw_is_physical_3F__3();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mw_is_physical_3F__2();
			break;
		default:
			mp_prim_drop();
			push_u64(1LL); // T
			break;
	}
}
static void mw_TYPE_5F_TYPE_1 (void) {
	push_u64(0LL); // PRIM_TYPE_TYPE
	mtw_TPrim_1();
}
static void mw_TYPE_5F_STACK_1 (void) {
	push_u64(1LL); // PRIM_TYPE_STACK
	mtw_TPrim_1();
}
static void mw_TYPE_5F_RESOURCE_1 (void) {
	push_u64(2LL); // PRIM_TYPE_RESOURCE
	mtw_TPrim_1();
}
static void mw_TYPE_5F_INT_1 (void) {
	push_u64(3LL); // PRIM_TYPE_INT
	mtw_TPrim_1();
}
static void mw_TYPE_5F_PTR_1 (void) {
	push_u64(4LL); // PRIM_TYPE_PTR
	mtw_TPrim_1();
}
static void mw_TYPE_5F_STR_1 (void) {
	push_u64(5LL); // PRIM_TYPE_STR
	mtw_TPrim_1();
}
static void mw_TYPE_5F_WORLD_1 (void) {
	push_u64(6LL); // PRIM_TYPE_WORLD
	mtw_TPrim_1();
}
static void mw_RESOURCE_5F_WORLD_1 (void) {
	mw_TYPE_5F_WORLD_1();
}
static void mw_expand_3 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mw_expand_1();
			break;
		default:
			mp_prim_id();
			break;
	}
}
static void mw_token_2 (void) {
}
static void mw_unify_failed_21__2 (void) {
	mw_over2_1();
	mw_token_2();
	mw_location_2();
	mw_trace_21__14();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(": error: Failed to unify ", 25);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	{
		VAL d2 = pop_value();
		mw_trace_21__11();
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" with ", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mw_trace_21__11();
	mw_line_trace_21__1();
	push_u64(0LL); // TYPE_ERROR
	mvar_num_errors_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_mut_get();
		mw_prim_int_succ_1();
		push_value(d2);
	}
	mp_prim_mut_set();
}
static void mw_unify_simple_21__1 (void) {
	switch (get_top_data_tag()) {
		case 5LL: // TVar
			mtp_TVar_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 5LL: // TVar
					mtp_TVar_1();
					mw_unify_21__1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TVar_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 2LL: // TPrim
					mtp_TPrim_1();
					mw_unify_21__4();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TPrim_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 7LL: // TData
			mtp_TData_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 7LL: // TData
					mtp_TData_1();
					mw_unify_21__10();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TData_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 6LL: // TTable
			mtp_TTable_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 6LL: // TTable
					mtp_TTable_1();
					mw_unify_21__9();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TTable_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 8LL: // TTensor
					mtp_TTensor_1();
					mw_unify_21__6();
					mw__3E_Type_3();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TTensor_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 9LL: // TMorphism
					mtp_TMorphism_1();
					mw_unify_21__2();
					mtw_TMorphism_1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TMorphism_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			mw_rotl_1();
			switch (get_top_data_tag()) {
				case 10LL: // TApp
					mtp_TApp_1();
					mw_unify2_21__1();
					mtw_TApp_1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TApp_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		case 11LL: // TMut
			mtp_TMut_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 11LL: // TMut
					mtp_TMut_1();
					mw_unify_21__7();
					mtw_TMut_1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_TMut_1();
						push_value(d6);
					}
					mw_unify_failed_21__2();
					break;
			}
			break;
		default:
			mw_unify_failed_21__2();
			break;
	}
}
static void mw_unify_aux_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // TYPE_ERROR
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 4LL: // THole
			mtp_THole_1();
			mw_type_hole_unify_21__1();
			break;
		case 3LL: // TMeta
			mtp_TMeta_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // TYPE_ERROR
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // TYPE_ERROR
					break;
				case 1LL: // TYPE_DONT_CARE
					(void)pop_u64();
					mtw_TMeta_1();
					break;
				case 4LL: // THole
					mtp_THole_1();
					{
						VAL d6 = pop_value();
						mtw_TMeta_1();
						push_value(d6);
					}
					mw_type_hole_unify_21__1();
					break;
				case 3LL: // TMeta
					mtp_TMeta_1();
					{
						VAL d6 = pop_value();
						mtw_TMeta_1();
						push_value(d6);
					}
					mw_unify_21__3();
					break;
				case 12LL: // TValue
					mtp_TValue_1();
					{
						VAL d6 = pop_value();
						mtw_TMeta_1();
						push_value(d6);
					}
					mw_unify_type_21__1();
					break;
				default:
					mp_prim_swap();
					mw_unify_21__3();
					break;
			}
			break;
		case 12LL: // TValue
			mtp_TValue_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // TYPE_ERROR
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // TYPE_ERROR
					break;
				case 1LL: // TYPE_DONT_CARE
					(void)pop_u64();
					mtw_TValue_1();
					break;
				case 4LL: // THole
					mtp_THole_1();
					{
						VAL d6 = pop_value();
						mtw_TValue_1();
						push_value(d6);
					}
					mw_type_hole_unify_21__1();
					break;
				case 3LL: // TMeta
					mtp_TMeta_1();
					{
						VAL d6 = pop_value();
						mtw_TValue_1();
						push_value(d6);
					}
					mw_unify_21__3();
					break;
				case 12LL: // TValue
					mtp_TValue_1();
					mw_unify_21__8();
					break;
				default:
					mp_prim_swap();
					mw_unify_type_21__1();
					break;
			}
			break;
		default:
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // TYPE_ERROR
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // TYPE_ERROR
					break;
				case 1LL: // TYPE_DONT_CARE
					(void)pop_u64();
					mp_prim_id();
					break;
				case 4LL: // THole
					mtp_THole_1();
					mw_type_hole_unify_21__1();
					break;
				case 3LL: // TMeta
					mtp_TMeta_1();
					mw_unify_21__3();
					break;
				case 12LL: // TValue
					mtp_TValue_1();
					mw_unify_type_21__1();
					break;
				default:
					mw_unify_simple_21__1();
					break;
			}
			break;
	}
}
static void mw_unify_21__7 (void) {
	{
		VAL d2 = pop_value();
		mw_expand_3();
		push_value(d2);
	}
	mw_expand_3();
	mw_unify_aux_21__1();
}
static void mw_unify_21__8 (void) {
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // VALUE_INT
			mtp_VALUE_5F_INT_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // VALUE_INT
					mtp_VALUE_5F_INT_1();
					mw_dup2_1();
					mp_prim_int_eq();
					if (pop_u64()) {
						mp_prim_drop();
						mtw_VALUE_5F_INT_1();
						mtw_TValue_1();
					} else {
						mw_drop2_1();
						mw_TYPE_5F_INT_1();
					}
					break;
				case 1LL: // VALUE_STR
					mtp_VALUE_5F_STR_1();
					mw_drop2_1();
					mp_prim_dup();
					mw_token_2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Can't unify int value with string value.", 40);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
					break;
				case 2LL: // VALUE_BLOCK
					mtp_VALUE_5F_BLOCK_1();
					mw_drop2_1();
					mp_prim_dup();
					mw_token_2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Can't unify int value with block.", 33);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 1LL: // VALUE_STR
			mtp_VALUE_5F_STR_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // VALUE_STR
					mtp_VALUE_5F_STR_1();
					mw_dup2_1();
					mw__3D__3D__7();
					if (pop_u64()) {
						mp_prim_drop();
						mtw_VALUE_5F_STR_1();
						mtw_TValue_1();
					} else {
						mw_drop2_1();
						mw_TYPE_5F_STR_1();
					}
					break;
				case 0LL: // VALUE_INT
					mtp_VALUE_5F_INT_1();
					mw_drop2_1();
					mp_prim_dup();
					mw_token_2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Can't unify string value with int value.", 40);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
					break;
				case 2LL: // VALUE_BLOCK
					mtp_VALUE_5F_BLOCK_1();
					mw_drop2_1();
					mp_prim_dup();
					mw_token_2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Can't unify string value with block.", 36);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 2LL: // VALUE_BLOCK
			mtp_VALUE_5F_BLOCK_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 2LL: // VALUE_BLOCK
					mtp_VALUE_5F_BLOCK_1();
					mw_dup2_1();
					mw__3D__3D__39();
					if (pop_u64()) {
						mp_prim_drop();
						mtw_VALUE_5F_BLOCK_1();
						mtw_TValue_1();
					} else {
						mw_arrow_5();
						mw_type_11();
						mw_block_unify_type_21__1();
						mw__3E_Type_1();
					}
					break;
				case 0LL: // VALUE_INT
					mtp_VALUE_5F_INT_1();
					mw_drop2_1();
					mp_prim_dup();
					mw_token_2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Can't unify block with int value.", 33);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
					break;
				case 1LL: // VALUE_STR
					mtp_VALUE_5F_STR_1();
					mw_drop2_1();
					mp_prim_dup();
					mw_token_2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Can't unify block with string value.", 36);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_unify_type_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // VALUE_INT
			mtp_VALUE_5F_INT_1();
			mp_prim_drop();
			mw_TYPE_5F_INT_1();
			mw_unify_21__7();
			break;
		case 1LL: // VALUE_STR
			mtp_VALUE_5F_STR_1();
			mp_prim_drop();
			mw_TYPE_5F_STR_1();
			mw_unify_21__7();
			break;
		case 2LL: // VALUE_BLOCK
			mtp_VALUE_5F_BLOCK_1();
			mp_prim_swap();
			mw_unify_block_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_unify_block_21__1 (void) {
	mw_expand_3();
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mw_over_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_type_12();
					mw__3E_Type_1();
					push_value(d5);
				}
				mw_unify_21__3();
				mp_prim_drop();
				push_value(d4);
			}
			mw_arrow_5();
			mw_type_11();
			mw__3E_Type_1();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mw_block_unify_type_21__1();
			mw__3E_Type_1();
			break;
		default:
			{
				VAL d4 = pop_value();
				mw_type_12();
				mw__3E_Type_1();
				push_value(d4);
			}
			mw_unify_21__7();
			break;
	}
}
static void mw_unify2_21__1 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		{
			VAL d3 = pop_value();
			mw_unify_21__7();
			mp_prim_swap();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_unify_21__7();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
}
static void mw_unify_21__4 (void) {
	mw_dup2_1();
	mw__3D__3D__23();
	if (pop_u64()) {
		mp_prim_drop();
		mtw_TPrim_1();
	} else {
		{
			VAL d3 = pop_value();
			mtw_TPrim_1();
			push_value(d3);
		}
		mtw_TPrim_1();
		mw_unify_failed_21__2();
	}
}
static void mw_unify_21__10 (void) {
	mw_dup2_1();
	mw__3D__3D__35();
	if (pop_u64()) {
		mp_prim_drop();
		mtw_TData_1();
	} else {
		{
			VAL d3 = pop_value();
			mtw_TData_1();
			push_value(d3);
		}
		mtw_TData_1();
		mw_unify_failed_21__2();
	}
}
static void mw_unify_21__9 (void) {
	mw_dup2_1();
	mw__3D__3D__26();
	if (pop_u64()) {
		mp_prim_drop();
		mtw_TTable_1();
	} else {
		{
			VAL d3 = pop_value();
			mtw_TTable_1();
			push_value(d3);
		}
		mtw_TTable_1();
		mw_unify_failed_21__2();
	}
}
static void mw_unify_21__1 (void) {
	mw_dup2_1();
	mw__3D__3D__21();
	if (pop_u64()) {
		mp_prim_drop();
		mtw_TVar_1();
	} else {
		{
			VAL d3 = pop_value();
			mtw_TVar_1();
			push_value(d3);
		}
		mtw_TVar_1();
		mw_unify_failed_21__2();
	}
}
static void mw_has_meta_3F__5 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mw_has_meta_3F__2();
			break;
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mw_drop2_1();
			push_u64(0LL); // F
			break;
		case 5LL: // TVar
			mtp_TVar_1();
			mw_drop2_1();
			push_u64(0LL); // F
			break;
		case 4LL: // THole
			mtp_THole_1();
			mw_drop2_1();
			push_u64(0LL); // F
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			mw_has_meta_3F__4();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mw_has_meta_3F__1();
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			mw_has_meta2_3F__1();
			break;
		case 7LL: // TData
			mtp_TData_1();
			mw_drop2_1();
			push_u64(0LL); // F
			break;
		case 6LL: // TTable
			mtp_TTable_1();
			mw_drop2_1();
			push_u64(0LL); // F
			break;
		case 12LL: // TValue
			mtp_TValue_1();
			mw_has_meta_3F__6();
			break;
		case 11LL: // TMut
			mtp_TMut_1();
			mw_has_meta_3F__5();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_has_meta2_3F__1 (void) {
	{
		VAL d2 = pop_value();
		mw_over_1();
		push_value(d2);
	}
	mw_has_meta_3F__5();
	if (pop_u64()) {
		mw_drop2_1();
		push_u64(1LL); // T
	} else {
		mw_has_meta_3F__5();
	}
}
static void mw_has_meta_3F__6 (void) {
	mw_type_5();
	mw_has_meta_3F__5();
}
static void mw_trace_sig_21__1 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mp_prim_dup();
			mw_type_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_trace_21__7();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_expand_3();
					mw_tuck_1();
					mtw_SOME_1();
					mp_prim_swap();
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
					mw_trace_sig_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<ERROR>", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mw_trace_21__6();
			break;
		default:
			mw_trace_21__11();
			break;
	}
}
static void mw_trace_21__11 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<ERROR>", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mw_trace_21__8();
			break;
		case 5LL: // TVar
			mtp_TVar_1();
			mw_trace_21__5();
			break;
		case 3LL: // TMeta
			mtp_TMeta_1();
			mw_trace_21__7();
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("[", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__10();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("[", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mtw_TMorphism_1();
			mw_trace_sig_21__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			break;
		case 7LL: // TData
			mtp_TData_1();
			mw_name_16();
			mw_trace_21__12();
			break;
		case 6LL: // TTable
			mtp_TTable_1();
			mw_name_8();
			mw_trace_21__12();
			break;
		case 4LL: // THole
			mtp_THole_1();
			mw_trace_21__12();
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			mw_trace_app_21__1();
			break;
		case 12LL: // TValue
			mtp_TValue_1();
			mw_type_5();
			mw_trace_21__11();
			break;
		case 11LL: // TMut
			mtp_TMut_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Mut(", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__11();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(")", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_type_5 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // VALUE_INT
			mtp_VALUE_5F_INT_1();
			mp_prim_drop();
			push_u64(3LL); // PRIM_TYPE_INT
			mtw_TPrim_1();
			break;
		case 1LL: // VALUE_STR
			mtp_VALUE_5F_STR_1();
			mp_prim_drop();
			push_u64(5LL); // PRIM_TYPE_STR
			mtw_TPrim_1();
			break;
		case 2LL: // VALUE_BLOCK
			mtp_VALUE_5F_BLOCK_1();
			mw_type_12();
			mw__3E_Type_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_trace_21__8 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // PRIM_TYPE_TYPE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<TYPE>", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 1LL: // PRIM_TYPE_STACK
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<STACK>", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 2LL: // PRIM_TYPE_RESOURCE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<RESOURCE>", 10);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 3LL: // PRIM_TYPE_INT
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Int", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 4LL: // PRIM_TYPE_PTR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Ptr", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 5LL: // PRIM_TYPE_STR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Str", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 6LL: // PRIM_TYPE_WORLD
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("+World", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_trace_21__2();
}
static void mw_freshen_6 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // TYPE_ERROR
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // TYPE_DONT_CARE
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mtw_TPrim_1();
			break;
		case 4LL: // THole
			mtp_THole_1();
			mtw_THole_1();
			break;
		case 7LL: // TData
			mtp_TData_1();
			mtw_TData_1();
			break;
		case 6LL: // TTable
			mtp_TTable_1();
			mtw_TTable_1();
			break;
		case 12LL: // TValue
			mtp_TValue_1();
			mtw_TValue_1();
			break;
		case 5LL: // TVar
			mtp_TVar_1();
			mw_freshen_1();
			break;
		case 3LL: // TMeta
			mtp_TMeta_1();
			mw_freshen_3();
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			mw_freshen_5();
			mtw_TTensor_1();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mw_freshen_2();
			mtw_TMorphism_1();
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			mw_freshen2_1();
			mtw_TApp_1();
			break;
		case 11LL: // TMut
			mtp_TMut_1();
			mw_freshen_6();
			mtw_TMut_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_freshen2_1 (void) {
	{
		VAL d2 = pop_value();
		mw_freshen_6();
		mp_prim_swap();
		push_value(d2);
	}
	mw_freshen_6();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
}
static void mw_freshen_1 (void) {
	mp_prim_swap();
	mw_dup2_1();
	mw_has_var_3F__1();
	if (pop_u64()) {
		mw_tuck_1();
		mw_get_var_1();
	} else {
		mw_new_21__5();
		mtw_TMeta_1();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_rotr_1();
			mw_cons_3();
			push_value(d3);
		}
	}
}
static void mw_rigidify_21__4 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mp_prim_dup();
			mw_type_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						mw_fresh_type_var_21__1();
						mtw_TVar_1();
						mp_prim_dup();
						mtw_SOME_1();
						push_value(d6);
					}
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_nip_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_rigidify_21__4();
			break;
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // TYPE_ERROR
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // TYPE_DONT_CARE
			break;
		case 2LL: // TPrim
			mtp_TPrim_1();
			mtw_TPrim_1();
			break;
		case 4LL: // THole
			mtp_THole_1();
			mtw_THole_1();
			break;
		case 5LL: // TVar
			mtp_TVar_1();
			mtw_TVar_1();
			break;
		case 6LL: // TTable
			mtp_TTable_1();
			mtw_TTable_1();
			break;
		case 7LL: // TData
			mtp_TData_1();
			mtw_TData_1();
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			{
				VAL d4 = pop_value();
				mw_rigidify_21__4();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_rigidify_21__4();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_TApp_1();
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			mw_rigidify_21__3();
			mtw_TTensor_1();
			break;
		case 9LL: // TMorphism
			mtp_TMorphism_1();
			mw_rigidify_21__1();
			mtw_TMorphism_1();
			break;
		case 12LL: // TValue
			mtp_TValue_1();
			mw_rigidify_21__5();
			break;
		case 11LL: // TMut
			mtp_TMut_1();
			mw_rigidify_21__4();
			mtw_TMut_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_rigidify_21__5 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // VALUE_INT
			mtp_VALUE_5F_INT_1();
			mtw_VALUE_5F_INT_1();
			mtw_TValue_1();
			break;
		case 1LL: // VALUE_STR
			mtp_VALUE_5F_STR_1();
			mtw_VALUE_5F_STR_1();
			mtw_TValue_1();
			break;
		case 2LL: // VALUE_BLOCK
			mtp_VALUE_5F_BLOCK_1();
			mw_arrow_5();
			mw_type_11();
			mw_rigidify_21__1();
			mw__3E_Type_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_arity_2 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TMeta
			mtp_TMeta_1();
			mp_prim_dup();
			mw_type_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_drop();
					push_i64(0LL);
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_expand_3();
					mw_tuck_1();
					mtw_SOME_1();
					mp_prim_swap();
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
					mw_arity_2();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 7LL: // TData
			mtp_TData_1();
			mw_arity_6();
			break;
		case 10LL: // TApp
			mtp_TApp_1();
			mp_prim_drop();
			mw_arity_2();
			mw_prim_int_pred_1();
			break;
		default:
			mp_prim_drop();
			push_i64(0LL);
			break;
	}
}
static void mw_index_7 (void) {
}
static void mw_alloc_21__5 (void) {
	mbuf_NUM_5();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_5();
	mp_prim_u64_set();
}
static void mw_type_3F__1 (void) {
	mfld__7E_type_3F__1();
	mp_prim_mut_get();
}
static void mw_has_meta_3F__2 (void) {
	mp_prim_dup();
	mw_type_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw__3D__3D__22();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mw_has_meta_3F__5();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_trace_21__7 (void) {
	mp_prim_dup();
	mw_type_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("?", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_index_7();
			mw_trace_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mw_trace_21__11();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_new_21__5 (void) {
	mw_alloc_21__5();
	push_u64(0LL); // NONE
	mw_over_1();
	mfld__7E_type_3F__1();
	mp_prim_mut_set();
}
static void mw_expand_1 (void) {
	mp_prim_dup();
	mw_type_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mtw_TMeta_1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_expand_3();
			mw_tuck_1();
			mtw_SOME_1();
			mp_prim_swap();
			mfld__7E_type_3F__1();
			mp_prim_mut_set();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_unify_21__3 (void) {
	mp_prim_dup();
	mw_type_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mw_unify_21__7();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mp_prim_swap();
			mw_meta_3D__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				mp_prim_swap();
				mw_dup2_1();
				mw_has_meta_3F__5();
				if (pop_u64()) {
					mp_prim_swap();
					mtw_TMeta_1();
					mw_unify_failed_21__2();
				} else {
					mw_tuck_1();
					mtw_SOME_1();
					mp_prim_swap();
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
				}
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3D__3D__22 (void) {
	{
		VAL d2 = pop_value();
		mw_index_7();
		push_value(d2);
	}
	mw_index_7();
	mp_prim_int_eq();
}
static void mw_freshen_3 (void) {
	mp_prim_dup();
	mw_type_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			mw_new_21__5();
			mtw_TMeta_1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_expand_3();
			mw_tuck_1();
			mtw_SOME_1();
			mp_prim_swap();
			mfld__7E_type_3F__1();
			mp_prim_mut_set();
			mw_freshen_6();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_type_hole_unify_21__1 (void) {
	mtw_THole_1();
	mw_trace_21__11();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" ~ ", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mp_prim_dup();
	mw_trace_21__11();
	mw_line_trace_21__1();
}
static void mw_trace_app_21__1 (void) {
	mw_trace_app_open_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(")", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
}
static void mw_trace_app_open_21__1 (void) {
	mp_prim_swap();
	mw_expand_3();
	switch (get_top_data_tag()) {
		case 10LL: // TApp
			mtp_TApp_1();
			mw_trace_app_open_21__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", ", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__11();
			break;
		default:
			mw_trace_21__11();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("(", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__11();
			break;
	}
}
static void mw__3E_Type_2 (void) {
	mp_prim_id();
}
static void mw__3E_Resource_1 (void) {
}
static void mw_has_meta_3F__3 (void) {
	mw__3E_Type_2();
	mw_has_meta_3F__5();
}
static void mw_unify_21__5 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Type_2();
		push_value(d2);
	}
	mw__3E_Type_2();
	mw_unify_21__7();
	mw__3E_Resource_1();
}
static void mw_trace_21__9 (void) {
	mw__3E_Type_2();
	mw_trace_21__11();
}
static void mw_freshen_4 (void) {
	mw__3E_Type_2();
	mw_freshen_6();
	mw__3E_Resource_1();
}
static void mw_rigidify_21__2 (void) {
	mw__3E_Type_2();
	mw_rigidify_21__4();
	mw__3E_Resource_1();
}
static void mw__3E_StackType_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // STACK_TYPE_ERROR
			break;
		case 1LL: // TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // STACK_TYPE_DONT_CARE
			break;
		case 5LL: // TVar
			mtp_TVar_1();
			mtw_STVar_1();
			break;
		case 3LL: // TMeta
			mtp_TMeta_1();
			mtw_STMeta_1();
			break;
		case 8LL: // TTensor
			mtp_TTensor_1();
			mp_prim_id();
			break;
		default:
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("kind error! expected stack type, got regular type.", 50);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
	}
}
static void mw__3E_Type_3 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // TYPE_ERROR
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // TYPE_DONT_CARE
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mtw_TVar_1();
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			mtw_TMeta_1();
			break;
		default:
			mtw_TTensor_1();
			break;
	}
}
static void mw_expand_2 (void) {
	switch (get_top_data_tag()) {
		case 4LL: // STMeta
			mtp_STMeta_1();
			mw_expand_1();
			mw__3E_StackType_1();
			break;
		default:
			mp_prim_id();
			break;
	}
}
static void mw_unit_3F__1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_split4_1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_split4_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_snoc_1();
				push_value(d4);
			}
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_split4_1();
				push_value(d4);
			}
			mw_snoc_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_pack2_1();
			{
				VAL d4 = pop_value();
				mw_split4_1();
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_snoc_1();
					push_value(d5);
				}
				push_value(d4);
			}
			break;
		default:
			push_u64(0LL); // L0
			push_u64(0LL); // L0
			push_u64(0LL); // L0
			break;
	}
}
static void mw_base_1 (void) {
	mw_split4_1();
	mw_drop3_1();
}
static void mw_top_type_3F__1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 7LL: // STWith
			mtp_STWith_1();
			mp_prim_drop();
			mw_top_type_3F__1();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			mw_nip_1();
			mtw_SOME_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_drop2_1();
			mw_top_type_3F__1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_top_tycon_3F__1 (void) {
	mw_top_type_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_tycon_3F__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_top_resource_3F__1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 7LL: // STWith
			mtp_STWith_1();
			mw_nip_1();
			mtw_SOME_1();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			mp_prim_drop();
			mw_top_resource_3F__1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_drop2_1();
			mw_top_resource_3F__1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_top_resource_tycon_3F__1 (void) {
	mw_top_resource_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw__3E_Type_2();
			mw_tycon_3F__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_has_meta_3F__4 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 4LL: // STMeta
			mtp_STMeta_1();
			mw__3D__3D__22();
			break;
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mw_drop2_1();
			push_u64(0LL); // F
			break;
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mw_has_meta_3F__5();
			if (pop_u64()) {
				mw_drop2_1();
				push_u64(1LL); // T
			} else {
				mw_has_meta_3F__4();
			}
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mw_has_meta_3F__5();
			if (pop_u64()) {
				mw_drop2_1();
				push_u64(1LL); // T
			} else {
				mw_has_meta_3F__4();
			}
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mw_has_meta_3F__3();
			if (pop_u64()) {
				mw_drop2_1();
				push_u64(1LL); // T
			} else {
				mw_has_meta_3F__4();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_unify_failed_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Type_3();
		push_value(d2);
	}
	mw__3E_Type_3();
	mw_unify_failed_21__2();
	mw__3E_StackType_1();
}
static void mw_unify_21__6 (void) {
	mp_prim_swap();
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // STACK_TYPE_ERROR
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			mp_prim_swap();
			mw_expand_2();
			switch (get_top_data_tag()) {
				case 0LL: // STACK_TYPE_ERROR
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // STACK_TYPE_ERROR
					break;
				case 1LL: // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_STMeta_1();
					break;
				case 4LL: // STMeta
					mtp_STMeta_1();
					{
						VAL d6 = pop_value();
						mtw_TMeta_1();
						push_value(d6);
					}
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
				default:
					mw__3E_Type_3();
					mp_prim_swap();
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
			}
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mp_prim_swap();
			mw_expand_2();
			switch (get_top_data_tag()) {
				case 0LL: // STACK_TYPE_ERROR
					(void)pop_u64();
					mp_prim_drop();
					push_u64(0LL); // STACK_TYPE_ERROR
					break;
				case 1LL: // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_STVar_1();
					break;
				case 4LL: // STMeta
					mtp_STMeta_1();
					{
						VAL d6 = pop_value();
						mtw_TVar_1();
						push_value(d6);
					}
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
				case 3LL: // STVar
					mtp_STVar_1();
					mw_unify_21__1();
					mw__3E_StackType_1();
					break;
				default:
					{
						VAL d6 = pop_value();
						mtw_STVar_1();
						push_value(d6);
					}
					mw_unify_failed_21__1();
					break;
			}
			break;
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			mw_expand_2();
			switch (get_top_data_tag()) {
				case 0LL: // STACK_TYPE_ERROR
					(void)pop_u64();
					push_u64(0LL); // STACK_TYPE_ERROR
					break;
				case 4LL: // STMeta
					mtp_STMeta_1();
					{
						VAL d6 = pop_value();
						push_u64(2LL); // STACK_TYPE_UNIT
						mw__3E_Type_3();
						push_value(d6);
					}
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
				case 1LL: // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					push_u64(2LL); // STACK_TYPE_UNIT
					break;
				case 2LL: // STACK_TYPE_UNIT
					(void)pop_u64();
					push_u64(2LL); // STACK_TYPE_UNIT
					break;
				default:
					push_u64(2LL); // STACK_TYPE_UNIT
					mw_unify_failed_21__1();
					break;
			}
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			mw_rotl_1();
			mw_expand_2();
			switch (get_top_data_tag()) {
				case 0LL: // STACK_TYPE_ERROR
					(void)pop_u64();
					mw_drop2_1();
					push_u64(0LL); // STACK_TYPE_ERROR
					break;
				case 4LL: // STMeta
					mtp_STMeta_1();
					{
						VAL d6 = pop_value();
						mtw_STCons_1();
						mw__3E_Type_3();
						push_value(d6);
					}
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
				case 1LL: // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_STCons_1();
					break;
				default:
					mp_prim_dup();
					mw_force_cons_3F__21__1();
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							mw_nip_1();
							mw_unpack2_1();
							{
								VAL d8 = pop_value();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_unify_21__6();
									mp_prim_swap();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_unify_21__7();
							{
								VAL d8 = pop_value();
								mp_prim_swap();
								push_value(d8);
							}
							mtw_STCons_1();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							{
								VAL d8 = pop_value();
								mtw_STCons_1();
								push_value(d8);
							}
							mw_unify_failed_21__1();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					break;
			}
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			mw_rotl_1();
			mw_expand_2();
			switch (get_top_data_tag()) {
				case 0LL: // STACK_TYPE_ERROR
					(void)pop_u64();
					mw_drop2_1();
					push_u64(0LL); // STACK_TYPE_ERROR
					break;
				case 4LL: // STMeta
					mtp_STMeta_1();
					{
						VAL d6 = pop_value();
						mtw_STWith_1();
						mw__3E_Type_3();
						push_value(d6);
					}
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
				case 1LL: // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_STWith_1();
					break;
				default:
					mp_prim_dup();
					mw_force_with_3F__21__1();
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							mw_nip_1();
							mw_unpack2_1();
							{
								VAL d8 = pop_value();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_unify_21__6();
									mp_prim_swap();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_unify_21__5();
							{
								VAL d8 = pop_value();
								mp_prim_swap();
								push_value(d8);
							}
							mtw_STWith_1();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							{
								VAL d8 = pop_value();
								mtw_STWith_1();
								push_value(d8);
							}
							mw_unify_failed_21__1();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					break;
			}
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_rot4l_1();
			mw_expand_2();
			switch (get_top_data_tag()) {
				case 0LL: // STACK_TYPE_ERROR
					(void)pop_u64();
					mw_drop3_1();
					push_u64(0LL); // STACK_TYPE_ERROR
					break;
				case 4LL: // STMeta
					mtp_STMeta_1();
					{
						VAL d6 = pop_value();
						mtw_STConsLabel_1();
						mw__3E_Type_3();
						push_value(d6);
					}
					mw_unify_21__3();
					mw__3E_StackType_1();
					break;
				case 1LL: // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_STConsLabel_1();
					break;
				default:
					mw_dup2_1();
					mw_force_cons_label_3F__21__1();
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							mw_nip_1();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_unpack2_1();
								{
									VAL d9 = pop_value();
									mp_prim_swap();
									{
										VAL d10 = pop_value();
										mw_unify_21__6();
										mp_prim_swap();
										push_value(d10);
									}
									push_value(d9);
								}
								mw_unify_21__7();
								{
									VAL d9 = pop_value();
									mp_prim_swap();
									push_value(d9);
								}
								push_value(d8);
							}
							mtw_STConsLabel_1();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							{
								VAL d8 = pop_value();
								mtw_STConsLabel_1();
								push_value(d8);
							}
							mw_unify_failed_21__1();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_force_cons_label_3F__21__1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // STACK_TYPE_ERROR
			push_u64(0LL); // TYPE_ERROR
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(1LL); // STACK_TYPE_DONT_CARE
			push_u64(1LL); // TYPE_DONT_CARE
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mw_drop2_1();
			push_u64(0LL); // NONE
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_force_cons_label_3F__21__1();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_unpack2_1();
					{
						VAL d6 = pop_value();
						mw_over_1();
						mtw_STWith_1();
						push_value(d6);
					}
					mw_pack2_1();
					mtw_SOME_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_force_cons_label_3F__21__1();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_unpack2_1();
					{
						VAL d6 = pop_value();
						mw_over_1();
						mtw_STCons_1();
						push_value(d6);
					}
					mw_pack2_1();
					mtw_SOME_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_over3_1();
			mw_over_1();
			mw__3D__3D__34();
			if (pop_u64()) {
				mp_prim_drop();
				mw_rotl_1();
				mp_prim_drop();
				mw_pack2_1();
				mtw_SOME_1();
			} else {
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_force_cons_label_3F__21__1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mw_unpack2_1();
						{
							VAL d7 = pop_value();
							mw_rotr_1();
							mtw_STConsLabel_1();
							push_value(d7);
						}
						mw_pack2_1();
						mtw_SOME_1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mw_drop2_1();
						push_u64(0LL); // NONE
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
			}
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_new_21__5();
					mtw_STMeta_1();
					mw_new_21__5();
					mtw_TMeta_1();
					mw_dup2_1();
					push_value(d5);
				}
				mtw_STConsLabel_1();
				mw__3E_Type_3();
				mtw_SOME_1();
				push_value(d4);
			}
			mfld__7E_type_3F__1();
			mp_prim_mut_set();
			mw_pack2_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_force_cons_3F__21__1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // STACK_TYPE_ERROR
			push_u64(0LL); // TYPE_ERROR
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // STACK_TYPE_DONT_CARE
			push_u64(1LL); // TYPE_DONT_CARE
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			mp_prim_swap();
			mw_force_cons_3F__21__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_unpack2_1();
					{
						VAL d6 = pop_value();
						mw_over_1();
						mtw_STWith_1();
						push_value(d6);
					}
					mw_pack2_1();
					mtw_SOME_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_rotl_1();
			mw_force_cons_3F__21__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mw_unpack2_1();
					{
						VAL d6 = pop_value();
						mw_rotr_1();
						mtw_STConsLabel_1();
						push_value(d6);
					}
					mw_pack2_1();
					mtw_SOME_1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mw_drop2_1();
					push_u64(0LL); // NONE
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			{
				VAL d4 = pop_value();
				mw_new_21__5();
				mtw_STMeta_1();
				mw_new_21__5();
				mtw_TMeta_1();
				mw_dup2_1();
				mtw_STCons_1();
				mw__3E_Type_3();
				mtw_SOME_1();
				push_value(d4);
			}
			mfld__7E_type_3F__1();
			mp_prim_mut_set();
			mw_pack2_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_force_with_3F__21__1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // STACK_TYPE_ERROR
			push_u64(0LL); // TYPE_ERROR
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // STACK_TYPE_DONT_CARE
			push_u64(1LL); // TYPE_DONT_CARE
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			mw_pack2_1();
			mtw_SOME_1();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			mp_prim_swap();
			mw_force_with_3F__21__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_unpack2_1();
					{
						VAL d6 = pop_value();
						mw_over_1();
						mtw_STCons_1();
						push_value(d6);
					}
					mw_pack2_1();
					mtw_SOME_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			mw_rotl_1();
			mw_force_with_3F__21__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mw_unpack2_1();
					{
						VAL d6 = pop_value();
						mw_rotr_1();
						mtw_STConsLabel_1();
						push_value(d6);
					}
					mw_pack2_1();
					mtw_SOME_1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mw_drop2_1();
					push_u64(0LL); // NONE
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			{
				VAL d4 = pop_value();
				mw_new_21__5();
				mtw_STMeta_1();
				mw_new_21__5();
				mtw_TMeta_1();
				mw_dup2_1();
				mtw_STWith_1();
				mw__3E_Type_3();
				mtw_SOME_1();
				push_value(d4);
			}
			mfld__7E_type_3F__1();
			mp_prim_mut_set();
			mw_pack2_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_trace_dom_21__1 (void) {
	mw_expand_2();
	mp_prim_dup();
	mw_unit_3F__1();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		mw_trace_21__10();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(" ", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_trace_21__2();
	}
}
static void mw_trace_cod_21__1 (void) {
	mw_expand_2();
	mp_prim_dup();
	mw_unit_3F__1();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(" ", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_trace_21__2();
		mw_trace_21__10();
	}
}
static void mw_trace_base_21__1 (void) {
	switch (get_top_data_tag()) {
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			mp_prim_id();
			push_u64(0LL); // F
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("*", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__7();
			push_u64(1LL); // T
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mp_prim_dup();
			mw_trace_21__5();
			mw_is_stack_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			push_u64(1LL); // T
			break;
		default:
			mw__3E_Type_3();
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
	}
}
static void mw_trace_21__10 (void) {
	mw_split4_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_trace_base_21__1();
				push_value(d4);
			}
			push_value(d3);
		}
		push_value(d2);
	}
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // L1
					mtp_L1_1();
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_unpack2_1();
					mw__3E_Str_6();
					mw_trace_21__2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(":", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					mw_trace_21__11();
					push_u64(1LL); // T
					break;
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						switch (get_top_data_tag()) {
							case 1LL: // T
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr(" ", 1);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mw_trace_21__2();
								break;
							case 0LL: // F
								(void)pop_u64();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_unpack2_1();
						mw__3E_Str_6();
						mw_trace_21__2();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(":", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						mw_trace_21__11();
						push_u64(1LL); // T
						push_value(d6);
					}
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_unpack2_1();
					mw__3E_Str_6();
					mw_trace_21__2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(":", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					mw_trace_21__11();
					push_u64(1LL); // T
					break;
				case 3LL: // L3
					mtp_L3_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mp_prim_swap();
							switch (get_top_data_tag()) {
								case 1LL: // T
									(void)pop_u64();
									{
										static bool vready = false;
										static VAL v;
										if (! vready) {
											v = mkstr(" ", 1);
											vready = true;
										}
										push_value(v);
										incref(v);
									}
									mw_trace_21__2();
									break;
								case 0LL: // F
									(void)pop_u64();
									mp_prim_id();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							mw_unpack2_1();
							mw__3E_Str_6();
							mw_trace_21__2();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(":", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							mw_trace_21__11();
							push_u64(1LL); // T
							push_value(d7);
						}
						mp_prim_swap();
						switch (get_top_data_tag()) {
							case 1LL: // T
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr(" ", 1);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mw_trace_21__2();
								break;
							case 0LL: // F
								(void)pop_u64();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_unpack2_1();
						mw__3E_Str_6();
						mw_trace_21__2();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(":", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						mw_trace_21__11();
						push_u64(1LL); // T
						push_value(d6);
					}
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_unpack2_1();
					mw__3E_Str_6();
					mw_trace_21__2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(":", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					mw_trace_21__11();
					push_u64(1LL); // T
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					mp_prim_drop();
					{
						VAL d6 = pop_value();
						mw_for_3_160();
						push_value(d6);
					}
					mw_for_3_160();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			push_value(d3);
		}
		push_value(d2);
	}
	{
		VAL d2 = pop_value();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__11();
				push_u64(1LL); // T
				break;
			case 2LL: // L2
				mtp_L2_1();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_trace_21__11();
					push_u64(1LL); // T
					push_value(d5);
				}
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__11();
				push_u64(1LL); // T
				break;
			case 3LL: // L3
				mtp_L3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						switch (get_top_data_tag()) {
							case 1LL: // T
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr(" ", 1);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mw_trace_21__2();
								break;
							case 0LL: // F
								(void)pop_u64();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_trace_21__11();
						push_u64(1LL); // T
						push_value(d6);
					}
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_trace_21__11();
					push_u64(1LL); // T
					push_value(d5);
				}
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__11();
				push_u64(1LL); // T
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				{
					VAL d5 = pop_value();
					mw_for_3_163();
					push_value(d5);
				}
				mw_for_3_163();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		push_value(d2);
	}
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__9();
			push_u64(1LL); // T
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__9();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__9();
			push_u64(1LL); // T
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_trace_21__9();
					push_u64(1LL); // T
					push_value(d5);
				}
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__9();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__9();
			push_u64(1LL); // T
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_165();
				push_value(d4);
			}
			mw_for_3_165();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_drop();
}
static void mw_semifreshen_1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			mp_prim_dup();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_semifreshen_1();
				push_value(d4);
			}
			mtw_STCons_1();
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_semifreshen_1();
				push_value(d4);
			}
			mtw_STWith_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_semifreshen_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mtw_STConsLabel_1();
			break;
		default:
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected unit-based stack in semifreshen!", 41);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
	}
}
static void mw_freshen_5 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			push_u64(2LL); // STACK_TYPE_UNIT
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_freshen_5();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_freshen_6();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_STCons_1();
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_freshen_5();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_freshen_4();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_STWith_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_freshen_5();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_freshen_6();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_STConsLabel_1();
			break;
		default:
			mw__3E_Type_3();
			mw_freshen_6();
			mw__3E_StackType_1();
			break;
	}
}
static void mw_freshen_aux_1 (void) {
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			mw_over_1();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_freshen_aux_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_freshen_6();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_STCons_1();
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_freshen_aux_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_freshen_4();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_STWith_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_freshen_aux_1();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_freshen_6();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_STConsLabel_1();
			break;
		default:
			mw__3E_Type_3();
			mw_freshen_6();
			mw__3E_StackType_1();
			break;
	}
}
static void mw_rigidify_21__3 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // STACK_TYPE_ERROR
			break;
		case 1LL: // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			push_u64(1LL); // STACK_TYPE_DONT_CARE
			break;
		case 2LL: // STACK_TYPE_UNIT
			(void)pop_u64();
			push_u64(2LL); // STACK_TYPE_UNIT
			break;
		case 4LL: // STMeta
			mtp_STMeta_1();
			mp_prim_dup();
			mw_type_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						mw_fresh_stack_type_var_21__1();
						mtw_TVar_1();
						mp_prim_dup();
						mtw_SOME_1();
						push_value(d6);
					}
					mfld__7E_type_3F__1();
					mp_prim_mut_set();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_nip_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw__3E_StackType_1();
			mw_rigidify_21__3();
			break;
		case 3LL: // STVar
			mtp_STVar_1();
			mtw_STVar_1();
			break;
		case 5LL: // STCons
			mtp_STCons_1();
			{
				VAL d4 = pop_value();
				mw_rigidify_21__3();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_rigidify_21__4();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_STCons_1();
			break;
		case 6LL: // STConsLabel
			mtp_STConsLabel_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_rigidify_21__3();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_rigidify_21__4();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_STConsLabel_1();
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			{
				VAL d4 = pop_value();
				mw_rigidify_21__3();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_rigidify_21__2();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_STWith_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3E_Type_1 (void) {
	mtw_TMorphism_1();
}
static void mw_unpack_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // ARROW_TYPE
			mtp_ARROW_5F_TYPE_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dom_1 (void) {
	mw_unpack_1();
	mp_prim_drop();
}
static void mw_cod_1 (void) {
	mw_unpack_1();
	mw_nip_1();
}
static void mw_unify_21__2 (void) {
	{
		VAL d2 = pop_value();
		mw_unpack_1();
		push_value(d2);
	}
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		{
			VAL d3 = pop_value();
			mw_unify_21__6();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_rotl_1();
	{
		VAL d2 = pop_value();
		mw_unify_21__6();
		push_value(d2);
	}
	mp_prim_swap();
	mtw_ARROW_5F_TYPE_1();
}
static void mw_has_meta_3F__1 (void) {
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mw_over_1();
		push_value(d2);
	}
	mw_has_meta_3F__4();
	if (pop_u64()) {
		mw_drop2_1();
		push_u64(1LL); // T
	} else {
		mw_has_meta_3F__4();
	}
}
static void mw_trace_21__6 (void) {
	mw_unpack_1();
	mp_prim_swap();
	mw_trace_dom_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("--", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	mw_trace_cod_21__1();
}
static void mw_semifreshen_sig_1 (void) {
	mp_prim_dup();
	mw_needs_fresh_stack_rest_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_semifreshen_aux_1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_semifreshen_aux_1 (void) {
	mw_new_21__5();
	mtw_STMeta_1();
	mp_prim_swap();
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mw_semifreshen_1();
		push_value(d2);
	}
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_semifreshen_1();
		push_value(d2);
	}
	mp_prim_swap();
	mtw_ARROW_5F_TYPE_1();
	mw_nip_1();
}
static void mw_needs_fresh_stack_rest_3F__1 (void) {
	mw_unpack_1();
	mw_base_1();
	mw_unit_3F__1();
	if (pop_u64()) {
		mw_base_1();
		mw_unit_3F__1();
	} else {
		mp_prim_drop();
		push_u64(0LL); // F
	}
}
static void mw_freshen_sig_1 (void) {
	mp_prim_dup();
	mw_needs_fresh_stack_rest_3F__1();
	if (pop_u64()) {
		mw_freshen_sig_aux_1();
	} else {
		mw_freshen_2();
	}
}
static void mw_freshen_sig_aux_1 (void) {
	mw_new_21__5();
	mtw_STMeta_1();
	mw_rotr_1();
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mw_freshen_aux_1();
		push_value(d2);
	}
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_freshen_aux_1();
		push_value(d2);
	}
	mp_prim_swap();
	mtw_ARROW_5F_TYPE_1();
	{
		VAL d2 = pop_value();
		mw_nip_1();
		push_value(d2);
	}
}
static void mw_freshen_2 (void) {
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mw_freshen_5();
		push_value(d2);
	}
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_freshen_5();
		push_value(d2);
	}
	mp_prim_swap();
	mtw_ARROW_5F_TYPE_1();
}
static void mw_rigidify_21__1 (void) {
	mw_unpack_1();
	{
		VAL d2 = pop_value();
		mw_rigidify_21__3();
		push_value(d2);
	}
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_rigidify_21__3();
		push_value(d2);
	}
	mp_prim_swap();
	mtw_ARROW_5F_TYPE_1();
}
static void mw_rigidify_sig_21__1 (void) {
	mw_rigidify_21__1();
}
static void mw_nil_6 (void) {
	push_u64(0LL); // SUBST_NIL
}
static void mw_cons_3 (void) {
	mw_rotr_1();
	mtw_SUBST_5F_CON_1();
}
static void mw_has_var_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // SUBST_NIL
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 1LL: // SUBST_CON
			mtp_SUBST_5F_CON_1();
			mw_nip_1();
			mw_over2_1();
			mw__3D__3D__21();
			if (pop_u64()) {
				mw_drop2_1();
				push_u64(1LL); // T
			} else {
				mw_has_var_3F__1();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_get_var_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // SUBST_NIL
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // TYPE_ERROR
			break;
		case 1LL: // SUBST_CON
			mtp_SUBST_5F_CON_1();
			mw_over3_1();
			mw__3D__3D__21();
			if (pop_u64()) {
				{
					VAL d5 = pop_value();
					mw_drop2_1();
					push_value(d5);
				}
			} else {
				mp_prim_drop();
				mw_get_var_1();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_qname_7 (void) {
	mw_prim_2();
	LPUSH(lbl_namespace);
	mp_prim_dup();
	mw_name_9();
	LPUSH(lbl_name);
	mw_arity_3();
	LPUSH(lbl_arity);
	mtw_MKQNAME_1();
}
static void mw_name_9 (void) {
	mfld__7E_name_2();
	mp_prim_mut_get();
}
static void mw_type_7 (void) {
	mfld__7E_type_3();
	mp_prim_mut_get();
}
static void mw_arity_3 (void) {
	mfld__7E_arity_2();
	mp_prim_mut_get();
}
static void mw_def_prim_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw__3E_Name_1();
		mw_over_1();
		mfld__7E_name_2();
		mp_prim_mut_set();
		push_value(d2);
	}
	mw_over_1();
	mfld__7E_arity_2();
	mp_prim_mut_set();
	mtw_DEF_5F_PRIM_1();
	mw_register_1();
}
static void mw_ctx_type_21__1 (void) {
	mw_tuck_1();
	mfld__7E_type_3();
	mp_prim_mut_set();
	mfld__7E_ctx_1();
	mp_prim_mut_set();
}
static void mw_init_prims_21__1 (void) {
	push_u64(75LL); // PRIM_SYNTAX_MODULE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("module", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(76LL); // PRIM_SYNTAX_IMPORT
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("import", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(78LL); // PRIM_SYNTAX_INLINE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("inline", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(77LL); // PRIM_SYNTAX_ALIAS
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("alias", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(79LL); // PRIM_SYNTAX_DEF
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("def", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(81LL); // PRIM_SYNTAX_DEF_TYPE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("def-type", 8);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(80LL); // PRIM_SYNTAX_DEF_MISSING
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("def-missing", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(82LL); // PRIM_SYNTAX_BUFFER
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("buffer", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(84LL); // PRIM_SYNTAX_DEF_EXTERNAL
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("def-external", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(86LL); // PRIM_SYNTAX_TABLE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("table", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(87LL); // PRIM_SYNTAX_FIELD
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("field", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(85LL); // PRIM_SYNTAX_EMBED_STR
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("embed-str", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(88LL); // PRIM_SYNTAX_DATA
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("data", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(83LL); // PRIM_SYNTAX_VARIABLE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("var", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(90LL); // PRIM_SYNTAX_ARROW
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("->", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(89LL); // PRIM_SYNTAX_DASHES
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("--", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(4LL); // PRIM_CORE_DIP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("dip", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(1LL);
	mw_def_prim_21__1();
	push_u64(6LL); // PRIM_CORE_WHILE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("while", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(2LL);
	mw_def_prim_21__1();
	push_u64(10LL); // PRIM_CORE_MATCH
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("match", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(11LL); // PRIM_CORE_LAMBDA
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\\", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(0LL); // PRIM_CORE_ID
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-id", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(1LL); // PRIM_CORE_DUP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-dup", 8);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(2LL); // PRIM_CORE_DROP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-drop", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(3LL); // PRIM_CORE_SWAP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-swap", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(4LL); // PRIM_CORE_DIP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-dip", 8);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(1LL);
	mw_def_prim_21__1();
	push_u64(5LL); // PRIM_CORE_IF
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-if", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(2LL);
	mw_def_prim_21__1();
	push_u64(6LL); // PRIM_CORE_WHILE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-while", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(2LL);
	mw_def_prim_21__1();
	push_u64(7LL); // PRIM_CORE_DEBUG
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-debug", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(8LL); // PRIM_CORE_PANIC
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-panic", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(9LL); // PRIM_CORE_RUN
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-run", 8);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(10LL); // PRIM_CORE_MATCH
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-match", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(11LL); // PRIM_CORE_LAMBDA
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-lambda", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(-1LL);
	mw_def_prim_21__1();
	push_u64(12LL); // PRIM_CORE_RSWAP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-rswap", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(13LL); // PRIM_CORE_RDIP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-rdip", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(1LL);
	mw_def_prim_21__1();
	push_u64(16LL); // PRIM_INT_ADD
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-add", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(17LL); // PRIM_INT_SUB
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-sub", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(18LL); // PRIM_INT_MUL
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-mul", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(19LL); // PRIM_INT_DIV
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-div", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(20LL); // PRIM_INT_MOD
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-mod", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(21LL); // PRIM_INT_AND
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-and", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(22LL); // PRIM_INT_OR
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-or", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(23LL); // PRIM_INT_XOR
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-xor", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(24LL); // PRIM_INT_SHL
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-shl", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(25LL); // PRIM_INT_SHR
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-shr", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(26LL); // PRIM_INT_TO_STR
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-to-str", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(14LL); // PRIM_INT_EQ
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-eq", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(15LL); // PRIM_INT_LT
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-int-lt", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(27LL); // PRIM_PACK_NIL
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-pack-nil", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(28LL); // PRIM_PACK_CONS
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-pack-cons", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(29LL); // PRIM_PACK_UNCONS
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-pack-uncons", 16);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(31LL); // PRIM_MUT_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-mut-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(32LL); // PRIM_MUT_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-mut-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(33LL); // PRIM_MUT_IS_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-mut-is-set", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(34LL); // PRIM_PTR_NIL
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-nil", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(35LL); // PRIM_PTR_EQ
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-eq", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(36LL); // PRIM_PTR_ADD
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-add", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(37LL); // PRIM_PTR_SIZE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-size", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(38LL); // PRIM_PTR_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(39LL); // PRIM_PTR_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(40LL); // PRIM_PTR_ALLOC
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-alloc", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(41LL); // PRIM_PTR_REALLOC
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-realloc", 16);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(42LL); // PRIM_PTR_FREE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-free", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(44LL); // PRIM_PTR_FILL
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-fill", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(43LL); // PRIM_PTR_COPY
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-ptr-copy", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(46LL); // PRIM_STR_COPY
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-str-copy", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(47LL); // PRIM_STR_NUM_BYTES
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-str-num-bytes", 18);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(48LL); // PRIM_STR_BASE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-str-base", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(49LL); // PRIM_STR_CAT
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-str-cat", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(45LL); // PRIM_STR_CMP
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-str-cmp", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(50LL); // PRIM_U8_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u8-get", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(51LL); // PRIM_U8_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u8-set", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(52LL); // PRIM_U16_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u16-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(53LL); // PRIM_U16_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u16-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(54LL); // PRIM_U32_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u32-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(55LL); // PRIM_U32_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u32-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(56LL); // PRIM_U64_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u64-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(57LL); // PRIM_U64_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-u64-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(58LL); // PRIM_I8_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i8-get", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(59LL); // PRIM_I8_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i8-set", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(60LL); // PRIM_I16_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i16-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(61LL); // PRIM_I16_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i16-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(62LL); // PRIM_I32_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i32-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(63LL); // PRIM_I32_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i32-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(64LL); // PRIM_I64_GET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i64-get", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(65LL); // PRIM_I64_SET
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-i64-set", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(66LL); // PRIM_SYS_OS
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-sys-os", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(67LL); // PRIM_SYS_ARGC
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-sys-argc", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(68LL); // PRIM_SYS_ARGV
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-sys-argv", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(69LL); // PRIM_POSIX_READ
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-posix-read", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(70LL); // PRIM_POSIX_WRITE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-posix-write", 16);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(71LL); // PRIM_POSIX_OPEN
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-posix-open", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(72LL); // PRIM_POSIX_CLOSE
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-posix-close", 16);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	push_u64(73LL); // PRIM_POSIX_EXIT
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("prim-posix-exit", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_def_prim_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_T0_1();
	mw_T__3E__1();
	mw_dup2_1();
	push_u64(0LL); // PRIM_CORE_ID
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(7LL); // PRIM_CORE_DEBUG
	mw_ctx_type_21__1();
	mw_drop2_1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_T2_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_dup2_1();
	push_u64(16LL); // PRIM_INT_ADD
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(17LL); // PRIM_INT_SUB
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(18LL); // PRIM_INT_MUL
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(19LL); // PRIM_INT_DIV
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(20LL); // PRIM_INT_MOD
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(21LL); // PRIM_INT_AND
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(22LL); // PRIM_INT_OR
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(23LL); // PRIM_INT_XOR
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(24LL); // PRIM_INT_SHL
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(25LL); // PRIM_INT_SHR
	mw_ctx_type_21__1();
	mw_drop2_1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_T2_1();
	mw_TYPE_5F_BOOL_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_dup2_1();
	push_u64(14LL); // PRIM_INT_EQ
	mw_ctx_type_21__1();
	mw_dup2_1();
	push_u64(15LL); // PRIM_INT_LT
	mw_ctx_type_21__1();
	mw_drop2_1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_TYPE_5F_STR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(26LL); // PRIM_INT_TO_STR
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(38LL); // PRIM_PTR_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_U8_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(50LL); // PRIM_U8_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_U16_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(52LL); // PRIM_U16_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_U32_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(54LL); // PRIM_U32_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_U64_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(56LL); // PRIM_U64_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_I8_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(58LL); // PRIM_I8_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_I16_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(60LL); // PRIM_I16_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_I32_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(62LL); // PRIM_I32_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_TYPE_5F_I64_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(64LL); // PRIM_I64_GET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(39LL); // PRIM_PTR_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_U8_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(51LL); // PRIM_U8_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_U16_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(53LL); // PRIM_U16_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_U32_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(55LL); // PRIM_U32_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_U64_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(57LL); // PRIM_U64_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_I8_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(59LL); // PRIM_I8_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_I16_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(61LL); // PRIM_I16_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_I32_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(63LL); // PRIM_I32_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_I64_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(65LL); // PRIM_I64_SET
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_T3_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(69LL); // PRIM_POSIX_READ
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_T3_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(70LL); // PRIM_POSIX_WRITE
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_T3_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(71LL); // PRIM_POSIX_OPEN
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(72LL); // PRIM_POSIX_CLOSE
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_T6_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(74LL); // PRIM_POSIX_MMAP
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(34LL); // PRIM_PTR_NIL
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_TYPE_5F_BOOL_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(35LL); // PRIM_PTR_EQ
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_PTR_1();
	mw_T2_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(36LL); // PRIM_PTR_ADD
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(37LL); // PRIM_PTR_SIZE
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(40LL); // PRIM_PTR_ALLOC
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_T2_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(41LL); // PRIM_PTR_REALLOC
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(42LL); // PRIM_PTR_FREE
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_PTR_1();
	mw_T3_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(43LL); // PRIM_PTR_COPY
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_INT_1();
	mw_TYPE_5F_PTR_1();
	mw_T3_1();
	mw_T0_1();
	mw_T__3E__1();
	push_u64(44LL); // PRIM_PTR_FILL
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_PTR_1();
	mw_TYPE_5F_INT_1();
	mw_T2_1();
	mw_TYPE_5F_STR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(46LL); // PRIM_STR_COPY
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_STR_1();
	mw_T1_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(47LL); // PRIM_STR_NUM_BYTES
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_STR_1();
	mw_T1_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(48LL); // PRIM_STR_BASE
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_STR_1();
	mw_TYPE_5F_STR_1();
	mw_T2_1();
	mw_TYPE_5F_STR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(49LL); // PRIM_STR_CAT
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_TYPE_5F_STR_1();
	mw_TYPE_5F_STR_1();
	mw_T2_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(45LL); // PRIM_STR_CMP
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(66LL); // PRIM_SYS_OS
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(67LL); // PRIM_SYS_ARGC
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_TYPE_5F_PTR_1();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(68LL); // PRIM_SYS_ARGV
	mw_ctx_type_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_T0_1();
	mw__3E_Type_3();
	mw_T1_1();
	mw_T__3E__1();
	push_u64(27LL); // PRIM_PACK_NIL
	mw_ctx_type_21__1();
	mw_TYPE_5F_TYPE_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("a", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_TYPE_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("b", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_TYPE_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("c", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_RESOURCE_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("+r", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_RESOURCE_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("+s", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_STACK_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("*x", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_STACK_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("*y", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	{
		VAL var_ys = pop_value();
		VAL var_xs = pop_value();
		VAL var_sr = pop_value();
		VAL var_rr = pop_value();
		VAL var_c = pop_value();
		VAL var_b = pop_value();
		VAL var_a = pop_value();
		incref(var_a);
		push_value(var_a);
		mtw_TVar_1();
		incref(var_b);
		push_value(var_b);
		mtw_TVar_1();
		incref(var_c);
		push_value(var_c);
		mtw_TVar_1();
		incref(var_rr);
		push_value(var_rr);
		mtw_TVar_1();
		incref(var_sr);
		push_value(var_sr);
		mtw_TVar_1();
		incref(var_xs);
		push_value(var_xs);
		mtw_STVar_1();
		incref(var_ys);
		push_value(var_ys);
		mtw_STVar_1();
		{
			VAL var_tys = pop_value();
			VAL var_txs = pop_value();
			VAL var_tsr = pop_value();
			VAL var_trr = pop_value();
			VAL var_tc = pop_value();
			VAL var_tb = pop_value();
			VAL var_ta = pop_value();
			incref(var_a);
			push_value(var_a);
			mw_CTX1_1();
			incref(var_ta);
			push_value(var_ta);
			mw_T1_1();
			mw_T0_1();
			mw_T__3E__1();
			push_u64(2LL); // PRIM_CORE_DROP
			mw_ctx_type_21__1();
			incref(var_a);
			push_value(var_a);
			mw_CTX1_1();
			incref(var_ta);
			push_value(var_ta);
			mw_T1_1();
			incref(var_ta);
			push_value(var_ta);
			incref(var_ta);
			push_value(var_ta);
			mw_T2_1();
			mw_T__3E__1();
			push_u64(1LL); // PRIM_CORE_DUP
			mw_ctx_type_21__1();
			incref(var_a);
			push_value(var_a);
			incref(var_b);
			push_value(var_b);
			mw_CTX2_1();
			incref(var_ta);
			push_value(var_ta);
			incref(var_tb);
			push_value(var_tb);
			mw_T2_1();
			incref(var_tb);
			push_value(var_tb);
			incref(var_ta);
			push_value(var_ta);
			mw_T2_1();
			mw_T__3E__1();
			push_u64(3LL); // PRIM_CORE_SWAP
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_ys);
			push_value(var_ys);
			mw_CTX2_1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_txs);
			push_value(var_txs);
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			mw__3E_Type_1();
			mw_T_2A__1();
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			push_u64(9LL); // PRIM_CORE_RUN
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_ys);
			push_value(var_ys);
			mw_CTX2_1();
			incref(var_txs);
			push_value(var_txs);
			mw_TYPE_5F_INT_1();
			mw_T_2A__1();
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			push_u64(73LL); // PRIM_POSIX_EXIT
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_ys);
			push_value(var_ys);
			mw_CTX2_1();
			incref(var_txs);
			push_value(var_txs);
			mw_TYPE_5F_STR_1();
			mw_T_2A__1();
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			push_u64(8LL); // PRIM_CORE_PANIC
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_ys);
			push_value(var_ys);
			incref(var_c);
			push_value(var_c);
			mw_CTX3_1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_tc);
			push_value(var_tc);
			mw_T_2A__1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			mw__3E_Type_1();
			mw_T_2A__1();
			incref(var_tys);
			push_value(var_tys);
			incref(var_tc);
			push_value(var_tc);
			mw_T_2A__1();
			mw_T__3E__1();
			push_u64(4LL); // PRIM_CORE_DIP
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_ys);
			push_value(var_ys);
			mw_CTX2_1();
			incref(var_txs);
			push_value(var_txs);
			mw_TYPE_5F_BOOL_1();
			mw_T_2A__1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			mw__3E_Type_1();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			push_u64(5LL); // PRIM_CORE_IF
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			mw_CTX1_1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_txs);
			push_value(var_txs);
			incref(var_txs);
			push_value(var_txs);
			mw_TYPE_5F_BOOL_1();
			mw_T_2A__1();
			mw_T__3E__1();
			mw__3E_Type_1();
			mw_T_2A__1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_txs);
			push_value(var_txs);
			mw_T__3E__1();
			mw__3E_Type_1();
			mw_T_2A__1();
			incref(var_txs);
			push_value(var_txs);
			mw_T__3E__1();
			push_u64(6LL); // PRIM_CORE_WHILE
			mw_ctx_type_21__1();
			incref(var_rr);
			push_value(var_rr);
			incref(var_sr);
			push_value(var_sr);
			mw_CTX2_1();
			mw_T0_1();
			incref(var_trr);
			push_value(var_trr);
			mw_T_2B__1();
			incref(var_tsr);
			push_value(var_tsr);
			mw_T_2B__1();
			mw_T0_1();
			incref(var_tsr);
			push_value(var_tsr);
			mw_T_2B__1();
			incref(var_trr);
			push_value(var_trr);
			mw_T_2B__1();
			mw_T__3E__1();
			push_u64(12LL); // PRIM_CORE_RSWAP
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_ys);
			push_value(var_ys);
			incref(var_rr);
			push_value(var_rr);
			mw_CTX3_1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_trr);
			push_value(var_trr);
			mw_T_2B__1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_tys);
			push_value(var_tys);
			mw_T__3E__1();
			mw__3E_Type_1();
			mw_T_2A__1();
			incref(var_tys);
			push_value(var_tys);
			incref(var_trr);
			push_value(var_trr);
			mw_T_2B__1();
			mw_T__3E__1();
			push_u64(13LL); // PRIM_CORE_RDIP
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_b);
			push_value(var_b);
			mw_CTX2_1();
			incref(var_txs);
			push_value(var_txs);
			mw__3E_Type_3();
			incref(var_tb);
			push_value(var_tb);
			mw_T2_1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_tb);
			push_value(var_tb);
			mw_T_2A__1();
			mw__3E_Type_3();
			mw_T1_1();
			mw_T__3E__1();
			push_u64(28LL); // PRIM_PACK_CONS
			mw_ctx_type_21__1();
			incref(var_xs);
			push_value(var_xs);
			incref(var_b);
			push_value(var_b);
			mw_CTX2_1();
			incref(var_txs);
			push_value(var_txs);
			incref(var_tb);
			push_value(var_tb);
			mw_T_2A__1();
			mw__3E_Type_3();
			mw_T1_1();
			incref(var_txs);
			push_value(var_txs);
			mw__3E_Type_3();
			incref(var_tb);
			push_value(var_tb);
			mw_T2_1();
			mw_T__3E__1();
			push_u64(29LL); // PRIM_PACK_UNCONS
			mw_ctx_type_21__1();
			incref(var_a);
			push_value(var_a);
			mw_CTX1_1();
			incref(var_ta);
			push_value(var_ta);
			mw_T1_1();
			incref(var_ta);
			push_value(var_ta);
			mtw_TMut_1();
			mw_T1_1();
			mw_T__3E__1();
			push_u64(30LL); // PRIM_MUT_NEW
			mw_ctx_type_21__1();
			incref(var_a);
			push_value(var_a);
			mw_CTX1_1();
			incref(var_ta);
			push_value(var_ta);
			mtw_TMut_1();
			mw_T1_1();
			incref(var_ta);
			push_value(var_ta);
			mw_T1_1();
			mw_T__3E__1();
			push_u64(31LL); // PRIM_MUT_GET
			mw_ctx_type_21__1();
			incref(var_a);
			push_value(var_a);
			mw_CTX1_1();
			incref(var_ta);
			push_value(var_ta);
			incref(var_ta);
			push_value(var_ta);
			mtw_TMut_1();
			mw_T2_1();
			mw_T0_1();
			mw_T__3E__1();
			push_u64(32LL); // PRIM_MUT_SET
			mw_ctx_type_21__1();
			incref(var_a);
			push_value(var_a);
			mw_CTX1_1();
			incref(var_ta);
			push_value(var_ta);
			mtw_TMut_1();
			mw_T1_1();
			mw_TYPE_5F_BOOL_1();
			mw_T1_1();
			mw_T__3E__1();
			push_u64(33LL); // PRIM_MUT_IS_SET
			mw_ctx_type_21__1();
			decref(var_tys);
			decref(var_txs);
			decref(var_tsr);
			decref(var_trr);
			decref(var_tc);
			decref(var_tb);
			decref(var_ta);
		}
		decref(var_ys);
		decref(var_xs);
		decref(var_sr);
		decref(var_rr);
		decref(var_c);
		decref(var_b);
		decref(var_a);
	}
}
static void mw_none_3F__3 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TOKEN_NONE
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_comma_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // TOKEN_COMMA
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_lparen_open_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 2LL: // TOKEN_LPAREN_OPEN
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_lparen_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TOKEN_LPAREN
			mtp_TOKEN_5F_LPAREN_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_lsquare_open_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 5LL: // TOKEN_LSQUARE_OPEN
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_lsquare_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 6LL: // TOKEN_LSQUARE
			mtp_TOKEN_5F_LSQUARE_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_rsquare_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 7LL: // TOKEN_RSQUARE
			mtp_TOKEN_5F_RSQUARE_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_lcurly_open_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 8LL: // TOKEN_LCURLY_OPEN
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_lcolon_open_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 11LL: // TOKEN_LCOLON_OPEN
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_lcolon_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 12LL: // TOKEN_LCOLON
			mtp_TOKEN_5F_LCOLON_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_lparen_or_lcolon_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TOKEN_LPAREN
			mtp_TOKEN_5F_LPAREN_1();
			mtw_SOME_1();
			break;
		case 12LL: // TOKEN_LCOLON
			mtp_TOKEN_5F_LCOLON_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_int_3F__3 (void) {
	switch (get_top_data_tag()) {
		case 14LL: // TOKEN_INT
			mtp_TOKEN_5F_INT_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_str_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 15LL: // TOKEN_STR
			mtp_TOKEN_5F_STR_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_name_3F__3 (void) {
	switch (get_top_data_tag()) {
		case 16LL: // TOKEN_NAME
			mtp_TOKEN_5F_NAME_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_dname_3F__3 (void) {
	switch (get_top_data_tag()) {
		case 17LL: // TOKEN_DNAME
			mtp_TOKEN_5F_DNAME_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_name_or_dname_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 16LL: // TOKEN_NAME
			mtp_TOKEN_5F_NAME_1();
			mtw_LEFT_1();
			mtw_SOME_1();
			break;
		case 17LL: // TOKEN_DNAME
			mtp_TOKEN_5F_DNAME_1();
			mtw_RIGHT_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_arg_end_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // TOKEN_COMMA
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 4LL: // TOKEN_RPAREN
			mtp_TOKEN_5F_RPAREN_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 10LL: // TOKEN_RCURLY
			mtp_TOKEN_5F_RCURLY_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 7LL: // TOKEN_RSQUARE
			mtp_TOKEN_5F_RSQUARE_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 13LL: // TOKEN_RCOLON
			mtp_TOKEN_5F_RCOLON_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_left_enclosure_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // TOKEN_LPAREN
			mtp_TOKEN_5F_LPAREN_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 6LL: // TOKEN_LSQUARE
			mtp_TOKEN_5F_LSQUARE_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 9LL: // TOKEN_LCURLY
			mtp_TOKEN_5F_LCURLY_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 12LL: // TOKEN_LCOLON
			mtp_TOKEN_5F_LCOLON_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_right_enclosure_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 4LL: // TOKEN_RPAREN
			mtp_TOKEN_5F_RPAREN_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 7LL: // TOKEN_RSQUARE
			mtp_TOKEN_5F_RSQUARE_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 10LL: // TOKEN_RCURLY
			mtp_TOKEN_5F_RCURLY_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 13LL: // TOKEN_RCOLON
			mtp_TOKEN_5F_RCOLON_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_sig_type_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_type_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_type_con_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_type_con_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_type_hole_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_is_type_hole_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_type_var_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_type_var_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_param_name_3F__2 (void) {
	mw_sig_type_var_3F__2();
}
static void mw_sig_stack_var_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_stack_var_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_resource_var_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_resource_var_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_resource_con_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_resource_con_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_dashes_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			push_u64(89LL); // PRIM_SYNTAX_DASHES
			mw_name_9();
			mw__3D__3D__30();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_pat_arrow_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			push_u64(90LL); // PRIM_SYNTAX_ARROW
			mw_name_9();
			mw__3D__3D__30();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_pat_underscore_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_is_underscore_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_module_header_3F__2 (void) {
	mw_name_3F__3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw__3E_Str_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("module", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3D__3D__7();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_index_8 (void) {
}
static void mw_succ_7 (void) {
	push_i64(1LL);
	mp_prim_int_add();
	mbuf_NUM_6();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_int_mod();
}
static void mw_pred_7 (void) {
	mp_prim_dup();
	push_i64(0LL);
	mp_prim_int_eq();
	if (pop_u64()) {
	} else {
		push_i64(1LL);
		mp_prim_int_sub();
	}
}
static void mw_alloc_21__6 (void) {
	mbuf_NUM_6();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_6();
	mp_prim_u64_set();
}
static void mw__3D__3D__25 (void) {
	{
		VAL d2 = pop_value();
		mw_index_8();
		push_value(d2);
	}
	mw_index_8();
	mp_prim_int_eq();
}
static void mw_value_3 (void) {
	mfld__7E_value_1();
	mp_prim_mut_get();
}
static void mw_module_3 (void) {
	mfld__7E_module_1();
	mp_prim_mut_get();
}
static void mw_col_1 (void) {
	mfld__7E_col_1();
	mp_prim_mut_get();
}
static void mw_row_1 (void) {
	mfld__7E_row_1();
	mp_prim_mut_get();
}
static void mw_none_3F__2 (void) {
	mw_value_3();
	mw_none_3F__3();
}
static void mw_comma_3F__1 (void) {
	mw_value_3();
	mw_comma_3F__2();
}
static void mw_lparen_open_3F__1 (void) {
	mw_value_3();
	mw_lparen_open_3F__2();
}
static void mw_lparen_3F__1 (void) {
	mw_value_3();
	mw_lparen_3F__2();
}
static void mw_lsquare_open_3F__1 (void) {
	mw_value_3();
	mw_lsquare_open_3F__2();
}
static void mw_lsquare_3F__1 (void) {
	mw_value_3();
	mw_lsquare_3F__2();
}
static void mw_rsquare_3F__1 (void) {
	mw_value_3();
	mw_rsquare_3F__2();
}
static void mw_lcurly_open_3F__1 (void) {
	mw_value_3();
	mw_lcurly_open_3F__2();
}
static void mw_lcolon_open_3F__1 (void) {
	mw_value_3();
	mw_lcolon_open_3F__2();
}
static void mw_lcolon_3F__1 (void) {
	mw_value_3();
	mw_lcolon_3F__2();
}
static void mw_lparen_or_lcolon_3F__1 (void) {
	mw_value_3();
	mw_lparen_or_lcolon_3F__2();
}
static void mw_int_3F__2 (void) {
	mw_value_3();
	mw_int_3F__3();
}
static void mw_str_3F__1 (void) {
	mw_value_3();
	mw_str_3F__2();
}
static void mw_name_3F__2 (void) {
	mw_value_3();
	mw_name_3F__3();
}
static void mw_dname_3F__2 (void) {
	mw_value_3();
	mw_dname_3F__3();
}
static void mw_name_or_dname_3F__1 (void) {
	mw_value_3();
	mw_name_or_dname_3F__2();
}
static void mw_arg_end_3F__1 (void) {
	mw_value_3();
	mw_arg_end_3F__2();
}
static void mw_left_enclosure_3F__1 (void) {
	mw_value_3();
	mw_left_enclosure_3F__2();
}
static void mw_right_enclosure_3F__1 (void) {
	mw_value_3();
	mw_right_enclosure_3F__2();
}
static void mw_sig_type_3F__1 (void) {
	mw_value_3();
	mw_sig_type_3F__2();
}
static void mw_sig_type_con_3F__1 (void) {
	mw_value_3();
	mw_sig_type_con_3F__2();
}
static void mw_sig_type_hole_3F__1 (void) {
	mw_value_3();
	mw_sig_type_hole_3F__2();
}
static void mw_sig_type_var_3F__1 (void) {
	mw_value_3();
	mw_sig_type_var_3F__2();
}
static void mw_sig_param_name_3F__1 (void) {
	mw_value_3();
	mw_sig_param_name_3F__2();
}
static void mw_sig_stack_var_3F__1 (void) {
	mw_value_3();
	mw_sig_stack_var_3F__2();
}
static void mw_sig_resource_var_3F__1 (void) {
	mw_value_3();
	mw_sig_resource_var_3F__2();
}
static void mw_sig_resource_con_3F__1 (void) {
	mw_value_3();
	mw_sig_resource_con_3F__2();
}
static void mw_sig_dashes_3F__1 (void) {
	mw_value_3();
	mw_sig_dashes_3F__2();
}
static void mw_pat_arrow_3F__1 (void) {
	mw_value_3();
	mw_pat_arrow_3F__2();
}
static void mw_pat_underscore_3F__1 (void) {
	mw_value_3();
	mw_pat_underscore_3F__2();
}
static void mw_module_header_3F__1 (void) {
	mw_value_3();
	mw_module_header_3F__2();
}
static void mw_alloc_none_21__1 (void) {
	mw_alloc_21__6();
	push_u64(0LL); // TOKEN_NONE
	mw_over_1();
	mfld__7E_value_1();
	mp_prim_mut_set();
}
static void mw_location_2 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_module_3();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_row_1();
		push_value(d2);
	}
	mw_col_1();
	mtw_LOCATION_1();
}
static void mw_next_1 (void) {
	mp_prim_dup();
	mw_value_3();
	switch (get_top_data_tag()) {
		case 3LL: // TOKEN_LPAREN
			mtp_TOKEN_5F_LPAREN_1();
			mw_nip_1();
			mw_succ_7();
			break;
		case 6LL: // TOKEN_LSQUARE
			mtp_TOKEN_5F_LSQUARE_1();
			mw_nip_1();
			mw_succ_7();
			break;
		case 9LL: // TOKEN_LCURLY
			mtp_TOKEN_5F_LCURLY_1();
			mw_nip_1();
			mw_succ_7();
			break;
		case 12LL: // TOKEN_LCOLON
			mtp_TOKEN_5F_LCOLON_1();
			mw_nip_1();
			mw_succ_7();
			break;
		case 16LL: // TOKEN_NAME
			mtp_TOKEN_5F_NAME_1();
			mp_prim_drop();
			mw_succ_7();
			mp_prim_dup();
			mw_lparen_or_lcolon_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_nip_1();
					mw_succ_7();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 17LL: // TOKEN_DNAME
			mtp_TOKEN_5F_DNAME_1();
			mp_prim_drop();
			mw_succ_7();
			mp_prim_dup();
			mw_lparen_or_lcolon_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_nip_1();
					mw_succ_7();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			mp_prim_drop();
			mw_succ_7();
			break;
	}
}
static void mw_prev_1 (void) {
	mw_pred_7();
	mp_prim_dup();
	mw_value_3();
	switch (get_top_data_tag()) {
		case 7LL: // TOKEN_RSQUARE
			mtp_TOKEN_5F_RSQUARE_1();
			mw_nip_1();
			break;
		case 10LL: // TOKEN_RCURLY
			mtp_TOKEN_5F_RCURLY_1();
			mw_nip_1();
			break;
		case 4LL: // TOKEN_RPAREN
			mtp_TOKEN_5F_RPAREN_1();
			mw_nip_1();
			mp_prim_dup();
			mw_pred_7();
			mw_name_or_dname_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					mw_pred_7();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 13LL: // TOKEN_RCOLON
			mtp_TOKEN_5F_RCOLON_1();
			mw_nip_1();
			mp_prim_dup();
			mw_pred_7();
			mw_name_or_dname_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					mw_pred_7();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			mp_prim_drop();
			break;
	}
}
static void mw_next_arg_end_1 (void) {
	while(1) {
		mp_prim_dup();
		mw_arg_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_next_1();
	}
}
static void mw_has_args_3F__1 (void) {
	mp_prim_dup();
	mw_name_or_dname_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			mw_succ_7();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_lparen_or_lcolon_3F__1();
	mw__3E_Bool_1();
}
static void mw_args_start_1 (void) {
	mp_prim_dup();
	mw_name_or_dname_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			mp_prim_dup();
			mw_succ_7();
			mw_lparen_or_lcolon_3F__1();
			mw__3E_Bool_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_succ_7();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_could_be_sig_label_3F__1 (void) {
	mp_prim_dup();
	mw_name_3F__2();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_label_name_3F__1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	if (pop_u64()) {
		mp_prim_dup();
		mw_succ_7();
		mw_lcolon_3F__1();
		mw__3E_Bool_1();
	} else {
		push_u64(0LL); // F
	}
	mw_nip_1();
}
static void mw_pattern_var_3F__1 (void) {
	mw_name_3F__2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_could_be_pattern_var_3F__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_args_0_1 (void) {
	mp_prim_dup();
	mw_num_args_1();
	mw_0_3D__1();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("expected no args", 16);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_emit_fatal_error_21__1();
	}
}
static void mw_args_1_1 (void) {
	mp_prim_dup();
	mw_num_args_1();
	push_i64(1LL);
	mp_prim_int_eq();
	if (pop_u64()) {
		mw_args_start_1();
		mw_succ_7();
	} else {
		mp_prim_dup();
		mw_num_args_1();
		push_i64(1LL);
		mp_prim_int_lt();
		if (pop_u64()) {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 1 arg, got none", 24);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 1 arg, got too many", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		}
	}
}
static void mw_args_2_1 (void) {
	mp_prim_dup();
	mw_num_args_1();
	push_i64(2LL);
	mp_prim_int_eq();
	if (pop_u64()) {
		mw_args_start_1();
		mw_succ_7();
		mp_prim_dup();
		mw_next_arg_end_1();
		mw_succ_7();
	} else {
		mp_prim_dup();
		mw_num_args_1();
		push_i64(2LL);
		mp_prim_int_lt();
		if (pop_u64()) {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 2 args, got too few", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 2 args, got too many", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		}
	}
}
static void mw_args_3_1 (void) {
	mp_prim_dup();
	mw_num_args_1();
	push_i64(3LL);
	mp_prim_int_eq();
	if (pop_u64()) {
		mw_args_start_1();
		mw_succ_7();
		mp_prim_dup();
		mw_next_arg_end_1();
		mw_succ_7();
		mp_prim_dup();
		mw_next_arg_end_1();
		mw_succ_7();
	} else {
		mp_prim_dup();
		mw_num_args_1();
		push_i64(3LL);
		mp_prim_int_lt();
		if (pop_u64()) {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 3 args, got too few", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 3 args, got too many", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		}
	}
}
static void mw_num_args_1 (void) {
	mw_args_start_1();
	mp_prim_dup();
	mw_left_enclosure_3F__1();
	if (pop_u64()) {
		{
			VAL d3 = pop_value();
			push_i64(0LL);
			push_value(d3);
		}
		while(1) {
			mp_prim_dup();
			mw_args_end_3F__1();
			mw_not_1();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				mw_prim_int_succ_1();
				push_value(d4);
			}
			mw_succ_7();
			mw_next_arg_end_1();
		}
		mp_prim_drop();
	} else {
		mp_prim_drop();
		push_i64(0LL);
	}
}
static void mw_args_2 (void) {
	mw_args_start_1();
	mp_prim_dup();
	mw_left_enclosure_3F__1();
	if (pop_u64()) {
		push_u64(0LL); // L0
		while(1) {
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_args_end_3F__1();
				mw_not_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				mw_succ_7();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_next_arg_end_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mp_prim_swap();
			mw_snoc_1();
		}
		mw_nip_1();
	} else {
		mp_prim_drop();
		push_u64(0LL); // L0
	}
}
static void mw_args_end_3F__1 (void) {
	mp_prim_dup();
	mw_comma_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_succ_7();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_right_enclosure_3F__1();
}
static void mw_args_2B__1 (void) {
	mp_prim_dup();
	mw_args_2();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected 1 or more args, got none", 33);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
}
static void mw_emit_error_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_location_2();
		push_value(d2);
	}
	mw_emit_error_at_21__1();
}
static void mw_emit_fatal_error_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_location_2();
		push_value(d2);
	}
	mw_emit_fatal_error_at_21__1();
}
static void mw_module_end_3F__1 (void) {
	mw_none_3F__2();
}
static void mw_run_end_3F__1 (void) {
	mw_value_3();
	switch (get_top_data_tag()) {
		case 0LL: // TOKEN_NONE
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 1LL: // TOKEN_COMMA
			(void)pop_u64();
			push_u64(1LL); // T
			break;
		case 4LL: // TOKEN_RPAREN
			mtp_TOKEN_5F_RPAREN_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 7LL: // TOKEN_RSQUARE
			mtp_TOKEN_5F_RSQUARE_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 10LL: // TOKEN_RCURLY
			mtp_TOKEN_5F_RCURLY_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 13LL: // TOKEN_RCOLON
			mtp_TOKEN_5F_RCOLON_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_run_tokens_1 (void) {
	push_u64(0LL); // L0
	while(1) {
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_run_end_3F__1();
			mw_not_1();
			push_value(d3);
		}
		mp_prim_swap();
		if (! pop_u64()) break;
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_next_1();
				push_value(d4);
			}
			push_value(d3);
		}
		mp_prim_swap();
		mw_snoc_1();
	}
	mw_nip_1();
}
static void mw_run_length_1 (void) {
	{
		VAL d2 = pop_value();
		push_i64(0LL);
		mw__3E_Nat_1();
		push_value(d2);
	}
	while(1) {
		mp_prim_dup();
		mw_run_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_next_1();
		{
			VAL d3 = pop_value();
			mw_1_2B__2();
			push_value(d3);
		}
	}
	mp_prim_drop();
}
static void mw_run_arrow_3F__1 (void) {
	mw_run_tokens_1();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_3244();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_sig_stack_end_3F__1 (void) {
	mp_prim_dup();
	mw_sig_dashes_3F__1();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mp_prim_dup();
		mw_run_end_3F__1();
	}
	mw_nip_1();
}
static void mw_sig_next_stack_end_1 (void) {
	while(1) {
		mp_prim_dup();
		mw_sig_stack_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_next_1();
	}
}
static void mw_sig_has_dashes_3F__1 (void) {
	mw_sig_next_stack_end_1();
	mw_sig_dashes_3F__1();
}
static void mw_sig_arity_1 (void) {
	mp_prim_dup();
	mw_sig_has_dashes_3F__1();
	if (pop_u64()) {
		mw_sig_count_types_1();
		mw_next_1();
		mw_sig_count_types_1();
		mp_prim_drop();
	} else {
		mw_sig_count_types_1();
		mp_prim_drop();
		push_i64(0LL);
		mw__3E_Nat_1();
		mp_prim_swap();
	}
}
static void mw_sig_count_types_1 (void) {
	push_i64(0LL);
	mw__3E_Nat_1();
	mp_prim_swap();
	while(1) {
		mp_prim_dup();
		mw_sig_stack_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mp_prim_dup();
		mw_sig_type_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				{
					VAL d5 = pop_value();
					mw_1_2B__2();
					push_value(d5);
				}
				break;
			case 0LL: // F
				(void)pop_u64();
				mp_prim_id();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_next_1();
	}
}
static void mw_alloc_21__18 (void) {
	mbuf_NUM_18();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_18();
	mp_prim_u64_set();
}
static void mw_head_9 (void) {
	mfld__7E_head_7();
	mp_prim_mut_get();
}
static void mw_qname_17 (void) {
	mfld__7E_qname_11();
	mp_prim_mut_get();
}
static void mw_target_2 (void) {
	mfld__7E_target_2();
	mw_force_21__1();
}
static void mw_new_21__11 (void) {
	mw_alloc_21__18();
	mw_tuck_1();
	mfld__7E_target_2();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_qname_11();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_7();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_ALIAS_1();
	mw_register_1();
}
static void mw_alloc_21__13 (void) {
	mbuf_NUM_13();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_13();
	mp_prim_u64_set();
}
static void mw_qname_11 (void) {
	mfld__7E_qname_6();
	mp_prim_mut_get();
}
static void mw_name_15 (void) {
	mw_qname_11();
	mw_name_12();
}
static void mw_symbol_1 (void) {
	mfld__7E_symbol_1();
	mp_prim_mut_get();
}
static void mw_head_7 (void) {
	mfld__7E_head_5();
	mp_prim_mut_get();
}
static void mw_sig_2 (void) {
	mfld__7E_sig_2();
	mp_prim_mut_get();
}
static void mw_ctx_type_2 (void) {
	mfld__7E_ctx_type_2();
	mw_force_21__1();
	mw_unpack2_1();
}
static void mw_type_8 (void) {
	mw_ctx_type_2();
	mw_nip_1();
}
static void mw_alloc_21__2 (void) {
	mbuf_NUM_2();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_2();
	mp_prim_u64_set();
}
static void mw_head_3 (void) {
	mfld__7E_head_2();
	mp_prim_mut_get();
}
static void mw_qname_2 (void) {
	mfld__7E_qname_2();
	mp_prim_mut_get();
}
static void mw_name_3 (void) {
	mw_qname_2();
	mw_name_12();
}
static void mw_type_3 (void) {
	mfld__7E_type_1();
	mw_force_21__1();
}
static void mw_new_21__2 (void) {
	mw_alloc_21__2();
	mw_tuck_1();
	mfld__7E_type_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_qname_2();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_2();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_VARIABLE_1();
	mw_register_1();
}
static void mw_package_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 2LL: // DEF_PACKAGE
			mtp_DEF_5F_PACKAGE_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_module_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // DEF_MODULE
			mtp_DEF_5F_MODULE_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_tag_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_prim_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_word_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mtw_SOME_1();
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
	}
}
static void mw_typecheck_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mw_target_2();
			mw_typecheck_21__1();
			break;
		case 2LL: // DEF_PACKAGE
			mtp_DEF_5F_PACKAGE_1();
			mp_prim_drop();
			break;
		case 1LL: // DEF_MODULE
			mtp_DEF_5F_MODULE_1();
			mp_prim_drop();
			break;
		case 9LL: // DEF_BUFFER
			mtp_DEF_5F_BUFFER_1();
			mp_prim_drop();
			break;
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mp_prim_drop();
			break;
		case 3LL: // DEF_DATA
			mtp_DEF_5F_DATA_1();
			mp_prim_drop();
			break;
		case 4LL: // DEF_TABLE
			mtp_DEF_5F_TABLE_1();
			mp_prim_drop();
			break;
		case 5LL: // DEF_TYPEDEF
			mtp_DEF_5F_TYPEDEF_1();
			mp_prim_drop();
			break;
		case 11LL: // DEF_EXTERNAL
			mtp_DEF_5F_EXTERNAL_1();
			mw_type_8();
			mp_prim_drop();
			break;
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mp_prim_dup();
			mw_type_2();
			mp_prim_drop();
			mw_arrow_2();
			mp_prim_drop();
			break;
		case 12LL: // DEF_FIELD
			mtp_DEF_5F_FIELD_1();
			mw_type_6();
			mp_prim_drop();
			break;
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mw_type_9();
			mp_prim_drop();
			break;
		case 10LL: // DEF_VARIABLE
			mtp_DEF_5F_VARIABLE_1();
			mw_type_3();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_defines_a_type_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mw_target_2();
			mw_defines_a_type_3F__1();
			break;
		case 2LL: // DEF_PACKAGE
			mtp_DEF_5F_PACKAGE_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 1LL: // DEF_MODULE
			mtp_DEF_5F_MODULE_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 9LL: // DEF_BUFFER
			mtp_DEF_5F_BUFFER_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 3LL: // DEF_DATA
			mtp_DEF_5F_DATA_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 4LL: // DEF_TABLE
			mtp_DEF_5F_TABLE_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 5LL: // DEF_TYPEDEF
			mtp_DEF_5F_TYPEDEF_1();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 11LL: // DEF_EXTERNAL
			mtp_DEF_5F_EXTERNAL_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 12LL: // DEF_FIELD
			mtp_DEF_5F_FIELD_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 10LL: // DEF_VARIABLE
			mtp_DEF_5F_VARIABLE_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_exposed_tycon_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mw_target_2();
			mw_exposed_tycon_3F__1();
			break;
		case 2LL: // DEF_PACKAGE
			mtp_DEF_5F_PACKAGE_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 1LL: // DEF_MODULE
			mtp_DEF_5F_MODULE_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 3LL: // DEF_DATA
			mtp_DEF_5F_DATA_1();
			mtw_TYCON_5F_DATA_1();
			mtw_SOME_1();
			break;
		case 4LL: // DEF_TABLE
			mtp_DEF_5F_TABLE_1();
			mtw_TYCON_5F_TABLE_1();
			mtw_SOME_1();
			break;
		case 5LL: // DEF_TYPEDEF
			mtp_DEF_5F_TYPEDEF_1();
			mw_target_1();
			mw_tycon_3F__1();
			break;
		case 9LL: // DEF_BUFFER
			mtp_DEF_5F_BUFFER_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 11LL: // DEF_EXTERNAL
			mtp_DEF_5F_EXTERNAL_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 12LL: // DEF_FIELD
			mtp_DEF_5F_FIELD_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 10LL: // DEF_VARIABLE
			mtp_DEF_5F_VARIABLE_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_head_3F__2 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mw_head_9();
			mtw_SOME_1();
			break;
		case 2LL: // DEF_PACKAGE
			mtp_DEF_5F_PACKAGE_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 1LL: // DEF_MODULE
			mtp_DEF_5F_MODULE_1();
			mw_start_1();
			mtw_SOME_1();
			break;
		case 3LL: // DEF_DATA
			mtp_DEF_5F_DATA_1();
			mw_head_3F__3();
			break;
		case 4LL: // DEF_TABLE
			mtp_DEF_5F_TABLE_1();
			mw_head_5();
			mtw_SOME_1();
			break;
		case 5LL: // DEF_TYPEDEF
			mtp_DEF_5F_TYPEDEF_1();
			mw_head_3F__1();
			break;
		case 9LL: // DEF_BUFFER
			mtp_DEF_5F_BUFFER_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 11LL: // DEF_EXTERNAL
			mtp_DEF_5F_EXTERNAL_1();
			mw_head_7();
			mtw_SOME_1();
			break;
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mw_head_2();
			mtw_SOME_1();
			break;
		case 12LL: // DEF_FIELD
			mtp_DEF_5F_FIELD_1();
			mw_head_4();
			mtw_SOME_1();
			break;
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mw_data_3();
			mw_head_3F__3();
			break;
		case 10LL: // DEF_VARIABLE
			mtp_DEF_5F_VARIABLE_1();
			mw_head_3();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_defining_module_3F__1 (void) {
	mw_head_3F__2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_module_3();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_qname_12 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mw_qname_17();
			break;
		case 2LL: // DEF_PACKAGE
			mtp_DEF_5F_PACKAGE_1();
			mw_qname_8();
			break;
		case 1LL: // DEF_MODULE
			mtp_DEF_5F_MODULE_1();
			mw_qname_10();
			break;
		case 9LL: // DEF_BUFFER
			mtp_DEF_5F_BUFFER_1();
			mw_qname_15();
			break;
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mw_qname_7();
			break;
		case 3LL: // DEF_DATA
			mtp_DEF_5F_DATA_1();
			mw_qname_13();
			break;
		case 4LL: // DEF_TABLE
			mtp_DEF_5F_TABLE_1();
			mw_qname_6();
			break;
		case 5LL: // DEF_TYPEDEF
			mtp_DEF_5F_TYPEDEF_1();
			mw_qname_3();
			break;
		case 11LL: // DEF_EXTERNAL
			mtp_DEF_5F_EXTERNAL_1();
			mw_qname_11();
			break;
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mw_qname_1();
			break;
		case 12LL: // DEF_FIELD
			mtp_DEF_5F_FIELD_1();
			mw_qname_5();
			break;
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mw_qname_14();
			break;
		case 10LL: // DEF_VARIABLE
			mtp_DEF_5F_VARIABLE_1();
			mw_qname_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_register_1 (void) {
	mp_prim_dup();
	mw_qname_12();
	mp_prim_dup();
	mw_undefined_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("qualified name already has definition", 37);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_name_12();
	mfld__7E_defs_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_mut_get();
		mp_prim_swap();
		mw_snoc_1();
		push_value(d2);
	}
	mp_prim_mut_set();
}
static void mw_def_index_1 (void) {
	mw_qname_12();
	mp_prim_dup();
	mw_name_12();
	mw_defs_1();
	mw_filter_2_946();
	mw_len_1();
	mw_nip_1();
}
static void mw_index_12 (void) {
}
static void mw_from_index_10 (void) {
}
static void mw_alloc_21__10 (void) {
	mbuf_NUM_10();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_10();
	mp_prim_u64_set();
}
static void mw__3E_Str_3 (void) {
	mfld__7E_Str_1();
	mp_prim_mut_get();
}
static void mw_defs_1 (void) {
	mfld__7E_defs_1();
	mp_prim_mut_get();
}
static void mw_mangled_1 (void) {
	mfld__7E_mangled_1();
	mw_force_21__1();
}
static void mw__3D__3D__30 (void) {
	{
		VAL d2 = pop_value();
		mw_index_12();
		push_value(d2);
	}
	mw_index_12();
	mp_prim_int_eq();
}
static void mw__3E_Int_17 (void) {
	mp_prim_id();
}
static void mw__3E_Hash_1 (void) {
	mw_HASH_5F_MAX_1();
	mp_prim_int_mod();
}
static void mw_HASH_5F_MAX_1 (void) {
	push_i64(65536LL);
}
static void mw_hash_name_40__1 (void) {
	mw__3E_Int_17();
	push_i64(8LL);
	mp_prim_int_mul();
	mw__3E_Offset_1();
	mbuf_HASH_5F_BUF_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_1();
	mw__40_I64_1();
	mw__UNSAFE_1();
	mw__3E_Int_3();
	mp_prim_dup();
	mw_0_3D__1();
	if (pop_u64()) {
		mp_prim_drop();
		push_u64(0LL); // NONE
	} else {
		mw_from_index_10();
		mtw_SOME_1();
	}
}
static void mw_hash_name_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_index_12();
		mw__3E_I64_1();
		push_value(d2);
	}
	mw__3E_Int_17();
	push_i64(8LL);
	mp_prim_int_mul();
	mw__3E_Offset_1();
	mbuf_HASH_5F_BUF_1();
	push_resource(MKU64(0LL)); // +UNSAFE
	mw_offset_1();
	mw__21_I64_1();
	mw__UNSAFE_1();
}
static void mw_hash_1 (void) {
	push_i64(0LL);
	mp_prim_swap();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Nat_7();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					push_resource(MKU64(0LL)); // +UNSAFE
					mw__40_Byte_1();
					mw__UNSAFE_1();
					mw__3E_Int_12();
					push_i64(17LL);
					mp_prim_int_mul();
					mw_over_1();
					push_i64(7LL);
					mp_prim_int_shl();
					mp_prim_int_xor();
					mp_prim_swap();
					push_i64(27LL);
					mp_prim_int_shr();
					mp_prim_int_xor();
					push_i64(1LL);
					mw__3E_Offset_1();
					push_value(d5);
				}
				push_resource(MKU64(0LL)); // +UNSAFE
				mw_offset_1();
				mw__UNSAFE_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		mp_prim_drop();
		push_value(d2);
	}
	mp_prim_drop();
	mw__3E_Hash_1();
}
static void mw_next_2 (void) {
	mw__3E_Int_17();
	mw_prim_int_succ_1();
	mw__3E_Hash_1();
}
static void mw_keep_going_3F__1 (void) {
	mp_prim_dup();
	mw_hash_name_40__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw__3E_Str_3();
			mw_over2_1();
			mw__3C__3E__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__3E_Name_1 (void) {
	mp_prim_dup();
	mw_hash_1();
	while(1) {
		mw_keep_going_3F__1();
		if (! pop_u64()) break;
		mw_next_2();
	}
	mp_prim_dup();
	mw_hash_name_40__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_alloc_21__10();
			mw_tuck_1();
			mp_prim_swap();
			mw_hash_name_21__1();
			mw_tuck_1();
			mfld__7E_Str_1();
			mp_prim_mut_set();
			push_u64(0LL); // L0
			mw_over_1();
			mfld__7E_defs_1();
			mp_prim_mut_set();
			mp_prim_dup();
			push_fnptr(&mb_169);
			mtw_LAZY_5F_DELAY_1();
			mw_over_1();
			mfld__7E_mangled_1();
			mp_prim_mut_set();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_trace_21__12 (void) {
	mw__3E_Str_3();
	mw_trace_21__2();
}
static void mw_head_6 (void) {
	mw__3E_Str_3();
	{
		VAL d2 = pop_value();
		push_i64(0LL);
		mw__3E_Offset_1();
		push_value(d2);
	}
	mw_byte_40__2();
}
static void mw_tail_head_1 (void) {
	mw__3E_Str_3();
	{
		VAL d2 = pop_value();
		push_i64(1LL);
		mw__3E_Offset_1();
		push_value(d2);
	}
	mw_byte_40__2();
}
static void mw_can_be_relative_3F__1 (void) {
	mw_head_6();
	mw_is_upper_1();
	mw_not_1();
}
static void mw_could_be_label_name_3F__1 (void) {
	mw_head_6();
	mw_is_lower_1();
}
static void mw_could_be_type_1 (void) {
	mw_head_6();
	mw_is_alpha_1();
}
static void mw_could_be_pattern_var_3F__1 (void) {
	mw_head_6();
	mw_is_lower_1();
}
static void mw_could_be_type_var_1 (void) {
	mw_head_6();
	mw_is_lower_1();
}
static void mw_could_be_type_con_1 (void) {
	mw_head_6();
	mw_is_upper_1();
}
static void mw_is_type_hole_1 (void) {
	mp_prim_dup();
	mw_head_6();
	push_u64(63LL); // B'?'
	mw__3D__3D__19();
	mp_prim_swap();
	mw_tail_head_1();
	mp_prim_dup();
	push_u64(0LL); // BNUL
	mw__3D__3D__19();
	mp_prim_swap();
	mw_is_lower_1();
	mw__7C__7C__1();
	mw__26__26__1();
}
static void mw_is_underscore_1 (void) {
	mp_prim_dup();
	mw_head_6();
	push_u64(95LL); // B'_'
	mw__3D__3D__19();
	mp_prim_swap();
	mw_tail_head_1();
	push_u64(0LL); // BNUL
	mw__3D__3D__19();
	mw__26__26__1();
}
static void mw_could_be_stack_var_1 (void) {
	mp_prim_dup();
	mw_head_6();
	push_u64(42LL); // B'*'
	mw__3D__3D__19();
	mp_prim_swap();
	mw_tail_head_1();
	mw_is_lower_1();
	mw__26__26__1();
}
static void mw_could_be_resource_var_1 (void) {
	mp_prim_dup();
	mw_head_6();
	push_u64(43LL); // B'+'
	mw__3D__3D__19();
	mp_prim_swap();
	mw_tail_head_1();
	mw_is_lower_1();
	mw__26__26__1();
}
static void mw_could_be_resource_con_1 (void) {
	mp_prim_dup();
	mw_head_6();
	push_u64(43LL); // B'+'
	mw__3D__3D__19();
	mp_prim_swap();
	mw_tail_head_1();
	mw_is_upper_1();
	mw__26__26__1();
}
static void mw_could_be_type_or_resource_con_1 (void) {
	mp_prim_dup();
	mw_could_be_type_con_1();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mp_prim_dup();
		mw_could_be_resource_con_1();
	}
	mw_nip_1();
}
static void mw_mangle_compute_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_thaw_1();
	mw__3E_Str_3();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Nat_7();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					push_resource(MKU64(0LL)); // +UNSAFE
					mw__40_Byte_1();
					mw__UNSAFE_1();
					mp_prim_dup();
					mw_is_alnum_1();
					if (pop_u64()) {
						mw_push_byte_ascii_21__1();
					} else {
						mp_prim_dup();
						push_u64(45LL); // B'-'
						mw__3D__3D__19();
						if (pop_u64()) {
							mp_prim_drop();
							push_u64(95LL); // B'_'
							mw_push_byte_ascii_21__1();
						} else {
							push_u64(95LL); // B'_'
							mw_push_byte_ascii_21__1();
							mw_to_hexdigits_1();
							{
								VAL d8 = pop_value();
								mw_push_byte_ascii_21__1();
								push_value(d8);
							}
							mw_push_byte_ascii_21__1();
							push_u64(95LL); // B'_'
							mw_push_byte_ascii_21__1();
						}
					}
					push_i64(1LL);
					mw__3E_Offset_1();
					push_value(d5);
				}
				push_resource(MKU64(0LL)); // +UNSAFE
				mw_offset_1();
				mw__UNSAFE_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		mp_prim_drop();
		push_value(d2);
	}
	mp_prim_drop();
	mw_freeze_1();
}
static void mw__3D__3D__31 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NAMESPACE_ROOT
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 0LL: // NAMESPACE_ROOT
					(void)pop_u64();
					push_u64(1LL); // T
					break;
				default:
					mp_prim_drop();
					push_u64(0LL); // F
					break;
			}
			break;
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // NAMESPACE_PACKAGE
					mtp_NAMESPACE_5F_PACKAGE_1();
					mp_prim_swap();
					mw__3D__3D__29();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		case 2LL: // NAMESPACE_MODULE
			mtp_NAMESPACE_5F_MODULE_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 2LL: // NAMESPACE_MODULE
					mtp_NAMESPACE_5F_MODULE_1();
					mp_prim_swap();
					mw__3D__3D__33();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		case 3LL: // NAMESPACE_TYCON
			mtp_NAMESPACE_5F_TYCON_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 3LL: // NAMESPACE_TYCON
					mtp_NAMESPACE_5F_TYCON_1();
					mp_prim_swap();
					mw__3D__3D__24();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		case 4LL: // NAMESPACE_WORD
			mtp_NAMESPACE_5F_WORD_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 4LL: // NAMESPACE_WORD
					mtp_NAMESPACE_5F_WORD_1();
					mp_prim_swap();
					mw__3D__3D__20();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // F
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_compare_6 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NAMESPACE_ROOT
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 0LL: // NAMESPACE_ROOT
					(void)pop_u64();
					push_u64(1LL); // EQ
					break;
				default:
					mp_prim_drop();
					push_u64(0LL); // LT
					break;
			}
			break;
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NAMESPACE_ROOT
					(void)pop_u64();
					mp_prim_drop();
					push_u64(2LL); // GT
					break;
				case 1LL: // NAMESPACE_PACKAGE
					mtp_NAMESPACE_5F_PACKAGE_1();
					mw_name_10();
					mw__3E_Str_3();
					mp_prim_swap();
					mw_name_10();
					mw__3E_Str_3();
					mw_compare_2();
					break;
				default:
					mw_drop2_1();
					push_u64(0LL); // LT
					break;
			}
			break;
		default:
			switch (get_top_data_tag()) {
				case 0LL: // NAMESPACE_ROOT
					(void)pop_u64();
					mp_prim_drop();
					push_u64(2LL); // GT
					break;
				case 1LL: // NAMESPACE_PACKAGE
					mtp_NAMESPACE_5F_PACKAGE_1();
					mw_drop2_1();
					push_u64(2LL); // GT
					break;
				default:
					mw_qname_9();
					mw_unwrap_1();
					mp_prim_swap();
					mw_qname_9();
					mw_unwrap_1();
					mw_compare_7();
					break;
			}
			break;
	}
}
static void mw_qname_9 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NAMESPACE_ROOT
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mw_qname_8();
			mtw_SOME_1();
			break;
		case 2LL: // NAMESPACE_MODULE
			mtp_NAMESPACE_5F_MODULE_1();
			mw_qname_10();
			mtw_SOME_1();
			break;
		case 3LL: // NAMESPACE_TYCON
			mtp_NAMESPACE_5F_TYCON_1();
			mw_qname_4();
			mtw_SOME_1();
			break;
		case 4LL: // NAMESPACE_WORD
			mtp_NAMESPACE_5F_WORD_1();
			mw_qname_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_module_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NAMESPACE_ROOT
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 2LL: // NAMESPACE_MODULE
			mtp_NAMESPACE_5F_MODULE_1();
			mtw_SOME_1();
			break;
		case 3LL: // NAMESPACE_TYCON
			mtp_NAMESPACE_5F_TYCON_1();
			mw_qname_4();
			mw_namespace_5();
			mw_module_3F__1();
			break;
		case 4LL: // NAMESPACE_WORD
			mtp_NAMESPACE_5F_WORD_1();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_prim_2 (void) {
	mw_prim_4();
	mtw_NAMESPACE_5F_MODULE_1();
}
static void mw__3E_Str_4 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NAMESPACE_ROOT
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("<root>", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mw_name_10();
			mw__3E_Str_3();
			break;
		case 2LL: // NAMESPACE_MODULE
			mtp_NAMESPACE_5F_MODULE_1();
			mw_qname_10();
			mw__3E_Str_5();
			break;
		case 3LL: // NAMESPACE_TYCON
			mtp_NAMESPACE_5F_TYCON_1();
			mw_qname_4();
			mw__3E_Str_5();
			break;
		case 4LL: // NAMESPACE_WORD
			mtp_NAMESPACE_5F_WORD_1();
			mw_qname_1();
			mw__3E_Str_5();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__2F_MKQNAME_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // MKQNAME
			mtp_MKQNAME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_arity_5 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_arity_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(4);
		tup->size = 4;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = u;
		decref(v);
		push_value(MKTUP(tup,4));
	}
}
static void mw_name_12 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_namespace_5 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_namespace_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 4, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(4);
		tup->size = 4;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = u;
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		decref(v);
		push_value(MKTUP(tup,4));
	}
}
static void mw_QNAME0_1 (void) {
	LPUSH(lbl_name);
	LPUSH(lbl_namespace);
	push_i64(0LL);
	LPUSH(lbl_arity);
	mtw_MKQNAME_1();
}
static void mw__3D__3D__32 (void) {
	mw__2F_MKQNAME_1();
	mw__2F_MKQNAME_1();
	LPOP(lbl_name);
	LPOP(lbl_name);
	mw__3D__3D__30();
	LPOP(lbl_arity);
	LPOP(lbl_arity);
	mp_prim_int_eq();
	mw__26__26__1();
	LPOP(lbl_namespace);
	LPOP(lbl_namespace);
	mw__3D__3D__31();
	mw__26__26__1();
}
static void mw__3C__3D__7 (void) {
	mw_compare_7();
	mw_is_le_1();
}
static void mw_compare_7 (void) {
	mw__2F_MKQNAME_1();
	mw__2F_MKQNAME_1();
	LPOP(lbl_arity);
	LPOP(lbl_arity);
	LPOP(lbl_name);
	mw__3E_Str_3();
	LPOP(lbl_name);
	mw__3E_Str_3();
	LPOP(lbl_namespace);
	LPOP(lbl_namespace);
	mw_compare_6();
	switch (get_top_data_tag()) {
		case 0LL: // LT
			(void)pop_u64();
			mw_drop4_1();
			push_u64(0LL); // LT
			break;
		case 2LL: // GT
			(void)pop_u64();
			mw_drop4_1();
			push_u64(2LL); // GT
			break;
		case 1LL: // EQ
			(void)pop_u64();
			mw_compare_2();
			switch (get_top_data_tag()) {
				case 0LL: // LT
					(void)pop_u64();
					mw_drop2_1();
					push_u64(0LL); // LT
					break;
				case 2LL: // GT
					(void)pop_u64();
					mw_drop2_1();
					push_u64(2LL); // GT
					break;
				case 1LL: // EQ
					(void)pop_u64();
					mw_compare_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_def_3F__1 (void) {
	mp_prim_dup();
	mw_name_12();
	mw_defs_1();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_2396();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
}
static void mw_defined_3F__1 (void) {
	mw_def_3F__1();
	mw_some_3F__1();
}
static void mw_undefined_3F__1 (void) {
	mw_def_3F__1();
	mw_none_3F__1();
}
static void mw_prim_3 (void) {
	LPUSH(lbl_arity);
	mw__3E_Name_1();
	LPUSH(lbl_name);
	mw_prim_2();
	LPUSH(lbl_namespace);
	mtw_MKQNAME_1();
}
static void mw__3E_Str_5 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // MKQNAME
			mtp_MKQNAME_1();
			LPOP(lbl_namespace);
			mw__3E_Str_4();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(".", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_str_cat();
			LPOP(lbl_name);
			mw__3E_Str_3();
			mp_prim_str_cat();
			LPOP(lbl_arity);
			mp_prim_dup();
			mw_0_3D__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("/", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					push_value(d5);
				}
				mw_show_1();
				mp_prim_str_cat();
				mp_prim_str_cat();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_to_module_path_1 (void) {
	mp_prim_dup();
	mw_namespace_5();
	switch (get_top_data_tag()) {
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mw_path_2();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("No path defined for package", 27);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_panic();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_swap();
			mw_name_12();
			mw__3E_Str_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(".mth", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_str_cat();
			mw__3E_Path_1();
			mw_join_unix_1();
			break;
		default:
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected module name", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
	}
}
static void mw_root_3F__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DNAME
			mtp_DNAME_1();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_parts_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DNAME
			mtp_DNAME_1();
			mw_nip_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_index_11 (void) {
}
static void mw_alloc_21__9 (void) {
	mbuf_NUM_9();
	mp_prim_u64_get();
	push_i64(1LL);
	mp_prim_int_add();
	mp_prim_dup();
	mbuf_NUM_9();
	mp_prim_u64_set();
}
static void mw_name_10 (void) {
	mfld__7E_name_3();
	mp_prim_mut_get();
}
static void mw_qname_8 (void) {
	push_u64(0LL); // NAMESPACE_ROOT
	mp_prim_swap();
	mw_name_10();
	mw_QNAME0_1();
}
static void mw_path_2 (void) {
	mfld__7E_path_1();
	mp_prim_mut_get();
}
static void mw_new_21__6 (void) {
	mw_alloc_21__9();
	mw_tuck_1();
	mfld__7E_name_3();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_path_1();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_PACKAGE_1();
	mw_register_1();
}
static void mw_new_or_set_path_21__1 (void) {
	mp_prim_dup();
	mw_find_4();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_dup();
			mw_path_2();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Package already has path", 24);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_panic();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						mp_prim_drop();
						push_value(d6);
					}
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mtw_SOME_1();
							push_value(d7);
						}
						mfld__7E_path_1();
						mp_prim_mut_set();
						push_value(d6);
					}
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 0LL: // NONE
			(void)pop_u64();
			{
				VAL d4 = pop_value();
				mtw_SOME_1();
				push_value(d4);
			}
			mw_new_21__6();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_4 (void) {
	push_u64(0LL); // NAMESPACE_ROOT
	mp_prim_swap();
	mw_QNAME0_1();
	mw_def_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_package_3F__2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_or_new_21__1 (void) {
	mp_prim_dup();
	mw_find_4();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			push_u64(0LL); // NONE
			mp_prim_swap();
			mw_new_21__6();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
}
static void mw__3D__3D__29 (void) {
	{
		VAL d2 = pop_value();
		mw_index_11();
		push_value(d2);
	}
	mw_index_11();
	mp_prim_int_eq();
}
static void mw_head_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // STACK_NIL
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // STACK_CONS
			mtp_STACK_5F_CONS_1();
			mp_prim_drop();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cons_1 (void) {
	mtw_STACK_5F_CONS_1();
}
static void mw_uncons_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // STACK_NIL
			(void)pop_u64();
			push_u64(0LL); // NONE
			push_u64(0LL); // STACK_NIL
			break;
		case 1LL: // STACK_CONS
			mtp_STACK_5F_CONS_1();
			{
				VAL d4 = pop_value();
				mtw_SOME_1();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__2F_LEXER_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // LEXER
			mtp_LEXER_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_last_token_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL u = VTUP(v)->cells[6];
	incref(u);
	push_value(u);
}
static void mw_lexer_last_token_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL* p = &VTUP(v)->cells[6];
	VAL t = *p; *p = u; decref(t);
}
static void mw_lexer_stack_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL u = VTUP(v)->cells[5];
	incref(u);
	push_value(u);
}
static void mw_lexer_stack_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL* p = &VTUP(v)->cells[5];
	VAL t = *p; *p = u; decref(t);
}
static void mw_lexer_col_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	push_value(u);
}
static void mw_lexer_col_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL* p = &VTUP(v)->cells[4];
	VAL t = *p; *p = u; decref(t);
}
static void mw_lexer_row_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	push_value(u);
}
static void mw_lexer_row_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL* p = &VTUP(v)->cells[3];
	VAL t = *p; *p = u; decref(t);
}
static void mw_lexer_module_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 7, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	push_value(u);
}
static void mw_lexer_stack_push_21__1 (void) {
	mw_lexer_stack_2();
	mw_cons_1();
	mw_lexer_stack_21__1();
}
static void mw_lexer_stack_pop_21__1 (void) {
	mw_lexer_stack_2();
	mw_uncons_1();
	mw_lexer_stack_21__1();
}
static void mw_lexer_stack_drop_1 (void) {
	mw_lexer_stack_pop_21__1();
	mp_prim_drop();
}
static void mw_lexer_stack_peek_1 (void) {
	mw_lexer_stack_2();
	mw_head_1();
}
static void mw_lexer_col_40__1 (void) {
	mw_lexer_col_2();
}
static void mw_lexer_row_40__1 (void) {
	mw_lexer_row_2();
}
static void mw_lexer_module_40__1 (void) {
	mw_lexer_module_2();
}
static void mw_run_lexer_21__1 (void) {
	mw_new_21__7();
	mp_prim_dup();
	LPUSH(lbl_lexer_module);
	mw_source_path_1();
	mw_open_file_21__1();
	mw_start_21__2();
	push_i64(1LL);
	mw__3E_Row_1();
	LPUSH(lbl_lexer_row);
	push_i64(1LL);
	mw__3E_Col_1();
	LPUSH(lbl_lexer_col);
	push_u64(0LL); // STACK_NIL
	LPUSH(lbl_lexer_stack);
	mw_alloc_none_21__1();
	mp_prim_dup();
	LPUSH(lbl_lexer_last_token);
	mtw_LEXER_1();
	while(1) {
		mw_done_3F__2();
		mw_not_1();
		if (! pop_u64()) break;
		mw_lexer_next_21__1();
	}
	push_u64(0LL); // TOKEN_NONE
	mw_lexer_emit_21__1();
	mw__2F_LEXER_1();
	mw_end_21__2();
	mw_close_file_21__1();
	LPOP(lbl_lexer_stack);
	mw_uncons_1();
	mp_prim_drop();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Mismatched left parenthesis.", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	LPOP(lbl_lexer_row);
	LPOP(lbl_lexer_col);
	LPOP(lbl_lexer_last_token);
	mw_drop3_1();
	LPOP(lbl_lexer_module);
	mw_alloc_none_21__1();
	mw_over_1();
	mfld__7E_end_1();
	mp_prim_mut_set();
	mp_prim_swap();
	mw_succ_7();
	mw_over_1();
	mfld__7E_start_1();
	mp_prim_mut_set();
}
static void mw_done_3F__2 (void) {
	mw__2F_LEXER_1();
	mw_done_3F__1();
	mtw_LEXER_1();
}
static void mw_lexer_make_21__1 (void) {
	mw_alloc_21__6();
	mw_tuck_1();
	mfld__7E_value_1();
	mp_prim_mut_set();
	mw_lexer_module_2();
	mw_over_1();
	mfld__7E_module_1();
	mp_prim_mut_set();
	mw_lexer_row_2();
	mw_over_1();
	mfld__7E_row_1();
	mp_prim_mut_set();
	mw_lexer_col_2();
	mw_over_1();
	mfld__7E_col_1();
	mp_prim_mut_set();
	mp_prim_dup();
	mw_lexer_last_token_21__1();
}
static void mw_lexer_emit_21__1 (void) {
	mw_lexer_make_21__1();
	mp_prim_drop();
}
static void mw_lexer_next_21__1 (void) {
	mw_lexer_peek_1();
	switch (get_top_data_tag()) {
		case 10LL: // BLF
			(void)pop_u64();
			mw_lexer_newline_21__1();
			mw_lexer_move_21__1();
			break;
		case 32LL: // BSPACE
			(void)pop_u64();
			mw_lexer_move_21__1();
			break;
		case 9LL: // BHT
			(void)pop_u64();
			mw_lexer_move_21__1();
			break;
		case 11LL: // BVT
			(void)pop_u64();
			mw_lexer_move_21__1();
			break;
		case 13LL: // BCR
			(void)pop_u64();
			mw_lexer_move_21__1();
			break;
		case 35LL: // BHASH
			(void)pop_u64();
			mw_lexer_skip_comment_21__1();
			mw_lexer_move_21__1();
			break;
		case 44LL: // BCOMMA
			(void)pop_u64();
			mw_lexer_close_colons_21__1();
			push_u64(1LL); // TOKEN_COMMA
			mw_lexer_emit_21__1();
			mw_lexer_move_21__1();
			break;
		case 41LL: // BRPAREN
			(void)pop_u64();
			mw_lexer_close_colons_21__1();
			mw_lexer_emit_rparen_21__1();
			mw_lexer_move_21__1();
			break;
		case 93LL: // BRSQUARE
			(void)pop_u64();
			mw_lexer_close_colons_21__1();
			mw_lexer_emit_rsquare_21__1();
			mw_lexer_move_21__1();
			break;
		case 125LL: // BRCURLY
			(void)pop_u64();
			mw_lexer_close_colons_21__1();
			mw_lexer_emit_rcurly_21__1();
			mw_lexer_move_21__1();
			break;
		case 58LL: // BCOLON
			(void)pop_u64();
			mw_lexer_prepare_for_args_21__1();
			mw_lexer_emit_lcolon_21__1();
			mw_lexer_move_21__1();
			break;
		case 40LL: // BLPAREN
			(void)pop_u64();
			mw_lexer_prepare_for_args_21__1();
			mw_lexer_emit_lparen_21__1();
			mw_lexer_move_21__1();
			break;
		case 91LL: // BLSQUARE
			(void)pop_u64();
			mw_lexer_prepare_for_atom_21__1();
			mw_lexer_emit_lsquare_21__1();
			mw_lexer_move_21__1();
			break;
		case 123LL: // BLCURLY
			(void)pop_u64();
			mw_lexer_prepare_for_atom_21__1();
			mw_lexer_emit_lcurly_21__1();
			mw_lexer_move_21__1();
			break;
		case 34LL: // BQUOTE
			(void)pop_u64();
			mw_lexer_prepare_for_atom_21__1();
			mw_lexer_emit_string_21__1();
			mw_lexer_move_21__1();
			break;
		default:
			mw_is_name_byte_1();
			if (pop_u64()) {
				mw_lexer_prepare_for_atom_21__1();
				mw_lexer_emit_name_21__1();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Unrecognized byte.", 18);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_lexer_emit_fatal_error_21__1();
			}
			break;
	}
}
static void mw_lexer_newline_21__1 (void) {
	mw_lexer_row_40__1();
	mw__3E_Int_19();
	mw_prim_int_succ_1();
	mw__3E_Row_1();
	mw_lexer_row_21__1();
	push_i64(0LL);
	mw__3E_Col_1();
	mw_lexer_col_21__1();
}
static void mw_lexer_emit_lcolon_21__1 (void) {
	push_u64(11LL); // TOKEN_LCOLON_OPEN
	mw_lexer_make_21__1();
	mw_lexer_stack_push_21__1();
}
static void mw_lexer_close_colons_21__1 (void) {
	mw_lexer_stack_peek_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_dup();
			mw_lcolon_open_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	while(1) {
		mp_prim_dup();
		mw_some_3F__1();
		if (! pop_u64()) break;
		mw_unwrap_1();
		mw_lexer_stack_drop_1();
		mp_prim_dup();
		mtw_TOKEN_5F_RCOLON_1();
		mw_lexer_make_21__1();
		mtw_TOKEN_5F_LCOLON_1();
		mp_prim_swap();
		mfld__7E_value_1();
		mp_prim_mut_set();
		mw_lexer_stack_peek_1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_dup();
				mw_lcolon_open_3F__1();
				if (pop_u64()) {
					mtw_SOME_1();
				} else {
					mp_prim_drop();
					push_u64(0LL); // NONE
				}
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
	}
	mp_prim_drop();
}
static void mw_lexer_prepare_for_atom_21__1 (void) {
	mw_lexer_last_token_2();
	mw_lcolon_open_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mw_lexer_close_colons_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_prepare_for_args_21__1 (void) {
	mw_lexer_last_token_2();
	mw_name_or_dname_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_lexer_close_colons_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_emit_lparen_21__1 (void) {
	push_u64(2LL); // TOKEN_LPAREN_OPEN
	mw_lexer_make_21__1();
	mw_lexer_stack_push_21__1();
}
static void mw_lexer_emit_rparen_21__1 (void) {
	mw_lexer_stack_pop_21__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Mismatched right parenthesis.", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_lexer_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_dup();
			mw_lparen_open_3F__1();
			if (pop_u64()) {
				mp_prim_dup();
				mtw_TOKEN_5F_RPAREN_1();
				mw_lexer_make_21__1();
				mtw_TOKEN_5F_LPAREN_1();
				mp_prim_swap();
				mfld__7E_value_1();
				mp_prim_mut_set();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Mismatched right parenthesis.", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_lexer_emit_fatal_error_21__1();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_emit_lsquare_21__1 (void) {
	push_u64(5LL); // TOKEN_LSQUARE_OPEN
	mw_lexer_make_21__1();
	mw_lexer_stack_push_21__1();
}
static void mw_lexer_emit_rsquare_21__1 (void) {
	mw_lexer_stack_pop_21__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Mismatched right square bracket.", 32);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_lexer_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_dup();
			mw_lsquare_open_3F__1();
			if (pop_u64()) {
				mp_prim_dup();
				mtw_TOKEN_5F_RSQUARE_1();
				mw_lexer_make_21__1();
				mtw_TOKEN_5F_LSQUARE_1();
				mp_prim_swap();
				mfld__7E_value_1();
				mp_prim_mut_set();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Mismatched right square bracket.", 32);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_lexer_emit_fatal_error_21__1();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_emit_lcurly_21__1 (void) {
	push_u64(8LL); // TOKEN_LCURLY_OPEN
	mw_lexer_make_21__1();
	mw_lexer_stack_push_21__1();
}
static void mw_lexer_emit_rcurly_21__1 (void) {
	mw_lexer_stack_pop_21__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Mismatched right curly brace.", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_lexer_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_dup();
			mw_lcurly_open_3F__1();
			if (pop_u64()) {
				mp_prim_dup();
				mtw_TOKEN_5F_RCURLY_1();
				mw_lexer_make_21__1();
				mtw_TOKEN_5F_LCURLY_1();
				mp_prim_swap();
				mfld__7E_value_1();
				mp_prim_mut_set();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Mismatched right curly brace.", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_lexer_emit_fatal_error_21__1();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_emit_name_21__1 (void) {
	{
		VAL d2 = pop_resource();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("", 0);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_thaw_1();
		push_resource(d2);
	}
	mw_lexer_module_40__1();
	mw_lexer_row_40__1();
	mw_lexer_col_40__1();
	mw_lexer_peek_1();
	while(1) {
		mp_prim_dup();
		mw_is_name_byte_1();
		if (! pop_u64()) break;
		{
			VAL d3 = pop_resource();
			mw_push_byte_unsafe_21__1();
			push_resource(d3);
		}
		mw_lexer_move_21__1();
		mw_lexer_peek_1();
	}
	mp_prim_drop();
	{
		VAL d2 = pop_resource();
		mw_is_doc_start_3F__1();
		push_resource(d2);
	}
	if (pop_u64()) {
		mw_drop3_1();
		mw_lexer_skip_doc_21__1();
	} else {
		{
			VAL d3 = pop_resource();
			mw_is_int_3F__1();
			if (pop_u64()) {
				mw_int_3F__1();
				mtw_TOKEN_5F_INT_1();
			} else {
				mw_dname_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mtw_TOKEN_5F_DNAME_1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mw_label_token_3F__1();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_id();
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mw_name_3F__1();
								mtw_TOKEN_5F_NAME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
			}
			push_resource(d3);
		}
		mw_alloc_21__6();
		mw_tuck_1();
		mfld__7E_value_1();
		mp_prim_mut_set();
		mw_tuck_1();
		mfld__7E_col_1();
		mp_prim_mut_set();
		mw_tuck_1();
		mfld__7E_row_1();
		mp_prim_mut_set();
		mw_tuck_1();
		mfld__7E_module_1();
		mp_prim_mut_set();
		mw_lexer_last_token_21__1();
	}
	{
		VAL d2 = pop_resource();
		mw_freeze_1();
		mp_prim_drop();
		push_resource(d2);
	}
}
static void mw_name_3F__1 (void) {
	mw_dup_21__1();
	mw__3E_Name_1();
}
static void mw_drop_last_byte_1 (void) {
	{
		VAL d2 = pop_resource();
		mw_num_bytes_3F__1();
		push_resource(d2);
	}
	mw_1__4();
	mw_take_slice_1();
}
static void mw_label_token_3F__1 (void) {
	push_i64(0LL);
	mw__3E_Offset_1();
	mw_byte_40__1();
	mw_is_lower_1();
	if (pop_u64()) {
		mw_last_byte_1();
		switch (get_top_data_tag()) {
			case 62LL: // B'>'
				(void)pop_u64();
				push_resource(MKU64(0LL)); // +UNSAFE
				mw_drop_last_byte_1();
				mw__UNSAFE_1();
				mw__3E_Name_1();
				mw_new_21__8();
				mtw_TOKEN_5F_LABEL_5F_POP_1();
				mtw_SOME_1();
				break;
			default:
				mp_prim_drop();
				push_u64(0LL); // NONE
				break;
		}
	} else {
		push_i64(0LL);
		mw__3E_Offset_1();
		mw_byte_40__1();
		push_u64(62LL); // B'>'
		mw__3D__3D__19();
		if (pop_u64()) {
			push_i64(1LL);
			mw__3E_Offset_1();
			mw_byte_40__1();
			mw_is_lower_1();
		} else {
			push_u64(0LL); // F
		}
		if (pop_u64()) {
			push_i64(1LL);
			mw__3E_Offset_1();
			push_resource(MKU64(0LL)); // +UNSAFE
			mw_drop_slice_1();
			mw__UNSAFE_1();
			mw__3E_Name_1();
			mw_new_21__8();
			mtw_TOKEN_5F_LABEL_5F_PUSH_1();
			mtw_SOME_1();
		} else {
			push_u64(0LL); // NONE
		}
	}
}
static void mw_dname_3F__1 (void) {
	push_u64(46LL); // BDOT
	mw_split_byte_1();
	mw_uncons_2();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_empty_3F__2();
				if (pop_u64()) {
					mp_prim_drop();
					push_u64(0LL); // NONE
				} else {
					mw__3E_Name_1();
					mtw_SOME_1();
				}
				push_value(d4);
			}
			mw_map_4_956();
			mtw_DNAME_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_is_doc_start_3F__1 (void) {
	mw_dup_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("|||", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3D__3D__7();
}
static void mw_is_int_3F__1 (void) {
	mw_is_dec_int_3F__1();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mw_is_hex_int_3F__1();
	}
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mw_is_oct_int_3F__1();
	}
}
static void mw_is_dec_int_3F__1 (void) {
	push_i64(0LL);
	mw__3E_Size_1();
	push_i64(0LL);
	mw__3E_Offset_1();
	mp_prim_dup();
	mw_byte_40__1();
	mw_is_sign_1();
	if (pop_u64()) {
		mw_1_2B__3();
	} else {
		mp_prim_id();
	}
	while(1) {
		mp_prim_dup();
		mw_byte_40__1();
		mw_is_digit_1();
		if (! pop_u64()) break;
		{
			VAL d3 = pop_value();
			mw_1_2B__4();
			push_value(d3);
		}
		mw_1_2B__3();
	}
	mp_prim_swap();
	mw_0_3E__4();
	if (pop_u64()) {
		mw_num_bytes_3F__1();
		mw__3E_Offset_3();
		mw__3D__3D__14();
	} else {
		mp_prim_drop();
		push_u64(0LL); // F
	}
}
static void mw_is_hex_int_3F__1 (void) {
	push_i64(0LL);
	mw__3E_Size_1();
	push_i64(0LL);
	mw__3E_Offset_1();
	mp_prim_dup();
	mw_byte_40__1();
	mw_is_sign_1();
	if (pop_u64()) {
		mw_1_2B__3();
	} else {
		mp_prim_id();
	}
	mp_prim_dup();
	mw_byte_40__1();
	push_u64(48LL); // B'0'
	mw__3D__3D__19();
	if (pop_u64()) {
		mw_1_2B__3();
		mp_prim_dup();
		mw_byte_40__1();
		push_u64(120LL); // B'x'
		mw__3D__3D__19();
		if (pop_u64()) {
			mw_1_2B__3();
			while(1) {
				mp_prim_dup();
				mw_byte_40__1();
				mw_is_hexdigit_1();
				if (! pop_u64()) break;
				{
					VAL d5 = pop_value();
					mw_1_2B__4();
					push_value(d5);
				}
				mw_1_2B__3();
			}
			mp_prim_swap();
			mw_0_3E__4();
			if (pop_u64()) {
				mw_num_bytes_3F__1();
				mw__3E_Offset_3();
				mw__3D__3D__14();
			} else {
				mp_prim_drop();
				push_u64(0LL); // F
			}
		} else {
			mw_drop2_1();
			push_u64(0LL); // F
		}
	} else {
		mw_drop2_1();
		push_u64(0LL); // F
	}
}
static void mw_is_oct_int_3F__1 (void) {
	push_i64(0LL);
	mw__3E_Size_1();
	push_i64(0LL);
	mw__3E_Offset_1();
	mp_prim_dup();
	mw_byte_40__1();
	mw_is_sign_1();
	if (pop_u64()) {
		mw_1_2B__3();
	} else {
		mp_prim_id();
	}
	mp_prim_dup();
	mw_byte_40__1();
	push_u64(48LL); // B'0'
	mw__3D__3D__19();
	if (pop_u64()) {
		mw_1_2B__3();
		mp_prim_dup();
		mw_byte_40__1();
		push_u64(111LL); // B'o'
		mw__3D__3D__19();
		if (pop_u64()) {
			mw_1_2B__3();
			while(1) {
				mp_prim_dup();
				mw_byte_40__1();
				push_u64(48LL); // B'0'
				push_u64(55LL); // B'7'
				mw_in_range_2();
				if (! pop_u64()) break;
				{
					VAL d5 = pop_value();
					mw_1_2B__4();
					push_value(d5);
				}
				mw_1_2B__3();
			}
			mp_prim_swap();
			mw_0_3E__4();
			if (pop_u64()) {
				mw_num_bytes_3F__1();
				mw__3E_Offset_3();
				mw__3D__3D__14();
			} else {
				mp_prim_drop();
				push_u64(0LL); // F
			}
		} else {
			mw_drop2_1();
			push_u64(0LL); // F
		}
	} else {
		mw_drop2_1();
		push_u64(0LL); // F
	}
}
static void mw_int_3F__1 (void) {
	mw_is_dec_int_3F__1();
	if (pop_u64()) {
		mw_dec_int_3F__1();
	} else {
		mw_is_hex_int_3F__1();
		if (pop_u64()) {
			mw_hex_int_3F__1();
		} else {
			mw_oct_int_3F__1();
		}
	}
}
static void mw_int_sign_1 (void) {
	push_i64(0LL);
	mw__3E_Offset_1();
	mw_byte_40__1();
	mw_byte_sign_value_index_1();
}
static void mw_byte_sign_value_index_1 (void) {
	switch (get_top_data_tag()) {
		case 45LL: // B'-'
			(void)pop_u64();
			push_i64(-1LL);
			push_i64(0LL);
			push_i64(1LL);
			mw__3E_Offset_1();
			break;
		case 43LL: // B'+'
			(void)pop_u64();
			push_i64(1LL);
			push_i64(0LL);
			push_i64(1LL);
			mw__3E_Offset_1();
			break;
		default:
			mp_prim_drop();
			push_i64(1LL);
			push_i64(0LL);
			push_i64(0LL);
			mw__3E_Offset_1();
			break;
	}
}
static void mw_dec_int_3F__1 (void) {
	mw_int_sign_1();
	while(1) {
		mp_prim_dup();
		mw_num_bytes_3F__1();
		mw__3E_Offset_3();
		mw__3C__4();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_byte_40__1();
			mw__3E_Int_12();
			{
				VAL d4 = pop_value();
				push_i64(10LL);
				mp_prim_int_mul();
				push_value(d4);
			}
			push_i64(48LL);
			mp_prim_int_sub();
			mp_prim_int_add();
			push_value(d3);
		}
		mw_1_2B__3();
	}
	mp_prim_drop();
	mp_prim_int_mul();
}
static void mw_hex_int_3F__1 (void) {
	mw_int_sign_1();
	mw_1_2B__3();
	mw_1_2B__3();
	while(1) {
		mp_prim_dup();
		mw_num_bytes_3F__1();
		mw__3E_Offset_3();
		mw__3C__4();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_byte_40__1();
			{
				VAL d4 = pop_value();
				push_i64(16LL);
				mp_prim_int_mul();
				push_value(d4);
			}
			mw_hexdigit_value_1();
			mp_prim_int_add();
			push_value(d3);
		}
		mw_1_2B__3();
	}
	mp_prim_drop();
	mp_prim_int_mul();
}
static void mw_oct_int_3F__1 (void) {
	mw_int_sign_1();
	mw_1_2B__3();
	mw_1_2B__3();
	while(1) {
		mp_prim_dup();
		mw_num_bytes_3F__1();
		mw__3E_Offset_3();
		mw__3C__4();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_byte_40__1();
			mw__3E_Int_12();
			{
				VAL d4 = pop_value();
				push_i64(8LL);
				mp_prim_int_mul();
				push_value(d4);
			}
			push_i64(48LL);
			mp_prim_int_sub();
			mp_prim_int_add();
			push_value(d3);
		}
		mw_1_2B__3();
	}
	mp_prim_drop();
	mp_prim_int_mul();
}
static void mw_hexdigit_value_1 (void) {
	mp_prim_dup();
	mw_is_digit_1();
	if (pop_u64()) {
		mw__3E_Int_12();
		push_i64(48LL);
		mp_prim_int_sub();
	} else {
		mw__3E_Int_12();
		push_i64(55LL);
		mp_prim_int_sub();
	}
}
static void mw_lexer_emit_string_21__1 (void) {
	{
		VAL d2 = pop_resource();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("", 0);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_thaw_1();
		push_resource(d2);
	}
	push_u64(0LL); // TOKEN_NONE
	mw_lexer_make_21__1();
	mw_lexer_move_21__1();
	mw_lexer_peek_1();
	while(1) {
		mp_prim_dup();
		mw_is_string_end_1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_lexer_push_string_byte_21__1();
		mw_lexer_move_21__1();
		mw_lexer_peek_1();
	}
	mp_prim_drop();
	{
		VAL d2 = pop_resource();
		mw_freeze_1();
		mtw_TOKEN_5F_STR_1();
		push_resource(d2);
	}
	mp_prim_swap();
	mfld__7E_value_1();
	mp_prim_mut_set();
}
static void mw_lexer_push_string_byte_21__1 (void) {
	switch (get_top_data_tag()) {
		case 92LL: // B'\'
			(void)pop_u64();
			mw_lexer_move_21__1();
			mw_lexer_peek_1();
			mw_lexer_push_string_escape_byte_21__1();
			break;
		default:
			{
				VAL d4 = pop_resource();
				mw_push_byte_unsafe_21__1();
				push_resource(d4);
			}
			break;
	}
}
static void mw_lexer_push_string_escape_byte_21__1 (void) {
	switch (get_top_data_tag()) {
		case 10LL: // BLF
			(void)pop_u64();
			mp_prim_id();
			break;
		case 110LL: // B'n'
			(void)pop_u64();
			push_u64(10LL); // BLF
			{
				VAL d4 = pop_resource();
				mw_push_byte_ascii_21__1();
				push_resource(d4);
			}
			break;
		case 114LL: // B'r'
			(void)pop_u64();
			push_u64(13LL); // BCR
			{
				VAL d4 = pop_resource();
				mw_push_byte_ascii_21__1();
				push_resource(d4);
			}
			break;
		case 116LL: // B't'
			(void)pop_u64();
			push_u64(9LL); // BHT
			{
				VAL d4 = pop_resource();
				mw_push_byte_ascii_21__1();
				push_resource(d4);
			}
			break;
		case 92LL: // B'\'
			(void)pop_u64();
			push_u64(92LL); // B'\'
			{
				VAL d4 = pop_resource();
				mw_push_byte_ascii_21__1();
				push_resource(d4);
			}
			break;
		case 34LL: // BQUOTE
			(void)pop_u64();
			push_u64(34LL); // BQUOTE
			{
				VAL d4 = pop_resource();
				mw_push_byte_ascii_21__1();
				push_resource(d4);
			}
			break;
		default:
			{
				VAL d4 = pop_resource();
				mw_push_byte_unsafe_21__1();
				push_resource(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Unknown character escape sequence.", 34);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_lexer_emit_warning_21__1();
			break;
	}
}
static void mw_lexer_skip_comment_21__1 (void) {
	while(1) {
		mw_lexer_comment_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_lexer_move_21__1();
	}
	mw_lexer_peek_1();
	push_u64(10LL); // BLF
	mw__3D__3D__19();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_lexer_newline_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_lexer_skip_doc_21__1 (void) {
	while(1) {
		mw_lexer_comment_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_lexer_move_21__1();
	}
}
static void mw_lexer_comment_end_3F__1 (void) {
	mw_done_3F__2();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mw_lexer_peek_1();
		mp_prim_dup();
		push_u64(10LL); // BLF
		mw__3D__3D__19();
		mw_nip_1();
	}
}
static void mw_lexer_peek_1 (void) {
	mw__2F_LEXER_1();
	mw_peek_1();
	mtw_LEXER_1();
}
static void mw_lexer_move_21__1 (void) {
	mw__2F_LEXER_1();
	mw_move_21__1();
	mtw_LEXER_1();
	mw_lexer_col_40__1();
	mw__3E_Int_18();
	mw_prim_int_succ_1();
	mw__3E_Col_1();
	mw_lexer_col_21__1();
}
static void mw_lexer_location_1 (void) {
	mw_lexer_module_40__1();
	mw_lexer_row_40__1();
	mw_lexer_col_40__1();
	mtw_LOCATION_1();
}
static void mw_lexer_emit_warning_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_lexer_location_1();
		push_value(d2);
	}
	mw_emit_warning_at_21__1();
}
static void mw_lexer_emit_fatal_error_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_lexer_location_1();
		push_value(d2);
	}
	mw_emit_fatal_error_at_21__1();
}
static void mw_type_elab_default_1 (void) {
	push_u64(0LL); // F
	mw_CTX0_1();
	mtw_TYPE_5F_ELAB_1();
}
static void mw_type_elab_stack_assertion_1 (void) {
	{
		VAL d2 = pop_value();
		push_u64(1LL); // T
		push_value(d2);
	}
	mtw_TYPE_5F_ELAB_1();
}
static void mw_type_elab_holes_allowed_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ELAB
			mtp_TYPE_5F_ELAB_1();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_type_elab_ctx_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ELAB
			mtp_TYPE_5F_ELAB_1();
			mw_nip_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_type_elab_ctx_3F__1 (void) {
	mp_prim_dup();
	mw_type_elab_ctx_1();
}
static void mw_type_elab_ctx_replace_1 (void) {
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // TYPE_ELAB
			mtp_TYPE_5F_ELAB_1();
			mp_prim_drop();
			mp_prim_swap();
			mtw_TYPE_5F_ELAB_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_type_sig_21__1 (void) {
	mp_prim_dup();
	mw_run_end_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_dup();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected type signature", 23);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_error_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_elab_type_sig_params_21__1();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
	mw_elab_type_stack_21__1();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		push_value(d2);
	}
	mp_prim_dup();
	mw_sig_dashes_3F__1();
	if (pop_u64()) {
		mw_next_1();
		mw_elab_type_stack_21__1();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			push_value(d3);
		}
	} else {
		{
			VAL d3 = pop_value();
			mw_T0_1();
			mw_rotr_1();
			push_value(d3);
		}
	}
	mp_prim_dup();
	mw_run_end_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_dup();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected right paren or comma", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		VAL d2 = pop_value();
		mw_rot4r_1();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // L1
					mtp_L1_1();
					mw_T_2A__1();
					break;
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw_T_2A__1();
						push_value(d6);
					}
					mw_T_2A__1();
					break;
				case 3LL: // L3
					mtp_L3_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_T_2A__1();
							push_value(d7);
						}
						mw_T_2A__1();
						push_value(d6);
					}
					mw_T_2A__1();
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					mp_prim_drop();
					{
						VAL d6 = pop_value();
						mw_for_3_1511();
						push_value(d6);
					}
					mw_for_3_1511();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			push_value(d3);
		}
		mw_T__3E__1();
		push_value(d2);
	}
}
static void mw_elab_type_sig_params_21__1 (void) {
	mp_prim_dup();
	mw_lparen_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			mp_prim_dup();
			mw_next_1();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // L0
				mw_rotr_1();
				mw_args_2();
				switch (get_top_data_tag()) {
					case 0LL: // L0
						(void)pop_u64();
						mp_prim_id();
						break;
					case 1LL: // L1
						mtp_L1_1();
						mw_elab_type_sig_21__1();
						mp_prim_drop();
						mw__3E_Type_1();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_snoc_1();
							push_value(d7);
						}
						break;
					case 2LL: // L2
						mtp_L2_1();
						{
							VAL d7 = pop_value();
							mw_elab_type_sig_21__1();
							mp_prim_drop();
							mw__3E_Type_1();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_snoc_1();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_elab_type_sig_21__1();
						mp_prim_drop();
						mw__3E_Type_1();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_snoc_1();
							push_value(d7);
						}
						break;
					case 3LL: // L3
						mtp_L3_1();
						{
							VAL d7 = pop_value();
							{
								VAL d8 = pop_value();
								mw_elab_type_sig_21__1();
								mp_prim_drop();
								mw__3E_Type_1();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_snoc_1();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_elab_type_sig_21__1();
							mp_prim_drop();
							mw__3E_Type_1();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_snoc_1();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_elab_type_sig_21__1();
						mp_prim_drop();
						mw__3E_Type_1();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_snoc_1();
							push_value(d7);
						}
						break;
					case 4LL: // LCAT
						mtp_LCAT_1();
						mp_prim_drop();
						{
							VAL d7 = pop_value();
							mw_for_3_1515();
							push_value(d7);
						}
						mw_for_3_1515();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mp_prim_swap();
				push_value(d4);
			}
			break;
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			mp_prim_swap();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_type_stack_21__1 (void) {
	mp_prim_dup();
	mw_sig_stack_var_3F__1();
	if (pop_u64()) {
		mw_elab_stack_var_21__1();
		{
			VAL d3 = pop_value();
			mtw_STVar_1();
			push_value(d3);
		}
	} else {
		{
			VAL d3 = pop_value();
			mw_T0_1();
			push_value(d3);
		}
	}
	mw_elab_type_stack_rest_21__1();
}
static void mw_elab_type_stack_rest_21__1 (void) {
	while(1) {
		mp_prim_dup();
		mw_sig_stack_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mp_prim_swap();
		{
			VAL d3 = pop_value();
			mw_elab_type_atom_21__1();
			push_value(d3);
		}
		mp_prim_swap();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			mw_cons_4();
			push_value(d3);
		}
	}
}
static void mw_elab_type_arg_21__1 (void) {
	mw_elab_type_atom_21__1();
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // STPCons
			mtp_STPCons_1();
			mp_prim_swap();
			break;
		case 1LL: // STPConsLabel
			mtp_STPConsLabel_1();
			mw_drop2_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected type, not label.", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 2LL: // STPWith
			mtp_STPWith_1();
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected type, not resource.", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_arg_end_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Unexpected token after type.", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_cons_4 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // STPCons
			mtp_STPCons_1();
			mtw_STCons_1();
			break;
		case 1LL: // STPConsLabel
			mtp_STPConsLabel_1();
			mtw_STConsLabel_1();
			break;
		case 2LL: // STPWith
			mtp_STPWith_1();
			mtw_STWith_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_type_atom_21__1 (void) {
	mp_prim_dup();
	mw_could_be_sig_label_3F__1();
	if (pop_u64()) {
		mw_elab_stack_label_21__1();
		{
			VAL d3 = pop_value();
			mtw_STPConsLabel_1();
			push_value(d3);
		}
	} else {
		mp_prim_dup();
		mw_sig_type_var_3F__1();
		if (pop_u64()) {
			mw_elab_type_var_21__1();
			{
				VAL d4 = pop_value();
				mtw_TVar_1();
				mtw_STPCons_1();
				push_value(d4);
			}
		} else {
			mp_prim_dup();
			mw_sig_type_con_3F__1();
			if (pop_u64()) {
				mw_elab_type_con_21__1();
				{
					VAL d5 = pop_value();
					mtw_STPCons_1();
					push_value(d5);
				}
			} else {
				mp_prim_dup();
				mw_sig_resource_var_3F__1();
				if (pop_u64()) {
					mw_elab_resource_var_21__1();
					{
						VAL d6 = pop_value();
						mtw_TVar_1();
						mtw_STPWith_1();
						push_value(d6);
					}
				} else {
					mp_prim_dup();
					mw_sig_resource_con_3F__1();
					if (pop_u64()) {
						mw_elab_resource_con_21__1();
						{
							VAL d7 = pop_value();
							mtw_STPWith_1();
							push_value(d7);
						}
					} else {
						mp_prim_dup();
						mw_pat_underscore_3F__1();
						if (pop_u64()) {
							mw_elab_type_dont_care_21__1();
							{
								VAL d8 = pop_value();
								mtw_STPCons_1();
								push_value(d8);
							}
						} else {
							mp_prim_dup();
							mw_sig_type_hole_3F__1();
							if (pop_u64()) {
								mw_elab_type_hole_21__1();
								{
									VAL d9 = pop_value();
									mtw_STPCons_1();
									push_value(d9);
								}
							} else {
								mp_prim_dup();
								mw_lsquare_3F__1();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_elab_type_quote_21__1();
										{
											VAL d11 = pop_value();
											mtw_STPCons_1();
											push_value(d11);
										}
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_dup();
										{
											static bool vready = false;
											static VAL v;
											if (! vready) {
												v = mkstr("Expected type, got unknown token.", 33);
												vready = true;
											}
											push_value(v);
											incref(v);
										}
										mw_emit_error_21__1();
										{
											VAL d11 = pop_value();
											push_u64(0LL); // TYPE_ERROR
											mtw_STPCons_1();
											push_value(d11);
										}
										mw_next_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
							}
						}
					}
				}
			}
		}
	}
}
static void mw_elab_stack_label_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_args_1_1();
		mw_elab_type_atom_21__1();
		mp_prim_drop();
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // STPCons
			mtp_STPCons_1();
			mp_prim_id();
			break;
		default:
			mp_prim_drop();
			mp_prim_dup();
			mw_args_1_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected type", 13);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_error_21__1();
			push_u64(0LL); // TYPE_ERROR
			break;
	}
	mp_prim_swap();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_name_3F__2();
		mw_unwrap_1();
		mw_new_21__8();
		push_value(d2);
	}
	mw_next_1();
}
static void mw_elab_stack_var_21__1 (void) {
	mw_TYPE_5F_STACK_1();
	mw_elab_implicit_var_21__1();
}
static void mw_elab_type_var_21__1 (void) {
	mw_TYPE_5F_TYPE_1();
	mw_elab_implicit_var_21__1();
}
static void mw_elab_resource_var_21__1 (void) {
	mw_TYPE_5F_RESOURCE_1();
	mw_elab_implicit_var_21__1();
}
static void mw_elab_implicit_var_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_type_elab_ctx_3F__1();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_over_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_name_3F__2();
			mw_unwrap_1();
			mw_dup2_1();
			mp_prim_swap();
			mw_lookup_2();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_rotl_1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_nip_1();
					mp_prim_dup();
					mw_type_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_nip_1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mw_new_21__3();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_next_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_type_elab_ctx_replace_1();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_elab_type_con_21__1 (void) {
	mp_prim_dup();
	mw_name_3F__2();
	mw_unwrap_1();
	mw__3E_Str_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Mut", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3D__3D__7();
	if (pop_u64()) {
		mw_tuck_1();
		mw_args_1_1();
		mw_elab_type_arg_21__1();
		mp_prim_drop();
		mtw_TMut_1();
		mw_rotl_1();
		mw_next_1();
	} else {
		mp_prim_dup();
		mw_name_3F__2();
		mw_unwrap_1();
		mw_defs_1();
		mw__3E_List_2B__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_find_some_2_3092();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				switch (get_top_data_tag()) {
					case 3LL: // DEF_DATA
						mtp_DEF_5F_DATA_1();
						mtw_TData_1();
						break;
					case 4LL: // DEF_TABLE
						mtp_DEF_5F_TABLE_1();
						mtw_TTable_1();
						break;
					case 5LL: // DEF_TYPEDEF
						mtp_DEF_5F_TYPEDEF_1();
						mw_target_1();
						break;
					default:
						mp_prim_drop();
						mp_prim_dup();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("Not a type.", 11);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_error_21__1();
						push_u64(0LL); // TYPE_ERROR
						break;
				}
				break;
			case 0LL: // NONE
				(void)pop_u64();
				mp_prim_dup();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Unknown type.", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_error_21__1();
				push_u64(0LL); // TYPE_ERROR
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_dup();
		mw_error_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				mw_over_1();
				mw_num_args_1();
				mw_over_1();
				mw_arity_2();
				mp_prim_int_eq();
				if (pop_u64()) {
					mw_elab_type_args_21__1();
				} else {
					mp_prim_drop();
					mp_prim_dup();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("Wrong number of argumets for type.", 34);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_error_21__1();
					push_u64(0LL); // TYPE_ERROR
				}
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_swap();
		mw_next_1();
	}
}
static void mw_elab_resource_con_21__1 (void) {
	mw_elab_type_con_21__1();
	{
		VAL d2 = pop_value();
		push_value(d2);
	}
}
static void mw_elab_type_args_21__1 (void) {
	mw_over_1();
	mw_has_args_3F__1();
	if (pop_u64()) {
		{
			VAL d3 = pop_value();
			mw_tuck_1();
			push_value(d3);
		}
		mp_prim_swap();
		mw_succ_7();
		while(1) {
			mp_prim_dup();
			mw_args_end_3F__1();
			mw_not_1();
			if (! pop_u64()) break;
			mw_succ_7();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_elab_type_arg_21__1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mtw_TApp_1();
				push_value(d4);
			}
		}
		mp_prim_drop();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			push_value(d3);
		}
	} else {
		mp_prim_id();
	}
}
static void mw_elab_type_hole_21__1 (void) {
	mw_over_1();
	mw_type_elab_holes_allowed_1();
	if (pop_u64()) {
		mp_prim_dup();
		mw_args_0_1();
		mp_prim_dup();
		mw_name_3F__2();
		mw_unwrap_1();
		mtw_THole_1();
		mp_prim_swap();
		mw_next_1();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("type holes are not allowed here", 31);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_emit_fatal_error_21__1();
	}
}
static void mw_elab_type_dont_care_21__1 (void) {
	mw_over_1();
	mw_type_elab_holes_allowed_1();
	if (pop_u64()) {
		mp_prim_dup();
		mw_args_0_1();
		push_u64(1LL); // TYPE_DONT_CARE
		mp_prim_swap();
		mw_next_1();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("underscore is not allowed here", 30);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_emit_fatal_error_21__1();
	}
}
static void mw_elab_type_quote_21__1 (void) {
	mw_args_1_1();
	mp_prim_dup();
	mw_sig_has_dashes_3F__1();
	if (pop_u64()) {
		mw_elab_type_sig_21__1();
		{
			VAL d3 = pop_value();
			mw__3E_Type_1();
			push_value(d3);
		}
	} else {
		mw_elab_type_stack_21__1();
		{
			VAL d3 = pop_value();
			mw__3E_Type_3();
			push_value(d3);
		}
	}
	mw_next_1();
}
static void mw_elab_type_unify_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_rotr_1();
		mw_unify_21__7();
		mw_nip_1();
		push_value(d2);
	}
}
static void mw_elab_stack_type_unify_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_rotr_1();
		mw_unify_21__6();
		mw_nip_1();
		push_value(d2);
	}
}
static void mw_elab_simple_type_arg_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_type_elab_default_1();
		push_value(d2);
	}
	mw_elab_type_arg_21__1();
	mp_prim_drop();
	mw_nip_1();
}
static void mw__2F_MKAB_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // MKAB
			mtp_MKAB_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_arrow_4 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 2, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	push_value(u);
}
static void mw_arrow_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 2, v);
	VAL* p = &VTUP(v)->cells[1];
	VAL t = *p; *p = u; decref(t);
}
static void mw_ab_token_40__1 (void) {
	mw_arrow_4();
	mw_token_end_4();
}
static void mw_ab_token_21__1 (void) {
	mw_arrow_4();
	{
		VAL d2 = pop_resource();
		mw_token_end_21__2();
		push_resource(d2);
	}
	mw_arrow_21__1();
}
static void mw_ab_type_40__1 (void) {
	mw_arrow_4();
	mw_cod_12();
}
static void mw_ab_type_21__1 (void) {
	mw_arrow_4();
	{
		VAL d2 = pop_resource();
		mw_cod_21__5();
		push_resource(d2);
	}
	mw_arrow_21__1();
}
static void mw_ab_ctx_40__1 (void) {
	mw_arrow_4();
	mw_ctx_13();
}
static void mw_ab_home_40__1 (void) {
	mw_arrow_4();
	mw_home_8();
}
static void mw_ab_build_21__1 (void) {
	{
		VAL var_f = pop_value();
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		incref(var_f);
		run_value(var_f);
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		decref(var_f);
	}
}
static void mw_ab_build_hom_21__1 (void) {
	{
		VAL var_f = pop_value();
		push_fnptr(&mb_1587);
		mw_dip2_1();
		push_fnptr(&mb_1588);
		incref(var_f);
		push_value(var_f);
		mp_prim_pack_cons();
		mw_ab_build_21__1();
		decref(var_f);
	}
}
static void mw_ab_build_word_arrow_21__1 (void) {
	{
		VAL var_f = pop_value();
		push_fnptr(&mb_1590);
		mw_sip_1();
		push_fnptr(&mb_1591);
		mw_sip_1();
		mtw_HOME_5F_WORD_1();
		incref(var_f);
		push_value(var_f);
		mw_ab_build_hom_21__1();
		decref(var_f);
	}
}
static void mw_ab_build_word_21__1 (void) {
	{
		VAL var_f = pop_value();
		push_fnptr(&mb_1593);
		incref(var_f);
		push_value(var_f);
		mp_prim_pack_cons();
		mw_sip_1();
		mw_tuck_1();
		mfld__7E_arrow_1();
		mp_prim_mut_set();
		decref(var_f);
	}
}
static void mw_ab_unify_type_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_ab_token_40__1();
		mw_ab_type_40__1();
		push_value(d2);
	}
	mw_unify_21__6();
	mw_ab_type_21__1();
	mp_prim_drop();
}
static void mw_ab_atom_21__1 (void) {
	mp_prim_dup();
	mw_token_11();
	mw_ab_token_21__1();
	mp_prim_dup();
	mw_cod_14();
	mw_ab_type_21__1();
	mw_arrow_4();
	{
		VAL d2 = pop_resource();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_atoms_4();
			mp_prim_swap();
			mw_ab_optimized_snoc_21__1();
			push_value(d3);
		}
		mw_atoms_21__2();
		push_resource(d2);
	}
	mw_arrow_21__1();
}
static void mw_ab_optimized_snoc_21__1 (void) {
	while(1) {
		{
			VAL d3 = pop_value();
			mw_atoms_has_last_block_3F__1();
			push_value(d3);
		}
		mp_prim_swap();
		if (pop_u64()) {
			mw_atom_accepts_args_3F__1();
		} else {
			push_u64(0LL); // F
		}
		if (! pop_u64()) break;
		mp_prim_swap();
		mw_atoms_turn_last_block_to_arg_1();
		mp_prim_swap();
	}
	mw_snoc_1();
}
static void mw_atom_accepts_args_3F__1 (void) {
	mp_prim_dup();
	mw_op_4();
	switch (get_top_data_tag()) {
		case 2LL: // OP_WORD
			mtp_OP_5F_WORD_1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_args_4();
				mw_len_1();
				mw__3E_Int_8();
				push_value(d4);
			}
			mw_arity_1();
			mp_prim_int_lt();
			break;
		case 1LL: // OP_PRIM
			mtp_OP_5F_PRIM_1();
			switch (get_top_data_tag()) {
				case 4LL: // PRIM_CORE_DIP
					(void)pop_u64();
					mp_prim_dup();
					mw_args_4();
					mw_len_1();
					push_i64(1LL);
					mw__3E_Nat_1();
					mw__3C__3();
					break;
				case 13LL: // PRIM_CORE_RDIP
					(void)pop_u64();
					mp_prim_dup();
					mw_args_4();
					mw_len_1();
					push_i64(1LL);
					mw__3E_Nat_1();
					mw__3C__3();
					break;
				case 5LL: // PRIM_CORE_IF
					(void)pop_u64();
					mp_prim_dup();
					mw_args_4();
					mw_len_1();
					push_i64(2LL);
					mw__3E_Nat_1();
					mw__3C__3();
					break;
				case 6LL: // PRIM_CORE_WHILE
					(void)pop_u64();
					mp_prim_dup();
					mw_args_4();
					mw_len_1();
					push_i64(2LL);
					mw__3E_Nat_1();
					mw__3C__3();
					break;
				default:
					mp_prim_drop();
					push_u64(0LL); // F
					break;
			}
			break;
		default:
			mp_prim_drop();
			push_u64(0LL); // F
			break;
	}
}
static void mw_atoms_has_last_block_3F__1 (void) {
	mp_prim_dup();
	mw_last_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_op_4();
			switch (get_top_data_tag()) {
				case 13LL: // OP_BLOCK
					mtp_OP_5F_BLOCK_1();
					mp_prim_drop();
					push_u64(1LL); // T
					break;
				default:
					mp_prim_drop();
					push_u64(0LL); // F
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_atoms_turn_last_block_to_arg_1 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_unsnoc_1();
			mp_prim_dup();
			mw_op_4();
			switch (get_top_data_tag()) {
				case 13LL: // OP_BLOCK
					mtp_OP_5F_BLOCK_1();
					{
						VAL d6 = pop_value();
						mw_dom_13();
						mw_rotl_1();
						mw_dom_21__5();
						push_value(d6);
					}
					mp_prim_swap();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_args_4();
						mw_cons_2();
						push_value(d6);
					}
					mw_args_21__1();
					mp_prim_swap();
					break;
				default:
					mp_prim_drop();
					mw_snoc_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_ab_op_21__1 (void) {
	mw_ab_ctx_40__1();
	LPUSH(lbl_ctx);
	mw_ab_token_40__1();
	LPUSH(lbl_token);
	mw_ab_home_40__1();
	LPUSH(lbl_home);
	mp_prim_dup();
	LPUSH(lbl_op);
	mw_elab_op_fresh_sig_21__1();
	{
		VAL d2 = pop_value();
		LPUSH(lbl_subst);
		push_value(d2);
	}
	mw_ab_expand_opsig_21__1();
	LPUSH(lbl_cod);
	LPUSH(lbl_dom);
	push_u64(0LL); // L0
	LPUSH(lbl_args);
	mtw_ATOM_1();
	mw_ab_atom_21__1();
}
static void mw_ab_expand_opsig_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // OPSIG_ID
			(void)pop_u64();
			mw_ab_type_40__1();
			mp_prim_dup();
			break;
		case 1LL: // OPSIG_PUSH
			mtp_OPSIG_5F_PUSH_1();
			{
				VAL d4 = pop_value();
				mw_ab_type_40__1();
				mp_prim_dup();
				push_value(d4);
			}
			mtw_STCons_1();
			break;
		case 2LL: // OPSIG_APPLY
			mtp_OPSIG_5F_APPLY_1();
			{
				VAL d4 = pop_value();
				mw_ab_type_40__1();
				push_value(d4);
			}
			mw_unpack_1();
			{
				VAL d4 = pop_value();
				mw_ab_token_40__1();
				mw_elab_stack_type_unify_21__1();
				mp_prim_drop();
				push_value(d4);
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_ab_int_21__1 (void) {
	mtw_OP_5F_INT_1();
	mw_ab_op_21__1();
}
static void mw_ab_str_21__1 (void) {
	mtw_OP_5F_STR_1();
	mw_ab_op_21__1();
}
static void mw_ab_buffer_21__1 (void) {
	mtw_OP_5F_BUFFER_1();
	mw_ab_op_21__1();
}
static void mw_ab_variable_21__1 (void) {
	mtw_OP_5F_VARIABLE_1();
	mw_ab_op_21__1();
}
static void mw_ab_field_21__1 (void) {
	mtw_OP_5F_FIELD_1();
	mw_ab_op_21__1();
}
static void mw_ab_var_21__1 (void) {
	mtw_OP_5F_VAR_1();
	mw_ab_op_21__1();
}
static void mw_ab_tag_21__1 (void) {
	mtw_OP_5F_TAG_1();
	mw_ab_op_21__1();
}
static void mw_ab_prim_21__1 (void) {
	mp_prim_dup();
	mfld__7E_type_3();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mtw_OP_5F_PRIM_1();
		mw_ab_op_21__1();
	} else {
		mw_ab_token_40__1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("prim does not have type", 23);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_emit_fatal_error_21__1();
	}
}
static void mw_ab_word_21__1 (void) {
	mtw_OP_5F_WORD_1();
	mw_ab_op_21__1();
}
static void mw_ab_external_21__1 (void) {
	mtw_OP_5F_EXTERNAL_1();
	mw_ab_op_21__1();
}
static void mw_ab_coerce_21__1 (void) {
	mtw_OP_5F_COERCE_1();
	mw_ab_op_21__1();
}
static void mw_ab_label_push_21__1 (void) {
	mtw_OP_5F_LABEL_5F_PUSH_1();
	mw_ab_op_21__1();
}
static void mw_ab_label_pop_21__1 (void) {
	mtw_OP_5F_LABEL_5F_POP_1();
	mw_ab_op_21__1();
}
static void mw_ab_block_at_21__1 (void) {
	{
		VAL var_f = pop_value();
		mw_ab_ctx_40__1();
		mw_new_21__5();
		mtw_STMeta_1();
		mw_rotl_1();
		mw_ab_home_40__1();
		{
			VAL d3 = pop_resource();
			incref(var_f);
			push_value(var_f);
			mw_ab_build_21__1();
			push_resource(d3);
		}
		mw_new_21__10();
		mtw_OP_5F_BLOCK_1();
		mw_ab_op_21__1();
		decref(var_f);
	}
}
static void mw_ab_block_21__1 (void) {
	{
		VAL var_f = pop_value();
		mw_ab_token_40__1();
		incref(var_f);
		push_value(var_f);
		mw_ab_block_at_21__1();
		decref(var_f);
	}
}
static void mw_ab_dip_21__1 (void) {
	{
		VAL var_f = pop_value();
		incref(var_f);
		push_value(var_f);
		mw_ab_block_21__1();
		push_u64(4LL); // PRIM_CORE_DIP
		mw_ab_prim_21__1();
		decref(var_f);
	}
}
static void mw_ab_while_21__1 (void) {
	{
		VAL var_g = pop_value();
		VAL var_f = pop_value();
		incref(var_f);
		push_value(var_f);
		mw_ab_block_21__1();
		incref(var_g);
		push_value(var_g);
		mw_ab_block_21__1();
		push_u64(6LL); // PRIM_CORE_WHILE
		mw_ab_prim_21__1();
		decref(var_g);
		decref(var_f);
	}
}
static void mw_ab_lambda_21__1 (void) {
	{
		VAL var_f = pop_value();
		{
			VAL d3 = pop_value();
			mw_ab_token_40__1();
			push_value(d3);
		}
		incref(var_f);
		push_value(var_f);
		mw_ab_lambda_at_21__1();
		decref(var_f);
	}
}
static void mw_ab_lambda_at_21__1 (void) {
	{
		VAL var_f = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_ab_ctx_40__1();
				mw_ab_type_40__1();
				push_value(d4);
			}
			push_fnptr(&mb_1624);
			mw_reverse_for_1();
			mw_rotl_1();
			mw_ab_home_40__1();
			{
				VAL d4 = pop_resource();
				incref(var_f);
				push_value(var_f);
				mw_ab_build_21__1();
				push_resource(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_params);
		LPUSH(lbl_body);
		mw_ab_ctx_40__1();
		LPUSH(lbl_outer_ctx);
		mw_ab_type_40__1();
		LPUSH(lbl_dom);
		mw_ab_token_40__1();
		LPUSH(lbl_token);
		mtw_LAMBDA_1();
		mtw_OP_5F_LAMBDA_1();
		mw_ab_op_21__1();
		decref(var_f);
	}
}
static void mw_elab_op_fresh_sig_21__1 (void) {
	mw_nil_6();
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // OP_NONE
			(void)pop_u64();
			push_u64(0LL); // OPSIG_ID
			break;
		case 7LL: // OP_INT
			mtp_OP_5F_INT_1();
			mtw_VALUE_5F_INT_1();
			mtw_TValue_1();
			mtw_OPSIG_5F_PUSH_1();
			break;
		case 8LL: // OP_STR
			mtp_OP_5F_STR_1();
			mtw_VALUE_5F_STR_1();
			mtw_TValue_1();
			mtw_OPSIG_5F_PUSH_1();
			break;
		case 4LL: // OP_BUFFER
			mtp_OP_5F_BUFFER_1();
			mp_prim_drop();
			mw_TYPE_5F_PTR_1();
			mtw_OPSIG_5F_PUSH_1();
			break;
		case 5LL: // OP_VARIABLE
			mtp_OP_5F_VARIABLE_1();
			mw_type_3();
			mtw_TMut_1();
			mtw_OPSIG_5F_PUSH_1();
			break;
		case 9LL: // OP_TAG
			mtp_OP_5F_TAG_1();
			mw_type_9();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 2LL: // OP_WORD
			mtp_OP_5F_WORD_1();
			mw_type_2();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 1LL: // OP_PRIM
			mtp_OP_5F_PRIM_1();
			mw_type_7();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 3LL: // OP_EXTERNAL
			mtp_OP_5F_EXTERNAL_1();
			mw_type_8();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 6LL: // OP_FIELD
			mtp_OP_5F_FIELD_1();
			mw_type_6();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 13LL: // OP_BLOCK
			mtp_OP_5F_BLOCK_1();
			mw_elab_block_sig_21__1();
			break;
		case 14LL: // OP_RUN
			mtp_OP_5F_RUN_1();
			mw_type_12();
			mw_semifreshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mw_elab_var_sig_21__1();
			break;
		case 10LL: // OP_MATCH
			mtp_OP_5F_MATCH_1();
			mw_elab_match_sig_21__1();
			break;
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mw_elab_lambda_sig_21__1();
			break;
		case 15LL: // OP_COERCE
			mtp_OP_5F_COERCE_1();
			mw_elab_coerce_sig_21__1();
			break;
		case 16LL: // OP_LABEL_PUSH
			mtp_OP_5F_LABEL_5F_PUSH_1();
			mw_elab_label_push_sig_21__1();
			break;
		case 17LL: // OP_LABEL_POP
			mtp_OP_5F_LABEL_5F_POP_1();
			mw_elab_label_pop_sig_21__1();
			break;
		case 18LL: // OP_DATA_GET_LABEL
			mtp_OP_5F_DATA_5F_GET_5F_LABEL_1();
			mw_data_get_label_type_1();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		case 19LL: // OP_DATA_SET_LABEL
			mtp_OP_5F_DATA_5F_SET_5F_LABEL_1();
			mw_data_set_label_type_1();
			mw_freshen_sig_1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_coerce_sig_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // COERCE_UNSAFE
			(void)pop_u64();
			mw_new_21__5();
			mtw_STMeta_1();
			mp_prim_dup();
			mw_new_21__5();
			mtw_TMeta_1();
			mw_T_2A__1();
			mp_prim_swap();
			mw_new_21__5();
			mtw_TMeta_1();
			mw_T_2A__1();
			mw_T__3E__1();
			mtw_OPSIG_5F_APPLY_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_block_sig_21__1 (void) {
	mtw_VALUE_5F_BLOCK_1();
	mtw_TValue_1();
	mtw_OPSIG_5F_PUSH_1();
}
static void mw_elab_match_sig_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_dom_6();
		push_value(d2);
	}
	mw_cod_6();
	mw_T__3E__1();
	mtw_OPSIG_5F_APPLY_1();
}
static void mw_elab_lambda_sig_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_dom_16();
		push_value(d2);
	}
	mw_cod_16();
	mw_T__3E__1();
	mtw_OPSIG_5F_APPLY_1();
}
static void mw_elab_var_sig_21__1 (void) {
	mp_prim_dup();
	mw_auto_run_3F__1();
	if (pop_u64()) {
		mw_type_4();
		mw_morphism_3F__1();
		mw_unwrap_1();
		mw_semifreshen_sig_1();
		mtw_OPSIG_5F_APPLY_1();
	} else {
		mw_type_4();
		mtw_OPSIG_5F_PUSH_1();
	}
}
static void mw_elab_label_push_sig_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_new_21__5();
		mtw_STMeta_1();
		mw_new_21__5();
		mtw_TMeta_1();
		mw_dup2_1();
		push_value(d2);
	}
	mtw_STConsLabel_1();
	{
		VAL d2 = pop_value();
		mtw_STCons_1();
		push_value(d2);
	}
	mw_T__3E__1();
	mtw_OPSIG_5F_APPLY_1();
}
static void mw_elab_label_pop_sig_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_new_21__5();
		mtw_STMeta_1();
		mw_new_21__5();
		mtw_TMeta_1();
		mw_dup2_1();
		push_value(d2);
	}
	mtw_STConsLabel_1();
	{
		VAL d2 = pop_value();
		mtw_STCons_1();
		push_value(d2);
	}
	mp_prim_swap();
	mw_T__3E__1();
	mtw_OPSIG_5F_APPLY_1();
}
static void mw_elab_arrow_hom_21__1 (void) {
	mw_rotl_1();
	{
		VAL d2 = pop_value();
		mw_elab_arrow_fwd_21__1();
		mp_prim_dup();
		mw_token_end_4();
		mw_over_1();
		mw_cod_12();
		push_value(d2);
	}
	mw_unify_21__6();
	mw_drop2_1();
}
static void mw_elab_arrow_fwd_21__1 (void) {
	LPUSH(lbl_home);
	mp_prim_dup();
	LPUSH(lbl_token_start);
	LPUSH(lbl_token_end);
	mp_prim_dup();
	LPUSH(lbl_dom);
	LPUSH(lbl_cod);
	LPUSH(lbl_ctx);
	push_u64(0LL); // L0
	LPUSH(lbl_atoms);
	mtw_ARROW_1();
	LPUSH(lbl_arrow);
	mtw_MKAB_1();
	mw_elab_atoms_21__1();
	mw__2F_MKAB_1();
	LPOP(lbl_arrow);
}
static void mw_elab_atoms_21__1 (void) {
	while(1) {
		mw_ab_token_40__1();
		mw_run_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_elab_atom_21__1();
		mw_ab_token_40__1();
		mw_next_1();
		mw_ab_token_21__1();
	}
}
static void mw_elab_atom_21__1 (void) {
	mw_ab_token_40__1();
	mw_value_3();
	switch (get_top_data_tag()) {
		case 16LL: // TOKEN_NAME
			mtp_TOKEN_5F_NAME_1();
			mw_ab_token_40__1();
			mw_num_args_1();
			mw_elab_atom_name_21__1();
			break;
		case 17LL: // TOKEN_DNAME
			mtp_TOKEN_5F_DNAME_1();
			mw_ab_token_40__1();
			mw_num_args_1();
			mw_elab_atom_dname_21__1();
			break;
		case 14LL: // TOKEN_INT
			mtp_TOKEN_5F_INT_1();
			mw_ab_int_21__1();
			break;
		case 15LL: // TOKEN_STR
			mtp_TOKEN_5F_STR_1();
			mw_ab_str_21__1();
			break;
		case 6LL: // TOKEN_LSQUARE
			mtp_TOKEN_5F_LSQUARE_1();
			mp_prim_drop();
			mw_elab_atom_block_21__1();
			break;
		case 9LL: // TOKEN_LCURLY
			mtp_TOKEN_5F_LCURLY_1();
			mp_prim_drop();
			mw_elab_atom_assert_21__1();
			break;
		case 18LL: // TOKEN_LABEL_PUSH
			mtp_TOKEN_5F_LABEL_5F_PUSH_1();
			mw_ab_label_push_21__1();
			break;
		case 19LL: // TOKEN_LABEL_POP
			mtp_TOKEN_5F_LABEL_5F_POP_1();
			mw_ab_label_pop_21__1();
			break;
		default:
			mw_ab_token_40__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Unexpected token in elab-atom!", 30);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
	}
}
static void mw_elab_atom_block_21__1 (void) {
	mw_ab_token_40__1();
	mw_args_1_1();
	mw_elab_block_at_21__1();
}
static void mw_elab_block_at_21__1 (void) {
	mw_ab_ctx_40__1();
	mp_prim_swap();
	mw_ab_home_40__1();
	mw_alloc_21__17();
	mw_tuck_1();
	mfld__7E_home_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_token_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_ctx_2();
	mp_prim_mut_set();
	mw_new_21__5();
	mtw_STMeta_1();
	mw_over_1();
	mfld__7E_dom_1();
	mp_prim_mut_set();
	mw_new_21__5();
	mtw_STMeta_1();
	mw_over_1();
	mfld__7E_cod_1();
	mp_prim_mut_set();
	mp_prim_dup();
	push_fnptr(&mb_1652);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_arrow_2();
	mp_prim_mut_set();
	mtw_OP_5F_BLOCK_1();
	mw_ab_op_21__1();
}
static void mw_elab_args_21__1 (void) {
	mw_ab_token_40__1();
	mw_args_2();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_elab_block_at_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_elab_block_at_21__1();
				push_value(d4);
			}
			mw_elab_block_at_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_elab_block_at_21__1();
					push_value(d5);
				}
				mw_elab_block_at_21__1();
				push_value(d4);
			}
			mw_elab_block_at_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1653();
				push_value(d4);
			}
			mw_for_3_1653();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_no_args_21__1 (void) {
	mw_ab_token_40__1();
	mw_args_0_1();
}
static void mw_elab_qname_is_imported_3F__1 (void) {
	mp_prim_dup();
	mw_namespace_5();
	switch (get_top_data_tag()) {
		case 2LL: // NAMESPACE_MODULE
			mtp_NAMESPACE_5F_MODULE_1();
			mw_nip_1();
			mw_elab_module_is_visible_1();
			break;
		case 3LL: // NAMESPACE_TYCON
			mtp_NAMESPACE_5F_TYCON_1();
			mw_elab_tycon_is_visible_1();
			if (pop_u64()) {
				mp_prim_dup();
				mw_def_3F__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						push_u64(0LL); // NONE
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mw_tag_3F__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_some_3F__1();
			} else {
				push_u64(0LL); // F
			}
			mw_nip_1();
			break;
		default:
			mw_drop2_1();
			push_u64(0LL); // F
			break;
	}
}
static void mw_arity_compatible_3F__1 (void) {
	mp_prim_dup();
	push_i64(-1LL);
	mp_prim_int_eq();
	{
		VAL d2 = pop_value();
		mp_prim_int_eq();
		push_value(d2);
	}
	mw__7C__7C__1();
}
static void mw_elab_atom_name_21__1 (void) {
	mw_over_1();
	mw_ab_ctx_40__1();
	mw_lookup_2();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			mw_elab_args_21__1();
			mw_ab_var_21__1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_over_1();
			mw_defs_1();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					push_u64(0LL); // L0
					break;
				case 1LL: // L1
					mtp_L1_1();
					mw_qname_12();
					mtw_L1_1();
					break;
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw_qname_12();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw_qname_12();
						push_value(d6);
					}
					mp_prim_swap();
					mtw_L2_1();
					break;
				case 3LL: // L3
					mtp_L3_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_qname_12();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_qname_12();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_qname_12();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					mtw_L3_1();
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_map_4_1645();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_map_4_1645();
							push_value(d7);
						}
						mp_prim_swap();
						push_value(d6);
					}
					mtw_LCAT_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_filter_2_1646();
			mw_filter_2_1647();
			mw_over2_1();
			mw_can_be_relative_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						mw_dup2_1();
						mw_elab_relative_name_candidates_21__1();
						push_value(d6);
					}
					mp_prim_swap();
					mw_cat_2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						mw_ab_token_40__1();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unknown name: ", 14);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						push_value(d6);
					}
					mw__3E_Str_3();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // L1
					mtp_L1_1();
					mw_nip_1();
					mw_elab_atom_qname_21__1();
					break;
				default:
					mw_nip_1();
					{
						VAL d6 = pop_value();
						mw_ab_token_40__1();
						push_value(d6);
					}
					mw_elab_ambiguous_name_error_21__1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_atom_dname_21__1 (void) {
	mw_over_1();
	mw_root_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			mw_elab_atom_nonrelative_dname_21__1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_swap();
			mw_parts_1();
			switch (get_top_data_tag()) {
				case 0LL: // L1+
					mtp_L1_2B__1();
					mp_prim_swap();
					mw_elab_atom_relative_name_21__1();
					break;
				default:
					mw_ab_token_40__1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("relative name has too many parts", 32);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_atom_nonrelative_dname_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_ab_token_40__1();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_elab_qname_from_nonrelative_dname_1();
	mw_elab_atom_qname_21__1();
}
static void mw_elab_relative_name_candidates_21__1 (void) {
	push_u64(0LL); // NAMESPACE_ROOT
	LPUSH(lbl_namespace);
	LPUSH(lbl_arity);
	LPUSH(lbl_name);
	mtw_MKQNAME_1();
	LPUSH(lbl_template);
	push_u64(0LL); // L0
	push_u64(0LL); // L0
	mw_ab_type_40__1();
	mw_top_tycon_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_snoc_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_ab_type_40__1();
	mw_top_resource_tycon_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_snoc_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mtw_NAMESPACE_5F_TYCON_1();
			LPOP(lbl_template);
			mp_prim_dup();
			LPUSH(lbl_template);
			mw_namespace_21__1();
			push_i64(-1LL);
			mw_over_1();
			mw_arity_21__1();
			mtw_L2_1();
			mw_cat_2();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mtw_NAMESPACE_5F_TYCON_1();
				LPOP(lbl_template);
				mp_prim_dup();
				LPUSH(lbl_template);
				mw_namespace_21__1();
				push_i64(-1LL);
				mw_over_1();
				mw_arity_21__1();
				mtw_L2_1();
				mw_cat_2();
				push_value(d4);
			}
			mtw_NAMESPACE_5F_TYCON_1();
			LPOP(lbl_template);
			mp_prim_dup();
			LPUSH(lbl_template);
			mw_namespace_21__1();
			push_i64(-1LL);
			mw_over_1();
			mw_arity_21__1();
			mtw_L2_1();
			mw_cat_2();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mtw_NAMESPACE_5F_TYCON_1();
					LPOP(lbl_template);
					mp_prim_dup();
					LPUSH(lbl_template);
					mw_namespace_21__1();
					push_i64(-1LL);
					mw_over_1();
					mw_arity_21__1();
					mtw_L2_1();
					mw_cat_2();
					push_value(d5);
				}
				mtw_NAMESPACE_5F_TYCON_1();
				LPOP(lbl_template);
				mp_prim_dup();
				LPUSH(lbl_template);
				mw_namespace_21__1();
				push_i64(-1LL);
				mw_over_1();
				mw_arity_21__1();
				mtw_L2_1();
				mw_cat_2();
				push_value(d4);
			}
			mtw_NAMESPACE_5F_TYCON_1();
			LPOP(lbl_template);
			mp_prim_dup();
			LPUSH(lbl_template);
			mw_namespace_21__1();
			push_i64(-1LL);
			mw_over_1();
			mw_arity_21__1();
			mtw_L2_1();
			mw_cat_2();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1659();
				push_value(d4);
			}
			mw_for_3_1659();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	LPOP(lbl_template);
	mp_prim_drop();
	mw_filter_2_1660();
}
static void mw_elab_atom_relative_name_21__1 (void) {
	mw_dup2_1();
	mw_elab_relative_name_candidates_21__1();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_ab_token_40__1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("unknown relative name: ", 23);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			mw__3E_Str_3();
			mp_prim_str_cat();
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // L1
			mtp_L1_1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			mw_elab_atom_qname_21__1();
			break;
		default:
			mw_nip_1();
			{
				VAL d4 = pop_value();
				mw_ab_token_40__1();
				push_value(d4);
			}
			mw_elab_ambiguous_name_error_21__1();
			break;
	}
}
static void mw_elab_ambiguous_name_error_21__1 (void) {
	{
		VAL d2 = pop_value();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("name is ambiguous, can't decide between:", 40);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		push_value(d2);
	}
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" ", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_str_cat();
					push_value(d5);
				}
				mw__3E_Str_5();
				mp_prim_str_cat();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" ", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_str_cat();
						push_value(d6);
					}
					mw__3E_Str_5();
					mp_prim_str_cat();
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_str_cat();
					push_value(d5);
				}
				mw__3E_Str_5();
				mp_prim_str_cat();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" ", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1664();
				push_value(d4);
			}
			mw_for_3_1664();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_emit_fatal_error_21__1();
}
static void mw_elab_atom_qname_21__1 (void) {
	mp_prim_dup();
	mw_def_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				VAL d4 = pop_value();
				mw_ab_token_40__1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("unknown name: ", 14);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_ab_token_40__1();
			mw_over_1();
			mw_def_visible_from_token_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					mw_over_1();
					mw_elab_atom_not_visible_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			mw_elab_atom_def_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_qname_is_visible_1 (void) {
	mw_namespace_5();
	mw_elab_namespace_is_visible_1();
}
static void mw_elab_namespace_is_visible_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NAMESPACE_ROOT
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // NAMESPACE_PACKAGE
			mtp_NAMESPACE_5F_PACKAGE_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		case 2LL: // NAMESPACE_MODULE
			mtp_NAMESPACE_5F_MODULE_1();
			mw_elab_module_is_visible_1();
			break;
		case 3LL: // NAMESPACE_TYCON
			mtp_NAMESPACE_5F_TYCON_1();
			mw_elab_tycon_is_visible_1();
			break;
		case 4LL: // NAMESPACE_WORD
			mtp_NAMESPACE_5F_WORD_1();
			mp_prim_drop();
			push_u64(0LL); // F
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_tycon_is_visible_1 (void) {
	mw_qname_4();
	mw_elab_qname_is_visible_1();
}
static void mw_elab_module_is_visible_1 (void) {
	mw_ab_token_40__1();
	mw_module_3();
	mw_visible_1();
}
static void mw_elab_stack_type_is_fine_3F__1 (void) {
	mw_ab_type_40__1();
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 0LL: // STACK_TYPE_ERROR
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		default:
			mp_prim_drop();
			push_u64(1LL); // T
			break;
	}
}
static void mw_elab_atom_def_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mw_target_2();
			mw_elab_atom_def_21__1();
			break;
		case 9LL: // DEF_BUFFER
			mtp_DEF_5F_BUFFER_1();
			mw_elab_no_args_21__1();
			mw_ab_buffer_21__1();
			break;
		case 10LL: // DEF_VARIABLE
			mtp_DEF_5F_VARIABLE_1();
			mw_elab_no_args_21__1();
			mw_ab_variable_21__1();
			break;
		case 11LL: // DEF_EXTERNAL
			mtp_DEF_5F_EXTERNAL_1();
			mw_elab_no_args_21__1();
			mw_ab_external_21__1();
			break;
		case 12LL: // DEF_FIELD
			mtp_DEF_5F_FIELD_1();
			mw_elab_no_args_21__1();
			mw_ab_field_21__1();
			break;
		case 8LL: // DEF_WORD
			mtp_DEF_5F_WORD_1();
			mw_elab_args_21__1();
			mw_ab_word_21__1();
			break;
		case 6LL: // DEF_TAG
			mtp_DEF_5F_TAG_1();
			mw_elab_args_21__1();
			mw_ab_tag_21__1();
			break;
		case 7LL: // DEF_PRIM
			mtp_DEF_5F_PRIM_1();
			mw_elab_prim_21__1();
			break;
		default:
			mw_qname_12();
			mw_name_12();
			mw_elab_atom_unknown_word_21__1();
			break;
	}
}
static void mw_elab_atom_unknown_word_21__1 (void) {
	mw_elab_stack_type_is_fine_3F__1();
	if (pop_u64()) {
		{
			VAL d3 = pop_value();
			mw_ab_token_40__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Unknown word: ", 14);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			push_value(d3);
		}
		mw__3E_Str_3();
		mp_prim_str_cat();
		mw_emit_error_21__1();
	} else {
		mp_prim_drop();
	}
	push_u64(0LL); // STACK_TYPE_ERROR
	mw_ab_type_21__1();
}
static void mw_elab_atom_not_visible_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_ab_token_40__1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("Word not visible: ", 18);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		push_value(d2);
	}
	mw__3E_Str_5();
	mp_prim_str_cat();
	mw_emit_error_21__1();
}
static void mw_elab_prim_21__1 (void) {
	switch (get_top_data_tag()) {
		case 10LL: // PRIM_CORE_MATCH
			(void)pop_u64();
			mw_elab_atom_match_21__1();
			break;
		case 11LL: // PRIM_CORE_LAMBDA
			(void)pop_u64();
			mw_elab_atom_lambda_21__1();
			break;
		default:
			mw_elab_args_21__1();
			mw_ab_prim_21__1();
			break;
	}
}
static void mw_elab_atom_assert_21__1 (void) {
	mw_ab_token_40__1();
	mw_ab_ctx_40__1();
	mw_type_elab_stack_assertion_1();
	mw_ab_token_40__1();
	mw_args_1_1();
	mw_elab_type_stack_21__1();
	mp_prim_drop();
	mw_nip_1();
	mw_ab_type_40__1();
	mp_prim_swap();
	mw_unify_21__6();
	mw_drop2_1();
}
static void mw_elab_atom_match_21__1 (void) {
	mw_new_21__5();
	mtw_STMeta_1();
	LPUSH(lbl_cod);
	mw_ab_token_40__1();
	mw_args_2B__1();
	mw_first_2();
	LPUSH(lbl_body);
	mw_elab_match_at_21__1();
}
static void mw_elab_match_at_21__1 (void) {
	mw_ab_ctx_40__1();
	LPUSH(lbl_ctx);
	mw_ab_type_40__1();
	LPUSH(lbl_dom);
	mw_ab_token_40__1();
	LPUSH(lbl_token);
	mw_ab_home_40__1();
	LPUSH(lbl_home);
	push_u64(0LL); // L0
	LPUSH(lbl_cases);
	{
		VAL d2 = pop_resource();
		mtw__2B_MATCH_1();
		mw_elab_match_cases_21__1();
		mw_elab_match_exhaustive_21__1();
		mw_freeze_2();
		push_resource(d2);
	}
	mtw_OP_5F_MATCH_1();
	mw_ab_op_21__1();
}
static void mw_elab_match_cases_21__1 (void) {
	mw_body_3();
	while(1) {
		mp_prim_dup();
		mw_args_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_elab_match_case_21__1();
	}
	mp_prim_drop();
}
static void mw_elab_match_case_21__1 (void) {
	mp_prim_dup();
	mw_run_arrow_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected arrow end", 18);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_dup2_1();
	mw__3D__3D__25();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected pattern", 16);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_dup2_1();
	mw_prev_1();
	mw__3D__3D__25();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("multi-part pattern not supported", 32);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		VAL d2 = pop_value();
		mw_pat_tokens_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_prev_1();
		push_value(d2);
	}
	mw_succ_7();
	{
		VAL d2 = pop_value();
		mw_home_2();
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mw_ctx_5();
		mp_prim_dup();
		LPUSH(lbl_outer_ctx);
		LPUSH(lbl_inner_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_saved);
		mw_dom_4();
		mp_prim_dup();
		LPUSH(lbl_mid);
		LPUSH(lbl_cod);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_PATTERN_1();
		{
			VAL d3 = pop_resource();
			mw_thaw_3();
			mw_elab_pattern_21__1();
			mw_freeze_3();
			push_resource(d3);
		}
		push_value(d2);
	}
	mp_prim_swap();
	{
		VAL var_pat = pop_value();
		incref(var_pat);
		push_value(var_pat);
		mw_inner_ctx_3();
		incref(var_pat);
		push_value(var_pat);
		mw_dom_7();
		mw_cod_4();
		mw_T__3E__1();
		mw_rotl_1();
		mw_home_2();
		{
			VAL d3 = pop_resource();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_unpack_1();
					mw_rotr_1();
					push_value(d5);
				}
				push_value(d4);
			}
			LPUSH(lbl_home);
			mp_prim_dup();
			LPUSH(lbl_token_start);
			LPUSH(lbl_token_end);
			mp_prim_dup();
			LPUSH(lbl_dom);
			LPUSH(lbl_cod);
			LPUSH(lbl_ctx);
			push_u64(0LL); // L0
			LPUSH(lbl_atoms);
			mtw_ARROW_1();
			LPUSH(lbl_arrow);
			mtw_MKAB_1();
			{
				VAL d4 = pop_value();
				mw_elab_atoms_21__1();
				mw_ab_token_40__1();
				mp_prim_dup();
				mw_comma_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						mw_succ_7();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_value(d4);
			}
			mw_ab_unify_type_21__1();
			mw__2F_MKAB_1();
			LPOP(lbl_arrow);
			push_resource(d3);
		}
		LPUSH(lbl_body);
		incref(var_pat);
		push_value(var_pat);
		LPUSH(lbl_pattern);
		mtw_CASE_1();
		mw_add_case_1();
		decref(var_pat);
	}
}
static void mw_pat_tokens_1 (void) {
	mw_run_tokens_1();
	{
		VAL d2 = pop_value();
		push_u64(1LL); // T
		push_value(d2);
	}
	mw_filter_2_3195();
	mw_nip_1();
}
static void mw_elab_pattern_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_elab_pattern_atom_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_elab_pattern_atom_21__1();
				push_value(d4);
			}
			mw_elab_pattern_atom_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_rotr_1();
			mw_dip2_1_1710();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_elab_pattern_atom_21__1();
				push_value(d4);
			}
			mw_elab_pattern_atom_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_1710();
				push_value(d4);
			}
			mw_reverse_for_2_1710();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_pattern_atom_21__1 (void) {
	mp_prim_dup();
	mw_pat_underscore_3F__1();
	if (pop_u64()) {
		mp_prim_drop();
		mw_underscore_21__1();
	} else {
		mp_prim_dup();
		mw_name_3F__2();
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				mw_defs_1();
				mw__3E_List_2B__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						push_u64(0LL); // NONE
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mw_find_some_2_1718();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("Unknown constructor.", 20);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mw_nip_1();
						mw_tag_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				break;
			case 0LL: // NONE
				(void)pop_u64();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Expected constructor name.", 26);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
	}
}
static void mw_ab_match_21__1 (void) {
	{
		VAL var_f = pop_value();
		mw_ab_ctx_40__1();
		LPUSH(lbl_ctx);
		mw_ab_type_40__1();
		LPUSH(lbl_dom);
		mw_ab_token_40__1();
		LPUSH(lbl_token);
		mw_ab_home_40__1();
		LPUSH(lbl_home);
		push_u64(0LL); // L0
		LPUSH(lbl_cases);
		{
			VAL d3 = pop_resource();
			mtw__2B_MATCH_1();
			incref(var_f);
			run_value(var_f);
			mw_freeze_2();
			push_resource(d3);
		}
		mtw_OP_5F_MATCH_1();
		mw_ab_op_21__1();
		decref(var_f);
	}
}
static void mw_case_21__1 (void) {
	{
		VAL var_mkbod = pop_value();
		VAL var_mkpat = pop_value();
		{
			VAL d3 = pop_value();
			mw_home_2();
			LPUSH(lbl_home);
			mp_prim_dup();
			LPUSH(lbl_token_start);
			LPUSH(lbl_token_end);
			mw_ctx_5();
			mp_prim_dup();
			LPUSH(lbl_outer_ctx);
			LPUSH(lbl_inner_ctx);
			push_u64(0LL); // L0
			LPUSH(lbl_saved);
			mw_dom_4();
			mp_prim_dup();
			LPUSH(lbl_mid);
			LPUSH(lbl_cod);
			push_u64(0LL); // L0
			LPUSH(lbl_atoms);
			mtw_PATTERN_1();
			{
				VAL d4 = pop_resource();
				mw_thaw_3();
				incref(var_mkpat);
				run_value(var_mkpat);
				mw_freeze_3();
				push_resource(d4);
			}
			push_value(d3);
		}
		mp_prim_swap();
		{
			VAL var_pat = pop_value();
			incref(var_pat);
			push_value(var_pat);
			mw_inner_ctx_3();
			incref(var_pat);
			push_value(var_pat);
			mw_dom_7();
			mw_cod_4();
			mw_T__3E__1();
			mw_rotl_1();
			mw_home_2();
			{
				VAL d4 = pop_resource();
				push_fnptr(&mb_1708);
				incref(var_mkbod);
				push_value(var_mkbod);
				mp_prim_pack_cons();
				mw_ab_build_hom_21__1();
				push_resource(d4);
			}
			LPUSH(lbl_body);
			incref(var_pat);
			push_value(var_pat);
			LPUSH(lbl_pattern);
			mtw_CASE_1();
			mw_add_case_1();
			decref(var_pat);
		}
		decref(var_mkbod);
		decref(var_mkpat);
	}
}
static void mw_elab_expand_tensor_21__1 (void) {
	LPUSH(lbl_tok);
	mw_force_cons_3F__21__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_unpack2_1();
			LPOP(lbl_tok);
			break;
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // STACK_TYPE_ERROR
			push_u64(0LL); // TYPE_ERROR
			LPOP(lbl_tok);
			mp_prim_dup();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected tuple type", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_lambda_param_3F__1 (void) {
	mp_prim_dup();
	mw_pattern_var_3F__1();
	if (pop_u64()) {
		mp_prim_dup();
		mw_args_0_1();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_next_1();
			push_value(d3);
		}
		{
			VAL d3 = pop_value();
			mw_new_21__5();
			mtw_TMeta_1();
			push_value(d3);
		}
		mw_name_3F__2();
		mw_unwrap_1();
		mw_new_21__3();
		mw__3E_Param_1();
		mtw_SOME_1();
	} else {
		mp_prim_dup();
		mw_lsquare_3F__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // F
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_drop();
				mp_prim_dup();
				mw_succ_7();
				mw_pattern_var_3F__1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		if (pop_u64()) {
			mp_prim_dup();
			mw_succ_7();
			mw_succ_7();
			mw_rsquare_3F__1();
			mw__3E_Bool_1();
		} else {
			push_u64(0LL); // F
		}
		if (pop_u64()) {
			mp_prim_dup();
			mw_succ_7();
			mw_args_0_1();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_next_1();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_new_21__5();
				mtw_STMeta_1();
				mw_new_21__5();
				mtw_STMeta_1();
				mw_T__3E__1();
				mtw_TMorphism_1();
				push_value(d4);
			}
			mw_succ_7();
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw__3E_Param_1();
			mtw_SOME_1();
		} else {
			push_u64(0LL); // NONE
		}
	}
}
static void mw_elab_atom_lambda_21__1 (void) {
	mw_ab_token_40__1();
	mw_args_1_1();
	push_u64(0LL); // L0
	{
		VAL d2 = pop_value();
		mw_elab_lambda_param_3F__1();
		push_value(d2);
	}
	mp_prim_swap();
	while(1) {
		mp_prim_dup();
		mw_some_3F__1();
		if (! pop_u64()) break;
		mw_unwrap_1();
		mw_snoc_1();
		{
			VAL d3 = pop_value();
			mw_elab_lambda_param_3F__1();
			push_value(d3);
		}
		mp_prim_swap();
	}
	mp_prim_drop();
	{
		VAL d2 = pop_value();
		mw_expect_token_arrow_1();
		mw_succ_7();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_ab_ctx_40__1();
			mw_ab_type_40__1();
			push_value(d3);
		}
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				break;
			case 2LL: // L2
				mtp_L2_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw__3E_Var_1();
						mp_prim_dup();
						{
							VAL d7 = pop_value();
							mw_new_4();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_ab_token_40__1();
					mw_elab_expand_tensor_21__1();
					{
						VAL d6 = pop_value();
						mw_rotl_1();
						mw_type_4();
						push_value(d6);
					}
					mw_elab_type_unify_21__1();
					mw_drop2_1();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				break;
			case 3LL: // L3
				mtp_L3_1();
				mw_rotr_1();
				mw_dip2_1_3168();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw__3E_Var_1();
						mp_prim_dup();
						{
							VAL d7 = pop_value();
							mw_new_4();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_ab_token_40__1();
					mw_elab_expand_tensor_21__1();
					{
						VAL d6 = pop_value();
						mw_rotl_1();
						mw_type_4();
						push_value(d6);
					}
					mw_elab_type_unify_21__1();
					mw_drop2_1();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_reverse_for_2_3168();
					push_value(d5);
				}
				mw_reverse_for_2_3168();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_rotl_1();
		mw_ab_home_40__1();
		{
			VAL d3 = pop_resource();
			LPUSH(lbl_home);
			mp_prim_dup();
			LPUSH(lbl_token_start);
			LPUSH(lbl_token_end);
			mp_prim_dup();
			LPUSH(lbl_dom);
			LPUSH(lbl_cod);
			LPUSH(lbl_ctx);
			push_u64(0LL); // L0
			LPUSH(lbl_atoms);
			mtw_ARROW_1();
			LPUSH(lbl_arrow);
			mtw_MKAB_1();
			mw_elab_atoms_21__1();
			mw__2F_MKAB_1();
			LPOP(lbl_arrow);
			push_resource(d3);
		}
		push_value(d2);
	}
	LPUSH(lbl_params);
	LPUSH(lbl_body);
	mw_ab_ctx_40__1();
	LPUSH(lbl_outer_ctx);
	mw_ab_type_40__1();
	LPUSH(lbl_dom);
	mw_ab_token_40__1();
	LPUSH(lbl_token);
	mtw_LAMBDA_1();
	mtw_OP_5F_LAMBDA_1();
	mw_ab_op_21__1();
}
static void mw_elab_match_exhaustive_21__1 (void) {
	mw_freeze_2();
	mp_prim_dup();
	mw_is_exhaustive_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_dup();
			mw_token_6();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Pattern match not exhaustive.", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_thaw_2();
}
static void mw_elab_module_21__1 (void) {
	mp_prim_dup();
	mw_start_1();
	mw_elab_module_header_21__1();
	while(1) {
		mp_prim_dup();
		mw_module_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_elab_module_decl_21__1();
	}
	mp_prim_drop();
}
static void mw_elab_module_package_name_1 (void) {
	mp_prim_dup();
	mw_dname_3F__2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected module name. (1)", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_over_1();
	mw_args_0_1();
	mp_prim_dup();
	mw_root_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected module name. (2)", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_swap();
	mw_parts_1();
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			break;
		default:
			mw_drop2_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected module name. (3)", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
	}
	{
		VAL d2 = pop_value();
		mw_find_or_new_21__1();
		mw_nip_1();
		push_value(d2);
	}
}
static void mw_elab_module_qname_1 (void) {
	mw_elab_module_package_name_1();
	{
		VAL d2 = pop_value();
		mtw_NAMESPACE_5F_PACKAGE_1();
		push_value(d2);
	}
	mw_QNAME0_1();
}
static void mw_elab_module_header_21__1 (void) {
	mp_prim_dup();
	mw_module_header_3F__1();
	if (pop_u64()) {
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_next_1();
			push_value(d3);
		}
		mw_args_1_1();
		mp_prim_dup();
		mw_elab_module_package_name_1();
		mw_over2_1();
		mw_module_3();
		mw_tuck_1();
		mfld__7E_name_4();
		mp_prim_mut_set();
		mw_tuck_1();
		mfld__7E_package_1();
		mp_prim_mut_set();
		mp_prim_dup();
		mw_qname_10();
		mw_defined_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_drop();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Module name already taken.", 26);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			case 0LL: // F
				(void)pop_u64();
				mp_prim_id();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_dup();
		mtw_DEF_5F_MODULE_1();
		mw_register_1();
		mw_check_module_path_1();
	} else {
		mp_prim_dup();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("Expected module header.", 23);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_emit_fatal_error_21__1();
	}
}
static void mw_check_module_path_1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_path_3();
		push_value(d2);
	}
	mw_qname_10();
	mw_to_module_path_1();
	mw_dup2_1();
	mw__3D__3D__16();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected module name to match path\n", 35);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_swap();
			mw__3E_Str_1();
			mp_prim_str_cat();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\n", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_str_cat();
			mp_prim_swap();
			mw__3E_Str_1();
			mp_prim_str_cat();
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_drop3_1();
}
static void mw_elab_module_decl_21__1 (void) {
	mp_prim_dup();
	mw_name_3F__2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("unknown declaration", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_defs_1();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_1735();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("unknown declaration", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 76LL: // PRIM_SYNTAX_IMPORT
			(void)pop_u64();
			mw_elab_module_import_21__1();
			break;
		case 77LL: // PRIM_SYNTAX_ALIAS
			(void)pop_u64();
			mw_elab_alias_21__1();
			break;
		case 78LL: // PRIM_SYNTAX_INLINE
			(void)pop_u64();
			mw_elab_inline_21__1();
			break;
		case 79LL: // PRIM_SYNTAX_DEF
			(void)pop_u64();
			mw_elab_def_21__1();
			break;
		case 80LL: // PRIM_SYNTAX_DEF_MISSING
			(void)pop_u64();
			mw_elab_def_missing_21__1();
			break;
		case 81LL: // PRIM_SYNTAX_DEF_TYPE
			(void)pop_u64();
			mw_elab_def_type_21__1();
			break;
		case 84LL: // PRIM_SYNTAX_DEF_EXTERNAL
			(void)pop_u64();
			mw_elab_def_external_21__1();
			break;
		case 82LL: // PRIM_SYNTAX_BUFFER
			(void)pop_u64();
			mw_elab_buffer_21__1();
			break;
		case 83LL: // PRIM_SYNTAX_VARIABLE
			(void)pop_u64();
			mw_elab_variable_21__1();
			break;
		case 86LL: // PRIM_SYNTAX_TABLE
			(void)pop_u64();
			mw_elab_table_21__1();
			break;
		case 87LL: // PRIM_SYNTAX_FIELD
			(void)pop_u64();
			mw_elab_field_21__1();
			break;
		case 88LL: // PRIM_SYNTAX_DATA
			(void)pop_u64();
			mw_elab_data_21__1();
			break;
		case 85LL: // PRIM_SYNTAX_EMBED_STR
			(void)pop_u64();
			mw_elab_embed_str_21__1();
			break;
		default:
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("unknown declaration", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
	}
}
static void mw_load_module_1 (void) {
	mp_prim_dup();
	mw_def_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_module_3F__2();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_drop();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("module name already taken", 25);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_to_module_path_1();
			mw_run_lexer_21__1();
			mw_elab_module_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_module_import_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_1_1();
	mp_prim_dup();
	mw_elab_module_qname_1();
	mw_load_module_1();
	{
		VAL d2 = pop_value();
		mw_module_3();
		push_value(d2);
	}
	mw_add_import_21__1();
}
static void mw_elab_data_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_alloc_21__14();
		push_u64(0LL); // L0
		mw_over_1();
		mfld__7E_tags_1();
		mp_prim_mut_set();
		mp_prim_swap();
		mw_args_2B__1();
		mw_uncons_2();
		{
			VAL d3 = pop_value();
			mw_elab_data_header_21__1();
			push_value(d3);
		}
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				mw_elab_data_tag_21__1();
				break;
			case 2LL: // L2
				mtp_L2_1();
				{
					VAL d5 = pop_value();
					mw_elab_data_tag_21__1();
					push_value(d5);
				}
				mw_elab_data_tag_21__1();
				break;
			case 3LL: // L3
				mtp_L3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_elab_data_tag_21__1();
						push_value(d6);
					}
					mw_elab_data_tag_21__1();
					push_value(d5);
				}
				mw_elab_data_tag_21__1();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				{
					VAL d5 = pop_value();
					mw_for_3_1798();
					push_value(d5);
				}
				mw_for_3_1798();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_elab_data_done_21__1();
		push_value(d2);
	}
	mw_next_1();
}
static void mw_elab_data_header_21__1 (void) {
	mw_dup2_1();
	mtw_SOME_1();
	mp_prim_swap();
	mfld__7E_head_3F__2();
	mp_prim_mut_set();
	mp_prim_dup();
	mw_sig_type_con_3F__1();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mp_prim_dup();
		mw_sig_resource_con_3F__1();
	}
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected type name.", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_dup2_1();
	mw_elab_def_qname_undefined_1();
	mw_over_1();
	mfld__7E_qname_7();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_DATA_1();
	mw_register_1();
	{
		VAL d2 = pop_value();
		mw_num_args_1();
		push_value(d2);
	}
	mfld__7E_arity_3();
	mp_prim_mut_set();
}
static void mw_elab_data_tag_21__1 (void) {
	mw_dup2_1();
	mw_name_3F__2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected constructor name.", 26);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	push_i64(0LL);
	mw_data_qname_1();
	mw_alloc_21__15();
	push_u64(0LL); // NONE
	mw_over_1();
	mfld__7E_untag_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_qname_8();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_TAG_1();
	mw_register_1();
	{
		VAL d2 = pop_value();
		mw_over_1();
		push_value(d2);
	}
	mw_dup2_1();
	mfld__7E_data_1();
	mp_prim_mut_set();
	mw_tuck_1();
	{
		VAL d2 = pop_value();
		mw_add_tag_21__1();
		push_value(d2);
	}
	mp_prim_swap();
	mw_succ_7();
	mp_prim_dup();
	mw_pat_arrow_3F__1();
	if (pop_u64()) {
		mw_succ_7();
		mtw_SOME_1();
		mw_over_1();
		mfld__7E_sig_3F__1();
		mp_prim_mut_set();
	} else {
		mp_prim_dup();
		mw_run_end_3F__1();
		if (pop_u64()) {
			mp_prim_drop();
			push_u64(0LL); // NONE
			mw_over_1();
			mfld__7E_sig_3F__1();
			mp_prim_mut_set();
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected arrow, comma, or right paren.", 38);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
		}
	}
	mp_prim_dup();
	push_fnptr(&mb_1813);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_ctx_type_3();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_num_type_inputs_from_sig_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mfld__7E_num_type_inputs_1();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_num_resource_inputs_from_sig_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mfld__7E_num_resource_inputs_1();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_label_inputs_from_sig_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mfld__7E_label_inputs_1();
		mp_prim_mut_set();
		push_value(d2);
	}
	mp_prim_dup();
	mw_outputs_resource_3F__1();
	mw_not_1();
	mw_over_1();
	mw_num_resource_inputs_1();
	mw_0_3E__2();
	mw__26__26__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_sig_3F__1();
			mw_unwrap_1();
			mw_run_tokens_1();
			mw__3E_List_2B__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_find_some_2_3029();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_unwrap_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Value type cannot contain resource.", 35);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_drop();
}
static void mw_data_word_new_21__1 (void) {
	mp_prim_dup();
	LPUSH(lbl_arity);
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_3F__3();
			mw_unwrap_1();
			mp_prim_dup();
			LPUSH(lbl_body);
			LPUSH(lbl_head);
			push_value(d3);
		}
		push_value(d2);
	}
	mw_data_word_qname_1();
	LPUSH(lbl_qname);
	push_u64(0LL); // NONE
	LPUSH(lbl_sig);
	mw_new_21__1();
}
static void mw_elab_data_done_21__1 (void) {
	{
		VAL var_dat = pop_value();
		incref(var_dat);
		push_value(var_dat);
		mw_is_enum_3F__1();
		push_fnptr(&mb_1828);
		incref(var_dat);
		push_value(var_dat);
		mp_prim_pack_cons();
		mw_then_1();
		incref(var_dat);
		push_value(var_dat);
		mw_tags_1();
		switch (get_top_data_tag()) {
			case 1LL: // L1
				mtp_L1_1();
				{
					VAL var_tag = pop_value();
					incref(var_dat);
					push_value(var_dat);
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("/", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					incref(var_tag);
					push_value(var_tag);
					mw_name_17();
					mw__3E_Str_3();
					mp_prim_str_cat();
					push_i64(0LL);
					mw_data_word_new_21__1();
					{
						VAL var_untag = pop_value();
						incref(var_tag);
						push_value(var_tag);
						push_fnptr(&mb_1831);
						mtw_LAZY_5F_DELAY_1();
						incref(var_untag);
						push_value(var_untag);
						mfld__7E_ctx_type_1();
						mp_prim_mut_set();
						incref(var_untag);
						push_value(var_untag);
						push_fnptr(&mb_1832);
						incref(var_tag);
						push_value(var_tag);
						mp_prim_pack_cons();
						incref(var_dat);
						push_value(var_dat);
						mp_prim_pack_cons();
						incref(var_untag);
						push_value(var_untag);
						mp_prim_pack_cons();
						mw_delay_1();
						incref(var_untag);
						push_value(var_untag);
						mfld__7E_arrow_1();
						mp_prim_mut_set();
						incref(var_untag);
						push_value(var_untag);
						mtw_SOME_1();
						incref(var_tag);
						push_value(var_tag);
						mfld__7E_untag_1();
						mp_prim_mut_set();
						incref(var_tag);
						push_value(var_tag);
						mw_create_projectors_21__1();
						decref(var_untag);
					}
					decref(var_tag);
				}
				break;
			default:
				mp_prim_drop();
				break;
		}
		decref(var_dat);
	}
}
static void mw_output_type_1 (void) {
	mp_prim_dup();
	mw_type_9();
	mw_cod_1();
	mw_expand_2();
	switch (get_top_data_tag()) {
		case 5LL: // STCons
			mtp_STCons_1();
			mtw_LEFT_1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			break;
		case 7LL: // STWith
			mtp_STWith_1();
			mtw_RIGHT_1();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			break;
		default:
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("Unexpected output type for constructor ", 39);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			mw_qname_14();
			mw__3E_Str_5();
			mp_prim_str_cat();
			mp_prim_panic();
			break;
	}
}
static void mw_project_input_label_1 (void) {
	mw_type_9();
	mw_dom_1();
	mw_force_cons_label_3F__21__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_unpack2_1();
			mw_nip_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_data_get_label_type_1 (void) {
	{
		VAL var_lbl = pop_value();
		VAL var_tag = pop_value();
		mw_T0_1();
		incref(var_tag);
		push_value(var_tag);
		mw_output_type_1();
		mw_T_2A__2B__1();
		incref(var_lbl);
		push_value(var_lbl);
		incref(var_tag);
		push_value(var_tag);
		mw_project_input_label_1();
		mw_unwrap_1();
		mw_T1_1();
		incref(var_tag);
		push_value(var_tag);
		mw_data_3();
		mw_is_resource_3F__2();
		push_fnptr(&mb_1638);
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_then_1();
		mw_T__3E__1();
		decref(var_lbl);
		decref(var_tag);
	}
}
static void mw_data_set_label_type_1 (void) {
	{
		VAL var_lbl = pop_value();
		VAL var_tag = pop_value();
		incref(var_lbl);
		push_value(var_lbl);
		incref(var_tag);
		push_value(var_tag);
		mw_project_input_label_1();
		mw_unwrap_1();
		mw_T1_1();
		incref(var_tag);
		push_value(var_tag);
		mw_output_type_1();
		mw_T_2A__2B__1();
		mw_T0_1();
		incref(var_tag);
		push_value(var_tag);
		mw_output_type_1();
		mw_T_2A__2B__1();
		mw_T__3E__1();
		decref(var_lbl);
		decref(var_tag);
	}
}
static void mw_create_projectors_21__1 (void) {
	mp_prim_dup();
	mw_data_3();
	mw_over_1();
	mw_untag_1();
	mw_unwrap_1();
	{
		VAL var_untag = pop_value();
		VAL var_dat = pop_value();
		VAL var_tag = pop_value();
		incref(var_tag);
		push_value(var_tag);
		mw_label_inputs_1();
		push_fnptr(&mb_1839);
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		incref(var_dat);
		push_value(var_dat);
		mp_prim_pack_cons();
		mw_reverse_for_1();
		decref(var_untag);
		decref(var_dat);
		decref(var_tag);
	}
}
static void mw_expect_token_arrow_1 (void) {
	mp_prim_dup();
	mw_pat_arrow_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Expected arrow.", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_token_def_args_1 (void) {
	mp_prim_dup();
	mw_args_2();
	mp_prim_dup();
	mw_len_1();
	push_i64(3LL);
	mw__3E_Nat_1();
	mw__3C__3();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("def expects at least three arguments", 36);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
	mw__3E_List_2B__1();
	mw_unwrap_1();
	mw_uncons_2();
	mw__3E_List_2B__1();
	mw_unwrap_1();
	mw_uncons_2();
	mw__3E_List_2B__1();
	mw_unwrap_1();
}
static void mw_elab_alias_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_2_1();
	mp_prim_swap();
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	mp_prim_dup();
	{
		VAL var_aliasqname = pop_value();
		mw_over_1();
		mw_next_1();
		mw_arg_end_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				mw_over_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected comma after alias name", 31);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_rotl_1();
		mp_prim_dup();
		mw_name_or_dname_3F__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected alias target, which must be a name", 43);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_id();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_over_1();
		mw_args_0_1();
		mw_over_1();
		mw_succ_7();
		mw_arg_end_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				mw_over_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected end of argument after alias target", 43);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_pack2_1();
		push_fnptr(&mb_1749);
		incref(var_aliasqname);
		push_value(var_aliasqname);
		mp_prim_pack_cons();
		mw_delay_1();
		mw_new_21__11();
		mp_prim_drop();
		decref(var_aliasqname);
	}
}
static void mw_elab_def_missing_21__1 (void) {
	mp_prim_dup();
	mw_args_2();
	mw_len_1();
	push_i64(3LL);
	mw__3E_Nat_1();
	mw__3C__3();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("def-missing expects at least three arguments", 44);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_succ_7();
	mw_succ_7();
	mw_elab_def_qname_1();
	mw_defined_3F__1();
	if (pop_u64()) {
		mw_next_1();
	} else {
		mw_elab_def_21__1();
	}
}
static void mw_prefer_inline_defs_3F__1 (void) {
	mvar__7E_prefer_inline_defs_3F__1();
	mw__40__3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_inline_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_1_1();
	{
		VAL d2 = pop_value();
		mw_prefer_inline_defs_3F__1();
		push_value(d2);
	}
	push_u64(1LL); // T
	mvar__7E_prefer_inline_defs_3F__1();
	mp_prim_mut_set();
	while(1) {
		mp_prim_dup();
		mw_arg_end_3F__1();
		mw_not_1();
		if (! pop_u64()) break;
		mw_elab_module_decl_21__1();
	}
	mp_prim_drop();
	mvar__7E_prefer_inline_defs_3F__1();
	mp_prim_mut_set();
}
static void mw_elab_def_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_token_def_args_1();
	mw_uncons_2();
	mw_is_empty_2();
	if (pop_u64()) {
		push_u64(1LL); // T
	} else {
		mp_prim_dup();
		mw_run_arrow_3F__1();
		mw__3E_Bool_1();
	}
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected match case", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	LPUSH(lbl_body);
	mtw_SOME_1();
	LPUSH(lbl_sig);
	mp_prim_dup();
	LPUSH(lbl_head);
	mp_prim_dup();
	mw_num_args_1();
	LPUSH(lbl_arity);
	mw_elab_def_qname_undefined_1();
	LPUSH(lbl_qname);
	mw_new_21__1();
	mw_prefer_inline_defs_3F__1();
	mw_over_1();
	mfld__7E_prefer_inline_3F__1();
	mp_prim_mut_set();
	mp_prim_dup();
	push_fnptr(&mb_1767);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	push_fnptr(&mb_1770);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_params_1();
	mp_prim_mut_set();
	mp_prim_dup();
	push_fnptr(&mb_1771);
	mtw_LAZY_5F_DELAY_1();
	mp_prim_swap();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
}
static void mw_elab_def_params_21__1 (void) {
	push_u64(0LL); // L0
	mw_over_1();
	mw_type_2();
	mw_rotl_1();
	mw_head_2();
	{
		VAL d2 = pop_value();
		mw_unpack_1();
		push_value(d2);
	}
	mw_nip_1();
	mw_args_2();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			break;
		case 2LL: // L2
			mtp_L2_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_sig_param_name_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						mp_prim_id();
						break;
					case 0LL: // F
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("expected parameter name", 23);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mp_prim_dup();
				mw_succ_7();
				mp_prim_dup();
				mw_run_end_3F__1();
				if (pop_u64()) {
					mp_prim_drop();
				} else {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected right paren or comma", 29);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
				}
				mw_elab_expand_tensor_21__1();
				mw_over_1();
				mw_morphism_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_drop();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("need function type for param", 28);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_name_3F__2();
				mw_unwrap_1();
				mw_new_auto_run_21__1();
				mw_rotr_1();
				{
					VAL d5 = pop_value();
					mw_cons_2();
					push_value(d5);
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_rotr_1();
			mw_dip2_1_1864();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_sig_param_name_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						mp_prim_id();
						break;
					case 0LL: // F
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("expected parameter name", 23);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mp_prim_dup();
				mw_succ_7();
				mp_prim_dup();
				mw_run_end_3F__1();
				if (pop_u64()) {
					mp_prim_drop();
				} else {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected right paren or comma", 29);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
				}
				mw_elab_expand_tensor_21__1();
				mw_over_1();
				mw_morphism_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_drop();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("need function type for param", 28);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_name_3F__2();
				mw_unwrap_1();
				mw_new_auto_run_21__1();
				mw_rotr_1();
				{
					VAL d5 = pop_value();
					mw_cons_2();
					push_value(d5);
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_1864();
				push_value(d4);
			}
			mw_reverse_for_2_1864();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_drop();
}
static void mw_elab_def_body_21__1 (void) {
	mw_ab_token_40__1();
	mw_run_arrow_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_drop();
			mp_prim_dup();
			LPUSH(lbl_cod);
			mw_ab_token_40__1();
			LPUSH(lbl_body);
			mw_elab_match_at_21__1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_elab_atoms_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_def_external_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_2_1();
	mw_over_1();
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	mp_prim_swap();
	mw_succ_7();
	mp_prim_dup();
	mw_comma_3F__1();
	if (pop_u64()) {
		mp_prim_drop();
		mp_prim_dup();
		mw_name_12();
	} else {
		mw_expect_token_arrow_1();
		mw_succ_7();
		mp_prim_dup();
		mw_name_3F__2();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected external symbol name", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_id();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_nip_1();
	}
	mw__3E_Str_3();
	mp_prim_swap();
	mw_alloc_21__13();
	mw_tuck_1();
	mfld__7E_qname_6();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_symbol_1();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_sig_2();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_5();
	mp_prim_mut_set();
	mp_prim_dup();
	push_fnptr(&mb_1786);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_ctx_type_2();
	mp_prim_mut_set();
	mtw_DEF_5F_EXTERNAL_1();
	mw_register_1();
}
static void mw_elab_def_type_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_2_1();
	mp_prim_swap();
	mp_prim_dup();
	mw_sig_type_con_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected type constructor", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	{
		VAL d2 = pop_value();
		mtw_SOME_1();
		push_value(d2);
	}
	mw_rotl_1();
	mw_elab_simple_type_arg_21__1();
	mw_new_21__4();
	mp_prim_drop();
}
static void mw_elab_buffer_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_2_1();
	mp_prim_swap();
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	mw_rotl_1();
	mp_prim_dup();
	mw_int_3F__2();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected buffer size", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
	mw__3E_Size_1();
	mw_new_21__9();
	mp_prim_drop();
}
static void mw_elab_variable_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_2_1();
	mp_prim_swap();
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	mw_rotl_1();
	push_fnptr(&mb_1791);
	mtw_LAZY_5F_DELAY_1();
	mw_new_21__2();
	mp_prim_drop();
}
static void mw_elab_table_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_1_1();
	mp_prim_dup();
	mw_sig_type_con_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected type name", 18);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_args_0_1();
	mp_prim_dup();
	mw_succ_7();
	mw_arg_end_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mw_succ_7();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected end of argument after table name", 41);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	mw_table_new_21__1();
	mp_prim_drop();
}
static void mw_elab_entry_point_1 (void) {
	mp_prim_dup();
	mw_def_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_word_3F__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_namespace_5();
				mw_module_3F__1();
				mw_unwrap_1();
				mw_start_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("can't find entry point ", 23);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_CTX0_1();
		mw_T0_1();
		mw_RESOURCE_5F_WORLD_1();
		mw_T_2B__1();
		mw_T0_1();
		mw_RESOURCE_5F_WORLD_1();
		mw_T_2B__1();
		mw_T__3E__1();
		push_value(d2);
	}
	mw_head_2();
	mp_prim_dup();
	mtw_HOME_5F_MAIN_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_unpack_1();
			mw_rotr_1();
			push_value(d3);
		}
		push_value(d2);
	}
	LPUSH(lbl_home);
	mp_prim_dup();
	LPUSH(lbl_token_start);
	LPUSH(lbl_token_end);
	mp_prim_dup();
	LPUSH(lbl_dom);
	LPUSH(lbl_cod);
	LPUSH(lbl_ctx);
	push_u64(0LL); // L0
	LPUSH(lbl_atoms);
	mtw_ARROW_1();
	LPUSH(lbl_arrow);
	mtw_MKAB_1();
	{
		VAL d2 = pop_value();
		mw_ab_word_21__1();
		push_value(d2);
	}
	mw_ab_unify_type_21__1();
	mw__2F_MKAB_1();
	LPOP(lbl_arrow);
}
static void mw_elab_embed_str_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_2_1();
	mp_prim_swap();
	mp_prim_dup();
	LPUSH(lbl_head);
	mw_elab_def_qname_undefined_1();
	LPUSH(lbl_qname);
	mp_prim_dup();
	LPUSH(lbl_body);
	push_u64(0LL); // NONE
	LPUSH(lbl_sig);
	push_i64(0LL);
	LPUSH(lbl_arity);
	mp_prim_dup();
	mw_str_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected source path", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw__3E_Path_1();
	mw_open_file_21__1();
	mw_read_file_21__2();
	mw_close_file_21__1();
	mw_nip_1();
	LPUSH(lbl_contents);
	mw_new_21__1();
	mw_CTX0_1();
	mw_T0_1();
	mw_TYPE_5F_STR_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			LPOP(lbl_contents);
			mw_ab_str_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
}
static void mw_typecheck_everything_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_10();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_defs_1();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // L1
					mtp_L1_1();
					mw_typecheck_21__1();
					break;
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw_typecheck_21__1();
						push_value(d6);
					}
					mw_typecheck_21__1();
					break;
				case 3LL: // L3
					mtp_L3_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_typecheck_21__1();
							push_value(d7);
						}
						mw_typecheck_21__1();
						push_value(d6);
					}
					mw_typecheck_21__1();
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					mp_prim_drop();
					{
						VAL d6 = pop_value();
						mw_for_3_181();
						push_value(d6);
					}
					mw_for_3_181();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_17();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_typecheck_21__2();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_TABLE_5F_MAX_5F_COUNT_1 (void) {
	push_i64(131072LL);
	mw__3E_Nat_1();
}
static void mw_table_qname_1 (void) {
	LPUSH(lbl_arity);
	mw__3E_Name_1();
	LPUSH(lbl_name);
	mtw_TYCON_5F_TABLE_1();
	mtw_NAMESPACE_5F_TYCON_1();
	LPUSH(lbl_namespace);
	mtw_MKQNAME_1();
}
static void mw_table_word_new_21__1 (void) {
	mw_over2_1();
	mw_head_5();
	mp_prim_dup();
	LPUSH(lbl_head);
	LPUSH(lbl_body);
	push_u64(0LL); // NONE
	LPUSH(lbl_sig);
	mp_prim_dup();
	LPUSH(lbl_arity);
	mw_table_qname_1();
	LPUSH(lbl_qname);
	mw_new_21__1();
}
static void mw_table_new_21__1 (void) {
	mw_alloc_21__8();
	mw_tuck_1();
	mfld__7E_qname_5();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_4();
	mp_prim_mut_set();
	mw_TABLE_5F_MAX_5F_COUNT_1();
	mw_over_1();
	mfld__7E_max_count_1();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_TABLE_1();
	mw_register_1();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("MAX", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_T0_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			mw_TABLE_5F_MAX_5F_COUNT_1();
			mw__3E_Int_8();
			mw_ab_int_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("nil", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_T0_1();
	mw_over3_1();
	mtw_TTable_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			push_i64(0LL);
			mw_ab_int_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
	mp_prim_dup();
	mw_head_5();
	mw_over_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("NUM", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_qname_1();
	push_i64(8LL);
	mw__3E_Size_1();
	mw_new_21__9();
	mw_over_1();
	mfld__7E_num_buffer_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("index", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_over2_1();
	mtw_TTable_1();
	mw_T1_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("from-index", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_over2_1();
	mtw_TTable_1();
	mw_T1_1();
	mw_TYPE_5F_INT_1();
	mw_T1_1();
	mp_prim_swap();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("succ", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_over2_1();
	mtw_TTable_1();
	mw_T1_1();
	mp_prim_dup();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_i64(1LL);
			mw_ab_int_21__1();
			push_u64(16LL); // PRIM_INT_ADD
			mw_ab_prim_21__1();
			mp_prim_dup();
			mw_num_buffer_1();
			mw_ab_buffer_21__1();
			push_u64(56LL); // PRIM_U64_GET
			mw_ab_prim_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_i64(1LL);
			mw_ab_int_21__1();
			push_u64(16LL); // PRIM_INT_ADD
			mw_ab_prim_21__1();
			push_u64(20LL); // PRIM_INT_MOD
			mw_ab_prim_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("pred", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_over2_1();
	mtw_TTable_1();
	mw_T1_1();
	mp_prim_dup();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_u64(1LL); // PRIM_CORE_DUP
			mw_ab_prim_21__1();
			push_i64(0LL);
			mw_ab_int_21__1();
			push_u64(14LL); // PRIM_INT_EQ
			mw_ab_prim_21__1();
			mw_ab_token_40__1();
			mw_ab_ctx_40__1();
			mw_new_21__5();
			mtw_STMeta_1();
			mw_rotl_1();
			mw_ab_home_40__1();
			{
				VAL d4 = pop_resource();
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mp_prim_dup();
				LPUSH(lbl_dom);
				LPUSH(lbl_cod);
				LPUSH(lbl_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_ARROW_1();
				LPUSH(lbl_arrow);
				mtw_MKAB_1();
				mw__2F_MKAB_1();
				LPOP(lbl_arrow);
				push_resource(d4);
			}
			mw_new_21__10();
			mtw_OP_5F_BLOCK_1();
			mw_ab_op_21__1();
			mw_ab_token_40__1();
			mw_ab_ctx_40__1();
			mw_new_21__5();
			mtw_STMeta_1();
			mw_rotl_1();
			mw_ab_home_40__1();
			{
				VAL d4 = pop_resource();
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mp_prim_dup();
				LPUSH(lbl_dom);
				LPUSH(lbl_cod);
				LPUSH(lbl_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_ARROW_1();
				LPUSH(lbl_arrow);
				mtw_MKAB_1();
				push_i64(1LL);
				mw_ab_int_21__1();
				push_u64(17LL); // PRIM_INT_SUB
				mw_ab_prim_21__1();
				mw__2F_MKAB_1();
				LPOP(lbl_arrow);
				push_resource(d4);
			}
			mw_new_21__10();
			mtw_OP_5F_BLOCK_1();
			mw_ab_op_21__1();
			push_u64(5LL); // PRIM_CORE_IF
			mw_ab_prim_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("for", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(1LL);
	mw_table_word_new_21__1();
	mw_TYPE_5F_STACK_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("*a", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mp_prim_dup();
	mtw_STVar_1();
	{
		VAL var_a = pop_value();
		VAL var_va = pop_value();
		VAL var_w = pop_value();
		VAL var_t = pop_value();
		incref(var_a);
		push_value(var_a);
		incref(var_t);
		push_value(var_t);
		mtw_TTable_1();
		mw_T_2A__1();
		incref(var_a);
		push_value(var_a);
		mw_T__3E__1();
		mw__3E_Type_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("x", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw__3E_Name_1();
		mw_new_auto_run_21__1();
		{
			VAL var_x = pop_value();
			incref(var_va);
			push_value(var_va);
			mw_CTX1_1();
			incref(var_a);
			push_value(var_a);
			incref(var_a);
			push_value(var_a);
			incref(var_t);
			push_value(var_t);
			mtw_TTable_1();
			mw_T_2A__1();
			incref(var_a);
			push_value(var_a);
			mw_T__3E__1();
			mw__3E_Type_1();
			mw_T_2A__1();
			incref(var_a);
			push_value(var_a);
			mw_T__3E__1();
			mw_ready2_1();
			incref(var_w);
			push_value(var_w);
			mfld__7E_ctx_type_1();
			mp_prim_mut_set();
			incref(var_w);
			push_value(var_w);
			push_fnptr(&mb_1880);
			incref(var_x);
			push_value(var_x);
			mp_prim_pack_cons();
			incref(var_t);
			push_value(var_t);
			mp_prim_pack_cons();
			mw_ab_build_word_21__1();
			mp_prim_drop();
			incref(var_t);
			push_value(var_t);
			decref(var_x);
		}
		decref(var_a);
		decref(var_va);
		decref(var_w);
		decref(var_t);
	}
	mp_prim_dup();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("alloc!", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_table_word_new_21__1();
	push_u64(0LL); // L0
	mw_T0_1();
	mw_over3_1();
	mtw_TTable_1();
	mw_T1_1();
	mw_T__3E__1();
	mw_ready2_1();
	mw_over_1();
	mfld__7E_ctx_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_ctx_type_1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_body_1();
			push_value(d3);
		}
		mtw_HOME_5F_WORD_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_unpack_1();
				mw_rotr_1();
				push_value(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_home);
		mp_prim_dup();
		LPUSH(lbl_token_start);
		LPUSH(lbl_token_end);
		mp_prim_dup();
		LPUSH(lbl_dom);
		LPUSH(lbl_cod);
		LPUSH(lbl_ctx);
		push_u64(0LL); // L0
		LPUSH(lbl_atoms);
		mtw_ARROW_1();
		LPUSH(lbl_arrow);
		mtw_MKAB_1();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_head_5();
			mw_ab_token_21__1();
			mp_prim_dup();
			mw_num_buffer_1();
			mw_ab_buffer_21__1();
			push_u64(56LL); // PRIM_U64_GET
			mw_ab_prim_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_i64(1LL);
			mw_ab_int_21__1();
			push_u64(16LL); // PRIM_INT_ADD
			mw_ab_prim_21__1();
			push_u64(1LL); // PRIM_CORE_DUP
			mw_ab_prim_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			mp_prim_dup();
			mw_num_buffer_1();
			mw_ab_buffer_21__1();
			push_u64(57LL); // PRIM_U64_SET
			mw_ab_prim_21__1();
			push_u64(0LL); // COERCE_UNSAFE
			mw_ab_coerce_21__1();
			push_value(d3);
		}
		mw_ab_unify_type_21__1();
		mw__2F_MKAB_1();
		LPOP(lbl_arrow);
		mw_ready_1();
		push_value(d2);
	}
	mw_tuck_1();
	mfld__7E_arrow_1();
	mp_prim_mut_set();
	mp_prim_drop();
}
static void mw_elab_qname_from_nonrelative_dname_1 (void) {
	mw_over_1();
	mw_root_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_drop2_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("relative name not allowed", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_could_be_type_or_resource_con_1();
	if (pop_u64()) {
		mw_rotl_1();
		mw_parts_1();
		switch (get_top_data_tag()) {
			case 0LL: // L1+
				mtp_L1_2B__1();
				mw_rotl_1();
				mw_elab_tycon_qname_1();
				break;
			default:
				mw_drop3_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("type-qualified name has too many parts", 38);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
		}
	} else {
		mw_rotr_1();
		{
			VAL d3 = pop_value();
			mw_parts_1();
			mw_cons_2B__2();
			push_value(d3);
		}
		mw_elab_absolute_qname_1();
	}
}
static void mw_module_visible_from_token_3F__1 (void) {
	mp_prim_swap();
	mw_module_3();
	mw_visible_1();
}
static void mw_def_visible_from_token_3F__1 (void) {
	mw_defining_module_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_drop();
			push_u64(1LL); // T
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_module_visible_from_token_3F__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_tycon_1 (void) {
	mp_prim_dup();
	mw_defs_1();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_1886();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("unknown type constructor: ", 26);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_swap();
			mw__3E_Str_3();
			mp_prim_str_cat();
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	{
		VAL d2 = pop_value();
		mw_drop2_1();
		push_value(d2);
	}
}
static void mw_elab_tycon_qname_1 (void) {
	LPUSH(lbl_arity);
	LPUSH(lbl_name);
	mw_elab_tycon_1();
	mtw_NAMESPACE_5F_TYCON_1();
	LPUSH(lbl_namespace);
	mtw_MKQNAME_1();
}
static void mw_elab_absolute_namespace_1 (void) {
	push_u64(0LL); // NAMESPACE_ROOT
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_QNAME0_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown namespace: ", 19);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_swap();
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			switch (get_top_data_tag()) {
				case 2LL: // DEF_PACKAGE
					mtp_DEF_5F_PACKAGE_1();
					mtw_NAMESPACE_5F_PACKAGE_1();
					break;
				case 1LL: // DEF_MODULE
					mtp_DEF_5F_MODULE_1();
					mtw_NAMESPACE_5F_MODULE_1();
					break;
				default:
					mw_exposed_tycon_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("invalid namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mtw_NAMESPACE_5F_TYCON_1();
					break;
			}
			mw_nip_1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_QNAME0_1();
				mp_prim_dup();
				mw_def_3F__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unknown namespace: ", 19);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_swap();
						mw__3E_Str_5();
						mp_prim_str_cat();
						mw_emit_fatal_error_21__1();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				switch (get_top_data_tag()) {
					case 2LL: // DEF_PACKAGE
						mtp_DEF_5F_PACKAGE_1();
						mtw_NAMESPACE_5F_PACKAGE_1();
						break;
					case 1LL: // DEF_MODULE
						mtp_DEF_5F_MODULE_1();
						mtw_NAMESPACE_5F_MODULE_1();
						break;
					default:
						mw_exposed_tycon_3F__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr("invalid namespace: ", 19);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mp_prim_swap();
								mw__3E_Str_5();
								mp_prim_str_cat();
								mw_emit_fatal_error_21__1();
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mtw_NAMESPACE_5F_TYCON_1();
						break;
				}
				mw_nip_1();
				push_value(d4);
			}
			mw_QNAME0_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown namespace: ", 19);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_swap();
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			switch (get_top_data_tag()) {
				case 2LL: // DEF_PACKAGE
					mtp_DEF_5F_PACKAGE_1();
					mtw_NAMESPACE_5F_PACKAGE_1();
					break;
				case 1LL: // DEF_MODULE
					mtp_DEF_5F_MODULE_1();
					mtw_NAMESPACE_5F_MODULE_1();
					break;
				default:
					mw_exposed_tycon_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("invalid namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mtw_NAMESPACE_5F_TYCON_1();
					break;
			}
			mw_nip_1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_QNAME0_1();
					mp_prim_dup();
					mw_def_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("unknown namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					switch (get_top_data_tag()) {
						case 2LL: // DEF_PACKAGE
							mtp_DEF_5F_PACKAGE_1();
							mtw_NAMESPACE_5F_PACKAGE_1();
							break;
						case 1LL: // DEF_MODULE
							mtp_DEF_5F_MODULE_1();
							mtw_NAMESPACE_5F_MODULE_1();
							break;
						default:
							mw_exposed_tycon_3F__1();
							switch (get_top_data_tag()) {
								case 0LL: // NONE
									(void)pop_u64();
									{
										static bool vready = false;
										static VAL v;
										if (! vready) {
											v = mkstr("invalid namespace: ", 19);
											vready = true;
										}
										push_value(v);
										incref(v);
									}
									mp_prim_swap();
									mw__3E_Str_5();
									mp_prim_str_cat();
									mw_emit_fatal_error_21__1();
									break;
								case 1LL: // SOME
									mtp_SOME_1();
									mp_prim_id();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							mtw_NAMESPACE_5F_TYCON_1();
							break;
					}
					mw_nip_1();
					push_value(d5);
				}
				mw_QNAME0_1();
				mp_prim_dup();
				mw_def_3F__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unknown namespace: ", 19);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_swap();
						mw__3E_Str_5();
						mp_prim_str_cat();
						mw_emit_fatal_error_21__1();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				switch (get_top_data_tag()) {
					case 2LL: // DEF_PACKAGE
						mtp_DEF_5F_PACKAGE_1();
						mtw_NAMESPACE_5F_PACKAGE_1();
						break;
					case 1LL: // DEF_MODULE
						mtp_DEF_5F_MODULE_1();
						mtw_NAMESPACE_5F_MODULE_1();
						break;
					default:
						mw_exposed_tycon_3F__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr("invalid namespace: ", 19);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mp_prim_swap();
								mw__3E_Str_5();
								mp_prim_str_cat();
								mw_emit_fatal_error_21__1();
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mtw_NAMESPACE_5F_TYCON_1();
						break;
				}
				mw_nip_1();
				push_value(d4);
			}
			mw_QNAME0_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown namespace: ", 19);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_swap();
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			switch (get_top_data_tag()) {
				case 2LL: // DEF_PACKAGE
					mtp_DEF_5F_PACKAGE_1();
					mtw_NAMESPACE_5F_PACKAGE_1();
					break;
				case 1LL: // DEF_MODULE
					mtp_DEF_5F_MODULE_1();
					mtw_NAMESPACE_5F_MODULE_1();
					break;
				default:
					mw_exposed_tycon_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("invalid namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mtw_NAMESPACE_5F_TYCON_1();
					break;
			}
			mw_nip_1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1891();
				push_value(d4);
			}
			mw_for_3_1891();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
}
static void mw_elab_absolute_qname_1 (void) {
	LPUSH(lbl_arity);
	mw_unsnoc_1();
	LPUSH(lbl_name);
	mw_elab_absolute_namespace_1();
	LPUSH(lbl_namespace);
	mtw_MKQNAME_1();
}
static void mw_elab_def_qname_1 (void) {
	mp_prim_dup();
	mw_name_or_dname_3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("expected name", 13);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // LEFT
			mtp_LEFT_1();
			LPUSH(lbl_name);
			mp_prim_dup();
			mw_module_3();
			mtw_NAMESPACE_5F_MODULE_1();
			LPUSH(lbl_namespace);
			mw_num_args_1();
			LPUSH(lbl_arity);
			mtw_MKQNAME_1();
			break;
		case 1LL: // RIGHT
			mtp_RIGHT_1();
			mw_over_1();
			mw_num_args_1();
			mw_elab_qname_from_nonrelative_dname_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_elab_def_qname_undefined_1 (void) {
	mp_prim_dup();
	mw_elab_def_qname_1();
	mp_prim_dup();
	mw_defined_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("name already defined", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
}
static void mw_elab_field_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_next_1();
		push_value(d2);
	}
	mw_args_3_1();
	mw_rotl_1();
	mp_prim_dup();
	mw_elab_def_qname_undefined_1();
	mw_field_new_21__1();
	mp_prim_drop();
}
static void mw_field_new_21__1 (void) {
	mw_alloc_21__7();
	mw_tuck_1();
	mfld__7E_qname_4();
	mp_prim_mut_set();
	mw_tuck_1();
	mfld__7E_head_3();
	mp_prim_mut_set();
	mp_prim_swap();
	push_fnptr(&mb_1894);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_value_type_1();
	mp_prim_mut_set();
	mp_prim_swap();
	push_fnptr(&mb_1895);
	mtw_LAZY_5F_DELAY_1();
	mw_over_1();
	mfld__7E_index_type_1();
	mp_prim_mut_set();
	mp_prim_dup();
	mtw_DEF_5F_FIELD_1();
	mw_register_1();
}
static void mw_value_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_key_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 3, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_empty_1 (void) {
	push_u64(0LL); // L0
}
static void mw_insert_1 (void) {
	mw_cons_2();
}
static void mw_run_specializer_21__1 (void) {
	mw_begin_21__1();
	mw_check_arrow_21__1();
	mw_loop_21__1();
	mw_end_21__3();
}
static void mw_checklist_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 2, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	push_value(u);
}
static void mw_checklist_21__1 (void) {
	VAL v = top_resource();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 2, v);
	VAL* p = &VTUP(v)->cells[1];
	VAL t = *p; *p = u; decref(t);
}
static void mw_begin_21__1 (void) {
	push_u64(0LL); // L0
	LPUSH(lbl_checklist);
	mtw_SPCHECK_1();
}
static void mw_end_21__3 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // SPCHECK
			mtp_SPCHECK_1();
			LPOP(lbl_checklist);
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_loop_21__1 (void) {
	mw_checklist_2();
	{
		VAL d2 = pop_resource();
		mw_uncons_3F__1();
		push_resource(d2);
	}
	mw_checklist_21__1();
	while(1) {
		mp_prim_dup();
		mw_some_3F__1();
		if (! pop_u64()) break;
		mw_unwrap_1();
		mw_do_item_check_21__1();
		mw_checklist_2();
		{
			VAL d3 = pop_resource();
			mw_uncons_3F__1();
			push_resource(d3);
		}
		mw_checklist_21__1();
	}
	mp_prim_drop();
}
static void mw_do_item_check_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // SPCHECK_WORD
			mtp_SPCHECK_5F_WORD_1();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_arrow_2();
				mw_check_arrow_21__1();
				mw_ready_1();
				push_value(d4);
			}
			mfld__7E_arrow_1();
			mp_prim_mut_set();
			break;
		case 1LL: // SPCHECK_BLOCK
			mtp_SPCHECK_5F_BLOCK_1();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_arrow_5();
				mw_check_arrow_21__1();
				mw_ready_1();
				push_value(d4);
			}
			mfld__7E_arrow_2();
			mp_prim_mut_set();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_check_arrow_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_atoms_4();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				push_u64(0LL); // L0
				break;
			case 1LL: // L1
				mtp_L1_1();
				mw_check_atom_21__1();
				break;
			case 2LL: // L2
				mtp_L2_1();
				{
					VAL d5 = pop_value();
					mw_check_atom_21__1();
					push_value(d5);
				}
				mw_dip_27__1_1897();
				mw_cat_2();
				break;
			case 3LL: // L3
				mtp_L3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_check_atom_21__1();
						push_value(d6);
					}
					mw_dip_27__1_1897();
					mw_cat_2();
					push_value(d5);
				}
				mw_dip_27__1_1897();
				mw_cat_2();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				{
					VAL d5 = pop_value();
					mw_flatmap_2_1897();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_flatmap_2_1897();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cat_2();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		push_value(d2);
	}
	mw_atoms_21__2();
}
static void mw_check_atom_21__1 (void) {
	mp_prim_dup();
	mw_op_4();
	switch (get_top_data_tag()) {
		case 0LL: // OP_NONE
			(void)pop_u64();
			mtw_L1_1();
			break;
		case 1LL: // OP_PRIM
			mtp_OP_5F_PRIM_1();
			mw_check_prim_atom_21__1();
			break;
		case 2LL: // OP_WORD
			mtp_OP_5F_WORD_1();
			mw_check_word_atom_21__1();
			break;
		case 3LL: // OP_EXTERNAL
			mtp_OP_5F_EXTERNAL_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 4LL: // OP_BUFFER
			mtp_OP_5F_BUFFER_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 5LL: // OP_VARIABLE
			mtp_OP_5F_VARIABLE_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 6LL: // OP_FIELD
			mtp_OP_5F_FIELD_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 7LL: // OP_INT
			mtp_OP_5F_INT_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 8LL: // OP_STR
			mtp_OP_5F_STR_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 9LL: // OP_TAG
			mtp_OP_5F_TAG_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 10LL: // OP_MATCH
			mtp_OP_5F_MATCH_1();
			mw_check_match_21__1();
			mtw_OP_5F_MATCH_1();
			mp_prim_swap();
			mw_op_21__3();
			mtw_L1_1();
			break;
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mw_check_lambda_21__1();
			mtw_OP_5F_LAMBDA_1();
			mp_prim_swap();
			mw_op_21__3();
			mtw_L1_1();
			break;
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 13LL: // OP_BLOCK
			mtp_OP_5F_BLOCK_1();
			mw_push_check_block_21__1();
			mtw_L1_1();
			break;
		case 14LL: // OP_RUN
			mtp_OP_5F_RUN_1();
			mw_push_check_block_21__1();
			mtw_L1_1();
			break;
		case 15LL: // OP_COERCE
			mtp_OP_5F_COERCE_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 16LL: // OP_LABEL_PUSH
			mtp_OP_5F_LABEL_5F_PUSH_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 17LL: // OP_LABEL_POP
			mtp_OP_5F_LABEL_5F_POP_1();
			mp_prim_drop();
			mtw_L1_1();
			break;
		case 18LL: // OP_DATA_GET_LABEL
			mtp_OP_5F_DATA_5F_GET_5F_LABEL_1();
			mw_drop2_1();
			mtw_L1_1();
			break;
		case 19LL: // OP_DATA_SET_LABEL
			mtp_OP_5F_DATA_5F_SET_5F_LABEL_1();
			mw_drop2_1();
			mtw_L1_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_check_arg_21__1 (void) {
	mw_push_check_block_21__1();
}
static void mw_check_prim_atom_21__1 (void) {
	mp_prim_drop();
	mp_prim_dup();
	mw_args_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_check_arg_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_check_arg_21__1();
				push_value(d4);
			}
			mw_check_arg_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_arg_21__1();
					push_value(d5);
				}
				mw_check_arg_21__1();
				push_value(d4);
			}
			mw_check_arg_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1904();
				push_value(d4);
			}
			mw_for_3_1904();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mtw_L1_1();
}
static void mw_check_word_atom_21__1 (void) {
	mw_over_1();
	mw_args_4();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_push_check_word_21__1();
			mtw_L1_1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_dup();
			mw_for_3_1905();
			mp_prim_dup();
			mw_map_4_1906();
			mw_find_some_2_2925();
			mw_some_3F__1();
			if (pop_u64()) {
				mw_drop2_1();
				mtw_L1_1();
			} else {
				mp_prim_swap();
				mw_specialize_word_21__1();
				mp_prim_dup();
				mw_push_check_word_21__1();
				mp_prim_swap();
				mw__2F_ATOM_1();
				LPOP(lbl_ctx);
				LPOP(lbl_dom);
				LPOP(lbl_cod);
				mw_T__3E__1();
				LPOP(lbl_token);
				LPOP(lbl_home);
				LPOP(lbl_subst);
				LPOP(lbl_op);
				LPOP(lbl_args);
				mw_drop3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_unpack_1();
						mw_rotr_1();
						push_value(d6);
					}
					push_value(d5);
				}
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mp_prim_dup();
				LPUSH(lbl_dom);
				LPUSH(lbl_cod);
				LPUSH(lbl_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_ARROW_1();
				LPUSH(lbl_arrow);
				mtw_MKAB_1();
				{
					VAL d5 = pop_value();
					mw_ab_word_21__1();
					push_value(d5);
				}
				mw_ab_unify_type_21__1();
				mw__2F_MKAB_1();
				LPOP(lbl_arrow);
				mw_atoms_4();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_check_match_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_cases_4();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				push_u64(0LL); // L0
				break;
			case 1LL: // L1
				mtp_L1_1();
				mw_check_case_21__1();
				mtw_L1_1();
				break;
			case 2LL: // L2
				mtp_L2_1();
				{
					VAL d5 = pop_value();
					mw_check_case_21__1();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_check_case_21__1();
					push_value(d5);
				}
				mp_prim_swap();
				mtw_L2_1();
				break;
			case 3LL: // L3
				mtp_L3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_check_case_21__1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotr_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_check_case_21__1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotr_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_check_case_21__1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotr_1();
				mtw_L3_1();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_map_4_1913();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw_map_4_1913();
						push_value(d6);
					}
					mp_prim_swap();
					push_value(d5);
				}
				mtw_LCAT_1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		push_value(d2);
	}
	mw_cases_21__2();
}
static void mw_check_case_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_body_5();
		mw_check_arrow_21__1();
		push_value(d2);
	}
	mw_body_21__2();
}
static void mw_check_lambda_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_body_9();
		mw_check_arrow_21__1();
		push_value(d2);
	}
	mw_body_21__4();
}
static void mw_push_check_word_21__1 (void) {
	mp_prim_dup();
	mfld__7E_sp_checked_1();
	mw__40__3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		push_u64(1LL); // T
		mw_over_1();
		mfld__7E_sp_checked_1();
		mp_prim_mut_set();
		mtw_SPCHECK_5F_WORD_1();
		mw_checklist_2();
		{
			VAL d3 = pop_resource();
			mw_cons_2();
			push_resource(d3);
		}
		mw_checklist_21__1();
	}
}
static void mw_push_check_block_21__1 (void) {
	mp_prim_dup();
	mfld__7E_sp_checked_2();
	mw__40__3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // F
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		push_u64(1LL); // T
		mw_over_1();
		mfld__7E_sp_checked_2();
		mp_prim_mut_set();
		mtw_SPCHECK_5F_BLOCK_1();
		mw_checklist_2();
		{
			VAL d3 = pop_resource();
			mw_cons_2();
			push_resource(d3);
		}
		mw_checklist_21__1();
	}
}
static void mw__2F_SPKEY_1 (void) {
}
static void mw__3D__3D__27 (void) {
	{
		VAL d2 = pop_value();
		mw__2F_SPKEY_1();
		push_value(d2);
	}
	mw__2F_SPKEY_1();
	mw_dup2_1();
	{
		VAL d2 = pop_value();
		mw_len_2();
		push_value(d2);
	}
	mw_len_2();
	mw__3D__3D__12();
	if (pop_u64()) {
		{
			VAL d3 = pop_value();
			mw_uncons_2();
			push_value(d3);
		}
		mw_uncons_2();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3D__3D__38();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_rotl_1();
		{
			VAL d3 = pop_value();
			push_u64(0LL); // L0
			{
				VAL d4 = pop_value();
				mw_uncons_3F__1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_uncons_3F__1();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_swap();
								switch (get_top_data_tag()) {
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(0LL); // NONE
										break;
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_swap();
										mw__3D__3D__38();
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			while(1) {
				mp_prim_dup();
				mw_some_3F__1();
				if (! pop_u64()) break;
				mw_unwrap_1();
				mw_snoc_1();
				{
					VAL d5 = pop_value();
					mw_uncons_3F__1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_uncons_3F__1();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							switch (get_top_data_tag()) {
								case 0LL: // NONE
									(void)pop_u64();
									mp_prim_drop();
									push_u64(0LL); // NONE
									break;
								case 1LL: // SOME
									mtp_SOME_1();
									mp_prim_swap();
									switch (get_top_data_tag()) {
										case 0LL: // NONE
											(void)pop_u64();
											mp_prim_drop();
											push_u64(0LL); // NONE
											break;
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_swap();
											mw__3D__3D__38();
											mtw_SOME_1();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					push_value(d5);
				}
				mp_prim_swap();
			}
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			push_value(d3);
		}
		mp_prim_swap();
		mw_cons_2B__1();
		mw_find_some_2_2907();
		mw_none_3F__1();
	} else {
		mw_drop2_1();
		push_u64(0LL); // F
	}
}
static void mw__3E_Str_2 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("", 0);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_thaw_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("(", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3B__1();
	{
		VAL d2 = pop_value();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("", 0);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		push_value(d2);
	}
	mw_for_3_135();
	mp_prim_drop();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(")", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3B__1();
	mw_freeze_1();
}
static void mw__3E_Name_2 (void) {
	mw__3E_Str_2();
	mw__3E_Name_1();
}
static void mw_sp_synthed_1 (void) {
	mfld__7E_sp_synthed_1();
	mw__40__3F__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_empty_1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_specialize_word_21__1 (void) {
	{
		VAL var_w = pop_value();
		VAL var_k = pop_value();
		incref(var_k);
		push_value(var_k);
		incref(var_w);
		push_value(var_w);
		mw_sp_synthed_1();
		mw__3E_List_2B__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_find_some_2_2896();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_nip_1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_value_2();
				mtw_SOME_1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				push_u64(0LL); // F
				mw_over_1();
				mfld__7E_prefer_inline_3F__1();
				mp_prim_mut_set();
				break;
			case 0LL: // NONE
				(void)pop_u64();
				incref(var_w);
				push_value(var_w);
				mw_head_2();
				LPUSH(lbl_head);
				push_u64(0LL); // NONE
				LPUSH(lbl_sig);
				incref(var_w);
				push_value(var_w);
				mw_body_1();
				LPUSH(lbl_body);
				incref(var_w);
				push_value(var_w);
				mtw_NAMESPACE_5F_WORD_1();
				incref(var_k);
				push_value(var_k);
				mw__3E_Name_2();
				mw_QNAME0_1();
				LPUSH(lbl_qname);
				push_i64(0LL);
				LPUSH(lbl_arity);
				mw_new_21__1();
				{
					VAL var_w_27_ = pop_value();
					incref(var_k);
					push_value(var_k);
					LPUSH(lbl_key);
					incref(var_w_27_);
					push_value(var_w_27_);
					LPUSH(lbl_value);
					mtw_KVPAIR_1();
					incref(var_w);
					push_value(var_w);
					mw_sp_synthed_1();
					mw_insert_1();
					incref(var_w);
					push_value(var_w);
					mfld__7E_sp_synthed_1();
					mp_prim_mut_set();
					push_fnptr(&mb_1924);
					incref(var_k);
					push_value(var_k);
					mp_prim_pack_cons();
					incref(var_w);
					push_value(var_w);
					mp_prim_pack_cons();
					mw_Str_2();
					incref(var_w_27_);
					push_value(var_w_27_);
					mfld__7E_cname_1();
					mp_prim_mut_set();
					incref(var_k);
					push_value(var_k);
					incref(var_w);
					push_value(var_w);
					mw_pack2_1();
					push_fnptr(&mb_2879);
					mtw_LAZY_5F_DELAY_1();
					incref(var_w_27_);
					push_value(var_w_27_);
					mfld__7E_ctx_type_1();
					mp_prim_mut_set();
					push_u64(1LL); // T
					incref(var_w_27_);
					push_value(var_w_27_);
					mfld__7E_prefer_inline_3F__1();
					mp_prim_mut_set();
					incref(var_k);
					push_value(var_k);
					incref(var_w);
					push_value(var_w);
					incref(var_w_27_);
					push_value(var_w_27_);
					mw_pack3_1();
					push_fnptr(&mb_2785);
					mtw_LAZY_5F_DELAY_1();
					incref(var_w_27_);
					push_value(var_w_27_);
					mfld__7E_arrow_1();
					mp_prim_mut_set();
					incref(var_w_27_);
					push_value(var_w_27_);
					decref(var_w_27_);
				}
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		decref(var_w);
		decref(var_k);
	}
}
static void mw_specialize_ctx_type_1 (void) {
	mw_nip_1();
	{
		VAL d2 = pop_value();
		push_u64(0LL); // SUBST_NIL
		push_value(d2);
	}
	mw_freshen_2();
	mw_nip_1();
	mp_prim_swap();
	mw__2F_SPKEY_1();
	mp_prim_dup();
	mw_first_2();
	mw_token_9();
	LPUSH(lbl_gamma);
	{
		VAL d2 = pop_value();
		push_u64(0LL); // SUBST_NIL
		push_value(d2);
	}
	mw_nip_1();
	{
		VAL d2 = pop_value();
		mw_unpack_1();
		mp_prim_swap();
		push_value(d2);
	}
	mw_reverse_for_2_1938();
	LPOP(lbl_gamma);
	mp_prim_drop();
	mp_prim_swap();
	mw_T__3E__1();
	{
		VAL d2 = pop_value();
		mw_CTX0_1();
		push_value(d2);
	}
	mw_rigidify_sig_21__1();
}
static void mw__2F__2B_SPSYNTH_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +SPSYNTH
			mtp__2B_SPSYNTH_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_spmap_2 (void) {
	VAL v = top_resource();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 5, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	push_value(u);
}
static void mw_synth_specialized_word_21__1 (void) {
	mp_prim_dup();
	LPUSH(lbl_spword);
	{
		VAL d2 = pop_value();
		LPUSH(lbl_spkey);
		push_value(d2);
	}
	mw_arrow_2();
	mw_atoms_4();
	mw__2F_L1_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("unexpected shape for synth-specialized-word!", 44);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_op_4();
	switch (get_top_data_tag()) {
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mp_prim_dup();
			mw_params_3();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					push_u64(0LL); // L0
					break;
				case 1LL: // L1
					mtp_L1_1();
					mw__2F_PARAM_1();
					mtw_L1_1();
					break;
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw__2F_PARAM_1();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw__2F_PARAM_1();
						push_value(d6);
					}
					mp_prim_swap();
					mtw_L2_1();
					break;
				case 3LL: // L3
					mtp_L3_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__2F_PARAM_1();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__2F_PARAM_1();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__2F_PARAM_1();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotr_1();
					mtw_L3_1();
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_map_4_1945();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_map_4_1945();
							push_value(d7);
						}
						mp_prim_swap();
						push_value(d6);
					}
					mtw_LCAT_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			LPOP(lbl_spkey);
			mp_prim_dup();
			LPUSH(lbl_spkey);
			mw__2F_SPKEY_1();
			mw__3E_List_2();
			mw_over_1();
			mw_len_1();
			mw_over_1();
			mw_len_1();
			mw__3D__3D__12();
			if (pop_u64()) {
				mp_prim_id();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("wrong number of lambda params in synth-specialized-word!", 56);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("assertion failed: ", 18);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_swap();
				mp_prim_str_cat();
				mp_prim_panic();
			}
			push_u64(0LL); // L0
			{
				VAL d4 = pop_value();
				mw_uncons_3F__1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_uncons_3F__1();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_swap();
								switch (get_top_data_tag()) {
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(0LL); // NONE
										break;
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_swap();
										mw__2F_ARG_5F_BLOCK_1();
										LPUSH(lbl_value);
										LPUSH(lbl_key);
										mtw_KVPAIR_1();
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			while(1) {
				mp_prim_dup();
				mw_some_3F__1();
				if (! pop_u64()) break;
				mw_unwrap_1();
				mw_snoc_1();
				{
					VAL d5 = pop_value();
					mw_uncons_3F__1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_uncons_3F__1();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							switch (get_top_data_tag()) {
								case 0LL: // NONE
									(void)pop_u64();
									mp_prim_drop();
									push_u64(0LL); // NONE
									break;
								case 1LL: // SOME
									mtp_SOME_1();
									mp_prim_swap();
									switch (get_top_data_tag()) {
										case 0LL: // NONE
											(void)pop_u64();
											mp_prim_drop();
											push_u64(0LL); // NONE
											break;
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_swap();
											mw__2F_ARG_5F_BLOCK_1();
											LPUSH(lbl_value);
											LPUSH(lbl_key);
											mtw_KVPAIR_1();
											mtw_SOME_1();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					push_value(d5);
				}
				mp_prim_swap();
			}
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_drop2_1();
				push_value(d4);
			}
			LPUSH(lbl_spmap);
			mtw__2B_SPSYNTH_1();
			mw_body_9();
			mw_synth_arrow_21__1();
			mw__2F__2B_SPSYNTH_1();
			LPOP(lbl_spkey);
			LPOP(lbl_spword);
			LPOP(lbl_spmap);
			mw_drop3_1();
			break;
		default:
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("unexpected shape", 16);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
	}
}
static void mw_synth_arrow_21__1 (void) {
	mw_atoms_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_synth_atom_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_synth_atom_21__1();
				push_value(d4);
			}
			mw_synth_atom_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_synth_atom_21__1();
					push_value(d5);
				}
				mw_synth_atom_21__1();
				push_value(d4);
			}
			mw_synth_atom_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1952();
				push_value(d4);
			}
			mw_for_3_1952();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_synth_atom_21__1 (void) {
	mp_prim_dup();
	mw_token_11();
	switch (get_top_resource_data_tag()) {
		case 0LL: // +SPSYNTH
			mtp__2B_SPSYNTH_1();
			mw_ab_token_21__1();
			mtw__2B_SPSYNTH_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_args_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_synth_arg_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_synth_arg_21__1();
				push_value(d4);
			}
			mw_synth_arg_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_synth_arg_21__1();
					push_value(d5);
				}
				mw_synth_arg_21__1();
				push_value(d4);
			}
			mw_synth_arg_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1954();
				push_value(d4);
			}
			mw_for_3_1954();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_op_4();
	mw_synth_op_21__1();
}
static void mw_synth_arg_21__1 (void) {
	mw_synth_block_21__1();
}
static void mw_synth_op_21__1 (void) {
	switch (get_top_data_tag()) {
		case 10LL: // OP_MATCH
			mtp_OP_5F_MATCH_1();
			mw_synth_match_21__1();
			break;
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mw_synth_lambda_21__1();
			break;
		case 13LL: // OP_BLOCK
			mtp_OP_5F_BLOCK_1();
			mw_synth_block_21__1();
			break;
		case 14LL: // OP_RUN
			mtp_OP_5F_RUN_1();
			mw_synth_run_21__1();
			break;
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mw_synth_var_21__1();
			break;
		default:
			switch (get_top_resource_data_tag()) {
				case 0LL: // +SPSYNTH
					mtp__2B_SPSYNTH_1();
					mw_ab_op_21__1();
					mtw__2B_SPSYNTH_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
	}
}
static void mw_synth_block_21__1 (void) {
	mp_prim_dup();
	mw_to_run_var_3();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_spmap_2();
			mw__3E_List_2B__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_find_some_2_2808();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_value_2();
					mtw_SOME_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			switch (get_top_resource_data_tag()) {
				case 0LL: // +SPSYNTH
					mtp__2B_SPSYNTH_1();
					mw_ab_token_40__1();
					mw_ab_ctx_40__1();
					mw_new_21__5();
					mtw_STMeta_1();
					mw_rotl_1();
					mw_ab_home_40__1();
					{
						VAL d6 = pop_resource();
						LPUSH(lbl_home);
						mp_prim_dup();
						LPUSH(lbl_token_start);
						LPUSH(lbl_token_end);
						mp_prim_dup();
						LPUSH(lbl_dom);
						LPUSH(lbl_cod);
						LPUSH(lbl_ctx);
						push_u64(0LL); // L0
						LPUSH(lbl_atoms);
						mtw_ARROW_1();
						LPUSH(lbl_arrow);
						mtw_MKAB_1();
						mtw__2B_SPSYNTH_1();
						mw_arrow_5();
						mw_synth_arrow_21__1();
						mw__2F__2B_SPSYNTH_1();
						mw__2F_MKAB_1();
						LPOP(lbl_arrow);
						push_resource(d6);
					}
					mw_new_21__10();
					mtw_OP_5F_BLOCK_1();
					mw_ab_op_21__1();
					mtw__2B_SPSYNTH_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mtw_OP_5F_BLOCK_1();
			switch (get_top_resource_data_tag()) {
				case 0LL: // +SPSYNTH
					mtp__2B_SPSYNTH_1();
					mw_ab_op_21__1();
					mtw__2B_SPSYNTH_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_synth_run_21__1 (void) {
	mw_arrow_5();
	mw_synth_arrow_21__1();
}
static void mw_synth_var_21__1 (void) {
	mp_prim_dup();
	mw_spmap_2();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_find_some_2_2799();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_value_2();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mtw_OP_5F_RUN_1();
			switch (get_top_resource_data_tag()) {
				case 0LL: // +SPSYNTH
					mtp__2B_SPSYNTH_1();
					mw_ab_op_21__1();
					mtw__2B_SPSYNTH_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 0LL: // NONE
			(void)pop_u64();
			switch (get_top_resource_data_tag()) {
				case 0LL: // +SPSYNTH
					mtp__2B_SPSYNTH_1();
					mw_ab_var_21__1();
					mtw__2B_SPSYNTH_1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_synth_match_21__1 (void) {
	mw_new_21__5();
	mtw_STMeta_1();
	LPUSH(lbl_cod);
	mp_prim_dup();
	mw_body_7();
	LPUSH(lbl_body);
	mw_cases_4();
	switch (get_top_resource_data_tag()) {
		case 0LL: // +SPSYNTH
			mtp__2B_SPSYNTH_1();
			mw_ab_ctx_40__1();
			LPUSH(lbl_ctx);
			mw_ab_type_40__1();
			LPUSH(lbl_dom);
			mw_ab_token_40__1();
			LPUSH(lbl_token);
			mw_ab_home_40__1();
			LPUSH(lbl_home);
			push_u64(0LL); // L0
			LPUSH(lbl_cases);
			{
				VAL d4 = pop_resource();
				mtw__2B_MATCH_1();
				switch (get_top_data_tag()) {
					case 0LL: // L0
						(void)pop_u64();
						mp_prim_id();
						break;
					case 1LL: // L1
						mtp_L1_1();
						mp_prim_dup();
						mw_pattern_4();
						mw_token_start_2();
						mw_over_1();
						mw_body_5();
						mw_token_start_4();
						{
							VAL d7 = pop_value();
							mw_home_2();
							LPUSH(lbl_home);
							mp_prim_dup();
							LPUSH(lbl_token_start);
							LPUSH(lbl_token_end);
							mw_ctx_5();
							mp_prim_dup();
							LPUSH(lbl_outer_ctx);
							LPUSH(lbl_inner_ctx);
							push_u64(0LL); // L0
							LPUSH(lbl_saved);
							mw_dom_4();
							mp_prim_dup();
							LPUSH(lbl_mid);
							LPUSH(lbl_cod);
							push_u64(0LL); // L0
							LPUSH(lbl_atoms);
							mtw_PATTERN_1();
							{
								VAL d8 = pop_resource();
								mw_thaw_3();
								mp_prim_dup();
								mw_pattern_4();
								mw_atoms_2();
								switch (get_top_data_tag()) {
									case 0LL: // L0
										(void)pop_u64();
										mp_prim_id();
										break;
									case 1LL: // L1
										mtp_L1_1();
										mw_op_2();
										mw_op_21__1();
										break;
									case 2LL: // L2
										mtp_L2_1();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_op_2();
											mw_op_21__1();
											push_value(d11);
										}
										mw_op_2();
										mw_op_21__1();
										break;
									case 3LL: // L3
										mtp_L3_1();
										mw_rotr_1();
										mw_dip2_1_1966();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_op_2();
											mw_op_21__1();
											push_value(d11);
										}
										mw_op_2();
										mw_op_21__1();
										break;
									case 4LL: // LCAT
										mtp_LCAT_1();
										mp_prim_drop();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_reverse_for_2_1966();
											push_value(d11);
										}
										mw_reverse_for_2_1966();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								mw_freeze_3();
								push_resource(d8);
							}
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL var_pat = pop_value();
							incref(var_pat);
							push_value(var_pat);
							mw_inner_ctx_3();
							incref(var_pat);
							push_value(var_pat);
							mw_dom_7();
							mw_cod_4();
							mw_T__3E__1();
							mw_rotl_1();
							mw_home_2();
							{
								VAL d8 = pop_resource();
								{
									VAL d9 = pop_value();
									{
										VAL d10 = pop_value();
										mw_unpack_1();
										mw_rotr_1();
										push_value(d10);
									}
									push_value(d9);
								}
								LPUSH(lbl_home);
								mp_prim_dup();
								LPUSH(lbl_token_start);
								LPUSH(lbl_token_end);
								mp_prim_dup();
								LPUSH(lbl_dom);
								LPUSH(lbl_cod);
								LPUSH(lbl_ctx);
								push_u64(0LL); // L0
								LPUSH(lbl_atoms);
								mtw_ARROW_1();
								LPUSH(lbl_arrow);
								mtw_MKAB_1();
								{
									VAL d9 = pop_value();
									mtw__2B_SPSYNTH_1();
									mw_body_5();
									mw_synth_arrow_21__1();
									mw__2F__2B_SPSYNTH_1();
									push_value(d9);
								}
								mw_ab_unify_type_21__1();
								mw__2F_MKAB_1();
								LPOP(lbl_arrow);
								push_resource(d8);
							}
							LPUSH(lbl_body);
							incref(var_pat);
							push_value(var_pat);
							LPUSH(lbl_pattern);
							mtw_CASE_1();
							mw_add_case_1();
							decref(var_pat);
						}
						break;
					case 2LL: // L2
						mtp_L2_1();
						{
							VAL d7 = pop_value();
							mp_prim_dup();
							mw_pattern_4();
							mw_token_start_2();
							mw_over_1();
							mw_body_5();
							mw_token_start_4();
							{
								VAL d8 = pop_value();
								mw_home_2();
								LPUSH(lbl_home);
								mp_prim_dup();
								LPUSH(lbl_token_start);
								LPUSH(lbl_token_end);
								mw_ctx_5();
								mp_prim_dup();
								LPUSH(lbl_outer_ctx);
								LPUSH(lbl_inner_ctx);
								push_u64(0LL); // L0
								LPUSH(lbl_saved);
								mw_dom_4();
								mp_prim_dup();
								LPUSH(lbl_mid);
								LPUSH(lbl_cod);
								push_u64(0LL); // L0
								LPUSH(lbl_atoms);
								mtw_PATTERN_1();
								{
									VAL d9 = pop_resource();
									mw_thaw_3();
									mp_prim_dup();
									mw_pattern_4();
									mw_atoms_2();
									switch (get_top_data_tag()) {
										case 0LL: // L0
											(void)pop_u64();
											mp_prim_id();
											break;
										case 1LL: // L1
											mtp_L1_1();
											mw_op_2();
											mw_op_21__1();
											break;
										case 2LL: // L2
											mtp_L2_1();
											mp_prim_swap();
											{
												VAL d12 = pop_value();
												mw_op_2();
												mw_op_21__1();
												push_value(d12);
											}
											mw_op_2();
											mw_op_21__1();
											break;
										case 3LL: // L3
											mtp_L3_1();
											mw_rotr_1();
											mw_dip2_1_1966();
											mp_prim_swap();
											{
												VAL d12 = pop_value();
												mw_op_2();
												mw_op_21__1();
												push_value(d12);
											}
											mw_op_2();
											mw_op_21__1();
											break;
										case 4LL: // LCAT
											mtp_LCAT_1();
											mp_prim_drop();
											mp_prim_swap();
											{
												VAL d12 = pop_value();
												mw_reverse_for_2_1966();
												push_value(d12);
											}
											mw_reverse_for_2_1966();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									mw_freeze_3();
									push_resource(d9);
								}
								push_value(d8);
							}
							mp_prim_swap();
							{
								VAL var_pat = pop_value();
								incref(var_pat);
								push_value(var_pat);
								mw_inner_ctx_3();
								incref(var_pat);
								push_value(var_pat);
								mw_dom_7();
								mw_cod_4();
								mw_T__3E__1();
								mw_rotl_1();
								mw_home_2();
								{
									VAL d9 = pop_resource();
									{
										VAL d10 = pop_value();
										{
											VAL d11 = pop_value();
											mw_unpack_1();
											mw_rotr_1();
											push_value(d11);
										}
										push_value(d10);
									}
									LPUSH(lbl_home);
									mp_prim_dup();
									LPUSH(lbl_token_start);
									LPUSH(lbl_token_end);
									mp_prim_dup();
									LPUSH(lbl_dom);
									LPUSH(lbl_cod);
									LPUSH(lbl_ctx);
									push_u64(0LL); // L0
									LPUSH(lbl_atoms);
									mtw_ARROW_1();
									LPUSH(lbl_arrow);
									mtw_MKAB_1();
									{
										VAL d10 = pop_value();
										mtw__2B_SPSYNTH_1();
										mw_body_5();
										mw_synth_arrow_21__1();
										mw__2F__2B_SPSYNTH_1();
										push_value(d10);
									}
									mw_ab_unify_type_21__1();
									mw__2F_MKAB_1();
									LPOP(lbl_arrow);
									push_resource(d9);
								}
								LPUSH(lbl_body);
								incref(var_pat);
								push_value(var_pat);
								LPUSH(lbl_pattern);
								mtw_CASE_1();
								mw_add_case_1();
								decref(var_pat);
							}
							push_value(d7);
						}
						mp_prim_dup();
						mw_pattern_4();
						mw_token_start_2();
						mw_over_1();
						mw_body_5();
						mw_token_start_4();
						{
							VAL d7 = pop_value();
							mw_home_2();
							LPUSH(lbl_home);
							mp_prim_dup();
							LPUSH(lbl_token_start);
							LPUSH(lbl_token_end);
							mw_ctx_5();
							mp_prim_dup();
							LPUSH(lbl_outer_ctx);
							LPUSH(lbl_inner_ctx);
							push_u64(0LL); // L0
							LPUSH(lbl_saved);
							mw_dom_4();
							mp_prim_dup();
							LPUSH(lbl_mid);
							LPUSH(lbl_cod);
							push_u64(0LL); // L0
							LPUSH(lbl_atoms);
							mtw_PATTERN_1();
							{
								VAL d8 = pop_resource();
								mw_thaw_3();
								mp_prim_dup();
								mw_pattern_4();
								mw_atoms_2();
								switch (get_top_data_tag()) {
									case 0LL: // L0
										(void)pop_u64();
										mp_prim_id();
										break;
									case 1LL: // L1
										mtp_L1_1();
										mw_op_2();
										mw_op_21__1();
										break;
									case 2LL: // L2
										mtp_L2_1();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_op_2();
											mw_op_21__1();
											push_value(d11);
										}
										mw_op_2();
										mw_op_21__1();
										break;
									case 3LL: // L3
										mtp_L3_1();
										mw_rotr_1();
										mw_dip2_1_1966();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_op_2();
											mw_op_21__1();
											push_value(d11);
										}
										mw_op_2();
										mw_op_21__1();
										break;
									case 4LL: // LCAT
										mtp_LCAT_1();
										mp_prim_drop();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_reverse_for_2_1966();
											push_value(d11);
										}
										mw_reverse_for_2_1966();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								mw_freeze_3();
								push_resource(d8);
							}
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL var_pat = pop_value();
							incref(var_pat);
							push_value(var_pat);
							mw_inner_ctx_3();
							incref(var_pat);
							push_value(var_pat);
							mw_dom_7();
							mw_cod_4();
							mw_T__3E__1();
							mw_rotl_1();
							mw_home_2();
							{
								VAL d8 = pop_resource();
								{
									VAL d9 = pop_value();
									{
										VAL d10 = pop_value();
										mw_unpack_1();
										mw_rotr_1();
										push_value(d10);
									}
									push_value(d9);
								}
								LPUSH(lbl_home);
								mp_prim_dup();
								LPUSH(lbl_token_start);
								LPUSH(lbl_token_end);
								mp_prim_dup();
								LPUSH(lbl_dom);
								LPUSH(lbl_cod);
								LPUSH(lbl_ctx);
								push_u64(0LL); // L0
								LPUSH(lbl_atoms);
								mtw_ARROW_1();
								LPUSH(lbl_arrow);
								mtw_MKAB_1();
								{
									VAL d9 = pop_value();
									mtw__2B_SPSYNTH_1();
									mw_body_5();
									mw_synth_arrow_21__1();
									mw__2F__2B_SPSYNTH_1();
									push_value(d9);
								}
								mw_ab_unify_type_21__1();
								mw__2F_MKAB_1();
								LPOP(lbl_arrow);
								push_resource(d8);
							}
							LPUSH(lbl_body);
							incref(var_pat);
							push_value(var_pat);
							LPUSH(lbl_pattern);
							mtw_CASE_1();
							mw_add_case_1();
							decref(var_pat);
						}
						break;
					case 3LL: // L3
						mtp_L3_1();
						{
							VAL d7 = pop_value();
							{
								VAL d8 = pop_value();
								mp_prim_dup();
								mw_pattern_4();
								mw_token_start_2();
								mw_over_1();
								mw_body_5();
								mw_token_start_4();
								{
									VAL d9 = pop_value();
									mw_home_2();
									LPUSH(lbl_home);
									mp_prim_dup();
									LPUSH(lbl_token_start);
									LPUSH(lbl_token_end);
									mw_ctx_5();
									mp_prim_dup();
									LPUSH(lbl_outer_ctx);
									LPUSH(lbl_inner_ctx);
									push_u64(0LL); // L0
									LPUSH(lbl_saved);
									mw_dom_4();
									mp_prim_dup();
									LPUSH(lbl_mid);
									LPUSH(lbl_cod);
									push_u64(0LL); // L0
									LPUSH(lbl_atoms);
									mtw_PATTERN_1();
									{
										VAL d10 = pop_resource();
										mw_thaw_3();
										mp_prim_dup();
										mw_pattern_4();
										mw_atoms_2();
										switch (get_top_data_tag()) {
											case 0LL: // L0
												(void)pop_u64();
												mp_prim_id();
												break;
											case 1LL: // L1
												mtp_L1_1();
												mw_op_2();
												mw_op_21__1();
												break;
											case 2LL: // L2
												mtp_L2_1();
												mp_prim_swap();
												{
													VAL d13 = pop_value();
													mw_op_2();
													mw_op_21__1();
													push_value(d13);
												}
												mw_op_2();
												mw_op_21__1();
												break;
											case 3LL: // L3
												mtp_L3_1();
												mw_rotr_1();
												mw_dip2_1_1966();
												mp_prim_swap();
												{
													VAL d13 = pop_value();
													mw_op_2();
													mw_op_21__1();
													push_value(d13);
												}
												mw_op_2();
												mw_op_21__1();
												break;
											case 4LL: // LCAT
												mtp_LCAT_1();
												mp_prim_drop();
												mp_prim_swap();
												{
													VAL d13 = pop_value();
													mw_reverse_for_2_1966();
													push_value(d13);
												}
												mw_reverse_for_2_1966();
												break;
											default:
												push_value(mkstr("unexpected fallthrough in match\n", 32)); 
												mp_prim_panic();
										}
										mw_freeze_3();
										push_resource(d10);
									}
									push_value(d9);
								}
								mp_prim_swap();
								{
									VAL var_pat = pop_value();
									incref(var_pat);
									push_value(var_pat);
									mw_inner_ctx_3();
									incref(var_pat);
									push_value(var_pat);
									mw_dom_7();
									mw_cod_4();
									mw_T__3E__1();
									mw_rotl_1();
									mw_home_2();
									{
										VAL d10 = pop_resource();
										{
											VAL d11 = pop_value();
											{
												VAL d12 = pop_value();
												mw_unpack_1();
												mw_rotr_1();
												push_value(d12);
											}
											push_value(d11);
										}
										LPUSH(lbl_home);
										mp_prim_dup();
										LPUSH(lbl_token_start);
										LPUSH(lbl_token_end);
										mp_prim_dup();
										LPUSH(lbl_dom);
										LPUSH(lbl_cod);
										LPUSH(lbl_ctx);
										push_u64(0LL); // L0
										LPUSH(lbl_atoms);
										mtw_ARROW_1();
										LPUSH(lbl_arrow);
										mtw_MKAB_1();
										{
											VAL d11 = pop_value();
											mtw__2B_SPSYNTH_1();
											mw_body_5();
											mw_synth_arrow_21__1();
											mw__2F__2B_SPSYNTH_1();
											push_value(d11);
										}
										mw_ab_unify_type_21__1();
										mw__2F_MKAB_1();
										LPOP(lbl_arrow);
										push_resource(d10);
									}
									LPUSH(lbl_body);
									incref(var_pat);
									push_value(var_pat);
									LPUSH(lbl_pattern);
									mtw_CASE_1();
									mw_add_case_1();
									decref(var_pat);
								}
								push_value(d8);
							}
							mp_prim_dup();
							mw_pattern_4();
							mw_token_start_2();
							mw_over_1();
							mw_body_5();
							mw_token_start_4();
							{
								VAL d8 = pop_value();
								mw_home_2();
								LPUSH(lbl_home);
								mp_prim_dup();
								LPUSH(lbl_token_start);
								LPUSH(lbl_token_end);
								mw_ctx_5();
								mp_prim_dup();
								LPUSH(lbl_outer_ctx);
								LPUSH(lbl_inner_ctx);
								push_u64(0LL); // L0
								LPUSH(lbl_saved);
								mw_dom_4();
								mp_prim_dup();
								LPUSH(lbl_mid);
								LPUSH(lbl_cod);
								push_u64(0LL); // L0
								LPUSH(lbl_atoms);
								mtw_PATTERN_1();
								{
									VAL d9 = pop_resource();
									mw_thaw_3();
									mp_prim_dup();
									mw_pattern_4();
									mw_atoms_2();
									switch (get_top_data_tag()) {
										case 0LL: // L0
											(void)pop_u64();
											mp_prim_id();
											break;
										case 1LL: // L1
											mtp_L1_1();
											mw_op_2();
											mw_op_21__1();
											break;
										case 2LL: // L2
											mtp_L2_1();
											mp_prim_swap();
											{
												VAL d12 = pop_value();
												mw_op_2();
												mw_op_21__1();
												push_value(d12);
											}
											mw_op_2();
											mw_op_21__1();
											break;
										case 3LL: // L3
											mtp_L3_1();
											mw_rotr_1();
											mw_dip2_1_1966();
											mp_prim_swap();
											{
												VAL d12 = pop_value();
												mw_op_2();
												mw_op_21__1();
												push_value(d12);
											}
											mw_op_2();
											mw_op_21__1();
											break;
										case 4LL: // LCAT
											mtp_LCAT_1();
											mp_prim_drop();
											mp_prim_swap();
											{
												VAL d12 = pop_value();
												mw_reverse_for_2_1966();
												push_value(d12);
											}
											mw_reverse_for_2_1966();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									mw_freeze_3();
									push_resource(d9);
								}
								push_value(d8);
							}
							mp_prim_swap();
							{
								VAL var_pat = pop_value();
								incref(var_pat);
								push_value(var_pat);
								mw_inner_ctx_3();
								incref(var_pat);
								push_value(var_pat);
								mw_dom_7();
								mw_cod_4();
								mw_T__3E__1();
								mw_rotl_1();
								mw_home_2();
								{
									VAL d9 = pop_resource();
									{
										VAL d10 = pop_value();
										{
											VAL d11 = pop_value();
											mw_unpack_1();
											mw_rotr_1();
											push_value(d11);
										}
										push_value(d10);
									}
									LPUSH(lbl_home);
									mp_prim_dup();
									LPUSH(lbl_token_start);
									LPUSH(lbl_token_end);
									mp_prim_dup();
									LPUSH(lbl_dom);
									LPUSH(lbl_cod);
									LPUSH(lbl_ctx);
									push_u64(0LL); // L0
									LPUSH(lbl_atoms);
									mtw_ARROW_1();
									LPUSH(lbl_arrow);
									mtw_MKAB_1();
									{
										VAL d10 = pop_value();
										mtw__2B_SPSYNTH_1();
										mw_body_5();
										mw_synth_arrow_21__1();
										mw__2F__2B_SPSYNTH_1();
										push_value(d10);
									}
									mw_ab_unify_type_21__1();
									mw__2F_MKAB_1();
									LPOP(lbl_arrow);
									push_resource(d9);
								}
								LPUSH(lbl_body);
								incref(var_pat);
								push_value(var_pat);
								LPUSH(lbl_pattern);
								mtw_CASE_1();
								mw_add_case_1();
								decref(var_pat);
							}
							push_value(d7);
						}
						mp_prim_dup();
						mw_pattern_4();
						mw_token_start_2();
						mw_over_1();
						mw_body_5();
						mw_token_start_4();
						{
							VAL d7 = pop_value();
							mw_home_2();
							LPUSH(lbl_home);
							mp_prim_dup();
							LPUSH(lbl_token_start);
							LPUSH(lbl_token_end);
							mw_ctx_5();
							mp_prim_dup();
							LPUSH(lbl_outer_ctx);
							LPUSH(lbl_inner_ctx);
							push_u64(0LL); // L0
							LPUSH(lbl_saved);
							mw_dom_4();
							mp_prim_dup();
							LPUSH(lbl_mid);
							LPUSH(lbl_cod);
							push_u64(0LL); // L0
							LPUSH(lbl_atoms);
							mtw_PATTERN_1();
							{
								VAL d8 = pop_resource();
								mw_thaw_3();
								mp_prim_dup();
								mw_pattern_4();
								mw_atoms_2();
								switch (get_top_data_tag()) {
									case 0LL: // L0
										(void)pop_u64();
										mp_prim_id();
										break;
									case 1LL: // L1
										mtp_L1_1();
										mw_op_2();
										mw_op_21__1();
										break;
									case 2LL: // L2
										mtp_L2_1();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_op_2();
											mw_op_21__1();
											push_value(d11);
										}
										mw_op_2();
										mw_op_21__1();
										break;
									case 3LL: // L3
										mtp_L3_1();
										mw_rotr_1();
										mw_dip2_1_1966();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_op_2();
											mw_op_21__1();
											push_value(d11);
										}
										mw_op_2();
										mw_op_21__1();
										break;
									case 4LL: // LCAT
										mtp_LCAT_1();
										mp_prim_drop();
										mp_prim_swap();
										{
											VAL d11 = pop_value();
											mw_reverse_for_2_1966();
											push_value(d11);
										}
										mw_reverse_for_2_1966();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								mw_freeze_3();
								push_resource(d8);
							}
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL var_pat = pop_value();
							incref(var_pat);
							push_value(var_pat);
							mw_inner_ctx_3();
							incref(var_pat);
							push_value(var_pat);
							mw_dom_7();
							mw_cod_4();
							mw_T__3E__1();
							mw_rotl_1();
							mw_home_2();
							{
								VAL d8 = pop_resource();
								{
									VAL d9 = pop_value();
									{
										VAL d10 = pop_value();
										mw_unpack_1();
										mw_rotr_1();
										push_value(d10);
									}
									push_value(d9);
								}
								LPUSH(lbl_home);
								mp_prim_dup();
								LPUSH(lbl_token_start);
								LPUSH(lbl_token_end);
								mp_prim_dup();
								LPUSH(lbl_dom);
								LPUSH(lbl_cod);
								LPUSH(lbl_ctx);
								push_u64(0LL); // L0
								LPUSH(lbl_atoms);
								mtw_ARROW_1();
								LPUSH(lbl_arrow);
								mtw_MKAB_1();
								{
									VAL d9 = pop_value();
									mtw__2B_SPSYNTH_1();
									mw_body_5();
									mw_synth_arrow_21__1();
									mw__2F__2B_SPSYNTH_1();
									push_value(d9);
								}
								mw_ab_unify_type_21__1();
								mw__2F_MKAB_1();
								LPOP(lbl_arrow);
								push_resource(d8);
							}
							LPUSH(lbl_body);
							incref(var_pat);
							push_value(var_pat);
							LPUSH(lbl_pattern);
							mtw_CASE_1();
							mw_add_case_1();
							decref(var_pat);
						}
						break;
					case 4LL: // LCAT
						mtp_LCAT_1();
						mp_prim_drop();
						{
							VAL d7 = pop_value();
							mw_for_3_1963();
							push_value(d7);
						}
						mw_for_3_1963();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_freeze_2();
				push_resource(d4);
			}
			mtw_OP_5F_MATCH_1();
			mw_ab_op_21__1();
			mtw__2B_SPSYNTH_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_synth_lambda_21__1 (void) {
	mp_prim_dup();
	mw_params_3();
	switch (get_top_resource_data_tag()) {
		case 0LL: // +SPSYNTH
			mtp__2B_SPSYNTH_1();
			{
				VAL d4 = pop_value();
				mw_ab_token_40__1();
				push_value(d4);
			}
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_ab_ctx_40__1();
					mw_ab_type_40__1();
					push_value(d5);
				}
				switch (get_top_data_tag()) {
					case 0LL: // L0
						(void)pop_u64();
						mp_prim_id();
						break;
					case 1LL: // L1
						mtp_L1_1();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw__3E_Var_1();
							mp_prim_dup();
							{
								VAL d8 = pop_value();
								mw_new_4();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_ab_token_40__1();
						mw_elab_expand_tensor_21__1();
						{
							VAL d7 = pop_value();
							mw_rotl_1();
							mw_type_4();
							push_value(d7);
						}
						mw_elab_type_unify_21__1();
						mw_drop2_1();
						break;
					case 2LL: // L2
						mtp_L2_1();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw__3E_Var_1();
								mp_prim_dup();
								{
									VAL d9 = pop_value();
									mw_new_4();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_ab_token_40__1();
							mw_elab_expand_tensor_21__1();
							{
								VAL d8 = pop_value();
								mw_rotl_1();
								mw_type_4();
								push_value(d8);
							}
							mw_elab_type_unify_21__1();
							mw_drop2_1();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw__3E_Var_1();
							mp_prim_dup();
							{
								VAL d8 = pop_value();
								mw_new_4();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_ab_token_40__1();
						mw_elab_expand_tensor_21__1();
						{
							VAL d7 = pop_value();
							mw_rotl_1();
							mw_type_4();
							push_value(d7);
						}
						mw_elab_type_unify_21__1();
						mw_drop2_1();
						break;
					case 3LL: // L3
						mtp_L3_1();
						mw_rotr_1();
						mw_dip2_1_2817();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw__3E_Var_1();
								mp_prim_dup();
								{
									VAL d9 = pop_value();
									mw_new_4();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_ab_token_40__1();
							mw_elab_expand_tensor_21__1();
							{
								VAL d8 = pop_value();
								mw_rotl_1();
								mw_type_4();
								push_value(d8);
							}
							mw_elab_type_unify_21__1();
							mw_drop2_1();
							push_value(d7);
						}
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw__3E_Var_1();
							mp_prim_dup();
							{
								VAL d8 = pop_value();
								mw_new_4();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_ab_token_40__1();
						mw_elab_expand_tensor_21__1();
						{
							VAL d7 = pop_value();
							mw_rotl_1();
							mw_type_4();
							push_value(d7);
						}
						mw_elab_type_unify_21__1();
						mw_drop2_1();
						break;
					case 4LL: // LCAT
						mtp_LCAT_1();
						mp_prim_drop();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw_reverse_for_2_2817();
							push_value(d7);
						}
						mw_reverse_for_2_2817();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_rotl_1();
				mw_ab_home_40__1();
				{
					VAL d5 = pop_resource();
					LPUSH(lbl_home);
					mp_prim_dup();
					LPUSH(lbl_token_start);
					LPUSH(lbl_token_end);
					mp_prim_dup();
					LPUSH(lbl_dom);
					LPUSH(lbl_cod);
					LPUSH(lbl_ctx);
					push_u64(0LL); // L0
					LPUSH(lbl_atoms);
					mtw_ARROW_1();
					LPUSH(lbl_arrow);
					mtw_MKAB_1();
					mtw__2B_SPSYNTH_1();
					mw_body_9();
					mw_synth_arrow_21__1();
					mw__2F__2B_SPSYNTH_1();
					mw__2F_MKAB_1();
					LPOP(lbl_arrow);
					push_resource(d5);
				}
				push_value(d4);
			}
			LPUSH(lbl_params);
			LPUSH(lbl_body);
			mw_ab_ctx_40__1();
			LPUSH(lbl_outer_ctx);
			mw_ab_type_40__1();
			LPUSH(lbl_dom);
			mw_ab_token_40__1();
			LPUSH(lbl_token);
			mtw_LAMBDA_1();
			mtw_OP_5F_LAMBDA_1();
			mw_ab_op_21__1();
			mtw__2B_SPSYNTH_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_OUTPUT_5F_BUFFER_5F_SIZE_1 (void) {
	push_i64(4096LL);
	mw__3E_Size_1();
}
static void mw__OUTPUT_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +OUTPUT
			mtp__2B_OUTPUT_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_start_21__1 (void) {
	push_i64(0LL);
	mw__3E_Size_1();
	mw_OUTPUT_5F_BUFFER_5F_SIZE_1();
	mw_new_2();
	mtw__2B_OUTPUT_1();
}
static void mw_end_21__1 (void) {
	mw_flush_21__1();
	mw__OUTPUT_1();
	mp_prim_drop();
	mw_rdrop_2();
}
static void mw_offset_40__1 (void) {
	mw_size_40__1();
	mw__3E_Offset_3();
}
static void mw_size_40__1 (void) {
	mw__OUTPUT_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mtw__2B_OUTPUT_1();
		push_value(d2);
	}
}
static void mw_size_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw__OUTPUT_1();
		mp_prim_drop();
		push_value(d2);
	}
	mtw__2B_OUTPUT_1();
}
static void mw_flush_21__1 (void) {
	mw__OUTPUT_1();
	{
		VAL d2 = pop_value();
		mp_prim_rswap();
		{
			VAL d3 = pop_resource();
			mw_buffer_base_1();
			push_resource(d3);
		}
		mp_prim_rswap();
		push_value(d2);
	}
	mtw__2B_OUTPUT_1();
	mw_size_40__1();
	mw__OUTPUT_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_resource();
			mw_unsafe_write_21__1();
			push_resource(d3);
		}
		push_value(d2);
	}
	mtw__2B_OUTPUT_1();
	push_i64(0LL);
	mw__3E_Size_1();
	mw_size_21__1();
}
static void mw_capacity_total_1 (void) {
	mw__OUTPUT_1();
	{
		VAL d2 = pop_value();
		mp_prim_rswap();
		{
			VAL d3 = pop_resource();
			mw_buffer_size_1();
			push_resource(d3);
		}
		mp_prim_rswap();
		push_value(d2);
	}
	mtw__2B_OUTPUT_1();
}
static void mw_capacity_remaining_1 (void) {
	mw_capacity_total_1();
	mw_size_40__1();
	mw___4();
}
static void mw_full_3F__1 (void) {
	mw_capacity_remaining_1();
	push_i64(0LL);
	mw__3E_Size_1();
	mw__3C__3D__5();
}
static void mw_put_2 (void) {
	mp_prim_dup();
	mw_num_bytes_1();
	mw_capacity_remaining_1();
	mw__3E__5();
	if (pop_u64()) {
		mw_flush_21__1();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mp_prim_str_base();
				push_value(d4);
			}
			mw_num_bytes_1();
			mw__OUTPUT_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_resource();
					mw_unsafe_write_21__1();
					push_resource(d5);
				}
				push_value(d4);
			}
			mtw__2B_OUTPUT_1();
			push_value(d3);
		}
		mp_prim_drop();
	} else {
		mp_prim_dup();
		mw_offset_40__1();
		mw__OUTPUT_1();
		{
			VAL d3 = pop_value();
			mp_prim_rswap();
			{
				VAL d4 = pop_resource();
				mw__21_Str_1();
				push_resource(d4);
			}
			mp_prim_rswap();
			push_value(d3);
		}
		mtw__2B_OUTPUT_1();
		mw_num_bytes_1();
		mw_size_40__1();
		mw__2B__4();
		mw_size_21__1();
	}
}
static void mw_put_byte_1 (void) {
	mw_full_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_flush_21__1();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_offset_40__1();
	mw__OUTPUT_1();
	{
		VAL d2 = pop_value();
		mp_prim_rswap();
		{
			VAL d3 = pop_resource();
			mw__21_Byte_2();
			push_resource(d3);
		}
		mp_prim_rswap();
		push_value(d2);
	}
	mtw__2B_OUTPUT_1();
	mw_size_40__1();
	mw_1_2B__4();
	mw_size_21__1();
}
static void mw_line_2 (void) {
	push_u64(10LL); // BLF
	mw_put_byte_1();
}
static void mw__SET_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +SET
			mtp__2B_SET_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_index_2 (void) {
	mw__SET_1();
	mp_prim_dup();
	{
		VAL d2 = pop_resource();
		{
			VAL d3 = pop_value();
			mp_prim_run();
			push_value(d3);
		}
		push_resource(d2);
	}
	mtw__2B_SET_1();
	mp_prim_dup();
	mw_0_3C__1();
	mw_not_1();
	if (pop_u64()) {
		mp_prim_id();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("negative index not allowed", 26);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	}
}
static void mw_SET_5F_INITIAL_5F_SIZE_1 (void) {
	push_i64(256LL);
	mw__3E_Size_1();
}
static void mw_rdrop_1 (void) {
	mw__SET_1();
	mp_prim_drop();
	mw_rdrop_2();
}
static void mw_offset_mask_1 (void) {
	mw_index_2();
	push_i64(8LL);
	mw__2F__25__1();
	mw_over_1();
	mw_prim_int_succ_1();
	mw__3E_Size_1();
	mw__SET_1();
	{
		VAL d2 = pop_value();
		mw_expand_21__1();
		push_value(d2);
	}
	mtw__2B_SET_1();
	{
		VAL d2 = pop_value();
		mw__3E_Offset_1();
		push_value(d2);
	}
	push_i64(1LL);
	mp_prim_swap();
	mp_prim_int_shl();
	mw__3E_U8_1();
}
static void mw_member_3F__1 (void) {
	mw_offset_mask_1();
	mw__SET_1();
	{
		VAL d2 = pop_value();
		mp_prim_swap();
		mw__40_U8_2();
		push_value(d2);
	}
	mtw__2B_SET_1();
	mw__26__5();
	mw__3E_Int_7();
	push_i64(0LL);
	mw__3C__3E__1();
}
static void mw_insert_21__1 (void) {
	mw_offset_mask_1();
	mw__SET_1();
	{
		VAL d2 = pop_value();
		mw_over_1();
		mw__40_U8_2();
		mw__7C__5();
		mp_prim_swap();
		mw__21_U8_2();
		push_value(d2);
	}
	mtw__2B_SET_1();
}
static void mw__3E_Int_16 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // NEED_WORD
			mtp_NEED_5F_WORD_1();
			mw_index_3();
			push_i64(4LL);
			mp_prim_int_mul();
			break;
		case 1LL: // NEED_BLOCK
			mtp_NEED_5F_BLOCK_1();
			mw_index_19();
			push_i64(4LL);
			mp_prim_int_mul();
			push_i64(1LL);
			mp_prim_int_add();
			break;
		case 2LL: // NEED_TAGW
			mtp_NEED_5F_TAGW_1();
			mw_index_17();
			push_i64(4LL);
			mp_prim_int_mul();
			push_i64(2LL);
			mp_prim_int_add();
			break;
		case 3LL: // NEED_TAGP
			mtp_NEED_5F_TAGP_1();
			mw_index_17();
			push_i64(4LL);
			mp_prim_int_mul();
			push_i64(3LL);
			mp_prim_int_add();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__NEEDS_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // +NEEDS
			mtp__2B_NEEDS_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_new_3 (void) {
	push_u64(0LL); // STACK_NIL
	push_fnptr(&mb_741);
	mw_SET_5F_INITIAL_5F_SIZE_1();
	mw_new_2();
	mtw__2B_SET_1();
	mtw__2B_NEEDS_1();
}
static void mw_rdrop_3 (void) {
	mw__NEEDS_1();
	mw_rdrop_1();
	mp_prim_drop();
}
static void mw_needed_3F__2 (void) {
	mw__NEEDS_1();
	{
		VAL d2 = pop_value();
		mw_member_3F__1();
		push_value(d2);
	}
	mtw__2B_NEEDS_1();
}
static void mw_needed_3F__1 (void) {
	mtw_NEED_5F_WORD_1();
	mw_needed_3F__2();
}
static void mw_needed_3F__3 (void) {
	mtw_NEED_5F_BLOCK_1();
	mw_needed_3F__2();
}
static void mw_word_needed_3F__1 (void) {
	mtw_NEED_5F_TAGW_1();
	mw_needed_3F__2();
}
static void mw_pat_needed_3F__1 (void) {
	mtw_NEED_5F_TAGP_1();
	mw_needed_3F__2();
}
static void mw_need_21__1 (void) {
	mp_prim_dup();
	mw_needed_3F__2();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_dup();
			mw__NEEDS_1();
			{
				VAL d4 = pop_value();
				mw_insert_21__1();
				push_value(d4);
			}
			mtw__2B_NEEDS_1();
			mp_prim_dup();
			mw__NEEDS_1();
			{
				VAL d4 = pop_resource();
				mtw_STACK_5F_CONS_1();
				push_resource(d4);
			}
			mtw__2B_NEEDS_1();
			mp_prim_dup();
			mw_needed_3F__2();
			if (pop_u64()) {
				mp_prim_id();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("needed? fail", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_panic();
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_drop();
}
static void mw_need_word_21__1 (void) {
	mtw_NEED_5F_WORD_1();
	mw_need_21__1();
}
static void mw_need_block_21__1 (void) {
	mtw_NEED_5F_BLOCK_1();
	mw_need_21__1();
}
static void mw_need_tag_word_21__1 (void) {
	mtw_NEED_5F_TAGW_1();
	mw_need_21__1();
}
static void mw_need_tag_pat_21__1 (void) {
	mtw_NEED_5F_TAGP_1();
	mw_need_21__1();
}
static void mw_determine_arrow_needs_21__1 (void) {
	mw_run_arrow_21__1();
	mw_determine_transitive_needs_21__1();
}
static void mw_determine_transitive_needs_21__1 (void) {
	mw__NEEDS_1();
	{
		VAL d2 = pop_resource();
		mw_uncons_1();
		push_resource(d2);
	}
	mtw__2B_NEEDS_1();
	while(1) {
		mp_prim_dup();
		mw_some_3F__1();
		if (! pop_u64()) break;
		mw_unwrap_1();
		mw_run_need_21__1();
		mw__NEEDS_1();
		{
			VAL d3 = pop_resource();
			mw_uncons_1();
			push_resource(d3);
		}
		mtw__2B_NEEDS_1();
	}
	mp_prim_drop();
}
static void mw_run_need_21__1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: // NEED_BLOCK
			mtp_NEED_5F_BLOCK_1();
			mw_run_block_21__1();
			break;
		case 0LL: // NEED_WORD
			mtp_NEED_5F_WORD_1();
			mw_run_word_21__1();
			break;
		case 2LL: // NEED_TAGW
			mtp_NEED_5F_TAGW_1();
			mp_prim_drop();
			break;
		case 3LL: // NEED_TAGP
			mtp_NEED_5F_TAGP_1();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_run_arg_21__1 (void) {
	mw_run_block_21__1();
}
static void mw_run_block_21__1 (void) {
	mw_arrow_5();
	mw_run_arrow_21__1();
}
static void mw_run_word_21__1 (void) {
	mw_arrow_2();
	mw_run_arrow_21__1();
}
static void mw_run_arrow_21__1 (void) {
	mw_atoms_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_run_atom_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_run_atom_21__1();
				push_value(d4);
			}
			mw_run_atom_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_run_atom_21__1();
					push_value(d5);
				}
				mw_run_atom_21__1();
				push_value(d4);
			}
			mw_run_atom_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2273();
				push_value(d4);
			}
			mw_for_3_2273();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_run_atom_21__1 (void) {
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_args_4();
		push_value(d2);
	}
	mw_op_4();
	mw_run_op_21__1();
}
static void mw_run_op_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // OP_NONE
			(void)pop_u64();
			mp_prim_drop();
			break;
		case 7LL: // OP_INT
			mtp_OP_5F_INT_1();
			mw_drop2_1();
			break;
		case 8LL: // OP_STR
			mtp_OP_5F_STR_1();
			mw_drop2_1();
			break;
		case 2LL: // OP_WORD
			mtp_OP_5F_WORD_1();
			mp_prim_dup();
			mw_prefer_inline_3F__1();
			if (pop_u64()) {
				mw_run_word_21__1();
			} else {
				mw_need_word_21__1();
			}
			mw_push_args_21__1();
			break;
		case 3LL: // OP_EXTERNAL
			mtp_OP_5F_EXTERNAL_1();
			mp_prim_drop();
			mw_push_args_21__1();
			break;
		case 4LL: // OP_BUFFER
			mtp_OP_5F_BUFFER_1();
			mp_prim_drop();
			mw_push_args_21__1();
			break;
		case 5LL: // OP_VARIABLE
			mtp_OP_5F_VARIABLE_1();
			mp_prim_drop();
			mw_push_args_21__1();
			break;
		case 6LL: // OP_FIELD
			mtp_OP_5F_FIELD_1();
			mp_prim_drop();
			mw_push_args_21__1();
			break;
		case 9LL: // OP_TAG
			mtp_OP_5F_TAG_1();
			mw_need_tag_word_21__1();
			mw_push_args_21__1();
			break;
		case 1LL: // OP_PRIM
			mtp_OP_5F_PRIM_1();
			mw_run_prim_21__1();
			break;
		case 10LL: // OP_MATCH
			mtp_OP_5F_MATCH_1();
			mw_nip_1();
			mw_run_match_21__1();
			break;
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mw_nip_1();
			mw_run_lambda_21__1();
			break;
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mw_drop2_1();
			break;
		case 13LL: // OP_BLOCK
			mtp_OP_5F_BLOCK_1();
			mw_nip_1();
			mw_push_block_21__1();
			break;
		case 14LL: // OP_RUN
			mtp_OP_5F_RUN_1();
			mw_nip_1();
			mw_run_block_21__1();
			break;
		case 15LL: // OP_COERCE
			mtp_OP_5F_COERCE_1();
			mw_drop2_1();
			break;
		case 16LL: // OP_LABEL_PUSH
			mtp_OP_5F_LABEL_5F_PUSH_1();
			mw_drop2_1();
			break;
		case 17LL: // OP_LABEL_POP
			mtp_OP_5F_LABEL_5F_POP_1();
			mw_drop2_1();
			break;
		case 18LL: // OP_DATA_GET_LABEL
			mtp_OP_5F_DATA_5F_GET_5F_LABEL_1();
			mw_drop3_1();
			break;
		case 19LL: // OP_DATA_SET_LABEL
			mtp_OP_5F_DATA_5F_SET_5F_LABEL_1();
			mw_drop3_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_run_prim_21__1 (void) {
	switch (get_top_data_tag()) {
		case 4LL: // PRIM_CORE_DIP
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 1LL: // L1
					mtp_L1_1();
					mw_run_arg_21__1();
					break;
				default:
					mw_push_args_21__1();
					break;
			}
			break;
		case 13LL: // PRIM_CORE_RDIP
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 1LL: // L1
					mtp_L1_1();
					mw_run_arg_21__1();
					break;
				default:
					mw_push_args_21__1();
					break;
			}
			break;
		case 5LL: // PRIM_CORE_IF
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw_run_arg_21__1();
						push_value(d6);
					}
					mw_run_arg_21__1();
					break;
				default:
					mw_push_args_21__1();
					break;
			}
			break;
		case 6LL: // PRIM_CORE_WHILE
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 2LL: // L2
					mtp_L2_1();
					{
						VAL d6 = pop_value();
						mw_run_arg_21__1();
						push_value(d6);
					}
					mw_run_arg_21__1();
					break;
				default:
					mw_push_args_21__1();
					break;
			}
			break;
		default:
			mp_prim_drop();
			mw_push_args_21__1();
			break;
	}
}
static void mw_run_match_21__1 (void) {
	mw_cases_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_run_case_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_run_case_21__1();
				push_value(d4);
			}
			mw_run_case_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_run_case_21__1();
					push_value(d5);
				}
				mw_run_case_21__1();
				push_value(d4);
			}
			mw_run_case_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2283();
				push_value(d4);
			}
			mw_for_3_2283();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_run_case_21__1 (void) {
	mp_prim_dup();
	mw_pattern_4();
	mw_run_pattern_21__1();
	mw_body_5();
	mw_run_arrow_21__1();
}
static void mw_run_lambda_21__1 (void) {
	mw_body_9();
	mw_run_arrow_21__1();
}
static void mw_run_pattern_21__1 (void) {
	mw_atoms_2();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_run_patatom_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_run_patatom_21__1();
				push_value(d4);
			}
			mw_run_patatom_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_run_patatom_21__1();
					push_value(d5);
				}
				mw_run_patatom_21__1();
				push_value(d4);
			}
			mw_run_patatom_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2284();
				push_value(d4);
			}
			mw_for_3_2284();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_run_patatom_21__1 (void) {
	mw_op_2();
	switch (get_top_data_tag()) {
		case 0LL: // PATOP_UNDERSCORE
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // PATOP_TAG
			mtp_PATOP_5F_TAG_1();
			mw_need_tag_pat_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_push_args_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_push_arg_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_push_arg_21__1();
				push_value(d4);
			}
			mw_push_arg_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_push_arg_21__1();
					push_value(d5);
				}
				mw_push_arg_21__1();
				push_value(d4);
			}
			mw_push_arg_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2280();
				push_value(d4);
			}
			mw_for_3_2280();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_push_arg_21__1 (void) {
	mw_push_block_21__1();
}
static void mw_push_block_21__1 (void) {
	mp_prim_dup();
	mw_to_run_var_3();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_drop2_1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_need_block_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_as_relative_path_1 (void) {
}
static void mw__3E_Bool_2 (void) {
	mp_prim_id();
}
static void mw_make_1 (void) {
	LPOP(lbl_output_path);
	LPOP(lbl_emit_debug_info);
	mtw_C99_5F_OPTIONS_1();
}
static void mw_emit_debug_info_3 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // C99_OPTIONS
			mtp_C99_5F_OPTIONS_1();
			mw_nip_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_output_path_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // C99_OPTIONS
			mtp_C99_5F_OPTIONS_1();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw__2F_MKC99_1 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: // MKC99
			mtp_MKC99_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_depth_40__1 (void) {
	mw__2F_MKC99_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mtw_MKC99_1();
		push_value(d2);
	}
}
static void mw_depth_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw__2F_MKC99_1();
		mp_prim_drop();
		push_value(d2);
	}
	mtw_MKC99_1();
}
static void mw_options_40__1 (void) {
	mw__2F_MKC99_1();
	mw_over_1();
	{
		VAL d2 = pop_value();
		mtw_MKC99_1();
		push_value(d2);
	}
}
static void mw_emit_debug_info_3F__1 (void) {
	mw_options_40__1();
	mw_emit_debug_info_3();
	mw__3E_Bool_2();
}
static void mw_put_3 (void) {
	mw__2F_MKC99_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_rswap();
			{
				VAL d4 = pop_resource();
				mw_put_2();
				push_resource(d4);
			}
			mp_prim_rswap();
			push_value(d3);
		}
		push_value(d2);
	}
	mtw_MKC99_1();
}
static void mw_put_byte_2 (void) {
	mw__2F_MKC99_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_rswap();
			{
				VAL d4 = pop_resource();
				mw_put_byte_1();
				push_resource(d4);
			}
			mp_prim_rswap();
			push_value(d3);
		}
		push_value(d2);
	}
	mtw_MKC99_1();
}
static void mw_line_3 (void) {
	mw__2F_MKC99_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_rswap();
			{
				VAL d4 = pop_resource();
				mw_line_2();
				push_resource(d4);
			}
			mp_prim_rswap();
			push_value(d3);
		}
		push_value(d2);
	}
	mtw_MKC99_1();
}
static void mw_c99_start_21__1 (void) {
	mp_prim_dup();
	mw_output_path_1();
	mw_as_relative_path_1();
	mw_create_file_21__1();
	mw_start_21__1();
	{
		VAL d2 = pop_resource();
		mw_new_3();
		mw_over_1();
		mw_determine_arrow_needs_21__1();
		push_resource(d2);
	}
	push_i64(0LL);
	mw__3E_Nat_1();
	mtw_MKC99_1();
}
static void mw_c99_end_21__1 (void) {
	mw__2F_MKC99_1();
	mw_drop2_1();
	{
		VAL d2 = pop_resource();
		mw_rdrop_3();
		push_resource(d2);
	}
	mw_end_21__1();
	mw_close_file_21__1();
}
static void mw_run_output_c99_21__1 (void) {
	mvar_num_errors_1();
	mp_prim_mut_get();
	mw_0_3E__1();
	if (pop_u64()) {
		mw_drop2_1();
	} else {
		mw_c99_start_21__1();
		mw_c99_header_21__1();
		mw_c99_label_defs_21__1();
		mw_c99_tag_defs_21__1();
		mw_c99_buffers_21__1();
		mw_c99_variables_21__1();
		mw_c99_externals_21__1();
		mw_c99_word_sigs_21__1();
		mw_c99_block_sigs_21__1();
		mw_c99_field_sigs_21__1();
		mw_c99_main_21__1();
		mw_c99_field_defs_21__1();
		mw_c99_word_defs_21__1();
		mw_c99_block_defs_21__1();
		mw_c99_end_21__1();
	}
}
static void mw_cname_7 (void) {
	mp_prim_dup();
	mfld__7E_cname_7();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mb_", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_index_19();
			mw_show_1();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_word_cname_1 (void) {
	mp_prim_dup();
	mfld__7E_word_cname_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mtw_", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_17();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_TAG_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_pat_cname_1 (void) {
	mp_prim_dup();
	mfld__7E_pat_cname_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mtp_", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_17();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_TAG_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_cname_6 (void) {
	mp_prim_dup();
	mfld__7E_cname_6();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mbuf_", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_18();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_BUFFER_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_cname_2 (void) {
	mp_prim_dup();
	mfld__7E_cname_2();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mvar_", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_3();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_VARIABLE_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_cname_3 (void) {
	mp_prim_dup();
	mfld__7E_cname_3();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mfld_", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_7();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_FIELD_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_cname_5 (void) {
	mp_prim_dup();
	mfld__7E_cname_5();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mext_", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_15();
			mw_mangled_1();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mtw_DEF_5F_EXTERNAL_1();
			mw_def_index_1();
			mw_show_2();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_cname_4 (void) {
	mp_prim_dup();
	mfld__7E_cname_4();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("", 0);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_thaw_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("mp_", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mp_prim_dup();
			mw_name_9();
			mw_mangled_1();
			mw__3B__1();
			mw_freeze_1();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_sig_put_1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("static void ", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" (void)", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
}
static void mw_c99_header_str_1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(
				"/* MIRTH HEADER */\n"
				"// #line 3 \"src/mirth/mirth.h\"\n"
				"\n"
				"#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n"
				"#define MIRTH_WINDOWS 1\n"
				"#elif defined(__linux__)\n"
				"#define MIRTH_LINUX 1\n"
				"#elif defined(__APPLE__)\n"
				"#define MIRTH_MACOS 1\n"
				"#else\n"
				"#error \"Platform not supported.\"\n"
				"#endif\n"
				"\n"
				"#include <stdint.h>\n"
				"#include <stdbool.h>\n"
				"#include <stddef.h>\n"
				"\n"
				"extern void* malloc(size_t);\n"
				"extern void* calloc(size_t, size_t);\n"
				"extern void* realloc(void*, size_t);\n"
				"extern void* memset(void*, int, size_t);\n"
				"extern void* memcpy(void*, const void*, size_t);\n"
				"extern int memcmp(const void*, const void*, size_t);\n"
				"extern int strcmp(const char*, const char*);\n"
				"extern size_t strlen(const char*);\n"
				"extern void free(void*);\n"
				"extern int read(int, void*, size_t);\n"
				"extern int write(int, const char*, size_t);\n"
				"extern int close(int);\n"
				"extern int open(const char*, int, int);\n"
				"extern void exit(int);\n"
				"\n"
				"typedef uint16_t TAG;\n"
				"#define REFS_FLAG \t 0x8000\n"
				"#define TUP_FLAG \t 0x4000\n"
				"#define TUP_LEN_MASK 0x3FFF\n"
				"#define TUP_LEN_MAX  0x3FFF\n"
				"\n"
				"#define TAG_INT 1\n"
				"#define TAG_PTR 1\n"
				"#define TAG_STR (2 | REFS_FLAG)\n"
				"#define TAG_FNPTR 3\n"
				"#define TAG_TUP_NIL TUP_FLAG\n"
				"#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)\n"
				"#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (n))\n"
				"\n"
				"typedef uint32_t REFS;\n"
				"typedef uint64_t USIZE;\n"
				"typedef void (*FNPTR)(void);\n"
				"\n"
				"typedef union DATA {\n"
				"\tUSIZE usize;\n"
				"\tuint64_t u64;\n"
				"\tuint32_t u32;\n"
				"\tuint16_t u16;\n"
				"\tuint8_t u8;\n"
				"\tint64_t i64;\n"
				"\tint32_t i32;\n"
				"\tint16_t i16;\n"
				"\tint8_t i8;\n"
				"\tvoid* ptr;\n"
				"\tFNPTR fnptr;\n"
				"\tREFS* refs;\n"
				"\tstruct TUP* tup;\n"
				"\tstruct STR* str;\n"
				"} DATA;\n"
				"\n"
				"typedef struct VAL {\n"
				"\tDATA data;\n"
				"\tTAG tag;\n"
				"} VAL;\n"
				"\n"
				"#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))\n"
				"\n"
				"#define VREFS(v)  (*(v).data.refs)\n"
				"#define VINT(v)   ((v).data.i64)\n"
				"#define VI64(v)   ((v).data.i64)\n"
				"#define VU64(v)   ((v).data.u64)\n"
				"#define VPTR(v)   ((v).data.ptr)\n"
				"#define VFNPTR(v) ((v).data.fnptr)\n"
				"#define VSTR(v)   ((v).data.str)\n"
				"#define VTUP(v)   ((v).data.tup)\n"
				"#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))\n"
				"\n"
				"#define HAS_REFS(v) ((v).tag & REFS_FLAG)\n"
				"#define IS_INT(v)   ((v).tag == TAG_INT)\n"
				"#define IS_U64(v)   ((v).tag == TAG_INT)\n"
				"#define IS_I64(v)   ((v).tag == TAG_INT)\n"
				"#define IS_PTR(v)   ((v).tag == TAG_PTR)\n"
				"#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)\n"
				"#define IS_STR(v)   ((v).tag == TAG_STR)\n"
				"#define IS_TUP(v)   ((v).tag & TUP_FLAG)\n"
				"#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))\n"
				"\n"
				"#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
				"#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
				"#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
				"#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})\n"
				"#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})\n"
				"#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})\n"
				"#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})\n"
				"#define MKNIL_C\t         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}\n"
				"#define MKNIL      ((VAL)MKNIL_C)\n"
				"\n"
				"typedef uint16_t TUPLEN;\n"
				"typedef struct TUP {\n"
				"\tREFS refs;\n"
				"\tTUPLEN cap;\n"
				"\tTUPLEN size;\n"
				"\tVAL cells[];\n"
				"} TUP;\n"
				"\n"
				"typedef struct STR {\n"
				"\tREFS refs;\n"
				"\tUSIZE cap;\n"
				"\tUSIZE size;\n"
				"\tchar data[];\n"
				"} STR;\n"
				"\n"
				"#define STACK_MAX 0x80000\n"
				"static USIZE stack_counter = STACK_MAX;\n"
				"static VAL stack [STACK_MAX] = {0};\n"
				"static USIZE rstack_counter = STACK_MAX;\n"
				"static VAL rstack [STACK_MAX] = {0};\n"
				"\n"
				"static int global_argc;\n"
				"static char** global_argv;\n"
				"\n"
				"static void push_value(VAL v);\n"
				"static void mp_prim_debug(void);\n"
				"static void mp_prim_rdebug(void);\n"
				"\n"
				"#if MIRTH_DEBUG\n"
				"\ttypedef struct LOC {\n"
				"\t\tFNPTR fnptr;\n"
				"\t\tconst char* word;\n"
				"\t\tconst char* path;\n"
				"\t\tUSIZE line, col;\n"
				"\t\tconst char* atom;\n"
				"\t} LOC;\n"
				"\tstatic USIZE fstack_counter = 0;\n"
				"\tstatic LOC fstack [STACK_MAX] = {\n"
				"\t\t{\n"
				"\t\t\t.fnptr=(void(*)(void))0,\n"
				"\t\t\t.word=\"<word>\",\n"
				"\t\t\t.path=\"<path>\",\n"
				"\t\t\t.line=0, .col=0,\n"
				"\t\t\t.atom=\"<atom>\"\n"
				"\t\t},\n"
				"\t};\n"
				"\n"
				"\t#define WORD_ENTER(_f,_w,_p,_l,_c) \\\n"
				"\t\tdo { \\\n"
				"\t\t\tfstack[fstack_counter].fnptr = (_f); \\\n"
				"\t\t\tfstack[fstack_counter].word = (_w); \\\n"
				"\t\t\tfstack[fstack_counter].path = (_p); \\\n"
				"\t\t\tfstack[fstack_counter].line = (_l); \\\n"
				"\t\t\tfstack[fstack_counter].col = (_c); \\\n"
				"\t\t\tfstack[fstack_counter].atom = \"\"; \\\n"
				"\t\t\tfstack_counter++; \\\n"
				"\t\t} while(0)\n"
				"\n"
				"\t#define WORD_ATOM(_l,_c,_n) \\\n"
				"\t\tdo { \\\n"
				"\t\t\tif (fstack_counter > 0) { \\\n"
				"\t\t\t\tfstack[fstack_counter-1].line = (_l); \\\n"
				"\t\t\t\tfstack[fstack_counter-1].col = (_c); \\\n"
				"\t\t\t\tfstack[fstack_counter-1].atom = (_n); \\\n"
				"\t\t\t} \\\n"
				"\t\t} while(0)\n"
				"\n"
				"\t#define WORD_EXIT(_f) \\\n"
				"\t\tdo { \\\n"
				"\t\t\tif ((fstack_counter == 0) || (fstack[fstack_counter-1].fnptr != (_f))) { \\\n"
				"\t\t\t\tTRACE(\"mismatched WORD_EXIT, expected \" #_f \"\\n\"); \\\n"
				"\t\t\t\texit(1); \\\n"
				"\t\t\t} \\\n"
				"\t\t\tfstack_counter--; \\\n"
				"\t\t} while(0)\n"
				"\t#define PRIM_ENTER(_f,_w) WORD_ENTER(_f,_w,__FILE__,__LINE__,1)\n"
				"\t#define PRIM_EXIT(_f) WORD_EXIT(_f)\n"
				"#else\n"
				"\t#define PRIM_ENTER(_f,_w)\n"
				"\t#define PRIM_EXIT(_f)\n"
				"#endif\n"
				"\n"
				"#define TRACE(x) write(2,x,strlen(x))\n"
				"#define _STR(x) #x\n"
				"#define STR(x) _STR(x)\n"
				"\n"
				"#define EXPECT(test,msg) \\\n"
				"\tdo { \\\n"
				"\t\tif (!(test)) { \\\n"
				"\t\t\tTRACE(msg \"\\n\"); \\\n"
				"\t\t\tmp_prim_debug(); \\\n"
				"\t\t\tmp_prim_rdebug(); \\\n"
				"\t\t\texit(1); \\\n"
				"\t\t} \\\n"
				"\t} while(0)\n"
				"\n"
				"#define EXPECT1(test,msg,v1) \\\n"
				"\tdo { \\\n"
				"\t\tif (!(test)) { \\\n"
				"\t\t\tTRACE(msg \"\\n\"); \\\n"
				"\t\t\tpush_value(v1); \\\n"
				"\t\t\tmp_prim_debug(); \\\n"
				"\t\t\tmp_prim_rdebug(); \\\n"
				"\t\t\texit(1); \\\n"
				"\t\t} \\\n"
				"\t} while(0)\n"
				"\n"
				"#define EXPECT2(test,msg,v1,v2) \\\n"
				"\tdo { \\\n"
				"\t\tif (!(test)) { \\\n"
				"\t\t\tTRACE(msg \"\\n\"); \\\n"
				"\t\t\tpush_value(v1); \\\n"
				"\t\t\tpush_value(v2); \\\n"
				"\t\t\tmp_prim_debug(); \\\n"
				"\t\t\tmp_prim_rdebug(); \\\n"
				"\t\t\texit(1); \\\n"
				"\t\t} \\\n"
				"\t} while(0)\n"
				"\n"
				"#define ASSERT(test) \\\n"
				"\tEXPECT(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\")\n"
				"#define ASSERT1(test,v) \\\n"
				"\tEXPECT1(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v)\n"
				"#define ASSERT2(test,v1,v2) \\\n"
				"\tEXPECT2(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v1, v2)\n"
				"\n"
				"#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)\n"
				"#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)\n"
				"static void free_value(VAL v) {\n"
				"\tASSERT(HAS_REFS(v));\n"
				"\tASSERT(VREFS(v) == 0);\n"
				"\tASSERT1(IS_TUP(v)||IS_STR(v), v);\n"
				"\tif (IS_TUP(v)) {\n"
				"\t\tTUP* tup = VTUP(v);\n"
				"\t\tASSERT(tup);\n"
				"\t\tfor (TUPLEN i = 0; i < tup->size; i++) {\n"
				"\t\t\tdecref(tup->cells[i]);\n"
				"\t\t}\n"
				"\t\tfree(tup);\n"
				"\t} else if (IS_STR(v)) {\n"
				"\t\tSTR* str = VSTR(v);\n"
				"\t\tASSERT(str);\n"
				"\t\tfree(str);\n"
				"\t}\n"
				"}\n"
				"\n"
				"static void value_uncons(VAL val, VAL* tail, VAL* head) {\n"
				"\tif (IS_TUP(val)) {\n"
				"\t\tTUPLEN len = VTUPLEN(val);\n"
				"\t\tTUP* tup = VTUP(val);\n"
				"\t\tASSERT1((len > 0) && tup, val);\n"
				"\t\tVAL tailval = MKTUP(tup, len-1);\n"
				"\t\tVAL headval = tup->cells[len-1];\n"
				"\t\tif (len == 1) {\n"
				"\t\t\tincref(headval);\n"
				"\t\t\tdecref(val);\n"
				"\t\t\ttailval = MKNIL;\n"
				"\t\t} else {\n"
				"\t\t\tif (tup->refs == 1) {\n"
				"\t\t\t\tfor (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }\n"
				"\t\t\t\tmemset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));\n"
				"\t\t\t\ttup->size = len-1;\n"
				"\t\t\t} else {\n"
				"\t\t\t\tincref(headval);\n"
				"\t\t\t}\n"
				"\t\t\tif (len == 2) {\n"
				"\t\t\t\tVAL ptval = tup->cells[0];\n"
				"\t\t\t\tif (!IS_TUP(ptval)) {\n"
				"\t\t\t\t\tincref(ptval);\n"
				"\t\t\t\t\tdecref(tailval);\n"
				"\t\t\t\t\ttailval = ptval;\n"
				"\t\t\t\t}\n"
				"\t\t\t}\n"
				"\t\t}\n"
				"\t\t*tail = tailval;\n"
				"\t\t*head = headval;\n"
				"\t} else {\n"
				"\t\t*tail = MKNIL;\n"
				"\t\t*head = val;\n"
				"\t}\n"
				"}\n"
				"\n"
				"static uint64_t value_u64 (VAL v) {\n"
				"\tASSERT1(IS_INT(v),v);\n"
				"\treturn VU64(v);\n"
				"}\n"
				"\n"
				"static int64_t value_i64 (VAL v) {\n"
				"\tASSERT1(IS_INT(v),v);\n"
				"\treturn VI64(v);\n"
				"}\n"
				"\n"
				"static void* value_ptr (VAL v) {\n"
				"\tASSERT1(IS_PTR(v),v);\n"
				"\treturn VPTR(v);\n"
				"}\n"
				"\n"
				"static FNPTR value_fnptr (VAL v) {\n"
				"\tASSERT1(IS_FNPTR(v),v);\n"
				"\treturn VFNPTR(v);\n"
				"}\n"
				"\n"
				"#define pop_u8() ((uint8_t)pop_u64())\n"
				"#define pop_u16() ((uint16_t)pop_u64())\n"
				"#define pop_u32() ((uint32_t)pop_u64())\n"
				"#define pop_u64() (value_u64(pop_value()))\n"
				"#define pop_i8() ((int8_t)pop_i64())\n"
				"#define pop_i16() ((int16_t)pop_i64())\n"
				"#define pop_i32() ((int32_t)pop_i64())\n"
				"#define pop_i64() (value_i64(pop_value()))\n"
				"#define pop_usize() (pop_u64())\n"
				"#define pop_bool() (pop_u64())\n"
				"#define pop_ptr() (value_ptr(pop_value()))\n"
				"#define pop_fnptr() (value_fnptr(pop_value()))\n"
				"\n"
				"#define push_u64(v) push_value(MKU64(v))\n"
				"#define push_i64(v) push_value(MKI64(v))\n"
				"#define push_usize(v) push_u64((uint64_t)(v))\n"
				"#define push_bool(b) push_u64((uint64_t)((bool)(b)))\n"
				"#define push_u8(b) push_u64((uint64_t)(b))\n"
				"#define push_u16(b) push_u64((uint64_t)(b))\n"
				"#define push_u32(b) push_u64((uint64_t)(b))\n"
				"#define push_i8(b) push_i64((int64_t)(b))\n"
				"#define push_i16(b) push_i64((int64_t)(b))\n"
				"#define push_i32(b) push_i64((int64_t)(b))\n"
				"#define push_ptr(p) push_value(MKPTR(p))\n"
				"#define push_fnptr(p) push_value(MKFNPTR(p))\n"
				"\n"
				"static void push_value(VAL x) {\n"
				"\tASSERT(stack_counter > 0);\n"
				"\tstack[--stack_counter] = x;\n"
				"}\n"
				"\n"
				"static VAL top_value(void) {\n"
				"\tASSERT(stack_counter < STACK_MAX);\n"
				"\treturn stack[stack_counter];\n"
				"}\n"
				"\n"
				"static VAL pop_value(void) {\n"
				"\tASSERT(stack_counter < STACK_MAX);\n"
				"\treturn stack[stack_counter++];\n"
				"}\n"
				"\n"
				"static void push_resource(VAL x) {\n"
				"\tASSERT(rstack_counter > 0);\n"
				"\trstack[--rstack_counter] = x;\n"
				"}\n"
				"\n"
				"static VAL top_resource(void) {\n"
				"\tASSERT(rstack_counter < STACK_MAX);\n"
				"\treturn rstack[rstack_counter];\n"
				"}\n"
				"\n"
				"static VAL pop_resource(void) {\n"
				"\tASSERT(rstack_counter < STACK_MAX);\n"
				"\treturn rstack[rstack_counter++];\n"
				"}\n"
				"\n"
				"// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.\n"
				"static TUP* tup_new (TUPLEN cap_hint) {\n"
				"\tif (cap_hint < 3) cap_hint = 3;\n"
				"\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
				"\tTUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
				"\tASSERT(new_tup);\n"
				"\tnew_tup->refs = 1;\n"
				"\tnew_tup->cap = cap_hint;\n"
				"\treturn new_tup;\n"
				"}\n"
				"\n"
				"// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.\n"
				"// Consume old_tup and copy its elements over to the new tuple.\n"
				"static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {\n"
				"\tASSERT(old_tup);\n"
				"\tif (cap_hint < old_tup->size) cap_hint = old_tup->size;\n"
				"\tif (old_tup->refs == 1) {\n"
				"\t\tif (cap_hint < 3) cap_hint = 3;\n"
				"\t\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
				"\t\tTUPLEN old_cap = old_tup->cap;\n"
				"\t\tTUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
				"\t\tASSERT(new_tup);\n"
				"\t\tif (old_cap < cap_hint) {\n"
				"\t\t\tmemset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));\n"
				"\t\t}\n"
				"\t\tnew_tup->cap = cap_hint;\n"
				"\t\treturn new_tup;\n"
				"\t} else {\n"
				"\t\tTUP* new_tup = tup_new(cap_hint);\n"
				"\t\tfor (TUPLEN i = 0; i < old_tup->size; i++) {\n"
				"\t\t\tVAL v = old_tup->cells[i];\n"
				"\t\t\tnew_tup->cells[i] = v;\n"
				"\t\t\tincref(v);\n"
				"\t\t}\n"
				"\t\tnew_tup->size = old_tup->size;\n"
				"\t\told_tup->refs--;\n"
				"\t\treturn new_tup;\n"
				"\t}\n"
				"}\n"
				"\n"
				"static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {\n"
				"\tif (IS_TUP(tail) && HAS_REFS(tail)) {\n"
				"\t\tTUPLEN tail_len = VTUPLEN(tail);\n"
				"\t\tTUP *tail_tup = VTUP(tail);\n"
				"\t\tASSERT1(tail_tup, tail);\n"
				"\t\tASSERT1(tail_len <= tail_tup->size, tail);\n"
				"\t\tif (tail_len < tail_tup->size) {\n"
				"\t\t\tASSERT1(tail_tup->refs >= 1, tail);\n"
				"\t\t\tif (tail_tup->refs == 1) {\n"
				"\t\t\t\tdecref(tail_tup->cells[tail_len]);\n"
				"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
				"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
				"\t\t\t} else {\n"
				"\t\t\t\tVAL *cmp = &tail_tup->cells[tail_len];\n"
				"\t\t\t\tif (VALEQ(*cmp, head)) {\n"
				"\t\t\t\t\tdecref(head);\n"
				"\t\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
				"\t\t\t\t} else {\n"
				"\t\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
				"\t\t\t\t\tTUP* new_tup = tup_new(cap_hint);\n"
				"\t\t\t\t\tfor (TUPLEN i = 0; i < tail_len; i++) {\n"
				"\t\t\t\t\t\tVAL v = tail_tup->cells[i];\n"
				"\t\t\t\t\t\tnew_tup->cells[i] = v;\n"
				"\t\t\t\t\t\tincref(v);\n"
				"\t\t\t\t\t}\n"
				"\t\t\t\t\tnew_tup->cells[tail_len] = head;\n"
				"\t\t\t\t\tnew_tup->size = tail_len+1;\n"
				"\t\t\t\t\ttail_tup->refs--;\n"
				"\t\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
				"\t\t\t\t}\n"
				"\t\t\t}\n"
				"\t\t} else {\n"
				"\t\t\tASSERT1(tail_len < TUP_LEN_MAX, tail);\n"
				"\t\t\tASSERT1(tail_len <= tail_tup->cap, tail);\n"
				"\t\t\tif (tail_len < tail_tup->cap) {\n"
				"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
				"\t\t\t\ttail_tup->size = tail_len+1;\n"
				"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
				"\t\t\t} else {\n"
				"\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
				"\t\t\t\tTUP* new_tup = tup_resize(tail_tup, cap_hint);\n"
				"\t\t\t\tASSERT(tail_len < new_tup->cap);\n"
				"\t\t\t\tnew_tup->size = tail_len+1;\n"
				"\t\t\t\tnew_tup->cells[tail_len] = head;\n"
				"\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
				"\t\t\t}\n"
				"\t\t}\n"
				"\t} else if (IS_TUP(tail)) { // cons onto nil\n"
				"\t\tASSERT(IS_NIL(tail));\n"
				"\t\tif (IS_TUP(head)) {\n"
				"\t\t\tTUP* tup = tup_new(cap_hint);\n"
				"\t\t\ttup->size = 1;\n"
				"\t\t\ttup->cells[0] = head;\n"
				"\t\t\treturn MKTUP(tup,1);\n"
				"\t\t} else { // non-tup value pretends to be unary tuple\n"
				"\t\t\treturn head;\n"
				"\t\t}\n"
				"\t} else { // cons onto non-tup value pretending to be unary tuple\n"
				"\t\tTUP* tup = tup_new(cap_hint);\n"
				"\t\ttup->size = 2;\n"
				"\t\ttup->cells[0] = tail;\n"
				"\t\ttup->cells[1] = head;\n"
				"\t\treturn MKTUP(tup,2);\n"
				"\t}\n"
				"}\n"
				"static VAL mkcons(VAL tail, VAL head) {\n"
				"\tVAL v = mkcons_hint(tail,head,3);\n"
				"\treturn v;\n"
				"}\n"
				"\n"
				"static VAL lpop(VAL* stk) {\n"
				"\tVAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);\n"
				"\t*stk=lcar; return lcdr;\n"
				"}\n"
				"static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }\n"
				"#define LPOP(v) push_value(lpop(&(v)))\n"
				"#define LPUSH(v) lpush(&(v),pop_value())\n"
				"\n"
				"static STR* str_alloc (USIZE cap) {\n"
				"\tASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);\n"
				"\tSTR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));\n"
				"\tEXPECT(str, \"failed to allocate string\");\n"
				"\tstr->refs = 1;\n"
				"\tstr->cap = cap;\n"
				"\treturn str;\n"
				"}\n"
				"\n"
				"static VAL mkstr (const char* data, USIZE size) {\n"
				"\tASSERT(data);\n"
				"\tASSERT(size <= SIZE_MAX - sizeof(STR) - 4);\n"
				"\tSTR* str = str_alloc(size);\n"
				"\tstr->size = size;\n"
				"\tmemcpy(str->data, data, (size_t)size);\n"
				"\treturn MKSTR(str);\n"
				"}\n"
				"\n"
				"static void do_uncons(void) {\n"
				"\tVAL val, tail, head;\n"
				"\tval = pop_value();\n"
				"\tvalue_uncons(val, &tail, &head);\n"
				"\tpush_value(tail);\n"
				"\tpush_value(head);\n"
				"}\n"
				"\n"
				"static USIZE get_data_tag(VAL v) {\n"
				"\tif (IS_TUP(v)) {\n"
				"\t\tASSERT(VTUPLEN(v) > 0);\n"
				"\t\treturn VU64(VTUP(v)->cells[0]);\n"
				"\t} else {\n"
				"\t\treturn VU64(v);\n"
				"\t}\n"
				"}\n"
				"\n"
				"static USIZE get_top_data_tag(void) {\n"
				"\treturn get_data_tag(top_value());\n"
				"}\n"
				"\n"
				"static USIZE get_top_resource_data_tag(void) {\n"
				"\treturn get_data_tag(top_resource());\n"
				"}\n"
				"\n"
				"static int str_cmp_(STR* s1, STR* s2) {\n"
				"\tASSERT(s1 && s2);\n"
				"\tUSIZE n1 = s1->size;\n"
				"\tUSIZE n2 = s2->size;\n"
				"\tUSIZE n = (n1 < n2 ? n1 : n2);\n"
				"\tASSERT(n < SIZE_MAX);\n"
				"\tint r = memcmp(s1->data, s2->data, (size_t)n);\n"
				"\tif (r) return r;\n"
				"\tif (n1 < n2) return -1;\n"
				"\tif (n1 > n2) return 1;\n"
				"\treturn 0;\n"
				"}\n"
				"\n"
				"static void run_value(VAL v) {\n"
				"\tif (IS_TUP(v)) {\n"
				"\t\tVAL h = VTUP(v)->cells[0];\n"
				"\t\tASSERT(IS_FNPTR(h));\n"
				"\t\tpush_value(v);\n"
				"\t\tVFNPTR(h)();\n"
				"\t} else {\n"
				"\t\tASSERT(IS_FNPTR(v));\n"
				"\t\tVFNPTR(v)();\n"
				"\t}\n"
				"}\n"
				"\n"
				"static void mp_prim_id (void) {}\n"
				"static void mp_prim_dup (void) {\n"
				"\tPRIM_ENTER(mp_prim_dup,\"prim-dup\");\n"
				"\tVAL v = top_value();\n"
				"\tpush_value(v);\n"
				"\tincref(v);\n"
				"\tPRIM_EXIT(mp_prim_dup);\n"
				"}\n"
				"static void mp_prim_drop (void) {\n"
				"\tPRIM_ENTER(mp_prim_drop,\"prim-drop\");\n"
				"\tVAL v = pop_value();\n"
				"\tdecref(v);\n"
				"\tPRIM_EXIT(mp_prim_drop);\n"
				"}\n"
				"\n"
				"static void mp_prim_swap (void) {\n"
				"\tPRIM_ENTER(mp_prim_swap,\"prim-swap\");\n"
				"\tVAL a = pop_value();\n"
				"\tVAL b = pop_value();\n"
				"\tpush_value(a);\n"
				"\tpush_value(b);\n"
				"\tPRIM_EXIT(mp_prim_swap);\n"
				"}\n"
				"\n"
				"static void mp_prim_rswap (void) {\n"
				"\tPRIM_ENTER(mp_prim_rswap,\"prim-rswap\");\n"
				"\tVAL a = pop_resource();\n"
				"\tVAL b = pop_resource();\n"
				"\tpush_resource(a);\n"
				"\tpush_resource(b);\n"
				"\tPRIM_EXIT(mp_prim_rswap);\n"
				"}\n"
				"\n"
				"static void mp_prim_int_add (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_add,\"prim-int-add\");\n"
				"\t// TODO promote to bigint on overflow.\n"
				"\tint64_t b = pop_i64();\n"
				"\tint64_t a = pop_i64();\n"
				"\tif (b >= 0) {\n"
				"\t\tEXPECT(a <= INT64_MAX - b, \"integer overflow during addition (too positive)\");\n"
				"\t} else {\n"
				"\t\tEXPECT(a >= INT64_MIN - b, \"integer overflow during addition (too negative)\");\n"
				"\t}\n"
				"\tpush_i64(a + b);\n"
				"\tPRIM_EXIT(mp_prim_int_add);\n"
				"}\n"
				"static void mp_prim_int_sub (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_sub,\"prim-int-sub\");\n"
				"\t// TODO promote to bigint on overflow\n"
				"\tint64_t b = pop_i64();\n"
				"\tint64_t a = pop_i64();\n"
				"\tif (b >= 0) {\n"
				"\t\tEXPECT(a >= INT64_MIN + b, \"integer overflow during subtraction (too negative)\");\n"
				"\t} else {\n"
				"\t\tEXPECT(a <= INT64_MAX + b, \"integer overflow during subtraction (too positive)\");\n"
				"\t}\n"
				"\tpush_i64(a - b);\n"
				"\tPRIM_EXIT(mp_prim_int_sub);\n"
				"}\n"
				"static void mp_prim_int_mul (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_mul,\"prim-int-mul\");\n"
				"\t// TODO promote to bigint on overflow\n"
				"\tint64_t b = pop_i64();\n"
				"\tint64_t a = pop_i64();\n"
				"\t// overflow checks for multiplication\n"
				"\tpush_i64(a * b);\n"
				"\tPRIM_EXIT(mp_prim_int_mul);\n"
				"}\n"
				"static void mp_prim_int_div (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_div,\"prim-int-div\");\n"
				"\t// TODO promote to bigint on overflow\n"
				"\tint64_t b = pop_i64();\n"
				"\tint64_t a = pop_i64();\n"
				"\tEXPECT(b != 0, \"divide by zero\");\n"
				"\tEXPECT(!((b == -1) && (a == INT64_MIN)), \"overflow during division\");\n"
				"\tint64_t r = a % b;\n"
				"\tint64_t q = a / b;\n"
				"\tif (((a < 0) ^ (b < 0)) && r) q--;\n"
				"\tpush_i64(q);\n"
				"\tPRIM_EXIT(mp_prim_int_div);\n"
				"}\n"
				"static void mp_prim_int_mod (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_mod,\"prim-int-mod\");\n"
				"\tint64_t b = pop_i64();\n"
				"\tint64_t a = pop_i64();\n"
				"\tEXPECT(b != 0, \"divide by zero\");\n"
				"\tif (b == -1) { push_i64(0); return; }\n"
				"\tint64_t r = a % b;\n"
				"\tint64_t q = a / b;\n"
				"\tif (((a < 0) ^ (b < 0)) && r) r += b;\n"
				"\tpush_i64(r);\n"
				"\tPRIM_EXIT(mp_prim_int_mod);\n"
				"}\n"
				"\n"
				"static void mp_prim_int_and (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_and,\"prim-int-and\");\n"
				"\tuint64_t b = pop_u64();\n"
				"\tuint64_t a = pop_u64();\n"
				"\tpush_u64(a & b);\n"
				"\tPRIM_EXIT(mp_prim_int_and);\n"
				"}\n"
				"static void mp_prim_int_or (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_or,\"prim-int-or\");\n"
				"\tuint64_t b = pop_u64();\n"
				"\tuint64_t a = pop_u64();\n"
				"\tpush_u64(a | b);\n"
				"\tPRIM_EXIT(mp_prim_int_or);\n"
				"}\n"
				"static void mp_prim_int_xor (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_xor,\"prim-int-xor\");\n"
				"\tuint64_t b = pop_u64();\n"
				"\tuint64_t a = pop_u64();\n"
				"\tpush_u64(a ^ b);\n"
				"\tPRIM_EXIT(mp_prim_int_xor);\n"
				"}\n"
				"static void mp_prim_int_shl (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_shl,\"prim-int-shl\");\n"
				"\tuint64_t b = pop_u64();\n"
				"\tuint64_t a = pop_u64();\n"
				"\tpush_u64((b >= 64) ? 0 : (a << b));\n"
				"\tPRIM_EXIT(mp_prim_int_shl);\n"
				"}\n"
				"static void mp_prim_int_shr (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_shr,\"prim-int-shr\");\n"
				"\tuint64_t b = pop_u64();\n"
				"\tuint64_t a = pop_u64();\n"
				"\tpush_u64((b >= 64) ? 0 : (a >> b));\n"
				"\tPRIM_EXIT(mp_prim_int_shr);\n"
				"}\n"
				"\n"
				"static void mp_prim_int_eq (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_eq,\"prim-int-eq\");\n"
				"\tVAL b = pop_value();\n"
				"\tVAL a = pop_value();\n"
				"\tASSERT1(IS_INT(a), a);\n"
				"\tASSERT1(IS_INT(b), a);\n"
				"\tpush_bool(VINT(a) == VINT(b));\n"
				"\tPRIM_EXIT(mp_prim_int_eq);\n"
				"}\n"
				"static void mp_prim_int_lt (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_lt,\"prim-int-lt\");\n"
				"\tVAL b = pop_value();\n"
				"\tVAL a = pop_value();\n"
				"\tASSERT2(IS_INT(a) && IS_INT(b), a, b);\n"
				"\tpush_bool(VINT(a) < VINT(b));\n"
				"\tPRIM_EXIT(mp_prim_int_lt);\n"
				"}\n"
				"static void mp_prim_str_cmp (void) {\n"
				"\tPRIM_ENTER(mp_prim_str_cmp,\"prim-str-cmp\");\n"
				"\tVAL b = pop_value();\n"
				"\tVAL a = pop_value();\n"
				"\tASSERT2(IS_STR(a) && IS_STR(b), a, b);\n"
				"\tint64_t cmp = str_cmp_(VSTR(a), VSTR(b));\n"
				"\tpush_i64(cmp);\n"
				"\tdecref(a); decref(b);\n"
				"\tPRIM_EXIT(mp_prim_str_cmp);\n"
				"}\n"
				"\n"
				"static void mp_prim_sys_argc (void) {\n"
				"\tPRIM_ENTER(mp_prim_sys_argc,\"prim-sys-argc\");\n"
				"\tpush_i64(global_argc);\n"
				"\tPRIM_EXIT(mp_prim_sys_argc);\n"
				"}\n"
				"static void mp_prim_sys_argv (void) {\n"
				"\tPRIM_ENTER(mp_prim_sys_argv,\"prim-sys-argv\");\n"
				"\tpush_ptr(global_argv);\n"
				"\tPRIM_EXIT(mp_prim_sys_argv);\n"
				"}\n"
				"\n"
				"static void mp_prim_posix_write (void) {\n"
				"\tPRIM_ENTER(mp_prim_posix_write,\"prim-posix-write\");\n"
				"\tUSIZE n = pop_usize();\n"
				"\tVAL vp = pop_value();\n"
				"\tvoid* p = value_ptr(vp);\n"
				"\tint fd = (int)pop_i64();\n"
				"\tASSERT(n <= SIZE_MAX);\n"
				"\tpush_i64((int64_t)write(fd, p, (size_t)n));\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_posix_write);\n"
				"}\n"
				"static void mp_prim_posix_read (void) {\n"
				"\tPRIM_ENTER(mp_prim_posix_read,\"prim-posix-read\");\n"
				"\tUSIZE n = pop_usize();\n"
				"\tVAL vp = pop_value();\n"
				"\tvoid* p = value_ptr(vp);\n"
				"\tint fd = (int)pop_i64();\n"
				"\tASSERT(n <= SIZE_MAX);\n"
				"\tpush_i64((int64_t)read(fd, p, (size_t)n));\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_posix_read);\n"
				"}\n"
				"static void mp_prim_posix_open (void) {\n"
				"\tPRIM_ENTER(mp_prim_posix_open,\"prim-posix-open\");\n"
				"\tint m = (int)pop_i64();\n"
				"\tint f = (int)pop_i64();\n"
				"\tVAL vp = pop_value();\n"
				"\tvoid* path = value_ptr(vp);\n"
				"\tpush_i64((int64_t)open(path,f,m));\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_posix_open);\n"
				"}\n"
				"static void mp_prim_posix_close (void) {\n"
				"\tPRIM_ENTER(mp_prim_posix_close,\"prim-posix-close\");\n"
				"\tint fd = (int)pop_i64();\n"
				"\tpush_i64((int64_t)close(fd));\n"
				"\tPRIM_EXIT(mp_prim_posix_close);\n"
				"}\n"
				"static void mp_prim_posix_exit (void) {\n"
				"\tPRIM_ENTER(mp_prim_posix_exit,\"prim-posix-exit\");\n"
				"\tint x = (int)pop_i64();\n"
				"\texit(x);\n"
				"\tPRIM_EXIT(mp_prim_posix_exit);\n"
				"}\n"
				"\n"
				"void int_repr(int64_t y, char** out_ptr, size_t *out_size) {\n"
				"\tstatic char c[32] = {0};\n"
				"\tmemset(c, 0, 32);\n"
				"\tchar* p = c+30;\n"
				"\tsize_t n = 0;\n"
				"\tuint64_t x;\n"
				"\tif (y < 0) {\n"
				"\t\tif (y == INT64_MIN) {\n"
				"\t\t\tx = 1+(uint64_t)INT64_MAX;\n"
				"\t\t} else {\n"
				"\t\t\tx = (uint64_t)-y;\n"
				"\t\t}\n"
				"\t} else {\n"
				"\t\tx = (uint64_t)y;\n"
				"\t}\n"
				"\tdo {\n"
				"\t\t*--p = '0' + (x % 10);\n"
				"\t\tx /= 10;\n"
				"\t\tn++;\n"
				"\t} while (x);\n"
				"\tif (y < 0) {\n"
				"\t\t*--p = '-';\n"
				"\t\tn++;\n"
				"\t}\n"
				"\t*out_ptr = p;\n"
				"\t*out_size = n;\n"
				"}\n"
				"\n"
				"void int_trace_(int64_t y, int fd) {\n"
				"\tchar* p; size_t n;\n"
				"\tint_repr(y, &p, &n);\n"
				"\twrite(fd, p, n);\n"
				"}\n"
				"\n"
				"void mp_prim_int_to_str(void) {\n"
				"\tPRIM_ENTER(mp_prim_int_to_str,\"prim-int-to-str\");\n"
				"\tint64_t x = pop_i64();\n"
				"\tbool cache = (0 <= x) && (x <= 255);\n"
				"\tstatic VAL scache[256] = {0};\n"
				"\tif (cache && scache[x].tag) {\n"
				"\t\tincref(scache[x]);\n"
				"\t\tpush_value(scache[x]);\n"
				"\t} else {\n"
				"\t\tchar* p; size_t n;\n"
				"\t\tint_repr(x,&p,&n);\n"
				"\t\tVAL out = mkstr(p,n);\n"
				"\t\tpush_value(out);\n"
				"\t\tif (cache) {\n"
				"\t\t\tscache[x] = out;\n"
				"\t\t\tincref(out);\n"
				"\t\t}\n"
				"\t}\n"
				"\tPRIM_EXIT(mp_prim_int_to_str);\n"
				"}\n"
				"\n"
				"void str_trace_(STR* str, int fd) {\n"
				"\tASSERT(str->size <= SIZE_MAX);\n"
				"\twrite(fd, \"\\\"\", 1);\n"
				"\twrite(fd, str->data, (size_t)str->size); // TODO handle escapes\n"
				"\twrite(fd, \"\\\"\", 1);\n"
				"}\n"
				"\n"
				"void value_trace_(VAL val, int fd) {\n"
				"\tif (IS_INT(val)) {\n"
				"\t\tint_trace_(VINT(val), fd);\n"
				"\t} else if (IS_STR(val)) {\n"
				"\t\tstr_trace_(VSTR(val), fd);\n"
				"\t} else if (IS_FNPTR(val)) {\n"
				"\t\twrite(fd, \"<fnptr>\", 7);\n"
				"\t} else if (IS_TUP(val)) {\n"
				"\t\tTUPLEN len = VTUPLEN(val);\n"
				"\t\tTUP* tup = VTUP(val);\n"
				"\t\tif (VTUPLEN(val) == 0) {\n"
				"\t\t\twrite(fd, \"[]\", 2);\n"
				"\t\t} else {\n"
				"\t\t\twrite(fd, \"[ \", 2);\n"
				"\t\t\tfor(TUPLEN i = 0; i < len; i++) {\n"
				"\t\t\t\tif (i > 0) write(fd, \" \", 1);\n"
				"\t\t\t\tvalue_trace_(tup->cells[i], fd);\n"
				"\t\t\t}\n"
				"\t\t\twrite(fd, \" ]\", 2);\n"
				"\t\t}\n"
				"\t} else {\n"
				"\t\tTRACE(\"value cannot be traced\");\n"
				"\t\texit(1);\n"
				"\t}\n"
				"}\n"
				"\n"
				"static void mp_prim_debug (void) {\n"
				"\tTRACE(\"??\");\n"
				"\tfor (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {\n"
				"\t\tTRACE(\" \");\n"
				"\t\tvalue_trace_(stack[i], 2);\n"
				"\t}\n"
				"\tTRACE(\"\\n\");\n"
				"}\n"
				"\n"
				"static void mp_prim_rdebug (void) {\n"
				"\t#if MIRTH_DEBUG\n"
				"\t\tTRACE(\"call stack:\\n\");\n"
				"\t\tfor (USIZE i = fstack_counter; i --> 1;) {\n"
				"\t\t\tTRACE(\"    \");\n"
				"\t\t\tif (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {\n"
				"\t\t\t\tTRACE(fstack[i-1].atom);\n"
				"\t\t\t\tTRACE(\" -> \");\n"
				"\t\t\t}\n"
				"\t\t\tTRACE(fstack[i].word);\n"
				"\t\t\tTRACE(\" at \");\n"
				"\t\t\tTRACE(fstack[i-1].path);\n"
				"\t\t\tTRACE(\":\");\n"
				"\t\t\tint_trace_((int64_t)fstack[i-1].line, 2);\n"
				"\t\t\tTRACE(\":\");\n"
				"\t\t\tint_trace_((int64_t)fstack[i-1].col, 2);\n"
				"\t\t\tTRACE(\"\\n\");\n"
				"\t\t}\n"
				"\t#endif\n"
				"}\n"
				"\n"
				"static void mp_prim_panic(void) {\n"
				"\t// TODO: expect less of the stack, i.e. panic gracefully even if stack\n"
				"\t// is in a weird state ... this is panic! after all\n"
				"\tVAL v = pop_value();\n"
				"\tASSERT(IS_STR(v));\n"
				"\tASSERT(VSTR(v)->size < SIZE_MAX);\n"
				"\twrite(2,VSTR(v)->data, (size_t)VSTR(v)->size);\n"
				"\tmp_prim_debug();\n"
				"\tmp_prim_rdebug();\n"
				"\texit(1);\n"
				"}\n"
				"\n"
				"static void mp_prim_ptr_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_get,\"prim-ptr-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tvoid **p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_ptr(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_ptr_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_u8_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_u8_get,\"prim-u8-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint8_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_u8(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u8_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_u16_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_u16_get,\"prim-u16-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint16_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_u16(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u16_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_u32_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_u32_get,\"prim-u32-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint32_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_u32(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u32_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_u64_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_u64_get,\"prim-u64-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint64_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_u64(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u64_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_i8_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_i8_get,\"prim-i8-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint8_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_i8(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i8_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_i16_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_i16_get,\"prim-i16-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint16_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_i16(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i16_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_i32_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_i32_get,\"prim-i32-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint32_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_i32(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i32_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_i64_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_i64_get,\"prim-i64-get\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint64_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to load from null pointer\");\n"
				"\tpush_i64(*p);\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i64_get);\n"
				"}\n"
				"\n"
				"static void mp_prim_int_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_int_set,\"prim-int-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint64_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_i64();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_int_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_ptr_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_set,\"prim-ptr-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tvoid **p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_ptr();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_ptr_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_u8_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_u8_set,\"prim-u8-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint8_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_u8();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u8_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_u16_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_u16_set,\"prim-u16-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint16_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_u16();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u16_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_u32_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_u32_set,\"prim-u32-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint32_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_u32();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u32_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_u64_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_u64_set,\"prim-u64-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tuint64_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_u64();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_u64_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_i8_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_i8_set,\"prim-i8-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint8_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_i8();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i8_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_i16_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_i16_set,\"prim-i16-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint16_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_i16();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i16_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_i32_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_i32_set,\"prim-i32-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint32_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_i32();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i32_set);\n"
				"}\n"
				"\n"
				"static void mp_prim_i64_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_i64_set,\"prim-i64-set\");\n"
				"\tVAL vp = pop_value();\n"
				"\tint64_t *p = value_ptr(vp);\n"
				"\tEXPECT(p, \"tried to write to null pointer\");\n"
				"\t*p = pop_i64();\n"
				"\tdecref(vp);\n"
				"\tPRIM_EXIT(mp_prim_i64_set);\n"
				"}\n"
				"\n"
				"\n"
				"#if defined(MIRTH_WINDOWS)\n"
				"#define mp_prim_sys_os() push_u64(1)\n"
				"#elif defined(MIRTH_LINUX)\n"
				"#define mp_prim_sys_os() push_u64(2)\n"
				"#elif defined(MIRTH_MACOS)\n"
				"#define mp_prim_sys_os() push_u64(3)\n"
				"#else\n"
				"#define mp_prim_sys_os() push_u64(0)\n"
				"#endif\n"
				"\n"
				"static void mp_prim_run (void) {\n"
				"\tPRIM_ENTER(mp_prim_run,\"prim-run\");\n"
				"\tVAL f = pop_value();\n"
				"\trun_value(f);\n"
				"\tPRIM_EXIT(mp_prim_run);\n"
				"}\n"
				"\n"
				"static void mp_prim_ptr_nil (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_nil,\"prim-ptr-nil\");\n"
				"\tpush_ptr((void*)0);\n"
				"\tPRIM_EXIT(mp_prim_ptr_nil);\n"
				"}\n"
				"static void mp_prim_ptr_eq (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_eq,\"prim-ptr-eq\");\n"
				"\tvoid* a = pop_ptr();\n"
				"\tvoid* b = pop_ptr();\n"
				"\tpush_bool(a == b);\n"
				"\tPRIM_EXIT(mp_prim_ptr_eq);\n"
				"}\n"
				"static void mp_prim_ptr_add (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_add,\"prim-ptr-add\");\n"
				"\tVAL vptr = pop_value();\n"
				"\tUSIZE n = pop_usize();\n"
				"\tASSERT1(IS_PTR(vptr), vptr);\n"
				"\tEXPECT(VPTR(vptr), \"attempt to add to null pointer\");\n"
				"\tchar* ptr = (char*)VPTR(vptr);\n"
				"\tpush_ptr(ptr + n);\n"
				"\tPRIM_EXIT(mp_prim_ptr_add);\n"
				"}\n"
				"#define mp_prim_ptr_size() push_u64((uint64_t)sizeof(void*))\n"
				"static void mp_prim_ptr_alloc (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_alloc,\"prim-ptr-alloc\");\n"
				"\tUSIZE n = pop_usize();\n"
				"\tvoid* p = malloc((size_t)n);\n"
				"\tEXPECT(p, \"failed to allocate buffer\");\n"
				"\tpush_ptr(p);\n"
				"\tPRIM_EXIT(mp_prim_ptr_alloc);\n"
				"}\n"
				"static void mp_prim_ptr_realloc (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_realloc,\"prim-ptr-realloc\");\n"
				"\tUSIZE n = pop_usize();\n"
				"\tvoid* p0 = pop_ptr();\n"
				"\tvoid* p1 = realloc(p0, (size_t)n);\n"
				"\tEXPECT(p1, \"failed to reallocate buffer\");\n"
				"\tpush_ptr(p1);\n"
				"\tPRIM_EXIT(mp_prim_ptr_realloc);\n"
				"}\n"
				"static void mp_prim_ptr_free (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_free,\"prim-ptr-free\");\n"
				"\tvoid* p = pop_ptr();\n"
				"\tfree(p);\n"
				"\tPRIM_EXIT(mp_prim_ptr_free);\n"
				"}\n"
				"\n"
				"static void mp_prim_ptr_copy (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_copy,\"prim-ptr-copy\");\n"
				"\tVAL vdst = pop_value();\n"
				"\tint64_t ilen = pop_i64();\n"
				"\tVAL vsrc = pop_value();\n"
				"\tASSERT2(IS_PTR(vsrc) && IS_PTR(vdst), vsrc, vdst);\n"
				"\tvoid* src = value_ptr(vsrc);\n"
				"\tvoid* dst = value_ptr(vdst);\n"
				"\tif (src && dst && (ilen > 0)) {\n"
				"\t\tASSERT((USIZE)ilen <= SIZE_MAX);\n"
				"\t\tmemcpy(dst, src, (size_t)ilen);\n"
				"\t}\n"
				"\tPRIM_EXIT(mp_prim_ptr_copy);\n"
				"}\n"
				"\n"
				"static void mp_prim_ptr_fill (void) {\n"
				"\tPRIM_ENTER(mp_prim_ptr_fill,\"prim-ptr-fill\");\n"
				"\tVAL vdst = pop_value();\n"
				"\tASSERT1(IS_PTR(vdst), vdst);\n"
				"\tint64_t ilen = pop_i64();\n"
				"\tuint64_t val = pop_u64();\n"
				"\tvoid* dst = value_ptr(vdst);\n"
				"\tif (dst && (ilen > 0)) {\n"
				"\t\tASSERT((USIZE)ilen <= SIZE_MAX);\n"
				"\t\tmemset(dst, (int)val, (size_t)ilen);\n"
				"\t}\n"
				"\tPRIM_EXIT(mp_prim_ptr_fill);\n"
				"}\n"
				"\n"
				"static void mp_prim_str_copy (void) {\n"
				"\tPRIM_ENTER(mp_prim_str_copy,\"prim-str-copy\");\n"
				"\tUSIZE size = pop_usize();\n"
				"\tchar* ptr = (char*)pop_ptr();\n"
				"\tASSERT(size <= SIZE_MAX-sizeof(STR)-4);\n"
				"\tASSERT(ptr);\n"
				"\tpush_value(mkstr(ptr, size));\n"
				"\tPRIM_EXIT(mp_prim_str_copy);\n"
				"}\n"
				"\n"
				"static void mp_prim_str_cat (void) {\n"
				"\tPRIM_ENTER(mp_prim_str_cat,\"prim-str-cat\");\n"
				"\tVAL v2 = pop_value();\n"
				"\tVAL v1 = pop_value();\n"
				"\tASSERT2(IS_STR(v1) && IS_STR(v2), v1, v2);\n"
				"\tSTR* s1 = VSTR(v1);\n"
				"\tSTR* s2 = VSTR(v2);\n"
				"\tUSIZE m = s1->cap;\n"
				"\tUSIZE n1 = s1->size;\n"
				"\tUSIZE n2 = s2->size;\n"
				"\tif ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {\n"
				"\t\tASSERT(n2 <= SIZE_MAX);\n"
				"\t\tmemcpy(s1->data + n1, s2->data, (size_t)n2);\n"
				"\t\ts1->size += n2;\n"
				"\t\tASSERT(s1->size + 4 <= s1->cap);\n"
				"\t\tpush_value(v1);\n"
				"\t\tdecref(v2);\n"
				"\t} else {\n"
				"\t\tUSIZE m2 = n1 + n2 + 4;\n"
				"\t\tif ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;\n"
				"\t\tSTR* str = str_alloc(m2);\n"
				"\t\tstr->size = n1+n2;\n"
				"\t\tASSERT(n1 <= SIZE_MAX);\n"
				"\t\tASSERT(n2 <= SIZE_MAX);\n"
				"\t\tmemcpy(str->data, s1->data, (size_t)n1);\n"
				"\t\tmemcpy(str->data+n1, s2->data, (size_t)n2);\n"
				"\t\tpush_value(MKSTR(str));\n"
				"\t\tdecref(v1);\n"
				"\t\tdecref(v2);\n"
				"\t}\n"
				"\tPRIM_EXIT(mp_prim_str_cat);\n"
				"}\n"
				"\n"
				"static void mp_prim_str_base (void) {\n"
				"\tPRIM_ENTER(mp_prim_str_base,\"prim-str-base\");\n"
				"\tVAL vstr = pop_value();\n"
				"\tASSERT1(IS_STR(vstr) && VSTR(vstr), vstr);\n"
				"\tpush_ptr(VSTR(vstr)->data);\n"
				"\tdecref(vstr);\n"
				"\tPRIM_EXIT(mp_prim_str_base);\n"
				"}\n"
				"\n"
				"static void mp_prim_str_num_bytes (void) {\n"
				"\tPRIM_ENTER(mp_prim_str_num_bytes,\"prim-str-num-bytes\");\n"
				"\tVAL v = pop_value();\n"
				"\tASSERT(IS_STR(v) && VSTR(v));\n"
				"\tpush_usize(VSTR(v)->size);\n"
				"\tdecref(v);\n"
				"\tPRIM_EXIT(mp_prim_str_num_bytes);\n"
				"}\n"
				"\n"
				"static void mp_prim_pack_nil (void) {\n"
				"\tPRIM_ENTER(mp_prim_pack_nil,\"prim-pack-nil\");\n"
				"\tpush_value(MKNIL);\n"
				"\tPRIM_EXIT(mp_prim_pack_nil);\n"
				"}\n"
				"\n"
				"static void mp_prim_pack_cons (void) {\n"
				"\tPRIM_ENTER(mp_prim_pack_cons,\"prim-pack-cons\");\n"
				"\tVAL cdr = pop_value();\n"
				"\tVAL car = pop_value();\n"
				"\tpush_value(mkcons(car,cdr));\n"
				"\tPRIM_EXIT(mp_prim_pack_cons);\n"
				"}\n"
				"\n"
				"static void mp_prim_pack_uncons (void) {\n"
				"\tPRIM_ENTER(mp_prim_pack_uncons,\"prim-pack-uncons\");\n"
				"\tdo_uncons();\n"
				"\tPRIM_EXIT(mp_prim_pack_uncons);\n"
				"}\n"
				"\n"
				"static void mp_prim_mut_get (void) {\n"
				"\tPRIM_ENTER(mp_prim_mut_get,\"prim-mut-get\");\n"
				"\tVAL mut = pop_value();\n"
				"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
				"\tVAL v = *(VAL*)VPTR(mut);\n"
				"\tEXPECT(v.tag, \"tried to read uninitialized value\");\n"
				"\tpush_value(v);\n"
				"\tincref(v);\n"
				"\tPRIM_EXIT(mp_prim_mut_get);\n"
				"}\n"
				"static void mp_prim_mut_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_mut_set,\"prim-mut-set\");\n"
				"\tVAL mut = pop_value();\n"
				"\tVAL newval = pop_value();\n"
				"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
				"\tVAL oldval = *(VAL*)VPTR(mut);\n"
				"\t*(VAL*)VPTR(mut) = newval;\n"
				"\tif (oldval.tag) {\n"
				"\t\tdecref(oldval);\n"
				"\t}\n"
				"\tdecref(mut);\n"
				"\tPRIM_EXIT(mp_prim_mut_set);\n"
				"}\n"
				"static void mp_prim_mut_is_set (void) {\n"
				"\tPRIM_ENTER(mp_prim_mut_is_set,\"prim-mut-is-set\");\n"
				"\tVAL mut = pop_value();\n"
				"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
				"\tVAL val = *(VAL*)VPTR(mut);\n"
				"\tpush_bool(val.tag);\n"
				"\tdecref(mut);\n"
				"\tPRIM_EXIT(mp_prim_mut_is_set);\n"
				"}\n"
				"\n"
				"/* GENERATED C99 */\n",
				32151
			);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
}
static void mw_c99_header_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("#define MIRTH_DEBUG ", 20);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_emit_debug_info_3F__1();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("1", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("0", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	}
	mw_put_3();
	mw_line_3();
	mw_c99_header_str_1();
	mw_put_3();
	mw_line_3();
}
static void mw_c99_buffers_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_16();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_buffer_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_buffer_21__1 (void) {
	mp_prim_dup();
	mw_cname_6();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tstatic uint8_t b[", 18);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_size_1();
	mw_show_4();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("] = {0};", 8);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tpush_ptr(&b);", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mp_prim_drop();
}
static void mw_c99_variables_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_2();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_variable_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_variable_21__1 (void) {
	mw_cname_2();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tstatic VAL v = {0};", 20);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tpush_ptr(&v);", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_tag_defs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_15();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_tag_def_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_tag_def_21__1 (void) {
	{
		VAL var_tag = pop_value();
		incref(var_tag);
		push_value(var_tag);
		mw_prefer_inline_3F__2();
		push_fnptr(&mb_2029);
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_else_1();
		decref(var_tag);
	}
}
static void mw_c99_tag_label_index_1 (void) {
	mw_over_1();
	mw_num_total_inputs_1();
	mw_1_2B__2();
	mw_over2_1();
	mw_label_inputs_1();
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_reverse_find_some_2_2334();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_drop();
	{
		VAL d2 = pop_value();
		mw_drop2_1();
		push_value(d2);
	}
}
static void mw_c99_tag_get_label_21__1 (void) {
	mw_over_1();
	mw_outputs_resource_3F__1();
	if (pop_u64()) {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("VAL v = top_resource();", 23);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("VAL v = pop_value();", 20);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	}
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("ASSERT1(IS_TUP(v), v);", 22);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("ASSERT1(VTUPLEN(v) == ", 22);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_over_1();
	mw_num_total_inputs_1();
	mw_1_2B__2();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(", v);", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("VAL u = VTUP(v)->cells[", 23);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_dup2_1();
	mw_c99_tag_label_index_1();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("];", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("incref(u);", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_over_1();
	mw_outputs_resource_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(v);", 10);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_value(u);", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_drop2_1();
}
static void mw_c99_tag_set_label_21__1 (void) {
	{
		VAL var_lbl = pop_value();
		VAL var_tag = pop_value();
		incref(var_tag);
		push_value(var_tag);
		mw_outputs_resource_3F__1();
		if (pop_u64()) {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL v = top_resource();", 23);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		} else {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL v = pop_value();", 20);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		}
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("VAL u = pop_value();", 20);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("ASSERT1(IS_TUP(v), v);", 22);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		push_fnptr(&mb_2074);
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_c99_line_1();
		incref(var_tag);
		push_value(var_tag);
		mw_outputs_resource_3F__1();
		if (pop_u64()) {
			push_fnptr(&mb_2077);
			incref(var_lbl);
			push_value(var_lbl);
			mp_prim_pack_cons();
			incref(var_tag);
			push_value(var_tag);
			mp_prim_pack_cons();
			mw_c99_line_1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL t = *p; *p = u; decref(t);", 30);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		} else {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("if (VTUP(v)->refs == 1) {", 25);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			push_fnptr(&mb_2080);
			incref(var_lbl);
			push_value(var_lbl);
			mp_prim_pack_cons();
			incref(var_tag);
			push_value(var_tag);
			mp_prim_pack_cons();
			mw_c99_nest_1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("} else {", 8);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			push_fnptr(&mb_2085);
			incref(var_lbl);
			push_value(var_lbl);
			mp_prim_pack_cons();
			incref(var_tag);
			push_value(var_tag);
			mp_prim_pack_cons();
			mw_c99_nest_1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("}", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		}
		decref(var_lbl);
		decref(var_tag);
	}
}
static void mw_c99_externals_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_13();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_external_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_external_21__1 (void) {
	mp_prim_dup();
	mw_sig_2();
	mw_sig_arity_1();
	mp_prim_dup();
	push_i64(2LL);
	mw__3E_Nat_1();
	mw__3E__3D__3();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("can't declare external with multiple return values", 50);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mp_prim_panic();
	} else {
		mp_prim_dup();
		push_i64(1LL);
		mw__3E_Nat_1();
		mw__3E__3D__3();
		if (pop_u64()) {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("int64_t ", 8);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("void ", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
		}
		mw_put_3();
	}
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_symbol_1();
			mw_put_3();
			push_value(d3);
		}
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" (", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_over_1();
	mp_prim_dup();
	mw_0_3E__2();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("int64_t", 7);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_1__2();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(", int64_t", 9);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
	} else {
		mp_prim_drop();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("void", 4);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_cname_5();
			mw_sig_put_1();
			push_value(d3);
		}
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_over_1();
	mp_prim_dup();
	mp_prim_swap();
	while(1) {
		mp_prim_dup();
		mw_0_3E__2();
		if (! pop_u64()) break;
		{
			VAL d3 = pop_value();
			mw_1__2();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tint64_t x", 10);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_i64();", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_1__2();
	}
	mp_prim_drop();
	mp_prim_drop();
	mp_prim_dup();
	mw_0_3E__2();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tpush_i64(", 10);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\t", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	}
	mw_put_3();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_symbol_1();
			mw_put_3();
			push_value(d3);
		}
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("(", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_0_3E__2();
		if (pop_u64()) {
			mp_prim_dup();
			mw_1__2();
			mp_prim_dup();
			push_i64(0LL);
			mw__3E_Nat_1();
			mp_prim_swap();
			while(1) {
				mp_prim_dup();
				mw_0_3E__2();
				if (! pop_u64()) break;
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("x", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_put_3();
						mw_show_2();
						mw_put_3();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(", ", 2);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_put_3();
						push_value(d6);
					}
					mw_1_2B__2();
					push_value(d5);
				}
				mw_1__2();
			}
			mp_prim_drop();
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("x", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_show_2();
			mw_put_3();
		} else {
			mp_prim_id();
		}
		push_value(d2);
	}
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(")", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_0_3E__2();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(";", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_drop3_1();
}
static void mw_c99_nest_1 (void) {
	{
		VAL var_f = pop_value();
		mw_depth_40__1();
		mw_1_2B__2();
		mw_depth_21__1();
		incref(var_f);
		run_value(var_f);
		mw_depth_40__1();
		mw_1__2();
		mw_depth_21__1();
		decref(var_f);
	}
}
static void mw_indent_1 (void) {
	mw_depth_40__1();
	while(1) {
		mp_prim_dup();
		mw_0_3E__2();
		if (! pop_u64()) break;
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\t", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			push_value(d3);
		}
		mw_1__2();
	}
	mp_prim_drop();
}
static void mw_c99_line_1 (void) {
	{
		VAL var_f = pop_value();
		mw_indent_1();
		incref(var_f);
		run_value(var_f);
		mw_line_3();
		decref(var_f);
	}
}
static void mw_c99_call_21__1 (void) {
	{
		VAL d2 = pop_value();
		mw_c99_args_push_21__1();
		push_value(d2);
	}
	mw_indent_1();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("();", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_arrow_21__1 (void) {
	mw_atoms_4();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_c99_atom_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_c99_atom_21__1();
				push_value(d4);
			}
			mw_c99_atom_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_atom_21__1();
					push_value(d5);
				}
				mw_c99_atom_21__1();
				push_value(d4);
			}
			mw_c99_atom_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2120();
				push_value(d4);
			}
			mw_for_3_2120();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_c99_atom_21__1 (void) {
	mw_emit_debug_info_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("WORD_ATOM(", 10);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_token_11();
			mw_row_1();
			mw__3E_Int_19();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", ", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_token_11();
			mw_col_1();
			mw__3E_Int_18();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", ", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_token_11();
			mw_name_3F__2();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mw__3E_Str_3();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("", 0);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_put_cstr_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_args_4();
		push_value(d2);
	}
	mw_op_4();
	mw_c99_args_op_21__1();
}
static void mw_c99_args_op_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // OP_NONE
			(void)pop_u64();
			mp_prim_drop();
			break;
		case 7LL: // OP_INT
			mtp_OP_5F_INT_1();
			mw_nip_1();
			mw_c99_int_21__1();
			break;
		case 8LL: // OP_STR
			mtp_OP_5F_STR_1();
			mw_nip_1();
			mw_c99_str_21__1();
			break;
		case 2LL: // OP_WORD
			mtp_OP_5F_WORD_1();
			mw_c99_word_21__1();
			break;
		case 3LL: // OP_EXTERNAL
			mtp_OP_5F_EXTERNAL_1();
			mw_cname_5();
			mw_c99_call_21__1();
			break;
		case 4LL: // OP_BUFFER
			mtp_OP_5F_BUFFER_1();
			mw_cname_6();
			mw_c99_call_21__1();
			break;
		case 5LL: // OP_VARIABLE
			mtp_OP_5F_VARIABLE_1();
			mw_cname_2();
			mw_c99_call_21__1();
			break;
		case 6LL: // OP_FIELD
			mtp_OP_5F_FIELD_1();
			mw_cname_3();
			mw_c99_call_21__1();
			break;
		case 9LL: // OP_TAG
			mtp_OP_5F_TAG_1();
			mw_c99_tag_word_21__1();
			break;
		case 1LL: // OP_PRIM
			mtp_OP_5F_PRIM_1();
			mw_c99_prim_21__1();
			break;
		case 10LL: // OP_MATCH
			mtp_OP_5F_MATCH_1();
			mw_nip_1();
			mw_c99_match_21__1();
			break;
		case 11LL: // OP_LAMBDA
			mtp_OP_5F_LAMBDA_1();
			mw_nip_1();
			mw_c99_lambda_21__1();
			break;
		case 12LL: // OP_VAR
			mtp_OP_5F_VAR_1();
			mw_nip_1();
			mw_c99_var_21__1();
			break;
		case 13LL: // OP_BLOCK
			mtp_OP_5F_BLOCK_1();
			mw_nip_1();
			mw_c99_block_push_21__1();
			break;
		case 14LL: // OP_RUN
			mtp_OP_5F_RUN_1();
			mw_nip_1();
			mw_c99_block_run_21__1();
			break;
		case 15LL: // OP_COERCE
			mtp_OP_5F_COERCE_1();
			mw_drop2_1();
			break;
		case 16LL: // OP_LABEL_PUSH
			mtp_OP_5F_LABEL_5F_PUSH_1();
			mw_nip_1();
			mw_c99_label_push_21__1();
			break;
		case 17LL: // OP_LABEL_POP
			mtp_OP_5F_LABEL_5F_POP_1();
			mw_nip_1();
			mw_c99_label_pop_21__1();
			break;
		case 18LL: // OP_DATA_GET_LABEL
			mtp_OP_5F_DATA_5F_GET_5F_LABEL_1();
			mw_c99_tag_get_label_21__1();
			mp_prim_drop();
			break;
		case 19LL: // OP_DATA_SET_LABEL
			mtp_OP_5F_DATA_5F_SET_5F_LABEL_1();
			mw_c99_tag_set_label_21__1();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_c99_word_21__1 (void) {
	mp_prim_dup();
	mw_prefer_inline_3F__1();
	if (pop_u64()) {
		{
			VAL d3 = pop_value();
			mw_c99_args_push_21__1();
			push_value(d3);
		}
		mw_arrow_2();
		mw_c99_arrow_21__1();
	} else {
		mw_cname_1();
		mw_c99_call_21__1();
	}
}
static void mw_value_show_1 (void) {
	mp_prim_dup();
	mfld__7E_value_show_1();
	mp_prim_dup();
	mp_prim_mut_is_set();
	if (pop_u64()) {
		mp_prim_mut_get();
	} else {
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_value_4();
			mw_show_2();
			mp_prim_dup();
			push_value(d3);
		}
		mp_prim_mut_set();
	}
	mw_nip_1();
}
static void mw_c99_tag_word_21__1 (void) {
	mp_prim_dup();
	mw_prefer_inline_3F__2();
	if (pop_u64()) {
		mp_prim_dup();
		mw_data_3();
		mw_is_transparent_3F__2();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				mw_indent_1();
				mp_prim_dup();
				mw_outputs_resource_3F__1();
				if (pop_u64()) {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("push_resource(MKU64(", 20);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mp_prim_dup();
					mw_value_show_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("LL)); // ", 9);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
				} else {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("push_u64(", 9);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mp_prim_dup();
					mw_value_show_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("LL); // ", 8);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
				}
				mp_prim_dup();
				mw_name_17();
				mw__3E_Str_3();
				mw_put_3();
				mw_line_3();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_drop2_1();
	} else {
		mw_word_cname_1();
		mw_c99_call_21__1();
	}
}
static void mw_c99_tag_case_pat_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("case ", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_value_show_1();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("LL: // ", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_name_17();
	mw__3E_Str_3();
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mp_prim_dup();
	mw_prefer_inline_3F__2();
	if (pop_u64()) {
		mp_prim_dup();
		mw_data_3();
		mw_is_transparent_3F__2();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				mw_indent_1();
				mp_prim_dup();
				mw_outputs_resource_3F__1();
				if (pop_u64()) {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("(void)pop_resource();", 21);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
				} else {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("(void)pop_u64();", 16);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
				}
				mw_put_3();
				mw_line_3();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_drop();
	} else {
		{
			VAL d3 = pop_value();
			push_u64(0LL); // L0
			push_value(d3);
		}
		mw_pat_cname_1();
		mw_c99_call_21__1();
	}
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
}
static void mw_c99_label_defs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_12();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_label_def_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_label_def_21__1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("static VAL lbl_", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_name_14();
	mw_mangled_1();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" = MKNIL_C;", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_label_push_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("LPUSH(lbl_", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_name_14();
	mw_mangled_1();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_label_pop_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("LPOP(lbl_", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_name_14();
	mw_mangled_1();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_int_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_i64(", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_show_1();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("LL);", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_str_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("{", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("static bool vready = false;", 27);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("static VAL v;", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("if (! vready) {", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mp_prim_dup();
	mw_num_bytes_1();
	push_i64(4090LL);
	mw__3E_Size_1();
	mw__3E__5();
	if (pop_u64()) {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("v = mkstr(", 10);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		mw_depth_40__1();
		mw_1_2B__2();
		mw_depth_21__1();
		mw_indent_1();
		mp_prim_dup();
		mw_put_cstr_long_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(",", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		mw_indent_1();
		mp_prim_dup();
		mw_num_bytes_1();
		mw_show_4();
		mw_put_3();
		mw_line_3();
		mw_depth_40__1();
		mw_1__2();
		mw_depth_21__1();
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("v = mkstr(", 10);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_put_cstr_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_num_bytes_1();
		mw_show_4();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	}
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("vready = true;", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_value(v);", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("incref(v);", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mp_prim_drop();
}
static void mw_put_cstr_long_1 (void) {
	push_u64(34LL); // BQUOTE
	mw_put_byte_2();
	push_u64(0LL); // BNUL
	mp_prim_swap();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Nat_7();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					push_resource(MKU64(0LL)); // +UNSAFE
					mw__40_Byte_1();
					mw__UNSAFE_1();
					mp_prim_swap();
					push_u64(10LL); // BLF
					mw__3D__3D__19();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							push_u64(34LL); // BQUOTE
							mw_put_byte_2();
							mw_line_3();
							mw_indent_1();
							push_u64(34LL); // BQUOTE
							mw_put_byte_2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mp_prim_dup();
					mw_c99_string_byte_21__1();
					push_i64(1LL);
					mw__3E_Offset_1();
					push_value(d5);
				}
				push_resource(MKU64(0LL)); // +UNSAFE
				mw_offset_1();
				mw__UNSAFE_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		mp_prim_drop();
		push_value(d2);
	}
	mp_prim_drop();
	push_u64(34LL); // BQUOTE
	mw_put_byte_2();
	mp_prim_drop();
}
static void mw_put_cstr_1 (void) {
	push_u64(34LL); // BQUOTE
	mw_put_byte_2();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_str_base();
			push_value(d3);
		}
		mw_num_bytes_1();
		mw__3E_Nat_7();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					push_resource(MKU64(0LL)); // +UNSAFE
					mw__40_Byte_1();
					mw__UNSAFE_1();
					mw_c99_string_byte_21__1();
					push_i64(1LL);
					mw__3E_Offset_1();
					push_value(d5);
				}
				push_resource(MKU64(0LL)); // +UNSAFE
				mw_offset_1();
				mw__UNSAFE_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		mp_prim_drop();
		push_value(d2);
	}
	mp_prim_drop();
	push_u64(34LL); // BQUOTE
	mw_put_byte_2();
}
static void mw_c99_string_byte_21__1 (void) {
	switch (get_top_data_tag()) {
		case 92LL: // B'\'
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\\\\", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			break;
		case 34LL: // BQUOTE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\\\"", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			break;
		case 9LL: // BHT
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\\t", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			break;
		case 10LL: // BLF
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\\n", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			break;
		case 13LL: // BCR
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\\r", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			break;
		default:
			mp_prim_dup();
			push_u64(32LL); // BSPACE
			push_u64(126LL); // B'~'
			mw_in_range_2();
			if (pop_u64()) {
				mw_put_byte_2();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\\x", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_to_hexdigits_1();
				{
					VAL d5 = pop_value();
					mw_put_byte_2();
					push_value(d5);
				}
				mw_put_byte_2();
			}
			break;
	}
}
static void mw_c99_prim_21__1 (void) {
	switch (get_top_data_tag()) {
		case 4LL: // PRIM_CORE_DIP
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 1LL: // L1
					mtp_L1_1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("{", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1_2B__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("VAL d", 5);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_depth_40__1();
					mw_show_2();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" = pop_value();", 15);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_c99_arg_run_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("push_value(d", 12);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_depth_40__1();
					mw_show_2();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(");", 2);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("}", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					break;
				default:
					push_u64(4LL); // PRIM_CORE_DIP
					mw_c99_prim_default_21__1();
					break;
			}
			break;
		case 13LL: // PRIM_CORE_RDIP
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 1LL: // L1
					mtp_L1_1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("{", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1_2B__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("VAL d", 5);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_depth_40__1();
					mw_show_2();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" = pop_resource();", 18);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_c99_arg_run_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("push_resource(d", 15);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_depth_40__1();
					mw_show_2();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(");", 2);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("}", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					break;
				default:
					push_u64(13LL); // PRIM_CORE_RDIP
					mw_c99_prim_default_21__1();
					break;
			}
			break;
		case 5LL: // PRIM_CORE_IF
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 2LL: // L2
					mtp_L2_1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("if (pop_u64()) {", 16);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1_2B__2();
					mw_depth_21__1();
					mp_prim_swap();
					mw_c99_arg_run_21__1();
					mw_depth_40__1();
					mw_1__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("} else {", 8);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1_2B__2();
					mw_depth_21__1();
					mw_c99_arg_run_21__1();
					mw_depth_40__1();
					mw_1__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("}", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					break;
				default:
					push_u64(5LL); // PRIM_CORE_IF
					mw_c99_prim_default_21__1();
					break;
			}
			break;
		case 6LL: // PRIM_CORE_WHILE
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 2LL: // L2
					mtp_L2_1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("while(1) {", 10);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_depth_40__1();
					mw_1_2B__2();
					mw_depth_21__1();
					mp_prim_swap();
					mw_c99_arg_run_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("if (! pop_u64()) break;", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_c99_arg_run_21__1();
					mw_depth_40__1();
					mw_1__2();
					mw_depth_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("}", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					break;
				default:
					push_u64(6LL); // PRIM_CORE_WHILE
					mw_c99_prim_default_21__1();
					break;
			}
			break;
		default:
			mw_c99_prim_default_21__1();
			break;
	}
}
static void mw_c99_prim_default_21__1 (void) {
	mw_cname_4();
	mw_c99_call_21__1();
}
static void mw_c99_args_push_21__1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_c99_arg_push_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_c99_arg_push_21__1();
				push_value(d4);
			}
			mw_c99_arg_push_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_arg_push_21__1();
					push_value(d5);
				}
				mw_c99_arg_push_21__1();
				push_value(d4);
			}
			mw_c99_arg_push_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2119();
				push_value(d4);
			}
			mw_for_3_2119();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_c99_arg_push_21__1 (void) {
	mw_c99_block_push_21__1();
}
static void mw_c99_arg_run_21__1 (void) {
	mw_c99_block_run_21__1();
}
static void mw_c99_block_run_21__1 (void) {
	mw_arrow_5();
	mw_c99_arrow_21__1();
}
static void mw_var_put_1 (void) {
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("var_", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_name_4();
	mw_mangled_1();
	mw_put_3();
}
static void mw_param_put_1 (void) {
	mw__3E_Var_1();
	mw_var_put_1();
}
static void mw_c99_pack_closure_vars_21__1 (void) {
	mw_filter_2_2215();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_c99_var_push_21__1();
			push_u64(0LL); // L0
			push_u64(28LL); // PRIM_PACK_CONS
			mw_cname_4();
			mw_c99_call_21__1();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_c99_var_push_21__1();
				push_u64(0LL); // L0
				push_u64(28LL); // PRIM_PACK_CONS
				mw_cname_4();
				mw_c99_call_21__1();
				push_value(d4);
			}
			mw_c99_var_push_21__1();
			push_u64(0LL); // L0
			push_u64(28LL); // PRIM_PACK_CONS
			mw_cname_4();
			mw_c99_call_21__1();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_var_push_21__1();
					push_u64(0LL); // L0
					push_u64(28LL); // PRIM_PACK_CONS
					mw_cname_4();
					mw_c99_call_21__1();
					push_value(d5);
				}
				mw_c99_var_push_21__1();
				push_u64(0LL); // L0
				push_u64(28LL); // PRIM_PACK_CONS
				mw_cname_4();
				mw_c99_call_21__1();
				push_value(d4);
			}
			mw_c99_var_push_21__1();
			push_u64(0LL); // L0
			push_u64(28LL); // PRIM_PACK_CONS
			mw_cname_4();
			mw_c99_call_21__1();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2216();
				push_value(d4);
			}
			mw_for_3_2216();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_c99_unpack_closure_vars_21__1 (void) {
	mw_filter_2_2219();
	mp_prim_dup();
	mw_empty_3F__4();
	if (pop_u64()) {
		mp_prim_drop();
	} else {
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				push_u64(0LL); // L0
				push_u64(29LL); // PRIM_PACK_UNCONS
				mw_cname_4();
				mw_c99_call_21__1();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				break;
			case 2LL: // L2
				mtp_L2_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					push_u64(0LL); // L0
					push_u64(29LL); // PRIM_PACK_UNCONS
					mw_cname_4();
					mw_c99_call_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("VAL ", 4);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_var_put_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" = pop_value();", 15);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					push_value(d5);
				}
				push_u64(0LL); // L0
				push_u64(29LL); // PRIM_PACK_UNCONS
				mw_cname_4();
				mw_c99_call_21__1();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				break;
			case 3LL: // L3
				mtp_L3_1();
				mw_rotr_1();
				mw_dip2_1_2222();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					push_u64(0LL); // L0
					push_u64(29LL); // PRIM_PACK_UNCONS
					mw_cname_4();
					mw_c99_call_21__1();
					mw_indent_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("VAL ", 4);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_var_put_1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" = pop_value();", 15);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					push_value(d5);
				}
				push_u64(0LL); // L0
				push_u64(29LL); // PRIM_PACK_UNCONS
				mw_cname_4();
				mw_c99_call_21__1();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_reverse_for_2_2222();
					push_value(d5);
				}
				mw_reverse_for_2_2222();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("pop_value();", 12);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	}
}
static void mw_c99_decref_closure_vars_21__1 (void) {
	mw_filter_2_2225();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_rotr_1();
			mw_dip2_1_2226();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2226();
				push_value(d4);
			}
			mw_reverse_for_2_2226();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_c99_block_push_21__1 (void) {
	mp_prim_dup();
	mw_to_run_var_3();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_nip_1();
			mw_c99_var_push_21__1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("push_fnptr(&", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_cname_7();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mp_prim_dup();
			mw_free_vars_6();
			mw_c99_pack_closure_vars_21__1();
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_c99_var_21__1 (void) {
	mp_prim_dup();
	mw_auto_run_3F__1();
	if (pop_u64()) {
		mw_c99_var_run_21__1();
	} else {
		mw_c99_var_push_21__1();
	}
}
static void mw_c99_var_run_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("incref(", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_var_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("run_value(", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_var_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mp_prim_drop();
}
static void mw_c99_var_push_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("incref(", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_var_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_value(", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mp_prim_dup();
	mw_var_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mp_prim_drop();
}
static void mw_c99_lambda_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("{", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mp_prim_dup();
	mw_params_3();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_rotr_1();
			mw_dip2_1_2191();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2191();
				push_value(d4);
			}
			mw_reverse_for_2_2191();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mp_prim_dup();
	mw_body_9();
	mw_c99_arrow_21__1();
	mw_params_3();
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L2
			mtp_L2_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // L3
			mtp_L3_1();
			mw_rotr_1();
			mw_dip2_1_2193();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2193();
				push_value(d4);
			}
			mw_reverse_for_2_2193();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_match_21__1 (void) {
	mp_prim_dup();
	mw_is_transparent_3F__1();
	if (pop_u64()) {
		mw_cases_4();
		mw_first_1();
		mw_unwrap_1();
		mw_body_5();
		mw_c99_arrow_21__1();
	} else {
		mp_prim_dup();
		mw_scrutinee_data_3F__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				mw_token_6();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("non-uniform match, not supported at present", 43);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mp_prim_id();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_is_resource_3F__2();
		if (pop_u64()) {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("switch (get_top_resource_data_tag()) {", 38);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		} else {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("switch (get_top_data_tag()) {", 29);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		}
		mw_depth_40__1();
		mw_1_2B__2();
		mw_depth_21__1();
		mp_prim_dup();
		mw_cases_4();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				mw_c99_case_21__1();
				break;
			case 2LL: // L2
				mtp_L2_1();
				{
					VAL d5 = pop_value();
					mw_c99_case_21__1();
					push_value(d5);
				}
				mw_c99_case_21__1();
				break;
			case 3LL: // L3
				mtp_L3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_c99_case_21__1();
						push_value(d6);
					}
					mw_c99_case_21__1();
					push_value(d5);
				}
				mw_c99_case_21__1();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				{
					VAL d5 = pop_value();
					mw_for_3_2183();
					push_value(d5);
				}
				mw_for_3_2183();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_has_default_case_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // T
				(void)pop_u64();
				mp_prim_id();
				break;
			case 0LL: // F
				(void)pop_u64();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("default:", 8);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_depth_40__1();
				mw_1_2B__2();
				mw_depth_21__1();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("push_value(mkstr(\"unexpected fallthrough in match\\n\", 32)); ", 60);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_u64(0LL); // L0
				push_u64(8LL); // PRIM_CORE_PANIC
				mw_cname_4();
				mw_c99_call_21__1();
				mw_depth_40__1();
				mw_1__2();
				mw_depth_21__1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_depth_40__1();
		mw_1__2();
		mw_depth_21__1();
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("}", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	}
}
static void mw_c99_case_21__1 (void) {
	mp_prim_dup();
	mw_pattern_4();
	mw_c99_pattern_21__1();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mw_body_5();
	mw_c99_arrow_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("break;", 6);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
}
static void mw_c99_pattern_21__1 (void) {
	mp_prim_dup();
	mw_is_default_3F__1();
	if (pop_u64()) {
		mp_prim_drop();
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("default:", 8);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		mp_prim_dup();
		mw_single_tag_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				mw_nip_1();
				mw_c99_tag_case_pat_21__1();
				break;
			case 0LL: // NONE
				(void)pop_u64();
				mw_token_start_2();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("c99 target -- don't know how to compile this pattern", 52);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
	}
}
static void mw_c99_word_sigs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_1();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw__2F_MKC99_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_resource();
						mw_needed_3F__1();
						push_resource(d6);
					}
					push_value(d5);
				}
				push_value(d4);
			}
			mtw_MKC99_1();
			if (pop_u64()) {
				mw_c99_word_sig_21__1();
			} else {
				mp_prim_drop();
			}
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_word_sig_21__1 (void) {
	mw_indent_1();
	mw_cname_1();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(";", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_block_sigs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_17();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw__2F_MKC99_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_resource();
						mw_needed_3F__3();
						push_resource(d6);
					}
					push_value(d5);
				}
				push_value(d4);
			}
			mtw_MKC99_1();
			if (pop_u64()) {
				mw_c99_block_sig_21__1();
			} else {
				mp_prim_drop();
			}
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_block_sig_21__1 (void) {
	mw_indent_1();
	mw_cname_7();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(";", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_field_sigs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_7();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_field_sig_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_field_sig_21__1 (void) {
	mw_indent_1();
	mw_cname_3();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(";", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_block_enter_21__1 (void) {
	mw_emit_debug_info_3F__1();
	if (pop_u64()) {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("WORD_ENTER(", 11);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_cname_7();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_home_11();
		switch (get_top_data_tag()) {
			case 0LL: // HOME_MAIN
				mtp_HOME_5F_MAIN_1();
				mp_prim_drop();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("block", 5);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				break;
			case 1LL: // HOME_WORD
				mtp_HOME_5F_WORD_1();
				mw_name_2();
				mw__3E_Str_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" block", 6);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_put_cstr_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_token_12();
		mw_module_3();
		mw_source_path_1();
		mw__3E_Str_1();
		mw_put_cstr_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_token_12();
		mw_row_1();
		mw__3E_Int_19();
		mw_show_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_token_12();
		mw_col_1();
		mw__3E_Int_18();
		mw_show_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		mp_prim_drop();
	} else {
		mp_prim_drop();
	}
}
static void mw_c99_block_exit_21__1 (void) {
	mw_emit_debug_info_3F__1();
	if (pop_u64()) {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("WORD_EXIT(", 10);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_cname_7();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		mp_prim_drop();
	}
}
static void mw_c99_block_defs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_17();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw__2F_MKC99_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_resource();
						mw_needed_3F__3();
						push_resource(d6);
					}
					push_value(d5);
				}
				push_value(d4);
			}
			mtw_MKC99_1();
			if (pop_u64()) {
				mw_c99_block_def_21__1();
			} else {
				mp_prim_drop();
			}
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_block_def_21__1 (void) {
	mw_indent_1();
	mp_prim_dup();
	mw_cname_7();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mp_prim_dup();
	mw_c99_block_enter_21__1();
	mp_prim_dup();
	mw_arrow_5();
	mp_prim_dup();
	mw_free_vars_4();
	mw_c99_unpack_closure_vars_21__1();
	mp_prim_dup();
	mw_c99_arrow_21__1();
	mw_free_vars_4();
	mw_c99_decref_closure_vars_21__1();
	mw_c99_block_exit_21__1();
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_c99_word_enter_21__1 (void) {
	mw_emit_debug_info_3F__1();
	if (pop_u64()) {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("WORD_ENTER(", 11);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_cname_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_name_2();
		mw__3E_Str_3();
		mw_put_cstr_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_body_1();
		mw_module_3();
		mw_source_path_1();
		mw__3E_Str_1();
		mw_put_cstr_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_body_1();
		mw_row_1();
		mw__3E_Int_19();
		mw_show_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(", ", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mp_prim_dup();
		mw_body_1();
		mw_col_1();
		mw__3E_Int_18();
		mw_show_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		mp_prim_drop();
	} else {
		mp_prim_drop();
	}
}
static void mw_c99_word_exit_21__1 (void) {
	mw_emit_debug_info_3F__1();
	if (pop_u64()) {
		mw_indent_1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("WORD_EXIT(", 10);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_cname_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		mp_prim_drop();
	}
}
static void mw_c99_word_defs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_1();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw__2F_MKC99_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_resource();
						mw_needed_3F__1();
						push_resource(d6);
					}
					push_value(d5);
				}
				push_value(d4);
			}
			mtw_MKC99_1();
			if (pop_u64()) {
				mw_c99_word_def_21__1();
			} else {
				mp_prim_drop();
			}
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_word_def_21__1 (void) {
	mw_indent_1();
	mp_prim_dup();
	mw_cname_1();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mp_prim_dup();
	mw_c99_word_enter_21__1();
	mp_prim_dup();
	mw_arrow_2();
	mw_c99_arrow_21__1();
	mp_prim_dup();
	mw_c99_word_exit_21__1();
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mp_prim_drop();
}
static void mw_c99_field_defs_21__1 (void) {
	push_i64(1LL);
	while(1) {
		mp_prim_dup();
		mbuf_NUM_7();
		mp_prim_u64_get();
		push_i64(1LL);
		mp_prim_int_add();
		mp_prim_int_lt();
		if (! pop_u64()) break;
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_c99_field_def_21__1();
			push_value(d3);
		}
		push_i64(1LL);
		mp_prim_int_add();
	}
	mp_prim_drop();
}
static void mw_c99_field_def_21__1 (void) {
	mp_prim_dup();
	mw_cname_3();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tsize_t i = (size_t)pop_u64();", 30);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tstatic struct VAL * p = 0;", 27);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tsize_t m = ", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_TABLE_5F_MAX_5F_COUNT_1();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(";", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tif (! p) { p = calloc(m, sizeof *p); }", 39);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tEXPECT(i<m, \"table grew too big\");", 35);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("\tpush_ptr(p+i);", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_line_3();
	mp_prim_drop();
}
static void mw_c99_main_21__1 (void) {
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("int main (int argc, char** argv) {", 34);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1_2B__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("global_argc = argc;", 19);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("global_argv = argv;", 19);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_resource(MKU64(0));", 24);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_emit_debug_info_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("WORD_ENTER(", 11);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("(void(*)(void))0, ", 18);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\"<main>\", ", 10);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_token_start_4();
			mw_module_3();
			mw_source_path_1();
			mw__3E_Str_1();
			mw_put_cstr_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", ", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_token_start_4();
			mw_row_1();
			mw__3E_Int_19();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", ", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_token_start_4();
			mw_col_1();
			mw__3E_Int_18();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_c99_arrow_21__1();
	mw_emit_debug_info_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("WORD_EXIT((void(*)(void))0);", 28);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 0LL: // F
			(void)pop_u64();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("return 0;", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_depth_40__1();
	mw_1__2();
	mw_depth_21__1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
}
static void mw_init_21__1 (void) {
	mw_init_errors_21__1();
	mw_init_types_21__1();
	mw_init_prims_21__1();
}
static void mw__2F_Arguments_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // Arguments
			mtp_Arguments_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_emit_debug_info_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = u;
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_packages_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[4];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_packages_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = u;
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_entry_point_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[3];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_entry_point_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = u;
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_output_file_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[2];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_output_file_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
		tup->cells[2] = u;
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_input_file_2 (void) {
	VAL v = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	VAL u = VTUP(v)->cells[1];
	incref(u);
	decref(v);
	push_value(u);
}
static void mw_input_file_21__1 (void) {
	VAL v = pop_value();
	VAL u = pop_value();
	ASSERT1(IS_TUP(v), v);
	ASSERT1(VTUPLEN(v) == 6, v);
	if (VTUP(v)->refs == 1) {
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
		push_value(v);
	} else {
		TUP *tup = tup_new(6);
		tup->size = 6;
		tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
		tup->cells[1] = u;
		tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
		tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
		tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
		tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
		decref(v);
		push_value(MKTUP(tup,6));
	}
}
static void mw_default_1 (void) {
	push_u64(0LL); // F
	LPUSH(lbl_emit_debug_info);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("mirth.mth", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Path_1();
	LPUSH(lbl_input_file);
	push_u64(0LL); // NONE
	LPUSH(lbl_output_file);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("main", 4);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_entry_point);
	push_u64(0LL); // L0
	LPUSH(lbl_packages);
	mtw_Arguments_2();
}
static void mw_compile_21__1 (void) {
	mw__2F_Arguments_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Compiling ", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_21__2();
	LPOP(lbl_input_file);
	mp_prim_dup();
	mw__3E_Str_1();
	mw_trace_ln_21__2();
	LPUSH(lbl_input_file);
	LPOP(lbl_packages);
	switch (get_top_data_tag()) {
		case 0LL: // L0
			(void)pop_u64();
			mp_prim_id();
			break;
		case 1LL: // L1
			mtp_L1_1();
			mw_unpack2_1();
			mp_prim_swap();
			mw__3E_Name_1();
			mw_new_or_set_path_21__1();
			mp_prim_drop();
			break;
		case 2LL: // L2
			mtp_L2_1();
			{
				VAL d4 = pop_value();
				mw_unpack2_1();
				mp_prim_swap();
				mw__3E_Name_1();
				mw_new_or_set_path_21__1();
				mp_prim_drop();
				push_value(d4);
			}
			mw_unpack2_1();
			mp_prim_swap();
			mw__3E_Name_1();
			mw_new_or_set_path_21__1();
			mp_prim_drop();
			break;
		case 3LL: // L3
			mtp_L3_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_unpack2_1();
					mp_prim_swap();
					mw__3E_Name_1();
					mw_new_or_set_path_21__1();
					mp_prim_drop();
					push_value(d5);
				}
				mw_unpack2_1();
				mp_prim_swap();
				mw__3E_Name_1();
				mw_new_or_set_path_21__1();
				mp_prim_drop();
				push_value(d4);
			}
			mw_unpack2_1();
			mp_prim_swap();
			mw__3E_Name_1();
			mw_new_or_set_path_21__1();
			mp_prim_drop();
			break;
		case 4LL: // LCAT
			mtp_LCAT_1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_152();
				push_value(d4);
			}
			mw_for_3_152();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	LPOP(lbl_input_file);
	mw_run_lexer_21__1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Building.", 9);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_trace_ln_21__2();
	mw_elab_module_21__1();
	mw_typecheck_everything_21__1();
	LPOP(lbl_entry_point);
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // NONE
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mtw_NAMESPACE_5F_MODULE_1();
				push_value(d4);
			}
			mw__3E_Name_1();
			mw_QNAME0_1();
			mw_elab_entry_point_1();
			mtw_SOME_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_nip_1();
	mvar_num_errors_1();
	mp_prim_mut_get();
	mw_0_3E__1();
	if (pop_u64()) {
		mvar_num_errors_1();
		mp_prim_mut_get();
		mw_trace_21__1();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(" errors.", 8);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_trace_ln_21__2();
		push_i64(1LL);
		mp_prim_posix_exit();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("No errors.", 10);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_trace_ln_21__2();
	}
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Specializer.", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_ln_21__2();
			mw_run_specializer_21__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Codegen.", 8);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_ln_21__2();
			LPOP(lbl_output_file);
			mw_unwrap_1();
			LPUSH(lbl_output_path);
			mw_make_1();
			mw_run_output_c99_21__1();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Skipping Codegen.", 17);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_ln_21__2();
			LPOP(lbl_emit_debug_info);
			mp_prim_drop();
			LPOP(lbl_output_file);
			mp_prim_drop();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_parse_package_def_1 (void) {
	{
		VAL d2 = pop_value();
		push_u64(58LL); // BCOLON
		push_value(d2);
	}
	mw_split_byte_2();
	switch (get_top_data_tag()) {
		case 2LL: // L2
			mtp_L2_1();
			mw__3E_Path_1();
			mw_pack2_1();
			break;
		default:
			mp_prim_drop();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("Invalid package path definition", 31);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mp_prim_panic();
			break;
	}
}
static void mw_compiler_parse_args_1 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // SHORT
			mtp_SHORT_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				push_value(d4);
			}
			switch (get_top_data_tag()) {
				case 111LL: // B'o'
					(void)pop_u64();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_output_file_2();
						mp_prim_drop();
						mw_unwrap_1();
						mw__3E_Path_1();
						mtw_SOME_1();
						push_value(d6);
					}
					mw_output_file_21__1();
					break;
				case 101LL: // B'e'
					(void)pop_u64();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_entry_point_2();
						mp_prim_drop();
						mw_unwrap_1();
						mtw_SOME_1();
						push_value(d6);
					}
					mw_entry_point_21__1();
					break;
				case 99LL: // B'c'
					(void)pop_u64();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_entry_point_2();
						mp_prim_drop();
						mp_prim_drop();
						push_u64(0LL); // NONE
						push_value(d6);
					}
					mw_entry_point_21__1();
					break;
				case 112LL: // B'p'
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						mw_unwrap_1();
						mw_parse_package_def_1();
						push_value(d6);
					}
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_packages_2();
						mw_cons_2();
						push_value(d6);
					}
					mw_packages_21__1();
					break;
				default:
					mp_prim_drop();
					mp_prim_swap();
					mp_prim_drop();
					push_u64(5LL); // UNKNOWN_ARG
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
			}
			break;
		case 2LL: // POSITIONAL
			(void)pop_u64();
			mp_prim_swap();
			mw_state_3();
			mw_positional_index_2();
			mw_0_3D__1();
			if (pop_u64()) {
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_input_file_2();
					mp_prim_drop();
					mw_unwrap_1();
					mw__3E_Path_1();
					push_value(d5);
				}
				mw_input_file_21__1();
			} else {
				{
					VAL d5 = pop_value();
					mp_prim_drop();
					push_value(d5);
				}
				push_u64(3LL); // TOO_MANY_ARGS
				mtw_SOME_1();
				mw_state_3();
				{
					VAL d5 = pop_resource();
					mw_error_21__1();
					push_resource(d5);
				}
				mw_state_21__1();
			}
			break;
		case 1LL: // LONG_ONLY
			mtp_LONG_5F_ONLY_1();
			mp_prim_dup();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("debug", 5);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3D__3D__7();
			if (pop_u64()) {
				mw_drop2_1();
				push_u64(1LL); // T
				mp_prim_swap();
				mw_emit_debug_info_21__1();
			} else {
				mw_drop2_1();
				push_u64(5LL); // UNKNOWN_ARG
				mtw_SOME_1();
				mw_state_3();
				{
					VAL d5 = pop_resource();
					mw_error_21__1();
					push_resource(d5);
				}
				mw_state_21__1();
			}
			break;
		case 3LL: // END
			(void)pop_u64();
			mw_state_3();
			mw_positional_index_2();
			push_i64(1LL);
			mp_prim_int_lt();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					push_u64(4LL); // TOO_FEW_ARGS
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_state_3();
			mw_arguments_2();
			mw_output_file_2();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mw_state_3();
					mw_arguments_2();
					mw_entry_point_2();
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_drop();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("output-file", 11);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mtw_MISSING_5F_ARG_1();
							mtw_SOME_1();
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_error_21__1();
								push_resource(d8);
							}
							mw_state_21__1();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_drop();
			break;
		default:
			mp_prim_drop();
			mp_prim_drop();
			push_u64(5LL); // UNKNOWN_ARG
			mtw_SOME_1();
			mw_state_3();
			mw_error_21__1();
			mw_state_21__1();
			break;
	}
}
static void mw_main_2 (void) {
	mw_init_21__1();
	mw_default_1();
	push_u64(0LL); // L0
	mtw__2B_LIST_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("output-file", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_name);
	push_u64(111LL); // B'o'
	mtw_SHORT_1();
	LPUSH(lbl_flag_type);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("OUTPUT_FILE", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_arg_doc);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Test argument", 13);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_doc);
	push_u64(0LL); // NONE
	LPUSH(lbl_group);
	mtw_ArgpOption_2();
	mw__3B__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("compile-only", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_name);
	push_u64(99LL); // B'c'
	mtw_SHORT_1();
	LPUSH(lbl_flag_type);
	push_u64(0LL); // NONE
	LPUSH(lbl_arg_doc);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Compile code without running codegen step", 41);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_doc);
	push_u64(0LL); // NONE
	LPUSH(lbl_group);
	mtw_ArgpOption_2();
	mw__3B__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("entry-point", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_name);
	push_u64(101LL); // B'e'
	mtw_SHORT_1();
	LPUSH(lbl_flag_type);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("ENTRY_POINT", 11);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_arg_doc);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Custom entry point word for compilation", 39);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_doc);
	push_u64(0LL); // NONE
	LPUSH(lbl_group);
	mtw_ArgpOption_2();
	mw__3B__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("package", 7);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_name);
	push_u64(112LL); // B'p'
	mtw_SHORT_1();
	LPUSH(lbl_flag_type);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("(PACKAGE:PATH)*", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_arg_doc);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Package locations", 17);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_doc);
	push_u64(0LL); // NONE
	LPUSH(lbl_group);
	mtw_ArgpOption_2();
	mw__3B__2();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("debug", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_name);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("debug", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_LONG_5F_ONLY_1();
	LPUSH(lbl_flag_type);
	push_u64(0LL); // NONE
	LPUSH(lbl_arg_doc);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Emit debugging information during codegen", 41);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_doc);
	push_u64(0LL); // NONE
	LPUSH(lbl_group);
	mtw_ArgpOption_2();
	mw__3B__2();
	mw__LIST_1();
	LPUSH(lbl_options);
	push_fnptr(&mb_99);
	mtw_SOME_1();
	LPUSH(lbl_parser);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("input-file", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mtw_SOME_1();
	LPUSH(lbl_args_doc);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("Mirth Compiler", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	LPUSH(lbl_doc);
	mtw_ArgumentParser_2();
	mw_parse_args_1();
	switch (get_top_data_tag()) {
		case 1LL: // RIGHT
			mtp_RIGHT_1();
			break;
		case 0LL: // LEFT
			mtp_LEFT_1();
			mw_show_6();
			mp_prim_panic();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_compile_21__1();
}
static void mw_filter_2_2225 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2225();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_for_2_2226 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_2226();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2226();
				push_value(d4);
			}
			mw_reverse_for_2_2226();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_2226 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_filter_3_2225 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2225();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2225();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_is_physical_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2225();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2225();
			}
			break;
	}
}
static void mw_for_3_2120 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_c99_atom_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_c99_atom_21__1();
				push_value(d4);
			}
			mw_c99_atom_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_atom_21__1();
					push_value(d5);
				}
				mw_c99_atom_21__1();
				push_value(d4);
			}
			mw_c99_atom_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2120();
				push_value(d4);
			}
			mw_for_3_2120();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_find_some_2_2334 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				mw_1__2();
				push_value(d4);
			}
			mw_over2_1();
			mw_over_1();
			mw__3D__3D__34();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			mw_find_some_aux2_1_2334();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_1__2();
						push_value(d6);
					}
					mw_over2_1();
					mw_over_1();
					mw__3D__3D__34();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2334();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_find_some_2_2334();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_reverse_find_some_2_2334();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2334 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_1__2();
			push_value(d3);
		}
		mw_over2_1();
		mw_over_1();
		mw__3D__3D__34();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			{
				VAL d4 = pop_value();
				mw_1__2();
				push_value(d4);
			}
			mw_over2_1();
			mw_over_1();
			mw__3D__3D__34();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_filter_2_2215 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2215();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_2216 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_c99_var_push_21__1();
			push_u64(0LL); // L0
			push_u64(28LL); // PRIM_PACK_CONS
			mw_cname_4();
			mw_c99_call_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_c99_var_push_21__1();
				push_u64(0LL); // L0
				push_u64(28LL); // PRIM_PACK_CONS
				mw_cname_4();
				mw_c99_call_21__1();
				push_value(d4);
			}
			mw_c99_var_push_21__1();
			push_u64(0LL); // L0
			push_u64(28LL); // PRIM_PACK_CONS
			mw_cname_4();
			mw_c99_call_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_var_push_21__1();
					push_u64(0LL); // L0
					push_u64(28LL); // PRIM_PACK_CONS
					mw_cname_4();
					mw_c99_call_21__1();
					push_value(d5);
				}
				mw_c99_var_push_21__1();
				push_u64(0LL); // L0
				push_u64(28LL); // PRIM_PACK_CONS
				mw_cname_4();
				mw_c99_call_21__1();
				push_value(d4);
			}
			mw_c99_var_push_21__1();
			push_u64(0LL); // L0
			push_u64(28LL); // PRIM_PACK_CONS
			mw_cname_4();
			mw_c99_call_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2216();
				push_value(d4);
			}
			mw_for_3_2216();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_2215 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2215();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2215();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_is_physical_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2215();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2215();
			}
			break;
	}
}
static void mw_reverse_for_2_2193 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_2193();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("decref(", 7);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2193();
				push_value(d4);
			}
			mw_reverse_for_2_2193();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_2193 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("decref(", 7);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_reverse_for_2_2191 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_2191();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_param_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2191();
				push_value(d4);
			}
			mw_reverse_for_2_2191();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_2191 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_param_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_find_some_2_2366 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_is_default_case_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2366();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_is_default_case_3F__1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2366();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2366();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2366();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2366 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_is_default_case_3F__1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_is_default_case_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_2373 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_op_2();
			mw__2F_PATOP_5F_UNDERSCORE_1();
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2373();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_op_2();
					mw__2F_PATOP_5F_UNDERSCORE_1();
					mw_not_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2373();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2373();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2373();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2373 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_op_2();
		mw__2F_PATOP_5F_UNDERSCORE_1();
		mw_not_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_op_2();
			mw__2F_PATOP_5F_UNDERSCORE_1();
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_2183 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_c99_case_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_c99_case_21__1();
				push_value(d4);
			}
			mw_c99_case_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_case_21__1();
					push_value(d5);
				}
				mw_c99_case_21__1();
				push_value(d4);
			}
			mw_c99_case_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2183();
				push_value(d4);
			}
			mw_for_3_2183();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_946 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_946();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_946 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_946();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_946();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				mw_qname_12();
				mw__3C__3D__7();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_946();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_946();
			}
			break;
	}
}
static void mw_find_some_2_2396 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw_qname_12();
			mw__3D__3D__32();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2396();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw_qname_12();
					mw__3D__3D__32();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2396();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2396();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2396();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2396 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw_qname_12();
		mw__3D__3D__32();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw_qname_12();
			mw__3D__3D__32();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_736 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw__3E_U8_3();
			mw_over_1();
			mw__21_U8_2();
			mw_1_2B__3();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw__3E_U8_3();
				mw_over_1();
				mw__21_U8_2();
				mw_1_2B__3();
				push_value(d4);
			}
			mw__3E_U8_3();
			mw_over_1();
			mw__21_U8_2();
			mw_1_2B__3();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3E_U8_3();
					mw_over_1();
					mw__21_U8_2();
					mw_1_2B__3();
					push_value(d5);
				}
				mw__3E_U8_3();
				mw_over_1();
				mw__21_U8_2();
				mw_1_2B__3();
				push_value(d4);
			}
			mw__3E_U8_3();
			mw_over_1();
			mw__21_U8_2();
			mw_1_2B__3();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_736();
				push_value(d4);
			}
			mw_for_3_736();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_1364 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1364();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_2430 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_pattern_4();
			mw_single_tag_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					{
						VAL d6 = pop_value();
						mw_over_1();
						push_value(d6);
					}
					mw_data_3();
					mw__3D__3D__35();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // F
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2430();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_pattern_4();
					mw_single_tag_3F__1();
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							{
								VAL d8 = pop_value();
								mw_over_1();
								push_value(d8);
							}
							mw_data_3();
							mw__3D__3D__35();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							push_u64(0LL); // F
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_not_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2430();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2430();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2430();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2430 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_pattern_4();
		mw_single_tag_3F__1();
		switch (get_top_data_tag()) {
			case 1LL: // SOME
				mtp_SOME_1();
				{
					VAL d5 = pop_value();
					mw_over_1();
					push_value(d5);
				}
				mw_data_3();
				mw__3D__3D__35();
				break;
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // F
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_not_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_pattern_4();
			mw_single_tag_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					{
						VAL d6 = pop_value();
						mw_over_1();
						push_value(d6);
					}
					mw_data_3();
					mw__3D__3D__35();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // F
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_filter_3_1364 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1364();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1364();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_is_default_case_3F__1();
				mw_not_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1364();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1364();
			}
			break;
	}
}
static void mw_for_3_2119 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_c99_arg_push_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_c99_arg_push_21__1();
				push_value(d4);
			}
			mw_c99_arg_push_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_c99_arg_push_21__1();
					push_value(d5);
				}
				mw_c99_arg_push_21__1();
				push_value(d4);
			}
			mw_c99_arg_push_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2119();
				push_value(d4);
			}
			mw_for_3_2119();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_2219 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2219();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_for_2_2222 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			push_u64(0LL); // L0
			push_u64(29LL); // PRIM_PACK_UNCONS
			mw_cname_4();
			mw_c99_call_21__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // L0
				push_u64(29LL); // PRIM_PACK_UNCONS
				mw_cname_4();
				mw_c99_call_21__1();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			push_u64(0LL); // L0
			push_u64(29LL); // PRIM_PACK_UNCONS
			mw_cname_4();
			mw_c99_call_21__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_2222();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // L0
				push_u64(29LL); // PRIM_PACK_UNCONS
				mw_cname_4();
				mw_c99_call_21__1();
				mw_indent_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("VAL ", 4);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_var_put_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" = pop_value();", 15);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				push_value(d4);
			}
			push_u64(0LL); // L0
			push_u64(29LL); // PRIM_PACK_UNCONS
			mw_cname_4();
			mw_c99_call_21__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2222();
				push_value(d4);
			}
			mw_reverse_for_2_2222();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_2222 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			push_u64(0LL); // L0
			push_u64(29LL); // PRIM_PACK_UNCONS
			mw_cname_4();
			mw_c99_call_21__1();
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("VAL ", 4);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_var_put_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(" = pop_value();", 15);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_filter_3_2219 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2219();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2219();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_is_physical_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2219();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2219();
			}
			break;
	}
}
static void mw_fold_2_2489 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_id();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2496();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					mp_prim_swap();
					mw_filter_2_2496();
					mw_nip_1();
					push_value(d5);
				}
				mw_cat_2();
				push_value(d4);
			}
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2496();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_fold_2_2489();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_fold_2_2489();
				push_value(d4);
			}
			mp_prim_swap();
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2496();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_2496 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2496();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_2496 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2496();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2496();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						mw__3E_List_2B__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mw_find_some_2_2506();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_some_3F__1();
						mw_nip_1();
						mw_not_1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2496();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2496();
			}
			break;
	}
}
static void mw_find_some_2_2506 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2506();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__3D__3D__21();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2506();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2506();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2506();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2506 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw__3D__3D__21();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_rotl_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_map_4_1298 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_free_vars_5();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_free_vars_5();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_5();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_5();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_5();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_5();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1298();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1298();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_2525 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2525();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_2525 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2525();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2525();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						mw__3E_List_2B__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mw_find_some_2_2535();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_some_3F__1();
						mw_nip_1();
						mw_not_1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2525();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2525();
			}
			break;
	}
}
static void mw_find_some_2_2535 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2535();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__3D__3D__21();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2535();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2535();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2535();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2535 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw__3D__3D__21();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_rotl_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_filter_2_2541 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2541();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_2541 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2541();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2541();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						mw__3E_List_2B__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mw_find_some_2_2551();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_some_3F__1();
						mw_nip_1();
						mw_not_1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2541();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2541();
			}
			break;
	}
}
static void mw_find_some_2_2551 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2551();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__3D__3D__21();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2551();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2551();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2551();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2551 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw__3D__3D__21();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_rotl_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_map_4_1305 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw__2F_PARAM_1();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw__2F_PARAM_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__2F_PARAM_1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1305();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1305();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_fold_2_2568 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_id();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2575();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					mp_prim_swap();
					mw_filter_2_2575();
					mw_nip_1();
					push_value(d5);
				}
				mw_cat_2();
				push_value(d4);
			}
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2575();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_fold_2_2568();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_fold_2_2568();
				push_value(d4);
			}
			mp_prim_swap();
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2575();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_2575 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2575();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_2575 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2575();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2575();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						mw__3E_List_2B__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mw_find_some_2_2585();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_some_3F__1();
						mw_nip_1();
						mw_not_1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2575();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2575();
			}
			break;
	}
}
static void mw_find_some_2_2585 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2585();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__3D__3D__21();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2585();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2585();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2585();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2585 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw__3D__3D__21();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_rotl_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_map_4_1303 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_free_vars_1();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_free_vars_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1303();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1303();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_fold_2_2602 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_id();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2609();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					mp_prim_swap();
					mw_filter_2_2609();
					mw_nip_1();
					push_value(d5);
				}
				mw_cat_2();
				push_value(d4);
			}
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2609();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_fold_2_2602();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_fold_2_2602();
				push_value(d4);
			}
			mp_prim_swap();
			mw_over_1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				mp_prim_swap();
				mw_filter_2_2609();
				mw_nip_1();
				push_value(d4);
			}
			mw_cat_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_2609 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_2609();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_2609 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_2609();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_2609();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						mw__3E_List_2B__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(0LL); // NONE
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mw_find_some_2_2619();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_some_3F__1();
						mw_nip_1();
						mw_not_1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_rotl_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_2609();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_2609();
			}
			break;
	}
}
static void mw_find_some_2_2619 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2619();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw__3D__3D__21();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_rotl_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2619();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2619();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2619();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2619 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw__3D__3D__21();
				push_value(d4);
			}
			push_value(d3);
		}
		mw_rotl_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3D__3D__21();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotl_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_map_4_1300 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_free_vars_3();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_free_vars_3();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_3();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1300();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1300();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_2051 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tlpush(&lbl_", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", tup->cells[", 13);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]);", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_prim_int_succ_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tlpush(&lbl_", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(", tup->cells[", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				push_value(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tlpush(&lbl_", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", tup->cells[", 13);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]);", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_prim_int_succ_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("\tlpush(&lbl_", 12);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_name_14();
					mw_mangled_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(", tup->cells[", 13);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mp_prim_dup();
					mw_show_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("]);", 3);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_prim_int_succ_1();
					push_value(d5);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tlpush(&lbl_", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(", tup->cells[", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				push_value(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tlpush(&lbl_", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(", tup->cells[", 13);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]);", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_prim_int_succ_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2051();
				push_value(d4);
			}
			mw_for_3_2051();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_for_2_2037 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\ttup->cells[", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_over_1();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("] = lpop(&lbl_", 14);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_1__2();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_over_1();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = lpop(&lbl_", 14);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				push_value(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\ttup->cells[", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_over_1();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("] = lpop(&lbl_", 14);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_1__2();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_2037();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_over_1();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = lpop(&lbl_", 14);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				push_value(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\ttup->cells[", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_over_1();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("] = lpop(&lbl_", 14);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_1__2();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2037();
				push_value(d4);
			}
			mw_reverse_for_2_2037();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_2037 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\ttup->cells[", 12);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_over_1();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("] = lpop(&lbl_", 14);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_name_14();
			mw_mangled_1();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(");", 2);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
			mw_1__2();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_for_3_2273 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_run_atom_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_run_atom_21__1();
				push_value(d4);
			}
			mw_run_atom_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_run_atom_21__1();
					push_value(d5);
				}
				mw_run_atom_21__1();
				push_value(d4);
			}
			mw_run_atom_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2273();
				push_value(d4);
			}
			mw_for_3_2273();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_2283 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_run_case_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_run_case_21__1();
				push_value(d4);
			}
			mw_run_case_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_run_case_21__1();
					push_value(d5);
				}
				mw_run_case_21__1();
				push_value(d4);
			}
			mw_run_case_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2283();
				push_value(d4);
			}
			mw_for_3_2283();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_2284 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_run_patatom_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_run_patatom_21__1();
				push_value(d4);
			}
			mw_run_patatom_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_run_patatom_21__1();
					push_value(d5);
				}
				mw_run_patatom_21__1();
				push_value(d4);
			}
			mw_run_patatom_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2284();
				push_value(d4);
			}
			mw_for_3_2284();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_2280 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_push_arg_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_push_arg_21__1();
				push_value(d4);
			}
			mw_push_arg_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_push_arg_21__1();
					push_value(d5);
				}
				mw_push_arg_21__1();
				push_value(d4);
			}
			mw_push_arg_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_2280();
				push_value(d4);
			}
			mw_for_3_2280();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip_27__1_1897 (void) {
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw_check_atom_21__1();
		push_value(d2);
	}
	mp_prim_swap();
}
static void mw_flatmap_2_1897 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_check_atom_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_check_atom_21__1();
				push_value(d4);
			}
			mw_dip_27__1_1897();
			mw_cat_2();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_atom_21__1();
					push_value(d5);
				}
				mw_dip_27__1_1897();
				mw_cat_2();
				push_value(d4);
			}
			mw_dip_27__1_1897();
			mw_cat_2();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_flatmap_2_1897();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_flatmap_2_1897();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_map_4_1913 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_check_case_21__1();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_check_case_21__1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_check_case_21__1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_case_21__1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_case_21__1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_case_21__1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1913();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1913();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1905 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_check_arg_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_check_arg_21__1();
				push_value(d4);
			}
			mw_check_arg_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_arg_21__1();
					push_value(d5);
				}
				mw_check_arg_21__1();
				push_value(d4);
			}
			mw_check_arg_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1905();
				push_value(d4);
			}
			mw_for_3_1905();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_map_4_1906 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_free_vars_3();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_free_vars_3();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_free_vars_3();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_free_vars_3();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1906();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1906();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_165 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__9();
			push_u64(1LL); // T
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__9();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__9();
			push_u64(1LL); // T
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_trace_21__9();
					push_u64(1LL); // T
					push_value(d5);
				}
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__9();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__9();
			push_u64(1LL); // T
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_165();
				push_value(d4);
			}
			mw_for_3_165();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_163 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__11();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_trace_21__11();
					push_u64(1LL); // T
					push_value(d5);
				}
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_trace_21__11();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_163();
				push_value(d4);
			}
			mw_for_3_163();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_160 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_unpack2_1();
			mw__3E_Str_6();
			mw_trace_21__2();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(":", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_unpack2_1();
				mw__3E_Str_6();
				mw_trace_21__2();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(":", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_trace_21__2();
				mw_trace_21__11();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_unpack2_1();
			mw__3E_Str_6();
			mw_trace_21__2();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(":", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_swap();
					switch (get_top_data_tag()) {
						case 1LL: // T
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr(" ", 1);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mw_trace_21__2();
							break;
						case 0LL: // F
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_unpack2_1();
					mw__3E_Str_6();
					mw_trace_21__2();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(":", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					mw_trace_21__11();
					push_u64(1LL); // T
					push_value(d5);
				}
				mp_prim_swap();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_trace_21__2();
						break;
					case 0LL: // F
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_unpack2_1();
				mw__3E_Str_6();
				mw_trace_21__2();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(":", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_trace_21__2();
				mw_trace_21__11();
				push_u64(1LL); // T
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_trace_21__2();
					break;
				case 0LL: // F
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_unpack2_1();
			mw__3E_Str_6();
			mw_trace_21__2();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(":", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_trace_21__2();
			mw_trace_21__11();
			push_u64(1LL); // T
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_160();
				push_value(d4);
			}
			mw_for_3_160();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1952 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_synth_atom_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_synth_atom_21__1();
				push_value(d4);
			}
			mw_synth_atom_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_synth_atom_21__1();
					push_value(d5);
				}
				mw_synth_atom_21__1();
				push_value(d4);
			}
			mw_synth_atom_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1952();
				push_value(d4);
			}
			mw_for_3_1952();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_2799 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw_key_2();
			mw__3D__3D__21();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2799();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw_key_2();
					mw__3D__3D__21();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2799();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2799();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2799();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2799 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw_key_2();
		mw__3D__3D__21();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw_key_2();
			mw__3D__3D__21();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_2808 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw_key_2();
			mw__3D__3D__21();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2808();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw_key_2();
					mw__3D__3D__21();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2808();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2808();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2808();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2808 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw_key_2();
		mw__3D__3D__21();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw_key_2();
			mw__3D__3D__21();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_reverse_for_2_2817 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_2817();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_2817();
				push_value(d4);
			}
			mw_reverse_for_2_2817();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_2817 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_for_3_1963 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_pattern_4();
			mw_token_start_2();
			mw_over_1();
			mw_body_5();
			mw_token_start_4();
			{
				VAL d4 = pop_value();
				mw_home_2();
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mw_ctx_5();
				mp_prim_dup();
				LPUSH(lbl_outer_ctx);
				LPUSH(lbl_inner_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_saved);
				mw_dom_4();
				mp_prim_dup();
				LPUSH(lbl_mid);
				LPUSH(lbl_cod);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_PATTERN_1();
				{
					VAL d5 = pop_resource();
					mw_thaw_3();
					mp_prim_dup();
					mw_pattern_4();
					mw_atoms_2();
					switch (get_top_data_tag()) {
						case 0LL: // L0
							(void)pop_u64();
							mp_prim_id();
							break;
						case 1LL: // L1
							mtp_L1_1();
							mw_op_2();
							mw_op_21__1();
							break;
						case 2LL: // L2
							mtp_L2_1();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_op_2();
								mw_op_21__1();
								push_value(d8);
							}
							mw_op_2();
							mw_op_21__1();
							break;
						case 3LL: // L3
							mtp_L3_1();
							mw_rotr_1();
							mw_dip2_1_1966();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_op_2();
								mw_op_21__1();
								push_value(d8);
							}
							mw_op_2();
							mw_op_21__1();
							break;
						case 4LL: // LCAT
							mtp_LCAT_1();
							mp_prim_drop();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_reverse_for_2_1966();
								push_value(d8);
							}
							mw_reverse_for_2_1966();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_freeze_3();
					push_resource(d5);
				}
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL var_pat = pop_value();
				incref(var_pat);
				push_value(var_pat);
				mw_inner_ctx_3();
				incref(var_pat);
				push_value(var_pat);
				mw_dom_7();
				mw_cod_4();
				mw_T__3E__1();
				mw_rotl_1();
				mw_home_2();
				{
					VAL d5 = pop_resource();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_unpack_1();
							mw_rotr_1();
							push_value(d7);
						}
						push_value(d6);
					}
					LPUSH(lbl_home);
					mp_prim_dup();
					LPUSH(lbl_token_start);
					LPUSH(lbl_token_end);
					mp_prim_dup();
					LPUSH(lbl_dom);
					LPUSH(lbl_cod);
					LPUSH(lbl_ctx);
					push_u64(0LL); // L0
					LPUSH(lbl_atoms);
					mtw_ARROW_1();
					LPUSH(lbl_arrow);
					mtw_MKAB_1();
					{
						VAL d6 = pop_value();
						mtw__2B_SPSYNTH_1();
						mw_body_5();
						mw_synth_arrow_21__1();
						mw__2F__2B_SPSYNTH_1();
						push_value(d6);
					}
					mw_ab_unify_type_21__1();
					mw__2F_MKAB_1();
					LPOP(lbl_arrow);
					push_resource(d5);
				}
				LPUSH(lbl_body);
				incref(var_pat);
				push_value(var_pat);
				LPUSH(lbl_pattern);
				mtw_CASE_1();
				mw_add_case_1();
				decref(var_pat);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_pattern_4();
				mw_token_start_2();
				mw_over_1();
				mw_body_5();
				mw_token_start_4();
				{
					VAL d5 = pop_value();
					mw_home_2();
					LPUSH(lbl_home);
					mp_prim_dup();
					LPUSH(lbl_token_start);
					LPUSH(lbl_token_end);
					mw_ctx_5();
					mp_prim_dup();
					LPUSH(lbl_outer_ctx);
					LPUSH(lbl_inner_ctx);
					push_u64(0LL); // L0
					LPUSH(lbl_saved);
					mw_dom_4();
					mp_prim_dup();
					LPUSH(lbl_mid);
					LPUSH(lbl_cod);
					push_u64(0LL); // L0
					LPUSH(lbl_atoms);
					mtw_PATTERN_1();
					{
						VAL d6 = pop_resource();
						mw_thaw_3();
						mp_prim_dup();
						mw_pattern_4();
						mw_atoms_2();
						switch (get_top_data_tag()) {
							case 0LL: // L0
								(void)pop_u64();
								mp_prim_id();
								break;
							case 1LL: // L1
								mtp_L1_1();
								mw_op_2();
								mw_op_21__1();
								break;
							case 2LL: // L2
								mtp_L2_1();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_op_2();
									mw_op_21__1();
									push_value(d9);
								}
								mw_op_2();
								mw_op_21__1();
								break;
							case 3LL: // L3
								mtp_L3_1();
								mw_rotr_1();
								mw_dip2_1_1966();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_op_2();
									mw_op_21__1();
									push_value(d9);
								}
								mw_op_2();
								mw_op_21__1();
								break;
							case 4LL: // LCAT
								mtp_LCAT_1();
								mp_prim_drop();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_reverse_for_2_1966();
									push_value(d9);
								}
								mw_reverse_for_2_1966();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_freeze_3();
						push_resource(d6);
					}
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL var_pat = pop_value();
					incref(var_pat);
					push_value(var_pat);
					mw_inner_ctx_3();
					incref(var_pat);
					push_value(var_pat);
					mw_dom_7();
					mw_cod_4();
					mw_T__3E__1();
					mw_rotl_1();
					mw_home_2();
					{
						VAL d6 = pop_resource();
						{
							VAL d7 = pop_value();
							{
								VAL d8 = pop_value();
								mw_unpack_1();
								mw_rotr_1();
								push_value(d8);
							}
							push_value(d7);
						}
						LPUSH(lbl_home);
						mp_prim_dup();
						LPUSH(lbl_token_start);
						LPUSH(lbl_token_end);
						mp_prim_dup();
						LPUSH(lbl_dom);
						LPUSH(lbl_cod);
						LPUSH(lbl_ctx);
						push_u64(0LL); // L0
						LPUSH(lbl_atoms);
						mtw_ARROW_1();
						LPUSH(lbl_arrow);
						mtw_MKAB_1();
						{
							VAL d7 = pop_value();
							mtw__2B_SPSYNTH_1();
							mw_body_5();
							mw_synth_arrow_21__1();
							mw__2F__2B_SPSYNTH_1();
							push_value(d7);
						}
						mw_ab_unify_type_21__1();
						mw__2F_MKAB_1();
						LPOP(lbl_arrow);
						push_resource(d6);
					}
					LPUSH(lbl_body);
					incref(var_pat);
					push_value(var_pat);
					LPUSH(lbl_pattern);
					mtw_CASE_1();
					mw_add_case_1();
					decref(var_pat);
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_pattern_4();
			mw_token_start_2();
			mw_over_1();
			mw_body_5();
			mw_token_start_4();
			{
				VAL d4 = pop_value();
				mw_home_2();
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mw_ctx_5();
				mp_prim_dup();
				LPUSH(lbl_outer_ctx);
				LPUSH(lbl_inner_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_saved);
				mw_dom_4();
				mp_prim_dup();
				LPUSH(lbl_mid);
				LPUSH(lbl_cod);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_PATTERN_1();
				{
					VAL d5 = pop_resource();
					mw_thaw_3();
					mp_prim_dup();
					mw_pattern_4();
					mw_atoms_2();
					switch (get_top_data_tag()) {
						case 0LL: // L0
							(void)pop_u64();
							mp_prim_id();
							break;
						case 1LL: // L1
							mtp_L1_1();
							mw_op_2();
							mw_op_21__1();
							break;
						case 2LL: // L2
							mtp_L2_1();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_op_2();
								mw_op_21__1();
								push_value(d8);
							}
							mw_op_2();
							mw_op_21__1();
							break;
						case 3LL: // L3
							mtp_L3_1();
							mw_rotr_1();
							mw_dip2_1_1966();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_op_2();
								mw_op_21__1();
								push_value(d8);
							}
							mw_op_2();
							mw_op_21__1();
							break;
						case 4LL: // LCAT
							mtp_LCAT_1();
							mp_prim_drop();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_reverse_for_2_1966();
								push_value(d8);
							}
							mw_reverse_for_2_1966();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_freeze_3();
					push_resource(d5);
				}
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL var_pat = pop_value();
				incref(var_pat);
				push_value(var_pat);
				mw_inner_ctx_3();
				incref(var_pat);
				push_value(var_pat);
				mw_dom_7();
				mw_cod_4();
				mw_T__3E__1();
				mw_rotl_1();
				mw_home_2();
				{
					VAL d5 = pop_resource();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_unpack_1();
							mw_rotr_1();
							push_value(d7);
						}
						push_value(d6);
					}
					LPUSH(lbl_home);
					mp_prim_dup();
					LPUSH(lbl_token_start);
					LPUSH(lbl_token_end);
					mp_prim_dup();
					LPUSH(lbl_dom);
					LPUSH(lbl_cod);
					LPUSH(lbl_ctx);
					push_u64(0LL); // L0
					LPUSH(lbl_atoms);
					mtw_ARROW_1();
					LPUSH(lbl_arrow);
					mtw_MKAB_1();
					{
						VAL d6 = pop_value();
						mtw__2B_SPSYNTH_1();
						mw_body_5();
						mw_synth_arrow_21__1();
						mw__2F__2B_SPSYNTH_1();
						push_value(d6);
					}
					mw_ab_unify_type_21__1();
					mw__2F_MKAB_1();
					LPOP(lbl_arrow);
					push_resource(d5);
				}
				LPUSH(lbl_body);
				incref(var_pat);
				push_value(var_pat);
				LPUSH(lbl_pattern);
				mtw_CASE_1();
				mw_add_case_1();
				decref(var_pat);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_pattern_4();
					mw_token_start_2();
					mw_over_1();
					mw_body_5();
					mw_token_start_4();
					{
						VAL d6 = pop_value();
						mw_home_2();
						LPUSH(lbl_home);
						mp_prim_dup();
						LPUSH(lbl_token_start);
						LPUSH(lbl_token_end);
						mw_ctx_5();
						mp_prim_dup();
						LPUSH(lbl_outer_ctx);
						LPUSH(lbl_inner_ctx);
						push_u64(0LL); // L0
						LPUSH(lbl_saved);
						mw_dom_4();
						mp_prim_dup();
						LPUSH(lbl_mid);
						LPUSH(lbl_cod);
						push_u64(0LL); // L0
						LPUSH(lbl_atoms);
						mtw_PATTERN_1();
						{
							VAL d7 = pop_resource();
							mw_thaw_3();
							mp_prim_dup();
							mw_pattern_4();
							mw_atoms_2();
							switch (get_top_data_tag()) {
								case 0LL: // L0
									(void)pop_u64();
									mp_prim_id();
									break;
								case 1LL: // L1
									mtp_L1_1();
									mw_op_2();
									mw_op_21__1();
									break;
								case 2LL: // L2
									mtp_L2_1();
									mp_prim_swap();
									{
										VAL d10 = pop_value();
										mw_op_2();
										mw_op_21__1();
										push_value(d10);
									}
									mw_op_2();
									mw_op_21__1();
									break;
								case 3LL: // L3
									mtp_L3_1();
									mw_rotr_1();
									mw_dip2_1_1966();
									mp_prim_swap();
									{
										VAL d10 = pop_value();
										mw_op_2();
										mw_op_21__1();
										push_value(d10);
									}
									mw_op_2();
									mw_op_21__1();
									break;
								case 4LL: // LCAT
									mtp_LCAT_1();
									mp_prim_drop();
									mp_prim_swap();
									{
										VAL d10 = pop_value();
										mw_reverse_for_2_1966();
										push_value(d10);
									}
									mw_reverse_for_2_1966();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							mw_freeze_3();
							push_resource(d7);
						}
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL var_pat = pop_value();
						incref(var_pat);
						push_value(var_pat);
						mw_inner_ctx_3();
						incref(var_pat);
						push_value(var_pat);
						mw_dom_7();
						mw_cod_4();
						mw_T__3E__1();
						mw_rotl_1();
						mw_home_2();
						{
							VAL d7 = pop_resource();
							{
								VAL d8 = pop_value();
								{
									VAL d9 = pop_value();
									mw_unpack_1();
									mw_rotr_1();
									push_value(d9);
								}
								push_value(d8);
							}
							LPUSH(lbl_home);
							mp_prim_dup();
							LPUSH(lbl_token_start);
							LPUSH(lbl_token_end);
							mp_prim_dup();
							LPUSH(lbl_dom);
							LPUSH(lbl_cod);
							LPUSH(lbl_ctx);
							push_u64(0LL); // L0
							LPUSH(lbl_atoms);
							mtw_ARROW_1();
							LPUSH(lbl_arrow);
							mtw_MKAB_1();
							{
								VAL d8 = pop_value();
								mtw__2B_SPSYNTH_1();
								mw_body_5();
								mw_synth_arrow_21__1();
								mw__2F__2B_SPSYNTH_1();
								push_value(d8);
							}
							mw_ab_unify_type_21__1();
							mw__2F_MKAB_1();
							LPOP(lbl_arrow);
							push_resource(d7);
						}
						LPUSH(lbl_body);
						incref(var_pat);
						push_value(var_pat);
						LPUSH(lbl_pattern);
						mtw_CASE_1();
						mw_add_case_1();
						decref(var_pat);
					}
					push_value(d5);
				}
				mp_prim_dup();
				mw_pattern_4();
				mw_token_start_2();
				mw_over_1();
				mw_body_5();
				mw_token_start_4();
				{
					VAL d5 = pop_value();
					mw_home_2();
					LPUSH(lbl_home);
					mp_prim_dup();
					LPUSH(lbl_token_start);
					LPUSH(lbl_token_end);
					mw_ctx_5();
					mp_prim_dup();
					LPUSH(lbl_outer_ctx);
					LPUSH(lbl_inner_ctx);
					push_u64(0LL); // L0
					LPUSH(lbl_saved);
					mw_dom_4();
					mp_prim_dup();
					LPUSH(lbl_mid);
					LPUSH(lbl_cod);
					push_u64(0LL); // L0
					LPUSH(lbl_atoms);
					mtw_PATTERN_1();
					{
						VAL d6 = pop_resource();
						mw_thaw_3();
						mp_prim_dup();
						mw_pattern_4();
						mw_atoms_2();
						switch (get_top_data_tag()) {
							case 0LL: // L0
								(void)pop_u64();
								mp_prim_id();
								break;
							case 1LL: // L1
								mtp_L1_1();
								mw_op_2();
								mw_op_21__1();
								break;
							case 2LL: // L2
								mtp_L2_1();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_op_2();
									mw_op_21__1();
									push_value(d9);
								}
								mw_op_2();
								mw_op_21__1();
								break;
							case 3LL: // L3
								mtp_L3_1();
								mw_rotr_1();
								mw_dip2_1_1966();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_op_2();
									mw_op_21__1();
									push_value(d9);
								}
								mw_op_2();
								mw_op_21__1();
								break;
							case 4LL: // LCAT
								mtp_LCAT_1();
								mp_prim_drop();
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_reverse_for_2_1966();
									push_value(d9);
								}
								mw_reverse_for_2_1966();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_freeze_3();
						push_resource(d6);
					}
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL var_pat = pop_value();
					incref(var_pat);
					push_value(var_pat);
					mw_inner_ctx_3();
					incref(var_pat);
					push_value(var_pat);
					mw_dom_7();
					mw_cod_4();
					mw_T__3E__1();
					mw_rotl_1();
					mw_home_2();
					{
						VAL d6 = pop_resource();
						{
							VAL d7 = pop_value();
							{
								VAL d8 = pop_value();
								mw_unpack_1();
								mw_rotr_1();
								push_value(d8);
							}
							push_value(d7);
						}
						LPUSH(lbl_home);
						mp_prim_dup();
						LPUSH(lbl_token_start);
						LPUSH(lbl_token_end);
						mp_prim_dup();
						LPUSH(lbl_dom);
						LPUSH(lbl_cod);
						LPUSH(lbl_ctx);
						push_u64(0LL); // L0
						LPUSH(lbl_atoms);
						mtw_ARROW_1();
						LPUSH(lbl_arrow);
						mtw_MKAB_1();
						{
							VAL d7 = pop_value();
							mtw__2B_SPSYNTH_1();
							mw_body_5();
							mw_synth_arrow_21__1();
							mw__2F__2B_SPSYNTH_1();
							push_value(d7);
						}
						mw_ab_unify_type_21__1();
						mw__2F_MKAB_1();
						LPOP(lbl_arrow);
						push_resource(d6);
					}
					LPUSH(lbl_body);
					incref(var_pat);
					push_value(var_pat);
					LPUSH(lbl_pattern);
					mtw_CASE_1();
					mw_add_case_1();
					decref(var_pat);
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_pattern_4();
			mw_token_start_2();
			mw_over_1();
			mw_body_5();
			mw_token_start_4();
			{
				VAL d4 = pop_value();
				mw_home_2();
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mw_ctx_5();
				mp_prim_dup();
				LPUSH(lbl_outer_ctx);
				LPUSH(lbl_inner_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_saved);
				mw_dom_4();
				mp_prim_dup();
				LPUSH(lbl_mid);
				LPUSH(lbl_cod);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_PATTERN_1();
				{
					VAL d5 = pop_resource();
					mw_thaw_3();
					mp_prim_dup();
					mw_pattern_4();
					mw_atoms_2();
					switch (get_top_data_tag()) {
						case 0LL: // L0
							(void)pop_u64();
							mp_prim_id();
							break;
						case 1LL: // L1
							mtp_L1_1();
							mw_op_2();
							mw_op_21__1();
							break;
						case 2LL: // L2
							mtp_L2_1();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_op_2();
								mw_op_21__1();
								push_value(d8);
							}
							mw_op_2();
							mw_op_21__1();
							break;
						case 3LL: // L3
							mtp_L3_1();
							mw_rotr_1();
							mw_dip2_1_1966();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_op_2();
								mw_op_21__1();
								push_value(d8);
							}
							mw_op_2();
							mw_op_21__1();
							break;
						case 4LL: // LCAT
							mtp_LCAT_1();
							mp_prim_drop();
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_reverse_for_2_1966();
								push_value(d8);
							}
							mw_reverse_for_2_1966();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_freeze_3();
					push_resource(d5);
				}
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL var_pat = pop_value();
				incref(var_pat);
				push_value(var_pat);
				mw_inner_ctx_3();
				incref(var_pat);
				push_value(var_pat);
				mw_dom_7();
				mw_cod_4();
				mw_T__3E__1();
				mw_rotl_1();
				mw_home_2();
				{
					VAL d5 = pop_resource();
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							mw_unpack_1();
							mw_rotr_1();
							push_value(d7);
						}
						push_value(d6);
					}
					LPUSH(lbl_home);
					mp_prim_dup();
					LPUSH(lbl_token_start);
					LPUSH(lbl_token_end);
					mp_prim_dup();
					LPUSH(lbl_dom);
					LPUSH(lbl_cod);
					LPUSH(lbl_ctx);
					push_u64(0LL); // L0
					LPUSH(lbl_atoms);
					mtw_ARROW_1();
					LPUSH(lbl_arrow);
					mtw_MKAB_1();
					{
						VAL d6 = pop_value();
						mtw__2B_SPSYNTH_1();
						mw_body_5();
						mw_synth_arrow_21__1();
						mw__2F__2B_SPSYNTH_1();
						push_value(d6);
					}
					mw_ab_unify_type_21__1();
					mw__2F_MKAB_1();
					LPOP(lbl_arrow);
					push_resource(d5);
				}
				LPUSH(lbl_body);
				incref(var_pat);
				push_value(var_pat);
				LPUSH(lbl_pattern);
				mtw_CASE_1();
				mw_add_case_1();
				decref(var_pat);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1963();
				push_value(d4);
			}
			mw_for_3_1963();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_2834 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw_covers_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2834();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw_covers_3F__1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2834();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2834();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2834();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2834 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw_covers_3F__1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw_covers_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_1238 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mtw_STCons_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mtw_STCons_1();
				push_value(d4);
			}
			mtw_STCons_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mtw_STCons_1();
					push_value(d5);
				}
				mtw_STCons_1();
				push_value(d4);
			}
			mtw_STCons_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1238();
				push_value(d4);
			}
			mw_for_3_1238();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_for_2_1966 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_op_2();
			mw_op_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_op_2();
				mw_op_21__1();
				push_value(d4);
			}
			mw_op_2();
			mw_op_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_1966();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_op_2();
				mw_op_21__1();
				push_value(d4);
			}
			mw_op_2();
			mw_op_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_1966();
				push_value(d4);
			}
			mw_reverse_for_2_1966();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_1966 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_op_2();
			mw_op_21__1();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_for_3_1954 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_synth_arg_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_synth_arg_21__1();
				push_value(d4);
			}
			mw_synth_arg_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_synth_arg_21__1();
					push_value(d5);
				}
				mw_synth_arg_21__1();
				push_value(d4);
			}
			mw_synth_arg_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1954();
				push_value(d4);
			}
			mw_for_3_1954();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_map_4_1945 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw__2F_PARAM_1();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw__2F_PARAM_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__2F_PARAM_1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__2F_PARAM_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1945();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1945();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_reverse_for_2_1938 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				mw_force_cons_3F__21__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unexpected domain in specialize-ctx-type", 40);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_panic();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_unpack2_1();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					LPOP(lbl_gamma);
					mp_prim_dup();
					LPUSH(lbl_gamma);
					push_value(d5);
				}
				push_value(d4);
			}
			mw__2F_ARG_5F_BLOCK_1();
			mw_type_12();
			mtw_TMorphism_1();
			mw_unify_21__7();
			mw_drop2_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_force_cons_3F__21__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("unexpected domain in specialize-ctx-type", 40);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_panic();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_unpack2_1();
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						LPOP(lbl_gamma);
						mp_prim_dup();
						LPUSH(lbl_gamma);
						push_value(d6);
					}
					push_value(d5);
				}
				mw__2F_ARG_5F_BLOCK_1();
				mw_type_12();
				mtw_TMorphism_1();
				mw_unify_21__7();
				mw_drop2_1();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_force_cons_3F__21__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unexpected domain in specialize-ctx-type", 40);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_panic();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_unpack2_1();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					LPOP(lbl_gamma);
					mp_prim_dup();
					LPUSH(lbl_gamma);
					push_value(d5);
				}
				push_value(d4);
			}
			mw__2F_ARG_5F_BLOCK_1();
			mw_type_12();
			mtw_TMorphism_1();
			mw_unify_21__7();
			mw_drop2_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_force_cons_3F__21__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr("unexpected domain in specialize-ctx-type", 40);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mp_prim_panic();
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mw_unpack2_1();
						push_value(d6);
					}
					{
						VAL d6 = pop_value();
						{
							VAL d7 = pop_value();
							LPOP(lbl_gamma);
							mp_prim_dup();
							LPUSH(lbl_gamma);
							push_value(d7);
						}
						push_value(d6);
					}
					mw__2F_ARG_5F_BLOCK_1();
					mw_type_12();
					mtw_TMorphism_1();
					mw_unify_21__7();
					mw_drop2_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_force_cons_3F__21__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("unexpected domain in specialize-ctx-type", 40);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_panic();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_unpack2_1();
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						LPOP(lbl_gamma);
						mp_prim_dup();
						LPUSH(lbl_gamma);
						push_value(d6);
					}
					push_value(d5);
				}
				mw__2F_ARG_5F_BLOCK_1();
				mw_type_12();
				mtw_TMorphism_1();
				mw_unify_21__7();
				mw_drop2_1();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_force_cons_3F__21__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unexpected domain in specialize-ctx-type", 40);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_panic();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_unpack2_1();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					LPOP(lbl_gamma);
					mp_prim_dup();
					LPUSH(lbl_gamma);
					push_value(d5);
				}
				push_value(d4);
			}
			mw__2F_ARG_5F_BLOCK_1();
			mw_type_12();
			mtw_TMorphism_1();
			mw_unify_21__7();
			mw_drop2_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_1938();
				push_value(d4);
			}
			mw_reverse_for_2_1938();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1925 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mw__2F_ARG_5F_BLOCK_1();
			mw_index_19();
			mw_show_1();
			mw__3B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("_", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw__3B__1();
				mw__2F_ARG_5F_BLOCK_1();
				mw_index_19();
				mw_show_1();
				mw__3B__1();
				push_value(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mw__2F_ARG_5F_BLOCK_1();
			mw_index_19();
			mw_show_1();
			mw__3B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("_", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw__3B__1();
					mw__2F_ARG_5F_BLOCK_1();
					mw_index_19();
					mw_show_1();
					mw__3B__1();
					push_value(d5);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("_", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw__3B__1();
				mw__2F_ARG_5F_BLOCK_1();
				mw_index_19();
				mw_show_1();
				mw__3B__1();
				push_value(d4);
			}
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("_", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw__3B__1();
			mw__2F_ARG_5F_BLOCK_1();
			mw_index_19();
			mw_show_1();
			mw__3B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1925();
				push_value(d4);
			}
			mw_for_3_1925();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_135 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				mw__3B__1();
				push_value(d4);
			}
			mw__3E_Str_9();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(",", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3B__1();
					push_value(d5);
				}
				mw__3E_Str_9();
				mw__3B__1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(",", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw__3B__1();
				push_value(d4);
			}
			mw__3E_Str_9();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(",", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw__3B__1();
						push_value(d6);
					}
					mw__3E_Str_9();
					mw__3B__1();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(",", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					mw__3B__1();
					push_value(d5);
				}
				mw__3E_Str_9();
				mw__3B__1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(",", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw__3B__1();
				push_value(d4);
			}
			mw__3E_Str_9();
			mw__3B__1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr(",", 1);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_135();
				push_value(d4);
			}
			mw_for_3_135();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_2896 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw_key_2();
			mw__3D__3D__27();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2896();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw_key_2();
					mw__3D__3D__27();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2896();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2896();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2896();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2896 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw_key_2();
		mw__3D__3D__27();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw_key_2();
			mw__3D__3D__27();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_2907 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2907();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_not_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2907();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2907();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2907();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2907 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_not_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_2925 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw__3E_List_2B__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_find_some_2_2931();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_some_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2925();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw__3E_List_2B__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							push_u64(0LL); // NONE
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mw_find_some_2_2931();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_some_3F__1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2925();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2925();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2925();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2925 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw__3E_List_2B__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				push_u64(0LL); // NONE
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_find_some_2_2931();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mw_some_3F__1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw__3E_List_2B__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					push_u64(0LL); // NONE
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mw_find_some_2_2931();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_some_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_2931 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_is_physical_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2931();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_is_physical_3F__1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2931();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2931();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2931();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2931 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_is_physical_3F__1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_is_physical_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_1904 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_check_arg_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_check_arg_21__1();
				push_value(d4);
			}
			mw_check_arg_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_check_arg_21__1();
					push_value(d5);
				}
				mw_check_arg_21__1();
				push_value(d4);
			}
			mw_check_arg_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1904();
				push_value(d4);
			}
			mw_for_3_1904();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_181 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_typecheck_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_typecheck_21__1();
				push_value(d4);
			}
			mw_typecheck_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_typecheck_21__1();
					push_value(d5);
				}
				mw_typecheck_21__1();
				push_value(d4);
			}
			mw_typecheck_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_181();
				push_value(d4);
			}
			mw_for_3_181();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1891 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_QNAME0_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown namespace: ", 19);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_swap();
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			switch (get_top_data_tag()) {
				case 2LL: // DEF_PACKAGE
					mtp_DEF_5F_PACKAGE_1();
					mtw_NAMESPACE_5F_PACKAGE_1();
					break;
				case 1LL: // DEF_MODULE
					mtp_DEF_5F_MODULE_1();
					mtw_NAMESPACE_5F_MODULE_1();
					break;
				default:
					mw_exposed_tycon_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("invalid namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mtw_NAMESPACE_5F_TYCON_1();
					break;
			}
			mw_nip_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_QNAME0_1();
				mp_prim_dup();
				mw_def_3F__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unknown namespace: ", 19);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_swap();
						mw__3E_Str_5();
						mp_prim_str_cat();
						mw_emit_fatal_error_21__1();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				switch (get_top_data_tag()) {
					case 2LL: // DEF_PACKAGE
						mtp_DEF_5F_PACKAGE_1();
						mtw_NAMESPACE_5F_PACKAGE_1();
						break;
					case 1LL: // DEF_MODULE
						mtp_DEF_5F_MODULE_1();
						mtw_NAMESPACE_5F_MODULE_1();
						break;
					default:
						mw_exposed_tycon_3F__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr("invalid namespace: ", 19);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mp_prim_swap();
								mw__3E_Str_5();
								mp_prim_str_cat();
								mw_emit_fatal_error_21__1();
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mtw_NAMESPACE_5F_TYCON_1();
						break;
				}
				mw_nip_1();
				push_value(d4);
			}
			mw_QNAME0_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown namespace: ", 19);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_swap();
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			switch (get_top_data_tag()) {
				case 2LL: // DEF_PACKAGE
					mtp_DEF_5F_PACKAGE_1();
					mtw_NAMESPACE_5F_PACKAGE_1();
					break;
				case 1LL: // DEF_MODULE
					mtp_DEF_5F_MODULE_1();
					mtw_NAMESPACE_5F_MODULE_1();
					break;
				default:
					mw_exposed_tycon_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("invalid namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mtw_NAMESPACE_5F_TYCON_1();
					break;
			}
			mw_nip_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_QNAME0_1();
					mp_prim_dup();
					mw_def_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("unknown namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					switch (get_top_data_tag()) {
						case 2LL: // DEF_PACKAGE
							mtp_DEF_5F_PACKAGE_1();
							mtw_NAMESPACE_5F_PACKAGE_1();
							break;
						case 1LL: // DEF_MODULE
							mtp_DEF_5F_MODULE_1();
							mtw_NAMESPACE_5F_MODULE_1();
							break;
						default:
							mw_exposed_tycon_3F__1();
							switch (get_top_data_tag()) {
								case 0LL: // NONE
									(void)pop_u64();
									{
										static bool vready = false;
										static VAL v;
										if (! vready) {
											v = mkstr("invalid namespace: ", 19);
											vready = true;
										}
										push_value(v);
										incref(v);
									}
									mp_prim_swap();
									mw__3E_Str_5();
									mp_prim_str_cat();
									mw_emit_fatal_error_21__1();
									break;
								case 1LL: // SOME
									mtp_SOME_1();
									mp_prim_id();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							mtw_NAMESPACE_5F_TYCON_1();
							break;
					}
					mw_nip_1();
					push_value(d5);
				}
				mw_QNAME0_1();
				mp_prim_dup();
				mw_def_3F__1();
				switch (get_top_data_tag()) {
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("unknown namespace: ", 19);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_swap();
						mw__3E_Str_5();
						mp_prim_str_cat();
						mw_emit_fatal_error_21__1();
						break;
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				switch (get_top_data_tag()) {
					case 2LL: // DEF_PACKAGE
						mtp_DEF_5F_PACKAGE_1();
						mtw_NAMESPACE_5F_PACKAGE_1();
						break;
					case 1LL: // DEF_MODULE
						mtp_DEF_5F_MODULE_1();
						mtw_NAMESPACE_5F_MODULE_1();
						break;
					default:
						mw_exposed_tycon_3F__1();
						switch (get_top_data_tag()) {
							case 0LL: // NONE
								(void)pop_u64();
								{
									static bool vready = false;
									static VAL v;
									if (! vready) {
										v = mkstr("invalid namespace: ", 19);
										vready = true;
									}
									push_value(v);
									incref(v);
								}
								mp_prim_swap();
								mw__3E_Str_5();
								mp_prim_str_cat();
								mw_emit_fatal_error_21__1();
								break;
							case 1LL: // SOME
								mtp_SOME_1();
								mp_prim_id();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						mtw_NAMESPACE_5F_TYCON_1();
						break;
				}
				mw_nip_1();
				push_value(d4);
			}
			mw_QNAME0_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown namespace: ", 19);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_swap();
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			switch (get_top_data_tag()) {
				case 2LL: // DEF_PACKAGE
					mtp_DEF_5F_PACKAGE_1();
					mtw_NAMESPACE_5F_PACKAGE_1();
					break;
				case 1LL: // DEF_MODULE
					mtp_DEF_5F_MODULE_1();
					mtw_NAMESPACE_5F_MODULE_1();
					break;
				default:
					mw_exposed_tycon_3F__1();
					switch (get_top_data_tag()) {
						case 0LL: // NONE
							(void)pop_u64();
							{
								static bool vready = false;
								static VAL v;
								if (! vready) {
									v = mkstr("invalid namespace: ", 19);
									vready = true;
								}
								push_value(v);
								incref(v);
							}
							mp_prim_swap();
							mw__3E_Str_5();
							mp_prim_str_cat();
							mw_emit_fatal_error_21__1();
							break;
						case 1LL: // SOME
							mtp_SOME_1();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mtw_NAMESPACE_5F_TYCON_1();
					break;
			}
			mw_nip_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1891();
				push_value(d4);
			}
			mw_for_3_1891();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_1886 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_over2_1();
			mw_over_1();
			mw_def_visible_from_token_3F__1();
			if (pop_u64()) {
				mw_exposed_tycon_3F__1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_1886();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_over2_1();
					mw_over_1();
					mw_def_visible_from_token_3F__1();
					if (pop_u64()) {
						mw_exposed_tycon_3F__1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_1886();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_1886();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_1886();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_1886 (void) {
	{
		VAL d2 = pop_value();
		mw_over2_1();
		mw_over_1();
		mw_def_visible_from_token_3F__1();
		if (pop_u64()) {
			mw_exposed_tycon_3F__1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_over2_1();
			mw_over_1();
			mw_def_visible_from_token_3F__1();
			if (pop_u64()) {
				mw_exposed_tycon_3F__1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_2994 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw__3D__3D__33();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_2994();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw__3D__3D__33();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_2994();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_2994();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_2994();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_2994 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw__3D__3D__33();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw__3D__3D__33();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_3018 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_num_type_inputs_1();
			mw_0_3D__2();
			if (pop_u64()) {
				mp_prim_dup();
				mw_num_resource_inputs_1();
				mw_0_3D__2();
			} else {
				push_u64(0LL); // F
			}
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_3018();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_num_type_inputs_1();
					mw_0_3D__2();
					if (pop_u64()) {
						mp_prim_dup();
						mw_num_resource_inputs_1();
						mw_0_3D__2();
					} else {
						push_u64(0LL); // F
					}
					mw_not_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3018();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_3018();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_3018();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3018 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_num_type_inputs_1();
		mw_0_3D__2();
		if (pop_u64()) {
			mp_prim_dup();
			mw_num_resource_inputs_1();
			mw_0_3D__2();
		} else {
			push_u64(0LL); // F
		}
		mw_not_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_num_type_inputs_1();
			mw_0_3D__2();
			if (pop_u64()) {
				mp_prim_dup();
				mw_num_resource_inputs_1();
				mw_0_3D__2();
			} else {
				push_u64(0LL); // F
			}
			mw_not_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_1798 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_elab_data_tag_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_elab_data_tag_21__1();
				push_value(d4);
			}
			mw_elab_data_tag_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_elab_data_tag_21__1();
					push_value(d5);
				}
				mw_elab_data_tag_21__1();
				push_value(d4);
			}
			mw_elab_data_tag_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1798();
				push_value(d4);
			}
			mw_for_3_1798();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_3029 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_sig_resource_con_3F__1();
			if (pop_u64()) {
				push_u64(1LL); // T
			} else {
				mp_prim_dup();
				mw_sig_resource_var_3F__1();
			}
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_3029();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_sig_resource_con_3F__1();
					if (pop_u64()) {
						push_u64(1LL); // T
					} else {
						mp_prim_dup();
						mw_sig_resource_var_3F__1();
					}
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3029();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_3029();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_3029();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3029 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_sig_resource_con_3F__1();
		if (pop_u64()) {
			push_u64(1LL); // T
		} else {
			mp_prim_dup();
			mw_sig_resource_var_3F__1();
		}
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_sig_resource_con_3F__1();
			if (pop_u64()) {
				push_u64(1LL); // T
			} else {
				mp_prim_dup();
				mw_sig_resource_var_3F__1();
			}
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_filter_2_1335 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1335();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_map_4_1336 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_21__8();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_name_3F__2();
				mw_unwrap_1();
				mw_new_21__8();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_name_3F__2();
				mw_unwrap_1();
				mw_new_21__8();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_name_3F__2();
					mw_unwrap_1();
					mw_new_21__8();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_name_3F__2();
					mw_unwrap_1();
					mw_new_21__8();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_name_3F__2();
					mw_unwrap_1();
					mw_new_21__8();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1336();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1336();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_1335 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1335();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1335();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_could_be_sig_label_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1335();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1335();
			}
			break;
	}
}
static void mw_filter_some_1_1341 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_some_2_1341();
			break;
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_1342 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1342();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_1342 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1342();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1342();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_could_be_resource_var_1();
				if (pop_u64()) {
					push_u64(1LL); // T
				} else {
					mp_prim_dup();
					mw_could_be_resource_con_1();
				}
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1342();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1342();
			}
			break;
	}
}
static void mw_filter_some_2_1341 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_some_2_1341();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_some_2_1341();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_unsnoc_1();
			{
				VAL d4 = pop_value();
				mw_filter_some_1_1341();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_name_3F__2();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mw_snoc_1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
	}
}
static void mw_reverse_find_some_2_3075 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_dup2_1();
			mw_name_4();
			mw__3D__3D__30();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			mw_find_some_aux2_1_3075();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_dup2_1();
					mw_name_4();
					mw__3D__3D__30();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3075();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_find_some_2_3075();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_reverse_find_some_2_3075();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3075 (void) {
	{
		VAL d2 = pop_value();
		mw_dup2_1();
		mw_name_4();
		mw__3D__3D__30();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_dup2_1();
			mw_name_4();
			mw__3D__3D__30();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_1511 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_T_2A__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_T_2A__1();
					push_value(d5);
				}
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1511();
				push_value(d4);
			}
			mw_for_3_1511();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1515 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_elab_type_sig_21__1();
			mp_prim_drop();
			mw__3E_Type_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_snoc_1();
				push_value(d4);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_elab_type_sig_21__1();
				mp_prim_drop();
				mw__3E_Type_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_snoc_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_elab_type_sig_21__1();
			mp_prim_drop();
			mw__3E_Type_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_snoc_1();
				push_value(d4);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_elab_type_sig_21__1();
					mp_prim_drop();
					mw__3E_Type_1();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw_snoc_1();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_elab_type_sig_21__1();
				mp_prim_drop();
				mw__3E_Type_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_snoc_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_elab_type_sig_21__1();
			mp_prim_drop();
			mw__3E_Type_1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_snoc_1();
				push_value(d4);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1515();
				push_value(d4);
			}
			mw_for_3_1515();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_3092 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_defines_a_type_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_3092();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_defines_a_type_3F__1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3092();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_3092();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_3092();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3092 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_defines_a_type_3F__1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_defines_a_type_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_reverse_for_2_3158 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_3158();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_3158();
				push_value(d4);
			}
			mw_reverse_for_2_3158();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_3158 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_reverse_for_2_3168 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_3168();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw__3E_Var_1();
					mp_prim_dup();
					{
						VAL d6 = pop_value();
						mw_new_4();
						push_value(d6);
					}
					push_value(d5);
				}
				mw_ab_token_40__1();
				mw_elab_expand_tensor_21__1();
				{
					VAL d5 = pop_value();
					mw_rotl_1();
					mw_type_4();
					push_value(d5);
				}
				mw_elab_type_unify_21__1();
				mw_drop2_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_3168();
				push_value(d4);
			}
			mw_reverse_for_2_3168();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_3168 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Var_1();
				mp_prim_dup();
				{
					VAL d5 = pop_value();
					mw_new_4();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_ab_token_40__1();
			mw_elab_expand_tensor_21__1();
			{
				VAL d4 = pop_value();
				mw_rotl_1();
				mw_type_4();
				push_value(d4);
			}
			mw_elab_type_unify_21__1();
			mw_drop2_1();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_reverse_for_2_1710 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_elab_pattern_atom_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_elab_pattern_atom_21__1();
				push_value(d4);
			}
			mw_elab_pattern_atom_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_1710();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_elab_pattern_atom_21__1();
				push_value(d4);
			}
			mw_elab_pattern_atom_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_1710();
				push_value(d4);
			}
			mw_reverse_for_2_1710();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_1710 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_elab_pattern_atom_21__1();
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_find_some_2_1718 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_tag_3F__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_1718();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_tag_3F__1();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_1718();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_1718();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_1718();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_1718 (void) {
	{
		VAL d2 = pop_value();
		mw_tag_3F__1();
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_tag_3F__1();
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_filter_2_3195 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_3195();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_3195 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_3195();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_3195();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_pat_arrow_3F__1();
					mw_not_1();
					push_value(d5);
				}
				mw__26__26__1();
				mw_tuck_1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_3195();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_3195();
			}
			break;
	}
}
static void mw_for_3_1653 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_elab_block_at_21__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_elab_block_at_21__1();
				push_value(d4);
			}
			mw_elab_block_at_21__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_elab_block_at_21__1();
					push_value(d5);
				}
				mw_elab_block_at_21__1();
				push_value(d4);
			}
			mw_elab_block_at_21__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1653();
				push_value(d4);
			}
			mw_for_3_1653();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1664 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" ", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_str_cat();
					push_value(d5);
				}
				mw__3E_Str_5();
				mp_prim_str_cat();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" ", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(" ", 1);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_str_cat();
						push_value(d6);
					}
					mw__3E_Str_5();
					mp_prim_str_cat();
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(" ", 1);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mp_prim_str_cat();
					push_value(d5);
				}
				mw__3E_Str_5();
				mp_prim_str_cat();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(" ", 1);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mp_prim_str_cat();
				push_value(d4);
			}
			mw__3E_Str_5();
			mp_prim_str_cat();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1664();
				push_value(d4);
			}
			mw_for_3_1664();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_1660 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1660();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_1660 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1660();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1660();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_defined_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1660();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1660();
			}
			break;
	}
}
static void mw_for_3_1659 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mtw_NAMESPACE_5F_TYCON_1();
			LPOP(lbl_template);
			mp_prim_dup();
			LPUSH(lbl_template);
			mw_namespace_21__1();
			push_i64(-1LL);
			mw_over_1();
			mw_arity_21__1();
			mtw_L2_1();
			mw_cat_2();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mtw_NAMESPACE_5F_TYCON_1();
				LPOP(lbl_template);
				mp_prim_dup();
				LPUSH(lbl_template);
				mw_namespace_21__1();
				push_i64(-1LL);
				mw_over_1();
				mw_arity_21__1();
				mtw_L2_1();
				mw_cat_2();
				push_value(d4);
			}
			mtw_NAMESPACE_5F_TYCON_1();
			LPOP(lbl_template);
			mp_prim_dup();
			LPUSH(lbl_template);
			mw_namespace_21__1();
			push_i64(-1LL);
			mw_over_1();
			mw_arity_21__1();
			mtw_L2_1();
			mw_cat_2();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mtw_NAMESPACE_5F_TYCON_1();
					LPOP(lbl_template);
					mp_prim_dup();
					LPUSH(lbl_template);
					mw_namespace_21__1();
					push_i64(-1LL);
					mw_over_1();
					mw_arity_21__1();
					mtw_L2_1();
					mw_cat_2();
					push_value(d5);
				}
				mtw_NAMESPACE_5F_TYCON_1();
				LPOP(lbl_template);
				mp_prim_dup();
				LPUSH(lbl_template);
				mw_namespace_21__1();
				push_i64(-1LL);
				mw_over_1();
				mw_arity_21__1();
				mtw_L2_1();
				mw_cat_2();
				push_value(d4);
			}
			mtw_NAMESPACE_5F_TYCON_1();
			LPOP(lbl_template);
			mp_prim_dup();
			LPUSH(lbl_template);
			mw_namespace_21__1();
			push_i64(-1LL);
			mw_over_1();
			mw_arity_21__1();
			mtw_L2_1();
			mw_cat_2();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1659();
				push_value(d4);
			}
			mw_for_3_1659();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_1646 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1646();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_2_1647 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1647();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_1647 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1647();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1647();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_elab_qname_is_imported_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1647();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1647();
			}
			break;
	}
}
static void mw_filter_3_1646 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1646();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1646();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				mw_arity_5();
				mw_arity_compatible_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1646();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1646();
			}
			break;
	}
}
static void mw_map_4_1645 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_qname_12();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_qname_12();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_qname_12();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_qname_12();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_qname_12();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_qname_12();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1645();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1645();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_3244 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_pat_arrow_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_3244();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_pat_arrow_3F__1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3244();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_3244();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_3244();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3244 (void) {
	{
		VAL d2 = pop_value();
		mp_prim_dup();
		mw_pat_arrow_3F__1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mp_prim_dup();
			mw_pat_arrow_3F__1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_reverse_for_2_1864 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_sig_param_name_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						mp_prim_id();
						break;
					case 0LL: // F
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("expected parameter name", 23);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mp_prim_dup();
				mw_succ_7();
				mp_prim_dup();
				mw_run_end_3F__1();
				if (pop_u64()) {
					mp_prim_drop();
				} else {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected right paren or comma", 29);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
				}
				mw_elab_expand_tensor_21__1();
				mw_over_1();
				mw_morphism_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_drop();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("need function type for param", 28);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_name_3F__2();
				mw_unwrap_1();
				mw_new_auto_run_21__1();
				mw_rotr_1();
				{
					VAL d5 = pop_value();
					mw_cons_2();
					push_value(d5);
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			mw_rotr_1();
			mw_dip2_1_1864();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_sig_param_name_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						mp_prim_id();
						break;
					case 0LL: // F
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("expected parameter name", 23);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mp_prim_dup();
				mw_succ_7();
				mp_prim_dup();
				mw_run_end_3F__1();
				if (pop_u64()) {
					mp_prim_drop();
				} else {
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected right paren or comma", 29);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
				}
				mw_elab_expand_tensor_21__1();
				mw_over_1();
				mw_morphism_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mp_prim_drop();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("need function type for param", 28);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mw_name_3F__2();
				mw_unwrap_1();
				mw_new_auto_run_21__1();
				mw_rotr_1();
				{
					VAL d5 = pop_value();
					mw_cons_2();
					push_value(d5);
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_reverse_for_2_1864();
				push_value(d4);
			}
			mw_reverse_for_2_1864();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_dip2_1_1864 (void) {
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			mw_sig_param_name_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // T
					(void)pop_u64();
					mp_prim_id();
					break;
				case 0LL: // F
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("expected parameter name", 23);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mp_prim_dup();
			mw_succ_7();
			mp_prim_dup();
			mw_run_end_3F__1();
			if (pop_u64()) {
				mp_prim_drop();
			} else {
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("expected right paren or comma", 29);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_emit_fatal_error_21__1();
			}
			mw_elab_expand_tensor_21__1();
			mw_over_1();
			mw_morphism_3F__1();
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_drop();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("need function type for param", 28);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_name_3F__2();
			mw_unwrap_1();
			mw_new_auto_run_21__1();
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				mw_cons_2();
				push_value(d4);
			}
			push_value(d3);
		}
		push_value(d2);
	}
}
static void mw_filter_2_1750 (void) {
	mw__3E_List_2B__1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			push_u64(0LL); // L0
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mw_filter_3_1750();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_map_4_1751 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_qname_12();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_qname_12();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_qname_12();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_qname_12();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_qname_12();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_qname_12();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1751();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1751();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_filter_3_1750 (void) {
	switch (get_top_data_tag()) {
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_filter_3_1750();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw_filter_3_1750();
				push_value(d4);
			}
			mp_prim_swap();
			mw_cat_2();
			break;
		default:
			mw_uncons_2();
			{
				VAL d4 = pop_value();
				mw_dup2_1();
				mw_def_visible_from_token_3F__1();
				push_value(d4);
			}
			mp_prim_swap();
			if (pop_u64()) {
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_filter_2_1750();
					push_value(d5);
				}
				mp_prim_swap();
				mw_cons_2();
			} else {
				mw_nip_1();
				mw_filter_2_1750();
			}
			break;
	}
}
static void mw_find_some_2_1735 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_prim_3F__2();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_1735();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_prim_3F__2();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_1735();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_1735();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_1735();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_1735 (void) {
	{
		VAL d2 = pop_value();
		mw_prim_3F__2();
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_prim_3F__2();
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_map_4_956 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw__3E_Name_1();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw__3E_Name_1();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				mw__3E_Name_1();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3E_Name_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3E_Name_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw__3E_Name_1();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_956();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_956();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_152 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_unpack2_1();
			mp_prim_swap();
			mw__3E_Name_1();
			mw_new_or_set_path_21__1();
			mp_prim_drop();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_unpack2_1();
				mp_prim_swap();
				mw__3E_Name_1();
				mw_new_or_set_path_21__1();
				mp_prim_drop();
				push_value(d4);
			}
			mw_unpack2_1();
			mp_prim_swap();
			mw__3E_Name_1();
			mw_new_or_set_path_21__1();
			mp_prim_drop();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_unpack2_1();
					mp_prim_swap();
					mw__3E_Name_1();
					mw_new_or_set_path_21__1();
					mp_prim_drop();
					push_value(d5);
				}
				mw_unpack2_1();
				mp_prim_swap();
				mw__3E_Name_1();
				mw_new_or_set_path_21__1();
				mp_prim_drop();
				push_value(d4);
			}
			mw_unpack2_1();
			mp_prim_swap();
			mw__3E_Name_1();
			mw_new_or_set_path_21__1();
			mp_prim_drop();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_152();
				push_value(d4);
			}
			mw_for_3_152();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_786 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_print_usage_for_option_1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_print_usage_for_option_1();
				push_value(d4);
			}
			mw_print_usage_for_option_1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_print_usage_for_option_1();
					push_value(d5);
				}
				mw_print_usage_for_option_1();
				push_value(d4);
			}
			mw_print_usage_for_option_1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_786();
				push_value(d4);
			}
			mw_for_3_786();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_304 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mp_prim_dup();
			mw_num_bytes_1();
			push_i64(1LL);
			mw__3E_Size_1();
			mw__3E__5();
			if (pop_u64()) {
				push_i64(0LL);
				mw__3E_Offset_1();
				mw_over_1();
				mw_byte_40__2();
				push_u64(45LL); // B'-'
				mw__3D__3D__19();
				if (pop_u64()) {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mp_prim_drop();
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(0LL); // F
										mw_state_3();
										mw_parsing_3F__21__2();
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(1LL); // MISSING_ARGUMENT_VALUE
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
					} else {
						mw_parse_flags_1();
					}
				} else {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_state_3();
										mw_arguments_2();
										mp_prim_swap();
										mtw_SOME_1();
										mw_state_3();
										mw_option_option_3();
										mw_unwrap_1();
										mw_flag_type_2();
										mw_parser_1();
										mw_unwrap_1();
										mp_prim_run();
										mw_state_3();
										{
											VAL d11 = pop_resource();
											mw_arguments_21__1();
											push_resource(d11);
										}
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(5LL); // UNKNOWN_ARG
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_u64(0LL); // F
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_parsing_3F__21__2();
							push_resource(d7);
						}
						mw_state_21__1();
					} else {
						mw_do_positional_option_1();
					}
				}
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				mw_num_bytes_1();
				push_i64(1LL);
				mw__3E_Size_1();
				mw__3E__5();
				if (pop_u64()) {
					push_i64(0LL);
					mw__3E_Offset_1();
					mw_over_1();
					mw_byte_40__2();
					push_u64(45LL); // B'-'
					mw__3D__3D__19();
					if (pop_u64()) {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mp_prim_drop();
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											push_u64(1LL); // MISSING_ARGUMENT_VALUE
											mtw_SOME_1();
											break;
										case 0LL: // NONE
											(void)pop_u64();
											push_u64(0LL); // F
											mw_state_3();
											mw_parsing_3F__21__2();
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									push_u64(1LL); // MISSING_ARGUMENT_VALUE
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
						} else {
							mw_parse_flags_1();
						}
					} else {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											mw_state_3();
											mw_arguments_2();
											mp_prim_swap();
											mtw_SOME_1();
											mw_state_3();
											mw_option_option_3();
											mw_unwrap_1();
											mw_flag_type_2();
											mw_parser_1();
											mw_unwrap_1();
											mp_prim_run();
											mw_state_3();
											{
												VAL d12 = pop_resource();
												mw_arguments_21__1();
												push_resource(d12);
											}
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										case 0LL: // NONE
											(void)pop_u64();
											mp_prim_drop();
											push_u64(5LL); // UNKNOWN_ARG
											mtw_SOME_1();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									mp_prim_drop();
									push_u64(5LL); // UNKNOWN_ARG
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							push_u64(0LL); // F
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_parsing_3F__21__2();
								push_resource(d8);
							}
							mw_state_21__1();
						} else {
							mw_do_positional_option_1();
						}
					}
				} else {
					mp_prim_drop();
					push_u64(0LL); // NONE
				}
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mtw_SOME_1();
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_error_21__1();
							push_resource(d7);
						}
						mw_state_21__1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_num_bytes_1();
			push_i64(1LL);
			mw__3E_Size_1();
			mw__3E__5();
			if (pop_u64()) {
				push_i64(0LL);
				mw__3E_Offset_1();
				mw_over_1();
				mw_byte_40__2();
				push_u64(45LL); // B'-'
				mw__3D__3D__19();
				if (pop_u64()) {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mp_prim_drop();
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(0LL); // F
										mw_state_3();
										mw_parsing_3F__21__2();
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(1LL); // MISSING_ARGUMENT_VALUE
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
					} else {
						mw_parse_flags_1();
					}
				} else {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_state_3();
										mw_arguments_2();
										mp_prim_swap();
										mtw_SOME_1();
										mw_state_3();
										mw_option_option_3();
										mw_unwrap_1();
										mw_flag_type_2();
										mw_parser_1();
										mw_unwrap_1();
										mp_prim_run();
										mw_state_3();
										{
											VAL d11 = pop_resource();
											mw_arguments_21__1();
											push_resource(d11);
										}
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(5LL); // UNKNOWN_ARG
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_u64(0LL); // F
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_parsing_3F__21__2();
							push_resource(d7);
						}
						mw_state_21__1();
					} else {
						mw_do_positional_option_1();
					}
				}
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mp_prim_dup();
					mw_num_bytes_1();
					push_i64(1LL);
					mw__3E_Size_1();
					mw__3E__5();
					if (pop_u64()) {
						push_i64(0LL);
						mw__3E_Offset_1();
						mw_over_1();
						mw_byte_40__2();
						push_u64(45LL); // B'-'
						mw__3D__3D__19();
						if (pop_u64()) {
							mw_state_3();
							mw_parsing_3F__3();
							if (pop_u64()) {
								mp_prim_drop();
								mw_state_3();
								mw_option_option_3();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mw_arg_doc_2();
										switch (get_top_data_tag()) {
											case 1LL: // SOME
												mtp_SOME_1();
												mp_prim_drop();
												push_u64(1LL); // MISSING_ARGUMENT_VALUE
												mtw_SOME_1();
												break;
											case 0LL: // NONE
												(void)pop_u64();
												push_u64(0LL); // F
												mw_state_3();
												mw_parsing_3F__21__2();
												mw_state_21__1();
												push_u64(0LL); // NONE
												break;
											default:
												push_value(mkstr("unexpected fallthrough in match\n", 32)); 
												mp_prim_panic();
										}
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
							} else {
								mw_parse_flags_1();
							}
						} else {
							mw_state_3();
							mw_parsing_3F__3();
							if (pop_u64()) {
								mw_state_3();
								mw_option_option_3();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mw_arg_doc_2();
										switch (get_top_data_tag()) {
											case 1LL: // SOME
												mtp_SOME_1();
												mp_prim_drop();
												mw_state_3();
												mw_arguments_2();
												mp_prim_swap();
												mtw_SOME_1();
												mw_state_3();
												mw_option_option_3();
												mw_unwrap_1();
												mw_flag_type_2();
												mw_parser_1();
												mw_unwrap_1();
												mp_prim_run();
												mw_state_3();
												{
													VAL d13 = pop_resource();
													mw_arguments_21__1();
													push_resource(d13);
												}
												mw_state_21__1();
												push_u64(0LL); // NONE
												break;
											case 0LL: // NONE
												(void)pop_u64();
												mp_prim_drop();
												push_u64(5LL); // UNKNOWN_ARG
												mtw_SOME_1();
												break;
											default:
												push_value(mkstr("unexpected fallthrough in match\n", 32)); 
												mp_prim_panic();
										}
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								push_u64(0LL); // F
								mw_state_3();
								{
									VAL d9 = pop_resource();
									mw_parsing_3F__21__2();
									push_resource(d9);
								}
								mw_state_21__1();
							} else {
								mw_do_positional_option_1();
							}
						}
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					switch (get_top_data_tag()) {
						case 1LL: // SOME
							mtp_SOME_1();
							mtw_SOME_1();
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_error_21__1();
								push_resource(d8);
							}
							mw_state_21__1();
							break;
						case 0LL: // NONE
							(void)pop_u64();
							mp_prim_id();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					push_value(d5);
				}
				mp_prim_dup();
				mw_num_bytes_1();
				push_i64(1LL);
				mw__3E_Size_1();
				mw__3E__5();
				if (pop_u64()) {
					push_i64(0LL);
					mw__3E_Offset_1();
					mw_over_1();
					mw_byte_40__2();
					push_u64(45LL); // B'-'
					mw__3D__3D__19();
					if (pop_u64()) {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mp_prim_drop();
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											push_u64(1LL); // MISSING_ARGUMENT_VALUE
											mtw_SOME_1();
											break;
										case 0LL: // NONE
											(void)pop_u64();
											push_u64(0LL); // F
											mw_state_3();
											mw_parsing_3F__21__2();
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									push_u64(1LL); // MISSING_ARGUMENT_VALUE
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
						} else {
							mw_parse_flags_1();
						}
					} else {
						mw_state_3();
						mw_parsing_3F__3();
						if (pop_u64()) {
							mw_state_3();
							mw_option_option_3();
							switch (get_top_data_tag()) {
								case 1LL: // SOME
									mtp_SOME_1();
									mw_arg_doc_2();
									switch (get_top_data_tag()) {
										case 1LL: // SOME
											mtp_SOME_1();
											mp_prim_drop();
											mw_state_3();
											mw_arguments_2();
											mp_prim_swap();
											mtw_SOME_1();
											mw_state_3();
											mw_option_option_3();
											mw_unwrap_1();
											mw_flag_type_2();
											mw_parser_1();
											mw_unwrap_1();
											mp_prim_run();
											mw_state_3();
											{
												VAL d12 = pop_resource();
												mw_arguments_21__1();
												push_resource(d12);
											}
											mw_state_21__1();
											push_u64(0LL); // NONE
											break;
										case 0LL: // NONE
											(void)pop_u64();
											mp_prim_drop();
											push_u64(5LL); // UNKNOWN_ARG
											mtw_SOME_1();
											break;
										default:
											push_value(mkstr("unexpected fallthrough in match\n", 32)); 
											mp_prim_panic();
									}
									break;
								case 0LL: // NONE
									(void)pop_u64();
									mp_prim_drop();
									push_u64(5LL); // UNKNOWN_ARG
									mtw_SOME_1();
									break;
								default:
									push_value(mkstr("unexpected fallthrough in match\n", 32)); 
									mp_prim_panic();
							}
							push_u64(0LL); // F
							mw_state_3();
							{
								VAL d8 = pop_resource();
								mw_parsing_3F__21__2();
								push_resource(d8);
							}
							mw_state_21__1();
						} else {
							mw_do_positional_option_1();
						}
					}
				} else {
					mp_prim_drop();
					push_u64(0LL); // NONE
				}
				switch (get_top_data_tag()) {
					case 1LL: // SOME
						mtp_SOME_1();
						mtw_SOME_1();
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_error_21__1();
							push_resource(d7);
						}
						mw_state_21__1();
						break;
					case 0LL: // NONE
						(void)pop_u64();
						mp_prim_id();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				push_value(d4);
			}
			mp_prim_dup();
			mw_num_bytes_1();
			push_i64(1LL);
			mw__3E_Size_1();
			mw__3E__5();
			if (pop_u64()) {
				push_i64(0LL);
				mw__3E_Offset_1();
				mw_over_1();
				mw_byte_40__2();
				push_u64(45LL); // B'-'
				mw__3D__3D__19();
				if (pop_u64()) {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mp_prim_drop();
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										push_u64(1LL); // MISSING_ARGUMENT_VALUE
										mtw_SOME_1();
										break;
									case 0LL: // NONE
										(void)pop_u64();
										push_u64(0LL); // F
										mw_state_3();
										mw_parsing_3F__21__2();
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								push_u64(1LL); // MISSING_ARGUMENT_VALUE
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
					} else {
						mw_parse_flags_1();
					}
				} else {
					mw_state_3();
					mw_parsing_3F__3();
					if (pop_u64()) {
						mw_state_3();
						mw_option_option_3();
						switch (get_top_data_tag()) {
							case 1LL: // SOME
								mtp_SOME_1();
								mw_arg_doc_2();
								switch (get_top_data_tag()) {
									case 1LL: // SOME
										mtp_SOME_1();
										mp_prim_drop();
										mw_state_3();
										mw_arguments_2();
										mp_prim_swap();
										mtw_SOME_1();
										mw_state_3();
										mw_option_option_3();
										mw_unwrap_1();
										mw_flag_type_2();
										mw_parser_1();
										mw_unwrap_1();
										mp_prim_run();
										mw_state_3();
										{
											VAL d11 = pop_resource();
											mw_arguments_21__1();
											push_resource(d11);
										}
										mw_state_21__1();
										push_u64(0LL); // NONE
										break;
									case 0LL: // NONE
										(void)pop_u64();
										mp_prim_drop();
										push_u64(5LL); // UNKNOWN_ARG
										mtw_SOME_1();
										break;
									default:
										push_value(mkstr("unexpected fallthrough in match\n", 32)); 
										mp_prim_panic();
								}
								break;
							case 0LL: // NONE
								(void)pop_u64();
								mp_prim_drop();
								push_u64(5LL); // UNKNOWN_ARG
								mtw_SOME_1();
								break;
							default:
								push_value(mkstr("unexpected fallthrough in match\n", 32)); 
								mp_prim_panic();
						}
						push_u64(0LL); // F
						mw_state_3();
						{
							VAL d7 = pop_resource();
							mw_parsing_3F__21__2();
							push_resource(d7);
						}
						mw_state_21__1();
					} else {
						mw_do_positional_option_1();
					}
				}
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			switch (get_top_data_tag()) {
				case 1LL: // SOME
					mtp_SOME_1();
					mtw_SOME_1();
					mw_state_3();
					{
						VAL d6 = pop_resource();
						mw_error_21__1();
						push_resource(d6);
					}
					mw_state_21__1();
					break;
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_304();
				push_value(d4);
			}
			mw_for_3_304();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_2_3317 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_over_1();
			mw_check_short_flag_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_3317();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_over_1();
					mw_check_short_flag_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3317();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_3317();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_3317();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3317 (void) {
	{
		VAL d2 = pop_value();
		mw_over_1();
		mw_check_short_flag_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_over_1();
			mw_check_short_flag_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_find_some_2_3326 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_over_1();
			mw_check_long_flag_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			mw_find_some_aux2_1_3326();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_over_1();
					mw_check_long_flag_1();
					if (pop_u64()) {
						mtw_SOME_1();
					} else {
						mp_prim_drop();
						push_u64(0LL); // NONE
					}
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_aux2_1_3326();
					break;
				default:
					{
						VAL d6 = pop_value();
						mw_drop2_1();
						push_value(d6);
					}
					break;
			}
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_find_some_2_3326();
				push_value(d4);
			}
			mp_prim_swap();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mw_find_some_2_3326();
					break;
				default:
					mw_nip_1();
					break;
			}
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_find_some_aux2_1_3326 (void) {
	{
		VAL d2 = pop_value();
		mw_over_1();
		mw_check_long_flag_1();
		if (pop_u64()) {
			mtw_SOME_1();
		} else {
			mp_prim_drop();
			push_u64(0LL); // NONE
		}
		push_value(d2);
	}
	mp_prim_swap();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_over_1();
			mw_check_long_flag_1();
			if (pop_u64()) {
				mtw_SOME_1();
			} else {
				mp_prim_drop();
				push_u64(0LL); // NONE
			}
			break;
		default:
			mw_nip_1();
			break;
	}
}
static void mw_for_3_1039 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			mw_T_2A__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_T_2A__1();
					push_value(d5);
				}
				mw_T_2A__1();
				push_value(d4);
			}
			mw_T_2A__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1039();
				push_value(d4);
			}
			mw_for_3_1039();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_for_3_1315 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mfld__7E_data_1();
			mp_prim_mut_set();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_over_1();
					push_value(d5);
				}
				mfld__7E_data_1();
				mp_prim_mut_set();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mfld__7E_data_1();
			mp_prim_mut_set();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_over_1();
						push_value(d6);
					}
					mfld__7E_data_1();
					mp_prim_mut_set();
					push_value(d5);
				}
				{
					VAL d5 = pop_value();
					mw_over_1();
					push_value(d5);
				}
				mfld__7E_data_1();
				mp_prim_mut_set();
				push_value(d4);
			}
			{
				VAL d4 = pop_value();
				mw_over_1();
				push_value(d4);
			}
			mfld__7E_data_1();
			mp_prim_mut_set();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			mp_prim_drop();
			{
				VAL d4 = pop_value();
				mw_for_3_1315();
				push_value(d4);
			}
			mw_for_3_1315();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mw_map_4_1311 (void) {
	switch (get_top_data_tag()) {
		case 0LL: // L1+
			mtp_L1_2B__1();
			{
				VAL d4 = pop_value();
				mw_alloc_21__15();
				mp_prim_dup();
				push_value(d4);
			}
			mp_prim_mut_set();
			mtw_L1_2B__1();
			break;
		case 1LL: // L2+
			mtp_L2_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_alloc_21__15();
					mp_prim_dup();
					push_value(d5);
				}
				mp_prim_mut_set();
				push_value(d4);
			}
			mp_prim_swap();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_alloc_21__15();
					mp_prim_dup();
					push_value(d5);
				}
				mp_prim_mut_set();
				push_value(d4);
			}
			mp_prim_swap();
			mtw_L2_2B__1();
			break;
		case 2LL: // L3+
			mtp_L3_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_alloc_21__15();
						mp_prim_dup();
						push_value(d6);
					}
					mp_prim_mut_set();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_alloc_21__15();
						mp_prim_dup();
						push_value(d6);
					}
					mp_prim_mut_set();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						mw_alloc_21__15();
						mp_prim_dup();
						push_value(d6);
					}
					mp_prim_mut_set();
					push_value(d5);
				}
				push_value(d4);
			}
			mw_rotr_1();
			mtw_L3_2B__1();
			break;
		case 3LL: // LCAT+
			mtp_LCAT_2B__1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_map_4_1311();
					push_value(d5);
				}
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_map_4_1311();
					push_value(d5);
				}
				mp_prim_swap();
				push_value(d4);
			}
			mtw_LCAT_2B__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
}
static void mb_99 (void) {
	mw_compiler_parse_args_1();
}
static void mb_169 (void) {
	mw_mangle_compute_21__1();
}
static void mb_741 (void) {
	mw__3E_Int_16();
}
static void mb_931 (void) {
	mp_prim_pack_uncons();
	VAL var_f = pop_value();
	pop_value();
	mp_prim_drop();
	incref(var_f);
	run_value(var_f);
	decref(var_f);
}
static void mb_1587 (void) {
	mw_unpack_1();
	mw_rotr_1();
}
static void mb_1588 (void) {
	mp_prim_pack_uncons();
	VAL var_f = pop_value();
	pop_value();
	incref(var_f);
	run_value(var_f);
	mw_ab_unify_type_21__1();
	decref(var_f);
}
static void mb_1590 (void) {
	mw_ctx_type_1();
}
static void mb_1591 (void) {
	mw_body_1();
}
static void mb_1593 (void) {
	mp_prim_pack_uncons();
	VAL var_f = pop_value();
	pop_value();
	push_fnptr(&mb_1594);
	incref(var_f);
	push_value(var_f);
	mp_prim_pack_cons();
	mw_ab_build_word_arrow_21__1();
	mw_ready_1();
	decref(var_f);
}
static void mb_1594 (void) {
	mp_prim_pack_uncons();
	VAL var_f = pop_value();
	pop_value();
	{
		VAL d2 = pop_value();
		incref(var_f);
		run_value(var_f);
		push_value(d2);
	}
	decref(var_f);
}
static void mb_1624 (void) {
	mp_prim_swap();
	{
		VAL d2 = pop_value();
		mw__3E_Var_1();
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mw_new_4();
			push_value(d3);
		}
		push_value(d2);
	}
	mw_ab_token_40__1();
	mw_elab_expand_tensor_21__1();
	{
		VAL d2 = pop_value();
		mw_rotl_1();
		mw_type_4();
		push_value(d2);
	}
	mw_elab_type_unify_21__1();
	mw_drop2_1();
}
static void mb_1638 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_output_type_1();
	mw_T_2A__2B__1();
	decref(var_tag);
}
static void mb_1652 (void) {
	mp_prim_dup();
	mw_ctx_16();
	mp_prim_swap();
	mp_prim_dup();
	mw_dom_14();
	mp_prim_swap();
	mp_prim_dup();
	mw_cod_15();
	mp_prim_swap();
	mp_prim_dup();
	mw_token_12();
	mp_prim_swap();
	mw_home_11();
	mw_elab_arrow_hom_21__1();
}
static void mb_1708 (void) {
	mp_prim_pack_uncons();
	VAL var_mkbod = pop_value();
	pop_value();
	{
		VAL d2 = pop_value();
		incref(var_mkbod);
		run_value(var_mkbod);
		push_value(d2);
	}
	decref(var_mkbod);
}
static void mb_1749 (void) {
	mp_prim_pack_uncons();
	VAL var_aliasqname = pop_value();
	pop_value();
	mw_unpack2_1();
	switch (get_top_data_tag()) {
		case 0LL: // LEFT
			mtp_LEFT_1();
			mw_defs_1();
			mw_filter_2_1750();
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("unknown alias target", 20);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // L1
					mtp_L1_1();
					break;
				default:
					switch (get_top_data_tag()) {
						case 0LL: // L0
							(void)pop_u64();
							push_u64(0LL); // L0
							break;
						case 1LL: // L1
							mtp_L1_1();
							mw_qname_12();
							mtw_L1_1();
							break;
						case 2LL: // L2
							mtp_L2_1();
							{
								VAL d8 = pop_value();
								mw_qname_12();
								push_value(d8);
							}
							mp_prim_swap();
							{
								VAL d8 = pop_value();
								mw_qname_12();
								push_value(d8);
							}
							mp_prim_swap();
							mtw_L2_1();
							break;
						case 3LL: // L3
							mtp_L3_1();
							{
								VAL d8 = pop_value();
								{
									VAL d9 = pop_value();
									mw_qname_12();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_rotr_1();
							{
								VAL d8 = pop_value();
								{
									VAL d9 = pop_value();
									mw_qname_12();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_rotr_1();
							{
								VAL d8 = pop_value();
								{
									VAL d9 = pop_value();
									mw_qname_12();
									push_value(d9);
								}
								push_value(d8);
							}
							mw_rotr_1();
							mtw_L3_1();
							break;
						case 4LL: // LCAT
							mtp_LCAT_1();
							{
								VAL d8 = pop_value();
								{
									VAL d9 = pop_value();
									mw_map_4_1751();
									push_value(d9);
								}
								mp_prim_swap();
								{
									VAL d9 = pop_value();
									mw_map_4_1751();
									push_value(d9);
								}
								mp_prim_swap();
								push_value(d8);
							}
							mtw_LCAT_1();
							break;
						default:
							push_value(mkstr("unexpected fallthrough in match\n", 32)); 
							mp_prim_panic();
					}
					mw_elab_ambiguous_name_error_21__1();
					break;
			}
			break;
		case 1LL: // RIGHT
			mtp_RIGHT_1();
			{
				VAL d4 = pop_value();
				mp_prim_dup();
				push_value(d4);
			}
			incref(var_aliasqname);
			push_value(var_aliasqname);
			mw_arity_5();
			mw_elab_qname_from_nonrelative_dname_1();
			mp_prim_dup();
			mw_def_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("undefined alias target ", 23);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						push_value(d6);
					}
					mw__3E_Str_5();
					mp_prim_str_cat();
					mw_emit_fatal_error_21__1();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					mp_prim_id();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_nip_1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_dup2_1();
	mw_def_visible_from_token_3F__1();
	switch (get_top_data_tag()) {
		case 1LL: // T
			(void)pop_u64();
			mp_prim_id();
			break;
		case 0LL: // F
			(void)pop_u64();
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("alias target is not visible", 27);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				push_value(d4);
			}
			mw_defining_module_3F__1();
			switch (get_top_data_tag()) {
				case 0LL: // NONE
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // SOME
					mtp_SOME_1();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(", need to import ", 17);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mp_prim_str_cat();
						push_value(d6);
					}
					mw_qname_10();
					mw__3E_Str_5();
					mp_prim_str_cat();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_emit_fatal_error_21__1();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	switch (get_top_data_tag()) {
		case 0LL: // DEF_ALIAS
			mtp_DEF_5F_ALIAS_1();
			mfld__7E_target_2();
			mp_prim_dup();
			mp_prim_mut_get();
			switch (get_top_data_tag()) {
				case 2LL: // LAZY_WAIT
					(void)pop_u64();
					mp_prim_drop();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("alias points to itself, circular aliases not allowed.", 53);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_emit_fatal_error_21__1();
					break;
				default:
					mp_prim_drop();
					mw_force_21__1();
					break;
			}
			mw_nip_1();
			break;
		default:
			mw_nip_1();
			break;
	}
	decref(var_aliasqname);
}
static void mb_1767 (void) {
	mw_type_elab_default_1();
	mw_over_1();
	mw_sig_1();
	switch (get_top_data_tag()) {
		case 0LL: // NONE
			(void)pop_u64();
			mw_over_1();
			mw_head_2();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("need word signature", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_emit_fatal_error_21__1();
			break;
		case 1LL: // SOME
			mtp_SOME_1();
			mp_prim_id();
			break;
		default:
			push_value(mkstr("unexpected fallthrough in match\n", 32)); 
			mp_prim_panic();
	}
	mw_elab_type_sig_21__1();
	mp_prim_drop();
	{
		VAL d2 = pop_value();
		mw_type_elab_ctx_1();
		push_value(d2);
	}
	mw_pack2_1();
	mw_nip_1();
}
static void mb_1770 (void) {
	mw_elab_def_params_21__1();
}
static void mb_1771 (void) {
	mp_prim_dup();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_ctx_type_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_body_1();
		push_value(d2);
	}
	mtw_HOME_5F_WORD_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_unpack_1();
			mw_rotr_1();
			push_value(d3);
		}
		push_value(d2);
	}
	LPUSH(lbl_home);
	mp_prim_dup();
	LPUSH(lbl_token_start);
	LPUSH(lbl_token_end);
	mp_prim_dup();
	LPUSH(lbl_dom);
	LPUSH(lbl_cod);
	LPUSH(lbl_ctx);
	push_u64(0LL); // L0
	LPUSH(lbl_atoms);
	mtw_ARROW_1();
	LPUSH(lbl_arrow);
	mtw_MKAB_1();
	mp_prim_swap();
	mw_params_1();
	mp_prim_dup();
	mw_is_empty_2();
	if (pop_u64()) {
		mp_prim_drop();
		mw_elab_def_body_21__1();
	} else {
		{
			VAL d3 = pop_value();
			mw_ab_token_40__1();
			push_value(d3);
		}
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_value();
				mw_ab_ctx_40__1();
				mw_ab_type_40__1();
				push_value(d4);
			}
			switch (get_top_data_tag()) {
				case 0LL: // L0
					(void)pop_u64();
					mp_prim_id();
					break;
				case 1LL: // L1
					mtp_L1_1();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw__3E_Var_1();
						mp_prim_dup();
						{
							VAL d7 = pop_value();
							mw_new_4();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_ab_token_40__1();
					mw_elab_expand_tensor_21__1();
					{
						VAL d6 = pop_value();
						mw_rotl_1();
						mw_type_4();
						push_value(d6);
					}
					mw_elab_type_unify_21__1();
					mw_drop2_1();
					break;
				case 2LL: // L2
					mtp_L2_1();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw__3E_Var_1();
							mp_prim_dup();
							{
								VAL d8 = pop_value();
								mw_new_4();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_ab_token_40__1();
						mw_elab_expand_tensor_21__1();
						{
							VAL d7 = pop_value();
							mw_rotl_1();
							mw_type_4();
							push_value(d7);
						}
						mw_elab_type_unify_21__1();
						mw_drop2_1();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw__3E_Var_1();
						mp_prim_dup();
						{
							VAL d7 = pop_value();
							mw_new_4();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_ab_token_40__1();
					mw_elab_expand_tensor_21__1();
					{
						VAL d6 = pop_value();
						mw_rotl_1();
						mw_type_4();
						push_value(d6);
					}
					mw_elab_type_unify_21__1();
					mw_drop2_1();
					break;
				case 3LL: // L3
					mtp_L3_1();
					mw_rotr_1();
					mw_dip2_1_3158();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mp_prim_swap();
						{
							VAL d7 = pop_value();
							mw__3E_Var_1();
							mp_prim_dup();
							{
								VAL d8 = pop_value();
								mw_new_4();
								push_value(d8);
							}
							push_value(d7);
						}
						mw_ab_token_40__1();
						mw_elab_expand_tensor_21__1();
						{
							VAL d7 = pop_value();
							mw_rotl_1();
							mw_type_4();
							push_value(d7);
						}
						mw_elab_type_unify_21__1();
						mw_drop2_1();
						push_value(d6);
					}
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw__3E_Var_1();
						mp_prim_dup();
						{
							VAL d7 = pop_value();
							mw_new_4();
							push_value(d7);
						}
						push_value(d6);
					}
					mw_ab_token_40__1();
					mw_elab_expand_tensor_21__1();
					{
						VAL d6 = pop_value();
						mw_rotl_1();
						mw_type_4();
						push_value(d6);
					}
					mw_elab_type_unify_21__1();
					mw_drop2_1();
					break;
				case 4LL: // LCAT
					mtp_LCAT_1();
					mp_prim_drop();
					mp_prim_swap();
					{
						VAL d6 = pop_value();
						mw_reverse_for_2_3158();
						push_value(d6);
					}
					mw_reverse_for_2_3158();
					break;
				default:
					push_value(mkstr("unexpected fallthrough in match\n", 32)); 
					mp_prim_panic();
			}
			mw_rotl_1();
			mw_ab_home_40__1();
			{
				VAL d4 = pop_resource();
				LPUSH(lbl_home);
				mp_prim_dup();
				LPUSH(lbl_token_start);
				LPUSH(lbl_token_end);
				mp_prim_dup();
				LPUSH(lbl_dom);
				LPUSH(lbl_cod);
				LPUSH(lbl_ctx);
				push_u64(0LL); // L0
				LPUSH(lbl_atoms);
				mtw_ARROW_1();
				LPUSH(lbl_arrow);
				mtw_MKAB_1();
				mw_elab_def_body_21__1();
				mw__2F_MKAB_1();
				LPOP(lbl_arrow);
				push_resource(d4);
			}
			push_value(d3);
		}
		LPUSH(lbl_params);
		LPUSH(lbl_body);
		mw_ab_ctx_40__1();
		LPUSH(lbl_outer_ctx);
		mw_ab_type_40__1();
		LPUSH(lbl_dom);
		mw_ab_token_40__1();
		LPUSH(lbl_token);
		mtw_LAMBDA_1();
		mtw_OP_5F_LAMBDA_1();
		mw_ab_op_21__1();
	}
	mw_ab_unify_type_21__1();
	mw__2F_MKAB_1();
	LPOP(lbl_arrow);
}
static void mb_1786 (void) {
	mw_type_elab_default_1();
	mp_prim_swap();
	mw_sig_2();
	mw_elab_type_sig_21__1();
	mp_prim_drop();
	{
		VAL d2 = pop_value();
		mw_type_elab_ctx_1();
		push_value(d2);
	}
	mw_pack2_1();
}
static void mb_1791 (void) {
	mw_elab_simple_type_arg_21__1();
}
static void mb_1813 (void) {
	mw_type_elab_default_1();
	mw_over_1();
	mw_data_3();
	mw_head_3F__3();
	mw_unwrap_1();
	mw_elab_type_atom_21__1();
	mp_prim_drop();
	{
		VAL d2 = pop_value();
		mw_T0_1();
		push_value(d2);
	}
	mw_cons_4();
	{
		VAL d2 = pop_value();
		mw_T0_1();
		mw_rotl_1();
		mw_sig_3F__1();
		switch (get_top_data_tag()) {
			case 0LL: // NONE
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // SOME
				mtp_SOME_1();
				mw_elab_type_stack_rest_21__1();
				mp_prim_dup();
				mw_run_end_3F__1();
				switch (get_top_data_tag()) {
					case 1LL: // T
						(void)pop_u64();
						mp_prim_id();
						break;
					case 0LL: // F
						(void)pop_u64();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("syntax error", 12);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_emit_fatal_error_21__1();
						break;
					default:
						push_value(mkstr("unexpected fallthrough in match\n", 32)); 
						mp_prim_panic();
				}
				mp_prim_drop();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		push_value(d2);
	}
	mw_T__3E__1();
	{
		VAL d2 = pop_value();
		mw_type_elab_ctx_1();
		push_value(d2);
	}
	mw_pack2_1();
}
static void mb_1828 (void) {
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	pop_value();
	incref(var_dat);
	push_value(var_dat);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("tag", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_data_word_new_21__1();
	{
		VAL var_tag = pop_value();
		mw_CTX0_1();
		incref(var_dat);
		push_value(var_dat);
		mtw_TData_1();
		mw_T1_1();
		mw_TYPE_5F_INT_1();
		mw_T1_1();
		mw_T__3E__1();
		mw_ready2_1();
		incref(var_tag);
		push_value(var_tag);
		mfld__7E_ctx_type_1();
		mp_prim_mut_set();
		incref(var_tag);
		push_value(var_tag);
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_ctx_type_1();
				push_value(d4);
			}
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_body_1();
				push_value(d4);
			}
			mtw_HOME_5F_WORD_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_unpack_1();
					mw_rotr_1();
					push_value(d5);
				}
				push_value(d4);
			}
			LPUSH(lbl_home);
			mp_prim_dup();
			LPUSH(lbl_token_start);
			LPUSH(lbl_token_end);
			mp_prim_dup();
			LPUSH(lbl_dom);
			LPUSH(lbl_cod);
			LPUSH(lbl_ctx);
			push_u64(0LL); // L0
			LPUSH(lbl_atoms);
			mtw_ARROW_1();
			LPUSH(lbl_arrow);
			mtw_MKAB_1();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // COERCE_UNSAFE
				mw_ab_coerce_21__1();
				push_value(d4);
			}
			mw_ab_unify_type_21__1();
			mw__2F_MKAB_1();
			LPOP(lbl_arrow);
			mw_ready_1();
			push_value(d3);
		}
		mw_tuck_1();
		mfld__7E_arrow_1();
		mp_prim_mut_set();
		mp_prim_drop();
		decref(var_tag);
	}
	incref(var_dat);
	push_value(var_dat);
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("from-tag-unsafe", 15);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	push_i64(0LL);
	mw_data_word_new_21__1();
	{
		VAL var_ftag = pop_value();
		mw_CTX0_1();
		mw_TYPE_5F_INT_1();
		mw_T1_1();
		incref(var_dat);
		push_value(var_dat);
		mtw_TData_1();
		mw_T1_1();
		mw_T__3E__1();
		mw_ready2_1();
		incref(var_ftag);
		push_value(var_ftag);
		mfld__7E_ctx_type_1();
		mp_prim_mut_set();
		incref(var_ftag);
		push_value(var_ftag);
		mp_prim_dup();
		{
			VAL d3 = pop_value();
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_ctx_type_1();
				push_value(d4);
			}
			mp_prim_dup();
			{
				VAL d4 = pop_value();
				mw_body_1();
				push_value(d4);
			}
			mtw_HOME_5F_WORD_1();
			{
				VAL d4 = pop_value();
				{
					VAL d5 = pop_value();
					mw_unpack_1();
					mw_rotr_1();
					push_value(d5);
				}
				push_value(d4);
			}
			LPUSH(lbl_home);
			mp_prim_dup();
			LPUSH(lbl_token_start);
			LPUSH(lbl_token_end);
			mp_prim_dup();
			LPUSH(lbl_dom);
			LPUSH(lbl_cod);
			LPUSH(lbl_ctx);
			push_u64(0LL); // L0
			LPUSH(lbl_atoms);
			mtw_ARROW_1();
			LPUSH(lbl_arrow);
			mtw_MKAB_1();
			{
				VAL d4 = pop_value();
				push_u64(0LL); // COERCE_UNSAFE
				mw_ab_coerce_21__1();
				push_value(d4);
			}
			mw_ab_unify_type_21__1();
			mw__2F_MKAB_1();
			LPOP(lbl_arrow);
			mw_ready_1();
			push_value(d3);
		}
		mw_tuck_1();
		mfld__7E_arrow_1();
		mp_prim_mut_set();
		mp_prim_drop();
		decref(var_ftag);
	}
	decref(var_dat);
}
static void mb_1831 (void) {
	mw_ctx_type_3();
	mw_unpack_1();
	mp_prim_swap();
	mw_T__3E__1();
	mw_pack2_1();
}
static void mb_1832 (void) {
	mp_prim_pack_uncons();
	VAL var_untag = pop_value();
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	push_fnptr(&mb_1833);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	incref(var_dat);
	push_value(var_dat);
	mp_prim_pack_cons();
	incref(var_untag);
	push_value(var_untag);
	mp_prim_pack_cons();
	mw_ab_build_word_arrow_21__1();
	decref(var_untag);
	decref(var_dat);
	decref(var_tag);
}
static void mb_1833 (void) {
	mp_prim_pack_uncons();
	VAL var_untag = pop_value();
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_untag);
	push_value(var_untag);
	mw_type_2();
	mw_cod_1();
	LPUSH(lbl_cod);
	incref(var_dat);
	push_value(var_dat);
	mw_head_3F__3();
	mw_unwrap_1();
	LPUSH(lbl_body);
	push_fnptr(&mb_1834);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	incref(var_dat);
	push_value(var_dat);
	mp_prim_pack_cons();
	mw_ab_match_21__1();
	decref(var_untag);
	decref(var_dat);
	decref(var_tag);
}
static void mb_1834 (void) {
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_dat);
	push_value(var_dat);
	mw_head_3F__3();
	mw_unwrap_1();
	mp_prim_dup();
	push_fnptr(&mb_1835);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	push_fnptr(&mb_1836);
	mw_case_21__1();
	decref(var_dat);
	decref(var_tag);
}
static void mb_1835 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_tag_21__1();
	decref(var_tag);
}
static void mb_1836 (void) {
	mp_prim_id();
}
static void mb_1839 (void) {
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	{
		VAL var_lbl = pop_value();
		incref(var_dat);
		push_value(var_dat);
		incref(var_lbl);
		push_value(var_lbl);
		mw_name_14();
		push_i64(0LL);
		mw_data_qname_1();
		mw_undefined_3F__1();
		push_fnptr(&mb_1840);
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		incref(var_lbl);
		push_value(var_lbl);
		mp_prim_pack_cons();
		incref(var_dat);
		push_value(var_dat);
		mp_prim_pack_cons();
		mw_then_1();
		decref(var_lbl);
	}
	decref(var_dat);
	decref(var_tag);
}
static void mb_1840 (void) {
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_dat);
	push_value(var_dat);
	incref(var_lbl);
	push_value(var_lbl);
	mw__3E_Str_6();
	push_i64(0LL);
	mw_data_word_new_21__1();
	incref(var_dat);
	push_value(var_dat);
	incref(var_lbl);
	push_value(var_lbl);
	mw__3E_Str_6();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("!", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mp_prim_str_cat();
	push_i64(0LL);
	mw_data_word_new_21__1();
	incref(var_dat);
	push_value(var_dat);
	incref(var_lbl);
	push_value(var_lbl);
	mw__3E_Str_6();
	push_i64(1LL);
	mw_data_word_new_21__1();
	{
		VAL var_lbl_5F_lens = pop_value();
		VAL var_lbl_5F_set = pop_value();
		VAL var_lbl_5F_get = pop_value();
		push_fnptr(&mb_1841);
		incref(var_lbl);
		push_value(var_lbl);
		mp_prim_pack_cons();
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_delay0_1();
		incref(var_lbl_5F_get);
		push_value(var_lbl_5F_get);
		mfld__7E_ctx_type_1();
		mp_prim_mut_set();
		incref(var_lbl_5F_get);
		push_value(var_lbl_5F_get);
		push_fnptr(&mb_1842);
		incref(var_lbl);
		push_value(var_lbl);
		mp_prim_pack_cons();
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_delay_1();
		incref(var_lbl_5F_get);
		push_value(var_lbl_5F_get);
		mfld__7E_arrow_1();
		mp_prim_mut_set();
		push_fnptr(&mb_1844);
		incref(var_lbl);
		push_value(var_lbl);
		mp_prim_pack_cons();
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_delay0_1();
		incref(var_lbl_5F_set);
		push_value(var_lbl_5F_set);
		mfld__7E_ctx_type_1();
		mp_prim_mut_set();
		incref(var_lbl_5F_set);
		push_value(var_lbl_5F_set);
		push_fnptr(&mb_1845);
		incref(var_lbl);
		push_value(var_lbl);
		mp_prim_pack_cons();
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		mw_delay_1();
		incref(var_lbl_5F_set);
		push_value(var_lbl_5F_set);
		mfld__7E_arrow_1();
		mp_prim_mut_set();
		push_fnptr(&mb_1847);
		incref(var_tag);
		push_value(var_tag);
		mp_prim_pack_cons();
		incref(var_lbl);
		push_value(var_lbl);
		mp_prim_pack_cons();
		mw_delay0_1();
		incref(var_lbl_5F_lens);
		push_value(var_lbl_5F_lens);
		mfld__7E_ctx_type_1();
		mp_prim_mut_set();
		incref(var_lbl_5F_lens);
		push_value(var_lbl_5F_lens);
		push_fnptr(&mb_1848);
		mtw_LAZY_5F_DELAY_1();
		incref(var_lbl_5F_lens);
		push_value(var_lbl_5F_lens);
		mfld__7E_params_1();
		mp_prim_mut_set();
		incref(var_lbl_5F_lens);
		push_value(var_lbl_5F_lens);
		push_fnptr(&mb_1849);
		incref(var_lbl_5F_set);
		push_value(var_lbl_5F_set);
		mp_prim_pack_cons();
		incref(var_lbl_5F_get);
		push_value(var_lbl_5F_get);
		mp_prim_pack_cons();
		incref(var_dat);
		push_value(var_dat);
		mp_prim_pack_cons();
		incref(var_lbl_5F_lens);
		push_value(var_lbl_5F_lens);
		mp_prim_pack_cons();
		mw_delay_1();
		incref(var_lbl_5F_lens);
		push_value(var_lbl_5F_lens);
		mfld__7E_arrow_1();
		mp_prim_mut_set();
		decref(var_lbl_5F_lens);
		decref(var_lbl_5F_set);
		decref(var_lbl_5F_get);
	}
	decref(var_dat);
	decref(var_lbl);
	decref(var_tag);
}
static void mb_1841 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_ctx_11();
	incref(var_tag);
	push_value(var_tag);
	incref(var_lbl);
	push_value(var_lbl);
	mw_data_get_label_type_1();
	mw_pack2_1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_1842 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	push_fnptr(&mb_1843);
	incref(var_lbl);
	push_value(var_lbl);
	mp_prim_pack_cons();
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_ab_build_word_arrow_21__1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_1843 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	incref(var_lbl);
	push_value(var_lbl);
	mtw_OP_5F_DATA_5F_GET_5F_LABEL_1();
	mw_ab_op_21__1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_1844 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_ctx_11();
	incref(var_tag);
	push_value(var_tag);
	incref(var_lbl);
	push_value(var_lbl);
	mw_data_set_label_type_1();
	mw_pack2_1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_1845 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	push_fnptr(&mb_1846);
	incref(var_lbl);
	push_value(var_lbl);
	mp_prim_pack_cons();
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_ab_build_word_arrow_21__1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_1846 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	incref(var_lbl);
	push_value(var_lbl);
	mtw_OP_5F_DATA_5F_SET_5F_LABEL_1();
	mw_ab_op_21__1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_1847 (void) {
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	mw_TYPE_5F_STACK_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("*x", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	mw_TYPE_5F_STACK_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("*y", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_21__3();
	incref(var_lbl);
	push_value(var_lbl);
	incref(var_tag);
	push_value(var_tag);
	mw_project_input_label_1();
	mw_unwrap_1();
	incref(var_tag);
	push_value(var_tag);
	mw_output_type_1();
	{
		VAL var_datty = pop_value();
		VAL var_lblty = pop_value();
		VAL var_sy = pop_value();
		VAL var_sx = pop_value();
		incref(var_tag);
		push_value(var_tag);
		mw_ctx_11();
		mw__2F_CTX_1();
		incref(var_sx);
		push_value(var_sx);
		incref(var_sy);
		push_value(var_sy);
		mtw_L2_1();
		mw_cat_2();
		incref(var_sx);
		push_value(var_sx);
		mtw_STVar_1();
		incref(var_datty);
		push_value(var_datty);
		mw_T_2A__2B__1();
		incref(var_sx);
		push_value(var_sx);
		mtw_STVar_1();
		incref(var_lblty);
		push_value(var_lblty);
		mw_T_2A__1();
		incref(var_sy);
		push_value(var_sy);
		mtw_STVar_1();
		incref(var_lblty);
		push_value(var_lblty);
		mw_T_2A__1();
		mw_T__3E__1();
		mtw_TMorphism_1();
		mw_T_2A__1();
		incref(var_sy);
		push_value(var_sy);
		mtw_STVar_1();
		incref(var_datty);
		push_value(var_datty);
		mw_T_2A__2B__1();
		mw_T__3E__1();
		mw_pack2_1();
		decref(var_datty);
		decref(var_lblty);
		decref(var_sy);
		decref(var_sx);
	}
	decref(var_lbl);
	decref(var_tag);
}
static void mb_1848 (void) {
	mw_type_2();
	mw_dom_1();
	mw_force_cons_3F__21__1();
	mw_unwrap_1();
	mw_unpack2_1();
	mw_nip_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("f", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw__3E_Name_1();
	mw_new_auto_run_21__1();
	mtw_L1_1();
}
static void mb_1849 (void) {
	mp_prim_pack_uncons();
	VAL var_lbl_5F_lens = pop_value();
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl_5F_get = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl_5F_set = pop_value();
	pop_value();
	push_fnptr(&mb_1850);
	incref(var_lbl_5F_set);
	push_value(var_lbl_5F_set);
	mp_prim_pack_cons();
	incref(var_lbl_5F_get);
	push_value(var_lbl_5F_get);
	mp_prim_pack_cons();
	incref(var_dat);
	push_value(var_dat);
	mp_prim_pack_cons();
	incref(var_lbl_5F_lens);
	push_value(var_lbl_5F_lens);
	mp_prim_pack_cons();
	mw_ab_build_word_arrow_21__1();
	decref(var_lbl_5F_lens);
	decref(var_dat);
	decref(var_lbl_5F_get);
	decref(var_lbl_5F_set);
}
static void mb_1850 (void) {
	mp_prim_pack_uncons();
	VAL var_lbl_5F_lens = pop_value();
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl_5F_get = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl_5F_set = pop_value();
	pop_value();
	incref(var_lbl_5F_lens);
	push_value(var_lbl_5F_lens);
	mw_params_1();
	mp_prim_dup();
	push_fnptr(&mb_1851);
	incref(var_lbl_5F_set);
	push_value(var_lbl_5F_set);
	mp_prim_pack_cons();
	incref(var_lbl_5F_get);
	push_value(var_lbl_5F_get);
	mp_prim_pack_cons();
	incref(var_dat);
	push_value(var_dat);
	mp_prim_pack_cons();
	mw_ab_lambda_21__1();
	decref(var_lbl_5F_lens);
	decref(var_dat);
	decref(var_lbl_5F_get);
	decref(var_lbl_5F_set);
}
static void mb_1851 (void) {
	mp_prim_pack_uncons();
	VAL var_dat = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl_5F_get = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl_5F_set = pop_value();
	pop_value();
	mw__2F_L1_1();
	mw_unwrap_1();
	mw__2F_PARAM_1();
	LPUSH(lbl_f);
	incref(var_dat);
	push_value(var_dat);
	mw_is_resource_3F__2();
	if (pop_u64()) {
		incref(var_lbl_5F_get);
		push_value(var_lbl_5F_get);
		mw_ab_word_21__1();
		mw_ab_token_40__1();
		mw_ab_ctx_40__1();
		mw_new_21__5();
		mtw_STMeta_1();
		mw_rotl_1();
		mw_ab_home_40__1();
		{
			VAL d3 = pop_resource();
			LPUSH(lbl_home);
			mp_prim_dup();
			LPUSH(lbl_token_start);
			LPUSH(lbl_token_end);
			mp_prim_dup();
			LPUSH(lbl_dom);
			LPUSH(lbl_cod);
			LPUSH(lbl_ctx);
			push_u64(0LL); // L0
			LPUSH(lbl_atoms);
			mtw_ARROW_1();
			LPUSH(lbl_arrow);
			mtw_MKAB_1();
			LPOP(lbl_f);
			mw_ab_var_21__1();
			mw__2F_MKAB_1();
			LPOP(lbl_arrow);
			push_resource(d3);
		}
		mw_new_21__10();
		mtw_OP_5F_BLOCK_1();
		mw_ab_op_21__1();
		push_u64(13LL); // PRIM_CORE_RDIP
		mw_ab_prim_21__1();
		incref(var_lbl_5F_set);
		push_value(var_lbl_5F_set);
		mw_ab_word_21__1();
	} else {
		push_u64(1LL); // PRIM_CORE_DUP
		mw_ab_prim_21__1();
		push_fnptr(&mb_1855);
		incref(var_lbl_5F_get);
		push_value(var_lbl_5F_get);
		mp_prim_pack_cons();
		mw_ab_dip_21__1();
		incref(var_lbl_5F_set);
		push_value(var_lbl_5F_set);
		mw_ab_word_21__1();
	}
	decref(var_dat);
	decref(var_lbl_5F_get);
	decref(var_lbl_5F_set);
}
static void mb_1855 (void) {
	mp_prim_pack_uncons();
	VAL var_lbl_5F_get = pop_value();
	pop_value();
	incref(var_lbl_5F_get);
	push_value(var_lbl_5F_get);
	mw_ab_word_21__1();
	LPOP(lbl_f);
	mw_ab_var_21__1();
	decref(var_lbl_5F_get);
}
static void mb_1880 (void) {
	mp_prim_pack_uncons();
	VAL var_t = pop_value();
	mp_prim_pack_uncons();
	VAL var_x = pop_value();
	pop_value();
	incref(var_t);
	push_value(var_t);
	mw_head_5();
	mw_ab_token_21__1();
	incref(var_x);
	push_value(var_x);
	mw__3E_Param_1();
	mtw_L1_1();
	push_fnptr(&mb_1881);
	incref(var_x);
	push_value(var_x);
	mp_prim_pack_cons();
	incref(var_t);
	push_value(var_t);
	mp_prim_pack_cons();
	mw_ab_lambda_21__1();
	decref(var_t);
	decref(var_x);
}
static void mb_1881 (void) {
	mp_prim_pack_uncons();
	VAL var_t = pop_value();
	mp_prim_pack_uncons();
	VAL var_x = pop_value();
	pop_value();
	push_i64(1LL);
	mw_ab_int_21__1();
	push_fnptr(&mb_1882);
	incref(var_t);
	push_value(var_t);
	mp_prim_pack_cons();
	push_fnptr(&mb_1883);
	incref(var_x);
	push_value(var_x);
	mp_prim_pack_cons();
	mw_ab_while_21__1();
	push_u64(2LL); // PRIM_CORE_DROP
	mw_ab_prim_21__1();
	decref(var_t);
	decref(var_x);
}
static void mb_1882 (void) {
	mp_prim_pack_uncons();
	VAL var_t = pop_value();
	pop_value();
	push_u64(1LL); // PRIM_CORE_DUP
	mw_ab_prim_21__1();
	incref(var_t);
	push_value(var_t);
	mw_num_buffer_1();
	mw_ab_buffer_21__1();
	push_u64(56LL); // PRIM_U64_GET
	mw_ab_prim_21__1();
	push_u64(0LL); // COERCE_UNSAFE
	mw_ab_coerce_21__1();
	push_i64(1LL);
	mw_ab_int_21__1();
	push_u64(16LL); // PRIM_INT_ADD
	mw_ab_prim_21__1();
	push_u64(15LL); // PRIM_INT_LT
	mw_ab_prim_21__1();
	decref(var_t);
}
static void mb_1883 (void) {
	mp_prim_pack_uncons();
	VAL var_x = pop_value();
	pop_value();
	push_u64(1LL); // PRIM_CORE_DUP
	mw_ab_prim_21__1();
	push_fnptr(&mb_1884);
	incref(var_x);
	push_value(var_x);
	mp_prim_pack_cons();
	mw_ab_dip_21__1();
	push_i64(1LL);
	mw_ab_int_21__1();
	push_u64(16LL); // PRIM_INT_ADD
	mw_ab_prim_21__1();
	decref(var_x);
}
static void mb_1884 (void) {
	mp_prim_pack_uncons();
	VAL var_x = pop_value();
	pop_value();
	push_u64(0LL); // COERCE_UNSAFE
	mw_ab_coerce_21__1();
	incref(var_x);
	push_value(var_x);
	mw_ab_var_21__1();
	decref(var_x);
}
static void mb_1894 (void) {
	mw_elab_simple_type_arg_21__1();
}
static void mb_1895 (void) {
	mw_elab_simple_type_arg_21__1();
}
static void mb_1924 (void) {
	mp_prim_pack_uncons();
	VAL var_w = pop_value();
	mp_prim_pack_uncons();
	VAL var_k = pop_value();
	pop_value();
	incref(var_w);
	push_value(var_w);
	mw_cname_1();
	mw__3B__1();
	incref(var_k);
	push_value(var_k);
	mw__2F_SPKEY_1();
	mw_for_3_1925();
	decref(var_w);
	decref(var_k);
}
static void mb_2029 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw__2F_MKC99_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_resource();
				mw_word_needed_3F__1();
				push_resource(d4);
			}
			push_value(d3);
		}
		push_value(d2);
	}
	mtw_MKC99_1();
	push_fnptr(&mb_2031);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_then_1();
	incref(var_tag);
	push_value(var_tag);
	mw__2F_MKC99_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			{
				VAL d4 = pop_resource();
				mw_pat_needed_3F__1();
				push_resource(d4);
			}
			push_value(d3);
		}
		push_value(d2);
	}
	mtw_MKC99_1();
	push_fnptr(&mb_2043);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_then_1();
	decref(var_tag);
}
static void mb_2031 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_word_cname_1();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	incref(var_tag);
	push_value(var_tag);
	mw_is_transparent_3F__3();
	push_fnptr(&mb_2032);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_else_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	decref(var_tag);
}
static void mb_2032 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_num_total_inputs_1();
	mw_0_3D__2();
	if (pop_u64()) {
		incref(var_tag);
		push_value(var_tag);
		mw_outputs_resource_3F__1();
		if (pop_u64()) {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tpush_resource(MKU64(", 21);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tpush_value(MKU64(", 18);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
		}
		mw_put_3();
		incref(var_tag);
		push_value(var_tag);
		mw_value_show_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("LL));", 5);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tTUP* tup = tup_new(", 20);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		incref(var_tag);
		push_value(var_tag);
		mw_num_total_inputs_1();
		mw_1_2B__2();
		mw_show_2();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(");", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\ttup->size = ", 13);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		incref(var_tag);
		push_value(var_tag);
		mw_num_total_inputs_1();
		mw_1_2B__2();
		mw_show_2();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr(";", 1);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\ttup->cells[0] = MKU64(", 23);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		incref(var_tag);
		push_value(var_tag);
		mw_value_show_1();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("LL);", 4);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		incref(var_tag);
		push_value(var_tag);
		mw_num_total_inputs_1();
		incref(var_tag);
		push_value(var_tag);
		mw_label_inputs_1();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_over_1();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = lpop(&lbl_", 14);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				break;
			case 2LL: // L2
				mtp_L2_1();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("\ttup->cells[", 12);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_over_1();
					mw_show_2();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("] = lpop(&lbl_", 14);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_name_14();
					mw_mangled_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(");", 2);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_1__2();
					push_value(d5);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_over_1();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = lpop(&lbl_", 14);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				break;
			case 3LL: // L3
				mtp_L3_1();
				mw_rotr_1();
				mw_dip2_1_2037();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("\ttup->cells[", 12);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_over_1();
					mw_show_2();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("] = lpop(&lbl_", 14);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_name_14();
					mw_mangled_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(");", 2);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_1__2();
					push_value(d5);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_over_1();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = lpop(&lbl_", 14);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(");", 2);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				mp_prim_swap();
				{
					VAL d5 = pop_value();
					mw_reverse_for_2_2037();
					push_value(d5);
				}
				mw_reverse_for_2_2037();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		incref(var_tag);
		push_value(var_tag);
		mw_num_resource_inputs_1();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = pop_resource();", 19);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		incref(var_tag);
		push_value(var_tag);
		mw_num_type_inputs_1();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\ttup->cells[", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_2();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("] = pop_value();", 16);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_1__2();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		mp_prim_drop();
		incref(var_tag);
		push_value(var_tag);
		mw_outputs_resource_3F__1();
		if (pop_u64()) {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tpush_resource(MKTUP(tup, ", 26);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
		} else {
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("\tpush_value(MKTUP(tup, ", 23);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
		}
		mw_put_3();
		incref(var_tag);
		push_value(var_tag);
		mw_num_total_inputs_1();
		mw_1_2B__2();
		mw_show_2();
		mw_put_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("));", 3);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	}
	decref(var_tag);
}
static void mb_2043 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_pat_cname_1();
	mw_sig_put_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(" {", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	incref(var_tag);
	push_value(var_tag);
	mw_is_transparent_3F__3();
	push_fnptr(&mb_2044);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_else_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("}", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	decref(var_tag);
}
static void mb_2044 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	incref(var_tag);
	push_value(var_tag);
	mw_outputs_resource_3F__1();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tVAL val = pop_resource();", 26);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tVAL val = pop_value();", 23);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
	}
	mw_put_3();
	mw_line_3();
	incref(var_tag);
	push_value(var_tag);
	mw_num_total_inputs_1();
	mw_0_3D__2();
	if (pop_u64()) {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\t(void)val;", 11);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	} else {
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tASSERT1(IS_TUP(val),val);", 26);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tTUP* tup = VTUP(val);", 22);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		push_i64(1LL);
		incref(var_tag);
		push_value(var_tag);
		mw_num_type_inputs_1();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tpush_value(tup->cells[", 23);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		incref(var_tag);
		push_value(var_tag);
		mw_num_resource_inputs_1();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tpush_resource(tup->cells[", 26);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		incref(var_tag);
		push_value(var_tag);
		mw_label_inputs_1();
		switch (get_top_data_tag()) {
			case 0LL: // L0
				(void)pop_u64();
				mp_prim_id();
				break;
			case 1LL: // L1
				mtp_L1_1();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tlpush(&lbl_", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(", tup->cells[", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				break;
			case 2LL: // L2
				mtp_L2_1();
				{
					VAL d5 = pop_value();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("\tlpush(&lbl_", 12);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_name_14();
					mw_mangled_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(", tup->cells[", 13);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mp_prim_dup();
					mw_show_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("]);", 3);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_prim_int_succ_1();
					push_value(d5);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tlpush(&lbl_", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(", tup->cells[", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				break;
			case 3LL: // L3
				mtp_L3_1();
				{
					VAL d5 = pop_value();
					{
						VAL d6 = pop_value();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("\tlpush(&lbl_", 12);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_put_3();
						mw_name_14();
						mw_mangled_1();
						mw_put_3();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr(", tup->cells[", 13);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_put_3();
						mp_prim_dup();
						mw_show_1();
						mw_put_3();
						{
							static bool vready = false;
							static VAL v;
							if (! vready) {
								v = mkstr("]);", 3);
								vready = true;
							}
							push_value(v);
							incref(v);
						}
						mw_put_3();
						mw_line_3();
						mw_prim_int_succ_1();
						push_value(d6);
					}
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("\tlpush(&lbl_", 12);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_name_14();
					mw_mangled_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr(", tup->cells[", 13);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mp_prim_dup();
					mw_show_1();
					mw_put_3();
					{
						static bool vready = false;
						static VAL v;
						if (! vready) {
							v = mkstr("]);", 3);
							vready = true;
						}
						push_value(v);
						incref(v);
					}
					mw_put_3();
					mw_line_3();
					mw_prim_int_succ_1();
					push_value(d5);
				}
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\tlpush(&lbl_", 12);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_name_14();
				mw_mangled_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr(", tup->cells[", 13);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				break;
			case 4LL: // LCAT
				mtp_LCAT_1();
				mp_prim_drop();
				{
					VAL d5 = pop_value();
					mw_for_3_2051();
					push_value(d5);
				}
				mw_for_3_2051();
				break;
			default:
				push_value(mkstr("unexpected fallthrough in match\n", 32)); 
				mp_prim_panic();
		}
		mp_prim_drop();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\tif (tup->refs > 1) {", 21);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		push_i64(1LL);
		incref(var_tag);
		push_value(var_tag);
		mw_num_total_inputs_1();
		while(1) {
			mp_prim_dup();
			mw_0_3E__2();
			if (! pop_u64()) break;
			{
				VAL d4 = pop_value();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("\t\tincref(tup->cells[", 20);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mp_prim_dup();
				mw_show_1();
				mw_put_3();
				{
					static bool vready = false;
					static VAL v;
					if (! vready) {
						v = mkstr("]);", 3);
						vready = true;
					}
					push_value(v);
					incref(v);
				}
				mw_put_3();
				mw_line_3();
				mw_prim_int_succ_1();
				push_value(d4);
			}
			mw_1__2();
		}
		mp_prim_drop();
		mp_prim_drop();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\t\tdecref(val);", 14);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\t} else {", 9);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\t\tfree(tup);", 12);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
		{
			static bool vready = false;
			static VAL v;
			if (! vready) {
				v = mkstr("\t}", 2);
				vready = true;
			}
			push_value(v);
			incref(v);
		}
		mw_put_3();
		mw_line_3();
	}
	decref(var_tag);
}
static void mb_2074 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("ASSERT1(VTUPLEN(v) == ", 22);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	incref(var_tag);
	push_value(var_tag);
	mw_num_total_inputs_1();
	mw_1_2B__2();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(", v);", 5);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	decref(var_tag);
}
static void mb_2077 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("VAL* p = &VTUP(v)->cells[", 25);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	incref(var_tag);
	push_value(var_tag);
	incref(var_lbl);
	push_value(var_lbl);
	mw_c99_tag_label_index_1();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("];", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_2080 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	push_fnptr(&mb_2081);
	incref(var_lbl);
	push_value(var_lbl);
	mp_prim_pack_cons();
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_c99_line_1();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("VAL t = *p; *p = u; decref(t);", 30);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_value(v);", 14);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_2081 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("VAL* p = &VTUP(v)->cells[", 25);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	incref(var_tag);
	push_value(var_tag);
	incref(var_lbl);
	push_value(var_lbl);
	mw_c99_tag_label_index_1();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("];", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_2085 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	mp_prim_pack_uncons();
	VAL var_lbl = pop_value();
	pop_value();
	push_fnptr(&mb_2086);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_c99_line_1();
	push_fnptr(&mb_2087);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_c99_line_1();
	push_i64(0LL);
	mw__3E_Nat_1();
	while(1) {
		mp_prim_dup();
		incref(var_tag);
		push_value(var_tag);
		mw_num_total_inputs_1();
		mw__3C__3D__3();
		if (! pop_u64()) break;
		mp_prim_dup();
		incref(var_tag);
		push_value(var_tag);
		incref(var_lbl);
		push_value(var_lbl);
		mw_c99_tag_label_index_1();
		mw__3D__3D__12();
		if (pop_u64()) {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("tup->cells[", 11);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("] = u;", 6);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		} else {
			mw_indent_1();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("tup->cells[", 11);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("] = VTUP(v)->cells[", 19);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]; incref(tup->cells[", 21);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mp_prim_dup();
			mw_show_2();
			mw_put_3();
			{
				static bool vready = false;
				static VAL v;
				if (! vready) {
					v = mkstr("]);", 3);
					vready = true;
				}
				push_value(v);
				incref(v);
			}
			mw_put_3();
			mw_line_3();
		}
		mw_1_2B__2();
	}
	mp_prim_drop();
	mw_indent_1();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("decref(v);", 10);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	mw_line_3();
	push_fnptr(&mb_2095);
	incref(var_tag);
	push_value(var_tag);
	mp_prim_pack_cons();
	mw_c99_line_1();
	decref(var_tag);
	decref(var_lbl);
}
static void mb_2086 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("TUP *tup = tup_new(", 19);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	incref(var_tag);
	push_value(var_tag);
	mw_num_total_inputs_1();
	mw_1_2B__2();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(");", 2);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	decref(var_tag);
}
static void mb_2087 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("tup->size = ", 12);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	incref(var_tag);
	push_value(var_tag);
	mw_num_total_inputs_1();
	mw_1_2B__2();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr(";", 1);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	decref(var_tag);
}
static void mb_2095 (void) {
	mp_prim_pack_uncons();
	VAL var_tag = pop_value();
	pop_value();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("push_value(MKTUP(tup,", 21);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	incref(var_tag);
	push_value(var_tag);
	mw_num_total_inputs_1();
	mw_1_2B__2();
	mw_show_2();
	mw_put_3();
	{
		static bool vready = false;
		static VAL v;
		if (! vready) {
			v = mkstr("));", 3);
			vready = true;
		}
		push_value(v);
		incref(v);
	}
	mw_put_3();
	decref(var_tag);
}
static void mb_2785 (void) {
	mw_unpack3_1();
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_ctx_type_1();
		push_value(d2);
	}
	mp_prim_dup();
	{
		VAL d2 = pop_value();
		mw_body_1();
		push_value(d2);
	}
	mtw_HOME_5F_WORD_1();
	{
		VAL d2 = pop_value();
		{
			VAL d3 = pop_value();
			mw_unpack_1();
			mw_rotr_1();
			push_value(d3);
		}
		push_value(d2);
	}
	LPUSH(lbl_home);
	mp_prim_dup();
	LPUSH(lbl_token_start);
	LPUSH(lbl_token_end);
	mp_prim_dup();
	LPUSH(lbl_dom);
	LPUSH(lbl_cod);
	LPUSH(lbl_ctx);
	push_u64(0LL); // L0
	LPUSH(lbl_atoms);
	mtw_ARROW_1();
	LPUSH(lbl_arrow);
	mtw_MKAB_1();
	{
		VAL d2 = pop_value();
		mw_synth_specialized_word_21__1();
		push_value(d2);
	}
	mw_ab_unify_type_21__1();
	mw__2F_MKAB_1();
	LPOP(lbl_arrow);
}
static void mb_2879 (void) {
	mw_unpack2_1();
	mw_ctx_type_1();
	mw_specialize_ctx_type_1();
	mw_pack2_1();
}
