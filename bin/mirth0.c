/* C99 generated by Mirth compiler. */
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#define MIRTH_WINDOWS 1
#elif defined(__linux__)
#define MIRTH_LINUX 1
#elif defined(__APPLE__)
#define MIRTH_MACOS 1
#else
#error "Platform not supported."
#endif

#include <stdint.h>
#include <stdbool.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef uintptr_t usize;

extern void* mmap(void*, int, int, int, int, int);
extern void* malloc(usize);
extern void* calloc(usize, usize);
extern void* realloc(void*, usize);
extern void* memset(void*, int, usize);
extern void* memcpy(void*, const void*, usize);
extern void free(void*);
extern usize strlen(const char*);
extern int read(int, void*, usize);
extern int write(int, void*, usize);
extern int close(int);
extern int open(void*, int, int);
extern int strcmp(const char*, const char*);
extern void exit(int);

typedef enum value_tag_t {
   VT_U64 = 0x00,
   VT_U32 = 0x01,
   VT_U21 = 0x02,
   VT_U16 = 0x03,
   VT_C16 = 0x90,
   VT_C21 = 0x96,
   VT_C32 = 0xA0,
   VT_C64 = 0xC0,
} value_tag_t;

typedef void (*fnptr)(void);

typedef union value_payload_t {
    void* vp_ptr;
    u8 vp_u8;
    u16 vp_u16;
    u32 vp_u32;
    u64 vp_u64;
    i8 vp_i8;
    i16 vp_i16;
    i32 vp_i32;
    i64 vp_i64;
    bool vp_bool;
    fnptr vp_fnptr;
} value_payload_t;

typedef struct value_t {
   value_payload_t payload;
   value_tag_t tag; 
} value_t; 

typedef struct cell_t {
   u32 refs;
   bool freecdr;
   value_t car;
   value_t cdr;
} cell_t;

#define STACK_SIZE 0x1000
static usize stack_counter = STACK_SIZE;
static value_t stack [STACK_SIZE] = {0};

#define HEAP_SIZE 0x80000
#define HEAP_MASK 0x7FFFF
static usize heap_next = 1;
static usize heap_count = 0;
static cell_t heap [HEAP_SIZE] = {0};

static int global_argc;
static char** global_argv;

#define get_cell_index(v) ((usize)(((v).tag & 0x80) ? ((v).payload.vp_u64 >> (0xC0 - (u64)((v).tag))) : 0))

#define incref(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) heap[i].refs++; }while(0)

#define decref(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) { if(heap[i].refs) { heap[i].refs--; if (heap[i].refs == 0) heap_free(i); } }} while(0)

static void heap_free(usize i) {
    cell_t *cell = heap + i;
    cell_t contents = *cell;
    memset(cell, 0, sizeof(cell_t));
    cell->cdr.payload.vp_u64 = heap_next;
    heap_next = i;
    heap_count--;
    if (contents.freecdr) { free(contents.cdr.payload.vp_ptr); }
    else { decref(contents.cdr); }
    decref(contents.car);
}

#define decref_for_uncons(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) { if (heap[i].refs) { heap[i].refs--; if (heap[i].refs == 0) { memset(heap+i, 0, sizeof(cell_t)); heap[i].cdr.payload.vp_u64 = heap_next; heap_next = i; heap_count--; } else { cell_t cell = heap[i]; incref(cell.car); incref(cell.cdr); } } } } while(0)
static void value_uncons(value_t val, value_t* car, value_t* cdr) {
    switch (val.tag) {
        case VT_U64: {
            value_t nil = { 0 };
            *car = nil;
            *cdr = val;
        } break;
        case VT_U32: {
            u64 vv = val.payload.vp_u64;
            u64 lo = vv & 0xFFFFFFFF;
            u64 hi = vv >> 32;
            car->tag = VT_U64; car->payload.vp_u64 = hi;
            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;
        } break;
        case VT_C64: {
            cell_t* cell = heap + val.payload.vp_u64;
            *car = cell->car;
            *cdr = cell->cdr;
        } break;
        case VT_C32: {
            u64 vv = val.payload.vp_u64;
            u64 lo = vv & 0xFFFFFFFF;
            u64 hi = vv >> 32;
            car->tag = VT_C64; car->payload.vp_u64 = hi;
            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;
        } break;
        case VT_U21: {
            u64 vv = val.payload.vp_u64;
            u64 lo = vv & 0x1FFFFF;
            u64 md = (vv >> 21) & 0x1FFFFF;
            u64 hi = (vv >> 42) & 0x1FFFFF;
            car->tag = VT_U32;
            car->payload.vp_u64 = (hi << 32) | md;
            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;
        } break;
        case VT_C21: {
            u64 vv = val.payload.vp_u64;
            u64 lo = vv & 0x1FFFFF;
            u64 md = (vv >> 21) & 0x1FFFFF;
            u64 hi = (vv >> 42) & 0x1FFFFF;
            car->tag = VT_C32;
            car->payload.vp_u64 = (hi << 32) | md;
            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;
        } break;
        case VT_U16: {
            u64 vv = val.payload.vp_u64;
            u64 lo = vv & 0xFFFF;
            u64 y2 = (vv >> 16) & 0xFFFF;
            u64 y1 = (vv >> 32) & 0xFFFF;
            u64 y0 = (vv >> 48) & 0xFFFF;
            car->tag = VT_U21;
            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;
            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;
        } break;
        case VT_C16: {
            u64 vv = val.payload.vp_u64;
            u64 lo = vv & 0xFFFF;
            u64 y2 = (vv >> 16) & 0xFFFF;
            u64 y1 = (vv >> 32) & 0xFFFF;
            u64 y0 = (vv >> 48) & 0xFFFF;
            car->tag = VT_C21;
            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;
            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;
        } break;
    }
}

static bool value_has_ptr_offset (value_t v) {
    if (v.tag == VT_C64) {
        usize cell_index = (usize)v.payload.vp_u64;
        struct cell_t * cell = heap + cell_index;
        return !cell->freecdr;
    } else {
        return v.tag != VT_U64;
    }
}

static u64 value_ptr_size (value_t v) {
    if (v.payload.vp_u64 == 0) {
        return 0;
    } else if (v.tag == VT_U64) {
        return strlen(v.payload.vp_ptr);
    } else if (value_has_ptr_offset(v)) {
        value_t car, cdr;
        value_uncons(v, &car, &cdr);
        value_t car2, cdr2;
        value_uncons(car, &car2, &cdr2);
        u64 size = car2.payload.vp_u64;
        u64 offset = cdr.payload.vp_u64;
        if (size >= offset) {
            return offset - size;
        } else {
            return 0;
        }
    } else {
        value_t car, cdr;
        value_uncons(v, &car, &cdr);
        return car.payload.vp_u64;
    }
}

static void* value_ptr_base (value_t v) {
    if (value_has_ptr_offset(v)) {
        value_t car, cdr;
        value_uncons(v, &car, &cdr);
        value_t car2, cdr2;
        value_uncons(car, &car2, &cdr2);
        return cdr2.payload.vp_ptr;
    } else {
        value_t car, cdr;
        value_uncons(v, &car, &cdr);
        return cdr.payload.vp_ptr;
    }
}

static i64 value_ptr_offset (value_t v) {
    if (value_has_ptr_offset(v)) {
        value_t car, cdr;
        value_uncons(v, &car, &cdr);
        return cdr.payload.vp_i64;
    } else {
        return 0;
    }
}

static void* value_ptr (value_t v) {
    usize cell_index; cell_t* cell; usize offset;
    switch (v.tag) {
        case VT_U64: return v.payload.vp_ptr;
        case VT_C64: 
            cell_index = (usize)v.payload.vp_u64;
            cell = heap + cell_index;
            if (cell->freecdr) {
                return cell->cdr.payload.vp_ptr;
            } else {
                offset = (usize)cell->cdr.payload.vp_u64;
                cell_index = (usize)cell->car.payload.vp_u64;
                break;
            }
       case VT_C32: 
            offset = (usize)v.payload.vp_u32;
            cell_index = (usize)(v.payload.vp_u64 >> 32);
            break;
       default: 
            return (void*)0;
    }
    cell = heap + cell_index;
    if (cell->freecdr) {
        char* base = cell->cdr.payload.vp_ptr;
        return (void*)(base + offset);
    }
    return (void*)0;
}

#define pop_value() (stack[stack_counter++])
#define pop_fnptr() (pop_value().payload.vp_fnptr)
#define pop_u8() (pop_value().payload.vp_u8)
#define pop_u16() (pop_value().payload.vp_u16)
#define pop_u32() (pop_value().payload.vp_u32)
#define pop_u64() (pop_value().payload.vp_u64)
#define pop_i8() (pop_value().payload.vp_i8)
#define pop_i16() (pop_value().payload.vp_i16)
#define pop_i32() (pop_value().payload.vp_i32)
#define pop_i64() (pop_value().payload.vp_i64)
#define pop_bool() (pop_value().payload.vp_bool)
#define pop_rawptr() (pop_value().payload.vp_ptr)
#define push_value(v) stack[--stack_counter] = (v)
#define push_u64(v) do { stack[--stack_counter].tag = VT_U64; stack[stack_counter].payload.vp_u64 = (v); } while(0)
#define push_i64(v) do { stack[--stack_counter].tag = VT_U64; stack[stack_counter].payload.vp_i64 = (v); } while(0)
#define push_ptr(v) push_u64((u64)(v))
#define push_fnptr(v) push_u64((u64)(v))
#define push_bool(b) push_u64((u64)((bool)(b)))
#define push_u8(b) push_u64((u64)(b))
#define push_u16(b) push_u64((u64)(b))
#define push_u32(b) push_u64((u64)(b))
#define push_i8(b) push_i64((i64)(b))
#define push_i16(b) push_i64((i64)(b))
#define push_i32(b) push_i64((i64)(b))
#define push_rawptr(v) push_u64((u64)(void*)(v))
static value_t mkcell (value_t car, value_t cdr) {
    if ((car.payload.vp_u64 == 0) && (cdr.tag == VT_U64))
        return cdr;
    if (cdr.tag == VT_U64) {
        switch (car.tag) {
            case VT_U64: {
                u64 x0 = car.payload.vp_u64;
                u64 x1 = cdr.payload.vp_u64;
                u64 y0 = x0 & 0xFFFFFFFFLL;
                u64 y1 = x1 & 0xFFFFFFFFLL;
                if ((x0 == y0) && (x1 == y1)) {
                    value_t r;
                    r.tag = VT_U32;
                    r.payload.vp_u64 = (y0 << 32) | y1;
                    return r;
                }
            } break;
            case VT_C64: {
                u64 x0 = car.payload.vp_u64;
                u64 x1 = cdr.payload.vp_u64;
                u64 y0 = x0 & 0xFFFFFFFFLL;
                u64 y1 = x1 & 0xFFFFFFFFLL;
                if ((x0 == y0) && (x1 == y1)) {
                    value_t r;
                    r.tag = VT_C32;
                    r.payload.vp_u64 = (y0 << 32) | y1;
                    return r;
                }
            } break;
            case VT_U32: {
                u64 x0 = car.payload.vp_u64 >> 32;
                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;
                u64 x2 = cdr.payload.vp_u64;
                u64 y0 = x0 & 0x1FFFFFLL;
                u64 y1 = x1 & 0x1FFFFFLL;
                u64 y2 = x2 & 0x1FFFFFLL;
                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {
                    value_t r;
                    r.tag = VT_U21;
                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;
                    return r;
                }
            } break;
            case VT_C32: {
                u64 x0 = car.payload.vp_u64 >> 32;
                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;
                u64 x2 = cdr.payload.vp_u64;
                u64 y0 = x0 & 0x1FFFFFLL;
                u64 y1 = x1 & 0x1FFFFFLL;
                u64 y2 = x2 & 0x1FFFFFLL;
                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {
                    value_t r;
                    r.tag = VT_C21;
                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;
                    return r;
                }
            } break;
            case VT_U21: {
                u64 x0 = car.payload.vp_u64 >> 42;
                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;
                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;
                u64 x3 = cdr.payload.vp_u64;
                u64 y0 = x0 & 0xFFFFLL;
                u64 y1 = x1 & 0xFFFFLL;
                u64 y2 = x2 & 0xFFFFLL;
                u64 y3 = x3 & 0xFFFFLL;
                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {
                    value_t r;
                    r.tag = VT_U16;
                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;
                    return r;
                }
            } break;
            case VT_C21: {
                u64 x0 = car.payload.vp_u64 >> 42;
                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;
                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;
                u64 x3 = cdr.payload.vp_u64;
                u64 y0 = x0 & 0xFFFFLL;
                u64 y1 = x1 & 0xFFFFLL;
                u64 y2 = x2 & 0xFFFFLL;
                u64 y3 = x3 & 0xFFFFLL;
                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {
                    value_t r;
                    r.tag = VT_C16;
                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;
                    return r;
                }
            } break;
            default: break;
        }
    }
    if (heap_count >= HEAP_SIZE - 1) {
        write(2, "HEAP OVERFLOW\n", 14);
        exit(1);
    }
    u64 cell_index = heap_next;
    cell_t *cell = heap + cell_index;
    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }
    if (cell_index >= HEAP_SIZE - 1) {
        write(2, "HEAP OVERFLOW\n", 14);
        exit(1);
    }
    u64 saved_index = cell->cdr.payload.vp_u64;
    heap_next = (usize)(saved_index ? saved_index : cell_index+1);
    heap_count++;
    cell->refs = 1;
    cell->freecdr = false;
    cell->car = car;
    cell->cdr = cdr;
    value_t v = {0};
    v.tag = VT_C64;
    v.payload.vp_u64 = cell_index;
    return v;
}

static value_t mkcell_raw (value_t car, value_t cdr) {
    u64 cell_index = heap_next;
    cell_t *cell = heap + cell_index;
    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }
    if (cell_index >= HEAP_SIZE - 1) {
        write(2, "HEAP OVERFLOW\n", 14);
        exit(1);
    }
    u64 saved_index = cell->cdr.payload.vp_u64;
    heap_next = (usize)(saved_index ? saved_index : cell_index+1);
    heap_count++;
    cell->refs = 1;
    cell->freecdr = false;
    cell->car = car;
    cell->cdr = cdr;
    value_t v = {0};
    v.tag = VT_C64;
    v.payload.vp_u64 = cell_index;
    return v;
}

static value_t mkcell_freecdr (value_t car, value_t cdr) {
    if (heap_count >= HEAP_SIZE - 1) {
        write(2, "HEAP OVERFLOW\n", 14);
        exit(1);
    }
    u64 cell_index = heap_next;
    cell_t *cell = heap + cell_index;
    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }
    if (cell_index >= HEAP_SIZE - 1) {
        write(2, "HEAP OVERFLOW\n", 14);
        exit(1);
    }
    u64 saved_index = cell->cdr.payload.vp_u64;
    heap_next = (usize)(saved_index ? saved_index : cell_index+1);
    heap_count++;
    cell->refs = 1;
    cell->freecdr = true;
    cell->car = car;
    cell->cdr = cdr;
    value_t v = {0};
    v.tag = VT_C64;
    v.payload.vp_u64 = cell_index;
    return v;
}

static void do_pack_uncons(void) {
    value_t car, cdr, val;
    val = pop_value();
    value_uncons(val, &car, &cdr);
    push_value(car); push_value(cdr);
    if (val.tag == VT_C64) {
        decref_for_uncons(val);
    }
}

#define get_value_tag(v) (((v).tag == VT_U64) ? (v).payload.vp_i64 : (((v).tag == VT_C64) ? (heap[(v).payload.vp_u64].cdr.payload.vp_i64) : (i64)((v).payload.vp_u64 & 0xFFFF)))
#define get_top_data_tag() (get_value_tag(stack[stack_counter]))
#define value_cmp(v1,v2) ((((v1).tag == VT_U64) && ((v2).tag == VT_U64)) ? ((v1).payload.vp_i64 - (v2).payload.vp_i64) : value_cmp_hard((v1), (v2)))

static i64 value_cmp_hard(value_t v1, value_t v2) {
    while(1) {
        i64 t1 = get_value_tag(v1);
        i64 t2 = get_value_tag(v2);
        if (t1 < t2) return -1;
        if (t1 > t2) return 1;
        if ((v1.tag == VT_U64) && (v2.tag == VT_U64)) return 0;
        value_t v1car, v1cdr, v2car, v2cdr;
        value_uncons(v1, &v1car, &v1cdr);
        value_uncons(v2, &v2car, &v2cdr);
        i64 cdrcmp = value_cmp(v1cdr, v2cdr);
        if (cdrcmp != 0) return cdrcmp;
        v1 = v1car; v2 = v2car;
    }
}

#define value_eq(v1,v2) (((v1).tag == (v2).tag) && (((v1).payload.vp_u64 == (v2).payload.vp_u64) || (((v1).tag & 0x80) && value_eq_hard((v1),(v2)))))

static bool value_eq_hard(value_t v1, value_t v2) {
    usize c1_index, c2_index; cell_t *c1, *c2;
    while (1) {
        if (v1.tag != v2.tag) return false;
        if (v1.payload.vp_u64 == v2.payload.vp_u64) return true;
        switch (v1.tag) {
            case VT_U64: return false;
            case VT_U32: return false;
            case VT_U21: return false;
            case VT_U16: return false;
            case VT_C64:
               c1_index = (usize)v1.payload.vp_u64;
               c2_index = (usize)v2.payload.vp_u64;
               break;
            case VT_C32:
               if (v1.payload.vp_u32 != v2.payload.vp_u32) return false;
               c1_index = (usize)(v1.payload.vp_u64 >> 32);
               c2_index = (usize)(v2.payload.vp_u64 >> 32);
               break;
            case VT_C21:
               if (  (v1.payload.vp_u64 & 0x03FFFFFFFFFF)
                  != (v2.payload.vp_u64 & 0x03FFFFFFFFFF)) return false;
               c1_index = (usize)(v1.payload.vp_u64 >> 42);
               c2_index = (usize)(v2.payload.vp_u64 >> 42);
               break;
            case VT_C16:
               if (  (v1.payload.vp_u64 & 0xFFFFFFFFFFFF)
                  != (v2.payload.vp_u64 & 0xFFFFFFFFFFFF)) return false;
               c1_index = (usize)(v1.payload.vp_u64 >> 48);
               c2_index = (usize)(v2.payload.vp_u64 >> 48);
               break;
        }
        c1 = heap + c1_index;
        c2 = heap + c2_index;
        if (!value_eq(c1->cdr, c2->cdr)) return false;
        v1 = c1->car; v2 = c2->car;
    }
}

#define do_run() do { do_pack_uncons(); fnptr fp = pop_fnptr(); fp(); } while(0)
#define mwprim_2E_core_2E_id() 0
#define mwprim_2E_core_2E_dup() do{ value_t v = stack[stack_counter]; push_value(v); incref(v); } while(0)

#define do_drop() decref(pop_value())
#define mwprim_2E_core_2E_drop() do_drop()

#define do_swap() do{ value_t x = stack[stack_counter]; stack[stack_counter] = stack[stack_counter+1]; stack[stack_counter+1] = x; } while(0)
#define mwprim_2E_core_2E_swap() do_swap()

static void mwprim_2E_core_2E_dip (void) {
    value_t f = pop_value();
    value_t x = pop_value();
    push_value(f);
    do_run();
    push_value(x);
}

static void mwprim_2E_core_2E_if (void) {
    value_t then_branch = pop_value();
    value_t else_branch = pop_value();
    bool b = pop_bool();
    if (b) {
        push_value(then_branch);
        decref(else_branch);
    } else {
        push_value(else_branch);
        decref(then_branch);
    }
    do_run();
}

static void mwprim_2E_core_2E_while (void) {
    value_t cond = pop_value();
    value_t body = pop_value();
    while(1) {
        push_value(cond); incref(cond); do_run();
        bool b = pop_bool();
        if (!b) break;
        push_value(body); incref(body); do_run();
    }
    decref(cond); decref(body);
}

#define mwprim_2E_int_2E_add() do { stack[stack_counter+1].payload.vp_u64 += stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_sub() do { stack[stack_counter+1].payload.vp_u64 -= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_mul() do { stack[stack_counter+1].payload.vp_i64 *= stack[stack_counter].payload.vp_i64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_div() do { i64 a = stack[stack_counter+1].payload.vp_i64; i64 b = stack[stack_counter].payload.vp_i64; i64 r = a % b; i64 q = a / b; if (((a < 0) ^ (b < 0)) && r) q--; stack_counter++; stack[stack_counter].payload.vp_i64 = q; } while(0)
#define mwprim_2E_int_2E_mod() do { i64 a = stack[stack_counter+1].payload.vp_i64; i64 b = stack[stack_counter].payload.vp_i64; i64 r = a % b; if (((a < 0) ^ (b < 0)) && r) r += b; stack_counter++; stack[stack_counter].payload.vp_i64 = r; } while(0)
#define mwprim_2E_int_2E_and() do { stack[stack_counter+1].payload.vp_u64 &= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_or() do { stack[stack_counter+1].payload.vp_u64 |= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_xor() do { stack[stack_counter+1].payload.vp_u64 ^= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_shl() do { stack[stack_counter+1].payload.vp_u64 <<= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_int_2E_shr() do { stack[stack_counter+1].payload.vp_u64 >>= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_value_2E_eq()  do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_eq(v1, v2)); decref(v1); decref(v2); } while(0)

#define mwprim_2E_value_2E_lt()  do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_cmp(v1, v2) < 0); decref(v1); decref(v2); } while(0)

#define mwprim_2E_value_2E_le()  do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_cmp(v1, v2) <= 0); decref(v1); decref(v2); } while(0)

static void mwprim_2E_posix_2E_write (void) {
    usize n = (usize)pop_u64();
    value_t vp = pop_value();
    void* p = value_ptr(vp);
    int f = (int)pop_i64();
    push_i64((i64)write(f, p, n));
    decref(vp);
}

static void mwprim_2E_posix_2E_read (void) {
    usize n = (usize)pop_u64();
    value_t vp = pop_value();
    void* p = value_ptr(vp);
    int f = (int)pop_i64();
    push_i64((i64)read(f,p,n));
    decref(vp);
}

static void mwprim_2E_posix_2E_open (void) {
    int m = (int)pop_i64();
    int f = (int)pop_i64();
    value_t vp = pop_value();
    void* p = value_ptr(vp);
    push_i64((i64)open(p,f,m));
    decref(vp);
}

static void mwprim_2E_posix_2E_close (void) {
    int x = (int)pop_i64();
    push_i64((i64)close(x));
}

static void mwprim_2E_posix_2E_exit (void) {
    int x = (int)pop_i64();
    exit(x);
}

static void mwprim_2E_posix_2E_mmap (void) {
    #ifdef MIRTH_WINDOWS
    pop_value(); pop_value(); pop_value(); pop_value();
    usize b = (usize)pop_u64();
    pop_value();
    push_ptr(malloc(b));
    #else
    int f = (int)pop_i64();
    int e = (int)pop_i64();
    int d = (int)pop_i64();
    int c = (int)pop_i64();
    usize b = (usize)pop_u64();
    value_t va = pop_value();
    void* a = value_ptr(va);
    void* p = mmap(a,b,c,d,e,f);
    push_ptr(p);
    decref(va);
    #endif
}

static void do_debug(void) {
    write(2, "??", 2);
    char c[32] = {0};
    char* cp;
    usize n;
    i64 x; i64 y;
    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {
        cp = c+30;
        x = stack[i].payload.vp_i64;
        n = 1;
        y = x; if (x < 0) { x = -x; }
        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);
        if (y < 0) { *cp-- = '-'; n++; } 
        *cp = ' ';
        write(2, cp, n);
    }
    write(2, "\n", 1);
}

#define mwprim_2E_core_2E_debug() do_debug()

#define mwprim_2E_value_2E_get() do { value_t vp = pop_value(); value_t* p = value_ptr(vp); push_value(*p); incref(*p); decref(vp); } while(0)
#define mwprim_2E_int_2E_get() do { value_t vp = pop_value(); i64* p = value_ptr(vp); push_i64(*p); decref(vp); } while(0)
#define mwprim_2E_ptr_2E_get() do { value_t vp = pop_value(); void** p = value_ptr(vp); push_ptr(*p); decref(vp); } while(0)
#define mwprim_2E_u8_2E_get() do { value_t vp = pop_value(); u8* p = value_ptr(vp); push_u8(*p); decref(vp); } while(0)
#define mwprim_2E_u16_2E_get() do { value_t vp = pop_value(); u16* p = value_ptr(vp); push_u16(*p); decref(vp); } while(0)
#define mwprim_2E_u32_2E_get() do { value_t vp = pop_value(); u32* p = value_ptr(vp); push_u32(*p); decref(vp); } while(0)
#define mwprim_2E_u64_2E_get() do { value_t vp = pop_value(); u64* p = value_ptr(vp); push_u64(*p); decref(vp); } while(0)
#define mwprim_2E_i8_2E_get() do { value_t vp = pop_value(); i8* p = value_ptr(vp); push_i8(*p); decref(vp); } while(0)
#define mwprim_2E_i16_2E_get() do { value_t vp = pop_value(); i16* p = value_ptr(vp); push_i16(*p); decref(vp); } while(0)
#define mwprim_2E_i32_2E_get() do { value_t vp = pop_value(); i32* p = value_ptr(vp); push_i32(*p); decref(vp); } while(0)
#define mwprim_2E_i64_2E_get() do { value_t vp = pop_value(); i64* p = value_ptr(vp); push_i64(*p); decref(vp); } while(0)
#define mwprim_2E_int_2E_set() do { value_t vp = pop_value(); i64* p = value_ptr(vp); *p = pop_i64(); decref(vp); } while(0)
#define mwprim_2E_u8_2E_set() do { value_t vp = pop_value(); u8* p = value_ptr(vp); *p = pop_u8(); decref(vp); } while(0)
#define mwprim_2E_u16_2E_set() do { value_t vp = pop_value(); u16* p = value_ptr(vp); *p = pop_u16(); decref(vp); } while(0)
#define mwprim_2E_u32_2E_set() do { value_t vp = pop_value(); u32* p = value_ptr(vp); *p = pop_u32(); decref(vp); } while(0)
#define mwprim_2E_u64_2E_set() do { value_t vp = pop_value(); u64* p = value_ptr(vp); *p = pop_u64(); decref(vp); } while(0)
#define mwprim_2E_i8_2E_set() do { value_t vp = pop_value(); i8* p = value_ptr(vp); *p = pop_i8(); decref(vp); } while(0)
#define mwprim_2E_i16_2E_set() do { value_t vp = pop_value(); i16* p = value_ptr(vp); *p = pop_i16(); decref(vp); } while(0)
#define mwprim_2E_i32_2E_set() do { value_t vp = pop_value(); i32* p = value_ptr(vp); *p = pop_i32(); decref(vp); } while(0)
#define mwprim_2E_i64_2E_set() do { value_t vp = pop_value(); i64* p = value_ptr(vp); *p = pop_i64(); decref(vp); } while(0)
#define mwprim_2E_ptr_2E_set() do { value_t vp = pop_value(); value_t vx = pop_value(); void** p = value_ptr(vp); *p = value_ptr(vx); decref(vp); decref(vx); } while(0)
#define mwprim_2E_value_2E_set() do { value_t vp = pop_value(); value_t vx = pop_value(); value_t* p = value_ptr(vp); value_t old = *p; *p = vx; decref(old); decref(vp); } while(0)
#if defined(MIRTH_WINDOWS)
#define mwprim_2E_sys_2E_os() push_u64(1)
#elif defined(MIRTH_LINUX)
#define mwprim_2E_sys_2E_os() push_u64(2)
#elif defined(MIRTH_MACOS)
#define mwprim_2E_sys_2E_os() push_u64(3)
#else
#define mwprim_2E_sys_2E_os() push_u64(0)
#endif

#define mwprim_2E_unsafe_2E_cast() 0

#define mwprim_2E_core_2E_run() do_run()

static void mwprim_2E_ptr_2E_add (void) {
    value_t vp = pop_value();
    i64 y = pop_i64();
    if (vp.tag == VT_U64) {
        push_i64(y + vp.payload.vp_i64);
    } else if (value_has_ptr_offset(vp)) {
        value_t car, cdr;
        value_uncons(vp, &car, &cdr);
        cdr.payload.vp_i64 += y;
        push_value(mkcell(car, cdr));
    } else {
        value_t vy = { .tag = VT_U64, .payload = { .vp_i64 = y } };
        push_value(mkcell(vp, vy));
    }
}
#define mwprim_2E_bool_2E_true() push_bool(true)
#define mwprim_2E_bool_2E_false() push_bool(false)
#define mwprim_2E_bool_2E_and() do { stack[stack_counter+1].payload.vp_u64 = stack[stack_counter+1].payload.vp_u64 && stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_bool_2E_or() do { stack[stack_counter+1].payload.vp_u64 = stack[stack_counter+1].payload.vp_u64 || stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)
#define mwprim_2E_sys_2E_argc() push_i64(global_argc)
#define mwprim_2E_sys_2E_argv() push_ptr(global_argv)
#define mwprim_2E_ptr_2E_size() push_u64((u64)sizeof(void*))
static void mwprim_2E_ptr_2E_alloc (void) {
    i64 psize = pop_i64();
    if (psize > 0) {
        usize size = (usize)psize;
        void* ptr = calloc(1,size);
        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };
        value_t vptr = { .tag = VT_U64, .payload = { .vp_ptr = ptr } };
        value_t v = mkcell_freecdr(vsize, vptr);
        push_value(v);
    } else {
        push_u64(0);
    }
}

static void* alloc_but_copy (usize dstn, void* src, usize srcn) {
    void* dst = calloc(1,dstn);
    if (src) {
        usize cpyn = (dstn > srcn) ? srcn : dstn;
        memcpy(dst, src, cpyn);
    }
    return dst;
}
static void mwprim_2E_ptr_2E_realloc (void) {
    i64 psize = pop_i64();
    value_t vptr = pop_value();
    if (psize <= 0) { 
        decref(vptr);
        push_u64(0);
        return;
    }
    usize new_size = (usize)psize;
    if ((vptr.tag == VT_C64) && !value_has_ptr_offset(vptr)) {
       usize cell_index = get_cell_index(vptr);
       cell_t *cell = heap + cell_index;
       usize old_size = (usize)cell->car.payload.vp_u64;
       void* old_ptr = cell->cdr.payload.vp_ptr;
       void* new_ptr = realloc(old_ptr, new_size);
       cell->car.payload.vp_i64 = psize;
       cell->cdr.payload.vp_ptr = new_ptr;
       if (old_size < new_size) {
           memset((char*)new_ptr + old_size, 0, new_size - old_size);
       }
       push_value(vptr);
    } else {
        void* old_ptr = value_ptr(vptr);
        usize old_size = (usize)value_ptr_size(vptr);
        void* new_ptr = alloc_but_copy(new_size, old_ptr, old_size);
        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };
        value_t vnew = { .tag = VT_U64, .payload = { .vp_ptr = new_ptr } };
        value_t v = mkcell_freecdr(vsize, vnew);
        push_value(v);
        decref(vptr);
    }
}

static void mwprim_2E_ptr_2E_copy (void) {
    value_t vdst = pop_value();
    i64 ilen = pop_i64();
    value_t vsrc = pop_value();
    void* src = value_ptr(vsrc);
    void* dst = value_ptr(vdst);
    if (src && dst && (ilen > 0)) {
        memcpy(dst, src, (usize)ilen);
    }
    decref(vsrc);
    decref(vdst);
}

static void mwprim_2E_ptr_2E_fill (void) {
    value_t vdst = pop_value();
    i64 ilen = pop_i64();
    i64 val = pop_i64();
    void* dst = value_ptr(vdst);
    if (dst && (ilen > 0)) {
        memset(dst, (int)val, (usize)ilen);
    }
    decref(vdst);
}

#define mwprim_2E_ptr_2E_raw() do { usize i = stack_counter; push_ptr(value_ptr(stack[i])); } while(0)
static void mwprim_2E_str_2E_eq (void){
    value_t vptr1 = pop_value();
    value_t vptr2 = pop_value();
    const char* ptr1 = value_ptr(vptr1);
    const char* ptr2 = value_ptr(vptr2);
    bool result = (!ptr1 || !ptr2) ? (ptr1 == ptr2) : strcmp(ptr1,ptr2) == 0;
    push_bool(result);
    decref(vptr1); decref(vptr2);
}

static void mwprim_2E_str_2E_alloc (void){
    i64 psize = pop_i64();
    push_i64(psize + 4);
    mwprim_2E_ptr_2E_alloc();
}

#define mwprim_2E_str_2E_base() 0

#define mwprim_2E_str_2E_size() do { value_t v = stack[stack_counter]; if (!v.payload.vp_u64) { push_u64(0); } else if (v.tag == VT_U64) { push_u64((u64)strlen(v.payload.vp_ptr)); } else { push_i64(value_ptr_size(v)-4); }  } while(0)

#define do_pack_cons() do { value_t cdr = pop_value(); value_t car = pop_value(); push_value(mkcell(car,cdr)); } while(0)
#define mwprim_2E_pack_2E_nil()  push_u64(0)
#define mwprim_2E_pack_2E_cons() do_pack_cons();
#define mwprim_2E_pack_2E_uncons() do_pack_uncons();

#define mwprim_2E_mut_2E_new() do { value_t car = pop_value(); value_t cdr = { 0 }; push_value(mkcell_raw(car,cdr)); } while(0)
#define mwprim_2E_mut_2E_get() do { do_pack_uncons(); pop_value(); } while(0)
#define mwprim_2E_mut_2E_set() do { value_t cellval = pop_value(); value_t newval = pop_value(); push_value(cellval); usize cellidx = get_cell_index(cellval); if (cellidx) { cell_t* cell = heap + cellidx; value_t oldval = cell->car; cell->car = newval; decref(oldval); } else { decref(newval); } } while(0)

#define mwRAWPTR() 0
#define mwOS_UNKNOWN() push_u64(0)
#define mwOS_WINDOWS() push_u64(1)
#define mwOS_LINUX() push_u64(2)
#define mwOS_MACOS() push_u64(3)
#define mwEQ() push_u64(0)
#define mwLT() push_u64(1)
#define mwGT() push_u64(2)
#define mwNONE() push_u64(0)
static void mwSOME (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwL0() push_u64(0)
static void mwL1 (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwL2 (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwL3 (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwLCAT (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 4LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwL1_2B_ (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwL2_2B_ (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwL3_2B_ (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwLCAT_2B_ (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwTS_STOP() push_u64(0)
#define mwTS_SKIP() push_u64(1)
static void mwTS_CHAR (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTS_PUSH (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTS_COPY (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 4LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwPATH() 0
#define mwFILE() 0
#define mwDEF_NONE() push_u64(0)
static void mwDEF_MODULE (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_TYPE (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_TAG (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_PRIM (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 4LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_WORD (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 5LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_BUFFER (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 6LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_EXTERNAL (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 7LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwDEF_FIELDWORD (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 8LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwHASH() 0
#define mwSET() 0
#define mwROW() 0
#define mwCOL() 0
static void mwLOCATION (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwTOKEN_NONE() push_u64(0)
#define mwTOKEN_COMMA() push_u64(1)
static void mwTOKEN_LPAREN (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_RPAREN (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_LSQUARE (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 4LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_RSQUARE (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 5LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_LCURLY (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 6LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_RCURLY (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 7LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_INT (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 8LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_STR (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 9LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTOKEN_NAME (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 10LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwBAG() 0
#define mwBAG_2B_() 0
#define mwMAP() 0
#define mwTYPE_ERROR() push_u64(0)
#define mwTYPE_DONT_CARE() push_u64(1)
static void mwTPrim (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTMeta (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTHole (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 4LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTVar (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 5LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTTable (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 6LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTData (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 7LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTTensor (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 8LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTMorphism (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 9LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTApp (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 10LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwTValue (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 11LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwVALUE_INT (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwVALUE_STR (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwVALUE_BLOCK (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwPRIM_TYPE_UNIT() push_u64(0)
#define mwPRIM_TYPE_TYPE() push_u64(1)
#define mwPRIM_TYPE_STACK() push_u64(2)
#define mwPRIM_TYPE_EFFECT() push_u64(3)
#define mwPRIM_TYPE_INT() push_u64(4)
#define mwPRIM_TYPE_PTR() push_u64(5)
#define mwPRIM_TYPE_STR() push_u64(6)
#define mwPRIM_TYPE_CHAR() push_u64(7)
#define mwPRIM_TYPE_BOOL() push_u64(8)
#define mwPRIM_TYPE_U64() push_u64(9)
#define mwPRIM_TYPE_U32() push_u64(10)
#define mwPRIM_TYPE_U16() push_u64(11)
#define mwPRIM_TYPE_U8() push_u64(12)
#define mwPRIM_TYPE_I64() push_u64(13)
#define mwPRIM_TYPE_I32() push_u64(14)
#define mwPRIM_TYPE_I16() push_u64(15)
#define mwPRIM_TYPE_I8() push_u64(16)
#define mwPRIM_TYPE_MUT() push_u64(17)
#define mwGAMMA() 0
#define mwSUBST() 0
static void mwARG_BLOCK (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwARG_VAR_RUN (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwOP_NONE() push_u64(0)
static void mwOP_PRIM (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_WORD (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_FIELDWORD (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 3LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_EXTERNAL (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 4LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_BUFFER (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 5LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_INT (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 6LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_STR (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 7LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_TAG (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 8LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_MATCH (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 9LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_LAMBDA (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 10LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_VAR (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 11LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOP_BLOCK (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 12LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwPARAM() 0
#define mwPATTERN_UNDERSCORE() push_u64(0)
static void mwPATTERN_TAG (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwLP_READY (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwLP_THUNK (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwLP_WAIT() push_u64(2)
#define mwLAZY() 0
static void mwFIELDWORD (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwFIELD_40_() push_u64(0)
#define mwFIELD_3F_() push_u64(1)
#define mwFIELD_21_() push_u64(2)
static void mwNEED_BLOCK (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwNEED_WORD (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwNEED_FIELD (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwCTX() 0
#define mwALLOW_HOLES() push_u64(0)
#define mwFORBID_HOLES() push_u64(1)
static void mwTYPE_ELAB (void) {
    value_t car = pop_value();
    car = mkcell(car, pop_value());
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 0LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwOPSIG_ID() push_u64(0)
static void mwOPSIG_PUSH (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 1LL } };
    car = mkcell(car, tag);
    push_value(car);
}
static void mwOPSIG_APPLY (void) {
    value_t car = pop_value();
    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = 2LL } };
    car = mkcell(car, tag);
    push_value(car);
}
#define mwPRIM_CORE_ID() push_u64(0)
#define mwPRIM_CORE_DUP() push_u64(1)
#define mwPRIM_CORE_DROP() push_u64(2)
#define mwPRIM_CORE_SWAP() push_u64(3)
#define mwPRIM_CORE_DIP() push_u64(4)
#define mwPRIM_CORE_IF() push_u64(5)
#define mwPRIM_CORE_WHILE() push_u64(6)
#define mwPRIM_CORE_DEBUG() push_u64(7)
#define mwPRIM_CORE_RUN() push_u64(8)
#define mwPRIM_CORE_MATCH() push_u64(9)
#define mwPRIM_CORE_LAMBDA() push_u64(10)
#define mwPRIM_UNSAFE_CAST() push_u64(11)
#define mwPRIM_VALUE_EQ() push_u64(12)
#define mwPRIM_VALUE_LT() push_u64(13)
#define mwPRIM_VALUE_LE() push_u64(14)
#define mwPRIM_VALUE_GET() push_u64(15)
#define mwPRIM_VALUE_SET() push_u64(16)
#define mwPRIM_INT_ADD() push_u64(17)
#define mwPRIM_INT_SUB() push_u64(18)
#define mwPRIM_INT_MUL() push_u64(19)
#define mwPRIM_INT_DIV() push_u64(20)
#define mwPRIM_INT_MOD() push_u64(21)
#define mwPRIM_INT_AND() push_u64(22)
#define mwPRIM_INT_OR() push_u64(23)
#define mwPRIM_INT_XOR() push_u64(24)
#define mwPRIM_INT_SHL() push_u64(25)
#define mwPRIM_INT_SHR() push_u64(26)
#define mwPRIM_INT_GET() push_u64(27)
#define mwPRIM_INT_SET() push_u64(28)
#define mwPRIM_BOOL_TRUE() push_u64(29)
#define mwPRIM_BOOL_FALSE() push_u64(30)
#define mwPRIM_BOOL_AND() push_u64(31)
#define mwPRIM_BOOL_OR() push_u64(32)
#define mwPRIM_PACK_NIL() push_u64(33)
#define mwPRIM_PACK_CONS() push_u64(34)
#define mwPRIM_PACK_UNCONS() push_u64(35)
#define mwPRIM_MUT_NEW() push_u64(36)
#define mwPRIM_MUT_GET() push_u64(37)
#define mwPRIM_MUT_SET() push_u64(38)
#define mwPRIM_PTR_ADD() push_u64(39)
#define mwPRIM_PTR_SIZE() push_u64(40)
#define mwPRIM_PTR_GET() push_u64(41)
#define mwPRIM_PTR_SET() push_u64(42)
#define mwPRIM_PTR_ALLOC() push_u64(43)
#define mwPRIM_PTR_REALLOC() push_u64(44)
#define mwPRIM_PTR_COPY() push_u64(45)
#define mwPRIM_PTR_FILL() push_u64(46)
#define mwPRIM_PTR_RAW() push_u64(47)
#define mwPRIM_STR_ALLOC() push_u64(48)
#define mwPRIM_STR_SIZE() push_u64(49)
#define mwPRIM_STR_BASE() push_u64(50)
#define mwPRIM_STR_EQ() push_u64(51)
#define mwPRIM_U8_GET() push_u64(52)
#define mwPRIM_U8_SET() push_u64(53)
#define mwPRIM_U16_GET() push_u64(54)
#define mwPRIM_U16_SET() push_u64(55)
#define mwPRIM_U32_GET() push_u64(56)
#define mwPRIM_U32_SET() push_u64(57)
#define mwPRIM_U64_GET() push_u64(58)
#define mwPRIM_U64_SET() push_u64(59)
#define mwPRIM_I8_GET() push_u64(60)
#define mwPRIM_I8_SET() push_u64(61)
#define mwPRIM_I16_GET() push_u64(62)
#define mwPRIM_I16_SET() push_u64(63)
#define mwPRIM_I32_GET() push_u64(64)
#define mwPRIM_I32_SET() push_u64(65)
#define mwPRIM_I64_GET() push_u64(66)
#define mwPRIM_I64_SET() push_u64(67)
#define mwPRIM_SYS_OS() push_u64(68)
#define mwPRIM_SYS_ARGC() push_u64(69)
#define mwPRIM_SYS_ARGV() push_u64(70)
#define mwPRIM_POSIX_READ() push_u64(71)
#define mwPRIM_POSIX_WRITE() push_u64(72)
#define mwPRIM_POSIX_OPEN() push_u64(73)
#define mwPRIM_POSIX_CLOSE() push_u64(74)
#define mwPRIM_POSIX_EXIT() push_u64(75)
#define mwPRIM_POSIX_MMAP() push_u64(76)
#define mwPRIM_SYNTAX_MODULE() push_u64(77)
#define mwPRIM_SYNTAX_IMPORT() push_u64(78)
#define mwPRIM_SYNTAX_DEF() push_u64(79)
#define mwPRIM_SYNTAX_DEF_TYPE() push_u64(80)
#define mwPRIM_SYNTAX_BUFFER() push_u64(81)
#define mwPRIM_SYNTAX_DEF_EXTERNAL() push_u64(82)
#define mwPRIM_SYNTAX_TARGET_C99() push_u64(83)
#define mwPRIM_SYNTAX_TABLE() push_u64(84)
#define mwPRIM_SYNTAX_FIELD() push_u64(85)
#define mwPRIM_SYNTAX_DATA() push_u64(86)
#define mwPRIM_SYNTAX_DASHES() push_u64(87)
#define mwPRIM_SYNTAX_ARROW() push_u64(88)

static u8 bSTR_BUF[8192] = {0};
#define mwSTR_BUF() push_ptr((void*)bSTR_BUF)
static u8 bSTR_BUF_LEN[8] = {0};
#define mwSTR_BUF_LEN() push_ptr((void*)bSTR_BUF_LEN)
static u8 bSOURCE_PATH_ROOT[8] = {0};
#define mwSOURCE_PATH_ROOT() push_ptr((void*)bSOURCE_PATH_ROOT)
static u8 bOUTPUT_PATH_ROOT[8] = {0};
#define mwOUTPUT_PATH_ROOT() push_ptr((void*)bOUTPUT_PATH_ROOT)
static u8 bINPUT_ISOPEN[8] = {0};
#define mwINPUT_ISOPEN() push_ptr((void*)bINPUT_ISOPEN)
static u8 bINPUT_LENGTH[8] = {0};
#define mwINPUT_LENGTH() push_ptr((void*)bINPUT_LENGTH)
static u8 bINPUT_OFFSET[8] = {0};
#define mwINPUT_OFFSET() push_ptr((void*)bINPUT_OFFSET)
static u8 bINPUT_HANDLE[8] = {0};
#define mwINPUT_HANDLE() push_ptr((void*)bINPUT_HANDLE)
static u8 bINPUT_BUFFER[8208] = {0};
#define mwINPUT_BUFFER() push_ptr((void*)bINPUT_BUFFER)
static u8 bName_2E_NUM[8] = {0};
#define mwName_2E_NUM() push_ptr((void*)bName_2E_NUM)
static u8 bNAME_HASH_TABLE[524288] = {0};
#define mwNAME_HASH_TABLE() push_ptr((void*)bNAME_HASH_TABLE)
static u8 bModule_2E_NUM[8] = {0};
#define mwModule_2E_NUM() push_ptr((void*)bModule_2E_NUM)
static u8 bToken_2E_NUM[8] = {0};
#define mwToken_2E_NUM() push_ptr((void*)bToken_2E_NUM)
static u8 bNUM_WARNINGS[8] = {0};
#define mwNUM_WARNINGS() push_ptr((void*)bNUM_WARNINGS)
static u8 bNUM_ERRORS[8] = {0};
#define mwNUM_ERRORS() push_ptr((void*)bNUM_ERRORS)
static u8 bLEXER_MODULE[16] = {0};
#define mwLEXER_MODULE() push_ptr((void*)bLEXER_MODULE)
static u8 bLEXER_ROW[16] = {0};
#define mwLEXER_ROW() push_ptr((void*)bLEXER_ROW)
static u8 bLEXER_COL[16] = {0};
#define mwLEXER_COL() push_ptr((void*)bLEXER_COL)
static u8 bLEXER_STACK_LENGTH[16] = {0};
#define mwLEXER_STACK_LENGTH() push_ptr((void*)bLEXER_STACK_LENGTH)
static u8 bLEXER_STACK_BUF[8192] = {0};
#define mwLEXER_STACK_BUF() push_ptr((void*)bLEXER_STACK_BUF)
static u8 bBuffer_2E_NUM[8] = {0};
#define mwBuffer_2E_NUM() push_ptr((void*)bBuffer_2E_NUM)
static u8 bMetaVar_2E_NUM[8] = {0};
#define mwMetaVar_2E_NUM() push_ptr((void*)bMetaVar_2E_NUM)
static u8 bData_2E_NUM[8] = {0};
#define mwData_2E_NUM() push_ptr((void*)bData_2E_NUM)
static u8 bTag_2E_NUM[8] = {0};
#define mwTag_2E_NUM() push_ptr((void*)bTag_2E_NUM)
static u8 bAtom_2E_NUM[8] = {0};
#define mwAtom_2E_NUM() push_ptr((void*)bAtom_2E_NUM)
static u8 bArrow_2E_NUM[8] = {0};
#define mwArrow_2E_NUM() push_ptr((void*)bArrow_2E_NUM)
static u8 bLambda_2E_NUM[8] = {0};
#define mwLambda_2E_NUM() push_ptr((void*)bLambda_2E_NUM)
static u8 bBlock_2E_NUM[8] = {0};
#define mwBlock_2E_NUM() push_ptr((void*)bBlock_2E_NUM)
static u8 bMatch_2E_NUM[8] = {0};
#define mwMatch_2E_NUM() push_ptr((void*)bMatch_2E_NUM)
static u8 bCase_2E_NUM[8] = {0};
#define mwCase_2E_NUM() push_ptr((void*)bCase_2E_NUM)
static u8 bVar_2E_NUM[8] = {0};
#define mwVar_2E_NUM() push_ptr((void*)bVar_2E_NUM)
static u8 bWord_2E_NUM[8] = {0};
#define mwWord_2E_NUM() push_ptr((void*)bWord_2E_NUM)
static u8 bTable_2E_NUM[8] = {0};
#define mwTable_2E_NUM() push_ptr((void*)bTable_2E_NUM)
static u8 bField_2E_NUM[8] = {0};
#define mwField_2E_NUM() push_ptr((void*)bField_2E_NUM)
static u8 bCODEGEN_FILE[8] = {0};
#define mwCODEGEN_FILE() push_ptr((void*)bCODEGEN_FILE)
static u8 bCODEGEN_LENGTH[8] = {0};
#define mwCODEGEN_LENGTH() push_ptr((void*)bCODEGEN_LENGTH)
static u8 bCODEGEN_BUF[256] = {0};
#define mwCODEGEN_BUF() push_ptr((void*)bCODEGEN_BUF)
static u8 bC99_DEPTH[8] = {0};
#define mwC99_DEPTH() push_ptr((void*)bC99_DEPTH)
static u8 bC99_NEED_STACK[16] = {0};
#define mwC99_NEED_STACK() push_ptr((void*)bC99_NEED_STACK)
static u8 bExternal_2E_NUM[8] = {0};
#define mwExternal_2E_NUM() push_ptr((void*)bExternal_2E_NUM)
static u8 bAB_HOME[16] = {0};
#define mwAB_HOME() push_ptr((void*)bAB_HOME)
static u8 bAB_HOMEIDX[8] = {0};
#define mwAB_HOMEIDX() push_ptr((void*)bAB_HOMEIDX)
static u8 bAB_ARROW[16] = {0};
#define mwAB_ARROW() push_ptr((void*)bAB_ARROW)

i64 stat (i64, i64);
static void mwstat (void) {
    i64 x2 = pop_i64();
    i64 x1 = pop_i64();
    push_i64(stat(x1, x2));
}

 static void mwid (void);
 static void mwdup (void);
 static void mwdrop (void);
 static void mwswap (void);
 static void mw_3F__3F_ (void);
 static void mwrun (void);
 static void mw_3D__3D_ (void);
 static void mw_3C__3D_ (void);
 static void mw_3C_ (void);
 static void mwvalue_40_ (void);
 static void mwvalue_21_ (void);
 static void mw_2B_ (void);
 static void mw_ (void);
 static void mw_2A_ (void);
 static void mw_2F_ (void);
 static void mw_25_ (void);
 static void mw_26_ (void);
 static void mw_7C_ (void);
 static void mw_5E_ (void);
 static void mw_3C__3C_ (void);
 static void mw_3E__3E_ (void);
 static void mwint_40_ (void);
 static void mwint_21_ (void);
 static void mwtrue (void);
 static void mwfalse (void);
 static void mw_26__26_ (void);
 static void mw_7C__7C_ (void);
 static void mwptr_2B_ (void);
 static void mw_7C_ptr_7C_ (void);
 static void mwptr_40_ (void);
 static void mwptr_21_ (void);
 static void mwwith_raw_ptr (void);
 static void mwu8_40_ (void);
 static void mwu8_21_ (void);
 static void mwu16_40_ (void);
 static void mwu16_21_ (void);
 static void mwu32_40_ (void);
 static void mwu32_21_ (void);
 static void mwu64_40_ (void);
 static void mwu64_21_ (void);
 static void mwi8_40_ (void);
 static void mwi8_21_ (void);
 static void mwi16_40_ (void);
 static void mwi16_21_ (void);
 static void mwi32_40_ (void);
 static void mwi32_21_ (void);
 static void mwi64_40_ (void);
 static void mwi64_21_ (void);
 static void mwOS__3E_Int (void);
 static void mwInt__3E_OS (void);
 static void mwRUNNING_OS (void);
 static void mwargc (void);
 static void mwargv (void);
 static void mwposix_read_21_ (void);
 static void mwposix_write_21_ (void);
 static void mwposix_open_21_ (void);
 static void mwposix_close_21_ (void);
 static void mwposix_exit_21_ (void);
 static void mwposix_mmap_21_ (void);
 static void mwrotr (void);
 static void mwrotl (void);
 static void mwover (void);
 static void mwover2 (void);
 static void mwover3 (void);
 static void mwtuck (void);
 static void mwnip (void);
 static void mwdup2 (void);
 static void mwdup3 (void);
 static void mwdip_3F_ (void);
 static void mwdip_27_ (void);
 static void mwdip2 (void);
 static void mwdip3 (void);
 static void mwdrop2 (void);
 static void mwdrop3 (void);
 static void mwdrop4 (void);
 static void mwrot4r (void);
 static void mwrot4l (void);
 static void mwor (void);
 static void mwand (void);
 static void mwStr__3E_Ptr (void);
 static void mwPtr__3E_Str (void);
 static void mwU8_MAX (void);
 static void mwU16_MAX (void);
 static void mwU32_MAX (void);
 static void mwI8_MAX (void);
 static void mwI16_MAX (void);
 static void mwI32_MAX (void);
 static void mwU8_MIN (void);
 static void mwU16_MIN (void);
 static void mwU32_MIN (void);
 static void mwI8_MIN (void);
 static void mwI16_MIN (void);
 static void mwI32_MIN (void);
 static void mwnot (void);
 static void mwcmp (void);
 static void mwcmp_3F_ (void);
 static void mw_3C__3E_ (void);
 static void mw_3E_ (void);
 static void mw_3E__3D_ (void);
 static void mw0_3D_ (void);
 static void mw0_3C_ (void);
 static void mw0_3E_ (void);
 static void mw0_3C__3E_ (void);
 static void mw1_2B_ (void);
 static void mw1_ (void);
 static void mwmax (void);
 static void mwmin (void);
 static void mwptrs (void);
 static void mwptr_40__40_ (void);
 static void mwptr_21__21_ (void);
 static void mwu8_40__40_ (void);
 static void mwu8_21__21_ (void);
 static void mwints (void);
 static void mwint_40__40_ (void);
 static void mwint_21__21_ (void);
 static void mwvalues (void);
 static void mwvalue_40__40_ (void);
 static void mwvalue_21__21_ (void);
 static void mwin_range (void);
 static void mwInt__3E_U8 (void);
 static void mwInt__3E_U16 (void);
 static void mwInt__3E_U32 (void);
 static void mwInt__3E_U64 (void);
 static void mwInt__3E_I8 (void);
 static void mwInt__3E_I16 (void);
 static void mwInt__3E_I32 (void);
 static void mwInt__3E_I64 (void);
 static void mwU8__3E_Int (void);
 static void mwU16__3E_Int (void);
 static void mwU32__3E_Int (void);
 static void mwU64__3E_Int (void);
 static void mwI8__3E_Int (void);
 static void mwI16__3E_Int (void);
 static void mwI32__3E_Int (void);
 static void mwI64__3E_Int (void);
 static void mwInt__3E_Char (void);
 static void mwChar__3E_Int (void);
 static void mwnegate (void);
 static void mwabs (void);
 static void mwnil (void);
 static void mwis_nil (void);
 static void mwis_nil_3F_ (void);
 static void mwpack_nil (void);
 static void mwpack_nil_3F_ (void);
 static void mwpack_cons (void);
 static void mwpack_uncons (void);
 static void mwpack0 (void);
 static void mwpack1 (void);
 static void mwpack2 (void);
 static void mwpack3 (void);
 static void mwpack4 (void);
 static void mwpack5 (void);
 static void mwunpack0 (void);
 static void mwunpack1 (void);
 static void mwunpack2 (void);
 static void mwunpack3 (void);
 static void mwunpack4 (void);
 static void mwunpack5 (void);
 static void mw_2E_0 (void);
 static void mw_2E_1 (void);
 static void mw_2E_2 (void);
 static void mw_2E_3 (void);
 static void mw_2E_4 (void);
 static void mw_2E_5 (void);
 static void mwis_none (void);
 static void mwis_some (void);
 static void mwis_none_3F_ (void);
 static void mwis_some_3F_ (void);
 static void mwunwrap (void);
 static void mwmaybe_map (void);
 static void mwmaybe_bind (void);
 static void mwmaybe_for (void);
 static void mwmaybe_filter (void);
 static void mwL4 (void);
 static void mwL5 (void);
 static void mwL6 (void);
 static void mwL7 (void);
 static void mwL8 (void);
 static void mwL9 (void);
 static void mwL10 (void);
 static void mwL11 (void);
 static void mwL12 (void);
 static void mwL4_2B_ (void);
 static void mwL5_2B_ (void);
 static void mwL6_2B_ (void);
 static void mwL7_2B_ (void);
 static void mwL8_2B_ (void);
 static void mwL9_2B_ (void);
 static void mwL10_2B_ (void);
 static void mwL11_2B_ (void);
 static void mwL12_2B_ (void);
 static void mwList_2B___3E_List (void);
 static void mwList__3E_List_2B_ (void);
 static void mwlen (void);
 static void mwlen_2B_ (void);
 static void mwlen_3F_ (void);
 static void mwlen_2B__3F_ (void);
 static void mwcons_2B_ (void);
 static void mwsnoc_2B_ (void);
 static void mwcons_2B__2B_ (void);
 static void mwsnoc_2B__2B_ (void);
 static void mwcons (void);
 static void mwsnoc (void);
 static void mwuncons (void);
 static void mwunsnoc (void);
 static void mwcat (void);
 static void mwcat__2B_ (void);
 static void mwcat_2B__ (void);
 static void mwcat_2B_ (void);
 static void mwcat_aux (void);
 static void mwrebalance_2B_ (void);
 static void mwsplit_half_left (void);
 static void mwsplit_half_right (void);
 static void mwsplit_half (void);
 static void mwfirst (void);
 static void mwlast (void);
 static void mwmiddle (void);
 static void mwfirst_2B_ (void);
 static void mwlast_2B_ (void);
 static void mwmiddle_2B_ (void);
 static void mwreverse (void);
 static void mwreverse_2B_ (void);
 static void mwmap (void);
 static void mwmap_2B_ (void);
 static void mwfor (void);
 static void mwfor_2B_ (void);
 static void mwreverse_for (void);
 static void mwreverse_for_2B_ (void);
 static void mwreduce (void);
 static void mwreduce_2B_ (void);
 static void mwmap_reduce (void);
 static void mwmap_reduce_2B_ (void);
 static void mwfilter (void);
 static void mwfilter_2B_ (void);
 static void mwfind (void);
 static void mwfind_2B_ (void);
 static void mwfind_3F_ (void);
 static void mwreverse_find (void);
 static void mwreverse_find_3F_ (void);
 static void mwany (void);
 static void mwany_3F_ (void);
 static void mwall (void);
 static void mwall_3F_ (void);
 static void mwcollect (void);
 static void mwchar_bytes (void);
 static void mwchar_valid_wobbly (void);
 static void mwchar_valid_3_wobbly (void);
 static void mwchar_valid_3F_ (void);
 static void mwchar_valid (void);
 static void mwchar_valid_1 (void);
 static void mwchar_valid_2 (void);
 static void mwchar_valid_3 (void);
 static void mwchar_valid_4 (void);
 static void mwchar_codepoint (void);
 static void mwchar_codepoint_1 (void);
 static void mwchar_codepoint_2 (void);
 static void mwchar_codepoint_3 (void);
 static void mwchar_codepoint_4 (void);
 static void mwchar_21_ (void);
 static void mwchar_21__precise (void);
 static void mwchar_21__2B__2B_ (void);
 static void mwchar_3F__2B__2B_ (void);
 static void mwchar_3F_ (void);
 static void mwchar_40_ (void);
 static void mwchar_40__width (void);
 static void mwchar_width (void);
 static void mwchar_width_3F_ (void);
 static void mwis_nul_3F_ (void);
 static void mwis_tab_3F_ (void);
 static void mwis_newline_3F_ (void);
 static void mwis_vtab_3F_ (void);
 static void mwis_return_3F_ (void);
 static void mwis_space_3F_ (void);
 static void mwis_quote_3F_ (void);
 static void mwis_pound_3F_ (void);
 static void mwis_lparen_3F_ (void);
 static void mwis_rparen_3F_ (void);
 static void mwis_asterisk_3F_ (void);
 static void mwis_plus_3F_ (void);
 static void mwis_comma_3F_ (void);
 static void mwis_minus_3F_ (void);
 static void mwis_dash_3F_ (void);
 static void mwis_dot_3F_ (void);
 static void mwis_digit_3F_ (void);
 static void mwis_colon_3F_ (void);
 static void mwis_semicolon_3F_ (void);
 static void mwis_lt_3F_ (void);
 static void mwis_eq_3F_ (void);
 static void mwis_gt_3F_ (void);
 static void mwis_question_mark_3F_ (void);
 static void mwis_upper_3F_ (void);
 static void mwis_upper_hexdigit_3F_ (void);
 static void mwis_lsquare_3F_ (void);
 static void mwis_backslash_3F_ (void);
 static void mwis_rsquare_3F_ (void);
 static void mwis_underscore_3F_ (void);
 static void mwis_lower_3F_ (void);
 static void mwis_lower_hexdigit_3F_ (void);
 static void mwis_n_3F_ (void);
 static void mwis_r_3F_ (void);
 static void mwis_t_3F_ (void);
 static void mwis_lcurly_3F_ (void);
 static void mwis_pipe_3F_ (void);
 static void mwis_rcurly_3F_ (void);
 static void mwis_whitespace_3F_ (void);
 static void mwis_hexdigit_3F_ (void);
 static void mwis_sign_3F_ (void);
 static void mwis_alpha_3F_ (void);
 static void mwis_string_end_3F_ (void);
 static void mwunderscore (void);
 static void mwis_visible_3F_ (void);
 static void mwis_name_char_3F_ (void);
 static void mwis_special_char_3F_ (void);
 static void mwstr_head (void);
 static void mwstr_head_width (void);
 static void mwstr_tail (void);
 static void mwstr_size_3F_ (void);
 static void mwstr_size (void);
 static void mwstr_length (void);
 static void mwstr_length_3F_ (void);
 static void mwstr_concat (void);
 static void mwstr_cat (void);
 static void mwstr_is_empty (void);
 static void mwstr_is_empty_3F_ (void);
 static void mwstr_copy_partial_21_ (void);
 static void mwSTR_BUF_SIZE (void);
 static void mwbuild_str_21_ (void);
 static void mwstr_buf_dup_21_ (void);
 static void mwstr_buf_length_3F_ (void);
 static void mwstr_buf_length_21_ (void);
 static void mwstr_buf_u8_40_ (void);
 static void mwstr_buf_u8_21_ (void);
 static void mwstr_buf_char_40_ (void);
 static void mwstr_buf_empty_3F_ (void);
 static void mwstr_buf_full_3F_ (void);
 static void mwstr_buf_clear_21_ (void);
 static void mwstr_buf_push_u8_21_ (void);
 static void mwstr_buf_push_char_21_ (void);
 static void mwstr_buf_push_str_21_ (void);
 static void mwstr_buf_push_ptr_21_ (void);
 static void mwstr_buf_21_ (void);
 static void mwstr_buf_char_21_ (void);
 static void mwto_digit (void);
 static void mwstr_buf_int_21_ (void);
 static void mwint_show (void);
 static void mwstr_buf_swap_u8_21_ (void);
 static void mwstr_buf_reverse_21_ (void);
 static void mwstr_eq (void);
 static void mwstr_eq_3F_ (void);
 static void mwstr_for (void);
 static void mwstr_transduce (void);
 static void mwstr_chars (void);
 static void mwstr_codepoints (void);
 static void mwstr_bytes (void);
 static void mwStr__3E_Path (void);
 static void mwPath__3E_Str (void);
 static void mwpath_40_ (void);
 static void mwpath_21_ (void);
 static void mwinit_paths_21_ (void);
 static void mwsource_path_root_40_ (void);
 static void mwsource_path_root_21_ (void);
 static void mwoutput_path_root_40_ (void);
 static void mwoutput_path_root_21_ (void);
 static void mwpath_separator (void);
 static void mwpath_is_empty_3F_ (void);
 static void mwpath_join (void);
 static void mwmake_source_path (void);
 static void mwmake_output_path (void);
 static void mwpanic_21_ (void);
 static void mwInt__3E_File (void);
 static void mwFile__3E_Int (void);
 static void mwfile_40_ (void);
 static void mwfile_21_ (void);
 static void mwstdin (void);
 static void mwstdout (void);
 static void mwstderr (void);
 static void mwstr_write_21_ (void);
 static void mwstr_print_21_ (void);
 static void mwstr_trace_21_ (void);
 static void mwstr_print_ln_21_ (void);
 static void mwstr_trace_ln_21_ (void);
 static void mwprint_ln_21_ (void);
 static void mwtrace_ln_21_ (void);
 static void mwstr_buf_write_21_ (void);
 static void mwstr_buf_print_21_ (void);
 static void mwstr_buf_trace_21_ (void);
 static void mwstr_buf_read_21_ (void);
 static void mwstr_buf_input_21_ (void);
 static void mwprint_char_21_ (void);
 static void mwtrace_char_21_ (void);
 static void mwint_write_21_ (void);
 static void mwint_print_21_ (void);
 static void mwint_trace_21_ (void);
 static void mwint_print_ln_21_ (void);
 static void mwint_trace_ln_21_ (void);
 static void mwopen_file_21_ (void);
 static void mwcreate_file_21_ (void);
 static void mwO_WRONLY_7C_O_CREAT_7C_O_TRUNC (void);
 static void mwclose_file_21_ (void);
 static void mwwith_raw_path (void);
 static void mwis_directory_3F_ (void);
 static void mwS_IFMT (void);
 static void mwS_IFDIR (void);
 static void mwS_IFREG (void);
 static void mwS_ISDIR (void);
 static void mwst_mode_40_ (void);
 static void mwINPUT_BUFFER_SIZE (void);
 static void mwinput_isopen_40_ (void);
 static void mwinput_length_40_ (void);
 static void mwinput_offset_40_ (void);
 static void mwinput_handle_40_ (void);
 static void mwinput_isopen_21_ (void);
 static void mwinput_length_21_ (void);
 static void mwinput_offset_21_ (void);
 static void mwinput_handle_21_ (void);
 static void mwinput_start_21_ (void);
 static void mwinput_end_21_ (void);
 static void mwinput_done_3F_ (void);
 static void mwinput_fill_buffer_21_ (void);
 static void mwinput_peek (void);
 static void mwinput_move_21_ (void);
 static void mwinput_prepare_for_more_21_ (void);
 static void mwinput_fill_buffer_tragic_21_ (void);
 static void mwName_2E_MAX (void);
 static void mwName_2E_id (void);
 static void mwName_2E_succ (void);
 static void mwName_2E_pred (void);
 static void mwName_2E_for (void);
 static void mwName_2E_alloc_21_ (void);
 static void mwInt__3E_Hash (void);
 static void mwHash__3E_Int (void);
 static void mwNAME_HASH_MAX (void);
 static void mwhash_name_21_ (void);
 static void mwhash_name_40_ (void);
 static void mwhash_name_3F_ (void);
 static void mwhash (void);
 static void mwname_hash (void);
 static void mwnext_hash (void);
 static void mwname_keep_going_3F_ (void);
 static void mwname_new_21_ (void);
 static void mwname_cat_21_ (void);
 static void mwname_trace_21_ (void);
 static void mwname_print_21_ (void);
 static void mwname_could_be_type (void);
 static void mwname_could_be_type_var (void);
 static void mwstr_could_be_type_var (void);
 static void mwname_could_be_type_con (void);
 static void mwname_is_type_hole (void);
 static void mwname_is_underscore (void);
 static void mwname_could_be_stack_var (void);
 static void mwname_could_be_effect_con (void);
 static void mwname_print_mangled_21_ (void);
 static void mwname_mangle_21_ (void);
 static void mwname_mangle_compute_21_ (void);
 static void mwchar_hexdigits (void);
 static void mwchar_hexdigits_first (void);
 static void mwchar_hexdigits_next (void);
 static void mwhexdigit (void);
 static void mwname_undefined_3F_ (void);
 static void mwname_defined_3F_ (void);
 static void mwunSET (void);
 static void mwset_insert (void);
 static void mwModule_2E_MAX (void);
 static void mwModule_2E_id (void);
 static void mwModule_2E_succ (void);
 static void mwModule_2E_pred (void);
 static void mwModule_2E_for (void);
 static void mwModule_2E_alloc_21_ (void);
 static void mwToken_2E_MAX (void);
 static void mwToken_2E_id (void);
 static void mwToken_2E_succ (void);
 static void mwToken_2E_pred (void);
 static void mwToken_2E_for (void);
 static void mwToken_2E_alloc_21_ (void);
 static void mwmodule_new_21_ (void);
 static void mwmodule_add_import_21_ (void);
 static void mwmodule_source_path (void);
 static void mwmodule_path_from_name (void);
 static void mwInt__3E_Row (void);
 static void mwRow__3E_Int (void);
 static void mwInt__3E_Col (void);
 static void mwCol__3E_Int (void);
 static void mwlocation_pack (void);
 static void mwlocation_unpack (void);
 static void mwlocation_trace_21_ (void);
 static void mwnum_warnings_40_ (void);
 static void mwnum_warnings_2B__2B_ (void);
 static void mwemit_warning_at_21_ (void);
 static void mwnum_errors_40_ (void);
 static void mwnum_errors_2B__2B_ (void);
 static void mwemit_error_at_21_ (void);
 static void mwemit_fatal_error_at_21_ (void);
 static void mwtoken_alloc_21_ (void);
 static void mwtoken_is_int_3F_ (void);
 static void mwtoken_is_str_3F_ (void);
 static void mwtoken_is_name_3F_ (void);
 static void mwtoken_is_comma_3F_ (void);
 static void mwtoken_is_arrow_3F_ (void);
 static void mwtoken_is_dashes_3F_ (void);
 static void mwtoken_is_lparen_3F_ (void);
 static void mwtoken_is_rparen_3F_ (void);
 static void mwtoken_is_lsquare_3F_ (void);
 static void mwtoken_is_rsquare_3F_ (void);
 static void mwtoken_is_lcurly_3F_ (void);
 static void mwtoken_is_rcurly_3F_ (void);
 static void mwtoken_name_40_ (void);
 static void mwtoken_name_3F_ (void);
 static void mwtoken_str_40_ (void);
 static void mwtoken_str_3F_ (void);
 static void mwtoken_int_40_ (void);
 static void mwtoken_int_3F_ (void);
 static void mwtoken_is_arg_end_3F_ (void);
 static void mwtoken_is_left_enclosure_3F_ (void);
 static void mwtoken_is_right_enclosure_3F_ (void);
 static void mwtoken_location (void);
 static void mwtoken_location_3F_ (void);
 static void mwtoken_succ (void);
 static void mwtoken_pred (void);
 static void mwtoken_next (void);
 static void mwtoken_prev (void);
 static void mwtoken_next_arg_end (void);
 static void mwtoken_has_args_3F_ (void);
 static void mwtoken_num_args (void);
 static void mwtoken_num_args_3F_ (void);
 static void mwtoken_args_0 (void);
 static void mwtoken_args_1 (void);
 static void mwtoken_args_2 (void);
 static void mwtoken_args_3 (void);
 static void mwtoken_args (void);
 static void mwtoken_is_args_end_3F_ (void);
 static void mwtoken_args_2B_ (void);
 static void mwemit_warning_21_ (void);
 static void mwemit_error_21_ (void);
 static void mwemit_fatal_error_21_ (void);
 static void mwtoken_is_module_end_3F_ (void);
 static void mwtoken_run_end_3F_ (void);
 static void mwsig_is_stack_end_3F_ (void);
 static void mwsig_is_stack_end2_3F_ (void);
 static void mwsig_next_stack_end (void);
 static void mwsig_has_dashes (void);
 static void mwsig_has_dashes_3F_ (void);
 static void mwsig_arity (void);
 static void mwsig_count_types (void);
 static void mwsig_token_is_type_3F_ (void);
 static void mwsig_token_is_type_con_3F_ (void);
 static void mwsig_token_is_type_hole_3F_ (void);
 static void mwtoken_is_underscore_3F_ (void);
 static void mwsig_token_is_type_var_3F_ (void);
 static void mwsig_token_is_stack_var_3F_ (void);
 static void mwsig_token_is_effect_con_3F_ (void);
 static void mwsig_skip_dashes (void);
 static void mwlexer_module_40_ (void);
 static void mwlexer_module_21_ (void);
 static void mwlexer_row_40_ (void);
 static void mwlexer_row_21_ (void);
 static void mwlexer_col_40_ (void);
 static void mwlexer_col_21_ (void);
 static void mwlexer_stack_length_40_ (void);
 static void mwlexer_stack_length_21_ (void);
 static void mwLEXER_STACK_SIZE (void);
 static void mwlexer_stack_clear_21_ (void);
 static void mwlexer_stack_empty_3F_ (void);
 static void mwlexer_stack_full_3F_ (void);
 static void mwlexer_stack_push_21_ (void);
 static void mwlexer_stack_pop_21_ (void);
 static void mwrun_lexer_21_ (void);
 static void mwlexer_done_3F_ (void);
 static void mwlexer_make_21_ (void);
 static void mwlexer_emit_21_ (void);
 static void mwlexer_next_21_ (void);
 static void mwlexer_newline_21_ (void);
 static void mwlexer_emit_lparen_21_ (void);
 static void mwlexer_emit_rparen_21_ (void);
 static void mwlexer_emit_lsquare_21_ (void);
 static void mwlexer_emit_rsquare_21_ (void);
 static void mwlexer_emit_lcurly_21_ (void);
 static void mwlexer_emit_rcurly_21_ (void);
 static void mwlexer_emit_name_21_ (void);
 static void mwstr_buf_is_doc_start_3F_ (void);
 static void mwstr_buf_is_arrow_3F_ (void);
 static void mwstr_buf_is_dashes_3F_ (void);
 static void mwstr_buf_is_equal_3F_ (void);
 static void mwstr_buf_is_int_3F_ (void);
 static void mwstr_buf_is_dec_int_3F_ (void);
 static void mwis_zero_char (void);
 static void mwis_xX_char (void);
 static void mwstr_buf_is_hex_int_3F_ (void);
 static void mwstr_buf_int_3F_ (void);
 static void mwstr_buf_dec_int_3F_ (void);
 static void mwstr_buf_hex_int_3F_ (void);
 static void mwhexdigit_value (void);
 static void mwlexer_emit_string_21_ (void);
 static void mwlexer_push_string_char_21_ (void);
 static void mwlexer_skip_comment_21_ (void);
 static void mwlexer_skip_doc_21_ (void);
 static void mwlexer_comment_end_3F_ (void);
 static void mwlexer_peek (void);
 static void mwlexer_move_21_ (void);
 static void mwlexer_location (void);
 static void mwlexer_emit_warning_21_ (void);
 static void mwlexer_emit_error_21_ (void);
 static void mwlexer_emit_fatal_error_21_ (void);
 static void mwBuffer_2E_MAX (void);
 static void mwBuffer_2E_id (void);
 static void mwBuffer_2E_succ (void);
 static void mwBuffer_2E_pred (void);
 static void mwBuffer_2E_for (void);
 static void mwBuffer_2E_alloc_21_ (void);
 static void mwbuffer_new_21_ (void);
 static void mwunBAG (void);
 static void mwB0 (void);
 static void mwB1 (void);
 static void mwB2 (void);
 static void mwB3 (void);
 static void mwunBAG_2B_ (void);
 static void mwB1_2B_ (void);
 static void mwB2_2B_ (void);
 static void mwB3_2B_ (void);
 static void mwBag_2B___3E_Bag (void);
 static void mwBag__3E_Bag_2B_ (void);
 static void mwbag_empty (void);
 static void mwbag_is_empty (void);
 static void mwbag_singleton (void);
 static void mwbag_is_singleton (void);
 static void mwbag_is_singleton_2B_ (void);
 static void mwbag_len (void);
 static void mwbag_len_2B_ (void);
 static void mwbag_len_3F_ (void);
 static void mwbag_len_2B__3F_ (void);
 static void mwbag_first (void);
 static void mwbag_last (void);
 static void mwbag_middle (void);
 static void mwbag_first_2B_ (void);
 static void mwbag_last_2B_ (void);
 static void mwbag_middle_2B_ (void);
 static void mwbag_split_half_left (void);
 static void mwbag_split_half_right (void);
 static void mwbag_split_half (void);
 static void mwbag_uncons (void);
 static void mwbag_unsnoc (void);
 static void mwbag_cons (void);
 static void mwbag_snoc (void);
 static void mwbag_cons_2B_ (void);
 static void mwbag_snoc_2B_ (void);
 static void mwbag_cons_2B__2B_ (void);
 static void mwbag_snoc_2B__2B_ (void);
 static void mwbag_has (void);
 static void mwbag_has_2B_ (void);
 static void mwbag_has_3F_ (void);
 static void mwbag_insert (void);
 static void mwbag_insert_2B_ (void);
 static void mwbag_insert_2B__2B_ (void);
 static void mwbag_replace (void);
 static void mwbag_cat_unsafe (void);
 static void mwbag_cat_unsafe__2B_ (void);
 static void mwbag_cat_unsafe_2B_ (void);
 static void mworder2 (void);
 static void mworder3 (void);
 static void mwbag_lookup_key (void);
 static void mwbag_lookup_key_2B_ (void);
 static void mwbag_lookup_key_3F_ (void);
 static void mwbag_replace_key (void);
 static void mwbag_replace_key_2B_ (void);
 static void mwbag_replace_key_2B__2B_ (void);
 static void mw_3D__3D_key (void);
 static void mw_3C__3D_key (void);
 static void mwbag_values (void);
 static void mwbag_values_2B_ (void);
 static void mwunMAP (void);
 static void mwmap_empty (void);
 static void mwmap_is_empty (void);
 static void mwmap_is_empty_3F_ (void);
 static void mwmap_singleton (void);
 static void mwmap_is_singleton (void);
 static void mwmap_has (void);
 static void mwmap_has_3F_ (void);
 static void mwmap_lookup (void);
 static void mwmap_lookup_3F_ (void);
 static void mwmap_insert (void);
 static void mwmap_cons (void);
 static void mwmap_snoc (void);
 static void mwmap_pairs (void);
 static void mwmap_keys (void);
 static void mwmap_values (void);
 static void mwMetaVar_2E_MAX (void);
 static void mwMetaVar_2E_id (void);
 static void mwMetaVar_2E_succ (void);
 static void mwMetaVar_2E_pred (void);
 static void mwMetaVar_2E_for (void);
 static void mwMetaVar_2E_alloc_21_ (void);
 static void mwData_2E_MAX (void);
 static void mwData_2E_id (void);
 static void mwData_2E_succ (void);
 static void mwData_2E_pred (void);
 static void mwData_2E_for (void);
 static void mwData_2E_alloc_21_ (void);
 static void mwTag_2E_MAX (void);
 static void mwTag_2E_id (void);
 static void mwTag_2E_succ (void);
 static void mwTag_2E_pred (void);
 static void mwTag_2E_for (void);
 static void mwTag_2E_alloc_21_ (void);
 static void mwdef_type_21_ (void);
 static void mwinit_types_21_ (void);
 static void mwT_2A_ (void);
 static void mwT__3E_ (void);
 static void mwTMut (void);
 static void mwT0 (void);
 static void mwT1 (void);
 static void mwT2 (void);
 static void mwT3 (void);
 static void mwT4 (void);
 static void mwT5 (void);
 static void mwT6 (void);
 static void mwtype_is_morphism (void);
 static void mwtype_is_morphism_3F_ (void);
 static void mwTYPE_TYPE (void);
 static void mwTYPE_STACK (void);
 static void mwTYPE_EFFECT (void);
 static void mwTYPE_UNIT (void);
 static void mwTYPE_BOOL (void);
 static void mwTYPE_MUT (void);
 static void mwTYPE_INT (void);
 static void mwTYPE_PTR (void);
 static void mwTYPE_STR (void);
 static void mwTYPE_CHAR (void);
 static void mwTYPE_U8 (void);
 static void mwTYPE_U16 (void);
 static void mwTYPE_U32 (void);
 static void mwTYPE_U64 (void);
 static void mwTYPE_I8 (void);
 static void mwTYPE_I16 (void);
 static void mwTYPE_I32 (void);
 static void mwTYPE_I64 (void);
 static void mwtype_expand (void);
 static void mwgamma_token_40_ (void);
 static void mwgamma_token_3F_ (void);
 static void mwtype_unify_failed_21_ (void);
 static void mwtype_unify_21_ (void);
 static void mwvalue_unify_21_ (void);
 static void mwtype_value_unify_21_ (void);
 static void mwvalue_type_unify_21_ (void);
 static void mwarrow_type (void);
 static void mwblock_infer_type_21_ (void);
 static void mwtype_unify_pair_21_ (void);
 static void mwtype_prim_unify_21_ (void);
 static void mwtype_data_unify_21_ (void);
 static void mwtype_table_unify_21_ (void);
 static void mwtype_var_unify_21_ (void);
 static void mwtype_has_meta_3F_ (void);
 static void mwtype_has_meta (void);
 static void mwtype_trace_sig_21_ (void);
 static void mwtype_trace_stack_dom_21_ (void);
 static void mwtype_trace_stack_cod_21_ (void);
 static void mwtype_trace_stack_21_ (void);
 static void mwtype_trace_21_ (void);
 static void mwvalue_trace_21_ (void);
 static void mwtype_trace_prim_21_ (void);
 static void mwtype_semifreshen_sig (void);
 static void mwtype_semifreshen_sig_aux (void);
 static void mwtype_semifreshen_sig_stack (void);
 static void mwtype_freshen_sig (void);
 static void mwtype_stack_rest (void);
 static void mwtype_sig_needs_fresh_stack_rest_3F_ (void);
 static void mwtype_freshen_sig_aux (void);
 static void mwtype_freshen_sig_stack (void);
 static void mwtype_freshen (void);
 static void mwtype_pair_freshen (void);
 static void mwmeta_freshen (void);
 static void mwtype_var_freshen (void);
 static void mwprim_type_arity (void);
 static void mwtype_arity (void);
 static void mwtype_head (void);
 static void mwtype_max_count_3F_ (void);
 static void mwmeta_trace_21_ (void);
 static void mwmeta_alloc_21_ (void);
 static void mwmeta_type_21_ (void);
 static void mwmeta_expand (void);
 static void mwmeta_unify_21_ (void);
 static void mwtype_hole_unify_21_ (void);
 static void mwtype_max_num_params (void);
 static void mwtype_num_morphisms_on_top (void);
 static void mwapp_type_trace_21_ (void);
 static void mwapp_type_trace_open_21_ (void);
 static void mwunSUBST (void);
 static void mwsubst_nil (void);
 static void mwsubst_is_nil (void);
 static void mwsubst_is_nil_3F_ (void);
 static void mwsubst_new_21_ (void);
 static void mwsubst_has_var (void);
 static void mwsubst_has_var_3F_ (void);
 static void mwsubst_get_var (void);
 static void mwsubst_get_var_3F_ (void);
 static void mwsubst_match_var (void);
 static void mwtag_num_inputs_3F_ (void);
 static void mwtag_is_transparent_3F_ (void);
 static void mwdata_num_tags (void);
 static void mwdata_add_tag_21_ (void);
 static void mwdata_is_enum_3F_ (void);
 static void mwdata_is_transparent (void);
 static void mwAtom_2E_MAX (void);
 static void mwAtom_2E_id (void);
 static void mwAtom_2E_succ (void);
 static void mwAtom_2E_pred (void);
 static void mwAtom_2E_for (void);
 static void mwAtom_2E_alloc_21_ (void);
 static void mwArrow_2E_MAX (void);
 static void mwArrow_2E_id (void);
 static void mwArrow_2E_succ (void);
 static void mwArrow_2E_pred (void);
 static void mwArrow_2E_for (void);
 static void mwArrow_2E_alloc_21_ (void);
 static void mwLambda_2E_MAX (void);
 static void mwLambda_2E_id (void);
 static void mwLambda_2E_succ (void);
 static void mwLambda_2E_pred (void);
 static void mwLambda_2E_for (void);
 static void mwLambda_2E_alloc_21_ (void);
 static void mwBlock_2E_MAX (void);
 static void mwBlock_2E_id (void);
 static void mwBlock_2E_succ (void);
 static void mwBlock_2E_pred (void);
 static void mwBlock_2E_for (void);
 static void mwBlock_2E_alloc_21_ (void);
 static void mwunPARAM (void);
 static void mwVar__3E_Param (void);
 static void mwParam__3E_Var (void);
 static void mwatom_arg_add_21_ (void);
 static void mwarrow_arg_add_21_ (void);
 static void mwarrow_atom_add_21_ (void);
 static void mwblock_new_21_ (void);
 static void mwblock_new_deferred_21_ (void);
 static void mwblock_arrow_40_ (void);
 static void mwblock_arrow_3F_ (void);
 static void mwblock_force_21_ (void);
 static void mwblock_unify_type_21_ (void);
 static void mwblock_unify_type_aux_21_ (void);
 static void mwMatch_2E_MAX (void);
 static void mwMatch_2E_id (void);
 static void mwMatch_2E_succ (void);
 static void mwMatch_2E_pred (void);
 static void mwMatch_2E_for (void);
 static void mwMatch_2E_alloc_21_ (void);
 static void mwCase_2E_MAX (void);
 static void mwCase_2E_id (void);
 static void mwCase_2E_succ (void);
 static void mwCase_2E_pred (void);
 static void mwCase_2E_for (void);
 static void mwCase_2E_alloc_21_ (void);
 static void mwmatch_add_case_21_ (void);
 static void mwmatch_is_exhaustive_3F_ (void);
 static void mwmatch_has_default_case_3F_ (void);
 static void mwmatch_scrutinee_type_3F_ (void);
 static void mwmatch_scrutinee_data_3F_ (void);
 static void mwmatch_is_transparent_3F_ (void);
 static void mwcases_cover_case_3F_ (void);
 static void mwcases_cover_case (void);
 static void mwcase_is_covered (void);
 static void mwcases_have_default_case (void);
 static void mwcase_is_default_case (void);
 static void mwpattern_is_covered (void);
 static void mwmut_new_21_ (void);
 static void mwmut_get_21_ (void);
 static void mwmut_set_21_ (void);
 static void mwmut (void);
 static void mw_40_ (void);
 static void mw_21_ (void);
 static void mwdelay (void);
 static void mwdelay0 (void);
 static void mwdelay2 (void);
 static void mwdelay3 (void);
 static void mwdelay4 (void);
 static void mwforce (void);
 static void mwforce2 (void);
 static void mwready (void);
 static void mwready2 (void);
 static void mwlazy_map (void);
 static void mwlazy_map2 (void);
 static void mwlazy_bind (void);
 static void mwVar_2E_MAX (void);
 static void mwVar_2E_id (void);
 static void mwVar_2E_succ (void);
 static void mwVar_2E_pred (void);
 static void mwVar_2E_for (void);
 static void mwVar_2E_alloc_21_ (void);
 static void mwvar_new_21_ (void);
 static void mwvar_new_implicit_21_ (void);
 static void mwvar_is_physical_3F_ (void);
 static void mwWord_2E_MAX (void);
 static void mwWord_2E_id (void);
 static void mwWord_2E_succ (void);
 static void mwWord_2E_pred (void);
 static void mwWord_2E_for (void);
 static void mwWord_2E_alloc_21_ (void);
 static void mwTable_2E_MAX (void);
 static void mwTable_2E_id (void);
 static void mwTable_2E_succ (void);
 static void mwTable_2E_pred (void);
 static void mwTable_2E_for (void);
 static void mwTable_2E_alloc_21_ (void);
 static void mwField_2E_MAX (void);
 static void mwField_2E_id (void);
 static void mwField_2E_succ (void);
 static void mwField_2E_pred (void);
 static void mwField_2E_for (void);
 static void mwField_2E_alloc_21_ (void);
 static void mwunFIELDWORD (void);
 static void mwfieldword_name_40_ (void);
 static void mwCODEGEN_BUF_SIZE (void);
 static void mwcodegen_file_40_ (void);
 static void mwcodegen_file_21_ (void);
 static void mwcodegen_length_40_ (void);
 static void mwcodegen_length_21_ (void);
 static void mwcodegen_u8_40_ (void);
 static void mwcodegen_u8_21_ (void);
 static void mwcodegen_full_3F_ (void);
 static void mwcodegen_flush_21_ (void);
 static void mw_2E_b (void);
 static void mw_2E_c (void);
 static void mw_2E_ (void);
 static void mwcodegen_start_21_ (void);
 static void mwcodegen_end_21_ (void);
 static void mwrun_output_c99_21_ (void);
 static void mwc99_depth_40_ (void);
 static void mwc99_depth_21_ (void);
 static void mwc99_depth_2B__2B_ (void);
 static void mwc99_depth__ (void);
 static void mw_2E_lf (void);
 static void mw_3B_ (void);
 static void mw_3B__3B_ (void);
 static void mw_2E_n (void);
 static void mw_2E_d (void);
 static void mw_2E_name (void);
 static void mw_2E_w (void);
 static void mw_2E_p (void);
 static void mw_2E_pm (void);
 static void mwc99_emit_header_21_ (void);
 static void mwc99_emit_buffers_21_ (void);
 static void mwc99_emit_buffer_21_ (void);
 static void mwc99_emit_tags_21_ (void);
 static void mwc99_emit_tag_21_ (void);
 static void mwc99_emit_prims_21_ (void);
 static void mwc99_emit_externals_21_ (void);
 static void mwc99_emit_external_21_ (void);
 static void mwc99_emit_arrow_21_ (void);
 static void mwc99_emit_atom_21_ (void);
 static void mwc99_emit_string_21_ (void);
 static void mwc99_emit_string_char_21_ (void);
 static void mwc99_emit_prim_21_ (void);
 static void mwc99_emit_prim_default_21_ (void);
 static void mwc99_emit_args_push_21_ (void);
 static void mwc99_emit_arg_push_21_ (void);
 static void mwc99_emit_arg_run_21_ (void);
 static void mw_2E_var_val (void);
 static void mwc99_pack_ctx_21_ (void);
 static void mwc99_unpack_ctx_21_ (void);
 static void mwc99_decref_ctx_21_ (void);
 static void mwneed_push_21_ (void);
 static void mwneed_pop_21_ (void);
 static void mwhas_need_3F_ (void);
 static void mwneed_word_21_ (void);
 static void mwneed_block_21_ (void);
 static void mwneed_field_21_ (void);
 static void mwneed_fieldword_21_ (void);
 static void mwc99_emit_needs_21_ (void);
 static void mwc99_emit_need_21_ (void);
 static void mwc99_emit_block_push_21_ (void);
 static void mwc99_emit_var_21_ (void);
 static void mwc99_emit_var_push_21_ (void);
 static void mwc99_emit_lambda_21_ (void);
 static void mwc99_emit_match_21_ (void);
 static void mwc99_emit_case_21_ (void);
 static void mwc99_emit_pattern_21_ (void);
 static void mwc99_emit_word_sigs_21_ (void);
 static void mwc99_emit_word_sig_21_ (void);
 static void mwc99_emit_block_sigs_21_ (void);
 static void mwc99_emit_block_sig_21_ (void);
 static void mwc99_emit_field_sigs_21_ (void);
 static void mwc99_emit_field_sig_21_ (void);
 static void mwc99_emit_block_defs_21_ (void);
 static void mwc99_emit_block_def_21_ (void);
 static void mw_2E_block (void);
 static void mwc99_emit_word_def_21_ (void);
 static void mwc99_emit_field_def_21_ (void);
 static void mwc99_emit_main_21_ (void);
 static void mwunCTX (void);
 static void mwctx_empty (void);
 static void mwctx_is_physically_empty (void);
 static void mwctx_new_21_ (void);
 static void mwctx_vars (void);
 static void mwctx_physical_vars (void);
 static void mwctx_lookup (void);
 static void mwExternal_2E_MAX (void);
 static void mwExternal_2E_id (void);
 static void mwExternal_2E_succ (void);
 static void mwExternal_2E_pred (void);
 static void mwExternal_2E_for (void);
 static void mwExternal_2E_alloc_21_ (void);
 static void mwHolesAllowed__3E_Bool (void);
 static void mwtype_elab_default (void);
 static void mwtype_elab_stack_assertion (void);
 static void mwtype_elab_holes_allowed_3F_ (void);
 static void mwtype_elab_ctx (void);
 static void mwtype_elab_ctx_3F_ (void);
 static void mwtype_elab_ctx_21_ (void);
 static void mwelab_type_sig_21_ (void);
 static void mwelab_type_stack_21_ (void);
 static void mwelab_type_stack_rest_21_ (void);
 static void mwelab_type_arg_21_ (void);
 static void mwelab_type_atom_21_ (void);
 static void mwelab_stack_var_21_ (void);
 static void mwelab_type_var_21_ (void);
 static void mwelab_implicit_var_21_ (void);
 static void mwelab_type_con_21_ (void);
 static void mwelab_type_args_21_ (void);
 static void mwelab_type_hole_21_ (void);
 static void mwelab_type_dont_care_21_ (void);
 static void mwelab_type_quote_21_ (void);
 static void mwelab_type_unify_21_ (void);
 static void mwelab_simple_type_arg_21_ (void);
 static void mwab_home_40_ (void);
 static void mwab_home_21_ (void);
 static void mwab_homeidx_40_ (void);
 static void mwab_homeidx_21_ (void);
 static void mwab_arrow_40_ (void);
 static void mwab_arrow_21_ (void);
 static void mwab_ctx_40_ (void);
 static void mwab_ctx_21_ (void);
 static void mwab_token_40_ (void);
 static void mwab_token_21_ (void);
 static void mwab_type_40_ (void);
 static void mwab_type_21_ (void);
 static void mwab_save_21_ (void);
 static void mwab_build_21_ (void);
 static void mwab_build_word_21_ (void);
 static void mwab_unify_type_21_ (void);
 static void mwab_atom_21_ (void);
 static void mwab_optimized_snoc_21_ (void);
 static void mwatom_accepts_args_3F_ (void);
 static void mwatoms_has_last_block_3F_ (void);
 static void mwatoms_turn_last_block_to_arg (void);
 static void mwblock_to_arg (void);
 static void mwarrow_to_run_var (void);
 static void mwatom_to_run_var (void);
 static void mwab_op_21_ (void);
 static void mwab_expand_opsig_21_ (void);
 static void mwab_int_21_ (void);
 static void mwab_str_21_ (void);
 static void mwab_buffer_21_ (void);
 static void mwab_var_21_ (void);
 static void mwab_tag_21_ (void);
 static void mwab_prim_21_ (void);
 static void mwab_word_21_ (void);
 static void mwab_external_21_ (void);
 static void mwab_fieldword_21_ (void);
 static void mwab_block_at_21_ (void);
 static void mwab_block_21_ (void);
 static void mwab_dip_21_ (void);
 static void mwab_if_21_ (void);
 static void mwab_while_21_ (void);
 static void mwab_lambda_21_ (void);
 static void mwelab_op_fresh_sig_21_ (void);
 static void mwelab_block_sig_21_ (void);
 static void mwelab_match_sig_21_ (void);
 static void mwelab_lambda_sig_21_ (void);
 static void mwelab_var_sig_21_ (void);
 static void mwelab_tag_sig_21_ (void);
 static void mwelab_tag_ctx_21_ (void);
 static void mwelab_tag_ctx_sig_21_ (void);
 static void mwelab_external_sig_21_ (void);
 static void mwelab_external_ctx_21_ (void);
 static void mwelab_external_ctx_sig_21_ (void);
 static void mwelab_word_sig_21_ (void);
 static void mwelab_word_ctx_21_ (void);
 static void mwelab_word_ctx_sig_21_ (void);
 static void mwelab_word_body_21_ (void);
 static void mwelab_arrow_21_ (void);
 static void mwelab_arrow_hom_21_ (void);
 static void mwelab_arrow_fwd_21_ (void);
 static void mwelab_atoms_21_ (void);
 static void mwelab_atoms_done_3F_ (void);
 static void mwelab_atom_21_ (void);
 static void mwelab_atom_block_21_ (void);
 static void mwelab_block_at_21_ (void);
 static void mwelab_args_21_ (void);
 static void mwelab_no_args_21_ (void);
 static void mwelab_atom_name_21_ (void);
 static void mwelab_prim_21_ (void);
 static void mwelab_atom_assert_21_ (void);
 static void mwelab_atom_lambda_21_ (void);
 static void mwelab_atom_match_21_ (void);
 static void mwelab_lambda_21_ (void);
 static void mwelab_expand_tensor_21_ (void);
 static void mwelab_expand_morphism_21_ (void);
 static void mwelab_lambda_pop_from_mid_21_ (void);
 static void mwtoken_is_lambda_param_3F_ (void);
 static void mwelab_lambda_params_21_ (void);
 static void mwelab_lambda_body_21_ (void);
 static void mwelab_match_21_ (void);
 static void mwelab_match_exhaustive_21_ (void);
 static void mwelab_match_cases_21_ (void);
 static void mwelab_match_case_21_ (void);
 static void mwelab_case_pattern_21_ (void);
 static void mwelab_case_body_21_ (void);
 static void mwelab_module_21_ (void);
 static void mwelab_module_header_21_ (void);
 static void mwelab_module_decl_21_ (void);
 static void mwelab_module_import_21_ (void);
 static void mwelab_data_21_ (void);
 static void mwelab_data_header_21_ (void);
 static void mwelab_data_tag_21_ (void);
 static void mwexpect_token_comma (void);
 static void mwexpect_token_rparen (void);
 static void mwexpect_token_arrow (void);
 static void mwelab_def_21_ (void);
 static void mwelab_def_external_21_ (void);
 static void mwelab_def_type_21_ (void);
 static void mwelab_buffer_21_ (void);
 static void mwelab_table_21_ (void);
 static void mwelab_target_c99_21_ (void);
 static void mwtypecheck_everything_21_ (void);
 static void mwtypecheck_name_21_ (void);
 static void mwTABLE_MAX_SIZE (void);
 static void mwtable_new_21_ (void);
 static void mwelab_field_21_ (void);
 static void mwfield_new_21_ (void);
 static void mwelab_field_sig_21_ (void);
 static void mwelab_field_word_type_21_ (void);
 static void mwname_prim_3D_ (void);
 static void mwtoken_prim_3D__3F_ (void);
 static void mwtoken_prim_3D_ (void);
 static void mwdef_prim_21_ (void);
 static void mwinit_prims_21_ (void);
 static void mwinit_21_ (void);
 static void mwcompile_21_ (void);
 static void mwmain (void);

 static void mb_Name_2E_pred_1 (void);
 static void mb_Name_2E_pred_2 (void);
 static void mb_Name_2E_for_2 (void);
 static void mb_Name_2E_for_3 (void);
 static void mb_Name_2E_for_4 (void);
 static void mb_Module_2E_pred_1 (void);
 static void mb_Module_2E_pred_2 (void);
 static void mb_Module_2E_for_2 (void);
 static void mb_Module_2E_for_3 (void);
 static void mb_Module_2E_for_4 (void);
 static void mb_Token_2E_pred_1 (void);
 static void mb_Token_2E_pred_2 (void);
 static void mb_Token_2E_for_2 (void);
 static void mb_Token_2E_for_3 (void);
 static void mb_Token_2E_for_4 (void);
 static void mb_Buffer_2E_pred_1 (void);
 static void mb_Buffer_2E_pred_2 (void);
 static void mb_Buffer_2E_for_2 (void);
 static void mb_Buffer_2E_for_3 (void);
 static void mb_Buffer_2E_for_4 (void);
 static void mb_MetaVar_2E_pred_1 (void);
 static void mb_MetaVar_2E_pred_2 (void);
 static void mb_MetaVar_2E_for_2 (void);
 static void mb_MetaVar_2E_for_3 (void);
 static void mb_MetaVar_2E_for_4 (void);
 static void mb_Data_2E_pred_1 (void);
 static void mb_Data_2E_pred_2 (void);
 static void mb_Data_2E_for_2 (void);
 static void mb_Data_2E_for_3 (void);
 static void mb_Data_2E_for_4 (void);
 static void mb_Tag_2E_pred_1 (void);
 static void mb_Tag_2E_pred_2 (void);
 static void mb_Tag_2E_for_2 (void);
 static void mb_Tag_2E_for_3 (void);
 static void mb_Tag_2E_for_4 (void);
 static void mb_Atom_2E_pred_1 (void);
 static void mb_Atom_2E_pred_2 (void);
 static void mb_Atom_2E_for_2 (void);
 static void mb_Atom_2E_for_3 (void);
 static void mb_Atom_2E_for_4 (void);
 static void mb_Arrow_2E_pred_1 (void);
 static void mb_Arrow_2E_pred_2 (void);
 static void mb_Arrow_2E_for_2 (void);
 static void mb_Arrow_2E_for_3 (void);
 static void mb_Arrow_2E_for_4 (void);
 static void mb_Lambda_2E_pred_1 (void);
 static void mb_Lambda_2E_pred_2 (void);
 static void mb_Lambda_2E_for_2 (void);
 static void mb_Lambda_2E_for_3 (void);
 static void mb_Lambda_2E_for_4 (void);
 static void mb_Block_2E_pred_1 (void);
 static void mb_Block_2E_pred_2 (void);
 static void mb_Block_2E_for_2 (void);
 static void mb_Block_2E_for_3 (void);
 static void mb_Block_2E_for_4 (void);
 static void mb_Match_2E_pred_1 (void);
 static void mb_Match_2E_pred_2 (void);
 static void mb_Match_2E_for_2 (void);
 static void mb_Match_2E_for_3 (void);
 static void mb_Match_2E_for_4 (void);
 static void mb_Case_2E_pred_1 (void);
 static void mb_Case_2E_pred_2 (void);
 static void mb_Case_2E_for_2 (void);
 static void mb_Case_2E_for_3 (void);
 static void mb_Case_2E_for_4 (void);
 static void mb_Var_2E_pred_1 (void);
 static void mb_Var_2E_pred_2 (void);
 static void mb_Var_2E_for_2 (void);
 static void mb_Var_2E_for_3 (void);
 static void mb_Var_2E_for_4 (void);
 static void mb_Word_2E_pred_1 (void);
 static void mb_Word_2E_pred_2 (void);
 static void mb_Word_2E_for_2 (void);
 static void mb_Word_2E_for_3 (void);
 static void mb_Word_2E_for_4 (void);
 static void mb_Table_2E_pred_1 (void);
 static void mb_Table_2E_pred_2 (void);
 static void mb_Table_2E_for_2 (void);
 static void mb_Table_2E_for_3 (void);
 static void mb_Table_2E_for_4 (void);
 static void mb_Field_2E_pred_1 (void);
 static void mb_Field_2E_pred_2 (void);
 static void mb_Field_2E_for_2 (void);
 static void mb_Field_2E_for_3 (void);
 static void mb_Field_2E_for_4 (void);
 static void mb_External_2E_pred_1 (void);
 static void mb_External_2E_pred_2 (void);
 static void mb_External_2E_for_2 (void);
 static void mb_External_2E_for_3 (void);
 static void mb_External_2E_for_4 (void);
 static void mb_init_prims_21__1 (void);
 static void mb_init_prims_21__2 (void);
 static void mb_init_prims_21__3 (void);
 static void mb_init_prims_21__4 (void);
 static void mb_init_prims_21__5 (void);
 static void mb_init_prims_21__6 (void);
 static void mb_init_prims_21__7 (void);
 static void mb_init_prims_21__8 (void);
 static void mb_init_prims_21__9 (void);
 static void mb_init_prims_21__10 (void);
 static void mb_init_prims_21__11 (void);
 static void mb_init_prims_21__12 (void);
 static void mb_init_prims_21__13 (void);
 static void mb_init_prims_21__14 (void);
 static void mb_init_prims_21__15 (void);
 static void mb_init_prims_21__16 (void);
 static void mb_init_prims_21__17 (void);
 static void mb_init_prims_21__18 (void);
 static void mb_init_prims_21__19 (void);
 static void mb_init_prims_21__20 (void);
 static void mb_init_prims_21__21 (void);
 static void mb_init_prims_21__22 (void);
 static void mb_init_prims_21__23 (void);
 static void mb_init_prims_21__24 (void);
 static void mb_init_prims_21__25 (void);
 static void mb_init_prims_21__26 (void);
 static void mb_init_prims_21__27 (void);
 static void mb_init_prims_21__28 (void);
 static void mb_init_prims_21__29 (void);
 static void mb_init_prims_21__30 (void);
 static void mb_init_prims_21__31 (void);
 static void mb_init_prims_21__32 (void);
 static void mb_init_prims_21__33 (void);
 static void mb_compile_21__1 (void);
 static void mb_compile_21__2 (void);
 static void mb_run_lexer_21__1 (void);
 static void mb_run_lexer_21__2 (void);
 static void mb_run_lexer_21__3 (void);
 static void mb_run_lexer_21__4 (void);
 static void mb_elab_module_21__1 (void);
 static void mb_elab_module_21__2 (void);
 static void mb_typecheck_everything_21__1 (void);
 static void mb_main_1 (void);
 static void mb_main_2 (void);
 static void mb_ptr_40__40__1 (void);
 static void mb_with_raw_ptr_2 (void);
 static void mb_Int__3E_OS_1 (void);
 static void mb_Int__3E_OS_6 (void);
 static void mb_Int__3E_OS_2 (void);
 static void mb_Int__3E_OS_5 (void);
 static void mb_Int__3E_OS_3 (void);
 static void mb_Int__3E_OS_4 (void);
 static void mb_posix_open_21__1 (void);
 static void mb_dip2_2 (void);
 static void mb_dip2_3 (void);
 static void mb_rotr_1 (void);
 static void mb_rotl_1 (void);
 static void mb_over_1 (void);
 static void mb_over2_1 (void);
 static void mb_over3_1 (void);
 static void mb_tuck_1 (void);
 static void mb_nip_1 (void);
 static void mb_dup3_1 (void);
 static void mb_dup3_2 (void);
 static void mb_dip_3F__2 (void);
 static void mb_dip_27__2 (void);
 static void mb_dip3_2 (void);
 static void mb_dip3_3 (void);
 static void mb_dip3_4 (void);
 static void mb_rot4r_1 (void);
 static void mb_rot4l_1 (void);
 static void mb_or_2 (void);
 static void mb_or_3 (void);
 static void mb_and_2 (void);
 static void mb_and_3 (void);
 static void mb_cmp_1 (void);
 static void mb_cmp_4 (void);
 static void mb_cmp_2 (void);
 static void mb_cmp_3 (void);
 static void mb_max_1 (void);
 static void mb_max_2 (void);
 static void mb_min_1 (void);
 static void mb_min_2 (void);
 static void mb_ptr_21__21__1 (void);
 static void mb_int_40__40__1 (void);
 static void mb_int_21__21__1 (void);
 static void mb_value_40__40__1 (void);
 static void mb_value_21__21__1 (void);
 static void mb_in_range_1 (void);
 static void mb_in_range_2 (void);
 static void mb_abs_1 (void);
 static void mb_abs_2 (void);
 static void mb_pack1_1 (void);
 static void mb_pack2_1 (void);
 static void mb_pack3_1 (void);
 static void mb_pack4_1 (void);
 static void mb_pack5_1 (void);
 static void mb_unpack2_1 (void);
 static void mb_unpack3_1 (void);
 static void mb_unpack4_1 (void);
 static void mb_unpack5_1 (void);
 static void mb_file_21__1 (void);
 static void mb_str_write_21__1 (void);
 static void mb_str_write_21__2 (void);
 static void mb_str_write_21__3 (void);
 static void mb_str_write_21__6 (void);
 static void mb_str_write_21__4 (void);
 static void mb_str_write_21__5 (void);
 static void mb_str_size_1 (void);
 static void mb_str_buf_write_21__1 (void);
 static void mb_str_buf_write_21__4 (void);
 static void mb_str_buf_write_21__2 (void);
 static void mb_str_buf_write_21__3 (void);
 static void mb_str_buf_read_21__1 (void);
 static void mb_str_buf_read_21__2 (void);
 static void mb_str_buf_length_21__1 (void);
 static void mb_print_char_21__1 (void);
 static void mb_build_str_21__2 (void);
 static void mb_trace_char_21__1 (void);
 static void mb_int_write_21__1 (void);
 static void mb_str_buf_int_21__1 (void);
 static void mb_str_buf_int_21__7 (void);
 static void mb_str_buf_int_21__2 (void);
 static void mb_str_buf_int_21__3 (void);
 static void mb_str_buf_int_21__4 (void);
 static void mb_str_buf_int_21__5 (void);
 static void mb_str_buf_int_21__6 (void);
 static void mb_open_file_21__1 (void);
 static void mb_open_file_21__2 (void);
 static void mb_create_file_21__1 (void);
 static void mb_create_file_21__2 (void);
 static void mb_close_file_21__1 (void);
 static void mb_close_file_21__2 (void);
 static void mb_with_raw_path_2 (void);
 static void mb_is_directory_3F__1 (void);
 static void mb_is_directory_3F__2 (void);
 static void mb_is_directory_3F__3 (void);
 static void mb_is_directory_3F__4 (void);
 static void mb_char_40__1 (void);
 static void mb_char_40__2 (void);
 static void mb_str_tail_1 (void);
 static void mb_str_length_1 (void);
 static void mb_str_length_3 (void);
 static void mb_str_length_2 (void);
 static void mb_str_concat_1 (void);
 static void mb_str_concat_2 (void);
 static void mb_str_concat_3 (void);
 static void mb_for_5 (void);
 static void mb_for_7 (void);
 static void mb_for_8 (void);
 static void mb_for_10 (void);
 static void mb_for_11 (void);
 static void mb_for_12 (void);
 static void mb_str_copy_partial_21__1 (void);
 static void mb_str_copy_partial_21__2 (void);
 static void mb_str_is_empty_1 (void);
 static void mb_str_is_empty_2 (void);
 static void mb_str_buf_dup_21__1 (void);
 static void mb_char_21__1 (void);
 static void mb_char_width_1 (void);
 static void mb_str_buf_reverse_21__1 (void);
 static void mb_str_buf_reverse_21__3 (void);
 static void mb_str_buf_reverse_21__2 (void);
 static void mb_int_show_1 (void);
 static void mb_str_buf_swap_u8_21__1 (void);
 static void mb_str_buf_swap_u8_21__2 (void);
 static void mb_str_for_2 (void);
 static void mb_str_for_4 (void);
 static void mb_str_for_3 (void);
 static void mb_str_transduce_2 (void);
 static void mb_str_transduce_3 (void);
 static void mb_str_transduce_11 (void);
 static void mb_str_transduce_4 (void);
 static void mb_str_transduce_9 (void);
 static void mb_str_chars_1 (void);
 static void mb_str_chars_2 (void);
 static void mb_str_codepoints_1 (void);
 static void mb_str_codepoints_2 (void);
 static void mb_char_codepoint_1 (void);
 static void mb_char_codepoint_6 (void);
 static void mb_char_codepoint_2 (void);
 static void mb_char_codepoint_5 (void);
 static void mb_char_codepoint_3 (void);
 static void mb_char_codepoint_4 (void);
 static void mb_str_bytes_1 (void);
 static void mb_str_bytes_4 (void);
 static void mb_str_bytes_2 (void);
 static void mb_str_bytes_3 (void);
 static void mb_L4_2B__1 (void);
 static void mb_L5_2B__1 (void);
 static void mb_L6_2B__1 (void);
 static void mb_L7_2B__1 (void);
 static void mb_L8_2B__1 (void);
 static void mb_L9_2B__1 (void);
 static void mb_L10_2B__1 (void);
 static void mb_L11_2B__1 (void);
 static void mb_L12_2B__1 (void);
 static void mb_len_6 (void);
 static void mb_len_2B__5 (void);
 static void mb_cons_2B__6 (void);
 static void mb_cons_2B__7 (void);
 static void mb_rebalance_2B__1 (void);
 static void mb_rebalance_2B__2 (void);
 static void mb_rebalance_2B__7 (void);
 static void mb_rebalance_2B__3 (void);
 static void mb_rebalance_2B__4 (void);
 static void mb_rebalance_2B__5 (void);
 static void mb_rebalance_2B__6 (void);
 static void mb_rebalance_2B__8 (void);
 static void mb_snoc_2B__6 (void);
 static void mb_snoc_2B__2B__1 (void);
 static void mb_uncons_5 (void);
 static void mb_unsnoc_2 (void);
 static void mb_unsnoc_4 (void);
 static void mb_unsnoc_6 (void);
 static void mb_unsnoc_8 (void);
 static void mb_cat_2B__7 (void);
 static void mb_cat_2B__13 (void);
 static void mb_cat_aux_1 (void);
 static void mb_split_half_left_2 (void);
 static void mb_split_half_left_4 (void);
 static void mb_split_half_left_6 (void);
 static void mb_split_half_right_2 (void);
 static void mb_split_half_right_4 (void);
 static void mb_split_half_right_6 (void);
 static void mb_split_half_right_8 (void);
 static void mb_split_half_3 (void);
 static void mb_split_half_5 (void);
 static void mb_split_half_7 (void);
 static void mb_split_half_9 (void);
 static void mb_first_1 (void);
 static void mb_last_1 (void);
 static void mb_last_2B__3 (void);
 static void mb_last_2B__5 (void);
 static void mb_middle_1 (void);
 static void mb_reverse_6 (void);
 static void mb_reverse_2B__5 (void);
 static void mb_map_5 (void);
 static void mb_map_6 (void);
 static void mb_map_8 (void);
 static void mb_map_9 (void);
 static void mb_map_10 (void);
 static void mb_map_11 (void);
 static void mb_map_12 (void);
 static void mb_map_13 (void);
 static void mb_map_15 (void);
 static void mb_map_16 (void);
 static void mb_map_17 (void);
 static void mb_map_18 (void);
 static void mb_map_19 (void);
 static void mb_map_2B__4 (void);
 static void mb_map_2B__5 (void);
 static void mb_map_2B__7 (void);
 static void mb_map_2B__8 (void);
 static void mb_map_2B__9 (void);
 static void mb_map_2B__10 (void);
 static void mb_map_2B__11 (void);
 static void mb_map_2B__12 (void);
 static void mb_map_2B__14 (void);
 static void mb_map_2B__15 (void);
 static void mb_map_2B__16 (void);
 static void mb_map_2B__17 (void);
 static void mb_map_2B__18 (void);
 static void mb_for_2B__4 (void);
 static void mb_for_2B__6 (void);
 static void mb_for_2B__7 (void);
 static void mb_for_2B__9 (void);
 static void mb_for_2B__10 (void);
 static void mb_for_2B__11 (void);
 static void mb_reverse_for_5 (void);
 static void mb_reverse_for_7 (void);
 static void mb_reverse_for_8 (void);
 static void mb_reverse_for_10 (void);
 static void mb_reverse_for_11 (void);
 static void mb_reverse_for_12 (void);
 static void mb_reverse_for_2B__4 (void);
 static void mb_reverse_for_2B__6 (void);
 static void mb_reverse_for_2B__7 (void);
 static void mb_reverse_for_2B__9 (void);
 static void mb_reverse_for_2B__10 (void);
 static void mb_reverse_for_2B__11 (void);
 static void mb_reduce_2 (void);
 static void mb_reduce_3 (void);
 static void mb_reduce_2B__6 (void);
 static void mb_reduce_2B__7 (void);
 static void mb_reduce_2B__8 (void);
 static void mb_map_reduce_2 (void);
 static void mb_map_reduce_3 (void);
 static void mb_map_reduce_2B__2 (void);
 static void mb_map_reduce_2B__3 (void);
 static void mb_filter_4 (void);
 static void mb_filter_2B__3 (void);
 static void mb_filter_2B__4 (void);
 static void mb_filter_2B__5 (void);
 static void mb_filter_2B__6 (void);
 static void mb_filter_2B__8 (void);
 static void mb_filter_2B__9 (void);
 static void mb_filter_2B__11 (void);
 static void mb_filter_2B__10 (void);
 static void mb_filter_2B__12 (void);
 static void mb_filter_2B__13 (void);
 static void mb_find_4 (void);
 static void mb_find_2B__3 (void);
 static void mb_find_2B__4 (void);
 static void mb_find_2B__7 (void);
 static void mb_find_2B__9 (void);
 static void mb_find_2B__10 (void);
 static void mb_find_2B__12 (void);
 static void mb_find_2B__11 (void);
 static void mb_find_3F__2 (void);
 static void mb_find_3F__3 (void);
 static void mb_reverse_find_2 (void);
 static void mb_reverse_find_3F__2 (void);
 static void mb_reverse_find_3F__3 (void);
 static void mb_any_2 (void);
 static void mb_any_3F__2 (void);
 static void mb_all_2 (void);
 static void mb_all_3F__2 (void);
 static void mb_collect_2 (void);
 static void mb_collect_4 (void);
 static void mb_collect_3 (void);
 static void mb_maybe_filter_4 (void);
 static void mb_maybe_filter_5 (void);
 static void mb_char_bytes_1 (void);
 static void mb_char_bytes_12 (void);
 static void mb_char_bytes_2 (void);
 static void mb_char_bytes_10 (void);
 static void mb_char_bytes_3 (void);
 static void mb_char_bytes_7 (void);
 static void mb_char_bytes_4 (void);
 static void mb_char_bytes_5 (void);
 static void mb_char_bytes_6 (void);
 static void mb_char_bytes_8 (void);
 static void mb_char_bytes_9 (void);
 static void mb_char_bytes_11 (void);
 static void mb_char_valid_wobbly_1 (void);
 static void mb_char_valid_wobbly_6 (void);
 static void mb_char_valid_wobbly_2 (void);
 static void mb_char_valid_wobbly_5 (void);
 static void mb_char_valid_wobbly_3 (void);
 static void mb_char_valid_wobbly_4 (void);
 static void mb_char_codepoint_3_1 (void);
 static void mb_char_codepoint_3_2 (void);
 static void mb_char_valid_1 (void);
 static void mb_char_valid_6 (void);
 static void mb_char_valid_2 (void);
 static void mb_char_valid_5 (void);
 static void mb_char_valid_3 (void);
 static void mb_char_valid_4 (void);
 static void mb_char_codepoint_4_1 (void);
 static void mb_char_codepoint_4_2 (void);
 static void mb_char_codepoint_4_3 (void);
 static void mb_char_codepoint_2_1 (void);
 static void mb_char_21__precise_1 (void);
 static void mb_char_21__precise_2 (void);
 static void mb_char_21__precise_11 (void);
 static void mb_char_21__precise_3 (void);
 static void mb_char_21__precise_9 (void);
 static void mb_char_21__precise_4 (void);
 static void mb_char_21__precise_6 (void);
 static void mb_char_21__precise_5 (void);
 static void mb_char_21__precise_7 (void);
 static void mb_char_21__precise_8 (void);
 static void mb_char_21__precise_10 (void);
 static void mb_char_21__precise_12 (void);
 static void mb_char_21__2B__2B__1 (void);
 static void mb_char_3F__2B__2B__1 (void);
 static void mb_is_whitespace_3F__1 (void);
 static void mb_is_whitespace_3F__2 (void);
 static void mb_is_hexdigit_3F__1 (void);
 static void mb_is_hexdigit_3F__2 (void);
 static void mb_is_sign_3F__1 (void);
 static void mb_is_string_end_3F__1 (void);
 static void mb_is_string_end_3F__2 (void);
 static void mb_is_name_char_3F__1 (void);
 static void mb_is_special_char_3F__1 (void);
 static void mb_is_special_char_3F__2 (void);
 static void mb_path_21__1 (void);
 static void mb_path_separator_1 (void);
 static void mb_path_separator_2 (void);
 static void mb_path_join_1 (void);
 static void mb_path_join_2 (void);
 static void mb_input_isopen_21__1 (void);
 static void mb_input_isopen_21__2 (void);
 static void mb_input_fill_buffer_21__1 (void);
 static void mb_input_fill_buffer_21__2 (void);
 static void mb_input_fill_buffer_21__3 (void);
 static void mb_input_fill_buffer_21__4 (void);
 static void mb_input_fill_buffer_21__5 (void);
 static void mb_input_fill_buffer_21__6 (void);
 static void mb_input_end_21__1 (void);
 static void mb_input_end_21__2 (void);
 static void mb_input_peek_1 (void);
 static void mb_input_peek_2 (void);
 static void mb_input_move_21__1 (void);
 static void mb_input_move_21__2 (void);
 static void mb_input_prepare_for_more_21__1 (void);
 static void mb_input_prepare_for_more_21__2 (void);
 static void mb_input_prepare_for_more_21__3 (void);
 static void mb_input_prepare_for_more_21__6 (void);
 static void mb_input_prepare_for_more_21__4 (void);
 static void mb_input_prepare_for_more_21__5 (void);
 static void mb_input_fill_buffer_tragic_21__1 (void);
 static void mb_input_fill_buffer_tragic_21__2 (void);
 static void mb_input_fill_buffer_tragic_21__3 (void);
 static void mb_input_fill_buffer_tragic_21__4 (void);
 static void mb_input_fill_buffer_tragic_21__5 (void);
 static void mb_input_fill_buffer_tragic_21__6 (void);
 static void mb_lexer_stack_push_21__1 (void);
 static void mb_lexer_stack_push_21__2 (void);
 static void mb_lexer_stack_pop_21__1 (void);
 static void mb_lexer_stack_pop_21__2 (void);
 static void mb_module_source_path_1 (void);
 static void mb_module_source_path_2 (void);
 static void mb_lexer_next_21__1 (void);
 static void mb_lexer_next_21__26 (void);
 static void mb_lexer_next_21__2 (void);
 static void mb_lexer_next_21__25 (void);
 static void mb_lexer_next_21__3 (void);
 static void mb_lexer_next_21__24 (void);
 static void mb_lexer_next_21__4 (void);
 static void mb_lexer_next_21__23 (void);
 static void mb_lexer_next_21__5 (void);
 static void mb_lexer_next_21__22 (void);
 static void mb_lexer_next_21__6 (void);
 static void mb_lexer_next_21__21 (void);
 static void mb_lexer_next_21__7 (void);
 static void mb_lexer_next_21__20 (void);
 static void mb_lexer_next_21__8 (void);
 static void mb_lexer_next_21__19 (void);
 static void mb_lexer_next_21__9 (void);
 static void mb_lexer_next_21__18 (void);
 static void mb_lexer_next_21__10 (void);
 static void mb_lexer_next_21__17 (void);
 static void mb_lexer_next_21__11 (void);
 static void mb_lexer_next_21__16 (void);
 static void mb_lexer_next_21__12 (void);
 static void mb_lexer_next_21__15 (void);
 static void mb_lexer_next_21__13 (void);
 static void mb_lexer_next_21__14 (void);
 static void mb_emit_fatal_error_21__1 (void);
 static void mb_lexer_make_21__1 (void);
 static void mb_lexer_make_21__2 (void);
 static void mb_lexer_make_21__3 (void);
 static void mb_lexer_make_21__4 (void);
 static void mb_lexer_make_21__5 (void);
 static void mb_lexer_make_21__6 (void);
 static void mb_lexer_emit_fatal_error_21__1 (void);
 static void mb_lexer_emit_name_21__1 (void);
 static void mb_lexer_emit_name_21__4 (void);
 static void mb_lexer_emit_name_21__2 (void);
 static void mb_lexer_emit_name_21__3 (void);
 static void mb_lexer_emit_name_21__5 (void);
 static void mb_lexer_emit_name_21__8 (void);
 static void mb_lexer_emit_name_21__6 (void);
 static void mb_lexer_emit_name_21__7 (void);
 static void mb_lexer_skip_comment_21__1 (void);
 static void mb_lexer_skip_comment_21__2 (void);
 static void mb_lexer_skip_comment_21__3 (void);
 static void mb_lexer_skip_comment_21__4 (void);
 static void mb_lexer_emit_rparen_21__1 (void);
 static void mb_lexer_emit_rparen_21__4 (void);
 static void mb_lexer_emit_rparen_21__2 (void);
 static void mb_lexer_emit_rparen_21__3 (void);
 static void mb_lexer_emit_rsquare_21__1 (void);
 static void mb_lexer_emit_rsquare_21__4 (void);
 static void mb_lexer_emit_rsquare_21__2 (void);
 static void mb_lexer_emit_rsquare_21__3 (void);
 static void mb_lexer_emit_rcurly_21__1 (void);
 static void mb_lexer_emit_rcurly_21__4 (void);
 static void mb_lexer_emit_rcurly_21__2 (void);
 static void mb_lexer_emit_rcurly_21__3 (void);
 static void mb_lexer_emit_string_21__1 (void);
 static void mb_lexer_emit_string_21__4 (void);
 static void mb_lexer_emit_string_21__2 (void);
 static void mb_lexer_emit_string_21__3 (void);
 static void mb_str_buf_is_doc_start_3F__1 (void);
 static void mb_str_buf_is_doc_start_3F__2 (void);
 static void mb_str_buf_is_doc_start_3F__3 (void);
 static void mb_lexer_skip_doc_21__1 (void);
 static void mb_lexer_skip_doc_21__2 (void);
 static void mb_str_buf_is_int_3F__1 (void);
 static void mb_str_buf_is_int_3F__2 (void);
 static void mb_str_buf_int_3F__1 (void);
 static void mb_str_buf_int_3F__2 (void);
 static void mb_name_new_21__1 (void);
 static void mb_name_new_21__2 (void);
 static void mb_name_new_21__3 (void);
 static void mb_name_new_21__4 (void);
 static void mb_str_buf_is_arrow_3F__1 (void);
 static void mb_str_buf_is_dashes_3F__1 (void);
 static void mb_str_buf_is_dashes_3F__2 (void);
 static void mb_str_buf_is_equal_3F__1 (void);
 static void mb_str_buf_is_equal_3F__2 (void);
 static void mb_str_buf_is_dec_int_3F__1 (void);
 static void mb_str_buf_is_dec_int_3F__2 (void);
 static void mb_str_buf_is_dec_int_3F__3 (void);
 static void mb_str_buf_is_dec_int_3F__5 (void);
 static void mb_str_buf_is_dec_int_3F__4 (void);
 static void mb_str_buf_is_dec_int_3F__6 (void);
 static void mb_str_buf_is_dec_int_3F__7 (void);
 static void mb_str_buf_is_hex_int_3F__1 (void);
 static void mb_str_buf_is_hex_int_3F__2 (void);
 static void mb_str_buf_is_hex_int_3F__3 (void);
 static void mb_str_buf_is_hex_int_3F__4 (void);
 static void mb_str_buf_is_hex_int_3F__5 (void);
 static void mb_str_buf_is_hex_int_3F__6 (void);
 static void mb_str_buf_is_hex_int_3F__7 (void);
 static void mb_str_buf_is_hex_int_3F__9 (void);
 static void mb_str_buf_is_hex_int_3F__8 (void);
 static void mb_str_buf_is_hex_int_3F__10 (void);
 static void mb_str_buf_is_hex_int_3F__11 (void);
 static void mb_is_xX_char_1 (void);
 static void mb_str_buf_dec_int_3F__1 (void);
 static void mb_str_buf_dec_int_3F__2 (void);
 static void mb_str_buf_dec_int_3F__3 (void);
 static void mb_str_buf_dec_int_3F__4 (void);
 static void mb_str_buf_dec_int_3F__5 (void);
 static void mb_str_buf_dec_int_3F__6 (void);
 static void mb_str_buf_dec_int_3F__9 (void);
 static void mb_str_buf_dec_int_3F__7 (void);
 static void mb_str_buf_dec_int_3F__8 (void);
 static void mb_str_buf_hex_int_3F__1 (void);
 static void mb_str_buf_hex_int_3F__2 (void);
 static void mb_str_buf_hex_int_3F__3 (void);
 static void mb_str_buf_hex_int_3F__4 (void);
 static void mb_str_buf_hex_int_3F__5 (void);
 static void mb_str_buf_hex_int_3F__6 (void);
 static void mb_str_buf_hex_int_3F__9 (void);
 static void mb_str_buf_hex_int_3F__7 (void);
 static void mb_str_buf_hex_int_3F__8 (void);
 static void mb_hexdigit_value_1 (void);
 static void mb_hexdigit_value_4 (void);
 static void mb_hexdigit_value_2 (void);
 static void mb_hexdigit_value_3 (void);
 static void mb_lexer_push_string_char_21__1 (void);
 static void mb_lexer_push_string_char_21__2 (void);
 static void mb_lexer_push_string_char_21__3 (void);
 static void mb_lexer_push_string_char_21__14 (void);
 static void mb_lexer_push_string_char_21__4 (void);
 static void mb_lexer_push_string_char_21__13 (void);
 static void mb_lexer_push_string_char_21__5 (void);
 static void mb_lexer_push_string_char_21__12 (void);
 static void mb_lexer_push_string_char_21__6 (void);
 static void mb_lexer_push_string_char_21__11 (void);
 static void mb_lexer_push_string_char_21__7 (void);
 static void mb_lexer_push_string_char_21__10 (void);
 static void mb_lexer_push_string_char_21__8 (void);
 static void mb_lexer_push_string_char_21__9 (void);
 static void mb_lexer_emit_warning_21__1 (void);
 static void mb_lexer_comment_end_3F__1 (void);
 static void mb_lexer_comment_end_3F__2 (void);
 static void mb_emit_warning_at_21__1 (void);
 static void mb_lexer_emit_error_21__1 (void);
 static void mb_emit_error_at_21__1 (void);
 static void mb_hash_1 (void);
 static void mb_hash_3 (void);
 static void mb_hash_2 (void);
 static void mb_name_keep_going_3F__1 (void);
 static void mb_name_keep_going_3F__3 (void);
 static void mb_name_keep_going_3F__2 (void);
 static void mb_name_cat_21__1 (void);
 static void mb_name_is_type_hole_1 (void);
 static void mb_name_is_type_hole_2 (void);
 static void mb_name_is_type_hole_3 (void);
 static void mb_name_is_type_hole_4 (void);
 static void mb_name_is_underscore_1 (void);
 static void mb_name_is_underscore_2 (void);
 static void mb_name_could_be_stack_var_1 (void);
 static void mb_name_could_be_stack_var_2 (void);
 static void mb_name_could_be_effect_con_1 (void);
 static void mb_name_could_be_effect_con_2 (void);
 static void mb_name_mangle_21__1 (void);
 static void mb_name_mangle_21__2 (void);
 static void mb_name_mangle_21__3 (void);
 static void mb_name_mangle_compute_21__1 (void);
 static void mb_name_mangle_compute_21__2 (void);
 static void mb_name_mangle_compute_21__9 (void);
 static void mb_name_mangle_compute_21__3 (void);
 static void mb_name_mangle_compute_21__8 (void);
 static void mb_name_mangle_compute_21__4 (void);
 static void mb_name_mangle_compute_21__7 (void);
 static void mb_name_mangle_compute_21__5 (void);
 static void mb_name_mangle_compute_21__6 (void);
 static void mb_char_hexdigits_1 (void);
 static void mb_char_hexdigits_2 (void);
 static void mb_char_hexdigits_first_1 (void);
 static void mb_char_hexdigits_next_1 (void);
 static void mb_char_hexdigits_next_2 (void);
 static void mb_char_hexdigits_next_3 (void);
 static void mb_char_hexdigits_next_4 (void);
 static void mb_hexdigit_1 (void);
 static void mb_hexdigit_2 (void);
 static void mb_token_prim_3D__3F__1 (void);
 static void mb_token_prev_4 (void);
 static void mb_token_prev_5 (void);
 static void mb_token_next_arg_end_1 (void);
 static void mb_token_next_arg_end_2 (void);
 static void mb_token_has_args_3F__1 (void);
 static void mb_token_has_args_3F__2 (void);
 static void mb_token_num_args_1 (void);
 static void mb_token_num_args_2 (void);
 static void mb_token_num_args_3 (void);
 static void mb_token_num_args_4 (void);
 static void mb_token_num_args_5 (void);
 static void mb_token_num_args_6 (void);
 static void mb_token_num_args_7 (void);
 static void mb_token_num_args_8 (void);
 static void mb_token_num_args_10 (void);
 static void mb_token_num_args_9 (void);
 static void mb_token_args_0_1 (void);
 static void mb_token_args_0_2 (void);
 static void mb_token_args_1_1 (void);
 static void mb_token_args_1_4 (void);
 static void mb_token_args_1_2 (void);
 static void mb_token_args_1_3 (void);
 static void mb_token_args_1_5 (void);
 static void mb_token_args_1_6 (void);
 static void mb_token_args_2_1 (void);
 static void mb_token_args_2_4 (void);
 static void mb_token_args_2_2 (void);
 static void mb_token_args_2_3 (void);
 static void mb_token_args_2_5 (void);
 static void mb_token_args_2_6 (void);
 static void mb_token_args_3_1 (void);
 static void mb_token_args_3_4 (void);
 static void mb_token_args_3_2 (void);
 static void mb_token_args_3_3 (void);
 static void mb_token_args_3_5 (void);
 static void mb_token_args_3_6 (void);
 static void mb_token_args_1 (void);
 static void mb_token_args_2 (void);
 static void mb_token_args_3 (void);
 static void mb_token_args_4 (void);
 static void mb_token_args_5 (void);
 static void mb_token_args_7 (void);
 static void mb_token_args_6 (void);
 static void mb_token_is_args_end_3F__1 (void);
 static void mb_token_is_args_end_3F__2 (void);
 static void mb_emit_warning_21__1 (void);
 static void mb_emit_error_21__1 (void);
 static void mb_sig_is_stack_end_3F__1 (void);
 static void mb_sig_is_stack_end_3F__2 (void);
 static void mb_sig_is_stack_end2_3F__1 (void);
 static void mb_sig_is_stack_end2_3F__2 (void);
 static void mb_sig_next_stack_end_1 (void);
 static void mb_sig_next_stack_end_2 (void);
 static void mb_sig_arity_1 (void);
 static void mb_sig_arity_2 (void);
 static void mb_sig_count_types_1 (void);
 static void mb_sig_count_types_5 (void);
 static void mb_sig_count_types_2 (void);
 static void mb_sig_count_types_3 (void);
 static void mb_sig_count_types_4 (void);
 static void mb_sig_skip_dashes_1 (void);
 static void mb_sig_skip_dashes_2 (void);
 static void mb_module_add_import_21__1 (void);
 static void mb_set_insert_1 (void);
 static void mb_module_path_from_name_1 (void);
 static void mb_module_path_from_name_2 (void);
 static void mb_module_path_from_name_5 (void);
 static void mb_module_path_from_name_3 (void);
 static void mb_module_path_from_name_4 (void);
 static void mb_bag_replace_1 (void);
 static void mb_bag_replace_2 (void);
 static void mb_codegen_flush_21__1 (void);
 static void mb_codegen_flush_21__2 (void);
 static void mb_codegen_flush_21__3 (void);
 static void mb_codegen_flush_21__6 (void);
 static void mb_codegen_flush_21__4 (void);
 static void mb_codegen_flush_21__5 (void);
 static void mb__2E_b_1 (void);
 static void mb__2E_b_2 (void);
 static void mb__2E_c_1 (void);
 static void mb__2E_c_2 (void);
 static void mb__2E__1 (void);
 static void mb__2E__3 (void);
 static void mb__2E__2 (void);
 static void mb__2E__4 (void);
 static void mb__2E__6 (void);
 static void mb__2E__5 (void);
 static void mb_run_output_c99_21__1 (void);
 static void mb_run_output_c99_21__2 (void);
 static void mb_c99_emit_tags_21__1 (void);
 static void mb_c99_emit_buffers_21__1 (void);
 static void mb_c99_emit_externals_21__1 (void);
 static void mb_c99_emit_word_sigs_21__1 (void);
 static void mb_c99_emit_block_sigs_21__1 (void);
 static void mb_c99_emit_field_sigs_21__1 (void);
 static void mb_c99_emit_needs_21__1 (void);
 static void mb_c99_emit_needs_21__4 (void);
 static void mb_c99_emit_tag_21__1 (void);
 static void mb_c99_emit_tag_21__6 (void);
 static void mb_c99_emit_tag_21__2 (void);
 static void mb_c99_emit_tag_21__5 (void);
 static void mb_c99_emit_tag_21__3 (void);
 static void mb_c99_emit_tag_21__4 (void);
 static void mb_tag_num_inputs_3F__1 (void);
 static void mb_tag_num_inputs_3F__2 (void);
 static void mb_tag_num_inputs_3F__3 (void);
 static void mb_tag_num_inputs_3F__5 (void);
 static void mb_tag_num_inputs_3F__4 (void);
 static void mb_c99_emit_external_21__1 (void);
 static void mb_c99_emit_external_21__4 (void);
 static void mb_c99_emit_external_21__2 (void);
 static void mb_c99_emit_external_21__3 (void);
 static void mb_c99_emit_external_21__5 (void);
 static void mb_c99_emit_external_21__6 (void);
 static void mb_c99_emit_external_21__7 (void);
 static void mb_c99_emit_external_21__8 (void);
 static void mb_c99_emit_external_21__9 (void);
 static void mb_c99_emit_external_21__10 (void);
 static void mb_c99_emit_external_21__11 (void);
 static void mb_c99_emit_external_21__12 (void);
 static void mb_c99_emit_external_21__13 (void);
 static void mb_c99_emit_external_21__14 (void);
 static void mb_c99_emit_external_21__15 (void);
 static void mb_c99_emit_external_21__16 (void);
 static void mb_c99_emit_external_21__17 (void);
 static void mb_c99_emit_external_21__18 (void);
 static void mb_c99_emit_external_21__19 (void);
 static void mb_c99_emit_external_21__20 (void);
 static void mb_c99_emit_external_21__21 (void);
 static void mb_c99_emit_external_21__22 (void);
 static void mb_c99_emit_arrow_21__1 (void);
 static void mb_c99_emit_atom_21__5 (void);
 static void mb_c99_emit_atom_21__8 (void);
 static void mb_c99_emit_atom_21__12 (void);
 static void mb_c99_emit_string_21__1 (void);
 static void mb_need_word_21__1 (void);
 static void mb_need_word_21__2 (void);
 static void mb_c99_emit_args_push_21__1 (void);
 static void mb_fieldword_name_40__1 (void);
 static void mb_c99_emit_prim_21__6 (void);
 static void mb_c99_emit_prim_21__10 (void);
 static void mb_c99_emit_match_21__1 (void);
 static void mb_c99_emit_match_21__5 (void);
 static void mb_c99_emit_match_21__2 (void);
 static void mb_c99_emit_match_21__3 (void);
 static void mb_c99_emit_match_21__4 (void);
 static void mb_c99_emit_lambda_21__1 (void);
 static void mb_c99_emit_lambda_21__2 (void);
 static void mb_c99_emit_var_21__1 (void);
 static void mb_c99_emit_var_21__2 (void);
 static void mb_c99_emit_var_21__3 (void);
 static void mb_c99_emit_string_char_21__1 (void);
 static void mb_c99_emit_string_char_21__13 (void);
 static void mb_c99_emit_string_char_21__2 (void);
 static void mb_c99_emit_string_char_21__12 (void);
 static void mb_c99_emit_string_char_21__3 (void);
 static void mb_c99_emit_string_char_21__11 (void);
 static void mb_c99_emit_string_char_21__4 (void);
 static void mb_c99_emit_string_char_21__10 (void);
 static void mb_c99_emit_string_char_21__5 (void);
 static void mb_c99_emit_string_char_21__9 (void);
 static void mb_c99_emit_string_char_21__6 (void);
 static void mb_c99_emit_string_char_21__8 (void);
 static void mb_c99_emit_string_char_21__7 (void);
 static void mb_c99_emit_prim_default_21__1 (void);
 static void mb_c99_pack_ctx_21__1 (void);
 static void mb_ctx_physical_vars_1 (void);
 static void mb_c99_unpack_ctx_21__1 (void);
 static void mb_c99_decref_ctx_21__1 (void);
 static void mb_need_block_21__1 (void);
 static void mb_need_block_21__2 (void);
 static void mb_need_field_21__1 (void);
 static void mb_need_field_21__2 (void);
 static void mb_c99_emit_word_def_21__1 (void);
 static void mb_c99_emit_word_def_21__2 (void);
 static void mb_c99_emit_word_def_21__3 (void);
 static void mb_c99_emit_word_def_21__4 (void);
 static void mb_c99_emit_block_def_21__1 (void);
 static void mb_c99_emit_block_def_21__2 (void);
 static void mb_c99_emit_block_def_21__3 (void);
 static void mb_c99_emit_block_def_21__4 (void);
 static void mb_c99_emit_field_def_21__1 (void);
 static void mb_c99_emit_field_def_21__2 (void);
 static void mb_c99_emit_field_def_21__3 (void);
 static void mb_c99_emit_field_def_21__4 (void);
 static void mb__2E_block_1 (void);
 static void mb__2E_block_2 (void);
 static void mb_c99_emit_pattern_21__3 (void);
 static void mb_c99_emit_pattern_21__4 (void);
 static void mb_c99_emit_pattern_21__5 (void);
 static void mb_c99_emit_pattern_21__6 (void);
 static void mb_c99_emit_block_defs_21__1 (void);
 static void mb_force_4 (void);
 static void mb_atom_arg_add_21__1 (void);
 static void mb_arrow_atom_add_21__1 (void);
 static void mb_block_force_21__1 (void);
 static void mb_block_force_21__2 (void);
 static void mb_block_force_21__3 (void);
 static void mb_block_force_21__6 (void);
 static void mb_block_force_21__4 (void);
 static void mb_block_force_21__5 (void);
 static void mb_ab_build_21__2 (void);
 static void mb_elab_atoms_21__1 (void);
 static void mb_elab_atoms_21__2 (void);
 static void mb_block_unify_type_21__1 (void);
 static void mb_block_unify_type_21__2 (void);
 static void mb_block_unify_type_21__3 (void);
 static void mb_block_unify_type_21__4 (void);
 static void mb_block_unify_type_aux_21__1 (void);
 static void mb_block_unify_type_aux_21__2 (void);
 static void mb_block_unify_type_aux_21__3 (void);
 static void mb_block_unify_type_aux_21__4 (void);
 static void mb_block_unify_type_aux_21__5 (void);
 static void mb_type_unify_21__8 (void);
 static void mb_type_unify_21__14 (void);
 static void mb_type_unify_21__16 (void);
 static void mb_type_unify_21__19 (void);
 static void mb_type_unify_21__24 (void);
 static void mb_type_unify_21__26 (void);
 static void mb_type_unify_21__28 (void);
 static void mb_type_unify_21__31 (void);
 static void mb_type_unify_21__36 (void);
 static void mb_type_unify_21__38 (void);
 static void mb_type_unify_21__40 (void);
 static void mb_type_unify_21__43 (void);
 static void mb_type_unify_21__48 (void);
 static void mb_type_unify_21__50 (void);
 static void mb_type_unify_21__52 (void);
 static void mb_type_unify_21__55 (void);
 static void mb_type_unify_21__60 (void);
 static void mb_type_unify_21__62 (void);
 static void mb_type_unify_21__64 (void);
 static void mb_type_unify_21__67 (void);
 static void mb_type_unify_21__72 (void);
 static void mb_type_unify_21__74 (void);
 static void mb_type_unify_21__76 (void);
 static void mb_type_unify_21__79 (void);
 static void mb_type_unify_21__84 (void);
 static void mb_type_unify_21__86 (void);
 static void mb_type_unify_21__88 (void);
 static void mb_type_unify_21__91 (void);
 static void mb_type_unify_21__96 (void);
 static void mb_type_unify_21__98 (void);
 static void mb_elab_expand_morphism_21__2 (void);
 static void mb_elab_expand_morphism_21__5 (void);
 static void mb_elab_expand_morphism_21__7 (void);
 static void mb_match_add_case_21__1 (void);
 static void mb_match_add_case_21__2 (void);
 static void mb_match_add_case_21__3 (void);
 static void mb_match_is_exhaustive_3F__1 (void);
 static void mb_match_is_exhaustive_3F__4 (void);
 static void mb_match_scrutinee_data_3F__1 (void);
 static void mb_cases_have_default_case_1 (void);
 static void mb_cases_cover_case_1 (void);
 static void mb_case_is_covered_1 (void);
 static void mb_pattern_is_covered_1 (void);
 static void mb_pattern_is_covered_2 (void);
 static void mb_def_type_21__1 (void);
 static void mb_T1_1 (void);
 static void mb_T2_1 (void);
 static void mb_T3_1 (void);
 static void mb_T4_1 (void);
 static void mb_T5_1 (void);
 static void mb_T6_1 (void);
 static void mb_meta_expand_1 (void);
 static void mb_meta_expand_2 (void);
 static void mb_meta_expand_3 (void);
 static void mb_type_unify_failed_21__1 (void);
 static void mb_type_unify_failed_21__2 (void);
 static void mb_type_hole_unify_21__1 (void);
 static void mb_type_hole_unify_21__2 (void);
 static void mb_meta_unify_21__1 (void);
 static void mb_meta_unify_21__7 (void);
 static void mb_meta_unify_21__2 (void);
 static void mb_meta_unify_21__6 (void);
 static void mb_meta_unify_21__3 (void);
 static void mb_meta_unify_21__5 (void);
 static void mb_meta_unify_21__4 (void);
 static void mb_type_var_unify_21__1 (void);
 static void mb_type_var_unify_21__3 (void);
 static void mb_type_var_unify_21__2 (void);
 static void mb_type_prim_unify_21__1 (void);
 static void mb_type_prim_unify_21__3 (void);
 static void mb_type_prim_unify_21__2 (void);
 static void mb_type_data_unify_21__1 (void);
 static void mb_type_data_unify_21__3 (void);
 static void mb_type_data_unify_21__2 (void);
 static void mb_type_table_unify_21__1 (void);
 static void mb_type_table_unify_21__3 (void);
 static void mb_type_table_unify_21__2 (void);
 static void mb_type_unify_pair_21__1 (void);
 static void mb_type_unify_pair_21__2 (void);
 static void mb_type_unify_pair_21__3 (void);
 static void mb_value_unify_21__3 (void);
 static void mb_value_unify_21__4 (void);
 static void mb_value_unify_21__9 (void);
 static void mb_value_unify_21__10 (void);
 static void mb_value_unify_21__15 (void);
 static void mb_value_unify_21__16 (void);
 static void mb_type_has_meta_8 (void);
 static void mb_type_has_meta_9 (void);
 static void mb_type_has_meta_10 (void);
 static void mb_type_has_meta_12 (void);
 static void mb_type_has_meta_13 (void);
 static void mb_type_has_meta_14 (void);
 static void mb_type_has_meta_16 (void);
 static void mb_type_has_meta_17 (void);
 static void mb_type_has_meta_18 (void);
 static void mb_type_trace_stack_dom_21__1 (void);
 static void mb_type_trace_stack_dom_21__2 (void);
 static void mb_type_trace_stack_cod_21__1 (void);
 static void mb_type_trace_stack_cod_21__2 (void);
 static void mb_type_trace_stack_21__3 (void);
 static void mb_type_trace_stack_21__4 (void);
 static void mb_type_semifreshen_sig_1 (void);
 static void mb_type_semifreshen_sig_2 (void);
 static void mb_type_sig_needs_fresh_stack_rest_3F__2 (void);
 static void mb_type_sig_needs_fresh_stack_rest_3F__3 (void);
 static void mb_type_semifreshen_sig_aux_2 (void);
 static void mb_type_semifreshen_sig_aux_3 (void);
 static void mb_type_semifreshen_sig_stack_2 (void);
 static void mb_type_freshen_sig_1 (void);
 static void mb_type_freshen_sig_2 (void);
 static void mb_type_freshen_sig_aux_2 (void);
 static void mb_type_freshen_sig_aux_3 (void);
 static void mb_type_freshen_sig_aux_4 (void);
 static void mb_type_freshen_sig_stack_2 (void);
 static void mb_type_freshen_sig_stack_3 (void);
 static void mb_type_var_freshen_1 (void);
 static void mb_type_var_freshen_3 (void);
 static void mb_type_var_freshen_2 (void);
 static void mb_meta_freshen_1 (void);
 static void mb_meta_freshen_2 (void);
 static void mb_type_pair_freshen_1 (void);
 static void mb_type_pair_freshen_2 (void);
 static void mb_type_max_count_3F__4 (void);
 static void mb_type_max_count_3F__5 (void);
 static void mb_data_is_enum_3F__1 (void);
 static void mb_map_insert_1 (void);
 static void mb_map_lookup_1 (void);
 static void mb_subst_match_var_1 (void);
 static void mb_subst_match_var_2 (void);
 static void mb_subst_match_var_3 (void);
 static void mb_data_add_tag_21__1 (void);
 static void mb_map_keys_1 (void);
 static void mb_map_values_1 (void);
 static void mb_order2_1 (void);
 static void mb_order2_2 (void);
 static void mb_order3_1 (void);
 static void mb_order3_2 (void);
 static void mb_order3_4 (void);
 static void mb_order3_3 (void);
 static void mb_Bag__3E_Bag_2B__1 (void);
 static void mb_bag_split_half_left_1 (void);
 static void mb_bag_split_half_right_1 (void);
 static void mb_bag_split_half_1 (void);
 static void mb_bag_unsnoc_1 (void);
 static void mb_bag_insert_2B__2B__1 (void);
 static void mb_bag_insert_2B__2B__6 (void);
 static void mb_bag_insert_2B__2B__2 (void);
 static void mb_bag_insert_2B__2B__3 (void);
 static void mb_bag_insert_2B__2B__5 (void);
 static void mb_bag_insert_2B__2B__4 (void);
 static void mb_bag_insert_2B__2B__7 (void);
 static void mb_bag_has_2B__1 (void);
 static void mb_bag_has_2B__7 (void);
 static void mb_bag_has_2B__2 (void);
 static void mb_bag_has_2B__6 (void);
 static void mb_bag_has_2B__8 (void);
 static void mb_bag_cat_unsafe__2B__1 (void);
 static void mb_bag_cat_unsafe_2B__1 (void);
 static void mb_bag_cat_unsafe_1 (void);
 static void mb_bag_lookup_key_2B__1 (void);
 static void mb_bag_lookup_key_2B__9 (void);
 static void mb_bag_lookup_key_2B__2 (void);
 static void mb_bag_lookup_key_2B__4 (void);
 static void mb_bag_lookup_key_2B__6 (void);
 static void mb_bag_lookup_key_2B__8 (void);
 static void mb_bag_lookup_key_2B__10 (void);
 static void mb_bag_lookup_key_2B__11 (void);
 static void mb_bag_lookup_key_2B__12 (void);
 static void mb_bag_replace_key_2B__2B__1 (void);
 static void mb_bag_replace_key_2B__2B__6 (void);
 static void mb_bag_replace_key_2B__2B__2 (void);
 static void mb_bag_replace_key_2B__2B__3 (void);
 static void mb_bag_replace_key_2B__2B__5 (void);
 static void mb_bag_replace_key_2B__2B__4 (void);
 static void mb_bag_replace_key_2B__2B__7 (void);
 static void mb_bag_replace_key_2B__2B__8 (void);
 static void mb_bag_replace_key_2B__2B__9 (void);
 static void mb__3D__3D_key_1 (void);
 static void mb__3C__3D_key_1 (void);
 static void mb_delay0_1 (void);
 static void mb_delay2_1 (void);
 static void mb_delay3_1 (void);
 static void mb_delay4_1 (void);
 static void mb_lazy_map_1 (void);
 static void mb_lazy_map_2 (void);
 static void mb_lazy_map2_1 (void);
 static void mb_lazy_map2_2 (void);
 static void mb_lazy_map2_3 (void);
 static void mb_lazy_bind_1 (void);
 static void mb_lazy_bind_2 (void);
 static void mb_var_is_physical_3F__1 (void);
 static void mb_var_is_physical_3F__2 (void);
 static void mb_var_is_physical_3F__3 (void);
 static void mb_type_elab_stack_assertion_1 (void);
 static void mb_elab_type_sig_21__1 (void);
 static void mb_elab_type_sig_21__3 (void);
 static void mb_elab_type_sig_21__2 (void);
 static void mb_elab_type_sig_21__4 (void);
 static void mb_elab_type_sig_21__5 (void);
 static void mb_elab_type_sig_21__6 (void);
 static void mb_elab_type_sig_21__7 (void);
 static void mb_elab_type_stack_21__1 (void);
 static void mb_elab_type_stack_21__3 (void);
 static void mb_elab_type_stack_21__2 (void);
 static void mb_elab_type_stack_21__4 (void);
 static void mb_elab_type_stack_rest_21__1 (void);
 static void mb_elab_type_stack_rest_21__4 (void);
 static void mb_elab_type_stack_rest_21__2 (void);
 static void mb_elab_type_stack_rest_21__3 (void);
 static void mb_elab_type_atom_21__1 (void);
 static void mb_elab_type_atom_21__11 (void);
 static void mb_elab_type_atom_21__2 (void);
 static void mb_elab_type_atom_21__10 (void);
 static void mb_elab_type_atom_21__3 (void);
 static void mb_elab_type_atom_21__9 (void);
 static void mb_elab_type_atom_21__4 (void);
 static void mb_elab_type_atom_21__8 (void);
 static void mb_elab_type_atom_21__5 (void);
 static void mb_elab_type_atom_21__7 (void);
 static void mb_elab_type_atom_21__6 (void);
 static void mb_elab_type_atom_21__12 (void);
 static void mb_elab_type_arg_21__1 (void);
 static void mb_elab_type_arg_21__2 (void);
 static void mb_elab_type_con_21__2 (void);
 static void mb_elab_type_con_21__3 (void);
 static void mb_elab_type_dont_care_21__1 (void);
 static void mb_elab_type_dont_care_21__2 (void);
 static void mb_elab_type_dont_care_21__3 (void);
 static void mb_elab_type_dont_care_21__4 (void);
 static void mb_elab_type_dont_care_21__5 (void);
 static void mb_elab_type_hole_21__1 (void);
 static void mb_elab_type_hole_21__2 (void);
 static void mb_elab_type_hole_21__3 (void);
 static void mb_elab_type_hole_21__4 (void);
 static void mb_elab_type_hole_21__5 (void);
 static void mb_elab_type_quote_21__1 (void);
 static void mb_elab_type_quote_21__2 (void);
 static void mb_elab_implicit_var_21__1 (void);
 static void mb_elab_implicit_var_21__2 (void);
 static void mb_elab_implicit_var_21__4 (void);
 static void mb_elab_implicit_var_21__6 (void);
 static void mb_elab_implicit_var_21__7 (void);
 static void mb_elab_implicit_var_21__8 (void);
 static void mb_elab_implicit_var_21__9 (void);
 static void mb_ctx_lookup_1 (void);
 static void mb_elab_type_unify_21__1 (void);
 static void mb_ctx_new_21__1 (void);
 static void mb_elab_type_args_21__1 (void);
 static void mb_elab_type_args_21__2 (void);
 static void mb_elab_type_args_21__3 (void);
 static void mb_elab_type_args_21__4 (void);
 static void mb_elab_type_args_21__5 (void);
 static void mb_elab_type_args_21__8 (void);
 static void mb_elab_type_args_21__6 (void);
 static void mb_elab_type_args_21__7 (void);
 static void mb_elab_type_args_21__9 (void);
 static void mb_elab_simple_type_arg_21__1 (void);
 static void mb_ab_save_21__2 (void);
 static void mb_ab_build_word_21__2 (void);
 static void mb_ab_build_word_21__3 (void);
 static void mb_ab_build_word_21__4 (void);
 static void mb_ab_build_word_21__5 (void);
 static void mb_ab_build_word_21__6 (void);
 static void mb_ab_unify_type_21__1 (void);
 static void mb_ab_atom_21__1 (void);
 static void mb_ab_optimized_snoc_21__1 (void);
 static void mb_ab_optimized_snoc_21__2 (void);
 static void mb_ab_optimized_snoc_21__3 (void);
 static void mb_ab_optimized_snoc_21__4 (void);
 static void mb_atom_accepts_args_3F__2 (void);
 static void mb_atoms_turn_last_block_to_arg_4 (void);
 static void mb_atom_to_run_var_2 (void);
 static void mb_atom_to_run_var_3 (void);
 static void mb_ab_op_21__1 (void);
 static void mb_ab_op_21__2 (void);
 static void mb_ab_expand_opsig_21__3 (void);
 static void mb_ab_expand_opsig_21__5 (void);
 static void mb_ab_expand_opsig_21__6 (void);
 static void mb_ab_prim_21__1 (void);
 static void mb_ab_prim_21__2 (void);
 static void mb_ab_block_at_21__2 (void);
 static void mb_ab_block_at_21__3 (void);
 static void mb_ab_block_21__2 (void);
 static void mb_ab_dip_21__2 (void);
 static void mb_ab_if_21__1 (void);
 static void mb_ab_while_21__1 (void);
 static void mb_ab_lambda_21__2 (void);
 static void mb_ab_lambda_21__3 (void);
 static void mb_ab_lambda_21__4 (void);
 static void mb_ab_lambda_21__5 (void);
 static void mb_ab_lambda_21__6 (void);
 static void mb_elab_expand_tensor_21__2 (void);
 static void mb_elab_expand_tensor_21__5 (void);
 static void mb_elab_expand_tensor_21__7 (void);
 static void mb_elab_field_word_type_21__1 (void);
 static void mb_elab_field_word_type_21__3 (void);
 static void mb_elab_field_word_type_21__5 (void);
 static void mb_elab_var_sig_21__1 (void);
 static void mb_elab_var_sig_21__2 (void);
 static void mb_elab_tag_ctx_sig_21__1 (void);
 static void mb_elab_tag_ctx_sig_21__9 (void);
 static void mb_elab_tag_ctx_sig_21__2 (void);
 static void mb_elab_tag_ctx_sig_21__3 (void);
 static void mb_elab_tag_ctx_sig_21__4 (void);
 static void mb_elab_tag_ctx_sig_21__5 (void);
 static void mb_elab_tag_ctx_sig_21__6 (void);
 static void mb_elab_tag_ctx_sig_21__7 (void);
 static void mb_elab_tag_ctx_sig_21__8 (void);
 static void mb_elab_tag_ctx_sig_21__10 (void);
 static void mb_elab_external_ctx_sig_21__1 (void);
 static void mb_elab_external_ctx_sig_21__5 (void);
 static void mb_elab_external_ctx_sig_21__2 (void);
 static void mb_elab_external_ctx_sig_21__3 (void);
 static void mb_elab_external_ctx_sig_21__4 (void);
 static void mb_elab_external_ctx_sig_21__6 (void);
 static void mb_elab_arrow_hom_21__1 (void);
 static void mb_elab_arrow_fwd_21__1 (void);
 static void mb_elab_args_21__1 (void);
 static void mb_elab_lambda_params_21__1 (void);
 static void mb_elab_lambda_params_21__2 (void);
 static void mb_elab_lambda_params_21__3 (void);
 static void mb_elab_lambda_params_21__13 (void);
 static void mb_elab_lambda_params_21__4 (void);
 static void mb_elab_lambda_params_21__5 (void);
 static void mb_elab_lambda_params_21__9 (void);
 static void mb_elab_lambda_params_21__6 (void);
 static void mb_elab_lambda_params_21__7 (void);
 static void mb_elab_lambda_params_21__8 (void);
 static void mb_elab_lambda_params_21__10 (void);
 static void mb_elab_lambda_params_21__11 (void);
 static void mb_elab_lambda_params_21__12 (void);
 static void mb_elab_lambda_body_21__1 (void);
 static void mb_elab_lambda_body_21__2 (void);
 static void mb_elab_lambda_body_21__3 (void);
 static void mb_elab_lambda_body_21__4 (void);
 static void mb_elab_lambda_pop_from_mid_21__1 (void);
 static void mb_elab_lambda_pop_from_mid_21__2 (void);
 static void mb_token_is_lambda_param_3F__1 (void);
 static void mb_token_is_lambda_param_3F__6 (void);
 static void mb_token_is_lambda_param_3F__2 (void);
 static void mb_token_is_lambda_param_3F__3 (void);
 static void mb_token_is_lambda_param_3F__4 (void);
 static void mb_token_is_lambda_param_3F__5 (void);
 static void mb_expect_token_arrow_1 (void);
 static void mb_expect_token_arrow_2 (void);
 static void mb_elab_match_cases_21__1 (void);
 static void mb_elab_match_cases_21__2 (void);
 static void mb_elab_match_cases_21__3 (void);
 static void mb_elab_match_cases_21__4 (void);
 static void mb_elab_match_exhaustive_21__1 (void);
 static void mb_elab_match_exhaustive_21__2 (void);
 static void mb_elab_match_case_21__1 (void);
 static void mb_elab_match_case_21__2 (void);
 static void mb_elab_match_case_21__3 (void);
 static void mb_elab_match_case_21__4 (void);
 static void mb_elab_case_pattern_21__1 (void);
 static void mb_elab_case_pattern_21__13 (void);
 static void mb_elab_case_pattern_21__2 (void);
 static void mb_elab_case_pattern_21__3 (void);
 static void mb_elab_case_pattern_21__5 (void);
 static void mb_elab_case_pattern_21__6 (void);
 static void mb_elab_case_pattern_21__7 (void);
 static void mb_elab_case_pattern_21__8 (void);
 static void mb_elab_case_pattern_21__9 (void);
 static void mb_elab_case_pattern_21__10 (void);
 static void mb_elab_case_pattern_21__14 (void);
 static void mb_elab_case_pattern_21__15 (void);
 static void mb_elab_case_pattern_21__16 (void);
 static void mb_elab_case_body_21__1 (void);
 static void mb_elab_case_body_21__2 (void);
 static void mb_elab_case_body_21__3 (void);
 static void mb_elab_case_body_21__4 (void);
 static void mb_elab_case_body_21__5 (void);
 static void mb_elab_module_header_21__1 (void);
 static void mb_elab_module_header_21__2 (void);
 static void mb_elab_module_header_21__3 (void);
 static void mb_elab_module_header_21__4 (void);
 static void mb_elab_module_header_21__5 (void);
 static void mb_elab_module_header_21__6 (void);
 static void mb_elab_module_header_21__7 (void);
 static void mb_elab_module_header_21__8 (void);
 static void mb_elab_module_decl_21__3 (void);
 static void mb_elab_module_decl_21__4 (void);
 static void mb_elab_module_import_21__1 (void);
 static void mb_elab_module_import_21__4 (void);
 static void mb_elab_module_import_21__6 (void);
 static void mb_elab_data_21__1 (void);
 static void mb_elab_data_21__2 (void);
 static void mb_elab_data_21__3 (void);
 static void mb_elab_data_header_21__1 (void);
 static void mb_elab_data_header_21__2 (void);
 static void mb_elab_data_header_21__3 (void);
 static void mb_elab_data_header_21__4 (void);
 static void mb_elab_data_tag_21__1 (void);
 static void mb_elab_data_tag_21__2 (void);
 static void mb_elab_data_tag_21__3 (void);
 static void mb_elab_data_tag_21__4 (void);
 static void mb_elab_data_tag_21__5 (void);
 static void mb_elab_data_tag_21__6 (void);
 static void mb_elab_data_tag_21__7 (void);
 static void mb_elab_data_tag_21__10 (void);
 static void mb_elab_data_tag_21__8 (void);
 static void mb_elab_data_tag_21__9 (void);
 static void mb_elab_data_tag_21__11 (void);
 static void mb_elab_data_tag_21__12 (void);
 static void mb_elab_data_tag_21__13 (void);
 static void mb_elab_data_tag_21__14 (void);
 static void mb_expect_token_comma_1 (void);
 static void mb_expect_token_comma_2 (void);
 static void mb_expect_token_rparen_1 (void);
 static void mb_expect_token_rparen_2 (void);
 static void mb_elab_def_21__1 (void);
 static void mb_elab_def_21__2 (void);
 static void mb_elab_def_21__3 (void);
 static void mb_elab_def_21__4 (void);
 static void mb_elab_def_21__5 (void);
 static void mb_elab_def_21__6 (void);
 static void mb_elab_def_21__7 (void);
 static void mb_elab_def_21__8 (void);
 static void mb_elab_def_21__9 (void);
 static void mb_elab_def_21__10 (void);
 static void mb_elab_def_21__11 (void);
 static void mb_elab_def_21__12 (void);
 static void mb_elab_def_external_21__1 (void);
 static void mb_elab_def_external_21__2 (void);
 static void mb_elab_def_external_21__3 (void);
 static void mb_elab_def_external_21__4 (void);
 static void mb_elab_def_external_21__5 (void);
 static void mb_elab_def_type_21__1 (void);
 static void mb_elab_def_type_21__2 (void);
 static void mb_elab_def_type_21__3 (void);
 static void mb_elab_def_type_21__4 (void);
 static void mb_elab_def_type_21__5 (void);
 static void mb_elab_buffer_21__1 (void);
 static void mb_elab_buffer_21__2 (void);
 static void mb_elab_buffer_21__3 (void);
 static void mb_elab_buffer_21__4 (void);
 static void mb_elab_buffer_21__5 (void);
 static void mb_elab_table_21__1 (void);
 static void mb_elab_table_21__2 (void);
 static void mb_elab_table_21__3 (void);
 static void mb_table_new_21__1 (void);
 static void mb_table_new_21__2 (void);
 static void mb_table_new_21__3 (void);
 static void mb_table_new_21__4 (void);
 static void mb_table_new_21__5 (void);
 static void mb_table_new_21__6 (void);
 static void mb_table_new_21__9 (void);
 static void mb_table_new_21__10 (void);
 static void mb_table_new_21__11 (void);
 static void mb_table_new_21__13 (void);
 static void mb_table_new_21__12 (void);
 static void mb_table_new_21__14 (void);
 static void mb_elab_target_c99_21__1 (void);
 static void mb_elab_target_c99_21__2 (void);
 static void mb_elab_target_c99_21__3 (void);
 static void mb_elab_field_21__1 (void);
 static void mb_elab_field_sig_21__1 (void);
 static void mb_elab_field_sig_21__4 (void);
 static void mb_name_prim_3D__1 (void);
 static void mb_def_prim_21__1 (void);

 static void mwname_str_40_ (void);
 static void mwname_str_3F_ (void);
 static void mwname_str_21_ (void);
 static void mwname_def_40_ (void);
 static void mwname_def_3F_ (void);
 static void mwname_def_21_ (void);
 static void mwname_mangle_cached_40_ (void);
 static void mwname_mangle_cached_3F_ (void);
 static void mwname_mangle_cached_21_ (void);
 static void mwmodule_name_40_ (void);
 static void mwmodule_name_3F_ (void);
 static void mwmodule_name_21_ (void);
 static void mwmodule_path_40_ (void);
 static void mwmodule_path_3F_ (void);
 static void mwmodule_path_21_ (void);
 static void mwmodule_start_40_ (void);
 static void mwmodule_start_3F_ (void);
 static void mwmodule_start_21_ (void);
 static void mwmodule_end_40_ (void);
 static void mwmodule_end_3F_ (void);
 static void mwmodule_end_21_ (void);
 static void mwmodule_imports_40_ (void);
 static void mwmodule_imports_3F_ (void);
 static void mwmodule_imports_21_ (void);
 static void mwtoken_value_40_ (void);
 static void mwtoken_value_3F_ (void);
 static void mwtoken_value_21_ (void);
 static void mwtoken_module_40_ (void);
 static void mwtoken_module_3F_ (void);
 static void mwtoken_module_21_ (void);
 static void mwtoken_row_40_ (void);
 static void mwtoken_row_3F_ (void);
 static void mwtoken_row_21_ (void);
 static void mwtoken_col_40_ (void);
 static void mwtoken_col_3F_ (void);
 static void mwtoken_col_21_ (void);
 static void mwbuffer_size_40_ (void);
 static void mwbuffer_size_3F_ (void);
 static void mwbuffer_size_21_ (void);
 static void mwbuffer_name_40_ (void);
 static void mwbuffer_name_3F_ (void);
 static void mwbuffer_name_21_ (void);
 static void mwmeta_is_defined_40_ (void);
 static void mwmeta_is_defined_3F_ (void);
 static void mwmeta_is_defined_21_ (void);
 static void mwmeta_type_raw_40_ (void);
 static void mwmeta_type_raw_3F_ (void);
 static void mwmeta_type_raw_21_ (void);
 static void mwdata_header_40_ (void);
 static void mwdata_header_3F_ (void);
 static void mwdata_header_21_ (void);
 static void mwdata_name_40_ (void);
 static void mwdata_name_3F_ (void);
 static void mwdata_name_21_ (void);
 static void mwdata_arity_40_ (void);
 static void mwdata_arity_3F_ (void);
 static void mwdata_arity_21_ (void);
 static void mwdata_tags_40_ (void);
 static void mwdata_tags_3F_ (void);
 static void mwdata_tags_21_ (void);
 static void mwtag_data_40_ (void);
 static void mwtag_data_3F_ (void);
 static void mwtag_data_21_ (void);
 static void mwtag_name_40_ (void);
 static void mwtag_name_3F_ (void);
 static void mwtag_name_21_ (void);
 static void mwtag_value_40_ (void);
 static void mwtag_value_3F_ (void);
 static void mwtag_value_21_ (void);
 static void mwtag_sig_40_ (void);
 static void mwtag_sig_3F_ (void);
 static void mwtag_sig_21_ (void);
 static void mwtag_has_sig_40_ (void);
 static void mwtag_has_sig_3F_ (void);
 static void mwtag_has_sig_21_ (void);
 static void mwtag_sig_is_checked_40_ (void);
 static void mwtag_sig_is_checked_3F_ (void);
 static void mwtag_sig_is_checked_21_ (void);
 static void mwtag_ctx_40_ (void);
 static void mwtag_ctx_3F_ (void);
 static void mwtag_ctx_21_ (void);
 static void mwtag_type_raw_40_ (void);
 static void mwtag_type_raw_3F_ (void);
 static void mwtag_type_raw_21_ (void);
 static void mwarrow_token_start_40_ (void);
 static void mwarrow_token_start_3F_ (void);
 static void mwarrow_token_start_21_ (void);
 static void mwarrow_token_end_40_ (void);
 static void mwarrow_token_end_3F_ (void);
 static void mwarrow_token_end_21_ (void);
 static void mwarrow_home_40_ (void);
 static void mwarrow_home_3F_ (void);
 static void mwarrow_home_21_ (void);
 static void mwarrow_homeidx_40_ (void);
 static void mwarrow_homeidx_3F_ (void);
 static void mwarrow_homeidx_21_ (void);
 static void mwarrow_ctx_40_ (void);
 static void mwarrow_ctx_3F_ (void);
 static void mwarrow_ctx_21_ (void);
 static void mwarrow_dom_40_ (void);
 static void mwarrow_dom_3F_ (void);
 static void mwarrow_dom_21_ (void);
 static void mwarrow_cod_40_ (void);
 static void mwarrow_cod_3F_ (void);
 static void mwarrow_cod_21_ (void);
 static void mwarrow_atoms_40_ (void);
 static void mwarrow_atoms_3F_ (void);
 static void mwarrow_atoms_21_ (void);
 static void mwatom_token_40_ (void);
 static void mwatom_token_3F_ (void);
 static void mwatom_token_21_ (void);
 static void mwatom_ctx_40_ (void);
 static void mwatom_ctx_3F_ (void);
 static void mwatom_ctx_21_ (void);
 static void mwatom_op_40_ (void);
 static void mwatom_op_3F_ (void);
 static void mwatom_op_21_ (void);
 static void mwatom_args_40_ (void);
 static void mwatom_args_3F_ (void);
 static void mwatom_args_21_ (void);
 static void mwatom_dom_40_ (void);
 static void mwatom_dom_3F_ (void);
 static void mwatom_dom_21_ (void);
 static void mwatom_cod_40_ (void);
 static void mwatom_cod_3F_ (void);
 static void mwatom_cod_21_ (void);
 static void mwatom_subst_40_ (void);
 static void mwatom_subst_3F_ (void);
 static void mwatom_subst_21_ (void);
 static void mwlambda_token_40_ (void);
 static void mwlambda_token_3F_ (void);
 static void mwlambda_token_21_ (void);
 static void mwlambda_outer_ctx_40_ (void);
 static void mwlambda_outer_ctx_3F_ (void);
 static void mwlambda_outer_ctx_21_ (void);
 static void mwlambda_inner_ctx_40_ (void);
 static void mwlambda_inner_ctx_3F_ (void);
 static void mwlambda_inner_ctx_21_ (void);
 static void mwlambda_dom_40_ (void);
 static void mwlambda_dom_3F_ (void);
 static void mwlambda_dom_21_ (void);
 static void mwlambda_mid_40_ (void);
 static void mwlambda_mid_3F_ (void);
 static void mwlambda_mid_21_ (void);
 static void mwlambda_cod_40_ (void);
 static void mwlambda_cod_3F_ (void);
 static void mwlambda_cod_21_ (void);
 static void mwlambda_params_40_ (void);
 static void mwlambda_params_3F_ (void);
 static void mwlambda_params_21_ (void);
 static void mwlambda_body_40_ (void);
 static void mwlambda_body_3F_ (void);
 static void mwlambda_body_21_ (void);
 static void mwblock_deferred_40_ (void);
 static void mwblock_deferred_3F_ (void);
 static void mwblock_deferred_21_ (void);
 static void mwblock_forcing_40_ (void);
 static void mwblock_forcing_3F_ (void);
 static void mwblock_forcing_21_ (void);
 static void mwblock_ctx_40_ (void);
 static void mwblock_ctx_3F_ (void);
 static void mwblock_ctx_21_ (void);
 static void mwblock_token_40_ (void);
 static void mwblock_token_3F_ (void);
 static void mwblock_token_21_ (void);
 static void mwblock_arrow_raw_40_ (void);
 static void mwblock_arrow_raw_3F_ (void);
 static void mwblock_arrow_raw_21_ (void);
 static void mwblock_needed_40_ (void);
 static void mwblock_needed_3F_ (void);
 static void mwblock_needed_21_ (void);
 static void mwmatch_ctx_40_ (void);
 static void mwmatch_ctx_3F_ (void);
 static void mwmatch_ctx_21_ (void);
 static void mwmatch_dom_40_ (void);
 static void mwmatch_dom_3F_ (void);
 static void mwmatch_dom_21_ (void);
 static void mwmatch_cod_40_ (void);
 static void mwmatch_cod_3F_ (void);
 static void mwmatch_cod_21_ (void);
 static void mwmatch_token_40_ (void);
 static void mwmatch_token_3F_ (void);
 static void mwmatch_token_21_ (void);
 static void mwmatch_cases_40_ (void);
 static void mwmatch_cases_3F_ (void);
 static void mwmatch_cases_21_ (void);
 static void mwcase_match_40_ (void);
 static void mwcase_match_3F_ (void);
 static void mwcase_match_21_ (void);
 static void mwcase_token_40_ (void);
 static void mwcase_token_3F_ (void);
 static void mwcase_token_21_ (void);
 static void mwcase_pattern_40_ (void);
 static void mwcase_pattern_3F_ (void);
 static void mwcase_pattern_21_ (void);
 static void mwcase_subst_40_ (void);
 static void mwcase_subst_3F_ (void);
 static void mwcase_subst_21_ (void);
 static void mwcase_mid_40_ (void);
 static void mwcase_mid_3F_ (void);
 static void mwcase_mid_21_ (void);
 static void mwcase_body_40_ (void);
 static void mwcase_body_3F_ (void);
 static void mwcase_body_21_ (void);
 static void mwvar_is_implicit_40_ (void);
 static void mwvar_is_implicit_3F_ (void);
 static void mwvar_is_implicit_21_ (void);
 static void mwvar_name_40_ (void);
 static void mwvar_name_3F_ (void);
 static void mwvar_name_21_ (void);
 static void mwvar_type_40_ (void);
 static void mwvar_type_3F_ (void);
 static void mwvar_type_21_ (void);
 static void mwvar_auto_run_40_ (void);
 static void mwvar_auto_run_3F_ (void);
 static void mwvar_auto_run_21_ (void);
 static void mwword_name_40_ (void);
 static void mwword_name_3F_ (void);
 static void mwword_name_21_ (void);
 static void mwword_sig_40_ (void);
 static void mwword_sig_3F_ (void);
 static void mwword_sig_21_ (void);
 static void mwword_body_40_ (void);
 static void mwword_body_3F_ (void);
 static void mwword_body_21_ (void);
 static void mwword_ctx_type_40_ (void);
 static void mwword_ctx_type_3F_ (void);
 static void mwword_ctx_type_21_ (void);
 static void mwword_arrow_40_ (void);
 static void mwword_arrow_3F_ (void);
 static void mwword_arrow_21_ (void);
 static void mwtable_name_40_ (void);
 static void mwtable_name_3F_ (void);
 static void mwtable_name_21_ (void);
 static void mwtable_num_buffer_40_ (void);
 static void mwtable_num_buffer_3F_ (void);
 static void mwtable_num_buffer_21_ (void);
 static void mwtable_max_count_40_ (void);
 static void mwtable_max_count_3F_ (void);
 static void mwtable_max_count_21_ (void);
 static void mwfield_sig_is_checked_40_ (void);
 static void mwfield_sig_is_checked_3F_ (void);
 static void mwfield_sig_is_checked_21_ (void);
 static void mwfield_body_is_checked_40_ (void);
 static void mwfield_body_is_checked_3F_ (void);
 static void mwfield_body_is_checked_21_ (void);
 static void mwfield_table_sig_40_ (void);
 static void mwfield_table_sig_3F_ (void);
 static void mwfield_table_sig_21_ (void);
 static void mwfield_type_sig_40_ (void);
 static void mwfield_type_sig_3F_ (void);
 static void mwfield_type_sig_21_ (void);
 static void mwfield_name_40_ (void);
 static void mwfield_name_3F_ (void);
 static void mwfield_name_21_ (void);
 static void mwfield_table_40_ (void);
 static void mwfield_table_3F_ (void);
 static void mwfield_table_21_ (void);
 static void mwfield_type_40_ (void);
 static void mwfield_type_3F_ (void);
 static void mwfield_type_21_ (void);
 static void mwc99_word_needed_40_ (void);
 static void mwc99_word_needed_3F_ (void);
 static void mwc99_word_needed_21_ (void);
 static void mwc99_field_needed_40_ (void);
 static void mwc99_field_needed_3F_ (void);
 static void mwc99_field_needed_21_ (void);
 static void mwc99_block_emitted_40_ (void);
 static void mwc99_block_emitted_3F_ (void);
 static void mwc99_block_emitted_21_ (void);
 static void mwc99_word_emitted_40_ (void);
 static void mwc99_word_emitted_3F_ (void);
 static void mwc99_word_emitted_21_ (void);
 static void mwc99_field_emitted_40_ (void);
 static void mwc99_field_emitted_3F_ (void);
 static void mwc99_field_emitted_21_ (void);
 static void mwexternal_name_40_ (void);
 static void mwexternal_name_3F_ (void);
 static void mwexternal_name_21_ (void);
 static void mwexternal_type_40_ (void);
 static void mwexternal_type_3F_ (void);
 static void mwexternal_type_21_ (void);
 static void mwexternal_sig_40_ (void);
 static void mwexternal_sig_3F_ (void);
 static void mwexternal_sig_21_ (void);
 static void mwexternal_sig_is_checked_40_ (void);
 static void mwexternal_sig_is_checked_3F_ (void);
 static void mwexternal_sig_is_checked_21_ (void);
 static void mwexternal_ctx_40_ (void);
 static void mwexternal_ctx_3F_ (void);
 static void mwexternal_ctx_21_ (void);
 static void mwprim_name_40_ (void);
 static void mwprim_name_3F_ (void);
 static void mwprim_name_21_ (void);
 static void mwprim_ctx_40_ (void);
 static void mwprim_ctx_3F_ (void);
 static void mwprim_ctx_21_ (void);
 static void mwprim_type_40_ (void);
 static void mwprim_type_3F_ (void);
 static void mwprim_type_21_ (void);
 static void mwprim_decl_40_ (void);
 static void mwprim_decl_3F_ (void);
 static void mwprim_decl_21_ (void);

int main (int argc, char** argv) {
    global_argc = argc;
    global_argv = argv;
    mwmain();
    return 0;
}
static void mwmain (void){
    mwinit_21_();
    push_i64(1LL);
    mwargc();
    mw_3C_();
    if (pop_u64()) {
    push_i64(1LL);
    mwargv();
    mwptr_40__40_();
    mwPtr__3E_Str();
    mwStr__3E_Path();
    mwcompile_21_();
    } else {
    push_ptr("Expected at least one argument\0\0\0");
    mwpanic_21_();
    }
}

static void mwpanic_21_ (void){
    push_ptr("panic: \0\0\0");
    mwstr_trace_21_();
    mwstr_trace_ln_21_();
    push_i64(1LL);
    mwposix_exit_21_();
}

static void mwposix_exit_21_ (void){
    mwprim_2E_posix_2E_exit();
}

static void mwstr_trace_ln_21_ (void){
    mwstr_trace_21_();
    mwtrace_ln_21_();
}

static void mwtrace_ln_21_ (void){
    push_ptr("\n\0\0\0");
    mwstr_trace_21_();
}

static void mwstr_trace_21_ (void){
    mwstderr();
    mwstr_write_21_();
}

static void mwstr_write_21_ (void){
    mwFile__3E_Int();
    mwswap();
    mwdup();
    mwstr_size();
    mwdup();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    mwStr__3E_Ptr();
      push_value(d2); }
    mwposix_write_21_();
      push_value(d1); }
    mwswap();
    mwdup();
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("error: write failed!\0\0\0");
    mwpanic_21_();
    } else {
    mwswap();
    mw_3C_();
    if (pop_u64()) {
    push_ptr("error: write output fewer bytes than expected!\0\0\0");
    mwpanic_21_();
    } else {
    mwid();
    }
    }
}

static void mwid (void){
    mwprim_2E_core_2E_id();
}

static void mwposix_write_21_ (void){
    mwprim_2E_posix_2E_write();
}

static void mwStr__3E_Ptr (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwstr_size (void){
    mwprim_2E_str_2E_size();
    { value_t d1 = pop_value();
    mwdrop();
      push_value(d1); }
}

static void mwdrop (void){
    mwprim_2E_core_2E_drop();
}

static void mwdup (void){
    mwprim_2E_core_2E_dup();
}

static void mwswap (void){
    mwprim_2E_core_2E_swap();
}

static void mwFile__3E_Int (void){
    mwid();
}

static void mwstderr (void){
    push_i64(2LL);
    mwInt__3E_File();
}

static void mwInt__3E_File (void){
    mwFILE();
}

static void mwcompile_21_ (void){
    push_ptr("Compiling \0\0\0");
    mwstr_trace_21_();
    mwdup();
    mwPath__3E_Str();
    mwstr_trace_ln_21_();
    mwrun_lexer_21_();
    push_ptr("Building.\0\0\0");
    mwstr_trace_ln_21_();
    mwelab_module_21_();
    mwdrop();
    mwtypecheck_everything_21_();
    mwnum_errors_40_();
    push_i64(0LL);
    mw_3E_();
    if (pop_u64()) {
    mwnum_errors_40_();
    mwint_trace_21_();
    push_ptr(" errors.\0\0\0");
    mwstr_trace_ln_21_();
    push_i64(1LL);
    mwposix_exit_21_();
    } else {
    push_ptr("Done.\0\0\0");
    mwstr_trace_ln_21_();
    }
}

static void mwint_trace_21_ (void){
    mwstderr();
    mwint_write_21_();
}

static void mwint_write_21_ (void){
    { value_t d1 = pop_value();
    mwstr_buf_int_21_();
      push_value(d1); }
    mwstr_buf_write_21_();
}

static void mwstr_buf_write_21_ (void){
    mwFile__3E_Int();
    mwSTR_BUF();
    mwstr_buf_length_3F_();
    mwposix_write_21_();
    mwdup();
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("error: str-buf write failed!\0\0\0");
    mwpanic_21_();
    } else {
    mwstr_buf_length_3F_();
    mw_3C_();
    if (pop_u64()) {
    push_ptr("error: str-buf write wrote fewer bytes than expected!\0\0\0");
    mwpanic_21_();
    } else {
    mwid();
    }
    }
}

static void mwstr_buf_length_3F_ (void){
    mwSTR_BUF_LEN();
    mwint_40_();
}

static void mwint_40_ (void){
    mwprim_2E_int_2E_get();
}

static void mwstr_buf_int_21_ (void){
    mwdup();
    mw0_3D_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("0\0\0\0");
    mwstr_buf_21_();
    } else {
    mwdup();
    { value_t d2 = pop_value();
    mwabs();
    mwstr_buf_clear_21_();
    while(1) {
    mwdup();
    mw0_3E_();
    if (!pop_u64()) break;
    mwdup();
    mwto_digit();
    mwstr_buf_push_char_21_();
    push_i64(10LL);
    mw_2F_();
    }
    mwdrop();
      push_value(d2); }
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_i64(45LL);
    mwInt__3E_Char();
    mwstr_buf_push_char_21_();
    } else {
    mwid();
    }
    mwstr_buf_reverse_21_();
    }
}

static void mwstr_buf_reverse_21_ (void){
    push_i64(0LL);
    mwstr_buf_length_3F_();
    mw1_();
    while(1) {
    mwdup2();
    mw_3C_();
    if (!pop_u64()) break;
    mwdup2();
    mwstr_buf_swap_u8_21_();
    { value_t d2 = pop_value();
    mw1_2B_();
      push_value(d2); }
    mw1_();
    }
    mwdrop2();
}

static void mwdrop2 (void){
    mwdrop();
    mwdrop();
}

static void mw1_2B_ (void){
    push_i64(1LL);
    mw_2B_();
}

static void mw_2B_ (void){
    mwprim_2E_int_2E_add();
}

static void mwstr_buf_swap_u8_21_ (void){
    mwdup2();
    mwswap();
    push_u64(0);
    push_fnptr(&mb_str_buf_swap_u8_21__1);
    do_pack_cons();
    mwdip3();
    { value_t d1 = pop_value();
    mwstr_buf_u8_40_();
      push_value(d1); }
    mwstr_buf_u8_21_();
    mwstr_buf_u8_21_();
}

static void mwstr_buf_u8_21_ (void){
    mwSTR_BUF();
    mwu8_21__21_();
}

static void mwu8_21__21_ (void){
    mwptr_2B_();
    mwu8_21_();
}

static void mwu8_21_ (void){
    mwprim_2E_u8_2E_set();
}

static void mwptr_2B_ (void){
    mwprim_2E_ptr_2E_add();
}

static void mwstr_buf_u8_40_ (void){
    mwSTR_BUF();
    mwu8_40__40_();
}

static void mwu8_40__40_ (void){
    mwptr_2B_();
    mwu8_40_();
}

static void mwu8_40_ (void){
    mwprim_2E_u8_2E_get();
}

static void mb_str_buf_swap_u8_21__1 (void) {
    do_drop();
    mwstr_buf_u8_40_();
}
static void mwdip3 (void){
    {
    value_t var_f_126 = pop_value();
    { value_t d2 = pop_value();
    { value_t d3 = pop_value();
    { value_t d4 = pop_value();
    push_value(var_f_126);
    incref(var_f_126);
    do_run();
      push_value(d4); }
      push_value(d3); }
      push_value(d2); }
    decref(var_f_126);
    }
}

static void mwdup2 (void){
    mwover();
    mwover();
}

static void mwover (void){
    { value_t d1 = pop_value();
    mwdup();
      push_value(d1); }
    mwswap();
}

static void mw1_ (void){
    push_i64(1LL);
    mw_();
}

static void mw_ (void){
    mwprim_2E_int_2E_sub();
}

static void mwInt__3E_Char (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mw_2F_ (void){
    mwprim_2E_int_2E_div();
}

static void mwstr_buf_push_char_21_ (void){
    mwdup();
    mwstr_buf_length_3F_();
    mwSTR_BUF();
    mwptr_2B_();
    mwchar_21_();
    mwchar_width();
    mwstr_buf_length_3F_();
    mw_2B_();
    mwstr_buf_length_21_();
}

static void mwstr_buf_length_21_ (void){
    mwdup();
    mwSTR_BUF_LEN();
    mwint_21_();
    { value_t d1 = pop_value();
    push_i64(0LL);
    mwInt__3E_U8();
      push_value(d1); }
    mwstr_buf_u8_21_();
}

static void mwInt__3E_U8 (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwint_21_ (void){
    mwprim_2E_int_2E_set();
}

static void mwchar_width (void){
    mwChar__3E_Int();
    { value_t d1 = pop_value();
    push_i64(4203265827220226048LL);
      push_value(d1); }
    push_i64(248LL);
    mw_26_();
    push_i64(2LL);
    mw_3E__3E_();
    mw_3E__3E_();
    push_i64(3LL);
    mw_26_();
    push_i64(1LL);
    mw_2B_();
}

static void mw_3E__3E_ (void){
    mwprim_2E_int_2E_shr();
}

static void mw_26_ (void){
    mwprim_2E_int_2E_and();
}

static void mwChar__3E_Int (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwchar_21_ (void){
    { value_t d1 = pop_value();
    mwChar__3E_Int();
    mwInt__3E_U32();
      push_value(d1); }
    mwu32_21_();
}

static void mwu32_21_ (void){
    mwprim_2E_u32_2E_set();
}

static void mwInt__3E_U32 (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwto_digit (void){
    push_i64(10LL);
    mw_25_();
    push_i64(48LL);
    mw_2B_();
    mwInt__3E_Char();
}

static void mw_25_ (void){
    mwprim_2E_int_2E_mod();
}

static void mw0_3E_ (void){
    push_i64(0LL);
    mw_3E_();
}

static void mwstr_buf_clear_21_ (void){
    push_i64(0LL);
    mwstr_buf_length_21_();
}

static void mwabs (void){
    mwdup();
    mw0_3C_();
    if (pop_u64()) {
    mwnegate();
    } else {
    mwid();
    }
}

static void mwnegate (void){
    push_i64(-1LL);
    mw_2A_();
}

static void mw_2A_ (void){
    mwprim_2E_int_2E_mul();
}

static void mw0_3C_ (void){
    push_i64(0LL);
    mw_3C_();
}

static void mwstr_buf_21_ (void){
    mwstr_buf_clear_21_();
    mwstr_buf_push_str_21_();
}

static void mwstr_buf_push_str_21_ (void){
    mwdup();
    mwStr__3E_Ptr();
    mwswap();
    mwstr_size();
    mwstr_buf_push_ptr_21_();
}

static void mwstr_buf_push_ptr_21_ (void){
    mwtuck();
    mwstr_buf_length_3F_();
    mwSTR_BUF();
    mwptr_2B_();
    mwprim_2E_ptr_2E_copy();
    mwstr_buf_length_3F_();
    mw_2B_();
    mwstr_buf_length_21_();
}

static void mwtuck (void){
    mwdup();
    { value_t d1 = pop_value();
    mwswap();
      push_value(d1); }
}

static void mw0_3D_ (void){
    push_i64(0LL);
    mw_3D__3D_();
}

static void mw_3D__3D_ (void){
    mwprim_2E_value_2E_eq();
}

static void mw_3E_ (void){
    mwswap();
    mw_3C_();
}

static void mwnum_errors_40_ (void){
    mwNUM_ERRORS();
    mwint_40_();
}

static void mwtypecheck_everything_21_ (void){
    push_u64(0);
    push_fnptr(&mb_typecheck_everything_21__1);
    do_pack_cons();
    mwName_2E_for();
}

static void mb_typecheck_everything_21__1 (void) {
    do_drop();
    mwtypecheck_name_21_();
}
static void mwtypecheck_name_21_ (void){
    mwname_def_40_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwelab_external_sig_21_();
    mwdrop();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwword_arrow_40_();
    mwforce();
    mwdrop();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    mwelab_field_word_type_21_();
    mwdrop();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwelab_tag_sig_21_();
    mwdrop();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwelab_tag_sig_21_ (void){
    mwelab_tag_ctx_sig_21_();
    mwnip();
}

static void mwnip (void){
    { value_t d1 = pop_value();
    mwdrop();
      push_value(d1); }
}

static void mwelab_tag_ctx_sig_21_ (void){
    mwtag_sig_is_checked_3F_();
    if (pop_u64()) {
    mwtag_type_raw_3F_();
    { value_t d2 = pop_value();
    mwtag_ctx_40_();
      push_value(d2); }
    } else {
    mwtype_elab_default();
    mwover();
    mwtag_data_40_();
    mwdata_header_40_();
    mwelab_type_atom_21_();
    mwdrop();
    mwT1();
    { value_t d2 = pop_value();
    mwover();
    mwtag_has_sig_3F_();
    if (pop_u64()) {
    mwtag_sig_40_();
    mwT0();
    mwswap();
    mwelab_type_stack_rest_21_();
    mwtoken_run_end_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    push_ptr("syntax error\0\0\0");
    mwemit_fatal_error_21_();
    }
    } else {
    mwdrop();
    mwT0();
    }
      push_value(d2); }
    mwT__3E_();
    { value_t d2 = pop_value();
    mwtype_elab_ctx();
      push_value(d2); }
    mwdup2();
    push_u64(0);
    push_fnptr(&mb_elab_tag_ctx_sig_21__8);
    do_pack_cons();
    mwdip2();
    }
}

static void mb_elab_tag_ctx_sig_21__8 (void) {
    do_drop();
    mwrotl();
    mwtuck();
    mwtag_type_raw_21_();
    mwtuck();
    mwtag_ctx_21_();
    mwtrue();
    mwswap();
    mwtag_sig_is_checked_21_();
}
static void mwtrue (void){
    mwprim_2E_bool_2E_true();
}

static void mwrotl (void){
    { value_t d1 = pop_value();
    mwswap();
      push_value(d1); }
    mwswap();
}

static void mwdip2 (void){
    {
    value_t var_f_102 = pop_value();
    { value_t d2 = pop_value();
    { value_t d3 = pop_value();
    push_value(var_f_102);
    incref(var_f_102);
    do_run();
      push_value(d3); }
      push_value(d2); }
    decref(var_f_102);
    }
}

static void mwtype_elab_ctx (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwnip();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwT__3E_ (void){
    mwTMorphism();
}

static void mwemit_fatal_error_21_ (void){
    { value_t d1 = pop_value();
    mwtoken_location();
      push_value(d1); }
    mwemit_fatal_error_at_21_();
}

static void mwemit_fatal_error_at_21_ (void){
    mwemit_error_at_21_();
    push_i64(1LL);
    mwposix_exit_21_();
}

static void mwemit_error_at_21_ (void){
    { value_t d1 = pop_value();
    mwlocation_trace_21_();
      push_value(d1); }
    push_ptr(": error: \0\0\0");
    mwstr_trace_21_();
    mwstr_trace_ln_21_();
    mwnum_errors_2B__2B_();
}

static void mwnum_errors_2B__2B_ (void){
    mwnum_errors_40_();
    mw1_2B_();
    mwNUM_ERRORS();
    mwint_21_();
}

static void mwlocation_trace_21_ (void){
    mwlocation_unpack();
    mwrotr();
    mwswap();
    mwmodule_source_path();
    mwPath__3E_Str();
    mwstr_trace_21_();
    push_ptr(":\0\0\0");
    mwstr_trace_21_();
    mwRow__3E_Int();
    mwint_trace_21_();
    push_ptr(":\0\0\0");
    mwstr_trace_21_();
    mwCol__3E_Int();
    mwint_trace_21_();
}

static void mwCol__3E_Int (void){
    mwid();
}

static void mwRow__3E_Int (void){
    mwid();
}

static void mwmodule_source_path (void){
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("<generated>\0\0\0");
    mwStr__3E_Path();
    } else {
    mwmodule_path_40_();
    mwmake_source_path();
    }
}

static void mwmake_source_path (void){
    mwsource_path_root_40_();
    mwswap();
    mwpath_join();
}

static void mwpath_join (void){
    mwswap();
    mwpath_is_empty_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwPath__3E_Str();
    mwpath_separator();
    mwrotl();
    mwPath__3E_Str();
    mwL3();
    mwstr_concat();
    mwStr__3E_Path();
    }
}

static void mwstr_concat (void){
    mwdup();
    push_i64(0LL);
    mwswap();
    push_u64(0);
    push_fnptr(&mb_str_concat_1);
    do_pack_cons();
    mwfor();
    mwprim_2E_str_2E_alloc();
    mwdup();
    { value_t d1 = pop_value();
    mwprim_2E_str_2E_base();
    mwswap();
    push_u64(0);
    push_fnptr(&mb_str_concat_3);
    do_pack_cons();
    mwfor();
    mwnil();
    mwswap();
    mwu8_21_();
      push_value(d1); }
}

static void mwnil (void){
    push_i64(0LL);
    mwprim_2E_unsafe_2E_cast();
}

static void mb_str_concat_3 (void) {
    do_drop();
    mwswap();
    mwstr_copy_partial_21_();
}
static void mwstr_copy_partial_21_ (void){
    { value_t d1 = pop_value();
    mwdup();
    mwStr__3E_Ptr();
    mwswap();
    mwstr_size();
      push_value(d1); }
    mwdup2();
    mwptr_2B_();
    { value_t d1 = pop_value();
    mwprim_2E_ptr_2E_copy();
      push_value(d1); }
}

static void mb_str_concat_1 (void) {
    do_drop();
    mwstr_size();
    mw_2B_();
}
static void mwfor (void){
    {
    value_t var_f_230 = pop_value();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_230);
    incref(var_f_230);
    do_run();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d3 = pop_value();
    push_value(var_f_230);
    incref(var_f_230);
    do_run();
      push_value(d3); }
    push_value(var_f_230);
    incref(var_f_230);
    do_run();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d3 = pop_value();
    { value_t d4 = pop_value();
    push_value(var_f_230);
    incref(var_f_230);
    do_run();
      push_value(d4); }
    push_value(var_f_230);
    incref(var_f_230);
    do_run();
      push_value(d3); }
    push_value(var_f_230);
    incref(var_f_230);
    do_run();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    { value_t d3 = pop_value();
    push_value(var_f_230);
    incref(var_f_230);
    mwfor_2B_();
      push_value(d3); }
    push_value(var_f_230);
    incref(var_f_230);
    mwfor_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_230);
    }
}

static void mwfor_2B_ (void){
    {
    value_t var_f_309 = pop_value();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_309);
    incref(var_f_309);
    do_run();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d3 = pop_value();
    push_value(var_f_309);
    incref(var_f_309);
    do_run();
      push_value(d3); }
    push_value(var_f_309);
    incref(var_f_309);
    do_run();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d3 = pop_value();
    { value_t d4 = pop_value();
    push_value(var_f_309);
    incref(var_f_309);
    do_run();
      push_value(d4); }
    push_value(var_f_309);
    incref(var_f_309);
    do_run();
      push_value(d3); }
    push_value(var_f_309);
    incref(var_f_309);
    do_run();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    { value_t d3 = pop_value();
    push_value(var_f_309);
    incref(var_f_309);
    mwfor_2B_();
      push_value(d3); }
    push_value(var_f_309);
    incref(var_f_309);
    mwfor_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_309);
    }
}

static void mwpath_separator (void){
    mwRUNNING_OS();
    mwOS_WINDOWS();
    mw_3D__3D_();
    if (pop_u64()) {
    push_ptr("\\\0\0\0");
    } else {
    push_ptr("/\0\0\0");
    }
}

static void mwRUNNING_OS (void){
    mwprim_2E_sys_2E_os();
    mwInt__3E_OS();
}

static void mwInt__3E_OS (void){
    mwdup();
    push_i64(1LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwOS_WINDOWS();
    } else {
    mwdup();
    push_i64(2LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwOS_LINUX();
    } else {
    mwdup();
    push_i64(3LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwOS_MACOS();
    } else {
    mwdrop();
    mwOS_UNKNOWN();
    }
    }
    }
}

static void mwpath_is_empty_3F_ (void){
    mwdup();
    mwPath__3E_Str();
    mwstr_is_empty();
}

static void mwstr_is_empty (void){
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    mwtrue();
    } else {
    mwstr_head();
    mwis_nil();
    }
}

static void mwis_nil (void){
    mwnil();
    mw_3D__3D_();
}

static void mwstr_head (void){
    mwStr__3E_Ptr();
    mwchar_40_();
}

static void mwchar_40_ (void){
    mwu32_40_();
    mwU32__3E_Int();
    mwdup();
    { value_t d1 = pop_value();
    push_i64(-4203265827220226049LL);
      push_value(d1); }
    push_i64(248LL);
    mw_26_();
    push_i64(2LL);
    mw_3E__3E_();
    mw_3E__3E_();
    push_i64(3LL);
    mw_26_();
    { value_t d1 = pop_value();
    push_i64(4294967295LL);
      push_value(d1); }
    push_i64(3LL);
    mw_3C__3C_();
    mw_3E__3E_();
    mw_26_();
    mwInt__3E_Char();
}

static void mw_3C__3C_ (void){
    mwprim_2E_int_2E_shl();
}

static void mwU32__3E_Int (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwu32_40_ (void){
    mwprim_2E_u32_2E_get();
}

static void mwsource_path_root_40_ (void){
    mwSOURCE_PATH_ROOT();
    mwpath_40_();
}

static void mwpath_40_ (void){
    mwptr_40_();
    mwPtr__3E_Str();
    mwStr__3E_Path();
}

static void mwptr_40_ (void){
    mwprim_2E_ptr_2E_get();
}

static value_t* fieldptr_module_path (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmodule_path_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_path(index);
    incref(v); push_value(v);
}
static void mwmodule_path_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_path(index);
    incref(v); push_value(v);
}
static void mwmodule_path_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_module_path(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwis_nil_3F_ (void){
    mwdup();
    mwnil();
    mw_3D__3D_();
}

static void mwrotr (void){
    mwswap();
    { value_t d1 = pop_value();
    mwswap();
      push_value(d1); }
}

static void mwlocation_unpack (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwid();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwtoken_location (void){
    mwtoken_module_3F_();
    mwswap();
    mwtoken_row_3F_();
    mwswap();
    mwtoken_col_40_();
    mwlocation_pack();
}

static void mwlocation_pack (void){
    mwLOCATION();
}

static value_t* fieldptr_token_col (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtoken_col_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_col(index);
    incref(v); push_value(v);
}
static void mwtoken_col_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_col(index);
    incref(v); push_value(v);
}
static void mwtoken_col_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_token_col(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_token_row (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtoken_row_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_row(index);
    incref(v); push_value(v);
}
static void mwtoken_row_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_row(index);
    incref(v); push_value(v);
}
static void mwtoken_row_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_token_row(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_token_module (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtoken_module_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_module(index);
    incref(v); push_value(v);
}
static void mwtoken_module_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_module(index);
    incref(v); push_value(v);
}
static void mwtoken_module_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_token_module(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtoken_run_end_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwtrue();
    break;
    case 1LL:
    do_drop();
    mwtrue();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwfalse (void){
    mwprim_2E_bool_2E_false();
}

static value_t* fieldptr_token_value (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtoken_value_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_value(index);
    incref(v); push_value(v);
}
static void mwtoken_value_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_token_value(index);
    incref(v); push_value(v);
}
static void mwtoken_value_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_token_value(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_type_stack_rest_21_ (void){
    while(1) {
    mwsig_is_stack_end2_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwswap();
    { value_t d2 = pop_value();
    mwelab_type_atom_21_();
      push_value(d2); }
    mwswap();
    { value_t d2 = pop_value();
    mwswap();
    mwTTensor();
      push_value(d2); }
    }
}

static void mwnot (void){
    mwfalse();
    mw_3D__3D_();
}

static void mwsig_is_stack_end2_3F_ (void){
    mwsig_is_stack_end_3F_();
    if (pop_u64()) {
    mwtrue();
    } else {
    mwsig_token_is_effect_con_3F_();
    }
}

static void mwsig_token_is_effect_con_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_could_be_effect_con();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwname_could_be_effect_con (void){
    mwname_str_40_();
    mwdup();
    mwstr_head();
    mwis_plus_3F_();
    mwnip();
    if (pop_u64()) {
    mwstr_tail();
    mwstr_head();
    mwis_upper_3F_();
    mwnip();
    } else {
    mwdrop();
    mwfalse();
    }
}

static void mwis_upper_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(65LL);
    push_i64(90LL);
    mwin_range();
}

static void mwin_range (void){
    { value_t d1 = pop_value();
    mwover();
    { value_t d2 = pop_value();
    mw_3E__3D_();
      push_value(d2); }
      push_value(d1); }
    mw_3C__3D_();
    mw_26__26_();
}

static void mw_26__26_ (void){
    mwprim_2E_bool_2E_and();
}

static void mw_3C__3D_ (void){
    mwprim_2E_value_2E_le();
}

static void mw_3E__3D_ (void){
    mwswap();
    mw_3C__3D_();
}

static void mwstr_tail (void){
    mwdup();
    { value_t d1 = pop_value();
    mwstr_head_width();
      push_value(d1); }
    mwStr__3E_Ptr();
    mwptr_2B_();
    mwPtr__3E_Str();
}

static void mwstr_head_width (void){
    mwStr__3E_Ptr();
    mwchar_40__width();
}

static void mwchar_40__width (void){
    mwu8_40_();
    mwU8__3E_Int();
    mwInt__3E_Char();
    mwchar_width();
}

static void mwU8__3E_Int (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwis_plus_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(43LL);
    mw_3D__3D_();
}

static value_t* fieldptr_name_str (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwname_str_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_name_str(index);
    incref(v); push_value(v);
}
static void mwname_str_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_name_str(index);
    incref(v); push_value(v);
}
static void mwname_str_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_name_str(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwsig_is_stack_end_3F_ (void){
    mwtoken_is_dashes_3F_();
    if (pop_u64()) {
    mwtrue();
    } else {
    mwtoken_run_end_3F_();
    }
}

static void mwtoken_is_dashes_3F_ (void){
    mwPRIM_SYNTAX_DASHES();
    mwtoken_prim_3D__3F_();
}

static void mwtoken_prim_3D__3F_ (void){
    { value_t d1 = pop_value();
    mwdup();
      push_value(d1); }
    mwtoken_prim_3D_();
}

static void mwtoken_prim_3D_ (void){
    mwswap();
    mwtoken_value_40_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwname_prim_3D_();
    break;
    default:
    mwdrop2();
    mwfalse();
    break;
    }
}

static void mwname_prim_3D_ (void){
    { value_t d1 = pop_value();
    mwname_def_40_();
      push_value(d1); }
    mwDEF_PRIM();
    mw_3D__3D_();
}

static void mwT0 (void){
    mwTYPE_UNIT();
}

static void mwTYPE_UNIT (void){
    mwPRIM_TYPE_UNIT();
    mwTPrim();
}

static value_t* fieldptr_tag_sig (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_sig_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_sig(index);
    incref(v); push_value(v);
}
static void mwtag_sig_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_sig(index);
    incref(v); push_value(v);
}
static void mwtag_sig_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_sig(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_tag_has_sig (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_has_sig_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_has_sig(index);
    incref(v); push_value(v);
}
static void mwtag_has_sig_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_has_sig(index);
    incref(v); push_value(v);
}
static void mwtag_has_sig_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_has_sig(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwT1 (void){
    { value_t d1 = pop_value();
    mwT0();
      push_value(d1); }
    mwT_2A_();
}

static void mwT_2A_ (void){
    mwTTensor();
}

static void mwelab_type_atom_21_ (void){
    mwsig_token_is_type_var_3F_();
    if (pop_u64()) {
    mwelab_type_var_21_();
    { value_t d2 = pop_value();
    mwTVar();
      push_value(d2); }
    } else {
    mwsig_token_is_type_con_3F_();
    if (pop_u64()) {
    mwelab_type_con_21_();
    } else {
    mwtoken_is_underscore_3F_();
    if (pop_u64()) {
    mwelab_type_dont_care_21_();
    } else {
    mwsig_token_is_type_hole_3F_();
    if (pop_u64()) {
    mwelab_type_hole_21_();
    } else {
    mwtoken_is_lsquare_3F_();
    if (pop_u64()) {
    mwelab_type_quote_21_();
    } else {
    mwdup();
    push_ptr("Expected type, got unknown token.\0\0\0");
    mwemit_error_21_();
    { value_t d6 = pop_value();
    mwTYPE_ERROR();
      push_value(d6); }
    mwtoken_next();
    }
    }
    }
    }
    }
}

static void mwtoken_next (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwtoken_succ();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwtoken_succ();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwtoken_succ();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtoken_succ();
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwtoken_succ();
    break;
    default:
    mwdrop();
    break;
    }
    break;
    default:
    mwdrop();
    mwtoken_succ();
    break;
    }
}

static void mwtoken_succ (void){
    mwToken_2E_succ();
}

static void mwToken_2E_succ (void){
    mwprim_2E_unsafe_2E_cast();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwToken_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_int_2E_mod();
    mwprim_2E_unsafe_2E_cast();
}

static void mwemit_error_21_ (void){
    { value_t d1 = pop_value();
    mwtoken_location();
      push_value(d1); }
    mwemit_error_at_21_();
}

static void mwelab_type_quote_21_ (void){
    mwtoken_args_1();
    mwsig_has_dashes_3F_();
    if (pop_u64()) {
    mwelab_type_sig_21_();
    } else {
    mwelab_type_stack_21_();
    }
    mwtoken_next();
}

static void mwelab_type_stack_21_ (void){
    mwsig_token_is_stack_var_3F_();
    if (pop_u64()) {
    mwelab_stack_var_21_();
    { value_t d2 = pop_value();
    mwTVar();
      push_value(d2); }
    } else {
    { value_t d2 = pop_value();
    mwTYPE_UNIT();
      push_value(d2); }
    }
    mwelab_type_stack_rest_21_();
}

static void mwelab_stack_var_21_ (void){
    mwTYPE_STACK();
    mwelab_implicit_var_21_();
}

static void mwelab_implicit_var_21_ (void){
    push_u64(0);
    push_fnptr(&mb_elab_implicit_var_21__1);
    do_pack_cons();
    mwdip2();
    mwover();
    push_u64(0);
    push_fnptr(&mb_elab_implicit_var_21__2);
    do_pack_cons();
    mwdip2();
    mwrotl();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwrotr();
    push_u64(0);
    push_fnptr(&mb_elab_implicit_var_21__4);
    do_pack_cons();
    mwdip2();
    mwelab_type_unify_21_();
    mwnip();
    break;
    case 0LL:
    do_drop();
    { value_t d2 = pop_value();
    { value_t d3 = pop_value();
    mwvar_new_implicit_21_();
      push_value(d3); }
    mwover();
    mwvar_type_21_();
    mwdup();
    { value_t d3 = pop_value();
    mwctx_new_21_();
      push_value(d3); }
      push_value(d2); }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    mwtoken_next();
    push_u64(0);
    push_fnptr(&mb_elab_implicit_var_21__9);
    do_pack_cons();
    mwdip2();
}

static void mb_elab_implicit_var_21__9 (void) {
    do_drop();
    mwtype_elab_ctx_21_();
}
static void mwtype_elab_ctx_21_ (void){
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwswap();
    mwTYPE_ELAB();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwctx_new_21_ (void){
    { value_t d1 = pop_value();
    mwunCTX();
      push_value(d1); }
    mwsnoc();
    mwCTX();
}

static void mwsnoc (void){
    mwsnoc_2B_();
    mwList_2B___3E_List();
}

static void mwList_2B___3E_List (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL1();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL2();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL3();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwLCAT();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwsnoc_2B_ (void){
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwL1_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwL2_2B_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwrotl();
    mwL3_2B_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwrot4l();
    mwL4_2B_();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mw1_2B_();
    { value_t d2 = pop_value();
    mwrotl();
    mwsnoc_2B__2B_();
    mwrebalance_2B_();
      push_value(d2); }
    mwLCAT_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwrebalance_2B_ (void){
    mwdup2();
    { value_t d1 = pop_value();
    mwlen_2B_();
      push_value(d1); }
    mwlen_2B_();
    mwdup2();
    push_i64(3LL);
    mw_2A_();
    mw_3E_();
    if (pop_u64()) {
    mwdrop2();
    { value_t d2 = pop_value();
    mwsplit_half_left();
      push_value(d2); }
    mwcat__2B_();
    mwrebalance_2B_();
    } else {
    { value_t d2 = pop_value();
    push_i64(3LL);
    mw_2A_();
      push_value(d2); }
    mw_3C_();
    if (pop_u64()) {
    mwsplit_half_right();
    { value_t d3 = pop_value();
    mwcat_2B__();
      push_value(d3); }
    mwrebalance_2B_();
    } else {
    mwid();
    }
    }
}

static void mwcat_2B__ (void){
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwcat_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwcat_2B_ (void){
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwcons_2B__2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwrotl();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL3_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL4_2B_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL5_2B_();
    break;
    default:
    { value_t d3 = pop_value();
    mwL2_2B_();
      push_value(d3); }
    mwcat_aux();
    break;
    }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwrot4l();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL4_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL5_2B_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL6_2B_();
    break;
    default:
    { value_t d3 = pop_value();
    mwL3_2B_();
      push_value(d3); }
    mwcat_aux();
    break;
    }
    break;
    default:
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwsnoc_2B__2B_();
    break;
    default:
    mwcat_aux();
    break;
    }
    break;
    }
}

static void mwL6_2B_ (void){
    mwL3_2B_();
    { value_t d1 = pop_value();
    mwL3_2B_();
      push_value(d1); }
    push_i64(6LL);
    mwLCAT_2B_();
}

static void mwcat_aux (void){
    mwrebalance_2B_();
    mwdup2();
    { value_t d1 = pop_value();
    mwlen_2B_();
      push_value(d1); }
    mwlen_2B_();
    mw_2B_();
    mwLCAT_2B_();
}

static void mwL5_2B_ (void){
    mwL3_2B_();
    { value_t d1 = pop_value();
    mwL2_2B_();
      push_value(d1); }
    push_i64(5LL);
    mwLCAT_2B_();
}

static void mwcons_2B__2B_ (void){
    mwList_2B___3E_List();
    mwcons_2B_();
}

static void mwcons_2B_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwL1_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwL2_2B_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL3_2B_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL4_2B_();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mw1_2B_();
    { value_t d2 = pop_value();
    { value_t d3 = pop_value();
    mwcons_2B__2B_();
      push_value(d3); }
    mwrebalance_2B_();
      push_value(d2); }
    mwLCAT_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwList__3E_List_2B_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwNONE();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwL1_2B_();
    mwSOME();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL2_2B_();
    mwSOME();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL3_2B_();
    mwSOME();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwLCAT_2B_();
    mwSOME();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwsplit_half_right (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL1_2B_();
    { value_t d2 = pop_value();
    mwL0();
      push_value(d2); }
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL1_2B_();
    { value_t d2 = pop_value();
    mwL1();
      push_value(d2); }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL2_2B_();
    { value_t d2 = pop_value();
    mwL1();
      push_value(d2); }
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    { value_t d2 = pop_value();
    mwList_2B___3E_List();
      push_value(d2); }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwcat__2B_ (void){
    mwswap();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwcat_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwsplit_half_left (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL0();
    { value_t d2 = pop_value();
    mwL1_2B_();
      push_value(d2); }
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL1();
    { value_t d2 = pop_value();
    mwL1_2B_();
      push_value(d2); }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL1();
    { value_t d2 = pop_value();
    mwL2_2B_();
      push_value(d2); }
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwList_2B___3E_List();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwlen_2B_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    push_i64(1LL);
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop2();
    push_i64(2LL);
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop3();
    push_i64(3LL);
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwdrop2();
      push_value(d2); }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwdrop3 (void){
    mwdrop();
    mwdrop();
    mwdrop();
}

static void mwsnoc_2B__2B_ (void){
    { value_t d1 = pop_value();
    mwList_2B___3E_List();
      push_value(d1); }
    mwsnoc_2B_();
}

static void mwL4_2B_ (void){
    mwL2_2B_();
    { value_t d1 = pop_value();
    mwL2_2B_();
      push_value(d1); }
    push_i64(4LL);
    mwLCAT_2B_();
}

static void mwrot4l (void){
    { value_t d1 = pop_value();
    mwrotl();
      push_value(d1); }
    mwswap();
}

static void mwunCTX (void){
    mwid();
}

static value_t* fieldptr_var_type (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwvar_type_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_type(index);
    incref(v); push_value(v);
}
static void mwvar_type_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_type(index);
    incref(v); push_value(v);
}
static void mwvar_type_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_var_type(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwvar_new_implicit_21_ (void){
    mwvar_new_21_();
    mwtrue();
    mwover();
    mwvar_is_implicit_21_();
}

static value_t* fieldptr_var_is_implicit (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwvar_is_implicit_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_is_implicit(index);
    incref(v); push_value(v);
}
static void mwvar_is_implicit_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_is_implicit(index);
    incref(v); push_value(v);
}
static void mwvar_is_implicit_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_var_is_implicit(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwvar_new_21_ (void){
    mwVar_2E_alloc_21_();
    mwtuck();
    mwvar_name_21_();
}

static value_t* fieldptr_var_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwvar_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_name(index);
    incref(v); push_value(v);
}
static void mwvar_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_name(index);
    incref(v); push_value(v);
}
static void mwvar_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_var_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwVar_2E_alloc_21_ (void){
    mwVar_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwVar_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwelab_type_unify_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwGAMMA();
    mwrotr();
    mwtype_unify_21_();
    mwnip();
      push_value(d1); }
}

static void mwtype_unify_21_ (void){
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwid();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTMeta();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTMeta();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    default:
    mwswap();
    mwmeta_unify_21_();
    break;
    }
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTVar();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTVar();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTVar();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwtype_var_unify_21_();
    break;
    default:
    { value_t d3 = pop_value();
    mwTVar();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTPrim();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTPrim();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTPrim();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTPrim();
      push_value(d3); }
    mwtype_value_unify_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwtype_prim_unify_21_();
    break;
    default:
    { value_t d3 = pop_value();
    mwTPrim();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTData();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTData();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTData();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTData();
      push_value(d3); }
    mwtype_value_unify_21_();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwtype_data_unify_21_();
    break;
    default:
    { value_t d3 = pop_value();
    mwTData();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTTable();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTTable();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTTable();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTTable();
      push_value(d3); }
    mwtype_value_unify_21_();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwtype_table_unify_21_();
    break;
    default:
    { value_t d3 = pop_value();
    mwTTable();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwrotl();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop2();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTTensor();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTTensor();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTTensor();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTTensor();
      push_value(d3); }
    mwtype_value_unify_21_();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_unify_pair_21_();
    mwTTensor();
    break;
    default:
    { value_t d3 = pop_value();
    mwTTensor();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwrotl();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop2();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTMorphism();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTMorphism();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTMorphism();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTMorphism();
      push_value(d3); }
    mwtype_value_unify_21_();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_unify_pair_21_();
    mwTMorphism();
    break;
    default:
    { value_t d3 = pop_value();
    mwTMorphism();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwrotl();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop2();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTApp();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTApp();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTApp();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTApp();
      push_value(d3); }
    mwtype_value_unify_21_();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_unify_pair_21_();
    mwTApp();
    break;
    default:
    { value_t d3 = pop_value();
    mwTApp();
      push_value(d3); }
    mwtype_unify_failed_21_();
    break;
    }
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTValue();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTValue();
      push_value(d3); }
    mwtype_hole_unify_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwTValue();
      push_value(d3); }
    mwmeta_unify_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    mwvalue_unify_21_();
    break;
    default:
    mwvalue_type_unify_21_();
    break;
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwvalue_type_unify_21_ (void){
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwTYPE_INT();
    mwswap();
    mwtype_unify_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwTYPE_STR();
    mwswap();
    mwtype_unify_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwblock_unify_type_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwblock_unify_type_21_ (void){
    mwswap();
    mwblock_deferred_3F_();
    if (pop_u64()) {
    mwblock_forcing_3F_();
    if (pop_u64()) {
    mwblock_token_40_();
    push_ptr("Recursive type detected for block.\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    mwblock_unify_type_aux_21_();
    }
    } else {
    mwblock_arrow_raw_40_();
    mwarrow_type();
    mwswap();
    mwtype_unify_21_();
    }
}

static void mwarrow_type (void){
    mwarrow_dom_3F_();
    mwswap();
    mwarrow_cod_40_();
    mwTMorphism();
}

static value_t* fieldptr_arrow_cod (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_cod_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_cod(index);
    incref(v); push_value(v);
}
static void mwarrow_cod_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_cod(index);
    incref(v); push_value(v);
}
static void mwarrow_cod_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_cod(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_arrow_dom (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_dom_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_dom(index);
    incref(v); push_value(v);
}
static void mwarrow_dom_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_dom(index);
    incref(v); push_value(v);
}
static void mwarrow_dom_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_dom(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_block_arrow_raw (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwblock_arrow_raw_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_arrow_raw(index);
    incref(v); push_value(v);
}
static void mwblock_arrow_raw_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_arrow_raw(index);
    incref(v); push_value(v);
}
static void mwblock_arrow_raw_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_block_arrow_raw(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwblock_unify_type_aux_21_ (void){
    mwtrue();
    mwover();
    mwblock_forcing_21_();
    { value_t d1 = pop_value();
    mwover();
    mwgamma_token_40_();
    mwelab_expand_morphism_21_();
    mwdrop();
      push_value(d1); }
    mwrotr();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    mwblock_ctx_3F_();
    mwover();
    mwblock_token_40_();
      push_value(d2); }
    mwswap();
    push_u64(0);
    push_fnptr(&mb_block_unify_type_aux_21__4);
    do_pack_cons();
    mwab_build_21_();
    mwdup2();
    mwswap();
    mwblock_arrow_raw_21_();
    { value_t d2 = pop_value();
    mwfalse();
    mwswap();
    mwblock_deferred_21_();
      push_value(d2); }
    mwarrow_cod_40_();
      push_value(d1); }
    mwtype_unify_21_();
}

static void mb_block_unify_type_aux_21__4 (void) {
    do_drop();
    mwelab_atoms_21_();
}
static void mwelab_atoms_21_ (void){
    while(1) {
    mwelab_atoms_done_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwelab_atom_21_();
    mwab_token_40_();
    mwtoken_next();
    mwab_token_21_();
    }
}

static void mwab_token_21_ (void){
    mwab_arrow_40_();
    mwarrow_token_end_21_();
}

static value_t* fieldptr_arrow_token_end (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_token_end_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_token_end(index);
    incref(v); push_value(v);
}
static void mwarrow_token_end_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_token_end(index);
    incref(v); push_value(v);
}
static void mwarrow_token_end_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_token_end(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_arrow_40_ (void){
    mwAB_ARROW();
    mwvalue_40_();
}

static void mwvalue_40_ (void){
    mwprim_2E_value_2E_get();
}

static void mwab_token_40_ (void){
    mwab_arrow_40_();
    mwarrow_token_end_40_();
}

static void mwelab_atom_21_ (void){
    mwab_token_40_();
    mwtoken_value_40_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwelab_atom_name_21_();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    mwab_int_21_();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    mwab_str_21_();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwelab_atom_block_21_();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwelab_atom_assert_21_();
    break;
    default:
    mwab_token_40_();
    push_ptr("Unexpected token in elab-atom!\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static void mwelab_atom_assert_21_ (void){
    mwab_token_40_();
    mwGAMMA();
    mwab_ctx_40_();
    mwtype_elab_stack_assertion();
    mwab_token_40_();
    mwtoken_args_1();
    mwelab_type_stack_21_();
    mwdrop();
    mwnip();
    mwab_type_40_();
    mwswap();
    mwtype_unify_21_();
    mwdrop2();
}

static void mwab_type_40_ (void){
    mwab_arrow_40_();
    mwarrow_cod_40_();
}

static void mwtype_elab_stack_assertion (void){
    { value_t d1 = pop_value();
    mwALLOW_HOLES();
      push_value(d1); }
    mwTYPE_ELAB();
}

static void mwab_ctx_40_ (void){
    mwab_arrow_40_();
    mwarrow_ctx_40_();
}

static value_t* fieldptr_arrow_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_ctx(index);
    incref(v); push_value(v);
}
static void mwarrow_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_ctx(index);
    incref(v); push_value(v);
}
static void mwarrow_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_atom_block_21_ (void){
    mwab_token_40_();
    mwtoken_args_1();
    mwelab_block_at_21_();
}

static void mwelab_block_at_21_ (void){
    mwab_ctx_40_();
    mwswap();
    mwblock_new_deferred_21_();
    mwOP_BLOCK();
    mwab_op_21_();
}

static void mwab_op_21_ (void){
    mwAtom_2E_alloc_21_();
    mwab_ctx_40_();
    mwover();
    mwatom_ctx_21_();
    mwab_token_40_();
    mwover();
    mwatom_token_21_();
    mwdup2();
    mwatom_op_21_();
    mwswap();
    mwelab_op_fresh_sig_21_();
    { value_t d1 = pop_value();
    mwover();
    mwatom_subst_21_();
      push_value(d1); }
    mwab_expand_opsig_21_();
    { value_t d1 = pop_value();
    mwover();
    mwatom_dom_21_();
      push_value(d1); }
    mwover();
    mwatom_cod_21_();
    mwab_atom_21_();
}

static void mwab_atom_21_ (void){
    mwatom_token_3F_();
    mwab_token_21_();
    mwatom_cod_3F_();
    mwab_type_21_();
    { value_t d1 = pop_value();
    mwab_arrow_40_();
    mwarrow_atoms_40_();
      push_value(d1); }
    mwab_optimized_snoc_21_();
    mwab_arrow_40_();
    mwarrow_atoms_21_();
}

static void mwab_optimized_snoc_21_ (void){
    while(1) {
    push_u64(0);
    push_fnptr(&mb_ab_optimized_snoc_21__3);
    do_pack_cons();
    mwdip_3F_();
    push_u64(0);
    push_fnptr(&mb_ab_optimized_snoc_21__4);
    do_pack_cons();
    mwand();
    if (!pop_u64()) break;
    mwswap();
    mwatoms_turn_last_block_to_arg();
    mwswap();
    }
    mwsnoc();
}

static void mwatoms_turn_last_block_to_arg (void){
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwL0();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwunsnoc();
    mwatom_op_3F_();
    switch (get_top_data_tag()) {
    case 12LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwatom_cod_40_();
    mwrotl();
    mwtuck();
    mwatom_dom_21_();
      push_value(d3); }
    mwblock_to_arg();
    mwatom_arg_add_21_();
    mwswap();
    break;
    default:
    mwdrop();
    mwsnoc();
    break;
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwatom_arg_add_21_ (void){
    { value_t d1 = pop_value();
    mwatom_args_3F_();
      push_value(d1); }
    mwsnoc();
    mwover();
    mwatom_args_21_();
}

static value_t* fieldptr_atom_args (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_args_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_args(index);
    incref(v); push_value(v);
}
static void mwatom_args_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_args(index);
    incref(v); push_value(v);
}
static void mwatom_args_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_args(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwblock_to_arg (void){
    mwblock_arrow_3F_();
    mwarrow_to_run_var();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwARG_BLOCK();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwARG_VAR_RUN();
    mwnip();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwarrow_to_run_var (void){
    mwarrow_atoms_40_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwatom_to_run_var();
    break;
    default:
    mwdrop();
    mwNONE();
    break;
    }
}

static void mwatom_to_run_var (void){
    mwatom_op_40_();
    switch (get_top_data_tag()) {
    case 11LL:
    do_pack_uncons(); do_drop();
    mwvar_auto_run_3F_();
    if (pop_u64()) {
    mwSOME();
    } else {
    mwdrop();
    mwNONE();
    }
    break;
    default:
    mwdrop();
    mwNONE();
    break;
    }
}

static value_t* fieldptr_var_auto_run (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwvar_auto_run_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_auto_run(index);
    incref(v); push_value(v);
}
static void mwvar_auto_run_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_var_auto_run(index);
    incref(v); push_value(v);
}
static void mwvar_auto_run_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_var_auto_run(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwblock_arrow_3F_ (void){
    mwdup();
    mwblock_arrow_40_();
}

static void mwblock_arrow_40_ (void){
    mwdup();
    mwblock_force_21_();
    mwblock_arrow_raw_40_();
}

static void mwblock_force_21_ (void){
    mwblock_deferred_3F_();
    if (pop_u64()) {
    mwblock_forcing_3F_();
    if (pop_u64()) {
    mwblock_token_40_();
    push_ptr("Recursive type detected for block.\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    mwtrue();
    mwover();
    mwblock_forcing_21_();
    mwblock_ctx_3F_();
    mwover();
    mwblock_token_40_();
    { value_t d3 = pop_value();
    mwmeta_alloc_21_();
    mwTMeta();
      push_value(d3); }
    push_u64(0);
    push_fnptr(&mb_block_force_21__5);
    do_pack_cons();
    mwab_build_21_();
    mwover();
    mwblock_arrow_raw_21_();
    mwfalse();
    mwswap();
    mwblock_deferred_21_();
    }
    } else {
    mwdrop();
    }
}

static void mb_block_force_21__5 (void) {
    do_drop();
    mwelab_atoms_21_();
}
static void mwmeta_alloc_21_ (void){
    mwMetaVar_2E_alloc_21_();
}

static void mwMetaVar_2E_alloc_21_ (void){
    mwMetaVar_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwMetaVar_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwunsnoc (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwL0();
      push_value(d2); }
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwL1();
      push_value(d2); }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwL2();
      push_value(d2); }
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwunsnoc();
    { value_t d2 = pop_value();
    mwcat_2B__();
    mwList_2B___3E_List();
      push_value(d2); }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mb_ab_optimized_snoc_21__4 (void) {
    do_drop();
    mwatom_accepts_args_3F_();
}
static void mwatom_accepts_args_3F_ (void){
    mwatom_op_3F_();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwatom_args_3F_();
    mwlen();
      push_value(d2); }
    mwelab_word_sig_21_();
    mwtype_max_num_params();
    mw_3C_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    switch (get_top_data_tag()) {
    case 8LL:
    do_drop();
    mwatom_args_3F_();
    mwlen();
    push_i64(1LL);
    mw_3C_();
    break;
    case 4LL:
    do_drop();
    mwatom_args_3F_();
    mwlen();
    push_i64(1LL);
    mw_3C_();
    break;
    case 5LL:
    do_drop();
    mwatom_args_3F_();
    mwlen();
    push_i64(2LL);
    mw_3C_();
    break;
    case 6LL:
    do_drop();
    mwatom_args_3F_();
    mwlen();
    push_i64(2LL);
    mw_3C_();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtype_max_num_params (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwtype_num_morphisms_on_top();
    break;
    default:
    mwdrop();
    push_i64(0LL);
    break;
    }
}

static void mwtype_num_morphisms_on_top (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop2();
    mwtype_num_morphisms_on_top();
    mw1_2B_();
    break;
    default:
    mwdrop2();
    push_i64(0LL);
    break;
    }
    break;
    default:
    mwdrop();
    push_i64(0LL);
    break;
    }
}

static void mwelab_word_sig_21_ (void){
    mwelab_word_ctx_sig_21_();
    mwnip();
}

static void mwelab_word_ctx_sig_21_ (void){
    mwword_ctx_type_40_();
    mwforce2();
}

static void mwforce2 (void){
    mwforce();
    mwunpack2();
}

static void mwunpack2 (void){
    mwpack_uncons();
    { value_t d1 = pop_value();
    mwunpack1();
      push_value(d1); }
}

static void mwunpack1 (void){
    mwpack_uncons();
    mwnip();
}

static void mwpack_uncons (void){
    mwprim_2E_pack_2E_uncons();
}

static value_t* fieldptr_word_ctx_type (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwword_ctx_type_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_ctx_type(index);
    incref(v); push_value(v);
}
static void mwword_ctx_type_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_ctx_type(index);
    incref(v); push_value(v);
}
static void mwword_ctx_type_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_word_ctx_type(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwlen (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_i64(0LL);
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    push_i64(1LL);
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop2();
    push_i64(2LL);
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop3();
    push_i64(3LL);
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwdrop2();
      push_value(d2); }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwand (void){
    {
    value_t var_f_147 = pop_value();
    if (pop_u64()) {
    push_value(var_f_147);
    incref(var_f_147);
    do_run();
    } else {
    mwfalse();
    }
    decref(var_f_147);
    }
}

static void mb_ab_optimized_snoc_21__3 (void) {
    do_drop();
    mwatoms_has_last_block_3F_();
}
static void mwatoms_has_last_block_3F_ (void){
    mwdup();
    mwlast();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwfalse();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwatom_op_40_();
    switch (get_top_data_tag()) {
    case 12LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwlast (void){
    mwList__3E_List_2B_();
    push_u64(0);
    push_fnptr(&mb_last_1);
    do_pack_cons();
    mwmaybe_map();
}

static void mb_last_1 (void) {
    do_drop();
    mwlast_2B_();
}
static void mwlast_2B_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwdrop();
      push_value(d2); }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwdrop2();
      push_value(d2); }
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwnip();
    mwlast_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwmaybe_map (void){
    {
    value_t var_f_294 = pop_value();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwNONE();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_294);
    incref(var_f_294);
    do_run();
    mwSOME();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_294);
    }
}

static void mwdip_3F_ (void){
    {
    value_t var_f_114 = pop_value();
    { value_t d2 = pop_value();
    push_value(var_f_114);
    incref(var_f_114);
    do_run();
      push_value(d2); }
    mwswap();
    decref(var_f_114);
    }
}

static value_t* fieldptr_arrow_atoms (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_atoms_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_atoms(index);
    incref(v); push_value(v);
}
static void mwarrow_atoms_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_atoms(index);
    incref(v); push_value(v);
}
static void mwarrow_atoms_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_atoms(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_type_21_ (void){
    mwab_arrow_40_();
    mwarrow_cod_21_();
}

static value_t* fieldptr_atom_cod (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_cod_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_cod(index);
    incref(v); push_value(v);
}
static void mwatom_cod_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_cod(index);
    incref(v); push_value(v);
}
static void mwatom_cod_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_cod(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_atom_dom (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_dom_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_dom(index);
    incref(v); push_value(v);
}
static void mwatom_dom_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_dom(index);
    incref(v); push_value(v);
}
static void mwatom_dom_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_dom(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_expand_opsig_21_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwab_type_40_();
    mwdup();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwab_type_40_();
    mwdup();
      push_value(d2); }
    mwTTensor();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwab_type_40_();
      push_value(d2); }
    mwab_token_40_();
    mwelab_expand_morphism_21_();
    mwswap();
    { value_t d2 = pop_value();
    mwelab_type_unify_21_();
    mwdrop();
      push_value(d2); }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static value_t* fieldptr_atom_subst (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_subst_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_subst(index);
    incref(v); push_value(v);
}
static void mwatom_subst_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_subst(index);
    incref(v); push_value(v);
}
static void mwatom_subst_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_subst(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_op_fresh_sig_21_ (void){
    mwsubst_nil();
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwOPSIG_ID();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwVALUE_INT();
    mwTValue();
    mwOPSIG_PUSH();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwVALUE_STR();
    mwTValue();
    mwOPSIG_PUSH();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwTYPE_PTR();
    mwOPSIG_PUSH();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    mwelab_tag_sig_21_();
    mwtype_freshen_sig();
    mwOPSIG_APPLY();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwelab_word_sig_21_();
    mwtype_freshen_sig();
    mwOPSIG_APPLY();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwprim_type_40_();
    mwtype_freshen_sig();
    mwOPSIG_APPLY();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwelab_external_sig_21_();
    mwtype_freshen_sig();
    mwOPSIG_APPLY();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwelab_field_word_type_21_();
    mwtype_freshen_sig();
    mwOPSIG_APPLY();
    break;
    case 12LL:
    do_pack_uncons(); do_drop();
    mwelab_block_sig_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    mwelab_var_sig_21_();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    mwelab_match_sig_21_();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    mwelab_lambda_sig_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwelab_lambda_sig_21_ (void){
    mwlambda_dom_3F_();
    mwswap();
    mwlambda_cod_40_();
    mwT__3E_();
    mwOPSIG_APPLY();
}

static value_t* fieldptr_lambda_cod (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_cod_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_cod(index);
    incref(v); push_value(v);
}
static void mwlambda_cod_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_cod(index);
    incref(v); push_value(v);
}
static void mwlambda_cod_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_cod(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_lambda_dom (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_dom_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_dom(index);
    incref(v); push_value(v);
}
static void mwlambda_dom_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_dom(index);
    incref(v); push_value(v);
}
static void mwlambda_dom_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_dom(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_match_sig_21_ (void){
    mwmatch_dom_3F_();
    mwswap();
    mwmatch_cod_40_();
    mwT__3E_();
    mwOPSIG_APPLY();
}

static value_t* fieldptr_match_cod (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmatch_cod_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_cod(index);
    incref(v); push_value(v);
}
static void mwmatch_cod_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_cod(index);
    incref(v); push_value(v);
}
static void mwmatch_cod_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_match_cod(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_match_dom (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmatch_dom_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_dom(index);
    incref(v); push_value(v);
}
static void mwmatch_dom_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_dom(index);
    incref(v); push_value(v);
}
static void mwmatch_dom_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_match_dom(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_var_sig_21_ (void){
    mwvar_auto_run_3F_();
    if (pop_u64()) {
    mwvar_type_40_();
    mwtype_semifreshen_sig();
    mwOPSIG_APPLY();
    } else {
    mwvar_type_40_();
    mwOPSIG_PUSH();
    }
}

static void mwtype_semifreshen_sig (void){
    mwtype_sig_needs_fresh_stack_rest_3F_();
    if (pop_u64()) {
    mwtype_semifreshen_sig_aux();
    } else {
    mwid();
    }
}

static void mwtype_semifreshen_sig_aux (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwmeta_alloc_21_();
    mwTMeta();
    mwrotr();
    { value_t d2 = pop_value();
    mwtype_semifreshen_sig_stack();
      push_value(d2); }
    mwswap();
    { value_t d2 = pop_value();
    mwtype_semifreshen_sig_stack();
      push_value(d2); }
    mwswap();
    mwTMorphism();
    mwnip();
    break;
    default:
    mwid();
    break;
    }
}

static void mwtype_semifreshen_sig_stack (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwtype_semifreshen_sig_stack();
      push_value(d2); }
    mwTTensor();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdup();
    break;
    default:
    mwTPrim();
    break;
    }
    break;
    default:
    mwid();
    break;
    }
}

static void mwtype_sig_needs_fresh_stack_rest_3F_ (void){
    mwdup();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_stack_rest();
    mwTYPE_UNIT();
    mw_3D__3D_();
    if (pop_u64()) {
    mwtype_stack_rest();
    mwTYPE_UNIT();
    mw_3D__3D_();
    } else {
    mwdrop();
    mwfalse();
    }
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtype_stack_rest (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwtype_stack_rest();
    break;
    default:
    mwid();
    break;
    }
}

static void mwelab_block_sig_21_ (void){
    mwVALUE_BLOCK();
    mwTValue();
    mwOPSIG_PUSH();
}

static value_t* fieldptr_prim_type (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwprim_type_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_type(index);
    incref(v); push_value(v);
}
static void mwprim_type_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_type(index);
    incref(v); push_value(v);
}
static void mwprim_type_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_prim_type(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtype_freshen_sig (void){
    mwtype_sig_needs_fresh_stack_rest_3F_();
    if (pop_u64()) {
    mwtype_freshen_sig_aux();
    } else {
    mwtype_freshen();
    }
}

static void mwtype_freshen (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_drop();
    mwTYPE_DONT_CARE();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwTPrim();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwTHole();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwTData();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwTTable();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    mwTValue();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwtype_var_freshen();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwmeta_freshen();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_pair_freshen();
    mwTTensor();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_pair_freshen();
    mwTMorphism();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwtype_pair_freshen();
    mwTApp();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwtype_pair_freshen (void){
    { value_t d1 = pop_value();
    mwtype_freshen();
    mwswap();
      push_value(d1); }
    mwtype_freshen();
    { value_t d1 = pop_value();
    mwswap();
      push_value(d1); }
}

static void mwmeta_freshen (void){
    mwmeta_is_defined_3F_();
    if (pop_u64()) {
    mwmeta_expand();
    mwtype_freshen();
    } else {
    mwdrop();
    mwmeta_alloc_21_();
    mwTMeta();
    }
}

static void mwmeta_expand (void){
    mwmeta_is_defined_3F_();
    if (pop_u64()) {
    mwdup();
    { value_t d2 = pop_value();
    mwmeta_type_raw_40_();
    mwtype_expand();
    mwdup();
      push_value(d2); }
    mwmeta_type_raw_21_();
    } else {
    mwTMeta();
    }
}

static value_t* fieldptr_meta_type_raw (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmeta_type_raw_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_meta_type_raw(index);
    incref(v); push_value(v);
}
static void mwmeta_type_raw_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_meta_type_raw(index);
    incref(v); push_value(v);
}
static void mwmeta_type_raw_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_meta_type_raw(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_meta_is_defined (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmeta_is_defined_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_meta_is_defined(index);
    incref(v); push_value(v);
}
static void mwmeta_is_defined_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_meta_is_defined(index);
    incref(v); push_value(v);
}
static void mwmeta_is_defined_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_meta_is_defined(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtype_var_freshen (void){
    mwswap();
    mwsubst_has_var_3F_();
    if (pop_u64()) {
    mwtuck();
    mwsubst_get_var();
    } else {
    mwmeta_alloc_21_();
    mwTMeta();
    mwdup();
    { value_t d2 = pop_value();
    mwrotr();
    mwsubst_new_21_();
      push_value(d2); }
    }
}

static void mwsubst_new_21_ (void){
    mwunSUBST();
    mwrotr();
    mwpack2();
    mwmap_insert();
    mwSUBST();
}

static void mwmap_insert (void){
    { value_t d1 = pop_value();
    mwunMAP();
      push_value(d1); }
    mwbag_replace_key();
    mwMAP();
}

static void mwbag_replace_key (void){
    mwbag_replace_key_2B_();
    mwBag_2B___3E_Bag();
}

static void mwBag_2B___3E_Bag (void){
    mwunBAG_2B_();
    mwList_2B___3E_List();
    mwBAG();
}

static void mwunBAG_2B_ (void){
    mwid();
}

static void mwbag_replace_key_2B_ (void){
    mwswap();
    mwBag__3E_Bag_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwB1_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwbag_replace_key_2B__2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwbag_replace_key_2B__2B_ (void){
    mwover();
    mwbag_is_singleton_2B_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwbag_first_2B_();
      push_value(d2); }
    mwdup2();
    mw_3D__3D_key();
    if (pop_u64()) {
    mwnip();
    mwB1_2B_();
    } else {
    mwB2_2B_();
    }
    } else {
    { value_t d2 = pop_value();
    mwbag_split_half_right();
    mwdup();
    mwbag_first_2B_();
      push_value(d2); }
    mwdup2();
    mw_3C__3D_key();
    if (pop_u64()) {
    mwnip();
    mwbag_replace_key_2B__2B_();
    mwbag_cat_unsafe__2B_();
    } else {
    mwnip();
    mwswap();
    { value_t d3 = pop_value();
    mwbag_replace_key_2B_();
      push_value(d3); }
    mwbag_cat_unsafe_2B_();
    }
    }
}

static void mwbag_cat_unsafe_2B_ (void){
    { value_t d1 = pop_value();
    mwunBAG_2B_();
      push_value(d1); }
    mwunBAG_2B_();
    mwcat_2B_();
    mwBAG_2B_();
}

static void mwbag_cat_unsafe__2B_ (void){
    { value_t d1 = pop_value();
    mwunBAG();
      push_value(d1); }
    mwunBAG_2B_();
    mwcat__2B_();
    mwBAG_2B_();
}

static void mwunBAG (void){
    mwid();
}

static void mw_3C__3D_key (void){
    { value_t d1 = pop_value();
    mw_2E_0();
      push_value(d1); }
    mw_2E_0();
    mw_3C__3D_();
}

static void mw_2E_0 (void){
    mwpack_uncons();
    mwnip();
}

static void mwbag_split_half_right (void){
    mwunBAG_2B_();
    mwsplit_half_right();
    { value_t d1 = pop_value();
    mwBAG();
      push_value(d1); }
    mwBAG_2B_();
}

static void mwB2_2B_ (void){
    mworder2();
    mwL2_2B_();
    mwBAG_2B_();
}

static void mworder2 (void){
    mwdup2();
    mw_3C__3D_();
    if (pop_u64()) {
    mwid();
    } else {
    mwswap();
    }
}

static void mw_3D__3D_key (void){
    { value_t d1 = pop_value();
    mw_2E_0();
      push_value(d1); }
    mw_2E_0();
    mw_3D__3D_();
}

static void mwbag_first_2B_ (void){
    mwunBAG_2B_();
    mwfirst_2B_();
}

static void mwfirst_2B_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop2();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop2();
    mwfirst_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwbag_is_singleton_2B_ (void){
    mwbag_len_2B_();
    push_i64(1LL);
    mw_3D__3D_();
}

static void mwbag_len_2B_ (void){
    mwunBAG_2B_();
    mwlen_2B_();
}

static void mwB1_2B_ (void){
    mwL1_2B_();
    mwBAG_2B_();
}

static void mwBag__3E_Bag_2B_ (void){
    mwunBAG();
    mwList__3E_List_2B_();
    push_u64(0);
    push_fnptr(&mb_Bag__3E_Bag_2B__1);
    do_pack_cons();
    mwmaybe_map();
}

static void mb_Bag__3E_Bag_2B__1 (void) {
    do_drop();
    mwBAG_2B_();
}
static void mwunMAP (void){
    mwid();
}

static void mwpack2 (void){
    { value_t d1 = pop_value();
    mwpack1();
      push_value(d1); }
    mwpack_cons();
}

static void mwpack_cons (void){
    mwprim_2E_pack_2E_cons();
}

static void mwpack1 (void){
    { value_t d1 = pop_value();
    mwpack0();
      push_value(d1); }
    mwpack_cons();
}

static void mwpack0 (void){
    mwpack_nil();
}

static void mwpack_nil (void){
    mwnil();
}

static void mwunSUBST (void){
    mwid();
}

static void mwsubst_get_var (void){
    mwunSUBST();
    mwswap();
    mwmap_lookup();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwid();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwmap_lookup (void){
    { value_t d1 = pop_value();
    mwunMAP();
      push_value(d1); }
    mwbag_lookup_key();
}

static void mwbag_lookup_key (void){
    mwswap();
    mwBag__3E_Bag_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwNONE();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwbag_lookup_key_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwbag_lookup_key_2B_ (void){
    mwover();
    mwbag_is_singleton_2B_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwbag_first_2B_();
    mwunpack2();
      push_value(d2); }
    mw_3D__3D_();
    if (pop_u64()) {
    mwSOME();
    } else {
    mwdrop();
    mwNONE();
    }
    } else {
    { value_t d2 = pop_value();
    mwbag_split_half_right();
    mwdup();
    mwbag_first_2B_();
    mwunpack2();
      push_value(d2); }
    mwcmp_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop2();
    mwSOME();
    { value_t d3 = pop_value();
    mwdrop2();
      push_value(d3); }
    break;
    case 1LL:
    do_drop();
    { value_t d3 = pop_value();
    mwdrop2();
    mwnip();
      push_value(d3); }
    mwbag_lookup_key_2B_();
    break;
    case 2LL:
    do_drop();
    { value_t d3 = pop_value();
    mwdrop3();
      push_value(d3); }
    mwbag_lookup_key();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    }
}

static void mwcmp_3F_ (void){
    mwdup2();
    mwcmp();
}

static void mwcmp (void){
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop2();
    mwEQ();
    } else {
    mw_3C_();
    if (pop_u64()) {
    mwLT();
    } else {
    mwGT();
    }
    }
}

static void mwsubst_has_var_3F_ (void){
    mwdup2();
    mwsubst_has_var();
}

static void mwsubst_has_var (void){
    mwunSUBST();
    mwswap();
    mwmap_has();
}

static void mwmap_has (void){
    mwmap_lookup();
    mwis_some();
}

static void mwis_some (void){
    mwis_nil();
    mwnot();
}

static void mwtype_freshen_sig_aux (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwmeta_alloc_21_();
    mwTMeta();
    mwrot4r();
    { value_t d2 = pop_value();
    mwtype_freshen_sig_stack();
      push_value(d2); }
    mwswap();
    { value_t d2 = pop_value();
    mwtype_freshen_sig_stack();
      push_value(d2); }
    mwswap();
    mwTMorphism();
    { value_t d2 = pop_value();
    mwnip();
      push_value(d2); }
    break;
    default:
    mwtype_freshen();
    break;
    }
}

static void mwtype_freshen_sig_stack (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwtype_freshen_sig_stack();
      push_value(d2); }
    mwswap();
    { value_t d2 = pop_value();
    mwtype_freshen();
      push_value(d2); }
    mwswap();
    mwTTensor();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwover();
    break;
    default:
    mwTPrim();
    break;
    }
    break;
    default:
    mwtype_freshen();
    break;
    }
}

static void mwrot4r (void){
    mwswap();
    { value_t d1 = pop_value();
    mwrotr();
      push_value(d1); }
}

static void mwTYPE_PTR (void){
    mwPRIM_TYPE_PTR();
    mwTPrim();
}

static void mwsubst_nil (void){
    mwnil();
}

static value_t* fieldptr_atom_op (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_op_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_op(index);
    incref(v); push_value(v);
}
static void mwatom_op_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_op(index);
    incref(v); push_value(v);
}
static void mwatom_op_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_op(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_atom_token (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_token_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_token(index);
    incref(v); push_value(v);
}
static void mwatom_token_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_token(index);
    incref(v); push_value(v);
}
static void mwatom_token_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_token(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_atom_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwatom_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_ctx(index);
    incref(v); push_value(v);
}
static void mwatom_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_atom_ctx(index);
    incref(v); push_value(v);
}
static void mwatom_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_atom_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwAtom_2E_alloc_21_ (void){
    mwAtom_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwAtom_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwblock_new_deferred_21_ (void){
    mwBlock_2E_alloc_21_();
    mwtrue();
    mwover();
    mwblock_deferred_21_();
    mwtuck();
    mwblock_token_21_();
    mwtuck();
    mwblock_ctx_21_();
}

static void mwBlock_2E_alloc_21_ (void){
    mwBlock_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwBlock_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwab_str_21_ (void){
    mwOP_STR();
    mwab_op_21_();
}

static void mwab_int_21_ (void){
    mwOP_INT();
    mwab_op_21_();
}

static void mwelab_atom_name_21_ (void){
    mwdup();
    mwab_ctx_40_();
    mwctx_lookup();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwelab_args_21_();
    mwab_var_21_();
    break;
    case 0LL:
    do_drop();
    mwname_def_40_();
    switch (get_top_data_tag()) {
    case 6LL:
    do_pack_uncons(); do_drop();
    mwelab_no_args_21_();
    mwab_buffer_21_();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwelab_no_args_21_();
    mwab_external_21_();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    mwelab_no_args_21_();
    mwab_fieldword_21_();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwelab_args_21_();
    mwab_word_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwelab_args_21_();
    mwab_tag_21_();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwelab_prim_21_();
    break;
    default:
    mwdrop();
    mwab_token_40_();
    push_ptr("Unknown word.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    mwab_type_21_();
    break;
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwelab_prim_21_ (void){
    switch (get_top_data_tag()) {
    case 9LL:
    do_drop();
    mwelab_atom_match_21_();
    break;
    case 10LL:
    do_drop();
    mwelab_atom_lambda_21_();
    break;
    default:
    mwelab_args_21_();
    mwab_prim_21_();
    break;
    }
}

static void mwab_prim_21_ (void){
    mwprim_type_3F_();
    mwis_nil();
    if (pop_u64()) {
    mwab_token_40_();
    push_ptr("compiler error: prim type missing\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    mwOP_PRIM();
    mwab_op_21_();
    }
}

static void mwelab_atom_lambda_21_ (void){
    mwLambda_2E_alloc_21_();
    mwab_ctx_40_();
    mwover();
    mwlambda_outer_ctx_21_();
    mwab_type_40_();
    mwover();
    mwlambda_dom_21_();
    mwab_token_40_();
    mwover();
    mwlambda_token_21_();
    mwelab_lambda_21_();
    mwOP_LAMBDA();
    mwab_op_21_();
}

static void mwelab_lambda_21_ (void){
    mwelab_lambda_params_21_();
    mwelab_lambda_body_21_();
}

static void mwelab_lambda_body_21_ (void){
    mwlambda_token_3F_();
    mwtoken_args_1();
    while(1) {
    mwtoken_is_lambda_param_3F_();
    if (!pop_u64()) break;
    mwtoken_next();
    }
    mwtoken_succ();
    { value_t d1 = pop_value();
    mwlambda_mid_3F_();
    { value_t d2 = pop_value();
    mwlambda_inner_ctx_3F_();
      push_value(d2); }
      push_value(d1); }
    mwelab_arrow_fwd_21_();
    mwdup2();
    mwswap();
    mwlambda_body_21_();
    mwarrow_cod_40_();
    mwover();
    mwlambda_cod_21_();
}

static value_t* fieldptr_lambda_body (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_body_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_body(index);
    incref(v); push_value(v);
}
static void mwlambda_body_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_body(index);
    incref(v); push_value(v);
}
static void mwlambda_body_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_body(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_arrow_fwd_21_ (void){
    push_u64(0);
    push_fnptr(&mb_elab_arrow_fwd_21__1);
    do_pack_cons();
    mwab_build_21_();
}

static void mb_elab_arrow_fwd_21__1 (void) {
    do_drop();
    mwelab_atoms_21_();
}
static value_t* fieldptr_lambda_inner_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_inner_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_inner_ctx(index);
    incref(v); push_value(v);
}
static void mwlambda_inner_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_inner_ctx(index);
    incref(v); push_value(v);
}
static void mwlambda_inner_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_inner_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_lambda_mid (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_mid_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_mid(index);
    incref(v); push_value(v);
}
static void mwlambda_mid_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_mid(index);
    incref(v); push_value(v);
}
static void mwlambda_mid_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_mid(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtoken_is_lambda_param_3F_ (void){
    mwsig_token_is_type_var_3F_();
    if (pop_u64()) {
    mwtoken_has_args_3F_();
    mwnot();
    } else {
    mwtoken_is_lsquare_3F_();
    if (pop_u64()) {
    mwdup();
    mwtrue();
    { value_t d3 = pop_value();
    mwtoken_succ();
    mwsig_token_is_type_var_3F_();
      push_value(d3); }
    mw_26__26_();
    { value_t d3 = pop_value();
    mwtoken_succ();
    mwtoken_is_rsquare_3F_();
      push_value(d3); }
    mw_26__26_();
    mwnip();
    } else {
    mwfalse();
    }
    }
}

static void mwtoken_is_rsquare_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 5LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtoken_has_args_3F_ (void){
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwdup();
    mwtoken_succ();
    mwtoken_is_lparen_3F_();
    mwnip();
    } else {
    mwfalse();
    }
}

static void mwtoken_is_lparen_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtoken_is_name_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwelab_lambda_params_21_ (void){
    mwlambda_outer_ctx_3F_();
    mwover();
    mwlambda_inner_ctx_21_();
    mwlambda_dom_3F_();
    mwover();
    mwlambda_mid_21_();
    mwlambda_token_3F_();
    mwtoken_args_1();
    while(1) {
    mwtoken_is_lambda_param_3F_();
    if (!pop_u64()) break;
    mwtoken_next();
    }
    mwexpect_token_arrow();
    mwtoken_prev();
    while(1) {
    mwtoken_is_lambda_param_3F_();
    if (!pop_u64()) break;
    mwelab_lambda_pop_from_mid_21_();
    mwdup();
    { value_t d2 = pop_value();
    mwsig_token_is_type_var_3F_();
    if (pop_u64()) {
    mwtoken_name_40_();
    mwvar_new_21_();
    mwtuck();
    mwvar_type_21_();
    } else {
    mwtoken_succ();
    { value_t d4 = pop_value();
    mwtype_expand();
    mwtype_is_morphism_3F_();
      push_value(d4); }
    mwswap();
    if (pop_u64()) {
    mwtoken_name_40_();
    mwvar_new_21_();
    mwtrue();
    mwover();
    mwvar_auto_run_21_();
    mwtuck();
    mwvar_type_21_();
    } else {
    push_ptr("block pattern on non-block argument\0\0\0");
    mwemit_fatal_error_21_();
    }
    }
    { value_t d3 = pop_value();
    mwlambda_params_3F_();
      push_value(d3); }
    mwdup();
    { value_t d3 = pop_value();
    mwVar__3E_Param();
    mwswap();
    mwcons();
    mwover();
    mwlambda_params_21_();
      push_value(d3); }
    { value_t d3 = pop_value();
    mwlambda_inner_ctx_3F_();
      push_value(d3); }
    mwctx_new_21_();
    mwover();
    mwlambda_inner_ctx_21_();
      push_value(d2); }
    mwtoken_prev();
    }
    mwdrop();
}

static void mwcons (void){
    mwcons_2B_();
    mwList_2B___3E_List();
}

static void mwVar__3E_Param (void){
    mwPARAM();
}

static value_t* fieldptr_lambda_params (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_params_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_params(index);
    incref(v); push_value(v);
}
static void mwlambda_params_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_params(index);
    incref(v); push_value(v);
}
static void mwlambda_params_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_params(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtype_is_morphism_3F_ (void){
    mwdup();
    mwtype_is_morphism();
}

static void mwtype_is_morphism (void){
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop2();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtoken_name_40_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    default:
    mwdrop();
    push_ptr("expected name\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static void mwelab_lambda_pop_from_mid_21_ (void){
    { value_t d1 = pop_value();
    mwlambda_mid_3F_();
      push_value(d1); }
    mwelab_expand_tensor_21_();
    push_u64(0);
    push_fnptr(&mb_elab_lambda_pop_from_mid_21__2);
    do_pack_cons();
    mwdip2();
}

static void mb_elab_lambda_pop_from_mid_21__2 (void) {
    do_drop();
    mwover();
    mwlambda_mid_21_();
}
static void mwelab_expand_tensor_21_ (void){
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    { value_t d2 = pop_value();
    mwTYPE_ERROR();
    mwTYPE_ERROR();
      push_value(d2); }
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwid();
    mwrotl();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwmeta_alloc_21_();
    mwTMeta();
    mwmeta_alloc_21_();
    mwTMeta();
    mwdup2();
    mwTTensor();
      push_value(d2); }
    mwmeta_type_21_();
    mwrotl();
    break;
    default:
    mwdrop();
    mwdup();
    push_ptr("expected tuple type\0\0\0");
    mwemit_error_21_();
    { value_t d2 = pop_value();
    mwTYPE_ERROR();
    mwTYPE_ERROR();
      push_value(d2); }
    break;
    }
}

static void mwmeta_type_21_ (void){
    mwtrue();
    mwover();
    mwmeta_is_defined_21_();
    mwmeta_type_raw_21_();
}

static void mwtoken_prev (void){
    mwtoken_pred();
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 5LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwdup();
    mwtoken_pred();
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwnip();
    } else {
    mwdrop();
    }
    break;
    default:
    mwdrop();
    break;
    }
}

static void mwtoken_pred (void){
    mwToken_2E_pred();
}

static void mwToken_2E_pred (void){
    mwprim_2E_unsafe_2E_cast();
    mwprim_2E_core_2E_dup();
    push_i64(0LL);
    mwprim_2E_value_2E_eq();
    if (pop_u64()) {
    } else {
    push_i64(1LL);
    mwprim_2E_int_2E_sub();
    }
    mwprim_2E_unsafe_2E_cast();
}

static void mwexpect_token_arrow (void){
    mwtoken_is_arrow_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("Expected arrow.\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwtoken_is_arrow_3F_ (void){
    mwPRIM_SYNTAX_ARROW();
    mwtoken_prim_3D__3F_();
}

static value_t* fieldptr_lambda_token (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_token_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_token(index);
    incref(v); push_value(v);
}
static void mwlambda_token_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_token(index);
    incref(v); push_value(v);
}
static void mwlambda_token_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_token(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_lambda_outer_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwlambda_outer_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_outer_ctx(index);
    incref(v); push_value(v);
}
static void mwlambda_outer_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_lambda_outer_ctx(index);
    incref(v); push_value(v);
}
static void mwlambda_outer_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_lambda_outer_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwLambda_2E_alloc_21_ (void){
    mwLambda_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwLambda_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwelab_atom_match_21_ (void){
    mwMatch_2E_alloc_21_();
    mwab_ctx_40_();
    mwover();
    mwmatch_ctx_21_();
    mwab_type_40_();
    mwover();
    mwmatch_dom_21_();
    mwab_token_40_();
    mwover();
    mwmatch_token_21_();
    mwmeta_alloc_21_();
    mwTMeta();
    mwover();
    mwmatch_cod_21_();
    mwelab_match_21_();
    mwOP_MATCH();
    mwab_op_21_();
}

static void mwelab_match_21_ (void){
    mwelab_match_cases_21_();
    mwelab_match_exhaustive_21_();
}

static void mwelab_match_exhaustive_21_ (void){
    mwmatch_is_exhaustive_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwmatch_token_3F_();
    push_ptr("Pattern match not exhaustive.\0\0\0");
    mwemit_error_21_();
    }
}

static void mwmatch_is_exhaustive_3F_ (void){
    mwmatch_has_default_case_3F_();
    if (pop_u64()) {
    mwtrue();
    } else {
    mwmatch_scrutinee_data_3F_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdata_num_tags();
    mwover();
    mwmatch_cases_40_();
    mwlen();
    mw_3D__3D_();
    break;
    case 0LL:
    do_drop();
    mwtrue();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    }
}

static value_t* fieldptr_match_cases (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmatch_cases_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_cases(index);
    incref(v); push_value(v);
}
static void mwmatch_cases_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_cases(index);
    incref(v); push_value(v);
}
static void mwmatch_cases_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_match_cases(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwdata_num_tags (void){
    mwdata_tags_40_();
    mwlen();
}

static value_t* fieldptr_data_tags (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwdata_tags_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_tags(index);
    incref(v); push_value(v);
}
static void mwdata_tags_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_tags(index);
    incref(v); push_value(v);
}
static void mwdata_tags_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_data_tags(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwmatch_scrutinee_data_3F_ (void){
    mwmatch_scrutinee_type_3F_();
    push_u64(0);
    push_fnptr(&mb_match_scrutinee_data_3F__1);
    do_pack_cons();
    mwmaybe_bind();
}

static void mb_match_scrutinee_data_3F__1 (void) {
    do_drop();
    mwtype_head();
    switch (get_top_data_tag()) {
    case 7LL:
    do_pack_uncons(); do_drop();
    mwSOME();
    break;
    default:
    mwdrop();
    mwNONE();
    break;
    }
}
static void mwtype_head (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwtype_head();
    break;
    default:
    mwid();
    break;
    }
}

static void mwmaybe_bind (void){
    {
    value_t var_f_372 = pop_value();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwNONE();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_372);
    incref(var_f_372);
    do_run();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_372);
    }
}

static void mwmatch_scrutinee_type_3F_ (void){
    mwmatch_dom_3F_();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwnip();
    mwSOME();
    break;
    default:
    mwdrop();
    mwNONE();
    break;
    }
}

static void mwmatch_has_default_case_3F_ (void){
    mwmatch_cases_3F_();
    mwcases_have_default_case();
}

static void mwcases_have_default_case (void){
    push_u64(0);
    push_fnptr(&mb_cases_have_default_case_1);
    do_pack_cons();
    mwany();
}

static void mb_cases_have_default_case_1 (void) {
    do_drop();
    mwdup();
    mwcase_is_default_case();
}
static void mwcase_is_default_case (void){
    mwcase_pattern_40_();
    mwPATTERN_UNDERSCORE();
    mw_3D__3D_();
}

static value_t* fieldptr_case_pattern (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwcase_pattern_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_pattern(index);
    incref(v); push_value(v);
}
static void mwcase_pattern_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_pattern(index);
    incref(v); push_value(v);
}
static void mwcase_pattern_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_case_pattern(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwany (void){
    {
    value_t var_f_351 = pop_value();
    push_value(var_f_351);
    incref(var_f_351);
    mwfind();
    mwis_some();
    decref(var_f_351);
    }
}

static void mwfind (void){
    {
    value_t var_f_336 = pop_value();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwNONE();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_336);
    incref(var_f_336);
    mwfind_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_336);
    }
}

static void mwfind_2B_ (void){
    {
    value_t var_f_339 = pop_value();
    switch (get_top_data_tag()) {
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    { value_t d3 = pop_value();
    push_value(var_f_339);
    incref(var_f_339);
    mwfind_2B_();
      push_value(d3); }
    mwswap();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwSOME();
    break;
    case 0LL:
    do_drop();
    push_value(var_f_339);
    incref(var_f_339);
    mwfind_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    break;
    default:
    mwuncons();
    { value_t d3 = pop_value();
    push_value(var_f_339);
    incref(var_f_339);
    do_run();
      push_value(d3); }
    mwswap();
    if (pop_u64()) {
    mwdrop();
    mwSOME();
    } else {
    mwnip();
    push_value(var_f_339);
    incref(var_f_339);
    mwfind();
    }
    break;
    }
    decref(var_f_339);
    }
}

static void mwuncons (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL0();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwL1();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwL2();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    { value_t d2 = pop_value();
    mwuncons();
      push_value(d2); }
    mwcat__2B_();
    mwList_2B___3E_List();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwelab_match_cases_21_ (void){
    mwmatch_token_3F_();
    mwtoken_has_args_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    mwtoken_succ();
    while(1) {
    mwtoken_is_rparen_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwelab_match_case_21_();
    }
    mwdrop();
    } else {
    push_ptr("match expects an arg\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwelab_match_case_21_ (void){
    mwCase_2E_alloc_21_();
    mwdup2();
    mwcase_token_21_();
    mwswap();
    { value_t d1 = pop_value();
    mwdup2();
    mwcase_match_21_();
      push_value(d1); }
    mwelab_case_pattern_21_();
    mwexpect_token_arrow();
    mwtoken_succ();
    mwelab_case_body_21_();
    { value_t d1 = pop_value();
    mwmatch_add_case_21_();
      push_value(d1); }
    mwtoken_is_comma_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
}

static void mwtoken_is_comma_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_drop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwmatch_add_case_21_ (void){
    { value_t d1 = pop_value();
    mwmatch_cases_3F_();
      push_value(d1); }
    mwcases_cover_case_3F_();
    if (pop_u64()) {
    mwcase_token_40_();
    push_ptr("Case is unreachable.\0\0\0");
    mwemit_error_21_();
    mwdrop();
    } else {
    mwsnoc();
    mwover();
    mwmatch_cases_21_();
    }
}

static void mwcases_cover_case_3F_ (void){
    mwdup2();
    mwcases_cover_case();
}

static void mwcases_cover_case (void){
    mwswap();
    push_u64(0);
    push_fnptr(&mb_cases_cover_case_1);
    do_pack_cons();
    mwany();
    mwnip();
}

static void mb_cases_cover_case_1 (void) {
    do_drop();
    mwdup2();
    mwcase_is_covered();
}
static void mwcase_is_covered (void){
    { value_t d1 = pop_value();
    mwcase_pattern_40_();
      push_value(d1); }
    mwcase_pattern_40_();
    mwpattern_is_covered();
}

static void mwpattern_is_covered (void){
    mwdup();
    mwPATTERN_UNDERSCORE();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop2();
    mwtrue();
    } else {
    mw_3D__3D_();
    }
}

static void mwelab_case_body_21_ (void){
    { value_t d1 = pop_value();
    mwcase_mid_3F_();
    { value_t d2 = pop_value();
    mwcase_match_3F_();
    mwmatch_ctx_40_();
      push_value(d2); }
      push_value(d1); }
    mwelab_arrow_fwd_21_();
    mwarrow_token_end_3F_();
    { value_t d1 = pop_value();
    mwarrow_cod_3F_();
      push_value(d1); }
    push_u64(0);
    push_fnptr(&mb_elab_case_body_21__4);
    do_pack_cons();
    mwdip2();
    push_u64(0);
    push_fnptr(&mb_elab_case_body_21__5);
    do_pack_cons();
    mwdip2();
    mwelab_type_unify_21_();
    mwnip();
}

static void mb_elab_case_body_21__5 (void) {
    do_drop();
    mwcase_match_3F_();
    mwmatch_cod_40_();
}
static void mb_elab_case_body_21__4 (void) {
    do_drop();
    mwover();
    mwcase_body_21_();
}
static value_t* fieldptr_case_body (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwcase_body_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_body(index);
    incref(v); push_value(v);
}
static void mwcase_body_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_body(index);
    incref(v); push_value(v);
}
static void mwcase_body_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_case_body(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_case_mid (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwcase_mid_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_mid(index);
    incref(v); push_value(v);
}
static void mwcase_mid_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_mid(index);
    incref(v); push_value(v);
}
static void mwcase_mid_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_case_mid(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_case_pattern_21_ (void){
    mwtoken_is_underscore_3F_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwPATTERN_UNDERSCORE();
    mwover();
    mwcase_pattern_21_();
      push_value(d2); }
    { value_t d2 = pop_value();
    mwcase_match_3F_();
    mwmatch_dom_40_();
    mwTYPE_DONT_CARE();
    mwTYPE_DONT_CARE();
    mwT_2A_();
      push_value(d2); }
    mwelab_type_unify_21_();
    { value_t d2 = pop_value();
    mwover();
    mwcase_mid_21_();
      push_value(d2); }
    mwtoken_succ();
    } else {
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_name_3F_();
    mwname_def_40_();
    switch (get_top_data_tag()) {
    case 3LL:
    do_pack_uncons(); do_drop();
    mwdup();
    mwPATTERN_TAG();
    mwrotr();
    push_u64(0);
    push_fnptr(&mb_elab_case_pattern_21__5);
    do_pack_cons();
    mwdip2();
    push_u64(0);
    push_fnptr(&mb_elab_case_pattern_21__6);
    do_pack_cons();
    mwdip2();
    mwelab_tag_sig_21_();
    mwsubst_nil();
    mwswap();
    mwtype_freshen_sig();
    mwrotr();
    { value_t d4 = pop_value();
    mwelab_expand_morphism_21_();
    push_u64(0);
    push_fnptr(&mb_elab_case_pattern_21__8);
    do_pack_cons();
    mwdip2();
    mwelab_type_unify_21_();
    mwnip();
    { value_t d5 = pop_value();
    mwover();
    mwcase_mid_21_();
      push_value(d5); }
      push_value(d4); }
    mwswap();
    { value_t d4 = pop_value();
    mwover();
    mwcase_subst_21_();
      push_value(d4); }
    mwtoken_succ();
    break;
    case 0LL:
    do_drop();
    push_ptr("Unknown constructor.\0\0\0");
    mwemit_fatal_error_21_();
    break;
    default:
    mwdrop();
    push_ptr("Not a constructor.\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
    } else {
    push_ptr("Expected constructor name.\0\0\0");
    mwemit_fatal_error_21_();
    }
    }
}

static value_t* fieldptr_case_subst (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwcase_subst_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_subst(index);
    incref(v); push_value(v);
}
static void mwcase_subst_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_subst(index);
    incref(v); push_value(v);
}
static void mwcase_subst_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_case_subst(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mb_elab_case_pattern_21__8 (void) {
    do_drop();
    mwswap();
}
static void mb_elab_case_pattern_21__6 (void) {
    do_drop();
    mwcase_match_3F_();
    mwmatch_dom_40_();
}
static void mb_elab_case_pattern_21__5 (void) {
    do_drop();
    mwover();
    mwcase_pattern_21_();
}
static void mwtoken_name_3F_ (void){
    mwdup();
    mwtoken_name_40_();
}

static value_t* fieldptr_case_match (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwcase_match_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_match(index);
    incref(v); push_value(v);
}
static void mwcase_match_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_match(index);
    incref(v); push_value(v);
}
static void mwcase_match_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_case_match(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_case_token (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwcase_token_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_token(index);
    incref(v); push_value(v);
}
static void mwcase_token_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_case_token(index);
    incref(v); push_value(v);
}
static void mwcase_token_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_case_token(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwCase_2E_alloc_21_ (void){
    mwCase_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwCase_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwtoken_is_rparen_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 3LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static value_t* fieldptr_match_token (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmatch_token_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_token(index);
    incref(v); push_value(v);
}
static void mwmatch_token_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_token(index);
    incref(v); push_value(v);
}
static void mwmatch_token_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_match_token(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_match_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmatch_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_ctx(index);
    incref(v); push_value(v);
}
static void mwmatch_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_match_ctx(index);
    incref(v); push_value(v);
}
static void mwmatch_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_match_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwMatch_2E_alloc_21_ (void){
    mwMatch_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwMatch_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwab_tag_21_ (void){
    mwOP_TAG();
    mwab_op_21_();
}

static void mwab_word_21_ (void){
    mwOP_WORD();
    mwab_op_21_();
}

static void mwab_fieldword_21_ (void){
    mwOP_FIELDWORD();
    mwab_op_21_();
}

static void mwab_external_21_ (void){
    mwOP_EXTERNAL();
    mwab_op_21_();
}

static void mwab_buffer_21_ (void){
    mwOP_BUFFER();
    mwab_op_21_();
}

static void mwelab_no_args_21_ (void){
    mwab_token_40_();
    mwtoken_args_0();
}

static void mwtoken_args_0 (void){
    mwtoken_num_args_3F_();
    push_i64(0LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    } else {
    push_ptr("expected no args\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwtoken_num_args_3F_ (void){
    mwdup();
    mwtoken_num_args();
}

static void mwtoken_num_args (void){
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_has_args_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
    } else {
    mwid();
    }
    mwtoken_is_left_enclosure_3F_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    push_i64(0LL);
      push_value(d2); }
    while(1) {
    mwtoken_is_right_enclosure_3F_();
    mwnot();
    if (!pop_u64()) break;
    { value_t d3 = pop_value();
    mw1_2B_();
      push_value(d3); }
    mwtoken_succ();
    mwtoken_next_arg_end();
    }
    mwdrop();
    } else {
    mwdrop();
    push_i64(0LL);
    }
}

static void mwtoken_next_arg_end (void){
    while(1) {
    mwtoken_is_arg_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwtoken_next();
    }
}

static void mwtoken_is_arg_end_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_drop();
    mwtrue();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtoken_is_right_enclosure_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 3LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwtoken_is_left_enclosure_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwab_var_21_ (void){
    mwOP_VAR();
    mwab_op_21_();
}

static void mwelab_args_21_ (void){
    mwab_token_40_();
    mwtoken_args();
    push_u64(0);
    push_fnptr(&mb_elab_args_21__1);
    do_pack_cons();
    mwreverse_for();
}

static void mb_elab_args_21__1 (void) {
    do_drop();
    mwelab_block_at_21_();
}
static void mwreverse_for (void){
    {
    value_t var_f_312 = pop_value();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_312);
    incref(var_f_312);
    do_run();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwswap();
    { value_t d3 = pop_value();
    push_value(var_f_312);
    incref(var_f_312);
    do_run();
      push_value(d3); }
    push_value(var_f_312);
    incref(var_f_312);
    do_run();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwrotr();
    push_value(var_f_312);
    incref(var_f_312);
    mwdip2();
    mwswap();
    { value_t d3 = pop_value();
    push_value(var_f_312);
    incref(var_f_312);
    do_run();
      push_value(d3); }
    push_value(var_f_312);
    incref(var_f_312);
    do_run();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwswap();
    { value_t d3 = pop_value();
    push_value(var_f_312);
    incref(var_f_312);
    mwreverse_for_2B_();
      push_value(d3); }
    push_value(var_f_312);
    incref(var_f_312);
    mwreverse_for_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_312);
    }
}

static void mwreverse_for_2B_ (void){
    {
    value_t var_f_315 = pop_value();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_315);
    incref(var_f_315);
    do_run();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwswap();
    { value_t d3 = pop_value();
    push_value(var_f_315);
    incref(var_f_315);
    do_run();
      push_value(d3); }
    push_value(var_f_315);
    incref(var_f_315);
    do_run();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwrotr();
    push_value(var_f_315);
    incref(var_f_315);
    mwdip2();
    mwswap();
    { value_t d3 = pop_value();
    push_value(var_f_315);
    incref(var_f_315);
    do_run();
      push_value(d3); }
    push_value(var_f_315);
    incref(var_f_315);
    do_run();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwswap();
    { value_t d3 = pop_value();
    push_value(var_f_315);
    incref(var_f_315);
    mwreverse_for_2B_();
      push_value(d3); }
    push_value(var_f_315);
    incref(var_f_315);
    mwreverse_for_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_315);
    }
}

static void mwtoken_args (void){
    mwtoken_has_args_3F_();
    if (pop_u64()) {
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
    mwL0();
    mwswap();
    while(1) {
    mwtoken_is_args_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwtoken_succ();
    mwdup();
    { value_t d3 = pop_value();
    mwsnoc();
      push_value(d3); }
    mwtoken_next_arg_end();
    }
    mwdrop();
    } else {
    mwdrop();
    mwL0();
    }
}

static void mwtoken_is_args_end_3F_ (void){
    mwdup();
    mwtoken_is_comma_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
    mwtoken_is_right_enclosure_3F_();
    mwnip();
}

static void mwctx_lookup (void){
    mwunCTX();
    push_u64(0);
    push_fnptr(&mb_ctx_lookup_1);
    do_pack_cons();
    mwreverse_find();
    mwnip();
}

static void mb_ctx_lookup_1 (void) {
    do_drop();
    mwdup2();
    mwvar_name_40_();
    mw_3D__3D_();
}
static void mwreverse_find (void){
    {
    value_t var_f_345 = pop_value();
    mwreverse();
    push_value(var_f_345);
    incref(var_f_345);
    mwfind();
    decref(var_f_345);
    }
}

static void mwreverse (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwL0();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwL1();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwswap();
    mwL2();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwrotr();
    mwswap();
    mwL3();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwreverse_2B_();
    mwswap();
    mwreverse_2B_();
      push_value(d2); }
    mwLCAT();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwreverse_2B_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwL1_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwswap();
    mwL2_2B_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwrotr();
    mwswap();
    mwL3_2B_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwreverse_2B_();
    mwswap();
    mwreverse_2B_();
      push_value(d2); }
    mwLCAT_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwelab_atoms_done_3F_ (void){
    mwab_token_40_();
    mwtoken_run_end_3F_();
    mwnip();
}

static void mwab_build_21_ (void){
    {
    value_t var_f_401 = pop_value();
    push_u64(0);
    push_value(var_f_401);
    incref(var_f_401);
    do_pack_cons();
    push_fnptr(&mb_ab_build_21__2);
    do_pack_cons();
    mwab_save_21_();
    decref(var_f_401);
    }
}

static void mb_ab_build_21__2 (void) {
    do_pack_uncons();
    value_t var_f_401 = pop_value();
    do_drop();
    mwArrow_2E_alloc_21_();
    mwab_home_40_();
    mwover();
    mwarrow_home_21_();
    mwab_homeidx_40_();
    mwover();
    mwarrow_homeidx_21_();
    mwab_homeidx_40_();
    mw1_2B_();
    mwab_homeidx_21_();
    mwtuck();
    mwdup2();
    mwarrow_token_start_21_();
    mwarrow_token_end_21_();
    mwtuck();
    mwdup2();
    mwarrow_dom_21_();
    mwarrow_cod_21_();
    mwtuck();
    mwarrow_ctx_21_();
    mwab_arrow_21_();
    push_value(var_f_401);
    incref(var_f_401);
    do_run();
    mwab_arrow_40_();
    decref(var_f_401);
}
static void mwab_arrow_21_ (void){
    mwAB_ARROW();
    mwvalue_21_();
}

static void mwvalue_21_ (void){
    mwprim_2E_value_2E_set();
}

static value_t* fieldptr_arrow_token_start (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_token_start_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_token_start(index);
    incref(v); push_value(v);
}
static void mwarrow_token_start_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_token_start(index);
    incref(v); push_value(v);
}
static void mwarrow_token_start_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_token_start(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_homeidx_21_ (void){
    mwAB_HOMEIDX();
    mwint_21_();
}

static value_t* fieldptr_arrow_homeidx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_homeidx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_homeidx(index);
    incref(v); push_value(v);
}
static void mwarrow_homeidx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_homeidx(index);
    incref(v); push_value(v);
}
static void mwarrow_homeidx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_homeidx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_homeidx_40_ (void){
    mwAB_HOMEIDX();
    mwint_40_();
}

static value_t* fieldptr_arrow_home (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwarrow_home_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_home(index);
    incref(v); push_value(v);
}
static void mwarrow_home_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_arrow_home(index);
    incref(v); push_value(v);
}
static void mwarrow_home_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_arrow_home(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_home_40_ (void){
    mwAB_HOME();
    mwvalue_40_();
}

static void mwArrow_2E_alloc_21_ (void){
    mwArrow_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwArrow_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwab_save_21_ (void){
    {
    value_t var_f_535 = pop_value();
    mwab_arrow_40_();
    { value_t d2 = pop_value();
    push_value(var_f_535);
    incref(var_f_535);
    do_run();
      push_value(d2); }
    mwab_arrow_21_();
    decref(var_f_535);
    }
}

static value_t* fieldptr_block_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwblock_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_ctx(index);
    incref(v); push_value(v);
}
static void mwblock_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_ctx(index);
    incref(v); push_value(v);
}
static void mwblock_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_block_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_expand_morphism_21_ (void){
    mwswap();
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    { value_t d2 = pop_value();
    mwTYPE_ERROR();
    mwTYPE_ERROR();
      push_value(d2); }
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwid();
    mwrotl();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwmeta_alloc_21_();
    mwTMeta();
    mwmeta_alloc_21_();
    mwTMeta();
    mwdup2();
    mwTMorphism();
      push_value(d2); }
    mwmeta_type_21_();
    mwrotl();
    break;
    default:
    mwdrop();
    mwdup();
    push_ptr("expected block type\0\0\0");
    mwemit_error_21_();
    { value_t d2 = pop_value();
    mwTYPE_ERROR();
    mwTYPE_ERROR();
      push_value(d2); }
    break;
    }
}

static void mwgamma_token_40_ (void){
    mwid();
}

static value_t* fieldptr_block_token (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwblock_token_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_token(index);
    incref(v); push_value(v);
}
static void mwblock_token_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_token(index);
    incref(v); push_value(v);
}
static void mwblock_token_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_block_token(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_block_forcing (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwblock_forcing_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_forcing(index);
    incref(v); push_value(v);
}
static void mwblock_forcing_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_forcing(index);
    incref(v); push_value(v);
}
static void mwblock_forcing_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_block_forcing(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_block_deferred (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwblock_deferred_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_deferred(index);
    incref(v); push_value(v);
}
static void mwblock_deferred_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_deferred(index);
    incref(v); push_value(v);
}
static void mwblock_deferred_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_block_deferred(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwTYPE_STR (void){
    mwPRIM_TYPE_STR();
    mwTPrim();
}

static void mwTYPE_INT (void){
    mwPRIM_TYPE_INT();
    mwTPrim();
}

static void mwvalue_unify_21_ (void){
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwVALUE_INT();
    mwTValue();
    } else {
    mwdrop2();
    mwTYPE_INT();
    }
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwgamma_token_3F_();
    push_ptr("Can't unify int value with string value.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwgamma_token_3F_();
    push_ptr("Can't unify int value with block.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwVALUE_STR();
    mwTValue();
    } else {
    mwdrop2();
    mwTYPE_STR();
    }
    break;
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwgamma_token_3F_();
    push_ptr("Can't unify string value with int value.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwgamma_token_3F_();
    push_ptr("Can't unify string value with block.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwswap();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwVALUE_BLOCK();
    mwTValue();
    } else {
    mwblock_infer_type_21_();
    mwblock_unify_type_21_();
    }
    break;
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwgamma_token_3F_();
    push_ptr("Can't unify block with int value.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwgamma_token_3F_();
    push_ptr("Can't unify block with string value.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwblock_infer_type_21_ (void){
    mwblock_arrow_40_();
    mwarrow_type();
}

static void mwgamma_token_3F_ (void){
    mwdup();
    mwgamma_token_40_();
}

static void mwtype_unify_pair_21_ (void){
    { value_t d1 = pop_value();
    mwswap();
    { value_t d2 = pop_value();
    mwtype_unify_21_();
    mwswap();
      push_value(d2); }
      push_value(d1); }
    mwtype_unify_21_();
    { value_t d1 = pop_value();
    mwswap();
      push_value(d1); }
}

static void mwtype_table_unify_21_ (void){
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwTTable();
    } else {
    { value_t d2 = pop_value();
    mwTTable();
      push_value(d2); }
    mwTTable();
    mwtype_unify_failed_21_();
    }
}

static void mwtype_data_unify_21_ (void){
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwTData();
    } else {
    { value_t d2 = pop_value();
    mwTData();
      push_value(d2); }
    mwTData();
    mwtype_unify_failed_21_();
    }
}

static void mwtype_prim_unify_21_ (void){
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwTPrim();
    } else {
    { value_t d2 = pop_value();
    mwTPrim();
      push_value(d2); }
    mwTPrim();
    mwtype_unify_failed_21_();
    }
}

static void mwtype_value_unify_21_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwTYPE_INT();
    mwtype_unify_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwTYPE_STR();
    mwtype_unify_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwblock_unify_type_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwtype_unify_failed_21_ (void){
    push_u64(0);
    push_fnptr(&mb_type_unify_failed_21__1);
    do_pack_cons();
    mwdip2();
    push_ptr(": error: Failed to unify \0\0\0");
    mwstr_trace_21_();
    { value_t d1 = pop_value();
    mwtype_trace_21_();
      push_value(d1); }
    push_ptr(" with \0\0\0");
    mwstr_trace_21_();
    mwtype_trace_21_();
    mwtrace_ln_21_();
    mwTYPE_ERROR();
    mwnum_errors_2B__2B_();
}

static void mwtype_trace_21_ (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_ptr("<ERROR>\0\0\0");
    mwstr_trace_21_();
    break;
    case 1LL:
    do_drop();
    push_ptr("_\0\0\0");
    mwstr_trace_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwtype_trace_prim_21_();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwvar_name_40_();
    mwname_trace_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwmeta_trace_21_();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    push_ptr("[\0\0\0");
    mwstr_trace_21_();
    mwTTensor();
    mwtype_trace_stack_21_();
    push_ptr("]\0\0\0");
    mwstr_trace_21_();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    push_ptr("[\0\0\0");
    mwstr_trace_21_();
    mwTMorphism();
    mwtype_trace_sig_21_();
    push_ptr("]\0\0\0");
    mwstr_trace_21_();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdata_name_40_();
    mwname_trace_21_();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwtable_name_40_();
    mwname_trace_21_();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwname_trace_21_();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwapp_type_trace_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    mwvalue_trace_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwvalue_trace_21_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwint_trace_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    push_ptr("\"...\"\0\0\0");
    mwstr_trace_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    push_ptr("[...]\0\0\0");
    mwstr_trace_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwapp_type_trace_21_ (void){
    mwapp_type_trace_open_21_();
    push_ptr(")\0\0\0");
    mwstr_trace_21_();
}

static void mwapp_type_trace_open_21_ (void){
    mwswap();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwapp_type_trace_open_21_();
    push_ptr(", \0\0\0");
    mwstr_trace_21_();
    mwtype_trace_21_();
    break;
    default:
    mwtype_trace_21_();
    push_ptr("(\0\0\0");
    mwstr_trace_21_();
    mwtype_trace_21_();
    break;
    }
}

static value_t* fieldptr_table_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtable_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_table_name(index);
    incref(v); push_value(v);
}
static void mwtable_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_table_name(index);
    incref(v); push_value(v);
}
static void mwtable_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_table_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_data_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwdata_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_name(index);
    incref(v); push_value(v);
}
static void mwdata_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_name(index);
    incref(v); push_value(v);
}
static void mwdata_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_data_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtype_trace_sig_21_ (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_ptr("<ERROR>\0\0\0");
    mwstr_trace_21_();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwswap();
    mwtype_trace_stack_dom_21_();
    push_ptr("--\0\0\0");
    mwstr_trace_21_();
    mwtype_trace_stack_cod_21_();
    break;
    default:
    mwtype_trace_stack_21_();
    break;
    }
}

static void mwtype_trace_stack_cod_21_ (void){
    mwtype_expand();
    mwdup();
    mwTYPE_UNIT();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    } else {
    push_ptr(" \0\0\0");
    mwstr_trace_21_();
    mwtype_trace_stack_21_();
    }
}

static void mwtype_trace_stack_dom_21_ (void){
    mwtype_expand();
    mwdup();
    mwTYPE_UNIT();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwtype_trace_stack_21_();
    push_ptr(" \0\0\0");
    mwstr_trace_21_();
    }
}

static void mwtype_trace_stack_21_ (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwswap();
    mwtype_trace_stack_dom_21_();
    mwtype_trace_21_();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwvar_name_40_();
    mwdup();
    mwname_trace_21_();
    mwname_could_be_stack_var();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr(" .\0\0\0");
    mwstr_trace_21_();
    }
    break;
    default:
    mwtype_trace_21_();
    break;
    }
}

static void mwname_could_be_stack_var (void){
    mwname_str_40_();
    mwdup();
    mwstr_head();
    mwis_asterisk_3F_();
    mwnip();
    if (pop_u64()) {
    mwstr_tail();
    mwstr_could_be_type_var();
    } else {
    mwdrop();
    mwfalse();
    }
}

static void mwstr_could_be_type_var (void){
    mwstr_head();
    mwis_lower_3F_();
    mwnip();
}

static void mwis_lower_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(97LL);
    push_i64(122LL);
    mwin_range();
}

static void mwis_asterisk_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(42LL);
    mw_3D__3D_();
}

static void mwmeta_trace_21_ (void){
    push_ptr("?\0\0\0");
    mwstr_trace_21_();
    mwMetaVar_2E_id();
    mwint_trace_21_();
}

static void mwMetaVar_2E_id (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwname_trace_21_ (void){
    mwname_str_40_();
    mwstr_trace_21_();
}

static void mwtype_trace_prim_21_ (void){
    switch (get_top_data_tag()) {
    case 1LL:
    do_drop();
    push_ptr("<TYPE>\0\0\0");
    break;
    case 2LL:
    do_drop();
    push_ptr("<STACK>\0\0\0");
    break;
    case 3LL:
    do_drop();
    push_ptr("<EFFECT>\0\0\0");
    break;
    case 0LL:
    do_drop();
    push_ptr("[]\0\0\0");
    break;
    case 8LL:
    do_drop();
    push_ptr("Bool\0\0\0");
    break;
    case 4LL:
    do_drop();
    push_ptr("Int\0\0\0");
    break;
    case 5LL:
    do_drop();
    push_ptr("Ptr\0\0\0");
    break;
    case 6LL:
    do_drop();
    push_ptr("Str\0\0\0");
    break;
    case 7LL:
    do_drop();
    push_ptr("Char\0\0\0");
    break;
    case 12LL:
    do_drop();
    push_ptr("U8\0\0\0");
    break;
    case 11LL:
    do_drop();
    push_ptr("U16\0\0\0");
    break;
    case 10LL:
    do_drop();
    push_ptr("U32\0\0\0");
    break;
    case 9LL:
    do_drop();
    push_ptr("U64\0\0\0");
    break;
    case 16LL:
    do_drop();
    push_ptr("I8\0\0\0");
    break;
    case 15LL:
    do_drop();
    push_ptr("I16\0\0\0");
    break;
    case 14LL:
    do_drop();
    push_ptr("I32\0\0\0");
    break;
    case 13LL:
    do_drop();
    push_ptr("I64\0\0\0");
    break;
    case 17LL:
    do_drop();
    push_ptr("Mut\0\0\0");
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    mwstr_trace_21_();
}

static void mb_type_unify_failed_21__1 (void) {
    do_drop();
    mwgamma_token_3F_();
    mwtoken_location();
    mwlocation_trace_21_();
}
static void mwtype_var_unify_21_ (void){
    mwdup2();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwTVar();
    } else {
    { value_t d2 = pop_value();
    mwTVar();
      push_value(d2); }
    mwTVar();
    mwtype_unify_failed_21_();
    }
}

static void mwmeta_unify_21_ (void){
    mwmeta_is_defined_3F_();
    if (pop_u64()) {
    mwmeta_expand();
    mwtype_unify_21_();
    } else {
    mwdup2();
    mwTMeta();
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwswap();
    mwtype_has_meta_3F_();
    if (pop_u64()) {
    mwswap();
    mwTMeta();
    mwtype_unify_failed_21_();
    } else {
    mwswap();
    { value_t d4 = pop_value();
    mwdup();
      push_value(d4); }
    mwmeta_type_21_();
    }
    }
    }
}

static void mwtype_has_meta_3F_ (void){
    mwdup2();
    mwtype_has_meta();
}

static void mwtype_has_meta (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwfalse();
    break;
    case 1LL:
    do_drop();
    mwdrop();
    mwfalse();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mw_3D__3D_();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwtype_has_meta_3F_();
    mwnip();
      push_value(d2); }
    mwswap();
    if (pop_u64()) {
    mwdrop2();
    mwtrue();
    } else {
    mwtype_has_meta();
    }
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwtype_has_meta_3F_();
    mwnip();
      push_value(d2); }
    mwswap();
    if (pop_u64()) {
    mwdrop2();
    mwtrue();
    } else {
    mwtype_has_meta();
    }
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    { value_t d2 = pop_value();
    mwtype_has_meta_3F_();
    mwnip();
      push_value(d2); }
    mwswap();
    if (pop_u64()) {
    mwdrop2();
    mwtrue();
    } else {
    mwtype_has_meta();
    }
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop2();
    mwfalse();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwblock_infer_type_21_();
    mwtype_has_meta();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwtype_hole_unify_21_ (void){
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwTHole();
    mwtype_trace_21_();
    push_ptr(" ~ \0\0\0");
    mwstr_trace_21_();
    mwdup();
    mwtype_trace_21_();
    mwtrace_ln_21_();
    }
}

static void mwtype_expand (void){
    switch (get_top_data_tag()) {
    case 3LL:
    do_pack_uncons(); do_drop();
    mwmeta_expand();
    break;
    default:
    mwid();
    break;
    }
}

static void mb_elab_implicit_var_21__4 (void) {
    do_drop();
    mwnip();
    mwvar_type_3F_();
}
static void mb_elab_implicit_var_21__2 (void) {
    do_drop();
    mwtoken_name_40_();
    mwdup2();
    mwswap();
    mwctx_lookup();
}
static void mb_elab_implicit_var_21__1 (void) {
    do_drop();
    mwtype_elab_ctx_3F_();
}
static void mwtype_elab_ctx_3F_ (void){
    mwdup();
    mwtype_elab_ctx();
}

static void mwTYPE_STACK (void){
    mwPRIM_TYPE_STACK();
    mwTPrim();
}

static void mwsig_token_is_stack_var_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_could_be_stack_var();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwelab_type_sig_21_ (void){
    mwelab_type_stack_21_();
    mwtoken_is_dashes_3F_();
    if (pop_u64()) {
    mwtoken_next();
    mwswap();
    { value_t d2 = pop_value();
    mwelab_type_stack_21_();
      push_value(d2); }
    mwswap();
    } else {
    { value_t d2 = pop_value();
    mwTYPE_UNIT();
      push_value(d2); }
    }
    while(1) {
    mwsig_token_is_effect_con_3F_();
    if (!pop_u64()) break;
    mwtoken_next();
    }
    { value_t d1 = pop_value();
    mwswap();
    mwTMorphism();
      push_value(d1); }
}

static void mwsig_has_dashes_3F_ (void){
    mwdup();
    mwsig_has_dashes();
}

static void mwsig_has_dashes (void){
    mwsig_next_stack_end();
    mwtoken_is_dashes_3F_();
    mwnip();
}

static void mwsig_next_stack_end (void){
    while(1) {
    mwsig_is_stack_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwtoken_next();
    }
}

static void mwtoken_args_1 (void){
    mwtoken_num_args_3F_();
    push_i64(1LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
    mwtoken_succ();
    } else {
    mwtoken_num_args_3F_();
    push_i64(1LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("expected 1 arg, got none\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    push_ptr("expected 1 arg, got too many\0\0\0");
    mwemit_fatal_error_21_();
    }
    }
}

static void mwtoken_is_lsquare_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 4LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwelab_type_hole_21_ (void){
    { value_t d1 = pop_value();
    mwtype_elab_holes_allowed_3F_();
      push_value(d1); }
    mwswap();
    mwHolesAllowed__3E_Bool();
    if (pop_u64()) {
    mwtoken_has_args_3F_();
    if (pop_u64()) {
    mwdup();
    push_ptr("Types with args not yet supported.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    } else {
    mwtoken_name_3F_();
    mwTHole();
    }
    mwswap();
    mwtoken_next();
    } else {
    push_ptr("type holes are not allowed here\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwHolesAllowed__3E_Bool (void){
    mwALLOW_HOLES();
    mw_3D__3D_();
}

static void mwtype_elab_holes_allowed_3F_ (void){
    mwdup();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwsig_token_is_type_hole_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_is_type_hole();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwname_is_type_hole (void){
    mwname_str_40_();
    mwdup();
    mwstr_head();
    mwis_question_mark_3F_();
    mwnip();
    if (pop_u64()) {
    mwstr_tail();
    mwstr_is_empty_3F_();
    if (pop_u64()) {
    mwdrop();
    mwtrue();
    } else {
    mwstr_could_be_type_var();
    }
    } else {
    mwdrop();
    mwfalse();
    }
}

static void mwstr_is_empty_3F_ (void){
    mwdup();
    mwstr_is_empty();
}

static void mwis_question_mark_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(63LL);
    mw_3D__3D_();
}

static void mwelab_type_dont_care_21_ (void){
    { value_t d1 = pop_value();
    mwtype_elab_holes_allowed_3F_();
      push_value(d1); }
    mwswap();
    mwHolesAllowed__3E_Bool();
    if (pop_u64()) {
    mwtoken_has_args_3F_();
    if (pop_u64()) {
    mwdup();
    push_ptr("Types with args not yet supported.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    } else {
    mwTYPE_DONT_CARE();
    }
    mwswap();
    mwtoken_next();
    } else {
    push_ptr("type don't care is not allowed here\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwtoken_is_underscore_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_is_underscore();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwname_is_underscore (void){
    mwname_str_40_();
    mwdup();
    mwstr_head();
    mwis_underscore_3F_();
    mwnip();
    if (pop_u64()) {
    mwstr_tail();
    mwstr_is_empty();
    } else {
    mwdrop();
    mwfalse();
    }
}

static void mwis_underscore_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(95LL);
    mw_3D__3D_();
}

static void mwelab_type_con_21_ (void){
    mwtoken_name_3F_();
    mwname_def_40_();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    mwover();
    mwtoken_num_args();
    mwover();
    mwtype_arity();
    mw_3D__3D_();
    if (pop_u64()) {
    mwelab_type_args_21_();
    } else {
    mwdrop();
    mwdup();
    push_ptr("Wrong number of arguments for type.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    }
    break;
    case 0LL:
    do_drop();
    mwdup();
    push_ptr("Unknown type.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    default:
    mwdrop();
    mwdup();
    push_ptr("Not a type.\0\0\0");
    mwemit_error_21_();
    mwTYPE_ERROR();
    break;
    }
    mwswap();
    mwtoken_next();
}

static void mwelab_type_args_21_ (void){
    { value_t d1 = pop_value();
    mwtoken_has_args_3F_();
      push_value(d1); }
    mwswap();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwtuck();
      push_value(d2); }
    mwswap();
    mwtoken_succ();
    while(1) {
    mwtoken_is_right_enclosure_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwtoken_succ();
    mwswap();
    { value_t d3 = pop_value();
    mwelab_type_arg_21_();
      push_value(d3); }
    mwswap();
    { value_t d3 = pop_value();
    mwswap();
    mwTApp();
      push_value(d3); }
    }
    mwdrop();
    { value_t d2 = pop_value();
    mwswap();
      push_value(d2); }
    } else {
    mwid();
    }
}

static void mwelab_type_arg_21_ (void){
    mwelab_type_atom_21_();
    mwtoken_is_arg_end_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("Unexpected token after type.\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwtype_arity (void){
    mwtype_expand();
    switch (get_top_data_tag()) {
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdata_arity_40_();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwtype_arity();
    mw1_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwprim_type_arity();
    break;
    default:
    mwdrop();
    push_i64(0LL);
    break;
    }
}

static void mwprim_type_arity (void){
    switch (get_top_data_tag()) {
    case 17LL:
    do_drop();
    push_i64(1LL);
    break;
    default:
    mwdrop();
    push_i64(0LL);
    break;
    }
}

static value_t* fieldptr_data_arity (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwdata_arity_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_arity(index);
    incref(v); push_value(v);
}
static void mwdata_arity_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_arity(index);
    incref(v); push_value(v);
}
static void mwdata_arity_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_data_arity(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwsig_token_is_type_con_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_could_be_type_con();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwname_could_be_type_con (void){
    mwname_str_40_();
    mwstr_head();
    mwis_upper_3F_();
    mwnip();
}

static void mwelab_type_var_21_ (void){
    mwTYPE_TYPE();
    mwelab_implicit_var_21_();
}

static void mwTYPE_TYPE (void){
    mwPRIM_TYPE_TYPE();
    mwTPrim();
}

static void mwsig_token_is_type_var_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_could_be_type_var();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwname_could_be_type_var (void){
    mwname_str_40_();
    mwstr_could_be_type_var();
}

static value_t* fieldptr_data_header (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwdata_header_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_header(index);
    incref(v); push_value(v);
}
static void mwdata_header_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_data_header(index);
    incref(v); push_value(v);
}
static void mwdata_header_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_data_header(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_tag_data (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_data_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_data(index);
    incref(v); push_value(v);
}
static void mwtag_data_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_data(index);
    incref(v); push_value(v);
}
static void mwtag_data_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_data(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtype_elab_default (void){
    mwFORBID_HOLES();
    mwctx_empty();
    mwTYPE_ELAB();
}

static void mwctx_empty (void){
    mwnil();
}

static value_t* fieldptr_tag_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_ctx(index);
    incref(v); push_value(v);
}
static void mwtag_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_ctx(index);
    incref(v); push_value(v);
}
static void mwtag_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_tag_type_raw (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_type_raw_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_type_raw(index);
    incref(v); push_value(v);
}
static void mwtag_type_raw_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_type_raw(index);
    incref(v); push_value(v);
}
static void mwtag_type_raw_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_type_raw(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_tag_sig_is_checked (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_sig_is_checked_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_sig_is_checked(index);
    incref(v); push_value(v);
}
static void mwtag_sig_is_checked_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_sig_is_checked(index);
    incref(v); push_value(v);
}
static void mwtag_sig_is_checked_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_sig_is_checked(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_field_word_type_21_ (void){
    mwunFIELDWORD();
    { value_t d1 = pop_value();
    mwelab_field_sig_21_();
      push_value(d1); }
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    { value_t d2 = pop_value();
    mwT1();
      push_value(d2); }
    mwT1();
    mwT__3E_();
    break;
    case 1LL:
    do_drop();
    { value_t d2 = pop_value();
    mwT1();
    mwdup();
      push_value(d2); }
    mwT_2A_();
    mwT__3E_();
    break;
    case 2LL:
    do_drop();
    mwswap();
    mwT2();
    mwT0();
    mwT__3E_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwT2 (void){
    { value_t d1 = pop_value();
    mwT1();
      push_value(d1); }
    mwT_2A_();
}

static void mwelab_field_sig_21_ (void){
    mwfield_sig_is_checked_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwfield_table_sig_3F_();
    mwdup();
    mwelab_simple_type_arg_21_();
    mwtype_max_count_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    push_ptr("expected table type or enum\0\0\0");
    mwemit_fatal_error_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwnip();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    mwover();
    mwfield_table_21_();
    mwfield_type_sig_3F_();
    mwelab_simple_type_arg_21_();
    mwover();
    mwfield_type_21_();
    mwtrue();
    mwover();
    mwfield_sig_is_checked_21_();
    }
    mwfield_table_3F_();
    mwswap();
    mwfield_type_40_();
}

static value_t* fieldptr_field_type (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwfield_type_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_type(index);
    incref(v); push_value(v);
}
static void mwfield_type_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_type(index);
    incref(v); push_value(v);
}
static void mwfield_type_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_field_type(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_field_type_sig (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwfield_type_sig_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_type_sig(index);
    incref(v); push_value(v);
}
static void mwfield_type_sig_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_type_sig(index);
    incref(v); push_value(v);
}
static void mwfield_type_sig_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_field_type_sig(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_field_table (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwfield_table_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_table(index);
    incref(v); push_value(v);
}
static void mwfield_table_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_table(index);
    incref(v); push_value(v);
}
static void mwfield_table_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_field_table(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtype_max_count_3F_ (void){
    mwdup();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwdrop();
    mwtype_max_count_3F_();
    mwnip();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwtable_max_count_40_();
    mw1_2B_();
    mwSOME();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwdata_is_enum_3F_();
    if (pop_u64()) {
    mwdata_tags_40_();
    mwlen();
    mwSOME();
    } else {
    mwdrop();
    mwNONE();
    }
    break;
    default:
    mwdrop();
    mwNONE();
    break;
    }
}

static void mwdata_is_enum_3F_ (void){
    mwdata_tags_3F_();
    push_u64(0);
    push_fnptr(&mb_data_is_enum_3F__1);
    do_pack_cons();
    mwall_3F_();
    mwnip();
}

static void mb_data_is_enum_3F__1 (void) {
    do_drop();
    mwtag_num_inputs_3F_();
    push_i64(0LL);
    mw_3D__3D_();
}
static void mwtag_num_inputs_3F_ (void){
    mwtag_has_sig_3F_();
    if (pop_u64()) {
    mwtag_sig_3F_();
    push_i64(0LL);
    mwswap();
    while(1) {
    mwtoken_run_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwtoken_next();
    { value_t d3 = pop_value();
    mw1_2B_();
      push_value(d3); }
    }
    mwdrop();
    } else {
    push_i64(0LL);
    }
}

static void mwall_3F_ (void){
    {
    value_t var_f_362 = pop_value();
    push_u64(0);
    push_value(var_f_362);
    incref(var_f_362);
    do_pack_cons();
    push_fnptr(&mb_all_3F__2);
    do_pack_cons();
    mwfind_3F_();
    mwis_none();
    decref(var_f_362);
    }
}

static void mwis_none (void){
    mwis_nil();
}

static void mb_all_3F__2 (void) {
    do_pack_uncons();
    value_t var_f_362 = pop_value();
    do_drop();
    push_value(var_f_362);
    incref(var_f_362);
    do_run();
    mwnot();
    decref(var_f_362);
}
static void mwfind_3F_ (void){
    {
    value_t var_f_342 = pop_value();
    mwdup();
    { value_t d2 = pop_value();
    push_value(var_f_342);
    incref(var_f_342);
    mwfind();
      push_value(d2); }
    mwswap();
    decref(var_f_342);
    }
}

static value_t* fieldptr_table_max_count (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtable_max_count_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_table_max_count(index);
    incref(v); push_value(v);
}
static void mwtable_max_count_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_table_max_count(index);
    incref(v); push_value(v);
}
static void mwtable_max_count_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_table_max_count(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_simple_type_arg_21_ (void){
    { value_t d1 = pop_value();
    mwtype_elab_default();
      push_value(d1); }
    mwelab_type_arg_21_();
    mwdrop();
    mwnip();
}

static value_t* fieldptr_field_table_sig (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwfield_table_sig_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_table_sig(index);
    incref(v); push_value(v);
}
static void mwfield_table_sig_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_table_sig(index);
    incref(v); push_value(v);
}
static void mwfield_table_sig_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_field_table_sig(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_field_sig_is_checked (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwfield_sig_is_checked_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_sig_is_checked(index);
    incref(v); push_value(v);
}
static void mwfield_sig_is_checked_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_sig_is_checked(index);
    incref(v); push_value(v);
}
static void mwfield_sig_is_checked_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_field_sig_is_checked(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwunFIELDWORD (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwid();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwforce (void){
    mwdup();
    mw_40_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    mwrotl();
    mwLP_WAIT();
    mwover();
    mw_21_();
    { value_t d3 = pop_value();
    mwrun();
    mwdup();
    mwLP_READY();
      push_value(d3); }
    mw_21_();
    break;
    case 2LL:
    do_drop();
    push_ptr("attempted to force already running thunk\0\0\0");
    mwpanic_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwrun (void){
    {
    value_t var_f_90 = pop_value();
    push_value(var_f_90);
    incref(var_f_90);
    do_run();
    decref(var_f_90);
    }
}

static void mw_21_ (void){
    mwprim_2E_mut_2E_set();
    mwdrop();
}

static void mw_40_ (void){
    mwprim_2E_mut_2E_get();
}

static value_t* fieldptr_word_arrow (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwword_arrow_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_arrow(index);
    incref(v); push_value(v);
}
static void mwword_arrow_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_arrow(index);
    incref(v); push_value(v);
}
static void mwword_arrow_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_word_arrow(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwelab_external_sig_21_ (void){
    mwelab_external_ctx_sig_21_();
    mwnip();
}

static void mwelab_external_ctx_sig_21_ (void){
    mwexternal_sig_is_checked_3F_();
    if (pop_u64()) {
    mwexternal_type_3F_();
    { value_t d2 = pop_value();
    mwexternal_ctx_40_();
      push_value(d2); }
    } else {
    mwexternal_sig_3F_();
    { value_t d2 = pop_value();
    mwtype_elab_default();
      push_value(d2); }
    mwelab_type_sig_21_();
    mwdrop();
    { value_t d2 = pop_value();
    mwtype_elab_ctx();
      push_value(d2); }
    mwdup2();
    push_u64(0);
    push_fnptr(&mb_elab_external_ctx_sig_21__4);
    do_pack_cons();
    mwdip2();
    }
}

static void mb_elab_external_ctx_sig_21__4 (void) {
    do_drop();
    mwrotl();
    mwtuck();
    mwexternal_type_21_();
    mwtuck();
    mwexternal_ctx_21_();
    mwtrue();
    mwswap();
    mwexternal_sig_is_checked_21_();
}
static value_t* fieldptr_external_sig (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwexternal_sig_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_sig(index);
    incref(v); push_value(v);
}
static void mwexternal_sig_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_sig(index);
    incref(v); push_value(v);
}
static void mwexternal_sig_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_external_sig(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_external_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwexternal_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_ctx(index);
    incref(v); push_value(v);
}
static void mwexternal_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_ctx(index);
    incref(v); push_value(v);
}
static void mwexternal_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_external_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_external_type (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwexternal_type_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_type(index);
    incref(v); push_value(v);
}
static void mwexternal_type_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_type(index);
    incref(v); push_value(v);
}
static void mwexternal_type_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_external_type(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_external_sig_is_checked (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwexternal_sig_is_checked_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_sig_is_checked(index);
    incref(v); push_value(v);
}
static void mwexternal_sig_is_checked_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_sig_is_checked(index);
    incref(v); push_value(v);
}
static void mwexternal_sig_is_checked_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_external_sig_is_checked(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_name_def (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwname_def_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_name_def(index);
    incref(v); push_value(v);
}
static void mwname_def_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_name_def(index);
    incref(v); push_value(v);
}
static void mwname_def_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_name_def(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwName_2E_for (void){
    {
    value_t var_x_25 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwName_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_25);
    incref(var_x_25);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_25);
    }
}

static void mwelab_module_21_ (void){
    mwmodule_start_3F_();
    mwelab_module_header_21_();
    while(1) {
    mwtoken_is_module_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwelab_module_decl_21_();
    }
    mwdrop();
}

static void mwelab_module_decl_21_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_def_40_();
    switch (get_top_data_tag()) {
    case 4LL:
    do_pack_uncons(); do_drop();
    mwprim_decl_40_();
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("unknown declaration\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    mwrun();
    }
    break;
    default:
    mwdrop();
    push_ptr("unknown declaration\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
    break;
    default:
    mwdrop();
    push_ptr("unsupported declaration\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static value_t* fieldptr_prim_decl (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwprim_decl_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_decl(index);
    incref(v); push_value(v);
}
static void mwprim_decl_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_decl(index);
    incref(v); push_value(v);
}
static void mwprim_decl_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_prim_decl(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwtoken_is_module_end_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwelab_module_header_21_ (void){
    mwPRIM_SYNTAX_MODULE();
    mwtoken_prim_3D__3F_();
    if (pop_u64()) {
    mwdup();
    mwtoken_args_1();
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("Expected module name.\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwtoken_name_3F_();
    mwname_defined_3F_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("Module name already taken.\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    mwid();
    }
    mwover();
    mwtoken_module_40_();
    mwdup2();
    mwmodule_name_21_();
    mwdup2();
    mwDEF_MODULE();
    mwswap();
    mwname_def_21_();
    mwmodule_path_40_();
    mwPath__3E_Str();
    mwswap();
    mwmodule_path_from_name();
    mwPath__3E_Str();
    mwstr_eq();
    if (pop_u64()) {
    mwdrop();
    } else {
    push_ptr("Module name should match path.\0\0\0");
    mwemit_error_21_();
    }
    mwtoken_next();
    } else {
    mwdup();
    push_ptr("Expected module header.\0\0\0");
    mwemit_error_21_();
    }
}

static void mwstr_eq (void){
    mwprim_2E_str_2E_eq();
}

static void mwmodule_path_from_name (void){
    mwname_str_40_();
    push_u64(0);
    push_fnptr(&mb_module_path_from_name_1);
    do_pack_cons();
    mwstr_transduce();
    push_ptr(".mth\0\0\0");
    mwstr_cat();
    mwStr__3E_Path();
}

static void mwstr_cat (void){
    mwL2();
    mwstr_concat();
}

static void mb_module_path_from_name_1 (void) {
    do_drop();
    mwis_dot_3F_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("/\0\0\0");
    mwTS_COPY();
    } else {
    mwis_upper_3F_();
    if (pop_u64()) {
    mwChar__3E_Int();
    push_i64(32LL);
    mw_7C_();
    mwInt__3E_Char();
    mwTS_CHAR();
    } else {
    mwTS_CHAR();
    }
    }
}
static void mw_7C_ (void){
    mwprim_2E_int_2E_or();
}

static void mwis_dot_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(46LL);
    mw_3D__3D_();
}

static void mwstr_transduce (void){
    {
    value_t var_f_241 = pop_value();
    push_u64(0);
    push_value(var_f_241);
    incref(var_f_241);
    do_pack_cons();
    push_fnptr(&mb_str_transduce_2);
    do_pack_cons();
    mwbuild_str_21_();
    decref(var_f_241);
    }
}

static void mb_str_transduce_2 (void) {
    do_pack_uncons();
    value_t var_f_241 = pop_value();
    do_drop();
    while(1) {
    mwstr_is_empty_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwdup();
    { value_t d2 = pop_value();
    mwstr_head();
    push_value(var_f_241);
    incref(var_f_241);
    do_run();
      push_value(d2); }
    mwstr_tail();
    mwswap();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    push_ptr("\0\0\0");
    break;
    case 1LL:
    do_drop();
    mwid();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwstr_buf_push_char_21_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    push_u64(0);
    push_value(var_f_241);
    incref(var_f_241);
    do_pack_cons();
    push_fnptr(&mb_str_transduce_9);
    do_pack_cons();
    mwfor();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    mwstr_buf_push_str_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    }
    mwdrop();
    decref(var_f_241);
}
static void mb_str_transduce_9 (void) {
    do_pack_uncons();
    value_t var_f_241 = pop_value();
    do_drop();
    mwstr_buf_push_char_21_();
    decref(var_f_241);
}
static void mwbuild_str_21_ (void){
    {
    value_t var_f_224 = pop_value();
    mwstr_buf_dup_21_();
    mwstr_buf_clear_21_();
    { value_t d2 = pop_value();
    push_value(var_f_224);
    incref(var_f_224);
    do_run();
    mwstr_buf_dup_21_();
      push_value(d2); }
    mwstr_buf_21_();
    decref(var_f_224);
    }
}

static void mwstr_buf_dup_21_ (void){
    mwSTR_BUF();
    mwstr_buf_length_3F_();
    mwdup();
    mwprim_2E_str_2E_alloc();
    mwdup();
    { value_t d1 = pop_value();
    mwprim_2E_str_2E_base();
    mwprim_2E_ptr_2E_copy();
      push_value(d1); }
}

static value_t* fieldptr_module_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmodule_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_name(index);
    incref(v); push_value(v);
}
static void mwmodule_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_name(index);
    incref(v); push_value(v);
}
static void mwmodule_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_module_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwname_defined_3F_ (void){
    mwname_undefined_3F_();
    mwnot();
}

static void mwname_undefined_3F_ (void){
    mwname_def_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static value_t* fieldptr_module_start (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmodule_start_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_start(index);
    incref(v); push_value(v);
}
static void mwmodule_start_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_start(index);
    incref(v); push_value(v);
}
static void mwmodule_start_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_module_start(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwrun_lexer_21_ (void){
    mwmodule_new_21_();
    mwlexer_module_21_();
    mwlexer_module_40_();
    mwmodule_source_path();
    mwPath__3E_Str();
    mwopen_file_21_();
    mwinput_start_21_();
    push_i64(1LL);
    mwInt__3E_Row();
    mwlexer_row_21_();
    push_i64(1LL);
    mwInt__3E_Col();
    mwlexer_col_21_();
    mwtoken_alloc_21_();
    while(1) {
    mwlexer_done_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwlexer_next_21_();
    }
    mwinput_end_21_();
    mwlexer_stack_empty_3F_();
    if (pop_u64()) {
    mwTOKEN_NONE();
    mwlexer_emit_21_();
    } else {
    mwlexer_stack_pop_21_();
    push_ptr("Mismatched left parenthesis.\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwtoken_alloc_21_();
    mwlexer_module_40_();
    mwmodule_end_21_();
    mwtoken_succ();
    mwlexer_module_40_();
    mwmodule_start_21_();
    mwlexer_module_40_();
}

static value_t* fieldptr_module_end (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmodule_end_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_end(index);
    incref(v); push_value(v);
}
static void mwmodule_end_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_end(index);
    incref(v); push_value(v);
}
static void mwmodule_end_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_module_end(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwlexer_stack_pop_21_ (void){
    mwlexer_stack_empty_3F_();
    if (pop_u64()) {
    push_ptr("lexer stack underflow\0\0\0");
    mwpanic_21_();
    } else {
    mwlexer_stack_length_40_();
    mw1_();
    mwdup();
    mwlexer_stack_length_21_();
    mwLEXER_STACK_BUF();
    mwvalue_40__40_();
    }
}

static void mwvalue_40__40_ (void){
    { value_t d1 = pop_value();
    mwvalues();
      push_value(d1); }
    mwptr_2B_();
    mwvalue_40_();
}

static void mwvalues (void){
    push_i64(16LL);
    mw_2A_();
}

static void mwlexer_stack_length_21_ (void){
    mwLEXER_STACK_LENGTH();
    mwvalue_21_();
}

static void mwlexer_stack_length_40_ (void){
    mwLEXER_STACK_LENGTH();
    mwvalue_40_();
}

static void mwlexer_emit_21_ (void){
    mwlexer_make_21_();
    mwdrop();
}

static void mwlexer_make_21_ (void){
    mwtoken_alloc_21_();
    mwtuck();
    mwtoken_value_21_();
    { value_t d1 = pop_value();
    mwlexer_module_40_();
      push_value(d1); }
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_module_21_();
      push_value(d1); }
    { value_t d1 = pop_value();
    mwlexer_row_40_();
      push_value(d1); }
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_row_21_();
      push_value(d1); }
    { value_t d1 = pop_value();
    mwlexer_col_40_();
      push_value(d1); }
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_col_21_();
      push_value(d1); }
}

static void mwlexer_col_40_ (void){
    mwLEXER_COL();
    mwvalue_40_();
}

static void mwlexer_row_40_ (void){
    mwLEXER_ROW();
    mwvalue_40_();
}

static void mwlexer_stack_empty_3F_ (void){
    mwlexer_stack_length_40_();
    push_i64(0LL);
    mw_3C__3D_();
}

static void mwinput_end_21_ (void){
    mwinput_isopen_40_();
    if (pop_u64()) {
    mwinput_handle_40_();
    mwclose_file_21_();
    } else {
    mwid();
    }
    mwstdin();
    mwinput_handle_21_();
    push_i64(0LL);
    mwinput_length_21_();
    push_i64(0LL);
    mwinput_offset_21_();
    mwfalse();
    mwinput_isopen_21_();
}

static void mwinput_isopen_21_ (void){
    if (pop_u64()) {
    push_i64(1LL);
    } else {
    push_i64(0LL);
    }
    mwINPUT_ISOPEN();
    mwint_21_();
}

static void mwinput_offset_21_ (void){
    mwINPUT_OFFSET();
    mwint_21_();
}

static void mwinput_length_21_ (void){
    mwINPUT_LENGTH();
    mwint_21_();
}

static void mwinput_handle_21_ (void){
    mwFile__3E_Int();
    mwINPUT_HANDLE();
    mwint_21_();
}

static void mwstdin (void){
    push_i64(0LL);
    mwInt__3E_File();
}

static void mwclose_file_21_ (void){
    mwFile__3E_Int();
    mwposix_close_21_();
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("failed to close file.\0\0\0");
    mwpanic_21_();
    } else {
    mwid();
    }
}

static void mwposix_close_21_ (void){
    mwprim_2E_posix_2E_close();
}

static void mwinput_handle_40_ (void){
    mwINPUT_HANDLE();
    mwint_40_();
    mwInt__3E_File();
}

static void mwinput_isopen_40_ (void){
    mwINPUT_ISOPEN();
    mwint_40_();
    mw0_3C__3E_();
}

static void mw0_3C__3E_ (void){
    push_i64(0LL);
    mw_3C__3E_();
}

static void mw_3C__3E_ (void){
    mw_3D__3D_();
    mwnot();
}

static void mwlexer_next_21_ (void){
    mwlexer_peek();
    mwchar_valid_3F_();
    mwnot();
    if (pop_u64()) {
    push_ptr("invalid character\0\0\0");
    mwlexer_emit_fatal_error_21_();
    } else {
    mwis_name_char_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_name_21_();
    } else {
    mwis_newline_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_newline_21_();
    } else {
    mwis_whitespace_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwis_pound_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_skip_comment_21_();
    } else {
    mwis_comma_3F_();
    if (pop_u64()) {
    mwdrop();
    mwTOKEN_COMMA();
    mwlexer_emit_21_();
    } else {
    mwis_lparen_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_lparen_21_();
    } else {
    mwis_rparen_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_rparen_21_();
    } else {
    mwis_lsquare_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_lsquare_21_();
    } else {
    mwis_rsquare_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_rsquare_21_();
    } else {
    mwis_lcurly_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_lcurly_21_();
    } else {
    mwis_rcurly_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_rcurly_21_();
    } else {
    mwis_quote_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_emit_string_21_();
    } else {
    push_ptr("unrecognized token\0\0\0");
    mwlexer_emit_fatal_error_21_();
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    mwlexer_move_21_();
    }
    }
}

static void mwlexer_move_21_ (void){
    mwinput_move_21_();
    mwlexer_col_40_();
    mwCol__3E_Int();
    mw1_2B_();
    mwInt__3E_Col();
    mwlexer_col_21_();
}

static void mwinput_move_21_ (void){
    mwinput_isopen_40_();
    if (pop_u64()) {
    mwinput_offset_40_();
    mwdup();
    mwINPUT_BUFFER();
    mwptr_2B_();
    mwchar_40__width();
    mw_2B_();
    mwinput_offset_21_();
    mwinput_prepare_for_more_21_();
    } else {
    push_ptr("error: attempted to move input buffer when file is already closed\0\0\0");
    mwpanic_21_();
    }
}

static void mwinput_prepare_for_more_21_ (void){
    mwinput_offset_40_();
    mwdup();
    push_i64(4LL);
    mw_2B_();
    mwinput_length_40_();
    mw_3E_();
    if (pop_u64()) {
    mwdup();
    mwinput_length_40_();
    mw_3E__3D_();
    if (pop_u64()) {
    mwdrop();
    mwinput_fill_buffer_21_();
    } else {
    mwdup();
    mwINPUT_BUFFER();
    mwptr_2B_();
    mwchar_40__width();
    mw_2B_();
    mwinput_length_40_();
    mw_3E_();
    if (pop_u64()) {
    mwinput_fill_buffer_tragic_21_();
    } else {
    mwid();
    }
    }
    } else {
    mwdrop();
    }
}

static void mwinput_fill_buffer_tragic_21_ (void){
    mwinput_offset_40_();
    mwINPUT_BUFFER();
    mwptr_2B_();
    mwu32_40_();
    mwINPUT_BUFFER();
    mwu32_21_();
    mwINPUT_BUFFER();
    mwchar_40__width();
    mwinput_length_21_();
    push_i64(0LL);
    mwinput_offset_21_();
    mwinput_isopen_40_();
    if (pop_u64()) {
    mwinput_handle_40_();
    mwFile__3E_Int();
    mwinput_length_40_();
    mwINPUT_BUFFER();
    mwptr_2B_();
    mwINPUT_BUFFER_SIZE();
    mwposix_read_21_();
    mwdup();
    push_i64(0LL);
    mw_3E__3D_();
    if (pop_u64()) {
    mwdup();
    push_i64(0LL);
    mw_3E_();
    if (pop_u64()) {
    mwinput_length_40_();
    mw_2B_();
    mwinput_length_21_();
    } else {
    mwdrop();
    }
    } else {
    mwdrop();
    push_ptr("error: failed to read from file\0\0\0");
    mwpanic_21_();
    }
    } else {
    push_ptr("error: attempted to fill input buffer when file is closed\0\0\0");
    mwpanic_21_();
    }
}

static void mwposix_read_21_ (void){
    mwprim_2E_posix_2E_read();
}

static void mwINPUT_BUFFER_SIZE (void){
    push_i64(8192LL);
}

static void mwinput_fill_buffer_21_ (void){
    mwinput_isopen_40_();
    if (pop_u64()) {
    mwinput_handle_40_();
    mwFile__3E_Int();
    mwINPUT_BUFFER();
    mwINPUT_BUFFER_SIZE();
    mwposix_read_21_();
    mwdup();
    push_i64(0LL);
    mw_3E__3D_();
    if (pop_u64()) {
    mwdup();
    push_i64(0LL);
    mw_3E_();
    if (pop_u64()) {
    mwinput_length_21_();
    push_i64(0LL);
    mwinput_offset_21_();
    } else {
    mwdrop();
    mwinput_end_21_();
    }
    } else {
    mwdrop();
    push_ptr("error: failed to read from file\0\0\0");
    mwpanic_21_();
    }
    } else {
    push_ptr("error: attempted to fill input buffer when file is closed\0\0\0");
    mwpanic_21_();
    }
}

static void mwinput_length_40_ (void){
    mwINPUT_LENGTH();
    mwint_40_();
}

static void mwinput_offset_40_ (void){
    mwINPUT_OFFSET();
    mwint_40_();
}

static void mwlexer_emit_string_21_ (void){
    mwstr_buf_clear_21_();
    mwTOKEN_NONE();
    mwlexer_make_21_();
    mwlexer_move_21_();
    mwlexer_peek();
    while(1) {
    mwis_string_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwchar_valid_3F_();
    if (pop_u64()) {
    mwlexer_push_string_char_21_();
    mwlexer_move_21_();
    mwlexer_peek();
    } else {
    push_ptr("invalid character in string literal\0\0\0");
    mwlexer_emit_fatal_error_21_();
    }
    }
    mwdrop();
    mwstr_buf_dup_21_();
    mwTOKEN_STR();
    mwswap();
    mwtoken_value_21_();
}

static void mwlexer_push_string_char_21_ (void){
    mwis_backslash_3F_();
    if (pop_u64()) {
    mwdrop();
    mwlexer_move_21_();
    mwlexer_peek();
    mwis_newline_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwis_n_3F_();
    if (pop_u64()) {
    mwdrop();
    push_i64(10LL);
    mwInt__3E_Char();
    mwstr_buf_push_char_21_();
    } else {
    mwis_r_3F_();
    if (pop_u64()) {
    mwdrop();
    push_i64(13LL);
    mwInt__3E_Char();
    mwstr_buf_push_char_21_();
    } else {
    mwis_t_3F_();
    if (pop_u64()) {
    mwdrop();
    push_i64(9LL);
    mwInt__3E_Char();
    mwstr_buf_push_char_21_();
    } else {
    mwis_quote_3F_();
    if (pop_u64()) {
    mwstr_buf_push_char_21_();
    } else {
    mwis_backslash_3F_();
    if (pop_u64()) {
    mwstr_buf_push_char_21_();
    } else {
    mwstr_buf_push_char_21_();
    push_ptr("Unknown character escape sequence.\0\0\0");
    mwlexer_emit_warning_21_();
    }
    }
    }
    }
    }
    }
    } else {
    mwstr_buf_push_char_21_();
    }
}

static void mwlexer_emit_warning_21_ (void){
    { value_t d1 = pop_value();
    mwlexer_location();
      push_value(d1); }
    mwemit_warning_at_21_();
}

static void mwemit_warning_at_21_ (void){
    { value_t d1 = pop_value();
    mwlocation_trace_21_();
      push_value(d1); }
    push_ptr(": warning: \0\0\0");
    mwstr_trace_21_();
    mwstr_trace_ln_21_();
    mwnum_warnings_2B__2B_();
}

static void mwnum_warnings_2B__2B_ (void){
    mwnum_warnings_40_();
    mw1_2B_();
    mwNUM_WARNINGS();
    mwint_21_();
}

static void mwnum_warnings_40_ (void){
    mwNUM_WARNINGS();
    mwint_40_();
}

static void mwlexer_location (void){
    mwlexer_module_40_();
    mwlexer_row_40_();
    mwlexer_col_40_();
    mwlocation_pack();
}

static void mwis_t_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(116LL);
    mw_3D__3D_();
}

static void mwis_r_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(114LL);
    mw_3D__3D_();
}

static void mwis_n_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(110LL);
    mw_3D__3D_();
}

static void mwis_backslash_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(92LL);
    mw_3D__3D_();
}

static void mwis_string_end_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    mwdup();
    push_i64(64LL);
    mw_3C_();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    push_i64(17179870209LL);
      push_value(d2); }
    mw_3E__3E_();
    push_i64(1LL);
    mw_26_();
    push_i64(0LL);
    mw_3C__3E_();
      push_value(d1); }
    mw_26__26_();
}

static void mwis_quote_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(34LL);
    mw_3D__3D_();
}

static void mwlexer_emit_rcurly_21_ (void){
    mwlexer_stack_empty_3F_();
    if (pop_u64()) {
    push_ptr("Mismatched right brace.\0\0\0");
    mwlexer_emit_fatal_error_21_();
    } else {
    mwlexer_stack_pop_21_();
    mwtoken_is_lcurly_3F_();
    if (pop_u64()) {
    mwdup();
    mwTOKEN_RCURLY();
    mwlexer_make_21_();
    mwTOKEN_LCURLY();
    mwswap();
    mwtoken_value_21_();
    } else {
    push_ptr("Mismatched right brace.\0\0\0");
    mwlexer_emit_fatal_error_21_();
    }
    }
}

static void mwtoken_is_lcurly_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 6LL:
    do_pack_uncons(); do_drop();
    mwdrop();
    mwtrue();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwis_rcurly_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(125LL);
    mw_3D__3D_();
}

static void mwlexer_emit_lcurly_21_ (void){
    mwnil();
    mwTOKEN_LCURLY();
    mwlexer_make_21_();
    mwlexer_stack_push_21_();
}

static void mwlexer_stack_push_21_ (void){
    mwlexer_stack_full_3F_();
    if (pop_u64()) {
    push_ptr("lexer stack overflow\0\0\0");
    mwpanic_21_();
    } else {
    mwlexer_stack_length_40_();
    mwdup();
    mw1_2B_();
    mwlexer_stack_length_21_();
    mwLEXER_STACK_BUF();
    mwvalue_21__21_();
    }
}

static void mwvalue_21__21_ (void){
    { value_t d1 = pop_value();
    mwvalues();
      push_value(d1); }
    mwptr_2B_();
    mwvalue_21_();
}

static void mwlexer_stack_full_3F_ (void){
    mwlexer_stack_length_40_();
    mwLEXER_STACK_SIZE();
    mw_3E__3D_();
}

static void mwLEXER_STACK_SIZE (void){
    push_i64(512LL);
}

static void mwis_lcurly_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(123LL);
    mw_3D__3D_();
}

static void mwlexer_emit_rsquare_21_ (void){
    mwlexer_stack_empty_3F_();
    if (pop_u64()) {
    push_ptr("Mismatched right bracket.\0\0\0");
    mwlexer_emit_fatal_error_21_();
    } else {
    mwlexer_stack_pop_21_();
    mwtoken_is_lsquare_3F_();
    if (pop_u64()) {
    mwdup();
    mwTOKEN_RSQUARE();
    mwlexer_make_21_();
    mwTOKEN_LSQUARE();
    mwswap();
    mwtoken_value_21_();
    } else {
    push_ptr("Mismatched right bracket.\0\0\0");
    mwlexer_emit_fatal_error_21_();
    }
    }
}

static void mwis_rsquare_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(93LL);
    mw_3D__3D_();
}

static void mwlexer_emit_lsquare_21_ (void){
    mwnil();
    mwTOKEN_LSQUARE();
    mwlexer_make_21_();
    mwlexer_stack_push_21_();
}

static void mwis_lsquare_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(91LL);
    mw_3D__3D_();
}

static void mwlexer_emit_rparen_21_ (void){
    mwlexer_stack_empty_3F_();
    if (pop_u64()) {
    push_ptr("Mismatched right parenthesis.\0\0\0");
    mwlexer_emit_fatal_error_21_();
    } else {
    mwlexer_stack_pop_21_();
    mwtoken_is_lparen_3F_();
    if (pop_u64()) {
    mwdup();
    mwTOKEN_RPAREN();
    mwlexer_make_21_();
    mwTOKEN_LPAREN();
    mwswap();
    mwtoken_value_21_();
    } else {
    push_ptr("Mismatched right parenthesis.\0\0\0");
    mwlexer_emit_fatal_error_21_();
    }
    }
}

static void mwis_rparen_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(41LL);
    mw_3D__3D_();
}

static void mwlexer_emit_lparen_21_ (void){
    mwnil();
    mwTOKEN_LPAREN();
    mwlexer_make_21_();
    mwlexer_stack_push_21_();
}

static void mwis_lparen_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(40LL);
    mw_3D__3D_();
}

static void mwis_comma_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(44LL);
    mw_3D__3D_();
}

static void mwlexer_skip_comment_21_ (void){
    while(1) {
    mwlexer_comment_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwlexer_move_21_();
    }
    mwlexer_peek();
    mwis_newline_3F_();
    if (pop_u64()) {
    mwlexer_newline_21_();
    } else {
    mwid();
    }
    mwdrop();
}

static void mwlexer_comment_end_3F_ (void){
    mwlexer_done_3F_();
    if (pop_u64()) {
    mwtrue();
    } else {
    mwlexer_peek();
    mwis_newline_3F_();
    mwnip();
    }
}

static void mwis_pound_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(35LL);
    mw_3D__3D_();
}

static void mwis_whitespace_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    mwdup();
    push_i64(33LL);
    mw_3C_();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    push_i64(4295101952LL);
      push_value(d2); }
    mw_3E__3E_();
    push_i64(1LL);
    mw_26_();
    push_i64(0LL);
    mw_3C__3E_();
      push_value(d1); }
    mw_26__26_();
}

static void mwlexer_newline_21_ (void){
    mwlexer_row_40_();
    mwRow__3E_Int();
    mw1_2B_();
    mwInt__3E_Row();
    mwlexer_row_21_();
    push_i64(0LL);
    mwInt__3E_Col();
    mwlexer_col_21_();
}

static void mwis_newline_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(10LL);
    mw_3D__3D_();
}

static void mwlexer_emit_name_21_ (void){
    mwstr_buf_clear_21_();
    mwlexer_module_40_();
    mwlexer_row_40_();
    mwlexer_col_40_();
    mwlexer_peek();
    while(1) {
    mwis_name_char_3F_();
    if (!pop_u64()) break;
    mwchar_valid_3F_();
    if (pop_u64()) {
    mwstr_buf_push_char_21_();
    mwlexer_move_21_();
    mwlexer_peek();
    } else {
    push_ptr("invalid character\0\0\0");
    mwlexer_emit_fatal_error_21_();
    }
    }
    mwdrop();
    mwstr_buf_is_doc_start_3F_();
    if (pop_u64()) {
    mwdrop3();
    mwlexer_skip_doc_21_();
    } else {
    mwstr_buf_is_int_3F_();
    if (pop_u64()) {
    mwstr_buf_int_3F_();
    mwTOKEN_INT();
    } else {
    mwstr_buf_dup_21_();
    mwname_new_21_();
    mwTOKEN_NAME();
    }
    mwtoken_alloc_21_();
    mwtuck();
    mwtoken_value_21_();
    mwtuck();
    mwtoken_col_21_();
    mwtuck();
    mwtoken_row_21_();
    mwtoken_module_21_();
    }
}

static void mwname_new_21_ (void){
    mwdup();
    mwhash();
    while(1) {
    mwname_keep_going_3F_();
    if (!pop_u64()) break;
    mwnext_hash();
    }
    mwhash_name_3F_();
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    mwName_2E_alloc_21_();
    mwtuck();
    mwswap();
    mwhash_name_21_();
    mwtuck();
    mwname_str_21_();
    } else {
    mwnip();
    mwnip();
    }
}

static void mwhash_name_21_ (void){
    mwHash__3E_Int();
    mwNAME_HASH_TABLE();
    mwvalue_21__21_();
}

static void mwHash__3E_Int (void){
    mwid();
}

static void mwName_2E_alloc_21_ (void){
    mwName_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwName_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwhash_name_3F_ (void){
    mwdup();
    mwhash_name_40_();
}

static void mwhash_name_40_ (void){
    mwHash__3E_Int();
    mwNAME_HASH_TABLE();
    mwvalue_40__40_();
}

static void mwnext_hash (void){
    mwHash__3E_Int();
    mw1_2B_();
    mwNAME_HASH_MAX();
    mw_26_();
    mwInt__3E_Hash();
}

static void mwInt__3E_Hash (void){
    mwHASH();
}

static void mwNAME_HASH_MAX (void){
    push_i64(32767LL);
}

static void mwname_keep_going_3F_ (void){
    mwhash_name_3F_();
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    mwfalse();
    } else {
    { value_t d2 = pop_value();
    mwover();
      push_value(d2); }
    mwname_str_40_();
    mwstr_eq();
    mwnot();
    }
}

static void mwhash (void){
    push_i64(0LL);
    mwswap();
    while(1) {
    mwstr_is_empty_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwdup();
    mwstr_tail();
    { value_t d2 = pop_value();
    mwstr_head();
    mwChar__3E_Int();
    push_i64(5LL);
    mw_2A_();
    mwswap();
    push_i64(18LL);
    mw_2A_();
    mw_5E_();
      push_value(d2); }
    }
    mwdrop();
    mwNAME_HASH_MAX();
    mw_26_();
    mwInt__3E_Hash();
}

static void mw_5E_ (void){
    mwprim_2E_int_2E_xor();
}

static void mwstr_buf_int_3F_ (void){
    mwstr_buf_is_dec_int_3F_();
    if (pop_u64()) {
    mwstr_buf_dec_int_3F_();
    } else {
    mwstr_buf_hex_int_3F_();
    }
}

static void mwstr_buf_hex_int_3F_ (void){
    push_i64(1LL);
    push_i64(0LL);
    push_i64(0LL);
    mwdup();
    mwstr_buf_char_40_();
    mwis_sign_3F_();
    if (pop_u64()) {
    mwis_dash_3F_();
    mwnip();
    if (pop_u64()) {
    push_u64(0);
    push_fnptr(&mb_str_buf_hex_int_3F__5);
    do_pack_cons();
    mwdip2();
    } else {
    mwid();
    }
    mw1_2B_();
    } else {
    mwdrop();
    }
    push_i64(2LL);
    mw_2B_();
    while(1) {
    mwdup();
    mwstr_buf_length_3F_();
    mw_3C_();
    if (!pop_u64()) break;
    mwdup();
    { value_t d2 = pop_value();
    mwstr_buf_char_40_();
    { value_t d3 = pop_value();
    push_i64(16LL);
    mw_2A_();
      push_value(d3); }
    mwhexdigit_value();
    mw_2B_();
      push_value(d2); }
    mw1_2B_();
    }
    mwdrop();
    mw_2A_();
}

static void mwhexdigit_value (void){
    mwis_digit_3F_();
    if (pop_u64()) {
    mwChar__3E_Int();
    push_i64(48LL);
    mw_();
    } else {
    mwis_upper_hexdigit_3F_();
    if (pop_u64()) {
    mwChar__3E_Int();
    push_i64(55LL);
    mw_();
    } else {
    mwChar__3E_Int();
    push_i64(87LL);
    mw_();
    }
    }
}

static void mwis_upper_hexdigit_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(65LL);
    push_i64(70LL);
    mwin_range();
}

static void mwis_digit_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(48LL);
    push_i64(57LL);
    mwin_range();
}

static void mb_str_buf_hex_int_3F__5 (void) {
    do_drop();
    mwdrop();
    push_i64(-1LL);
}
static void mwis_dash_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(45LL);
    mw_3D__3D_();
}

static void mwis_sign_3F_ (void){
    mwis_plus_3F_();
    { value_t d1 = pop_value();
    mwis_minus_3F_();
      push_value(d1); }
    mw_7C__7C_();
}

static void mw_7C__7C_ (void){
    mwprim_2E_bool_2E_or();
}

static void mwis_minus_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(45LL);
    mw_3D__3D_();
}

static void mwstr_buf_char_40_ (void){
    mwSTR_BUF();
    mwptr_2B_();
    mwchar_40_();
}

static void mwstr_buf_dec_int_3F_ (void){
    push_i64(1LL);
    push_i64(0LL);
    push_i64(0LL);
    mwdup();
    mwstr_buf_char_40_();
    mwis_sign_3F_();
    if (pop_u64()) {
    mwis_dash_3F_();
    mwnip();
    if (pop_u64()) {
    push_u64(0);
    push_fnptr(&mb_str_buf_dec_int_3F__5);
    do_pack_cons();
    mwdip2();
    } else {
    mwid();
    }
    mw1_2B_();
    } else {
    mwdrop();
    }
    while(1) {
    mwdup();
    mwstr_buf_length_3F_();
    mw_3C_();
    if (!pop_u64()) break;
    mwdup();
    { value_t d2 = pop_value();
    mwstr_buf_char_40_();
    mwChar__3E_Int();
    { value_t d3 = pop_value();
    push_i64(10LL);
    mw_2A_();
      push_value(d3); }
    push_i64(48LL);
    mw_();
    mw_2B_();
      push_value(d2); }
    mw1_2B_();
    }
    mwdrop();
    mw_2A_();
}

static void mb_str_buf_dec_int_3F__5 (void) {
    do_drop();
    mwdrop();
    push_i64(-1LL);
}
static void mwstr_buf_is_dec_int_3F_ (void){
    push_i64(0LL);
    push_i64(0LL);
    mwdup();
    mwstr_buf_char_40_();
    mwis_sign_3F_();
    mwnip();
    if (pop_u64()) {
    mw1_2B_();
    } else {
    mwid();
    }
    while(1) {
    mwdup();
    mwstr_buf_char_40_();
    mwis_digit_3F_();
    mwnip();
    if (!pop_u64()) break;
    { value_t d2 = pop_value();
    mw1_2B_();
      push_value(d2); }
    mw1_2B_();
    }
    mwswap();
    push_i64(1LL);
    mw_3E__3D_();
    if (pop_u64()) {
    mwstr_buf_length_3F_();
    mw_3D__3D_();
    } else {
    mwdrop();
    mwfalse();
    }
}

static void mwstr_buf_is_int_3F_ (void){
    mwstr_buf_is_dec_int_3F_();
    if (pop_u64()) {
    mwtrue();
    } else {
    mwstr_buf_is_hex_int_3F_();
    }
}

static void mwstr_buf_is_hex_int_3F_ (void){
    push_i64(0LL);
    push_i64(0LL);
    mwdup();
    mwstr_buf_char_40_();
    mwis_sign_3F_();
    mwnip();
    if (pop_u64()) {
    mw1_2B_();
    } else {
    mwid();
    }
    mwdup();
    mwstr_buf_char_40_();
    mwis_zero_char();
    if (pop_u64()) {
    mw1_2B_();
    mwdup();
    mwstr_buf_char_40_();
    mwis_xX_char();
    if (pop_u64()) {
    mw1_2B_();
    while(1) {
    mwdup();
    mwstr_buf_char_40_();
    mwis_hexdigit_3F_();
    mwnip();
    if (!pop_u64()) break;
    { value_t d4 = pop_value();
    mw1_2B_();
      push_value(d4); }
    mw1_2B_();
    }
    mwswap();
    push_i64(1LL);
    mw_3E__3D_();
    if (pop_u64()) {
    mwstr_buf_length_3F_();
    mw_3D__3D_();
    } else {
    mwdrop();
    mwfalse();
    }
    } else {
    mwdrop2();
    mwfalse();
    }
    } else {
    mwdrop2();
    mwfalse();
    }
}

static void mwis_hexdigit_3F_ (void){
    mwis_digit_3F_();
    { value_t d1 = pop_value();
    mwis_upper_hexdigit_3F_();
      push_value(d1); }
    mw_7C__7C_();
    { value_t d1 = pop_value();
    mwis_lower_hexdigit_3F_();
      push_value(d1); }
    mw_7C__7C_();
}

static void mwis_lower_hexdigit_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(97LL);
    push_i64(102LL);
    mwin_range();
}

static void mwis_xX_char (void){
    mwChar__3E_Int();
    mwdup();
    push_i64(88LL);
    mw_3D__3D_();
    { value_t d1 = pop_value();
    push_i64(120LL);
    mw_3D__3D_();
      push_value(d1); }
    mw_7C__7C_();
}

static void mwis_zero_char (void){
    mwChar__3E_Int();
    push_i64(48LL);
    mw_3D__3D_();
}

static void mwlexer_skip_doc_21_ (void){
    while(1) {
    mwlexer_comment_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwlexer_move_21_();
    }
}

static void mwstr_buf_is_doc_start_3F_ (void){
    mwstr_buf_length_3F_();
    push_i64(3LL);
    mw_3D__3D_();
    push_u64(0);
    push_fnptr(&mb_str_buf_is_doc_start_3F__1);
    do_pack_cons();
    mwand();
}

static void mb_str_buf_is_doc_start_3F__1 (void) {
    do_drop();
    push_i64(0LL);
    mwstr_buf_char_40_();
    mwis_pipe_3F_();
    mwnip();
    push_u64(0);
    push_fnptr(&mb_str_buf_is_doc_start_3F__2);
    do_pack_cons();
    mwand();
    push_u64(0);
    push_fnptr(&mb_str_buf_is_doc_start_3F__3);
    do_pack_cons();
    mwand();
}
static void mb_str_buf_is_doc_start_3F__3 (void) {
    do_drop();
    push_i64(2LL);
    mwstr_buf_char_40_();
    mwis_pipe_3F_();
    mwnip();
}
static void mb_str_buf_is_doc_start_3F__2 (void) {
    do_drop();
    push_i64(1LL);
    mwstr_buf_char_40_();
    mwis_pipe_3F_();
    mwnip();
}
static void mwis_pipe_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(124LL);
    mw_3D__3D_();
}

static void mwis_name_char_3F_ (void){
    mwis_visible_3F_();
    { value_t d1 = pop_value();
    mwis_special_char_3F_();
    mwnot();
      push_value(d1); }
    mw_26__26_();
}

static void mwis_special_char_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    mwdup();
    push_i64(64LL);
    mw_3C_();
    if (pop_u64()) {
    push_i64(288251318412247040LL);
    } else {
    push_i64(64LL);
    mw_();
    push_i64(2882303762188206080LL);
    }
    mwswap();
    mw_3E__3E_();
    push_i64(1LL);
    mw_26_();
    push_i64(0LL);
    mw_3C__3E_();
}

static void mwis_visible_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(32LL);
    mw_3E_();
}

static void mwlexer_emit_fatal_error_21_ (void){
    { value_t d1 = pop_value();
    mwlexer_location();
      push_value(d1); }
    mwemit_fatal_error_at_21_();
}

static void mwchar_valid_3F_ (void){
    mwdup();
    mwchar_valid();
}

static void mwchar_valid (void){
    mwchar_width_3F_();
    mwdup();
    push_i64(1LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwchar_valid_1();
    } else {
    mwdup();
    push_i64(2LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwchar_valid_2();
    } else {
    mwdup();
    push_i64(3LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwchar_valid_3();
    } else {
    mwdrop();
    mwchar_valid_4();
    }
    }
    }
}

static void mwchar_valid_4 (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(3233857784LL);
    mw_26_();
    push_i64(2155905264LL);
    mw_3D__3D_();
    mwswap();
    mwchar_codepoint_4();
    push_i64(65536LL);
    push_i64(1114111LL);
    mwin_range();
    mw_26__26_();
}

static void mwchar_codepoint_4 (void){
    mwChar__3E_Int();
    mwdup();
    push_i64(1056964608LL);
    mw_26_();
    push_i64(24LL);
    mw_3E__3E_();
    { value_t d1 = pop_value();
    mwdup();
    push_i64(4128768LL);
    mw_26_();
    push_i64(10LL);
    mw_3E__3E_();
    { value_t d2 = pop_value();
    mwdup();
    push_i64(16128LL);
    mw_26_();
    push_i64(4LL);
    mw_3C__3C_();
    { value_t d3 = pop_value();
    push_i64(7LL);
    mw_26_();
    push_i64(18LL);
    mw_3C__3C_();
      push_value(d3); }
      push_value(d2); }
      push_value(d1); }
    mw_7C_();
    mw_7C_();
    mw_7C_();
}

static void mwchar_valid_3 (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(4290822384LL);
    mw_26_();
    push_i64(8421600LL);
    mw_3D__3D_();
    mwswap();
    mwchar_codepoint_3();
    mwdup();
    push_i64(2048LL);
    push_i64(65535LL);
    mwin_range();
    mwswap();
    push_i64(55296LL);
    push_i64(57343LL);
    mwin_range();
    mwnot();
    mw_26__26_();
    mw_26__26_();
}

static void mwchar_codepoint_3 (void){
    mwChar__3E_Int();
    mwdup();
    push_i64(4128768LL);
    mw_26_();
    push_i64(16LL);
    mw_3E__3E_();
    { value_t d1 = pop_value();
    mwdup();
    push_i64(16128LL);
    mw_26_();
    push_i64(2LL);
    mw_3E__3E_();
    { value_t d2 = pop_value();
    push_i64(15LL);
    mw_26_();
    push_i64(12LL);
    mw_3C__3C_();
      push_value(d2); }
      push_value(d1); }
    mw_7C_();
    mw_7C_();
}

static void mwchar_valid_2 (void){
    mwChar__3E_Int();
    mwdup();
    push_i64(4294951136LL);
    mw_26_();
    push_i64(32960LL);
    mw_3D__3D_();
    mwswap();
    push_i64(31LL);
    mw_26_();
    push_i64(2LL);
    mw_3E__3D_();
    mw_26__26_();
}

static void mwchar_valid_1 (void){
    mwChar__3E_Int();
    push_i64(4294967168LL);
    mw_26_();
    push_i64(0LL);
    mw_3D__3D_();
}

static void mwchar_width_3F_ (void){
    mwdup();
    mwchar_width();
}

static void mwlexer_peek (void){
    mwinput_peek();
}

static void mwinput_peek (void){
    mwinput_isopen_40_();
    if (pop_u64()) {
    mwinput_offset_40_();
    mwINPUT_BUFFER();
    mwptr_2B_();
    mwchar_40_();
    } else {
    push_ptr("error: attempted to read input buffer when file is already closed\0\0\0");
    mwpanic_21_();
    }
}

static void mwlexer_done_3F_ (void){
    mwinput_done_3F_();
}

static void mwinput_done_3F_ (void){
    mwinput_isopen_40_();
    mwnot();
}

static void mwtoken_alloc_21_ (void){
    mwToken_2E_alloc_21_();
    mwTOKEN_NONE();
    mwover();
    mwtoken_value_21_();
}

static void mwToken_2E_alloc_21_ (void){
    mwToken_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwToken_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwlexer_col_21_ (void){
    mwLEXER_COL();
    mwvalue_21_();
}

static void mwInt__3E_Col (void){
    mwCOL();
}

static void mwlexer_row_21_ (void){
    mwLEXER_ROW();
    mwvalue_21_();
}

static void mwInt__3E_Row (void){
    mwROW();
}

static void mwinput_start_21_ (void){
    mwinput_handle_21_();
    push_i64(0LL);
    mwinput_length_21_();
    push_i64(0LL);
    mwinput_offset_21_();
    mwtrue();
    mwinput_isopen_21_();
    mwinput_fill_buffer_21_();
}

static void mwopen_file_21_ (void){
    push_i64(0LL);
    push_i64(0LL);
    mwposix_open_21_();
    mwdup();
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("Failed to open file!\0\0\0");
    mwpanic_21_();
    } else {
    mwInt__3E_File();
    }
}

static void mwposix_open_21_ (void){
    push_u64(0);
    push_fnptr(&mb_posix_open_21__1);
    do_pack_cons();
    mwdip2();
    mwprim_2E_posix_2E_open();
}

static void mb_posix_open_21__1 (void) {
    do_drop();
    mwStr__3E_Ptr();
}
static void mwlexer_module_40_ (void){
    mwLEXER_MODULE();
    mwvalue_40_();
}

static void mwlexer_module_21_ (void){
    mwLEXER_MODULE();
    mwvalue_21_();
}

static void mwmodule_new_21_ (void){
    mwModule_2E_alloc_21_();
    mwtuck();
    mwmodule_path_21_();
}

static void mwModule_2E_alloc_21_ (void){
    mwModule_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwModule_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwPath__3E_Str (void){
    mwid();
}

static void mwStr__3E_Path (void){
    mwPATH();
}

static void mwPtr__3E_Str (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwptr_40__40_ (void){
    { value_t d1 = pop_value();
    mwptrs();
      push_value(d1); }
    mwptr_2B_();
    mwptr_40_();
}

static void mwptrs (void){
    mw_7C_ptr_7C_();
    mw_2A_();
}

static void mw_7C_ptr_7C_ (void){
    mwprim_2E_ptr_2E_size();
}

static void mwargv (void){
    mwprim_2E_sys_2E_argv();
}

static void mw_3C_ (void){
    mwprim_2E_value_2E_lt();
}

static void mwargc (void){
    mwprim_2E_sys_2E_argc();
}

static void mwinit_21_ (void){
    mwinit_paths_21_();
    mwinit_prims_21_();
    mwinit_types_21_();
}

static void mwinit_types_21_ (void){
    mwTYPE_INT();
    push_ptr("Int\0\0\0");
    mwdef_type_21_();
    mwTYPE_PTR();
    push_ptr("Ptr\0\0\0");
    mwdef_type_21_();
    mwTYPE_STR();
    push_ptr("Str\0\0\0");
    mwdef_type_21_();
    mwTYPE_CHAR();
    push_ptr("Char\0\0\0");
    mwdef_type_21_();
    mwTYPE_U8();
    push_ptr("U8\0\0\0");
    mwdef_type_21_();
    mwTYPE_U16();
    push_ptr("U16\0\0\0");
    mwdef_type_21_();
    mwTYPE_U32();
    push_ptr("U32\0\0\0");
    mwdef_type_21_();
    mwTYPE_U64();
    push_ptr("U64\0\0\0");
    mwdef_type_21_();
    mwTYPE_I8();
    push_ptr("I8\0\0\0");
    mwdef_type_21_();
    mwTYPE_I16();
    push_ptr("I16\0\0\0");
    mwdef_type_21_();
    mwTYPE_I32();
    push_ptr("I32\0\0\0");
    mwdef_type_21_();
    mwTYPE_I64();
    push_ptr("I64\0\0\0");
    mwdef_type_21_();
    mwTYPE_BOOL();
    push_ptr("Bool\0\0\0");
    mwdef_type_21_();
    mwTYPE_MUT();
    push_ptr("Mut\0\0\0");
    mwdef_type_21_();
}

static void mwTYPE_MUT (void){
    mwPRIM_TYPE_MUT();
    mwTPrim();
}

static void mwTYPE_BOOL (void){
    mwPRIM_TYPE_BOOL();
    mwTPrim();
}

static void mwTYPE_I64 (void){
    mwPRIM_TYPE_I64();
    mwTPrim();
}

static void mwTYPE_I32 (void){
    mwPRIM_TYPE_I32();
    mwTPrim();
}

static void mwTYPE_I16 (void){
    mwPRIM_TYPE_I16();
    mwTPrim();
}

static void mwTYPE_I8 (void){
    mwPRIM_TYPE_I8();
    mwTPrim();
}

static void mwTYPE_U64 (void){
    mwPRIM_TYPE_U64();
    mwTPrim();
}

static void mwTYPE_U32 (void){
    mwPRIM_TYPE_U32();
    mwTPrim();
}

static void mwTYPE_U16 (void){
    mwPRIM_TYPE_U16();
    mwTPrim();
}

static void mwTYPE_U8 (void){
    mwPRIM_TYPE_U8();
    mwTPrim();
}

static void mwTYPE_CHAR (void){
    mwPRIM_TYPE_CHAR();
    mwTPrim();
}

static void mwdef_type_21_ (void){
    { value_t d1 = pop_value();
    mwDEF_TYPE();
      push_value(d1); }
    mwname_new_21_();
    mwname_def_21_();
}

static void mwinit_prims_21_ (void){
    mwPRIM_SYNTAX_MODULE();
    push_ptr("module\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_IMPORT();
    push_ptr("import\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_DEF();
    push_ptr("def\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_DEF_TYPE();
    push_ptr("def-type\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_BUFFER();
    push_ptr("buffer\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_DEF_EXTERNAL();
    push_ptr("def-external\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_TABLE();
    push_ptr("table\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_FIELD();
    push_ptr("field\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_TARGET_C99();
    push_ptr("target-c99\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_DATA();
    push_ptr("data\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_ARROW();
    push_ptr("->\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYNTAX_DASHES();
    push_ptr("--\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_DIP();
    push_ptr("dip\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_IF();
    push_ptr("if\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_WHILE();
    push_ptr("while\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_MATCH();
    push_ptr("match\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_LAMBDA();
    push_ptr("\\\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_ID();
    push_ptr("prim.core.id\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_DUP();
    push_ptr("prim.core.dup\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_DROP();
    push_ptr("prim.core.drop\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_SWAP();
    push_ptr("prim.core.swap\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_DIP();
    push_ptr("prim.core.dip\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_IF();
    push_ptr("prim.core.if\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_WHILE();
    push_ptr("prim.core.while\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_DEBUG();
    push_ptr("prim.core.debug\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_RUN();
    push_ptr("prim.core.run\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_MATCH();
    push_ptr("prim.core.match\0\0\0");
    mwdef_prim_21_();
    mwPRIM_CORE_LAMBDA();
    push_ptr("prim.core.lambda\0\0\0");
    mwdef_prim_21_();
    mwPRIM_UNSAFE_CAST();
    push_ptr("prim.unsafe.cast\0\0\0");
    mwdef_prim_21_();
    mwPRIM_VALUE_EQ();
    push_ptr("prim.value.eq\0\0\0");
    mwdef_prim_21_();
    mwPRIM_VALUE_LT();
    push_ptr("prim.value.lt\0\0\0");
    mwdef_prim_21_();
    mwPRIM_VALUE_LE();
    push_ptr("prim.value.le\0\0\0");
    mwdef_prim_21_();
    mwPRIM_VALUE_GET();
    push_ptr("prim.value.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_VALUE_SET();
    push_ptr("prim.value.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_ADD();
    push_ptr("prim.int.add\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_SUB();
    push_ptr("prim.int.sub\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_MUL();
    push_ptr("prim.int.mul\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_DIV();
    push_ptr("prim.int.div\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_MOD();
    push_ptr("prim.int.mod\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_AND();
    push_ptr("prim.int.and\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_OR();
    push_ptr("prim.int.or\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_XOR();
    push_ptr("prim.int.xor\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_SHL();
    push_ptr("prim.int.shl\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_SHR();
    push_ptr("prim.int.shr\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_GET();
    push_ptr("prim.int.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_INT_SET();
    push_ptr("prim.int.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_BOOL_TRUE();
    push_ptr("prim.bool.true\0\0\0");
    mwdef_prim_21_();
    mwPRIM_BOOL_FALSE();
    push_ptr("prim.bool.false\0\0\0");
    mwdef_prim_21_();
    mwPRIM_BOOL_AND();
    push_ptr("prim.bool.and\0\0\0");
    mwdef_prim_21_();
    mwPRIM_BOOL_OR();
    push_ptr("prim.bool.or\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PACK_NIL();
    push_ptr("prim.pack.nil\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PACK_CONS();
    push_ptr("prim.pack.cons\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PACK_UNCONS();
    push_ptr("prim.pack.uncons\0\0\0");
    mwdef_prim_21_();
    mwPRIM_MUT_NEW();
    push_ptr("prim.mut.new\0\0\0");
    mwdef_prim_21_();
    mwPRIM_MUT_GET();
    push_ptr("prim.mut.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_MUT_SET();
    push_ptr("prim.mut.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_ADD();
    push_ptr("prim.ptr.add\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_SIZE();
    push_ptr("prim.ptr.size\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_GET();
    push_ptr("prim.ptr.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_SET();
    push_ptr("prim.ptr.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_ALLOC();
    push_ptr("prim.ptr.alloc\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_REALLOC();
    push_ptr("prim.ptr.realloc\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_FILL();
    push_ptr("prim.ptr.fill\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_COPY();
    push_ptr("prim.ptr.copy\0\0\0");
    mwdef_prim_21_();
    mwPRIM_PTR_RAW();
    push_ptr("prim.ptr.raw\0\0\0");
    mwdef_prim_21_();
    mwPRIM_STR_ALLOC();
    push_ptr("prim.str.alloc\0\0\0");
    mwdef_prim_21_();
    mwPRIM_STR_SIZE();
    push_ptr("prim.str.size\0\0\0");
    mwdef_prim_21_();
    mwPRIM_STR_BASE();
    push_ptr("prim.str.base\0\0\0");
    mwdef_prim_21_();
    mwPRIM_STR_EQ();
    push_ptr("prim.str.eq\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U8_GET();
    push_ptr("prim.u8.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U8_SET();
    push_ptr("prim.u8.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U16_GET();
    push_ptr("prim.u16.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U16_SET();
    push_ptr("prim.u16.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U32_GET();
    push_ptr("prim.u32.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U32_SET();
    push_ptr("prim.u32.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U64_GET();
    push_ptr("prim.u64.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_U64_SET();
    push_ptr("prim.u64.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I8_GET();
    push_ptr("prim.i8.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I8_SET();
    push_ptr("prim.i8.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I16_GET();
    push_ptr("prim.i16.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I16_SET();
    push_ptr("prim.i16.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I32_GET();
    push_ptr("prim.i32.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I32_SET();
    push_ptr("prim.i32.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I64_GET();
    push_ptr("prim.i64.get\0\0\0");
    mwdef_prim_21_();
    mwPRIM_I64_SET();
    push_ptr("prim.i64.set\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYS_OS();
    push_ptr("prim.sys.os\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYS_ARGC();
    push_ptr("prim.sys.argc\0\0\0");
    mwdef_prim_21_();
    mwPRIM_SYS_ARGV();
    push_ptr("prim.sys.argv\0\0\0");
    mwdef_prim_21_();
    mwPRIM_POSIX_READ();
    push_ptr("prim.posix.read\0\0\0");
    mwdef_prim_21_();
    mwPRIM_POSIX_WRITE();
    push_ptr("prim.posix.write\0\0\0");
    mwdef_prim_21_();
    mwPRIM_POSIX_OPEN();
    push_ptr("prim.posix.open\0\0\0");
    mwdef_prim_21_();
    mwPRIM_POSIX_CLOSE();
    push_ptr("prim.posix.close\0\0\0");
    mwdef_prim_21_();
    mwPRIM_POSIX_EXIT();
    push_ptr("prim.posix.exit\0\0\0");
    mwdef_prim_21_();
    mwPRIM_POSIX_MMAP();
    push_ptr("prim.posix.mmap\0\0\0");
    mwdef_prim_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__1);
    do_pack_cons();
    mwPRIM_SYNTAX_IMPORT();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__2);
    do_pack_cons();
    mwPRIM_SYNTAX_DEF();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__3);
    do_pack_cons();
    mwPRIM_SYNTAX_DEF_EXTERNAL();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__4);
    do_pack_cons();
    mwPRIM_SYNTAX_DEF_TYPE();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__5);
    do_pack_cons();
    mwPRIM_SYNTAX_BUFFER();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__6);
    do_pack_cons();
    mwPRIM_SYNTAX_TABLE();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__7);
    do_pack_cons();
    mwPRIM_SYNTAX_FIELD();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__8);
    do_pack_cons();
    mwPRIM_SYNTAX_TARGET_C99();
    mwprim_decl_21_();
    push_u64(0);
    push_fnptr(&mb_init_prims_21__9);
    do_pack_cons();
    mwPRIM_SYNTAX_DATA();
    mwprim_decl_21_();
    mwT0();
    mwT0();
    mwT__3E_();
    mwdup();
    mwPRIM_CORE_ID();
    mwprim_type_21_();
    mwdup();
    mwPRIM_CORE_DEBUG();
    mwprim_type_21_();
    mwdrop();
    mwTYPE_INT();
    mwTYPE_INT();
    mwT2();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwdup();
    mwPRIM_INT_ADD();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_SUB();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_MUL();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_DIV();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_MOD();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_AND();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_OR();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_XOR();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_SHL();
    mwprim_type_21_();
    mwdup();
    mwPRIM_INT_SHR();
    mwprim_type_21_();
    mwdrop();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_INT_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_PTR_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_U8();
    mwT1();
    mwT__3E_();
    mwPRIM_U8_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_U16();
    mwT1();
    mwT__3E_();
    mwPRIM_U16_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_U32();
    mwT1();
    mwT__3E_();
    mwPRIM_U32_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_U64();
    mwT1();
    mwT__3E_();
    mwPRIM_U64_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_I8();
    mwT1();
    mwT__3E_();
    mwPRIM_I8_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_I16();
    mwT1();
    mwT__3E_();
    mwPRIM_I16_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_I32();
    mwT1();
    mwT__3E_();
    mwPRIM_I32_GET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_I64();
    mwT1();
    mwT__3E_();
    mwPRIM_I64_GET();
    mwprim_type_21_();
    mwTYPE_INT();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_INT_SET();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_PTR_SET();
    mwprim_type_21_();
    mwTYPE_U8();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_U8_SET();
    mwprim_type_21_();
    mwTYPE_U16();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_U16_SET();
    mwprim_type_21_();
    mwTYPE_U32();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_U32_SET();
    mwprim_type_21_();
    mwTYPE_U64();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_U64_SET();
    mwprim_type_21_();
    mwTYPE_I8();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_I8_SET();
    mwprim_type_21_();
    mwTYPE_I16();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_I16_SET();
    mwprim_type_21_();
    mwTYPE_I32();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_I32_SET();
    mwprim_type_21_();
    mwTYPE_I64();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_I64_SET();
    mwprim_type_21_();
    mwTYPE_INT();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwT3();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_POSIX_READ();
    mwprim_type_21_();
    mwTYPE_INT();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwT3();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_POSIX_WRITE();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwTYPE_INT();
    mwT3();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_POSIX_OPEN();
    mwprim_type_21_();
    mwTYPE_INT();
    mwT1();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_POSIX_CLOSE();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwTYPE_INT();
    mwTYPE_INT();
    mwTYPE_INT();
    mwTYPE_INT();
    mwT6();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_POSIX_MMAP();
    mwprim_type_21_();
    mwTYPE_INT();
    mwTYPE_PTR();
    mwT2();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_PTR_ADD();
    mwprim_type_21_();
    mwT0();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_PTR_SIZE();
    mwprim_type_21_();
    mwTYPE_INT();
    mwT1();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_PTR_ALLOC();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwT2();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_PTR_REALLOC();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwTYPE_PTR();
    mwT3();
    mwT0();
    mwT__3E_();
    mwPRIM_PTR_COPY();
    mwprim_type_21_();
    mwTYPE_INT();
    mwTYPE_INT();
    mwTYPE_PTR();
    mwT3();
    mwT0();
    mwT__3E_();
    mwPRIM_PTR_FILL();
    mwprim_type_21_();
    mwTYPE_PTR();
    mwT1();
    mwTYPE_PTR();
    mwTYPE_INT();
    mwT2();
    mwT__3E_();
    mwPRIM_PTR_RAW();
    mwprim_type_21_();
    mwTYPE_INT();
    mwT1();
    mwTYPE_STR();
    mwT1();
    mwT__3E_();
    mwPRIM_STR_ALLOC();
    mwprim_type_21_();
    mwTYPE_STR();
    mwT1();
    mwTYPE_STR();
    mwTYPE_INT();
    mwT2();
    mwT__3E_();
    mwPRIM_STR_SIZE();
    mwprim_type_21_();
    mwTYPE_STR();
    mwT1();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_STR_BASE();
    mwprim_type_21_();
    mwTYPE_STR();
    mwTYPE_STR();
    mwT2();
    mwTYPE_BOOL();
    mwT1();
    mwT__3E_();
    mwPRIM_STR_EQ();
    mwprim_type_21_();
    mwT0();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_SYS_OS();
    mwprim_type_21_();
    mwT0();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwPRIM_SYS_ARGC();
    mwprim_type_21_();
    mwT0();
    mwTYPE_PTR();
    mwT1();
    mwT__3E_();
    mwPRIM_SYS_ARGV();
    mwprim_type_21_();
    mwT0();
    mwTYPE_BOOL();
    mwT1();
    mwT__3E_();
    mwdup();
    mwPRIM_BOOL_TRUE();
    mwprim_type_21_();
    mwdup();
    mwPRIM_BOOL_FALSE();
    mwprim_type_21_();
    mwdrop();
    mwTYPE_BOOL();
    mwTYPE_BOOL();
    mwT2();
    mwTYPE_BOOL();
    mwT1();
    mwT__3E_();
    mwdup();
    mwPRIM_BOOL_AND();
    mwprim_type_21_();
    mwdup();
    mwPRIM_BOOL_OR();
    mwprim_type_21_();
    mwdrop();
    mwT0();
    mwT0();
    mwT1();
    mwT__3E_();
    mwPRIM_PACK_NIL();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_DROP();
    mwprim_ctx_21_();
    mwTVar();
    mwT1();
    mwT0();
    mwT__3E_();
    mwPRIM_CORE_DROP();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_DUP();
    mwprim_ctx_21_();
    mwTVar();
    mwdup();
    mwT1();
    mwdup();
    mwrotl();
    mwT_2A_();
    mwT__3E_();
    mwPRIM_CORE_DUP();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwdup();
    mwPRIM_VALUE_EQ();
    mwprim_ctx_21_();
    mwdup();
    mwPRIM_VALUE_LT();
    mwprim_ctx_21_();
    mwdup();
    mwPRIM_VALUE_LE();
    mwprim_ctx_21_();
    mwdrop();
    mwTVar();
    mwdup();
    mwT2();
    mwTYPE_BOOL();
    mwT1();
    mwT__3E_();
    mwdup();
    mwPRIM_VALUE_EQ();
    mwprim_type_21_();
    mwdup();
    mwPRIM_VALUE_LT();
    mwprim_type_21_();
    mwdup();
    mwPRIM_VALUE_LE();
    mwprim_type_21_();
    mwdrop();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    push_ptr("b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_SWAP();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
      push_value(d1); }
    mwTVar();
    mwdup2();
    mwT2();
    mwrotr();
    mwswap();
    mwT2();
    mwT__3E_();
    mwPRIM_CORE_SWAP();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    push_ptr("b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_UNSAFE_CAST();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
    mwT1();
      push_value(d1); }
    mwTVar();
    mwT1();
    mwT__3E_();
    mwPRIM_UNSAFE_CAST();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("*b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_RUN();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
      push_value(d1); }
    mwTVar();
    mwdup2();
    mwT__3E_();
    mwswap();
    { value_t d1 = pop_value();
    mwT_2A_();
      push_value(d1); }
    mwT__3E_();
    mwPRIM_CORE_RUN();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("*b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_POSIX_EXIT();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
      push_value(d1); }
    mwTVar();
    { value_t d1 = pop_value();
    mwTYPE_INT();
    mwT_2A_();
      push_value(d1); }
    mwT__3E_();
    mwPRIM_POSIX_EXIT();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("*b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("c\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup3();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_DIP();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    mwTVar();
      push_value(d2); }
    mwTVar();
      push_value(d1); }
    mwTVar();
    { value_t d1 = pop_value();
    mwdup2();
      push_value(d1); }
    mwtuck();
    mwT_2A_();
    { value_t d1 = pop_value();
    mwT_2A_();
      push_value(d1); }
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    mwT__3E_();
      push_value(d2); }
    mwswap();
    mwT_2A_();
      push_value(d1); }
    mwT__3E_();
    mwPRIM_CORE_DIP();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("*b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_IF();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
      push_value(d1); }
    mwTVar();
    mwdup2();
    mwT__3E_();
    mwswap();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    mwTYPE_BOOL();
    mwT_2A_();
      push_value(d2); }
    mwdup();
    { value_t d2 = pop_value();
    mwT_2A_();
      push_value(d2); }
    mwT_2A_();
      push_value(d1); }
    mwT__3E_();
    mwPRIM_CORE_IF();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwPRIM_CORE_WHILE();
    mwprim_ctx_21_();
    mwTVar();
    mwdup();
    mwdup();
    { value_t d1 = pop_value();
    mwdup();
    mwT__3E_();
    mwT_2A_();
      push_value(d1); }
    mwdup();
    { value_t d1 = pop_value();
    mwdup();
    mwTYPE_BOOL();
    mwT_2A_();
    mwT__3E_();
    mwT_2A_();
      push_value(d1); }
    mwT__3E_();
    mwPRIM_CORE_WHILE();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_PACK_CONS();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
      push_value(d1); }
    mwTVar();
    mwdup2();
    mwT2();
    mwrotr();
    mwT_2A_();
    mwT1();
    mwT__3E_();
    mwPRIM_PACK_CONS();
    mwprim_type_21_();
    push_ptr("*a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    push_ptr("b\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup2();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwswap();
    mwctx_new_21_();
    mwPRIM_PACK_UNCONS();
    mwprim_ctx_21_();
    { value_t d1 = pop_value();
    mwTVar();
      push_value(d1); }
    mwTVar();
    mwdup2();
    mwT_2A_();
    mwT1();
    mwrotr();
    mwT2();
    mwT__3E_();
    mwPRIM_PACK_UNCONS();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwPRIM_VALUE_GET();
    mwprim_ctx_21_();
    mwTVar();
    { value_t d1 = pop_value();
    mwTYPE_PTR();
    mwT1();
      push_value(d1); }
    mwT1();
    mwT__3E_();
    mwPRIM_VALUE_GET();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwPRIM_VALUE_SET();
    mwprim_ctx_21_();
    mwTVar();
    mwTYPE_PTR();
    mwT2();
    mwT0();
    mwT__3E_();
    mwPRIM_VALUE_SET();
    mwprim_type_21_();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_TYPE();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwctx_empty();
    mwswap();
    mwctx_new_21_();
    mwdup();
    mwPRIM_MUT_NEW();
    mwprim_ctx_21_();
    mwdup();
    mwPRIM_MUT_GET();
    mwprim_ctx_21_();
    mwdup();
    mwPRIM_MUT_SET();
    mwprim_ctx_21_();
    mwdrop();
    mwdup();
    mwTVar();
    mwdup();
    mwTMut();
    { value_t d1 = pop_value();
    mwT1();
      push_value(d1); }
    mwT1();
    mwT__3E_();
    mwPRIM_MUT_NEW();
    mwprim_type_21_();
    mwdup();
    mwTVar();
    mwdup();
    { value_t d1 = pop_value();
    mwTMut();
    mwT1();
      push_value(d1); }
    mwT1();
    mwT__3E_();
    mwPRIM_MUT_GET();
    mwprim_type_21_();
    mwTVar();
    mwdup();
    mwTMut();
    mwdup();
    { value_t d1 = pop_value();
    mwT2();
      push_value(d1); }
    mwT1();
    mwT__3E_();
    mwPRIM_MUT_SET();
    mwprim_type_21_();
}

static void mwTMut (void){
    mwTYPE_MUT();
    mwswap();
    mwTApp();
}

static void mwdup3 (void){
    mwdup();
    { value_t d1 = pop_value();
    { value_t d2 = pop_value();
    mwdup2();
      push_value(d2); }
    mwrotr();
      push_value(d1); }
}

static value_t* fieldptr_prim_ctx (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwprim_ctx_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_ctx(index);
    incref(v); push_value(v);
}
static void mwprim_ctx_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_ctx(index);
    incref(v); push_value(v);
}
static void mwprim_ctx_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_prim_ctx(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwT6 (void){
    { value_t d1 = pop_value();
    mwT5();
      push_value(d1); }
    mwT_2A_();
}

static void mwT5 (void){
    { value_t d1 = pop_value();
    mwT4();
      push_value(d1); }
    mwT_2A_();
}

static void mwT4 (void){
    { value_t d1 = pop_value();
    mwT3();
      push_value(d1); }
    mwT_2A_();
}

static void mwT3 (void){
    { value_t d1 = pop_value();
    mwT2();
      push_value(d1); }
    mwT_2A_();
}

static void mb_init_prims_21__9 (void) {
    do_drop();
    mwelab_data_21_();
}
static void mwelab_data_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwData_2E_alloc_21_();
    mwswap();
    mwtoken_args_2B_();
    mwuncons();
    { value_t d2 = pop_value();
    mwelab_data_header_21_();
      push_value(d2); }
    push_u64(0);
    push_fnptr(&mb_elab_data_21__3);
    do_pack_cons();
    mwfor();
    mwdrop();
      push_value(d1); }
    mwtoken_next();
}

static void mb_elab_data_21__3 (void) {
    do_drop();
    mwelab_data_tag_21_();
}
static void mwelab_data_tag_21_ (void){
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("Expected constructor name.\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwtoken_name_3F_();
    mwname_undefined_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwdrop();
    push_ptr("Name already defined. (Overlapping tags not supported.)\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwTag_2E_alloc_21_();
    mwdup2();
    mwDEF_TAG();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwtag_name_21_();
    { value_t d1 = pop_value();
    mwover();
      push_value(d1); }
    mwdup2();
    mwtag_data_21_();
    mwtuck();
    { value_t d1 = pop_value();
    mwdata_add_tag_21_();
      push_value(d1); }
    mwswap();
    mwtoken_succ();
    mwtoken_is_arrow_3F_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwtrue();
    mwover();
    mwtag_has_sig_21_();
      push_value(d2); }
    mwtoken_succ();
    mwtuck();
    { value_t d2 = pop_value();
    mwtag_sig_21_();
      push_value(d2); }
    while(1) {
    mwtoken_run_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwtoken_next();
    }
    } else {
    mwtoken_run_end_3F_();
    if (pop_u64()) {
    mwnip();
    } else {
    push_ptr("Expected arrow, comma, or right paren.\0\0\0");
    mwemit_fatal_error_21_();
    }
    }
    mwdrop();
}

static void mwdata_add_tag_21_ (void){
    mwdup2();
    mwdata_num_tags();
    mwswap();
    mwtag_value_21_();
    mwdata_tags_3F_();
    mwrotr();
    { value_t d1 = pop_value();
    mwsnoc();
      push_value(d1); }
    mwdata_tags_21_();
}

static value_t* fieldptr_tag_value (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_value_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_value(index);
    incref(v); push_value(v);
}
static void mwtag_value_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_value(index);
    incref(v); push_value(v);
}
static void mwtag_value_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_value(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_tag_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtag_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_name(index);
    incref(v); push_value(v);
}
static void mwtag_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_tag_name(index);
    incref(v); push_value(v);
}
static void mwtag_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_tag_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwTag_2E_alloc_21_ (void){
    mwTag_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwTag_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwelab_data_header_21_ (void){
    mwdup2();
    mwswap();
    mwdata_header_21_();
    mwsig_token_is_type_con_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("Expected type name.\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwdup2();
    mwtoken_name_40_();
    mwname_undefined_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwdrop2();
    push_ptr("Name already defined.\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwover();
    mwTData();
    mwDEF_TYPE();
    mwover();
    mwname_def_21_();
    mwswap();
    mwdata_name_21_();
    mwtoken_num_args();
    mwover();
    mwdata_arity_21_();
}

static void mwtoken_args_2B_ (void){
    mwdup();
    mwtoken_args();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_ptr("expected args\0\0\0");
    mwemit_fatal_error_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwData_2E_alloc_21_ (void){
    mwData_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwData_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mb_init_prims_21__8 (void) {
    do_drop();
    mwelab_target_c99_21_();
}
static void mwelab_target_c99_21_ (void){
    mwtypecheck_everything_21_();
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_2();
    { value_t d1 = pop_value();
    mwtoken_str_40_();
    mwStr__3E_Path();
      push_value(d1); }
    { value_t d1 = pop_value();
    mwctx_empty();
    mwT0();
    mwT0();
    mwT__3E_();
      push_value(d1); }
    mwelab_arrow_21_();
    mwswap();
    mwrun_output_c99_21_();
}

static void mwrun_output_c99_21_ (void){
    mwnum_errors_40_();
    push_i64(0LL);
    mw_3E_();
    if (pop_u64()) {
    mwdrop2();
    } else {
    mwmake_output_path();
    mwPath__3E_Str();
    mwcreate_file_21_();
    mwcodegen_start_21_();
    mwc99_emit_header_21_();
    mwc99_emit_prims_21_();
    mwc99_emit_tags_21_();
    mwc99_emit_buffers_21_();
    mwc99_emit_externals_21_();
    mwc99_emit_word_sigs_21_();
    mwc99_emit_block_sigs_21_();
    mwc99_emit_field_sigs_21_();
    mwc99_emit_main_21_();
    mwc99_emit_needs_21_();
    mwcodegen_end_21_();
    }
}

static void mwcodegen_end_21_ (void){
    mwcodegen_flush_21_();
    mwcodegen_file_40_();
    mwclose_file_21_();
    mwstdout();
    mwcodegen_file_21_();
    push_i64(0LL);
    mwcodegen_length_21_();
}

static void mwcodegen_length_21_ (void){
    mwCODEGEN_LENGTH();
    mwint_21_();
}

static void mwcodegen_file_21_ (void){
    mwCODEGEN_FILE();
    mwfile_21_();
}

static void mwfile_21_ (void){
    { value_t d1 = pop_value();
    mwFile__3E_Int();
      push_value(d1); }
    mwint_21_();
}

static void mwstdout (void){
    push_i64(1LL);
    mwInt__3E_File();
}

static void mwcodegen_file_40_ (void){
    mwCODEGEN_FILE();
    mwfile_40_();
}

static void mwfile_40_ (void){
    mwint_40_();
    mwInt__3E_File();
}

static void mwcodegen_flush_21_ (void){
    mwcodegen_length_40_();
    push_i64(0LL);
    mw_3E_();
    if (pop_u64()) {
    mwcodegen_file_40_();
    mwFile__3E_Int();
    mwCODEGEN_BUF();
    mwcodegen_length_40_();
    mwposix_write_21_();
    mwdup();
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("error: codegen write failed\0\0\0");
    mwpanic_21_();
    } else {
    mwcodegen_length_40_();
    mw_3C_();
    if (pop_u64()) {
    push_ptr("error: codegen write wrote fewer bytes than expected\0\0\0");
    mwpanic_21_();
    } else {
    push_i64(0LL);
    mwcodegen_length_21_();
    }
    }
    } else {
    mwid();
    }
}

static void mwcodegen_length_40_ (void){
    mwCODEGEN_LENGTH();
    mwint_40_();
}

static void mwc99_emit_needs_21_ (void){
    while(1) {
    mwhas_need_3F_();
    if (!pop_u64()) break;
    mwneed_pop_21_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_ptr("unexpected branch in c99-emit-needs!\0\0\0");
    mwpanic_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_need_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    }
}

static void mwc99_emit_need_21_ (void){
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_word_def_21_();
    break;
    case 0LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_block_def_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_field_def_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwc99_emit_field_def_21_ (void){
    mwc99_field_needed_3F_();
    if (pop_u64()) {
    mwc99_field_emitted_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwtrue();
    mwover();
    mwc99_field_emitted_21_();
    push_ptr("static value_t* fieldptr_\0\0\0");
    mw_2E_();
    mwfield_name_3F_();
    mw_2E_name();
    push_ptr(" (usize i) {\0\0\0");
    mw_3B_();
    push_ptr("    static struct value_t * p;\0\0\0");
    mw_3B_();
    push_ptr("    static usize n = 0; \0\0\0");
    mw_3B_();
    push_ptr("    if (i >= n) {\0\0\0");
    mw_3B_();
    push_ptr("        usize new_n = n+1;\0\0\0");
    mw_3B_();
    push_ptr("        while (i >= new_n) new_n *= 2;\0\0\0");
    mw_3B_();
    push_ptr("        p = realloc(p, sizeof(struct value_t) * new_n);\0\0\0");
    mw_3B_();
    push_ptr("        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));\0\0\0");
    mw_3B_();
    push_ptr("        n = new_n;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    return p+i;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwfield_name_3F_();
    push_ptr("@\0\0\0");
    mwname_cat_21_();
    mw_2E_w();
    push_ptr("{\0\0\0");
    mw_3B_();
    push_ptr("    usize index = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t v = *fieldptr_\0\0\0");
    mw_2E_();
    mwfield_name_3F_();
    mw_2E_name();
    push_ptr("(index);\0\0\0");
    mw_3B_();
    push_ptr("    incref(v); push_value(v);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
    mwfield_name_3F_();
    push_ptr("?\0\0\0");
    mwname_cat_21_();
    mw_2E_w();
    push_ptr("{\0\0\0");
    mw_3B_();
    push_ptr("    mwdup();\0\0\0");
    mw_3B_();
    push_ptr("    usize index = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t v = *fieldptr_\0\0\0");
    mw_2E_();
    mwfield_name_3F_();
    mw_2E_name();
    push_ptr("(index);\0\0\0");
    mw_3B_();
    push_ptr("    incref(v); push_value(v);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
    mwfield_name_3F_();
    push_ptr("!\0\0\0");
    mwname_cat_21_();
    mw_2E_w();
    push_ptr("{\0\0\0");
    mw_3B_();
    push_ptr("    usize index = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t newvalue = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    value_t* p = fieldptr_\0\0\0");
    mw_2E_();
    mwfield_name_3F_();
    mw_2E_name();
    push_ptr("(index);\0\0\0");
    mw_3B_();
    push_ptr("    value_t oldvalue = *p;\0\0\0");
    mw_3B_();
    push_ptr("    *p = newvalue;\0\0\0");
    mw_3B_();
    push_ptr("    decref(oldvalue);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwdrop();
    }
    } else {
    mwdrop();
    }
}

static void mw_2E_w (void){
    push_ptr("static void mw\0\0\0");
    mw_2E_();
    mw_2E_name();
    push_ptr(" (void)\0\0\0");
    mw_2E_();
}

static void mwname_cat_21_ (void){
    { value_t d1 = pop_value();
    mwname_str_40_();
      push_value(d1); }
    mwstr_cat();
    mwname_new_21_();
}

static void mw_3B__3B_ (void){
    mw_2E_();
    mw_2E_lf();
    mw_2E_lf();
}

static void mw_2E_lf (void){
    push_i64(10LL);
    mwInt__3E_U8();
    mw_2E_b();
}

static void mw_2E_b (void){
    mwcodegen_full_3F_();
    if (pop_u64()) {
    mwcodegen_flush_21_();
    } else {
    mwid();
    }
    mwcodegen_length_40_();
    mwdup();
    mw1_2B_();
    mwcodegen_length_21_();
    mwcodegen_u8_21_();
}

static void mwcodegen_u8_21_ (void){
    mwCODEGEN_BUF();
    mwu8_21__21_();
}

static void mwcodegen_full_3F_ (void){
    mwcodegen_length_40_();
    push_i64(4LL);
    mw_2B_();
    mwCODEGEN_BUF_SIZE();
    mw_3E__3D_();
}

static void mwCODEGEN_BUF_SIZE (void){
    push_i64(256LL);
}

static void mw_3B_ (void){
    mw_2E_();
    mw_2E_lf();
}

static void mw_2E_name (void){
    mwname_mangle_21_();
    mw_2E_();
}

static void mwname_mangle_21_ (void){
    mwname_mangle_cached_3F_();
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop();
    mwdup();
    { value_t d2 = pop_value();
    mwname_mangle_compute_21_();
    mwdup();
      push_value(d2); }
    mwname_mangle_cached_21_();
    } else {
    mwnip();
    }
}

static void mwname_mangle_compute_21_ (void){
    mwname_str_40_();
    push_u64(0);
    push_fnptr(&mb_name_mangle_compute_21__1);
    do_pack_cons();
    mwstr_transduce();
}

static void mb_name_mangle_compute_21__1 (void) {
    do_drop();
    mwis_alpha_3F_();
    if (pop_u64()) {
    mwTS_CHAR();
    } else {
    mwis_digit_3F_();
    if (pop_u64()) {
    mwTS_CHAR();
    } else {
    mwis_underscore_3F_();
    if (pop_u64()) {
    mwTS_CHAR();
    } else {
    mwis_dash_3F_();
    if (pop_u64()) {
    mwdrop();
    mwunderscore();
    mwTS_CHAR();
    } else {
    mwchar_hexdigits();
    mwunderscore();
    mwswap();
    mwcons();
    mwunderscore();
    mwsnoc();
    mwTS_PUSH();
    }
    }
    }
    }
}
static void mwchar_hexdigits (void){
    mwChar__3E_Int();
    mwchar_hexdigits_first();
    while(1) {
    mwdup();
    push_i64(0LL);
    mw_3E_();
    if (!pop_u64()) break;
    mwchar_hexdigits_next();
    }
    mwdrop();
}

static void mwchar_hexdigits_next (void){
    mwdup();
    { value_t d1 = pop_value();
    push_i64(15LL);
    mw_26_();
    mwhexdigit();
      push_value(d1); }
    push_i64(4LL);
    mw_3E__3E_();
    mwdup();
    { value_t d1 = pop_value();
    push_i64(15LL);
    mw_26_();
    mwhexdigit();
      push_value(d1); }
    push_i64(4LL);
    mw_3E__3E_();
    { value_t d1 = pop_value();
    mwswap();
    { value_t d2 = pop_value();
    mwsnoc();
      push_value(d2); }
    mwsnoc();
      push_value(d1); }
}

static void mwhexdigit (void){
    mwdup();
    push_i64(10LL);
    mw_3E__3D_();
    if (pop_u64()) {
    push_i64(55LL);
    mw_2B_();
    mwInt__3E_Char();
    } else {
    push_i64(48LL);
    mw_2B_();
    mwInt__3E_Char();
    }
}

static void mwchar_hexdigits_first (void){
    { value_t d1 = pop_value();
    mwL0();
      push_value(d1); }
    mwchar_hexdigits_next();
}

static void mwunderscore (void){
    push_i64(95LL);
    mwInt__3E_Char();
}

static void mwis_alpha_3F_ (void){
    mwdup();
    mwChar__3E_Int();
    push_i64(4294967263LL);
    mw_26_();
    push_i64(65LL);
    push_i64(90LL);
    mwin_range();
}

static value_t* fieldptr_name_mangle_cached (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwname_mangle_cached_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_name_mangle_cached(index);
    incref(v); push_value(v);
}
static void mwname_mangle_cached_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_name_mangle_cached(index);
    incref(v); push_value(v);
}
static void mwname_mangle_cached_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_name_mangle_cached(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_field_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwfield_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_name(index);
    incref(v); push_value(v);
}
static void mwfield_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_field_name(index);
    incref(v); push_value(v);
}
static void mwfield_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_field_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mw_2E_ (void){
    mwdup();
    mwStr__3E_Ptr();
    mwswap();
    mwstr_size();
    mwdup();
    mwcodegen_length_40_();
    mw_2B_();
    mwCODEGEN_BUF_SIZE();
    mw_3E_();
    if (pop_u64()) {
    mwcodegen_flush_21_();
    while(1) {
    mwdup();
    mwCODEGEN_BUF_SIZE();
    mw_3E_();
    if (!pop_u64()) break;
    mwover();
    mwCODEGEN_BUF_SIZE();
    mwCODEGEN_BUF();
    mwprim_2E_ptr_2E_copy();
    mwCODEGEN_BUF_SIZE();
    mwcodegen_length_21_();
    mwcodegen_flush_21_();
    { value_t d3 = pop_value();
    mwCODEGEN_BUF_SIZE();
    mwswap();
    mwptr_2B_();
      push_value(d3); }
    mwCODEGEN_BUF_SIZE();
    mw_();
    }
    mwdup();
    mwcodegen_length_21_();
    mwCODEGEN_BUF();
    mwprim_2E_ptr_2E_copy();
    } else {
    mwdup();
    { value_t d2 = pop_value();
    mwcodegen_length_40_();
    mwCODEGEN_BUF();
    mwptr_2B_();
    mwprim_2E_ptr_2E_copy();
      push_value(d2); }
    mwcodegen_length_40_();
    mw_2B_();
    mwcodegen_length_21_();
    }
}

static value_t* fieldptr_c99_field_emitted (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwc99_field_emitted_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_field_emitted(index);
    incref(v); push_value(v);
}
static void mwc99_field_emitted_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_field_emitted(index);
    incref(v); push_value(v);
}
static void mwc99_field_emitted_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_c99_field_emitted(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_c99_field_needed (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwc99_field_needed_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_field_needed(index);
    incref(v); push_value(v);
}
static void mwc99_field_needed_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_field_needed(index);
    incref(v); push_value(v);
}
static void mwc99_field_needed_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_c99_field_needed(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwc99_emit_block_def_21_ (void){
    mwblock_needed_3F_();
    if (pop_u64()) {
    mwc99_block_emitted_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwtrue();
    mwover();
    mwc99_block_emitted_21_();
    push_ptr("static void \0\0\0");
    mw_2E_();
    mwdup();
    mw_2E_block();
    push_ptr(" (void) {\0\0\0");
    mw_3B_();
    mwblock_arrow_40_();
    mwarrow_ctx_3F_();
    mwc99_unpack_ctx_21_();
    mwdup();
    mwc99_emit_arrow_21_();
    mwarrow_ctx_40_();
    mwc99_decref_ctx_21_();
    push_ptr("}\0\0\0");
    mw_3B_();
    }
    } else {
    mwdrop();
    }
}

static void mwc99_decref_ctx_21_ (void){
    mwctx_physical_vars();
    push_u64(0);
    push_fnptr(&mb_c99_decref_ctx_21__1);
    do_pack_cons();
    mwreverse_for();
}

static void mb_c99_decref_ctx_21__1 (void) {
    do_drop();
    push_ptr("    decref(\0\0\0");
    mw_2E_();
    mw_2E_var_val();
    push_ptr(");\0\0\0");
    mw_3B_();
}
static void mw_2E_var_val (void){
    push_ptr("var_\0\0\0");
    mw_2E_();
    mwvar_name_3F_();
    mw_2E_name();
    push_ptr("_\0\0\0");
    mw_2E_();
    mwVar_2E_id();
    mw_2E_n();
}

static void mw_2E_n (void){
    mwint_show();
    mw_2E_();
}

static void mwint_show (void){
    push_u64(0);
    push_fnptr(&mb_int_show_1);
    do_pack_cons();
    mwbuild_str_21_();
}

static void mb_int_show_1 (void) {
    do_drop();
    mwstr_buf_int_21_();
}
static void mwVar_2E_id (void){
    mwprim_2E_unsafe_2E_cast();
}

static void mwctx_physical_vars (void){
    mwctx_vars();
    push_u64(0);
    push_fnptr(&mb_ctx_physical_vars_1);
    do_pack_cons();
    mwfilter();
}

static void mb_ctx_physical_vars_1 (void) {
    do_drop();
    mwvar_is_physical_3F_();
}
static void mwvar_is_physical_3F_ (void){
    mwtrue();
    { value_t d1 = pop_value();
    mwvar_type_3F_();
    mwPRIM_TYPE_TYPE();
    mwTPrim();
    mw_3C__3E_();
      push_value(d1); }
    mw_26__26_();
    { value_t d1 = pop_value();
    mwvar_type_3F_();
    mwPRIM_TYPE_STACK();
    mwTPrim();
    mw_3C__3E_();
      push_value(d1); }
    mw_26__26_();
    { value_t d1 = pop_value();
    mwvar_type_3F_();
    mwPRIM_TYPE_EFFECT();
    mwTPrim();
    mw_3C__3E_();
      push_value(d1); }
    mw_26__26_();
}

static void mwfilter (void){
    {
    value_t var_f_330 = pop_value();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwL0();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_value(var_f_330);
    incref(var_f_330);
    mwfilter_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    decref(var_f_330);
    }
}

static void mwfilter_2B_ (void){
    {
    value_t var_f_333 = pop_value();
    switch (get_top_data_tag()) {
    case 3LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    do_pack_uncons(); do_swap();
    mwdrop();
    { value_t d3 = pop_value();
    push_value(var_f_333);
    incref(var_f_333);
    mwfilter_2B_();
      push_value(d3); }
    push_u64(0);
    push_value(var_f_333);
    incref(var_f_333);
    do_pack_cons();
    push_fnptr(&mb_filter_2B__5);
    do_pack_cons();
    mwdip_27_();
    mwcat();
    break;
    default:
    mwuncons();
    { value_t d3 = pop_value();
    push_value(var_f_333);
    incref(var_f_333);
    do_run();
      push_value(d3); }
    mwswap();
    if (pop_u64()) {
    push_u64(0);
    push_value(var_f_333);
    incref(var_f_333);
    do_pack_cons();
    push_fnptr(&mb_filter_2B__12);
    do_pack_cons();
    mwdip_27_();
    mwcons();
    } else {
    mwnip();
    push_value(var_f_333);
    incref(var_f_333);
    mwfilter();
    }
    break;
    }
    decref(var_f_333);
    }
}

static void mb_filter_2B__12 (void) {
    do_pack_uncons();
    value_t var_f_333 = pop_value();
    do_drop();
    push_value(var_f_333);
    incref(var_f_333);
    mwfilter();
    decref(var_f_333);
}
static void mwcat (void){
    mwswap();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwid();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwList_2B___3E_List();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwcat_2B_();
    mwList_2B___3E_List();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mb_filter_2B__5 (void) {
    do_pack_uncons();
    value_t var_f_333 = pop_value();
    do_drop();
    push_value(var_f_333);
    incref(var_f_333);
    mwfilter_2B_();
    decref(var_f_333);
}
static void mwdip_27_ (void){
    {
    value_t var_f_120 = pop_value();
    mwswap();
    { value_t d2 = pop_value();
    push_value(var_f_120);
    incref(var_f_120);
    do_run();
      push_value(d2); }
    mwswap();
    decref(var_f_120);
    }
}

static void mwctx_vars (void){
    mwunCTX();
}

static void mwc99_emit_arrow_21_ (void){
    mwc99_depth_2B__2B_();
    mwarrow_atoms_40_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_arrow_21__1);
    do_pack_cons();
    mwfor();
    mwc99_depth__();
}

static void mwc99_depth__ (void){
    mwc99_depth_40_();
    mw1_();
    mwc99_depth_21_();
}

static void mwc99_depth_21_ (void){
    mwC99_DEPTH();
    mwint_21_();
}

static void mwc99_depth_40_ (void){
    mwC99_DEPTH();
    mwint_40_();
}

static void mb_c99_emit_arrow_21__1 (void) {
    do_drop();
    mwc99_emit_atom_21_();
}
static void mwc99_emit_atom_21_ (void){
    mwatom_op_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    break;
    case 6LL:
    do_pack_uncons(); do_drop();
    mwnip();
    push_ptr("    push_i64(\0\0\0");
    mw_2E_();
    mw_2E_n();
    push_ptr("LL);\0\0\0");
    mw_3B_();
    break;
    case 7LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwc99_emit_string_21_();
    break;
    case 2LL:
    do_pack_uncons(); do_drop();
    mwneed_word_21_();
    { value_t d2 = pop_value();
    mwatom_args_40_();
    mwc99_emit_args_push_21_();
      push_value(d2); }
    push_ptr("    mw\0\0\0");
    mw_2E_();
    mwword_name_40_();
    mw_2E_name();
    push_ptr("();\0\0\0");
    mw_3B_();
    break;
    case 3LL:
    do_pack_uncons(); do_drop();
    mwneed_fieldword_21_();
    mwnip();
    mwfieldword_name_40_();
    push_ptr("    mw\0\0\0");
    mw_2E_();
    mw_2E_name();
    push_ptr("();\0\0\0");
    mw_3B_();
    break;
    case 4LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwatom_args_40_();
    mwc99_emit_args_push_21_();
      push_value(d2); }
    push_ptr("    mw\0\0\0");
    mw_2E_();
    mwexternal_name_40_();
    mw_2E_name();
    push_ptr("();\0\0\0");
    mw_3B_();
    break;
    case 5LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwbuffer_name_40_();
    push_ptr("    mw\0\0\0");
    mw_2E_();
    mw_2E_name();
    push_ptr("();\0\0\0");
    mw_3B_();
    break;
    case 8LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwtag_name_40_();
    push_ptr("    mw\0\0\0");
    mw_2E_();
    mw_2E_name();
    push_ptr("();\0\0\0");
    mw_3B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    { value_t d2 = pop_value();
    mwatom_args_40_();
      push_value(d2); }
    mwc99_emit_prim_21_();
    break;
    case 9LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwc99_emit_match_21_();
    break;
    case 10LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwc99_emit_lambda_21_();
    break;
    case 11LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwc99_emit_var_21_();
    break;
    case 12LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwc99_emit_block_push_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwc99_emit_block_push_21_ (void){
    mwneed_block_21_();
    mwblock_arrow_3F_();
    mwarrow_ctx_40_();
    mwc99_pack_ctx_21_();
    push_ptr("    push_fnptr(&\0\0\0");
    mw_2E_();
    mw_2E_block();
    push_ptr(");\0\0\0");
    mw_3B_();
    push_ptr("    do_pack_cons();\0\0\0");
    mw_3B_();
}

static void mwc99_pack_ctx_21_ (void){
    push_ptr("    push_u64(0);\0\0\0");
    mw_3B_();
    mwctx_physical_vars();
    push_u64(0);
    push_fnptr(&mb_c99_pack_ctx_21__1);
    do_pack_cons();
    mwfor();
}

static void mb_c99_pack_ctx_21__1 (void) {
    do_drop();
    mwc99_emit_var_push_21_();
    push_ptr("    do_pack_cons();\0\0\0");
    mw_3B_();
}
static void mwc99_emit_var_push_21_ (void){
    push_ptr("    push_value(\0\0\0");
    mw_2E_();
    mwdup();
    mw_2E_var_val();
    push_ptr(");\0\0\0");
    mw_3B_();
    push_ptr("    incref(\0\0\0");
    mw_2E_();
    mw_2E_var_val();
    push_ptr(");\0\0\0");
    mw_3B_();
}

static void mwneed_block_21_ (void){
    mwblock_needed_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwtrue();
    mwover();
    mwblock_needed_21_();
    mwdup();
    mwNEED_BLOCK();
    mwneed_push_21_();
    }
}

static void mwneed_push_21_ (void){
    mwC99_NEED_STACK();
    mwvalue_40_();
    mwcons();
    mwC99_NEED_STACK();
    mwvalue_21_();
}

static void mwc99_emit_var_21_ (void){
    mwvar_auto_run_3F_();
    { value_t d1 = pop_value();
    mwc99_emit_var_push_21_();
      push_value(d1); }
    if (pop_u64()) {
    push_ptr("    do_run();\0\0\0");
    mw_3B_();
    } else {
    mwid();
    }
}

static void mwc99_emit_lambda_21_ (void){
    push_ptr("    {\0\0\0");
    mw_3B_();
    mwlambda_params_3F_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_lambda_21__1);
    do_pack_cons();
    mwreverse_for();
    mwlambda_body_3F_();
    mwc99_emit_arrow_21_();
    mwlambda_params_40_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_lambda_21__2);
    do_pack_cons();
    mwreverse_for();
    push_ptr("    }\0\0\0");
    mw_3B_();
}

static void mb_c99_emit_lambda_21__2 (void) {
    do_drop();
    push_ptr("    decref(\0\0\0");
    mw_2E_();
    mwParam__3E_Var();
    mw_2E_var_val();
    push_ptr(");\0\0\0");
    mw_3B_();
}
static void mwParam__3E_Var (void){
    mwid();
}

static void mb_c99_emit_lambda_21__1 (void) {
    do_drop();
    push_ptr("    value_t \0\0\0");
    mw_2E_();
    mwParam__3E_Var();
    mw_2E_var_val();
    push_ptr(" = pop_value();\0\0\0");
    mw_3B_();
}
static void mwc99_emit_match_21_ (void){
    mwmatch_is_transparent_3F_();
    if (pop_u64()) {
    mwmatch_cases_3F_();
    mwfirst();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwmatch_token_40_();
    push_ptr("codegen: unexpected number of cases in transparent match\0\0\0");
    mwemit_fatal_error_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwcase_body_40_();
    mwc99_emit_arrow_21_();
    mwdrop();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    } else {
    push_ptr("    switch (get_top_data_tag()) {\0\0\0");
    mw_3B_();
    mwmatch_cases_3F_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_match_21__2);
    do_pack_cons();
    mwfor();
    mwmatch_has_default_case_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("    default: write(2, \"unexpected fallthrough in match\\n\", 32); do_debug(); exit(99);\0\0\0");
    mw_3B_();
    }
    mwdrop();
    push_ptr("    }\0\0\0");
    mw_3B_();
    }
}

static void mb_c99_emit_match_21__2 (void) {
    do_drop();
    mwc99_emit_case_21_();
}
static void mwc99_emit_case_21_ (void){
    mwcase_pattern_3F_();
    mwc99_emit_pattern_21_();
    mwcase_body_40_();
    mwc99_emit_arrow_21_();
    push_ptr("    break;\0\0\0");
    mw_3B_();
}

static void mwc99_emit_pattern_21_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_ptr("    default:\0\0\0");
    mw_3B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    push_ptr("    case \0\0\0");
    mw_2E_();
    mwtag_value_3F_();
    mw_2E_n();
    push_ptr("LL:\0\0\0");
    mw_3B_();
    mwtag_num_inputs_3F_();
    mwnip();
    mwdup();
    push_i64(0LL);
    mw_3E_();
    if (pop_u64()) {
    push_ptr("    do_pack_uncons(); do_drop();\0\0\0");
    mw_3B_();
    while(1) {
    mwdup();
    push_i64(1LL);
    mw_3E_();
    if (!pop_u64()) break;
    push_ptr("    do_pack_uncons(); do_swap();\0\0\0");
    mw_3B_();
    mw1_();
    }
    mwdrop();
    } else {
    mwdrop();
    push_ptr("    do_drop();\0\0\0");
    mw_3B_();
    }
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwfirst (void){
    mwList__3E_List_2B_();
    push_u64(0);
    push_fnptr(&mb_first_1);
    do_pack_cons();
    mwmaybe_map();
}

static void mb_first_1 (void) {
    do_drop();
    mwfirst_2B_();
}
static void mwmatch_is_transparent_3F_ (void){
    mwmatch_scrutinee_data_3F_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwdata_is_transparent();
    break;
    case 0LL:
    do_drop();
    mwfalse();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwdata_is_transparent (void){
    mwdata_tags_40_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    mwtag_num_inputs_3F_();
    push_i64(1LL);
    mw_3D__3D_();
    mwnip();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwc99_emit_prim_21_ (void){
    switch (get_top_data_tag()) {
    case 4LL:
    do_drop();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    push_ptr("    { value_t d\0\0\0");
    mw_2E_();
    mw_2E_d();
    push_ptr(" = pop_value();\0\0\0");
    mw_3B_();
    mwc99_emit_arg_run_21_();
    push_ptr("      push_value(d\0\0\0");
    mw_2E_();
    mw_2E_d();
    push_ptr("); }\0\0\0");
    mw_3B_();
    break;
    default:
    mwPRIM_CORE_DIP();
    mwc99_emit_prim_default_21_();
    break;
    }
    break;
    case 5LL:
    do_drop();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    push_ptr("    if (pop_u64()) {\0\0\0");
    mw_3B_();
    { value_t d3 = pop_value();
    mwc99_emit_arg_run_21_();
      push_value(d3); }
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    mwc99_emit_arg_run_21_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    break;
    default:
    mwPRIM_CORE_IF();
    mwc99_emit_prim_default_21_();
    break;
    }
    break;
    case 6LL:
    do_drop();
    switch (get_top_data_tag()) {
    case 2LL:
    do_pack_uncons(); do_drop();
    do_pack_uncons(); do_swap();
    push_ptr("    while(1) {\0\0\0");
    mw_3B_();
    { value_t d3 = pop_value();
    mwc99_emit_arg_run_21_();
      push_value(d3); }
    push_ptr("    if (!pop_u64()) break;\0\0\0");
    mw_3B_();
    mwc99_emit_arg_run_21_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    break;
    default:
    mwPRIM_CORE_WHILE();
    mwc99_emit_prim_default_21_();
    break;
    }
    break;
    default:
    mwc99_emit_prim_default_21_();
    break;
    }
}

static void mwc99_emit_prim_default_21_ (void){
    { value_t d1 = pop_value();
    mwc99_emit_args_push_21_();
      push_value(d1); }
    push_ptr("    mw\0\0\0");
    mw_2E_();
    mwprim_name_40_();
    mw_2E_name();
    push_ptr("();\0\0\0");
    mw_3B_();
}

static value_t* fieldptr_prim_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwprim_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_name(index);
    incref(v); push_value(v);
}
static void mwprim_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_prim_name(index);
    incref(v); push_value(v);
}
static void mwprim_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_prim_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwc99_emit_arg_run_21_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwblock_arrow_40_();
    mwc99_emit_arrow_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_var_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mw_2E_d (void){
    mwc99_depth_40_();
    mw_2E_n();
}

static value_t* fieldptr_buffer_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwbuffer_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_buffer_name(index);
    incref(v); push_value(v);
}
static void mwbuffer_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_buffer_name(index);
    incref(v); push_value(v);
}
static void mwbuffer_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_buffer_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_external_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwexternal_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_name(index);
    incref(v); push_value(v);
}
static void mwexternal_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_external_name(index);
    incref(v); push_value(v);
}
static void mwexternal_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_external_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwfieldword_name_40_ (void){
    mwunFIELDWORD();
    { value_t d1 = pop_value();
    mwfield_name_40_();
      push_value(d1); }
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_ptr("@\0\0\0");
    break;
    case 1LL:
    do_drop();
    push_ptr("?\0\0\0");
    break;
    case 2LL:
    do_drop();
    push_ptr("!\0\0\0");
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    mwname_cat_21_();
}

static void mwneed_fieldword_21_ (void){
    mwdup();
    mwunFIELDWORD();
    mwdrop();
    mwneed_field_21_();
    mwdrop();
}

static void mwneed_field_21_ (void){
    mwc99_field_needed_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwtrue();
    mwover();
    mwc99_field_needed_21_();
    mwdup();
    mwNEED_FIELD();
    mwneed_push_21_();
    }
}

static value_t* fieldptr_word_name (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwword_name_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_name(index);
    incref(v); push_value(v);
}
static void mwword_name_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_name(index);
    incref(v); push_value(v);
}
static void mwword_name_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_word_name(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwc99_emit_args_push_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_args_push_21__1);
    do_pack_cons();
    mwreverse_for();
}

static void mb_c99_emit_args_push_21__1 (void) {
    do_drop();
    mwc99_emit_arg_push_21_();
}
static void mwc99_emit_arg_push_21_ (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_block_push_21_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwc99_emit_var_push_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwneed_word_21_ (void){
    mwc99_word_needed_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwtrue();
    mwover();
    mwc99_word_needed_21_();
    mwdup();
    mwNEED_WORD();
    mwneed_push_21_();
    }
}

static value_t* fieldptr_c99_word_needed (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwc99_word_needed_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_word_needed(index);
    incref(v); push_value(v);
}
static void mwc99_word_needed_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_word_needed(index);
    incref(v); push_value(v);
}
static void mwc99_word_needed_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_c99_word_needed(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwc99_emit_string_21_ (void){
    push_ptr("    push_ptr(\"\0\0\0");
    mw_2E_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_string_21__1);
    do_pack_cons();
    mwstr_for();
    push_ptr("\\0\\0\\0\");\0\0\0");
    mw_3B_();
}

static void mb_c99_emit_string_21__1 (void) {
    do_drop();
    mwc99_emit_string_char_21_();
}
static void mwc99_emit_string_char_21_ (void){
    mwis_backslash_3F_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("\\\\\0\0\0");
    mw_2E_();
    } else {
    mwis_quote_3F_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("\\\"\0\0\0");
    mw_2E_();
    } else {
    mwdup();
    mwChar__3E_Int();
    push_i64(32LL);
    push_i64(127LL);
    mwin_range();
    if (pop_u64()) {
    mw_2E_c();
    } else {
    mwdup();
    mwChar__3E_Int();
    push_i64(9LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("\\t\0\0\0");
    mw_2E_();
    } else {
    mwdup();
    mwChar__3E_Int();
    push_i64(10LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("\\n\0\0\0");
    mw_2E_();
    } else {
    mwdup();
    mwChar__3E_Int();
    push_i64(13LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    push_ptr("\\r\0\0\0");
    mw_2E_();
    } else {
    mwchar_bytes();
    push_u64(0);
    push_fnptr(&mb_c99_emit_string_char_21__7);
    do_pack_cons();
    mwfor();
    }
    }
    }
    }
    }
    }
}

static void mb_c99_emit_string_char_21__7 (void) {
    do_drop();
    push_ptr("\\x\0\0\0");
    mw_2E_();
    mwdup();
    mwU8__3E_Int();
    push_i64(4LL);
    mw_3E__3E_();
    mwhexdigit();
    mw_2E_c();
    mwU8__3E_Int();
    push_i64(15LL);
    mw_26_();
    mwhexdigit();
    mw_2E_c();
}
static void mwchar_bytes (void){
    mwchar_width_3F_();
    mwdup();
    push_i64(1LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwChar__3E_Int();
    mwInt__3E_U8();
    mwL1();
    } else {
    mwdup();
    push_i64(2LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwdrop();
    mwChar__3E_Int();
    mwdup();
    push_i64(8LL);
    mw_3E__3E_();
    mwInt__3E_U8();
    { value_t d3 = pop_value();
    push_i64(255LL);
    mw_26_();
    mwInt__3E_U8();
      push_value(d3); }
    mwL2();
    } else {
    push_i64(3LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwChar__3E_Int();
    mwdup();
    push_i64(16LL);
    mw_3E__3E_();
    mwInt__3E_U8();
    { value_t d4 = pop_value();
    mwdup();
    push_i64(8LL);
    mw_3E__3E_();
    push_i64(255LL);
    mw_26_();
    mwInt__3E_U8();
    { value_t d5 = pop_value();
    push_i64(255LL);
    mw_26_();
    mwInt__3E_U8();
      push_value(d5); }
      push_value(d4); }
    mwL3();
    } else {
    mwChar__3E_Int();
    mwdup();
    push_i64(24LL);
    mw_3E__3E_();
    mwInt__3E_U8();
    { value_t d4 = pop_value();
    mwdup();
    push_i64(16LL);
    mw_3E__3E_();
    push_i64(255LL);
    mw_26_();
    mwInt__3E_U8();
    { value_t d5 = pop_value();
    mwdup();
    push_i64(8LL);
    mw_3E__3E_();
    push_i64(255LL);
    mw_26_();
    mwInt__3E_U8();
    { value_t d6 = pop_value();
    push_i64(255LL);
    mw_26_();
    mwInt__3E_U8();
      push_value(d6); }
      push_value(d5); }
      push_value(d4); }
    mwL4();
    }
    }
    }
}

static void mwL4 (void){
    mwL4_2B_();
    mwList_2B___3E_List();
}

static void mw_2E_c (void){
    mwcodegen_full_3F_();
    if (pop_u64()) {
    mwcodegen_flush_21_();
    } else {
    mwid();
    }
    mwdup();
    mwcodegen_length_40_();
    mwCODEGEN_BUF();
    mwptr_2B_();
    mwchar_21_();
    mwchar_width();
    mwcodegen_length_40_();
    mw_2B_();
    mwcodegen_length_21_();
}

static void mwstr_for (void){
    {
    value_t var_f_239 = pop_value();
    while(1) {
    mwstr_is_empty_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwdup();
    mwstr_tail();
    { value_t d3 = pop_value();
    mwstr_head();
    push_value(var_f_239);
    incref(var_f_239);
    do_run();
      push_value(d3); }
    }
    mwdrop();
    decref(var_f_239);
    }
}

static void mwc99_depth_2B__2B_ (void){
    mwc99_depth_40_();
    mw1_2B_();
    mwc99_depth_21_();
}

static void mwc99_unpack_ctx_21_ (void){
    mwctx_physical_vars();
    push_u64(0);
    push_fnptr(&mb_c99_unpack_ctx_21__1);
    do_pack_cons();
    mwreverse_for();
    push_ptr("    do_drop();\0\0\0");
    mw_3B_();
}

static void mb_c99_unpack_ctx_21__1 (void) {
    do_drop();
    push_ptr("    do_pack_uncons();\0\0\0");
    mw_3B_();
    push_ptr("    value_t \0\0\0");
    mw_2E_();
    mw_2E_var_val();
    push_ptr(" = pop_value();\0\0\0");
    mw_3B_();
}
static void mw_2E_block (void){
    push_ptr("mb_\0\0\0");
    mw_2E_();
    mwblock_arrow_3F_();
    mwarrow_home_3F_();
    mwis_nil_3F_();
    if (pop_u64()) {
    mwdrop2();
    mwBlock_2E_id();
    mw_2E_n();
    } else {
    mwword_name_40_();
    mw_2E_name();
    push_ptr("_\0\0\0");
    mw_2E_();
    mwarrow_homeidx_40_();
    mw_2E_n();
    mwdrop();
    }
}

static void mwBlock_2E_id (void){
    mwprim_2E_unsafe_2E_cast();
}

static value_t* fieldptr_c99_block_emitted (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwc99_block_emitted_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_block_emitted(index);
    incref(v); push_value(v);
}
static void mwc99_block_emitted_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_block_emitted(index);
    incref(v); push_value(v);
}
static void mwc99_block_emitted_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_c99_block_emitted(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static value_t* fieldptr_block_needed (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwblock_needed_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_needed(index);
    incref(v); push_value(v);
}
static void mwblock_needed_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_block_needed(index);
    incref(v); push_value(v);
}
static void mwblock_needed_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_block_needed(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwc99_emit_word_def_21_ (void){
    mwc99_word_needed_3F_();
    if (pop_u64()) {
    mwc99_word_emitted_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwtrue();
    mwover();
    mwc99_word_emitted_21_();
    mwword_name_3F_();
    mw_2E_w();
    push_ptr("{\0\0\0");
    mw_3B_();
    mwword_arrow_40_();
    mwforce();
    mwc99_emit_arrow_21_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    }
    } else {
    mwdrop();
    }
}

static value_t* fieldptr_c99_word_emitted (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwc99_word_emitted_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_word_emitted(index);
    incref(v); push_value(v);
}
static void mwc99_word_emitted_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_c99_word_emitted(index);
    incref(v); push_value(v);
}
static void mwc99_word_emitted_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_c99_word_emitted(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwneed_pop_21_ (void){
    mwC99_NEED_STACK();
    mwvalue_40_();
    mwList__3E_List_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwNONE();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwuncons();
    mwC99_NEED_STACK();
    mwvalue_21_();
    mwSOME();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwhas_need_3F_ (void){
    mwC99_NEED_STACK();
    mwvalue_40_();
    mwis_nil();
    mwnot();
}

static void mwc99_emit_main_21_ (void){
    push_ptr("int main (int argc, char** argv) {\0\0\0");
    mw_3B_();
    push_ptr("    global_argc = argc;\0\0\0");
    mw_3B_();
    push_ptr("    global_argv = argv;\0\0\0");
    mw_3B_();
    mwc99_emit_arrow_21_();
    push_ptr("    return 0;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
}

static void mwc99_emit_field_sigs_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_field_sigs_21__1);
    do_pack_cons();
    mwField_2E_for();
    mw_2E_lf();
}

static void mb_c99_emit_field_sigs_21__1 (void) {
    do_drop();
    mwc99_emit_field_sig_21_();
}
static void mwc99_emit_field_sig_21_ (void){
    mwfalse();
    mwover();
    mwc99_field_needed_21_();
    mwfalse();
    mwover();
    mwc99_field_emitted_21_();
    push_ptr(" static void mw\0\0\0");
    mw_2E_();
    mwfield_name_3F_();
    push_ptr("@\0\0\0");
    mwname_cat_21_();
    mw_2E_name();
    push_ptr(" (void);\0\0\0");
    mw_3B_();
    push_ptr(" static void mw\0\0\0");
    mw_2E_();
    mwfield_name_3F_();
    push_ptr("?\0\0\0");
    mwname_cat_21_();
    mw_2E_name();
    push_ptr(" (void);\0\0\0");
    mw_3B_();
    push_ptr(" static void mw\0\0\0");
    mw_2E_();
    mwfield_name_40_();
    push_ptr("!\0\0\0");
    mwname_cat_21_();
    mw_2E_name();
    push_ptr(" (void);\0\0\0");
    mw_3B_();
}

static void mwField_2E_for (void){
    {
    value_t var_x_57 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwField_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_57);
    incref(var_x_57);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_57);
    }
}

static void mwc99_emit_block_sigs_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_block_sigs_21__1);
    do_pack_cons();
    mwBlock_2E_for();
    mw_2E_lf();
}

static void mb_c99_emit_block_sigs_21__1 (void) {
    do_drop();
    mwc99_emit_block_sig_21_();
}
static void mwc99_emit_block_sig_21_ (void){
    mwfalse();
    mwover();
    mwblock_needed_21_();
    mwfalse();
    mwover();
    mwc99_block_emitted_21_();
    push_ptr(" static void \0\0\0");
    mw_2E_();
    mw_2E_block();
    push_ptr(" (void);\0\0\0");
    mw_3B_();
}

static void mwBlock_2E_for (void){
    {
    value_t var_x_45 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwBlock_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_45);
    incref(var_x_45);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_45);
    }
}

static void mwc99_emit_word_sigs_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_word_sigs_21__1);
    do_pack_cons();
    mwWord_2E_for();
    mw_2E_lf();
}

static void mb_c99_emit_word_sigs_21__1 (void) {
    do_drop();
    mwc99_emit_word_sig_21_();
}
static void mwc99_emit_word_sig_21_ (void){
    mwfalse();
    mwover();
    mwc99_word_needed_21_();
    mwfalse();
    mwover();
    mwc99_word_emitted_21_();
    push_ptr(" static void mw\0\0\0");
    mw_2E_();
    mwword_name_40_();
    mw_2E_name();
    push_ptr(" (void);\0\0\0");
    mw_3B_();
}

static void mwWord_2E_for (void){
    {
    value_t var_x_53 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwWord_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_53);
    incref(var_x_53);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_53);
    }
}

static void mwc99_emit_externals_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_externals_21__1);
    do_pack_cons();
    mwExternal_2E_for();
    mw_2E_lf();
}

static void mb_c99_emit_externals_21__1 (void) {
    do_drop();
    mwc99_emit_external_21_();
}
static void mwc99_emit_external_21_ (void){
    mwexternal_sig_3F_();
    mwsig_arity();
    mwdup();
    push_i64(2LL);
    mw_3E__3D_();
    if (pop_u64()) {
    push_ptr("can't declare external with multiple return values\0\0\0");
    mwpanic_21_();
    } else {
    mwdup();
    push_i64(1LL);
    mw_3E__3D_();
    if (pop_u64()) {
    push_ptr("i64 \0\0\0");
    mw_2E_();
    } else {
    push_ptr("void \0\0\0");
    mw_2E_();
    }
    }
    push_u64(0);
    push_fnptr(&mb_c99_emit_external_21__5);
    do_pack_cons();
    mwdip2();
    push_ptr(" (\0\0\0");
    mw_2E_();
    mwover();
    mwdup();
    mw0_3E_();
    if (pop_u64()) {
    push_ptr("i64\0\0\0");
    mw_2E_();
    mw1_();
    while(1) {
    mwdup();
    mw0_3E_();
    if (!pop_u64()) break;
    push_ptr(", i64\0\0\0");
    mw_2E_();
    mw1_();
    }
    mwdrop();
    } else {
    mwdrop();
    push_ptr("void\0\0\0");
    mw_2E_();
    }
    push_ptr(");\0\0\0");
    mw_3B_();
    push_ptr("static void mw\0\0\0");
    mw_2E_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_external_21__10);
    do_pack_cons();
    mwdip2();
    push_ptr(" (void) {\0\0\0");
    mw_3B_();
    mwover();
    while(1) {
    mwdup();
    mw0_3E_();
    if (!pop_u64()) break;
    push_ptr("    i64 x\0\0\0");
    mw_2E_();
    mwdup();
    mw_2E_n();
    push_ptr(" = pop_i64();\0\0\0");
    mw_3B_();
    mw1_();
    }
    mwdrop();
    mwdup();
    mw0_3E_();
    if (pop_u64()) {
    push_ptr("    push_i64(\0\0\0");
    } else {
    push_ptr("    \0\0\0");
    }
    mw_2E_();
    push_u64(0);
    push_fnptr(&mb_c99_emit_external_21__15);
    do_pack_cons();
    mwdip2();
    push_ptr("(\0\0\0");
    mw_2E_();
    { value_t d1 = pop_value();
    mwdup();
    mw0_3E_();
    if (pop_u64()) {
    push_ptr("x1\0\0\0");
    mw_2E_();
    mwdup();
    mw1_();
    while(1) {
    mwdup();
    mw0_3E_();
    if (!pop_u64()) break;
    push_ptr(", x\0\0\0");
    mw_2E_();
    mwdup2();
    mw_();
    mw1_2B_();
    mw_2E_n();
    mw1_();
    }
    mwdrop();
    } else {
    mwid();
    }
      push_value(d1); }
    push_ptr(")\0\0\0");
    mw_2E_();
    mwdup();
    mw0_3E_();
    if (pop_u64()) {
    push_ptr(");\0\0\0");
    } else {
    push_ptr(" ;\0\0\0");
    }
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
    mwdrop3();
}

static void mb_c99_emit_external_21__15 (void) {
    do_drop();
    mwexternal_name_3F_();
    mw_2E_name();
}
static void mb_c99_emit_external_21__10 (void) {
    do_drop();
    mwexternal_name_3F_();
    mw_2E_name();
}
static void mb_c99_emit_external_21__5 (void) {
    do_drop();
    mwexternal_name_3F_();
    mw_2E_name();
}
static void mwsig_arity (void){
    mwsig_has_dashes_3F_();
    if (pop_u64()) {
    mwsig_count_types();
    mwtoken_next();
    mwsig_count_types();
    mwdrop();
    } else {
    mwsig_count_types();
    mwdrop();
    push_i64(0LL);
    mwswap();
    }
}

static void mwsig_count_types (void){
    push_i64(0LL);
    mwswap();
    while(1) {
    mwsig_is_stack_end_3F_();
    mwnot();
    if (!pop_u64()) break;
    mwsig_token_is_type_3F_();
    if (pop_u64()) {
    { value_t d3 = pop_value();
    mw1_2B_();
      push_value(d3); }
    } else {
    mwid();
    }
    mwtoken_next();
    }
}

static void mwsig_token_is_type_3F_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_could_be_type();
    break;
    default:
    mwdrop();
    mwfalse();
    break;
    }
}

static void mwname_could_be_type (void){
    mwname_str_40_();
    mwstr_head();
    mwis_alpha_3F_();
    mwnip();
}

static void mwExternal_2E_for (void){
    {
    value_t var_x_59 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwExternal_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_59);
    incref(var_x_59);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_59);
    }
}

static void mwc99_emit_buffers_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_buffers_21__1);
    do_pack_cons();
    mwBuffer_2E_for();
    mw_2E_lf();
}

static void mb_c99_emit_buffers_21__1 (void) {
    do_drop();
    mwc99_emit_buffer_21_();
}
static void mwc99_emit_buffer_21_ (void){
    push_ptr("static u8 b\0\0\0");
    mw_2E_();
    mwbuffer_name_3F_();
    mw_2E_name();
    push_ptr("[\0\0\0");
    mw_2E_();
    mwbuffer_size_3F_();
    mw_2E_n();
    push_ptr("] = {0};\0\0\0");
    mw_3B_();
    push_ptr("#define mw\0\0\0");
    mw_2E_();
    mwbuffer_name_3F_();
    mw_2E_name();
    push_ptr("() push_ptr((void*)b\0\0\0");
    mw_2E_();
    mwbuffer_name_40_();
    mw_2E_name();
    push_ptr(")\0\0\0");
    mw_3B_();
}

static value_t* fieldptr_buffer_size (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwbuffer_size_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_buffer_size(index);
    incref(v); push_value(v);
}
static void mwbuffer_size_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_buffer_size(index);
    incref(v); push_value(v);
}
static void mwbuffer_size_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_buffer_size(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwBuffer_2E_for (void){
    {
    value_t var_x_31 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwBuffer_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_31);
    incref(var_x_31);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_31);
    }
}

static void mwc99_emit_tags_21_ (void){
    push_u64(0);
    push_fnptr(&mb_c99_emit_tags_21__1);
    do_pack_cons();
    mwTag_2E_for();
    mw_2E_lf();
}

static void mb_c99_emit_tags_21__1 (void) {
    do_drop();
    mwc99_emit_tag_21_();
}
static void mwc99_emit_tag_21_ (void){
    mwtag_is_transparent_3F_();
    if (pop_u64()) {
    push_ptr("#define mw\0\0\0");
    mw_2E_();
    mwtag_name_40_();
    mw_2E_name();
    push_ptr("() 0\0\0\0");
    mw_3B_();
    } else {
    mwtag_num_inputs_3F_();
    push_i64(0LL);
    mw_3D__3D_();
    if (pop_u64()) {
    push_ptr("#define mw\0\0\0");
    mw_2E_();
    mwtag_name_3F_();
    mw_2E_name();
    push_ptr("() push_u64(\0\0\0");
    mw_2E_();
    mwtag_value_40_();
    mw_2E_n();
    push_ptr(")\0\0\0");
    mw_3B_();
    } else {
    push_ptr("static void mw\0\0\0");
    mw_2E_();
    mwtag_name_3F_();
    mw_2E_name();
    push_ptr(" (void) {\0\0\0");
    mw_3B_();
    push_ptr("    value_t car = pop_value();\0\0\0");
    mw_3B_();
    mwtag_num_inputs_3F_();
    mw1_();
    while(1) {
    mwdup();
    push_i64(0LL);
    mw_3E_();
    if (!pop_u64()) break;
    push_ptr("    car = mkcell(car, pop_value());\0\0\0");
    mw_3B_();
    mw1_();
    }
    mwdrop();
    push_ptr("    value_t tag = { .tag = VT_U64, .payload = { .vp_i64 = \0\0\0");
    mw_2E_();
    mwtag_value_40_();
    mw_2E_n();
    push_ptr("LL } };\0\0\0");
    mw_3B_();
    push_ptr("    car = mkcell(car, tag);\0\0\0");
    mw_3B_();
    push_ptr("    push_value(car);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
    }
    }
}

static void mwtag_is_transparent_3F_ (void){
    mwtag_data_3F_();
    mwdata_is_transparent();
}

static void mwTag_2E_for (void){
    {
    value_t var_x_37 = pop_value();
    push_i64(1LL);
    while(1) {
    mwprim_2E_core_2E_dup();
    mwTag_2E_NUM();
    mwprim_2E_int_2E_get();
    mwprim_2E_value_2E_le();
    if (!pop_u64()) break;
    mwprim_2E_core_2E_dup();
    { value_t d3 = pop_value();
    mwprim_2E_unsafe_2E_cast();
    push_value(var_x_37);
    incref(var_x_37);
    do_run();
      push_value(d3); }
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    }
    mwprim_2E_core_2E_drop();
    decref(var_x_37);
    }
}

static void mwc99_emit_prims_21_ (void){
    push_ptr("#define get_cell_index(v) ((usize)(((v).tag & 0x80) ? ((v).payload.vp_u64 >> (0xC0 - (u64)((v).tag))) : 0))\0\0\0");
    mw_3B__3B_();
    push_ptr("#define incref(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) heap[i].refs++; }while(0)\0\0\0");
    mw_3B__3B_();
    push_ptr("#define decref(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) { if(heap[i].refs) { heap[i].refs--; if (heap[i].refs == 0) heap_free(i); } }} while(0)\0\0\0");
    mw_3B__3B_();
    push_ptr("static void heap_free(usize i) {\0\0\0");
    mw_3B_();
    push_ptr("    cell_t *cell = heap + i;\0\0\0");
    mw_3B_();
    push_ptr("    cell_t contents = *cell;\0\0\0");
    mw_3B_();
    push_ptr("    memset(cell, 0, sizeof(cell_t));\0\0\0");
    mw_3B_();
    push_ptr("    cell->cdr.payload.vp_u64 = heap_next;\0\0\0");
    mw_3B_();
    push_ptr("    heap_next = i;\0\0\0");
    mw_3B_();
    push_ptr("    heap_count--;\0\0\0");
    mw_3B_();
    push_ptr("    if (contents.freecdr) { free(contents.cdr.payload.vp_ptr); }\0\0\0");
    mw_3B_();
    push_ptr("    else { decref(contents.cdr); }\0\0\0");
    mw_3B_();
    push_ptr("    decref(contents.car);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("#define decref_for_uncons(v) do{ value_t w = (v); usize i = get_cell_index(w); if(i) { if (heap[i].refs) { heap[i].refs--; if (heap[i].refs == 0) { memset(heap+i, 0, sizeof(cell_t)); heap[i].cdr.payload.vp_u64 = heap_next; heap_next = i; heap_count--; } else { cell_t cell = heap[i]; incref(cell.car); incref(cell.cdr); } } } } while(0)\0\0\0");
    mw_3B_();
    push_ptr("static void value_uncons(value_t val, value_t* car, value_t* cdr) {\0\0\0");
    mw_3B_();
    push_ptr("    switch (val.tag) {\0\0\0");
    mw_3B_();
    push_ptr("        case VT_U64: {\0\0\0");
    mw_3B_();
    push_ptr("            value_t nil = { 0 };\0\0\0");
    mw_3B_();
    push_ptr("            *car = nil;\0\0\0");
    mw_3B_();
    push_ptr("            *cdr = val;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_U32: {\0\0\0");
    mw_3B_();
    push_ptr("            u64 vv = val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            u64 lo = vv & 0xFFFFFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 hi = vv >> 32;\0\0\0");
    mw_3B_();
    push_ptr("            car->tag = VT_U64; car->payload.vp_u64 = hi;\0\0\0");
    mw_3B_();
    push_ptr("            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_C64: {\0\0\0");
    mw_3B_();
    push_ptr("            cell_t* cell = heap + val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            *car = cell->car;\0\0\0");
    mw_3B_();
    push_ptr("            *cdr = cell->cdr;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_C32: {\0\0\0");
    mw_3B_();
    push_ptr("            u64 vv = val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            u64 lo = vv & 0xFFFFFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 hi = vv >> 32;\0\0\0");
    mw_3B_();
    push_ptr("            car->tag = VT_C64; car->payload.vp_u64 = hi;\0\0\0");
    mw_3B_();
    push_ptr("            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_U21: {\0\0\0");
    mw_3B_();
    push_ptr("            u64 vv = val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            u64 lo = vv & 0x1FFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 md = (vv >> 21) & 0x1FFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 hi = (vv >> 42) & 0x1FFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            car->tag = VT_U32;\0\0\0");
    mw_3B_();
    push_ptr("            car->payload.vp_u64 = (hi << 32) | md;\0\0\0");
    mw_3B_();
    push_ptr("            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_C21: {\0\0\0");
    mw_3B_();
    push_ptr("            u64 vv = val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            u64 lo = vv & 0x1FFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 md = (vv >> 21) & 0x1FFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 hi = (vv >> 42) & 0x1FFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            car->tag = VT_C32;\0\0\0");
    mw_3B_();
    push_ptr("            car->payload.vp_u64 = (hi << 32) | md;\0\0\0");
    mw_3B_();
    push_ptr("            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_U16: {\0\0\0");
    mw_3B_();
    push_ptr("            u64 vv = val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            u64 lo = vv & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 y2 = (vv >> 16) & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 y1 = (vv >> 32) & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 y0 = (vv >> 48) & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            car->tag = VT_U21;\0\0\0");
    mw_3B_();
    push_ptr("            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;\0\0\0");
    mw_3B_();
    push_ptr("            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_C16: {\0\0\0");
    mw_3B_();
    push_ptr("            u64 vv = val.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            u64 lo = vv & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 y2 = (vv >> 16) & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 y1 = (vv >> 32) & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            u64 y0 = (vv >> 48) & 0xFFFF;\0\0\0");
    mw_3B_();
    push_ptr("            car->tag = VT_C21;\0\0\0");
    mw_3B_();
    push_ptr("            car->payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;\0\0\0");
    mw_3B_();
    push_ptr("            cdr->tag = VT_U64; cdr->payload.vp_u64 = lo;\0\0\0");
    mw_3B_();
    push_ptr("        } break;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static bool value_has_ptr_offset (value_t v) {\0\0\0");
    mw_3B_();
    push_ptr("    if (v.tag == VT_C64) {\0\0\0");
    mw_3B_();
    push_ptr("        usize cell_index = (usize)v.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("        struct cell_t * cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("        return !cell->freecdr;\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        return v.tag != VT_U64;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static u64 value_ptr_size (value_t v) {\0\0\0");
    mw_3B_();
    push_ptr("    if (v.payload.vp_u64 == 0) {\0\0\0");
    mw_3B_();
    push_ptr("        return 0;\0\0\0");
    mw_3B_();
    push_ptr("    } else if (v.tag == VT_U64) {\0\0\0");
    mw_3B_();
    push_ptr("        return strlen(v.payload.vp_ptr);\0\0\0");
    mw_3B_();
    push_ptr("    } else if (value_has_ptr_offset(v)) {\0\0\0");
    mw_3B_();
    push_ptr("        value_t car, cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("        value_t car2, cdr2;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(car, &car2, &cdr2);\0\0\0");
    mw_3B_();
    push_ptr("        u64 size = car2.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("        u64 offset = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("        if (size >= offset) {\0\0\0");
    mw_3B_();
    push_ptr("            return offset - size;\0\0\0");
    mw_3B_();
    push_ptr("        } else {\0\0\0");
    mw_3B_();
    push_ptr("            return 0;\0\0\0");
    mw_3B_();
    push_ptr("        }\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        value_t car, cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("        return car.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static void* value_ptr_base (value_t v) {\0\0\0");
    mw_3B_();
    push_ptr("    if (value_has_ptr_offset(v)) {\0\0\0");
    mw_3B_();
    push_ptr("        value_t car, cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("        value_t car2, cdr2;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(car, &car2, &cdr2);\0\0\0");
    mw_3B_();
    push_ptr("        return cdr2.payload.vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        value_t car, cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("        return cdr.payload.vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static i64 value_ptr_offset (value_t v) {\0\0\0");
    mw_3B_();
    push_ptr("    if (value_has_ptr_offset(v)) {\0\0\0");
    mw_3B_();
    push_ptr("        value_t car, cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("        return cdr.payload.vp_i64;\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        return 0;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static void* value_ptr (value_t v) {\0\0\0");
    mw_3B_();
    push_ptr("    usize cell_index; cell_t* cell; usize offset;\0\0\0");
    mw_3B_();
    push_ptr("    switch (v.tag) {\0\0\0");
    mw_3B_();
    push_ptr("        case VT_U64: return v.payload.vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("        case VT_C64: \0\0\0");
    mw_3B_();
    push_ptr("            cell_index = (usize)v.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("            cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("            if (cell->freecdr) {\0\0\0");
    mw_3B_();
    push_ptr("                return cell->cdr.payload.vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("            } else {\0\0\0");
    mw_3B_();
    push_ptr("                offset = (usize)cell->cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                cell_index = (usize)cell->car.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                break;\0\0\0");
    mw_3B_();
    push_ptr("            }\0\0\0");
    mw_3B_();
    push_ptr("       case VT_C32: \0\0\0");
    mw_3B_();
    push_ptr("            offset = (usize)v.payload.vp_u32;\0\0\0");
    mw_3B_();
    push_ptr("            cell_index = (usize)(v.payload.vp_u64 >> 32);\0\0\0");
    mw_3B_();
    push_ptr("            break;\0\0\0");
    mw_3B_();
    push_ptr("       default: \0\0\0");
    mw_3B_();
    push_ptr("            return (void*)0;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    if (cell->freecdr) {\0\0\0");
    mw_3B_();
    push_ptr("        char* base = cell->cdr.payload.vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("        return (void*)(base + offset);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    return (void*)0;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("#define pop_value() (stack[stack_counter++])\0\0\0");
    mw_3B_();
    push_ptr("#define pop_fnptr() (pop_value().payload.vp_fnptr)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_u8() (pop_value().payload.vp_u8)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_u16() (pop_value().payload.vp_u16)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_u32() (pop_value().payload.vp_u32)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_u64() (pop_value().payload.vp_u64)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_i8() (pop_value().payload.vp_i8)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_i16() (pop_value().payload.vp_i16)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_i32() (pop_value().payload.vp_i32)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_i64() (pop_value().payload.vp_i64)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_bool() (pop_value().payload.vp_bool)\0\0\0");
    mw_3B_();
    push_ptr("#define pop_rawptr() (pop_value().payload.vp_ptr)\0\0\0");
    mw_3B_();
    push_ptr("#define push_value(v) stack[--stack_counter] = (v)\0\0\0");
    mw_3B_();
    push_ptr("#define push_u64(v) do { stack[--stack_counter].tag = VT_U64; stack[stack_counter].payload.vp_u64 = (v); } while(0)\0\0\0");
    mw_3B_();
    push_ptr("#define push_i64(v) do { stack[--stack_counter].tag = VT_U64; stack[stack_counter].payload.vp_i64 = (v); } while(0)\0\0\0");
    mw_3B_();
    push_ptr("#define push_ptr(v) push_u64((u64)(v))\0\0\0");
    mw_3B_();
    push_ptr("#define push_fnptr(v) push_u64((u64)(v))\0\0\0");
    mw_3B_();
    push_ptr("#define push_bool(b) push_u64((u64)((bool)(b)))\0\0\0");
    mw_3B_();
    push_ptr("#define push_u8(b) push_u64((u64)(b))\0\0\0");
    mw_3B_();
    push_ptr("#define push_u16(b) push_u64((u64)(b))\0\0\0");
    mw_3B_();
    push_ptr("#define push_u32(b) push_u64((u64)(b))\0\0\0");
    mw_3B_();
    push_ptr("#define push_i8(b) push_i64((i64)(b))\0\0\0");
    mw_3B_();
    push_ptr("#define push_i16(b) push_i64((i64)(b))\0\0\0");
    mw_3B_();
    push_ptr("#define push_i32(b) push_i64((i64)(b))\0\0\0");
    mw_3B_();
    push_ptr("#define push_rawptr(v) push_u64((u64)(void*)(v))\0\0\0");
    mw_3B_();
    push_ptr("static value_t mkcell (value_t car, value_t cdr) {\0\0\0");
    mw_3B_();
    push_ptr("    if ((car.payload.vp_u64 == 0) && (cdr.tag == VT_U64))\0\0\0");
    mw_3B_();
    push_ptr("        return cdr;\0\0\0");
    mw_3B_();
    push_ptr("    if (cdr.tag == VT_U64) {\0\0\0");
    mw_3B_();
    push_ptr("        switch (car.tag) {\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U64: {\0\0\0");
    mw_3B_();
    push_ptr("                u64 x0 = car.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x1 = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y0 = x0 & 0xFFFFFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y1 = x1 & 0xFFFFFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                if ((x0 == y0) && (x1 == y1)) {\0\0\0");
    mw_3B_();
    push_ptr("                    value_t r;\0\0\0");
    mw_3B_();
    push_ptr("                    r.tag = VT_U32;\0\0\0");
    mw_3B_();
    push_ptr("                    r.payload.vp_u64 = (y0 << 32) | y1;\0\0\0");
    mw_3B_();
    push_ptr("                    return r;\0\0\0");
    mw_3B_();
    push_ptr("                }\0\0\0");
    mw_3B_();
    push_ptr("            } break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C64: {\0\0\0");
    mw_3B_();
    push_ptr("                u64 x0 = car.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x1 = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y0 = x0 & 0xFFFFFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y1 = x1 & 0xFFFFFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                if ((x0 == y0) && (x1 == y1)) {\0\0\0");
    mw_3B_();
    push_ptr("                    value_t r;\0\0\0");
    mw_3B_();
    push_ptr("                    r.tag = VT_C32;\0\0\0");
    mw_3B_();
    push_ptr("                    r.payload.vp_u64 = (y0 << 32) | y1;\0\0\0");
    mw_3B_();
    push_ptr("                    return r;\0\0\0");
    mw_3B_();
    push_ptr("                }\0\0\0");
    mw_3B_();
    push_ptr("            } break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U32: {\0\0\0");
    mw_3B_();
    push_ptr("                u64 x0 = car.payload.vp_u64 >> 32;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x2 = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y0 = x0 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y1 = x1 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y2 = x2 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {\0\0\0");
    mw_3B_();
    push_ptr("                    value_t r;\0\0\0");
    mw_3B_();
    push_ptr("                    r.tag = VT_U21;\0\0\0");
    mw_3B_();
    push_ptr("                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;\0\0\0");
    mw_3B_();
    push_ptr("                    return r;\0\0\0");
    mw_3B_();
    push_ptr("                }\0\0\0");
    mw_3B_();
    push_ptr("            } break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C32: {\0\0\0");
    mw_3B_();
    push_ptr("                u64 x0 = car.payload.vp_u64 >> 32;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x1 = car.payload.vp_u64 & 0xFFFFFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x2 = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y0 = x0 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y1 = x1 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y2 = x2 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                if ((x0 == y0) && (x1 == y1) && (x2 == y2)) {\0\0\0");
    mw_3B_();
    push_ptr("                    value_t r;\0\0\0");
    mw_3B_();
    push_ptr("                    r.tag = VT_C21;\0\0\0");
    mw_3B_();
    push_ptr("                    r.payload.vp_u64 = (y0 << 42) | (y1 << 21) | y2;\0\0\0");
    mw_3B_();
    push_ptr("                    return r;\0\0\0");
    mw_3B_();
    push_ptr("                }\0\0\0");
    mw_3B_();
    push_ptr("            } break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U21: {\0\0\0");
    mw_3B_();
    push_ptr("                u64 x0 = car.payload.vp_u64 >> 42;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x3 = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y0 = x0 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y1 = x1 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y2 = x2 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y3 = x3 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {\0\0\0");
    mw_3B_();
    push_ptr("                    value_t r;\0\0\0");
    mw_3B_();
    push_ptr("                    r.tag = VT_U16;\0\0\0");
    mw_3B_();
    push_ptr("                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;\0\0\0");
    mw_3B_();
    push_ptr("                    return r;\0\0\0");
    mw_3B_();
    push_ptr("                }\0\0\0");
    mw_3B_();
    push_ptr("            } break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C21: {\0\0\0");
    mw_3B_();
    push_ptr("                u64 x0 = car.payload.vp_u64 >> 42;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x1 = (car.payload.vp_u64 >> 21) & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x2 = car.payload.vp_u64 & 0x1FFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 x3 = cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y0 = x0 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y1 = x1 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y2 = x2 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                u64 y3 = x3 & 0xFFFFLL;\0\0\0");
    mw_3B_();
    push_ptr("                if ((x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)) {\0\0\0");
    mw_3B_();
    push_ptr("                    value_t r;\0\0\0");
    mw_3B_();
    push_ptr("                    r.tag = VT_C16;\0\0\0");
    mw_3B_();
    push_ptr("                    r.payload.vp_u64 = (y0 << 48) | (y1 << 32) | (y2 << 16) | y3;\0\0\0");
    mw_3B_();
    push_ptr("                    return r;\0\0\0");
    mw_3B_();
    push_ptr("                }\0\0\0");
    mw_3B_();
    push_ptr("            } break;\0\0\0");
    mw_3B_();
    push_ptr("            default: break;\0\0\0");
    mw_3B_();
    push_ptr("        }\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    if (heap_count >= HEAP_SIZE - 1) {\0\0\0");
    mw_3B_();
    push_ptr("        write(2, \"HEAP OVERFLOW\\n\", 14);\0\0\0");
    mw_3B_();
    push_ptr("        exit(1);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    u64 cell_index = heap_next;\0\0\0");
    mw_3B_();
    push_ptr("    cell_t *cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }\0\0\0");
    mw_3B_();
    push_ptr("    if (cell_index >= HEAP_SIZE - 1) {\0\0\0");
    mw_3B_();
    push_ptr("        write(2, \"HEAP OVERFLOW\\n\", 14);\0\0\0");
    mw_3B_();
    push_ptr("        exit(1);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    u64 saved_index = cell->cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("    heap_next = (usize)(saved_index ? saved_index : cell_index+1);\0\0\0");
    mw_3B_();
    push_ptr("    heap_count++;\0\0\0");
    mw_3B_();
    push_ptr("    cell->refs = 1;\0\0\0");
    mw_3B_();
    push_ptr("    cell->freecdr = false;\0\0\0");
    mw_3B_();
    push_ptr("    cell->car = car;\0\0\0");
    mw_3B_();
    push_ptr("    cell->cdr = cdr;\0\0\0");
    mw_3B_();
    push_ptr("    value_t v = {0};\0\0\0");
    mw_3B_();
    push_ptr("    v.tag = VT_C64;\0\0\0");
    mw_3B_();
    push_ptr("    v.payload.vp_u64 = cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    return v;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static value_t mkcell_raw (value_t car, value_t cdr) {\0\0\0");
    mw_3B_();
    push_ptr("    u64 cell_index = heap_next;\0\0\0");
    mw_3B_();
    push_ptr("    cell_t *cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }\0\0\0");
    mw_3B_();
    push_ptr("    if (cell_index >= HEAP_SIZE - 1) {\0\0\0");
    mw_3B_();
    push_ptr("        write(2, \"HEAP OVERFLOW\\n\", 14);\0\0\0");
    mw_3B_();
    push_ptr("        exit(1);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    u64 saved_index = cell->cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("    heap_next = (usize)(saved_index ? saved_index : cell_index+1);\0\0\0");
    mw_3B_();
    push_ptr("    heap_count++;\0\0\0");
    mw_3B_();
    push_ptr("    cell->refs = 1;\0\0\0");
    mw_3B_();
    push_ptr("    cell->freecdr = false;\0\0\0");
    mw_3B_();
    push_ptr("    cell->car = car;\0\0\0");
    mw_3B_();
    push_ptr("    cell->cdr = cdr;\0\0\0");
    mw_3B_();
    push_ptr("    value_t v = {0};\0\0\0");
    mw_3B_();
    push_ptr("    v.tag = VT_C64;\0\0\0");
    mw_3B_();
    push_ptr("    v.payload.vp_u64 = cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    return v;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static value_t mkcell_freecdr (value_t car, value_t cdr) {\0\0\0");
    mw_3B_();
    push_ptr("    if (heap_count >= HEAP_SIZE - 1) {\0\0\0");
    mw_3B_();
    push_ptr("        write(2, \"HEAP OVERFLOW\\n\", 14);\0\0\0");
    mw_3B_();
    push_ptr("        exit(1);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    u64 cell_index = heap_next;\0\0\0");
    mw_3B_();
    push_ptr("    cell_t *cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    while ((cell->refs > 0) && (cell_index < HEAP_SIZE)) { cell++; cell_index++; }\0\0\0");
    mw_3B_();
    push_ptr("    if (cell_index >= HEAP_SIZE - 1) {\0\0\0");
    mw_3B_();
    push_ptr("        write(2, \"HEAP OVERFLOW\\n\", 14);\0\0\0");
    mw_3B_();
    push_ptr("        exit(1);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    u64 saved_index = cell->cdr.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("    heap_next = (usize)(saved_index ? saved_index : cell_index+1);\0\0\0");
    mw_3B_();
    push_ptr("    heap_count++;\0\0\0");
    mw_3B_();
    push_ptr("    cell->refs = 1;\0\0\0");
    mw_3B_();
    push_ptr("    cell->freecdr = true;\0\0\0");
    mw_3B_();
    push_ptr("    cell->car = car;\0\0\0");
    mw_3B_();
    push_ptr("    cell->cdr = cdr;\0\0\0");
    mw_3B_();
    push_ptr("    value_t v = {0};\0\0\0");
    mw_3B_();
    push_ptr("    v.tag = VT_C64;\0\0\0");
    mw_3B_();
    push_ptr("    v.payload.vp_u64 = cell_index;\0\0\0");
    mw_3B_();
    push_ptr("    return v;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static void do_pack_uncons(void) {\0\0\0");
    mw_3B_();
    push_ptr("    value_t car, cdr, val;\0\0\0");
    mw_3B_();
    push_ptr("    val = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    value_uncons(val, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("    push_value(car); push_value(cdr);\0\0\0");
    mw_3B_();
    push_ptr("    if (val.tag == VT_C64) {\0\0\0");
    mw_3B_();
    push_ptr("        decref_for_uncons(val);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("#define get_value_tag(v) (((v).tag == VT_U64) ? (v).payload.vp_i64 : (((v).tag == VT_C64) ? (heap[(v).payload.vp_u64].cdr.payload.vp_i64) : (i64)((v).payload.vp_u64 & 0xFFFF)))\0\0\0");
    mw_3B_();
    push_ptr("#define get_top_data_tag() (get_value_tag(stack[stack_counter]))\0\0\0");
    mw_3B_();
    push_ptr("#define value_cmp(v1,v2) ((((v1).tag == VT_U64) && ((v2).tag == VT_U64)) ? ((v1).payload.vp_i64 - (v2).payload.vp_i64) : value_cmp_hard((v1), (v2)))\0\0\0");
    mw_3B__3B_();
    push_ptr("static i64 value_cmp_hard(value_t v1, value_t v2) {\0\0\0");
    mw_3B_();
    push_ptr("    while(1) {\0\0\0");
    mw_3B_();
    push_ptr("        i64 t1 = get_value_tag(v1);\0\0\0");
    mw_3B_();
    push_ptr("        i64 t2 = get_value_tag(v2);\0\0\0");
    mw_3B_();
    push_ptr("        if (t1 < t2) return -1;\0\0\0");
    mw_3B_();
    push_ptr("        if (t1 > t2) return 1;\0\0\0");
    mw_3B_();
    push_ptr("        if ((v1.tag == VT_U64) && (v2.tag == VT_U64)) return 0;\0\0\0");
    mw_3B_();
    push_ptr("        value_t v1car, v1cdr, v2car, v2cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v1, &v1car, &v1cdr);\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(v2, &v2car, &v2cdr);\0\0\0");
    mw_3B_();
    push_ptr("        i64 cdrcmp = value_cmp(v1cdr, v2cdr);\0\0\0");
    mw_3B_();
    push_ptr("        if (cdrcmp != 0) return cdrcmp;\0\0\0");
    mw_3B_();
    push_ptr("        v1 = v1car; v2 = v2car;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("#define value_eq(v1,v2) (((v1).tag == (v2).tag) && (((v1).payload.vp_u64 == (v2).payload.vp_u64) || (((v1).tag & 0x80) && value_eq_hard((v1),(v2)))))\0\0\0");
    mw_3B__3B_();
    push_ptr("static bool value_eq_hard(value_t v1, value_t v2) {\0\0\0");
    mw_3B_();
    push_ptr("    usize c1_index, c2_index; cell_t *c1, *c2;\0\0\0");
    mw_3B_();
    push_ptr("    while (1) {\0\0\0");
    mw_3B_();
    push_ptr("        if (v1.tag != v2.tag) return false;\0\0\0");
    mw_3B_();
    push_ptr("        if (v1.payload.vp_u64 == v2.payload.vp_u64) return true;\0\0\0");
    mw_3B_();
    push_ptr("        switch (v1.tag) {\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U64: return false;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U32: return false;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U21: return false;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_U16: return false;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C64:\0\0\0");
    mw_3B_();
    push_ptr("               c1_index = (usize)v1.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("               c2_index = (usize)v2.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("               break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C32:\0\0\0");
    mw_3B_();
    push_ptr("               if (v1.payload.vp_u32 != v2.payload.vp_u32) return false;\0\0\0");
    mw_3B_();
    push_ptr("               c1_index = (usize)(v1.payload.vp_u64 >> 32);\0\0\0");
    mw_3B_();
    push_ptr("               c2_index = (usize)(v2.payload.vp_u64 >> 32);\0\0\0");
    mw_3B_();
    push_ptr("               break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C21:\0\0\0");
    mw_3B_();
    push_ptr("               if (  (v1.payload.vp_u64 & 0x03FFFFFFFFFF)\0\0\0");
    mw_3B_();
    push_ptr("                  != (v2.payload.vp_u64 & 0x03FFFFFFFFFF)) return false;\0\0\0");
    mw_3B_();
    push_ptr("               c1_index = (usize)(v1.payload.vp_u64 >> 42);\0\0\0");
    mw_3B_();
    push_ptr("               c2_index = (usize)(v2.payload.vp_u64 >> 42);\0\0\0");
    mw_3B_();
    push_ptr("               break;\0\0\0");
    mw_3B_();
    push_ptr("            case VT_C16:\0\0\0");
    mw_3B_();
    push_ptr("               if (  (v1.payload.vp_u64 & 0xFFFFFFFFFFFF)\0\0\0");
    mw_3B_();
    push_ptr("                  != (v2.payload.vp_u64 & 0xFFFFFFFFFFFF)) return false;\0\0\0");
    mw_3B_();
    push_ptr("               c1_index = (usize)(v1.payload.vp_u64 >> 48);\0\0\0");
    mw_3B_();
    push_ptr("               c2_index = (usize)(v2.payload.vp_u64 >> 48);\0\0\0");
    mw_3B_();
    push_ptr("               break;\0\0\0");
    mw_3B_();
    push_ptr("        }\0\0\0");
    mw_3B_();
    push_ptr("        c1 = heap + c1_index;\0\0\0");
    mw_3B_();
    push_ptr("        c2 = heap + c2_index;\0\0\0");
    mw_3B_();
    push_ptr("        if (!value_eq(c1->cdr, c2->cdr)) return false;\0\0\0");
    mw_3B_();
    push_ptr("        v1 = c1->car; v2 = c2->car;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("#define do_run() do { do_pack_uncons(); fnptr fp = pop_fnptr(); fp(); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_CORE_ID();
    mw_2E_pm();
    push_ptr("0\0\0\0");
    mw_3B_();
    mwPRIM_CORE_DUP();
    mw_2E_pm();
    push_ptr("do{ value_t v = stack[stack_counter]; push_value(v); incref(v); } while(0)\0\0\0");
    mw_3B__3B_();
    push_ptr("#define do_drop() decref(pop_value())\0\0\0");
    mw_3B_();
    mwPRIM_CORE_DROP();
    mw_2E_pm();
    push_ptr("do_drop()\0\0\0");
    mw_3B__3B_();
    push_ptr("#define do_swap() do{ value_t x = stack[stack_counter]; stack[stack_counter] = stack[stack_counter+1]; stack[stack_counter+1] = x; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_CORE_SWAP();
    mw_2E_pm();
    push_ptr("do_swap()\0\0\0");
    mw_3B__3B_();
    mwPRIM_CORE_DIP();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    value_t f = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    value_t x = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    push_value(f);\0\0\0");
    mw_3B_();
    push_ptr("    do_run();\0\0\0");
    mw_3B_();
    push_ptr("    push_value(x);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_CORE_IF();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    value_t then_branch = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    value_t else_branch = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    bool b = pop_bool();\0\0\0");
    mw_3B_();
    push_ptr("    if (b) {\0\0\0");
    mw_3B_();
    push_ptr("        push_value(then_branch);\0\0\0");
    mw_3B_();
    push_ptr("        decref(else_branch);\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        push_value(else_branch);\0\0\0");
    mw_3B_();
    push_ptr("        decref(then_branch);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    do_run();\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_CORE_WHILE();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    value_t cond = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    value_t body = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    while(1) {\0\0\0");
    mw_3B_();
    push_ptr("        push_value(cond); incref(cond); do_run();\0\0\0");
    mw_3B_();
    push_ptr("        bool b = pop_bool();\0\0\0");
    mw_3B_();
    push_ptr("        if (!b) break;\0\0\0");
    mw_3B_();
    push_ptr("        push_value(body); incref(body); do_run();\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    decref(cond); decref(body);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_INT_ADD();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 += stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_SUB();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 -= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_MUL();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_i64 *= stack[stack_counter].payload.vp_i64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_DIV();
    mw_2E_pm();
    push_ptr("do { i64 a = stack[stack_counter+1].payload.vp_i64; i64 b = stack[stack_counter].payload.vp_i64; i64 r = a % b; i64 q = a / b; if (((a < 0) ^ (b < 0)) && r) q--; stack_counter++; stack[stack_counter].payload.vp_i64 = q; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_MOD();
    mw_2E_pm();
    push_ptr("do { i64 a = stack[stack_counter+1].payload.vp_i64; i64 b = stack[stack_counter].payload.vp_i64; i64 r = a % b; if (((a < 0) ^ (b < 0)) && r) r += b; stack_counter++; stack[stack_counter].payload.vp_i64 = r; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_AND();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 &= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_OR();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 |= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_XOR();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 ^= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_SHL();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 <<= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_SHR();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 >>= stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_VALUE_EQ();
    mw_2E_pm();
    push_ptr(" do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_eq(v1, v2)); decref(v1); decref(v2); } while(0)\0\0\0");
    mw_3B__3B_();
    mwPRIM_VALUE_LT();
    mw_2E_pm();
    push_ptr(" do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_cmp(v1, v2) < 0); decref(v1); decref(v2); } while(0)\0\0\0");
    mw_3B__3B_();
    mwPRIM_VALUE_LE();
    mw_2E_pm();
    push_ptr(" do { value_t v2 = pop_value(); value_t v1 = pop_value(); push_bool(value_cmp(v1, v2) <= 0); decref(v1); decref(v2); } while(0)\0\0\0");
    mw_3B__3B_();
    mwPRIM_POSIX_WRITE();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    usize n = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t vp = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    void* p = value_ptr(vp);\0\0\0");
    mw_3B_();
    push_ptr("    int f = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    push_i64((i64)write(f, p, n));\0\0\0");
    mw_3B_();
    push_ptr("    decref(vp);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_POSIX_READ();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    usize n = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t vp = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    void* p = value_ptr(vp);\0\0\0");
    mw_3B_();
    push_ptr("    int f = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    push_i64((i64)read(f,p,n));\0\0\0");
    mw_3B_();
    push_ptr("    decref(vp);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_POSIX_OPEN();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    int m = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    int f = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t vp = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    void* p = value_ptr(vp);\0\0\0");
    mw_3B_();
    push_ptr("    push_i64((i64)open(p,f,m));\0\0\0");
    mw_3B_();
    push_ptr("    decref(vp);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_POSIX_CLOSE();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    int x = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    push_i64((i64)close(x));\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_POSIX_EXIT();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    int x = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    exit(x);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_POSIX_MMAP();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    #ifdef MIRTH_WINDOWS\0\0\0");
    mw_3B_();
    push_ptr("    pop_value(); pop_value(); pop_value(); pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    usize b = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    push_ptr(malloc(b));\0\0\0");
    mw_3B_();
    push_ptr("    #else\0\0\0");
    mw_3B_();
    push_ptr("    int f = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    int e = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    int d = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    int c = (int)pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    usize b = (usize)pop_u64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t va = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    void* a = value_ptr(va);\0\0\0");
    mw_3B_();
    push_ptr("    void* p = mmap(a,b,c,d,e,f);\0\0\0");
    mw_3B_();
    push_ptr("    push_ptr(p);\0\0\0");
    mw_3B_();
    push_ptr("    decref(va);\0\0\0");
    mw_3B_();
    push_ptr("    #endif\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static void do_debug(void) {\0\0\0");
    mw_3B_();
    push_ptr("    write(2, \"??\", 2);\0\0\0");
    mw_3B_();
    push_ptr("    char c[32] = {0};\0\0\0");
    mw_3B_();
    push_ptr("    char* cp;\0\0\0");
    mw_3B_();
    push_ptr("    usize n;\0\0\0");
    mw_3B_();
    push_ptr("    i64 x; i64 y;\0\0\0");
    mw_3B_();
    push_ptr("    for (long i = STACK_SIZE-1; i >= (long)stack_counter; i--) {\0\0\0");
    mw_3B_();
    push_ptr("        cp = c+30;\0\0\0");
    mw_3B_();
    push_ptr("        x = stack[i].payload.vp_i64;\0\0\0");
    mw_3B_();
    push_ptr("        n = 1;\0\0\0");
    mw_3B_();
    push_ptr("        y = x; if (x < 0) { x = -x; }\0\0\0");
    mw_3B_();
    push_ptr("        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);\0\0\0");
    mw_3B_();
    push_ptr("        if (y < 0) { *cp-- = '-'; n++; } \0\0\0");
    mw_3B_();
    push_ptr("        *cp = ' ';\0\0\0");
    mw_3B_();
    push_ptr("        write(2, cp, n);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    write(2, \"\\n\", 1);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_CORE_DEBUG();
    mw_2E_pm();
    push_ptr("do_debug()\0\0\0");
    mw_3B__3B_();
    mwPRIM_VALUE_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); value_t* p = value_ptr(vp); push_value(*p); incref(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i64* p = value_ptr(vp); push_i64(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_PTR_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); void** p = value_ptr(vp); push_ptr(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U8_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u8* p = value_ptr(vp); push_u8(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U16_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u16* p = value_ptr(vp); push_u16(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U32_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u32* p = value_ptr(vp); push_u32(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U64_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u64* p = value_ptr(vp); push_u64(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I8_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i8* p = value_ptr(vp); push_i8(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I16_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i16* p = value_ptr(vp); push_i16(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I32_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i32* p = value_ptr(vp); push_i32(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I64_GET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i64* p = value_ptr(vp); push_i64(*p); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_INT_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i64* p = value_ptr(vp); *p = pop_i64(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U8_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u8* p = value_ptr(vp); *p = pop_u8(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U16_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u16* p = value_ptr(vp); *p = pop_u16(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U32_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u32* p = value_ptr(vp); *p = pop_u32(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_U64_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); u64* p = value_ptr(vp); *p = pop_u64(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I8_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i8* p = value_ptr(vp); *p = pop_i8(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I16_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i16* p = value_ptr(vp); *p = pop_i16(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I32_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i32* p = value_ptr(vp); *p = pop_i32(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_I64_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); i64* p = value_ptr(vp); *p = pop_i64(); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_PTR_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); value_t vx = pop_value(); void** p = value_ptr(vp); *p = value_ptr(vx); decref(vp); decref(vx); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_VALUE_SET();
    mw_2E_pm();
    push_ptr("do { value_t vp = pop_value(); value_t vx = pop_value(); value_t* p = value_ptr(vp); value_t old = *p; *p = vx; decref(old); decref(vp); } while(0)\0\0\0");
    mw_3B_();
    push_ptr("#if defined(MIRTH_WINDOWS)\0\0\0");
    mw_3B_();
    mwPRIM_SYS_OS();
    mw_2E_pm();
    push_ptr("push_u64(\0\0\0");
    mw_2E_();
    mwOS_WINDOWS();
    mwOS__3E_Int();
    mw_2E_n();
    push_ptr(")\0\0\0");
    mw_3B_();
    push_ptr("#elif defined(MIRTH_LINUX)\0\0\0");
    mw_3B_();
    mwPRIM_SYS_OS();
    mw_2E_pm();
    push_ptr("push_u64(\0\0\0");
    mw_2E_();
    mwOS_LINUX();
    mwOS__3E_Int();
    mw_2E_n();
    push_ptr(")\0\0\0");
    mw_3B_();
    push_ptr("#elif defined(MIRTH_MACOS)\0\0\0");
    mw_3B_();
    mwPRIM_SYS_OS();
    mw_2E_pm();
    push_ptr("push_u64(\0\0\0");
    mw_2E_();
    mwOS_MACOS();
    mwOS__3E_Int();
    mw_2E_n();
    push_ptr(")\0\0\0");
    mw_3B_();
    push_ptr("#else\0\0\0");
    mw_3B_();
    mwPRIM_SYS_OS();
    mw_2E_pm();
    push_ptr("push_u64(\0\0\0");
    mw_2E_();
    mwOS_UNKNOWN();
    mwOS__3E_Int();
    mw_2E_n();
    push_ptr(")\0\0\0");
    mw_3B_();
    push_ptr("#endif\0\0\0");
    mw_3B__3B_();
    mwPRIM_UNSAFE_CAST();
    mw_2E_pm();
    push_ptr("0\0\0\0");
    mw_3B__3B_();
    mwPRIM_CORE_RUN();
    mw_2E_pm();
    push_ptr("do_run()\0\0\0");
    mw_3B__3B_();
    mwPRIM_PTR_ADD();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    value_t vp = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    i64 y = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    if (vp.tag == VT_U64) {\0\0\0");
    mw_3B_();
    push_ptr("        push_i64(y + vp.payload.vp_i64);\0\0\0");
    mw_3B_();
    push_ptr("    } else if (value_has_ptr_offset(vp)) {\0\0\0");
    mw_3B_();
    push_ptr("        value_t car, cdr;\0\0\0");
    mw_3B_();
    push_ptr("        value_uncons(vp, &car, &cdr);\0\0\0");
    mw_3B_();
    push_ptr("        cdr.payload.vp_i64 += y;\0\0\0");
    mw_3B_();
    push_ptr("        push_value(mkcell(car, cdr));\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        value_t vy = { .tag = VT_U64, .payload = { .vp_i64 = y } };\0\0\0");
    mw_3B_();
    push_ptr("        push_value(mkcell(vp, vy));\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
    mwPRIM_BOOL_TRUE();
    mw_2E_pm();
    push_ptr("push_bool(true)\0\0\0");
    mw_3B_();
    mwPRIM_BOOL_FALSE();
    mw_2E_pm();
    push_ptr("push_bool(false)\0\0\0");
    mw_3B_();
    mwPRIM_BOOL_AND();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 = stack[stack_counter+1].payload.vp_u64 && stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_BOOL_OR();
    mw_2E_pm();
    push_ptr("do { stack[stack_counter+1].payload.vp_u64 = stack[stack_counter+1].payload.vp_u64 || stack[stack_counter].payload.vp_u64; stack_counter++; } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_SYS_ARGC();
    mw_2E_pm();
    push_ptr("push_i64(global_argc)\0\0\0");
    mw_3B_();
    mwPRIM_SYS_ARGV();
    mw_2E_pm();
    push_ptr("push_ptr(global_argv)\0\0\0");
    mw_3B_();
    mwPRIM_PTR_SIZE();
    mw_2E_pm();
    push_ptr("push_u64((u64)sizeof(void*))\0\0\0");
    mw_3B_();
    mwPRIM_PTR_ALLOC();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    i64 psize = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    if (psize > 0) {\0\0\0");
    mw_3B_();
    push_ptr("        usize size = (usize)psize;\0\0\0");
    mw_3B_();
    push_ptr("        void* ptr = calloc(1,size);\0\0\0");
    mw_3B_();
    push_ptr("        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };\0\0\0");
    mw_3B_();
    push_ptr("        value_t vptr = { .tag = VT_U64, .payload = { .vp_ptr = ptr } };\0\0\0");
    mw_3B_();
    push_ptr("        value_t v = mkcell_freecdr(vsize, vptr);\0\0\0");
    mw_3B_();
    push_ptr("        push_value(v);\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        push_u64(0);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    push_ptr("static void* alloc_but_copy (usize dstn, void* src, usize srcn) {\0\0\0");
    mw_3B_();
    push_ptr("    void* dst = calloc(1,dstn);\0\0\0");
    mw_3B_();
    push_ptr("    if (src) {\0\0\0");
    mw_3B_();
    push_ptr("        usize cpyn = (dstn > srcn) ? srcn : dstn;\0\0\0");
    mw_3B_();
    push_ptr("        memcpy(dst, src, cpyn);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    return dst;\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B_();
    mwPRIM_PTR_REALLOC();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    i64 psize = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t vptr = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    if (psize <= 0) { \0\0\0");
    mw_3B_();
    push_ptr("        decref(vptr);\0\0\0");
    mw_3B_();
    push_ptr("        push_u64(0);\0\0\0");
    mw_3B_();
    push_ptr("        return;\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    usize new_size = (usize)psize;\0\0\0");
    mw_3B_();
    push_ptr("    if ((vptr.tag == VT_C64) && !value_has_ptr_offset(vptr)) {\0\0\0");
    mw_3B_();
    push_ptr("       usize cell_index = get_cell_index(vptr);\0\0\0");
    mw_3B_();
    push_ptr("       cell_t *cell = heap + cell_index;\0\0\0");
    mw_3B_();
    push_ptr("       usize old_size = (usize)cell->car.payload.vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("       void* old_ptr = cell->cdr.payload.vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("       void* new_ptr = realloc(old_ptr, new_size);\0\0\0");
    mw_3B_();
    push_ptr("       cell->car.payload.vp_i64 = psize;\0\0\0");
    mw_3B_();
    push_ptr("       cell->cdr.payload.vp_ptr = new_ptr;\0\0\0");
    mw_3B_();
    push_ptr("       if (old_size < new_size) {\0\0\0");
    mw_3B_();
    push_ptr("           memset((char*)new_ptr + old_size, 0, new_size - old_size);\0\0\0");
    mw_3B_();
    push_ptr("       }\0\0\0");
    mw_3B_();
    push_ptr("       push_value(vptr);\0\0\0");
    mw_3B_();
    push_ptr("    } else {\0\0\0");
    mw_3B_();
    push_ptr("        void* old_ptr = value_ptr(vptr);\0\0\0");
    mw_3B_();
    push_ptr("        usize old_size = (usize)value_ptr_size(vptr);\0\0\0");
    mw_3B_();
    push_ptr("        void* new_ptr = alloc_but_copy(new_size, old_ptr, old_size);\0\0\0");
    mw_3B_();
    push_ptr("        value_t vsize = { .tag = VT_U64, .payload = { .vp_i64 = psize } };\0\0\0");
    mw_3B_();
    push_ptr("        value_t vnew = { .tag = VT_U64, .payload = { .vp_ptr = new_ptr } };\0\0\0");
    mw_3B_();
    push_ptr("        value_t v = mkcell_freecdr(vsize, vnew);\0\0\0");
    mw_3B_();
    push_ptr("        push_value(v);\0\0\0");
    mw_3B_();
    push_ptr("        decref(vptr);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_PTR_COPY();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    value_t vdst = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    i64 ilen = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    value_t vsrc = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    void* src = value_ptr(vsrc);\0\0\0");
    mw_3B_();
    push_ptr("    void* dst = value_ptr(vdst);\0\0\0");
    mw_3B_();
    push_ptr("    if (src && dst && (ilen > 0)) {\0\0\0");
    mw_3B_();
    push_ptr("        memcpy(dst, src, (usize)ilen);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    decref(vsrc);\0\0\0");
    mw_3B_();
    push_ptr("    decref(vdst);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_PTR_FILL();
    mw_2E_p();
    push_ptr(" {\0\0\0");
    mw_3B_();
    push_ptr("    value_t vdst = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    i64 ilen = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    i64 val = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    void* dst = value_ptr(vdst);\0\0\0");
    mw_3B_();
    push_ptr("    if (dst && (ilen > 0)) {\0\0\0");
    mw_3B_();
    push_ptr("        memset(dst, (int)val, (usize)ilen);\0\0\0");
    mw_3B_();
    push_ptr("    }\0\0\0");
    mw_3B_();
    push_ptr("    decref(vdst);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_PTR_RAW();
    mw_2E_pm();
    push_ptr("do { usize i = stack_counter; push_ptr(value_ptr(stack[i])); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_STR_EQ();
    mw_2E_p();
    push_ptr("{\0\0\0");
    mw_3B_();
    push_ptr("    value_t vptr1 = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    value_t vptr2 = pop_value();\0\0\0");
    mw_3B_();
    push_ptr("    const char* ptr1 = value_ptr(vptr1);\0\0\0");
    mw_3B_();
    push_ptr("    const char* ptr2 = value_ptr(vptr2);\0\0\0");
    mw_3B_();
    push_ptr("    bool result = (!ptr1 || !ptr2) ? (ptr1 == ptr2) : strcmp(ptr1,ptr2) == 0;\0\0\0");
    mw_3B_();
    push_ptr("    push_bool(result);\0\0\0");
    mw_3B_();
    push_ptr("    decref(vptr1); decref(vptr2);\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_STR_ALLOC();
    mw_2E_p();
    push_ptr("{\0\0\0");
    mw_3B_();
    push_ptr("    i64 psize = pop_i64();\0\0\0");
    mw_3B_();
    push_ptr("    push_i64(psize + 4);\0\0\0");
    mw_3B_();
    push_ptr("    mwprim_2E_ptr_2E_alloc();\0\0\0");
    mw_3B_();
    push_ptr("}\0\0\0");
    mw_3B__3B_();
    mwPRIM_STR_BASE();
    mw_2E_pm();
    push_ptr("0\0\0\0");
    mw_3B__3B_();
    mwPRIM_STR_SIZE();
    mw_2E_pm();
    push_ptr("do { value_t v = stack[stack_counter]; if (!v.payload.vp_u64) { push_u64(0); } else if (v.tag == VT_U64) { push_u64((u64)strlen(v.payload.vp_ptr)); } else { push_i64(value_ptr_size(v)-4); }  } while(0)\0\0\0");
    mw_3B__3B_();
    push_ptr("#define do_pack_cons() do { value_t cdr = pop_value(); value_t car = pop_value(); push_value(mkcell(car,cdr)); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_PACK_NIL();
    mw_2E_pm();
    push_ptr(" push_u64(0)\0\0\0");
    mw_3B_();
    mwPRIM_PACK_CONS();
    mw_2E_pm();
    push_ptr("do_pack_cons();\0\0\0");
    mw_3B_();
    mwPRIM_PACK_UNCONS();
    mw_2E_pm();
    push_ptr("do_pack_uncons();\0\0\0");
    mw_3B__3B_();
    mwPRIM_MUT_NEW();
    mw_2E_pm();
    push_ptr("do { value_t car = pop_value(); value_t cdr = { 0 }; push_value(mkcell_raw(car,cdr)); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_MUT_GET();
    mw_2E_pm();
    push_ptr("do { do_pack_uncons(); pop_value(); } while(0)\0\0\0");
    mw_3B_();
    mwPRIM_MUT_SET();
    mw_2E_pm();
    push_ptr("do { value_t cellval = pop_value(); value_t newval = pop_value(); push_value(cellval); usize cellidx = get_cell_index(cellval); if (cellidx) { cell_t* cell = heap + cellidx; value_t oldval = cell->car; cell->car = newval; decref(oldval); } else { decref(newval); } } while(0)\0\0\0");
    mw_3B__3B_();
}

static void mwOS__3E_Int (void){
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    push_i64(0LL);
    break;
    case 1LL:
    do_drop();
    push_i64(1LL);
    break;
    case 2LL:
    do_drop();
    push_i64(2LL);
    break;
    case 3LL:
    do_drop();
    push_i64(3LL);
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mw_2E_p (void){
    mwprim_name_40_();
    mw_2E_w();
}

static void mw_2E_pm (void){
    push_ptr("#define mw\0\0\0");
    mw_2E_();
    mwprim_name_40_();
    mw_2E_name();
    push_ptr("() \0\0\0");
    mw_2E_();
}

static void mwc99_emit_header_21_ (void){
    push_ptr("/* C99 generated by Mirth compiler. */\0\0\0");
    mw_3B_();
    push_ptr("#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\0\0\0");
    mw_3B_();
    push_ptr("#define MIRTH_WINDOWS 1\0\0\0");
    mw_3B_();
    push_ptr("#elif defined(__linux__)\0\0\0");
    mw_3B_();
    push_ptr("#define MIRTH_LINUX 1\0\0\0");
    mw_3B_();
    push_ptr("#elif defined(__APPLE__)\0\0\0");
    mw_3B_();
    push_ptr("#define MIRTH_MACOS 1\0\0\0");
    mw_3B_();
    push_ptr("#else\0\0\0");
    mw_3B_();
    push_ptr("#error \"Platform not supported.\"\0\0\0");
    mw_3B_();
    push_ptr("#endif\0\0\0");
    mw_3B__3B_();
    push_ptr("#include <stdint.h>\0\0\0");
    mw_3B_();
    push_ptr("#include <stdbool.h>\0\0\0");
    mw_3B__3B_();
    push_ptr("typedef uint8_t u8;\0\0\0");
    mw_3B_();
    push_ptr("typedef uint16_t u16;\0\0\0");
    mw_3B_();
    push_ptr("typedef uint32_t u32;\0\0\0");
    mw_3B_();
    push_ptr("typedef uint64_t u64;\0\0\0");
    mw_3B_();
    push_ptr("typedef int8_t i8;\0\0\0");
    mw_3B_();
    push_ptr("typedef int16_t i16;\0\0\0");
    mw_3B_();
    push_ptr("typedef int32_t i32;\0\0\0");
    mw_3B_();
    push_ptr("typedef int64_t i64;\0\0\0");
    mw_3B_();
    push_ptr("typedef uintptr_t usize;\0\0\0");
    mw_3B__3B_();
    push_ptr("extern void* mmap(void*, int, int, int, int, int);\0\0\0");
    mw_3B_();
    push_ptr("extern void* malloc(usize);\0\0\0");
    mw_3B_();
    push_ptr("extern void* calloc(usize, usize);\0\0\0");
    mw_3B_();
    push_ptr("extern void* realloc(void*, usize);\0\0\0");
    mw_3B_();
    push_ptr("extern void* memset(void*, int, usize);\0\0\0");
    mw_3B_();
    push_ptr("extern void* memcpy(void*, const void*, usize);\0\0\0");
    mw_3B_();
    push_ptr("extern void free(void*);\0\0\0");
    mw_3B_();
    push_ptr("extern usize strlen(const char*);\0\0\0");
    mw_3B_();
    push_ptr("extern int read(int, void*, usize);\0\0\0");
    mw_3B_();
    push_ptr("extern int write(int, void*, usize);\0\0\0");
    mw_3B_();
    push_ptr("extern int close(int);\0\0\0");
    mw_3B_();
    push_ptr("extern int open(void*, int, int);\0\0\0");
    mw_3B_();
    push_ptr("extern int strcmp(const char*, const char*);\0\0\0");
    mw_3B_();
    push_ptr("extern void exit(int);\0\0\0");
    mw_3B__3B_();
    push_ptr("typedef enum value_tag_t {\0\0\0");
    mw_3B_();
    push_ptr("   VT_U64 = 0x00,\0\0\0");
    mw_3B_();
    push_ptr("   VT_U32 = 0x01,\0\0\0");
    mw_3B_();
    push_ptr("   VT_U21 = 0x02,\0\0\0");
    mw_3B_();
    push_ptr("   VT_U16 = 0x03,\0\0\0");
    mw_3B_();
    push_ptr("   VT_C16 = 0x90,\0\0\0");
    mw_3B_();
    push_ptr("   VT_C21 = 0x96,\0\0\0");
    mw_3B_();
    push_ptr("   VT_C32 = 0xA0,\0\0\0");
    mw_3B_();
    push_ptr("   VT_C64 = 0xC0,\0\0\0");
    mw_3B_();
    push_ptr("} value_tag_t;\0\0\0");
    mw_3B__3B_();
    push_ptr("typedef void (*fnptr)(void);\0\0\0");
    mw_3B__3B_();
    push_ptr("typedef union value_payload_t {\0\0\0");
    mw_3B_();
    push_ptr("    void* vp_ptr;\0\0\0");
    mw_3B_();
    push_ptr("    u8 vp_u8;\0\0\0");
    mw_3B_();
    push_ptr("    u16 vp_u16;\0\0\0");
    mw_3B_();
    push_ptr("    u32 vp_u32;\0\0\0");
    mw_3B_();
    push_ptr("    u64 vp_u64;\0\0\0");
    mw_3B_();
    push_ptr("    i8 vp_i8;\0\0\0");
    mw_3B_();
    push_ptr("    i16 vp_i16;\0\0\0");
    mw_3B_();
    push_ptr("    i32 vp_i32;\0\0\0");
    mw_3B_();
    push_ptr("    i64 vp_i64;\0\0\0");
    mw_3B_();
    push_ptr("    bool vp_bool;\0\0\0");
    mw_3B_();
    push_ptr("    fnptr vp_fnptr;\0\0\0");
    mw_3B_();
    push_ptr("} value_payload_t;\0\0\0");
    mw_3B__3B_();
    push_ptr("typedef struct value_t {\0\0\0");
    mw_3B_();
    push_ptr("   value_payload_t payload;\0\0\0");
    mw_3B_();
    push_ptr("   value_tag_t tag; \0\0\0");
    mw_3B_();
    push_ptr("} value_t; \0\0\0");
    mw_3B__3B_();
    push_ptr("typedef struct cell_t {\0\0\0");
    mw_3B_();
    push_ptr("   u32 refs;\0\0\0");
    mw_3B_();
    push_ptr("   bool freecdr;\0\0\0");
    mw_3B_();
    push_ptr("   value_t car;\0\0\0");
    mw_3B_();
    push_ptr("   value_t cdr;\0\0\0");
    mw_3B_();
    push_ptr("} cell_t;\0\0\0");
    mw_3B__3B_();
    push_ptr("#define STACK_SIZE 0x1000\0\0\0");
    mw_3B_();
    push_ptr("static usize stack_counter = STACK_SIZE;\0\0\0");
    mw_3B_();
    push_ptr("static value_t stack [STACK_SIZE] = {0};\0\0\0");
    mw_3B__3B_();
    push_ptr("#define HEAP_SIZE 0x80000\0\0\0");
    mw_3B_();
    push_ptr("#define HEAP_MASK 0x7FFFF\0\0\0");
    mw_3B_();
    push_ptr("static usize heap_next = 1;\0\0\0");
    mw_3B_();
    push_ptr("static usize heap_count = 0;\0\0\0");
    mw_3B_();
    push_ptr("static cell_t heap [HEAP_SIZE] = {0};\0\0\0");
    mw_3B__3B_();
    push_ptr("static int global_argc;\0\0\0");
    mw_3B_();
    push_ptr("static char** global_argv;\0\0\0");
    mw_3B__3B_();
}

static void mwcodegen_start_21_ (void){
    mwcodegen_file_21_();
    push_i64(0LL);
    mwcodegen_length_21_();
}

static void mwcreate_file_21_ (void){
    mwO_WRONLY_7C_O_CREAT_7C_O_TRUNC();
    push_i64(438LL);
    mwposix_open_21_();
    mwdup();
    push_i64(0LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("Failed to create file!\0\0\0");
    mwpanic_21_();
    } else {
    mwInt__3E_File();
    }
}

static void mwO_WRONLY_7C_O_CREAT_7C_O_TRUNC (void){
    mwRUNNING_OS();
    switch (get_top_data_tag()) {
    case 3LL:
    do_drop();
    push_i64(1537LL);
    break;
    case 2LL:
    do_drop();
    push_i64(577LL);
    break;
    case 1LL:
    do_drop();
    push_i64(769LL);
    break;
    case 0LL:
    do_drop();
    push_ptr("O_WRONLY|O_CREAT|O_TRUNC on unknown os\0\0\0");
    mwpanic_21_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwmake_output_path (void){
    mwoutput_path_root_40_();
    mwswap();
    mwpath_join();
}

static void mwoutput_path_root_40_ (void){
    mwOUTPUT_PATH_ROOT();
    mwpath_40_();
}

static void mwelab_arrow_21_ (void){
    mwelab_expand_morphism_21_();
    mwelab_arrow_hom_21_();
}

static void mwelab_arrow_hom_21_ (void){
    mwswap();
    { value_t d1 = pop_value();
    mwelab_arrow_fwd_21_();
    mwarrow_token_end_3F_();
    mwGAMMA();
    mwover();
    mwarrow_cod_40_();
      push_value(d1); }
    mwtype_unify_21_();
    mwdrop2();
}

static void mwtoken_str_40_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 9LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    default:
    mwdrop();
    push_ptr("expected string\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static void mwtoken_args_2 (void){
    mwtoken_num_args_3F_();
    push_i64(2LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
    mwtoken_succ();
    mwdup();
    mwtoken_next_arg_end();
    mwtoken_succ();
    } else {
    mwtoken_num_args_3F_();
    push_i64(2LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("expected 2 args, got too few\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    push_ptr("expected 2 args, got too many\0\0\0");
    mwemit_fatal_error_21_();
    }
    }
}

static void mb_init_prims_21__7 (void) {
    do_drop();
    mwelab_field_21_();
}
static void mwelab_field_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_3();
    mwrotl();
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwnip();
    mwrotr();
    mwfield_new_21_();
    mwdrop();
    break;
    default:
    mwdrop();
    push_ptr("expected field name\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static void mwfield_new_21_ (void){
    mwField_2E_alloc_21_();
    mwtuck();
    mwfield_type_sig_21_();
    mwtuck();
    mwfield_table_sig_21_();
    mwtuck();
    mwfield_name_21_();
    mwdup();
    mwFIELD_40_();
    mwFIELDWORD();
    mwDEF_FIELDWORD();
    mwover();
    mwfield_name_40_();
    push_ptr("@\0\0\0");
    mwname_cat_21_();
    mwname_def_21_();
    mwdup();
    mwFIELD_3F_();
    mwFIELDWORD();
    mwDEF_FIELDWORD();
    mwover();
    mwfield_name_40_();
    push_ptr("?\0\0\0");
    mwname_cat_21_();
    mwname_def_21_();
    mwdup();
    mwFIELD_21_();
    mwFIELDWORD();
    mwDEF_FIELDWORD();
    mwover();
    mwfield_name_40_();
    push_ptr("!\0\0\0");
    mwname_cat_21_();
    mwname_def_21_();
}

static void mwField_2E_alloc_21_ (void){
    mwField_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwField_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwtoken_args_3 (void){
    mwtoken_num_args_3F_();
    push_i64(3LL);
    mw_3D__3D_();
    if (pop_u64()) {
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_succ();
    } else {
    mwid();
    }
    mwtoken_succ();
    mwdup();
    mwtoken_next_arg_end();
    mwtoken_succ();
    mwdup();
    mwtoken_next_arg_end();
    mwtoken_succ();
    } else {
    mwtoken_num_args_3F_();
    push_i64(3LL);
    mw_3C_();
    if (pop_u64()) {
    push_ptr("expected 3 args, got too few\0\0\0");
    mwemit_fatal_error_21_();
    } else {
    push_ptr("expected 3 args, got too many\0\0\0");
    mwemit_fatal_error_21_();
    }
    }
}

static void mb_init_prims_21__6 (void) {
    do_drop();
    mwelab_table_21_();
}
static void mwelab_table_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_1();
    mwsig_token_is_type_con_3F_();
    if (pop_u64()) {
    mwtoken_name_40_();
    mwtable_new_21_();
    mwdrop();
    } else {
    push_ptr("expected table name\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwtable_new_21_ (void){
    mwTable_2E_alloc_21_();
    mwdup2();
    mwTTable();
    mwDEF_TYPE();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwtable_name_21_();
    mwTABLE_MAX_SIZE();
    mwover();
    mwtable_max_count_21_();
    mwtable_name_3F_();
    push_ptr(".MAX\0\0\0");
    mwname_cat_21_();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwword_name_21_();
    mwL0();
    mwCTX();
    mwT0();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwready2();
    mwover();
    mwword_ctx_type_21_();
    push_u64(0);
    push_fnptr(&mb_table_new_21__1);
    do_pack_cons();
    mwab_build_word_21_();
    mwdrop();
    mwtable_name_3F_();
    push_ptr(".NUM\0\0\0");
    mwname_cat_21_();
    push_i64(8LL);
    mwbuffer_new_21_();
    mwover();
    mwtable_num_buffer_21_();
    mwtable_name_3F_();
    push_ptr(".id\0\0\0");
    mwname_cat_21_();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwword_name_21_();
    mwL0();
    mwCTX();
    mwover2();
    mwTTable();
    mwT1();
    mwTYPE_INT();
    mwT1();
    mwT__3E_();
    mwready2();
    mwover();
    mwword_ctx_type_21_();
    push_u64(0);
    push_fnptr(&mb_table_new_21__2);
    do_pack_cons();
    mwab_build_word_21_();
    mwdrop();
    mwtable_name_3F_();
    push_ptr(".succ\0\0\0");
    mwname_cat_21_();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwword_name_21_();
    mwL0();
    mwCTX();
    mwover2();
    mwTTable();
    mwT1();
    mwdup();
    mwT__3E_();
    mwready2();
    mwover();
    mwword_ctx_type_21_();
    push_u64(0);
    push_fnptr(&mb_table_new_21__3);
    do_pack_cons();
    mwab_build_word_21_();
    mwdrop();
    mwtable_name_3F_();
    push_ptr(".pred\0\0\0");
    mwname_cat_21_();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwword_name_21_();
    mwL0();
    mwCTX();
    mwover2();
    mwTTable();
    mwT1();
    mwdup();
    mwT__3E_();
    mwready2();
    mwover();
    mwword_ctx_type_21_();
    push_u64(0);
    push_fnptr(&mb_table_new_21__4);
    do_pack_cons();
    mwab_build_word_21_();
    mwdrop();
    mwtable_name_3F_();
    push_ptr(".for\0\0\0");
    mwname_cat_21_();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwword_name_21_();
    push_ptr("x\0\0\0");
    mwname_new_21_();
    mwvar_new_21_();
    {
    value_t var_x_557 = pop_value();
    value_t var_w_558 = pop_value();
    value_t var_t_559 = pop_value();
    push_ptr("a\0\0\0");
    mwname_new_21_();
    mwvar_new_implicit_21_();
    mwTYPE_STACK();
    mwover();
    mwvar_type_21_();
    mwdup();
    mwL1();
    mwCTX();
    mwswap();
    mwTVar();
    {
    value_t var_a_560 = pop_value();
    push_value(var_a_560);
    incref(var_a_560);
    push_value(var_a_560);
    incref(var_a_560);
    push_value(var_t_559);
    incref(var_t_559);
    mwTTable();
    mwT_2A_();
    push_value(var_a_560);
    incref(var_a_560);
    mwT__3E_();
    mwT_2A_();
    push_value(var_a_560);
    incref(var_a_560);
    mwT__3E_();
    mwready2();
    push_value(var_w_558);
    incref(var_w_558);
    mwword_ctx_type_21_();
    push_value(var_a_560);
    incref(var_a_560);
    push_value(var_t_559);
    incref(var_t_559);
    mwTTable();
    mwT_2A_();
    push_value(var_a_560);
    incref(var_a_560);
    mwT__3E_();
    push_value(var_x_557);
    incref(var_x_557);
    mwvar_type_21_();
    mwtrue();
    push_value(var_x_557);
    incref(var_x_557);
    mwvar_auto_run_21_();
    decref(var_a_560);
    }
    push_value(var_w_558);
    incref(var_w_558);
    push_u64(0);
    push_value(var_x_557);
    incref(var_x_557);
    do_pack_cons();
    push_value(var_w_558);
    incref(var_w_558);
    do_pack_cons();
    push_value(var_t_559);
    incref(var_t_559);
    do_pack_cons();
    push_fnptr(&mb_table_new_21__9);
    do_pack_cons();
    mwab_build_word_21_();
    mwdrop();
    push_value(var_t_559);
    incref(var_t_559);
    decref(var_x_557);
    decref(var_w_558);
    decref(var_t_559);
    }
    mwtable_name_3F_();
    push_ptr(".alloc!\0\0\0");
    mwname_cat_21_();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwword_name_21_();
    mwL0();
    mwCTX();
    mwT0();
    mwover3();
    mwTTable();
    mwT1();
    mwT__3E_();
    mwready2();
    mwover();
    mwword_ctx_type_21_();
    push_u64(0);
    push_fnptr(&mb_table_new_21__14);
    do_pack_cons();
    mwab_build_word_21_();
    mwdrop();
}

static void mb_table_new_21__14 (void) {
    do_drop();
    mwtable_num_buffer_3F_();
    mwab_buffer_21_();
    mwPRIM_INT_GET();
    mwab_prim_21_();
    push_i64(1LL);
    mwab_int_21_();
    mwPRIM_INT_ADD();
    mwab_prim_21_();
    mwPRIM_CORE_DUP();
    mwab_prim_21_();
    mwtable_num_buffer_3F_();
    mwab_buffer_21_();
    mwPRIM_INT_SET();
    mwab_prim_21_();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
}
static void mwover3 (void){
    { value_t d1 = pop_value();
    mwover2();
      push_value(d1); }
    mwswap();
}

static void mb_table_new_21__9 (void) {
    do_pack_uncons();
    value_t var_t_559 = pop_value();
    do_pack_uncons();
    value_t var_w_558 = pop_value();
    do_pack_uncons();
    value_t var_x_557 = pop_value();
    do_drop();
    push_value(var_x_557);
    incref(var_x_557);
    mwVar__3E_Param();
    mwL1();
    push_u64(0);
    push_value(var_x_557);
    incref(var_x_557);
    do_pack_cons();
    push_value(var_w_558);
    incref(var_w_558);
    do_pack_cons();
    push_value(var_t_559);
    incref(var_t_559);
    do_pack_cons();
    push_fnptr(&mb_table_new_21__10);
    do_pack_cons();
    mwab_lambda_21_();
    decref(var_t_559);
    decref(var_w_558);
    decref(var_x_557);
}
static void mb_table_new_21__10 (void) {
    do_pack_uncons();
    value_t var_t_559 = pop_value();
    do_pack_uncons();
    value_t var_w_558 = pop_value();
    do_pack_uncons();
    value_t var_x_557 = pop_value();
    do_drop();
    push_i64(1LL);
    mwab_int_21_();
    push_u64(0);
    push_value(var_x_557);
    incref(var_x_557);
    do_pack_cons();
    push_value(var_w_558);
    incref(var_w_558);
    do_pack_cons();
    push_value(var_t_559);
    incref(var_t_559);
    do_pack_cons();
    push_fnptr(&mb_table_new_21__11);
    do_pack_cons();
    push_u64(0);
    push_value(var_x_557);
    incref(var_x_557);
    do_pack_cons();
    push_value(var_w_558);
    incref(var_w_558);
    do_pack_cons();
    push_value(var_t_559);
    incref(var_t_559);
    do_pack_cons();
    push_fnptr(&mb_table_new_21__13);
    do_pack_cons();
    mwab_while_21_();
    mwPRIM_CORE_DROP();
    mwab_prim_21_();
    decref(var_t_559);
    decref(var_w_558);
    decref(var_x_557);
}
static void mb_table_new_21__13 (void) {
    do_pack_uncons();
    value_t var_t_559 = pop_value();
    do_pack_uncons();
    value_t var_w_558 = pop_value();
    do_pack_uncons();
    value_t var_x_557 = pop_value();
    do_drop();
    mwPRIM_CORE_DUP();
    mwab_prim_21_();
    push_value(var_t_559);
    incref(var_t_559);
    mwtable_num_buffer_40_();
    mwab_buffer_21_();
    mwPRIM_INT_GET();
    mwab_prim_21_();
    mwPRIM_VALUE_LE();
    mwab_prim_21_();
    decref(var_t_559);
    decref(var_w_558);
    decref(var_x_557);
}
static void mb_table_new_21__11 (void) {
    do_pack_uncons();
    value_t var_t_559 = pop_value();
    do_pack_uncons();
    value_t var_w_558 = pop_value();
    do_pack_uncons();
    value_t var_x_557 = pop_value();
    do_drop();
    mwPRIM_CORE_DUP();
    mwab_prim_21_();
    push_u64(0);
    push_value(var_x_557);
    incref(var_x_557);
    do_pack_cons();
    push_value(var_w_558);
    incref(var_w_558);
    do_pack_cons();
    push_value(var_t_559);
    incref(var_t_559);
    do_pack_cons();
    push_fnptr(&mb_table_new_21__12);
    do_pack_cons();
    mwab_dip_21_();
    push_i64(1LL);
    mwab_int_21_();
    mwPRIM_INT_ADD();
    mwab_prim_21_();
    decref(var_t_559);
    decref(var_w_558);
    decref(var_x_557);
}
static void mb_table_new_21__12 (void) {
    do_pack_uncons();
    value_t var_t_559 = pop_value();
    do_pack_uncons();
    value_t var_w_558 = pop_value();
    do_pack_uncons();
    value_t var_x_557 = pop_value();
    do_drop();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
    push_value(var_x_557);
    incref(var_x_557);
    mwab_var_21_();
    decref(var_t_559);
    decref(var_w_558);
    decref(var_x_557);
}
static void mwab_dip_21_ (void){
    {
    value_t var_f_547 = pop_value();
    push_value(var_f_547);
    incref(var_f_547);
    mwab_block_21_();
    mwPRIM_CORE_DIP();
    mwab_prim_21_();
    decref(var_f_547);
    }
}

static void mwab_block_21_ (void){
    {
    value_t var_f_544 = pop_value();
    mwab_token_40_();
    push_value(var_f_544);
    incref(var_f_544);
    mwab_block_at_21_();
    decref(var_f_544);
    }
}

static void mwab_block_at_21_ (void){
    {
    value_t var_f_541 = pop_value();
    mwBlock_2E_alloc_21_();
    { value_t d2 = pop_value();
    mwab_ctx_40_();
    mwmeta_alloc_21_();
    mwTMeta();
    mwrotl();
    push_value(var_f_541);
    incref(var_f_541);
    mwab_build_21_();
      push_value(d2); }
    mwtuck();
    mwblock_arrow_raw_21_();
    mwOP_BLOCK();
    mwab_op_21_();
    decref(var_f_541);
    }
}

static void mwab_while_21_ (void){
    { value_t d1 = pop_value();
    mwab_block_21_();
      push_value(d1); }
    mwab_block_21_();
    mwPRIM_CORE_WHILE();
    mwab_prim_21_();
}

static void mwab_lambda_21_ (void){
    {
    value_t var_f_556 = pop_value();
    mwLambda_2E_alloc_21_();
    mwab_ctx_40_();
    mwover();
    mwlambda_outer_ctx_21_();
    mwab_type_40_();
    mwover();
    mwlambda_dom_21_();
    mwab_token_40_();
    mwover();
    mwlambda_token_21_();
    mwdup2();
    mwlambda_params_21_();
    { value_t d2 = pop_value();
    mwab_ctx_40_();
    mwab_type_40_();
    mwrotl();
    push_u64(0);
    push_value(var_f_556);
    incref(var_f_556);
    do_pack_cons();
    push_fnptr(&mb_ab_lambda_21__3);
    do_pack_cons();
    mwfor();
      push_value(d2); }
    mwtuck();
    mwlambda_mid_21_();
    mwtuck();
    mwlambda_inner_ctx_21_();
    mwlambda_inner_ctx_3F_();
    mwover();
    mwlambda_mid_40_();
    mwab_token_40_();
    push_u64(0);
    push_value(var_f_556);
    incref(var_f_556);
    do_pack_cons();
    push_fnptr(&mb_ab_lambda_21__5);
    do_pack_cons();
    mwab_build_21_();
    mwover();
    mwlambda_body_21_();
    mwOP_LAMBDA();
    mwab_op_21_();
    decref(var_f_556);
    }
}

static void mb_ab_lambda_21__5 (void) {
    do_pack_uncons();
    value_t var_f_556 = pop_value();
    do_drop();
    { value_t d1 = pop_value();
    push_value(var_f_556);
    incref(var_f_556);
    do_run();
      push_value(d1); }
    mwab_type_40_();
    mwover();
    mwlambda_cod_21_();
    decref(var_f_556);
}
static void mb_ab_lambda_21__3 (void) {
    do_pack_uncons();
    value_t var_f_556 = pop_value();
    do_drop();
    mwswap();
    { value_t d1 = pop_value();
    mwParam__3E_Var();
    mwctx_new_21_();
      push_value(d1); }
    mwab_token_40_();
    mwelab_expand_tensor_21_();
    mwdrop2();
    decref(var_f_556);
}
static void mb_table_new_21__4 (void) {
    do_drop();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
    mwPRIM_CORE_DUP();
    mwab_prim_21_();
    push_i64(0LL);
    mwab_int_21_();
    mwPRIM_VALUE_EQ();
    mwab_prim_21_();
    push_u64(0);
    push_fnptr(&mb_table_new_21__5);
    do_pack_cons();
    push_u64(0);
    push_fnptr(&mb_table_new_21__6);
    do_pack_cons();
    mwab_if_21_();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
}
static void mb_table_new_21__6 (void) {
    do_drop();
    mwid();
}
static void mb_table_new_21__5 (void) {
    do_drop();
    push_i64(1LL);
    mwab_int_21_();
    mwPRIM_INT_SUB();
    mwab_prim_21_();
}
static void mwab_if_21_ (void){
    { value_t d1 = pop_value();
    mwab_block_21_();
      push_value(d1); }
    mwab_block_21_();
    mwPRIM_CORE_IF();
    mwab_prim_21_();
}

static void mb_table_new_21__3 (void) {
    do_drop();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
    push_i64(1LL);
    mwab_int_21_();
    mwPRIM_INT_ADD();
    mwab_prim_21_();
    mwtable_num_buffer_3F_();
    mwab_buffer_21_();
    mwPRIM_INT_GET();
    mwab_prim_21_();
    push_i64(1LL);
    mwab_int_21_();
    mwPRIM_INT_ADD();
    mwab_prim_21_();
    mwPRIM_INT_MOD();
    mwab_prim_21_();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
}
static void mb_table_new_21__2 (void) {
    do_drop();
    mwPRIM_UNSAFE_CAST();
    mwab_prim_21_();
}
static void mwover2 (void){
    { value_t d1 = pop_value();
    mwover();
      push_value(d1); }
    mwswap();
}

static value_t* fieldptr_table_num_buffer (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwtable_num_buffer_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_table_num_buffer(index);
    incref(v); push_value(v);
}
static void mwtable_num_buffer_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_table_num_buffer(index);
    incref(v); push_value(v);
}
static void mwtable_num_buffer_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_table_num_buffer(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwbuffer_new_21_ (void){
    mwBuffer_2E_alloc_21_();
    mwtuck();
    mwbuffer_size_21_();
    mwtuck();
    mwdup2();
    mwbuffer_name_21_();
    mwDEF_BUFFER();
    mwswap();
    mwname_def_21_();
}

static void mwBuffer_2E_alloc_21_ (void){
    mwBuffer_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwBuffer_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mb_table_new_21__1 (void) {
    do_drop();
    mwTABLE_MAX_SIZE();
    mwab_int_21_();
}
static void mwab_build_word_21_ (void){
    {
    value_t var_f_538 = pop_value();
    mwdup();
    mwab_home_21_();
    push_i64(0LL);
    mwab_homeidx_21_();
    mwdup();
    { value_t d2 = pop_value();
    mwelab_word_ctx_sig_21_();
      push_value(d2); }
    mwword_body_3F_();
    mwswap();
    { value_t d2 = pop_value();
    mwelab_expand_morphism_21_();
    mwswap();
      push_value(d2); }
    { value_t d2 = pop_value();
    { value_t d3 = pop_value();
    push_value(var_f_538);
    incref(var_f_538);
    mwab_build_21_();
      push_value(d3); }
    mwover();
    mwarrow_cod_3F_();
    mwswap();
    mwarrow_token_end_40_();
    mwelab_type_unify_21_();
    mwdrop2();
    mwready();
      push_value(d2); }
    mwtuck();
    mwword_arrow_21_();
    mwnil();
    mwab_home_21_();
    decref(var_f_538);
    }
}

static void mwready (void){
    mwLP_READY();
    mwmut();
    mwLAZY();
}

static void mwmut (void){
    mwprim_2E_mut_2E_new();
}

static value_t* fieldptr_word_body (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwword_body_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_body(index);
    incref(v); push_value(v);
}
static void mwword_body_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_body(index);
    incref(v); push_value(v);
}
static void mwword_body_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_word_body(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwab_home_21_ (void){
    mwAB_HOME();
    mwvalue_21_();
}

static void mwready2 (void){
    mwpack2();
    mwready();
}

static void mwWord_2E_alloc_21_ (void){
    mwWord_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwWord_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mwTABLE_MAX_SIZE (void){
    push_i64(131072LL);
}

static void mwTable_2E_alloc_21_ (void){
    mwTable_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwTable_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mb_init_prims_21__5 (void) {
    do_drop();
    mwelab_buffer_21_();
}
static void mwelab_buffer_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_2();
    mwswap();
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_name_3F_();
    mwname_undefined_3F_();
    if (pop_u64()) {
    mwnip();
    mwswap();
    mwtoken_int_40_();
    mwbuffer_new_21_();
    mwdrop();
    } else {
    mwdrop();
    push_ptr("buffer already defined\0\0\0");
    mwemit_fatal_error_21_();
    }
    } else {
    push_ptr("expected buffer name\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwtoken_int_40_ (void){
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 8LL:
    do_pack_uncons(); do_drop();
    mwnip();
    break;
    default:
    mwdrop();
    push_ptr("expected int\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static void mb_init_prims_21__4 (void) {
    do_drop();
    mwelab_def_type_21_();
}
static void mwelab_def_type_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_2();
    mwswap();
    mwsig_token_is_type_con_3F_();
    if (pop_u64()) {
    mwtoken_name_3F_();
    mwname_undefined_3F_();
    if (pop_u64()) {
    mwnip();
    mwswap();
    mwelab_simple_type_arg_21_();
    mwDEF_TYPE();
    mwswap();
    mwname_def_21_();
    } else {
    mwdrop();
    push_ptr("type already defined\0\0\0");
    mwemit_fatal_error_21_();
    }
    } else {
    push_ptr("expected type constructor\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mb_init_prims_21__3 (void) {
    do_drop();
    mwelab_def_external_21_();
}
static void mwelab_def_external_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_2();
    mwswap();
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwtoken_name_3F_();
    mwname_undefined_3F_();
    if (pop_u64()) {
    mwnip();
    mwExternal_2E_alloc_21_();
    mwdup2();
    mwDEF_EXTERNAL();
    mwswap();
    mwname_def_21_();
    mwtuck();
    mwexternal_name_21_();
    mwexternal_sig_21_();
    } else {
    mwdrop();
    push_ptr("word already defined\0\0\0");
    mwemit_fatal_error_21_();
    }
    } else {
    push_ptr("expected word name\0\0\0");
    mwemit_fatal_error_21_();
    }
}

static void mwExternal_2E_alloc_21_ (void){
    mwExternal_2E_NUM();
    mwprim_2E_int_2E_get();
    push_i64(1LL);
    mwprim_2E_int_2E_add();
    mwprim_2E_core_2E_dup();
    mwExternal_2E_NUM();
    mwprim_2E_int_2E_set();
    mwprim_2E_unsafe_2E_cast();
}

static void mb_init_prims_21__2 (void) {
    do_drop();
    mwelab_def_21_();
}
static void mwelab_def_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_3();
    mwrotl();
    mwtoken_is_name_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    push_ptr("expected word name\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwtoken_name_3F_();
    mwname_undefined_3F_();
    if (pop_u64()) {
    mwid();
    } else {
    mwdrop();
    push_ptr("word already defined\0\0\0");
    mwemit_fatal_error_21_();
    }
    mwnip();
    mwWord_2E_alloc_21_();
    mwdup2();
    mwDEF_WORD();
    mwswap();
    mwname_def_21_();
    mwdup();
    { value_t d1 = pop_value();
    mwword_name_21_();
      push_value(d1); }
    mwdup();
    { value_t d1 = pop_value();
    mwword_body_21_();
      push_value(d1); }
    mwdup();
    { value_t d1 = pop_value();
    mwword_sig_21_();
      push_value(d1); }
    mwdup();
    push_u64(0);
    push_fnptr(&mb_elab_def_21__9);
    do_pack_cons();
    mwdelay();
    mwdup2();
    mwswap();
    mwword_ctx_type_21_();
    mwover();
    push_u64(0);
    push_fnptr(&mb_elab_def_21__11);
    do_pack_cons();
    mwdelay2();
    mwswap();
    mwword_arrow_21_();
}

static void mb_elab_def_21__11 (void) {
    do_drop();
    mwdup();
    mwab_home_21_();
    push_i64(0LL);
    mwab_homeidx_21_();
    { value_t d1 = pop_value();
    mwforce2();
      push_value(d1); }
    mwword_body_40_();
    mwelab_arrow_21_();
    mwnil();
    mwab_home_21_();
}
static void mwdelay2 (void){
    mwpack3();
    push_u64(0);
    push_fnptr(&mb_delay2_1);
    do_pack_cons();
    mwdelay();
}

static void mb_delay2_1 (void) {
    do_drop();
    mwunpack3();
    mwrun();
}
static void mwunpack3 (void){
    mwpack_uncons();
    { value_t d1 = pop_value();
    mwunpack2();
      push_value(d1); }
}

static void mwpack3 (void){
    { value_t d1 = pop_value();
    mwpack2();
      push_value(d1); }
    mwpack_cons();
}

static void mb_elab_def_21__9 (void) {
    do_drop();
    mwtype_elab_default();
    mwswap();
    mwword_sig_40_();
    mwelab_type_sig_21_();
    mwdrop();
    { value_t d1 = pop_value();
    mwtype_elab_ctx();
      push_value(d1); }
    mwpack2();
}
static void mwdelay (void){
    mwLP_THUNK();
    mwmut();
    mwLAZY();
}

static value_t* fieldptr_word_sig (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwword_sig_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_sig(index);
    incref(v); push_value(v);
}
static void mwword_sig_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_word_sig(index);
    incref(v); push_value(v);
}
static void mwword_sig_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_word_sig(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mb_init_prims_21__1 (void) {
    do_drop();
    mwelab_module_import_21_();
}
static void mwelab_module_import_21_ (void){
    mwdup();
    { value_t d1 = pop_value();
    mwtoken_next();
      push_value(d1); }
    mwtoken_args_1();
    mwtoken_value_3F_();
    switch (get_top_data_tag()) {
    case 10LL:
    do_pack_uncons(); do_drop();
    mwname_def_3F_();
    switch (get_top_data_tag()) {
    case 1LL:
    do_pack_uncons(); do_drop();
    { value_t d3 = pop_value();
    mwdrop2();
    mwtoken_module_3F_();
      push_value(d3); }
    mwmodule_add_import_21_();
    break;
    case 0LL:
    do_drop();
    mwmodule_path_from_name();
    mwrun_lexer_21_();
    mwelab_module_21_();
    { value_t d3 = pop_value();
    mwdrop();
    mwtoken_module_3F_();
      push_value(d3); }
    mwmodule_add_import_21_();
    break;
    default:
    mwdrop2();
    push_ptr("module name already taken\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
    break;
    default:
    mwdrop();
    push_ptr("expected module name\0\0\0");
    mwemit_fatal_error_21_();
    break;
    }
}

static void mwmodule_add_import_21_ (void){
    { value_t d1 = pop_value();
    mwmodule_imports_3F_();
      push_value(d1); }
    mwset_insert();
    mwswap();
    mwmodule_imports_21_();
}

static void mwset_insert (void){
    { value_t d1 = pop_value();
    mwunSET();
      push_value(d1); }
    mwbag_replace();
    mwSET();
}

static void mwbag_replace (void){
    mwbag_has_3F_();
    if (pop_u64()) {
    mwdrop();
    } else {
    mwbag_insert();
    }
}

static void mwbag_insert (void){
    mwbag_insert_2B_();
    mwBag_2B___3E_Bag();
}

static void mwbag_insert_2B_ (void){
    mwswap();
    mwBag__3E_Bag_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwB1_2B_();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwbag_insert_2B__2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwbag_insert_2B__2B_ (void){
    mwover();
    mwbag_is_singleton_2B_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwbag_first_2B_();
      push_value(d2); }
    mwB2_2B_();
    } else {
    { value_t d2 = pop_value();
    mwbag_split_half_right();
      push_value(d2); }
    mwover();
    mwbag_first_2B_();
    mwdup2();
    mw_3E__3D_();
    if (pop_u64()) {
    mwdrop();
    mwbag_insert_2B__2B_();
    mwbag_cat_unsafe__2B_();
    } else {
    mwdrop();
    mwswap();
    { value_t d3 = pop_value();
    mwbag_insert_2B_();
      push_value(d3); }
    mwbag_cat_unsafe_2B_();
    }
    }
}

static void mwbag_has_3F_ (void){
    mwdup2();
    mwbag_has();
}

static void mwbag_has (void){
    mwswap();
    mwBag__3E_Bag_2B_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop();
    mwfalse();
    break;
    case 1LL:
    do_pack_uncons(); do_drop();
    mwswap();
    mwbag_has_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
}

static void mwbag_has_2B_ (void){
    mwover();
    mwbag_is_singleton_2B_();
    if (pop_u64()) {
    { value_t d2 = pop_value();
    mwbag_first_2B_();
      push_value(d2); }
    mw_3D__3D_();
    } else {
    { value_t d2 = pop_value();
    mwbag_split_half_right();
      push_value(d2); }
    mwover();
    mwbag_first_2B_();
    mwcmp_3F_();
    switch (get_top_data_tag()) {
    case 0LL:
    do_drop();
    mwdrop4();
    mwtrue();
    break;
    case 1LL:
    do_drop();
    mwdrop();
    mwnip();
    mwbag_has();
    break;
    case 2LL:
    do_drop();
    mwdrop();
    { value_t d3 = pop_value();
    mwnip();
      push_value(d3); }
    mwbag_has_2B_();
    break;
    default: write(2, "unexpected fallthrough in match\n", 32); do_debug(); exit(99);
    }
    }
}

static void mwdrop4 (void){
    mwdrop();
    mwdrop();
    mwdrop();
    mwdrop();
}

static void mwunSET (void){
    mwid();
}

static value_t* fieldptr_module_imports (usize i) {
    static struct value_t * p;
    static usize n = 0; 
    if (i >= n) {
        usize new_n = n+1;
        while (i >= new_n) new_n *= 2;
        p = realloc(p, sizeof(struct value_t) * new_n);
        memset(p+n, 0, sizeof(struct value_t) * (new_n - n));
        n = new_n;
    }
    return p+i;
}

static void mwmodule_imports_40_ (void){
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_imports(index);
    incref(v); push_value(v);
}
static void mwmodule_imports_3F_ (void){
    mwdup();
    usize index = (usize)pop_u64();
    value_t v = *fieldptr_module_imports(index);
    incref(v); push_value(v);
}
static void mwmodule_imports_21_ (void){
    usize index = (usize)pop_u64();
    value_t newvalue = pop_value();
    value_t* p = fieldptr_module_imports(index);
    value_t oldvalue = *p;
    *p = newvalue;
    decref(oldvalue);
}

static void mwdef_prim_21_ (void){
    mwname_new_21_();
    mwdup2();
    { value_t d1 = pop_value();
    mwDEF_PRIM();
      push_value(d1); }
    mwname_def_21_();
    mwswap();
    mwprim_name_21_();
}

static void mwinit_paths_21_ (void){
    push_ptr("src\0\0\0");
    mwStr__3E_Path();
    mwsource_path_root_21_();
    push_ptr("bin\0\0\0");
    mwStr__3E_Path();
    mwoutput_path_root_21_();
}

static void mwoutput_path_root_21_ (void){
    mwOUTPUT_PATH_ROOT();
    mwpath_21_();
}

static void mwpath_21_ (void){
    { value_t d1 = pop_value();
    mwPath__3E_Str();
    mwStr__3E_Ptr();
      push_value(d1); }
    mwptr_21_();
}

static void mwptr_21_ (void){
    mwprim_2E_ptr_2E_set();
}

static void mwsource_path_root_21_ (void){
    mwSOURCE_PATH_ROOT();
    mwpath_21_();
}

