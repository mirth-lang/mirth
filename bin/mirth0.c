#define MIRTH_DEBUG 0
/* MIRTH HEADER */
// #line 3 "src/mirth.h"

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#define MIRTH_WINDOWS 1
#elif defined(__linux__)
#define MIRTH_LINUX 1
#elif defined(__APPLE__)
#define MIRTH_MACOS 1
#else
#error "Platform not supported."
#endif

#if defined(__x86_64__) || defined(_M_X64)
#define MIRTH_AMD64
#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)
#define MIRTH_I386
#elif defined(__aarch64__) || defined(_M_ARM64)
#define MIRTH_ARM64
#else
#error "Architecture not supported."
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <float.h>

extern void* malloc(size_t);
extern void* calloc(size_t, size_t);
extern void* realloc(void*, size_t);
extern void* memset(void*, int, size_t);
extern void* memcpy(void*, const void*, size_t);
extern int memcmp(const void*, const void*, size_t);
extern int strcmp(const char*, const char*);
extern size_t strlen(const char*);
extern void free(void*);
extern int read(int, void*, size_t);
extern int write(int, const char*, size_t);
extern int close(int);
extern int open(const char*, int, ...);
extern void exit(int);
extern int sprintf (char * s, const char * format, ...);

typedef uint16_t TAG;
#define REFS_FLAG 	 0x8000
#define TUP_FLAG 	 0x4000
#define TUP_LEN_MASK 0x3FFF
#define TUP_LEN_MAX  0x3FFF

#define TAG_INT 1
#define TAG_PTR 1
#define TAG_STR (2 | REFS_FLAG)
#define TAG_FNPTR 3
#define TAG_F32 4
#define TAG_F64 5
#define TAG_TUP_NIL TUP_FLAG
#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)
#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (TAG)(n))

typedef uint32_t REFS;
typedef uint64_t USIZE;
typedef void (*FNPTR)(void);

typedef union DATA {
	USIZE usize;
	uint64_t u64;
	uint32_t u32;
	uint16_t u16;
	uint8_t u8;
	int64_t i64;
	int32_t i32;
	int16_t i16;
	int8_t i8;
	float f32;
	double f64;
	void* ptr;
	FNPTR fnptr;
	REFS* refs;
	struct TUP* tup;
	struct STR* str;
} DATA;

typedef struct VAL {
	DATA data;
	TAG tag;
} VAL;

#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))

#define VREFS(v)  (*(v).data.refs)
#define VVAL(v)   (v)
#define VINT(v)   ((v).data.i64)
#define VI64(v)   ((v).data.i64)
#define VI32(v)   ((v).data.i32)
#define VI16(v)   ((v).data.i16)
#define VI8(v)    ((v).data.i8)
#define VU64(v)   ((v).data.u64)
#define VU32(v)   ((v).data.u32)
#define VU16(v)   ((v).data.u16)
#define VU8(v)    ((v).data.u8)
#define VBOOL(v)  ((_Bool)((v).data.u64))
#define VF32(v)   ((v).data.f32)
#define VF64(v)   ((v).data.f64)
#define VPTR(v)   ((v).data.ptr)
#define VFNPTR(v) ((v).data.fnptr)
#define VSTR(v)   ((v).data.str)
#define VTUP(v)   ((v).data.tup)
#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))

#define HAS_REFS(v) ((v).tag & REFS_FLAG)
#define IS_VAL(v)   (1)
#define IS_INT(v)   ((v).tag == TAG_INT)
#define IS_I64(v)   ((v).tag == TAG_INT)
#define IS_U64(v)   ((v).tag == TAG_INT)
#define IS_BOOL(v)  ((v).tag == TAG_INT)
#define IS_F32(v)   ((v).tag == TAG_F32)
#define IS_F64(v)   ((v).tag == TAG_F64)
#define IS_PTR(v)   ((v).tag == TAG_PTR)
#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)
#define IS_STR(v)   ((v).tag == TAG_STR)
#define IS_TUP(v)   ((v).tag & TUP_FLAG)
#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))

#define MKVAL(x)   (x)
#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI32(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI16(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI8(x)    ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKU32(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKU16(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKU8(x)    ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKBOOL(x)  ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKF32(x)   ((VAL){.tag=TAG_F32, .data={.f32=(x)}})
#define MKF64(x)   ((VAL){.tag=TAG_F64, .data={.f64=(x)}})
#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})
#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})
#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})
#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})
#define MKNIL_C	         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}
#define MKNIL      ((VAL)MKNIL_C)

#define STRLIT(v,x,n) \
	do { \
		static STR* mval = 0; \
		if (!mval) mval = str_make(x,n); \
		incref(MKSTR(mval)); \
		v = mval; \
	} while(0)

typedef uint16_t TUPLEN;
typedef struct TUP {
	REFS refs;
	TUPLEN cap;
	TUPLEN size;
	VAL cells[];
} TUP;

typedef struct STR {
	REFS refs;
	USIZE cap;
	USIZE size;
	char data[];
} STR;

#define STACK_MAX 0x80000
static USIZE stack_counter = STACK_MAX;
static VAL stack [STACK_MAX] = {0};
static USIZE rstack_counter = STACK_MAX;
static VAL rstack [STACK_MAX] = {0};

static int global_argc;
static char** global_argv;

static void push_value(VAL v);
static void trace_stack(void);
static void trace_rstack(void);

#if MIRTH_DEBUG
	typedef struct LOC {
		const char* word;
		const char* path;
		USIZE line, col;
		const char* atom;
	} LOC;
	static USIZE fstack_counter = 0;
	static LOC fstack [STACK_MAX] = {
		{
			.word="<word>",
			.path="<path>",
			.line=0, .col=0,
			.atom="<atom>"
		},
	};

	#define WORD_ENTER(_w,_p,_l,_c) \
		do { \
			fstack[fstack_counter].word = (_w); \
			fstack[fstack_counter].path = (_p); \
			fstack[fstack_counter].line = (_l); \
			fstack[fstack_counter].col = (_c); \
			fstack[fstack_counter].atom = ""; \
			fstack_counter++; \
		} while(0)

	#define WORD_ATOM(_l,_c,_n) \
		do { \
			if (fstack_counter > 0) { \
				fstack[fstack_counter-1].line = (_l); \
				fstack[fstack_counter-1].col = (_c); \
				fstack[fstack_counter-1].atom = (_n); \
			} \
		} while(0)

	#define WORD_EXIT \
		do { \
			if (fstack_counter == 0) { \
				TRACE("mismatched WORD_EXIT\n"); \
				exit(1); \
			} \
			fstack_counter--; \
		} while(0)
#endif

#define TRACE(x) write(2,x,strlen(x))
#define _STR(x) #x
#define STR(x) _STR(x)

#define EXPECT(test,msg) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			trace_stack(); \
			trace_rstack(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT1(test,msg,v1) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			trace_stack(); \
			trace_rstack(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT2(test,msg,v1,v2) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			push_value(v2); \
			trace_stack(); \
			trace_rstack(); \
			exit(1); \
		} \
	} while(0)

#define ASSERT(test) \
	EXPECT(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")")
#define ASSERT1(test,v) \
	EXPECT1(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v)
#define ASSERT2(test,v1,v2) \
	EXPECT2(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v1, v2)

#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)
#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)
static void free_value(VAL v) {
	ASSERT(HAS_REFS(v));
	ASSERT(VREFS(v) == 0);
	ASSERT1(IS_TUP(v)||IS_STR(v), v);
	if (IS_TUP(v)) {
		TUP* tup = VTUP(v);
		ASSERT(tup);
		for (TUPLEN i = 0; i < tup->size; i++) {
			decref(tup->cells[i]);
		}
		free(tup);
	} else if (IS_STR(v)) {
		STR* str = VSTR(v);
		ASSERT(str);
		free(str);
	}
}

static void tup_decref_outer(TUP* tup, size_t n) {
	if (tup->refs == 1) {
		for (size_t i = n; i < tup->size; i++) {
			decref(tup->cells[i]);
		}
		free(tup);
	} else {
		for (size_t i = 0; i < n; i++) {
			incref(tup->cells[i]);
		}
		if (!--tup->refs) free_value(MKTUP(tup,n));
	}
}

static void value_uncons(VAL val, VAL* tail, VAL* head) {
	if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		ASSERT1((len > 0) && tup, val);
		VAL tailval = MKTUP(tup, len-1);
		VAL headval = tup->cells[len-1];
		if (len == 1) {
			incref(headval);
			decref(val);
			tailval = MKNIL;
		} else {
			if (tup->refs == 1) {
				for (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }
				memset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));
				tup->size = len-1;
			} else {
				incref(headval);
			}
			if (len == 2) {
				VAL ptval = tup->cells[0];
				if (!IS_TUP(ptval)) {
					incref(ptval);
					decref(tailval);
					tailval = ptval;
				}
			}
		}
		*tail = tailval;
		*head = headval;
	} else {
		*tail = MKNIL;
		*head = val;
	}
}

static uint64_t value_u64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VU64(v);
}

static int64_t value_i64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VI64(v);
}

static float value_f32 (VAL v) {
	ASSERT1(IS_F32(v), v);
	return VF32(v);
}

static double value_f64 (VAL v) {
	ASSERT1(IS_F64(v), v);
	return VF64(v);
}

static void* value_ptr (VAL v) {
	ASSERT1(IS_PTR(v),v);
	return VPTR(v);
}

static FNPTR value_fnptr (VAL v) {
	ASSERT1(IS_FNPTR(v),v);
	return VFNPTR(v);
}

static STR* value_str (VAL v) {
	ASSERT1(IS_STR(v),v);
	return VSTR(v);
}

#define pop_u8() ((uint8_t)pop_u64())
#define pop_u16() ((uint16_t)pop_u64())
#define pop_u32() ((uint32_t)pop_u64())
#define pop_u64() (value_u64(pop_value()))
#define pop_i8() ((int8_t)pop_i64())
#define pop_i16() ((int16_t)pop_i64())
#define pop_i32() ((int32_t)pop_i64())
#define pop_i64() (value_i64(pop_value()))
#define pop_usize() (pop_u64())
#define pop_f32() (value_f32(pop_value()))
#define pop_f64() (value_f64(pop_value()))
#define pop_bool() ((bool)pop_u64())
#define pop_str() (value_str(pop_value()))
#define pop_ptr() (value_ptr(pop_value()))
#define pop_fnptr() (value_fnptr(pop_value()))

#define push_u64(v) push_value(MKU64(v))
#define push_i64(v) push_value(MKI64(v))
#define push_usize(v) push_u64((uint64_t)(v))
#define push_bool(b) push_u64((uint64_t)((bool)(b)))
#define push_u8(b) push_u64((uint64_t)(b))
#define push_u16(b) push_u64((uint64_t)(b))
#define push_u32(b) push_u64((uint64_t)(b))
#define push_i8(b) push_i64((int64_t)(b))
#define push_i16(b) push_i64((int64_t)(b))
#define push_i32(b) push_i64((int64_t)(b))
#define push_f32(f) push_value(MKF32(f))
#define push_f64(f) push_value(MKF64(f))
#define push_str(p) push_value(MKSTR(p))
#define push_ptr(p) push_value(MKPTR(p))
#define push_fnptr(p) push_value(MKFNPTR(p))

static void push_value(VAL x) {
	ASSERT(stack_counter > 0);
	stack[--stack_counter] = x;
}

static VAL top_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter];
}

static VAL pop_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter++];
}

static void push_resource(VAL x) {
	ASSERT(rstack_counter > 0);
	rstack[--rstack_counter] = x;
}

static VAL top_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter];
}

static VAL pop_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter++];
}

// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.
static TUP* tup_new (TUPLEN cap_hint) {
	if (cap_hint < 3) cap_hint = 3;
	if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
	TUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
	ASSERT(new_tup);
	new_tup->refs = 1;
	new_tup->cap = cap_hint;
	return new_tup;
}

// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.
// Consume old_tup and copy its elements over to the new tuple.
static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {
	ASSERT(old_tup);
	if (cap_hint < old_tup->size) cap_hint = old_tup->size;
	if (old_tup->refs == 1) {
		if (cap_hint < 3) cap_hint = 3;
		if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
		TUPLEN old_cap = old_tup->cap;
		TUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
		ASSERT(new_tup);
		if (old_cap < cap_hint) {
			memset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));
		}
		new_tup->cap = cap_hint;
		return new_tup;
	} else {
		TUP* new_tup = tup_new(cap_hint);
		for (TUPLEN i = 0; i < old_tup->size; i++) {
			VAL v = old_tup->cells[i];
			new_tup->cells[i] = v;
			incref(v);
		}
		new_tup->size = old_tup->size;
		old_tup->refs--;
		return new_tup;
	}
}

static VAL tup_replace (VAL tup, TUPLEN i, VAL v) {
	ASSERT(IS_TUP(tup));
	TUPLEN n = VTUPLEN(tup);
	ASSERT(i < n);
	if (VTUP(tup)->refs > 1) {
		TUP* newtup = tup_new(n);
		newtup->size = n;
		memcpy(newtup->cells, VTUP(tup)->cells, n*sizeof(VAL));
		for (TUPLEN j=0; j<n; j++) incref(newtup->cells[j]);
		decref(tup);
		tup = MKTUP(newtup, n);
	}
	VAL u = VTUP(tup)->cells[i];
	VTUP(tup)->cells[i] = v;
	decref(u);
	return tup;
}

static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {
	if (IS_TUP(tail) && HAS_REFS(tail)) {
		TUPLEN tail_len = VTUPLEN(tail);
		TUP *tail_tup = VTUP(tail);
		ASSERT1(tail_tup, tail);
		ASSERT1(tail_len <= tail_tup->size, tail);
		if (tail_len < tail_tup->size) {
			ASSERT1(tail_tup->refs >= 1, tail);
			if (tail_tup->refs == 1) {
				decref(tail_tup->cells[tail_len]);
				tail_tup->cells[tail_len] = head;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				VAL *cmp = &tail_tup->cells[tail_len];
				if (VALEQ(*cmp, head)) {
					decref(head);
					return MKTUP(tail_tup, tail_len+1);
				} else {
					if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
					TUP* new_tup = tup_new(cap_hint);
					for (TUPLEN i = 0; i < tail_len; i++) {
						VAL v = tail_tup->cells[i];
						new_tup->cells[i] = v;
						incref(v);
					}
					new_tup->cells[tail_len] = head;
					new_tup->size = tail_len+1;
					tail_tup->refs--;
					return MKTUP(new_tup, tail_len+1);
				}
			}
		} else {
			ASSERT1(tail_len < TUP_LEN_MAX, tail);
			ASSERT1(tail_len <= tail_tup->cap, tail);
			if (tail_len < tail_tup->cap) {
				tail_tup->cells[tail_len] = head;
				tail_tup->size = tail_len+1;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
				TUP* new_tup = tup_resize(tail_tup, cap_hint);
				ASSERT(tail_len < new_tup->cap);
				new_tup->size = tail_len+1;
				new_tup->cells[tail_len] = head;
				return MKTUP(new_tup, tail_len+1);
			}
		}
	} else if (IS_TUP(tail)) { // cons onto nil
		ASSERT(IS_NIL(tail));
		if (IS_TUP(head)) {
			TUP* tup = tup_new(cap_hint);
			tup->size = 1;
			tup->cells[0] = head;
			return MKTUP(tup,1);
		} else { // non-tup value pretends to be unary tuple
			return head;
		}
	} else { // cons onto non-tup value pretending to be unary tuple
		TUP* tup = tup_new(cap_hint);
		tup->size = 2;
		tup->cells[0] = tail;
		tup->cells[1] = head;
		return MKTUP(tup,2);
	}
}
static VAL mkcons(VAL tail, VAL head) {
	VAL v = mkcons_hint(tail,head,3);
	return v;
}

static VAL lpop(VAL* stk) {
	VAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);
	*stk=lcar; return lcdr;
}
static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }
#define LPOP(v) push_value(lpop(&(v)))
#define LPUSH(v) lpush(&(v),pop_value())
#define LPOPR(v) push_resource(lpop(&(v)))
#define LPUSHR(v) lpush(&(v),pop_resource())

static STR* str_alloc (USIZE cap) {
	ASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));
	EXPECT(str, "failed to allocate string");
	str->refs = 1;
	str->cap = cap;
	return str;
}

static STR* str_make (const char* data, USIZE size) {
	ASSERT(data);
	ASSERT(size <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = str_alloc(size);
	str->size = size;
	memcpy(str->data, data, (size_t)size);
	return str;
}
#define mkstr(x,n) MKSTR(str_make((x), (n)))

static STR* str_cat (STR* s1, STR* s2) {
	EXPECT(s1 && s2, "invalid strings in prim-str-cat");
	USIZE m = s1->cap;
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	if ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {
		ASSERT(n2 <= SIZE_MAX);
		memcpy(s1->data + n1, s2->data, (size_t)n2);
		s1->size += n2;
		ASSERT(s1->size + 4 <= s1->cap);
		decref(MKSTR(s2));
		return s1;
	} else {
		USIZE m2 = n1 + n2 + 4;
		if ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;
		STR* str = str_alloc(m2);
		str->size = n1+n2;
		ASSERT(n1 <= SIZE_MAX);
		ASSERT(n2 <= SIZE_MAX);
		memcpy(str->data, s1->data, (size_t)n1);
		memcpy(str->data+n1, s2->data, (size_t)n2);
		decref(MKSTR(s1));
		decref(MKSTR(s2));
		return str;
	}
}

static USIZE get_data_tag(VAL v) {
	if (IS_TUP(v)) {
		ASSERT(VTUPLEN(v) > 0);
		return VU64(VTUP(v)->cells[0]);
	} else {
		return VU64(v);
	}
}

static USIZE get_top_data_tag(void) {
	return get_data_tag(top_value());
}

static USIZE get_top_resource_data_tag(void) {
	return get_data_tag(top_resource());
}

static int str_cmp(STR* s1, STR* s2) {
	ASSERT(s1 && s2);
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	USIZE n = (n1 < n2 ? n1 : n2);
	ASSERT(n < SIZE_MAX);
	int r = memcmp(s1->data, s2->data, (size_t)n);
	decref(MKSTR(s1));
	decref(MKSTR(s2));
	if (r) return r;
	if (n1 < n2) return -1;
	if (n1 > n2) return 1;
	return 0;
}

static void run_value(VAL v) {
	if (IS_TUP(v)) {
		VAL h = VTUP(v)->cells[0];
		ASSERT(IS_FNPTR(h));
		push_value(v);
		VFNPTR(h)();
	} else {
		ASSERT(IS_FNPTR(v));
		VFNPTR(v)();
	}
}

static int64_t i64_add (int64_t a, int64_t b) {
	EXPECT(((b >= 0) && (a <= INT64_MAX - b))
		|| ((b <  0) && (a >= INT64_MIN - b)),
		"overflow during integer addition");
	return a + b;
}

static int64_t i64_sub (int64_t a, int64_t b) {
	EXPECT(((b >= 0) && (a >= INT64_MIN + b))
		|| ((b <  0) && (a <= INT64_MAX + b)),
		"overflow during integer subtraction");
	return a - b;
}

static int64_t i64_mul (int64_t a, int64_t b) {
	EXPECT((a == 0) || (b == 0) ||
		((a > 0) && (b > 0) && (a <= INT64_MAX/b)) ||
		((a > 0) && (b < 0) && (a <= INT64_MIN/b)) ||
		((a < 0) && (b > 0) && (a >= INT64_MIN/b)) ||
		((a < 0) && (b < 0) && (a >= INT64_MAX/b)),
		"overflow during integer multiplication"
	);
	return a * b;
}

static int64_t i64_div (int64_t a, int64_t b) {
	EXPECT(b != 0, "divide by zero");
	EXPECT(!((b == -1) && (a == INT64_MIN)), "overflow during integer division");
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) q--;
	return q;
}

static int64_t i64_mod (int64_t a, int64_t b) {
	EXPECT(b != 0, "divide by zero");
	EXPECT(!((b == -1) && (a == INT64_MIN)), "overflow during integer division");
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) r += b;
	return r;
}

static uint64_t u64_shl (uint64_t a, uint64_t b) {
	if (b >= 64) return 0;
	return (a << b);
}

static uint64_t u64_shr (uint64_t a, uint64_t b) {
	if (b >= 64) return 0;
	return (a >> b);
}

static STR* f32_show (float d) {
 	char result[DBL_DIG+32] = {0};
	int len = sprintf(result, "%.*g", DBL_DIG, d);
	return str_make(result, len);
}

static STR* f64_show (double d) {
 	char result[DBL_DIG+32] = {0};
	int len = sprintf(result, "%.*g", DBL_DIG, d);
	return str_make(result, len);
}

void int_repr(int64_t y, char** out_ptr, size_t *out_size) {
	static char c[32] = {0};
	memset(c, 0, 32);
	char* p = c+30;
	size_t n = 0;
	uint64_t x;
	if (y < 0) {
		if (y == INT64_MIN) {
			x = 1+(uint64_t)INT64_MAX;
		} else {
			x = (uint64_t)-y;
		}
	} else {
		x = (uint64_t)y;
	}
	do {
		*--p = '0' + (x % 10);
		x /= 10;
		n++;
	} while (x);
	if (y < 0) {
		*--p = '-';
		n++;
	}
	*out_ptr = p;
	*out_size = n;
}

void int_trace_(int64_t y, int fd) {
	char* p; size_t n;
	int_repr(y, &p, &n);
	write(fd, p, n);
}

STR* i64_show (int64_t x) {
	bool cache = (0 <= x) && (x <= 255);
	static STR* scache[256] = {0};
	if (cache && scache[x]) {
		STR* s = scache[x];
		incref(MKSTR(s));
		return s;
	} else {
		char* p; size_t n;
		int_repr(x,&p,&n);
		STR* s = str_make(p,n);
		if (cache) {
			scache[x] = s;
			incref(MKSTR(s));
		}
		return s;
	}
}

void str_trace_(STR* str, int fd) {
	ASSERT(str->size <= SIZE_MAX);
	write(fd, "\"", 1);
	USIZE i0 = 0;
	char xb[4]={'\\','x'};
	USIZE i;
	for (i = 0; i < str->size; i++) {
		const char* c = NULL; size_t n=0;
		uint8_t v=str->data[i];
		switch(v) {
			case '\n': c="\\n"; n=2; break;
			case '\r': c="\\r"; n=2; break;
			case '\t': c="\\t"; n=2; break;
			case '\\': c="\\\\"; n=2; break;
			case '\"': c="\\\""; n=2; break;
			default:
				if (!((' ' <= v) && (v < 0x7F))) {
					xb[2] = '0' + (v&15) + ('A'-'9'-1)*((v&15) > 9);
					xb[3] = '0' + (v/16) + ('A'-'9'-1)*((v/16) > 9);
					c=xb; n=4;
				}
		}
		if ((n > 0) && (i0 < i)) {
			write(fd, str->data+i0, (size_t)(i-i0));
			i0=i+1;
		}
		write(fd, c, n);
	}
	if (i0 < i) write(fd, str->data+i0, (size_t)(i-i0));
	write(fd, "\"", 1);
}

void value_trace_(VAL val, int fd) {
	if (IS_INT(val)) {
		int_trace_(VINT(val), fd);
	} else if (IS_STR(val)) {
		str_trace_(VSTR(val), fd);
	} else if (IS_FNPTR(val)) {
		write(fd, "<fnptr>", 7);
	} else if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		if (VTUPLEN(val) == 0) {
			write(fd, "[]", 2);
		} else {
			write(fd, "[ ", 2);
			for(TUPLEN i = 0; i < len; i++) {
				if (i > 0) write(fd, " ", 1);
				value_trace_(tup->cells[i], fd);
			}
			write(fd, " ]", 2);
		}
	} else {
		TRACE("value cannot be traced");
		exit(1);
	}
}

static void trace_stack (void) {
	TRACE("??");
	for (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {
		TRACE(" ");
		value_trace_(stack[i], 2);
	}
	TRACE("\n");
}

static void trace_rstack (void) {
	#if MIRTH_DEBUG
		TRACE("call stack:\n");
		for (USIZE i = fstack_counter; i --> 1;) {
			TRACE("    ");
			if (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {
				TRACE(fstack[i-1].atom);
				TRACE(" -> ");
			}
			TRACE(fstack[i].word);
			TRACE(" at ");
			TRACE(fstack[i-1].path);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].line, 2);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].col, 2);
			TRACE("\n");
		}
	#endif
}

static void do_panic(STR* m) {
	if (m) {
		size_t n = (m->size < 2048) ? (size_t)(m->size) : 2048;
		write(2, m->data, n);
		TRACE("\n");
	} else {
		TRACE("panic!\n");
	}
	trace_stack();
	trace_rstack();
	exit(1);
}

#if defined(MIRTH_WINDOWS)
#define RUNNING_OS 1
#elif defined(MIRTH_LINUX)
#define RUNNING_OS 2
#elif defined(MIRTH_MACOS)
#define RUNNING_OS 3
#else
#define RUNNING_OS 0
#endif

#if defined(MIRTH_I386)
#define RUNNING_ARCH 1
#elif defined(MIRTH_AMD64)
#define RUNNING_ARCH 2
#elif defined(MIRTH_ARM64)
#define RUNNING_ARCH 3
#else
#define RUNNING_ARCH 0
#endif

static void* ptr_alloc (uint64_t n) {
	EXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), "invalid size in prim-ptr-alloc");
	void* p = malloc((size_t)n);
	EXPECT(p, "failed to allocate in prim-ptr-alloc");
	return p;
}

static void* ptr_realloc (void* p, uint64_t n) {
	EXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), "invalid size in prim-ptr-realloc");
	void* p2 = realloc(p, (size_t)n);
	EXPECT(p2, "failed to reallocate in prim-ptr-realloc");
	return p2;
}

static void ptr_copy (void* src, uint64_t len, void* dst) {
	if (len > 0) {
		EXPECT(len <= SIZE_MAX, "invalid size in prim-ptr-copy");
		EXPECT(src && dst, "invalid pointer in prim-ptr-copy");
		memcpy(dst, src, (size_t)len);
	}
}

static void ptr_fill (uint8_t val, uint64_t len, void* dst) {
	if (len > 0) {
		EXPECT(len <= SIZE_MAX, "invalid size in prim-ptr-fill");
		EXPECT(dst, "invalid pointer in prim-ptr-fill");
		memset(dst, (int)val, (size_t)len);
	}
}

static void* str_base (STR* s) {
	EXPECT(s && (s->refs > 1), "invalid string for prim-str-base");
	s->refs--;
	return s->data;
}

static uint64_t str_size (STR* s) {
	EXPECT(s, "invalid string for prim-str-size");
	uint64_t n = s->size;
	decref(MKSTR(s));
	return n;
}

static VAL mut_get (void* mut) {
	EXPECT(mut, "invalid pointer in prim-mut-get");
	VAL v = *(VAL*)mut;
	EXPECT(v.tag, "tried to read uninitialized value");
	incref(v);
	return v;
}

static void mut_set (VAL newval, void* mut) {
	EXPECT(mut, "invalid pointer in prim-mut-set");
	VAL oldval = *(VAL*)mut;
	*(VAL*)mut = newval;
	if (oldval.tag) {
		decref(oldval);
	}
}

static bool mut_is_set (void* mut) {
	EXPECT(mut, "invalid pointer in prim-mut-is-set");
	VAL val = *(VAL*)mut;
	return (val.tag != 0);
}

/* GENERATED C99 */

static VAL lbl_emitZ_debugZ_info = MKNIL_C;
static VAL lbl_inputZ_file = MKNIL_C;
static VAL lbl_outputZ_file = MKNIL_C;
static VAL lbl_entryZ_point = MKNIL_C;
static VAL lbl_packages = MKNIL_C;
static VAL lbl_packageZ_searchZ_paths = MKNIL_C;
static VAL lbl_outputZ_path = MKNIL_C;
static VAL lbl_name = MKNIL_C;
static VAL lbl_flagZ_type = MKNIL_C;
static VAL lbl_argZ_doc = MKNIL_C;
static VAL lbl_doc = MKNIL_C;
static VAL lbl_group = MKNIL_C;
static VAL lbl_options = MKNIL_C;
static VAL lbl_parser = MKNIL_C;
static VAL lbl_argsZ_doc = MKNIL_C;
static VAL lbl_x1 = MKNIL_C;
static VAL lbl_x2 = MKNIL_C;
static VAL lbl_x3 = MKNIL_C;
static VAL lbl_x4 = MKNIL_C;
static VAL lbl_tail = MKNIL_C;
static VAL lbl_head = MKNIL_C;
static VAL lbl_x = MKNIL_C;
static VAL lbl_rest = MKNIL_C;
static VAL lbl_ok = MKNIL_C;
static VAL lbl_escapeZ_hex = MKNIL_C;
static VAL lbl_sizze = MKNIL_C;
static VAL lbl_base = MKNIL_C;
static VAL lbl_oldZ_sizze = MKNIL_C;
static VAL lbl_origZ_sizze = MKNIL_C;
static VAL lbl_origZ_offset = MKNIL_C;
static VAL lbl_fileZ_descriptor = MKNIL_C;
static VAL lbl_owned = MKNIL_C;
static VAL lbl_sliceZ_sizze = MKNIL_C;
static VAL lbl_sliceZ_base = MKNIL_C;
static VAL lbl_success = MKNIL_C;
static VAL lbl_wroteZ_bytes = MKNIL_C;
static VAL lbl_length = MKNIL_C;
static VAL lbl_offset = MKNIL_C;
static VAL lbl_ZPlusbuffer = MKNIL_C;
static VAL lbl_ZPlusfile = MKNIL_C;
static VAL lbl_ZPlusworld = MKNIL_C;
static VAL lbl_numZ_tests = MKNIL_C;
static VAL lbl_numZ_failed = MKNIL_C;
static VAL lbl_testZ_name = MKNIL_C;
static VAL lbl_testZ_failed = MKNIL_C;
static VAL lbl_ZPlustests = MKNIL_C;
static VAL lbl_colZ_offset = MKNIL_C;
static VAL lbl_argumentZ_parser = MKNIL_C;
static VAL lbl_state = MKNIL_C;
static VAL lbl_docZ_length = MKNIL_C;
static VAL lbl_oo = MKNIL_C;
static VAL lbl_argv = MKNIL_C;
static VAL lbl_programZ_name = MKNIL_C;
static VAL lbl_argvZ_info = MKNIL_C;
static VAL lbl_parsingZAsk = MKNIL_C;
static VAL lbl_option = MKNIL_C;
static VAL lbl_optionZ_option = MKNIL_C;
static VAL lbl_arg = MKNIL_C;
static VAL lbl_arguments = MKNIL_C;
static VAL lbl_positionalZ_index = MKNIL_C;
static VAL lbl_longestZ_argZ_length = MKNIL_C;
static VAL lbl_error = MKNIL_C;
static VAL lbl_namespace = MKNIL_C;
static VAL lbl_arity = MKNIL_C;
static VAL lbl_std = MKNIL_C;
static VAL lbl_prim = MKNIL_C;
static VAL lbl_bool = MKNIL_C;
static VAL lbl_true = MKNIL_C;
static VAL lbl_false = MKNIL_C;
static VAL lbl_u64 = MKNIL_C;
static VAL lbl_mkZ_u64 = MKNIL_C;
static VAL lbl_u32 = MKNIL_C;
static VAL lbl_mkZ_u32 = MKNIL_C;
static VAL lbl_u16 = MKNIL_C;
static VAL lbl_mkZ_u16 = MKNIL_C;
static VAL lbl_u8 = MKNIL_C;
static VAL lbl_mkZ_u8 = MKNIL_C;
static VAL lbl_i64 = MKNIL_C;
static VAL lbl_mkZ_i64 = MKNIL_C;
static VAL lbl_i32 = MKNIL_C;
static VAL lbl_mkZ_i32 = MKNIL_C;
static VAL lbl_i16 = MKNIL_C;
static VAL lbl_mkZ_i16 = MKNIL_C;
static VAL lbl_i8 = MKNIL_C;
static VAL lbl_mkZ_i8 = MKNIL_C;
static VAL lbl_cchar = MKNIL_C;
static VAL lbl_mkZ_cchar = MKNIL_C;
static VAL lbl_cichar = MKNIL_C;
static VAL lbl_mkZ_cichar = MKNIL_C;
static VAL lbl_cshort = MKNIL_C;
static VAL lbl_mkZ_cshort = MKNIL_C;
static VAL lbl_cint = MKNIL_C;
static VAL lbl_mkZ_cint = MKNIL_C;
static VAL lbl_clong = MKNIL_C;
static VAL lbl_mkZ_clong = MKNIL_C;
static VAL lbl_clonglong = MKNIL_C;
static VAL lbl_mkZ_clonglong = MKNIL_C;
static VAL lbl_cisizze = MKNIL_C;
static VAL lbl_mkZ_cisizze = MKNIL_C;
static VAL lbl_cintptr = MKNIL_C;
static VAL lbl_mkZ_cintptr = MKNIL_C;
static VAL lbl_cuchar = MKNIL_C;
static VAL lbl_mkZ_cuchar = MKNIL_C;
static VAL lbl_cushort = MKNIL_C;
static VAL lbl_mkZ_cushort = MKNIL_C;
static VAL lbl_cuint = MKNIL_C;
static VAL lbl_mkZ_cuint = MKNIL_C;
static VAL lbl_culong = MKNIL_C;
static VAL lbl_mkZ_culong = MKNIL_C;
static VAL lbl_culonglong = MKNIL_C;
static VAL lbl_mkZ_culonglong = MKNIL_C;
static VAL lbl_cusizze = MKNIL_C;
static VAL lbl_mkZ_cusizze = MKNIL_C;
static VAL lbl_cuintptr = MKNIL_C;
static VAL lbl_mkZ_cuintptr = MKNIL_C;
static VAL lbl_cptr = MKNIL_C;
static VAL lbl_mkZ_cptr = MKNIL_C;
static VAL lbl_cconst = MKNIL_C;
static VAL lbl_mkZ_cconst = MKNIL_C;
static VAL lbl_crestrict = MKNIL_C;
static VAL lbl_mkZ_crestrict = MKNIL_C;
static VAL lbl_cvolatile = MKNIL_C;
static VAL lbl_mkZ_cvolatile = MKNIL_C;
static VAL lbl_cvoid = MKNIL_C;
static VAL lbl_mkZ_cvoid = MKNIL_C;
static VAL lbl_numZ_errors = MKNIL_C;
static VAL lbl_numZ_warnings = MKNIL_C;
static VAL lbl_preferZ_inlineZ_defs = MKNIL_C;
static VAL lbl_builtin = MKNIL_C;
static VAL lbl_mirthZ_baseZ_path = MKNIL_C;
static VAL lbl_ZPlusdiagnostics = MKNIL_C;
static VAL lbl_ZPluspropstack = MKNIL_C;
static VAL lbl_errorZ_token = MKNIL_C;
static VAL lbl_severity = MKNIL_C;
static VAL lbl_message = MKNIL_C;
static VAL lbl_location = MKNIL_C;
static VAL lbl_old = MKNIL_C;
static VAL lbl_new = MKNIL_C;
static VAL lbl_label = MKNIL_C;
static VAL lbl_module = MKNIL_C;
static VAL lbl_row = MKNIL_C;
static VAL lbl_col = MKNIL_C;
static VAL lbl_token = MKNIL_C;
static VAL lbl_a = MKNIL_C;
static VAL lbl_b = MKNIL_C;
static VAL lbl_c = MKNIL_C;
static VAL lbl_rr = MKNIL_C;
static VAL lbl_sr = MKNIL_C;
static VAL lbl_xs = MKNIL_C;
static VAL lbl_ys = MKNIL_C;
static VAL lbl_ta = MKNIL_C;
static VAL lbl_tb = MKNIL_C;
static VAL lbl_tc = MKNIL_C;
static VAL lbl_trr = MKNIL_C;
static VAL lbl_tsr = MKNIL_C;
static VAL lbl_txs = MKNIL_C;
static VAL lbl_tys = MKNIL_C;
static VAL lbl_qname = MKNIL_C;
static VAL lbl_type = MKNIL_C;
static VAL lbl_data = MKNIL_C;
static VAL lbl_field = MKNIL_C;
static VAL lbl_labels = MKNIL_C;
static VAL lbl_withses = MKNIL_C;
static VAL lbl_conses = MKNIL_C;
static VAL lbl_parts = MKNIL_C;
static VAL lbl_baseZAsk = MKNIL_C;
static VAL lbl_dom = MKNIL_C;
static VAL lbl_cod = MKNIL_C;
static VAL lbl_ctype = MKNIL_C;
static VAL lbl_tags = MKNIL_C;
static VAL lbl_params = MKNIL_C;
static VAL lbl_tag = MKNIL_C;
static VAL lbl_inputs = MKNIL_C;
static VAL lbl_value = MKNIL_C;
static VAL lbl_underlying = MKNIL_C;
static VAL lbl_tagname = MKNIL_C;
static VAL lbl_dataname = MKNIL_C;
static VAL lbl_input = MKNIL_C;
static VAL lbl_ftag = MKNIL_C;
static VAL lbl_typeZDivresource = MKNIL_C;
static VAL lbl_body = MKNIL_C;
static VAL lbl_sigZAsk = MKNIL_C;
static VAL lbl_pattern = MKNIL_C;
static VAL lbl_ctx = MKNIL_C;
static VAL lbl_subst = MKNIL_C;
static VAL lbl_op = MKNIL_C;
static VAL lbl_saved = MKNIL_C;
static VAL lbl_home = MKNIL_C;
static VAL lbl_cases = MKNIL_C;
static VAL lbl_tokenZ_start = MKNIL_C;
static VAL lbl_tokenZ_end = MKNIL_C;
static VAL lbl_outerZ_ctx = MKNIL_C;
static VAL lbl_innerZ_ctx = MKNIL_C;
static VAL lbl_mid = MKNIL_C;
static VAL lbl_atoms = MKNIL_C;
static VAL lbl_args = MKNIL_C;
static VAL lbl_lexerZ_module = MKNIL_C;
static VAL lbl_ZPlusinput = MKNIL_C;
static VAL lbl_lexerZ_row = MKNIL_C;
static VAL lbl_lexerZ_col = MKNIL_C;
static VAL lbl_lexerZ_stack = MKNIL_C;
static VAL lbl_lexerZ_lastZ_token = MKNIL_C;
static VAL lbl_allowZ_typeZ_holes = MKNIL_C;
static VAL lbl_allowZ_implicitZ_typeZ_vars = MKNIL_C;
static VAL lbl_ignoreZ_lastZ_name = MKNIL_C;
static VAL lbl_nameZDivdname = MKNIL_C;
static VAL lbl_candidates = MKNIL_C;
static VAL lbl_rejected = MKNIL_C;
static VAL lbl_sort = MKNIL_C;
static VAL lbl_reportZ_ambiguousZ_asZ_warning = MKNIL_C;
static VAL lbl_accum = MKNIL_C;
static VAL lbl_arrow = MKNIL_C;
static VAL lbl_word = MKNIL_C;
static VAL lbl_ZPlusab = MKNIL_C;
static VAL lbl_ZPluspat = MKNIL_C;
static VAL lbl_tok = MKNIL_C;
static VAL lbl_header = MKNIL_C;
static VAL lbl_valueZAsk = MKNIL_C;
static VAL lbl_syn = MKNIL_C;
static VAL lbl_dat = MKNIL_C;
static VAL lbl_untag = MKNIL_C;
static VAL lbl_lbl = MKNIL_C;
static VAL lbl_lblz_get = MKNIL_C;
static VAL lbl_lblz_set = MKNIL_C;
static VAL lbl_lblz_lens = MKNIL_C;
static VAL lbl_sx = MKNIL_C;
static VAL lbl_sy = MKNIL_C;
static VAL lbl_lblty = MKNIL_C;
static VAL lbl_datty = MKNIL_C;
static VAL lbl_f = MKNIL_C;
static VAL lbl_hasZ_paren = MKNIL_C;
static VAL lbl_target = MKNIL_C;
static VAL lbl_alias = MKNIL_C;
static VAL lbl_code = MKNIL_C;
static VAL lbl_symbol = MKNIL_C;
static VAL lbl_sig = MKNIL_C;
static VAL lbl_extblock = MKNIL_C;
static VAL lbl_external = MKNIL_C;
static VAL lbl_ZPlusmirth = MKNIL_C;
static VAL lbl_contents = MKNIL_C;
static VAL lbl_tbl = MKNIL_C;
static VAL lbl_va = MKNIL_C;
static VAL lbl_vx = MKNIL_C;
static VAL lbl_valueZ_type = MKNIL_C;
static VAL lbl_indexZ_type = MKNIL_C;
static VAL lbl_fld = MKNIL_C;
static VAL lbl_checklist = MKNIL_C;
static VAL lbl_w = MKNIL_C;
static VAL lbl_key = MKNIL_C;
static VAL lbl_wordZTick = MKNIL_C;
static VAL lbl_spword = MKNIL_C;
static VAL lbl_spkey = MKNIL_C;
static VAL lbl_spmap = MKNIL_C;
static VAL lbl_depth = MKNIL_C;
static VAL lbl_freshZ_counter = MKNIL_C;
static VAL lbl_ZPlusneeds = MKNIL_C;
static VAL lbl_ZPlusoutput = MKNIL_C;
static VAL lbl_pfx = MKNIL_C;
static VAL lbl_sfx = MKNIL_C;
static VAL lbl_tup = MKNIL_C;
static VAL lbl_i = MKNIL_C;
static VAL lbl_fieldty = MKNIL_C;
static VAL lbl_ZPlustuplevar = MKNIL_C;
static VAL lbl_fieldrepr = MKNIL_C;
static VAL lbl_fieldval = MKNIL_C;
static VAL lbl_tupleval = MKNIL_C;
static VAL lbl_ext = MKNIL_C;
static VAL lbl_cty = MKNIL_C;
static VAL lbl_outty = MKNIL_C;
static VAL lbl_argZ_index = MKNIL_C;
static VAL lbl_expr = MKNIL_C;
static VAL lbl_repr = MKNIL_C;
static VAL lbl_source = MKNIL_C;
static VAL lbl_localZ_name = MKNIL_C;
static VAL lbl_localZ_repr = MKNIL_C;
static VAL lbl_cname = MKNIL_C;
static VAL lbl_inZ_params = MKNIL_C;
static VAL lbl_returnZ_param = MKNIL_C;
static VAL lbl_outZ_params = MKNIL_C;
static VAL lbl_mustZ_flushZAsk = MKNIL_C;
static VAL lbl_api = MKNIL_C;
static VAL lbl_poppedZ_inputs = MKNIL_C;
static VAL lbl_reservedZ_outputs = MKNIL_C;
static VAL lbl_sep = MKNIL_C;
static VAL lbl_ZPluslocal = MKNIL_C;
static VAL lbl_ZPlusstr = MKNIL_C;
static VAL lbl_avoidZ_hexdigit = MKNIL_C;
static VAL lbl_localZ_resourceZ_repr = MKNIL_C;
static VAL lbl_localZ_resourceZ_name = MKNIL_C;
static VAL lbl_ZPluscore = MKNIL_C;
static VAL lbl_ZPlusstack = MKNIL_C;
static VAL lbl_ZPlusx = MKNIL_C;
static VAL lbl_branchZ_splitZ_target = MKNIL_C;
static VAL lbl_branchZ_splitZ_mustZ_flushZAsk = MKNIL_C;
static VAL lbl_ZPlusb = MKNIL_C;
static VAL lbl_ZPlusa = MKNIL_C;
static VAL lbl_ZPlusdipped = MKNIL_C;
static VAL lbl_ZPluscond = MKNIL_C;
static VAL lbl_ZPlusknot = MKNIL_C;
static VAL lbl_ZPlusclosure = MKNIL_C;
static VAL lbl_ZPluscons = MKNIL_C;
static VAL lbl_ZPlustail = MKNIL_C;
static VAL lbl_ZPlushead = MKNIL_C;
static VAL lbl_ZPlusdst = MKNIL_C;
static VAL lbl_ZPluslen = MKNIL_C;
static VAL lbl_ZPlussrc = MKNIL_C;
static VAL lbl_ZPlusval = MKNIL_C;
static VAL lbl_outZ_type = MKNIL_C;
static VAL lbl_argsZ_swapped = MKNIL_C;
static VAL lbl_arg2Z_type = MKNIL_C;
static VAL lbl_arg1Z_type = MKNIL_C;
static VAL lbl_arg1 = MKNIL_C;
static VAL lbl_arg2 = MKNIL_C;
static VAL lbl_argZ_type = MKNIL_C;
static VAL lbl_ZPlusfnptr = MKNIL_C;
static VAL lbl_ZPlustup = MKNIL_C;
static VAL lbl_var = MKNIL_C;
static VAL lbl_ZPlusscrutinee = MKNIL_C;
static VAL lbl_ZPlusindex = MKNIL_C;
static VAL lbl_stack = MKNIL_C;
static VAL lbl_ZPlusset = MKNIL_C;
static VAL mtw_std_either_Either_2_Left (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* Left */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_std_either_Either_2_Left (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_std_either_Either_2_Right (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* Right */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_std_either_Either_2_Right (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_std_buffer_ZPlusBuffer_ZPlusBuffer (int64_t x1, void* x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +Buffer */);
	v3->cells[2] = MKPTR(x2);
	v3->cells[1] = MKI64(x1);
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_std_buffer_ZPlusBuffer_ZPlusBuffer (VAL x1, int64_t *x2, void* *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VPTR(v5);
	*x2 = VI64(v4);
}
static VAL mtw_std_list_List_1_Cons (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(1LL /* Cons */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_std_list_List_1_Cons (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_std_list_ListZPlus_1_ListZPlus (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* List+ */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_std_list_ListZPlus_1_ListZPlus (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_std_maybe_Maybe_1_Some (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* Some */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_std_maybe_Maybe_1_Some (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_std_input_ZPlusInputOpenState_ZPlusInputOpenState (int64_t x1, int64_t x2, VAL x3, VAL x4) {
	TUP* v5 = tup_new(5);
	v5->size = 5;
	v5->cells[0] = MKI64(0LL /* +InputOpenState */);
	v5->cells[4] = x4;
	v5->cells[3] = x3;
	v5->cells[2] = MKI64(x2);
	v5->cells[1] = MKI64(x1);
	VAL v6 = (MKTUP(v5, 5));
	return v6;
}
static void mtp_std_input_ZPlusInputOpenState_ZPlusInputOpenState (VAL x1, int64_t *x2, int64_t *x3, VAL *x4, VAL *x5) {
	VAL v6 = VTUP(x1)->cells[1];
	VAL v7 = VTUP(x1)->cells[2];
	VAL v8 = VTUP(x1)->cells[3];
	VAL v9 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	*x5 = v9;
	*x4 = v8;
	*x3 = VI64(v7);
	*x2 = VI64(v6);
}
static VAL mtw_std_input_ZPlusInput_ZPlusInputOpen (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* +InputOpen */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_std_input_ZPlusInput_ZPlusInputOpen (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_std_input_ZPlusInput_ZPlusInputDone (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* +InputDone */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_std_input_ZPlusInput_ZPlusInputDone (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_std_output_ZPlusOutput_ZPlusOutput (int64_t x1, VAL x2, VAL x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* +Output */);
	v4->cells[3] = x3;
	v4->cells[2] = x2;
	v4->cells[1] = MKI64(x1);
	VAL v5 = (MKTUP(v4, 4));
	return v5;
}
static void mtp_std_output_ZPlusOutput_ZPlusOutput (VAL x1, int64_t *x2, VAL *x3, VAL *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = v7;
	*x3 = v6;
	*x2 = VI64(v5);
}
static VAL mtw_std_file_ZPlusFile_ZPlusFile (int64_t x1, int64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +File */);
	v3->cells[2] = MKI64(x2);
	v3->cells[1] = MKI64(x1);
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_std_file_ZPlusFile_ZPlusFile (VAL x1, int64_t *x2, int64_t *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VI64(v5);
	*x2 = VI64(v4);
}
static VAL mtw_std_file_ZPlusFileZAsk_ZPlusFileOk (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* +FileOk */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_std_file_ZPlusFileZAsk_ZPlusFileOk (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_std_file_ZPlusFileZAsk_ZPlusFileErr (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* +FileErr */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_std_file_ZPlusFileZAsk_ZPlusFileErr (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtp_std_terminal_Sgr_FGColor (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtp_std_terminal_Sgr_BGColor (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static int64_t mtp_std_terminal_SGRColor_Numbered (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static void mtp_std_terminal_SGRColor_RGB (VAL x1, int64_t *x2, int64_t *x3, int64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VI64(v7);
	*x3 = VI64(v6);
	*x2 = VI64(v5);
}
static VAL mtw_argZ_parser_state_ArgvInfo_ArgvInfo (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* ArgvInfo */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_argZ_parser_state_CurrentArg_CurrentArg (int64_t x1, VAL x2, VAL x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* CurrentArg */);
	v4->cells[3] = x3;
	v4->cells[2] = x2;
	v4->cells[1] = MKI64(x1);
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static VAL mtw_argZ_parser_state_State_1_State (VAL x1, VAL x2, VAL x3, int64_t x4, int64_t x5, VAL x6) {
	TUP* v7 = tup_new(7);
	v7->size = 7;
	v7->cells[0] = MKI64(0LL /* State */);
	v7->cells[6] = x6;
	v7->cells[5] = MKI64(x5);
	v7->cells[4] = MKI64(x4);
	v7->cells[3] = x3;
	v7->cells[2] = x2;
	v7->cells[1] = x1;
	VAL v8 = MKTUP(v7, 7);
	return v8;
}
static VAL mtw_argZ_parser_types_ArgumentParser_1_ArgumentParser (VAL x1, VAL x2, VAL x3, VAL x4) {
	TUP* v5 = tup_new(5);
	v5->size = 5;
	v5->cells[0] = MKI64(0LL /* ArgumentParser */);
	v5->cells[4] = x4;
	v5->cells[3] = x3;
	v5->cells[2] = x2;
	v5->cells[1] = x1;
	VAL v6 = MKTUP(v5, 5);
	return v6;
}
static VAL mtw_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +ArgumentParser */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_argZ_parser_types_ArgpOptionType_Short (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* Short */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_argZ_parser_types_ArgpOptionType_Short (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_argZ_parser_types_ArgpOptionType_LongOnly (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* LongOnly */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_argZ_parser_types_ArgpOptionType_LongOnly (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_argZ_parser_types_ArgpOption_ArgpOption (VAL x1, VAL x2, VAL x3, VAL x4, VAL x5) {
	TUP* v6 = tup_new(6);
	v6->size = 6;
	v6->cells[0] = MKI64(0LL /* ArgpOption */);
	v6->cells[5] = x5;
	v6->cells[4] = x4;
	v6->cells[3] = x3;
	v6->cells[2] = x2;
	v6->cells[1] = x1;
	VAL v7 = MKTUP(v6, 6);
	return v7;
}
static VAL mtw_argZ_parser_types_ArgumentParsingError_MissingArg (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* MissingArg */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_argZ_parser_types_ArgumentParsingError_MissingArg (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_tycon_Tycon_TYCONz_DATA (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* TYCON_DATA */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_tycon_Tycon_TYCONz_DATA (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_tycon_Tycon_TYCONz_TABLE (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* TYCON_TABLE */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_tycon_Tycon_TYCONz_TABLE (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_tycon_Tycon_TYCONz_PRIM (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* TYCON_PRIM */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_tycon_Tycon_TYCONz_PRIM (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_data_SemiTransparentData_SemiTransparentData (uint64_t x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* SemiTransparentData */);
	v3->cells[2] = x2;
	v3->cells[1] = MKU64(x1);
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_data_DataPartial_DataPartial (uint64_t x1, uint64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* DataPartial */);
	v3->cells[2] = MKU64(x2);
	v3->cells[1] = MKU64(x1);
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_data_DataPartial_DataPartial (VAL x1, uint64_t *x2, uint64_t *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VU64(v5);
	*x2 = VU64(v4);
}
static VAL mtw_mirth_data_TagField_TagField (uint64_t x1, uint64_t x2, VAL x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* TagField */);
	v4->cells[3] = x3;
	v4->cells[2] = MKU64(x2);
	v4->cells[1] = MKU64(x1);
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_data_TagField_TagField (VAL x1, uint64_t *x2, uint64_t *x3, VAL *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = v7;
	*x3 = VU64(v6);
	*x2 = VU64(v5);
}
static VAL mtw_mirth_match_Match_Match (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v8 = tup_new(8);
	v8->size = 8;
	v8->cells[0] = MKI64(0LL /* Match */);
	v8->cells[7] = x7;
	v8->cells[6] = x6;
	v8->cells[5] = x5;
	v8->cells[4] = x4;
	v8->cells[3] = MKU64(x3);
	v8->cells[2] = MKU64(x2);
	v8->cells[1] = x1;
	VAL v9 = MKTUP(v8, 8);
	return v9;
}
static void mtp_mirth_match_Match_Match (VAL x1, VAL *x2, uint64_t *x3, uint64_t *x4, VAL *x5, VAL *x6, VAL *x7, VAL *x8) {
	VAL v9 = VTUP(x1)->cells[1];
	VAL v10 = VTUP(x1)->cells[2];
	VAL v11 = VTUP(x1)->cells[3];
	VAL v12 = VTUP(x1)->cells[4];
	VAL v13 = VTUP(x1)->cells[5];
	VAL v14 = VTUP(x1)->cells[6];
	VAL v15 = VTUP(x1)->cells[7];
	tup_decref_outer(VTUP(x1),8);
	*x8 = v15;
	*x7 = v14;
	*x6 = v13;
	*x5 = v12;
	*x4 = VU64(v11);
	*x3 = VU64(v10);
	*x2 = v9;
}
static VAL mtw_mirth_match_ZPlusMatch_ZPlusMatch (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v8 = tup_new(8);
	v8->size = 8;
	v8->cells[0] = MKI64(0LL /* +Match */);
	v8->cells[7] = x7;
	v8->cells[6] = x6;
	v8->cells[5] = x5;
	v8->cells[4] = x4;
	v8->cells[3] = MKU64(x3);
	v8->cells[2] = MKU64(x2);
	v8->cells[1] = x1;
	VAL v9 = (MKTUP(v8, 8));
	return v9;
}
static void mtp_mirth_match_ZPlusMatch_ZPlusMatch (VAL x1, VAL *x2, uint64_t *x3, uint64_t *x4, VAL *x5, VAL *x6, VAL *x7, VAL *x8) {
	VAL v9 = VTUP(x1)->cells[1];
	VAL v10 = VTUP(x1)->cells[2];
	VAL v11 = VTUP(x1)->cells[3];
	VAL v12 = VTUP(x1)->cells[4];
	VAL v13 = VTUP(x1)->cells[5];
	VAL v14 = VTUP(x1)->cells[6];
	VAL v15 = VTUP(x1)->cells[7];
	tup_decref_outer(VTUP(x1),8);
	*x8 = v15;
	*x7 = v14;
	*x6 = v13;
	*x5 = v12;
	*x4 = VU64(v11);
	*x3 = VU64(v10);
	*x2 = v9;
}
static VAL mtw_mirth_match_Case_CASE (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* CASE */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_match_Pattern_Pattern (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7, VAL x8, VAL x9) {
	TUP* v10 = tup_new(10);
	v10->size = 10;
	v10->cells[0] = MKI64(0LL /* Pattern */);
	v10->cells[9] = x9;
	v10->cells[8] = x8;
	v10->cells[7] = x7;
	v10->cells[6] = x6;
	v10->cells[5] = x5;
	v10->cells[4] = x4;
	v10->cells[3] = MKU64(x3);
	v10->cells[2] = MKU64(x2);
	v10->cells[1] = x1;
	VAL v11 = MKTUP(v10, 10);
	return v11;
}
static VAL mtw_mirth_match_PatternAtom_PATATOM (uint64_t x1, VAL x2, VAL x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v8 = tup_new(8);
	v8->size = 8;
	v8->cells[0] = MKI64(0LL /* PATATOM */);
	v8->cells[7] = x7;
	v8->cells[6] = x6;
	v8->cells[5] = x5;
	v8->cells[4] = x4;
	v8->cells[3] = x3;
	v8->cells[2] = x2;
	v8->cells[1] = MKU64(x1);
	VAL v9 = MKTUP(v8, 8);
	return v9;
}
static VAL mtw_mirth_match_PatternOp_PatOpTag (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* PatOpTag */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_match_PatternOp_PatOpTag (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_external_ExternalBlockPart_EBPCode (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* EBPCode */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_external_ExternalBlockPart_EBPCode (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_external_ExternalBlockPart_EBPDef (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* EBPDef */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_external_ExternalBlockPart_EBPDef (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpPrim (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* OpPrim */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_arrow_Op_OpPrim (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_arrow_Op_OpWord (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* OpWord */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpWord (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpExternal (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* OpExternal */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpExternal (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpBuffer (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* OpBuffer */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpBuffer (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpVariable (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(5LL /* OpVariable */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpVariable (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpField (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(6LL /* OpField */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpField (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpInt (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(7LL /* OpInt */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_arrow_Op_OpInt (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_arrow_Op_OpF64 (double x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(8LL /* OpF64 */);
	v2->cells[1] = MKF64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static double mtp_mirth_arrow_Op_OpF64 (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VF64(v2);
}
static VAL mtw_mirth_arrow_Op_OpStr (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(9LL /* OpStr */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_arrow_Op_OpStr (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_arrow_Op_OpTag (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(10LL /* OpTag */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpTag (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpMatch (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(11LL /* OpMatch */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_arrow_Op_OpMatch (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_arrow_Op_OpLambda (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(12LL /* OpLambda */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_arrow_Op_OpLambda (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_arrow_Op_OpVar (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(13LL /* OpVar */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpVar (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpBlockPush (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(14LL /* OpBlockPush */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpBlockPush (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpBlockRun (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(15LL /* OpBlockRun */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpBlockRun (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpCoerce (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(16LL /* OpCoerce */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_arrow_Op_OpCoerce (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_arrow_Op_OpLabelPush (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(17LL /* OpLabelPush */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPush (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpLabelPop (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(18LL /* OpLabelPop */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPop (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpLabelPushR (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(19LL /* OpLabelPushR */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPushR (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpLabelPopR (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(20LL /* OpLabelPopR */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPopR (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpDataGetTag (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(21LL /* OpDataGetTag */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Op_OpDataGetTag (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Op_OpDataGetLabel (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(22LL /* OpDataGetLabel */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_arrow_Op_OpDataGetLabel (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_arrow_Op_OpDataSetLabel (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(23LL /* OpDataSetLabel */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_arrow_Op_OpDataSetLabel (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_arrow_Home_HomeMain (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* HomeMain */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Home_HomeMain (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Home_HomeWord (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* HomeWord */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_arrow_Home_HomeWord (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_arrow_Arrow_Arrow (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v8 = tup_new(8);
	v8->size = 8;
	v8->cells[0] = MKI64(0LL /* Arrow */);
	v8->cells[7] = x7;
	v8->cells[6] = x6;
	v8->cells[5] = x5;
	v8->cells[4] = x4;
	v8->cells[3] = MKU64(x3);
	v8->cells[2] = MKU64(x2);
	v8->cells[1] = x1;
	VAL v9 = MKTUP(v8, 8);
	return v9;
}
static VAL mtw_mirth_arrow_Atom_Atom (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, VAL x6, VAL x7, VAL x8) {
	TUP* v9 = tup_new(9);
	v9->size = 9;
	v9->cells[0] = MKI64(0LL /* Atom */);
	v9->cells[8] = x8;
	v9->cells[7] = x7;
	v9->cells[6] = x6;
	v9->cells[5] = x5;
	v9->cells[4] = x4;
	v9->cells[3] = x3;
	v9->cells[2] = MKU64(x2);
	v9->cells[1] = x1;
	VAL v10 = MKTUP(v9, 9);
	return v10;
}
static void mtp_mirth_arrow_Atom_Atom (VAL x1, VAL *x2, uint64_t *x3, VAL *x4, VAL *x5, VAL *x6, VAL *x7, VAL *x8, VAL *x9) {
	VAL v10 = VTUP(x1)->cells[1];
	VAL v11 = VTUP(x1)->cells[2];
	VAL v12 = VTUP(x1)->cells[3];
	VAL v13 = VTUP(x1)->cells[4];
	VAL v14 = VTUP(x1)->cells[5];
	VAL v15 = VTUP(x1)->cells[6];
	VAL v16 = VTUP(x1)->cells[7];
	VAL v17 = VTUP(x1)->cells[8];
	tup_decref_outer(VTUP(x1),9);
	*x9 = v17;
	*x8 = v16;
	*x7 = v15;
	*x6 = v14;
	*x5 = v13;
	*x4 = v12;
	*x3 = VU64(v11);
	*x2 = v10;
}
static VAL mtw_mirth_arrow_Lambda_Lambda (uint64_t x1, VAL x2, VAL x3, VAL x4, VAL x5) {
	TUP* v6 = tup_new(6);
	v6->size = 6;
	v6->cells[0] = MKI64(0LL /* Lambda */);
	v6->cells[5] = x5;
	v6->cells[4] = x4;
	v6->cells[3] = x3;
	v6->cells[2] = x2;
	v6->cells[1] = MKU64(x1);
	VAL v7 = MKTUP(v6, 6);
	return v7;
}
static VAL mtw_mirth_type_Type_TPrim (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* TPrim */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_type_Type_TPrim (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_type_Type_TMeta (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* TMeta */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_Type_TMeta (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_Type_THole (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* THole */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_Type_THole (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_Type_TVar (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(5LL /* TVar */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_Type_TVar (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_Type_TTable (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(6LL /* TTable */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_Type_TTable (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_Type_TData (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(7LL /* TData */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_Type_TData (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_Type_TDataPartial (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(8LL /* TDataPartial */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_Type_TDataPartial (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_Type_TTensor (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(9LL /* TTensor */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_Type_TTensor (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_Type_TMorphism (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(10LL /* TMorphism */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_Type_TMorphism (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_Type_TApp (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(11LL /* TApp */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_Type_TApp (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_type_Type_TMut (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(12LL /* TMut */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_Type_TMut (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_Type_TValue (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(13LL /* TValue */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_Type_TValue (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_Value_VALUEz_INT (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* VALUE_INT */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_type_Value_VALUEz_INT (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_type_Value_VALUEz_F64 (double x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* VALUE_F64 */);
	v2->cells[1] = MKF64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static double mtp_mirth_type_Value_VALUEz_F64 (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VF64(v2);
}
static VAL mtw_mirth_type_Value_VALUEz_STR (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* VALUE_STR */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_Value_VALUEz_STR (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_Value_VALUEz_BLOCK (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* VALUE_BLOCK */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_Value_VALUEz_BLOCK (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_StackType_STVar (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* STVar */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_StackType_STVar (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_StackType_STMeta (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* STMeta */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_StackType_STMeta (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_StackType_STCons (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(5LL /* STCons */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_StackType_STCons (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_type_StackType_STConsLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(6LL /* STConsLabel */);
	v4->cells[3] = MKU64(x3);
	v4->cells[2] = x2;
	v4->cells[1] = x1;
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_type_StackType_STConsLabel (VAL x1, VAL *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v7);
	*x3 = v6;
	*x2 = v5;
}
static VAL mtw_mirth_type_StackType_STWith (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(7LL /* STWith */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_StackType_STWith (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_type_StackType_STWithLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(8LL /* STWithLabel */);
	v4->cells[3] = MKU64(x3);
	v4->cells[2] = x2;
	v4->cells[1] = x1;
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_type_StackType_STWithLabel (VAL x1, VAL *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v7);
	*x3 = v6;
	*x2 = v5;
}
static VAL mtw_mirth_type_ArrowType_ARROWz_TYPE (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* ARROW_TYPE */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_ArrowType_ARROWz_TYPE (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_type_Subst_SUBSTz_CON (VAL x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(1LL /* SUBST_CON */);
	v4->cells[3] = MKU64(x3);
	v4->cells[2] = x2;
	v4->cells[1] = x1;
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_type_Subst_SUBSTz_CON (VAL x1, VAL *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v7);
	*x3 = v6;
	*x2 = v5;
}
static VAL mtw_mirth_type_StackTypeBase_STBVar (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* STBVar */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_StackTypeBase_STBVar (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_StackTypeBase_STBMeta (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* STBMeta */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_type_StackTypeBase_STBMeta (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_type_StackTypePart_STPCons (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* STPCons */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_StackTypePart_STPCons (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_StackTypePart_STPConsLabel (VAL x1, uint64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(1LL /* STPConsLabel */);
	v3->cells[2] = MKU64(x2);
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_StackTypePart_STPConsLabel (VAL x1, VAL *x2, uint64_t *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VU64(v5);
	*x2 = v4;
}
static VAL mtw_mirth_type_StackTypePart_STPWith (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* STPWith */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_StackTypePart_STPWith (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_StackTypePart_STPWithLabel (VAL x1, uint64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(3LL /* STPWithLabel */);
	v3->cells[2] = MKU64(x2);
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_StackTypePart_STPWithLabel (VAL x1, VAL *x2, uint64_t *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VU64(v5);
	*x2 = v4;
}
static VAL mtw_mirth_type_CType_IntLike (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* IntLike */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CType_IntLike (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CType_F32Like (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* F32Like */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CType_F32Like (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CType_F64Like (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* F64Like */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CType_F64Like (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CType_PtrLike (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* PtrLike */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CType_PtrLike (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CType_FnPtr (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* FnPtr */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CType_FnPtr (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPCons (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* CTSPCons */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CTypeStackPart_CTSPCons (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPConsLabel (VAL x1, uint64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(1LL /* CTSPConsLabel */);
	v3->cells[2] = MKU64(x2);
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_CTypeStackPart_CTSPConsLabel (VAL x1, VAL *x2, uint64_t *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VU64(v5);
	*x2 = v4;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPWith (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* CTSPWith */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_type_CTypeStackPart_CTSPWith (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPWithLabel (VAL x1, uint64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(3LL /* CTSPWithLabel */);
	v3->cells[2] = MKU64(x2);
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_type_CTypeStackPart_CTSPWithLabel (VAL x1, VAL *x2, uint64_t *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = VU64(v5);
	*x2 = v4;
}
static VAL mtw_mirth_type_CTypeStack_CTypeStack (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* CTypeStack */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_type_CTypeArrow_CTypeArrow (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* CTypeArrow */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_token_TokenValue_TokenLParen (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(6LL /* TokenLParen */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLParen (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenRParen (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(7LL /* TokenRParen */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRParen (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLSquare (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(8LL /* TokenLSquare */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLSquare (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenRSquare (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(9LL /* TokenRSquare */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRSquare (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLCurly (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(10LL /* TokenLCurly */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLCurly (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenRCurly (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(11LL /* TokenRCurly */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRCurly (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLColon (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(12LL /* TokenLColon */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLColon (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenRColon (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(13LL /* TokenRColon */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRColon (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenInt (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(14LL /* TokenInt */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_token_TokenValue_TokenInt (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenF64 (double x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(15LL /* TokenF64 */);
	v2->cells[1] = MKF64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static double mtp_mirth_token_TokenValue_TokenF64 (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VF64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenStr (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(16LL /* TokenStr */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_token_TokenValue_TokenStr (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_token_TokenValue_TokenName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(17LL /* TokenName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenName (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenDName (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(18LL /* TokenDName */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_token_TokenValue_TokenDName (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPop (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(19LL /* TokenLabelPop */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPop (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPush (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(20LL /* TokenLabelPush */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPush (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPopR (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(21LL /* TokenLabelPopR */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPopR (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPushR (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(22LL /* TokenLabelPushR */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPushR (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelGet (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(23LL /* TokenLabelGet */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelGet (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelSet (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(24LL /* TokenLabelSet */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelSet (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_location_Location_Location (uint64_t x1, int64_t x2, int64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* Location */);
	v4->cells[3] = MKI64(x3);
	v4->cells[2] = MKI64(x2);
	v4->cells[1] = MKU64(x1);
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_location_Location_Location (VAL x1, uint64_t *x2, int64_t *x3, int64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VI64(v7);
	*x3 = VI64(v6);
	*x2 = VU64(v5);
}
static VAL mtw_mirth_mirth_Builtin_Builtin (uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t x7, uint64_t x8, uint64_t x9, uint64_t x10, uint64_t x11, uint64_t x12, uint64_t x13, uint64_t x14, uint64_t x15, uint64_t x16, uint64_t x17, uint64_t x18, uint64_t x19, uint64_t x20, uint64_t x21, uint64_t x22, uint64_t x23, uint64_t x24, uint64_t x25, uint64_t x26, uint64_t x27, uint64_t x28, uint64_t x29, uint64_t x30, uint64_t x31, uint64_t x32, uint64_t x33, uint64_t x34, uint64_t x35, uint64_t x36, uint64_t x37, uint64_t x38, uint64_t x39, uint64_t x40, uint64_t x41, uint64_t x42, uint64_t x43, uint64_t x44, uint64_t x45, uint64_t x46, uint64_t x47, uint64_t x48, uint64_t x49, uint64_t x50, uint64_t x51, uint64_t x52, uint64_t x53, uint64_t x54, uint64_t x55, uint64_t x56, uint64_t x57, uint64_t x58, uint64_t x59, uint64_t x60, uint64_t x61) {
	TUP* v62 = tup_new(62);
	v62->size = 62;
	v62->cells[0] = MKI64(0LL /* Builtin */);
	v62->cells[61] = MKU64(x61);
	v62->cells[60] = MKU64(x60);
	v62->cells[59] = MKU64(x59);
	v62->cells[58] = MKU64(x58);
	v62->cells[57] = MKU64(x57);
	v62->cells[56] = MKU64(x56);
	v62->cells[55] = MKU64(x55);
	v62->cells[54] = MKU64(x54);
	v62->cells[53] = MKU64(x53);
	v62->cells[52] = MKU64(x52);
	v62->cells[51] = MKU64(x51);
	v62->cells[50] = MKU64(x50);
	v62->cells[49] = MKU64(x49);
	v62->cells[48] = MKU64(x48);
	v62->cells[47] = MKU64(x47);
	v62->cells[46] = MKU64(x46);
	v62->cells[45] = MKU64(x45);
	v62->cells[44] = MKU64(x44);
	v62->cells[43] = MKU64(x43);
	v62->cells[42] = MKU64(x42);
	v62->cells[41] = MKU64(x41);
	v62->cells[40] = MKU64(x40);
	v62->cells[39] = MKU64(x39);
	v62->cells[38] = MKU64(x38);
	v62->cells[37] = MKU64(x37);
	v62->cells[36] = MKU64(x36);
	v62->cells[35] = MKU64(x35);
	v62->cells[34] = MKU64(x34);
	v62->cells[33] = MKU64(x33);
	v62->cells[32] = MKU64(x32);
	v62->cells[31] = MKU64(x31);
	v62->cells[30] = MKU64(x30);
	v62->cells[29] = MKU64(x29);
	v62->cells[28] = MKU64(x28);
	v62->cells[27] = MKU64(x27);
	v62->cells[26] = MKU64(x26);
	v62->cells[25] = MKU64(x25);
	v62->cells[24] = MKU64(x24);
	v62->cells[23] = MKU64(x23);
	v62->cells[22] = MKU64(x22);
	v62->cells[21] = MKU64(x21);
	v62->cells[20] = MKU64(x20);
	v62->cells[19] = MKU64(x19);
	v62->cells[18] = MKU64(x18);
	v62->cells[17] = MKU64(x17);
	v62->cells[16] = MKU64(x16);
	v62->cells[15] = MKU64(x15);
	v62->cells[14] = MKU64(x14);
	v62->cells[13] = MKU64(x13);
	v62->cells[12] = MKU64(x12);
	v62->cells[11] = MKU64(x11);
	v62->cells[10] = MKU64(x10);
	v62->cells[9] = MKU64(x9);
	v62->cells[8] = MKU64(x8);
	v62->cells[7] = MKU64(x7);
	v62->cells[6] = MKU64(x6);
	v62->cells[5] = MKU64(x5);
	v62->cells[4] = MKU64(x4);
	v62->cells[3] = MKU64(x3);
	v62->cells[2] = MKU64(x2);
	v62->cells[1] = MKU64(x1);
	VAL v63 = MKTUP(v62, 62);
	return v63;
}
static VAL mtw_mirth_mirth_ZPlusMirth_ZPlusMirth (int64_t x1, int64_t x2, int64_t x3, VAL x4, VAL x5, VAL x6, VAL x7, VAL x8, VAL x9) {
	TUP* v10 = tup_new(10);
	v10->size = 10;
	v10->cells[0] = MKI64(0LL /* +Mirth */);
	v10->cells[9] = x9;
	v10->cells[8] = x8;
	v10->cells[7] = x7;
	v10->cells[6] = x6;
	v10->cells[5] = x5;
	v10->cells[4] = x4;
	v10->cells[3] = MKI64(x3);
	v10->cells[2] = MKI64(x2);
	v10->cells[1] = MKI64(x1);
	VAL v11 = (MKTUP(v10, 10));
	return v11;
}
static void mtp_mirth_mirth_ZPlusMirth_ZPlusMirth (VAL x1, int64_t *x2, int64_t *x3, int64_t *x4, VAL *x5, VAL *x6, VAL *x7, VAL *x8, VAL *x9, VAL *x10) {
	VAL v11 = VTUP(x1)->cells[1];
	VAL v12 = VTUP(x1)->cells[2];
	VAL v13 = VTUP(x1)->cells[3];
	VAL v14 = VTUP(x1)->cells[4];
	VAL v15 = VTUP(x1)->cells[5];
	VAL v16 = VTUP(x1)->cells[6];
	VAL v17 = VTUP(x1)->cells[7];
	VAL v18 = VTUP(x1)->cells[8];
	VAL v19 = VTUP(x1)->cells[9];
	tup_decref_outer(VTUP(x1),10);
	*x10 = v19;
	*x9 = v18;
	*x8 = v17;
	*x7 = v16;
	*x6 = v15;
	*x5 = v14;
	*x4 = VI64(v13);
	*x3 = VI64(v12);
	*x2 = VI64(v11);
}
static VAL mtw_mirth_mirth_Diagnostic_Diagnostic (int64_t x1, VAL x2, VAL x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* Diagnostic */);
	v4->cells[3] = x3;
	v4->cells[2] = x2;
	v4->cells[1] = MKI64(x1);
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_mirth_Diagnostic_Diagnostic (VAL x1, int64_t *x2, VAL *x3, VAL *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = v7;
	*x3 = v6;
	*x2 = VI64(v5);
}
static VAL mtw_mirth_mirth_Prop_1_Prop (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* Prop */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_mirth_PropState_1_PSReady (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* PSReady */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_mirth_PropState_1_PSReady (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_mirth_PropState_1_PSDelay (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(1LL /* PSDelay */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_mirth_PropState_1_PSDelay (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_mirth_PropLabel_DataQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* DataQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_DataParams (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* DataParams */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_DataCType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* DataCType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_TagType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* TagType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_TableQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* TableQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_TypeDefQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(5LL /* TypeDefQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_TypeDefTarget (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(6LL /* TypeDefTarget */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_WordQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(7LL /* WordQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_WordType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(8LL /* WordType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_WordParams (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(9LL /* WordParams */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_WordArrow (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(10LL /* WordArrow */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_BlockArrow (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(11LL /* BlockArrow */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_AliasQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(12LL /* AliasQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_AliasTarget (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(13LL /* AliasTarget */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_ExternalQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(14LL /* ExternalQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_ExternalType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(15LL /* ExternalType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_ExternalCType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(16LL /* ExternalCType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_VariableType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(17LL /* VariableType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_FieldQName (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(18LL /* FieldQName */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_FieldValueType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(19LL /* FieldValueType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_mirth_PropLabel_FieldIndexType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(20LL /* FieldIndexType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtw_mirth_def_Def_DefAlias (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* DefAlias */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefAlias (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefModule (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* DefModule */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefModule (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefPackage (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* DefPackage */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefPackage (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefData (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* DefData */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefData (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefTable (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* DefTable */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefTable (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefType (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(5LL /* DefType */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefType (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefTag (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(6LL /* DefTag */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefTag (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefPrim (int64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(7LL /* DefPrim */);
	v2->cells[1] = MKI64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static int64_t mtp_mirth_def_Def_DefPrim (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v2);
}
static VAL mtw_mirth_def_Def_DefWord (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(8LL /* DefWord */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefWord (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefBuffer (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(9LL /* DefBuffer */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefBuffer (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefVariable (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(10LL /* DefVariable */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefVariable (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefExternal (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(11LL /* DefExternal */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefExternal (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_def_Def_DefField (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(12LL /* DefField */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_def_Def_DefField (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* NAMESPACE_PACKAGE */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_MODULE (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* NAMESPACE_MODULE */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_name_Namespace_NAMESPACEz_MODULE (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_TYCON (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* NAMESPACE_TYCON */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_name_Namespace_NAMESPACEz_TYCON (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_WORD (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* NAMESPACE_WORD */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_name_Namespace_NAMESPACEz_WORD (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_name_QName_MKQNAME (VAL x1, uint64_t x2, int64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* MKQNAME */);
	v4->cells[3] = MKI64(x3);
	v4->cells[2] = MKU64(x2);
	v4->cells[1] = x1;
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_name_QName_MKQNAME (VAL x1, VAL *x2, uint64_t *x3, int64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VI64(v7);
	*x3 = VU64(v6);
	*x2 = v5;
}
static VAL mtw_mirth_name_DName_DName (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* DName */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_name_DName_DName (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_lexer_ZPlusLexer_ZPlusLexer (uint64_t x1, int64_t x2, int64_t x3, VAL x4, uint64_t x5, VAL x6) {
	TUP* v7 = tup_new(7);
	v7->size = 7;
	v7->cells[0] = MKI64(0LL /* +Lexer */);
	v7->cells[6] = x6;
	v7->cells[5] = MKU64(x5);
	v7->cells[4] = x4;
	v7->cells[3] = MKI64(x3);
	v7->cells[2] = MKI64(x2);
	v7->cells[1] = MKU64(x1);
	VAL v8 = (MKTUP(v7, 7));
	return v8;
}
static void mtp_mirth_lexer_ZPlusLexer_ZPlusLexer (VAL x1, uint64_t *x2, int64_t *x3, int64_t *x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = VTUP(x1)->cells[1];
	VAL v9 = VTUP(x1)->cells[2];
	VAL v10 = VTUP(x1)->cells[3];
	VAL v11 = VTUP(x1)->cells[4];
	VAL v12 = VTUP(x1)->cells[5];
	VAL v13 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	*x7 = v13;
	*x6 = VU64(v12);
	*x5 = v11;
	*x4 = VI64(v10);
	*x3 = VI64(v9);
	*x2 = VU64(v8);
}
static VAL mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab (VAL x1, uint64_t x2, int64_t x3, int64_t x4) {
	TUP* v5 = tup_new(5);
	v5->size = 5;
	v5->cells[0] = MKI64(0LL /* +TypeElab */);
	v5->cells[4] = MKI64(x4);
	v5->cells[3] = MKI64(x3);
	v5->cells[2] = MKU64(x2);
	v5->cells[1] = x1;
	VAL v6 = (MKTUP(v5, 5));
	return v6;
}
static void mtp_mirth_elab_ZPlusTypeElab_ZPlusTypeElab (VAL x1, VAL *x2, uint64_t *x3, int64_t *x4, int64_t *x5) {
	VAL v6 = VTUP(x1)->cells[1];
	VAL v7 = VTUP(x1)->cells[2];
	VAL v8 = VTUP(x1)->cells[3];
	VAL v9 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	*x5 = VI64(v9);
	*x4 = VI64(v8);
	*x3 = VU64(v7);
	*x2 = v6;
}
static VAL mtw_mirth_elab_ZPlusResolveDef_ZPlusResolveDef (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, int64_t x6, int64_t x7) {
	TUP* v8 = tup_new(8);
	v8->size = 8;
	v8->cells[0] = MKI64(0LL /* +ResolveDef */);
	v8->cells[7] = MKI64(x7);
	v8->cells[6] = MKI64(x6);
	v8->cells[5] = x5;
	v8->cells[4] = x4;
	v8->cells[3] = x3;
	v8->cells[2] = MKU64(x2);
	v8->cells[1] = x1;
	VAL v9 = (MKTUP(v8, 8));
	return v9;
}
static void mtp_mirth_elab_ZPlusResolveDef_ZPlusResolveDef (VAL x1, VAL *x2, uint64_t *x3, VAL *x4, VAL *x5, VAL *x6, int64_t *x7, int64_t *x8) {
	VAL v9 = VTUP(x1)->cells[1];
	VAL v10 = VTUP(x1)->cells[2];
	VAL v11 = VTUP(x1)->cells[3];
	VAL v12 = VTUP(x1)->cells[4];
	VAL v13 = VTUP(x1)->cells[5];
	VAL v14 = VTUP(x1)->cells[6];
	VAL v15 = VTUP(x1)->cells[7];
	tup_decref_outer(VTUP(x1),8);
	*x8 = VI64(v15);
	*x7 = VI64(v14);
	*x6 = v13;
	*x5 = v12;
	*x4 = v11;
	*x3 = VU64(v10);
	*x2 = v9;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* RD_WRONG_SORT */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* RD_WRONG_ARITY */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* RD_NOT_IMPORTED */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(4LL /* RD_WRONG_QUALIFIER */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(5LL /* RD_WRONG_CONSTRUCTOR */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(6LL /* RD_METHOD_NOT_AVAILABLE */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(7LL /* RD_METHOD_WRONG_TYPE */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_OpSig_OPSIGz_PUSH (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* OPSIG_PUSH */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_OpSig_OPSIGz_PUSH (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_OpSig_OPSIGz_APPLY (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* OPSIG_APPLY */);
	v2->cells[1] = x1;
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static VAL mtp_mirth_elab_OpSig_OPSIGz_APPLY (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_elab_SyntaxData_SyntaxData (uint64_t x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* SyntaxData */);
	v3->cells[2] = x2;
	v3->cells[1] = MKU64(x1);
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_elab_SyntaxData_SyntaxData (VAL x1, uint64_t *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = VU64(v4);
}
static VAL mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag (uint64_t x1, VAL x2, uint64_t x3, VAL x4) {
	TUP* v5 = tup_new(5);
	v5->size = 5;
	v5->cells[0] = MKI64(0LL /* SyntaxDataTag */);
	v5->cells[4] = x4;
	v5->cells[3] = MKU64(x3);
	v5->cells[2] = x2;
	v5->cells[1] = MKU64(x1);
	VAL v6 = MKTUP(v5, 5);
	return v6;
}
static VAL mtw_mirth_elab_SyntaxDef_SyntaxDef (uint64_t x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* SyntaxDef */);
	v4->cells[3] = MKU64(x3);
	v4->cells[2] = x2;
	v4->cells[1] = MKU64(x1);
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_elab_SyntaxDef_SyntaxDef (VAL x1, uint64_t *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v7);
	*x3 = v6;
	*x2 = VU64(v5);
}
static VAL mtw_mirth_elab_ExternalDeclPart_EDPCode (uint64_t x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* EDPCode */);
	v3->cells[2] = x2;
	v3->cells[1] = MKU64(x1);
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static void mtp_mirth_elab_ExternalDeclPart_EDPCode (VAL x1, uint64_t *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = VU64(v4);
}
static VAL mtw_mirth_elab_ExternalDeclPart_EDPDef (uint64_t x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(1LL /* EDPDef */);
	v4->cells[3] = MKU64(x3);
	v4->cells[2] = x2;
	v4->cells[1] = MKU64(x1);
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_elab_ExternalDeclPart_EDPDef (VAL x1, uint64_t *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v7);
	*x3 = v6;
	*x2 = VU64(v5);
}
static VAL mtw_std_map_KVPair_2_KVPair (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* KVPair */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_specializzer_SPCheckItem_SPCHECKz_WORD (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* SPCHECK_WORD */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_specializzer_SPCheckItem_SPCHECKz_WORD (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* SPCHECK_BLOCK */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	TUP* v5 = tup_new(5);
	v5->size = 5;
	v5->cells[0] = MKI64(0LL /* +SPSYNTH */);
	v5->cells[4] = x3;
	v5->cells[3] = MKU64(x2);
	v5->cells[2] = x1;
	v5->cells[1] = x4;
	VAL v6 = (MKTUP(v5, 5));
	return v6;
}
static void mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH (VAL x1, VAL *x2, uint64_t *x3, VAL *x4, VAL *x5) {
	VAL v6 = (VTUP(x1)->cells[1]);
	VAL v7 = VTUP(x1)->cells[2];
	VAL v8 = VTUP(x1)->cells[3];
	VAL v9 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	*x5 = v6;
	*x4 = v9;
	*x3 = VU64(v8);
	*x2 = v7;
}
static VAL mtw_mirth_need_Need_NEEDz_WORD (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* NEED_WORD */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_need_Need_NEEDz_WORD (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_need_Need_NEEDz_BLOCK (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* NEED_BLOCK */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_need_Need_NEEDz_BLOCK (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_need_Need_NEEDz_TAGW (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(2LL /* NEED_TAGW */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_need_Need_NEEDz_TAGW (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_need_Need_NEEDz_TAGP (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* NEED_TAGP */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_need_Need_NEEDz_TAGP (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_need_ZPlusNeeds_ZPlusNeeds (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +Needs */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_mirth_need_ZPlusNeeds_ZPlusNeeds (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_c99_C99z_Options_C99z_Options (VAL x1, int64_t x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* C99_Options */);
	v3->cells[2] = MKI64(x2);
	v3->cells[1] = x1;
	VAL v4 = MKTUP(v3, 3);
	return v4;
}
static VAL mtw_mirth_c99_ZPlusC99_ZPlusC99 (VAL x1, int64_t x2, int64_t x3, VAL x4, VAL x5, VAL x6) {
	TUP* v7 = tup_new(7);
	v7->size = 7;
	v7->cells[0] = MKI64(0LL /* +C99 */);
	v7->cells[6] = x6;
	v7->cells[5] = x5;
	v7->cells[4] = x4;
	v7->cells[3] = MKI64(x3);
	v7->cells[2] = MKI64(x2);
	v7->cells[1] = x1;
	VAL v8 = (MKTUP(v7, 7));
	return v8;
}
static void mtp_mirth_c99_ZPlusC99_ZPlusC99 (VAL x1, VAL *x2, int64_t *x3, int64_t *x4, VAL *x5, VAL *x6, VAL *x7) {
	VAL v8 = VTUP(x1)->cells[1];
	VAL v9 = VTUP(x1)->cells[2];
	VAL v10 = VTUP(x1)->cells[3];
	VAL v11 = VTUP(x1)->cells[4];
	VAL v12 = VTUP(x1)->cells[5];
	VAL v13 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	*x7 = v13;
	*x6 = v12;
	*x5 = v11;
	*x4 = VI64(v10);
	*x3 = VI64(v9);
	*x2 = v8;
}
static VAL mtw_mirth_c99_C99APIArgSource_C99AASz_ValueLabel (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* C99AAS_ValueLabel */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel (uint64_t x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(3LL /* C99AAS_ResourceLabel */);
	v2->cells[1] = MKU64(x1);
	VAL v3 = MKTUP(v2, 2);
	return v3;
}
static uint64_t mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel (VAL x1) {
	VAL v2 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v2);
}
static VAL mtw_mirth_c99_C99APIArg_C99APIArg (VAL x1, int64_t x2, VAL x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(0LL /* C99APIArg */);
	v4->cells[3] = x3;
	v4->cells[2] = MKI64(x2);
	v4->cells[1] = x1;
	VAL v5 = MKTUP(v4, 4);
	return v5;
}
static void mtp_mirth_c99_C99APIArg_C99APIArg (VAL x1, VAL *x2, int64_t *x3, VAL *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = VTUP(x1)->cells[2];
	VAL v7 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	*x4 = v7;
	*x3 = VI64(v6);
	*x2 = v5;
}
static VAL mtw_mirth_c99_C99API_C99API (VAL x1, VAL x2, VAL x3, VAL x4, VAL x5, int64_t x6) {
	TUP* v7 = tup_new(7);
	v7->size = 7;
	v7->cells[0] = MKI64(0LL /* C99API */);
	v7->cells[6] = MKI64(x6);
	v7->cells[5] = x5;
	v7->cells[4] = x4;
	v7->cells[3] = x3;
	v7->cells[2] = x2;
	v7->cells[1] = x1;
	VAL v8 = MKTUP(v7, 7);
	return v8;
}
static VAL mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local (int64_t x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +C99Local */);
	v3->cells[2] = x2;
	v3->cells[1] = MKI64(x1);
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = VI64(v4);
}
static VAL mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource (int64_t x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +C99LocalResource */);
	v3->cells[2] = x2;
	v3->cells[1] = MKI64(x1);
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = VI64(v4);
}
static VAL mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(0LL /* +Left */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* +Right */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* +C99LocalSome */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome (VAL x1) {
	TUP* v2 = tup_new(2);
	v2->size = 2;
	v2->cells[0] = MKI64(1LL /* +C99LocalResourceSome */);
	v2->cells[1] = x1;
	VAL v3 = (MKTUP(v2, 2));
	return v3;
}
static VAL mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome (VAL x1) {
	VAL v2 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v2;
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(1LL /* +SCCons */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = (VTUP(x1)->cells[1]);
	VAL v5 = (VTUP(x1)->cells[2]);
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(2LL /* +SCWith */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = (VTUP(x1)->cells[1]);
	VAL v5 = (VTUP(x1)->cells[2]);
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(3LL /* +SCConsLabel */);
	v4->cells[3] = x2;
	v4->cells[2] = x1;
	v4->cells[1] = MKU64(x3);
	VAL v5 = (MKTUP(v4, 4));
	return v5;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel (VAL x1, VAL *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = (VTUP(x1)->cells[2]);
	VAL v7 = (VTUP(x1)->cells[3]);
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v5);
	*x3 = v7;
	*x2 = v6;
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v4 = tup_new(4);
	v4->size = 4;
	v4->cells[0] = MKI64(4LL /* +SCWithLabel */);
	v4->cells[3] = x2;
	v4->cells[2] = x1;
	v4->cells[1] = MKU64(x3);
	VAL v5 = (MKTUP(v4, 4));
	return v5;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel (VAL x1, VAL *x2, VAL *x3, uint64_t *x4) {
	VAL v5 = VTUP(x1)->cells[1];
	VAL v6 = (VTUP(x1)->cells[2]);
	VAL v7 = (VTUP(x1)->cells[3]);
	tup_decref_outer(VTUP(x1),4);
	*x4 = VU64(v5);
	*x3 = v7;
	*x2 = v6;
}
static VAL mtw_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit (VAL x1, VAL x2, VAL x3, int64_t x4) {
	TUP* v5 = tup_new(5);
	v5->size = 5;
	v5->cells[0] = MKI64(0LL /* +C99BranchSplit */);
	v5->cells[4] = MKI64(x4);
	v5->cells[3] = x3;
	v5->cells[2] = x2;
	v5->cells[1] = x1;
	VAL v6 = (MKTUP(v5, 5));
	return v6;
}
static void mtp_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit (VAL x1, VAL *x2, VAL *x3, VAL *x4, int64_t *x5) {
	VAL v6 = VTUP(x1)->cells[1];
	VAL v7 = VTUP(x1)->cells[2];
	VAL v8 = VTUP(x1)->cells[3];
	VAL v9 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	*x5 = VI64(v9);
	*x4 = v8;
	*x3 = v7;
	*x2 = v6;
}
static VAL mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch (VAL x1, VAL x2) {
	TUP* v3 = tup_new(3);
	v3->size = 3;
	v3->cells[0] = MKI64(0LL /* +C99Branch */);
	v3->cells[2] = x2;
	v3->cells[1] = x1;
	VAL v4 = (MKTUP(v3, 3));
	return v4;
}
static void mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VTUP(x1)->cells[1];
	VAL v5 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	*x3 = v5;
	*x2 = v4;
}
static VAL mtw_mirth_main_Arguments_Arguments (VAL x1, VAL x2, VAL x3, VAL x4, VAL x5, int64_t x6) {
	TUP* v7 = tup_new(7);
	v7->size = 7;
	v7->cells[0] = MKI64(0LL /* Arguments */);
	v7->cells[6] = MKI64(x6);
	v7->cells[5] = x5;
	v7->cells[4] = x4;
	v7->cells[3] = x3;
	v7->cells[2] = x2;
	v7->cells[1] = x1;
	VAL v8 = MKTUP(v7, 7);
	return v8;
}
static void mtp_mirth_main_Arguments_Arguments (VAL x1, VAL *x2, VAL *x3, VAL *x4, VAL *x5, VAL *x6, int64_t *x7) {
	VAL v8 = VTUP(x1)->cells[1];
	VAL v9 = VTUP(x1)->cells[2];
	VAL v10 = VTUP(x1)->cells[3];
	VAL v11 = VTUP(x1)->cells[4];
	VAL v12 = VTUP(x1)->cells[5];
	VAL v13 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	*x7 = VI64(v13);
	*x6 = v12;
	*x5 = v11;
	*x4 = v10;
	*x3 = v9;
	*x2 = v8;
}
static char mbuf_mirth_label_Label_NUM[8] = {0};
static char mbuf_mirth_var_Var_NUM[8] = {0};
static char mbuf_mirth_buffer_Buffer_NUM[8] = {0};
static char mbuf_mirth_word_Word_NUM[8] = {0};
static char mbuf_mirth_table_Table_NUM[8] = {0};
static char mbuf_mirth_table_Field_NUM[8] = {0};
static char mbuf_mirth_data_Data_NUM[8] = {0};
static char mbuf_mirth_data_Tag_NUM[8] = {0};
static char mbuf_mirth_external_External_NUM[8] = {0};
static char mbuf_mirth_external_ExternalBlock_NUM[8] = {0};
static char mbuf_mirth_variable_Variable_NUM[8] = {0};
static char mbuf_mirth_arrow_Block_NUM[8] = {0};
static char mbuf_mirth_typedef_TypeDef_NUM[8] = {0};
static char mbuf_mirth_type_MetaVar_NUM[8] = {0};
static char mbuf_mirth_token_Token_NUM[8] = {0};
static char mbuf_mirth_module_Module_NUM[8] = {0};
static char mbuf_mirth_alias_Alias_NUM[8] = {0};
static char mbuf_mirth_name_Name_NUM[8] = {0};
static char mbuf_mirth_name_HASHz_BUF[524288] = {0};
static char mbuf_mirth_package_Package_NUM[8] = {0};
size_t strlen (const char *);
static void mext_std_ctypes_CStr_numZ_bytes (int64_t x1, void* x2, int64_t *x3, int64_t *x4) {
	const char * X2 = (const char *)(x2);
	size_t Y = strlen(X2);
	int64_t v5 = ((int64_t)(0));
	int64_t v6 = (int64_t)(Y);
	*x4 = v6;
	*x3 = v5;
}
int read (int, void*, size_t);
static int64_t mext_std_posix_externalZ_posixZ_read (int64_t x1, void* x2, int64_t x3) {
	size_t X3 = (size_t)(x3);
	void* X2 = (void*)(x2);
	int X1 = (int)(x1);
	int Y = read(X1, X2, X3);
	int64_t v4 = (int64_t)(Y);
	return v4;
}
int write (int, const char *, size_t);
static int64_t mext_std_posix_externalZ_posixZ_write (int64_t x1, void* x2, int64_t x3) {
	size_t X3 = (size_t)(x3);
	const char * X2 = (const char *)(x2);
	int X1 = (int)(x1);
	int Y = write(X1, X2, X3);
	int64_t v4 = (int64_t)(Y);
	return v4;
}
int close (int);
static int64_t mext_std_posix_externalZ_posixZ_close (int64_t x1) {
	int X1 = (int)(x1);
	int Y = close(X1);
	int64_t v2 = (int64_t)(Y);
	return v2;
}
void exit (int);
static void mext_std_posix_externalZ_posixZ_exit (int64_t x1) {
	int X1 = (int)(x1);
	exit(X1);
}
int open_internal(const char* path, int flags, int mode) { return open(path, flags, mode); }
int open_internal (const char *, int, int);
static int64_t mext_std_posix_internalZ_posixZ_open (void* x1, int64_t x2, int64_t x3) {
	int X3 = (int)(x3);
	int X2 = (int)(x2);
	const char * X1 = (const char *)(x1);
	int Y = open_internal(X1, X2, X3);
	int64_t v4 = (int64_t)(Y);
	return v4;
}
int stat (const char *, void*);
static void mext_std_world_posixZ_stat (int64_t x1, void* x2, void* x3, int64_t *x4, int64_t *x5) {
	void* X3 = (void*)(x3);
	const char * X2 = (const char *)(x2);
	int Y = stat(X2, X3);
	int64_t v6 = ((int64_t)(0));
	int64_t v7 = (int64_t)(Y);
	*x5 = v7;
	*x4 = v6;
}
double strtod(const char*, char**);
double string_to_float64(const char* float64_str) {
    return strtod(float64_str, 0);
}
double string_to_float64 (const char *);
static double mext_mirth_lexer_stringz_toz_float64 (void* x1) {
	const char * X1 = (const char *)(x1);
	double Y = string_to_float64(X1);
	double v2 = (double)(Y);
	return v2;
}
static VAL mw_std_either_Either_2_leftZAsk (VAL x1);
static VAL mw_std_either_Either_2_rightZAsk (VAL x1);
static int64_t mw_std_prim_Int_ZToByte (int64_t x1);
static int64_t mw_std_prim_U8_ZToByte (int64_t x1);
static void mw_std_prim_Ptr_ZAtByte (void* x1, int64_t x2, int64_t *x3, int64_t *x4);
static int64_t mw_std_byte_Byte_isZ_upper (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_lower (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_digit (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_alpha (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_alnum (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_printable (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_hexdigit (int64_t x1);
static VAL mw_std_byte_Byte_emitZ_asciiZThen (VAL x1, int64_t x2);
static VAL mw_std_byte_Byte_toZ_strZ_unsafe (int64_t x1);
static VAL mw_std_byte_Byte_toZ_asciiZ_str (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_stringZ_end (int64_t x1);
static void mw_std_byte_Byte_toZ_hexdigits (int64_t x1, int64_t *x2, int64_t *x3);
static int64_t mw_std_byte_oneZ_hexdigitZ_byte (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_nameZ_byte (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_sign (int64_t x1);
static VAL mw_std_byte_Byte_zzencode (int64_t x1);
static VAL mw_std_buffer_ZPlusBuffer_new (int64_t x1);
static VAL mw_std_buffer_ZPlusBuffer_resizzeZBang (int64_t x1, VAL x2);
static VAL mw_std_buffer_ZPlusBuffer_expandZBang (int64_t x1, VAL x2);
static void mw_std_buffer_ZPlusBuffer_rdrop (VAL x1);
static VAL mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang (int64_t x1, int64_t x2, VAL x3);
static void mw_std_buffer_ZPlusBuffer_clampZ_spanZBang (int64_t x1, int64_t x2, VAL x3, int64_t *x4, int64_t *x5, VAL *x6);
static void mw_std_buffer_ZPlusBuffer_prepareZ_spanZBang (int64_t x1, int64_t x2, VAL x3, int64_t *x4, VAL *x5);
static void mw_std_buffer_ZPlusBuffer_ZAtU8 (int64_t x1, VAL x2, int64_t *x3, VAL *x4);
static VAL mw_std_buffer_ZPlusBuffer_ZBangU8 (int64_t x1, int64_t x2, VAL x3);
static VAL mw_std_buffer_ZPlusBuffer_ZBangByte (int64_t x1, int64_t x2, VAL x3);
static VAL mw_std_buffer_ZPlusBuffer_ZBangStr (VAL x1, int64_t x2, VAL x3);
static void mw_std_buffer_ZPlusBuffer_ZAtStr (int64_t x1, int64_t x2, VAL x3, VAL *x4, VAL *x5);
static void mw_std_prim_Ptr_ZBangStrZPlus (VAL x1, void* x2, int64_t x3, void* *x4, int64_t *x5);
static void mw_std_str_ZPlusStr_dupZBang (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_numZ_bytesZAsk (VAL x1, int64_t *x2, VAL *x3);
static int64_t mw_std_prim_Str_lastZ_byte (VAL x1);
static void mw_std_str_ZPlusStr_lastZ_byte (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_byteZAt (int64_t x1, VAL x2, int64_t *x3, VAL *x4);
static int64_t mw_std_str_offsetZ_inZ_bounds (int64_t x1, int64_t x2);
static int64_t mw_std_prim_Str_byteZAt (int64_t x1, VAL x2);
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang (int64_t x1, VAL x2);
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang (int64_t x1, VAL x2);
static VAL mw_std_str_ZPlusStr_pushZ_strZBang (VAL x1, VAL x2);
static void mw_std_prim_Str_dropZ_bytes (int64_t x1, VAL x2, int64_t x3, VAL *x4, int64_t *x5);
static VAL mw_std_prim_Str_fromZ_bytesZ_unsafe (VAL x1);
static void mw_std_str_clampZ_sliceZ_offsetZ_sizze (int64_t x1, int64_t x2, int64_t x3, int64_t *x4, int64_t *x5);
static void mw_std_prim_Str_slice (int64_t x1, int64_t x2, VAL x3, int64_t x4, VAL *x5, int64_t *x6);
static void mw_std_prim_Str_dropZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, int64_t *x5);
static void mw_std_prim_Str_takeZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, int64_t *x5);
static void mw_std_str_ZPlusStr_slice (int64_t x1, int64_t x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, int64_t *x7);
static void mw_std_str_ZPlusStr_offsetZ_slice (int64_t x1, int64_t x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, int64_t *x7);
static void mw_std_str_ZPlusStr_takeZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, VAL *x5, int64_t *x6);
static void mw_std_str_ZPlusStr_dropZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, VAL *x5, int64_t *x6);
static void mw_std_str_ZPlusStr_splitZ_byte (int64_t x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_std_prim_Str_splitZ_byte (int64_t x1, VAL x2);
static void mw_std_str_ZPlusStr_pushZ_showZ_byteZBang (VAL x1, int64_t x2, int64_t x3, int64_t *x4, VAL *x5);
static VAL mw_std_prim_Str_showZThen (VAL x1, VAL x2);
static int64_t mw_std_list_List_1_ZDivL0 (VAL x1);
static VAL mw_std_list_List_1_ZDivL1 (VAL x1);
static VAL mw_std_list_List_1_ZDivL2 (VAL x1);
static int64_t mw_std_list_List_1_emptyZAsk (VAL x1);
static int64_t mw_std_list_List_1_len (VAL x1);
static VAL mw_std_list_List_1_ZToListZPlus (VAL x1);
static void mw_std_list_List_1_uncons (VAL x1, VAL *x2, VAL *x3);
static void mw_std_list_ListZPlus_1_uncons (VAL x1, VAL *x2, VAL *x3);
static void mw_std_list_List_1_unsnoc (VAL x1, VAL *x2, VAL *x3);
static void mw_std_list_ListZPlus_1_unsnoc (VAL x1, VAL *x2, VAL *x3);
static VAL mw_std_list_List_1_cat (VAL x1, VAL x2);
static VAL mw_std_list_List_1_first (VAL x1);
static VAL mw_std_list_List_1_last (VAL x1);
static VAL mw_std_list_ListZPlus_1_first (VAL x1);
static VAL mw_std_list_ListZPlus_1_last (VAL x1);
static VAL mw_std_list_List_1_reverse (VAL x1);
static VAL mw_std_list_ListZPlus_1_reverse (VAL x1);
static VAL mw_std_prim_Int_range (int64_t x1, int64_t x2);
static int64_t mw_std_maybe_Maybe_1_noneZAsk (VAL x1);
static int64_t mw_std_maybe_Maybe_1_someZAsk (VAL x1);
static int64_t mw_std_maybe_Maybe_1_ZToBool (VAL x1);
static VAL mw_std_maybe_Maybe_1_ZToList (VAL x1);
static VAL mw_std_maybe_Maybe_1_zzip (VAL x1, VAL x2);
static int64_t mw_std_prim_Int_ZToOS (int64_t x1);
static int64_t mw_std_prim_Int_ZToArch (int64_t x1);
static VAL mw_std_prim_Int_ZToU8ZAsk (int64_t x1);
static VAL mw_std_prim_Int_ZToU16ZAsk (int64_t x1);
static int64_t mw_std_prim_Int_ZToU8 (int64_t x1);
static int64_t mw_std_prim_Int_ZToU16 (int64_t x1);
static int64_t mw_std_prim_Int_ZToI64 (int64_t x1);
static VAL mw_std_prelude_ZAtZAsk (void* x1);
static VAL mw_std_path_PATHz_SEPARATOR (void);
static VAL mw_std_path_Path_joinZ_with (VAL x1, VAL x2, VAL x3);
static VAL mw_std_path_Path_join (VAL x1, VAL x2);
static int64_t mw_std_byte_Byte_isZ_pathZ_separatorZAsk (int64_t x1);
static void mw_std_path_Path_splitZ_last (VAL x1, VAL *x2, VAL *x3);
static VAL mw_std_path_Path_pathZThen (VAL x1, VAL x2);
static VAL mw_std_input_ZPlusInputOpenState_endZBang (VAL x1);
static int64_t mw_std_input_INPUTz_BUFFERz_SIZZE (void);
static VAL mw_std_input_ZPlusInput_startZBang (VAL x1);
static VAL mw_std_input_ZPlusInput_endZBang (VAL x1);
static void mw_std_input_ZPlusInput_doneZAsk (VAL x1, int64_t *x2, VAL *x3);
static VAL mw_std_input_ZPlusInputOpenState_refillZ_bufferZBang (VAL x1);
static void mw_std_input_ZPlusInput_peek (VAL x1, int64_t *x2, VAL *x3);
static VAL mw_std_input_ZPlusInput_moveZBang (VAL x1);
static VAL mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang (VAL x1);
static void mw_std_input_ZPlusInput_readZ_chunkZBang (VAL x1, VAL *x2, VAL *x3);
static void mw_std_input_ZPlusInput_readZ_fileZBang (VAL x1, VAL *x2, VAL *x3);
static int64_t mw_std_output_OUTPUTz_BUFFERz_SIZZE (void);
static VAL mw_std_output_ZPlusOutput_startZBang (VAL x1);
static VAL mw_std_output_ZPlusOutput_endZBang (VAL x1);
static VAL mw_std_output_ZPlusOutput_flushZBang (VAL x1);
static void mw_std_output_ZPlusOutput_offset (VAL x1, VAL *x2, int64_t *x3);
static void mw_std_output_ZPlusOutput_capacityZ_total (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_output_ZPlusOutput_capacityZ_remaining (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_output_ZPlusOutput_fullZAsk (VAL x1, int64_t *x2, VAL *x3);
static VAL mw_std_output_ZPlusOutput_put (VAL x1, VAL x2);
static VAL mw_std_output_ZPlusOutput_putZ_byte (int64_t x1, VAL x2);
static VAL mw_std_output_ZPlusOutput_line (VAL x1);
static int64_t mw_std_posix_posixZ_openZBang (VAL x1, int64_t x2, int64_t x3);
static void mw_std_prim_ZPlusWorld_openZ_fileZBang (VAL x1, int64_t x2, int64_t *x3, VAL *x4);
static void mw_std_prim_ZPlusWorld_createZ_fileZBang (VAL x1, int64_t x2, int64_t *x3, VAL *x4);
static void mw_std_prim_ZPlusWorld_stderrZ_file (int64_t x1, int64_t *x2, VAL *x3);
static VAL mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC (void);
static int64_t mw_std_file_ZPlusFile_closeZ_fileZBang (int64_t x1, VAL x2);
static void mw_std_prelude_ZPlusUnsafe_writeZ_bytesZBang (void* x1, int64_t x2, VAL x3, int64_t x4, int64_t *x5, int64_t *x6, VAL *x7, int64_t *x8);
static void mw_std_prelude_ZPlusUnsafe_readZ_bytesZBang (void* x1, int64_t x2, VAL x3, int64_t x4, int64_t *x5, int64_t *x6, VAL *x7, int64_t *x8);
static void mw_std_file_ZPlusFile_readZ_fileZBang (VAL x1, VAL *x2, VAL *x3);
static int64_t mw_std_prim_ZPlusWorld_traceZ_ (VAL x1, int64_t x2);
static void mw_std_prim_ZPlusWorld_isZ_directoryZAsk (int64_t x1, VAL x2, int64_t *x3, int64_t *x4);
static int64_t mw_std_world_Sz_IFMT (void);
static int64_t mw_std_world_Sz_IFDIR (void);
static int64_t mw_std_world_Sz_ISDIR (int64_t x1);
static void mw_std_world_stz_modeZAt (void* x1, int64_t x2, int64_t *x3, int64_t *x4);
static VAL mw_std_terminal_SGRColor_showZThen (VAL x1, VAL x2);
static VAL mw_std_terminal_Sgr_emitZThen (VAL x1, VAL x2);
static VAL mw_std_terminal_csiZThen (VAL x1);
static VAL mw_argZ_parser_state_State_1_init (VAL x1);
static VAL mw_argZ_parser_state_State_1_argv (VAL x1);
static VAL mw_argZ_parser_state_State_1_programZ_name (VAL x1);
static int64_t mw_argZ_parser_state_State_1_parsingZAsk (VAL x1);
static VAL mw_argZ_parser_state_State_1_parsingZAskZBang (int64_t x1, VAL x2);
static VAL mw_argZ_parser_state_State_1_optionZ_option (VAL x1);
static VAL mw_argZ_parser_state_State_1_optionZ_optionZBang (VAL x1, VAL x2);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop (VAL x1);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_parser (VAL x1, VAL *x2, VAL *x3);
static int64_t mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk (VAL x1);
static VAL mw_argZ_parser_types_ArgumentParsingError_emitZThen (VAL x1, VAL x2);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_usage (VAL x1, VAL *x2, VAL *x3);
static void mw_argZ_parser_types_ArgpOption_usageZThen (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_argZ_parser_parse_checkZ_shortZ_flag (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, int64_t *x6);
static void mw_argZ_parser_parse_checkZ_longZ_flag (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, int64_t *x6);
static void mw_argZ_parser_parse_parseZ_flags (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_argZ_parser_parse_doZ_positionalZ_option (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_argZ_parser_parse_parseZ_args (VAL x1, VAL x2);
static void mw_argZ_parser_parse_readZ_fromZ_argv (int64_t x1, int64_t x2, VAL *x3, int64_t *x4);
static VAL mw_argZ_parser_parse_argvZ_toZ_str (void);
static int64_t mw_mirth_label_Label_index (uint64_t x1);
static uint64_t mw_mirth_label_Label_allocZBang (void);
static uint64_t mw_mirth_label_Label_name (uint64_t x1);
static VAL mw_mirth_label_Label_ZToStr (uint64_t x1);
static int64_t mw_mirth_label_Label_ZEqualZEqual (uint64_t x1, uint64_t x2);
static uint64_t mw_mirth_label_Label_newZBang (uint64_t x1);
static int64_t mw_mirth_label_Label_isZ_resourceZ_labelZAsk (uint64_t x1);
static int64_t mw_mirth_var_Var_index (uint64_t x1);
static uint64_t mw_mirth_var_Var_allocZBang (void);
static uint64_t mw_mirth_var_Var_name (uint64_t x1);
static VAL mw_mirth_var_Var_type (uint64_t x1);
static VAL mw_mirth_var_Var_autoZ_runZAsk (uint64_t x1);
static int64_t mw_mirth_var_Var_ZEqualZEqual (uint64_t x1, uint64_t x2);
static VAL mw_mirth_var_Var_typeZThen (VAL x1, uint64_t x2);
static int64_t mw_mirth_var_Var_isZ_stackZAsk (uint64_t x1);
static int64_t mw_mirth_var_Var_isZ_physicalZAsk (uint64_t x1);
static uint64_t mw_mirth_var_Var_newZBang (VAL x1, uint64_t x2);
static uint64_t mw_mirth_var_Var_newZ_autoZ_runZBang (VAL x1, uint64_t x2);
static VAL mw_std_list_List_1_ZToCtx (VAL x1);
static VAL mw_mirth_var_Ctx_ZToList (VAL x1);
static VAL mw_mirth_var_Ctx0 (void);
static VAL mw_mirth_var_Ctx1 (uint64_t x1);
static VAL mw_mirth_var_Ctx2 (uint64_t x1, uint64_t x2);
static VAL mw_mirth_var_Ctx3 (uint64_t x1, uint64_t x2, uint64_t x3);
static VAL mw_mirth_var_Ctx_new (VAL x1, uint64_t x2);
static VAL mw_mirth_var_Ctx_lookup (uint64_t x1, VAL x2);
static void mw_mirth_var_Ctx_freshZ_nameZBang (VAL x1, VAL *x2, uint64_t *x3);
static void mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang (VAL x1, VAL *x2, uint64_t *x3);
static void mw_mirth_var_Ctx_freshZ_typeZ_varZBang (VAL x1, VAL *x2, uint64_t *x3);
static void mw_mirth_var_Ctx_freshZ_varZBang (VAL x1, VAL x2, VAL *x3, uint64_t *x4);
static void mw_mirth_var_Var_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_var_Var_freshen (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_buffer_Buffer_index (uint64_t x1);
static uint64_t mw_mirth_buffer_Buffer_allocZBang (void);
static int64_t mw_mirth_buffer_Buffer_sizze (uint64_t x1);
static VAL mw_mirth_buffer_Buffer_qname (uint64_t x1);
static uint64_t mw_mirth_buffer_Buffer_name (uint64_t x1);
static int64_t mw_mirth_buffer_Buffer_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_buffer_Buffer_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, uint64_t *x6);
static int64_t mw_mirth_word_Word_index (uint64_t x1);
static uint64_t mw_mirth_word_Word_allocZBang (void);
static VAL mw_mirth_word_Word_qnameZ_soft (uint64_t x1);
static void mw_mirth_word_Word_qnameZ_hard (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_word_Word_namespaceZ_hard (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_word_Word_name (uint64_t x1);
static uint64_t mw_mirth_word_Word_head (uint64_t x1);
static VAL mw_mirth_word_Word_sigZAsk (uint64_t x1);
static uint64_t mw_mirth_word_Word_body (uint64_t x1);
static int64_t mw_mirth_word_Word_arity (uint64_t x1);
static void mw_mirth_word_Word_params (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_word_Word_arrow (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_word_Word_inferringZ_typeZAsk (uint64_t x1);
static void mw_mirth_word_Word_cname (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_word_Word_ctxZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_word_Word_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_word_Word_preferZ_inlineZAsk (uint64_t x1);
static void mw_mirth_word_Word_makeZ_inlineZBang (uint64_t x1);
static void mw_mirth_word_Word_newZBang (uint64_t x1, VAL x2, uint64_t x3, uint64_t x4, int64_t x5, VAL x6, uint64_t *x7, VAL *x8);
static int64_t mw_mirth_word_Word_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_word_Word_incZ_numZ_blocksZBang (uint64_t x1);
static int64_t mw_mirth_table_Table_index (uint64_t x1);
static uint64_t mw_mirth_table_Table_allocZBang (void);
static uint64_t mw_mirth_table_Table_head (uint64_t x1);
static VAL mw_mirth_table_Table_qnameZ_soft (uint64_t x1);
static void mw_mirth_table_Table_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_table_Table_name (uint64_t x1);
static uint64_t mw_mirth_table_Table_numZ_buffer (uint64_t x1);
static int64_t mw_mirth_table_Table_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_table_Field_index (uint64_t x1);
static uint64_t mw_mirth_table_Field_allocZBang (void);
static uint64_t mw_mirth_table_Field_head (uint64_t x1);
static uint64_t mw_mirth_table_Field_name (uint64_t x1);
static VAL mw_mirth_table_Field_qnameZ_soft (uint64_t x1);
static void mw_mirth_table_Field_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_table_Field_indexZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_table_Field_valueZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_table_Field_dom (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_table_Field_cod (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_table_Field_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_table_Field_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_tycon_Tycon_qnameZ_hard (VAL x1, VAL x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_tycon_Tycon_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_tycon_Tycon_fullZ_typeZ_fresh (VAL x1, VAL x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_data_Data_index (uint64_t x1);
static uint64_t mw_mirth_data_Data_allocZBang (void);
static VAL mw_mirth_data_Data_headZAsk (uint64_t x1);
static uint64_t mw_mirth_data_Data_name (uint64_t x1);
static VAL mw_mirth_data_Data_qnameZ_soft (uint64_t x1);
static void mw_mirth_data_Data_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_data_Data_arity (uint64_t x1);
static void mw_mirth_data_Data_params (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_data_Data_tags (uint64_t x1);
static void mw_mirth_data_Data_ctypeZAsk (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_data_TYPEz_BOOL (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_U64 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_U32 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_U16 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_U8 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_I64 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_I32 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_I16 (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_data_TYPEz_I8 (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_data_makeZ_primZ_dataZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5, VAL x6);
static VAL mw_mirth_data_makeZ_primZ_tagZBang (VAL x1, VAL x2, int64_t x3, VAL x4, uint64_t x5);
static VAL mw_mirth_data_makeZ_primZ_intlikeZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL x5, VAL x6);
static VAL mw_mirth_data_initZ_dataZBang (VAL x1);
static VAL mw_mirth_data_dataZ_qname (uint64_t x1, uint64_t x2, int64_t x3);
static VAL mw_mirth_data_dataZ_wordZ_qname (uint64_t x1, VAL x2, int64_t x3);
static int64_t mw_mirth_data_Data_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_data_Data_numZ_tags (uint64_t x1);
static VAL mw_mirth_data_Data_addZ_tagZBang (VAL x1, uint64_t x2, uint64_t x3);
static int64_t mw_mirth_data_Data_isZ_enumZ_orZ_unitZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_unitZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_enumZAsk (uint64_t x1);
static void mw_mirth_data_Data_semiZ_transparentZAsk (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_data_Data_isZ_resourceZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_valueZ_typeZAsk (uint64_t x1);
static void mw_mirth_data_Data_fullZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_data_Tag_index (uint64_t x1);
static uint64_t mw_mirth_data_Tag_allocZBang (void);
static uint64_t mw_mirth_data_Tag_data (uint64_t x1);
static VAL mw_mirth_data_Tag_qname (uint64_t x1);
static uint64_t mw_mirth_data_Tag_name (uint64_t x1);
static int64_t mw_mirth_data_Tag_value (uint64_t x1);
static VAL mw_mirth_data_Tag_labelZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputs (uint64_t x1);
static VAL mw_mirth_data_Tag_sigZAsk (uint64_t x1);
static void mw_mirth_data_Tag_ctxZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_data_Tag_ctx (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_data_Tag_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_labelZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_totalZ_inputs (uint64_t x1);
static void mw_mirth_data_Tag_inputs (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_data_Tag_semiZ_transparentZAsk (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_data_Tag_outputsZ_resourceZAsk (uint64_t x1);
static int64_t mw_mirth_data_Tag_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_data_Tag_preferZ_inlineZAsk (VAL x1, uint64_t x2, VAL *x3, int64_t *x4);
static int64_t mw_mirth_data_DataPartial_ZEqualZEqual (VAL x1, VAL x2);
static VAL mw_mirth_match_Match_thaw (VAL x1);
static VAL mw_mirth_match_ZPlusMatch_freezze (VAL x1);
static int64_t mw_mirth_match_Match_isZ_exhaustiveZAsk (VAL x1);
static int64_t mw_mirth_match_Match_hasZ_defaultZ_caseZAsk (VAL x1);
static VAL mw_mirth_match_Match_scrutineeZ_dataZAsk (VAL x1);
static void mw_mirth_match_ZPlusMatch_addZ_case (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk (VAL x1, VAL x2, int64_t *x3, VAL *x4);
static int64_t mw_mirth_match_Case_coversZAsk (VAL x1, VAL x2);
static int64_t mw_mirth_match_Case_isZ_defaultZ_caseZAsk (VAL x1);
static VAL mw_mirth_match_Pattern_dom (VAL x1);
static VAL mw_mirth_match_Pattern_thaw (VAL x1);
static VAL mw_mirth_match_Pattern_singleZ_tagZAsk (VAL x1);
static int64_t mw_mirth_match_Pattern_isZ_defaultZAsk (VAL x1);
static VAL mw_mirth_match_ZPlusPattern_freezze (VAL x1);
static void mw_mirth_match_ZPlusPattern_opZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_match_ZPlusPattern_underscoreZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_match_ZPlusPattern_tagZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static int64_t mw_mirth_match_Pattern_coversZAsk (VAL x1, VAL x2);
static VAL mw_mirth_match_PatternOp_ZDivPatOpTag (VAL x1);
static int64_t mw_mirth_match_PatternOp_ZDivPatOpUnderscore (VAL x1);
static int64_t mw_mirth_external_External_index (uint64_t x1);
static uint64_t mw_mirth_external_External_allocZBang (void);
static VAL mw_mirth_external_External_qnameZ_soft (uint64_t x1);
static void mw_mirth_external_External_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_external_External_name (uint64_t x1);
static int64_t mw_mirth_external_External_arity (uint64_t x1);
static VAL mw_mirth_external_External_symbol (uint64_t x1);
static uint64_t mw_mirth_external_External_head (uint64_t x1);
static uint64_t mw_mirth_external_External_sig (uint64_t x1);
static void mw_mirth_external_External_ctxZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_external_External_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_external_External_ctype (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_external_External_ZEqualZEqual (uint64_t x1, uint64_t x2);
static uint64_t mw_mirth_external_ExternalBlock_allocZBang (void);
static VAL mw_mirth_external_ExternalBlock_parts (uint64_t x1);
static int64_t mw_mirth_variable_Variable_index (uint64_t x1);
static uint64_t mw_mirth_variable_Variable_allocZBang (void);
static VAL mw_mirth_variable_Variable_qname (uint64_t x1);
static uint64_t mw_mirth_variable_Variable_name (uint64_t x1);
static void mw_mirth_variable_Variable_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_variable_Variable_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_variable_Variable_newZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5);
static int64_t mw_mirth_arrow_Block_index (uint64_t x1);
static uint64_t mw_mirth_arrow_Block_allocZBang (void);
static void mw_mirth_arrow_Arrow_ctxZ_type (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_arrow_Arrow_type (VAL x1);
static VAL mw_mirth_arrow_Lambda_cod (VAL x1);
static VAL mw_mirth_arrow_Block_ctx (uint64_t x1);
static uint64_t mw_mirth_arrow_Block_token (uint64_t x1);
static VAL mw_mirth_arrow_Block_dom (uint64_t x1);
static VAL mw_mirth_arrow_Block_cod (uint64_t x1);
static VAL mw_mirth_arrow_Block_home (uint64_t x1);
static VAL mw_mirth_arrow_Block_type (uint64_t x1);
static void mw_mirth_arrow_Block_arrow (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Block_qname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_arrow_Block_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_arrow_Block_registerZ_homeZBang (uint64_t x1);
static void mw_mirth_arrow_Block_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Block_newZBang (VAL x1, VAL x2, VAL *x3, uint64_t *x4);
static void mw_mirth_arrow_Block_newZ_deferredZBang_1 (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL x5, VAL *x6, uint64_t *x7);
static VAL mw_mirth_arrow_Block_typecheckZBang (VAL x1, uint64_t x2);
static void mw_mirth_arrow_blockZ_unifyZ_typeZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_arrow_Block_toZ_runZ_var (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_arrow_Arrow_toZ_runZ_var (VAL x1);
static VAL mw_mirth_arrow_Atom_toZ_runZ_var (VAL x1);
static void mw_mirth_arrow_Arg_ZToStr (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_arrow_Arg_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_arrow_Block_freeZ_vars (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Arrow_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Atom_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Arg_freeZ_vars (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Op_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_match_Match_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_match_Case_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_arrow_Lambda_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_arrow_Arg_token (uint64_t x1);
static int64_t mw_mirth_typedef_TypeDef_index (uint64_t x1);
static uint64_t mw_mirth_typedef_TypeDef_allocZBang (void);
static VAL mw_mirth_typedef_TypeDef_qnameZ_soft (uint64_t x1);
static void mw_mirth_typedef_TypeDef_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_typedef_TypeDef_namespace (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_typedef_TypeDef_name (uint64_t x1);
static void mw_mirth_typedef_TypeDef_target (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_typedef_TypeDef_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_typedef_TypeDef_newZBang (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6);
static VAL mw_mirth_mirth_ZPlusMirth_defZ_typeZBang (VAL x1, VAL x2, VAL x3);
static int64_t mw_mirth_type_PrimType_isZ_resourceZAsk (int64_t x1);
static int64_t mw_mirth_type_PrimType_isZ_physicalZAsk (int64_t x1);
static VAL mw_mirth_type_Type_tyconZAsk (VAL x1);
static void mw_mirth_type_PrimType_tyconZ_qname (VAL x1, int64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_type_Value_tyconZAsk (VAL x1);
static int64_t mw_mirth_type_PrimType_ZToInt (int64_t x1);
static int64_t mw_mirth_type_PrimType_ZEqualZEqual (int64_t x1, int64_t x2);
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang (VAL x1, int64_t x2);
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang (VAL x1, int64_t x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_initZ_typesZBang (VAL x1);
static VAL mw_mirth_type_TZPlus (VAL x1, VAL x2);
static VAL mw_mirth_type_TZMul (VAL x1, VAL x2);
static VAL mw_mirth_type_TZMulZPlus (VAL x1, VAL x2);
static VAL mw_mirth_type_TZ_ZTo (VAL x1, VAL x2);
static VAL mw_mirth_type_TT (VAL x1);
static VAL mw_mirth_type_T0 (void);
static VAL mw_mirth_type_T1 (VAL x1);
static VAL mw_mirth_type_T2 (VAL x1, VAL x2);
static VAL mw_mirth_type_T3 (VAL x1, VAL x2, VAL x3);
static int64_t mw_mirth_type_Type_errorZAsk (VAL x1);
static VAL mw_mirth_type_Type_morphismZAsk (VAL x1);
static VAL mw_mirth_type_Type_primZAsk (VAL x1);
static int64_t mw_mirth_type_Type_metaZEqual (uint64_t x1, VAL x2);
static int64_t mw_mirth_type_Type_isZ_physicalZAsk (VAL x1);
static VAL mw_mirth_type_TYPEz_TYPE (void);
static VAL mw_mirth_type_TYPEz_STACK (void);
static VAL mw_mirth_type_TYPEz_RESOURCE (void);
static VAL mw_mirth_type_TYPEz_INT (void);
static VAL mw_mirth_type_TYPEz_F32 (void);
static VAL mw_mirth_type_TYPEz_F64 (void);
static VAL mw_mirth_type_TYPEz_PTR (void);
static VAL mw_mirth_type_TYPEz_STR (void);
static VAL mw_mirth_type_TYPEz_WORLD (void);
static VAL mw_mirth_type_RESOURCEz_WORLD (void);
static VAL mw_mirth_type_Type_expand (VAL x1);
static void mw_mirth_type_ZPlusGamma_rdrop (uint64_t x1);
static void mw_mirth_type_Type_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Type_unifyZ_simpleZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Type_unifyZ_auxZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Type_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6);
static void mw_mirth_type_Type_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Value_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Value_unifyZ_typeZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Value_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6);
static void mw_mirth_type_Type_unifyZ_blockZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Type_unify2ZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, VAL x6, VAL *x7, uint64_t *x8, VAL *x9, VAL *x10);
static void mw_mirth_type_PrimType_unifyZBang (VAL x1, uint64_t x2, int64_t x3, int64_t x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_data_Data_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_data_DataPartial_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_table_Table_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7);
static int64_t mw_mirth_type_Type_hasZ_metaZAsk (uint64_t x1, VAL x2);
static int64_t mw_mirth_type_Type_hasZ_meta2ZAsk (uint64_t x1, VAL x2, VAL x3);
static int64_t mw_mirth_type_Value_hasZ_metaZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_Type_typeZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_Value_type (VAL x1);
static VAL mw_mirth_type_PrimType_typeZThen (VAL x1, int64_t x2);
static void mw_mirth_type_Type_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_Type_freshen2 (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_type_Type_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_type_Value_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_type_Type_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_type_MetaVar_index (uint64_t x1);
static uint64_t mw_mirth_type_MetaVar_allocZBang (void);
static VAL mw_mirth_type_MetaVar_typeZAsk (uint64_t x1);
static int64_t mw_mirth_type_MetaVar_hasZ_metaZAsk (uint64_t x1, uint64_t x2);
static VAL mw_mirth_type_MetaVar_typeZThen (VAL x1, uint64_t x2);
static uint64_t mw_mirth_type_MetaVar_newZBang (void);
static VAL mw_mirth_type_MetaVar_expand (uint64_t x1);
static void mw_mirth_type_MetaVar_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_MetaVar_unifyZ_errorZBang (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, uint64_t *x5, VAL *x6);
static int64_t mw_mirth_type_MetaVar_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_type_MetaVar_freshen (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_type_typeZ_holeZ_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7);
static VAL mw_mirth_type_Type_appZ_typeZThenZThen (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Type_appZ_typeZ_openZThenZThen (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Resource_ZToType (VAL x1);
static VAL mw_mirth_type_Type_ZToResource (VAL x1);
static int64_t mw_mirth_type_Resource_hasZ_metaZAsk (uint64_t x1, VAL x2);
static void mw_mirth_type_Resource_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_Resource_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6);
static VAL mw_mirth_type_Resource_typeZThen (VAL x1, VAL x2);
static void mw_mirth_type_Resource_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_Resource_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_type_Resource_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_type_Type_ZToStackType (VAL x1);
static VAL mw_mirth_type_StackType_ZToType (VAL x1);
static VAL mw_mirth_type_StackType_expand (VAL x1);
static int64_t mw_mirth_type_StackType_unitZAsk (VAL x1);
static void mw_mirth_type_StackType_split4 (VAL x1, VAL *x2, VAL *x3, VAL *x4, VAL *x5);
static VAL mw_mirth_type_StackType_base (VAL x1);
static VAL mw_mirth_type_StackType_labelZ_topZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackType_topZ_typeZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_tyconZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_resourceZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_namespaces (VAL x1);
static int64_t mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk (VAL x1);
static int64_t mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk (VAL x1);
static int64_t mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk (VAL x1);
static int64_t mw_mirth_type_StackType_hasZ_metaZAsk (uint64_t x1, VAL x2);
static void mw_mirth_type_StackType_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_StackType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_StackType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6);
static VAL mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackType_forceZ_consZAskZBang (VAL x1);
static VAL mw_mirth_type_StackType_forceZ_withZAskZBang (VAL x1);
static VAL mw_mirth_type_StackType_domZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_StackType_codZThen (VAL x1, VAL x2);
static void mw_mirth_type_StackType_baseZThen (VAL x1, VAL x2, VAL *x3, int64_t *x4);
static VAL mw_mirth_type_StackType_stackZThen (VAL x1, VAL x2);
static void mw_mirth_type_StackType_semifreshen (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_StackType_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_StackType_freshenZ_aux (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_type_StackType_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_type_ArrowType_ZToType (VAL x1);
static VAL mw_mirth_type_ArrowType_invert (VAL x1);
static void mw_mirth_type_ArrowType_unpack (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_type_ArrowType_dom (VAL x1);
static VAL mw_mirth_type_ArrowType_cod (VAL x1);
static void mw_mirth_type_ArrowType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_type_ArrowType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6);
static int64_t mw_mirth_type_ArrowType_hasZ_metaZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_ArrowType_sigZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_ArrowType_semifreshenZ_sig (VAL x1);
static VAL mw_mirth_type_ArrowType_semifreshenZ_aux (VAL x1);
static int64_t mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk (VAL x1);
static void mw_mirth_type_ArrowType_freshenZ_sig (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_ArrowType_freshenZ_sigZ_aux (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_ArrowType_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_ArrowType_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_type_ArrowType_rigidifyZ_sigZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_type_Subst_nil (void);
static VAL mw_mirth_type_Subst_cons (VAL x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_type_Subst_hasZ_varZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_Subst_getZ_var (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackTypePart_cons (VAL x1, VAL x2);
static void mw_mirth_type_StackType_splitZ_parts (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_type_StackTypePart_typeZDivresource (VAL x1);
static VAL mw_mirth_type_CType_cname (VAL x1);
static int64_t mw_mirth_type_CType_phantomZAsk (VAL x1);
static void mw_mirth_type_Resource_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_Type_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_Resource_ctypeZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_Type_ctypeZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_Type_ctype1ZAsk (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_type_PrimType_ctypeZAsk (VAL x1, int64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_data_Data_ctype1ZAsk (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static VAL mw_mirth_type_CTypeStackPart_ctype (VAL x1);
static VAL mw_mirth_type_CTypeStackPart_labelZAsk (VAL x1);
static void mw_mirth_type_StackTypePart_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_StackTypeBase_ctypeZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_StackType_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_type_ArrowType_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_prim_Prim_qname (VAL x1, int64_t x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_prim_Prim_name (int64_t x1);
static VAL mw_mirth_prim_Prim_type (int64_t x1);
static int64_t mw_mirth_prim_Prim_arity (int64_t x1);
static int64_t mw_mirth_prim_Prim_ZToInt (int64_t x1);
static int64_t mw_mirth_prim_Prim_ZEqualZEqual (int64_t x1, int64_t x2);
static VAL mw_mirth_prim_defZ_primZBang (VAL x1, int64_t x2, VAL x3, int64_t x4);
static void mw_mirth_prim_Prim_ctxZ_typeZBang (VAL x1, VAL x2, int64_t x3);
static VAL mw_mirth_prim_initZ_primsZBang (VAL x1);
static int64_t mw_mirth_token_TokenValue_noneZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_commaZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lparenZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lparenZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_rparenZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lsquareZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lsquareZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_rsquareZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lcurlyZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lcurlyZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_rcurlyZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lcolonZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lcolonZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_intZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_strZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_nameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_dnameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_nameZDivdnameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lastZ_nameZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_argZ_endZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_leftZ_enclosureZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_rightZ_enclosureZAsk (VAL x1);
static uint64_t mw_mirth_token_nameZDivdnameZ_lastZ_name (VAL x1);
static VAL mw_mirth_token_nameZDivdnameZ_penultimateZ_nameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_dashesZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_arrowZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_patZ_underscoreZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_moduleZ_headerZAsk (VAL x1);
static int64_t mw_mirth_token_Token_index (uint64_t x1);
static uint64_t mw_mirth_token_Token_succ (uint64_t x1);
static uint64_t mw_mirth_token_Token_pred (uint64_t x1);
static uint64_t mw_mirth_token_Token_allocZBang (void);
static int64_t mw_mirth_token_Token_ZEqualZEqual (uint64_t x1, uint64_t x2);
static VAL mw_mirth_token_Token_value (uint64_t x1);
static uint64_t mw_mirth_token_Token_module (uint64_t x1);
static int64_t mw_mirth_token_Token_col (uint64_t x1);
static int64_t mw_mirth_token_Token_row (uint64_t x1);
static int64_t mw_mirth_token_Token_noneZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_commaZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lparenZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lparenZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_rparenZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lsquareZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lsquareZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_rsquareZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lcurlyZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lcurlyZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_rcurlyZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lcolonZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lcolonZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_intZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_strZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_nameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_dnameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_nameZDivdnameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lastZ_nameZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_argZ_endZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_leftZ_enclosureZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_rightZ_enclosureZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_typeZ_conZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_typeZ_holeZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_typeZ_varZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_paramZ_nameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_stackZ_varZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_resourceZ_varZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_resourceZ_conZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_dashesZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_arrowZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_patZ_underscoreZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_moduleZ_headerZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_canZ_takeZ_argsZAsk (uint64_t x1);
static uint64_t mw_mirth_token_Token_allocZ_noneZBang (void);
static VAL mw_mirth_token_Token_location (uint64_t x1);
static uint64_t mw_mirth_token_Token_next (uint64_t x1);
static uint64_t mw_mirth_token_Token_prev (uint64_t x1);
static uint64_t mw_mirth_token_Token_nextZ_argZ_end (uint64_t x1);
static int64_t mw_mirth_token_Token_hasZ_argsZAsk (uint64_t x1);
static uint64_t mw_mirth_token_Token_argsZ_start (uint64_t x1);
static int64_t mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_sigZ_labelZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_patternZ_varZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_patternZ_autoZ_runZ_varZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_argsZ_0 (uint64_t x1, VAL x2);
static void mw_mirth_token_Token_argsZ_1 (uint64_t x1, VAL x2, uint64_t *x3, VAL *x4);
static void mw_mirth_token_Token_argsZ_2 (uint64_t x1, VAL x2, uint64_t *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_token_Token_argsZ_3 (uint64_t x1, VAL x2, uint64_t *x3, uint64_t *x4, uint64_t *x5, VAL *x6);
static int64_t mw_mirth_token_Token_numZ_args (uint64_t x1);
static VAL mw_mirth_token_Token_args (uint64_t x1);
static int64_t mw_mirth_token_Token_argsZ_endZAsk (uint64_t x1);
static void mw_mirth_token_Token_argsZPlus (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_token_Token_moduleZ_endZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_runZ_endZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_runZ_tokens (uint64_t x1);
static int64_t mw_mirth_token_Token_runZ_length (uint64_t x1);
static VAL mw_mirth_token_Token_runZ_arrowZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_stackZ_endZAsk (uint64_t x1);
static uint64_t mw_mirth_token_Token_sigZ_nextZ_stackZ_end (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_hasZ_dashesZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_patZ_tokens (uint64_t x1);
static int64_t mw_mirth_module_Module_index (uint64_t x1);
static uint64_t mw_mirth_module_Module_allocZBang (void);
static uint64_t mw_mirth_module_Module_package (uint64_t x1);
static uint64_t mw_mirth_module_Module_name (uint64_t x1);
static VAL mw_mirth_module_Module_qname (uint64_t x1);
static VAL mw_mirth_module_Module_path (uint64_t x1);
static uint64_t mw_mirth_module_Module_start (uint64_t x1);
static VAL mw_mirth_module_Module_imports (uint64_t x1);
static int64_t mw_mirth_module_Module_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_module_Module_prim (VAL x1, VAL *x2, uint64_t *x3);
static VAL mw_mirth_module_initZ_modulesZBang (VAL x1);
static void mw_mirth_module_Module_newZBang (VAL x1, VAL x2, VAL *x3, uint64_t *x4);
static void mw_mirth_module_Module_addZ_importZBang (uint64_t x1, uint64_t x2);
static VAL mw_mirth_module_Module_sourceZ_path (uint64_t x1);
static int64_t mw_mirth_module_Module_visible (uint64_t x1, uint64_t x2);
static int64_t mw_std_prim_Int_ZToRow (int64_t x1);
static int64_t mw_mirth_location_Row_ZToInt (int64_t x1);
static VAL mw_mirth_location_Row_showZThen (VAL x1, int64_t x2);
static int64_t mw_std_prim_Int_ZToCol (int64_t x1);
static int64_t mw_mirth_location_Col_ZToInt (int64_t x1);
static VAL mw_mirth_location_Col_showZThen (VAL x1, int64_t x2);
static VAL mw_mirth_location_Location_emitZThen (VAL x1, VAL x2);
static int64_t mw_mirth_alias_Alias_index (uint64_t x1);
static uint64_t mw_mirth_alias_Alias_allocZBang (void);
static VAL mw_mirth_alias_Alias_qnameZ_soft (uint64_t x1);
static void mw_mirth_alias_Alias_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_alias_Alias_namespaceZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_alias_Alias_name (uint64_t x1);
static int64_t mw_mirth_alias_Alias_arity (uint64_t x1);
static void mw_mirth_alias_Alias_target (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_alias_Alias_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_alias_Alias_newZBang (VAL x1, uint64_t x2, uint64_t x3, int64_t x4, VAL *x5, uint64_t *x6);
static VAL mw_mirth_mirth_Builtin_AllocZBang (void);
static VAL mw_mirth_mirth_ZPlusMirth_InitZBang (void);
static void mw_mirth_mirth_ZPlusMirth_rdrop (VAL x1);
static void mw_mirth_mirth_ZPlusMirth_mirthZ_baseZ_libZ_path (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_mirth_Severity_ZToStr (int64_t x1);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang (VAL x1, VAL x2, int64_t x3, VAL x4);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang (uint64_t x1, VAL x2, VAL x3, VAL x4);
static VAL mw_mirth_mirth_ZPlusMirth_errorZBang (VAL x1, VAL x2);
static void mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang (VAL x1, VAL x2);
static void mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang (VAL x1);
static void mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang (int64_t x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_mirth_ZPlusMirth_popZ_diagnostics (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_mirth_Diagnostic_diagnosticZThen (VAL x1, VAL x2);
static void mw_mirth_mirth_PropLabel_prop (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_mirth_PropLabel_prop2 (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6);
static void mw_mirth_mirth_PropLabel_prop_1 (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6);
static VAL mw_mirth_mirth_Prop_1_readyZAsk (VAL x1);
static void mw_mirth_mirth_Prop_1_tryZ_forceZBang (void* x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_mirth_Prop_1_forceZBang (void* x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_def_Def_packageZAsk (VAL x1);
static VAL mw_mirth_def_Def_moduleZAsk (VAL x1);
static VAL mw_mirth_def_Def_aliasZAsk (VAL x1);
static VAL mw_mirth_def_Def_dataZAsk (VAL x1);
static VAL mw_mirth_def_Def_tableZAsk (VAL x1);
static VAL mw_mirth_def_Def_typedefZAsk (VAL x1);
static VAL mw_mirth_def_Def_tagZAsk (VAL x1);
static VAL mw_mirth_def_Def_primZAsk (VAL x1);
static VAL mw_mirth_def_Def_wordZAsk (VAL x1);
static VAL mw_mirth_def_Def_bufferZAsk (VAL x1);
static VAL mw_mirth_def_Def_variableZAsk (VAL x1);
static VAL mw_mirth_def_Def_externalZAsk (VAL x1);
static VAL mw_mirth_def_Def_fieldZAsk (VAL x1);
static int64_t mw_mirth_def_Def_ZEqualZEqual (VAL x1, VAL x2);
static VAL mw_mirth_def_Def_typecheckZBang (VAL x1, VAL x2);
static void mw_mirth_def_Def_callableZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4);
static void mw_mirth_def_Def_definesZ_aZ_typeZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4);
static void mw_mirth_def_Def_exposedZ_tyconZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_def_Def_sameZ_resolvedZAsk (VAL x1, VAL x2, VAL x3, VAL *x4, int64_t *x5);
static void mw_mirth_def_Def_resolve (VAL x1, VAL x2, VAL *x3, VAL *x4);
static uint64_t mw_mirth_def_Def_name (VAL x1);
static int64_t mw_mirth_def_Def_arity (VAL x1);
static void mw_mirth_def_Def_qnameZ_soft (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_def_Def_qnameZ_hard (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_def_Def_asZ_namespaceZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_def_Def_register (VAL x1, VAL x2);
static int64_t mw_mirth_name_Name_index (uint64_t x1);
static uint64_t mw_mirth_name_Name_fromZ_index (int64_t x1);
static uint64_t mw_mirth_name_Name_allocZBang (void);
static VAL mw_mirth_name_Name_ZToStr (uint64_t x1);
static VAL mw_mirth_name_Name_defs (uint64_t x1);
static VAL mw_mirth_name_Name_mangled (uint64_t x1);
static int64_t mw_mirth_name_Name_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_name_Hash_ZToInt (int64_t x1);
static int64_t mw_std_prim_Int_ZToHash (int64_t x1);
static int64_t mw_mirth_name_Hash_offset (int64_t x1);
static int64_t mw_mirth_name_HASHz_MAX (void);
static VAL mw_mirth_name_hashZ_nameZAt (int64_t x1);
static void mw_mirth_name_hashZ_nameZBang (uint64_t x1, int64_t x2);
static int64_t mw_std_prim_Str_hash (VAL x1);
static int64_t mw_mirth_name_Hash_next (int64_t x1);
static void mw_mirth_name_Hash_keepZ_goingZAsk (VAL x1, int64_t x2, VAL *x3, int64_t *x4, int64_t *x5);
static uint64_t mw_std_prim_Str_ZToName (VAL x1);
static int64_t mw_mirth_name_Name_head (uint64_t x1);
static int64_t mw_mirth_name_Name_tailZ_head (uint64_t x1);
static int64_t mw_mirth_name_Name_canZ_beZ_relativeZAsk (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_var (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_con (uint64_t x1);
static int64_t mw_mirth_name_Name_isZ_typeZ_hole (uint64_t x1);
static int64_t mw_mirth_name_Name_isZ_underscore (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_stackZ_var (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_var (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_con (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_constructor (uint64_t x1);
static VAL mw_mirth_name_Name_mangleZ_computeZBang (uint64_t x1);
static int64_t mw_mirth_name_Namespace_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_name_Namespace_qname (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_name_Namespace_moduleZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_name_Namespace_prim (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_name_Namespace_ZToStr (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_name_Namespace_mangled (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_name_QNAME0 (VAL x1, uint64_t x2);
static int64_t mw_mirth_name_QName_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_name_QName_defZ_hardZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_name_QName_definedZ_hardZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4);
static void mw_mirth_name_QName_defZ_softZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_name_QName_definedZ_softZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4);
static void mw_mirth_name_QName_undefinedZ_softZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4);
static void mw_mirth_name_QName_prim (VAL x1, VAL x2, int64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_name_QName_ZToStr (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_name_QName_toZ_moduleZ_path (VAL x1, int64_t x2, VAL x3, VAL *x4, int64_t *x5, VAL *x6);
static void mw_mirth_name_QName_mangled (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_name_DName_rootZAsk (VAL x1);
static VAL mw_mirth_name_DName_parts (VAL x1);
static uint64_t mw_mirth_name_DName_lastZ_name (VAL x1);
static VAL mw_mirth_name_DName_penultimateZ_nameZAsk (VAL x1);
static int64_t mw_mirth_name_DName_isZ_relativeZAsk (VAL x1);
static int64_t mw_mirth_package_Package_index (uint64_t x1);
static uint64_t mw_mirth_package_Package_allocZBang (void);
static uint64_t mw_mirth_package_Package_name (uint64_t x1);
static VAL mw_mirth_package_Package_qname (uint64_t x1);
static VAL mw_mirth_package_Package_path (uint64_t x1);
static void mw_mirth_package_Package_std (VAL x1, VAL *x2, uint64_t *x3);
static VAL mw_mirth_package_initZ_packagesZBang (VAL x1);
static void mw_mirth_package_Package_pathZ_orZ_search (int64_t x1, VAL x2, uint64_t x3, int64_t *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_package_Package_pathZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_package_Package_newZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, uint64_t *x5);
static void mw_mirth_package_Package_newZ_orZ_pathZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, uint64_t *x5);
static void mw_mirth_package_Package_find (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_package_Package_findZ_orZ_newZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static int64_t mw_mirth_package_Package_ZEqualZEqual (uint64_t x1, uint64_t x2);
static VAL mw_mirth_lexer_lexerZ_stackZ_pushZBang (uint64_t x1, VAL x2);
static void mw_mirth_lexer_lexerZ_stackZ_popZBang (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_lexer_lexerZ_stackZ_drop (VAL x1);
static void mw_mirth_lexer_lexerZ_stackZ_peek (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_lexer_runZ_lexerZBang (VAL x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6);
static void mw_mirth_lexer_ZPlusLexer_doneZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_mirth_lexer_lexerZ_makeZBang (VAL x1, VAL x2, uint64_t *x3, VAL *x4);
static VAL mw_mirth_lexer_lexerZ_emitZBang (VAL x1, VAL x2);
static void mw_mirth_lexer_lexerZ_nextZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_lexer_lexerZ_newlineZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_emitZ_lcolonZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_closeZ_colonsZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_emitZ_lparenZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_rparenZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_lexer_lexerZ_emitZ_lsquareZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_rsquareZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_lexer_lexerZ_emitZ_nameZBang (VAL x1);
static void mw_std_str_ZPlusStr_nameZAsk (VAL x1, uint64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_firstZ_byte (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_secondZ_byte (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_thirdZ_byte (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_firstZ_twoZ_bytes (VAL x1, int64_t x2, VAL *x3, VAL *x4, int64_t *x5);
static void mw_std_str_ZPlusStr_dropZ_firstZ_byte (VAL x1, int64_t x2, VAL *x3, VAL *x4, int64_t *x5);
static void mw_std_str_ZPlusStr_dropZ_lastZ_byte (VAL x1, int64_t x2, VAL *x3, VAL *x4, int64_t *x5);
static void mw_std_str_ZPlusStr_labelZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_dnameZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_std_str_ZPlusStr_isZ_docZ_startZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_isZ_floatZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_floatZ_sign (VAL x1, int64_t *x2, int64_t *x3, VAL *x4);
static void mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float (int64_t x1, int64_t *x2, int64_t *x3);
static void mw_std_str_ZPlusStr_floatZAsk (VAL x1, double *x2, VAL *x3);
static void mw_std_str_ZPlusStr_isZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_isZ_decZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_isZ_hexZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_isZ_octZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_intZ_sign (VAL x1, int64_t *x2, int64_t *x3, int64_t *x4, VAL *x5);
static void mw_mirth_lexer_byteZ_signZ_valueZ_index (int64_t x1, int64_t *x2, int64_t *x3, int64_t *x4);
static void mw_std_str_ZPlusStr_decZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_hexZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_std_str_ZPlusStr_octZ_intZAsk (VAL x1, int64_t *x2, VAL *x3);
static int64_t mw_mirth_lexer_hexdigitZ_value (int64_t x1);
static void mw_mirth_lexer_lexerZ_emitZ_stringZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, VAL *x7);
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, VAL *x7);
static VAL mw_mirth_lexer_lexerZ_skipZ_commentZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_skipZ_docZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_commentZ_endZAsk (VAL x1, int64_t *x2, VAL *x3);
static void mw_mirth_lexer_lexerZ_peek (VAL x1, int64_t *x2, VAL *x3);
static VAL mw_mirth_lexer_lexerZ_moveZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_location (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_lexer_lexerZ_emitZ_warningZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang (uint64_t x1);
static void mw_mirth_elab_ZPlusTypeElab_rdrop (VAL x1);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL *x5, VAL *x6, VAL *x7);
static void mw_mirth_elab_resolveZ_defZ_beginZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, int64_t x5, VAL x6, VAL *x7, VAL *x8);
static void mw_mirth_elab_resolveZ_defZ_endZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_ZPlusResolveDef_rdrop (VAL x1);
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous (VAL x1, VAL x2);
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_arity (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_roots (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3, VAL *x4, int64_t *x5);
static int64_t mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk (uint64_t x1, VAL x2);
static void mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3, VAL *x4, int64_t *x5);
static void mw_mirth_name_QName_climbZ_upZ_nameZAsk (VAL x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_name_QName_climbZ_upZ_dnameZAsk (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6, VAL *x7);
static void mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6, uint64_t *x7);
static void mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6, uint64_t *x7);
static void mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_abZ_tokenZAt (VAL x1, VAL *x2, uint64_t *x3);
static VAL mw_mirth_elab_abZ_tokenZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_abZ_typeZAt (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_elab_abZ_typeZBang (VAL x1, VAL x2);
static void mw_mirth_elab_abZ_ctxZAt (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_elab_abZ_homeZAt (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5, uint64_t *x6, VAL *x7, uint64_t *x8);
static void mw_mirth_elab_finalizzeZ_wordZ_arrow (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_guessZ_initialZ_ctxZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5, uint64_t *x6);
static void mw_mirth_elab_abZ_unifyZ_typeZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static VAL mw_mirth_elab_abZ_atomZBang (VAL x1, VAL x2);
static VAL mw_mirth_elab_abZ_optimizzedZ_snocZBang (VAL x1, VAL x2);
static void mw_mirth_elab_atomZ_acceptsZ_argsZAsk (VAL x1, VAL *x2, int64_t *x3);
static int64_t mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk (VAL x1);
static void mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_abZ_opZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_expandZ_opsigZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6, VAL *x7);
static void mw_mirth_elab_abZ_intZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_f64ZBang (double x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_strZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_bufferZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_variableZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_fieldZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_varZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_tagZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_primZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_wordZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_externalZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_coerceZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_labelZ_pushZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_labelZ_popZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_labelZ_pushZ_rZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_abZ_labelZ_popZ_rZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_opZ_freshZ_sigZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_dataZ_getZ_tagZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_elab_elabZ_coerceZ_sigZBang (int64_t x1);
static VAL mw_mirth_elab_elabZ_blockZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_matchZ_sigZBang (VAL x1);
static VAL mw_mirth_elab_elabZ_lambdaZ_sigZBang (VAL x1);
static VAL mw_mirth_elab_elabZ_varZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_popZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang (uint64_t x1);
static void mw_mirth_elab_elabZ_arrowZ_homZBang (VAL x1, VAL x2, VAL x3, VAL x4, uint64_t x5, VAL x6, VAL *x7, VAL *x8);
static void mw_mirth_elab_elabZ_arrowZ_fwdZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5, VAL *x6, VAL *x7);
static void mw_mirth_elab_elabZ_atomsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_atomZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_labelZ_getZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_labelZ_setZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_atomZ_blockZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_blockZ_atZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_argsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_noZ_argsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static int64_t mw_mirth_elab_arityZ_compatibleZAsk (int64_t x1, int64_t x2);
static void mw_mirth_elab_elabZ_atomZ_nameZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_atomZ_dnameZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static int64_t mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk (uint64_t x1);
static void mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_atomZ_failedZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_atomZ_defZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_primZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_atomZ_assertZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_atomZ_matchZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_matchZ_atZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_elabZ_matchZ_casesZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_matchZ_caseZBang (uint64_t x1, VAL x2, VAL x3, uint64_t *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_elabZ_patternZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_patternZ_atomZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_expandZ_tensorZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6, uint64_t *x7);
static void mw_mirth_elab_elabZ_lambdaZ_paramZAsk (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_elabZ_atomZ_lambdaZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_matchZ_exhaustiveZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_moduleZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6);
static void mw_mirth_elab_elabZ_moduleZ_packageZ_name (uint64_t x1, VAL x2, uint64_t *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_elabZ_moduleZ_qname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_moduleZ_headerZBang (int64_t x1, VAL x2, uint64_t x3, int64_t *x4, VAL *x5, uint64_t *x6);
static void mw_mirth_elab_checkZ_moduleZ_path (uint64_t x1, uint64_t x2, int64_t x3, VAL x4, int64_t *x5, VAL *x6);
static void mw_mirth_elab_elabZ_moduleZ_declZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6);
static void mw_mirth_elab_loadZ_module (uint64_t x1, VAL x2, int64_t x3, VAL x4, uint64_t *x5, uint64_t *x6, int64_t *x7, VAL *x8);
static void mw_mirth_elab_elabZ_moduleZ_importZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6);
static void mw_mirth_elab_parseZ_data (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_parseZ_dataZ_header (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5);
static void mw_mirth_elab_parseZ_dataZ_tags (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_parseZ_dataZ_tag (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_parseZ_struct (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_parseZ_structZ_tag (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, uint64_t *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_elab_elabZ_dataZBang (VAL x1, uint64_t x2, uint64_t *x3, VAL *x4);
static void mw_mirth_elab_elabZ_structZBang (VAL x1, uint64_t x2, uint64_t *x3, VAL *x4);
static VAL mw_mirth_elab_elabZ_dataZ_auxZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_dataZ_headerZBang (uint64_t x1, uint64_t x2, VAL x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_elabZ_dataZ_paramsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_dataZ_tagZBang (uint64_t x1, VAL x2, VAL x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_dataZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, uint64_t *x6);
static VAL mw_mirth_elab_elabZ_dataZ_doneZBang (VAL x1, uint64_t x2);
static void mw_mirth_data_Tag_outputZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_data_Tag_projectZ_inputZ_label (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_data_Tag_projectZ_tagZ_field (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_dataZ_getZ_labelZ_type (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_dataZ_setZ_labelZ_type (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_elab_createZ_projectorsZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_expectZ_tokenZ_arrow (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_parseZ_alias (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5, uint64_t *x6, VAL *x7);
static void mw_mirth_elab_elabZ_aliasZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_defZ_missingZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_inlineZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6);
static void mw_mirth_elab_parseZ_def (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_elabZ_defZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang (VAL x1, uint64_t x2, uint64_t x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_paramsZBang (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_defZ_bodyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_elab_parseZ_externalZ_decl (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_parseZ_externalZ_declZ_part (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5);
static void mw_mirth_elab_elabZ_externalZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_externalZ_blockZ_partZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_externalZ_defZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL *x5, uint64_t *x6);
static void mw_mirth_elab_elabZ_defZ_externalZ_ctype (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_defZ_typeZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_bufferZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_variableZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_tableZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static void mw_mirth_elab_elabZ_entryZ_point (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_embedZ_strZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6);
static VAL mw_mirth_elab_typecheckZ_everythingZBang (VAL x1);
static int64_t mw_mirth_elab_TABLEz_MAXz_COUNT (void);
static VAL mw_mirth_elab_tableZ_qname (uint64_t x1, VAL x2, int64_t x3);
static void mw_mirth_elab_tableZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, uint64_t *x6);
static void mw_mirth_elab_tableZ_newZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6);
static void mw_mirth_elab_resolveZ_defZ_namespace (VAL x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, VAL *x6);
static int64_t mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk (uint64_t x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_qname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_defZ_qnameZ_undefined (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_elab_elabZ_defZ_head (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5, int64_t *x6, VAL *x7);
static void mw_mirth_elab_parseZ_field (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5, uint64_t *x6, uint64_t *x7);
static void mw_mirth_elab_elabZ_fieldZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4);
static VAL mw_std_map_Map_2_empty (void);
static VAL mw_std_map_Map_2_insert (VAL x1, VAL x2);
static void mw_mirth_specializzer_runZ_specializzerZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_specializzer_ZPlusSPCheck_beginZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_endZBang (VAL x1);
static void mw_mirth_specializzer_ZPlusSPCheck_loopZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang (uint64_t x1, VAL x2);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang (VAL x1, int64_t x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6, VAL *x7);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang (uint64_t x1, VAL x2);
static int64_t mw_mirth_specializzer_SPKey_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_specializzer_SPKey_ZToStr (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_specializzer_SPKey_ZToName (VAL x1, VAL x2, VAL *x3, uint64_t *x4);
static VAL mw_mirth_word_Word_spZ_synthed (uint64_t x1);
static void mw_mirth_specializzer_specializzeZ_wordZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, uint64_t *x5);
static void mw_mirth_specializzer_specializzeZ_ctxZ_type (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6, VAL *x7);
static void mw_mirth_specializzer_synthZ_specializzedZ_wordZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static int64_t mw_std_set_SETz_INITIALz_SIZZE (void);
static VAL mw_std_set_ZPlusSet_new (void);
static void mw_std_set_ZPlusSet_rdrop (VAL x1);
static void mw_std_set_ZPlusSet_offsetZ_mask (int64_t x1, VAL x2, int64_t *x3, int64_t *x4, VAL *x5);
static void mw_std_set_ZPlusSet_memberZAsk (int64_t x1, VAL x2, int64_t *x3, VAL *x4);
static VAL mw_std_set_ZPlusSet_insertZBang (int64_t x1, VAL x2);
static int64_t mw_mirth_need_Need_ZToNat (VAL x1);
static VAL mw_mirth_need_ZPlusNeeds_new (void);
static void mw_mirth_need_ZPlusNeeds_rdrop (VAL x1);
static void mw_mirth_need_Need_neededZAsk (VAL x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_word_Word_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_arrow_Block_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_data_Tag_wordZ_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_data_Tag_patZ_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4);
static VAL mw_mirth_need_ZPlusNeeds_needZBang (VAL x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_wordZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_blockZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang (uint64_t x1, VAL x2);
static void mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_need_ZPlusNeeds_runZ_needZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_argsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_argZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_blockZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_wordZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_arrowZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_atomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_opZBang (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6);
static void mw_mirth_need_ZPlusNeeds_runZ_primZBang (VAL x1, int64_t x2, VAL x3, VAL x4, VAL *x5, VAL *x6);
static void mw_mirth_need_ZPlusNeeds_runZ_matchZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_caseZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_patternZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_runZ_patatomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_pushZ_argsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_pushZ_argZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_need_ZPlusNeeds_pushZ_blockZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static VAL mw_mirth_c99_ZPlusC99_put (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_putZ_byte (int64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_line (VAL x1);
static void mw_mirth_c99_c99Z_startZBang (VAL x1, VAL x2, int64_t x3, VAL x4, VAL *x5, int64_t *x6, VAL *x7);
static void mw_mirth_c99_c99Z_endZBang (int64_t x1, VAL x2, int64_t *x3, VAL *x4);
static VAL mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99_freshZ_natZBang (VAL x1, int64_t *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99_freshZ_nameZBang (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_c99_runZ_outputZ_c99ZBang (VAL x1, VAL x2, int64_t x3, VAL x4, int64_t *x5, VAL *x6);
static void mw_mirth_data_Tag_wordZ_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_data_Tag_patZ_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_buffer_Buffer_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_variable_Variable_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_table_Field_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_external_External_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_ZPlusC99_sigZ_put (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_headerZ_str (void);
static VAL mw_mirth_c99_c99Z_headerZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_buffersZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_bufferZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_bufferZ_callZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_variablesZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_variableZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_variableZ_callZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_tagZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_tagZ_bodyZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_tagZ_defZBang (uint64_t x1, VAL x2);
static void mw_mirth_c99_c99Z_tagZ_labelZ_index (uint64_t x1, uint64_t x2, VAL x3, int64_t *x4, VAL *x5);
static VAL mw_mirth_c99_c99Z_tagZ_getZ_labelZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_tagZ_setZ_labelZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_externalZ_blocksZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_externalZ_blockZBang (uint64_t x1, VAL x2);
static void mw_mirth_external_External_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_external_External_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_c99Z_externalZ_callZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_externalZ_defZBang (uint64_t x1, VAL x2);
static void mw_mirth_type_CTypeStackPart_c99Z_argZ_name (int64_t x1, VAL x2, VAL x3, int64_t *x4, VAL *x5, VAL *x6);
static int64_t mw_mirth_type_CType_ZToC99ReprType (VAL x1);
static void mw_mirth_type_CTypeStackPart_c99Z_pop (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_type_CTypeStackPart_c99Z_push (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_ZPlusC99_indent (VAL x1);
static void mw_mirth_c99_C99APIArg_popZ_consumeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_C99APIArg_pushZ_toZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux (VAL x1, VAL x2, int64_t *x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params (VAL x1, VAL x2, int64_t *x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_C99APIArg_reserveZ_asZ_newZ_localZBang (VAL x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_C99APIArg_reserveZ_asZ_isZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_smartZ_callZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_ZPlusC99_smartZ_sigZ_put (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_smartZ_sigZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_apiZ_enterZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_apiZ_exitZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_arrowZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_atomZBang (VAL x1, VAL x2);
static int64_t mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk (VAL x1);
static VAL mw_mirth_c99_c99Z_atomZ_opZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_c99Z_getZ_dataZ_tagZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_data_Tag_valueZ_show (uint64_t x1);
static VAL mw_mirth_c99_c99Z_tagZ_callZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_reverseZ_tagZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_labelZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_labelZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_pushZ_localZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_pushZ_localZ_labelZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_c99_popZ_localZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5);
static VAL mw_mirth_c99_c99Z_labelZ_pushZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_pushZ_rZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_popZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_popZ_rZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_intZBang (int64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_f64ZBang (double x1, VAL x2);
static VAL mw_mirth_c99_c99Z_strZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_putZ_cstrZ_long (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_putZ_cstr (VAL x1, VAL x2);
static void mw_mirth_c99_c99Z_stringZ_byteZBang (int64_t x1, int64_t x2, VAL x3, int64_t *x4, VAL *x5);
static int64_t mw_mirth_c99_C99ReprType_ZEqualZEqual (int64_t x1, int64_t x2);
static int64_t mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk (int64_t x1);
static int64_t mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_vZ_macro (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_mkZ_macro (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_popZ_macro (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_pushZ_macro (int64_t x1);
static void mw_mirth_type_Resource_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_type_Type_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4);
static int64_t mw_mirth_type_PrimType_c99Z_repr (int64_t x1);
static void mw_mirth_data_Data_c99Z_repr (uint64_t x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_c99_ZPlusC99Local_rdup (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99Local_rdrop (VAL x1);
static void mw_mirth_c99_C99ReprType_newZ_localZBang (int64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang (int64_t x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99Local_consume (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_as (int64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99Local_dropZ_localZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Local_dupZ_localZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99Local_peekZ_dataZ_tag (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99LocalResource_rdup (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99LocalResource_rdrop (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalResource_dropZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99LocalResource_dupZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static VAL mw_mirth_c99_ZPlusC99LocalResource_consume (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL (VAL x1);
static void mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang (VAL x1, int64_t x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99LocalResource_peekZ_dataZ_tag (VAL x1, VAL *x2, VAL *x3);
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_peekZ_dataZ_tag (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL (VAL x1);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_ZPlusC99Branch_refreshZ_branchZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk (uint64_t x1, VAL x2, uint64_t *x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk (uint64_t x1, VAL x2, uint64_t *x3, VAL *x4, VAL *x5);
static VAL mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99StackCache_rdup (VAL x1, VAL *x2, VAL *x3);
static void mw_mirth_c99_ZPlusC99StackCache_rdrop (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99_startZ_branchZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang (VAL x1, int64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang (VAL x1, int64_t x2, VAL *x3, VAL *x4);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5);
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6);
static VAL mw_mirth_c99_c99Z_primZBang (VAL x1, int64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_primZ_syntaxZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_binopZBang (VAL x1, int64_t x2, VAL x3, int64_t x4, VAL x5, int64_t x6, VAL x7, VAL x8);
static VAL mw_mirth_c99_c99Z_unopZBang (VAL x1, int64_t x2, VAL x3, VAL x4, VAL x5);
static VAL mw_mirth_c99_c99Z_argsZ_pushZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_argZ_pushZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_argZ_runZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_runZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_varZ_put (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_packZ_closureZ_varsZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_popZ_toZ_varZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_pushZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_varZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_varZ_runZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_varZ_pushZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_lambdaZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_matchZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_singleZ_caseZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_caseZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_data_Tag_wordZ_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_data_Tag_patZ_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_word_Word_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5);
static void mw_mirth_data_Tag_wordZ_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_data_Tag_patZ_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static void mw_mirth_word_Word_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4);
static VAL mw_mirth_c99_c99Z_wordZ_sigsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_wordZ_sigZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_sigsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_blockZ_sigZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_enterZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_exitZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_blockZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_exposeZ_stackZ_typeZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_enterZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_exitZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_wordZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_fieldZ_sigZ_put (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_fieldZ_sigsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_fieldZ_sigZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_fieldZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_fieldZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_fieldZ_callZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_mainZBang (VAL x1, VAL x2);
static VAL mw_mirth_main_Arguments_default (void);
static void mw_mirth_main_compileZBang (VAL x1, int64_t x2, VAL x3, int64_t *x4, VAL *x5);
static VAL mw_mirth_main_parseZ_packageZ_def (VAL x1);
static void mw_mirth_main_compilerZ_parseZ_args (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6);
static int64_t mw_mirth_main_main (int64_t x1);
static void mb_mirth_main_main_1 (void);
static void mb_mirth_elab_elabZ_blockZ_atZBang_1 (void);
static void mb_mirth_elab_elabZ_defZBang_0 (void);
static void mb_mirth_elab_elabZ_defZBang_2 (void);
static void mb_mirth_elab_elabZ_defZBang_3 (void);
static void mb_mirth_elab_elabZ_defZ_typeZBang_2 (void);
static void mb_mirth_elab_elabZ_variableZBang_1 (void);
static void mb_mirth_elab_elabZ_fieldZBang_1 (void);
static void mb_mirth_elab_elabZ_fieldZBang_2 (void);
static void mb_mirth_elab_elabZ_dataZ_headerZBang_2 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_5 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_14 (void);
static void mb_mirth_elab_elabZ_defZ_head_3 (void);
static void mb_mirth_elab_createZ_projectorsZBang_24 (void);
static void mb_mirth_elab_elabZ_externalZ_defZBang_2 (void);
static void mb_mirth_elab_elabZ_externalZ_defZBang_4 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot81ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot63ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot267ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot167ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot134ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot106ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot73ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot104ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_dataZ_tagZBangZDot42ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotelabZ_aliasZBangZDot21ZRParen_1 (void);
static void* mfld_mirth_label_Label_ZTildename (uint64_t i);
static void* mfld_mirth_var_Var_ZTildename (uint64_t i);
static void* mfld_mirth_var_Var_ZTildetype (uint64_t i);
static void* mfld_mirth_var_Var_ZTildeautoZ_runZAsk (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildehead (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildesizze (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildeqname (uint64_t i);
static void* mfld_mirth_word_Word_ZTildename (uint64_t i);
static void* mfld_mirth_word_Word_ZTildearity (uint64_t i);
static void* mfld_mirth_word_Word_ZTildeqname (uint64_t i);
static void* mfld_mirth_word_Word_ZTildehead (uint64_t i);
static void* mfld_mirth_word_Word_ZTildesigZAsk (uint64_t i);
static void* mfld_mirth_word_Word_ZTildebody (uint64_t i);
static void* mfld_mirth_word_Word_ZTildectxZ_type (uint64_t i);
static void* mfld_mirth_word_Word_ZTildeparams (uint64_t i);
static void* mfld_mirth_word_Word_ZTildearrow (uint64_t i);
static void* mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk (uint64_t i);
static void* mfld_mirth_word_Word_ZTildecname (uint64_t i);
static void* mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk (uint64_t i);
static void* mfld_mirth_word_Word_ZTildenumZ_blocks (uint64_t i);
static void* mfld_mirth_table_Table_ZTildehead (uint64_t i);
static void* mfld_mirth_table_Table_ZTildename (uint64_t i);
static void* mfld_mirth_table_Table_ZTildeqname (uint64_t i);
static void* mfld_mirth_table_Table_ZTildenumZ_buffer (uint64_t i);
static void* mfld_mirth_table_Table_ZTildemaxZ_count (uint64_t i);
static void* mfld_mirth_table_Field_ZTildehead (uint64_t i);
static void* mfld_mirth_table_Field_ZTildename (uint64_t i);
static void* mfld_mirth_table_Field_ZTildeqname (uint64_t i);
static void* mfld_mirth_table_Field_ZTildeindexZ_type (uint64_t i);
static void* mfld_mirth_table_Field_ZTildevalueZ_type (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeheadZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeqname (uint64_t i);
static void* mfld_mirth_data_Data_ZTildename (uint64_t i);
static void* mfld_mirth_data_Data_ZTildearity (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeparams (uint64_t i);
static void* mfld_mirth_data_Data_ZTildetags (uint64_t i);
static void* mfld_mirth_data_Data_ZTildectypeZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildelastZ_tagZ_value (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_unitZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_enumZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_transparentZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildesemiZ_transparentZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_resourceZAsk (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildedata (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildeqname (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildevalue (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildelabelZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildesigZAsk (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildectxZ_type (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildeuntag (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildeinputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildefields (uint64_t i);
static void* mfld_mirth_external_External_ZTildename (uint64_t i);
static void* mfld_mirth_external_External_ZTildearity (uint64_t i);
static void* mfld_mirth_external_External_ZTildeqname (uint64_t i);
static void* mfld_mirth_external_External_ZTildesymbol (uint64_t i);
static void* mfld_mirth_external_External_ZTildehead (uint64_t i);
static void* mfld_mirth_external_External_ZTildesig (uint64_t i);
static void* mfld_mirth_external_External_ZTildectxZ_type (uint64_t i);
static void* mfld_mirth_external_External_ZTildectype (uint64_t i);
static void* mfld_mirth_external_ExternalBlock_ZTildetoken (uint64_t i);
static void* mfld_mirth_external_ExternalBlock_ZTildeparts (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildehead (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildeqname (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildetype (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildectx (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildetoken (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildehome (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildedom (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildecod (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildearrow (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildeqname (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildehomeZ_index (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildecname (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildefreeZ_vars (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildeheadZAsk (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildename (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildeqname (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildetarget (uint64_t i);
static void* mfld_mirth_type_MetaVar_ZTildetypeZAsk (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildename (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildectx (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildetype (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildedecl (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildearity (uint64_t i);
static void* mfld_mirth_token_Token_ZTildevalue (uint64_t i);
static void* mfld_mirth_token_Token_ZTildemodule (uint64_t i);
static void* mfld_mirth_token_Token_ZTilderow (uint64_t i);
static void* mfld_mirth_token_Token_ZTildecol (uint64_t i);
static void* mfld_mirth_module_Module_ZTildepackage (uint64_t i);
static void* mfld_mirth_module_Module_ZTildename (uint64_t i);
static void* mfld_mirth_module_Module_ZTildepath (uint64_t i);
static void* mfld_mirth_module_Module_ZTildestart (uint64_t i);
static void* mfld_mirth_module_Module_ZTildeend (uint64_t i);
static void* mfld_mirth_module_Module_ZTildeimports (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildehead (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildename (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildearity (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildeqname (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildetarget (uint64_t i);
static void* mfld_mirth_name_Name_ZTildeStr (uint64_t i);
static void* mfld_mirth_name_Name_ZTildedefs (uint64_t i);
static void* mfld_mirth_name_Name_ZTildemangled (uint64_t i);
static void* mfld_mirth_name_Name_ZTildelabel (uint64_t i);
static void* mfld_mirth_package_Package_ZTildename (uint64_t i);
static void* mfld_mirth_package_Package_ZTildepath (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildeoutputZ_type (uint64_t i);
static void* mfld_mirth_word_Word_ZTildespZ_checked (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildespZ_checked (uint64_t i);
static void* mfld_mirth_word_Word_ZTildespZ_synthed (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildewordZ_cname (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildepatZ_cname (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildecname (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildecname (uint64_t i);
static void* mfld_mirth_table_Field_ZTildecname (uint64_t i);
static void* mfld_mirth_external_External_ZTildecname (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildecname (uint64_t i);
static void* mfld_mirth_external_External_ZTildec99Z_api (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildevalueZ_show (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildewordZ_c99Z_api (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildepatZ_c99Z_api (uint64_t i);
static void* mfld_mirth_word_Word_ZTildec99Z_api (uint64_t i);
int main (int argc, char** argv) {
	global_argc = argc;
	global_argv = argv;
	int64_t v0 = (0 /* The World! */);
	int64_t v1 = (mw_mirth_main_main(v0));
	push_resource(MKI64(v1));
	return 0;
}
static void* mfld_mirth_label_Label_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_var_Var_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_var_Var_ZTildetype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_var_Var_ZTildeautoZ_runZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildesizze (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildesigZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildebody (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildectxZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildeparams (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildearrow (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildenumZ_blocks (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildenumZ_buffer (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildemaxZ_count (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildeindexZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildevalueZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeheadZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeparams (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildetags (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildectypeZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildelastZ_tagZ_value (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_unitZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_enumZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_transparentZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildesemiZ_transparentZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_resourceZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildedata (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildevalue (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildelabelZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildesigZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildectxZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildeuntag (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildeinputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildefields (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildesymbol (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildesig (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildectxZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildectype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_ExternalBlock_ZTildetoken (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_ExternalBlock_ZTildeparts (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildetype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildectx (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildetoken (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildehome (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildedom (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildecod (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildearrow (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildehomeZ_index (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildefreeZ_vars (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildeheadZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildetarget (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_type_MetaVar_ZTildetypeZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildectx (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildetype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildedecl (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTildevalue (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTildemodule (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTilderow (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTildecol (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildepackage (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildepath (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildestart (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildeend (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildeimports (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildetarget (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildeStr (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildedefs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildemangled (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildelabel (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_package_Package_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_package_Package_ZTildepath (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildeoutputZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildespZ_checked (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildespZ_checked (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildespZ_synthed (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildewordZ_cname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildepatZ_cname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildec99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildevalueZ_show (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildewordZ_c99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildepatZ_c99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildec99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static VAL mw_std_either_Either_2_leftZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Left
			VAL v3 = mtp_std_either_Either_2_Left(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			x2 = v4;
		} break;
		case 1LL: { // Right
			VAL v5 = mtp_std_either_Either_2_Right(x1);
			decref(v5);
			VAL v6 = MKI64(0LL /* None */);
			x2 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_std_either_Either_2_rightZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Left
			VAL v3 = mtp_std_either_Either_2_Left(x1);
			decref(v3);
			VAL v4 = MKI64(0LL /* None */);
			x2 = v4;
		} break;
		case 1LL: { // Right
			VAL v5 = mtp_std_either_Either_2_Right(x1);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			x2 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static int64_t mw_std_prim_Int_ZToByte (int64_t x1) {
	int64_t v2 = 0LL;
	int64_t v3 = 255LL;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	int64_t x7;
	if (v6) {
		x7 = x1;
	} else {
		STR* v8;
		STRLIT(v8, "Int->Byte out of range", 22);
		STR* v9;
		STRLIT(v9, "assertion failed: ", 18);
		STR* v10 = str_cat(v9, v8);
		push_i64(x1);
		do_panic(v10);
		int64_t v11 = pop_i64();
		x7 = v11;
	}
	return x7;
}
static int64_t mw_std_prim_U8_ZToByte (int64_t x1) {
	int64_t v2 = mw_std_prim_Int_ZToByte(x1);
	return v2;
}
static void mw_std_prim_Ptr_ZAtByte (void* x1, int64_t x2, int64_t *x3, int64_t *x4) {
	uint8_t v5 = *(uint8_t*)x1;
	int64_t v6 = mw_std_prim_U8_ZToByte(((int64_t)v5));
	*x4 = x2;
	*x3 = v6;
}
static int64_t mw_std_byte_Byte_isZ_upper (int64_t x1) {
	int64_t v2 = 65LL /* B'A' */;
	int64_t v3 = 90LL /* B'Z' */;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	return ((int64_t)v6);
}
static int64_t mw_std_byte_Byte_isZ_lower (int64_t x1) {
	int64_t v2 = 97LL /* B'a' */;
	int64_t v3 = 122LL /* B'z' */;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	return ((int64_t)v6);
}
static int64_t mw_std_byte_Byte_isZ_digit (int64_t x1) {
	int64_t v2 = 48LL /* B'0' */;
	int64_t v3 = 57LL /* B'9' */;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	return ((int64_t)v6);
}
static int64_t mw_std_byte_Byte_isZ_alpha (int64_t x1) {
	int64_t v2 = mw_std_byte_Byte_isZ_upper(x1);
	int64_t x3;
	if (((bool)v2)) {
		int64_t v4 = 1LL /* True */;
		x3 = v4;
	} else {
		int64_t v5 = mw_std_byte_Byte_isZ_lower(x1);
		x3 = v5;
	}
	return x3;
}
static int64_t mw_std_byte_Byte_isZ_alnum (int64_t x1) {
	int64_t v2 = mw_std_byte_Byte_isZ_digit(x1);
	int64_t x3;
	if (((bool)v2)) {
		int64_t v4 = 1LL /* True */;
		x3 = v4;
	} else {
		int64_t v5 = mw_std_byte_Byte_isZ_alpha(x1);
		x3 = v5;
	}
	return x3;
}
static int64_t mw_std_byte_Byte_isZ_printable (int64_t x1) {
	int64_t v2 = 33LL /* B'!' */;
	int64_t v3 = 126LL /* B'~' */;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	return ((int64_t)v6);
}
static int64_t mw_std_byte_Byte_isZ_hexdigit (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 48LL: { // B'0'
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 49LL: { // B'1'
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		case 50LL: { // B'2'
			int64_t v5 = 1LL /* True */;
			x2 = v5;
		} break;
		case 51LL: { // B'3'
			int64_t v6 = 1LL /* True */;
			x2 = v6;
		} break;
		case 52LL: { // B'4'
			int64_t v7 = 1LL /* True */;
			x2 = v7;
		} break;
		case 53LL: { // B'5'
			int64_t v8 = 1LL /* True */;
			x2 = v8;
		} break;
		case 54LL: { // B'6'
			int64_t v9 = 1LL /* True */;
			x2 = v9;
		} break;
		case 55LL: { // B'7'
			int64_t v10 = 1LL /* True */;
			x2 = v10;
		} break;
		case 56LL: { // B'8'
			int64_t v11 = 1LL /* True */;
			x2 = v11;
		} break;
		case 57LL: { // B'9'
			int64_t v12 = 1LL /* True */;
			x2 = v12;
		} break;
		case 65LL: { // B'A'
			int64_t v13 = 1LL /* True */;
			x2 = v13;
		} break;
		case 66LL: { // B'B'
			int64_t v14 = 1LL /* True */;
			x2 = v14;
		} break;
		case 67LL: { // B'C'
			int64_t v15 = 1LL /* True */;
			x2 = v15;
		} break;
		case 68LL: { // B'D'
			int64_t v16 = 1LL /* True */;
			x2 = v16;
		} break;
		case 69LL: { // B'E'
			int64_t v17 = 1LL /* True */;
			x2 = v17;
		} break;
		case 70LL: { // B'F'
			int64_t v18 = 1LL /* True */;
			x2 = v18;
		} break;
		case 97LL: { // B'a'
			int64_t v19 = 1LL /* True */;
			x2 = v19;
		} break;
		case 98LL: { // B'b'
			int64_t v20 = 1LL /* True */;
			x2 = v20;
		} break;
		case 99LL: { // B'c'
			int64_t v21 = 1LL /* True */;
			x2 = v21;
		} break;
		case 100LL: { // B'd'
			int64_t v22 = 1LL /* True */;
			x2 = v22;
		} break;
		case 101LL: { // B'e'
			int64_t v23 = 1LL /* True */;
			x2 = v23;
		} break;
		case 102LL: { // B'f'
			int64_t v24 = 1LL /* True */;
			x2 = v24;
		} break;
		default: {
			int64_t v25 = 0LL /* False */;
			x2 = v25;
		} break;
	}
	return x2;
}
static VAL mw_std_byte_Byte_emitZ_asciiZThen (VAL x1, int64_t x2) {
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(x2, x1));
	return v3;
}
static VAL mw_std_byte_Byte_toZ_strZ_unsafe (int64_t x1) {
	VAL v2 = MKI64(0LL /* Nil */);
	VAL v3 = mtw_std_list_List_1_Cons(MKI64(x1), v2);
	VAL v4 = mw_std_prim_Str_fromZ_bytesZ_unsafe(v3);
	return v4;
}
static VAL mw_std_byte_Byte_toZ_asciiZ_str (int64_t x1) {
	int64_t v2 = 0LL /* BNUL */;
	int64_t v3 = 127LL /* BDEL */;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	VAL x7;
	if (v6) {
		VAL v8 = mw_std_byte_Byte_toZ_strZ_unsafe(x1);
		VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
		x7 = v9;
	} else {
		VAL v10 = MKI64(0LL /* None */);
		x7 = v10;
	}
	return x7;
}
static int64_t mw_std_byte_Byte_isZ_stringZ_end (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 34LL: { // BQUOTE
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 10LL: { // BLF
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		case 0LL: { // BNUL
			int64_t v5 = 1LL /* True */;
			x2 = v5;
		} break;
		default: {
			int64_t v6 = 0LL /* False */;
			x2 = v6;
		} break;
	}
	return x2;
}
static void mw_std_byte_Byte_toZ_hexdigits (int64_t x1, int64_t *x2, int64_t *x3) {
	int64_t v4 = 4LL;
	uint64_t v5 = u64_shr(((uint64_t)x1), ((uint64_t)v4));
	int64_t v6 = mw_std_byte_oneZ_hexdigitZ_byte(((int64_t)v5));
	int64_t v7 = 15LL;
	uint64_t v8 = (((uint64_t)x1) & ((uint64_t)v7));
	int64_t v9 = mw_std_byte_oneZ_hexdigitZ_byte(((int64_t)v8));
	*x3 = v9;
	*x2 = v6;
}
static int64_t mw_std_byte_oneZ_hexdigitZ_byte (int64_t x1) {
	int64_t v2 = 9LL;
	bool v3 = (x1 > v2);
	int64_t x4;
	VAL x5;
	if (v3) {
		int64_t v6 = 55LL;
		x5 = MKI64(v6);
		x4 = x1;
	} else {
		int64_t v7 = 48LL;
		x5 = MKI64(v7);
		x4 = x1;
	}
	int64_t v8 = i64_add(x4, VI64(x5));
	int64_t v9 = mw_std_prim_Int_ZToByte(v8);
	return v9;
}
static int64_t mw_std_byte_Byte_isZ_nameZ_byte (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 40LL: { // BLPAREN
			int64_t v3 = 0LL /* False */;
			x2 = v3;
		} break;
		case 41LL: { // BRPAREN
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
		case 91LL: { // BLSQUARE
			int64_t v5 = 0LL /* False */;
			x2 = v5;
		} break;
		case 93LL: { // BRSQUARE
			int64_t v6 = 0LL /* False */;
			x2 = v6;
		} break;
		case 123LL: { // BLCURLY
			int64_t v7 = 0LL /* False */;
			x2 = v7;
		} break;
		case 125LL: { // BRCURLY
			int64_t v8 = 0LL /* False */;
			x2 = v8;
		} break;
		case 44LL: { // BCOMMA
			int64_t v9 = 0LL /* False */;
			x2 = v9;
		} break;
		case 34LL: { // BQUOTE
			int64_t v10 = 0LL /* False */;
			x2 = v10;
		} break;
		case 58LL: { // BCOLON
			int64_t v11 = 0LL /* False */;
			x2 = v11;
		} break;
		case 127LL: { // BDEL
			int64_t v12 = 0LL /* False */;
			x2 = v12;
		} break;
		default: {
			int64_t v13 = 32LL /* BSPACE */;
			bool v14 = (x1 > v13);
			x2 = ((int64_t)v14);
		} break;
	}
	return x2;
}
static int64_t mw_std_byte_Byte_isZ_sign (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 45LL: { // B'-'
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 43LL: { // B'+'
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		default: {
			int64_t v5 = 0LL /* False */;
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_std_byte_Byte_zzencode (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 38LL: { // B'&'
			STR* v3;
			STRLIT(v3, "ZAmp", 4);
			x2 = MKSTR(v3);
		} break;
		case 63LL: { // B'?'
			STR* v4;
			STRLIT(v4, "ZAsk", 4);
			x2 = MKSTR(v4);
		} break;
		case 64LL: { // B'@'
			STR* v5;
			STRLIT(v5, "ZAt", 3);
			x2 = MKSTR(v5);
		} break;
		case 92LL: { // B'\'
			STR* v6;
			STRLIT(v6, "ZBSlash", 7);
			x2 = MKSTR(v6);
		} break;
		case 33LL: { // B'!'
			STR* v7;
			STRLIT(v7, "ZBang", 5);
			x2 = MKSTR(v7);
		} break;
		case 94LL: { // B'^'
			STR* v8;
			STRLIT(v8, "ZCaret", 6);
			x2 = MKSTR(v8);
		} break;
		case 58LL: { // BCOLON
			STR* v9;
			STRLIT(v9, "ZColon", 6);
			x2 = MKSTR(v9);
		} break;
		case 44LL: { // BCOMMA
			STR* v10;
			STRLIT(v10, "ZComma", 6);
			x2 = MKSTR(v10);
		} break;
		case 47LL: { // B'/'
			STR* v11;
			STRLIT(v11, "ZDiv", 4);
			x2 = MKSTR(v11);
		} break;
		case 36LL: { // B'$'
			STR* v12;
			STRLIT(v12, "ZDollar", 7);
			x2 = MKSTR(v12);
		} break;
		case 46LL: { // BDOT
			STR* v13;
			STRLIT(v13, "ZDot", 4);
			x2 = MKSTR(v13);
		} break;
		case 61LL: { // B'='
			STR* v14;
			STRLIT(v14, "ZEqual", 6);
			x2 = MKSTR(v14);
		} break;
		case 35LL: { // BHASH
			STR* v15;
			STRLIT(v15, "ZHash", 5);
			x2 = MKSTR(v15);
		} break;
		case 123LL: { // BLCURLY
			STR* v16;
			STRLIT(v16, "ZLCurly", 7);
			x2 = MKSTR(v16);
		} break;
		case 40LL: { // BLPAREN
			STR* v17;
			STRLIT(v17, "ZLParen", 7);
			x2 = MKSTR(v17);
		} break;
		case 91LL: { // BLSQUARE
			STR* v18;
			STRLIT(v18, "ZLSquare", 8);
			x2 = MKSTR(v18);
		} break;
		case 60LL: { // B'<'
			STR* v19;
			STRLIT(v19, "ZLess", 5);
			x2 = MKSTR(v19);
		} break;
		case 37LL: { // B'%'
			STR* v20;
			STRLIT(v20, "ZMod", 4);
			x2 = MKSTR(v20);
		} break;
		case 42LL: { // B'*'
			STR* v21;
			STRLIT(v21, "ZMul", 4);
			x2 = MKSTR(v21);
		} break;
		case 124LL: { // B'|'
			STR* v22;
			STRLIT(v22, "ZPipe", 5);
			x2 = MKSTR(v22);
		} break;
		case 43LL: { // B'+'
			STR* v23;
			STRLIT(v23, "ZPlus", 5);
			x2 = MKSTR(v23);
		} break;
		case 34LL: { // BQUOTE
			STR* v24;
			STRLIT(v24, "ZQuote", 6);
			x2 = MKSTR(v24);
		} break;
		case 125LL: { // BRCURLY
			STR* v25;
			STRLIT(v25, "ZRCurly", 7);
			x2 = MKSTR(v25);
		} break;
		case 41LL: { // BRPAREN
			STR* v26;
			STRLIT(v26, "ZRParen", 7);
			x2 = MKSTR(v26);
		} break;
		case 93LL: { // BRSQUARE
			STR* v27;
			STRLIT(v27, "ZRSquare", 8);
			x2 = MKSTR(v27);
		} break;
		case 59LL: { // B';'
			STR* v28;
			STRLIT(v28, "ZThen", 5);
			x2 = MKSTR(v28);
		} break;
		case 39LL: { // BTICK
			STR* v29;
			STRLIT(v29, "ZTick", 5);
			x2 = MKSTR(v29);
		} break;
		case 126LL: { // B'~'
			STR* v30;
			STRLIT(v30, "ZTilde", 6);
			x2 = MKSTR(v30);
		} break;
		case 62LL: { // B'>'
			STR* v31;
			STRLIT(v31, "ZTo", 3);
			x2 = MKSTR(v31);
		} break;
		case 90LL: { // B'Z'
			STR* v32;
			STRLIT(v32, "ZZ", 2);
			x2 = MKSTR(v32);
		} break;
		case 45LL: { // B'-'
			STR* v33;
			STRLIT(v33, "Z_", 2);
			x2 = MKSTR(v33);
		} break;
		case 122LL: { // B'z'
			STR* v34;
			STRLIT(v34, "zz", 2);
			x2 = MKSTR(v34);
		} break;
		case 95LL: { // B'_'
			STR* v35;
			STRLIT(v35, "z_", 2);
			x2 = MKSTR(v35);
		} break;
		default: {
			int64_t v36 = mw_std_byte_Byte_isZ_alnum(x1);
			VAL x37;
			if (((bool)v36)) {
				VAL v38 = mw_std_byte_Byte_toZ_strZ_unsafe(x1);
				x37 = v38;
			} else {
				STR* v39;
				STRLIT(v39, "", 0);
				STR* v40;
				STRLIT(v40, "Z", 1);
				VAL v41 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v40), MKSTR(v39)));
				STR* v42 = i64_show(x1);
				VAL v43 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v42), v41));
				STR* v44;
				STRLIT(v44, "U", 1);
				VAL v45 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v44), v43));
				x37 = v45;
			}
			x2 = x37;
		} break;
	}
	return x2;
}
static VAL mw_std_buffer_ZPlusBuffer_new (int64_t x1) {
	int64_t v2 = (0LL /* +Unsafe */);
	void* v3 = ptr_alloc(((uint64_t)x1));;
	VAL v4 = (mtw_std_buffer_ZPlusBuffer_ZPlusBuffer(x1, v3));
	int64_t v5 = 0LL;
	int64_t v6 = VI64(VTUP(v4)->cells[1]);
	VAL v7 = (mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang(v5, v6, v4));
	return v7;
}
static VAL mw_std_buffer_ZPlusBuffer_resizzeZBang (int64_t x1, VAL x2) {
	int64_t v3 = VI64(VTUP(x2)->cells[1]);
	VTUP(x2)->cells[1] = MKI64(x1);
	int64_t v4 = VI64(VTUP(x2)->cells[1]);
	void* v5 = VPTR(VTUP(x2)->cells[2]);
	int64_t v6 = (0LL /* +Unsafe */);
	void* v7 = ptr_realloc(v5,((uint64_t)v4));
	VTUP(x2)->cells[2] = MKPTR(v7);
	int64_t v8 = VI64(VTUP(x2)->cells[1]);
	int64_t v9 = i64_sub(v8, v3);
	int64_t v10 = 0LL;
	bool v11 = (v9 < v10);
	VAL x12;
	if (v11) {
		x12 = x2;
	} else {
		VAL v13 = (mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang(v3, v9, x2));
		x12 = v13;
	}
	return x12;
}
static VAL mw_std_buffer_ZPlusBuffer_expandZBang (int64_t x1, VAL x2) {
	int64_t v3 = VI64(VTUP(x2)->cells[1]);
	bool v4 = (x1 > v3);
	VAL x5;
	if (v4) {
		int64_t v6 = VI64(VTUP(x2)->cells[1]);
		int64_t v7 = 2LL;
		int64_t v8 = i64_mul(v6, v7);
		bool v9 = (x1 < v8);
		int64_t x10;
		if (v9) {
			x10 = v8;
			push_resource(x2);
		} else {
			x10 = x1;
			push_resource(x2);
		}
		VAL r11 = pop_resource();
		VAL v12 = (mw_std_buffer_ZPlusBuffer_resizzeZBang(x10, r11));
		x5 = v12;
	} else {
		x5 = x2;
	}
	return x5;
}
static void mw_std_buffer_ZPlusBuffer_rdrop (VAL x1) {
	int64_t v2;
	void* v3;
	mtp_std_buffer_ZPlusBuffer_ZPlusBuffer(x1, &v2, &v3);
	int64_t v4 = (0LL /* +Unsafe */);
	free(v3);
}
static VAL mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang (int64_t x1, int64_t x2, VAL x3) {
	int64_t v4;
	int64_t v5;
	VAL v6;
	mw_std_buffer_ZPlusBuffer_clampZ_spanZBang(x1, x2, x3, &v4, &v5, &v6);
	void* v7 = VPTR(VTUP(v6)->cells[2]);
	int64_t v8 = (0LL /* +Unsafe */);
	void* v9 = (void*)(v4 + (char*)v7);
	int64_t v10 = 0LL;
	int64_t v11 = mw_std_prim_Int_ZToU8(v10);
	ptr_fill(((uint8_t)v11), ((uint64_t)v5), v9);
	return v6;
}
static void mw_std_buffer_ZPlusBuffer_clampZ_spanZBang (int64_t x1, int64_t x2, VAL x3, int64_t *x4, int64_t *x5, VAL *x6) {
	int64_t v7 = VI64(VTUP(x3)->cells[1]);
	int64_t v8 = i64_sub(v7, x1);
	int64_t v9 = 0LL;
	bool v10 = (v8 < v9);
	VAL x11;
	int64_t x12;
	int64_t x13;
	if (v10) {
		int64_t v14 = VI64(VTUP(x3)->cells[1]);
		int64_t v15 = 0LL;
		x13 = v15;
		x12 = v14;
		x11 = x3;
	} else {
		bool v16 = (v8 < x2);
		int64_t x17;
		if (v16) {
			x17 = v8;
			push_resource(x3);
			push_i64(x1);
		} else {
			x17 = x2;
			push_resource(x3);
			push_i64(x1);
		}
		x13 = x17;
		int64_t v18 = pop_i64();
		x12 = v18;
		VAL r19 = pop_resource();
		x11 = r19;
	}
	*x6 = x11;
	*x5 = x13;
	*x4 = x12;
}
static void mw_std_buffer_ZPlusBuffer_prepareZ_spanZBang (int64_t x1, int64_t x2, VAL x3, int64_t *x4, VAL *x5) {
	int64_t v6 = i64_add(x2, x1);
	VAL v7 = (mw_std_buffer_ZPlusBuffer_expandZBang(v6, x3));
	*x5 = v7;
	*x4 = x1;
}
static void mw_std_buffer_ZPlusBuffer_ZAtU8 (int64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	int64_t v5 = 1LL;
	int64_t v6;
	VAL v7;
	mw_std_buffer_ZPlusBuffer_prepareZ_spanZBang(x1, v5, x2, &v6, &v7);
	void* v8 = VPTR(VTUP(v7)->cells[2]);
	int64_t v9 = (0LL /* +Unsafe */);
	void* v10 = (void*)(v6 + (char*)v8);
	uint8_t v11 = *(uint8_t*)v10;
	*x4 = v7;
	*x3 = ((int64_t)v11);
}
static VAL mw_std_buffer_ZPlusBuffer_ZBangU8 (int64_t x1, int64_t x2, VAL x3) {
	int64_t v4 = 1LL;
	int64_t v5;
	VAL v6;
	mw_std_buffer_ZPlusBuffer_prepareZ_spanZBang(x2, v4, x3, &v5, &v6);
	void* v7 = VPTR(VTUP(v6)->cells[2]);
	int64_t v8 = (0LL /* +Unsafe */);
	void* v9 = (void*)(v5 + (char*)v7);
	*(uint8_t*)v9 = ((uint8_t)x1);
	return v6;
}
static VAL mw_std_buffer_ZPlusBuffer_ZBangByte (int64_t x1, int64_t x2, VAL x3) {
	int64_t v4 = mw_std_prim_Int_ZToU8(x1);
	VAL v5 = (mw_std_buffer_ZPlusBuffer_ZBangU8(v4, x2, x3));
	return v5;
}
static VAL mw_std_buffer_ZPlusBuffer_ZBangStr (VAL x1, int64_t x2, VAL x3) {
	incref(x1);
	uint64_t v4 = str_size(VSTR(x1));
	int64_t v5 = 0LL;
	bool v6 = (((int64_t)v4) < v5);
	int64_t x7;
	if (v6) {
		x7 = v5;
		push_resource(x3);
		push_value(x1);
		push_i64(x2);
	} else {
		x7 = ((int64_t)v4);
		push_resource(x3);
		push_value(x1);
		push_i64(x2);
	}
	VAL r8 = pop_resource();
	int64_t v9 = pop_i64();
	int64_t v10;
	VAL v11;
	mw_std_buffer_ZPlusBuffer_prepareZ_spanZBang(v9, x7, r8, &v10, &v11);
	void* v12 = VPTR(VTUP(v11)->cells[2]);
	int64_t v13 = (0LL /* +Unsafe */);
	void* v14 = (void*)(v10 + (char*)v12);
	VAL v15 = pop_value();
	void* v16;
	int64_t v17;
	mw_std_prim_Ptr_ZBangStrZPlus(v15, v14, v13, &v16, &v17);
	return v11;
}
static void mw_std_buffer_ZPlusBuffer_ZAtStr (int64_t x1, int64_t x2, VAL x3, VAL *x4, VAL *x5) {
	int64_t v6;
	VAL v7;
	mw_std_buffer_ZPlusBuffer_prepareZ_spanZBang(x1, x2, x3, &v6, &v7);
	void* v8 = VPTR(VTUP(v7)->cells[2]);
	int64_t v9 = (0LL /* +Unsafe */);
	void* v10 = (void*)(v6 + (char*)v8);
	STR* v11 = str_make(v10, ((uint64_t)x2));
	*x5 = v7;
	*x4 = MKSTR(v11);
}
static void mw_std_prim_Ptr_ZBangStrZPlus (VAL x1, void* x2, int64_t x3, void* *x4, int64_t *x5) {
	incref(x1);
	incref(x1);
	void* v6 = str_base(VSTR(x1));
	uint64_t v7 = str_size(VSTR(x1));
	int64_t v8 = 0LL;
	bool v9 = (((int64_t)v7) < v8);
	int64_t x10;
	if (v9) {
		x10 = v8;
		push_resource(MKI64(x3));
		push_ptr(x2);
		push_ptr(v6);
	} else {
		x10 = ((int64_t)v7);
		push_resource(MKI64(x3));
		push_ptr(x2);
		push_ptr(v6);
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	incref(v12);
	void* v13 = (void*)(x10 + (char*)VPTR(v12));
	ptr_copy(VPTR(v11), ((uint64_t)x10), VPTR(v12));
	decref(x1);
	int64_t r14 = VI64(pop_resource());
	*x5 = r14;
	*x4 = v13;
}
static void mw_std_str_ZPlusStr_dupZBang (VAL x1, VAL *x2, VAL *x3) {
	incref(x1);
	*x3 = x1;
	*x2 = x1;
}
static void mw_std_str_ZPlusStr_numZ_bytesZAsk (VAL x1, int64_t *x2, VAL *x3) {
	incref(x1);
	uint64_t v4 = str_size(VSTR(x1));
	int64_t v5 = 0LL;
	bool v6 = (((int64_t)v4) < v5);
	int64_t x7;
	if (v6) {
		x7 = v5;
		push_value(x1);
	} else {
		x7 = ((int64_t)v4);
		push_value(x1);
	}
	VAL v8 = pop_value();
	*x3 = v8;
	*x2 = x7;
}
static int64_t mw_std_prim_Str_lastZ_byte (VAL x1) {
	incref(x1);
	uint64_t v2 = str_size(VSTR(x1));
	int64_t v3 = 0LL;
	bool v4 = (((int64_t)v2) < v3);
	int64_t x5;
	if (v4) {
		x5 = v3;
		push_value(x1);
	} else {
		x5 = ((int64_t)v2);
		push_value(x1);
	}
	int64_t v6 = 1LL;
	int64_t v7 = i64_sub(x5, v6);
	int64_t v8 = 0LL;
	bool v9 = (v7 < v8);
	int64_t x10;
	if (v9) {
		VAL v11 = pop_value();
		decref(v11);
		int64_t v12 = 0LL /* BNUL */;
		x10 = v12;
	} else {
		VAL v13 = pop_value();
		int64_t v14 = mw_std_prim_Str_byteZAt(v7, v13);
		x10 = v14;
	}
	return x10;
}
static void mw_std_str_ZPlusStr_lastZ_byte (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4;
	VAL v5;
	mw_std_str_ZPlusStr_dupZBang(x1, &v4, &v5);
	int64_t v6 = mw_std_prim_Str_lastZ_byte(v4);
	*x3 = v5;
	*x2 = v6;
}
static void mw_std_str_ZPlusStr_byteZAt (int64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_std_str_ZPlusStr_dupZBang(x2, &v5, &v6);
	int64_t v7 = mw_std_prim_Str_byteZAt(x1, v5);
	*x4 = v6;
	*x3 = v7;
}
static int64_t mw_std_str_offsetZ_inZ_bounds (int64_t x1, int64_t x2) {
	int64_t v3 = 0LL;
	bool v4 = (x1 >= v3);
	bool v5 = (x1 <= x2);
	bool v6 = (v4 && v5);
	return ((int64_t)v6);
}
static int64_t mw_std_prim_Str_byteZAt (int64_t x1, VAL x2) {
	incref(x2);
	incref(x2);
	void* v3 = str_base(VSTR(x2));
	uint64_t v4 = str_size(VSTR(x2));
	int64_t v5 = 0LL;
	bool v6 = (((int64_t)v4) < v5);
	int64_t x7;
	if (v6) {
		x7 = v5;
		push_i64(x1);
		push_ptr(v3);
	} else {
		x7 = ((int64_t)v4);
		push_i64(x1);
		push_ptr(v3);
	}
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	incref(v9);
	int64_t v10 = mw_std_str_offsetZ_inZ_bounds(VI64(v9), x7);
	int64_t x11;
	if (((bool)v10)) {
		int64_t v12 = (0LL /* +Unsafe */);
		void* v13 = (void*)(VI64(v9) + (char*)VPTR(v8));
		int64_t v14;
		int64_t v15;
		mw_std_prim_Ptr_ZAtByte(v13, v12, &v14, &v15);
		x11 = v14;
	} else {
		decref(v8);
		decref(v9);
		int64_t v16 = 0LL /* BNUL */;
		x11 = v16;
	}
	decref(x2);
	return x11;
}
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang (int64_t x1, VAL x2) {
	VAL v3 = mw_std_byte_Byte_toZ_strZ_unsafe(x1);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(v3, x2));
	return v4;
}
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang (int64_t x1, VAL x2) {
	VAL v3 = mw_std_byte_Byte_toZ_asciiZ_str(x1);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(v5, x2));
			x4 = v6;
		} break;
		case 0LL: { // None
			x4 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_std_str_ZPlusStr_pushZ_strZBang (VAL x1, VAL x2) {
	STR* v3 = str_cat(VSTR(x2), VSTR(x1));
	return MKSTR(v3);
}
static void mw_std_prim_Str_dropZ_bytes (int64_t x1, VAL x2, int64_t x3, VAL *x4, int64_t *x5) {
	incref(x2);
	incref(x2);
	void* v6 = str_base(VSTR(x2));
	uint64_t v7 = str_size(VSTR(x2));
	int64_t v8 = 0LL;
	bool v9 = (((int64_t)v7) < v8);
	int64_t x10;
	if (v9) {
		x10 = v8;
		push_i64(x1);
		push_resource(MKI64(x3));
		push_ptr(v6);
	} else {
		x10 = ((int64_t)v7);
		push_i64(x1);
		push_resource(MKI64(x3));
		push_ptr(v6);
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	incref(v12);
	int64_t v13 = i64_sub(x10, VI64(v12));
	int64_t v14 = 0LL;
	bool v15 = (v13 < v14);
	VAL x16;
	int64_t x17;
	if (v15) {
		decref(v11);
		decref(v12);
		STR* v18;
		STRLIT(v18, "", 0);
		int64_t r19 = VI64(pop_resource());
		x17 = r19;
		x16 = MKSTR(v18);
	} else {
		void* v20 = (void*)(VI64(v12) + (char*)VPTR(v11));
		STR* v21 = str_make(v20, ((uint64_t)v13));
		int64_t r22 = VI64(pop_resource());
		x17 = r22;
		x16 = MKSTR(v21);
	}
	decref(x2);
	*x5 = x17;
	*x4 = x16;
}
static VAL mw_std_prim_Str_fromZ_bytesZ_unsafe (VAL x1) {
	incref(x1);
	int64_t v2 = mw_std_list_List_1_len(x1);
	VAL v3 = (mw_std_buffer_ZPlusBuffer_new(v2));
	int64_t v4 = 0LL;
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(x1, &v5, &v6);
	VAL x7;
	int64_t x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			int64_t v12 = mw_std_prim_Int_ZToU8(VI64(v11));
			VAL v13 = (mw_std_buffer_ZPlusBuffer_ZBangU8(v12, v4, v3));
			int64_t v14 = 1LL;
			int64_t v15 = i64_add(v4, v14);
			int64_t v16 = 1LL /* True */;
			x10 = v16;
			x9 = v6;
			x8 = v15;
			x7 = v13;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x10 = v17;
			x9 = v6;
			x8 = v4;
			x7 = v3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x7);
	int64_t v19 = x8;
	VAL v20 = x9;
	int64_t v21 = x10;
	while (((bool)v21)) {
		VAL v22 = (v18);
		int64_t v23 = v19;
		VAL v24 = v20;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		int64_t x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
				int64_t v32 = mw_std_prim_Int_ZToU8(VI64(v31));
				VAL v33 = (mw_std_buffer_ZPlusBuffer_ZBangU8(v32, v23, v22));
				int64_t v34 = 1LL;
				int64_t v35 = i64_add(v23, v34);
				int64_t v36 = 1LL /* True */;
				x30 = v36;
				x29 = v26;
				x28 = v35;
				x27 = v33;
			} break;
			case 0LL: { // None
				int64_t v37 = 0LL /* False */;
				x30 = v37;
				x29 = v26;
				x28 = v23;
				x27 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x30;
		v20 = x29;
		v19 = x28;
		v18 = x27;
	}
	decref(v20);
	void* v38 = VPTR(VTUP(v18)->cells[2]);
	int64_t v39 = VI64(VTUP(v18)->cells[1]);
	int64_t v40 = (0LL /* +Unsafe */);
	STR* v41 = str_make(v38, ((uint64_t)v39));
	mw_std_buffer_ZPlusBuffer_rdrop(v18);
	return MKSTR(v41);
}
static void mw_std_str_clampZ_sliceZ_offsetZ_sizze (int64_t x1, int64_t x2, int64_t x3, int64_t *x4, int64_t *x5) {
	bool v6 = (x1 < x3);
	int64_t x7;
	if (v6) {
		x7 = x1;
		push_i64(x3);
	} else {
		x7 = x3;
		push_i64(x3);
	}
	VAL v8 = pop_value();
	int64_t v9 = i64_sub(VI64(v8), x7);
	int64_t v10 = 0LL;
	bool v11 = (v9 < v10);
	int64_t x12;
	int64_t x13;
	if (v11) {
		int64_t v14 = 0LL;
		x13 = v14;
		x12 = x7;
	} else {
		bool v15 = (x2 < v9);
		int64_t x16;
		if (v15) {
			x16 = x2;
			push_i64(x7);
		} else {
			x16 = v9;
			push_i64(x7);
		}
		x13 = x16;
		int64_t v17 = pop_i64();
		x12 = v17;
	}
	*x5 = x13;
	*x4 = x12;
}
static void mw_std_prim_Str_slice (int64_t x1, int64_t x2, VAL x3, int64_t x4, VAL *x5, int64_t *x6) {
	incref(x3);
	incref(x3);
	void* v7 = str_base(VSTR(x3));
	uint64_t v8 = str_size(VSTR(x3));
	int64_t v9 = 0LL;
	bool v10 = (((int64_t)v8) < v9);
	int64_t x11;
	if (v10) {
		x11 = v9;
		push_i64(x1);
		push_i64(x2);
		push_resource(MKI64(x4));
		push_ptr(v7);
	} else {
		x11 = ((int64_t)v8);
		push_i64(x1);
		push_i64(x2);
		push_resource(MKI64(x4));
		push_ptr(v7);
	}
	void* v12 = pop_ptr();
	int64_t v13 = pop_i64();
	int64_t v14 = pop_i64();
	int64_t v15;
	int64_t v16;
	mw_std_str_clampZ_sliceZ_offsetZ_sizze(v14, v13, x11, &v15, &v16);
	void* v17 = (void*)(v15 + (char*)v12);
	STR* v18 = str_make(v17, ((uint64_t)v16));
	decref(x3);
	int64_t r19 = VI64(pop_resource());
	*x6 = r19;
	*x5 = MKSTR(v18);
}
static void mw_std_prim_Str_dropZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, int64_t *x5) {
	VAL v6;
	VAL v7;
	int64_t v8;
	mw_std_str_ZPlusStr_dropZ_slice(x1, x2, x3, &v6, &v7, &v8);
	decref(v7);
	*x5 = v8;
	*x4 = v6;
}
static void mw_std_prim_Str_takeZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, int64_t *x5) {
	VAL v6;
	VAL v7;
	int64_t v8;
	mw_std_str_ZPlusStr_takeZ_slice(x1, x2, x3, &v6, &v7, &v8);
	decref(v7);
	*x5 = v8;
	*x4 = v6;
}
static void mw_std_str_ZPlusStr_slice (int64_t x1, int64_t x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, int64_t *x7) {
	VAL v8;
	VAL v9;
	mw_std_str_ZPlusStr_dupZBang(x3, &v8, &v9);
	VAL v10;
	int64_t v11;
	mw_std_prim_Str_slice(x1, x2, v8, x4, &v10, &v11);
	*x7 = v11;
	*x6 = v9;
	*x5 = v10;
}
static void mw_std_str_ZPlusStr_offsetZ_slice (int64_t x1, int64_t x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, int64_t *x7) {
	int64_t v8 = i64_sub(x2, x1);
	int64_t v9 = 0LL;
	bool v10 = (v8 < v9);
	VAL x11;
	VAL x12;
	int64_t x13;
	if (v10) {
		STR* v14;
		STRLIT(v14, "", 0);
		x13 = x4;
		x12 = x3;
		x11 = MKSTR(v14);
	} else {
		VAL v15;
		VAL v16;
		int64_t v17;
		mw_std_str_ZPlusStr_slice(x1, v8, x3, x4, &v15, &v16, &v17);
		x13 = v17;
		x12 = v16;
		x11 = v15;
	}
	*x7 = x13;
	*x6 = x12;
	*x5 = x11;
}
static void mw_std_str_ZPlusStr_takeZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, VAL *x5, int64_t *x6) {
	int64_t v7 = 0LL;
	VAL v8;
	VAL v9;
	int64_t v10;
	mw_std_str_ZPlusStr_slice(v7, x1, x2, x3, &v8, &v9, &v10);
	*x6 = v10;
	*x5 = v9;
	*x4 = v8;
}
static void mw_std_str_ZPlusStr_dropZ_slice (int64_t x1, VAL x2, int64_t x3, VAL *x4, VAL *x5, int64_t *x6) {
	int64_t v7;
	VAL v8;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x2, &v7, &v8);
	VAL v9;
	VAL v10;
	int64_t v11;
	mw_std_str_ZPlusStr_slice(x1, v7, v8, x3, &v9, &v10, &v11);
	*x6 = v11;
	*x5 = v10;
	*x4 = v9;
}
static void mw_std_str_ZPlusStr_splitZ_byte (int64_t x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = MKI64(0LL /* Nil */);
	VAL v6 = mw_std_list_List_1_reverse(v5);
	int64_t v7 = 0LL;
	int64_t v8;
	VAL v9;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x2, &v8, &v9);
	bool v10 = (v7 < v8);
	int64_t v11 = x1;
	int64_t v12 = v7;
	int64_t v13 = v7;
	VAL v14 = (v9);
	VAL v15 = (v6);
	bool v16 = v10;
	while (v16) {
		int64_t v17 = v11;
		int64_t v18 = v12;
		int64_t v19 = v13;
		VAL v20 = (v14);
		VAL v21 = (v15);
		int64_t v22;
		VAL v23;
		mw_std_str_ZPlusStr_byteZAt(v19, v20, &v22, &v23);
		bool v24 = (v22 == v17);
		int64_t x25;
		VAL x26;
		VAL x27;
		int64_t x28;
		int64_t x29;
		if (v24) {
			int64_t v30 = (0LL /* +Unsafe */);
			VAL v31;
			VAL v32;
			int64_t v33;
			mw_std_str_ZPlusStr_offsetZ_slice(v18, v19, v23, v30, &v31, &v32, &v33);
			VAL v34 = mtw_std_list_List_1_Cons(v31, v21);
			int64_t v35 = 1LL;
			int64_t v36 = i64_add(v19, v35);
			x29 = v36;
			x28 = v36;
			x27 = v34;
			x26 = v32;
			x25 = v17;
		} else {
			int64_t v37 = 1LL;
			int64_t v38 = i64_add(v19, v37);
			x29 = v38;
			x28 = v18;
			x27 = v21;
			x26 = v23;
			x25 = v17;
		}
		int64_t v39;
		VAL v40;
		mw_std_str_ZPlusStr_numZ_bytesZAsk(x26, &v39, &v40);
		bool v41 = (x29 < v39);
		v16 = v41;
		v15 = x27;
		v14 = v40;
		v13 = x29;
		v12 = x28;
		v11 = x25;
	}
	int64_t v42 = (0LL /* +Unsafe */);
	VAL v43;
	VAL v44;
	int64_t v45;
	mw_std_str_ZPlusStr_offsetZ_slice(v12, v13, v14, v42, &v43, &v44, &v45);
	VAL v46 = mtw_std_list_ListZPlus_1_ListZPlus(v43, v15);
	VAL v47 = mw_std_list_ListZPlus_1_reverse(v46);
	*x4 = v44;
	*x3 = v47;
}
static VAL mw_std_prim_Str_splitZ_byte (int64_t x1, VAL x2) {
	VAL v3;
	VAL v4;
	mw_std_str_ZPlusStr_splitZ_byte(x1, x2, &v3, &v4);
	decref(v4);
	return v3;
}
static void mw_std_str_ZPlusStr_pushZ_showZ_byteZBang (VAL x1, int64_t x2, int64_t x3, int64_t *x4, VAL *x5) {
	int64_t x6;
	VAL x7;
	switch (x3) {
		case 34LL: { // BQUOTE
			STR* v8;
			STRLIT(v8, "\\\"", 2);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), x1));
			int64_t v10 = 0LL /* False */;
			x7 = v9;
			x6 = v10;
		} break;
		case 92LL: { // B'\'
			STR* v11;
			STRLIT(v11, "\\\\", 2);
			VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), x1));
			int64_t v13 = 0LL /* False */;
			x7 = v12;
			x6 = v13;
		} break;
		case 10LL: { // BLF
			STR* v14;
			STRLIT(v14, "\n", 1);
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), x1));
			int64_t v16 = 0LL /* False */;
			x7 = v15;
			x6 = v16;
		} break;
		case 13LL: { // BCR
			STR* v17;
			STRLIT(v17, "\r", 1);
			VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v17), x1));
			int64_t v19 = 0LL /* False */;
			x7 = v18;
			x6 = v19;
		} break;
		case 9LL: { // BHT
			STR* v20;
			STRLIT(v20, "\t", 1);
			VAL v21 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v20), x1));
			int64_t v22 = 0LL /* False */;
			x7 = v21;
			x6 = v22;
		} break;
		default: {
			int64_t v23 = 32LL /* BSPACE */;
			int64_t v24 = 126LL /* B'~' */;
			bool v25 = (x3 >= v23);
			bool v26 = (x3 <= v24);
			bool v27 = (v25 && v26);
			VAL x28;
			int64_t x29;
			int64_t x30;
			int64_t x31;
			if (v27) {
				VAL x32;
				int64_t x33;
				int64_t x34;
				int64_t x35;
				if (((bool)x2)) {
					int64_t v36 = mw_std_byte_Byte_isZ_hexdigit(x3);
					x35 = v36;
					x34 = x2;
					x33 = x3;
					x32 = x1;
				} else {
					int64_t v37 = 0LL /* False */;
					x35 = v37;
					x34 = x2;
					x33 = x3;
					x32 = x1;
				}
				bool v38 = !((bool)x35);
				x31 = ((int64_t)v38);
				x30 = x33;
				x29 = x34;
				x28 = x32;
			} else {
				int64_t v39 = 0LL /* False */;
				x31 = v39;
				x30 = x3;
				x29 = x2;
				x28 = x1;
			}
			VAL x40;
			int64_t x41;
			if (((bool)x31)) {
				VAL v42 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(x30, x28));
				int64_t v43 = 0LL /* False */;
				x41 = v43;
				x40 = v42;
			} else {
				STR* v44;
				STRLIT(v44, "\\x", 2);
				VAL v45 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v44), x28));
				int64_t v46;
				int64_t v47;
				mw_std_byte_Byte_toZ_hexdigits(x30, &v46, &v47);
				VAL v48 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v46, v45));
				VAL v49 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v47, v48));
				int64_t v50 = 1LL /* True */;
				x41 = v50;
				x40 = v49;
			}
			x7 = x40;
			x6 = x41;
		} break;
	}
	*x5 = x7;
	*x4 = x6;
}
static VAL mw_std_prim_Str_showZThen (VAL x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "\"", 1);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), x2));
	int64_t v5 = 0LL /* False */;
	incref(x1);
	incref(x1);
	void* v6 = str_base(VSTR(x1));
	uint64_t v7 = str_size(VSTR(x1));
	int64_t v8 = 0LL;
	bool v9 = (((int64_t)v7) < v8);
	int64_t x10;
	if (v9) {
		x10 = v8;
		push_resource(v4);
		lpush(&lbl_escapeZ_hex, MKI64(v5));
		push_ptr(v6);
	} else {
		x10 = ((int64_t)v7);
		push_resource(v4);
		lpush(&lbl_escapeZ_hex, MKI64(v5));
		push_ptr(v6);
	}
	int64_t v11 = 0LL;
	bool v12 = (x10 > v11);
	int64_t v13 = x10;
	bool v14 = v12;
	while (v14) {
		int64_t v15 = v13;
		void* v16 = pop_ptr();
		int64_t v17 = (0LL /* +Unsafe */);
		int64_t v18;
		int64_t v19;
		mw_std_prim_Ptr_ZAtByte(v16, v17, &v18, &v19);
		int64_t v20 = VI64(lpop(&lbl_escapeZ_hex));
		VAL r21 = pop_resource();
		int64_t v22;
		VAL v23;
		mw_std_str_ZPlusStr_pushZ_showZ_byteZBang(r21, v20, v18, &v22, &v23);
		int64_t v24 = 1LL;
		int64_t v25 = (0LL /* +Unsafe */);
		void* v26 = (void*)(v24 + (char*)v16);
		int64_t v27 = 1LL;
		int64_t v28 = i64_sub(v15, v27);
		int64_t v29 = 0LL;
		bool v30 = (v28 < v29);
		int64_t x31;
		if (v30) {
			int64_t v32 = 0LL;
			x31 = v32;
			lpush(&lbl_escapeZ_hex, MKI64(v22));
			push_resource(v23);
			push_ptr(v26);
		} else {
			x31 = v28;
			lpush(&lbl_escapeZ_hex, MKI64(v22));
			push_resource(v23);
			push_ptr(v26);
		}
		int64_t v33 = 0LL;
		bool v34 = (x31 > v33);
		v14 = v34;
		v13 = x31;
	}
	void* v35 = pop_ptr();
	decref(x1);
	int64_t v36 = VI64(lpop(&lbl_escapeZ_hex));
	STR* v37;
	STRLIT(v37, "\"", 1);
	VAL r38 = pop_resource();
	VAL v39 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v37), r38));
	return v39;
}
static int64_t mw_std_list_List_1_ZDivL0 (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static VAL mw_std_list_List_1_ZDivL1 (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 1LL: { // Cons
			VAL v3;
			VAL v4;
			mtp_std_list_List_1_Cons(x1, &v3, &v4);
			VAL x5;
			switch (get_data_tag(v4)) {
				case 0LL: { // Nil
					VAL v6 = mtw_std_maybe_Maybe_1_Some(v3);
					x5 = v6;
				} break;
				default: {
					decref(v4);
					decref(v3);
					VAL v7 = MKI64(0LL /* None */);
					x5 = v7;
				} break;
			}
			x2 = x5;
		} break;
		default: {
			decref(x1);
			VAL v8 = MKI64(0LL /* None */);
			x2 = v8;
		} break;
	}
	return x2;
}
static VAL mw_std_list_List_1_ZDivL2 (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 1LL: { // Cons
			VAL v3;
			VAL v4;
			mtp_std_list_List_1_Cons(x1, &v3, &v4);
			VAL v5 = mw_std_list_List_1_ZDivL1(v4);
			VAL x6;
			switch (get_data_tag(v5)) {
				case 1LL: { // Some
					VAL v7 = mtp_std_maybe_Maybe_1_Some(v5);
					VAL v8 = MKNIL;
					VAL v9 = mkcons(v8, v3);
					VAL v10 = mkcons(v9, v7);
					VAL v11 = mtw_std_maybe_Maybe_1_Some(v10);
					x6 = v11;
				} break;
				case 0LL: { // None
					decref(v3);
					VAL v12 = MKI64(0LL /* None */);
					x6 = v12;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x2 = x6;
		} break;
		default: {
			decref(x1);
			VAL v13 = MKI64(0LL /* None */);
			x2 = v13;
		} break;
	}
	return x2;
}
static int64_t mw_std_list_List_1_emptyZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static int64_t mw_std_list_List_1_len (VAL x1) {
	int64_t v2 = 0LL;
	VAL v3;
	VAL v4;
	mw_std_list_List_1_uncons(x1, &v3, &v4);
	int64_t x5;
	VAL x6;
	int64_t x7;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v3);
			decref(v8);
			int64_t v9 = 1LL;
			int64_t v10 = i64_add(v2, v9);
			int64_t v11 = 1LL /* True */;
			x7 = v11;
			x6 = v4;
			x5 = v10;
		} break;
		case 0LL: { // None
			int64_t v12 = 0LL /* False */;
			x7 = v12;
			x6 = v4;
			x5 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v13 = x5;
	VAL v14 = x6;
	int64_t v15 = x7;
	while (((bool)v15)) {
		int64_t v16 = v13;
		VAL v17 = v14;
		VAL v18;
		VAL v19;
		mw_std_list_List_1_uncons(v17, &v18, &v19);
		int64_t x20;
		VAL x21;
		int64_t x22;
		switch (get_data_tag(v18)) {
			case 1LL: { // Some
				VAL v23 = mtp_std_maybe_Maybe_1_Some(v18);
				decref(v23);
				int64_t v24 = 1LL;
				int64_t v25 = i64_add(v16, v24);
				int64_t v26 = 1LL /* True */;
				x22 = v26;
				x21 = v19;
				x20 = v25;
			} break;
			case 0LL: { // None
				int64_t v27 = 0LL /* False */;
				x22 = v27;
				x21 = v19;
				x20 = v16;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v15 = x22;
		v14 = x21;
		v13 = x20;
	}
	decref(v14);
	return v13;
}
static VAL mw_std_list_List_1_ZToListZPlus (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			VAL v3 = MKI64(0LL /* None */);
			x2 = v3;
		} break;
		case 1LL: { // Cons
			VAL v4;
			VAL v5;
			mtp_std_list_List_1_Cons(x1, &v4, &v5);
			VAL v6 = mtw_std_list_ListZPlus_1_ListZPlus(v4, v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			x2 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_std_list_List_1_uncons (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			VAL v6 = MKI64(0LL /* None */);
			VAL v7 = MKI64(0LL /* Nil */);
			x5 = v7;
			x4 = v6;
		} break;
		case 1LL: { // Cons
			VAL v8;
			VAL v9;
			mtp_std_list_List_1_Cons(x1, &v8, &v9);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v8);
			x5 = v9;
			x4 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_std_list_ListZPlus_1_uncons (VAL x1, VAL *x2, VAL *x3) {
	VAL v4;
	VAL v5;
	mtp_std_list_ListZPlus_1_ListZPlus(x1, &v4, &v5);
	*x3 = v5;
	*x2 = v4;
}
static void mw_std_list_List_1_unsnoc (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = mw_std_list_List_1_reverse(x1);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v4, &v5, &v6);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	*x3 = v5;
	*x2 = v7;
}
static void mw_std_list_ListZPlus_1_unsnoc (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = mw_std_list_ListZPlus_1_reverse(x1);
	VAL v5;
	VAL v6;
	mw_std_list_ListZPlus_1_uncons(v4, &v5, &v6);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	*x3 = v5;
	*x2 = v7;
}
static VAL mw_std_list_List_1_cat (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // Nil
			x3 = x1;
		} break;
		default: {
			VAL v4 = mw_std_list_List_1_reverse(x1);
			VAL v5;
			VAL v6;
			mw_std_list_List_1_uncons(v4, &v5, &v6);
			VAL x7;
			VAL x8;
			int64_t x9;
			switch (get_data_tag(v5)) {
				case 1LL: { // Some
					VAL v10 = mtp_std_maybe_Maybe_1_Some(v5);
					VAL v11 = mtw_std_list_List_1_Cons(v10, x2);
					int64_t v12 = 1LL /* True */;
					x9 = v12;
					x8 = v6;
					x7 = v11;
				} break;
				case 0LL: { // None
					int64_t v13 = 0LL /* False */;
					x9 = v13;
					x8 = v6;
					x7 = x2;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v14 = x7;
			VAL v15 = x8;
			int64_t v16 = x9;
			while (((bool)v16)) {
				VAL v17 = v14;
				VAL v18 = v15;
				VAL v19;
				VAL v20;
				mw_std_list_List_1_uncons(v18, &v19, &v20);
				VAL x21;
				VAL x22;
				int64_t x23;
				switch (get_data_tag(v19)) {
					case 1LL: { // Some
						VAL v24 = mtp_std_maybe_Maybe_1_Some(v19);
						VAL v25 = mtw_std_list_List_1_Cons(v24, v17);
						int64_t v26 = 1LL /* True */;
						x23 = v26;
						x22 = v20;
						x21 = v25;
					} break;
					case 0LL: { // None
						int64_t v27 = 0LL /* False */;
						x23 = v27;
						x22 = v20;
						x21 = v17;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v16 = x23;
				v15 = x22;
				v14 = x21;
			}
			decref(v15);
			x3 = v14;
		} break;
	}
	return x3;
}
static VAL mw_std_list_List_1_first (VAL x1) {
	VAL v2 = mw_std_list_List_1_ZToListZPlus(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = VVAL(VTUP(v4)->cells[1]);
			incref(v5);
			decref(v4);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			x3 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x3 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_std_list_List_1_last (VAL x1) {
	VAL v2 = mw_std_list_List_1_ZToListZPlus(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_std_list_ListZPlus_1_last(v4);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			x3 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x3 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_std_list_ListZPlus_1_first (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[1]);
	incref(v2);
	decref(x1);
	return v2;
}
static VAL mw_std_list_ListZPlus_1_last (VAL x1) {
	VAL v2;
	VAL v3;
	mw_std_list_ListZPlus_1_uncons(x1, &v2, &v3);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v3, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			decref(v2);
			int64_t v10 = 1LL /* True */;
			x8 = v10;
			x7 = v5;
			x6 = v9;
		} break;
		case 0LL: { // None
			int64_t v11 = 0LL /* False */;
			x8 = v11;
			x7 = v5;
			x6 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v12 = x6;
	VAL v13 = x7;
	int64_t v14 = x8;
	while (((bool)v14)) {
		VAL v15 = v12;
		VAL v16 = v13;
		VAL v17;
		VAL v18;
		mw_std_list_List_1_uncons(v16, &v17, &v18);
		VAL x19;
		VAL x20;
		int64_t x21;
		switch (get_data_tag(v17)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v17);
				decref(v15);
				int64_t v23 = 1LL /* True */;
				x21 = v23;
				x20 = v18;
				x19 = v22;
			} break;
			case 0LL: { // None
				int64_t v24 = 0LL /* False */;
				x21 = v24;
				x20 = v18;
				x19 = v15;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v14 = x21;
		v13 = x20;
		v12 = x19;
	}
	decref(v13);
	return v12;
}
static VAL mw_std_list_List_1_reverse (VAL x1) {
	VAL v2 = MKI64(0LL /* Nil */);
	VAL v3;
	VAL v4;
	mw_std_list_List_1_uncons(x1, &v3, &v4);
	VAL x5;
	VAL x6;
	int64_t x7;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v9 = mtw_std_list_List_1_Cons(v8, v2);
			int64_t v10 = 1LL /* True */;
			x7 = v10;
			x6 = v4;
			x5 = v9;
		} break;
		case 0LL: { // None
			int64_t v11 = 0LL /* False */;
			x7 = v11;
			x6 = v4;
			x5 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v12 = x5;
	VAL v13 = x6;
	int64_t v14 = x7;
	while (((bool)v14)) {
		VAL v15 = v12;
		VAL v16 = v13;
		VAL v17;
		VAL v18;
		mw_std_list_List_1_uncons(v16, &v17, &v18);
		VAL x19;
		VAL x20;
		int64_t x21;
		switch (get_data_tag(v17)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v17);
				VAL v23 = mtw_std_list_List_1_Cons(v22, v15);
				int64_t v24 = 1LL /* True */;
				x21 = v24;
				x20 = v18;
				x19 = v23;
			} break;
			case 0LL: { // None
				int64_t v25 = 0LL /* False */;
				x21 = v25;
				x20 = v18;
				x19 = v15;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v14 = x21;
		v13 = x20;
		v12 = x19;
	}
	decref(v13);
	return v12;
}
static VAL mw_std_list_ListZPlus_1_reverse (VAL x1) {
	VAL v2;
	VAL v3;
	mw_std_list_ListZPlus_1_uncons(x1, &v2, &v3);
	VAL v4 = MKI64(0LL /* Nil */);
	VAL v5 = mtw_std_list_ListZPlus_1_ListZPlus(v2, v4);
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(v3, &v6, &v7);
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v12;
			VAL v13;
			mtp_std_list_ListZPlus_1_ListZPlus(v5, &v12, &v13);
			VAL v14 = mtw_std_list_List_1_Cons(v12, v13);
			VAL v15 = mtw_std_list_ListZPlus_1_ListZPlus(v11, v14);
			int64_t v16 = 1LL /* True */;
			x10 = v16;
			x9 = v7;
			x8 = v15;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x10 = v17;
			x9 = v7;
			x8 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = x8;
	VAL v19 = x9;
	int64_t v20 = x10;
	while (((bool)v20)) {
		VAL v21 = v18;
		VAL v22 = v19;
		VAL v23;
		VAL v24;
		mw_std_list_List_1_uncons(v22, &v23, &v24);
		VAL x25;
		VAL x26;
		int64_t x27;
		switch (get_data_tag(v23)) {
			case 1LL: { // Some
				VAL v28 = mtp_std_maybe_Maybe_1_Some(v23);
				VAL v29;
				VAL v30;
				mtp_std_list_ListZPlus_1_ListZPlus(v21, &v29, &v30);
				VAL v31 = mtw_std_list_List_1_Cons(v29, v30);
				VAL v32 = mtw_std_list_ListZPlus_1_ListZPlus(v28, v31);
				int64_t v33 = 1LL /* True */;
				x27 = v33;
				x26 = v24;
				x25 = v32;
			} break;
			case 0LL: { // None
				int64_t v34 = 0LL /* False */;
				x27 = v34;
				x26 = v24;
				x25 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x27;
		v19 = x26;
		v18 = x25;
	}
	decref(v19);
	return v18;
}
static VAL mw_std_prim_Int_range (int64_t x1, int64_t x2) {
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	bool v5 = (x1 <= x2);
	int64_t v6 = x1;
	int64_t v7 = x2;
	VAL v8 = (v4);
	bool v9 = v5;
	while (v9) {
		int64_t v10 = v6;
		int64_t v11 = v7;
		VAL v12 = (v8);
		int64_t v13 = 1LL;
		int64_t v14 = i64_add(v10, v13);
		VAL v15 = mtw_std_list_List_1_Cons(MKI64(v10), v12);
		bool v16 = (v14 <= v11);
		v9 = v16;
		v8 = v15;
		v7 = v11;
		v6 = v14;
	}
	VAL v17 = mw_std_list_List_1_reverse(v8);
	return v17;
}
static int64_t mw_std_maybe_Maybe_1_noneZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // None
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(x1);
			decref(v4);
			int64_t v5 = 0LL /* False */;
			x2 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static int64_t mw_std_maybe_Maybe_1_someZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			x2 = v3;
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(x1);
			decref(v4);
			int64_t v5 = 1LL /* True */;
			x2 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static int64_t mw_std_maybe_Maybe_1_ZToBool (VAL x1) {
	int64_t v2 = mw_std_maybe_Maybe_1_someZAsk(x1);
	return v2;
}
static VAL mw_std_maybe_Maybe_1_ZToList (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // None
			VAL v3 = MKI64(0LL /* Nil */);
			x2 = v3;
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(x1);
			VAL v5 = MKI64(0LL /* Nil */);
			VAL v6 = mtw_std_list_List_1_Cons(v4, v5);
			x2 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_std_maybe_Maybe_1_zzip (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // None
			decref(x1);
			VAL v4 = MKI64(0LL /* None */);
			x3 = v4;
		} break;
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(x2);
			VAL x6;
			switch (get_data_tag(x1)) {
				case 0LL: { // None
					decref(v5);
					VAL v7 = MKI64(0LL /* None */);
					x6 = v7;
				} break;
				case 1LL: { // Some
					VAL v8 = mtp_std_maybe_Maybe_1_Some(x1);
					VAL v9 = MKNIL;
					VAL v10 = mkcons(v9, v8);
					VAL v11 = mkcons(v10, v5);
					VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
					x6 = v12;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_std_prim_Int_ZToOS (int64_t x1) {
	int64_t v2 = 1LL;
	int64_t v3 = 3LL;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	int64_t x7;
	if (v6) {
		x7 = x1;
	} else {
		int64_t v8 = 0LL /* OS_UNKNOWN */;
		x7 = v8;
	}
	return x7;
}
static int64_t mw_std_prim_Int_ZToArch (int64_t x1) {
	int64_t v2 = 1LL;
	int64_t v3 = 3LL;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	int64_t x7;
	if (v6) {
		x7 = x1;
	} else {
		int64_t v8 = 0LL /* ARCH_UNKNOWN */;
		x7 = v8;
	}
	return x7;
}
static VAL mw_std_prim_Int_ZToU8ZAsk (int64_t x1) {
	int64_t v2 = 0LL;
	int64_t v3 = 255LL;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	VAL x7;
	if (v6) {
		VAL v8 = mtw_std_maybe_Maybe_1_Some(MKI64(x1));
		x7 = v8;
	} else {
		VAL v9 = MKI64(0LL /* None */);
		x7 = v9;
	}
	return x7;
}
static VAL mw_std_prim_Int_ZToU16ZAsk (int64_t x1) {
	int64_t v2 = 0LL;
	int64_t v3 = 65535LL;
	bool v4 = (x1 >= v2);
	bool v5 = (x1 <= v3);
	bool v6 = (v4 && v5);
	VAL x7;
	if (v6) {
		VAL v8 = mtw_std_maybe_Maybe_1_Some(MKI64(x1));
		x7 = v8;
	} else {
		VAL v9 = MKI64(0LL /* None */);
		x7 = v9;
	}
	return x7;
}
static int64_t mw_std_prim_Int_ZToU8 (int64_t x1) {
	VAL v2 = mw_std_prim_Int_ZToU8ZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			x3 = VI64(v4);
		} break;
		case 0LL: { // None
			STR* v5;
			STRLIT(v5, "U8 out of bounds", 16);
			do_panic(v5);
			int64_t v6 = pop_i64();
			x3 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_std_prim_Int_ZToU16 (int64_t x1) {
	VAL v2 = mw_std_prim_Int_ZToU16ZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			x3 = VI64(v4);
		} break;
		case 0LL: { // None
			STR* v5;
			STRLIT(v5, "U16 out of bounds", 17);
			do_panic(v5);
			int64_t v6 = pop_i64();
			x3 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_std_prim_Int_ZToI64 (int64_t x1) {
	return x1;
}
static VAL mw_std_prelude_ZAtZAsk (void* x1) {
	bool v2 = mut_is_set(x1);
	VAL x3;
	if (v2) {
		VAL v4 = mut_get(x1);
		VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
		x3 = v5;
	} else {
		VAL v6 = MKI64(0LL /* None */);
		x3 = v6;
	}
	return x3;
}
static VAL mw_std_path_PATHz_SEPARATOR (void) {
	int64_t v1 = RUNNING_OS;
	int64_t v2 = mw_std_prim_Int_ZToOS(v1);
	int64_t v3 = 1LL /* OS_WINDOWS */;
	bool v4 = (v2 == v3);
	VAL x5;
	if (v4) {
		STR* v6;
		STRLIT(v6, "\\", 1);
		x5 = MKSTR(v6);
	} else {
		STR* v7;
		STRLIT(v7, "/", 1);
		x5 = MKSTR(v7);
	}
	return x5;
}
static VAL mw_std_path_Path_joinZ_with (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	uint64_t v4 = str_size(VSTR(x1));
	int64_t v5 = 0LL;
	bool v6 = (((int64_t)v4) < v5);
	int64_t x7;
	if (v6) {
		x7 = v5;
		push_value(x1);
		push_value(x2);
		push_value(x3);
	} else {
		x7 = ((int64_t)v4);
		push_value(x1);
		push_value(x2);
		push_value(x3);
	}
	int64_t v8 = 0LL;
	bool v9 = (x7 == v8);
	VAL x10;
	if (v9) {
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		decref(v12);
		VAL v13 = pop_value();
		decref(v13);
		x10 = v11;
	} else {
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		STR* v17 = str_cat(VSTR(v16), VSTR(v15));
		STR* v18 = str_cat(v17, VSTR(v14));
		x10 = MKSTR(v18);
	}
	return x10;
}
static VAL mw_std_path_Path_join (VAL x1, VAL x2) {
	VAL v3 = mw_std_path_PATHz_SEPARATOR();
	VAL v4 = mw_std_path_Path_joinZ_with(x1, v3, x2);
	return v4;
}
static int64_t mw_std_byte_Byte_isZ_pathZ_separatorZAsk (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 47LL: { // B'/'
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 92LL: { // B'\'
			int64_t v4 = RUNNING_OS;
			int64_t v5 = mw_std_prim_Int_ZToOS(v4);
			int64_t v6 = 1LL /* OS_WINDOWS */;
			bool v7 = (v5 == v6);
			x2 = ((int64_t)v7);
		} break;
		default: {
			int64_t v8 = 0LL /* False */;
			x2 = v8;
		} break;
	}
	return x2;
}
static void mw_std_path_Path_splitZ_last (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x1, &v4, &v5);
	VAL v6 = MKI64(0LL /* None */);
	incref(v6);
	int64_t v7 = mw_std_maybe_Maybe_1_noneZAsk(v6);
	VAL x8;
	int64_t x9;
	VAL x10;
	int64_t x11;
	if (((bool)v7)) {
		int64_t v12 = 0LL;
		bool v13 = (v4 > v12);
		x11 = ((int64_t)v13);
		x10 = v6;
		x9 = v4;
		x8 = v5;
	} else {
		int64_t v14 = 0LL /* False */;
		x11 = v14;
		x10 = v6;
		x9 = v4;
		x8 = v5;
	}
	VAL v15 = (x8);
	int64_t v16 = x9;
	VAL v17 = x10;
	int64_t v18 = x11;
	while (((bool)v18)) {
		VAL v19 = (v15);
		int64_t v20 = v16;
		VAL v21 = v17;
		decref(v21);
		int64_t v22 = 1LL;
		int64_t v23 = i64_sub(v20, v22);
		int64_t v24 = 0LL;
		bool v25 = (v23 < v24);
		int64_t x26;
		if (v25) {
			int64_t v27 = 0LL;
			x26 = v27;
			push_resource(v19);
		} else {
			x26 = v23;
			push_resource(v19);
		}
		VAL r28 = pop_resource();
		int64_t v29;
		VAL v30;
		mw_std_str_ZPlusStr_byteZAt(x26, r28, &v29, &v30);
		int64_t v31 = mw_std_byte_Byte_isZ_pathZ_separatorZAsk(v29);
		VAL x32;
		int64_t x33;
		VAL x34;
		if (((bool)v31)) {
			VAL v35 = mtw_std_maybe_Maybe_1_Some(MKI64(x26));
			x34 = v35;
			x33 = x26;
			x32 = v30;
		} else {
			VAL v36 = MKI64(0LL /* None */);
			x34 = v36;
			x33 = x26;
			x32 = v30;
		}
		incref(x34);
		int64_t v37 = mw_std_maybe_Maybe_1_noneZAsk(x34);
		VAL x38;
		int64_t x39;
		VAL x40;
		int64_t x41;
		if (((bool)v37)) {
			int64_t v42 = 0LL;
			bool v43 = (x33 > v42);
			x41 = ((int64_t)v43);
			x40 = x34;
			x39 = x33;
			x38 = x32;
		} else {
			int64_t v44 = 0LL /* False */;
			x41 = v44;
			x40 = x34;
			x39 = x33;
			x38 = x32;
		}
		v18 = x41;
		v17 = x40;
		v16 = x39;
		v15 = x38;
	}
	VAL x45;
	VAL x46;
	switch (get_data_tag(v17)) {
		case 1LL: { // Some
			VAL v47 = mtp_std_maybe_Maybe_1_Some(v17);
			int64_t v48 = (0LL /* +Unsafe */);
			incref(v47);
			incref(v15);
			int64_t v49 = 1LL;
			int64_t v50 = i64_add(VI64(v47), v49);
			VAL v51;
			int64_t v52;
			mw_std_prim_Str_dropZ_slice(v50, v15, v48, &v51, &v52);
			VAL v53;
			int64_t v54;
			mw_std_prim_Str_takeZ_slice(VI64(v47), v15, v52, &v53, &v54);
			VAL v55 = mtw_std_maybe_Maybe_1_Some(v51);
			x46 = v55;
			x45 = v53;
		} break;
		case 0LL: { // None
			VAL v56 = MKI64(0LL /* None */);
			x46 = v56;
			x45 = v15;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x46;
	*x2 = x45;
}
static VAL mw_std_path_Path_pathZThen (VAL x1, VAL x2) {
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(x1, x2));
	return v3;
}
static VAL mw_std_input_ZPlusInputOpenState_endZBang (VAL x1) {
	int64_t v2;
	int64_t v3;
	VAL v4;
	VAL v5;
	mtp_std_input_ZPlusInputOpenState_ZPlusInputOpenState(x1, &v2, &v3, &v4, &v5);
	mw_std_buffer_ZPlusBuffer_rdrop(v5);
	return v4;
}
static int64_t mw_std_input_INPUTz_BUFFERz_SIZZE (void) {
	int64_t v1 = 8192LL;
	int64_t v2 = 0LL;
	bool v3 = (v1 < v2);
	int64_t x4;
	if (v3) {
		x4 = v2;
	} else {
		x4 = v1;
	}
	return x4;
}
static VAL mw_std_input_ZPlusInput_startZBang (VAL x1) {
	int64_t v2 = mw_std_input_INPUTz_BUFFERz_SIZZE();
	VAL v3 = (mw_std_buffer_ZPlusBuffer_new(v2));
	int64_t v4 = 0LL;
	int64_t v5 = 0LL;
	VAL v6 = (mtw_std_input_ZPlusInputOpenState_ZPlusInputOpenState(v4, v5, x1, v3));
	VAL v7 = (mw_std_input_ZPlusInputOpenState_refillZ_bufferZBang(v6));
	return v7;
}
static VAL mw_std_input_ZPlusInput_endZBang (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v3 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			VAL v4 = (mw_std_input_ZPlusInputOpenState_endZBang(v3));
			x2 = v4;
		} break;
		case 1LL: { // +InputDone
			VAL v5 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			x2 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_std_input_ZPlusInput_doneZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v6 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v7 = 0LL /* False */;
			VAL v8 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(v6));
			x5 = v8;
			x4 = v7;
		} break;
		case 1LL: { // +InputDone
			VAL v9 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			int64_t v10 = 1LL /* True */;
			VAL v11 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v9));
			x5 = v11;
			x4 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static VAL mw_std_input_ZPlusInputOpenState_refillZ_bufferZBang (VAL x1) {
	VAL v2 = (VVAL(VTUP(x1)->cells[4]));
	void* v3 = VPTR(VTUP(v2)->cells[2]);
	int64_t v4 = VI64(VTUP(v2)->cells[1]);
	VTUP(x1)->cells[4] = v2;
	VAL v5 = (VVAL(VTUP(x1)->cells[3]));
	int64_t v6 = (0LL /* +Unsafe */);
	int64_t v7;
	int64_t v8;
	VAL v9;
	int64_t v10;
	mw_std_prelude_ZPlusUnsafe_readZ_bytesZBang(v3, v4, v5, v6, &v7, &v8, &v9, &v10);
	VTUP(x1)->cells[3] = v9;
	int64_t v11 = 0LL;
	bool v12 = (v7 > v11);
	bool v13 = (((bool)v8) && v12);
	VAL x14;
	if (v13) {
		VTUP(x1)->cells[1] = MKI64(v7);
		int64_t v15 = 0LL;
		VTUP(x1)->cells[2] = MKI64(v15);
		VAL v16 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(x1));
		x14 = v16;
	} else {
		VAL v17 = (mw_std_input_ZPlusInputOpenState_endZBang(x1));
		VAL v18 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v17));
		x14 = v18;
	}
	return x14;
}
static void mw_std_input_ZPlusInput_peek (VAL x1, int64_t *x2, VAL *x3) {
	int64_t x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v6 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v7 = VI64(VTUP(v6)->cells[2]);
			VAL v8 = (VVAL(VTUP(v6)->cells[4]));
			int64_t v9;
			VAL v10;
			mw_std_buffer_ZPlusBuffer_ZAtU8(v7, v8, &v9, &v10);
			VTUP(v6)->cells[4] = v10;
			int64_t v11 = mw_std_prim_U8_ZToByte(v9);
			VAL v12 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(v6));
			x5 = v12;
			x4 = v11;
		} break;
		case 1LL: { // +InputDone
			VAL v13 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			int64_t v14 = 0LL /* BNUL */;
			VAL v15 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v13));
			x5 = v15;
			x4 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static VAL mw_std_input_ZPlusInput_moveZBang (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v3 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v4 = VI64(VTUP(v3)->cells[1]);
			int64_t v5 = 1LL;
			int64_t v6 = i64_sub(v4, v5);
			int64_t v7 = 0LL;
			bool v8 = (v6 < v7);
			int64_t x9;
			if (v8) {
				int64_t v10 = 0LL;
				x9 = v10;
			} else {
				x9 = v6;
			}
			VTUP(v3)->cells[1] = MKI64(x9);
			int64_t v11 = VI64(VTUP(v3)->cells[2]);
			int64_t v12 = 1LL;
			int64_t v13 = i64_add(v11, v12);
			VTUP(v3)->cells[2] = MKI64(v13);
			VAL v14 = (mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang(v3));
			x2 = v14;
		} break;
		case 1LL: { // +InputDone
			VAL v15 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			VAL v16 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v15));
			x2 = v16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang (VAL x1) {
	int64_t v2 = VI64(VTUP(x1)->cells[1]);
	int64_t v3 = 0LL;
	bool v4 = (v2 == v3);
	VAL x5;
	if (v4) {
		VAL v6 = (mw_std_input_ZPlusInputOpenState_refillZ_bufferZBang(x1));
		x5 = v6;
	} else {
		VAL v7 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(x1));
		x5 = v7;
	}
	return x5;
}
static void mw_std_input_ZPlusInput_readZ_chunkZBang (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v6 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v7 = VI64(VTUP(v6)->cells[2]);
			int64_t v8 = VI64(VTUP(v6)->cells[1]);
			VAL v9 = (VVAL(VTUP(v6)->cells[4]));
			VAL v10;
			VAL v11;
			mw_std_buffer_ZPlusBuffer_ZAtStr(v7, v8, v9, &v10, &v11);
			VTUP(v6)->cells[4] = v11;
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v10);
			VAL v13 = (mw_std_input_ZPlusInputOpenState_refillZ_bufferZBang(v6));
			x5 = v13;
			x4 = v12;
		} break;
		case 1LL: { // +InputDone
			VAL v14 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			VAL v15 = MKI64(0LL /* None */);
			VAL v16 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v14));
			x5 = v16;
			x4 = v15;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_std_input_ZPlusInput_readZ_fileZBang (VAL x1, VAL *x2, VAL *x3) {
	STR* v4;
	STRLIT(v4, "", 0);
	VAL v5;
	VAL v6;
	mw_std_input_ZPlusInput_readZ_chunkZBang(x1, &v5, &v6);
	VAL x7;
	VAL x8;
	int64_t x9;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v5);
			STR* v11 = str_cat(v4, VSTR(v10));
			int64_t v12 = 1LL /* True */;
			x9 = v12;
			x8 = MKSTR(v11);
			x7 = v6;
		} break;
		case 0LL: { // None
			int64_t v13 = 0LL /* False */;
			x9 = v13;
			x8 = MKSTR(v4);
			x7 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v14 = (x7);
	VAL v15 = x8;
	int64_t v16 = x9;
	while (((bool)v16)) {
		VAL v17 = (v14);
		VAL v18 = v15;
		VAL v19;
		VAL v20;
		mw_std_input_ZPlusInput_readZ_chunkZBang(v17, &v19, &v20);
		VAL x21;
		VAL x22;
		int64_t x23;
		switch (get_data_tag(v19)) {
			case 1LL: { // Some
				VAL v24 = mtp_std_maybe_Maybe_1_Some(v19);
				STR* v25 = str_cat(VSTR(v18), VSTR(v24));
				int64_t v26 = 1LL /* True */;
				x23 = v26;
				x22 = MKSTR(v25);
				x21 = v20;
			} break;
			case 0LL: { // None
				int64_t v27 = 0LL /* False */;
				x23 = v27;
				x22 = v18;
				x21 = v20;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v16 = x23;
		v15 = x22;
		v14 = x21;
	}
	*x3 = v14;
	*x2 = v15;
}
static int64_t mw_std_output_OUTPUTz_BUFFERz_SIZZE (void) {
	int64_t v1 = 4096LL;
	int64_t v2 = 0LL;
	bool v3 = (v1 < v2);
	int64_t x4;
	if (v3) {
		x4 = v2;
	} else {
		x4 = v1;
	}
	return x4;
}
static VAL mw_std_output_ZPlusOutput_startZBang (VAL x1) {
	int64_t v2 = 0LL;
	int64_t v3 = mw_std_output_OUTPUTz_BUFFERz_SIZZE();
	VAL v4 = (mw_std_buffer_ZPlusBuffer_new(v3));
	VAL v5 = (mtw_std_output_ZPlusOutput_ZPlusOutput(v2, x1, v4));
	return v5;
}
static VAL mw_std_output_ZPlusOutput_endZBang (VAL x1) {
	VAL v2 = (mw_std_output_ZPlusOutput_flushZBang(x1));
	int64_t v3;
	VAL v4;
	VAL v5;
	mtp_std_output_ZPlusOutput_ZPlusOutput(v2, &v3, &v4, &v5);
	mw_std_buffer_ZPlusBuffer_rdrop(v5);
	return v4;
}
static VAL mw_std_output_ZPlusOutput_flushZBang (VAL x1) {
	VAL v2 = (VVAL(VTUP(x1)->cells[3]));
	void* v3 = VPTR(VTUP(v2)->cells[2]);
	VTUP(x1)->cells[3] = v2;
	int64_t v4 = VI64(VTUP(x1)->cells[1]);
	VAL v5 = (VVAL(VTUP(x1)->cells[2]));
	int64_t v6 = (0LL /* +Unsafe */);
	int64_t v7;
	int64_t v8;
	VAL v9;
	int64_t v10;
	mw_std_prelude_ZPlusUnsafe_writeZ_bytesZBang(v3, v4, v5, v6, &v7, &v8, &v9, &v10);
	VTUP(x1)->cells[2] = v9;
	int64_t v11 = 0LL;
	VTUP(x1)->cells[1] = MKI64(v11);
	return x1;
}
static void mw_std_output_ZPlusOutput_offset (VAL x1, VAL *x2, int64_t *x3) {
	int64_t v4 = VI64(VTUP(x1)->cells[1]);
	*x3 = v4;
	*x2 = x1;
}
static void mw_std_output_ZPlusOutput_capacityZ_total (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4 = (VVAL(VTUP(x1)->cells[3]));
	int64_t v5 = VI64(VTUP(v4)->cells[1]);
	VTUP(x1)->cells[3] = v4;
	*x3 = x1;
	*x2 = v5;
}
static void mw_std_output_ZPlusOutput_capacityZ_remaining (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_output_ZPlusOutput_capacityZ_total(x1, &v4, &v5);
	int64_t v6 = VI64(VTUP(v5)->cells[1]);
	int64_t v7 = i64_sub(v4, v6);
	int64_t v8 = 0LL;
	bool v9 = (v7 < v8);
	VAL x10;
	int64_t x11;
	if (v9) {
		int64_t v12 = 0LL;
		x11 = v12;
		x10 = v5;
	} else {
		x11 = v7;
		x10 = v5;
	}
	*x3 = x10;
	*x2 = x11;
}
static void mw_std_output_ZPlusOutput_fullZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_output_ZPlusOutput_capacityZ_remaining(x1, &v4, &v5);
	int64_t v6 = 0LL;
	bool v7 = (v4 == v6);
	*x3 = v5;
	*x2 = ((int64_t)v7);
}
static VAL mw_std_output_ZPlusOutput_put (VAL x1, VAL x2) {
	incref(x1);
	uint64_t v3 = str_size(VSTR(x1));
	int64_t v4 = 0LL;
	bool v5 = (((int64_t)v3) < v4);
	int64_t x6;
	if (v5) {
		x6 = v4;
		push_resource(x2);
		push_value(x1);
	} else {
		x6 = ((int64_t)v3);
		push_resource(x2);
		push_value(x1);
	}
	VAL r7 = pop_resource();
	int64_t v8;
	VAL v9;
	mw_std_output_ZPlusOutput_capacityZ_remaining(r7, &v8, &v9);
	bool v10 = (x6 > v8);
	VAL x11;
	if (v10) {
		VAL v12 = (mw_std_output_ZPlusOutput_flushZBang(v9));
		VAL v13 = pop_value();
		incref(v13);
		uint64_t v14 = str_size(VSTR(v13));
		int64_t v15 = 0LL;
		bool v16 = (((int64_t)v14) < v15);
		int64_t x17;
		if (v16) {
			x17 = v15;
			push_resource(v12);
			push_value(v13);
		} else {
			x17 = ((int64_t)v14);
			push_resource(v12);
			push_value(v13);
		}
		VAL r18 = pop_resource();
		int64_t v19;
		VAL v20;
		mw_std_output_ZPlusOutput_capacityZ_total(r18, &v19, &v20);
		bool v21 = (x17 >= v19);
		VAL x22;
		if (v21) {
			VAL v23 = pop_value();
			incref(v23);
			incref(v23);
			void* v24 = str_base(VSTR(v23));
			uint64_t v25 = str_size(VSTR(v23));
			int64_t v26 = 0LL;
			bool v27 = (((int64_t)v25) < v26);
			int64_t x28;
			if (v27) {
				x28 = v26;
				push_resource(v20);
				push_ptr(v24);
			} else {
				x28 = ((int64_t)v25);
				push_resource(v20);
				push_ptr(v24);
			}
			VAL r29 = pop_resource();
			VAL v30 = (VVAL(VTUP(r29)->cells[2]));
			int64_t v31 = (0LL /* +Unsafe */);
			void* v32 = pop_ptr();
			int64_t v33;
			int64_t v34;
			VAL v35;
			int64_t v36;
			mw_std_prelude_ZPlusUnsafe_writeZ_bytesZBang(v32, x28, v30, v31, &v33, &v34, &v35, &v36);
			VTUP(r29)->cells[2] = v35;
			decref(v23);
			x22 = r29;
		} else {
			VAL v37 = pop_value();
			VAL v38 = (mw_std_output_ZPlusOutput_put(v37, v20));
			x22 = v38;
		}
		x11 = x22;
	} else {
		VAL v39 = pop_value();
		incref(v39);
		VAL v40;
		int64_t v41;
		mw_std_output_ZPlusOutput_offset(v9, &v40, &v41);
		VAL v42 = (VVAL(VTUP(v40)->cells[3]));
		VAL v43 = (mw_std_buffer_ZPlusBuffer_ZBangStr(v39, v41, v42));
		VTUP(v40)->cells[3] = v43;
		uint64_t v44 = str_size(VSTR(v39));
		int64_t v45 = 0LL;
		bool v46 = (((int64_t)v44) < v45);
		int64_t x47;
		if (v46) {
			x47 = v45;
			push_resource(v40);
		} else {
			x47 = ((int64_t)v44);
			push_resource(v40);
		}
		VAL r48 = pop_resource();
		int64_t v49 = VI64(VTUP(r48)->cells[1]);
		int64_t v50 = i64_add(x47, v49);
		VTUP(r48)->cells[1] = MKI64(v50);
		x11 = r48;
	}
	return x11;
}
static VAL mw_std_output_ZPlusOutput_putZ_byte (int64_t x1, VAL x2) {
	int64_t v3;
	VAL v4;
	mw_std_output_ZPlusOutput_fullZAsk(x2, &v3, &v4);
	int64_t x5;
	VAL x6;
	if (((bool)v3)) {
		VAL v7 = (mw_std_output_ZPlusOutput_flushZBang(v4));
		x6 = v7;
		x5 = x1;
	} else {
		x6 = v4;
		x5 = x1;
	}
	VAL v8;
	int64_t v9;
	mw_std_output_ZPlusOutput_offset(x6, &v8, &v9);
	VAL v10 = (VVAL(VTUP(v8)->cells[3]));
	VAL v11 = (mw_std_buffer_ZPlusBuffer_ZBangByte(x5, v9, v10));
	VTUP(v8)->cells[3] = v11;
	int64_t v12 = VI64(VTUP(v8)->cells[1]);
	int64_t v13 = 1LL;
	int64_t v14 = i64_add(v12, v13);
	VTUP(v8)->cells[1] = MKI64(v14);
	return v8;
}
static VAL mw_std_output_ZPlusOutput_line (VAL x1) {
	int64_t v2 = 10LL /* BLF */;
	VAL v3 = (mw_std_output_ZPlusOutput_putZ_byte(v2, x1));
	return v3;
}
static int64_t mw_std_posix_posixZ_openZBang (VAL x1, int64_t x2, int64_t x3) {
	incref(x1);
	void* v4 = str_base(VSTR(x1));
	int64_t v5 = mext_std_posix_internalZ_posixZ_open(v4, x2, x3);
	decref(x1);
	return v5;
}
static void mw_std_prim_ZPlusWorld_openZ_fileZBang (VAL x1, int64_t x2, int64_t *x3, VAL *x4) {
	incref(x1);
	int64_t v5 = 0LL;
	int64_t v6 = 0LL;
	int64_t v7 = mw_std_posix_posixZ_openZBang(x1, v5, v6);
	int64_t v8 = 0LL;
	bool v9 = (v7 > v8);
	int64_t x10;
	VAL x11;
	if (v9) {
		decref(x1);
		int64_t v12 = 1LL /* True */;
		VAL v13 = (mtw_std_file_ZPlusFile_ZPlusFile(v7, v12));
		VAL v14 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileOk(v13));
		x11 = v14;
		x10 = x2;
	} else {
		STR* v15;
		STRLIT(v15, "", 0);
		STR* v16;
		STRLIT(v16, "Failed to open file: ", 21);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), MKSTR(v15)));
		VAL v18 = (mw_std_prim_Str_showZThen(x1, v17));
		VAL v19 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileErr(v18));
		x11 = v19;
		x10 = x2;
	}
	*x4 = x11;
	*x3 = x10;
}
static void mw_std_prim_ZPlusWorld_createZ_fileZBang (VAL x1, int64_t x2, int64_t *x3, VAL *x4) {
	incref(x1);
	VAL v5 = mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC();
	int64_t x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v5);
			int64_t v9 = 438LL;
			int64_t v10 = mw_std_posix_posixZ_openZBang(x1, VI64(v8), v9);
			int64_t v11 = 0LL;
			bool v12 = (v10 > v11);
			int64_t x13;
			VAL x14;
			if (v12) {
				decref(x1);
				int64_t v15 = 1LL /* True */;
				VAL v16 = (mtw_std_file_ZPlusFile_ZPlusFile(v10, v15));
				VAL v17 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileOk(v16));
				x14 = v17;
				x13 = x2;
			} else {
				STR* v18;
				STRLIT(v18, "", 0);
				STR* v19;
				STRLIT(v19, "Failed to create file: ", 23);
				VAL v20 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v19), MKSTR(v18)));
				VAL v21 = (mw_std_prim_Str_showZThen(x1, v20));
				VAL v22 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileErr(v21));
				x14 = v22;
				x13 = x2;
			}
			x7 = x14;
			x6 = x13;
		} break;
		case 0LL: { // None
			decref(x1);
			decref(x1);
			STR* v23;
			STRLIT(v23, "Don't know how to create file on unknown OS.", 44);
			VAL v24 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileErr(MKSTR(v23)));
			x7 = v24;
			x6 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_std_prim_ZPlusWorld_stderrZ_file (int64_t x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 2LL;
	int64_t v5 = 0LL /* False */;
	VAL v6 = (mtw_std_file_ZPlusFile_ZPlusFile(v4, v5));
	*x3 = v6;
	*x2 = x1;
}
static VAL mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC (void) {
	int64_t v1 = RUNNING_OS;
	int64_t v2 = mw_std_prim_Int_ZToOS(v1);
	VAL x3;
	switch (v2) {
		case 3LL: { // OS_MACOS
			int64_t v4 = 1537LL;
			VAL v5 = mtw_std_maybe_Maybe_1_Some(MKI64(v4));
			x3 = v5;
		} break;
		case 2LL: { // OS_LINUX
			int64_t v6 = 577LL;
			VAL v7 = mtw_std_maybe_Maybe_1_Some(MKI64(v6));
			x3 = v7;
		} break;
		case 1LL: { // OS_WINDOWS
			int64_t v8 = 769LL;
			VAL v9 = mtw_std_maybe_Maybe_1_Some(MKI64(v8));
			x3 = v9;
		} break;
		case 0LL: { // OS_UNKNOWN
			VAL v10 = MKI64(0LL /* None */);
			x3 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_std_file_ZPlusFile_closeZ_fileZBang (int64_t x1, VAL x2) {
	int64_t v3;
	int64_t v4;
	mtp_std_file_ZPlusFile_ZPlusFile(x2, &v3, &v4);
	int64_t x5;
	if (((bool)v4)) {
		int64_t v6 = mext_std_posix_externalZ_posixZ_close(v3);
		int64_t v7 = 0LL;
		bool v8 = (v6 >= v7);
		int64_t x9;
		int64_t x10;
		if (v8) {
			x10 = v6;
			x9 = x1;
		} else {
			STR* v11;
			STRLIT(v11, "Error while closing file.", 25);
			push_resource(MKI64(x1));
			push_i64(v6);
			do_panic(v11);
			int64_t v12 = pop_i64();
			x10 = v12;
			int64_t r13 = VI64(pop_resource());
			x9 = r13;
		}
		x5 = x9;
	} else {
		x5 = x1;
	}
	return x5;
}
static void mw_std_prelude_ZPlusUnsafe_writeZ_bytesZBang (void* x1, int64_t x2, VAL x3, int64_t x4, int64_t *x5, int64_t *x6, VAL *x7, int64_t *x8) {
	int64_t v9 = 1LL /* True */;
	int64_t v10 = 0LL;
	int64_t v11 = 0LL;
	bool v12 = (x2 > v11);
	bool v13 = (v12 && ((bool)v9));
	VAL v14 = (x3);
	int64_t v15 = (x4);
	void* v16 = x1;
	int64_t v17 = v10;
	int64_t v18 = x2;
	int64_t v19 = v9;
	bool v20 = v13;
	while (v20) {
		VAL v21 = (v14);
		int64_t v22 = (v15);
		void* v23 = v16;
		int64_t v24 = v17;
		int64_t v25 = v18;
		int64_t v26 = v19;
		int64_t v27 = VI64(VTUP(v21)->cells[1]);
		int64_t v28 = mext_std_posix_externalZ_posixZ_write(v27, v23, v25);
		int64_t v29 = 0LL;
		bool v30 = (v28 < v29);
		int64_t x31;
		VAL x32;
		int64_t x33;
		int64_t x34;
		void* x35;
		int64_t x36;
		if (v30) {
			int64_t v37 = 0LL /* False */;
			x36 = v25;
			x35 = v23;
			x34 = v22;
			x33 = v24;
			x32 = v21;
			x31 = v37;
		} else {
			int64_t v38 = i64_add(v28, v24);
			void* v39 = (void*)(v28 + (char*)v23);
			int64_t v40 = i64_sub(v25, v28);
			int64_t v41 = 0LL;
			bool v42 = (v40 < v41);
			int64_t x43;
			VAL x44;
			int64_t x45;
			int64_t x46;
			void* x47;
			int64_t x48;
			if (v42) {
				int64_t v49 = 0LL;
				x48 = v49;
				x47 = v39;
				x46 = v22;
				x45 = v38;
				x44 = v21;
				x43 = v26;
			} else {
				x48 = v40;
				x47 = v39;
				x46 = v22;
				x45 = v38;
				x44 = v21;
				x43 = v26;
			}
			x36 = x48;
			x35 = x47;
			x34 = x46;
			x33 = x45;
			x32 = x44;
			x31 = x43;
		}
		int64_t v50 = 0LL;
		bool v51 = (x36 > v50);
		bool v52 = (v51 && ((bool)x31));
		v20 = v52;
		v19 = x31;
		v18 = x36;
		v17 = x33;
		v16 = x35;
		v15 = x34;
		v14 = x32;
	}
	*x8 = v15;
	*x7 = v14;
	*x6 = v19;
	*x5 = v17;
}
static void mw_std_prelude_ZPlusUnsafe_readZ_bytesZBang (void* x1, int64_t x2, VAL x3, int64_t x4, int64_t *x5, int64_t *x6, VAL *x7, int64_t *x8) {
	int64_t v9 = VI64(VTUP(x3)->cells[1]);
	int64_t v10 = mext_std_posix_externalZ_posixZ_read(v9, x1, x2);
	int64_t v11 = 0LL;
	bool v12 = (v10 < v11);
	VAL x13;
	int64_t x14;
	int64_t x15;
	int64_t x16;
	if (v12) {
		int64_t v17 = 0LL;
		int64_t v18 = 0LL /* False */;
		x16 = v18;
		x15 = v17;
		x14 = x4;
		x13 = x3;
	} else {
		int64_t v19 = 1LL /* True */;
		x16 = v19;
		x15 = v10;
		x14 = x4;
		x13 = x3;
	}
	*x8 = x14;
	*x7 = x13;
	*x6 = x16;
	*x5 = x15;
}
static void mw_std_file_ZPlusFile_readZ_fileZBang (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = (mw_std_input_ZPlusInput_startZBang(x1));
	VAL v5;
	VAL v6;
	mw_std_input_ZPlusInput_readZ_fileZBang(v4, &v5, &v6);
	VAL v7 = (mw_std_input_ZPlusInput_endZBang(v6));
	*x3 = v7;
	*x2 = v5;
}
static int64_t mw_std_prim_ZPlusWorld_traceZ_ (VAL x1, int64_t x2) {
	int64_t v3;
	VAL v4;
	mw_std_prim_ZPlusWorld_stderrZ_file(x2, &v3, &v4);
	incref(x1);
	incref(x1);
	void* v5 = str_base(VSTR(x1));
	uint64_t v6 = str_size(VSTR(x1));
	int64_t v7 = 0LL;
	bool v8 = (((int64_t)v6) < v7);
	int64_t x9;
	if (v8) {
		x9 = v7;
		push_resource(MKI64(v3));
		push_resource(v4);
		push_ptr(v5);
	} else {
		x9 = ((int64_t)v6);
		push_resource(MKI64(v3));
		push_resource(v4);
		push_ptr(v5);
	}
	int64_t v10 = (0LL /* +Unsafe */);
	VAL r11 = pop_resource();
	void* v12 = pop_ptr();
	int64_t v13;
	int64_t v14;
	VAL v15;
	int64_t v16;
	mw_std_prelude_ZPlusUnsafe_writeZ_bytesZBang(v12, x9, r11, v10, &v13, &v14, &v15, &v16);
	decref(x1);
	int64_t r17 = VI64(pop_resource());
	int64_t v18 = (mw_std_file_ZPlusFile_closeZ_fileZBang(r17, v15));
	return v18;
}
static void mw_std_prim_ZPlusWorld_isZ_directoryZAsk (int64_t x1, VAL x2, int64_t *x3, int64_t *x4) {
	int64_t v5 = 256LL;
	VAL v6 = (mw_std_buffer_ZPlusBuffer_new(v5));
	incref(x2);
	incref(x2);
	void* v7 = str_base(VSTR(x2));
	uint64_t v8 = str_size(VSTR(x2));
	int64_t v9 = 0LL;
	bool v10 = (((int64_t)v8) < v9);
	int64_t x11;
	if (v10) {
		x11 = v9;
		push_resource(MKI64(x1));
		push_resource(v6);
		push_ptr(v7);
	} else {
		x11 = ((int64_t)v8);
		push_resource(MKI64(x1));
		push_resource(v6);
		push_ptr(v7);
	}
	VAL v12 = pop_value();
	incref(v12);
	int64_t v13 = (0LL /* +Unsafe */);
	void* v14 = (void*)(x11 + (char*)VPTR(v12));
	uint8_t v15 = *(uint8_t*)v14;
	int64_t v16 = 0LL;
	bool v17 = (((int64_t)v15) == v16);
	int64_t x18;
	VAL x19;
	void* x20;
	if (v17) {
		x20 = VPTR(v12);
		VAL r21 = pop_resource();
		x19 = r21;
		int64_t r22 = VI64(pop_resource());
		x18 = r22;
	} else {
		STR* v23;
		STRLIT(v23, "tried to use Str as CStr, but Str is not zero terminated", 56);
		push_value(v12);
		do_panic(v23);
		void* v24 = pop_ptr();
		x20 = v24;
		VAL r25 = pop_resource();
		x19 = r25;
		int64_t r26 = VI64(pop_resource());
		x18 = r26;
	}
	void* v27 = VPTR(VTUP(x19)->cells[2]);
	int64_t v28 = (0LL /* +Unsafe */);
	int64_t v29;
	int64_t v30;
	mext_std_world_posixZ_stat(v28, x20, v27, &v29, &v30);
	int64_t v31 = 0LL;
	bool v32 = (v30 == v31);
	int64_t x33;
	VAL x34;
	int64_t x35;
	if (v32) {
		void* v36 = VPTR(VTUP(x19)->cells[2]);
		int64_t v37 = (0LL /* +Unsafe */);
		int64_t v38;
		int64_t v39;
		mw_std_world_stz_modeZAt(v36, v37, &v38, &v39);
		int64_t v40 = mw_std_world_Sz_ISDIR(v38);
		x35 = v40;
		x34 = x19;
		x33 = x18;
	} else {
		int64_t v41 = 0LL /* False */;
		x35 = v41;
		x34 = x19;
		x33 = x18;
	}
	decref(x2);
	mw_std_buffer_ZPlusBuffer_rdrop(x34);
	*x4 = x35;
	*x3 = x33;
}
static int64_t mw_std_world_Sz_IFMT (void) {
	int64_t v1 = 61440LL;
	int64_t v2 = mw_std_prim_Int_ZToU16(v1);
	return v2;
}
static int64_t mw_std_world_Sz_IFDIR (void) {
	int64_t v1 = 16384LL;
	int64_t v2 = mw_std_prim_Int_ZToU16(v1);
	return v2;
}
static int64_t mw_std_world_Sz_ISDIR (int64_t x1) {
	int64_t v2 = mw_std_world_Sz_IFMT();
	uint64_t v3 = (((uint64_t)x1) & ((uint64_t)v2));
	int64_t v4 = mw_std_world_Sz_IFDIR();
	bool v5 = (((int64_t)v3) == v4);
	return ((int64_t)v5);
}
static void mw_std_world_stz_modeZAt (void* x1, int64_t x2, int64_t *x3, int64_t *x4) {
	int64_t v5 = RUNNING_OS;
	int64_t v6 = mw_std_prim_Int_ZToOS(v5);
	void* x7;
	int64_t x8;
	int64_t x9;
	switch (v6) {
		case 2LL: { // OS_LINUX
			int64_t v10 = 24LL;
			x9 = v10;
			x8 = x2;
			x7 = x1;
		} break;
		case 1LL: { // OS_WINDOWS
			int64_t v11 = 6LL;
			x9 = v11;
			x8 = x2;
			x7 = x1;
		} break;
		case 3LL: { // OS_MACOS
			int64_t v12 = RUNNING_ARCH;
			int64_t v13 = mw_std_prim_Int_ZToArch(v12);
			int64_t v14 = 3LL /* ARCH_ARM64 */;
			bool v15 = (v13 == v14);
			void* x16;
			int64_t x17;
			int64_t x18;
			if (v15) {
				int64_t v19 = 4LL;
				x18 = v19;
				x17 = x2;
				x16 = x1;
			} else {
				int64_t v20 = 8LL;
				x18 = v20;
				x17 = x2;
				x16 = x1;
			}
			x9 = x18;
			x8 = x17;
			x7 = x16;
		} break;
		default: {
			int64_t v21 = 8LL;
			x9 = v21;
			x8 = x2;
			x7 = x1;
		} break;
	}
	void* v22 = (void*)(x9 + (char*)x7);
	uint16_t v23 = *(uint16_t*)v22;
	*x4 = x8;
	*x3 = ((int64_t)v23);
}
static VAL mw_std_terminal_SGRColor_showZThen (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x1)) {
		case 0LL: { // Numbered
			int64_t v4 = mtp_std_terminal_SGRColor_Numbered(x1);
			STR* v5;
			STRLIT(v5, ";5;", 3);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), x2));
			STR* v7 = i64_show(v4);
			VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
			x3 = v8;
		} break;
		case 1LL: { // RGB
			int64_t v9;
			int64_t v10;
			int64_t v11;
			mtp_std_terminal_SGRColor_RGB(x1, &v9, &v10, &v11);
			STR* v12;
			STRLIT(v12, ";2;", 3);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), x2));
			STR* v14 = i64_show(v11);
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), v13));
			STR* v16;
			STRLIT(v16, ";", 1);
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), v15));
			STR* v18 = i64_show(v10);
			VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), v17));
			STR* v20;
			STRLIT(v20, ";", 1);
			VAL v21 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v20), v19));
			STR* v22 = i64_show(v9);
			VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v22), v21));
			x3 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_std_terminal_Sgr_emitZThen (VAL x1, VAL x2) {
	VAL v3 = (mw_std_terminal_csiZThen(x2));
	incref(x1);
	int64_t v4 = get_data_tag(x1);
	decref(x1);
	STR* v5 = i64_show(v4);
	VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), v3));
	VAL x7;
	switch (get_data_tag(x1)) {
		case 38LL: { // FGColor
			VAL v8 = mtp_std_terminal_Sgr_FGColor(x1);
			VAL v9 = (mw_std_terminal_SGRColor_showZThen(v8, v6));
			x7 = v9;
		} break;
		case 48LL: { // BGColor
			VAL v10 = mtp_std_terminal_Sgr_BGColor(x1);
			VAL v11 = (mw_std_terminal_SGRColor_showZThen(v10, v6));
			x7 = v11;
		} break;
		default: {
			decref(x1);
			x7 = v6;
		} break;
	}
	STR* v12;
	STRLIT(v12, "m", 1);
	VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), x7));
	return v13;
}
static VAL mw_std_terminal_csiZThen (VAL x1) {
	int64_t v2 = 27LL /* BESC */;
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(v2, x1));
	int64_t v4 = 91LL /* BLSQUARE */;
	VAL v5 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(v4, v3));
	return v5;
}
static VAL mw_argZ_parser_state_State_1_init (VAL x1) {
	VAL v2 = mw_argZ_parser_parse_argvZ_toZ_str();
	int64_t v3 = 0LL;
	int64_t v4 = (0LL /* +Unsafe */);
	VAL v5;
	int64_t v6;
	mw_argZ_parser_parse_readZ_fromZ_argv(v4, v3, &v5, &v6);
	VAL v7 = mtw_argZ_parser_state_ArgvInfo_ArgvInfo(v2, v5);
	int64_t v8 = 0LL /* False */;
	VAL v9 = MKI64(0LL /* None */);
	VAL v10 = MKI64(0LL /* None */);
	VAL v11 = mtw_argZ_parser_state_CurrentArg_CurrentArg(v8, v9, v10);
	int64_t v12 = 0LL;
	int64_t v13 = 0LL;
	VAL v14 = MKI64(0LL /* None */);
	VAL v15 = mtw_argZ_parser_state_State_1_State(x1, v7, v11, v12, v13, v14);
	return v15;
}
static VAL mw_argZ_parser_state_State_1_argv (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[2]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(v2)->cells[1]);
	incref(v3);
	decref(v2);
	return v3;
}
static VAL mw_argZ_parser_state_State_1_programZ_name (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[2]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(v2)->cells[2]);
	incref(v3);
	decref(v2);
	return v3;
}
static int64_t mw_argZ_parser_state_State_1_parsingZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[3]);
	incref(v2);
	decref(x1);
	int64_t v3 = VI64(VTUP(v2)->cells[1]);
	decref(v2);
	return v3;
}
static VAL mw_argZ_parser_state_State_1_parsingZAskZBang (int64_t x1, VAL x2) {
	incref(x2);
	VAL v3 = VVAL(VTUP(x2)->cells[3]);
	incref(v3);
	decref(x2);
	VAL v4 = tup_replace(v3, 1, MKI64(x1));
	VAL v5 = tup_replace(x2, 3, v4);
	return v5;
}
static VAL mw_argZ_parser_state_State_1_optionZ_option (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[3]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(v2)->cells[3]);
	incref(v3);
	decref(v2);
	return v3;
}
static VAL mw_argZ_parser_state_State_1_optionZ_optionZBang (VAL x1, VAL x2) {
	incref(x2);
	VAL v3 = VVAL(VTUP(x2)->cells[3]);
	incref(v3);
	decref(x2);
	VAL v4 = tup_replace(v3, 3, x1);
	VAL v5 = tup_replace(x2, 3, v4);
	return v5;
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser(x1, &v2, &v3);
	decref(v2);
	decref(v3);
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_parser (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[1]);
	incref(v4);
	VAL v5 = VVAL(VTUP(v4)->cells[2]);
	incref(v5);
	decref(v4);
	*x3 = v5;
	*x2 = x1;
}
static int64_t mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Short
			int64_t v3 = mtp_argZ_parser_types_ArgpOptionType_Short(x1);
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		default: {
			decref(x1);
			int64_t v5 = 0LL /* False */;
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_argZ_parser_types_ArgumentParsingError_emitZThen (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x1)) {
		case 1LL: { // MissingArg
			VAL v4 = mtp_argZ_parser_types_ArgumentParsingError_MissingArg(x1);
			VAL v5 = MKI64(31LL /* FGRed */);
			VAL v6 = (mw_std_terminal_Sgr_emitZThen(v5, x2));
			STR* v7;
			STRLIT(v7, "Missing argument: ", 18);
			VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
			VAL v9 = MKI64(0LL /* Reset */);
			VAL v10 = (mw_std_terminal_Sgr_emitZThen(v9, v8));
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v4, v10));
			x3 = v11;
		} break;
		case 0LL: { // MissingArgValue
			STR* v12;
			STRLIT(v12, "Missing associated value for flag option", 40);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), x2));
			x3 = v13;
		} break;
		case 2LL: { // TooManyArgs
			STR* v14;
			STRLIT(v14, "Too many positional arguments passed", 36);
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), x2));
			x3 = v15;
		} break;
		case 3LL: { // TooFewArgs
			STR* v16;
			STRLIT(v16, "Too few positional arguments passed", 35);
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), x2));
			x3 = v17;
		} break;
		case 4LL: { // UnknownArg
			STR* v18;
			STRLIT(v18, "Got an unknown option", 21);
			VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), x2));
			x3 = v19;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_usage (VAL x1, VAL *x2, VAL *x3) {
	STR* v4;
	STRLIT(v4, "", 0);
	VAL v5 = MKI64(1LL /* Bold */);
	VAL v6 = (mw_std_terminal_Sgr_emitZThen(v5, MKSTR(v4)));
	STR* v7;
	STRLIT(v7, "Usage: ", 7);
	VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
	VAL v9 = MKI64(0LL /* Reset */);
	VAL v10 = (mw_std_terminal_Sgr_emitZThen(v9, v8));
	STR* v11;
	STRLIT(v11, "  ", 2);
	VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
	VAL v13 = VVAL(VTUP(x1)->cells[2]);
	incref(v13);
	VAL v14 = mw_argZ_parser_state_State_1_programZ_name(v13);
	VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(v14, v12));
	STR* v16;
	STRLIT(v16, " [options] ", 11);
	VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), v15));
	VAL v18 = VVAL(VTUP(x1)->cells[1]);
	incref(v18);
	VAL v19 = VVAL(VTUP(v18)->cells[3]);
	incref(v19);
	decref(v18);
	VAL x20;
	VAL x21;
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v22 = mtp_std_maybe_Maybe_1_Some(v19);
			VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(v22, v17));
			x21 = v23;
			x20 = x1;
		} break;
		case 0LL: { // None
			x21 = v17;
			x20 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	STR* v24;
	STRLIT(v24, "\n\n", 2);
	VAL v25 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), x21));
	VAL v26 = VVAL(VTUP(x20)->cells[1]);
	incref(v26);
	VAL v27 = VVAL(VTUP(v26)->cells[1]);
	incref(v27);
	decref(v26);
	VAL v28;
	VAL v29;
	mw_std_list_List_1_uncons(v27, &v28, &v29);
	VAL x30;
	VAL x31;
	VAL x32;
	int64_t x33;
	switch (get_data_tag(v28)) {
		case 1LL: { // Some
			VAL v34 = mtp_std_maybe_Maybe_1_Some(v28);
			VAL v35;
			VAL v36;
			mw_argZ_parser_types_ArgpOption_usageZThen(x20, v25, v34, &v35, &v36);
			int64_t v37 = 1LL /* True */;
			x33 = v37;
			x32 = v29;
			x31 = v36;
			x30 = v35;
		} break;
		case 0LL: { // None
			int64_t v38 = 0LL /* False */;
			x33 = v38;
			x32 = v29;
			x31 = v25;
			x30 = x20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v39 = (x30);
	VAL v40 = (x31);
	VAL v41 = x32;
	int64_t v42 = x33;
	while (((bool)v42)) {
		VAL v43 = (v39);
		VAL v44 = (v40);
		VAL v45 = v41;
		VAL v46;
		VAL v47;
		mw_std_list_List_1_uncons(v45, &v46, &v47);
		VAL x48;
		VAL x49;
		VAL x50;
		int64_t x51;
		switch (get_data_tag(v46)) {
			case 1LL: { // Some
				VAL v52 = mtp_std_maybe_Maybe_1_Some(v46);
				VAL v53;
				VAL v54;
				mw_argZ_parser_types_ArgpOption_usageZThen(v43, v44, v52, &v53, &v54);
				int64_t v55 = 1LL /* True */;
				x51 = v55;
				x50 = v47;
				x49 = v54;
				x48 = v53;
			} break;
			case 0LL: { // None
				int64_t v56 = 0LL /* False */;
				x51 = v56;
				x50 = v47;
				x49 = v44;
				x48 = v43;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v42 = x51;
		v41 = x50;
		v40 = x49;
		v39 = x48;
	}
	decref(v41);
	STR* v57;
	STRLIT(v57, "\n", 1);
	VAL v58 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v57), v40));
	*x3 = v58;
	*x2 = v39;
}
static void mw_argZ_parser_types_ArgpOption_usageZThen (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	STR* v6;
	STRLIT(v6, "  ", 2);
	VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), x2));
	int64_t v8 = 0LL;
	incref(x3);
	VAL v9 = VVAL(VTUP(x3)->cells[2]);
	incref(v9);
	decref(x3);
	VAL x10;
	VAL x11;
	int64_t x12;
	VAL x13;
	switch (get_data_tag(v9)) {
		case 0LL: { // Short
			int64_t v14 = mtp_argZ_parser_types_ArgpOptionType_Short(v9);
			int64_t v15 = mw_std_byte_Byte_isZ_printable(v14);
			VAL x16;
			VAL x17;
			int64_t x18;
			VAL x19;
			int64_t x20;
			if (((bool)v15)) {
				int64_t v21 = 2LL;
				int64_t v22 = i64_add(v8, v21);
				STR* v23;
				STRLIT(v23, "-", 1);
				VAL v24 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v23), v7));
				VAL v25 = (mw_std_byte_Byte_emitZ_asciiZThen(v24, v14));
				x20 = v14;
				x19 = x3;
				x18 = v22;
				x17 = v25;
				x16 = x1;
			} else {
				x20 = v14;
				x19 = x3;
				x18 = v8;
				x17 = v7;
				x16 = x1;
			}
			x13 = x19;
			x12 = x18;
			x11 = x17;
			x10 = x16;
		} break;
		default: {
			decref(v9);
			x13 = x3;
			x12 = v8;
			x11 = v7;
			x10 = x1;
		} break;
	}
	incref(x13);
	VAL v26 = VVAL(VTUP(x13)->cells[2]);
	incref(v26);
	decref(x13);
	int64_t v27 = mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk(v26);
	VAL x28;
	VAL x29;
	int64_t x30;
	VAL x31;
	int64_t x32;
	if (((bool)v27)) {
		incref(x13);
		VAL v33 = VVAL(VTUP(x13)->cells[1]);
		incref(v33);
		decref(x13);
		int64_t v34 = mw_std_maybe_Maybe_1_someZAsk(v33);
		x32 = v34;
		x31 = x13;
		x30 = x12;
		x29 = x11;
		x28 = x10;
	} else {
		int64_t v35 = 0LL /* False */;
		x32 = v35;
		x31 = x13;
		x30 = x12;
		x29 = x11;
		x28 = x10;
	}
	VAL x36;
	VAL x37;
	int64_t x38;
	VAL x39;
	if (((bool)x32)) {
		STR* v40;
		STRLIT(v40, ", ", 2);
		VAL v41 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v40), x29));
		int64_t v42 = 2LL;
		int64_t v43 = i64_add(x30, v42);
		x39 = x31;
		x38 = v43;
		x37 = v41;
		x36 = x28;
	} else {
		x39 = x31;
		x38 = x30;
		x37 = x29;
		x36 = x28;
	}
	incref(x39);
	VAL v44 = VVAL(VTUP(x39)->cells[1]);
	incref(v44);
	decref(x39);
	VAL x45;
	VAL x46;
	int64_t x47;
	VAL x48;
	switch (get_data_tag(v44)) {
		case 1LL: { // Some
			VAL v49 = mtp_std_maybe_Maybe_1_Some(v44);
			incref(v49);
			uint64_t v50 = str_size(VSTR(v49));
			int64_t v51 = 0LL;
			bool v52 = (((int64_t)v50) < v51);
			int64_t x53;
			if (v52) {
				x53 = v51;
				push_resource(x36);
				push_resource(x37);
				lpush(&lbl_colZ_offset, MKI64(x38));
				push_value(x39);
				push_value(v49);
			} else {
				x53 = ((int64_t)v50);
				push_resource(x36);
				push_resource(x37);
				lpush(&lbl_colZ_offset, MKI64(x38));
				push_value(x39);
				push_value(v49);
			}
			int64_t v54 = VI64(lpop(&lbl_colZ_offset));
			int64_t v55 = 2LL;
			int64_t v56 = i64_add(v54, v55);
			int64_t v57 = i64_add(x53, v56);
			STR* v58;
			STRLIT(v58, "--", 2);
			VAL r59 = pop_resource();
			VAL v60 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v58), r59));
			VAL v61 = pop_value();
			VAL v62 = (mw_std_str_ZPlusStr_pushZ_strZBang(v61, v60));
			VAL v63 = pop_value();
			incref(v63);
			VAL v64 = VVAL(VTUP(v63)->cells[3]);
			incref(v64);
			decref(v63);
			VAL x65;
			int64_t x66;
			VAL x67;
			VAL x68;
			switch (get_data_tag(v64)) {
				case 1LL: { // Some
					VAL v69 = mtp_std_maybe_Maybe_1_Some(v64);
					incref(v69);
					uint64_t v70 = str_size(VSTR(v69));
					int64_t v71 = 0LL;
					bool v72 = (((int64_t)v70) < v71);
					int64_t x73;
					if (v72) {
						x73 = v71;
						lpush(&lbl_colZ_offset, MKI64(v57));
						push_resource(v62);
						push_value(v63);
						push_value(v69);
					} else {
						x73 = ((int64_t)v70);
						lpush(&lbl_colZ_offset, MKI64(v57));
						push_resource(v62);
						push_value(v63);
						push_value(v69);
					}
					int64_t v74 = VI64(lpop(&lbl_colZ_offset));
					int64_t v75 = 1LL;
					int64_t v76 = i64_add(v74, v75);
					int64_t v77 = i64_add(x73, v76);
					STR* v78;
					STRLIT(v78, " ", 1);
					VAL r79 = pop_resource();
					VAL v80 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v78), r79));
					VAL v81 = pop_value();
					VAL v82 = (mw_std_str_ZPlusStr_pushZ_strZBang(v81, v80));
					VAL v83 = pop_value();
					x68 = v83;
					x67 = v82;
					x66 = v77;
					VAL r84 = pop_resource();
					x65 = r84;
				} break;
				case 0LL: { // None
					x68 = v63;
					x67 = v62;
					x66 = v57;
					VAL r85 = pop_resource();
					x65 = r85;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x48 = x68;
			x47 = x66;
			x46 = x67;
			x45 = x65;
		} break;
		case 0LL: { // None
			x48 = x39;
			x47 = x38;
			x46 = x37;
			x45 = x36;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	incref(x48);
	VAL v86 = VVAL(VTUP(x48)->cells[4]);
	incref(v86);
	decref(x48);
	VAL x87;
	VAL x88;
	int64_t x89;
	VAL x90;
	switch (get_data_tag(v86)) {
		case 1LL: { // Some
			VAL v91 = mtp_std_maybe_Maybe_1_Some(v86);
			VAL v92 = VVAL(VTUP(x45)->cells[2]);
			incref(v92);
			int64_t v93 = VI64(VTUP(v92)->cells[5]);
			decref(v92);
			bool v94 = (x47 < v93);
			VAL x95;
			VAL x96;
			int64_t x97;
			VAL x98;
			VAL x99;
			if (v94) {
				int64_t v100 = i64_sub(v93, x47);
				int64_t v101 = 0LL;
				VAL v102 = mw_std_prim_Int_range(v101, v100);
				VAL v103;
				VAL v104;
				mw_std_list_List_1_uncons(v102, &v103, &v104);
				VAL x105;
				VAL x106;
				int64_t x107;
				VAL x108;
				VAL x109;
				VAL x110;
				int64_t x111;
				switch (get_data_tag(v103)) {
					case 1LL: { // Some
						VAL v112 = mtp_std_maybe_Maybe_1_Some(v103);
						decref(v112);
						STR* v113;
						STRLIT(v113, " ", 1);
						VAL v114 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v113), x46));
						int64_t v115 = 1LL /* True */;
						x111 = v115;
						x110 = v104;
						x109 = v114;
						x108 = x45;
						x107 = x47;
						x106 = v91;
						x105 = x48;
					} break;
					case 0LL: { // None
						int64_t v116 = 0LL /* False */;
						x111 = v116;
						x110 = v104;
						x109 = x46;
						x108 = x45;
						x107 = x47;
						x106 = v91;
						x105 = x48;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v117 = x105;
				VAL v118 = x106;
				int64_t v119 = x107;
				VAL v120 = (x108);
				VAL v121 = (x109);
				VAL v122 = x110;
				int64_t v123 = x111;
				while (((bool)v123)) {
					VAL v124 = v117;
					VAL v125 = v118;
					int64_t v126 = v119;
					VAL v127 = (v120);
					VAL v128 = (v121);
					VAL v129 = v122;
					VAL v130;
					VAL v131;
					mw_std_list_List_1_uncons(v129, &v130, &v131);
					VAL x132;
					VAL x133;
					int64_t x134;
					VAL x135;
					VAL x136;
					VAL x137;
					int64_t x138;
					switch (get_data_tag(v130)) {
						case 1LL: { // Some
							VAL v139 = mtp_std_maybe_Maybe_1_Some(v130);
							decref(v139);
							STR* v140;
							STRLIT(v140, " ", 1);
							VAL v141 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v140), v128));
							int64_t v142 = 1LL /* True */;
							x138 = v142;
							x137 = v131;
							x136 = v141;
							x135 = v127;
							x134 = v126;
							x133 = v125;
							x132 = v124;
						} break;
						case 0LL: { // None
							int64_t v143 = 0LL /* False */;
							x138 = v143;
							x137 = v131;
							x136 = v128;
							x135 = v127;
							x134 = v126;
							x133 = v125;
							x132 = v124;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v123 = x138;
					v122 = x137;
					v121 = x136;
					v120 = x135;
					v119 = x134;
					v118 = x133;
					v117 = x132;
				}
				decref(v122);
				x99 = v121;
				x98 = v120;
				x97 = v119;
				x96 = v118;
				x95 = v117;
			} else {
				x99 = x46;
				x98 = x45;
				x97 = x47;
				x96 = v91;
				x95 = x48;
			}
			STR* v144;
			STRLIT(v144, "    ", 4);
			VAL v145 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v144), x99));
			VAL v146 = (mw_std_str_ZPlusStr_pushZ_strZBang(x96, v145));
			x90 = x95;
			x89 = x97;
			x88 = v146;
			x87 = x98;
		} break;
		case 0LL: { // None
			x90 = x48;
			x89 = x47;
			x88 = x46;
			x87 = x45;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	STR* v147;
	STRLIT(v147, "\n", 1);
	VAL v148 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v147), x88));
	decref(x90);
	*x5 = v148;
	*x4 = x87;
}
static void mw_argZ_parser_parse_checkZ_shortZ_flag (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, int64_t *x6) {
	incref(x2);
	VAL v7 = VVAL(VTUP(x2)->cells[2]);
	incref(v7);
	decref(x2);
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v7)) {
		case 0LL: { // Short
			int64_t v11 = mtp_argZ_parser_types_ArgpOptionType_Short(v7);
			int64_t v12 = 0LL;
			int64_t v13 = mw_std_prim_Str_byteZAt(v12, x3);
			bool v14 = (v11 == v13);
			x10 = ((int64_t)v14);
			x9 = x2;
			x8 = x1;
		} break;
		default: {
			decref(v7);
			decref(x3);
			int64_t v15 = 0LL /* False */;
			x10 = v15;
			x9 = x2;
			x8 = x1;
		} break;
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static void mw_argZ_parser_parse_checkZ_longZ_flag (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, int64_t *x6) {
	incref(x2);
	VAL v7 = VVAL(VTUP(x2)->cells[1]);
	incref(v7);
	decref(x2);
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			bool v12 = (str_cmp(VSTR(x3), VSTR(v11)) == 0);
			x10 = ((int64_t)v12);
			x9 = x2;
			x8 = x1;
		} break;
		case 0LL: { // None
			decref(x3);
			int64_t v13 = 0LL /* False */;
			x10 = v13;
			x9 = x2;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static void mw_argZ_parser_parse_parseZ_flags (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	uint64_t v5 = str_size(VSTR(x2));
	int64_t v6 = 0LL;
	bool v7 = (((int64_t)v5) < v6);
	int64_t x8;
	if (v7) {
		x8 = v6;
		push_resource(x1);
		push_value(x2);
	} else {
		x8 = ((int64_t)v5);
		push_resource(x1);
		push_value(x2);
	}
	int64_t v9 = 2LL;
	bool v10 = (x8 >= v9);
	VAL x11;
	VAL x12;
	int64_t x13;
	if (v10) {
		int64_t v14 = 1LL;
		VAL v15 = pop_value();
		incref(v15);
		int64_t v16 = mw_std_prim_Str_byteZAt(v14, v15);
		int64_t v17 = 45LL /* B'-' */;
		bool v18 = (v16 == v17);
		x13 = ((int64_t)v18);
		x12 = v15;
		VAL r19 = pop_resource();
		x11 = r19;
	} else {
		int64_t v20 = 0LL /* False */;
		x13 = v20;
		VAL v21 = pop_value();
		x12 = v21;
		VAL r22 = pop_resource();
		x11 = r22;
	}
	VAL x23;
	VAL x24;
	VAL x25;
	if (((bool)x13)) {
		int64_t v26 = 2LL;
		incref(x12);
		int64_t v27 = (0LL /* +Unsafe */);
		VAL v28;
		int64_t v29;
		mw_std_prim_Str_dropZ_bytes(v26, x12, v27, &v28, &v29);
		VAL v30 = VVAL(VTUP(x11)->cells[1]);
		incref(v30);
		VAL v31 = VVAL(VTUP(v30)->cells[1]);
		incref(v31);
		decref(v30);
		VAL v32 = MKI64(0LL /* None */);
		VAL v33;
		VAL v34;
		mw_std_list_List_1_uncons(v31, &v33, &v34);
		VAL x35;
		VAL x36;
		VAL x37;
		VAL x38;
		int64_t x39;
		switch (get_data_tag(v33)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(v33);
				incref(v40);
				incref(v28);
				VAL v41;
				VAL v42;
				int64_t v43;
				mw_argZ_parser_parse_checkZ_longZ_flag(x11, v40, v28, &v41, &v42, &v43);
				decref(v42);
				VAL x44;
				VAL x45;
				VAL x46;
				if (((bool)v43)) {
					VAL v47 = mtw_std_maybe_Maybe_1_Some(v40);
					x46 = v47;
					x45 = v41;
					x44 = v28;
					push_value(x12);
				} else {
					decref(v40);
					VAL v48 = MKI64(0LL /* None */);
					x46 = v48;
					x45 = v41;
					x44 = v28;
					push_value(x12);
				}
				VAL x49;
				VAL x50;
				VAL x51;
				VAL x52;
				switch (get_data_tag(x46)) {
					case 0LL: { // None
						x52 = v34;
						x51 = v32;
						x50 = x45;
						x49 = x44;
					} break;
					default: {
						decref(v34);
						decref(v32);
						VAL v53 = MKI64(0LL /* Nil */);
						x52 = v53;
						x51 = x46;
						x50 = x45;
						x49 = x44;
					} break;
				}
				int64_t v54 = 1LL /* True */;
				x39 = v54;
				x38 = x52;
				x37 = x51;
				x36 = x50;
				x35 = x49;
			} break;
			case 0LL: { // None
				int64_t v55 = 0LL /* False */;
				x39 = v55;
				x38 = v34;
				x37 = v32;
				x36 = x11;
				x35 = v28;
				push_value(x12);
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v56 = x35;
		VAL v57 = (x36);
		VAL v58 = x37;
		VAL v59 = x38;
		int64_t v60 = x39;
		while (((bool)v60)) {
			VAL v61 = v56;
			VAL v62 = (v57);
			VAL v63 = v58;
			VAL v64 = v59;
			VAL v65;
			VAL v66;
			mw_std_list_List_1_uncons(v64, &v65, &v66);
			VAL x67;
			VAL x68;
			VAL x69;
			VAL x70;
			int64_t x71;
			switch (get_data_tag(v65)) {
				case 1LL: { // Some
					VAL v72 = mtp_std_maybe_Maybe_1_Some(v65);
					incref(v72);
					incref(v61);
					VAL v73;
					VAL v74;
					int64_t v75;
					mw_argZ_parser_parse_checkZ_longZ_flag(v62, v72, v61, &v73, &v74, &v75);
					decref(v74);
					VAL x76;
					VAL x77;
					VAL x78;
					if (((bool)v75)) {
						VAL v79 = mtw_std_maybe_Maybe_1_Some(v72);
						x78 = v79;
						x77 = v73;
						x76 = v61;
					} else {
						decref(v72);
						VAL v80 = MKI64(0LL /* None */);
						x78 = v80;
						x77 = v73;
						x76 = v61;
					}
					VAL x81;
					VAL x82;
					VAL x83;
					VAL x84;
					switch (get_data_tag(x78)) {
						case 0LL: { // None
							x84 = v66;
							x83 = v63;
							x82 = x77;
							x81 = x76;
						} break;
						default: {
							decref(v66);
							decref(v63);
							VAL v85 = MKI64(0LL /* Nil */);
							x84 = v85;
							x83 = x78;
							x82 = x77;
							x81 = x76;
						} break;
					}
					int64_t v86 = 1LL /* True */;
					x71 = v86;
					x70 = x84;
					x69 = x83;
					x68 = x82;
					x67 = x81;
				} break;
				case 0LL: { // None
					int64_t v87 = 0LL /* False */;
					x71 = v87;
					x70 = v66;
					x69 = v63;
					x68 = v62;
					x67 = v61;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v60 = x71;
			v59 = x70;
			v58 = x69;
			v57 = x68;
			v56 = x67;
		}
		decref(v59);
		decref(v56);
		VAL x88;
		VAL x89;
		switch (get_data_tag(v58)) {
			case 1LL: { // Some
				VAL v90 = mtp_std_maybe_Maybe_1_Some(v58);
				incref(v90);
				VAL v91 = VVAL(VTUP(v90)->cells[3]);
				incref(v91);
				decref(v90);
				VAL x92;
				switch (get_data_tag(v91)) {
					case 1LL: { // Some
						VAL v93 = mtp_std_maybe_Maybe_1_Some(v91);
						int64_t v94 = 1LL /* True */;
						VAL v95 = VVAL(VTUP(v57)->cells[2]);
						incref(v95);
						VAL v96 = mw_argZ_parser_state_State_1_parsingZAskZBang(v94, v95);
						VAL v97 = VTUP(v57)->cells[2];
						decref(v97);
						VTUP(v57)->cells[2] = v96;
						decref(v93);
						VAL v98 = mtw_std_maybe_Maybe_1_Some(v90);
						VAL v99 = VVAL(VTUP(v57)->cells[2]);
						incref(v99);
						VAL v100 = mw_argZ_parser_state_State_1_optionZ_optionZBang(v98, v99);
						VAL v101 = VTUP(v57)->cells[2];
						decref(v101);
						VTUP(v57)->cells[2] = v100;
						x92 = v57;
					} break;
					case 0LL: { // None
						VAL v102 = VVAL(VTUP(v90)->cells[2]);
						incref(v102);
						decref(v90);
						VAL v103 = VVAL(VTUP(v57)->cells[2]);
						incref(v103);
						VAL v104 = VVAL(VTUP(v103)->cells[1]);
						incref(v104);
						decref(v103);
						VAL v105 = MKI64(0LL /* None */);
						VAL v106;
						VAL v107;
						mw_argZ_parser_types_ZPlusArgumentParser_1_parser(v57, &v106, &v107);
						push_value(v104);
						push_value(v105);
						push_value(v102);
						push_resource(v106);
						run_value(v107);
						VAL r108 = pop_resource();
						VAL v109 = VVAL(VTUP(r108)->cells[2]);
						incref(v109);
						VAL v110 = pop_value();
						VAL v111 = tup_replace(v109, 1, v110);
						VAL v112 = VTUP(r108)->cells[2];
						decref(v112);
						VTUP(r108)->cells[2] = v111;
						x92 = r108;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v113 = MKI64(0LL /* None */);
				x89 = v113;
				x88 = x92;
			} break;
			case 0LL: { // None
				VAL v114 = MKI64(4LL /* UnknownArg */);
				VAL v115 = mtw_std_maybe_Maybe_1_Some(v114);
				x89 = v115;
				x88 = v57;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x25 = x89;
		x24 = x88;
		VAL v116 = pop_value();
		x23 = v116;
	} else {
		int64_t v117 = 1LL;
		incref(x12);
		int64_t v118 = (0LL /* +Unsafe */);
		VAL v119;
		int64_t v120;
		mw_std_prim_Str_dropZ_bytes(v117, x12, v118, &v119, &v120);
		VAL v121 = VVAL(VTUP(x11)->cells[1]);
		incref(v121);
		VAL v122 = VVAL(VTUP(v121)->cells[1]);
		incref(v122);
		decref(v121);
		VAL v123 = MKI64(0LL /* None */);
		VAL v124;
		VAL v125;
		mw_std_list_List_1_uncons(v122, &v124, &v125);
		VAL x126;
		VAL x127;
		VAL x128;
		VAL x129;
		int64_t x130;
		switch (get_data_tag(v124)) {
			case 1LL: { // Some
				VAL v131 = mtp_std_maybe_Maybe_1_Some(v124);
				incref(v131);
				incref(v119);
				VAL v132;
				VAL v133;
				int64_t v134;
				mw_argZ_parser_parse_checkZ_shortZ_flag(x11, v131, v119, &v132, &v133, &v134);
				decref(v133);
				VAL x135;
				VAL x136;
				VAL x137;
				if (((bool)v134)) {
					VAL v138 = mtw_std_maybe_Maybe_1_Some(v131);
					x137 = v138;
					x136 = v132;
					x135 = v119;
					push_value(x12);
				} else {
					decref(v131);
					VAL v139 = MKI64(0LL /* None */);
					x137 = v139;
					x136 = v132;
					x135 = v119;
					push_value(x12);
				}
				VAL x140;
				VAL x141;
				VAL x142;
				VAL x143;
				switch (get_data_tag(x137)) {
					case 0LL: { // None
						x143 = v125;
						x142 = v123;
						x141 = x136;
						x140 = x135;
					} break;
					default: {
						decref(v125);
						decref(v123);
						VAL v144 = MKI64(0LL /* Nil */);
						x143 = v144;
						x142 = x137;
						x141 = x136;
						x140 = x135;
					} break;
				}
				int64_t v145 = 1LL /* True */;
				x130 = v145;
				x129 = x143;
				x128 = x142;
				x127 = x141;
				x126 = x140;
			} break;
			case 0LL: { // None
				int64_t v146 = 0LL /* False */;
				x130 = v146;
				x129 = v125;
				x128 = v123;
				x127 = x11;
				x126 = v119;
				push_value(x12);
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v147 = x126;
		VAL v148 = (x127);
		VAL v149 = x128;
		VAL v150 = x129;
		int64_t v151 = x130;
		while (((bool)v151)) {
			VAL v152 = v147;
			VAL v153 = (v148);
			VAL v154 = v149;
			VAL v155 = v150;
			VAL v156;
			VAL v157;
			mw_std_list_List_1_uncons(v155, &v156, &v157);
			VAL x158;
			VAL x159;
			VAL x160;
			VAL x161;
			int64_t x162;
			switch (get_data_tag(v156)) {
				case 1LL: { // Some
					VAL v163 = mtp_std_maybe_Maybe_1_Some(v156);
					incref(v163);
					incref(v152);
					VAL v164;
					VAL v165;
					int64_t v166;
					mw_argZ_parser_parse_checkZ_shortZ_flag(v153, v163, v152, &v164, &v165, &v166);
					decref(v165);
					VAL x167;
					VAL x168;
					VAL x169;
					if (((bool)v166)) {
						VAL v170 = mtw_std_maybe_Maybe_1_Some(v163);
						x169 = v170;
						x168 = v164;
						x167 = v152;
					} else {
						decref(v163);
						VAL v171 = MKI64(0LL /* None */);
						x169 = v171;
						x168 = v164;
						x167 = v152;
					}
					VAL x172;
					VAL x173;
					VAL x174;
					VAL x175;
					switch (get_data_tag(x169)) {
						case 0LL: { // None
							x175 = v157;
							x174 = v154;
							x173 = x168;
							x172 = x167;
						} break;
						default: {
							decref(v157);
							decref(v154);
							VAL v176 = MKI64(0LL /* Nil */);
							x175 = v176;
							x174 = x169;
							x173 = x168;
							x172 = x167;
						} break;
					}
					int64_t v177 = 1LL /* True */;
					x162 = v177;
					x161 = x175;
					x160 = x174;
					x159 = x173;
					x158 = x172;
				} break;
				case 0LL: { // None
					int64_t v178 = 0LL /* False */;
					x162 = v178;
					x161 = v157;
					x160 = v154;
					x159 = v153;
					x158 = v152;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v151 = x162;
			v150 = x161;
			v149 = x160;
			v148 = x159;
			v147 = x158;
		}
		decref(v150);
		decref(v147);
		VAL x179;
		VAL x180;
		switch (get_data_tag(v149)) {
			case 1LL: { // Some
				VAL v181 = mtp_std_maybe_Maybe_1_Some(v149);
				incref(v181);
				VAL v182 = VVAL(VTUP(v181)->cells[3]);
				incref(v182);
				decref(v181);
				VAL x183;
				switch (get_data_tag(v182)) {
					case 1LL: { // Some
						VAL v184 = mtp_std_maybe_Maybe_1_Some(v182);
						int64_t v185 = 1LL /* True */;
						VAL v186 = VVAL(VTUP(v148)->cells[2]);
						incref(v186);
						VAL v187 = mw_argZ_parser_state_State_1_parsingZAskZBang(v185, v186);
						VAL v188 = VTUP(v148)->cells[2];
						decref(v188);
						VTUP(v148)->cells[2] = v187;
						decref(v184);
						VAL v189 = mtw_std_maybe_Maybe_1_Some(v181);
						VAL v190 = VVAL(VTUP(v148)->cells[2]);
						incref(v190);
						VAL v191 = mw_argZ_parser_state_State_1_optionZ_optionZBang(v189, v190);
						VAL v192 = VTUP(v148)->cells[2];
						decref(v192);
						VTUP(v148)->cells[2] = v191;
						x183 = v148;
					} break;
					case 0LL: { // None
						VAL v193 = VVAL(VTUP(v181)->cells[2]);
						incref(v193);
						decref(v181);
						VAL v194 = VVAL(VTUP(v148)->cells[2]);
						incref(v194);
						VAL v195 = VVAL(VTUP(v194)->cells[1]);
						incref(v195);
						decref(v194);
						VAL v196 = MKI64(0LL /* None */);
						VAL v197;
						VAL v198;
						mw_argZ_parser_types_ZPlusArgumentParser_1_parser(v148, &v197, &v198);
						push_value(v195);
						push_value(v196);
						push_value(v193);
						push_resource(v197);
						run_value(v198);
						VAL r199 = pop_resource();
						VAL v200 = VVAL(VTUP(r199)->cells[2]);
						incref(v200);
						VAL v201 = pop_value();
						VAL v202 = tup_replace(v200, 1, v201);
						VAL v203 = VTUP(r199)->cells[2];
						decref(v203);
						VTUP(r199)->cells[2] = v202;
						x183 = r199;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v204 = MKI64(0LL /* None */);
				x180 = v204;
				x179 = x183;
			} break;
			case 0LL: { // None
				VAL v205 = MKI64(4LL /* UnknownArg */);
				VAL v206 = mtw_std_maybe_Maybe_1_Some(v205);
				x180 = v206;
				x179 = v148;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x25 = x180;
		x24 = x179;
		VAL v207 = pop_value();
		x23 = v207;
	}
	decref(x23);
	*x4 = x25;
	*x3 = x24;
}
static void mw_argZ_parser_parse_doZ_positionalZ_option (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x1)->cells[2]);
	incref(v5);
	VAL v6 = VVAL(VTUP(v5)->cells[1]);
	incref(v6);
	decref(v5);
	VAL v7 = mtw_std_maybe_Maybe_1_Some(x2);
	VAL v8 = MKI64(2LL /* Positional */);
	VAL v9;
	VAL v10;
	mw_argZ_parser_types_ZPlusArgumentParser_1_parser(x1, &v9, &v10);
	push_value(v6);
	push_value(v7);
	push_value(v8);
	push_resource(v9);
	run_value(v10);
	VAL r11 = pop_resource();
	VAL v12 = VVAL(VTUP(r11)->cells[2]);
	incref(v12);
	VAL v13 = pop_value();
	VAL v14 = tup_replace(v12, 1, v13);
	VAL v15 = VTUP(r11)->cells[2];
	decref(v15);
	VTUP(r11)->cells[2] = v14;
	VAL v16 = MKI64(0LL /* None */);
	VAL v17 = VVAL(VTUP(r11)->cells[2]);
	incref(v17);
	int64_t v18 = VI64(VTUP(v17)->cells[4]);
	decref(v17);
	int64_t v19 = 1LL;
	int64_t v20 = i64_add(v18, v19);
	VAL v21 = VVAL(VTUP(r11)->cells[2]);
	incref(v21);
	VAL v22 = tup_replace(v21, 4, MKI64(v20));
	VAL v23 = VTUP(r11)->cells[2];
	decref(v23);
	VTUP(r11)->cells[2] = v22;
	*x4 = v16;
	*x3 = r11;
}
static VAL mw_argZ_parser_parse_parseZ_args (VAL x1, VAL x2) {
	VAL v3 = mw_argZ_parser_state_State_1_init(x1);
	VAL v4 = (mtw_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser(x2, v3));
	VAL v5 = VVAL(VTUP(v4)->cells[1]);
	incref(v5);
	VAL v6 = VVAL(VTUP(v5)->cells[1]);
	incref(v6);
	decref(v5);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v7);
			int64_t v13 = 0LL;
			incref(v12);
			VAL v14 = VVAL(VTUP(v12)->cells[2]);
			incref(v14);
			decref(v12);
			VAL x15;
			VAL x16;
			int64_t x17;
			switch (get_data_tag(v14)) {
				case 0LL: { // Short
					int64_t v18 = mtp_argZ_parser_types_ArgpOptionType_Short(v14);
					int64_t v19 = 2LL;
					int64_t v20 = i64_add(v13, v19);
					x17 = v20;
					x16 = v12;
					x15 = v4;
				} break;
				default: {
					decref(v14);
					x17 = v13;
					x16 = v12;
					x15 = v4;
				} break;
			}
			incref(x16);
			VAL v21 = VVAL(VTUP(x16)->cells[1]);
			incref(v21);
			decref(x16);
			VAL x22;
			int64_t x23;
			VAL x24;
			switch (get_data_tag(v21)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v21);
					uint64_t v26 = str_size(VSTR(v25));
					int64_t v27 = 0LL;
					bool v28 = (((int64_t)v26) < v27);
					int64_t x29;
					if (v28) {
						x29 = v27;
						push_resource(x15);
						lpush(&lbl_docZ_length, MKI64(x17));
						push_value(x16);
					} else {
						x29 = ((int64_t)v26);
						push_resource(x15);
						lpush(&lbl_docZ_length, MKI64(x17));
						push_value(x16);
					}
					int64_t v30 = VI64(lpop(&lbl_docZ_length));
					int64_t v31 = 3LL;
					int64_t v32 = i64_add(v30, v31);
					int64_t v33 = i64_add(x29, v32);
					VAL v34 = pop_value();
					x24 = v34;
					x23 = v33;
					VAL r35 = pop_resource();
					x22 = r35;
				} break;
				case 0LL: { // None
					x24 = x16;
					x23 = x17;
					x22 = x15;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v36 = VVAL(VTUP(x24)->cells[3]);
			incref(v36);
			decref(x24);
			VAL x37;
			int64_t x38;
			switch (get_data_tag(v36)) {
				case 1LL: { // Some
					VAL v39 = mtp_std_maybe_Maybe_1_Some(v36);
					uint64_t v40 = str_size(VSTR(v39));
					int64_t v41 = 0LL;
					bool v42 = (((int64_t)v40) < v41);
					int64_t x43;
					if (v42) {
						x43 = v41;
						push_resource(x22);
						lpush(&lbl_docZ_length, MKI64(x23));
					} else {
						x43 = ((int64_t)v40);
						push_resource(x22);
						lpush(&lbl_docZ_length, MKI64(x23));
					}
					int64_t v44 = VI64(lpop(&lbl_docZ_length));
					int64_t v45 = 1LL;
					int64_t v46 = i64_add(v44, v45);
					int64_t v47 = i64_add(x43, v46);
					x38 = v47;
					VAL r48 = pop_resource();
					x37 = r48;
				} break;
				case 0LL: { // None
					x38 = x23;
					x37 = x22;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v49 = VVAL(VTUP(x37)->cells[2]);
			incref(v49);
			int64_t v50 = VI64(VTUP(v49)->cells[5]);
			decref(v49);
			bool v51 = (x38 > v50);
			VAL x52;
			if (v51) {
				VAL v53 = VVAL(VTUP(x37)->cells[2]);
				incref(v53);
				VAL v54 = tup_replace(v53, 5, MKI64(x38));
				VAL v55 = VTUP(x37)->cells[2];
				decref(v55);
				VTUP(x37)->cells[2] = v54;
				x52 = x37;
			} else {
				x52 = x37;
			}
			int64_t v56 = 1LL /* True */;
			x11 = v56;
			x10 = v8;
			x9 = x52;
		} break;
		case 0LL: { // None
			int64_t v57 = 0LL /* False */;
			x11 = v57;
			x10 = v8;
			x9 = v4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v58 = (x9);
	VAL v59 = x10;
	int64_t v60 = x11;
	while (((bool)v60)) {
		VAL v61 = (v58);
		VAL v62 = v59;
		VAL v63;
		VAL v64;
		mw_std_list_List_1_uncons(v62, &v63, &v64);
		VAL x65;
		VAL x66;
		int64_t x67;
		switch (get_data_tag(v63)) {
			case 1LL: { // Some
				VAL v68 = mtp_std_maybe_Maybe_1_Some(v63);
				int64_t v69 = 0LL;
				incref(v68);
				VAL v70 = VVAL(VTUP(v68)->cells[2]);
				incref(v70);
				decref(v68);
				VAL x71;
				VAL x72;
				int64_t x73;
				switch (get_data_tag(v70)) {
					case 0LL: { // Short
						int64_t v74 = mtp_argZ_parser_types_ArgpOptionType_Short(v70);
						int64_t v75 = 2LL;
						int64_t v76 = i64_add(v69, v75);
						x73 = v76;
						x72 = v68;
						x71 = v61;
					} break;
					default: {
						decref(v70);
						x73 = v69;
						x72 = v68;
						x71 = v61;
					} break;
				}
				incref(x72);
				VAL v77 = VVAL(VTUP(x72)->cells[1]);
				incref(v77);
				decref(x72);
				VAL x78;
				int64_t x79;
				VAL x80;
				switch (get_data_tag(v77)) {
					case 1LL: { // Some
						VAL v81 = mtp_std_maybe_Maybe_1_Some(v77);
						uint64_t v82 = str_size(VSTR(v81));
						int64_t v83 = 0LL;
						bool v84 = (((int64_t)v82) < v83);
						int64_t x85;
						if (v84) {
							x85 = v83;
							push_resource(x71);
							lpush(&lbl_docZ_length, MKI64(x73));
							push_value(x72);
						} else {
							x85 = ((int64_t)v82);
							push_resource(x71);
							lpush(&lbl_docZ_length, MKI64(x73));
							push_value(x72);
						}
						int64_t v86 = VI64(lpop(&lbl_docZ_length));
						int64_t v87 = 3LL;
						int64_t v88 = i64_add(v86, v87);
						int64_t v89 = i64_add(x85, v88);
						VAL v90 = pop_value();
						x80 = v90;
						x79 = v89;
						VAL r91 = pop_resource();
						x78 = r91;
					} break;
					case 0LL: { // None
						x80 = x72;
						x79 = x73;
						x78 = x71;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v92 = VVAL(VTUP(x80)->cells[3]);
				incref(v92);
				decref(x80);
				VAL x93;
				int64_t x94;
				switch (get_data_tag(v92)) {
					case 1LL: { // Some
						VAL v95 = mtp_std_maybe_Maybe_1_Some(v92);
						uint64_t v96 = str_size(VSTR(v95));
						int64_t v97 = 0LL;
						bool v98 = (((int64_t)v96) < v97);
						int64_t x99;
						if (v98) {
							x99 = v97;
							push_resource(x78);
							lpush(&lbl_docZ_length, MKI64(x79));
						} else {
							x99 = ((int64_t)v96);
							push_resource(x78);
							lpush(&lbl_docZ_length, MKI64(x79));
						}
						int64_t v100 = VI64(lpop(&lbl_docZ_length));
						int64_t v101 = 1LL;
						int64_t v102 = i64_add(v100, v101);
						int64_t v103 = i64_add(x99, v102);
						x94 = v103;
						VAL r104 = pop_resource();
						x93 = r104;
					} break;
					case 0LL: { // None
						x94 = x79;
						x93 = x78;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v105 = VVAL(VTUP(x93)->cells[2]);
				incref(v105);
				int64_t v106 = VI64(VTUP(v105)->cells[5]);
				decref(v105);
				bool v107 = (x94 > v106);
				VAL x108;
				if (v107) {
					VAL v109 = VVAL(VTUP(x93)->cells[2]);
					incref(v109);
					VAL v110 = tup_replace(v109, 5, MKI64(x94));
					VAL v111 = VTUP(x93)->cells[2];
					decref(v111);
					VTUP(x93)->cells[2] = v110;
					x108 = x93;
				} else {
					x108 = x93;
				}
				int64_t v112 = 1LL /* True */;
				x67 = v112;
				x66 = v64;
				x65 = x108;
			} break;
			case 0LL: { // None
				int64_t v113 = 0LL /* False */;
				x67 = v113;
				x66 = v64;
				x65 = v61;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v60 = x67;
		v59 = x66;
		v58 = x65;
	}
	decref(v59);
	VAL v114 = VVAL(VTUP(v58)->cells[2]);
	incref(v114);
	VAL v115 = mw_argZ_parser_state_State_1_argv(v114);
	VAL v116;
	VAL v117;
	mw_std_list_List_1_uncons(v115, &v116, &v117);
	VAL x118;
	VAL x119;
	int64_t x120;
	switch (get_data_tag(v116)) {
		case 1LL: { // Some
			VAL v121 = mtp_std_maybe_Maybe_1_Some(v116);
			incref(v121);
			uint64_t v122 = str_size(VSTR(v121));
			int64_t v123 = 0LL;
			bool v124 = (((int64_t)v122) < v123);
			int64_t x125;
			if (v124) {
				x125 = v123;
				push_resource(v58);
				push_value(v121);
			} else {
				x125 = ((int64_t)v122);
				push_resource(v58);
				push_value(v121);
			}
			int64_t v126 = 1LL;
			bool v127 = (x125 > v126);
			VAL x128;
			VAL x129;
			if (v127) {
				int64_t v130 = 0LL;
				VAL v131 = pop_value();
				incref(v131);
				int64_t v132 = mw_std_prim_Str_byteZAt(v130, v131);
				int64_t v133 = 45LL /* B'-' */;
				bool v134 = (v132 == v133);
				VAL x135;
				VAL x136;
				if (v134) {
					VAL r137 = pop_resource();
					VAL v138 = VVAL(VTUP(r137)->cells[2]);
					incref(v138);
					int64_t v139 = mw_argZ_parser_state_State_1_parsingZAsk(v138);
					VAL x140;
					VAL x141;
					if (((bool)v139)) {
						decref(v131);
						VAL v142 = VVAL(VTUP(r137)->cells[2]);
						incref(v142);
						VAL v143 = mw_argZ_parser_state_State_1_optionZ_option(v142);
						VAL x144;
						VAL x145;
						switch (get_data_tag(v143)) {
							case 1LL: { // Some
								VAL v146 = mtp_std_maybe_Maybe_1_Some(v143);
								VAL v147 = VVAL(VTUP(v146)->cells[3]);
								incref(v147);
								decref(v146);
								VAL x148;
								VAL x149;
								switch (get_data_tag(v147)) {
									case 1LL: { // Some
										VAL v150 = mtp_std_maybe_Maybe_1_Some(v147);
										decref(v150);
										VAL v151 = MKI64(0LL /* MissingArgValue */);
										VAL v152 = mtw_std_maybe_Maybe_1_Some(v151);
										x149 = v152;
										x148 = r137;
									} break;
									case 0LL: { // None
										int64_t v153 = 0LL /* False */;
										VAL v154 = VVAL(VTUP(r137)->cells[2]);
										incref(v154);
										VAL v155 = mw_argZ_parser_state_State_1_parsingZAskZBang(v153, v154);
										VAL v156 = VTUP(r137)->cells[2];
										decref(v156);
										VTUP(r137)->cells[2] = v155;
										VAL v157 = MKI64(0LL /* None */);
										x149 = v157;
										x148 = r137;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								x145 = x149;
								x144 = x148;
							} break;
							case 0LL: { // None
								VAL v158 = MKI64(0LL /* MissingArgValue */);
								VAL v159 = mtw_std_maybe_Maybe_1_Some(v158);
								x145 = v159;
								x144 = r137;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						x141 = x145;
						x140 = x144;
					} else {
						VAL v160;
						VAL v161;
						mw_argZ_parser_parse_parseZ_flags(r137, v131, &v160, &v161);
						x141 = v161;
						x140 = v160;
					}
					x136 = x141;
					x135 = x140;
				} else {
					VAL r162 = pop_resource();
					VAL v163 = VVAL(VTUP(r162)->cells[2]);
					incref(v163);
					int64_t v164 = mw_argZ_parser_state_State_1_parsingZAsk(v163);
					VAL x165;
					VAL x166;
					if (((bool)v164)) {
						VAL v167 = VVAL(VTUP(r162)->cells[2]);
						incref(v167);
						VAL v168 = mw_argZ_parser_state_State_1_optionZ_option(v167);
						VAL x169;
						VAL x170;
						switch (get_data_tag(v168)) {
							case 1LL: { // Some
								VAL v171 = mtp_std_maybe_Maybe_1_Some(v168);
								incref(v171);
								VAL v172 = VVAL(VTUP(v171)->cells[3]);
								incref(v172);
								decref(v171);
								VAL x173;
								VAL x174;
								switch (get_data_tag(v172)) {
									case 1LL: { // Some
										VAL v175 = mtp_std_maybe_Maybe_1_Some(v172);
										decref(v175);
										VAL v176 = VVAL(VTUP(r162)->cells[2]);
										incref(v176);
										VAL v177 = VVAL(VTUP(v176)->cells[1]);
										incref(v177);
										decref(v176);
										VAL v178 = mtw_std_maybe_Maybe_1_Some(v131);
										VAL v179 = VVAL(VTUP(v171)->cells[2]);
										incref(v179);
										decref(v171);
										VAL v180;
										VAL v181;
										mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r162, &v180, &v181);
										push_value(v177);
										push_value(v178);
										push_value(v179);
										push_resource(v180);
										run_value(v181);
										VAL r182 = pop_resource();
										VAL v183 = VVAL(VTUP(r182)->cells[2]);
										incref(v183);
										VAL v184 = pop_value();
										VAL v185 = tup_replace(v183, 1, v184);
										VAL v186 = VTUP(r182)->cells[2];
										decref(v186);
										VTUP(r182)->cells[2] = v185;
										VAL v187 = MKI64(0LL /* None */);
										x174 = v187;
										x173 = r182;
									} break;
									case 0LL: { // None
										decref(v171);
										decref(v131);
										VAL v188 = MKI64(4LL /* UnknownArg */);
										VAL v189 = mtw_std_maybe_Maybe_1_Some(v188);
										x174 = v189;
										x173 = r162;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								x170 = x174;
								x169 = x173;
							} break;
							case 0LL: { // None
								decref(v131);
								VAL v190 = MKI64(4LL /* UnknownArg */);
								VAL v191 = mtw_std_maybe_Maybe_1_Some(v190);
								x170 = v191;
								x169 = r162;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v192 = 0LL /* False */;
						VAL v193 = VVAL(VTUP(x169)->cells[2]);
						incref(v193);
						VAL v194 = mw_argZ_parser_state_State_1_parsingZAskZBang(v192, v193);
						VAL v195 = VTUP(x169)->cells[2];
						decref(v195);
						VTUP(x169)->cells[2] = v194;
						x166 = x169;
						x165 = x170;
					} else {
						VAL v196;
						VAL v197;
						mw_argZ_parser_parse_doZ_positionalZ_option(r162, v131, &v196, &v197);
						x166 = v196;
						x165 = v197;
					}
					x136 = x165;
					x135 = x166;
				}
				x129 = x136;
				x128 = x135;
			} else {
				VAL v198 = pop_value();
				decref(v198);
				VAL v199 = MKI64(0LL /* None */);
				x129 = v199;
				VAL r200 = pop_resource();
				x128 = r200;
			}
			VAL x201;
			switch (get_data_tag(x129)) {
				case 1LL: { // Some
					VAL v202 = mtp_std_maybe_Maybe_1_Some(x129);
					VAL v203 = mtw_std_maybe_Maybe_1_Some(v202);
					VAL v204 = VVAL(VTUP(x128)->cells[2]);
					incref(v204);
					VAL v205 = tup_replace(v204, 6, v203);
					VAL v206 = VTUP(x128)->cells[2];
					decref(v206);
					VTUP(x128)->cells[2] = v205;
					x201 = x128;
				} break;
				case 0LL: { // None
					x201 = x128;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v207 = 1LL /* True */;
			x120 = v207;
			x119 = v117;
			x118 = x201;
		} break;
		case 0LL: { // None
			int64_t v208 = 0LL /* False */;
			x120 = v208;
			x119 = v117;
			x118 = v58;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v209 = (x118);
	VAL v210 = x119;
	int64_t v211 = x120;
	while (((bool)v211)) {
		VAL v212 = (v209);
		VAL v213 = v210;
		VAL v214;
		VAL v215;
		mw_std_list_List_1_uncons(v213, &v214, &v215);
		VAL x216;
		VAL x217;
		int64_t x218;
		switch (get_data_tag(v214)) {
			case 1LL: { // Some
				VAL v219 = mtp_std_maybe_Maybe_1_Some(v214);
				incref(v219);
				uint64_t v220 = str_size(VSTR(v219));
				int64_t v221 = 0LL;
				bool v222 = (((int64_t)v220) < v221);
				int64_t x223;
				if (v222) {
					x223 = v221;
					push_resource(v212);
					push_value(v219);
				} else {
					x223 = ((int64_t)v220);
					push_resource(v212);
					push_value(v219);
				}
				int64_t v224 = 1LL;
				bool v225 = (x223 > v224);
				VAL x226;
				VAL x227;
				if (v225) {
					int64_t v228 = 0LL;
					VAL v229 = pop_value();
					incref(v229);
					int64_t v230 = mw_std_prim_Str_byteZAt(v228, v229);
					int64_t v231 = 45LL /* B'-' */;
					bool v232 = (v230 == v231);
					VAL x233;
					VAL x234;
					if (v232) {
						VAL r235 = pop_resource();
						VAL v236 = VVAL(VTUP(r235)->cells[2]);
						incref(v236);
						int64_t v237 = mw_argZ_parser_state_State_1_parsingZAsk(v236);
						VAL x238;
						VAL x239;
						if (((bool)v237)) {
							decref(v229);
							VAL v240 = VVAL(VTUP(r235)->cells[2]);
							incref(v240);
							VAL v241 = mw_argZ_parser_state_State_1_optionZ_option(v240);
							VAL x242;
							VAL x243;
							switch (get_data_tag(v241)) {
								case 1LL: { // Some
									VAL v244 = mtp_std_maybe_Maybe_1_Some(v241);
									VAL v245 = VVAL(VTUP(v244)->cells[3]);
									incref(v245);
									decref(v244);
									VAL x246;
									VAL x247;
									switch (get_data_tag(v245)) {
										case 1LL: { // Some
											VAL v248 = mtp_std_maybe_Maybe_1_Some(v245);
											decref(v248);
											VAL v249 = MKI64(0LL /* MissingArgValue */);
											VAL v250 = mtw_std_maybe_Maybe_1_Some(v249);
											x247 = v250;
											x246 = r235;
										} break;
										case 0LL: { // None
											int64_t v251 = 0LL /* False */;
											VAL v252 = VVAL(VTUP(r235)->cells[2]);
											incref(v252);
											VAL v253 = mw_argZ_parser_state_State_1_parsingZAskZBang(v251, v252);
											VAL v254 = VTUP(r235)->cells[2];
											decref(v254);
											VTUP(r235)->cells[2] = v253;
											VAL v255 = MKI64(0LL /* None */);
											x247 = v255;
											x246 = r235;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									x243 = x247;
									x242 = x246;
								} break;
								case 0LL: { // None
									VAL v256 = MKI64(0LL /* MissingArgValue */);
									VAL v257 = mtw_std_maybe_Maybe_1_Some(v256);
									x243 = v257;
									x242 = r235;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							x239 = x243;
							x238 = x242;
						} else {
							VAL v258;
							VAL v259;
							mw_argZ_parser_parse_parseZ_flags(r235, v229, &v258, &v259);
							x239 = v259;
							x238 = v258;
						}
						x234 = x239;
						x233 = x238;
					} else {
						VAL r260 = pop_resource();
						VAL v261 = VVAL(VTUP(r260)->cells[2]);
						incref(v261);
						int64_t v262 = mw_argZ_parser_state_State_1_parsingZAsk(v261);
						VAL x263;
						VAL x264;
						if (((bool)v262)) {
							VAL v265 = VVAL(VTUP(r260)->cells[2]);
							incref(v265);
							VAL v266 = mw_argZ_parser_state_State_1_optionZ_option(v265);
							VAL x267;
							VAL x268;
							switch (get_data_tag(v266)) {
								case 1LL: { // Some
									VAL v269 = mtp_std_maybe_Maybe_1_Some(v266);
									incref(v269);
									VAL v270 = VVAL(VTUP(v269)->cells[3]);
									incref(v270);
									decref(v269);
									VAL x271;
									VAL x272;
									switch (get_data_tag(v270)) {
										case 1LL: { // Some
											VAL v273 = mtp_std_maybe_Maybe_1_Some(v270);
											decref(v273);
											VAL v274 = VVAL(VTUP(r260)->cells[2]);
											incref(v274);
											VAL v275 = VVAL(VTUP(v274)->cells[1]);
											incref(v275);
											decref(v274);
											VAL v276 = mtw_std_maybe_Maybe_1_Some(v229);
											VAL v277 = VVAL(VTUP(v269)->cells[2]);
											incref(v277);
											decref(v269);
											VAL v278;
											VAL v279;
											mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r260, &v278, &v279);
											push_value(v275);
											push_value(v276);
											push_value(v277);
											push_resource(v278);
											run_value(v279);
											VAL r280 = pop_resource();
											VAL v281 = VVAL(VTUP(r280)->cells[2]);
											incref(v281);
											VAL v282 = pop_value();
											VAL v283 = tup_replace(v281, 1, v282);
											VAL v284 = VTUP(r280)->cells[2];
											decref(v284);
											VTUP(r280)->cells[2] = v283;
											VAL v285 = MKI64(0LL /* None */);
											x272 = v285;
											x271 = r280;
										} break;
										case 0LL: { // None
											decref(v269);
											decref(v229);
											VAL v286 = MKI64(4LL /* UnknownArg */);
											VAL v287 = mtw_std_maybe_Maybe_1_Some(v286);
											x272 = v287;
											x271 = r260;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									x268 = x272;
									x267 = x271;
								} break;
								case 0LL: { // None
									decref(v229);
									VAL v288 = MKI64(4LL /* UnknownArg */);
									VAL v289 = mtw_std_maybe_Maybe_1_Some(v288);
									x268 = v289;
									x267 = r260;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v290 = 0LL /* False */;
							VAL v291 = VVAL(VTUP(x267)->cells[2]);
							incref(v291);
							VAL v292 = mw_argZ_parser_state_State_1_parsingZAskZBang(v290, v291);
							VAL v293 = VTUP(x267)->cells[2];
							decref(v293);
							VTUP(x267)->cells[2] = v292;
							x264 = x267;
							x263 = x268;
						} else {
							VAL v294;
							VAL v295;
							mw_argZ_parser_parse_doZ_positionalZ_option(r260, v229, &v294, &v295);
							x264 = v294;
							x263 = v295;
						}
						x234 = x263;
						x233 = x264;
					}
					x227 = x234;
					x226 = x233;
				} else {
					VAL v296 = pop_value();
					decref(v296);
					VAL v297 = MKI64(0LL /* None */);
					x227 = v297;
					VAL r298 = pop_resource();
					x226 = r298;
				}
				VAL x299;
				switch (get_data_tag(x227)) {
					case 1LL: { // Some
						VAL v300 = mtp_std_maybe_Maybe_1_Some(x227);
						VAL v301 = mtw_std_maybe_Maybe_1_Some(v300);
						VAL v302 = VVAL(VTUP(x226)->cells[2]);
						incref(v302);
						VAL v303 = tup_replace(v302, 6, v301);
						VAL v304 = VTUP(x226)->cells[2];
						decref(v304);
						VTUP(x226)->cells[2] = v303;
						x299 = x226;
					} break;
					case 0LL: { // None
						x299 = x226;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v305 = 1LL /* True */;
				x218 = v305;
				x217 = v215;
				x216 = x299;
			} break;
			case 0LL: { // None
				int64_t v306 = 0LL /* False */;
				x218 = v306;
				x217 = v215;
				x216 = v212;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v211 = x218;
		v210 = x217;
		v209 = x216;
	}
	decref(v210);
	VAL v307 = VVAL(VTUP(v209)->cells[2]);
	incref(v307);
	int64_t v308 = mw_argZ_parser_state_State_1_parsingZAsk(v307);
	VAL x309;
	if (((bool)v308)) {
		VAL v310 = MKI64(0LL /* MissingArgValue */);
		VAL v311 = mtw_std_maybe_Maybe_1_Some(v310);
		VAL v312 = VVAL(VTUP(v209)->cells[2]);
		incref(v312);
		VAL v313 = tup_replace(v312, 6, v311);
		VAL v314 = VTUP(v209)->cells[2];
		decref(v314);
		VTUP(v209)->cells[2] = v313;
		x309 = v209;
	} else {
		x309 = v209;
	}
	VAL v315 = VVAL(VTUP(x309)->cells[2]);
	incref(v315);
	VAL v316 = VVAL(VTUP(v315)->cells[1]);
	incref(v316);
	decref(v315);
	VAL v317 = MKI64(0LL /* None */);
	VAL v318 = MKI64(3LL /* End */);
	VAL v319;
	VAL v320;
	mw_argZ_parser_types_ZPlusArgumentParser_1_parser(x309, &v319, &v320);
	push_value(v316);
	push_value(v317);
	push_value(v318);
	push_resource(v319);
	run_value(v320);
	VAL r321 = pop_resource();
	VAL v322 = VVAL(VTUP(r321)->cells[2]);
	incref(v322);
	VAL v323 = pop_value();
	VAL v324 = tup_replace(v322, 1, v323);
	VAL v325 = VTUP(r321)->cells[2];
	decref(v325);
	VTUP(r321)->cells[2] = v324;
	VAL v326 = VVAL(VTUP(r321)->cells[2]);
	incref(v326);
	VAL v327 = VVAL(VTUP(v326)->cells[1]);
	incref(v327);
	decref(v326);
	VAL v328 = VVAL(VTUP(r321)->cells[2]);
	incref(v328);
	VAL v329 = VVAL(VTUP(v328)->cells[6]);
	incref(v329);
	decref(v328);
	VAL x330;
	VAL x331;
	switch (get_data_tag(v329)) {
		case 1LL: { // Some
			VAL v332 = mtp_std_maybe_Maybe_1_Some(v329);
			VAL v333;
			VAL v334;
			mw_argZ_parser_types_ZPlusArgumentParser_1_usage(r321, &v333, &v334);
			VAL v335 = MKNIL;
			VAL v336 = mkcons(v335, v332);
			VAL v337 = mkcons(v336, v334);
			VAL v338 = mtw_std_either_Either_2_Left(v337);
			decref(v327);
			x331 = v338;
			x330 = v333;
		} break;
		case 0LL: { // None
			VAL v339 = mtw_std_either_Either_2_Right(v327);
			x331 = v339;
			x330 = r321;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop(x330);
	return x331;
}
static void mw_argZ_parser_parse_readZ_fromZ_argv (int64_t x1, int64_t x2, VAL *x3, int64_t *x4) {
	int64_t v5 = 0LL;
	bool v6 = (x2 < v5);
	VAL x7;
	int64_t x8;
	if (v6) {
		STR* v9;
		STRLIT(v9, "", 0);
		x8 = x1;
		x7 = MKSTR(v9);
	} else {
		uint64_t v10 = sizeof(void*);
		int64_t v11 = 0LL;
		bool v12 = (((int64_t)v10) < v11);
		int64_t x13;
		if (v12) {
			x13 = v11;
			push_resource(MKI64(x1));
			push_i64(x2);
		} else {
			x13 = ((int64_t)v10);
			push_resource(MKI64(x1));
			push_i64(x2);
		}
		int64_t v14 = pop_i64();
		int64_t v15 = i64_mul(v14, x13);
		void* v16 = global_argv;
		void* v17 = (void*)(v15 + (char*)v16);
		void* v18 = *(void**)v17;
		int64_t r19 = VI64(pop_resource());
		int64_t v20;
		int64_t v21;
		mext_std_ctypes_CStr_numZ_bytes(r19, v18, &v20, &v21);
		STR* v22 = str_make(v18, ((uint64_t)v21));
		x8 = v20;
		x7 = MKSTR(v22);
	}
	*x4 = x8;
	*x3 = x7;
}
static VAL mw_argZ_parser_parse_argvZ_toZ_str (void) {
	int64_t v1 = 1LL;
	int64_t v2 = global_argc;
	int64_t v3 = 1LL;
	int64_t v4 = i64_sub(v2, v3);
	VAL v5 = mw_std_prim_Int_range(v1, v4);
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v5, &v8, &v9);
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v8);
			int64_t v14 = (0LL /* +Unsafe */);
			VAL v15;
			int64_t v16;
			mw_argZ_parser_parse_readZ_fromZ_argv(v14, VI64(v13), &v15, &v16);
			VAL v17 = mtw_std_list_List_1_Cons(v15, v7);
			int64_t v18 = 1LL /* True */;
			x12 = v18;
			x11 = v9;
			x10 = v17;
		} break;
		case 0LL: { // None
			int64_t v19 = 0LL /* False */;
			x12 = v19;
			x11 = v9;
			x10 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v20 = (x10);
	VAL v21 = x11;
	int64_t v22 = x12;
	while (((bool)v22)) {
		VAL v23 = (v20);
		VAL v24 = v21;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		VAL x28;
		int64_t x29;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v25);
				int64_t v31 = (0LL /* +Unsafe */);
				VAL v32;
				int64_t v33;
				mw_argZ_parser_parse_readZ_fromZ_argv(v31, VI64(v30), &v32, &v33);
				VAL v34 = mtw_std_list_List_1_Cons(v32, v23);
				int64_t v35 = 1LL /* True */;
				x29 = v35;
				x28 = v26;
				x27 = v34;
			} break;
			case 0LL: { // None
				int64_t v36 = 0LL /* False */;
				x29 = v36;
				x28 = v26;
				x27 = v23;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v22 = x29;
		v21 = x28;
		v20 = x27;
	}
	decref(v21);
	VAL v37 = mw_std_list_List_1_reverse(v20);
	return v37;
}
static int64_t mw_mirth_label_Label_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_label_Label_allocZBang (void) {
	void* v1 = mbuf_mirth_label_Label_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_label_Label_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_label_Label_name (uint64_t x1) {
	void* v2 = mfld_mirth_label_Label_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_label_Label_ZToStr (uint64_t x1) {
	uint64_t v2 = mw_mirth_label_Label_name(x1);
	VAL v3 = mw_mirth_name_Name_ZToStr(v2);
	return v3;
}
static int64_t mw_mirth_label_Label_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_label_Label_index(x1);
	int64_t v4 = mw_mirth_label_Label_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static uint64_t mw_mirth_label_Label_newZBang (uint64_t x1) {
	void* v2 = mfld_mirth_name_Name_ZTildelabel(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	uint64_t x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = VU64(v6);
		x4 = x1;
	} else {
		uint64_t v7 = mw_mirth_label_Label_allocZBang();
		void* v8 = mfld_mirth_label_Label_ZTildename(v7);
		mut_set(MKU64(x1), v8);
		mut_set(MKU64(v7), v2);
		x5 = v7;
		x4 = x1;
	}
	return x5;
}
static int64_t mw_mirth_label_Label_isZ_resourceZ_labelZAsk (uint64_t x1) {
	uint64_t v2 = mw_mirth_label_Label_name(x1);
	int64_t v3 = mw_mirth_name_Name_head(v2);
	int64_t v4 = 43LL /* B'+' */;
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static int64_t mw_mirth_var_Var_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_var_Var_allocZBang (void) {
	void* v1 = mbuf_mirth_var_Var_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_var_Var_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_var_Var_name (uint64_t x1) {
	void* v2 = mfld_mirth_var_Var_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_var_Var_type (uint64_t x1) {
	void* v2 = mfld_mirth_var_Var_ZTildetype(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static VAL mw_mirth_var_Var_autoZ_runZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_var_Var_ZTildeautoZ_runZAsk(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static int64_t mw_mirth_var_Var_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_var_Var_index(x1);
	int64_t v4 = mw_mirth_var_Var_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static VAL mw_mirth_var_Var_typeZThen (VAL x1, uint64_t x2) {
	uint64_t v3 = mw_mirth_var_Var_name(x2);
	VAL v4 = mw_mirth_name_Name_ZToStr(v3);
	VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(v4, x1));
	return v5;
}
static int64_t mw_mirth_var_Var_isZ_stackZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_var_Var_type(x1);
	VAL v3 = mw_mirth_type_Type_primZAsk(v2);
	int64_t x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			int64_t v6 = 1LL /* PRIM_TYPE_STACK */;
			int64_t v7 = mw_mirth_type_PrimType_ZEqualZEqual(VI64(v5), v6);
			x4 = v7;
		} break;
		case 0LL: { // None
			int64_t v8 = 0LL /* False */;
			x4 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static int64_t mw_mirth_var_Var_isZ_physicalZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_var_Var_type(x1);
	int64_t v3 = mw_mirth_type_Type_isZ_physicalZAsk(v2);
	return v3;
}
static uint64_t mw_mirth_var_Var_newZBang (VAL x1, uint64_t x2) {
	uint64_t v3 = mw_mirth_var_Var_allocZBang();
	void* v4 = mfld_mirth_var_Var_ZTildename(v3);
	mut_set(MKU64(x2), v4);
	void* v5 = mfld_mirth_var_Var_ZTildetype(v3);
	mut_set(x1, v5);
	VAL v6 = MKI64(0LL /* None */);
	void* v7 = mfld_mirth_var_Var_ZTildeautoZ_runZAsk(v3);
	mut_set(v6, v7);
	return v3;
}
static uint64_t mw_mirth_var_Var_newZ_autoZ_runZBang (VAL x1, uint64_t x2) {
	incref(x1);
	VAL v3 = mtw_mirth_type_Type_TMorphism(x1);
	uint64_t v4 = mw_mirth_var_Var_newZBang(v3, x2);
	VAL v5 = mtw_std_maybe_Maybe_1_Some(x1);
	void* v6 = mfld_mirth_var_Var_ZTildeautoZ_runZAsk(v4);
	mut_set(v5, v6);
	return v4;
}
static VAL mw_std_list_List_1_ZToCtx (VAL x1) {
	return x1;
}
static VAL mw_mirth_var_Ctx_ZToList (VAL x1) {
	return x1;
}
static VAL mw_mirth_var_Ctx0 (void) {
	VAL v1 = MKI64(0LL /* Nil */);
	return v1;
}
static VAL mw_mirth_var_Ctx1 (uint64_t x1) {
	VAL v2 = MKI64(0LL /* Nil */);
	VAL v3 = mtw_std_list_List_1_Cons(MKU64(x1), v2);
	return v3;
}
static VAL mw_mirth_var_Ctx2 (uint64_t x1, uint64_t x2) {
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mtw_std_list_List_1_Cons(MKU64(x2), v3);
	VAL v5 = mtw_std_list_List_1_Cons(MKU64(x1), v4);
	return v5;
}
static VAL mw_mirth_var_Ctx3 (uint64_t x1, uint64_t x2, uint64_t x3) {
	VAL v4 = MKI64(0LL /* Nil */);
	VAL v5 = mtw_std_list_List_1_Cons(MKU64(x3), v4);
	VAL v6 = mtw_std_list_List_1_Cons(MKU64(x2), v5);
	VAL v7 = mtw_std_list_List_1_Cons(MKU64(x1), v6);
	return v7;
}
static VAL mw_mirth_var_Ctx_new (VAL x1, uint64_t x2) {
	VAL v3 = mw_mirth_var_Ctx_ZToList(x1);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5 = mtw_std_list_List_1_Cons(MKU64(x2), v4);
	VAL v6 = mw_std_list_List_1_reverse(v5);
	VAL v7 = mw_std_list_List_1_ZToCtx(v6);
	return v7;
}
static VAL mw_mirth_var_Ctx_lookup (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_var_Ctx_ZToList(x2);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5 = MKI64(0LL /* None */);
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(v4, &v6, &v7);
	uint64_t x8;
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v6);
			incref(v12);
			uint64_t v13 = mw_mirth_var_Var_name(VU64(v12));
			int64_t v14 = mw_mirth_name_Name_ZEqualZEqual(x1, v13);
			uint64_t x15;
			VAL x16;
			if (((bool)v14)) {
				VAL v17 = mtw_std_maybe_Maybe_1_Some(v12);
				x16 = v17;
				x15 = x1;
			} else {
				decref(v12);
				VAL v18 = MKI64(0LL /* None */);
				x16 = v18;
				x15 = x1;
			}
			uint64_t x19;
			VAL x20;
			VAL x21;
			switch (get_data_tag(x16)) {
				case 0LL: { // None
					x21 = v7;
					x20 = v5;
					x19 = x15;
				} break;
				default: {
					decref(v7);
					decref(v5);
					VAL v22 = MKI64(0LL /* Nil */);
					x21 = v22;
					x20 = x16;
					x19 = x15;
				} break;
			}
			int64_t v23 = 1LL /* True */;
			x11 = v23;
			x10 = x21;
			x9 = x20;
			x8 = x19;
		} break;
		case 0LL: { // None
			int64_t v24 = 0LL /* False */;
			x11 = v24;
			x10 = v7;
			x9 = v5;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v25 = x8;
	VAL v26 = x9;
	VAL v27 = x10;
	int64_t v28 = x11;
	while (((bool)v28)) {
		uint64_t v29 = v25;
		VAL v30 = v26;
		VAL v31 = v27;
		VAL v32;
		VAL v33;
		mw_std_list_List_1_uncons(v31, &v32, &v33);
		uint64_t x34;
		VAL x35;
		VAL x36;
		int64_t x37;
		switch (get_data_tag(v32)) {
			case 1LL: { // Some
				VAL v38 = mtp_std_maybe_Maybe_1_Some(v32);
				incref(v38);
				uint64_t v39 = mw_mirth_var_Var_name(VU64(v38));
				int64_t v40 = mw_mirth_name_Name_ZEqualZEqual(v29, v39);
				uint64_t x41;
				VAL x42;
				if (((bool)v40)) {
					VAL v43 = mtw_std_maybe_Maybe_1_Some(v38);
					x42 = v43;
					x41 = v29;
				} else {
					decref(v38);
					VAL v44 = MKI64(0LL /* None */);
					x42 = v44;
					x41 = v29;
				}
				uint64_t x45;
				VAL x46;
				VAL x47;
				switch (get_data_tag(x42)) {
					case 0LL: { // None
						x47 = v33;
						x46 = v30;
						x45 = x41;
					} break;
					default: {
						decref(v33);
						decref(v30);
						VAL v48 = MKI64(0LL /* Nil */);
						x47 = v48;
						x46 = x42;
						x45 = x41;
					} break;
				}
				int64_t v49 = 1LL /* True */;
				x37 = v49;
				x36 = x47;
				x35 = x46;
				x34 = x45;
			} break;
			case 0LL: { // None
				int64_t v50 = 0LL /* False */;
				x37 = v50;
				x36 = v33;
				x35 = v30;
				x34 = v29;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v28 = x37;
		v27 = x36;
		v26 = x35;
		v25 = x34;
	}
	decref(v27);
	return v26;
}
static void mw_mirth_var_Ctx_freshZ_nameZBang (VAL x1, VAL *x2, uint64_t *x3) {
	int64_t v4 = 1LL;
	STR* v5;
	STRLIT(v5, "_x1", 3);
	uint64_t v6 = mw_std_prim_Str_ZToName(MKSTR(v5));
	incref(x1);
	VAL v7 = mw_mirth_var_Ctx_lookup(v6, x1);
	VAL x8;
	VAL x9;
	uint64_t x10;
	int64_t x11;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v7);
			decref(v12);
			int64_t v13 = 1LL;
			int64_t v14 = i64_add(v4, v13);
			STR* v15;
			STRLIT(v15, "_x", 2);
			STR* v16 = i64_show(v14);
			STR* v17 = str_cat(v15, v16);
			uint64_t v18 = mw_std_prim_Str_ZToName(MKSTR(v17));
			int64_t v19 = 1LL /* True */;
			x11 = v19;
			x10 = v18;
			x9 = MKI64(v14);
			x8 = x1;
		} break;
		case 0LL: { // None
			int64_t v20 = 0LL /* False */;
			x11 = v20;
			x10 = v6;
			x9 = MKI64(v4);
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v21 = x8;
	VAL v22 = x9;
	uint64_t v23 = x10;
	int64_t v24 = x11;
	while (((bool)v24)) {
		VAL v25 = v21;
		VAL v26 = v22;
		uint64_t v27 = v23;
		incref(v25);
		VAL v28 = mw_mirth_var_Ctx_lookup(v27, v25);
		VAL x29;
		VAL x30;
		uint64_t x31;
		int64_t x32;
		switch (get_data_tag(v28)) {
			case 1LL: { // Some
				VAL v33 = mtp_std_maybe_Maybe_1_Some(v28);
				decref(v33);
				int64_t v34 = 1LL;
				int64_t v35 = i64_add(VI64(v26), v34);
				STR* v36;
				STRLIT(v36, "_x", 2);
				STR* v37 = i64_show(v35);
				STR* v38 = str_cat(v36, v37);
				uint64_t v39 = mw_std_prim_Str_ZToName(MKSTR(v38));
				int64_t v40 = 1LL /* True */;
				x32 = v40;
				x31 = v39;
				x30 = MKI64(v35);
				x29 = v25;
			} break;
			case 0LL: { // None
				int64_t v41 = 0LL /* False */;
				x32 = v41;
				x31 = v27;
				x30 = v26;
				x29 = v25;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v24 = x32;
		v23 = x31;
		v22 = x30;
		v21 = x29;
	}
	decref(v22);
	*x3 = v23;
	*x2 = v21;
}
static void mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang (VAL x1, VAL *x2, uint64_t *x3) {
	int64_t v4 = 1LL /* PRIM_TYPE_STACK */;
	VAL v5 = mtw_mirth_type_Type_TPrim(v4);
	VAL v6;
	uint64_t v7;
	mw_mirth_var_Ctx_freshZ_varZBang(v5, x1, &v6, &v7);
	*x3 = v7;
	*x2 = v6;
}
static void mw_mirth_var_Ctx_freshZ_typeZ_varZBang (VAL x1, VAL *x2, uint64_t *x3) {
	int64_t v4 = 0LL /* PRIM_TYPE_TYPE */;
	VAL v5 = mtw_mirth_type_Type_TPrim(v4);
	VAL v6;
	uint64_t v7;
	mw_mirth_var_Ctx_freshZ_varZBang(v5, x1, &v6, &v7);
	*x3 = v7;
	*x2 = v6;
}
static void mw_mirth_var_Ctx_freshZ_varZBang (VAL x1, VAL x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_var_Ctx_freshZ_nameZBang(x2, &v5, &v6);
	uint64_t v7 = mw_mirth_var_Var_newZBang(x1, v6);
	VAL v8 = mw_mirth_var_Ctx_new(v5, v7);
	*x4 = v7;
	*x3 = v8;
}
static void mw_mirth_var_Var_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7) {
	int64_t v8 = mw_mirth_var_Var_ZEqualZEqual(x3, x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	if (((bool)v8)) {
		VAL v12 = mtw_mirth_type_Type_TVar(x3);
		x11 = v12;
		x10 = x2;
		x9 = x1;
	} else {
		VAL v13 = mtw_mirth_type_Type_TVar(x3);
		VAL v14 = mtw_mirth_type_Type_TVar(x4);
		VAL v15;
		uint64_t v16;
		VAL v17;
		mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v13, v14, &v15, &v16, &v17);
		x11 = v17;
		x10 = v16;
		x9 = v15;
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_var_Var_freshen (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	incref(x1);
	int64_t v5 = mw_mirth_type_Subst_hasZ_varZAsk(x2, x1);
	VAL x6;
	VAL x7;
	if (((bool)v5)) {
		incref(x1);
		VAL v8 = mw_mirth_type_Subst_getZ_var(x2, x1);
		x7 = v8;
		x6 = x1;
	} else {
		uint64_t v9 = mw_mirth_type_MetaVar_newZBang();
		VAL v10 = mtw_mirth_type_Type_TMeta(v9);
		incref(v10);
		VAL v11 = mw_mirth_type_Subst_cons(v10, x2, x1);
		x7 = v10;
		x6 = v11;
	}
	*x4 = x7;
	*x3 = x6;
}
static int64_t mw_mirth_buffer_Buffer_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_buffer_Buffer_allocZBang (void) {
	void* v1 = mbuf_mirth_buffer_Buffer_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_buffer_Buffer_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static int64_t mw_mirth_buffer_Buffer_sizze (uint64_t x1) {
	void* v2 = mfld_mirth_buffer_Buffer_ZTildesizze(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static VAL mw_mirth_buffer_Buffer_qname (uint64_t x1) {
	void* v2 = mfld_mirth_buffer_Buffer_ZTildeqname(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_buffer_Buffer_name (uint64_t x1) {
	VAL v2 = mw_mirth_buffer_Buffer_qname(x1);
	uint64_t v3 = VU64(VTUP(v2)->cells[2]);
	decref(v2);
	return v3;
}
static int64_t mw_mirth_buffer_Buffer_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_buffer_Buffer_index(x1);
	int64_t v4 = mw_mirth_buffer_Buffer_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_buffer_Buffer_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, uint64_t *x6) {
	uint64_t v7 = mw_mirth_buffer_Buffer_allocZBang();
	void* v8 = mfld_mirth_buffer_Buffer_ZTildesizze(v7);
	mut_set(MKI64(x4), v8);
	void* v9 = mfld_mirth_buffer_Buffer_ZTildeqname(v7);
	mut_set(x3, v9);
	void* v10 = mfld_mirth_buffer_Buffer_ZTildehead(v7);
	mut_set(MKU64(x2), v10);
	VAL v11 = mtw_mirth_def_Def_DefBuffer(v7);
	VAL v12 = (mw_mirth_def_Def_register(x1, v11));
	*x6 = v7;
	*x5 = v12;
}
static int64_t mw_mirth_word_Word_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_word_Word_allocZBang (void) {
	void* v1 = mbuf_mirth_word_Word_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_word_Word_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_word_Word_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_word_Word_qnameZ_hard (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_word_Word_ZTildeqname(x1);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_word_Word_namespaceZ_hard (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_word_Word_qnameZ_hard(x1, x2, &v5, &v6);
	VAL v7 = VVAL(VTUP(v5)->cells[1]);
	incref(v7);
	decref(v5);
	*x4 = v6;
	*x3 = v7;
}
static uint64_t mw_mirth_word_Word_name (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static uint64_t mw_mirth_word_Word_head (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildehead(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_word_Word_sigZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildesigZAsk(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_word_Word_body (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildebody(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static int64_t mw_mirth_word_Word_arity (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildearity(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static void mw_mirth_word_Word_params (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_word_Word_ZTildeparams(x1);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_word_Word_arrow (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_word_Word_ZTildearrow(x1);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static int64_t mw_mirth_word_Word_inferringZ_typeZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	int64_t x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			x4 = VI64(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			x4 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_word_Word_cname (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_word_Word_ZTildecname(x1);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x1;
		x7 = x2;
	} else {
		VAL v11;
		VAL v12;
		mw_mirth_word_Word_qnameZ_hard(x1, x2, &v11, &v12);
		VAL v13;
		VAL v14;
		mw_mirth_name_QName_mangled(v12, v11, &v13, &v14);
		STR* v15;
		STRLIT(v15, "", 0);
		STR* v16;
		STRLIT(v16, "mw_", 3);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), MKSTR(v15)));
		VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(v14, v17));
		incref(v18);
		mut_set(v18, v5);
		x9 = v18;
		x8 = x1;
		x7 = v13;
	}
	*x4 = x7;
	*x3 = x9;
}
static void mw_mirth_word_Word_ctxZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	void* v6 = mfld_mirth_word_Word_ZTildectxZ_type(x1);
	VAL v7;
	VAL v8;
	mw_mirth_mirth_Prop_1_forceZBang(v6, x2, &v7, &v8);
	VAL v9;
	VAL v10;
	value_uncons(v7, &v9, &v10);
	VAL v11;
	VAL v12;
	value_uncons(v9, &v11, &v12);
	decref(v11);
	*x5 = v8;
	*x4 = v10;
	*x3 = v12;
}
static void mw_mirth_word_Word_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_word_Word_ctxZ_type(x1, x2, &v5, &v6, &v7);
	decref(v5);
	*x4 = v7;
	*x3 = v6;
}
static int64_t mw_mirth_word_Word_preferZ_inlineZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	int64_t x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			x4 = VI64(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			x4 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_word_Word_makeZ_inlineZBang (uint64_t x1) {
	int64_t v2 = 1LL /* True */;
	void* v3 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(x1);
	mut_set(MKI64(v2), v3);
}
static void mw_mirth_word_Word_newZBang (uint64_t x1, VAL x2, uint64_t x3, uint64_t x4, int64_t x5, VAL x6, uint64_t *x7, VAL *x8) {
	uint64_t v9 = mw_mirth_word_Word_allocZBang();
	void* v10 = mfld_mirth_word_Word_ZTildename(v9);
	mut_set(MKU64(x4), v10);
	void* v11 = mfld_mirth_word_Word_ZTildehead(v9);
	mut_set(MKU64(x1), v11);
	void* v12 = mfld_mirth_word_Word_ZTildebody(v9);
	mut_set(MKU64(x3), v12);
	void* v13 = mfld_mirth_word_Word_ZTildearity(v9);
	mut_set(MKI64(x5), v13);
	void* v14 = mfld_mirth_word_Word_ZTildesigZAsk(v9);
	mut_set(x2, v14);
	VAL v15 = mtw_mirth_def_Def_DefWord(v9);
	VAL v16 = (mw_mirth_def_Def_register(x6, v15));
	*x8 = v16;
	*x7 = v9;
}
static int64_t mw_mirth_word_Word_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_word_Word_index(x1);
	int64_t v4 = mw_mirth_word_Word_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static int64_t mw_mirth_word_Word_incZ_numZ_blocksZBang (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildenumZ_blocks(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	int64_t x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			incref(v5);
			int64_t v6 = 1LL;
			int64_t v7 = i64_add(VI64(v5), v6);
			void* v8 = mfld_mirth_word_Word_ZTildenumZ_blocks(x1);
			mut_set(MKI64(v7), v8);
			x4 = VI64(v5);
		} break;
		case 0LL: { // None
			int64_t v9 = 1LL;
			void* v10 = mfld_mirth_word_Word_ZTildenumZ_blocks(x1);
			mut_set(MKI64(v9), v10);
			int64_t v11 = 0LL;
			x4 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static int64_t mw_mirth_table_Table_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_table_Table_allocZBang (void) {
	void* v1 = mbuf_mirth_table_Table_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_table_Table_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_table_Table_head (uint64_t x1) {
	void* v2 = mfld_mirth_table_Table_ZTildehead(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_table_Table_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_table_Table_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_table_Table_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_table_Table_ZTildeqname(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static uint64_t mw_mirth_table_Table_name (uint64_t x1) {
	void* v2 = mfld_mirth_table_Table_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static uint64_t mw_mirth_table_Table_numZ_buffer (uint64_t x1) {
	void* v2 = mfld_mirth_table_Table_ZTildenumZ_buffer(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static int64_t mw_mirth_table_Table_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_table_Table_index(x1);
	int64_t v4 = mw_mirth_table_Table_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static int64_t mw_mirth_table_Field_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_table_Field_allocZBang (void) {
	void* v1 = mbuf_mirth_table_Field_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_table_Field_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_table_Field_head (uint64_t x1) {
	void* v2 = mfld_mirth_table_Field_ZTildehead(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static uint64_t mw_mirth_table_Field_name (uint64_t x1) {
	void* v2 = mfld_mirth_table_Field_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_table_Field_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_table_Field_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_table_Field_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_table_Field_ZTildeqname(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static void mw_mirth_table_Field_indexZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_table_Field_ZTildeindexZ_type(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static void mw_mirth_table_Field_valueZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_table_Field_ZTildevalueZ_type(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static void mw_mirth_table_Field_dom (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_table_Field_indexZ_type(x1, x2, &v5, &v6);
	VAL v7 = mw_mirth_type_T1(v6);
	*x4 = v7;
	*x3 = v5;
}
static void mw_mirth_table_Field_cod (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_table_Field_valueZ_type(x1, x2, &v5, &v6);
	VAL v7 = mtw_mirth_type_Type_TMut(v6);
	VAL v8 = mw_mirth_type_T1(v7);
	*x4 = v8;
	*x3 = v5;
}
static void mw_mirth_table_Field_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_table_Field_dom(x1, x2, &v5, &v6);
	VAL v7;
	VAL v8;
	mw_mirth_table_Field_cod(v5, x2, &v7, &v8);
	VAL v9 = mw_mirth_type_TZ_ZTo(v6, v8);
	*x4 = v9;
	*x3 = v7;
}
static int64_t mw_mirth_table_Field_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_table_Field_index(x1);
	int64_t v4 = mw_mirth_table_Field_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_tycon_Tycon_qnameZ_hard (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			uint64_t v7 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			VAL v8;
			VAL v9;
			mw_mirth_data_Data_qnameZ_hard(x1, v7, &v8, &v9);
			x6 = v9;
			x5 = v8;
		} break;
		case 1LL: { // TYCON_TABLE
			uint64_t v10 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			VAL v11;
			VAL v12;
			mw_mirth_table_Table_qnameZ_hard(x1, v10, &v11, &v12);
			x6 = v12;
			x5 = v11;
		} break;
		case 2LL: { // TYCON_PRIM
			int64_t v13 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			VAL v14;
			VAL v15;
			mw_mirth_type_PrimType_tyconZ_qname(x1, v13, &v14, &v15);
			x6 = v15;
			x5 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static int64_t mw_mirth_tycon_Tycon_ZEqualZEqual (VAL x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			uint64_t v4 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			int64_t x5;
			switch (get_data_tag(x1)) {
				case 0LL: { // TYCON_DATA
					uint64_t v6 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x1);
					int64_t v7 = mw_mirth_data_Data_ZEqualZEqual(v4, v6);
					x5 = v7;
				} break;
				default: {
					decref(x1);
					int64_t v8 = 0LL /* False */;
					x5 = v8;
				} break;
			}
			x3 = x5;
		} break;
		case 1LL: { // TYCON_TABLE
			uint64_t v9 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			int64_t x10;
			switch (get_data_tag(x1)) {
				case 1LL: { // TYCON_TABLE
					uint64_t v11 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x1);
					int64_t v12 = mw_mirth_table_Table_ZEqualZEqual(v9, v11);
					x10 = v12;
				} break;
				default: {
					decref(x1);
					int64_t v13 = 0LL /* False */;
					x10 = v13;
				} break;
			}
			x3 = x10;
		} break;
		case 2LL: { // TYCON_PRIM
			int64_t v14 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			int64_t x15;
			switch (get_data_tag(x1)) {
				case 2LL: { // TYCON_PRIM
					int64_t v16 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x1);
					int64_t v17 = mw_mirth_type_PrimType_ZEqualZEqual(v14, v16);
					x15 = v17;
				} break;
				default: {
					decref(x1);
					int64_t v18 = 0LL /* False */;
					x15 = v18;
				} break;
			}
			x3 = x15;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_tycon_Tycon_fullZ_typeZ_fresh (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			uint64_t v7 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			VAL v8 = MKI64(0LL /* SUBST_NIL */);
			VAL v9;
			VAL v10;
			mw_mirth_data_Data_fullZ_type(x1, v7, &v9, &v10);
			VAL x11;
			VAL x12;
			VAL x13;
			switch (get_data_tag(v10)) {
				case 0LL: { // Left
					VAL v14 = mtp_std_either_Either_2_Left(v10);
					VAL v15;
					VAL v16;
					mw_mirth_type_Type_freshen(v8, v14, &v15, &v16);
					VAL v17 = mtw_std_either_Either_2_Left(v16);
					x13 = v17;
					x12 = v15;
					x11 = v9;
				} break;
				case 1LL: { // Right
					VAL v18 = mtp_std_either_Either_2_Right(v10);
					VAL v19;
					VAL v20;
					mw_mirth_type_Resource_freshen(v8, v18, &v19, &v20);
					VAL v21 = mtw_std_either_Either_2_Right(v20);
					x13 = v21;
					x12 = v19;
					x11 = v9;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x12);
			x6 = x13;
			x5 = x11;
		} break;
		case 2LL: { // TYCON_PRIM
			int64_t v22 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			int64_t v23 = mw_mirth_type_PrimType_isZ_resourceZAsk(v22);
			VAL x24;
			VAL x25;
			if (((bool)v23)) {
				VAL v26 = mtw_mirth_type_Type_TPrim(v22);
				VAL v27 = mtw_std_either_Either_2_Right(v26);
				x25 = v27;
				x24 = x1;
			} else {
				VAL v28 = mtw_mirth_type_Type_TPrim(v22);
				VAL v29 = mtw_std_either_Either_2_Left(v28);
				x25 = v29;
				x24 = x1;
			}
			x6 = x25;
			x5 = x24;
		} break;
		case 1LL: { // TYCON_TABLE
			uint64_t v30 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			VAL v31 = mtw_mirth_type_Type_TTable(v30);
			VAL v32 = mtw_std_either_Either_2_Left(v31);
			x6 = v32;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static int64_t mw_mirth_data_Data_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_data_Data_allocZBang (void) {
	void* v1 = mbuf_mirth_data_Data_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_data_Data_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_data_Data_headZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildeheadZAsk(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_data_Data_name (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_data_Data_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_data_Data_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Data_ZTildeqname(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static int64_t mw_mirth_data_Data_arity (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildearity(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static void mw_mirth_data_Data_params (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Data_ZTildeparams(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static VAL mw_mirth_data_Data_tags (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildetags(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static void mw_mirth_data_Data_ctypeZAsk (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Data_ZTildectypeZAsk(x1);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_data_TYPEz_BOOL (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[3]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_U64 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[6]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_U32 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[8]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_U16 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[10]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_U8 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[12]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_I64 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[14]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_I32 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[16]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_I16 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[18]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_data_TYPEz_I8 (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[20]);
	decref(v4);
	VAL v6 = mtw_mirth_type_Type_TData(v5);
	*x3 = v6;
	*x2 = x1;
}
static VAL mw_mirth_data_makeZ_primZ_dataZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5, VAL x6) {
	incref(x3);
	int64_t v7 = mw_std_list_List_1_len(x3);
	void* v8 = mfld_mirth_data_Data_ZTildearity(x4);
	mut_set(MKI64(v7), v8);
	incref(x2);
	uint64_t v9 = mw_std_prim_Str_ZToName(x2);
	void* v10 = mfld_mirth_data_Data_ZTildename(x4);
	mut_set(MKU64(v9), v10);
	VAL v11;
	VAL v12;
	mw_mirth_name_QName_prim(x1, x2, v7, &v11, &v12);
	VAL v13 = mtw_mirth_mirth_PropLabel_DataQName(x4);
	VAL v14;
	VAL v15;
	mw_mirth_mirth_PropLabel_prop(v12, v13, v11, &v14, &v15);
	void* v16 = mfld_mirth_data_Data_ZTildeqname(x4);
	mut_set(v14, v16);
	VAL v17 = mtw_mirth_mirth_PropLabel_DataCType(x4);
	VAL v18;
	VAL v19;
	mw_mirth_mirth_PropLabel_prop(x6, v17, v15, &v18, &v19);
	void* v20 = mfld_mirth_data_Data_ZTildectypeZAsk(x4);
	mut_set(v18, v20);
	incref(x5);
	VAL v21;
	VAL v22;
	mw_std_list_List_1_uncons(x5, &v21, &v22);
	VAL x23;
	VAL x24;
	uint64_t x25;
	VAL x26;
	VAL x27;
	int64_t x28;
	switch (get_data_tag(v21)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(v21);
			void* v30 = mfld_mirth_data_Tag_ZTildedata(VU64(v29));
			mut_set(MKU64(x4), v30);
			int64_t v31 = 1LL /* True */;
			x28 = v31;
			x27 = v22;
			x26 = x5;
			x25 = x4;
			x24 = v19;
			x23 = x3;
		} break;
		case 0LL: { // None
			int64_t v32 = 0LL /* False */;
			x28 = v32;
			x27 = v22;
			x26 = x5;
			x25 = x4;
			x24 = v19;
			x23 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v33 = x23;
	VAL v34 = (x24);
	uint64_t v35 = x25;
	VAL v36 = x26;
	VAL v37 = x27;
	int64_t v38 = x28;
	while (((bool)v38)) {
		VAL v39 = v33;
		VAL v40 = (v34);
		uint64_t v41 = v35;
		VAL v42 = v36;
		VAL v43 = v37;
		VAL v44;
		VAL v45;
		mw_std_list_List_1_uncons(v43, &v44, &v45);
		VAL x46;
		VAL x47;
		uint64_t x48;
		VAL x49;
		VAL x50;
		int64_t x51;
		switch (get_data_tag(v44)) {
			case 1LL: { // Some
				VAL v52 = mtp_std_maybe_Maybe_1_Some(v44);
				void* v53 = mfld_mirth_data_Tag_ZTildedata(VU64(v52));
				mut_set(MKU64(v41), v53);
				int64_t v54 = 1LL /* True */;
				x51 = v54;
				x50 = v45;
				x49 = v42;
				x48 = v41;
				x47 = v40;
				x46 = v39;
			} break;
			case 0LL: { // None
				int64_t v55 = 0LL /* False */;
				x51 = v55;
				x50 = v45;
				x49 = v42;
				x48 = v41;
				x47 = v40;
				x46 = v39;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v38 = x51;
		v37 = x50;
		v36 = x49;
		v35 = x48;
		v34 = x47;
		v33 = x46;
	}
	decref(v37);
	void* v56 = mfld_mirth_data_Data_ZTildetags(v35);
	mut_set(v36, v56);
	VAL v57 = mtw_mirth_mirth_PropLabel_DataParams(v35);
	VAL v58;
	VAL v59;
	mw_mirth_mirth_PropLabel_prop(v33, v57, v34, &v58, &v59);
	void* v60 = mfld_mirth_data_Data_ZTildeparams(v35);
	mut_set(v58, v60);
	VAL v61 = MKI64(0LL /* None */);
	void* v62 = mfld_mirth_data_Data_ZTildeheadZAsk(v35);
	mut_set(v61, v62);
	VAL v63 = mtw_mirth_def_Def_DefData(v35);
	VAL v64 = (mw_mirth_def_Def_register(v59, v63));
	return v64;
}
static VAL mw_mirth_data_makeZ_primZ_tagZBang (VAL x1, VAL x2, int64_t x3, VAL x4, uint64_t x5) {
	uint64_t v6 = mw_mirth_data_Tag_data(x5);
	int64_t v7 = 0LL;
	VAL v8 = mw_mirth_data_dataZ_wordZ_qname(v6, x2, v7);
	void* v9 = mfld_mirth_data_Tag_ZTildeqname(x5);
	mut_set(v8, v9);
	void* v10 = mfld_mirth_data_Tag_ZTildevalue(x5);
	mut_set(MKI64(x3), v10);
	incref(x4);
	int64_t v11 = mw_std_list_List_1_len(x4);
	void* v12 = mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs(x5);
	mut_set(MKI64(v11), v12);
	int64_t v13 = 0LL;
	void* v14 = mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs(x5);
	mut_set(MKI64(v13), v14);
	VAL v15 = MKI64(0LL /* Nil */);
	void* v16 = mfld_mirth_data_Tag_ZTildelabelZ_inputs(x5);
	mut_set(v15, v16);
	uint64_t v17 = mw_mirth_data_Tag_data(x5);
	VAL v18;
	VAL v19;
	mw_mirth_data_Data_params(x1, v17, &v18, &v19);
	VAL v20 = mw_std_list_List_1_ZToCtx(v19);
	VAL v21 = mw_mirth_type_TT(x4);
	VAL v22 = mw_mirth_type_T0();
	uint64_t v23 = mw_mirth_data_Tag_data(x5);
	VAL v24;
	VAL v25;
	mw_mirth_data_Data_fullZ_type(v18, v23, &v24, &v25);
	VAL v26 = mw_mirth_type_TZMulZPlus(v22, v25);
	VAL v27 = mw_mirth_type_TZ_ZTo(v21, v26);
	VAL v28 = mtw_mirth_mirth_PropLabel_TagType(x5);
	VAL v29;
	VAL v30;
	mw_mirth_mirth_PropLabel_prop2(v20, v27, v28, v24, &v29, &v30);
	void* v31 = mfld_mirth_data_Tag_ZTildectxZ_type(x5);
	mut_set(v29, v31);
	VAL v32 = mtw_mirth_def_Def_DefTag(x5);
	VAL v33 = (mw_mirth_def_Def_register(v30, v32));
	return v33;
}
static VAL mw_mirth_data_makeZ_primZ_intlikeZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL x5, VAL x6) {
	VAL v7 = MKI64(0LL /* Nil */);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mtw_std_list_List_1_Cons(MKU64(x4), v8);
	VAL v10 = mtw_mirth_type_CType_IntLike(x5);
	VAL v11 = mtw_std_maybe_Maybe_1_Some(v10);
	VAL v12 = (mw_mirth_data_makeZ_primZ_dataZBang(x6, x1, v7, x2, v9, v11));
	int64_t v13 = 0LL;
	VAL v14 = mw_mirth_type_TYPEz_INT();
	VAL v15 = MKI64(0LL /* Nil */);
	VAL v16 = mtw_std_list_List_1_Cons(v14, v15);
	VAL v17 = (mw_mirth_data_makeZ_primZ_tagZBang(v12, x3, v13, v16, x4));
	return v17;
}
static VAL mw_mirth_data_initZ_dataZBang (VAL x1) {
	STR* v2;
	STRLIT(v2, "Bool", 4);
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[3]);
	decref(v4);
	VAL v6 = VVAL(VTUP(x1)->cells[4]);
	incref(v6);
	uint64_t v7 = VU64(VTUP(v6)->cells[4]);
	decref(v6);
	VAL v8 = VVAL(VTUP(x1)->cells[4]);
	incref(v8);
	uint64_t v9 = VU64(VTUP(v8)->cells[5]);
	decref(v8);
	VAL v10 = MKI64(0LL /* Nil */);
	VAL v11 = mtw_std_list_List_1_Cons(MKU64(v9), v10);
	VAL v12 = mtw_std_list_List_1_Cons(MKU64(v7), v11);
	STR* v13;
	STRLIT(v13, "_Bool", 5);
	VAL v14 = mtw_mirth_type_CType_IntLike(MKSTR(v13));
	VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
	VAL v16 = (mw_mirth_data_makeZ_primZ_dataZBang(x1, MKSTR(v2), v3, v5, v12, v15));
	STR* v17;
	STRLIT(v17, "False", 5);
	int64_t v18 = 0LL;
	VAL v19 = MKI64(0LL /* Nil */);
	VAL v20 = VVAL(VTUP(v16)->cells[4]);
	incref(v20);
	uint64_t v21 = VU64(VTUP(v20)->cells[5]);
	decref(v20);
	VAL v22 = (mw_mirth_data_makeZ_primZ_tagZBang(v16, MKSTR(v17), v18, v19, v21));
	STR* v23;
	STRLIT(v23, "True", 4);
	int64_t v24 = 1LL;
	VAL v25 = MKI64(0LL /* Nil */);
	VAL v26 = VVAL(VTUP(v22)->cells[4]);
	incref(v26);
	uint64_t v27 = VU64(VTUP(v26)->cells[4]);
	decref(v26);
	VAL v28 = (mw_mirth_data_makeZ_primZ_tagZBang(v22, MKSTR(v23), v24, v25, v27));
	VAL v29 = mw_mirth_type_TYPEz_TYPE();
	STR* v30;
	STRLIT(v30, "a", 1);
	uint64_t v31 = mw_std_prim_Str_ZToName(MKSTR(v30));
	uint64_t v32 = mw_mirth_var_Var_newZBang(v29, v31);
	STR* v33;
	STRLIT(v33, "CPtr", 4);
	VAL v34 = MKI64(0LL /* Nil */);
	VAL v35 = mtw_std_list_List_1_Cons(MKU64(v32), v34);
	VAL v36 = VVAL(VTUP(v28)->cells[4]);
	incref(v36);
	uint64_t v37 = VU64(VTUP(v36)->cells[52]);
	decref(v36);
	VAL v38 = VVAL(VTUP(v28)->cells[4]);
	incref(v38);
	uint64_t v39 = VU64(VTUP(v38)->cells[53]);
	decref(v38);
	VAL v40 = MKI64(0LL /* Nil */);
	VAL v41 = mtw_std_list_List_1_Cons(MKU64(v39), v40);
	VAL v42 = MKI64(0LL /* None */);
	VAL v43 = (mw_mirth_data_makeZ_primZ_dataZBang(v28, MKSTR(v33), v35, v37, v41, v42));
	STR* v44;
	STRLIT(v44, "CPtr", 4);
	int64_t v45 = 0LL;
	VAL v46 = mw_mirth_type_TYPEz_PTR();
	VAL v47 = MKI64(0LL /* Nil */);
	VAL v48 = mtw_std_list_List_1_Cons(v46, v47);
	VAL v49 = VVAL(VTUP(v43)->cells[4]);
	incref(v49);
	uint64_t v50 = VU64(VTUP(v49)->cells[53]);
	decref(v49);
	VAL v51 = (mw_mirth_data_makeZ_primZ_tagZBang(v43, MKSTR(v44), v45, v48, v50));
	STR* v52;
	STRLIT(v52, "CConst", 6);
	VAL v53 = MKI64(0LL /* Nil */);
	VAL v54 = mtw_std_list_List_1_Cons(MKU64(v32), v53);
	VAL v55 = VVAL(VTUP(v51)->cells[4]);
	incref(v55);
	uint64_t v56 = VU64(VTUP(v55)->cells[54]);
	decref(v55);
	VAL v57 = VVAL(VTUP(v51)->cells[4]);
	incref(v57);
	uint64_t v58 = VU64(VTUP(v57)->cells[55]);
	decref(v57);
	VAL v59 = MKI64(0LL /* Nil */);
	VAL v60 = mtw_std_list_List_1_Cons(MKU64(v58), v59);
	VAL v61 = MKI64(0LL /* None */);
	VAL v62 = (mw_mirth_data_makeZ_primZ_dataZBang(v51, MKSTR(v52), v54, v56, v60, v61));
	STR* v63;
	STRLIT(v63, "CConst", 6);
	int64_t v64 = 0LL;
	VAL v65 = mtw_mirth_type_Type_TVar(v32);
	VAL v66 = MKI64(0LL /* Nil */);
	VAL v67 = mtw_std_list_List_1_Cons(v65, v66);
	VAL v68 = VVAL(VTUP(v62)->cells[4]);
	incref(v68);
	uint64_t v69 = VU64(VTUP(v68)->cells[55]);
	decref(v68);
	VAL v70 = (mw_mirth_data_makeZ_primZ_tagZBang(v62, MKSTR(v63), v64, v67, v69));
	STR* v71;
	STRLIT(v71, "CRestrict", 9);
	VAL v72 = MKI64(0LL /* Nil */);
	VAL v73 = mtw_std_list_List_1_Cons(MKU64(v32), v72);
	VAL v74 = VVAL(VTUP(v70)->cells[4]);
	incref(v74);
	uint64_t v75 = VU64(VTUP(v74)->cells[56]);
	decref(v74);
	VAL v76 = VVAL(VTUP(v70)->cells[4]);
	incref(v76);
	uint64_t v77 = VU64(VTUP(v76)->cells[57]);
	decref(v76);
	VAL v78 = MKI64(0LL /* Nil */);
	VAL v79 = mtw_std_list_List_1_Cons(MKU64(v77), v78);
	VAL v80 = MKI64(0LL /* None */);
	VAL v81 = (mw_mirth_data_makeZ_primZ_dataZBang(v70, MKSTR(v71), v73, v75, v79, v80));
	STR* v82;
	STRLIT(v82, "CRestrict", 9);
	int64_t v83 = 0LL;
	VAL v84 = mtw_mirth_type_Type_TVar(v32);
	VAL v85 = MKI64(0LL /* Nil */);
	VAL v86 = mtw_std_list_List_1_Cons(v84, v85);
	VAL v87 = VVAL(VTUP(v81)->cells[4]);
	incref(v87);
	uint64_t v88 = VU64(VTUP(v87)->cells[57]);
	decref(v87);
	VAL v89 = (mw_mirth_data_makeZ_primZ_tagZBang(v81, MKSTR(v82), v83, v86, v88));
	STR* v90;
	STRLIT(v90, "CVolatile", 9);
	VAL v91 = MKI64(0LL /* Nil */);
	VAL v92 = mtw_std_list_List_1_Cons(MKU64(v32), v91);
	VAL v93 = VVAL(VTUP(v89)->cells[4]);
	incref(v93);
	uint64_t v94 = VU64(VTUP(v93)->cells[58]);
	decref(v93);
	VAL v95 = VVAL(VTUP(v89)->cells[4]);
	incref(v95);
	uint64_t v96 = VU64(VTUP(v95)->cells[59]);
	decref(v95);
	VAL v97 = MKI64(0LL /* Nil */);
	VAL v98 = mtw_std_list_List_1_Cons(MKU64(v96), v97);
	VAL v99 = MKI64(0LL /* None */);
	VAL v100 = (mw_mirth_data_makeZ_primZ_dataZBang(v89, MKSTR(v90), v92, v94, v98, v99));
	STR* v101;
	STRLIT(v101, "CVolatile", 9);
	int64_t v102 = 0LL;
	VAL v103 = mtw_mirth_type_Type_TVar(v32);
	VAL v104 = MKI64(0LL /* Nil */);
	VAL v105 = mtw_std_list_List_1_Cons(v103, v104);
	VAL v106 = VVAL(VTUP(v100)->cells[4]);
	incref(v106);
	uint64_t v107 = VU64(VTUP(v106)->cells[59]);
	decref(v106);
	VAL v108 = (mw_mirth_data_makeZ_primZ_tagZBang(v100, MKSTR(v101), v102, v105, v107));
	STR* v109;
	STRLIT(v109, "CVoid", 5);
	VAL v110 = MKI64(0LL /* Nil */);
	VAL v111 = VVAL(VTUP(v108)->cells[4]);
	incref(v111);
	uint64_t v112 = VU64(VTUP(v111)->cells[60]);
	decref(v111);
	VAL v113 = VVAL(VTUP(v108)->cells[4]);
	incref(v113);
	uint64_t v114 = VU64(VTUP(v113)->cells[61]);
	decref(v113);
	VAL v115 = MKI64(0LL /* Nil */);
	VAL v116 = mtw_std_list_List_1_Cons(MKU64(v114), v115);
	VAL v117 = MKI64(5LL /* Phantom */);
	VAL v118 = mtw_std_maybe_Maybe_1_Some(v117);
	VAL v119 = (mw_mirth_data_makeZ_primZ_dataZBang(v108, MKSTR(v109), v110, v112, v116, v118));
	STR* v120;
	STRLIT(v120, "CVoid", 5);
	int64_t v121 = 0LL;
	VAL v122 = MKI64(0LL /* Nil */);
	VAL v123 = VVAL(VTUP(v119)->cells[4]);
	incref(v123);
	uint64_t v124 = VU64(VTUP(v123)->cells[61]);
	decref(v123);
	VAL v125 = (mw_mirth_data_makeZ_primZ_tagZBang(v119, MKSTR(v120), v121, v122, v124));
	STR* v126;
	STRLIT(v126, "U64", 3);
	VAL v127 = VVAL(VTUP(v125)->cells[4]);
	incref(v127);
	uint64_t v128 = VU64(VTUP(v127)->cells[6]);
	decref(v127);
	STR* v129;
	STRLIT(v129, "Int>U64-unsafe", 14);
	VAL v130 = VVAL(VTUP(v125)->cells[4]);
	incref(v130);
	uint64_t v131 = VU64(VTUP(v130)->cells[7]);
	decref(v130);
	STR* v132;
	STRLIT(v132, "uint64_t", 8);
	VAL v133 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v126), v128, MKSTR(v129), v131, MKSTR(v132), v125));
	STR* v134;
	STRLIT(v134, "U32", 3);
	VAL v135 = VVAL(VTUP(v133)->cells[4]);
	incref(v135);
	uint64_t v136 = VU64(VTUP(v135)->cells[8]);
	decref(v135);
	STR* v137;
	STRLIT(v137, "Int>U32-unsafe", 14);
	VAL v138 = VVAL(VTUP(v133)->cells[4]);
	incref(v138);
	uint64_t v139 = VU64(VTUP(v138)->cells[9]);
	decref(v138);
	STR* v140;
	STRLIT(v140, "uint32_t", 8);
	VAL v141 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v134), v136, MKSTR(v137), v139, MKSTR(v140), v133));
	STR* v142;
	STRLIT(v142, "U16", 3);
	VAL v143 = VVAL(VTUP(v141)->cells[4]);
	incref(v143);
	uint64_t v144 = VU64(VTUP(v143)->cells[10]);
	decref(v143);
	STR* v145;
	STRLIT(v145, "Int>U16-unsafe", 14);
	VAL v146 = VVAL(VTUP(v141)->cells[4]);
	incref(v146);
	uint64_t v147 = VU64(VTUP(v146)->cells[11]);
	decref(v146);
	STR* v148;
	STRLIT(v148, "uint16_t", 8);
	VAL v149 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v142), v144, MKSTR(v145), v147, MKSTR(v148), v141));
	STR* v150;
	STRLIT(v150, "U8", 2);
	VAL v151 = VVAL(VTUP(v149)->cells[4]);
	incref(v151);
	uint64_t v152 = VU64(VTUP(v151)->cells[12]);
	decref(v151);
	STR* v153;
	STRLIT(v153, "Int>U8-unsafe", 13);
	VAL v154 = VVAL(VTUP(v149)->cells[4]);
	incref(v154);
	uint64_t v155 = VU64(VTUP(v154)->cells[13]);
	decref(v154);
	STR* v156;
	STRLIT(v156, "uint8_t", 7);
	VAL v157 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v150), v152, MKSTR(v153), v155, MKSTR(v156), v149));
	STR* v158;
	STRLIT(v158, "I64", 3);
	VAL v159 = VVAL(VTUP(v157)->cells[4]);
	incref(v159);
	uint64_t v160 = VU64(VTUP(v159)->cells[14]);
	decref(v159);
	STR* v161;
	STRLIT(v161, "Int>I64-unsafe", 14);
	VAL v162 = VVAL(VTUP(v157)->cells[4]);
	incref(v162);
	uint64_t v163 = VU64(VTUP(v162)->cells[15]);
	decref(v162);
	STR* v164;
	STRLIT(v164, "int64_t", 7);
	VAL v165 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v158), v160, MKSTR(v161), v163, MKSTR(v164), v157));
	STR* v166;
	STRLIT(v166, "I32", 3);
	VAL v167 = VVAL(VTUP(v165)->cells[4]);
	incref(v167);
	uint64_t v168 = VU64(VTUP(v167)->cells[16]);
	decref(v167);
	STR* v169;
	STRLIT(v169, "Int>I32-unsafe", 14);
	VAL v170 = VVAL(VTUP(v165)->cells[4]);
	incref(v170);
	uint64_t v171 = VU64(VTUP(v170)->cells[17]);
	decref(v170);
	STR* v172;
	STRLIT(v172, "int32_t", 7);
	VAL v173 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v166), v168, MKSTR(v169), v171, MKSTR(v172), v165));
	STR* v174;
	STRLIT(v174, "I16", 3);
	VAL v175 = VVAL(VTUP(v173)->cells[4]);
	incref(v175);
	uint64_t v176 = VU64(VTUP(v175)->cells[18]);
	decref(v175);
	STR* v177;
	STRLIT(v177, "Int>I16-unsafe", 14);
	VAL v178 = VVAL(VTUP(v173)->cells[4]);
	incref(v178);
	uint64_t v179 = VU64(VTUP(v178)->cells[19]);
	decref(v178);
	STR* v180;
	STRLIT(v180, "int16_t", 7);
	VAL v181 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v174), v176, MKSTR(v177), v179, MKSTR(v180), v173));
	STR* v182;
	STRLIT(v182, "I8", 2);
	VAL v183 = VVAL(VTUP(v181)->cells[4]);
	incref(v183);
	uint64_t v184 = VU64(VTUP(v183)->cells[20]);
	decref(v183);
	STR* v185;
	STRLIT(v185, "Int>I8-unsafe", 13);
	VAL v186 = VVAL(VTUP(v181)->cells[4]);
	incref(v186);
	uint64_t v187 = VU64(VTUP(v186)->cells[21]);
	decref(v186);
	STR* v188;
	STRLIT(v188, "int8_t", 6);
	VAL v189 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v182), v184, MKSTR(v185), v187, MKSTR(v188), v181));
	STR* v190;
	STRLIT(v190, "CChar", 5);
	VAL v191 = VVAL(VTUP(v189)->cells[4]);
	incref(v191);
	uint64_t v192 = VU64(VTUP(v191)->cells[22]);
	decref(v191);
	STR* v193;
	STRLIT(v193, "CChar", 5);
	VAL v194 = VVAL(VTUP(v189)->cells[4]);
	incref(v194);
	uint64_t v195 = VU64(VTUP(v194)->cells[23]);
	decref(v194);
	STR* v196;
	STRLIT(v196, "char", 4);
	VAL v197 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v190), v192, MKSTR(v193), v195, MKSTR(v196), v189));
	STR* v198;
	STRLIT(v198, "CIChar", 6);
	VAL v199 = VVAL(VTUP(v197)->cells[4]);
	incref(v199);
	uint64_t v200 = VU64(VTUP(v199)->cells[24]);
	decref(v199);
	STR* v201;
	STRLIT(v201, "CIChar", 6);
	VAL v202 = VVAL(VTUP(v197)->cells[4]);
	incref(v202);
	uint64_t v203 = VU64(VTUP(v202)->cells[25]);
	decref(v202);
	STR* v204;
	STRLIT(v204, "signed char", 11);
	VAL v205 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v198), v200, MKSTR(v201), v203, MKSTR(v204), v197));
	STR* v206;
	STRLIT(v206, "CShort", 6);
	VAL v207 = VVAL(VTUP(v205)->cells[4]);
	incref(v207);
	uint64_t v208 = VU64(VTUP(v207)->cells[26]);
	decref(v207);
	STR* v209;
	STRLIT(v209, "CShort", 6);
	VAL v210 = VVAL(VTUP(v205)->cells[4]);
	incref(v210);
	uint64_t v211 = VU64(VTUP(v210)->cells[27]);
	decref(v210);
	STR* v212;
	STRLIT(v212, "short", 5);
	VAL v213 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v206), v208, MKSTR(v209), v211, MKSTR(v212), v205));
	STR* v214;
	STRLIT(v214, "CInt", 4);
	VAL v215 = VVAL(VTUP(v213)->cells[4]);
	incref(v215);
	uint64_t v216 = VU64(VTUP(v215)->cells[28]);
	decref(v215);
	STR* v217;
	STRLIT(v217, "CInt", 4);
	VAL v218 = VVAL(VTUP(v213)->cells[4]);
	incref(v218);
	uint64_t v219 = VU64(VTUP(v218)->cells[29]);
	decref(v218);
	STR* v220;
	STRLIT(v220, "int", 3);
	VAL v221 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v214), v216, MKSTR(v217), v219, MKSTR(v220), v213));
	STR* v222;
	STRLIT(v222, "CLong", 5);
	VAL v223 = VVAL(VTUP(v221)->cells[4]);
	incref(v223);
	uint64_t v224 = VU64(VTUP(v223)->cells[30]);
	decref(v223);
	STR* v225;
	STRLIT(v225, "CLong", 5);
	VAL v226 = VVAL(VTUP(v221)->cells[4]);
	incref(v226);
	uint64_t v227 = VU64(VTUP(v226)->cells[31]);
	decref(v226);
	STR* v228;
	STRLIT(v228, "long", 4);
	VAL v229 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v222), v224, MKSTR(v225), v227, MKSTR(v228), v221));
	STR* v230;
	STRLIT(v230, "CLongLong", 9);
	VAL v231 = VVAL(VTUP(v229)->cells[4]);
	incref(v231);
	uint64_t v232 = VU64(VTUP(v231)->cells[32]);
	decref(v231);
	STR* v233;
	STRLIT(v233, "CLongLong", 9);
	VAL v234 = VVAL(VTUP(v229)->cells[4]);
	incref(v234);
	uint64_t v235 = VU64(VTUP(v234)->cells[33]);
	decref(v234);
	STR* v236;
	STRLIT(v236, "long long", 9);
	VAL v237 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v230), v232, MKSTR(v233), v235, MKSTR(v236), v229));
	STR* v238;
	STRLIT(v238, "CISize", 6);
	VAL v239 = VVAL(VTUP(v237)->cells[4]);
	incref(v239);
	uint64_t v240 = VU64(VTUP(v239)->cells[34]);
	decref(v239);
	STR* v241;
	STRLIT(v241, "CISize", 6);
	VAL v242 = VVAL(VTUP(v237)->cells[4]);
	incref(v242);
	uint64_t v243 = VU64(VTUP(v242)->cells[35]);
	decref(v242);
	STR* v244;
	STRLIT(v244, "ssize_t", 7);
	VAL v245 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v238), v240, MKSTR(v241), v243, MKSTR(v244), v237));
	STR* v246;
	STRLIT(v246, "CIntPtr", 7);
	VAL v247 = VVAL(VTUP(v245)->cells[4]);
	incref(v247);
	uint64_t v248 = VU64(VTUP(v247)->cells[36]);
	decref(v247);
	STR* v249;
	STRLIT(v249, "CIntPtr", 7);
	VAL v250 = VVAL(VTUP(v245)->cells[4]);
	incref(v250);
	uint64_t v251 = VU64(VTUP(v250)->cells[37]);
	decref(v250);
	STR* v252;
	STRLIT(v252, "intptr_t", 8);
	VAL v253 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v246), v248, MKSTR(v249), v251, MKSTR(v252), v245));
	STR* v254;
	STRLIT(v254, "CUChar", 6);
	VAL v255 = VVAL(VTUP(v253)->cells[4]);
	incref(v255);
	uint64_t v256 = VU64(VTUP(v255)->cells[38]);
	decref(v255);
	STR* v257;
	STRLIT(v257, "CUChar", 6);
	VAL v258 = VVAL(VTUP(v253)->cells[4]);
	incref(v258);
	uint64_t v259 = VU64(VTUP(v258)->cells[39]);
	decref(v258);
	STR* v260;
	STRLIT(v260, "unsigned char", 13);
	VAL v261 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v254), v256, MKSTR(v257), v259, MKSTR(v260), v253));
	STR* v262;
	STRLIT(v262, "CUShort", 7);
	VAL v263 = VVAL(VTUP(v261)->cells[4]);
	incref(v263);
	uint64_t v264 = VU64(VTUP(v263)->cells[40]);
	decref(v263);
	STR* v265;
	STRLIT(v265, "CUShort", 7);
	VAL v266 = VVAL(VTUP(v261)->cells[4]);
	incref(v266);
	uint64_t v267 = VU64(VTUP(v266)->cells[41]);
	decref(v266);
	STR* v268;
	STRLIT(v268, "unsigned short", 14);
	VAL v269 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v262), v264, MKSTR(v265), v267, MKSTR(v268), v261));
	STR* v270;
	STRLIT(v270, "CUInt", 5);
	VAL v271 = VVAL(VTUP(v269)->cells[4]);
	incref(v271);
	uint64_t v272 = VU64(VTUP(v271)->cells[42]);
	decref(v271);
	STR* v273;
	STRLIT(v273, "CUInt", 5);
	VAL v274 = VVAL(VTUP(v269)->cells[4]);
	incref(v274);
	uint64_t v275 = VU64(VTUP(v274)->cells[43]);
	decref(v274);
	STR* v276;
	STRLIT(v276, "unsigned int", 12);
	VAL v277 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v270), v272, MKSTR(v273), v275, MKSTR(v276), v269));
	STR* v278;
	STRLIT(v278, "CULong", 6);
	VAL v279 = VVAL(VTUP(v277)->cells[4]);
	incref(v279);
	uint64_t v280 = VU64(VTUP(v279)->cells[44]);
	decref(v279);
	STR* v281;
	STRLIT(v281, "CULong", 6);
	VAL v282 = VVAL(VTUP(v277)->cells[4]);
	incref(v282);
	uint64_t v283 = VU64(VTUP(v282)->cells[45]);
	decref(v282);
	STR* v284;
	STRLIT(v284, "unsigned long", 13);
	VAL v285 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v278), v280, MKSTR(v281), v283, MKSTR(v284), v277));
	STR* v286;
	STRLIT(v286, "CULongLong", 10);
	VAL v287 = VVAL(VTUP(v285)->cells[4]);
	incref(v287);
	uint64_t v288 = VU64(VTUP(v287)->cells[46]);
	decref(v287);
	STR* v289;
	STRLIT(v289, "CULongLong", 10);
	VAL v290 = VVAL(VTUP(v285)->cells[4]);
	incref(v290);
	uint64_t v291 = VU64(VTUP(v290)->cells[47]);
	decref(v290);
	STR* v292;
	STRLIT(v292, "unsigned long long", 18);
	VAL v293 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v286), v288, MKSTR(v289), v291, MKSTR(v292), v285));
	STR* v294;
	STRLIT(v294, "CUSize", 6);
	VAL v295 = VVAL(VTUP(v293)->cells[4]);
	incref(v295);
	uint64_t v296 = VU64(VTUP(v295)->cells[48]);
	decref(v295);
	STR* v297;
	STRLIT(v297, "CUSize", 6);
	VAL v298 = VVAL(VTUP(v293)->cells[4]);
	incref(v298);
	uint64_t v299 = VU64(VTUP(v298)->cells[49]);
	decref(v298);
	STR* v300;
	STRLIT(v300, "size_t", 6);
	VAL v301 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v294), v296, MKSTR(v297), v299, MKSTR(v300), v293));
	STR* v302;
	STRLIT(v302, "CUIntPtr", 8);
	VAL v303 = VVAL(VTUP(v301)->cells[4]);
	incref(v303);
	uint64_t v304 = VU64(VTUP(v303)->cells[50]);
	decref(v303);
	STR* v305;
	STRLIT(v305, "CUIntPtr", 8);
	VAL v306 = VVAL(VTUP(v301)->cells[4]);
	incref(v306);
	uint64_t v307 = VU64(VTUP(v306)->cells[51]);
	decref(v306);
	STR* v308;
	STRLIT(v308, "uintptr_t", 9);
	VAL v309 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v302), v304, MKSTR(v305), v307, MKSTR(v308), v301));
	return v309;
}
static VAL mw_mirth_data_dataZ_qname (uint64_t x1, uint64_t x2, int64_t x3) {
	VAL v4 = mtw_mirth_tycon_Tycon_TYCONz_DATA(x1);
	VAL v5 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v4);
	VAL v6 = mtw_mirth_name_QName_MKQNAME(v5, x2, x3);
	return v6;
}
static VAL mw_mirth_data_dataZ_wordZ_qname (uint64_t x1, VAL x2, int64_t x3) {
	uint64_t v4 = mw_std_prim_Str_ZToName(x2);
	VAL v5 = mw_mirth_data_dataZ_qname(x1, v4, x3);
	return v5;
}
static int64_t mw_mirth_data_Data_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_data_Data_index(x1);
	int64_t v4 = mw_mirth_data_Data_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static int64_t mw_mirth_data_Data_numZ_tags (uint64_t x1) {
	VAL v2 = mw_mirth_data_Data_tags(x1);
	int64_t v3 = mw_std_list_List_1_len(v2);
	return v3;
}
static VAL mw_mirth_data_Data_addZ_tagZBang (VAL x1, uint64_t x2, uint64_t x3) {
	void* v4 = mfld_mirth_data_Tag_ZTildevalue(x2);
	bool v5 = mut_is_set(v4);
	VAL x6;
	uint64_t x7;
	uint64_t x8;
	int64_t x9;
	if (v5) {
		VAL v10 = mut_get(v4);
		x9 = VI64(v10);
		x8 = x2;
		x7 = x3;
		x6 = x1;
	} else {
		void* v11 = mfld_mirth_data_Data_ZTildelastZ_tagZ_value(x3);
		VAL v12 = mw_std_prelude_ZAtZAsk(v11);
		VAL x13;
		uint64_t x14;
		uint64_t x15;
		int64_t x16;
		switch (get_data_tag(v12)) {
			case 1LL: { // Some
				VAL v17 = mtp_std_maybe_Maybe_1_Some(v12);
				int64_t v18 = 1LL;
				int64_t v19 = i64_add(VI64(v17), v18);
				x16 = v19;
				x15 = x3;
				x14 = x2;
				x13 = x1;
			} break;
			case 0LL: { // None
				int64_t v20 = 0LL;
				x16 = v20;
				x15 = x3;
				x14 = x2;
				x13 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		mut_set(MKI64(x16), v4);
		x9 = x16;
		x8 = x14;
		x7 = x15;
		x6 = x13;
	}
	VAL v21 = mw_mirth_data_Data_tags(x7);
	VAL v22 = MKI64(0LL /* None */);
	VAL v23;
	VAL v24;
	mw_std_list_List_1_uncons(v21, &v23, &v24);
	VAL x25;
	uint64_t x26;
	int64_t x27;
	uint64_t x28;
	VAL x29;
	VAL x30;
	int64_t x31;
	switch (get_data_tag(v23)) {
		case 1LL: { // Some
			VAL v32 = mtp_std_maybe_Maybe_1_Some(v23);
			incref(v32);
			int64_t v33 = mw_mirth_data_Tag_value(VU64(v32));
			bool v34 = (v33 == x9);
			VAL x35;
			uint64_t x36;
			int64_t x37;
			uint64_t x38;
			VAL x39;
			if (v34) {
				VAL v40 = mtw_std_maybe_Maybe_1_Some(v32);
				x39 = v40;
				x38 = x7;
				x37 = x9;
				x36 = x8;
				x35 = x6;
			} else {
				decref(v32);
				VAL v41 = MKI64(0LL /* None */);
				x39 = v41;
				x38 = x7;
				x37 = x9;
				x36 = x8;
				x35 = x6;
			}
			VAL x42;
			uint64_t x43;
			int64_t x44;
			uint64_t x45;
			VAL x46;
			VAL x47;
			switch (get_data_tag(x39)) {
				case 0LL: { // None
					x47 = v24;
					x46 = v22;
					x45 = x38;
					x44 = x37;
					x43 = x36;
					x42 = x35;
				} break;
				default: {
					decref(v24);
					decref(v22);
					VAL v48 = MKI64(0LL /* Nil */);
					x47 = v48;
					x46 = x39;
					x45 = x38;
					x44 = x37;
					x43 = x36;
					x42 = x35;
				} break;
			}
			int64_t v49 = 1LL /* True */;
			x31 = v49;
			x30 = x47;
			x29 = x46;
			x28 = x45;
			x27 = x44;
			x26 = x43;
			x25 = x42;
		} break;
		case 0LL: { // None
			int64_t v50 = 0LL /* False */;
			x31 = v50;
			x30 = v24;
			x29 = v22;
			x28 = x7;
			x27 = x9;
			x26 = x8;
			x25 = x6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v51 = (x25);
	uint64_t v52 = x26;
	int64_t v53 = x27;
	uint64_t v54 = x28;
	VAL v55 = x29;
	VAL v56 = x30;
	int64_t v57 = x31;
	while (((bool)v57)) {
		VAL v58 = (v51);
		uint64_t v59 = v52;
		int64_t v60 = v53;
		uint64_t v61 = v54;
		VAL v62 = v55;
		VAL v63 = v56;
		VAL v64;
		VAL v65;
		mw_std_list_List_1_uncons(v63, &v64, &v65);
		VAL x66;
		uint64_t x67;
		int64_t x68;
		uint64_t x69;
		VAL x70;
		VAL x71;
		int64_t x72;
		switch (get_data_tag(v64)) {
			case 1LL: { // Some
				VAL v73 = mtp_std_maybe_Maybe_1_Some(v64);
				incref(v73);
				int64_t v74 = mw_mirth_data_Tag_value(VU64(v73));
				bool v75 = (v74 == v60);
				VAL x76;
				uint64_t x77;
				int64_t x78;
				uint64_t x79;
				VAL x80;
				if (v75) {
					VAL v81 = mtw_std_maybe_Maybe_1_Some(v73);
					x80 = v81;
					x79 = v61;
					x78 = v60;
					x77 = v59;
					x76 = v58;
				} else {
					decref(v73);
					VAL v82 = MKI64(0LL /* None */);
					x80 = v82;
					x79 = v61;
					x78 = v60;
					x77 = v59;
					x76 = v58;
				}
				VAL x83;
				uint64_t x84;
				int64_t x85;
				uint64_t x86;
				VAL x87;
				VAL x88;
				switch (get_data_tag(x80)) {
					case 0LL: { // None
						x88 = v65;
						x87 = v62;
						x86 = x79;
						x85 = x78;
						x84 = x77;
						x83 = x76;
					} break;
					default: {
						decref(v65);
						decref(v62);
						VAL v89 = MKI64(0LL /* Nil */);
						x88 = v89;
						x87 = x80;
						x86 = x79;
						x85 = x78;
						x84 = x77;
						x83 = x76;
					} break;
				}
				int64_t v90 = 1LL /* True */;
				x72 = v90;
				x71 = x88;
				x70 = x87;
				x69 = x86;
				x68 = x85;
				x67 = x84;
				x66 = x83;
			} break;
			case 0LL: { // None
				int64_t v91 = 0LL /* False */;
				x72 = v91;
				x71 = v65;
				x70 = v62;
				x69 = v61;
				x68 = v60;
				x67 = v59;
				x66 = v58;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v57 = x72;
		v56 = x71;
		v55 = x70;
		v54 = x69;
		v53 = x68;
		v52 = x67;
		v51 = x66;
	}
	decref(v56);
	VAL x92;
	uint64_t x93;
	int64_t x94;
	uint64_t x95;
	switch (get_data_tag(v55)) {
		case 1LL: { // Some
			VAL v96 = mtp_std_maybe_Maybe_1_Some(v55);
			STR* v97;
			STRLIT(v97, "", 0);
			STR* v98;
			STRLIT(v98, "Constructors ", 13);
			VAL v99 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v98), MKSTR(v97)));
			uint64_t v100 = mw_mirth_data_Tag_name(VU64(v96));
			VAL v101 = mw_mirth_name_Name_ZToStr(v100);
			VAL v102 = (mw_std_str_ZPlusStr_pushZ_strZBang(v101, v99));
			STR* v103;
			STRLIT(v103, " and ", 5);
			VAL v104 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v103), v102));
			uint64_t v105 = mw_mirth_data_Tag_name(v52);
			VAL v106 = mw_mirth_name_Name_ZToStr(v105);
			VAL v107 = (mw_std_str_ZPlusStr_pushZ_strZBang(v106, v104));
			STR* v108;
			STRLIT(v108, " have the same tag value.", 25);
			VAL v109 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v108), v107));
			VAL v110 = mw_mirth_data_Data_headZAsk(v54);
			int64_t x111;
			uint64_t x112;
			uint64_t x113;
			VAL x114;
			switch (get_data_tag(v110)) {
				case 1LL: { // Some
					VAL v115 = mtp_std_maybe_Maybe_1_Some(v110);
					VAL v116 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(VU64(v115), v109, v51));
					x114 = v116;
					x113 = v54;
					x112 = v52;
					x111 = v53;
				} break;
				case 0LL: { // None
					VAL v117 = (mw_mirth_mirth_ZPlusMirth_errorZBang(v109, v51));
					x114 = v117;
					x113 = v54;
					x112 = v52;
					x111 = v53;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x95 = x113;
			x94 = x111;
			x93 = x112;
			x92 = x114;
		} break;
		case 0LL: { // None
			x95 = v54;
			x94 = v53;
			x93 = v52;
			x92 = v51;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	void* v118 = mfld_mirth_data_Data_ZTildelastZ_tagZ_value(x95);
	mut_set(MKI64(x94), v118);
	void* v119 = mfld_mirth_data_Data_ZTildetags(x95);
	VAL v120 = mut_get(v119);
	VAL v121 = mw_std_list_List_1_reverse(v120);
	VAL v122 = mtw_std_list_List_1_Cons(MKU64(x93), v121);
	VAL v123 = mw_std_list_List_1_reverse(v122);
	mut_set(v123, v119);
	return x92;
}
static int64_t mw_mirth_data_Data_isZ_enumZ_orZ_unitZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_data_Data_isZ_enumZAsk(x1);
	int64_t v3 = mw_mirth_data_Data_isZ_unitZAsk(x1);
	bool v4 = (((bool)v3) || ((bool)v2));
	return ((int64_t)v4);
}
static int64_t mw_mirth_data_Data_isZ_unitZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildeisZ_unitZAsk(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	int64_t x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = VI64(v6);
		x4 = x1;
	} else {
		VAL v7 = mw_mirth_data_Data_tags(x1);
		VAL v8 = mw_std_list_List_1_ZDivL1(v7);
		uint64_t x9;
		int64_t x10;
		switch (get_data_tag(v8)) {
			case 1LL: { // Some
				VAL v11 = mtp_std_maybe_Maybe_1_Some(v8);
				int64_t v12 = mw_mirth_data_Tag_numZ_totalZ_inputs(VU64(v11));
				int64_t v13 = 0LL;
				bool v14 = (v12 == v13);
				x10 = ((int64_t)v14);
				x9 = x1;
			} break;
			case 0LL: { // None
				int64_t v15 = 0LL /* False */;
				x10 = v15;
				x9 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		mut_set(MKI64(x10), v2);
		x5 = x10;
		x4 = x9;
	}
	return x5;
}
static int64_t mw_mirth_data_Data_isZ_enumZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildeisZ_enumZAsk(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	int64_t x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = VI64(v6);
		x4 = x1;
	} else {
		int64_t v7 = mw_mirth_data_Data_isZ_unitZAsk(x1);
		bool v8 = !((bool)v7);
		uint64_t x9;
		int64_t x10;
		if (v8) {
			VAL v11 = mw_mirth_data_Data_tags(x1);
			VAL v12 = MKI64(0LL /* None */);
			VAL v13;
			VAL v14;
			mw_std_list_List_1_uncons(v11, &v13, &v14);
			uint64_t x15;
			VAL x16;
			VAL x17;
			int64_t x18;
			switch (get_data_tag(v13)) {
				case 1LL: { // Some
					VAL v19 = mtp_std_maybe_Maybe_1_Some(v13);
					incref(v19);
					int64_t v20 = mw_mirth_data_Tag_numZ_totalZ_inputs(VU64(v19));
					int64_t v21 = 0LL;
					bool v22 = (v20 == v21);
					bool v23 = !v22;
					uint64_t x24;
					VAL x25;
					if (v23) {
						VAL v26 = mtw_std_maybe_Maybe_1_Some(v19);
						x25 = v26;
						x24 = x1;
					} else {
						decref(v19);
						VAL v27 = MKI64(0LL /* None */);
						x25 = v27;
						x24 = x1;
					}
					uint64_t x28;
					VAL x29;
					VAL x30;
					switch (get_data_tag(x25)) {
						case 0LL: { // None
							x30 = v14;
							x29 = v12;
							x28 = x24;
						} break;
						default: {
							decref(v14);
							decref(v12);
							VAL v31 = MKI64(0LL /* Nil */);
							x30 = v31;
							x29 = x25;
							x28 = x24;
						} break;
					}
					int64_t v32 = 1LL /* True */;
					x18 = v32;
					x17 = x30;
					x16 = x29;
					x15 = x28;
				} break;
				case 0LL: { // None
					int64_t v33 = 0LL /* False */;
					x18 = v33;
					x17 = v14;
					x16 = v12;
					x15 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v34 = x15;
			VAL v35 = x16;
			VAL v36 = x17;
			int64_t v37 = x18;
			while (((bool)v37)) {
				uint64_t v38 = v34;
				VAL v39 = v35;
				VAL v40 = v36;
				VAL v41;
				VAL v42;
				mw_std_list_List_1_uncons(v40, &v41, &v42);
				uint64_t x43;
				VAL x44;
				VAL x45;
				int64_t x46;
				switch (get_data_tag(v41)) {
					case 1LL: { // Some
						VAL v47 = mtp_std_maybe_Maybe_1_Some(v41);
						incref(v47);
						int64_t v48 = mw_mirth_data_Tag_numZ_totalZ_inputs(VU64(v47));
						int64_t v49 = 0LL;
						bool v50 = (v48 == v49);
						bool v51 = !v50;
						uint64_t x52;
						VAL x53;
						if (v51) {
							VAL v54 = mtw_std_maybe_Maybe_1_Some(v47);
							x53 = v54;
							x52 = v38;
						} else {
							decref(v47);
							VAL v55 = MKI64(0LL /* None */);
							x53 = v55;
							x52 = v38;
						}
						uint64_t x56;
						VAL x57;
						VAL x58;
						switch (get_data_tag(x53)) {
							case 0LL: { // None
								x58 = v42;
								x57 = v39;
								x56 = x52;
							} break;
							default: {
								decref(v42);
								decref(v39);
								VAL v59 = MKI64(0LL /* Nil */);
								x58 = v59;
								x57 = x53;
								x56 = x52;
							} break;
						}
						int64_t v60 = 1LL /* True */;
						x46 = v60;
						x45 = x58;
						x44 = x57;
						x43 = x56;
					} break;
					case 0LL: { // None
						int64_t v61 = 0LL /* False */;
						x46 = v61;
						x45 = v42;
						x44 = v39;
						x43 = v38;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v37 = x46;
				v36 = x45;
				v35 = x44;
				v34 = x43;
			}
			decref(v36);
			int64_t v62 = mw_std_maybe_Maybe_1_noneZAsk(v35);
			x10 = v62;
			x9 = v34;
		} else {
			int64_t v63 = 0LL /* False */;
			x10 = v63;
			x9 = x1;
		}
		mut_set(MKI64(x10), v2);
		x5 = x10;
		x4 = x9;
	}
	return x5;
}
static void mw_mirth_data_Data_semiZ_transparentZAsk (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Data_ZTildesemiZ_transparentZAsk(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11 = mw_mirth_data_Data_tags(x2);
		VAL v12 = mw_std_list_List_1_ZDivL1(v11);
		VAL x13;
		uint64_t x14;
		VAL x15;
		switch (get_data_tag(v12)) {
			case 1LL: { // Some
				VAL v16 = mtp_std_maybe_Maybe_1_Some(v12);
				incref(v16);
				VAL v17;
				VAL v18;
				mw_mirth_data_Tag_inputs(x1, VU64(v16), &v17, &v18);
				VAL v19 = mw_std_list_List_1_ZDivL1(v18);
				uint64_t x20;
				uint64_t x21;
				VAL x22;
				VAL x23;
				switch (get_data_tag(v19)) {
					case 1LL: { // Some
						VAL v24 = mtp_std_maybe_Maybe_1_Some(v19);
						incref(v16);
						VAL v25 = mtw_mirth_data_SemiTransparentData_SemiTransparentData(VU64(v16), v24);
						VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
						x23 = v26;
						x22 = v17;
						x21 = VU64(v16);
						x20 = x2;
					} break;
					case 0LL: { // None
						VAL v27 = MKI64(0LL /* None */);
						x23 = v27;
						x22 = v17;
						x21 = VU64(v16);
						x20 = x2;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x15 = x23;
				x14 = x20;
				x13 = x22;
			} break;
			case 0LL: { // None
				VAL v28 = MKI64(0LL /* None */);
				x15 = v28;
				x14 = x2;
				x13 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		incref(x15);
		mut_set(x15, v5);
		x9 = x15;
		x8 = x14;
		x7 = x13;
	}
	*x4 = x9;
	*x3 = x7;
}
static int64_t mw_mirth_data_Data_isZ_resourceZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_data_Data_ZTildeisZ_resourceZAsk(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	int64_t x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = VI64(v6);
		x4 = x1;
	} else {
		uint64_t v7 = mw_mirth_data_Data_name(x1);
		int64_t v8 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(v7);
		mut_set(MKI64(v8), v2);
		x5 = v8;
		x4 = x1;
	}
	return x5;
}
static int64_t mw_mirth_data_Data_isZ_valueZ_typeZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_data_Data_isZ_resourceZAsk(x1);
	bool v3 = !((bool)v2);
	return ((int64_t)v3);
}
static void mw_mirth_data_Data_fullZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = mtw_mirth_type_Type_TData(x2);
	VAL v6;
	VAL v7;
	mw_mirth_data_Data_params(x1, x2, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v7, &v8, &v9);
	uint64_t x10;
	VAL x11;
	VAL x12;
	VAL x13;
	int64_t x14;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v16 = mtw_mirth_type_Type_TVar(VU64(v15));
			VAL v17 = mtw_mirth_type_Type_TApp(v5, v16);
			int64_t v18 = 1LL /* True */;
			x14 = v18;
			x13 = v9;
			x12 = v6;
			x11 = v17;
			x10 = x2;
		} break;
		case 0LL: { // None
			int64_t v19 = 0LL /* False */;
			x14 = v19;
			x13 = v9;
			x12 = v6;
			x11 = v5;
			x10 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v20 = x10;
	VAL v21 = x11;
	VAL v22 = (x12);
	VAL v23 = x13;
	int64_t v24 = x14;
	while (((bool)v24)) {
		uint64_t v25 = v20;
		VAL v26 = v21;
		VAL v27 = (v22);
		VAL v28 = v23;
		VAL v29;
		VAL v30;
		mw_std_list_List_1_uncons(v28, &v29, &v30);
		uint64_t x31;
		VAL x32;
		VAL x33;
		VAL x34;
		int64_t x35;
		switch (get_data_tag(v29)) {
			case 1LL: { // Some
				VAL v36 = mtp_std_maybe_Maybe_1_Some(v29);
				VAL v37 = mtw_mirth_type_Type_TVar(VU64(v36));
				VAL v38 = mtw_mirth_type_Type_TApp(v26, v37);
				int64_t v39 = 1LL /* True */;
				x35 = v39;
				x34 = v30;
				x33 = v27;
				x32 = v38;
				x31 = v25;
			} break;
			case 0LL: { // None
				int64_t v40 = 0LL /* False */;
				x35 = v40;
				x34 = v30;
				x33 = v27;
				x32 = v26;
				x31 = v25;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v24 = x35;
		v23 = x34;
		v22 = x33;
		v21 = x32;
		v20 = x31;
	}
	decref(v23);
	int64_t v41 = mw_mirth_data_Data_isZ_valueZ_typeZAsk(v20);
	VAL x42;
	VAL x43;
	if (((bool)v41)) {
		VAL v44 = mtw_std_either_Either_2_Left(v21);
		x43 = v44;
		x42 = v22;
	} else {
		VAL v45 = mtw_std_either_Either_2_Right(v21);
		x43 = v45;
		x42 = v22;
	}
	*x4 = x43;
	*x3 = x42;
}
static int64_t mw_mirth_data_Tag_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_data_Tag_allocZBang (void) {
	void* v1 = mbuf_mirth_data_Tag_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_data_Tag_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_data_Tag_data (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildedata(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_data_Tag_qname (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildeqname(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_data_Tag_name (uint64_t x1) {
	VAL v2 = mw_mirth_data_Tag_qname(x1);
	uint64_t v3 = VU64(VTUP(v2)->cells[2]);
	decref(v2);
	return v3;
}
static int64_t mw_mirth_data_Tag_value (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildevalue(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static VAL mw_mirth_data_Tag_labelZ_inputs (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildelabelZ_inputs(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputs (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputs (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static VAL mw_mirth_data_Tag_sigZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildesigZAsk(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static void mw_mirth_data_Tag_ctxZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5) {
	void* v6 = mfld_mirth_data_Tag_ZTildectxZ_type(x2);
	VAL v7;
	VAL v8;
	mw_mirth_mirth_Prop_1_forceZBang(v6, x1, &v7, &v8);
	VAL v9;
	VAL v10;
	value_uncons(v7, &v9, &v10);
	VAL v11;
	VAL v12;
	value_uncons(v9, &v11, &v12);
	decref(v11);
	*x5 = v10;
	*x4 = v12;
	*x3 = v8;
}
static void mw_mirth_data_Tag_ctx (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_ctxZ_type(x1, x2, &v5, &v6, &v7);
	decref(v7);
	*x4 = v6;
	*x3 = v5;
}
static void mw_mirth_data_Tag_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_ctxZ_type(x1, x2, &v5, &v6, &v7);
	decref(v6);
	*x4 = v7;
	*x3 = v5;
}
static VAL mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig (uint64_t x1) {
	VAL v2 = mw_mirth_data_Tag_sigZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_mirth_token_Token_runZ_tokens(VU64(v4));
			VAL v6 = MKI64(0LL /* Nil */);
			VAL v7 = mw_std_list_List_1_reverse(v6);
			VAL v8;
			VAL v9;
			mw_std_list_List_1_uncons(v5, &v8, &v9);
			VAL x10;
			VAL x11;
			int64_t x12;
			switch (get_data_tag(v8)) {
				case 1LL: { // Some
					VAL v13 = mtp_std_maybe_Maybe_1_Some(v8);
					VAL v14 = mw_mirth_token_Token_sigZ_labelZAsk(VU64(v13));
					VAL x15;
					switch (get_data_tag(v14)) {
						case 1LL: { // Some
							VAL v16 = mtp_std_maybe_Maybe_1_Some(v14);
							VAL v17 = mtw_std_list_List_1_Cons(v16, v7);
							x15 = v17;
						} break;
						case 0LL: { // None
							x15 = v7;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					int64_t v18 = 1LL /* True */;
					x12 = v18;
					x11 = v9;
					x10 = x15;
				} break;
				case 0LL: { // None
					int64_t v19 = 0LL /* False */;
					x12 = v19;
					x11 = v9;
					x10 = v7;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v20 = (x10);
			VAL v21 = x11;
			int64_t v22 = x12;
			while (((bool)v22)) {
				VAL v23 = (v20);
				VAL v24 = v21;
				VAL v25;
				VAL v26;
				mw_std_list_List_1_uncons(v24, &v25, &v26);
				VAL x27;
				VAL x28;
				int64_t x29;
				switch (get_data_tag(v25)) {
					case 1LL: { // Some
						VAL v30 = mtp_std_maybe_Maybe_1_Some(v25);
						VAL v31 = mw_mirth_token_Token_sigZ_labelZAsk(VU64(v30));
						VAL x32;
						switch (get_data_tag(v31)) {
							case 1LL: { // Some
								VAL v33 = mtp_std_maybe_Maybe_1_Some(v31);
								VAL v34 = mtw_std_list_List_1_Cons(v33, v23);
								x32 = v34;
							} break;
							case 0LL: { // None
								x32 = v23;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v35 = 1LL /* True */;
						x29 = v35;
						x28 = v26;
						x27 = x32;
					} break;
					case 0LL: { // None
						int64_t v36 = 0LL /* False */;
						x29 = v36;
						x28 = v26;
						x27 = v23;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v22 = x29;
				v21 = x28;
				v20 = x27;
			}
			decref(v21);
			VAL v37 = mw_std_list_List_1_reverse(v20);
			x3 = v37;
		} break;
		case 0LL: { // None
			VAL v38 = MKI64(0LL /* Nil */);
			x3 = v38;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig (uint64_t x1) {
	VAL v2 = mw_mirth_data_Tag_sigZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			int64_t v5 = mw_mirth_token_Token_runZ_length(VU64(v4));
			int64_t v6 = mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig(x1);
			int64_t v7 = i64_sub(v5, v6);
			int64_t v8 = 0LL;
			bool v9 = (v7 < v8);
			int64_t x10;
			if (v9) {
				x10 = v8;
				push_u64(x1);
			} else {
				x10 = v7;
				push_u64(x1);
			}
			uint64_t v11 = pop_u64();
			VAL v12 = mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig(v11);
			int64_t v13 = mw_std_list_List_1_len(v12);
			int64_t v14 = i64_sub(x10, v13);
			int64_t v15 = 0LL;
			bool v16 = (v14 < v15);
			int64_t x17;
			if (v16) {
				x17 = v15;
			} else {
				x17 = v14;
			}
			x3 = x17;
		} break;
		case 0LL: { // None
			int64_t v18 = 0LL;
			x3 = v18;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig (uint64_t x1) {
	VAL v2 = mw_mirth_data_Tag_sigZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_mirth_token_Token_runZ_tokens(VU64(v4));
			VAL v6 = MKI64(0LL /* Nil */);
			VAL v7 = mw_std_list_List_1_reverse(v6);
			VAL v8;
			VAL v9;
			mw_std_list_List_1_uncons(v5, &v8, &v9);
			VAL x10;
			VAL x11;
			int64_t x12;
			switch (get_data_tag(v8)) {
				case 1LL: { // Some
					VAL v13 = mtp_std_maybe_Maybe_1_Some(v8);
					incref(v13);
					int64_t v14 = mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk(VU64(v13));
					bool v15 = !((bool)v14);
					VAL x16;
					if (v15) {
						VAL v17 = mtw_std_maybe_Maybe_1_Some(v13);
						x16 = v17;
					} else {
						decref(v13);
						VAL v18 = MKI64(0LL /* None */);
						x16 = v18;
					}
					VAL x19;
					switch (get_data_tag(x16)) {
						case 1LL: { // Some
							VAL v20 = mtp_std_maybe_Maybe_1_Some(x16);
							VAL v21 = mtw_std_list_List_1_Cons(v20, v7);
							x19 = v21;
						} break;
						case 0LL: { // None
							x19 = v7;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					int64_t v22 = 1LL /* True */;
					x12 = v22;
					x11 = v9;
					x10 = x19;
				} break;
				case 0LL: { // None
					int64_t v23 = 0LL /* False */;
					x12 = v23;
					x11 = v9;
					x10 = v7;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v24 = (x10);
			VAL v25 = x11;
			int64_t v26 = x12;
			while (((bool)v26)) {
				VAL v27 = (v24);
				VAL v28 = v25;
				VAL v29;
				VAL v30;
				mw_std_list_List_1_uncons(v28, &v29, &v30);
				VAL x31;
				VAL x32;
				int64_t x33;
				switch (get_data_tag(v29)) {
					case 1LL: { // Some
						VAL v34 = mtp_std_maybe_Maybe_1_Some(v29);
						incref(v34);
						int64_t v35 = mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk(VU64(v34));
						bool v36 = !((bool)v35);
						VAL x37;
						if (v36) {
							VAL v38 = mtw_std_maybe_Maybe_1_Some(v34);
							x37 = v38;
						} else {
							decref(v34);
							VAL v39 = MKI64(0LL /* None */);
							x37 = v39;
						}
						VAL x40;
						switch (get_data_tag(x37)) {
							case 1LL: { // Some
								VAL v41 = mtp_std_maybe_Maybe_1_Some(x37);
								VAL v42 = mtw_std_list_List_1_Cons(v41, v27);
								x40 = v42;
							} break;
							case 0LL: { // None
								x40 = v27;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v43 = 1LL /* True */;
						x33 = v43;
						x32 = v30;
						x31 = x40;
					} break;
					case 0LL: { // None
						int64_t v44 = 0LL /* False */;
						x33 = v44;
						x32 = v30;
						x31 = v27;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v26 = x33;
				v25 = x32;
				v24 = x31;
			}
			decref(v25);
			VAL v45 = mw_std_list_List_1_reverse(v24);
			VAL v46 = MKI64(0LL /* Nil */);
			VAL v47 = mw_std_list_List_1_reverse(v46);
			VAL v48;
			VAL v49;
			mw_std_list_List_1_uncons(v45, &v48, &v49);
			VAL x50;
			VAL x51;
			int64_t x52;
			switch (get_data_tag(v48)) {
				case 1LL: { // Some
					VAL v53 = mtp_std_maybe_Maybe_1_Some(v48);
					VAL v54 = mw_mirth_token_Token_nameZAsk(VU64(v53));
					VAL x55;
					switch (get_data_tag(v54)) {
						case 1LL: { // Some
							VAL v56 = mtp_std_maybe_Maybe_1_Some(v54);
							VAL v57 = mtw_std_list_List_1_Cons(v56, v47);
							x55 = v57;
						} break;
						case 0LL: { // None
							x55 = v47;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					int64_t v58 = 1LL /* True */;
					x52 = v58;
					x51 = v49;
					x50 = x55;
				} break;
				case 0LL: { // None
					int64_t v59 = 0LL /* False */;
					x52 = v59;
					x51 = v49;
					x50 = v47;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v60 = (x50);
			VAL v61 = x51;
			int64_t v62 = x52;
			while (((bool)v62)) {
				VAL v63 = (v60);
				VAL v64 = v61;
				VAL v65;
				VAL v66;
				mw_std_list_List_1_uncons(v64, &v65, &v66);
				VAL x67;
				VAL x68;
				int64_t x69;
				switch (get_data_tag(v65)) {
					case 1LL: { // Some
						VAL v70 = mtp_std_maybe_Maybe_1_Some(v65);
						VAL v71 = mw_mirth_token_Token_nameZAsk(VU64(v70));
						VAL x72;
						switch (get_data_tag(v71)) {
							case 1LL: { // Some
								VAL v73 = mtp_std_maybe_Maybe_1_Some(v71);
								VAL v74 = mtw_std_list_List_1_Cons(v73, v63);
								x72 = v74;
							} break;
							case 0LL: { // None
								x72 = v63;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v75 = 1LL /* True */;
						x69 = v75;
						x68 = v66;
						x67 = x72;
					} break;
					case 0LL: { // None
						int64_t v76 = 0LL /* False */;
						x69 = v76;
						x68 = v66;
						x67 = v63;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v62 = x69;
				v61 = x68;
				v60 = x67;
			}
			decref(v61);
			VAL v77 = mw_std_list_List_1_reverse(v60);
			VAL v78 = MKI64(0LL /* Nil */);
			VAL v79 = mw_std_list_List_1_reverse(v78);
			VAL v80;
			VAL v81;
			mw_std_list_List_1_uncons(v77, &v80, &v81);
			VAL x82;
			VAL x83;
			int64_t x84;
			switch (get_data_tag(v80)) {
				case 1LL: { // Some
					VAL v85 = mtp_std_maybe_Maybe_1_Some(v80);
					incref(v85);
					incref(v85);
					int64_t v86 = mw_mirth_name_Name_couldZ_beZ_resourceZ_var(VU64(v85));
					int64_t x87;
					if (((bool)v86)) {
						decref(v85);
						int64_t v88 = 1LL /* True */;
						x87 = v88;
					} else {
						int64_t v89 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(VU64(v85));
						x87 = v89;
					}
					VAL x90;
					if (((bool)x87)) {
						VAL v91 = mtw_std_maybe_Maybe_1_Some(v85);
						x90 = v91;
					} else {
						decref(v85);
						VAL v92 = MKI64(0LL /* None */);
						x90 = v92;
					}
					VAL x93;
					switch (get_data_tag(x90)) {
						case 1LL: { // Some
							VAL v94 = mtp_std_maybe_Maybe_1_Some(x90);
							VAL v95 = mtw_std_list_List_1_Cons(v94, v79);
							x93 = v95;
						} break;
						case 0LL: { // None
							x93 = v79;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					int64_t v96 = 1LL /* True */;
					x84 = v96;
					x83 = v81;
					x82 = x93;
				} break;
				case 0LL: { // None
					int64_t v97 = 0LL /* False */;
					x84 = v97;
					x83 = v81;
					x82 = v79;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v98 = (x82);
			VAL v99 = x83;
			int64_t v100 = x84;
			while (((bool)v100)) {
				VAL v101 = (v98);
				VAL v102 = v99;
				VAL v103;
				VAL v104;
				mw_std_list_List_1_uncons(v102, &v103, &v104);
				VAL x105;
				VAL x106;
				int64_t x107;
				switch (get_data_tag(v103)) {
					case 1LL: { // Some
						VAL v108 = mtp_std_maybe_Maybe_1_Some(v103);
						incref(v108);
						incref(v108);
						int64_t v109 = mw_mirth_name_Name_couldZ_beZ_resourceZ_var(VU64(v108));
						int64_t x110;
						if (((bool)v109)) {
							decref(v108);
							int64_t v111 = 1LL /* True */;
							x110 = v111;
						} else {
							int64_t v112 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(VU64(v108));
							x110 = v112;
						}
						VAL x113;
						if (((bool)x110)) {
							VAL v114 = mtw_std_maybe_Maybe_1_Some(v108);
							x113 = v114;
						} else {
							decref(v108);
							VAL v115 = MKI64(0LL /* None */);
							x113 = v115;
						}
						VAL x116;
						switch (get_data_tag(x113)) {
							case 1LL: { // Some
								VAL v117 = mtp_std_maybe_Maybe_1_Some(x113);
								VAL v118 = mtw_std_list_List_1_Cons(v117, v101);
								x116 = v118;
							} break;
							case 0LL: { // None
								x116 = v101;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v119 = 1LL /* True */;
						x107 = v119;
						x106 = v104;
						x105 = x116;
					} break;
					case 0LL: { // None
						int64_t v120 = 0LL /* False */;
						x107 = v120;
						x106 = v104;
						x105 = v101;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v100 = x107;
				v99 = x106;
				v98 = x105;
			}
			decref(v99);
			VAL v121 = mw_std_list_List_1_reverse(v98);
			int64_t v122 = mw_std_list_List_1_len(v121);
			x3 = v122;
		} break;
		case 0LL: { // None
			int64_t v123 = 0LL;
			x3 = v123;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_data_Tag_numZ_labelZ_inputs (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	int64_t x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = VI64(v6);
		x4 = x1;
	} else {
		VAL v7 = mw_mirth_data_Tag_labelZ_inputs(x1);
		int64_t v8 = mw_std_list_List_1_len(v7);
		mut_set(MKI64(v8), v2);
		x5 = v8;
		x4 = x1;
	}
	return x5;
}
static int64_t mw_mirth_data_Tag_numZ_totalZ_inputs (uint64_t x1) {
	int64_t v2 = mw_mirth_data_Tag_numZ_labelZ_inputs(x1);
	int64_t v3 = mw_mirth_data_Tag_numZ_typeZ_inputs(x1);
	int64_t v4 = i64_add(v2, v3);
	int64_t v5 = mw_mirth_data_Tag_numZ_resourceZ_inputs(x1);
	int64_t v6 = i64_add(v4, v5);
	return v6;
}
static void mw_mirth_data_Tag_inputs (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Tag_ZTildeinputs(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11;
		VAL v12;
		mw_mirth_data_Tag_type(x1, x2, &v11, &v12);
		VAL v13 = mw_mirth_type_ArrowType_dom(v12);
		VAL v14;
		VAL v15;
		mw_mirth_type_StackType_splitZ_parts(v13, &v14, &v15);
		decref(v14);
		incref(v15);
		mut_set(v15, v5);
		x9 = v15;
		x8 = x2;
		x7 = v11;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_data_Tag_semiZ_transparentZAsk (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	uint64_t v5 = mw_mirth_data_Tag_data(x2);
	VAL v6;
	VAL v7;
	mw_mirth_data_Data_semiZ_transparentZAsk(x1, v5, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static int64_t mw_mirth_data_Tag_outputsZ_resourceZAsk (uint64_t x1) {
	uint64_t v2 = mw_mirth_data_Tag_data(x1);
	int64_t v3 = mw_mirth_data_Data_isZ_resourceZAsk(v2);
	return v3;
}
static int64_t mw_mirth_data_Tag_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_data_Tag_index(x1);
	int64_t v4 = mw_mirth_data_Tag_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_data_Tag_preferZ_inlineZAsk (VAL x1, uint64_t x2, VAL *x3, int64_t *x4) {
	uint64_t v5 = mw_mirth_data_Tag_data(x2);
	VAL v6;
	VAL v7;
	mw_mirth_data_Data_semiZ_transparentZAsk(x1, v5, &v6, &v7);
	uint64_t x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			decref(v11);
			int64_t v12 = 1LL /* True */;
			x10 = v12;
			x9 = v6;
			x8 = x2;
		} break;
		case 0LL: { // None
			int64_t v13 = mw_mirth_data_Tag_numZ_totalZ_inputs(x2);
			int64_t v14 = 0LL;
			bool v15 = (v13 == v14);
			x10 = ((int64_t)v15);
			x9 = v6;
			x8 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x10;
	*x3 = x9;
}
static int64_t mw_mirth_data_DataPartial_ZEqualZEqual (VAL x1, VAL x2) {
	uint64_t v3;
	uint64_t v4;
	mtp_mirth_data_DataPartial_DataPartial(x2, &v3, &v4);
	uint64_t v5;
	uint64_t v6;
	mtp_mirth_data_DataPartial_DataPartial(x1, &v5, &v6);
	int64_t v7 = mw_mirth_data_Data_ZEqualZEqual(v5, v3);
	int64_t v8 = mw_mirth_label_Label_ZEqualZEqual(v6, v4);
	bool v9 = (((bool)v7) && ((bool)v8));
	return ((int64_t)v9);
}
static VAL mw_mirth_match_Match_thaw (VAL x1) {
	VAL v2;
	uint64_t v3;
	uint64_t v4;
	VAL v5;
	VAL v6;
	VAL v7;
	VAL v8;
	mtp_mirth_match_Match_Match(x1, &v2, &v3, &v4, &v5, &v6, &v7, &v8);
	VAL v9 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v2, v3, v4, v5, v6, v7, v8));
	return v9;
}
static VAL mw_mirth_match_ZPlusMatch_freezze (VAL x1) {
	VAL v2;
	uint64_t v3;
	uint64_t v4;
	VAL v5;
	VAL v6;
	VAL v7;
	VAL v8;
	mtp_mirth_match_ZPlusMatch_ZPlusMatch(x1, &v2, &v3, &v4, &v5, &v6, &v7, &v8);
	VAL v9 = mtw_mirth_match_Match_Match(v2, v3, v4, v5, v6, v7, v8);
	return v9;
}
static int64_t mw_mirth_match_Match_isZ_exhaustiveZAsk (VAL x1) {
	incref(x1);
	int64_t v2 = mw_mirth_match_Match_hasZ_defaultZ_caseZAsk(x1);
	VAL x3;
	int64_t x4;
	if (((bool)v2)) {
		int64_t v5 = 1LL /* True */;
		x4 = v5;
		x3 = x1;
	} else {
		incref(x1);
		VAL v6 = mw_mirth_match_Match_scrutineeZ_dataZAsk(x1);
		VAL x7;
		int64_t x8;
		switch (get_data_tag(v6)) {
			case 1LL: { // Some
				VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
				int64_t v10 = mw_mirth_data_Data_numZ_tags(VU64(v9));
				incref(x1);
				VAL v11 = VVAL(VTUP(x1)->cells[7]);
				incref(v11);
				decref(x1);
				int64_t v12 = mw_std_list_List_1_len(v11);
				bool v13 = (v10 == v12);
				x8 = ((int64_t)v13);
				x7 = x1;
			} break;
			case 0LL: { // None
				incref(x1);
				VAL v14 = VVAL(VTUP(x1)->cells[7]);
				incref(v14);
				decref(x1);
				int64_t v15 = mw_std_list_List_1_len(v14);
				int64_t v16 = 0LL;
				bool v17 = (v15 > v16);
				x8 = ((int64_t)v17);
				x7 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x4 = x8;
		x3 = x7;
	}
	decref(x3);
	return x4;
}
static int64_t mw_mirth_match_Match_hasZ_defaultZ_caseZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[7]);
	incref(v2);
	decref(x1);
	VAL v3 = MKI64(0LL /* None */);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v2, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			incref(v9);
			int64_t v10 = mw_mirth_match_Case_isZ_defaultZ_caseZAsk(v9);
			VAL x11;
			if (((bool)v10)) {
				VAL v12 = mtw_std_maybe_Maybe_1_Some(v9);
				x11 = v12;
			} else {
				decref(v9);
				VAL v13 = MKI64(0LL /* None */);
				x11 = v13;
			}
			VAL x14;
			VAL x15;
			switch (get_data_tag(x11)) {
				case 0LL: { // None
					x15 = v5;
					x14 = v3;
				} break;
				default: {
					decref(v5);
					decref(v3);
					VAL v16 = MKI64(0LL /* Nil */);
					x15 = v16;
					x14 = x11;
				} break;
			}
			int64_t v17 = 1LL /* True */;
			x8 = v17;
			x7 = x15;
			x6 = x14;
		} break;
		case 0LL: { // None
			int64_t v18 = 0LL /* False */;
			x8 = v18;
			x7 = v5;
			x6 = v3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v19 = x6;
	VAL v20 = x7;
	int64_t v21 = x8;
	while (((bool)v21)) {
		VAL v22 = v19;
		VAL v23 = v20;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		VAL x26;
		VAL x27;
		int64_t x28;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v29 = mtp_std_maybe_Maybe_1_Some(v24);
				incref(v29);
				int64_t v30 = mw_mirth_match_Case_isZ_defaultZ_caseZAsk(v29);
				VAL x31;
				if (((bool)v30)) {
					VAL v32 = mtw_std_maybe_Maybe_1_Some(v29);
					x31 = v32;
				} else {
					decref(v29);
					VAL v33 = MKI64(0LL /* None */);
					x31 = v33;
				}
				VAL x34;
				VAL x35;
				switch (get_data_tag(x31)) {
					case 0LL: { // None
						x35 = v25;
						x34 = v22;
					} break;
					default: {
						decref(v25);
						decref(v22);
						VAL v36 = MKI64(0LL /* Nil */);
						x35 = v36;
						x34 = x31;
					} break;
				}
				int64_t v37 = 1LL /* True */;
				x28 = v37;
				x27 = x35;
				x26 = x34;
			} break;
			case 0LL: { // None
				int64_t v38 = 0LL /* False */;
				x28 = v38;
				x27 = v25;
				x26 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x28;
		v20 = x27;
		v19 = x26;
	}
	decref(v20);
	int64_t v39 = mw_std_maybe_Maybe_1_someZAsk(v19);
	return v39;
}
static VAL mw_mirth_match_Match_scrutineeZ_dataZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[7]);
	incref(v2);
	decref(x1);
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v2, &v5, &v6);
	VAL x7;
	VAL x8;
	int64_t x9;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v10);
			int64_t v11 = mw_mirth_match_Case_isZ_defaultZ_caseZAsk(v10);
			bool v12 = !((bool)v11);
			VAL x13;
			if (v12) {
				VAL v14 = mtw_std_maybe_Maybe_1_Some(v10);
				x13 = v14;
			} else {
				decref(v10);
				VAL v15 = MKI64(0LL /* None */);
				x13 = v15;
			}
			VAL x16;
			switch (get_data_tag(x13)) {
				case 1LL: { // Some
					VAL v17 = mtp_std_maybe_Maybe_1_Some(x13);
					VAL v18 = mtw_std_list_List_1_Cons(v17, v4);
					x16 = v18;
				} break;
				case 0LL: { // None
					x16 = v4;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v19 = 1LL /* True */;
			x9 = v19;
			x8 = v6;
			x7 = x16;
		} break;
		case 0LL: { // None
			int64_t v20 = 0LL /* False */;
			x9 = v20;
			x8 = v6;
			x7 = v4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v21 = (x7);
	VAL v22 = x8;
	int64_t v23 = x9;
	while (((bool)v23)) {
		VAL v24 = (v21);
		VAL v25 = v22;
		VAL v26;
		VAL v27;
		mw_std_list_List_1_uncons(v25, &v26, &v27);
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v26)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v26);
				incref(v31);
				int64_t v32 = mw_mirth_match_Case_isZ_defaultZ_caseZAsk(v31);
				bool v33 = !((bool)v32);
				VAL x34;
				if (v33) {
					VAL v35 = mtw_std_maybe_Maybe_1_Some(v31);
					x34 = v35;
				} else {
					decref(v31);
					VAL v36 = MKI64(0LL /* None */);
					x34 = v36;
				}
				VAL x37;
				switch (get_data_tag(x34)) {
					case 1LL: { // Some
						VAL v38 = mtp_std_maybe_Maybe_1_Some(x34);
						VAL v39 = mtw_std_list_List_1_Cons(v38, v24);
						x37 = v39;
					} break;
					case 0LL: { // None
						x37 = v24;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v40 = 1LL /* True */;
				x30 = v40;
				x29 = v27;
				x28 = x37;
			} break;
			case 0LL: { // None
				int64_t v41 = 0LL /* False */;
				x30 = v41;
				x29 = v27;
				x28 = v24;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v23 = x30;
		v22 = x29;
		v21 = x28;
	}
	decref(v22);
	VAL v42 = mw_std_list_List_1_reverse(v21);
	incref(v42);
	VAL v43 = mw_std_list_List_1_first(v42);
	VAL x44;
	VAL x45;
	switch (get_data_tag(v43)) {
		case 1LL: { // Some
			VAL v46 = mtp_std_maybe_Maybe_1_Some(v43);
			VAL v47 = VVAL(VTUP(v46)->cells[1]);
			incref(v47);
			decref(v46);
			VAL v48 = mw_mirth_match_Pattern_singleZ_tagZAsk(v47);
			x45 = v48;
			x44 = v42;
		} break;
		case 0LL: { // None
			VAL v49 = MKI64(0LL /* None */);
			x45 = v49;
			x44 = v42;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x50;
	VAL x51;
	switch (get_data_tag(x45)) {
		case 1LL: { // Some
			VAL v52 = mtp_std_maybe_Maybe_1_Some(x45);
			uint64_t v53 = mw_mirth_data_Tag_data(VU64(v52));
			VAL v54 = mtw_std_maybe_Maybe_1_Some(MKU64(v53));
			x51 = v54;
			x50 = x44;
		} break;
		case 0LL: { // None
			VAL v55 = MKI64(0LL /* None */);
			x51 = v55;
			x50 = x44;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x56;
	switch (get_data_tag(x51)) {
		case 1LL: { // Some
			VAL v57 = mtp_std_maybe_Maybe_1_Some(x51);
			VAL v58 = MKI64(0LL /* None */);
			VAL v59;
			VAL v60;
			mw_std_list_List_1_uncons(x50, &v59, &v60);
			uint64_t x61;
			VAL x62;
			VAL x63;
			int64_t x64;
			switch (get_data_tag(v59)) {
				case 1LL: { // Some
					VAL v65 = mtp_std_maybe_Maybe_1_Some(v59);
					incref(v65);
					VAL v66 = VVAL(VTUP(v65)->cells[1]);
					incref(v66);
					decref(v65);
					VAL v67 = mw_mirth_match_Pattern_singleZ_tagZAsk(v66);
					uint64_t x68;
					int64_t x69;
					switch (get_data_tag(v67)) {
						case 1LL: { // Some
							VAL v70 = mtp_std_maybe_Maybe_1_Some(v67);
							incref(v57);
							uint64_t v71 = mw_mirth_data_Tag_data(VU64(v70));
							int64_t v72 = mw_mirth_data_Data_ZEqualZEqual(VU64(v57), v71);
							x69 = v72;
							x68 = VU64(v57);
						} break;
						case 0LL: { // None
							int64_t v73 = 0LL /* False */;
							x69 = v73;
							x68 = VU64(v57);
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					bool v74 = !((bool)x69);
					uint64_t x75;
					VAL x76;
					if (v74) {
						VAL v77 = mtw_std_maybe_Maybe_1_Some(v65);
						x76 = v77;
						x75 = x68;
					} else {
						decref(v65);
						VAL v78 = MKI64(0LL /* None */);
						x76 = v78;
						x75 = x68;
					}
					uint64_t x79;
					VAL x80;
					VAL x81;
					switch (get_data_tag(x76)) {
						case 0LL: { // None
							x81 = v60;
							x80 = v58;
							x79 = x75;
						} break;
						default: {
							decref(v60);
							decref(v58);
							VAL v82 = MKI64(0LL /* Nil */);
							x81 = v82;
							x80 = x76;
							x79 = x75;
						} break;
					}
					int64_t v83 = 1LL /* True */;
					x64 = v83;
					x63 = x81;
					x62 = x80;
					x61 = x79;
				} break;
				case 0LL: { // None
					int64_t v84 = 0LL /* False */;
					x64 = v84;
					x63 = v60;
					x62 = v58;
					x61 = VU64(v57);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v85 = x61;
			VAL v86 = x62;
			VAL v87 = x63;
			int64_t v88 = x64;
			while (((bool)v88)) {
				uint64_t v89 = v85;
				VAL v90 = v86;
				VAL v91 = v87;
				VAL v92;
				VAL v93;
				mw_std_list_List_1_uncons(v91, &v92, &v93);
				uint64_t x94;
				VAL x95;
				VAL x96;
				int64_t x97;
				switch (get_data_tag(v92)) {
					case 1LL: { // Some
						VAL v98 = mtp_std_maybe_Maybe_1_Some(v92);
						incref(v98);
						VAL v99 = VVAL(VTUP(v98)->cells[1]);
						incref(v99);
						decref(v98);
						VAL v100 = mw_mirth_match_Pattern_singleZ_tagZAsk(v99);
						uint64_t x101;
						int64_t x102;
						switch (get_data_tag(v100)) {
							case 1LL: { // Some
								VAL v103 = mtp_std_maybe_Maybe_1_Some(v100);
								uint64_t v104 = mw_mirth_data_Tag_data(VU64(v103));
								int64_t v105 = mw_mirth_data_Data_ZEqualZEqual(v89, v104);
								x102 = v105;
								x101 = v89;
							} break;
							case 0LL: { // None
								int64_t v106 = 0LL /* False */;
								x102 = v106;
								x101 = v89;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						bool v107 = !((bool)x102);
						uint64_t x108;
						VAL x109;
						if (v107) {
							VAL v110 = mtw_std_maybe_Maybe_1_Some(v98);
							x109 = v110;
							x108 = x101;
						} else {
							decref(v98);
							VAL v111 = MKI64(0LL /* None */);
							x109 = v111;
							x108 = x101;
						}
						uint64_t x112;
						VAL x113;
						VAL x114;
						switch (get_data_tag(x109)) {
							case 0LL: { // None
								x114 = v93;
								x113 = v90;
								x112 = x108;
							} break;
							default: {
								decref(v93);
								decref(v90);
								VAL v115 = MKI64(0LL /* Nil */);
								x114 = v115;
								x113 = x109;
								x112 = x108;
							} break;
						}
						int64_t v116 = 1LL /* True */;
						x97 = v116;
						x96 = x114;
						x95 = x113;
						x94 = x112;
					} break;
					case 0LL: { // None
						int64_t v117 = 0LL /* False */;
						x97 = v117;
						x96 = v93;
						x95 = v90;
						x94 = v89;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v88 = x97;
				v87 = x96;
				v86 = x95;
				v85 = x94;
			}
			decref(v87);
			int64_t v118 = mw_std_maybe_Maybe_1_noneZAsk(v86);
			VAL x119;
			if (((bool)v118)) {
				VAL v120 = mtw_std_maybe_Maybe_1_Some(MKU64(v85));
				x119 = v120;
			} else {
				VAL v121 = MKI64(0LL /* None */);
				x119 = v121;
			}
			x56 = x119;
		} break;
		case 0LL: { // None
			decref(x50);
			VAL v122 = MKI64(0LL /* None */);
			x56 = v122;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x56;
}
static void mw_mirth_match_ZPlusMatch_addZ_case (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x3);
	int64_t v6;
	VAL v7;
	mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk(x3, x2, &v6, &v7);
	VAL x8;
	VAL x9;
	if (((bool)v6)) {
		VAL v10 = VVAL(VTUP(x3)->cells[1]);
		incref(v10);
		decref(x3);
		uint64_t v11 = VU64(VTUP(v10)->cells[2]);
		decref(v10);
		STR* v12;
		STRLIT(v12, "Case is unreachable.", 20);
		VAL v13 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v11, MKSTR(v12), x1));
		x9 = v7;
		x8 = v13;
	} else {
		VAL v14 = VVAL(VTUP(v7)->cells[7]);
		incref(v14);
		VAL v15 = mw_std_list_List_1_reverse(v14);
		VAL v16 = mtw_std_list_List_1_Cons(x3, v15);
		VAL v17 = mw_std_list_List_1_reverse(v16);
		VAL v18 = VTUP(v7)->cells[7];
		decref(v18);
		VTUP(v7)->cells[7] = v17;
		x9 = v7;
		x8 = x1;
	}
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk (VAL x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x2)->cells[7]);
	incref(v5);
	VAL v6 = MKI64(0LL /* None */);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v5, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v7);
			incref(v14);
			incref(x1);
			int64_t v15 = mw_mirth_match_Case_coversZAsk(x1, v14);
			VAL x16;
			VAL x17;
			VAL x18;
			if (((bool)v15)) {
				VAL v19 = mtw_std_maybe_Maybe_1_Some(v14);
				x18 = v19;
				x17 = x1;
				x16 = x2;
			} else {
				decref(v14);
				VAL v20 = MKI64(0LL /* None */);
				x18 = v20;
				x17 = x1;
				x16 = x2;
			}
			VAL x21;
			VAL x22;
			VAL x23;
			VAL x24;
			switch (get_data_tag(x18)) {
				case 0LL: { // None
					x24 = v8;
					x23 = v6;
					x22 = x17;
					x21 = x16;
				} break;
				default: {
					decref(v8);
					decref(v6);
					VAL v25 = MKI64(0LL /* Nil */);
					x24 = v25;
					x23 = x18;
					x22 = x17;
					x21 = x16;
				} break;
			}
			int64_t v26 = 1LL /* True */;
			x13 = v26;
			x12 = x24;
			x11 = x23;
			x10 = x22;
			x9 = x21;
		} break;
		case 0LL: { // None
			int64_t v27 = 0LL /* False */;
			x13 = v27;
			x12 = v8;
			x11 = v6;
			x10 = x1;
			x9 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v28 = (x9);
	VAL v29 = x10;
	VAL v30 = x11;
	VAL v31 = x12;
	int64_t v32 = x13;
	while (((bool)v32)) {
		VAL v33 = (v28);
		VAL v34 = v29;
		VAL v35 = v30;
		VAL v36 = v31;
		VAL v37;
		VAL v38;
		mw_std_list_List_1_uncons(v36, &v37, &v38);
		VAL x39;
		VAL x40;
		VAL x41;
		VAL x42;
		int64_t x43;
		switch (get_data_tag(v37)) {
			case 1LL: { // Some
				VAL v44 = mtp_std_maybe_Maybe_1_Some(v37);
				incref(v44);
				incref(v34);
				int64_t v45 = mw_mirth_match_Case_coversZAsk(v34, v44);
				VAL x46;
				VAL x47;
				VAL x48;
				if (((bool)v45)) {
					VAL v49 = mtw_std_maybe_Maybe_1_Some(v44);
					x48 = v49;
					x47 = v34;
					x46 = v33;
				} else {
					decref(v44);
					VAL v50 = MKI64(0LL /* None */);
					x48 = v50;
					x47 = v34;
					x46 = v33;
				}
				VAL x51;
				VAL x52;
				VAL x53;
				VAL x54;
				switch (get_data_tag(x48)) {
					case 0LL: { // None
						x54 = v38;
						x53 = v35;
						x52 = x47;
						x51 = x46;
					} break;
					default: {
						decref(v38);
						decref(v35);
						VAL v55 = MKI64(0LL /* Nil */);
						x54 = v55;
						x53 = x48;
						x52 = x47;
						x51 = x46;
					} break;
				}
				int64_t v56 = 1LL /* True */;
				x43 = v56;
				x42 = x54;
				x41 = x53;
				x40 = x52;
				x39 = x51;
			} break;
			case 0LL: { // None
				int64_t v57 = 0LL /* False */;
				x43 = v57;
				x42 = v38;
				x41 = v35;
				x40 = v34;
				x39 = v33;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v32 = x43;
		v31 = x42;
		v30 = x41;
		v29 = x40;
		v28 = x39;
	}
	decref(v31);
	decref(v29);
	int64_t v58 = mw_std_maybe_Maybe_1_someZAsk(v30);
	*x4 = v28;
	*x3 = v58;
}
static int64_t mw_mirth_match_Case_coversZAsk (VAL x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x1)->cells[1]);
	incref(v3);
	decref(x1);
	VAL v4 = VVAL(VTUP(x2)->cells[1]);
	incref(v4);
	decref(x2);
	int64_t v5 = mw_mirth_match_Pattern_coversZAsk(v3, v4);
	return v5;
}
static int64_t mw_mirth_match_Case_isZ_defaultZ_caseZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[1]);
	incref(v2);
	decref(x1);
	int64_t v3 = mw_mirth_match_Pattern_isZ_defaultZAsk(v2);
	return v3;
}
static VAL mw_mirth_match_Pattern_dom (VAL x1) {
	incref(x1);
	VAL v2 = VVAL(VTUP(x1)->cells[7]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[6]);
	incref(v3);
	decref(x1);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v3, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			VAL v10 = mtw_mirth_type_StackType_STCons(v2, v9);
			int64_t v11 = 1LL /* True */;
			x8 = v11;
			x7 = v5;
			x6 = v10;
		} break;
		case 0LL: { // None
			int64_t v12 = 0LL /* False */;
			x8 = v12;
			x7 = v5;
			x6 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v13 = x6;
	VAL v14 = x7;
	int64_t v15 = x8;
	while (((bool)v15)) {
		VAL v16 = v13;
		VAL v17 = v14;
		VAL v18;
		VAL v19;
		mw_std_list_List_1_uncons(v17, &v18, &v19);
		VAL x20;
		VAL x21;
		int64_t x22;
		switch (get_data_tag(v18)) {
			case 1LL: { // Some
				VAL v23 = mtp_std_maybe_Maybe_1_Some(v18);
				VAL v24 = mtw_mirth_type_StackType_STCons(v16, v23);
				int64_t v25 = 1LL /* True */;
				x22 = v25;
				x21 = v19;
				x20 = v24;
			} break;
			case 0LL: { // None
				int64_t v26 = 0LL /* False */;
				x22 = v26;
				x21 = v19;
				x20 = v16;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v15 = x22;
		v14 = x21;
		v13 = x20;
	}
	decref(v14);
	return v13;
}
static VAL mw_mirth_match_Pattern_thaw (VAL x1) {
	return x1;
}
static VAL mw_mirth_match_Pattern_singleZ_tagZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[9]);
	incref(v2);
	decref(x1);
	VAL v3 = mw_std_list_List_1_ZDivL1(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = VVAL(VTUP(v5)->cells[7]);
			incref(v6);
			decref(v5);
			VAL v7 = mw_mirth_match_PatternOp_ZDivPatOpTag(v6);
			x4 = v7;
		} break;
		case 0LL: { // None
			VAL v8 = MKI64(0LL /* None */);
			x4 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static int64_t mw_mirth_match_Pattern_isZ_defaultZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[9]);
	incref(v2);
	decref(x1);
	VAL v3 = MKI64(0LL /* None */);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v2, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			incref(v9);
			VAL v10 = VVAL(VTUP(v9)->cells[7]);
			incref(v10);
			decref(v9);
			int64_t v11 = mw_mirth_match_PatternOp_ZDivPatOpUnderscore(v10);
			bool v12 = !((bool)v11);
			VAL x13;
			if (v12) {
				VAL v14 = mtw_std_maybe_Maybe_1_Some(v9);
				x13 = v14;
			} else {
				decref(v9);
				VAL v15 = MKI64(0LL /* None */);
				x13 = v15;
			}
			VAL x16;
			VAL x17;
			switch (get_data_tag(x13)) {
				case 0LL: { // None
					x17 = v5;
					x16 = v3;
				} break;
				default: {
					decref(v5);
					decref(v3);
					VAL v18 = MKI64(0LL /* Nil */);
					x17 = v18;
					x16 = x13;
				} break;
			}
			int64_t v19 = 1LL /* True */;
			x8 = v19;
			x7 = x17;
			x6 = x16;
		} break;
		case 0LL: { // None
			int64_t v20 = 0LL /* False */;
			x8 = v20;
			x7 = v5;
			x6 = v3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v21 = x6;
	VAL v22 = x7;
	int64_t v23 = x8;
	while (((bool)v23)) {
		VAL v24 = v21;
		VAL v25 = v22;
		VAL v26;
		VAL v27;
		mw_std_list_List_1_uncons(v25, &v26, &v27);
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v26)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v26);
				incref(v31);
				VAL v32 = VVAL(VTUP(v31)->cells[7]);
				incref(v32);
				decref(v31);
				int64_t v33 = mw_mirth_match_PatternOp_ZDivPatOpUnderscore(v32);
				bool v34 = !((bool)v33);
				VAL x35;
				if (v34) {
					VAL v36 = mtw_std_maybe_Maybe_1_Some(v31);
					x35 = v36;
				} else {
					decref(v31);
					VAL v37 = MKI64(0LL /* None */);
					x35 = v37;
				}
				VAL x38;
				VAL x39;
				switch (get_data_tag(x35)) {
					case 0LL: { // None
						x39 = v27;
						x38 = v24;
					} break;
					default: {
						decref(v27);
						decref(v24);
						VAL v40 = MKI64(0LL /* Nil */);
						x39 = v40;
						x38 = x35;
					} break;
				}
				int64_t v41 = 1LL /* True */;
				x30 = v41;
				x29 = x39;
				x28 = x38;
			} break;
			case 0LL: { // None
				int64_t v42 = 0LL /* False */;
				x30 = v42;
				x29 = v27;
				x28 = v24;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v23 = x30;
		v22 = x29;
		v21 = x28;
	}
	decref(v22);
	int64_t v43 = mw_std_maybe_Maybe_1_noneZAsk(v21);
	return v43;
}
static VAL mw_mirth_match_ZPlusPattern_freezze (VAL x1) {
	return x1;
}
static void mw_mirth_match_ZPlusPattern_opZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL x6;
	VAL x7;
	switch (get_data_tag(x1)) {
		case 0LL: { // PatOpUnderscore
			VAL v8;
			VAL v9;
			mw_mirth_match_ZPlusPattern_underscoreZBang(x2, x3, &v8, &v9);
			x7 = v9;
			x6 = v8;
		} break;
		case 1LL: { // PatOpTag
			uint64_t v10 = mtp_mirth_match_PatternOp_PatOpTag(x1);
			VAL v11;
			VAL v12;
			mw_mirth_match_ZPlusPattern_tagZBang(x2, x3, v10, &v11, &v12);
			x7 = v12;
			x6 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_match_ZPlusPattern_underscoreZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	uint64_t v5 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	incref(x2);
	VAL v6 = VVAL(VTUP(x2)->cells[5]);
	incref(v6);
	decref(x2);
	incref(x2);
	VAL v7 = VVAL(VTUP(x2)->cells[7]);
	incref(v7);
	decref(x2);
	VAL v8 = MKI64(0LL /* SUBST_NIL */);
	VAL v9 = MKI64(0LL /* PatOpUnderscore */);
	incref(x2);
	VAL v10 = VVAL(VTUP(x2)->cells[7]);
	incref(v10);
	decref(x2);
	VAL v11 = mw_mirth_type_StackType_forceZ_consZAskZBang(v10);
	uint64_t x12;
	VAL x13;
	VAL x14;
	VAL x15;
	VAL x16;
	VAL x17;
	VAL x18;
	VAL x19;
	VAL x20;
	switch (get_data_tag(v11)) {
		case 0LL: { // None
			incref(x2);
			uint64_t v21 = VU64(VTUP(x2)->cells[2]);
			decref(x2);
			STR* v22;
			STRLIT(v22, "pattern expects something on stack", 34);
			VAL v23 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v21, MKSTR(v22), x1));
			VAL v24 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v25 = MKI64(0LL /* TYPE_ERROR */);
			x20 = v25;
			x19 = v24;
			x18 = x2;
			x17 = v23;
			x16 = v9;
			x15 = v8;
			x14 = v7;
			x13 = v6;
			x12 = v5;
		} break;
		case 1LL: { // Some
			VAL v26 = mtp_std_maybe_Maybe_1_Some(v11);
			VAL v27;
			VAL v28;
			value_uncons(v26, &v27, &v28);
			VAL v29;
			VAL v30;
			value_uncons(v27, &v29, &v30);
			decref(v29);
			x20 = v28;
			x19 = v30;
			x18 = x2;
			x17 = x1;
			x16 = v9;
			x15 = v8;
			x14 = v7;
			x13 = v6;
			x12 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	incref(x20);
	incref(x18);
	incref(x18);
	VAL v31 = VVAL(VTUP(x18)->cells[6]);
	incref(v31);
	decref(x18);
	VAL v32 = mtw_std_list_List_1_Cons(x20, v31);
	VAL v33 = tup_replace(x18, 6, v32);
	decref(x18);
	VAL v34 = MKI64(0LL /* Nil */);
	VAL v35 = mtw_std_list_List_1_Cons(x20, v34);
	incref(x19);
	incref(v33);
	VAL v36 = tup_replace(v33, 7, x19);
	decref(v33);
	VAL v37 = mtw_mirth_match_PatternAtom_PATATOM(x12, x13, v35, x19, x14, x15, x16);
	incref(v36);
	incref(v36);
	VAL v38 = VVAL(VTUP(v36)->cells[9]);
	incref(v38);
	decref(v36);
	VAL v39 = mtw_std_list_List_1_Cons(v37, v38);
	VAL v40 = tup_replace(v36, 9, v39);
	decref(v36);
	*x4 = v40;
	*x3 = x17;
}
static void mw_mirth_match_ZPlusPattern_tagZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_match_PatternOp_PatOpTag(x3);
	VAL v7 = MKI64(0LL /* Nil */);
	incref(x2);
	uint64_t v8 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	incref(x2);
	VAL v9 = VVAL(VTUP(x2)->cells[5]);
	incref(v9);
	decref(x2);
	VAL v10 = MKI64(0LL /* SUBST_NIL */);
	VAL v11;
	VAL v12;
	mw_mirth_data_Tag_type(x1, x3, &v11, &v12);
	VAL v13;
	VAL v14;
	mw_mirth_type_ArrowType_freshenZ_sig(v10, v12, &v13, &v14);
	VAL v15;
	VAL v16;
	mw_mirth_type_ArrowType_unpack(v14, &v15, &v16);
	incref(x2);
	VAL v17 = VVAL(VTUP(x2)->cells[7]);
	incref(v17);
	decref(x2);
	incref(x2);
	uint64_t v18 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	VAL v19;
	uint64_t v20;
	VAL v21;
	mw_mirth_type_StackType_unifyZBang(v11, v18, v17, v16, &v19, &v20, &v21);
	mw_mirth_type_ZPlusGamma_rdrop(v20);
	incref(v15);
	incref(x2);
	VAL v22 = tup_replace(x2, 7, v15);
	decref(x2);
	VAL v23 = mtw_mirth_match_PatternAtom_PATATOM(v8, v9, v7, v15, v21, v13, v6);
	incref(v22);
	incref(v22);
	VAL v24 = VVAL(VTUP(v22)->cells[9]);
	incref(v24);
	decref(v22);
	VAL v25 = mtw_std_list_List_1_Cons(v23, v24);
	VAL v26 = tup_replace(v22, 9, v25);
	decref(v22);
	*x5 = v26;
	*x4 = v19;
}
static int64_t mw_mirth_match_Pattern_coversZAsk (VAL x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x1)->cells[9]);
	incref(v3);
	decref(x1);
	VAL v4 = mw_std_list_List_1_ZDivL1(v3);
	VAL v5 = VVAL(VTUP(x2)->cells[9]);
	incref(v5);
	decref(x2);
	VAL v6 = mw_std_list_List_1_ZDivL1(v5);
	VAL v7 = mw_std_maybe_Maybe_1_zzip(v4, v6);
	int64_t x8;
	switch (get_data_tag(v7)) {
		case 0LL: { // None
			int64_t v9 = 0LL /* False */;
			x8 = v9;
		} break;
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v11;
			VAL v12;
			value_uncons(v10, &v11, &v12);
			VAL v13;
			VAL v14;
			value_uncons(v11, &v13, &v14);
			decref(v13);
			VAL v15 = VVAL(VTUP(v12)->cells[7]);
			incref(v15);
			decref(v12);
			int64_t x16;
			switch (get_data_tag(v15)) {
				case 0LL: { // PatOpUnderscore
					decref(v14);
					int64_t v17 = 1LL /* True */;
					x16 = v17;
				} break;
				case 1LL: { // PatOpTag
					uint64_t v18 = mtp_mirth_match_PatternOp_PatOpTag(v15);
					VAL v19 = VVAL(VTUP(v14)->cells[7]);
					incref(v19);
					decref(v14);
					int64_t x20;
					switch (get_data_tag(v19)) {
						case 0LL: { // PatOpUnderscore
							int64_t v21 = 0LL /* False */;
							x20 = v21;
						} break;
						case 1LL: { // PatOpTag
							uint64_t v22 = mtp_mirth_match_PatternOp_PatOpTag(v19);
							int64_t v23 = mw_mirth_data_Tag_ZEqualZEqual(v18, v22);
							x20 = v23;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x16 = x20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x8;
}
static VAL mw_mirth_match_PatternOp_ZDivPatOpTag (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 1LL: { // PatOpTag
			uint64_t v3 = mtp_mirth_match_PatternOp_PatOpTag(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_match_PatternOp_ZDivPatOpUnderscore (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // PatOpUnderscore
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_external_External_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_external_External_allocZBang (void) {
	void* v1 = mbuf_mirth_external_External_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_external_External_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_external_External_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_external_External_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_external_External_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_external_External_ZTildeqname(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static uint64_t mw_mirth_external_External_name (uint64_t x1) {
	void* v2 = mfld_mirth_external_External_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static int64_t mw_mirth_external_External_arity (uint64_t x1) {
	void* v2 = mfld_mirth_external_External_ZTildearity(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static VAL mw_mirth_external_External_symbol (uint64_t x1) {
	void* v2 = mfld_mirth_external_External_ZTildesymbol(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_external_External_head (uint64_t x1) {
	void* v2 = mfld_mirth_external_External_ZTildehead(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static uint64_t mw_mirth_external_External_sig (uint64_t x1) {
	void* v2 = mfld_mirth_external_External_ZTildesig(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static void mw_mirth_external_External_ctxZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5) {
	void* v6 = mfld_mirth_external_External_ZTildectxZ_type(x2);
	VAL v7;
	VAL v8;
	mw_mirth_mirth_Prop_1_forceZBang(v6, x1, &v7, &v8);
	VAL v9;
	VAL v10;
	value_uncons(v7, &v9, &v10);
	VAL v11;
	VAL v12;
	value_uncons(v9, &v11, &v12);
	decref(v11);
	*x5 = v10;
	*x4 = v12;
	*x3 = v8;
}
static void mw_mirth_external_External_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_external_External_ctxZ_type(x1, x2, &v5, &v6, &v7);
	decref(v6);
	*x4 = v7;
	*x3 = v5;
}
static void mw_mirth_external_External_ctype (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_external_External_ZTildectype(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static int64_t mw_mirth_external_External_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_external_External_index(x1);
	int64_t v4 = mw_mirth_external_External_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static uint64_t mw_mirth_external_ExternalBlock_allocZBang (void) {
	void* v1 = mbuf_mirth_external_ExternalBlock_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_external_ExternalBlock_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_external_ExternalBlock_parts (uint64_t x1) {
	void* v2 = mfld_mirth_external_ExternalBlock_ZTildeparts(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static int64_t mw_mirth_variable_Variable_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_variable_Variable_allocZBang (void) {
	void* v1 = mbuf_mirth_variable_Variable_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_variable_Variable_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_variable_Variable_qname (uint64_t x1) {
	void* v2 = mfld_mirth_variable_Variable_ZTildeqname(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_variable_Variable_name (uint64_t x1) {
	VAL v2 = mw_mirth_variable_Variable_qname(x1);
	uint64_t v3 = VU64(VTUP(v2)->cells[2]);
	decref(v2);
	return v3;
}
static void mw_mirth_variable_Variable_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_variable_Variable_ZTildetype(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static int64_t mw_mirth_variable_Variable_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_variable_Variable_index(x1);
	int64_t v4 = mw_mirth_variable_Variable_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_variable_Variable_newZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5) {
	uint64_t v6 = mw_mirth_variable_Variable_allocZBang();
	void* v7 = mfld_mirth_variable_Variable_ZTildeqname(v6);
	mut_set(x3, v7);
	void* v8 = mfld_mirth_variable_Variable_ZTildehead(v6);
	mut_set(MKU64(x2), v8);
	VAL v9 = mtw_mirth_def_Def_DefVariable(v6);
	VAL v10 = (mw_mirth_def_Def_register(x1, v9));
	*x5 = v6;
	*x4 = v10;
}
static int64_t mw_mirth_arrow_Block_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_arrow_Block_allocZBang (void) {
	void* v1 = mbuf_mirth_arrow_Block_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_arrow_Block_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static void mw_mirth_arrow_Arrow_ctxZ_type (VAL x1, VAL *x2, VAL *x3) {
	incref(x1);
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	decref(x1);
	VAL v5 = mw_mirth_arrow_Arrow_type(x1);
	*x3 = v5;
	*x2 = v4;
}
static VAL mw_mirth_arrow_Arrow_type (VAL x1) {
	incref(x1);
	VAL v2 = VVAL(VTUP(x1)->cells[5]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[6]);
	incref(v3);
	decref(x1);
	VAL v4 = mw_mirth_type_TZ_ZTo(v2, v3);
	return v4;
}
static VAL mw_mirth_arrow_Lambda_cod (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[5]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(v2)->cells[6]);
	incref(v3);
	decref(v2);
	return v3;
}
static VAL mw_mirth_arrow_Block_ctx (uint64_t x1) {
	void* v2 = mfld_mirth_arrow_Block_ZTildectx(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_arrow_Block_token (uint64_t x1) {
	void* v2 = mfld_mirth_arrow_Block_ZTildetoken(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_arrow_Block_dom (uint64_t x1) {
	void* v2 = mfld_mirth_arrow_Block_ZTildedom(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static VAL mw_mirth_arrow_Block_cod (uint64_t x1) {
	void* v2 = mfld_mirth_arrow_Block_ZTildecod(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static VAL mw_mirth_arrow_Block_home (uint64_t x1) {
	void* v2 = mfld_mirth_arrow_Block_ZTildehome(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static VAL mw_mirth_arrow_Block_type (uint64_t x1) {
	VAL v2 = mw_mirth_arrow_Block_dom(x1);
	VAL v3 = mw_mirth_arrow_Block_cod(x1);
	VAL v4 = mw_mirth_type_TZ_ZTo(v2, v3);
	return v4;
}
static void mw_mirth_arrow_Block_arrow (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_arrow_Block_ZTildearrow(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static void mw_mirth_arrow_Block_qname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_arrow_Block_ZTildeqname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11 = mw_mirth_arrow_Block_home(x2);
		uint64_t x12;
		VAL x13;
		VAL x14;
		switch (get_data_tag(v11)) {
			case 0LL: { // HomeMain
				uint64_t v15 = mtp_mirth_arrow_Home_HomeMain(v11);
				uint64_t v16 = mw_mirth_token_Token_module(v15);
				VAL v17 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v16);
				VAL v18;
				VAL v19;
				mw_mirth_arrow_Block_arrow(x1, x2, &v18, &v19);
				uint64_t v20 = VU64(VTUP(v19)->cells[2]);
				decref(v19);
				int64_t v21 = mw_mirth_token_Token_index(v20);
				STR* v22 = i64_show(v21);
				STR* v23;
				STRLIT(v23, "entry@", 6);
				STR* v24 = str_cat(v23, v22);
				uint64_t v25 = mw_std_prim_Str_ZToName(MKSTR(v24));
				VAL v26 = mw_mirth_name_QNAME0(v17, v25);
				x14 = v26;
				x13 = v18;
				x12 = x2;
			} break;
			case 1LL: { // HomeWord
				uint64_t v27 = mtp_mirth_arrow_Home_HomeWord(v11);
				VAL v28 = mtw_mirth_name_Namespace_NAMESPACEz_WORD(v27);
				VAL v29;
				VAL v30;
				mw_mirth_arrow_Block_arrow(x1, x2, &v29, &v30);
				VAL v31;
				VAL v32;
				mw_mirth_word_Word_arrow(v27, v29, &v31, &v32);
				uint64_t v33 = VU64(VTUP(v30)->cells[2]);
				decref(v30);
				int64_t v34 = mw_mirth_token_Token_index(v33);
				uint64_t v35 = VU64(VTUP(v31)->cells[2]);
				decref(v31);
				int64_t v36 = mw_mirth_token_Token_index(v35);
				int64_t v37 = i64_sub(v34, v36);
				STR* v38 = i64_show(v37);
				uint64_t v39 = mw_std_prim_Str_ZToName(MKSTR(v38));
				VAL v40 = mw_mirth_name_QNAME0(v28, v39);
				x14 = v40;
				x13 = v32;
				x12 = x2;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		incref(x14);
		mut_set(x14, v5);
		x9 = x14;
		x8 = x12;
		x7 = x13;
	}
	*x4 = x9;
	*x3 = x7;
}
static int64_t mw_mirth_arrow_Block_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_arrow_Block_index(x1);
	int64_t v4 = mw_mirth_arrow_Block_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_arrow_Block_registerZ_homeZBang (uint64_t x1) {
	VAL v2 = mw_mirth_arrow_Block_home(x1);
	switch (get_data_tag(v2)) {
		case 1LL: { // HomeWord
			uint64_t v3 = mtp_mirth_arrow_Home_HomeWord(v2);
			int64_t v4 = mw_mirth_word_Word_incZ_numZ_blocksZBang(v3);
			void* v5 = mfld_mirth_arrow_Block_ZTildehomeZ_index(x1);
			mut_set(MKI64(v4), v5);
		} break;
		case 0LL: { // HomeMain
			uint64_t v6 = mtp_mirth_arrow_Home_HomeMain(v2);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
}
static void mw_mirth_arrow_Block_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_arrow_Block_ZTildecname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11 = mw_mirth_arrow_Block_home(x2);
		VAL x12;
		uint64_t x13;
		VAL x14;
		switch (get_data_tag(v11)) {
			case 1LL: { // HomeWord
				uint64_t v15 = mtp_mirth_arrow_Home_HomeWord(v11);
				VAL v16;
				VAL v17;
				mw_mirth_word_Word_qnameZ_hard(v15, x1, &v16, &v17);
				VAL v18;
				VAL v19;
				mw_mirth_name_QName_mangled(v17, v16, &v18, &v19);
				STR* v20;
				STRLIT(v20, "", 0);
				STR* v21;
				STRLIT(v21, "mb_", 3);
				VAL v22 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v21), MKSTR(v20)));
				VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(v19, v22));
				STR* v24;
				STRLIT(v24, "_", 1);
				VAL v25 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), v23));
				void* v26 = mfld_mirth_arrow_Block_ZTildehomeZ_index(x2);
				VAL v27 = mut_get(v26);
				STR* v28 = i64_show(VI64(v27));
				VAL v29 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v28), v25));
				x14 = v29;
				x13 = x2;
				x12 = v18;
			} break;
			case 0LL: { // HomeMain
				uint64_t v30 = mtp_mirth_arrow_Home_HomeMain(v11);
				STR* v31;
				STRLIT(v31, "", 0);
				STR* v32;
				STRLIT(v32, "mb_", 3);
				VAL v33 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v32), MKSTR(v31)));
				int64_t v34 = mw_mirth_arrow_Block_index(x2);
				STR* v35 = i64_show(v34);
				VAL v36 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v35), v33));
				x14 = v36;
				x13 = x2;
				x12 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		incref(x14);
		mut_set(x14, v5);
		x9 = x14;
		x8 = x13;
		x7 = x12;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_arrow_Block_newZBang (VAL x1, VAL x2, VAL *x3, uint64_t *x4) {
	uint64_t v5 = mw_mirth_arrow_Block_allocZBang();
	incref(x2);
	VAL v6 = VVAL(VTUP(x2)->cells[1]);
	incref(v6);
	decref(x2);
	void* v7 = mfld_mirth_arrow_Block_ZTildehome(v5);
	mut_set(v6, v7);
	mw_mirth_arrow_Block_registerZ_homeZBang(v5);
	incref(x2);
	VAL v8 = VVAL(VTUP(x2)->cells[4]);
	incref(v8);
	decref(x2);
	void* v9 = mfld_mirth_arrow_Block_ZTildectx(v5);
	mut_set(v8, v9);
	incref(x2);
	uint64_t v10 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	void* v11 = mfld_mirth_arrow_Block_ZTildetoken(v5);
	mut_set(MKU64(v10), v11);
	incref(x2);
	VAL v12 = VVAL(VTUP(x2)->cells[5]);
	incref(v12);
	decref(x2);
	void* v13 = mfld_mirth_arrow_Block_ZTildedom(v5);
	mut_set(v12, v13);
	incref(x2);
	VAL v14 = VVAL(VTUP(x2)->cells[6]);
	incref(v14);
	decref(x2);
	void* v15 = mfld_mirth_arrow_Block_ZTildecod(v5);
	mut_set(v14, v15);
	VAL v16 = mtw_mirth_mirth_PropLabel_BlockArrow(v5);
	VAL v17;
	VAL v18;
	mw_mirth_mirth_PropLabel_prop(x2, v16, x1, &v17, &v18);
	void* v19 = mfld_mirth_arrow_Block_ZTildearrow(v5);
	mut_set(v17, v19);
	*x4 = v5;
	*x3 = v18;
}
static void mw_mirth_arrow_Block_newZ_deferredZBang_1 (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL x5, VAL *x6, uint64_t *x7) {
	push_resource(x1);
	push_value(x2);
	push_u64(x3);
	push_value(x4);
	push_value(x5);
	{
		VAL v8 = pop_value();
		VAL var_f = v8;
		uint64_t v9 = mw_mirth_arrow_Block_allocZBang();
		VAL v10 = pop_value();
		void* v11 = mfld_mirth_arrow_Block_ZTildehome(v9);
		mut_set(v10, v11);
		mw_mirth_arrow_Block_registerZ_homeZBang(v9);
		VAL v12 = pop_value();
		void* v13 = mfld_mirth_arrow_Block_ZTildetoken(v9);
		mut_set(v12, v13);
		VAL v14 = pop_value();
		void* v15 = mfld_mirth_arrow_Block_ZTildectx(v9);
		mut_set(v14, v15);
		uint64_t v16 = mw_mirth_type_MetaVar_newZBang();
		VAL v17 = mtw_mirth_type_StackType_STMeta(v16);
		void* v18 = mfld_mirth_arrow_Block_ZTildedom(v9);
		mut_set(v17, v18);
		uint64_t v19 = mw_mirth_type_MetaVar_newZBang();
		VAL v20 = mtw_mirth_type_StackType_STMeta(v19);
		void* v21 = mfld_mirth_arrow_Block_ZTildecod(v9);
		mut_set(v20, v21);
		VAL v22 = mtw_mirth_mirth_PropLabel_BlockArrow(v9);
		incref(var_f);
		VAL v23 = var_f;
		VAL r24 = pop_resource();
		VAL v25;
		VAL v26;
		mw_mirth_mirth_PropLabel_prop_1(MKU64(v9), v22, r24, v23, &v25, &v26);
		void* v27 = mfld_mirth_arrow_Block_ZTildearrow(v9);
		mut_set(v25, v27);
		decref(var_f);
		push_resource(v26);
		push_u64(v9);
	}
	uint64_t v28 = pop_u64();
	*x7 = v28;
	VAL r29 = pop_resource();
	*x6 = r29;
}
static VAL mw_mirth_arrow_Block_typecheckZBang (VAL x1, uint64_t x2) {
	VAL v3;
	VAL v4;
	mw_mirth_arrow_Block_arrow(x1, x2, &v3, &v4);
	decref(v4);
	return v3;
}
static void mw_mirth_arrow_blockZ_unifyZ_typeZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_arrow_Block_type(x3);
	VAL v9;
	uint64_t v10;
	VAL v11;
	mw_mirth_type_ArrowType_unifyZBang(x1, x2, v8, x4, &v9, &v10, &v11);
	decref(v11);
	VAL v12;
	VAL v13;
	mw_mirth_arrow_Block_arrow(v9, x3, &v12, &v13);
	VAL v14 = mw_mirth_arrow_Arrow_type(v13);
	*x7 = v14;
	*x6 = v10;
	*x5 = v12;
}
static void mw_mirth_arrow_Block_toZ_runZ_var (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_arrow(x1, x2, &v5, &v6);
	VAL v7 = mw_mirth_arrow_Arrow_toZ_runZ_var(v6);
	*x4 = v7;
	*x3 = v5;
}
static VAL mw_mirth_arrow_Arrow_toZ_runZ_var (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[7]);
	incref(v2);
	decref(x1);
	VAL v3 = mw_std_list_List_1_ZDivL1(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_arrow_Atom_toZ_runZ_var(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_arrow_Atom_toZ_runZ_var (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[4]);
	incref(v2);
	decref(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 13LL: { // OpVar
			uint64_t v4 = mtp_mirth_arrow_Op_OpVar(v2);
			VAL v5 = mw_mirth_var_Var_autoZ_runZAsk(v4);
			VAL x6;
			switch (get_data_tag(v5)) {
				case 1LL: { // Some
					VAL v7 = mtp_std_maybe_Maybe_1_Some(v5);
					decref(v7);
					VAL v8 = mtw_std_maybe_Maybe_1_Some(MKU64(v4));
					x6 = v8;
				} break;
				case 0LL: { // None
					VAL v9 = MKI64(0LL /* None */);
					x6 = v9;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x6;
		} break;
		default: {
			decref(v2);
			VAL v10 = MKI64(0LL /* None */);
			x3 = v10;
		} break;
	}
	return x3;
}
static void mw_mirth_arrow_Arg_ZToStr (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_qname(x1, x2, &v5, &v6);
	VAL v7;
	VAL v8;
	mw_mirth_name_QName_ZToStr(v5, v6, &v7, &v8);
	*x4 = v8;
	*x3 = v7;
}
static int64_t mw_mirth_arrow_Arg_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_arrow_Block_ZEqualZEqual(x1, x2);
	return v3;
}
static void mw_mirth_arrow_Block_freeZ_vars (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_arrow_Block_ZTildefreeZ_vars(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11;
		VAL v12;
		mw_mirth_arrow_Block_arrow(x1, x2, &v11, &v12);
		VAL v13;
		VAL v14;
		mw_mirth_arrow_Arrow_freeZ_vars(v11, v12, &v13, &v14);
		incref(v14);
		mut_set(v14, v5);
		x9 = v14;
		x8 = x2;
		x7 = v13;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_arrow_Arrow_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x2)->cells[7]);
	incref(v5);
	decref(x2);
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v5, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v15;
			VAL v16;
			mw_mirth_arrow_Atom_freeZ_vars(x1, v14, &v15, &v16);
			VAL v17 = mtw_std_list_List_1_Cons(v16, v7);
			int64_t v18 = 1LL /* True */;
			x13 = v18;
			x12 = v9;
			x11 = v17;
			x10 = v15;
		} break;
		case 0LL: { // None
			int64_t v19 = 0LL /* False */;
			x13 = v19;
			x12 = v9;
			x11 = v7;
			x10 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v20 = (x10);
	VAL v21 = (x11);
	VAL v22 = x12;
	int64_t v23 = x13;
	while (((bool)v23)) {
		VAL v24 = (v20);
		VAL v25 = (v21);
		VAL v26 = v22;
		VAL v27;
		VAL v28;
		mw_std_list_List_1_uncons(v26, &v27, &v28);
		VAL x29;
		VAL x30;
		VAL x31;
		int64_t x32;
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				VAL v33 = mtp_std_maybe_Maybe_1_Some(v27);
				VAL v34;
				VAL v35;
				mw_mirth_arrow_Atom_freeZ_vars(v24, v33, &v34, &v35);
				VAL v36 = mtw_std_list_List_1_Cons(v35, v25);
				int64_t v37 = 1LL /* True */;
				x32 = v37;
				x31 = v28;
				x30 = v36;
				x29 = v34;
			} break;
			case 0LL: { // None
				int64_t v38 = 0LL /* False */;
				x32 = v38;
				x31 = v28;
				x30 = v25;
				x29 = v24;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v23 = x32;
		v22 = x31;
		v21 = x30;
		v20 = x29;
	}
	decref(v22);
	VAL v39 = mw_std_list_List_1_reverse(v21);
	VAL v40 = mw_std_list_List_1_ZToListZPlus(v39);
	VAL x41;
	VAL x42;
	switch (get_data_tag(v40)) {
		case 1LL: { // Some
			VAL v43 = mtp_std_maybe_Maybe_1_Some(v40);
			VAL v44;
			VAL v45;
			mw_std_list_ListZPlus_1_uncons(v43, &v44, &v45);
			VAL v46;
			VAL v47;
			mw_std_list_List_1_uncons(v45, &v46, &v47);
			VAL x48;
			VAL x49;
			VAL x50;
			int64_t x51;
			switch (get_data_tag(v46)) {
				case 1LL: { // Some
					VAL v52 = mtp_std_maybe_Maybe_1_Some(v46);
					incref(v44);
					VAL v53 = MKI64(0LL /* Nil */);
					VAL v54 = mw_std_list_List_1_reverse(v53);
					VAL v55;
					VAL v56;
					mw_std_list_List_1_uncons(v52, &v55, &v56);
					VAL x57;
					VAL x58;
					VAL x59;
					VAL x60;
					int64_t x61;
					switch (get_data_tag(v55)) {
						case 1LL: { // Some
							VAL v62 = mtp_std_maybe_Maybe_1_Some(v55);
							incref(v62);
							incref(v44);
							VAL v63 = MKI64(0LL /* None */);
							VAL v64;
							VAL v65;
							mw_std_list_List_1_uncons(v44, &v64, &v65);
							VAL x66;
							uint64_t x67;
							VAL x68;
							VAL x69;
							int64_t x70;
							switch (get_data_tag(v64)) {
								case 1LL: { // Some
									VAL v71 = mtp_std_maybe_Maybe_1_Some(v64);
									incref(v71);
									incref(v62);
									int64_t v72 = mw_mirth_var_Var_ZEqualZEqual(VU64(v62), VU64(v71));
									VAL x73;
									uint64_t x74;
									VAL x75;
									if (((bool)v72)) {
										VAL v76 = mtw_std_maybe_Maybe_1_Some(v71);
										x75 = v76;
										x74 = VU64(v62);
										x73 = v20;
									} else {
										decref(v71);
										VAL v77 = MKI64(0LL /* None */);
										x75 = v77;
										x74 = VU64(v62);
										x73 = v20;
									}
									VAL x78;
									uint64_t x79;
									VAL x80;
									VAL x81;
									switch (get_data_tag(x75)) {
										case 0LL: { // None
											x81 = v65;
											x80 = v63;
											x79 = x74;
											x78 = x73;
										} break;
										default: {
											decref(v65);
											decref(v63);
											VAL v82 = MKI64(0LL /* Nil */);
											x81 = v82;
											x80 = x75;
											x79 = x74;
											x78 = x73;
										} break;
									}
									int64_t v83 = 1LL /* True */;
									x70 = v83;
									x69 = x81;
									x68 = x80;
									x67 = x79;
									x66 = x78;
								} break;
								case 0LL: { // None
									int64_t v84 = 0LL /* False */;
									x70 = v84;
									x69 = v65;
									x68 = v63;
									x67 = VU64(v62);
									x66 = v20;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v85 = (x66);
							uint64_t v86 = x67;
							VAL v87 = x68;
							VAL v88 = x69;
							int64_t v89 = x70;
							while (((bool)v89)) {
								VAL v90 = (v85);
								uint64_t v91 = v86;
								VAL v92 = v87;
								VAL v93 = v88;
								VAL v94;
								VAL v95;
								mw_std_list_List_1_uncons(v93, &v94, &v95);
								VAL x96;
								uint64_t x97;
								VAL x98;
								VAL x99;
								int64_t x100;
								switch (get_data_tag(v94)) {
									case 1LL: { // Some
										VAL v101 = mtp_std_maybe_Maybe_1_Some(v94);
										incref(v101);
										int64_t v102 = mw_mirth_var_Var_ZEqualZEqual(v91, VU64(v101));
										VAL x103;
										uint64_t x104;
										VAL x105;
										if (((bool)v102)) {
											VAL v106 = mtw_std_maybe_Maybe_1_Some(v101);
											x105 = v106;
											x104 = v91;
											x103 = v90;
										} else {
											decref(v101);
											VAL v107 = MKI64(0LL /* None */);
											x105 = v107;
											x104 = v91;
											x103 = v90;
										}
										VAL x108;
										uint64_t x109;
										VAL x110;
										VAL x111;
										switch (get_data_tag(x105)) {
											case 0LL: { // None
												x111 = v95;
												x110 = v92;
												x109 = x104;
												x108 = x103;
											} break;
											default: {
												decref(v95);
												decref(v92);
												VAL v112 = MKI64(0LL /* Nil */);
												x111 = v112;
												x110 = x105;
												x109 = x104;
												x108 = x103;
											} break;
										}
										int64_t v113 = 1LL /* True */;
										x100 = v113;
										x99 = x111;
										x98 = x110;
										x97 = x109;
										x96 = x108;
									} break;
									case 0LL: { // None
										int64_t v114 = 0LL /* False */;
										x100 = v114;
										x99 = v95;
										x98 = v92;
										x97 = v91;
										x96 = v90;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v89 = x100;
								v88 = x99;
								v87 = x98;
								v86 = x97;
								v85 = x96;
							}
							decref(v88);
							int64_t v115 = mw_std_maybe_Maybe_1_someZAsk(v87);
							bool v116 = !((bool)v115);
							VAL x117;
							VAL x118;
							VAL x119;
							if (v116) {
								VAL v120 = mtw_std_maybe_Maybe_1_Some(v62);
								x119 = v120;
								x118 = v44;
								x117 = v85;
							} else {
								decref(v62);
								VAL v121 = MKI64(0LL /* None */);
								x119 = v121;
								x118 = v44;
								x117 = v85;
							}
							VAL x122;
							switch (get_data_tag(x119)) {
								case 1LL: { // Some
									VAL v123 = mtp_std_maybe_Maybe_1_Some(x119);
									VAL v124 = mtw_std_list_List_1_Cons(v123, v54);
									x122 = v124;
									push_resource(x117);
									push_value(x118);
								} break;
								case 0LL: { // None
									x122 = v54;
									push_resource(x117);
									push_value(x118);
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v125 = 1LL /* True */;
							x61 = v125;
							x60 = v56;
							x59 = x122;
							VAL v126 = pop_value();
							x58 = v126;
							VAL r127 = pop_resource();
							x57 = r127;
						} break;
						case 0LL: { // None
							int64_t v128 = 0LL /* False */;
							x61 = v128;
							x60 = v56;
							x59 = v54;
							x58 = v44;
							x57 = v20;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v129 = (x57);
					VAL v130 = x58;
					VAL v131 = (x59);
					VAL v132 = x60;
					int64_t v133 = x61;
					while (((bool)v133)) {
						VAL v134 = (v129);
						VAL v135 = v130;
						VAL v136 = (v131);
						VAL v137 = v132;
						VAL v138;
						VAL v139;
						mw_std_list_List_1_uncons(v137, &v138, &v139);
						VAL x140;
						VAL x141;
						VAL x142;
						VAL x143;
						int64_t x144;
						switch (get_data_tag(v138)) {
							case 1LL: { // Some
								VAL v145 = mtp_std_maybe_Maybe_1_Some(v138);
								incref(v145);
								incref(v135);
								VAL v146 = MKI64(0LL /* None */);
								VAL v147;
								VAL v148;
								mw_std_list_List_1_uncons(v135, &v147, &v148);
								VAL x149;
								uint64_t x150;
								VAL x151;
								VAL x152;
								int64_t x153;
								switch (get_data_tag(v147)) {
									case 1LL: { // Some
										VAL v154 = mtp_std_maybe_Maybe_1_Some(v147);
										incref(v154);
										incref(v145);
										int64_t v155 = mw_mirth_var_Var_ZEqualZEqual(VU64(v145), VU64(v154));
										VAL x156;
										uint64_t x157;
										VAL x158;
										if (((bool)v155)) {
											VAL v159 = mtw_std_maybe_Maybe_1_Some(v154);
											x158 = v159;
											x157 = VU64(v145);
											x156 = v134;
										} else {
											decref(v154);
											VAL v160 = MKI64(0LL /* None */);
											x158 = v160;
											x157 = VU64(v145);
											x156 = v134;
										}
										VAL x161;
										uint64_t x162;
										VAL x163;
										VAL x164;
										switch (get_data_tag(x158)) {
											case 0LL: { // None
												x164 = v148;
												x163 = v146;
												x162 = x157;
												x161 = x156;
											} break;
											default: {
												decref(v148);
												decref(v146);
												VAL v165 = MKI64(0LL /* Nil */);
												x164 = v165;
												x163 = x158;
												x162 = x157;
												x161 = x156;
											} break;
										}
										int64_t v166 = 1LL /* True */;
										x153 = v166;
										x152 = x164;
										x151 = x163;
										x150 = x162;
										x149 = x161;
									} break;
									case 0LL: { // None
										int64_t v167 = 0LL /* False */;
										x153 = v167;
										x152 = v148;
										x151 = v146;
										x150 = VU64(v145);
										x149 = v134;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v168 = (x149);
								uint64_t v169 = x150;
								VAL v170 = x151;
								VAL v171 = x152;
								int64_t v172 = x153;
								while (((bool)v172)) {
									VAL v173 = (v168);
									uint64_t v174 = v169;
									VAL v175 = v170;
									VAL v176 = v171;
									VAL v177;
									VAL v178;
									mw_std_list_List_1_uncons(v176, &v177, &v178);
									VAL x179;
									uint64_t x180;
									VAL x181;
									VAL x182;
									int64_t x183;
									switch (get_data_tag(v177)) {
										case 1LL: { // Some
											VAL v184 = mtp_std_maybe_Maybe_1_Some(v177);
											incref(v184);
											int64_t v185 = mw_mirth_var_Var_ZEqualZEqual(v174, VU64(v184));
											VAL x186;
											uint64_t x187;
											VAL x188;
											if (((bool)v185)) {
												VAL v189 = mtw_std_maybe_Maybe_1_Some(v184);
												x188 = v189;
												x187 = v174;
												x186 = v173;
											} else {
												decref(v184);
												VAL v190 = MKI64(0LL /* None */);
												x188 = v190;
												x187 = v174;
												x186 = v173;
											}
											VAL x191;
											uint64_t x192;
											VAL x193;
											VAL x194;
											switch (get_data_tag(x188)) {
												case 0LL: { // None
													x194 = v178;
													x193 = v175;
													x192 = x187;
													x191 = x186;
												} break;
												default: {
													decref(v178);
													decref(v175);
													VAL v195 = MKI64(0LL /* Nil */);
													x194 = v195;
													x193 = x188;
													x192 = x187;
													x191 = x186;
												} break;
											}
											int64_t v196 = 1LL /* True */;
											x183 = v196;
											x182 = x194;
											x181 = x193;
											x180 = x192;
											x179 = x191;
										} break;
										case 0LL: { // None
											int64_t v197 = 0LL /* False */;
											x183 = v197;
											x182 = v178;
											x181 = v175;
											x180 = v174;
											x179 = v173;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v172 = x183;
									v171 = x182;
									v170 = x181;
									v169 = x180;
									v168 = x179;
								}
								decref(v171);
								int64_t v198 = mw_std_maybe_Maybe_1_someZAsk(v170);
								bool v199 = !((bool)v198);
								VAL x200;
								VAL x201;
								VAL x202;
								if (v199) {
									VAL v203 = mtw_std_maybe_Maybe_1_Some(v145);
									x202 = v203;
									x201 = v135;
									x200 = v168;
								} else {
									decref(v145);
									VAL v204 = MKI64(0LL /* None */);
									x202 = v204;
									x201 = v135;
									x200 = v168;
								}
								VAL x205;
								switch (get_data_tag(x202)) {
									case 1LL: { // Some
										VAL v206 = mtp_std_maybe_Maybe_1_Some(x202);
										VAL v207 = mtw_std_list_List_1_Cons(v206, v136);
										x205 = v207;
										push_resource(x200);
										push_value(x201);
									} break;
									case 0LL: { // None
										x205 = v136;
										push_resource(x200);
										push_value(x201);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v208 = 1LL /* True */;
								x144 = v208;
								x143 = v139;
								x142 = x205;
								VAL v209 = pop_value();
								x141 = v209;
								VAL r210 = pop_resource();
								x140 = r210;
							} break;
							case 0LL: { // None
								int64_t v211 = 0LL /* False */;
								x144 = v211;
								x143 = v139;
								x142 = v136;
								x141 = v135;
								x140 = v134;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v133 = x144;
						v132 = x143;
						v131 = x142;
						v130 = x141;
						v129 = x140;
					}
					decref(v132);
					VAL v212 = mw_std_list_List_1_reverse(v131);
					decref(v130);
					VAL v213 = mw_std_list_List_1_cat(v44, v212);
					int64_t v214 = 1LL /* True */;
					x51 = v214;
					x50 = v47;
					x49 = v213;
					x48 = v129;
				} break;
				case 0LL: { // None
					int64_t v215 = 0LL /* False */;
					x51 = v215;
					x50 = v47;
					x49 = v44;
					x48 = v20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v216 = (x48);
			VAL v217 = x49;
			VAL v218 = x50;
			int64_t v219 = x51;
			while (((bool)v219)) {
				VAL v220 = (v216);
				VAL v221 = v217;
				VAL v222 = v218;
				VAL v223;
				VAL v224;
				mw_std_list_List_1_uncons(v222, &v223, &v224);
				VAL x225;
				VAL x226;
				VAL x227;
				int64_t x228;
				switch (get_data_tag(v223)) {
					case 1LL: { // Some
						VAL v229 = mtp_std_maybe_Maybe_1_Some(v223);
						incref(v221);
						VAL v230 = MKI64(0LL /* Nil */);
						VAL v231 = mw_std_list_List_1_reverse(v230);
						VAL v232;
						VAL v233;
						mw_std_list_List_1_uncons(v229, &v232, &v233);
						VAL x234;
						VAL x235;
						VAL x236;
						VAL x237;
						int64_t x238;
						switch (get_data_tag(v232)) {
							case 1LL: { // Some
								VAL v239 = mtp_std_maybe_Maybe_1_Some(v232);
								incref(v239);
								incref(v221);
								VAL v240 = MKI64(0LL /* None */);
								VAL v241;
								VAL v242;
								mw_std_list_List_1_uncons(v221, &v241, &v242);
								VAL x243;
								uint64_t x244;
								VAL x245;
								VAL x246;
								int64_t x247;
								switch (get_data_tag(v241)) {
									case 1LL: { // Some
										VAL v248 = mtp_std_maybe_Maybe_1_Some(v241);
										incref(v248);
										incref(v239);
										int64_t v249 = mw_mirth_var_Var_ZEqualZEqual(VU64(v239), VU64(v248));
										VAL x250;
										uint64_t x251;
										VAL x252;
										if (((bool)v249)) {
											VAL v253 = mtw_std_maybe_Maybe_1_Some(v248);
											x252 = v253;
											x251 = VU64(v239);
											x250 = v220;
										} else {
											decref(v248);
											VAL v254 = MKI64(0LL /* None */);
											x252 = v254;
											x251 = VU64(v239);
											x250 = v220;
										}
										VAL x255;
										uint64_t x256;
										VAL x257;
										VAL x258;
										switch (get_data_tag(x252)) {
											case 0LL: { // None
												x258 = v242;
												x257 = v240;
												x256 = x251;
												x255 = x250;
											} break;
											default: {
												decref(v242);
												decref(v240);
												VAL v259 = MKI64(0LL /* Nil */);
												x258 = v259;
												x257 = x252;
												x256 = x251;
												x255 = x250;
											} break;
										}
										int64_t v260 = 1LL /* True */;
										x247 = v260;
										x246 = x258;
										x245 = x257;
										x244 = x256;
										x243 = x255;
									} break;
									case 0LL: { // None
										int64_t v261 = 0LL /* False */;
										x247 = v261;
										x246 = v242;
										x245 = v240;
										x244 = VU64(v239);
										x243 = v220;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v262 = (x243);
								uint64_t v263 = x244;
								VAL v264 = x245;
								VAL v265 = x246;
								int64_t v266 = x247;
								while (((bool)v266)) {
									VAL v267 = (v262);
									uint64_t v268 = v263;
									VAL v269 = v264;
									VAL v270 = v265;
									VAL v271;
									VAL v272;
									mw_std_list_List_1_uncons(v270, &v271, &v272);
									VAL x273;
									uint64_t x274;
									VAL x275;
									VAL x276;
									int64_t x277;
									switch (get_data_tag(v271)) {
										case 1LL: { // Some
											VAL v278 = mtp_std_maybe_Maybe_1_Some(v271);
											incref(v278);
											int64_t v279 = mw_mirth_var_Var_ZEqualZEqual(v268, VU64(v278));
											VAL x280;
											uint64_t x281;
											VAL x282;
											if (((bool)v279)) {
												VAL v283 = mtw_std_maybe_Maybe_1_Some(v278);
												x282 = v283;
												x281 = v268;
												x280 = v267;
											} else {
												decref(v278);
												VAL v284 = MKI64(0LL /* None */);
												x282 = v284;
												x281 = v268;
												x280 = v267;
											}
											VAL x285;
											uint64_t x286;
											VAL x287;
											VAL x288;
											switch (get_data_tag(x282)) {
												case 0LL: { // None
													x288 = v272;
													x287 = v269;
													x286 = x281;
													x285 = x280;
												} break;
												default: {
													decref(v272);
													decref(v269);
													VAL v289 = MKI64(0LL /* Nil */);
													x288 = v289;
													x287 = x282;
													x286 = x281;
													x285 = x280;
												} break;
											}
											int64_t v290 = 1LL /* True */;
											x277 = v290;
											x276 = x288;
											x275 = x287;
											x274 = x286;
											x273 = x285;
										} break;
										case 0LL: { // None
											int64_t v291 = 0LL /* False */;
											x277 = v291;
											x276 = v272;
											x275 = v269;
											x274 = v268;
											x273 = v267;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v266 = x277;
									v265 = x276;
									v264 = x275;
									v263 = x274;
									v262 = x273;
								}
								decref(v265);
								int64_t v292 = mw_std_maybe_Maybe_1_someZAsk(v264);
								bool v293 = !((bool)v292);
								VAL x294;
								VAL x295;
								VAL x296;
								if (v293) {
									VAL v297 = mtw_std_maybe_Maybe_1_Some(v239);
									x296 = v297;
									x295 = v221;
									x294 = v262;
								} else {
									decref(v239);
									VAL v298 = MKI64(0LL /* None */);
									x296 = v298;
									x295 = v221;
									x294 = v262;
								}
								VAL x299;
								switch (get_data_tag(x296)) {
									case 1LL: { // Some
										VAL v300 = mtp_std_maybe_Maybe_1_Some(x296);
										VAL v301 = mtw_std_list_List_1_Cons(v300, v231);
										x299 = v301;
										push_resource(x294);
										push_value(x295);
									} break;
									case 0LL: { // None
										x299 = v231;
										push_resource(x294);
										push_value(x295);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v302 = 1LL /* True */;
								x238 = v302;
								x237 = v233;
								x236 = x299;
								VAL v303 = pop_value();
								x235 = v303;
								VAL r304 = pop_resource();
								x234 = r304;
							} break;
							case 0LL: { // None
								int64_t v305 = 0LL /* False */;
								x238 = v305;
								x237 = v233;
								x236 = v231;
								x235 = v221;
								x234 = v220;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v306 = (x234);
						VAL v307 = x235;
						VAL v308 = (x236);
						VAL v309 = x237;
						int64_t v310 = x238;
						while (((bool)v310)) {
							VAL v311 = (v306);
							VAL v312 = v307;
							VAL v313 = (v308);
							VAL v314 = v309;
							VAL v315;
							VAL v316;
							mw_std_list_List_1_uncons(v314, &v315, &v316);
							VAL x317;
							VAL x318;
							VAL x319;
							VAL x320;
							int64_t x321;
							switch (get_data_tag(v315)) {
								case 1LL: { // Some
									VAL v322 = mtp_std_maybe_Maybe_1_Some(v315);
									incref(v322);
									incref(v312);
									VAL v323 = MKI64(0LL /* None */);
									VAL v324;
									VAL v325;
									mw_std_list_List_1_uncons(v312, &v324, &v325);
									VAL x326;
									uint64_t x327;
									VAL x328;
									VAL x329;
									int64_t x330;
									switch (get_data_tag(v324)) {
										case 1LL: { // Some
											VAL v331 = mtp_std_maybe_Maybe_1_Some(v324);
											incref(v331);
											incref(v322);
											int64_t v332 = mw_mirth_var_Var_ZEqualZEqual(VU64(v322), VU64(v331));
											VAL x333;
											uint64_t x334;
											VAL x335;
											if (((bool)v332)) {
												VAL v336 = mtw_std_maybe_Maybe_1_Some(v331);
												x335 = v336;
												x334 = VU64(v322);
												x333 = v311;
											} else {
												decref(v331);
												VAL v337 = MKI64(0LL /* None */);
												x335 = v337;
												x334 = VU64(v322);
												x333 = v311;
											}
											VAL x338;
											uint64_t x339;
											VAL x340;
											VAL x341;
											switch (get_data_tag(x335)) {
												case 0LL: { // None
													x341 = v325;
													x340 = v323;
													x339 = x334;
													x338 = x333;
												} break;
												default: {
													decref(v325);
													decref(v323);
													VAL v342 = MKI64(0LL /* Nil */);
													x341 = v342;
													x340 = x335;
													x339 = x334;
													x338 = x333;
												} break;
											}
											int64_t v343 = 1LL /* True */;
											x330 = v343;
											x329 = x341;
											x328 = x340;
											x327 = x339;
											x326 = x338;
										} break;
										case 0LL: { // None
											int64_t v344 = 0LL /* False */;
											x330 = v344;
											x329 = v325;
											x328 = v323;
											x327 = VU64(v322);
											x326 = v311;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									VAL v345 = (x326);
									uint64_t v346 = x327;
									VAL v347 = x328;
									VAL v348 = x329;
									int64_t v349 = x330;
									while (((bool)v349)) {
										VAL v350 = (v345);
										uint64_t v351 = v346;
										VAL v352 = v347;
										VAL v353 = v348;
										VAL v354;
										VAL v355;
										mw_std_list_List_1_uncons(v353, &v354, &v355);
										VAL x356;
										uint64_t x357;
										VAL x358;
										VAL x359;
										int64_t x360;
										switch (get_data_tag(v354)) {
											case 1LL: { // Some
												VAL v361 = mtp_std_maybe_Maybe_1_Some(v354);
												incref(v361);
												int64_t v362 = mw_mirth_var_Var_ZEqualZEqual(v351, VU64(v361));
												VAL x363;
												uint64_t x364;
												VAL x365;
												if (((bool)v362)) {
													VAL v366 = mtw_std_maybe_Maybe_1_Some(v361);
													x365 = v366;
													x364 = v351;
													x363 = v350;
												} else {
													decref(v361);
													VAL v367 = MKI64(0LL /* None */);
													x365 = v367;
													x364 = v351;
													x363 = v350;
												}
												VAL x368;
												uint64_t x369;
												VAL x370;
												VAL x371;
												switch (get_data_tag(x365)) {
													case 0LL: { // None
														x371 = v355;
														x370 = v352;
														x369 = x364;
														x368 = x363;
													} break;
													default: {
														decref(v355);
														decref(v352);
														VAL v372 = MKI64(0LL /* Nil */);
														x371 = v372;
														x370 = x365;
														x369 = x364;
														x368 = x363;
													} break;
												}
												int64_t v373 = 1LL /* True */;
												x360 = v373;
												x359 = x371;
												x358 = x370;
												x357 = x369;
												x356 = x368;
											} break;
											case 0LL: { // None
												int64_t v374 = 0LL /* False */;
												x360 = v374;
												x359 = v355;
												x358 = v352;
												x357 = v351;
												x356 = v350;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										v349 = x360;
										v348 = x359;
										v347 = x358;
										v346 = x357;
										v345 = x356;
									}
									decref(v348);
									int64_t v375 = mw_std_maybe_Maybe_1_someZAsk(v347);
									bool v376 = !((bool)v375);
									VAL x377;
									VAL x378;
									VAL x379;
									if (v376) {
										VAL v380 = mtw_std_maybe_Maybe_1_Some(v322);
										x379 = v380;
										x378 = v312;
										x377 = v345;
									} else {
										decref(v322);
										VAL v381 = MKI64(0LL /* None */);
										x379 = v381;
										x378 = v312;
										x377 = v345;
									}
									VAL x382;
									switch (get_data_tag(x379)) {
										case 1LL: { // Some
											VAL v383 = mtp_std_maybe_Maybe_1_Some(x379);
											VAL v384 = mtw_std_list_List_1_Cons(v383, v313);
											x382 = v384;
											push_resource(x377);
											push_value(x378);
										} break;
										case 0LL: { // None
											x382 = v313;
											push_resource(x377);
											push_value(x378);
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									int64_t v385 = 1LL /* True */;
									x321 = v385;
									x320 = v316;
									x319 = x382;
									VAL v386 = pop_value();
									x318 = v386;
									VAL r387 = pop_resource();
									x317 = r387;
								} break;
								case 0LL: { // None
									int64_t v388 = 0LL /* False */;
									x321 = v388;
									x320 = v316;
									x319 = v313;
									x318 = v312;
									x317 = v311;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v310 = x321;
							v309 = x320;
							v308 = x319;
							v307 = x318;
							v306 = x317;
						}
						decref(v309);
						VAL v389 = mw_std_list_List_1_reverse(v308);
						decref(v307);
						VAL v390 = mw_std_list_List_1_cat(v221, v389);
						int64_t v391 = 1LL /* True */;
						x228 = v391;
						x227 = v224;
						x226 = v390;
						x225 = v306;
					} break;
					case 0LL: { // None
						int64_t v392 = 0LL /* False */;
						x228 = v392;
						x227 = v224;
						x226 = v221;
						x225 = v220;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v219 = x228;
				v218 = x227;
				v217 = x226;
				v216 = x225;
			}
			decref(v218);
			VAL v393 = mtw_std_maybe_Maybe_1_Some(v217);
			x42 = v393;
			x41 = v216;
		} break;
		case 0LL: { // None
			VAL v394 = MKI64(0LL /* None */);
			x42 = v394;
			x41 = v20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x395;
	VAL x396;
	switch (get_data_tag(x42)) {
		case 1LL: { // Some
			VAL v397 = mtp_std_maybe_Maybe_1_Some(x42);
			x396 = v397;
			x395 = x41;
		} break;
		case 0LL: { // None
			VAL v398 = MKI64(0LL /* Nil */);
			x396 = v398;
			x395 = x41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x396;
	*x3 = x395;
}
static void mw_mirth_arrow_Atom_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	VAL v5 = VVAL(VTUP(x2)->cells[5]);
	incref(v5);
	decref(x2);
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v5, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	VAL x13;
	int64_t x14;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v16;
			VAL v17;
			mw_mirth_arrow_Arg_freeZ_vars(x1, VU64(v15), &v16, &v17);
			VAL v18 = mtw_std_list_List_1_Cons(v17, v7);
			int64_t v19 = 1LL /* True */;
			x14 = v19;
			x13 = v9;
			x12 = v18;
			x11 = x2;
			x10 = v16;
		} break;
		case 0LL: { // None
			int64_t v20 = 0LL /* False */;
			x14 = v20;
			x13 = v9;
			x12 = v7;
			x11 = x2;
			x10 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v21 = (x10);
	VAL v22 = x11;
	VAL v23 = (x12);
	VAL v24 = x13;
	int64_t v25 = x14;
	while (((bool)v25)) {
		VAL v26 = (v21);
		VAL v27 = v22;
		VAL v28 = (v23);
		VAL v29 = v24;
		VAL v30;
		VAL v31;
		mw_std_list_List_1_uncons(v29, &v30, &v31);
		VAL x32;
		VAL x33;
		VAL x34;
		VAL x35;
		int64_t x36;
		switch (get_data_tag(v30)) {
			case 1LL: { // Some
				VAL v37 = mtp_std_maybe_Maybe_1_Some(v30);
				VAL v38;
				VAL v39;
				mw_mirth_arrow_Arg_freeZ_vars(v26, VU64(v37), &v38, &v39);
				VAL v40 = mtw_std_list_List_1_Cons(v39, v28);
				int64_t v41 = 1LL /* True */;
				x36 = v41;
				x35 = v31;
				x34 = v40;
				x33 = v27;
				x32 = v38;
			} break;
			case 0LL: { // None
				int64_t v42 = 0LL /* False */;
				x36 = v42;
				x35 = v31;
				x34 = v28;
				x33 = v27;
				x32 = v26;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v25 = x36;
		v24 = x35;
		v23 = x34;
		v22 = x33;
		v21 = x32;
	}
	decref(v24);
	VAL v43 = mw_std_list_List_1_reverse(v23);
	VAL v44 = mw_std_list_List_1_ZToListZPlus(v43);
	VAL x45;
	VAL x46;
	VAL x47;
	switch (get_data_tag(v44)) {
		case 1LL: { // Some
			VAL v48 = mtp_std_maybe_Maybe_1_Some(v44);
			VAL v49;
			VAL v50;
			mw_std_list_ListZPlus_1_uncons(v48, &v49, &v50);
			VAL v51;
			VAL v52;
			mw_std_list_List_1_uncons(v50, &v51, &v52);
			VAL x53;
			VAL x54;
			VAL x55;
			VAL x56;
			int64_t x57;
			switch (get_data_tag(v51)) {
				case 1LL: { // Some
					VAL v58 = mtp_std_maybe_Maybe_1_Some(v51);
					incref(v49);
					VAL v59 = MKI64(0LL /* Nil */);
					VAL v60 = mw_std_list_List_1_reverse(v59);
					VAL v61;
					VAL v62;
					mw_std_list_List_1_uncons(v58, &v61, &v62);
					VAL x63;
					VAL x64;
					VAL x65;
					VAL x66;
					VAL x67;
					int64_t x68;
					switch (get_data_tag(v61)) {
						case 1LL: { // Some
							VAL v69 = mtp_std_maybe_Maybe_1_Some(v61);
							incref(v69);
							incref(v49);
							VAL v70 = MKI64(0LL /* None */);
							VAL v71;
							VAL v72;
							mw_std_list_List_1_uncons(v49, &v71, &v72);
							VAL x73;
							VAL x74;
							uint64_t x75;
							VAL x76;
							VAL x77;
							int64_t x78;
							switch (get_data_tag(v71)) {
								case 1LL: { // Some
									VAL v79 = mtp_std_maybe_Maybe_1_Some(v71);
									incref(v79);
									incref(v69);
									int64_t v80 = mw_mirth_var_Var_ZEqualZEqual(VU64(v69), VU64(v79));
									VAL x81;
									VAL x82;
									uint64_t x83;
									VAL x84;
									if (((bool)v80)) {
										VAL v85 = mtw_std_maybe_Maybe_1_Some(v79);
										x84 = v85;
										x83 = VU64(v69);
										x82 = v22;
										x81 = v21;
									} else {
										decref(v79);
										VAL v86 = MKI64(0LL /* None */);
										x84 = v86;
										x83 = VU64(v69);
										x82 = v22;
										x81 = v21;
									}
									VAL x87;
									VAL x88;
									uint64_t x89;
									VAL x90;
									VAL x91;
									switch (get_data_tag(x84)) {
										case 0LL: { // None
											x91 = v72;
											x90 = v70;
											x89 = x83;
											x88 = x82;
											x87 = x81;
										} break;
										default: {
											decref(v72);
											decref(v70);
											VAL v92 = MKI64(0LL /* Nil */);
											x91 = v92;
											x90 = x84;
											x89 = x83;
											x88 = x82;
											x87 = x81;
										} break;
									}
									int64_t v93 = 1LL /* True */;
									x78 = v93;
									x77 = x91;
									x76 = x90;
									x75 = x89;
									x74 = x88;
									x73 = x87;
								} break;
								case 0LL: { // None
									int64_t v94 = 0LL /* False */;
									x78 = v94;
									x77 = v72;
									x76 = v70;
									x75 = VU64(v69);
									x74 = v22;
									x73 = v21;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v95 = (x73);
							VAL v96 = x74;
							uint64_t v97 = x75;
							VAL v98 = x76;
							VAL v99 = x77;
							int64_t v100 = x78;
							while (((bool)v100)) {
								VAL v101 = (v95);
								VAL v102 = v96;
								uint64_t v103 = v97;
								VAL v104 = v98;
								VAL v105 = v99;
								VAL v106;
								VAL v107;
								mw_std_list_List_1_uncons(v105, &v106, &v107);
								VAL x108;
								VAL x109;
								uint64_t x110;
								VAL x111;
								VAL x112;
								int64_t x113;
								switch (get_data_tag(v106)) {
									case 1LL: { // Some
										VAL v114 = mtp_std_maybe_Maybe_1_Some(v106);
										incref(v114);
										int64_t v115 = mw_mirth_var_Var_ZEqualZEqual(v103, VU64(v114));
										VAL x116;
										VAL x117;
										uint64_t x118;
										VAL x119;
										if (((bool)v115)) {
											VAL v120 = mtw_std_maybe_Maybe_1_Some(v114);
											x119 = v120;
											x118 = v103;
											x117 = v102;
											x116 = v101;
										} else {
											decref(v114);
											VAL v121 = MKI64(0LL /* None */);
											x119 = v121;
											x118 = v103;
											x117 = v102;
											x116 = v101;
										}
										VAL x122;
										VAL x123;
										uint64_t x124;
										VAL x125;
										VAL x126;
										switch (get_data_tag(x119)) {
											case 0LL: { // None
												x126 = v107;
												x125 = v104;
												x124 = x118;
												x123 = x117;
												x122 = x116;
											} break;
											default: {
												decref(v107);
												decref(v104);
												VAL v127 = MKI64(0LL /* Nil */);
												x126 = v127;
												x125 = x119;
												x124 = x118;
												x123 = x117;
												x122 = x116;
											} break;
										}
										int64_t v128 = 1LL /* True */;
										x113 = v128;
										x112 = x126;
										x111 = x125;
										x110 = x124;
										x109 = x123;
										x108 = x122;
									} break;
									case 0LL: { // None
										int64_t v129 = 0LL /* False */;
										x113 = v129;
										x112 = v107;
										x111 = v104;
										x110 = v103;
										x109 = v102;
										x108 = v101;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v100 = x113;
								v99 = x112;
								v98 = x111;
								v97 = x110;
								v96 = x109;
								v95 = x108;
							}
							decref(v99);
							int64_t v130 = mw_std_maybe_Maybe_1_someZAsk(v98);
							bool v131 = !((bool)v130);
							VAL x132;
							VAL x133;
							VAL x134;
							VAL x135;
							if (v131) {
								VAL v136 = mtw_std_maybe_Maybe_1_Some(v69);
								x135 = v136;
								x134 = v49;
								x133 = v96;
								x132 = v95;
							} else {
								decref(v69);
								VAL v137 = MKI64(0LL /* None */);
								x135 = v137;
								x134 = v49;
								x133 = v96;
								x132 = v95;
							}
							VAL x138;
							switch (get_data_tag(x135)) {
								case 1LL: { // Some
									VAL v139 = mtp_std_maybe_Maybe_1_Some(x135);
									VAL v140 = mtw_std_list_List_1_Cons(v139, v60);
									x138 = v140;
									push_resource(x132);
									push_value(x133);
									push_value(x134);
								} break;
								case 0LL: { // None
									x138 = v60;
									push_resource(x132);
									push_value(x133);
									push_value(x134);
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v141 = 1LL /* True */;
							x68 = v141;
							x67 = v62;
							x66 = x138;
							VAL v142 = pop_value();
							x65 = v142;
							VAL v143 = pop_value();
							x64 = v143;
							VAL r144 = pop_resource();
							x63 = r144;
						} break;
						case 0LL: { // None
							int64_t v145 = 0LL /* False */;
							x68 = v145;
							x67 = v62;
							x66 = v60;
							x65 = v49;
							x64 = v22;
							x63 = v21;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v146 = (x63);
					VAL v147 = x64;
					VAL v148 = x65;
					VAL v149 = (x66);
					VAL v150 = x67;
					int64_t v151 = x68;
					while (((bool)v151)) {
						VAL v152 = (v146);
						VAL v153 = v147;
						VAL v154 = v148;
						VAL v155 = (v149);
						VAL v156 = v150;
						VAL v157;
						VAL v158;
						mw_std_list_List_1_uncons(v156, &v157, &v158);
						VAL x159;
						VAL x160;
						VAL x161;
						VAL x162;
						VAL x163;
						int64_t x164;
						switch (get_data_tag(v157)) {
							case 1LL: { // Some
								VAL v165 = mtp_std_maybe_Maybe_1_Some(v157);
								incref(v165);
								incref(v154);
								VAL v166 = MKI64(0LL /* None */);
								VAL v167;
								VAL v168;
								mw_std_list_List_1_uncons(v154, &v167, &v168);
								VAL x169;
								VAL x170;
								uint64_t x171;
								VAL x172;
								VAL x173;
								int64_t x174;
								switch (get_data_tag(v167)) {
									case 1LL: { // Some
										VAL v175 = mtp_std_maybe_Maybe_1_Some(v167);
										incref(v175);
										incref(v165);
										int64_t v176 = mw_mirth_var_Var_ZEqualZEqual(VU64(v165), VU64(v175));
										VAL x177;
										VAL x178;
										uint64_t x179;
										VAL x180;
										if (((bool)v176)) {
											VAL v181 = mtw_std_maybe_Maybe_1_Some(v175);
											x180 = v181;
											x179 = VU64(v165);
											x178 = v153;
											x177 = v152;
										} else {
											decref(v175);
											VAL v182 = MKI64(0LL /* None */);
											x180 = v182;
											x179 = VU64(v165);
											x178 = v153;
											x177 = v152;
										}
										VAL x183;
										VAL x184;
										uint64_t x185;
										VAL x186;
										VAL x187;
										switch (get_data_tag(x180)) {
											case 0LL: { // None
												x187 = v168;
												x186 = v166;
												x185 = x179;
												x184 = x178;
												x183 = x177;
											} break;
											default: {
												decref(v168);
												decref(v166);
												VAL v188 = MKI64(0LL /* Nil */);
												x187 = v188;
												x186 = x180;
												x185 = x179;
												x184 = x178;
												x183 = x177;
											} break;
										}
										int64_t v189 = 1LL /* True */;
										x174 = v189;
										x173 = x187;
										x172 = x186;
										x171 = x185;
										x170 = x184;
										x169 = x183;
									} break;
									case 0LL: { // None
										int64_t v190 = 0LL /* False */;
										x174 = v190;
										x173 = v168;
										x172 = v166;
										x171 = VU64(v165);
										x170 = v153;
										x169 = v152;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v191 = (x169);
								VAL v192 = x170;
								uint64_t v193 = x171;
								VAL v194 = x172;
								VAL v195 = x173;
								int64_t v196 = x174;
								while (((bool)v196)) {
									VAL v197 = (v191);
									VAL v198 = v192;
									uint64_t v199 = v193;
									VAL v200 = v194;
									VAL v201 = v195;
									VAL v202;
									VAL v203;
									mw_std_list_List_1_uncons(v201, &v202, &v203);
									VAL x204;
									VAL x205;
									uint64_t x206;
									VAL x207;
									VAL x208;
									int64_t x209;
									switch (get_data_tag(v202)) {
										case 1LL: { // Some
											VAL v210 = mtp_std_maybe_Maybe_1_Some(v202);
											incref(v210);
											int64_t v211 = mw_mirth_var_Var_ZEqualZEqual(v199, VU64(v210));
											VAL x212;
											VAL x213;
											uint64_t x214;
											VAL x215;
											if (((bool)v211)) {
												VAL v216 = mtw_std_maybe_Maybe_1_Some(v210);
												x215 = v216;
												x214 = v199;
												x213 = v198;
												x212 = v197;
											} else {
												decref(v210);
												VAL v217 = MKI64(0LL /* None */);
												x215 = v217;
												x214 = v199;
												x213 = v198;
												x212 = v197;
											}
											VAL x218;
											VAL x219;
											uint64_t x220;
											VAL x221;
											VAL x222;
											switch (get_data_tag(x215)) {
												case 0LL: { // None
													x222 = v203;
													x221 = v200;
													x220 = x214;
													x219 = x213;
													x218 = x212;
												} break;
												default: {
													decref(v203);
													decref(v200);
													VAL v223 = MKI64(0LL /* Nil */);
													x222 = v223;
													x221 = x215;
													x220 = x214;
													x219 = x213;
													x218 = x212;
												} break;
											}
											int64_t v224 = 1LL /* True */;
											x209 = v224;
											x208 = x222;
											x207 = x221;
											x206 = x220;
											x205 = x219;
											x204 = x218;
										} break;
										case 0LL: { // None
											int64_t v225 = 0LL /* False */;
											x209 = v225;
											x208 = v203;
											x207 = v200;
											x206 = v199;
											x205 = v198;
											x204 = v197;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v196 = x209;
									v195 = x208;
									v194 = x207;
									v193 = x206;
									v192 = x205;
									v191 = x204;
								}
								decref(v195);
								int64_t v226 = mw_std_maybe_Maybe_1_someZAsk(v194);
								bool v227 = !((bool)v226);
								VAL x228;
								VAL x229;
								VAL x230;
								VAL x231;
								if (v227) {
									VAL v232 = mtw_std_maybe_Maybe_1_Some(v165);
									x231 = v232;
									x230 = v154;
									x229 = v192;
									x228 = v191;
								} else {
									decref(v165);
									VAL v233 = MKI64(0LL /* None */);
									x231 = v233;
									x230 = v154;
									x229 = v192;
									x228 = v191;
								}
								VAL x234;
								switch (get_data_tag(x231)) {
									case 1LL: { // Some
										VAL v235 = mtp_std_maybe_Maybe_1_Some(x231);
										VAL v236 = mtw_std_list_List_1_Cons(v235, v155);
										x234 = v236;
										push_resource(x228);
										push_value(x229);
										push_value(x230);
									} break;
									case 0LL: { // None
										x234 = v155;
										push_resource(x228);
										push_value(x229);
										push_value(x230);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v237 = 1LL /* True */;
								x164 = v237;
								x163 = v158;
								x162 = x234;
								VAL v238 = pop_value();
								x161 = v238;
								VAL v239 = pop_value();
								x160 = v239;
								VAL r240 = pop_resource();
								x159 = r240;
							} break;
							case 0LL: { // None
								int64_t v241 = 0LL /* False */;
								x164 = v241;
								x163 = v158;
								x162 = v155;
								x161 = v154;
								x160 = v153;
								x159 = v152;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v151 = x164;
						v150 = x163;
						v149 = x162;
						v148 = x161;
						v147 = x160;
						v146 = x159;
					}
					decref(v150);
					VAL v242 = mw_std_list_List_1_reverse(v149);
					decref(v148);
					VAL v243 = mw_std_list_List_1_cat(v49, v242);
					int64_t v244 = 1LL /* True */;
					x57 = v244;
					x56 = v52;
					x55 = v243;
					x54 = v147;
					x53 = v146;
				} break;
				case 0LL: { // None
					int64_t v245 = 0LL /* False */;
					x57 = v245;
					x56 = v52;
					x55 = v49;
					x54 = v22;
					x53 = v21;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v246 = (x53);
			VAL v247 = x54;
			VAL v248 = x55;
			VAL v249 = x56;
			int64_t v250 = x57;
			while (((bool)v250)) {
				VAL v251 = (v246);
				VAL v252 = v247;
				VAL v253 = v248;
				VAL v254 = v249;
				VAL v255;
				VAL v256;
				mw_std_list_List_1_uncons(v254, &v255, &v256);
				VAL x257;
				VAL x258;
				VAL x259;
				VAL x260;
				int64_t x261;
				switch (get_data_tag(v255)) {
					case 1LL: { // Some
						VAL v262 = mtp_std_maybe_Maybe_1_Some(v255);
						incref(v253);
						VAL v263 = MKI64(0LL /* Nil */);
						VAL v264 = mw_std_list_List_1_reverse(v263);
						VAL v265;
						VAL v266;
						mw_std_list_List_1_uncons(v262, &v265, &v266);
						VAL x267;
						VAL x268;
						VAL x269;
						VAL x270;
						VAL x271;
						int64_t x272;
						switch (get_data_tag(v265)) {
							case 1LL: { // Some
								VAL v273 = mtp_std_maybe_Maybe_1_Some(v265);
								incref(v273);
								incref(v253);
								VAL v274 = MKI64(0LL /* None */);
								VAL v275;
								VAL v276;
								mw_std_list_List_1_uncons(v253, &v275, &v276);
								VAL x277;
								VAL x278;
								uint64_t x279;
								VAL x280;
								VAL x281;
								int64_t x282;
								switch (get_data_tag(v275)) {
									case 1LL: { // Some
										VAL v283 = mtp_std_maybe_Maybe_1_Some(v275);
										incref(v283);
										incref(v273);
										int64_t v284 = mw_mirth_var_Var_ZEqualZEqual(VU64(v273), VU64(v283));
										VAL x285;
										VAL x286;
										uint64_t x287;
										VAL x288;
										if (((bool)v284)) {
											VAL v289 = mtw_std_maybe_Maybe_1_Some(v283);
											x288 = v289;
											x287 = VU64(v273);
											x286 = v252;
											x285 = v251;
										} else {
											decref(v283);
											VAL v290 = MKI64(0LL /* None */);
											x288 = v290;
											x287 = VU64(v273);
											x286 = v252;
											x285 = v251;
										}
										VAL x291;
										VAL x292;
										uint64_t x293;
										VAL x294;
										VAL x295;
										switch (get_data_tag(x288)) {
											case 0LL: { // None
												x295 = v276;
												x294 = v274;
												x293 = x287;
												x292 = x286;
												x291 = x285;
											} break;
											default: {
												decref(v276);
												decref(v274);
												VAL v296 = MKI64(0LL /* Nil */);
												x295 = v296;
												x294 = x288;
												x293 = x287;
												x292 = x286;
												x291 = x285;
											} break;
										}
										int64_t v297 = 1LL /* True */;
										x282 = v297;
										x281 = x295;
										x280 = x294;
										x279 = x293;
										x278 = x292;
										x277 = x291;
									} break;
									case 0LL: { // None
										int64_t v298 = 0LL /* False */;
										x282 = v298;
										x281 = v276;
										x280 = v274;
										x279 = VU64(v273);
										x278 = v252;
										x277 = v251;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v299 = (x277);
								VAL v300 = x278;
								uint64_t v301 = x279;
								VAL v302 = x280;
								VAL v303 = x281;
								int64_t v304 = x282;
								while (((bool)v304)) {
									VAL v305 = (v299);
									VAL v306 = v300;
									uint64_t v307 = v301;
									VAL v308 = v302;
									VAL v309 = v303;
									VAL v310;
									VAL v311;
									mw_std_list_List_1_uncons(v309, &v310, &v311);
									VAL x312;
									VAL x313;
									uint64_t x314;
									VAL x315;
									VAL x316;
									int64_t x317;
									switch (get_data_tag(v310)) {
										case 1LL: { // Some
											VAL v318 = mtp_std_maybe_Maybe_1_Some(v310);
											incref(v318);
											int64_t v319 = mw_mirth_var_Var_ZEqualZEqual(v307, VU64(v318));
											VAL x320;
											VAL x321;
											uint64_t x322;
											VAL x323;
											if (((bool)v319)) {
												VAL v324 = mtw_std_maybe_Maybe_1_Some(v318);
												x323 = v324;
												x322 = v307;
												x321 = v306;
												x320 = v305;
											} else {
												decref(v318);
												VAL v325 = MKI64(0LL /* None */);
												x323 = v325;
												x322 = v307;
												x321 = v306;
												x320 = v305;
											}
											VAL x326;
											VAL x327;
											uint64_t x328;
											VAL x329;
											VAL x330;
											switch (get_data_tag(x323)) {
												case 0LL: { // None
													x330 = v311;
													x329 = v308;
													x328 = x322;
													x327 = x321;
													x326 = x320;
												} break;
												default: {
													decref(v311);
													decref(v308);
													VAL v331 = MKI64(0LL /* Nil */);
													x330 = v331;
													x329 = x323;
													x328 = x322;
													x327 = x321;
													x326 = x320;
												} break;
											}
											int64_t v332 = 1LL /* True */;
											x317 = v332;
											x316 = x330;
											x315 = x329;
											x314 = x328;
											x313 = x327;
											x312 = x326;
										} break;
										case 0LL: { // None
											int64_t v333 = 0LL /* False */;
											x317 = v333;
											x316 = v311;
											x315 = v308;
											x314 = v307;
											x313 = v306;
											x312 = v305;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v304 = x317;
									v303 = x316;
									v302 = x315;
									v301 = x314;
									v300 = x313;
									v299 = x312;
								}
								decref(v303);
								int64_t v334 = mw_std_maybe_Maybe_1_someZAsk(v302);
								bool v335 = !((bool)v334);
								VAL x336;
								VAL x337;
								VAL x338;
								VAL x339;
								if (v335) {
									VAL v340 = mtw_std_maybe_Maybe_1_Some(v273);
									x339 = v340;
									x338 = v253;
									x337 = v300;
									x336 = v299;
								} else {
									decref(v273);
									VAL v341 = MKI64(0LL /* None */);
									x339 = v341;
									x338 = v253;
									x337 = v300;
									x336 = v299;
								}
								VAL x342;
								switch (get_data_tag(x339)) {
									case 1LL: { // Some
										VAL v343 = mtp_std_maybe_Maybe_1_Some(x339);
										VAL v344 = mtw_std_list_List_1_Cons(v343, v264);
										x342 = v344;
										push_resource(x336);
										push_value(x337);
										push_value(x338);
									} break;
									case 0LL: { // None
										x342 = v264;
										push_resource(x336);
										push_value(x337);
										push_value(x338);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v345 = 1LL /* True */;
								x272 = v345;
								x271 = v266;
								x270 = x342;
								VAL v346 = pop_value();
								x269 = v346;
								VAL v347 = pop_value();
								x268 = v347;
								VAL r348 = pop_resource();
								x267 = r348;
							} break;
							case 0LL: { // None
								int64_t v349 = 0LL /* False */;
								x272 = v349;
								x271 = v266;
								x270 = v264;
								x269 = v253;
								x268 = v252;
								x267 = v251;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v350 = (x267);
						VAL v351 = x268;
						VAL v352 = x269;
						VAL v353 = (x270);
						VAL v354 = x271;
						int64_t v355 = x272;
						while (((bool)v355)) {
							VAL v356 = (v350);
							VAL v357 = v351;
							VAL v358 = v352;
							VAL v359 = (v353);
							VAL v360 = v354;
							VAL v361;
							VAL v362;
							mw_std_list_List_1_uncons(v360, &v361, &v362);
							VAL x363;
							VAL x364;
							VAL x365;
							VAL x366;
							VAL x367;
							int64_t x368;
							switch (get_data_tag(v361)) {
								case 1LL: { // Some
									VAL v369 = mtp_std_maybe_Maybe_1_Some(v361);
									incref(v369);
									incref(v358);
									VAL v370 = MKI64(0LL /* None */);
									VAL v371;
									VAL v372;
									mw_std_list_List_1_uncons(v358, &v371, &v372);
									VAL x373;
									VAL x374;
									uint64_t x375;
									VAL x376;
									VAL x377;
									int64_t x378;
									switch (get_data_tag(v371)) {
										case 1LL: { // Some
											VAL v379 = mtp_std_maybe_Maybe_1_Some(v371);
											incref(v379);
											incref(v369);
											int64_t v380 = mw_mirth_var_Var_ZEqualZEqual(VU64(v369), VU64(v379));
											VAL x381;
											VAL x382;
											uint64_t x383;
											VAL x384;
											if (((bool)v380)) {
												VAL v385 = mtw_std_maybe_Maybe_1_Some(v379);
												x384 = v385;
												x383 = VU64(v369);
												x382 = v357;
												x381 = v356;
											} else {
												decref(v379);
												VAL v386 = MKI64(0LL /* None */);
												x384 = v386;
												x383 = VU64(v369);
												x382 = v357;
												x381 = v356;
											}
											VAL x387;
											VAL x388;
											uint64_t x389;
											VAL x390;
											VAL x391;
											switch (get_data_tag(x384)) {
												case 0LL: { // None
													x391 = v372;
													x390 = v370;
													x389 = x383;
													x388 = x382;
													x387 = x381;
												} break;
												default: {
													decref(v372);
													decref(v370);
													VAL v392 = MKI64(0LL /* Nil */);
													x391 = v392;
													x390 = x384;
													x389 = x383;
													x388 = x382;
													x387 = x381;
												} break;
											}
											int64_t v393 = 1LL /* True */;
											x378 = v393;
											x377 = x391;
											x376 = x390;
											x375 = x389;
											x374 = x388;
											x373 = x387;
										} break;
										case 0LL: { // None
											int64_t v394 = 0LL /* False */;
											x378 = v394;
											x377 = v372;
											x376 = v370;
											x375 = VU64(v369);
											x374 = v357;
											x373 = v356;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									VAL v395 = (x373);
									VAL v396 = x374;
									uint64_t v397 = x375;
									VAL v398 = x376;
									VAL v399 = x377;
									int64_t v400 = x378;
									while (((bool)v400)) {
										VAL v401 = (v395);
										VAL v402 = v396;
										uint64_t v403 = v397;
										VAL v404 = v398;
										VAL v405 = v399;
										VAL v406;
										VAL v407;
										mw_std_list_List_1_uncons(v405, &v406, &v407);
										VAL x408;
										VAL x409;
										uint64_t x410;
										VAL x411;
										VAL x412;
										int64_t x413;
										switch (get_data_tag(v406)) {
											case 1LL: { // Some
												VAL v414 = mtp_std_maybe_Maybe_1_Some(v406);
												incref(v414);
												int64_t v415 = mw_mirth_var_Var_ZEqualZEqual(v403, VU64(v414));
												VAL x416;
												VAL x417;
												uint64_t x418;
												VAL x419;
												if (((bool)v415)) {
													VAL v420 = mtw_std_maybe_Maybe_1_Some(v414);
													x419 = v420;
													x418 = v403;
													x417 = v402;
													x416 = v401;
												} else {
													decref(v414);
													VAL v421 = MKI64(0LL /* None */);
													x419 = v421;
													x418 = v403;
													x417 = v402;
													x416 = v401;
												}
												VAL x422;
												VAL x423;
												uint64_t x424;
												VAL x425;
												VAL x426;
												switch (get_data_tag(x419)) {
													case 0LL: { // None
														x426 = v407;
														x425 = v404;
														x424 = x418;
														x423 = x417;
														x422 = x416;
													} break;
													default: {
														decref(v407);
														decref(v404);
														VAL v427 = MKI64(0LL /* Nil */);
														x426 = v427;
														x425 = x419;
														x424 = x418;
														x423 = x417;
														x422 = x416;
													} break;
												}
												int64_t v428 = 1LL /* True */;
												x413 = v428;
												x412 = x426;
												x411 = x425;
												x410 = x424;
												x409 = x423;
												x408 = x422;
											} break;
											case 0LL: { // None
												int64_t v429 = 0LL /* False */;
												x413 = v429;
												x412 = v407;
												x411 = v404;
												x410 = v403;
												x409 = v402;
												x408 = v401;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										v400 = x413;
										v399 = x412;
										v398 = x411;
										v397 = x410;
										v396 = x409;
										v395 = x408;
									}
									decref(v399);
									int64_t v430 = mw_std_maybe_Maybe_1_someZAsk(v398);
									bool v431 = !((bool)v430);
									VAL x432;
									VAL x433;
									VAL x434;
									VAL x435;
									if (v431) {
										VAL v436 = mtw_std_maybe_Maybe_1_Some(v369);
										x435 = v436;
										x434 = v358;
										x433 = v396;
										x432 = v395;
									} else {
										decref(v369);
										VAL v437 = MKI64(0LL /* None */);
										x435 = v437;
										x434 = v358;
										x433 = v396;
										x432 = v395;
									}
									VAL x438;
									switch (get_data_tag(x435)) {
										case 1LL: { // Some
											VAL v439 = mtp_std_maybe_Maybe_1_Some(x435);
											VAL v440 = mtw_std_list_List_1_Cons(v439, v359);
											x438 = v440;
											push_resource(x432);
											push_value(x433);
											push_value(x434);
										} break;
										case 0LL: { // None
											x438 = v359;
											push_resource(x432);
											push_value(x433);
											push_value(x434);
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									int64_t v441 = 1LL /* True */;
									x368 = v441;
									x367 = v362;
									x366 = x438;
									VAL v442 = pop_value();
									x365 = v442;
									VAL v443 = pop_value();
									x364 = v443;
									VAL r444 = pop_resource();
									x363 = r444;
								} break;
								case 0LL: { // None
									int64_t v445 = 0LL /* False */;
									x368 = v445;
									x367 = v362;
									x366 = v359;
									x365 = v358;
									x364 = v357;
									x363 = v356;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v355 = x368;
							v354 = x367;
							v353 = x366;
							v352 = x365;
							v351 = x364;
							v350 = x363;
						}
						decref(v354);
						VAL v446 = mw_std_list_List_1_reverse(v353);
						decref(v352);
						VAL v447 = mw_std_list_List_1_cat(v253, v446);
						int64_t v448 = 1LL /* True */;
						x261 = v448;
						x260 = v256;
						x259 = v447;
						x258 = v351;
						x257 = v350;
					} break;
					case 0LL: { // None
						int64_t v449 = 0LL /* False */;
						x261 = v449;
						x260 = v256;
						x259 = v253;
						x258 = v252;
						x257 = v251;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v250 = x261;
				v249 = x260;
				v248 = x259;
				v247 = x258;
				v246 = x257;
			}
			decref(v249);
			VAL v450 = mtw_std_maybe_Maybe_1_Some(v248);
			x47 = v450;
			x46 = v247;
			x45 = v246;
		} break;
		case 0LL: { // None
			VAL v451 = MKI64(0LL /* None */);
			x47 = v451;
			x46 = v22;
			x45 = v21;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x452;
	switch (get_data_tag(x47)) {
		case 1LL: { // Some
			VAL v453 = mtp_std_maybe_Maybe_1_Some(x47);
			x452 = v453;
			push_resource(x45);
			push_value(x46);
		} break;
		case 0LL: { // None
			VAL v454 = MKI64(0LL /* Nil */);
			x452 = v454;
			push_resource(x45);
			push_value(x46);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v455 = pop_value();
	VAL v456 = VVAL(VTUP(v455)->cells[4]);
	incref(v456);
	decref(v455);
	VAL r457 = pop_resource();
	VAL v458;
	VAL v459;
	mw_mirth_arrow_Op_freeZ_vars(r457, v456, &v458, &v459);
	incref(x452);
	VAL v460 = MKI64(0LL /* Nil */);
	VAL v461 = mw_std_list_List_1_reverse(v460);
	VAL v462;
	VAL v463;
	mw_std_list_List_1_uncons(v459, &v462, &v463);
	VAL x464;
	VAL x465;
	VAL x466;
	VAL x467;
	int64_t x468;
	switch (get_data_tag(v462)) {
		case 1LL: { // Some
			VAL v469 = mtp_std_maybe_Maybe_1_Some(v462);
			incref(v469);
			incref(x452);
			VAL v470 = MKI64(0LL /* None */);
			VAL v471;
			VAL v472;
			mw_std_list_List_1_uncons(x452, &v471, &v472);
			VAL x473;
			uint64_t x474;
			VAL x475;
			VAL x476;
			int64_t x477;
			switch (get_data_tag(v471)) {
				case 1LL: { // Some
					VAL v478 = mtp_std_maybe_Maybe_1_Some(v471);
					incref(v478);
					incref(v469);
					int64_t v479 = mw_mirth_var_Var_ZEqualZEqual(VU64(v469), VU64(v478));
					VAL x480;
					uint64_t x481;
					VAL x482;
					if (((bool)v479)) {
						VAL v483 = mtw_std_maybe_Maybe_1_Some(v478);
						x482 = v483;
						x481 = VU64(v469);
						x480 = v458;
					} else {
						decref(v478);
						VAL v484 = MKI64(0LL /* None */);
						x482 = v484;
						x481 = VU64(v469);
						x480 = v458;
					}
					VAL x485;
					uint64_t x486;
					VAL x487;
					VAL x488;
					switch (get_data_tag(x482)) {
						case 0LL: { // None
							x488 = v472;
							x487 = v470;
							x486 = x481;
							x485 = x480;
						} break;
						default: {
							decref(v472);
							decref(v470);
							VAL v489 = MKI64(0LL /* Nil */);
							x488 = v489;
							x487 = x482;
							x486 = x481;
							x485 = x480;
						} break;
					}
					int64_t v490 = 1LL /* True */;
					x477 = v490;
					x476 = x488;
					x475 = x487;
					x474 = x486;
					x473 = x485;
				} break;
				case 0LL: { // None
					int64_t v491 = 0LL /* False */;
					x477 = v491;
					x476 = v472;
					x475 = v470;
					x474 = VU64(v469);
					x473 = v458;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v492 = (x473);
			uint64_t v493 = x474;
			VAL v494 = x475;
			VAL v495 = x476;
			int64_t v496 = x477;
			while (((bool)v496)) {
				VAL v497 = (v492);
				uint64_t v498 = v493;
				VAL v499 = v494;
				VAL v500 = v495;
				VAL v501;
				VAL v502;
				mw_std_list_List_1_uncons(v500, &v501, &v502);
				VAL x503;
				uint64_t x504;
				VAL x505;
				VAL x506;
				int64_t x507;
				switch (get_data_tag(v501)) {
					case 1LL: { // Some
						VAL v508 = mtp_std_maybe_Maybe_1_Some(v501);
						incref(v508);
						int64_t v509 = mw_mirth_var_Var_ZEqualZEqual(v498, VU64(v508));
						VAL x510;
						uint64_t x511;
						VAL x512;
						if (((bool)v509)) {
							VAL v513 = mtw_std_maybe_Maybe_1_Some(v508);
							x512 = v513;
							x511 = v498;
							x510 = v497;
						} else {
							decref(v508);
							VAL v514 = MKI64(0LL /* None */);
							x512 = v514;
							x511 = v498;
							x510 = v497;
						}
						VAL x515;
						uint64_t x516;
						VAL x517;
						VAL x518;
						switch (get_data_tag(x512)) {
							case 0LL: { // None
								x518 = v502;
								x517 = v499;
								x516 = x511;
								x515 = x510;
							} break;
							default: {
								decref(v502);
								decref(v499);
								VAL v519 = MKI64(0LL /* Nil */);
								x518 = v519;
								x517 = x512;
								x516 = x511;
								x515 = x510;
							} break;
						}
						int64_t v520 = 1LL /* True */;
						x507 = v520;
						x506 = x518;
						x505 = x517;
						x504 = x516;
						x503 = x515;
					} break;
					case 0LL: { // None
						int64_t v521 = 0LL /* False */;
						x507 = v521;
						x506 = v502;
						x505 = v499;
						x504 = v498;
						x503 = v497;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v496 = x507;
				v495 = x506;
				v494 = x505;
				v493 = x504;
				v492 = x503;
			}
			decref(v495);
			int64_t v522 = mw_std_maybe_Maybe_1_someZAsk(v494);
			bool v523 = !((bool)v522);
			VAL x524;
			VAL x525;
			VAL x526;
			if (v523) {
				VAL v527 = mtw_std_maybe_Maybe_1_Some(v469);
				x526 = v527;
				x525 = x452;
				x524 = v492;
			} else {
				decref(v469);
				VAL v528 = MKI64(0LL /* None */);
				x526 = v528;
				x525 = x452;
				x524 = v492;
			}
			VAL x529;
			switch (get_data_tag(x526)) {
				case 1LL: { // Some
					VAL v530 = mtp_std_maybe_Maybe_1_Some(x526);
					VAL v531 = mtw_std_list_List_1_Cons(v530, v461);
					x529 = v531;
					push_resource(x524);
					push_value(x525);
				} break;
				case 0LL: { // None
					x529 = v461;
					push_resource(x524);
					push_value(x525);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v532 = 1LL /* True */;
			x468 = v532;
			x467 = v463;
			x466 = x529;
			VAL v533 = pop_value();
			x465 = v533;
			VAL r534 = pop_resource();
			x464 = r534;
		} break;
		case 0LL: { // None
			int64_t v535 = 0LL /* False */;
			x468 = v535;
			x467 = v463;
			x466 = v461;
			x465 = x452;
			x464 = v458;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v536 = (x464);
	VAL v537 = x465;
	VAL v538 = (x466);
	VAL v539 = x467;
	int64_t v540 = x468;
	while (((bool)v540)) {
		VAL v541 = (v536);
		VAL v542 = v537;
		VAL v543 = (v538);
		VAL v544 = v539;
		VAL v545;
		VAL v546;
		mw_std_list_List_1_uncons(v544, &v545, &v546);
		VAL x547;
		VAL x548;
		VAL x549;
		VAL x550;
		int64_t x551;
		switch (get_data_tag(v545)) {
			case 1LL: { // Some
				VAL v552 = mtp_std_maybe_Maybe_1_Some(v545);
				incref(v552);
				incref(v542);
				VAL v553 = MKI64(0LL /* None */);
				VAL v554;
				VAL v555;
				mw_std_list_List_1_uncons(v542, &v554, &v555);
				VAL x556;
				uint64_t x557;
				VAL x558;
				VAL x559;
				int64_t x560;
				switch (get_data_tag(v554)) {
					case 1LL: { // Some
						VAL v561 = mtp_std_maybe_Maybe_1_Some(v554);
						incref(v561);
						incref(v552);
						int64_t v562 = mw_mirth_var_Var_ZEqualZEqual(VU64(v552), VU64(v561));
						VAL x563;
						uint64_t x564;
						VAL x565;
						if (((bool)v562)) {
							VAL v566 = mtw_std_maybe_Maybe_1_Some(v561);
							x565 = v566;
							x564 = VU64(v552);
							x563 = v541;
						} else {
							decref(v561);
							VAL v567 = MKI64(0LL /* None */);
							x565 = v567;
							x564 = VU64(v552);
							x563 = v541;
						}
						VAL x568;
						uint64_t x569;
						VAL x570;
						VAL x571;
						switch (get_data_tag(x565)) {
							case 0LL: { // None
								x571 = v555;
								x570 = v553;
								x569 = x564;
								x568 = x563;
							} break;
							default: {
								decref(v555);
								decref(v553);
								VAL v572 = MKI64(0LL /* Nil */);
								x571 = v572;
								x570 = x565;
								x569 = x564;
								x568 = x563;
							} break;
						}
						int64_t v573 = 1LL /* True */;
						x560 = v573;
						x559 = x571;
						x558 = x570;
						x557 = x569;
						x556 = x568;
					} break;
					case 0LL: { // None
						int64_t v574 = 0LL /* False */;
						x560 = v574;
						x559 = v555;
						x558 = v553;
						x557 = VU64(v552);
						x556 = v541;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v575 = (x556);
				uint64_t v576 = x557;
				VAL v577 = x558;
				VAL v578 = x559;
				int64_t v579 = x560;
				while (((bool)v579)) {
					VAL v580 = (v575);
					uint64_t v581 = v576;
					VAL v582 = v577;
					VAL v583 = v578;
					VAL v584;
					VAL v585;
					mw_std_list_List_1_uncons(v583, &v584, &v585);
					VAL x586;
					uint64_t x587;
					VAL x588;
					VAL x589;
					int64_t x590;
					switch (get_data_tag(v584)) {
						case 1LL: { // Some
							VAL v591 = mtp_std_maybe_Maybe_1_Some(v584);
							incref(v591);
							int64_t v592 = mw_mirth_var_Var_ZEqualZEqual(v581, VU64(v591));
							VAL x593;
							uint64_t x594;
							VAL x595;
							if (((bool)v592)) {
								VAL v596 = mtw_std_maybe_Maybe_1_Some(v591);
								x595 = v596;
								x594 = v581;
								x593 = v580;
							} else {
								decref(v591);
								VAL v597 = MKI64(0LL /* None */);
								x595 = v597;
								x594 = v581;
								x593 = v580;
							}
							VAL x598;
							uint64_t x599;
							VAL x600;
							VAL x601;
							switch (get_data_tag(x595)) {
								case 0LL: { // None
									x601 = v585;
									x600 = v582;
									x599 = x594;
									x598 = x593;
								} break;
								default: {
									decref(v585);
									decref(v582);
									VAL v602 = MKI64(0LL /* Nil */);
									x601 = v602;
									x600 = x595;
									x599 = x594;
									x598 = x593;
								} break;
							}
							int64_t v603 = 1LL /* True */;
							x590 = v603;
							x589 = x601;
							x588 = x600;
							x587 = x599;
							x586 = x598;
						} break;
						case 0LL: { // None
							int64_t v604 = 0LL /* False */;
							x590 = v604;
							x589 = v585;
							x588 = v582;
							x587 = v581;
							x586 = v580;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v579 = x590;
					v578 = x589;
					v577 = x588;
					v576 = x587;
					v575 = x586;
				}
				decref(v578);
				int64_t v605 = mw_std_maybe_Maybe_1_someZAsk(v577);
				bool v606 = !((bool)v605);
				VAL x607;
				VAL x608;
				VAL x609;
				if (v606) {
					VAL v610 = mtw_std_maybe_Maybe_1_Some(v552);
					x609 = v610;
					x608 = v542;
					x607 = v575;
				} else {
					decref(v552);
					VAL v611 = MKI64(0LL /* None */);
					x609 = v611;
					x608 = v542;
					x607 = v575;
				}
				VAL x612;
				switch (get_data_tag(x609)) {
					case 1LL: { // Some
						VAL v613 = mtp_std_maybe_Maybe_1_Some(x609);
						VAL v614 = mtw_std_list_List_1_Cons(v613, v543);
						x612 = v614;
						push_resource(x607);
						push_value(x608);
					} break;
					case 0LL: { // None
						x612 = v543;
						push_resource(x607);
						push_value(x608);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v615 = 1LL /* True */;
				x551 = v615;
				x550 = v546;
				x549 = x612;
				VAL v616 = pop_value();
				x548 = v616;
				VAL r617 = pop_resource();
				x547 = r617;
			} break;
			case 0LL: { // None
				int64_t v618 = 0LL /* False */;
				x551 = v618;
				x550 = v546;
				x549 = v543;
				x548 = v542;
				x547 = v541;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v540 = x551;
		v539 = x550;
		v538 = x549;
		v537 = x548;
		v536 = x547;
	}
	decref(v539);
	VAL v619 = mw_std_list_List_1_reverse(v538);
	decref(v537);
	VAL v620 = mw_std_list_List_1_cat(x452, v619);
	*x4 = v620;
	*x3 = v536;
}
static void mw_mirth_arrow_Arg_freeZ_vars (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_freeZ_vars(x1, x2, &v5, &v6);
	*x4 = v6;
	*x3 = v5;
}
static void mw_mirth_arrow_Op_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			VAL v7 = MKI64(0LL /* Nil */);
			x6 = v7;
			x5 = x1;
		} break;
		case 1LL: { // OpPrim
			int64_t v8 = mtp_mirth_arrow_Op_OpPrim(x2);
			VAL v9 = MKI64(0LL /* Nil */);
			x6 = v9;
			x5 = x1;
		} break;
		case 2LL: { // OpWord
			uint64_t v10 = mtp_mirth_arrow_Op_OpWord(x2);
			VAL v11 = MKI64(0LL /* Nil */);
			x6 = v11;
			x5 = x1;
		} break;
		case 3LL: { // OpExternal
			uint64_t v12 = mtp_mirth_arrow_Op_OpExternal(x2);
			VAL v13 = MKI64(0LL /* Nil */);
			x6 = v13;
			x5 = x1;
		} break;
		case 4LL: { // OpBuffer
			uint64_t v14 = mtp_mirth_arrow_Op_OpBuffer(x2);
			VAL v15 = MKI64(0LL /* Nil */);
			x6 = v15;
			x5 = x1;
		} break;
		case 5LL: { // OpVariable
			uint64_t v16 = mtp_mirth_arrow_Op_OpVariable(x2);
			VAL v17 = MKI64(0LL /* Nil */);
			x6 = v17;
			x5 = x1;
		} break;
		case 6LL: { // OpField
			uint64_t v18 = mtp_mirth_arrow_Op_OpField(x2);
			VAL v19 = MKI64(0LL /* Nil */);
			x6 = v19;
			x5 = x1;
		} break;
		case 7LL: { // OpInt
			int64_t v20 = mtp_mirth_arrow_Op_OpInt(x2);
			VAL v21 = MKI64(0LL /* Nil */);
			x6 = v21;
			x5 = x1;
		} break;
		case 8LL: { // OpF64
			double v22 = mtp_mirth_arrow_Op_OpF64(x2);
			VAL v23 = MKI64(0LL /* Nil */);
			x6 = v23;
			x5 = x1;
		} break;
		case 9LL: { // OpStr
			VAL v24 = mtp_mirth_arrow_Op_OpStr(x2);
			decref(v24);
			VAL v25 = MKI64(0LL /* Nil */);
			x6 = v25;
			x5 = x1;
		} break;
		case 10LL: { // OpTag
			uint64_t v26 = mtp_mirth_arrow_Op_OpTag(x2);
			VAL v27 = MKI64(0LL /* Nil */);
			x6 = v27;
			x5 = x1;
		} break;
		case 11LL: { // OpMatch
			VAL v28 = mtp_mirth_arrow_Op_OpMatch(x2);
			VAL v29;
			VAL v30;
			mw_mirth_match_Match_freeZ_vars(x1, v28, &v29, &v30);
			x6 = v30;
			x5 = v29;
		} break;
		case 12LL: { // OpLambda
			VAL v31 = mtp_mirth_arrow_Op_OpLambda(x2);
			VAL v32;
			VAL v33;
			mw_mirth_arrow_Lambda_freeZ_vars(x1, v31, &v32, &v33);
			x6 = v33;
			x5 = v32;
		} break;
		case 13LL: { // OpVar
			uint64_t v34 = mtp_mirth_arrow_Op_OpVar(x2);
			VAL v35 = MKI64(0LL /* Nil */);
			VAL v36 = mtw_std_list_List_1_Cons(MKU64(v34), v35);
			x6 = v36;
			x5 = x1;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v37 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			VAL v38;
			VAL v39;
			mw_mirth_arrow_Block_freeZ_vars(x1, v37, &v38, &v39);
			x6 = v39;
			x5 = v38;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v40 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			VAL v41;
			VAL v42;
			mw_mirth_arrow_Block_freeZ_vars(x1, v40, &v41, &v42);
			x6 = v42;
			x5 = v41;
		} break;
		case 16LL: { // OpCoerce
			int64_t v43 = mtp_mirth_arrow_Op_OpCoerce(x2);
			VAL v44 = MKI64(0LL /* Nil */);
			x6 = v44;
			x5 = x1;
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v45 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			VAL v46 = MKI64(0LL /* Nil */);
			x6 = v46;
			x5 = x1;
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v47 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			VAL v48 = MKI64(0LL /* Nil */);
			x6 = v48;
			x5 = x1;
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v49 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			VAL v50 = MKI64(0LL /* Nil */);
			x6 = v50;
			x5 = x1;
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v51 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			VAL v52 = MKI64(0LL /* Nil */);
			x6 = v52;
			x5 = x1;
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v53 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			VAL v54 = MKI64(0LL /* Nil */);
			x6 = v54;
			x5 = x1;
		} break;
		case 22LL: { // OpDataGetLabel
			VAL v55 = mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			decref(v55);
			VAL v56 = MKI64(0LL /* Nil */);
			x6 = v56;
			x5 = x1;
		} break;
		case 23LL: { // OpDataSetLabel
			VAL v57 = mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			decref(v57);
			VAL v58 = MKI64(0LL /* Nil */);
			x6 = v58;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_match_Match_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x2)->cells[7]);
	incref(v5);
	decref(x2);
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v5, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v15;
			VAL v16;
			mw_mirth_match_Case_freeZ_vars(x1, v14, &v15, &v16);
			VAL v17 = mtw_std_list_List_1_Cons(v16, v7);
			int64_t v18 = 1LL /* True */;
			x13 = v18;
			x12 = v9;
			x11 = v17;
			x10 = v15;
		} break;
		case 0LL: { // None
			int64_t v19 = 0LL /* False */;
			x13 = v19;
			x12 = v9;
			x11 = v7;
			x10 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v20 = (x10);
	VAL v21 = (x11);
	VAL v22 = x12;
	int64_t v23 = x13;
	while (((bool)v23)) {
		VAL v24 = (v20);
		VAL v25 = (v21);
		VAL v26 = v22;
		VAL v27;
		VAL v28;
		mw_std_list_List_1_uncons(v26, &v27, &v28);
		VAL x29;
		VAL x30;
		VAL x31;
		int64_t x32;
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				VAL v33 = mtp_std_maybe_Maybe_1_Some(v27);
				VAL v34;
				VAL v35;
				mw_mirth_match_Case_freeZ_vars(v24, v33, &v34, &v35);
				VAL v36 = mtw_std_list_List_1_Cons(v35, v25);
				int64_t v37 = 1LL /* True */;
				x32 = v37;
				x31 = v28;
				x30 = v36;
				x29 = v34;
			} break;
			case 0LL: { // None
				int64_t v38 = 0LL /* False */;
				x32 = v38;
				x31 = v28;
				x30 = v25;
				x29 = v24;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v23 = x32;
		v22 = x31;
		v21 = x30;
		v20 = x29;
	}
	decref(v22);
	VAL v39 = mw_std_list_List_1_reverse(v21);
	VAL v40 = mw_std_list_List_1_ZToListZPlus(v39);
	VAL x41;
	VAL x42;
	switch (get_data_tag(v40)) {
		case 1LL: { // Some
			VAL v43 = mtp_std_maybe_Maybe_1_Some(v40);
			VAL v44;
			VAL v45;
			mw_std_list_ListZPlus_1_uncons(v43, &v44, &v45);
			VAL v46;
			VAL v47;
			mw_std_list_List_1_uncons(v45, &v46, &v47);
			VAL x48;
			VAL x49;
			VAL x50;
			int64_t x51;
			switch (get_data_tag(v46)) {
				case 1LL: { // Some
					VAL v52 = mtp_std_maybe_Maybe_1_Some(v46);
					incref(v44);
					VAL v53 = MKI64(0LL /* Nil */);
					VAL v54 = mw_std_list_List_1_reverse(v53);
					VAL v55;
					VAL v56;
					mw_std_list_List_1_uncons(v52, &v55, &v56);
					VAL x57;
					VAL x58;
					VAL x59;
					VAL x60;
					int64_t x61;
					switch (get_data_tag(v55)) {
						case 1LL: { // Some
							VAL v62 = mtp_std_maybe_Maybe_1_Some(v55);
							incref(v62);
							incref(v44);
							VAL v63 = MKI64(0LL /* None */);
							VAL v64;
							VAL v65;
							mw_std_list_List_1_uncons(v44, &v64, &v65);
							VAL x66;
							uint64_t x67;
							VAL x68;
							VAL x69;
							int64_t x70;
							switch (get_data_tag(v64)) {
								case 1LL: { // Some
									VAL v71 = mtp_std_maybe_Maybe_1_Some(v64);
									incref(v71);
									incref(v62);
									int64_t v72 = mw_mirth_var_Var_ZEqualZEqual(VU64(v62), VU64(v71));
									VAL x73;
									uint64_t x74;
									VAL x75;
									if (((bool)v72)) {
										VAL v76 = mtw_std_maybe_Maybe_1_Some(v71);
										x75 = v76;
										x74 = VU64(v62);
										x73 = v20;
									} else {
										decref(v71);
										VAL v77 = MKI64(0LL /* None */);
										x75 = v77;
										x74 = VU64(v62);
										x73 = v20;
									}
									VAL x78;
									uint64_t x79;
									VAL x80;
									VAL x81;
									switch (get_data_tag(x75)) {
										case 0LL: { // None
											x81 = v65;
											x80 = v63;
											x79 = x74;
											x78 = x73;
										} break;
										default: {
											decref(v65);
											decref(v63);
											VAL v82 = MKI64(0LL /* Nil */);
											x81 = v82;
											x80 = x75;
											x79 = x74;
											x78 = x73;
										} break;
									}
									int64_t v83 = 1LL /* True */;
									x70 = v83;
									x69 = x81;
									x68 = x80;
									x67 = x79;
									x66 = x78;
								} break;
								case 0LL: { // None
									int64_t v84 = 0LL /* False */;
									x70 = v84;
									x69 = v65;
									x68 = v63;
									x67 = VU64(v62);
									x66 = v20;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v85 = (x66);
							uint64_t v86 = x67;
							VAL v87 = x68;
							VAL v88 = x69;
							int64_t v89 = x70;
							while (((bool)v89)) {
								VAL v90 = (v85);
								uint64_t v91 = v86;
								VAL v92 = v87;
								VAL v93 = v88;
								VAL v94;
								VAL v95;
								mw_std_list_List_1_uncons(v93, &v94, &v95);
								VAL x96;
								uint64_t x97;
								VAL x98;
								VAL x99;
								int64_t x100;
								switch (get_data_tag(v94)) {
									case 1LL: { // Some
										VAL v101 = mtp_std_maybe_Maybe_1_Some(v94);
										incref(v101);
										int64_t v102 = mw_mirth_var_Var_ZEqualZEqual(v91, VU64(v101));
										VAL x103;
										uint64_t x104;
										VAL x105;
										if (((bool)v102)) {
											VAL v106 = mtw_std_maybe_Maybe_1_Some(v101);
											x105 = v106;
											x104 = v91;
											x103 = v90;
										} else {
											decref(v101);
											VAL v107 = MKI64(0LL /* None */);
											x105 = v107;
											x104 = v91;
											x103 = v90;
										}
										VAL x108;
										uint64_t x109;
										VAL x110;
										VAL x111;
										switch (get_data_tag(x105)) {
											case 0LL: { // None
												x111 = v95;
												x110 = v92;
												x109 = x104;
												x108 = x103;
											} break;
											default: {
												decref(v95);
												decref(v92);
												VAL v112 = MKI64(0LL /* Nil */);
												x111 = v112;
												x110 = x105;
												x109 = x104;
												x108 = x103;
											} break;
										}
										int64_t v113 = 1LL /* True */;
										x100 = v113;
										x99 = x111;
										x98 = x110;
										x97 = x109;
										x96 = x108;
									} break;
									case 0LL: { // None
										int64_t v114 = 0LL /* False */;
										x100 = v114;
										x99 = v95;
										x98 = v92;
										x97 = v91;
										x96 = v90;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v89 = x100;
								v88 = x99;
								v87 = x98;
								v86 = x97;
								v85 = x96;
							}
							decref(v88);
							int64_t v115 = mw_std_maybe_Maybe_1_someZAsk(v87);
							bool v116 = !((bool)v115);
							VAL x117;
							VAL x118;
							VAL x119;
							if (v116) {
								VAL v120 = mtw_std_maybe_Maybe_1_Some(v62);
								x119 = v120;
								x118 = v44;
								x117 = v85;
							} else {
								decref(v62);
								VAL v121 = MKI64(0LL /* None */);
								x119 = v121;
								x118 = v44;
								x117 = v85;
							}
							VAL x122;
							switch (get_data_tag(x119)) {
								case 1LL: { // Some
									VAL v123 = mtp_std_maybe_Maybe_1_Some(x119);
									VAL v124 = mtw_std_list_List_1_Cons(v123, v54);
									x122 = v124;
									push_resource(x117);
									push_value(x118);
								} break;
								case 0LL: { // None
									x122 = v54;
									push_resource(x117);
									push_value(x118);
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v125 = 1LL /* True */;
							x61 = v125;
							x60 = v56;
							x59 = x122;
							VAL v126 = pop_value();
							x58 = v126;
							VAL r127 = pop_resource();
							x57 = r127;
						} break;
						case 0LL: { // None
							int64_t v128 = 0LL /* False */;
							x61 = v128;
							x60 = v56;
							x59 = v54;
							x58 = v44;
							x57 = v20;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v129 = (x57);
					VAL v130 = x58;
					VAL v131 = (x59);
					VAL v132 = x60;
					int64_t v133 = x61;
					while (((bool)v133)) {
						VAL v134 = (v129);
						VAL v135 = v130;
						VAL v136 = (v131);
						VAL v137 = v132;
						VAL v138;
						VAL v139;
						mw_std_list_List_1_uncons(v137, &v138, &v139);
						VAL x140;
						VAL x141;
						VAL x142;
						VAL x143;
						int64_t x144;
						switch (get_data_tag(v138)) {
							case 1LL: { // Some
								VAL v145 = mtp_std_maybe_Maybe_1_Some(v138);
								incref(v145);
								incref(v135);
								VAL v146 = MKI64(0LL /* None */);
								VAL v147;
								VAL v148;
								mw_std_list_List_1_uncons(v135, &v147, &v148);
								VAL x149;
								uint64_t x150;
								VAL x151;
								VAL x152;
								int64_t x153;
								switch (get_data_tag(v147)) {
									case 1LL: { // Some
										VAL v154 = mtp_std_maybe_Maybe_1_Some(v147);
										incref(v154);
										incref(v145);
										int64_t v155 = mw_mirth_var_Var_ZEqualZEqual(VU64(v145), VU64(v154));
										VAL x156;
										uint64_t x157;
										VAL x158;
										if (((bool)v155)) {
											VAL v159 = mtw_std_maybe_Maybe_1_Some(v154);
											x158 = v159;
											x157 = VU64(v145);
											x156 = v134;
										} else {
											decref(v154);
											VAL v160 = MKI64(0LL /* None */);
											x158 = v160;
											x157 = VU64(v145);
											x156 = v134;
										}
										VAL x161;
										uint64_t x162;
										VAL x163;
										VAL x164;
										switch (get_data_tag(x158)) {
											case 0LL: { // None
												x164 = v148;
												x163 = v146;
												x162 = x157;
												x161 = x156;
											} break;
											default: {
												decref(v148);
												decref(v146);
												VAL v165 = MKI64(0LL /* Nil */);
												x164 = v165;
												x163 = x158;
												x162 = x157;
												x161 = x156;
											} break;
										}
										int64_t v166 = 1LL /* True */;
										x153 = v166;
										x152 = x164;
										x151 = x163;
										x150 = x162;
										x149 = x161;
									} break;
									case 0LL: { // None
										int64_t v167 = 0LL /* False */;
										x153 = v167;
										x152 = v148;
										x151 = v146;
										x150 = VU64(v145);
										x149 = v134;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v168 = (x149);
								uint64_t v169 = x150;
								VAL v170 = x151;
								VAL v171 = x152;
								int64_t v172 = x153;
								while (((bool)v172)) {
									VAL v173 = (v168);
									uint64_t v174 = v169;
									VAL v175 = v170;
									VAL v176 = v171;
									VAL v177;
									VAL v178;
									mw_std_list_List_1_uncons(v176, &v177, &v178);
									VAL x179;
									uint64_t x180;
									VAL x181;
									VAL x182;
									int64_t x183;
									switch (get_data_tag(v177)) {
										case 1LL: { // Some
											VAL v184 = mtp_std_maybe_Maybe_1_Some(v177);
											incref(v184);
											int64_t v185 = mw_mirth_var_Var_ZEqualZEqual(v174, VU64(v184));
											VAL x186;
											uint64_t x187;
											VAL x188;
											if (((bool)v185)) {
												VAL v189 = mtw_std_maybe_Maybe_1_Some(v184);
												x188 = v189;
												x187 = v174;
												x186 = v173;
											} else {
												decref(v184);
												VAL v190 = MKI64(0LL /* None */);
												x188 = v190;
												x187 = v174;
												x186 = v173;
											}
											VAL x191;
											uint64_t x192;
											VAL x193;
											VAL x194;
											switch (get_data_tag(x188)) {
												case 0LL: { // None
													x194 = v178;
													x193 = v175;
													x192 = x187;
													x191 = x186;
												} break;
												default: {
													decref(v178);
													decref(v175);
													VAL v195 = MKI64(0LL /* Nil */);
													x194 = v195;
													x193 = x188;
													x192 = x187;
													x191 = x186;
												} break;
											}
											int64_t v196 = 1LL /* True */;
											x183 = v196;
											x182 = x194;
											x181 = x193;
											x180 = x192;
											x179 = x191;
										} break;
										case 0LL: { // None
											int64_t v197 = 0LL /* False */;
											x183 = v197;
											x182 = v178;
											x181 = v175;
											x180 = v174;
											x179 = v173;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v172 = x183;
									v171 = x182;
									v170 = x181;
									v169 = x180;
									v168 = x179;
								}
								decref(v171);
								int64_t v198 = mw_std_maybe_Maybe_1_someZAsk(v170);
								bool v199 = !((bool)v198);
								VAL x200;
								VAL x201;
								VAL x202;
								if (v199) {
									VAL v203 = mtw_std_maybe_Maybe_1_Some(v145);
									x202 = v203;
									x201 = v135;
									x200 = v168;
								} else {
									decref(v145);
									VAL v204 = MKI64(0LL /* None */);
									x202 = v204;
									x201 = v135;
									x200 = v168;
								}
								VAL x205;
								switch (get_data_tag(x202)) {
									case 1LL: { // Some
										VAL v206 = mtp_std_maybe_Maybe_1_Some(x202);
										VAL v207 = mtw_std_list_List_1_Cons(v206, v136);
										x205 = v207;
										push_resource(x200);
										push_value(x201);
									} break;
									case 0LL: { // None
										x205 = v136;
										push_resource(x200);
										push_value(x201);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v208 = 1LL /* True */;
								x144 = v208;
								x143 = v139;
								x142 = x205;
								VAL v209 = pop_value();
								x141 = v209;
								VAL r210 = pop_resource();
								x140 = r210;
							} break;
							case 0LL: { // None
								int64_t v211 = 0LL /* False */;
								x144 = v211;
								x143 = v139;
								x142 = v136;
								x141 = v135;
								x140 = v134;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v133 = x144;
						v132 = x143;
						v131 = x142;
						v130 = x141;
						v129 = x140;
					}
					decref(v132);
					VAL v212 = mw_std_list_List_1_reverse(v131);
					decref(v130);
					VAL v213 = mw_std_list_List_1_cat(v44, v212);
					int64_t v214 = 1LL /* True */;
					x51 = v214;
					x50 = v47;
					x49 = v213;
					x48 = v129;
				} break;
				case 0LL: { // None
					int64_t v215 = 0LL /* False */;
					x51 = v215;
					x50 = v47;
					x49 = v44;
					x48 = v20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v216 = (x48);
			VAL v217 = x49;
			VAL v218 = x50;
			int64_t v219 = x51;
			while (((bool)v219)) {
				VAL v220 = (v216);
				VAL v221 = v217;
				VAL v222 = v218;
				VAL v223;
				VAL v224;
				mw_std_list_List_1_uncons(v222, &v223, &v224);
				VAL x225;
				VAL x226;
				VAL x227;
				int64_t x228;
				switch (get_data_tag(v223)) {
					case 1LL: { // Some
						VAL v229 = mtp_std_maybe_Maybe_1_Some(v223);
						incref(v221);
						VAL v230 = MKI64(0LL /* Nil */);
						VAL v231 = mw_std_list_List_1_reverse(v230);
						VAL v232;
						VAL v233;
						mw_std_list_List_1_uncons(v229, &v232, &v233);
						VAL x234;
						VAL x235;
						VAL x236;
						VAL x237;
						int64_t x238;
						switch (get_data_tag(v232)) {
							case 1LL: { // Some
								VAL v239 = mtp_std_maybe_Maybe_1_Some(v232);
								incref(v239);
								incref(v221);
								VAL v240 = MKI64(0LL /* None */);
								VAL v241;
								VAL v242;
								mw_std_list_List_1_uncons(v221, &v241, &v242);
								VAL x243;
								uint64_t x244;
								VAL x245;
								VAL x246;
								int64_t x247;
								switch (get_data_tag(v241)) {
									case 1LL: { // Some
										VAL v248 = mtp_std_maybe_Maybe_1_Some(v241);
										incref(v248);
										incref(v239);
										int64_t v249 = mw_mirth_var_Var_ZEqualZEqual(VU64(v239), VU64(v248));
										VAL x250;
										uint64_t x251;
										VAL x252;
										if (((bool)v249)) {
											VAL v253 = mtw_std_maybe_Maybe_1_Some(v248);
											x252 = v253;
											x251 = VU64(v239);
											x250 = v220;
										} else {
											decref(v248);
											VAL v254 = MKI64(0LL /* None */);
											x252 = v254;
											x251 = VU64(v239);
											x250 = v220;
										}
										VAL x255;
										uint64_t x256;
										VAL x257;
										VAL x258;
										switch (get_data_tag(x252)) {
											case 0LL: { // None
												x258 = v242;
												x257 = v240;
												x256 = x251;
												x255 = x250;
											} break;
											default: {
												decref(v242);
												decref(v240);
												VAL v259 = MKI64(0LL /* Nil */);
												x258 = v259;
												x257 = x252;
												x256 = x251;
												x255 = x250;
											} break;
										}
										int64_t v260 = 1LL /* True */;
										x247 = v260;
										x246 = x258;
										x245 = x257;
										x244 = x256;
										x243 = x255;
									} break;
									case 0LL: { // None
										int64_t v261 = 0LL /* False */;
										x247 = v261;
										x246 = v242;
										x245 = v240;
										x244 = VU64(v239);
										x243 = v220;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v262 = (x243);
								uint64_t v263 = x244;
								VAL v264 = x245;
								VAL v265 = x246;
								int64_t v266 = x247;
								while (((bool)v266)) {
									VAL v267 = (v262);
									uint64_t v268 = v263;
									VAL v269 = v264;
									VAL v270 = v265;
									VAL v271;
									VAL v272;
									mw_std_list_List_1_uncons(v270, &v271, &v272);
									VAL x273;
									uint64_t x274;
									VAL x275;
									VAL x276;
									int64_t x277;
									switch (get_data_tag(v271)) {
										case 1LL: { // Some
											VAL v278 = mtp_std_maybe_Maybe_1_Some(v271);
											incref(v278);
											int64_t v279 = mw_mirth_var_Var_ZEqualZEqual(v268, VU64(v278));
											VAL x280;
											uint64_t x281;
											VAL x282;
											if (((bool)v279)) {
												VAL v283 = mtw_std_maybe_Maybe_1_Some(v278);
												x282 = v283;
												x281 = v268;
												x280 = v267;
											} else {
												decref(v278);
												VAL v284 = MKI64(0LL /* None */);
												x282 = v284;
												x281 = v268;
												x280 = v267;
											}
											VAL x285;
											uint64_t x286;
											VAL x287;
											VAL x288;
											switch (get_data_tag(x282)) {
												case 0LL: { // None
													x288 = v272;
													x287 = v269;
													x286 = x281;
													x285 = x280;
												} break;
												default: {
													decref(v272);
													decref(v269);
													VAL v289 = MKI64(0LL /* Nil */);
													x288 = v289;
													x287 = x282;
													x286 = x281;
													x285 = x280;
												} break;
											}
											int64_t v290 = 1LL /* True */;
											x277 = v290;
											x276 = x288;
											x275 = x287;
											x274 = x286;
											x273 = x285;
										} break;
										case 0LL: { // None
											int64_t v291 = 0LL /* False */;
											x277 = v291;
											x276 = v272;
											x275 = v269;
											x274 = v268;
											x273 = v267;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v266 = x277;
									v265 = x276;
									v264 = x275;
									v263 = x274;
									v262 = x273;
								}
								decref(v265);
								int64_t v292 = mw_std_maybe_Maybe_1_someZAsk(v264);
								bool v293 = !((bool)v292);
								VAL x294;
								VAL x295;
								VAL x296;
								if (v293) {
									VAL v297 = mtw_std_maybe_Maybe_1_Some(v239);
									x296 = v297;
									x295 = v221;
									x294 = v262;
								} else {
									decref(v239);
									VAL v298 = MKI64(0LL /* None */);
									x296 = v298;
									x295 = v221;
									x294 = v262;
								}
								VAL x299;
								switch (get_data_tag(x296)) {
									case 1LL: { // Some
										VAL v300 = mtp_std_maybe_Maybe_1_Some(x296);
										VAL v301 = mtw_std_list_List_1_Cons(v300, v231);
										x299 = v301;
										push_resource(x294);
										push_value(x295);
									} break;
									case 0LL: { // None
										x299 = v231;
										push_resource(x294);
										push_value(x295);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v302 = 1LL /* True */;
								x238 = v302;
								x237 = v233;
								x236 = x299;
								VAL v303 = pop_value();
								x235 = v303;
								VAL r304 = pop_resource();
								x234 = r304;
							} break;
							case 0LL: { // None
								int64_t v305 = 0LL /* False */;
								x238 = v305;
								x237 = v233;
								x236 = v231;
								x235 = v221;
								x234 = v220;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v306 = (x234);
						VAL v307 = x235;
						VAL v308 = (x236);
						VAL v309 = x237;
						int64_t v310 = x238;
						while (((bool)v310)) {
							VAL v311 = (v306);
							VAL v312 = v307;
							VAL v313 = (v308);
							VAL v314 = v309;
							VAL v315;
							VAL v316;
							mw_std_list_List_1_uncons(v314, &v315, &v316);
							VAL x317;
							VAL x318;
							VAL x319;
							VAL x320;
							int64_t x321;
							switch (get_data_tag(v315)) {
								case 1LL: { // Some
									VAL v322 = mtp_std_maybe_Maybe_1_Some(v315);
									incref(v322);
									incref(v312);
									VAL v323 = MKI64(0LL /* None */);
									VAL v324;
									VAL v325;
									mw_std_list_List_1_uncons(v312, &v324, &v325);
									VAL x326;
									uint64_t x327;
									VAL x328;
									VAL x329;
									int64_t x330;
									switch (get_data_tag(v324)) {
										case 1LL: { // Some
											VAL v331 = mtp_std_maybe_Maybe_1_Some(v324);
											incref(v331);
											incref(v322);
											int64_t v332 = mw_mirth_var_Var_ZEqualZEqual(VU64(v322), VU64(v331));
											VAL x333;
											uint64_t x334;
											VAL x335;
											if (((bool)v332)) {
												VAL v336 = mtw_std_maybe_Maybe_1_Some(v331);
												x335 = v336;
												x334 = VU64(v322);
												x333 = v311;
											} else {
												decref(v331);
												VAL v337 = MKI64(0LL /* None */);
												x335 = v337;
												x334 = VU64(v322);
												x333 = v311;
											}
											VAL x338;
											uint64_t x339;
											VAL x340;
											VAL x341;
											switch (get_data_tag(x335)) {
												case 0LL: { // None
													x341 = v325;
													x340 = v323;
													x339 = x334;
													x338 = x333;
												} break;
												default: {
													decref(v325);
													decref(v323);
													VAL v342 = MKI64(0LL /* Nil */);
													x341 = v342;
													x340 = x335;
													x339 = x334;
													x338 = x333;
												} break;
											}
											int64_t v343 = 1LL /* True */;
											x330 = v343;
											x329 = x341;
											x328 = x340;
											x327 = x339;
											x326 = x338;
										} break;
										case 0LL: { // None
											int64_t v344 = 0LL /* False */;
											x330 = v344;
											x329 = v325;
											x328 = v323;
											x327 = VU64(v322);
											x326 = v311;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									VAL v345 = (x326);
									uint64_t v346 = x327;
									VAL v347 = x328;
									VAL v348 = x329;
									int64_t v349 = x330;
									while (((bool)v349)) {
										VAL v350 = (v345);
										uint64_t v351 = v346;
										VAL v352 = v347;
										VAL v353 = v348;
										VAL v354;
										VAL v355;
										mw_std_list_List_1_uncons(v353, &v354, &v355);
										VAL x356;
										uint64_t x357;
										VAL x358;
										VAL x359;
										int64_t x360;
										switch (get_data_tag(v354)) {
											case 1LL: { // Some
												VAL v361 = mtp_std_maybe_Maybe_1_Some(v354);
												incref(v361);
												int64_t v362 = mw_mirth_var_Var_ZEqualZEqual(v351, VU64(v361));
												VAL x363;
												uint64_t x364;
												VAL x365;
												if (((bool)v362)) {
													VAL v366 = mtw_std_maybe_Maybe_1_Some(v361);
													x365 = v366;
													x364 = v351;
													x363 = v350;
												} else {
													decref(v361);
													VAL v367 = MKI64(0LL /* None */);
													x365 = v367;
													x364 = v351;
													x363 = v350;
												}
												VAL x368;
												uint64_t x369;
												VAL x370;
												VAL x371;
												switch (get_data_tag(x365)) {
													case 0LL: { // None
														x371 = v355;
														x370 = v352;
														x369 = x364;
														x368 = x363;
													} break;
													default: {
														decref(v355);
														decref(v352);
														VAL v372 = MKI64(0LL /* Nil */);
														x371 = v372;
														x370 = x365;
														x369 = x364;
														x368 = x363;
													} break;
												}
												int64_t v373 = 1LL /* True */;
												x360 = v373;
												x359 = x371;
												x358 = x370;
												x357 = x369;
												x356 = x368;
											} break;
											case 0LL: { // None
												int64_t v374 = 0LL /* False */;
												x360 = v374;
												x359 = v355;
												x358 = v352;
												x357 = v351;
												x356 = v350;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										v349 = x360;
										v348 = x359;
										v347 = x358;
										v346 = x357;
										v345 = x356;
									}
									decref(v348);
									int64_t v375 = mw_std_maybe_Maybe_1_someZAsk(v347);
									bool v376 = !((bool)v375);
									VAL x377;
									VAL x378;
									VAL x379;
									if (v376) {
										VAL v380 = mtw_std_maybe_Maybe_1_Some(v322);
										x379 = v380;
										x378 = v312;
										x377 = v345;
									} else {
										decref(v322);
										VAL v381 = MKI64(0LL /* None */);
										x379 = v381;
										x378 = v312;
										x377 = v345;
									}
									VAL x382;
									switch (get_data_tag(x379)) {
										case 1LL: { // Some
											VAL v383 = mtp_std_maybe_Maybe_1_Some(x379);
											VAL v384 = mtw_std_list_List_1_Cons(v383, v313);
											x382 = v384;
											push_resource(x377);
											push_value(x378);
										} break;
										case 0LL: { // None
											x382 = v313;
											push_resource(x377);
											push_value(x378);
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									int64_t v385 = 1LL /* True */;
									x321 = v385;
									x320 = v316;
									x319 = x382;
									VAL v386 = pop_value();
									x318 = v386;
									VAL r387 = pop_resource();
									x317 = r387;
								} break;
								case 0LL: { // None
									int64_t v388 = 0LL /* False */;
									x321 = v388;
									x320 = v316;
									x319 = v313;
									x318 = v312;
									x317 = v311;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v310 = x321;
							v309 = x320;
							v308 = x319;
							v307 = x318;
							v306 = x317;
						}
						decref(v309);
						VAL v389 = mw_std_list_List_1_reverse(v308);
						decref(v307);
						VAL v390 = mw_std_list_List_1_cat(v221, v389);
						int64_t v391 = 1LL /* True */;
						x228 = v391;
						x227 = v224;
						x226 = v390;
						x225 = v306;
					} break;
					case 0LL: { // None
						int64_t v392 = 0LL /* False */;
						x228 = v392;
						x227 = v224;
						x226 = v221;
						x225 = v220;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v219 = x228;
				v218 = x227;
				v217 = x226;
				v216 = x225;
			}
			decref(v218);
			VAL v393 = mtw_std_maybe_Maybe_1_Some(v217);
			x42 = v393;
			x41 = v216;
		} break;
		case 0LL: { // None
			VAL v394 = MKI64(0LL /* None */);
			x42 = v394;
			x41 = v20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x395;
	switch (get_data_tag(x42)) {
		case 1LL: { // Some
			VAL v396 = mtp_std_maybe_Maybe_1_Some(x42);
			x395 = v396;
			push_resource(x41);
		} break;
		case 0LL: { // None
			VAL v397 = MKI64(0LL /* Nil */);
			x395 = v397;
			push_resource(x41);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x395;
	VAL r398 = pop_resource();
	*x3 = r398;
}
static void mw_mirth_match_Case_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x2)->cells[2]);
	incref(v5);
	decref(x2);
	VAL v6;
	VAL v7;
	mw_mirth_arrow_Arrow_freeZ_vars(x1, v5, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_arrow_Lambda_freeZ_vars (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	VAL v5 = VVAL(VTUP(x2)->cells[5]);
	incref(v5);
	decref(x2);
	VAL v6;
	VAL v7;
	mw_mirth_arrow_Arrow_freeZ_vars(x1, v5, &v6, &v7);
	VAL v8 = VVAL(VTUP(x2)->cells[4]);
	incref(v8);
	decref(x2);
	VAL v9 = MKI64(0LL /* Nil */);
	VAL v10 = mw_std_list_List_1_reverse(v9);
	VAL v11;
	VAL v12;
	mw_std_list_List_1_uncons(v7, &v11, &v12);
	VAL x13;
	VAL x14;
	VAL x15;
	VAL x16;
	int64_t x17;
	switch (get_data_tag(v11)) {
		case 1LL: { // Some
			VAL v18 = mtp_std_maybe_Maybe_1_Some(v11);
			incref(v18);
			incref(v8);
			VAL v19 = MKI64(0LL /* None */);
			VAL v20;
			VAL v21;
			mw_std_list_List_1_uncons(v8, &v20, &v21);
			VAL x22;
			uint64_t x23;
			VAL x24;
			VAL x25;
			int64_t x26;
			switch (get_data_tag(v20)) {
				case 1LL: { // Some
					VAL v27 = mtp_std_maybe_Maybe_1_Some(v20);
					incref(v27);
					incref(v18);
					int64_t v28 = mw_mirth_var_Var_ZEqualZEqual(VU64(v18), VU64(v27));
					VAL x29;
					uint64_t x30;
					VAL x31;
					if (((bool)v28)) {
						VAL v32 = mtw_std_maybe_Maybe_1_Some(v27);
						x31 = v32;
						x30 = VU64(v18);
						x29 = v6;
					} else {
						decref(v27);
						VAL v33 = MKI64(0LL /* None */);
						x31 = v33;
						x30 = VU64(v18);
						x29 = v6;
					}
					VAL x34;
					uint64_t x35;
					VAL x36;
					VAL x37;
					switch (get_data_tag(x31)) {
						case 0LL: { // None
							x37 = v21;
							x36 = v19;
							x35 = x30;
							x34 = x29;
						} break;
						default: {
							decref(v21);
							decref(v19);
							VAL v38 = MKI64(0LL /* Nil */);
							x37 = v38;
							x36 = x31;
							x35 = x30;
							x34 = x29;
						} break;
					}
					int64_t v39 = 1LL /* True */;
					x26 = v39;
					x25 = x37;
					x24 = x36;
					x23 = x35;
					x22 = x34;
				} break;
				case 0LL: { // None
					int64_t v40 = 0LL /* False */;
					x26 = v40;
					x25 = v21;
					x24 = v19;
					x23 = VU64(v18);
					x22 = v6;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v41 = (x22);
			uint64_t v42 = x23;
			VAL v43 = x24;
			VAL v44 = x25;
			int64_t v45 = x26;
			while (((bool)v45)) {
				VAL v46 = (v41);
				uint64_t v47 = v42;
				VAL v48 = v43;
				VAL v49 = v44;
				VAL v50;
				VAL v51;
				mw_std_list_List_1_uncons(v49, &v50, &v51);
				VAL x52;
				uint64_t x53;
				VAL x54;
				VAL x55;
				int64_t x56;
				switch (get_data_tag(v50)) {
					case 1LL: { // Some
						VAL v57 = mtp_std_maybe_Maybe_1_Some(v50);
						incref(v57);
						int64_t v58 = mw_mirth_var_Var_ZEqualZEqual(v47, VU64(v57));
						VAL x59;
						uint64_t x60;
						VAL x61;
						if (((bool)v58)) {
							VAL v62 = mtw_std_maybe_Maybe_1_Some(v57);
							x61 = v62;
							x60 = v47;
							x59 = v46;
						} else {
							decref(v57);
							VAL v63 = MKI64(0LL /* None */);
							x61 = v63;
							x60 = v47;
							x59 = v46;
						}
						VAL x64;
						uint64_t x65;
						VAL x66;
						VAL x67;
						switch (get_data_tag(x61)) {
							case 0LL: { // None
								x67 = v51;
								x66 = v48;
								x65 = x60;
								x64 = x59;
							} break;
							default: {
								decref(v51);
								decref(v48);
								VAL v68 = MKI64(0LL /* Nil */);
								x67 = v68;
								x66 = x61;
								x65 = x60;
								x64 = x59;
							} break;
						}
						int64_t v69 = 1LL /* True */;
						x56 = v69;
						x55 = x67;
						x54 = x66;
						x53 = x65;
						x52 = x64;
					} break;
					case 0LL: { // None
						int64_t v70 = 0LL /* False */;
						x56 = v70;
						x55 = v51;
						x54 = v48;
						x53 = v47;
						x52 = v46;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v45 = x56;
				v44 = x55;
				v43 = x54;
				v42 = x53;
				v41 = x52;
			}
			decref(v44);
			int64_t v71 = mw_std_maybe_Maybe_1_someZAsk(v43);
			bool v72 = !((bool)v71);
			VAL x73;
			VAL x74;
			VAL x75;
			if (v72) {
				VAL v76 = mtw_std_maybe_Maybe_1_Some(v18);
				x75 = v76;
				x74 = v8;
				x73 = v41;
			} else {
				decref(v18);
				VAL v77 = MKI64(0LL /* None */);
				x75 = v77;
				x74 = v8;
				x73 = v41;
			}
			VAL x78;
			switch (get_data_tag(x75)) {
				case 1LL: { // Some
					VAL v79 = mtp_std_maybe_Maybe_1_Some(x75);
					VAL v80 = mtw_std_list_List_1_Cons(v79, v10);
					x78 = v80;
					push_resource(x73);
					push_value(x74);
				} break;
				case 0LL: { // None
					x78 = v10;
					push_resource(x73);
					push_value(x74);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v81 = 1LL /* True */;
			x17 = v81;
			x16 = v12;
			x15 = x78;
			VAL v82 = pop_value();
			x14 = v82;
			VAL r83 = pop_resource();
			x13 = r83;
		} break;
		case 0LL: { // None
			int64_t v84 = 0LL /* False */;
			x17 = v84;
			x16 = v12;
			x15 = v10;
			x14 = v8;
			x13 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v85 = (x13);
	VAL v86 = x14;
	VAL v87 = (x15);
	VAL v88 = x16;
	int64_t v89 = x17;
	while (((bool)v89)) {
		VAL v90 = (v85);
		VAL v91 = v86;
		VAL v92 = (v87);
		VAL v93 = v88;
		VAL v94;
		VAL v95;
		mw_std_list_List_1_uncons(v93, &v94, &v95);
		VAL x96;
		VAL x97;
		VAL x98;
		VAL x99;
		int64_t x100;
		switch (get_data_tag(v94)) {
			case 1LL: { // Some
				VAL v101 = mtp_std_maybe_Maybe_1_Some(v94);
				incref(v101);
				incref(v91);
				VAL v102 = MKI64(0LL /* None */);
				VAL v103;
				VAL v104;
				mw_std_list_List_1_uncons(v91, &v103, &v104);
				VAL x105;
				uint64_t x106;
				VAL x107;
				VAL x108;
				int64_t x109;
				switch (get_data_tag(v103)) {
					case 1LL: { // Some
						VAL v110 = mtp_std_maybe_Maybe_1_Some(v103);
						incref(v110);
						incref(v101);
						int64_t v111 = mw_mirth_var_Var_ZEqualZEqual(VU64(v101), VU64(v110));
						VAL x112;
						uint64_t x113;
						VAL x114;
						if (((bool)v111)) {
							VAL v115 = mtw_std_maybe_Maybe_1_Some(v110);
							x114 = v115;
							x113 = VU64(v101);
							x112 = v90;
						} else {
							decref(v110);
							VAL v116 = MKI64(0LL /* None */);
							x114 = v116;
							x113 = VU64(v101);
							x112 = v90;
						}
						VAL x117;
						uint64_t x118;
						VAL x119;
						VAL x120;
						switch (get_data_tag(x114)) {
							case 0LL: { // None
								x120 = v104;
								x119 = v102;
								x118 = x113;
								x117 = x112;
							} break;
							default: {
								decref(v104);
								decref(v102);
								VAL v121 = MKI64(0LL /* Nil */);
								x120 = v121;
								x119 = x114;
								x118 = x113;
								x117 = x112;
							} break;
						}
						int64_t v122 = 1LL /* True */;
						x109 = v122;
						x108 = x120;
						x107 = x119;
						x106 = x118;
						x105 = x117;
					} break;
					case 0LL: { // None
						int64_t v123 = 0LL /* False */;
						x109 = v123;
						x108 = v104;
						x107 = v102;
						x106 = VU64(v101);
						x105 = v90;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v124 = (x105);
				uint64_t v125 = x106;
				VAL v126 = x107;
				VAL v127 = x108;
				int64_t v128 = x109;
				while (((bool)v128)) {
					VAL v129 = (v124);
					uint64_t v130 = v125;
					VAL v131 = v126;
					VAL v132 = v127;
					VAL v133;
					VAL v134;
					mw_std_list_List_1_uncons(v132, &v133, &v134);
					VAL x135;
					uint64_t x136;
					VAL x137;
					VAL x138;
					int64_t x139;
					switch (get_data_tag(v133)) {
						case 1LL: { // Some
							VAL v140 = mtp_std_maybe_Maybe_1_Some(v133);
							incref(v140);
							int64_t v141 = mw_mirth_var_Var_ZEqualZEqual(v130, VU64(v140));
							VAL x142;
							uint64_t x143;
							VAL x144;
							if (((bool)v141)) {
								VAL v145 = mtw_std_maybe_Maybe_1_Some(v140);
								x144 = v145;
								x143 = v130;
								x142 = v129;
							} else {
								decref(v140);
								VAL v146 = MKI64(0LL /* None */);
								x144 = v146;
								x143 = v130;
								x142 = v129;
							}
							VAL x147;
							uint64_t x148;
							VAL x149;
							VAL x150;
							switch (get_data_tag(x144)) {
								case 0LL: { // None
									x150 = v134;
									x149 = v131;
									x148 = x143;
									x147 = x142;
								} break;
								default: {
									decref(v134);
									decref(v131);
									VAL v151 = MKI64(0LL /* Nil */);
									x150 = v151;
									x149 = x144;
									x148 = x143;
									x147 = x142;
								} break;
							}
							int64_t v152 = 1LL /* True */;
							x139 = v152;
							x138 = x150;
							x137 = x149;
							x136 = x148;
							x135 = x147;
						} break;
						case 0LL: { // None
							int64_t v153 = 0LL /* False */;
							x139 = v153;
							x138 = v134;
							x137 = v131;
							x136 = v130;
							x135 = v129;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v128 = x139;
					v127 = x138;
					v126 = x137;
					v125 = x136;
					v124 = x135;
				}
				decref(v127);
				int64_t v154 = mw_std_maybe_Maybe_1_someZAsk(v126);
				bool v155 = !((bool)v154);
				VAL x156;
				VAL x157;
				VAL x158;
				if (v155) {
					VAL v159 = mtw_std_maybe_Maybe_1_Some(v101);
					x158 = v159;
					x157 = v91;
					x156 = v124;
				} else {
					decref(v101);
					VAL v160 = MKI64(0LL /* None */);
					x158 = v160;
					x157 = v91;
					x156 = v124;
				}
				VAL x161;
				switch (get_data_tag(x158)) {
					case 1LL: { // Some
						VAL v162 = mtp_std_maybe_Maybe_1_Some(x158);
						VAL v163 = mtw_std_list_List_1_Cons(v162, v92);
						x161 = v163;
						push_resource(x156);
						push_value(x157);
					} break;
					case 0LL: { // None
						x161 = v92;
						push_resource(x156);
						push_value(x157);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v164 = 1LL /* True */;
				x100 = v164;
				x99 = v95;
				x98 = x161;
				VAL v165 = pop_value();
				x97 = v165;
				VAL r166 = pop_resource();
				x96 = r166;
			} break;
			case 0LL: { // None
				int64_t v167 = 0LL /* False */;
				x100 = v167;
				x99 = v95;
				x98 = v92;
				x97 = v91;
				x96 = v90;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v89 = x100;
		v88 = x99;
		v87 = x98;
		v86 = x97;
		v85 = x96;
	}
	decref(v88);
	VAL v168 = mw_std_list_List_1_reverse(v87);
	decref(v86);
	*x4 = v168;
	*x3 = v85;
}
static uint64_t mw_mirth_arrow_Arg_token (uint64_t x1) {
	uint64_t v2 = mw_mirth_arrow_Block_token(x1);
	return v2;
}
static int64_t mw_mirth_typedef_TypeDef_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_typedef_TypeDef_allocZBang (void) {
	void* v1 = mbuf_mirth_typedef_TypeDef_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_typedef_TypeDef_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_typedef_TypeDef_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_typedef_TypeDef_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_typedef_TypeDef_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_typedef_TypeDef_ZTildeqname(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static void mw_mirth_typedef_TypeDef_namespace (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_typedef_TypeDef_qnameZ_hard(x1, x2, &v5, &v6);
	VAL v7 = VVAL(VTUP(v6)->cells[1]);
	incref(v7);
	decref(v6);
	*x4 = v7;
	*x3 = v5;
}
static uint64_t mw_mirth_typedef_TypeDef_name (uint64_t x1) {
	void* v2 = mfld_mirth_typedef_TypeDef_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static void mw_mirth_typedef_TypeDef_target (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_typedef_TypeDef_ZTildetarget(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static int64_t mw_mirth_typedef_TypeDef_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_typedef_TypeDef_index(x1);
	int64_t v4 = mw_mirth_typedef_TypeDef_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_typedef_TypeDef_newZBang (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6) {
	uint64_t v7 = mw_mirth_typedef_TypeDef_allocZBang();
	void* v8 = mfld_mirth_typedef_TypeDef_ZTildeheadZAsk(v7);
	mut_set(x2, v8);
	void* v9 = mfld_mirth_typedef_TypeDef_ZTildename(v7);
	mut_set(MKU64(x3), v9);
	VAL v10 = mtw_mirth_mirth_PropLabel_TypeDefQName(v7);
	VAL v11 = mtw_mirth_mirth_Prop_1_Prop(v10, x4);
	void* v12 = mfld_mirth_typedef_TypeDef_ZTildeqname(v7);
	mut_set(v11, v12);
	VAL v13 = mtw_mirth_def_Def_DefType(v7);
	VAL v14 = (mw_mirth_def_Def_register(x1, v13));
	*x6 = v7;
	*x5 = v14;
}
static VAL mw_mirth_mirth_ZPlusMirth_defZ_typeZBang (VAL x1, VAL x2, VAL x3) {
	VAL v4 = MKI64(0LL /* None */);
	incref(x2);
	uint64_t v5 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	VAL v6 = mtw_mirth_mirth_PropState_1_PSReady(x2);
	VAL v7;
	uint64_t v8;
	mw_mirth_typedef_TypeDef_newZBang(x1, v4, v5, v6, &v7, &v8);
	VAL v9 = mtw_mirth_mirth_PropLabel_TypeDefTarget(v8);
	VAL v10;
	VAL v11;
	mw_mirth_mirth_PropLabel_prop(x3, v9, v7, &v10, &v11);
	void* v12 = mfld_mirth_typedef_TypeDef_ZTildetarget(v8);
	mut_set(v10, v12);
	return v11;
}
static int64_t mw_mirth_type_PrimType_isZ_resourceZAsk (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 8LL: { // PRIM_TYPE_WORLD
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_type_PrimType_isZ_physicalZAsk (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 0LL: { // PRIM_TYPE_TYPE
			int64_t v3 = 0LL /* False */;
			x2 = v3;
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			int64_t v5 = 0LL /* False */;
			x2 = v5;
		} break;
		default: {
			int64_t v6 = 1LL /* True */;
			x2 = v6;
		} break;
	}
	return x2;
}
static VAL mw_mirth_type_Type_tyconZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			VAL v3 = MKI64(0LL /* None */);
			x2 = v3;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			VAL v4 = MKI64(0LL /* None */);
			x2 = v4;
		} break;
		case 2LL: { // TPrim
			int64_t v5 = mtp_mirth_type_Type_TPrim(x1);
			VAL v6 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			x2 = v7;
		} break;
		case 3LL: { // TMeta
			uint64_t v8 = mtp_mirth_type_Type_TMeta(x1);
			VAL v9 = mw_mirth_type_MetaVar_typeZAsk(v8);
			VAL x10;
			switch (get_data_tag(v9)) {
				case 0LL: { // None
					VAL v11 = MKI64(0LL /* None */);
					x10 = v11;
				} break;
				case 1LL: { // Some
					VAL v12 = mtp_std_maybe_Maybe_1_Some(v9);
					VAL v13 = mw_mirth_type_Type_expand(v12);
					incref(v13);
					VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
					void* v15 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v8);
					mut_set(v14, v15);
					VAL v16 = mw_mirth_type_Type_tyconZAsk(v13);
					x10 = v16;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x2 = x10;
		} break;
		case 4LL: { // THole
			uint64_t v17 = mtp_mirth_type_Type_THole(x1);
			VAL v18 = MKI64(0LL /* None */);
			x2 = v18;
		} break;
		case 5LL: { // TVar
			uint64_t v19 = mtp_mirth_type_Type_TVar(x1);
			VAL v20 = MKI64(0LL /* None */);
			x2 = v20;
		} break;
		case 6LL: { // TTable
			uint64_t v21 = mtp_mirth_type_Type_TTable(x1);
			VAL v22 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v21);
			VAL v23 = mtw_std_maybe_Maybe_1_Some(v22);
			x2 = v23;
		} break;
		case 7LL: { // TData
			uint64_t v24 = mtp_mirth_type_Type_TData(x1);
			VAL v25 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v24);
			VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
			x2 = v26;
		} break;
		case 8LL: { // TDataPartial
			VAL v27 = mtp_mirth_type_Type_TDataPartial(x1);
			uint64_t v28 = VU64(VTUP(v27)->cells[1]);
			decref(v27);
			VAL v29 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v28);
			VAL v30 = mtw_std_maybe_Maybe_1_Some(v29);
			x2 = v30;
		} break;
		case 10LL: { // TMorphism
			VAL v31 = mtp_mirth_type_Type_TMorphism(x1);
			decref(v31);
			VAL v32 = MKI64(0LL /* None */);
			x2 = v32;
		} break;
		case 9LL: { // TTensor
			VAL v33 = mtp_mirth_type_Type_TTensor(x1);
			decref(v33);
			VAL v34 = MKI64(0LL /* None */);
			x2 = v34;
		} break;
		case 11LL: { // TApp
			VAL v35;
			VAL v36;
			mtp_mirth_type_Type_TApp(x1, &v35, &v36);
			decref(v36);
			VAL v37 = mw_mirth_type_Type_tyconZAsk(v35);
			x2 = v37;
		} break;
		case 12LL: { // TMut
			VAL v38 = mtp_mirth_type_Type_TMut(x1);
			VAL v39 = mw_mirth_type_Type_tyconZAsk(v38);
			x2 = v39;
		} break;
		case 13LL: { // TValue
			VAL v40 = mtp_mirth_type_Type_TValue(x1);
			VAL v41 = mw_mirth_type_Value_tyconZAsk(v40);
			x2 = v41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_type_PrimType_tyconZ_qname (VAL x1, int64_t x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (x2) {
		case 0LL: { // PRIM_TYPE_TYPE
			STR* v7;
			STRLIT(v7, "TYPE", 4);
			int64_t v8 = 0LL;
			VAL v9;
			VAL v10;
			mw_mirth_name_QName_prim(x1, MKSTR(v7), v8, &v9, &v10);
			x6 = v10;
			x5 = v9;
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			STR* v11;
			STRLIT(v11, "STACK", 5);
			int64_t v12 = 0LL;
			VAL v13;
			VAL v14;
			mw_mirth_name_QName_prim(x1, MKSTR(v11), v12, &v13, &v14);
			x6 = v14;
			x5 = v13;
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			STR* v15;
			STRLIT(v15, "Resource", 8);
			int64_t v16 = 0LL;
			VAL v17;
			VAL v18;
			mw_mirth_name_QName_prim(x1, MKSTR(v15), v16, &v17, &v18);
			x6 = v18;
			x5 = v17;
		} break;
		case 3LL: { // PRIM_TYPE_INT
			STR* v19;
			STRLIT(v19, "Int", 3);
			int64_t v20 = 0LL;
			VAL v21;
			VAL v22;
			mw_mirth_name_QName_prim(x1, MKSTR(v19), v20, &v21, &v22);
			x6 = v22;
			x5 = v21;
		} break;
		case 4LL: { // PRIM_TYPE_F32
			STR* v23;
			STRLIT(v23, "F32", 3);
			int64_t v24 = 0LL;
			VAL v25;
			VAL v26;
			mw_mirth_name_QName_prim(x1, MKSTR(v23), v24, &v25, &v26);
			x6 = v26;
			x5 = v25;
		} break;
		case 5LL: { // PRIM_TYPE_F64
			STR* v27;
			STRLIT(v27, "F64", 3);
			int64_t v28 = 0LL;
			VAL v29;
			VAL v30;
			mw_mirth_name_QName_prim(x1, MKSTR(v27), v28, &v29, &v30);
			x6 = v30;
			x5 = v29;
		} break;
		case 7LL: { // PRIM_TYPE_STR
			STR* v31;
			STRLIT(v31, "Str", 3);
			int64_t v32 = 0LL;
			VAL v33;
			VAL v34;
			mw_mirth_name_QName_prim(x1, MKSTR(v31), v32, &v33, &v34);
			x6 = v34;
			x5 = v33;
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			STR* v35;
			STRLIT(v35, "Ptr", 3);
			int64_t v36 = 0LL;
			VAL v37;
			VAL v38;
			mw_mirth_name_QName_prim(x1, MKSTR(v35), v36, &v37, &v38);
			x6 = v38;
			x5 = v37;
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			STR* v39;
			STRLIT(v39, "+World", 6);
			int64_t v40 = 0LL;
			VAL v41;
			VAL v42;
			mw_mirth_name_QName_prim(x1, MKSTR(v39), v40, &v41, &v42);
			x6 = v42;
			x5 = v41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static VAL mw_mirth_type_Value_tyconZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // VALUE_INT
			int64_t v3 = mtp_mirth_type_Value_VALUEz_INT(x1);
			int64_t v4 = 3LL /* PRIM_TYPE_INT */;
			VAL v5 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v4);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			x2 = v6;
		} break;
		case 1LL: { // VALUE_F64
			double v7 = mtp_mirth_type_Value_VALUEz_F64(x1);
			int64_t v8 = 5LL /* PRIM_TYPE_F64 */;
			VAL v9 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v8);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			x2 = v10;
		} break;
		case 2LL: { // VALUE_STR
			VAL v11 = mtp_mirth_type_Value_VALUEz_STR(x1);
			decref(v11);
			int64_t v12 = 7LL /* PRIM_TYPE_STR */;
			VAL v13 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v12);
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			x2 = v14;
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v15 = mtp_mirth_type_Value_VALUEz_BLOCK(x1);
			VAL v16 = MKI64(0LL /* None */);
			x2 = v16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static int64_t mw_mirth_type_PrimType_ZToInt (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_type_PrimType_ZEqualZEqual (int64_t x1, int64_t x2) {
	int64_t v3 = mw_mirth_type_PrimType_ZToInt(x1);
	int64_t v4 = mw_mirth_type_PrimType_ZToInt(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang (VAL x1, int64_t x2) {
	VAL v3;
	VAL v4;
	mw_mirth_type_PrimType_tyconZ_qname(x1, x2, &v3, &v4);
	VAL v5 = mtw_mirth_type_Type_TPrim(x2);
	VAL v6 = (mw_mirth_mirth_ZPlusMirth_defZ_typeZBang(v3, v4, v5));
	return v6;
}
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang (VAL x1, int64_t x2, VAL x3) {
	uint64_t v4 = mw_std_prim_Str_ZToName(x3);
	VAL v5;
	VAL v6;
	mw_mirth_type_PrimType_tyconZ_qname(x1, x2, &v5, &v6);
	VAL v7 = tup_replace(v6, 2, MKU64(v4));
	VAL v8 = mtw_mirth_type_Type_TPrim(x2);
	VAL v9 = (mw_mirth_mirth_ZPlusMirth_defZ_typeZBang(v5, v7, v8));
	return v9;
}
static VAL mw_mirth_mirth_ZPlusMirth_initZ_typesZBang (VAL x1) {
	int64_t v2 = 3LL /* PRIM_TYPE_INT */;
	VAL v3 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(x1, v2));
	int64_t v4 = 4LL /* PRIM_TYPE_F32 */;
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v3, v4));
	int64_t v6 = 4LL /* PRIM_TYPE_F32 */;
	STR* v7;
	STRLIT(v7, "Float32", 7);
	VAL v8 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang(v5, v6, MKSTR(v7)));
	int64_t v9 = 5LL /* PRIM_TYPE_F64 */;
	VAL v10 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v8, v9));
	int64_t v11 = 5LL /* PRIM_TYPE_F64 */;
	STR* v12;
	STRLIT(v12, "Float64", 7);
	VAL v13 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang(v10, v11, MKSTR(v12)));
	int64_t v14 = 6LL /* PRIM_TYPE_PTR */;
	VAL v15 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v13, v14));
	int64_t v16 = 7LL /* PRIM_TYPE_STR */;
	VAL v17 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v15, v16));
	int64_t v18 = 8LL /* PRIM_TYPE_WORLD */;
	VAL v19 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v17, v18));
	VAL v20 = (mw_mirth_data_initZ_dataZBang(v19));
	return v20;
}
static VAL mw_mirth_type_TZPlus (VAL x1, VAL x2) {
	VAL v3 = mtw_mirth_type_StackType_STWith(x1, x2);
	return v3;
}
static VAL mw_mirth_type_TZMul (VAL x1, VAL x2) {
	VAL v3 = mtw_mirth_type_StackType_STCons(x1, x2);
	return v3;
}
static VAL mw_mirth_type_TZMulZPlus (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // Left
			VAL v4 = mtp_std_either_Either_2_Left(x2);
			VAL v5 = mw_mirth_type_TZMul(x1, v4);
			x3 = v5;
		} break;
		case 1LL: { // Right
			VAL v6 = mtp_std_either_Either_2_Right(x2);
			VAL v7 = mw_mirth_type_TZPlus(x1, v6);
			x3 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_TZ_ZTo (VAL x1, VAL x2) {
	VAL v3 = mtw_mirth_type_ArrowType_ARROWz_TYPE(x1, x2);
	return v3;
}
static VAL mw_mirth_type_TT (VAL x1) {
	VAL v2 = mw_mirth_type_T0();
	VAL v3;
	VAL v4;
	mw_std_list_List_1_uncons(x1, &v3, &v4);
	VAL x5;
	VAL x6;
	int64_t x7;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v9 = mw_mirth_type_TZMul(v2, v8);
			int64_t v10 = 1LL /* True */;
			x7 = v10;
			x6 = v4;
			x5 = v9;
		} break;
		case 0LL: { // None
			int64_t v11 = 0LL /* False */;
			x7 = v11;
			x6 = v4;
			x5 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v12 = x5;
	VAL v13 = x6;
	int64_t v14 = x7;
	while (((bool)v14)) {
		VAL v15 = v12;
		VAL v16 = v13;
		VAL v17;
		VAL v18;
		mw_std_list_List_1_uncons(v16, &v17, &v18);
		VAL x19;
		VAL x20;
		int64_t x21;
		switch (get_data_tag(v17)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v17);
				VAL v23 = mw_mirth_type_TZMul(v15, v22);
				int64_t v24 = 1LL /* True */;
				x21 = v24;
				x20 = v18;
				x19 = v23;
			} break;
			case 0LL: { // None
				int64_t v25 = 0LL /* False */;
				x21 = v25;
				x20 = v18;
				x19 = v15;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v14 = x21;
		v13 = x20;
		v12 = x19;
	}
	decref(v13);
	return v12;
}
static VAL mw_mirth_type_T0 (void) {
	VAL v1 = MKI64(2LL /* STACK_TYPE_UNIT */);
	return v1;
}
static VAL mw_mirth_type_T1 (VAL x1) {
	VAL v2 = mw_mirth_type_T0();
	VAL v3 = mw_mirth_type_TZMul(v2, x1);
	return v3;
}
static VAL mw_mirth_type_T2 (VAL x1, VAL x2) {
	VAL v3 = mw_mirth_type_T1(x1);
	VAL v4 = mw_mirth_type_TZMul(v3, x2);
	return v4;
}
static VAL mw_mirth_type_T3 (VAL x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_type_T2(x1, x2);
	VAL v5 = mw_mirth_type_TZMul(v4, x3);
	return v5;
}
static int64_t mw_mirth_type_Type_errorZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_Type_expand(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // TYPE_ERROR
			int64_t v4 = 1LL /* True */;
			x3 = v4;
		} break;
		default: {
			decref(v2);
			int64_t v5 = 0LL /* False */;
			x3 = v5;
		} break;
	}
	return x3;
}
static VAL mw_mirth_type_Type_morphismZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_Type_expand(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 10LL: { // TMorphism
			VAL v4 = mtp_mirth_type_Type_TMorphism(v2);
			VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
			x3 = v5;
		} break;
		default: {
			decref(v2);
			VAL v6 = MKI64(0LL /* None */);
			x3 = v6;
		} break;
	}
	return x3;
}
static VAL mw_mirth_type_Type_primZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_Type_expand(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 2LL: { // TPrim
			int64_t v4 = mtp_mirth_type_Type_TPrim(v2);
			VAL v5 = mtw_std_maybe_Maybe_1_Some(MKI64(v4));
			x3 = v5;
		} break;
		default: {
			decref(v2);
			VAL v6 = MKI64(0LL /* None */);
			x3 = v6;
		} break;
	}
	return x3;
}
static int64_t mw_mirth_type_Type_metaZEqual (uint64_t x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 3LL: { // TMeta
			uint64_t v4 = mtp_mirth_type_Type_TMeta(x2);
			int64_t v5 = mw_mirth_type_MetaVar_ZEqualZEqual(x1, v4);
			x3 = v5;
		} break;
		default: {
			decref(x2);
			int64_t v6 = 0LL /* False */;
			x3 = v6;
		} break;
	}
	return x3;
}
static int64_t mw_mirth_type_Type_isZ_physicalZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 3LL: { // TMeta
			uint64_t v3 = mtp_mirth_type_Type_TMeta(x1);
			VAL v4 = mw_mirth_type_MetaVar_typeZAsk(v3);
			int64_t x5;
			switch (get_data_tag(v4)) {
				case 0LL: { // None
					STR* v6;
					STRLIT(v6, "unbound meta at Type.is-physical?", 33);
					push_u64(v3);
					do_panic(v6);
					int64_t v7 = pop_i64();
					x5 = v7;
				} break;
				case 1LL: { // Some
					VAL v8 = mtp_std_maybe_Maybe_1_Some(v4);
					VAL v9 = mw_mirth_type_Type_expand(v8);
					incref(v9);
					VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
					void* v11 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v3);
					mut_set(v10, v11);
					int64_t v12 = mw_mirth_type_Type_isZ_physicalZAsk(v9);
					x5 = v12;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x2 = x5;
		} break;
		case 2LL: { // TPrim
			int64_t v13 = mtp_mirth_type_Type_TPrim(x1);
			int64_t v14 = mw_mirth_type_PrimType_isZ_physicalZAsk(v13);
			x2 = v14;
		} break;
		default: {
			decref(x1);
			int64_t v15 = 1LL /* True */;
			x2 = v15;
		} break;
	}
	return x2;
}
static VAL mw_mirth_type_TYPEz_TYPE (void) {
	int64_t v1 = 0LL /* PRIM_TYPE_TYPE */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_STACK (void) {
	int64_t v1 = 1LL /* PRIM_TYPE_STACK */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_RESOURCE (void) {
	int64_t v1 = 2LL /* PRIM_TYPE_RESOURCE */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_INT (void) {
	int64_t v1 = 3LL /* PRIM_TYPE_INT */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_F32 (void) {
	int64_t v1 = 4LL /* PRIM_TYPE_F32 */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_F64 (void) {
	int64_t v1 = 5LL /* PRIM_TYPE_F64 */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_PTR (void) {
	int64_t v1 = 6LL /* PRIM_TYPE_PTR */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_STR (void) {
	int64_t v1 = 7LL /* PRIM_TYPE_STR */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_TYPEz_WORLD (void) {
	int64_t v1 = 8LL /* PRIM_TYPE_WORLD */;
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	return v2;
}
static VAL mw_mirth_type_RESOURCEz_WORLD (void) {
	VAL v1 = mw_mirth_type_TYPEz_WORLD();
	return v1;
}
static VAL mw_mirth_type_Type_expand (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 3LL: { // TMeta
			uint64_t v3 = mtp_mirth_type_Type_TMeta(x1);
			VAL v4 = mw_mirth_type_MetaVar_expand(v3);
			x2 = v4;
		} break;
		default: {
			x2 = x1;
		} break;
	}
	return x2;
}
static void mw_mirth_type_ZPlusGamma_rdrop (uint64_t x1) {
}
static void mw_mirth_type_Type_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	STR* v8;
	STRLIT(v8, "", 0);
	STR* v9;
	STRLIT(v9, "Failed to unify ", 16);
	VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), MKSTR(v8)));
	VAL v11 = (mw_mirth_type_Type_typeZThen(x3, v10));
	STR* v12;
	STRLIT(v12, " with ", 6);
	VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
	VAL v14 = (mw_mirth_type_Type_typeZThen(x4, v13));
	VAL v15 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, v14, x1));
	VAL v16 = MKI64(0LL /* TYPE_ERROR */);
	*x7 = v16;
	*x6 = x2;
	*x5 = v15;
}
static void mw_mirth_type_Type_unifyZ_simpleZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(x4)) {
		case 5LL: { // TVar
			uint64_t v11 = mtp_mirth_type_Type_TVar(x4);
			VAL x12;
			uint64_t x13;
			VAL x14;
			switch (get_data_tag(x3)) {
				case 5LL: { // TVar
					uint64_t v15 = mtp_mirth_type_Type_TVar(x3);
					VAL v16;
					uint64_t v17;
					VAL v18;
					mw_mirth_var_Var_unifyZBang(x1, x2, v11, v15, &v16, &v17, &v18);
					x14 = v18;
					x13 = v17;
					x12 = v16;
				} break;
				default: {
					VAL v19 = mtw_mirth_type_Type_TVar(v11);
					VAL v20;
					uint64_t v21;
					VAL v22;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v19, x3, &v20, &v21, &v22);
					x14 = v22;
					x13 = v21;
					x12 = v20;
				} break;
			}
			x10 = x14;
			x9 = x13;
			x8 = x12;
		} break;
		case 2LL: { // TPrim
			int64_t v23 = mtp_mirth_type_Type_TPrim(x4);
			VAL x24;
			uint64_t x25;
			VAL x26;
			switch (get_data_tag(x3)) {
				case 2LL: { // TPrim
					int64_t v27 = mtp_mirth_type_Type_TPrim(x3);
					VAL v28;
					uint64_t v29;
					VAL v30;
					mw_mirth_type_PrimType_unifyZBang(x1, x2, v23, v27, &v28, &v29, &v30);
					x26 = v30;
					x25 = v29;
					x24 = v28;
				} break;
				default: {
					VAL v31 = mtw_mirth_type_Type_TPrim(v23);
					VAL v32;
					uint64_t v33;
					VAL v34;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v31, x3, &v32, &v33, &v34);
					x26 = v34;
					x25 = v33;
					x24 = v32;
				} break;
			}
			x10 = x26;
			x9 = x25;
			x8 = x24;
		} break;
		case 7LL: { // TData
			uint64_t v35 = mtp_mirth_type_Type_TData(x4);
			VAL x36;
			uint64_t x37;
			VAL x38;
			switch (get_data_tag(x3)) {
				case 7LL: { // TData
					uint64_t v39 = mtp_mirth_type_Type_TData(x3);
					VAL v40;
					uint64_t v41;
					VAL v42;
					mw_mirth_data_Data_unifyZBang(x1, x2, v35, v39, &v40, &v41, &v42);
					x38 = v42;
					x37 = v41;
					x36 = v40;
				} break;
				default: {
					VAL v43 = mtw_mirth_type_Type_TData(v35);
					VAL v44;
					uint64_t v45;
					VAL v46;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v43, x3, &v44, &v45, &v46);
					x38 = v46;
					x37 = v45;
					x36 = v44;
				} break;
			}
			x10 = x38;
			x9 = x37;
			x8 = x36;
		} break;
		case 8LL: { // TDataPartial
			VAL v47 = mtp_mirth_type_Type_TDataPartial(x4);
			VAL x48;
			uint64_t x49;
			VAL x50;
			switch (get_data_tag(x3)) {
				case 8LL: { // TDataPartial
					VAL v51 = mtp_mirth_type_Type_TDataPartial(x3);
					VAL v52;
					uint64_t v53;
					VAL v54;
					mw_mirth_data_DataPartial_unifyZBang(x1, x2, v47, v51, &v52, &v53, &v54);
					x50 = v54;
					x49 = v53;
					x48 = v52;
				} break;
				default: {
					VAL v55 = mtw_mirth_type_Type_TDataPartial(v47);
					VAL v56;
					uint64_t v57;
					VAL v58;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v55, x3, &v56, &v57, &v58);
					x50 = v58;
					x49 = v57;
					x48 = v56;
				} break;
			}
			x10 = x50;
			x9 = x49;
			x8 = x48;
		} break;
		case 6LL: { // TTable
			uint64_t v59 = mtp_mirth_type_Type_TTable(x4);
			VAL x60;
			uint64_t x61;
			VAL x62;
			switch (get_data_tag(x3)) {
				case 6LL: { // TTable
					uint64_t v63 = mtp_mirth_type_Type_TTable(x3);
					VAL v64;
					uint64_t v65;
					VAL v66;
					mw_mirth_table_Table_unifyZBang(x1, x2, v59, v63, &v64, &v65, &v66);
					x62 = v66;
					x61 = v65;
					x60 = v64;
				} break;
				default: {
					VAL v67 = mtw_mirth_type_Type_TTable(v59);
					VAL v68;
					uint64_t v69;
					VAL v70;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v67, x3, &v68, &v69, &v70);
					x62 = v70;
					x61 = v69;
					x60 = v68;
				} break;
			}
			x10 = x62;
			x9 = x61;
			x8 = x60;
		} break;
		case 9LL: { // TTensor
			VAL v71 = mtp_mirth_type_Type_TTensor(x4);
			VAL x72;
			uint64_t x73;
			VAL x74;
			switch (get_data_tag(x3)) {
				case 9LL: { // TTensor
					VAL v75 = mtp_mirth_type_Type_TTensor(x3);
					VAL v76;
					uint64_t v77;
					VAL v78;
					mw_mirth_type_StackType_unifyZBang(x1, x2, v71, v75, &v76, &v77, &v78);
					VAL v79 = mw_mirth_type_StackType_ZToType(v78);
					x74 = v79;
					x73 = v77;
					x72 = v76;
				} break;
				default: {
					VAL v80 = mtw_mirth_type_Type_TTensor(v71);
					VAL v81;
					uint64_t v82;
					VAL v83;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v80, x3, &v81, &v82, &v83);
					x74 = v83;
					x73 = v82;
					x72 = v81;
				} break;
			}
			x10 = x74;
			x9 = x73;
			x8 = x72;
		} break;
		case 10LL: { // TMorphism
			VAL v84 = mtp_mirth_type_Type_TMorphism(x4);
			VAL x85;
			uint64_t x86;
			VAL x87;
			switch (get_data_tag(x3)) {
				case 10LL: { // TMorphism
					VAL v88 = mtp_mirth_type_Type_TMorphism(x3);
					VAL v89;
					uint64_t v90;
					VAL v91;
					mw_mirth_type_ArrowType_unifyZBang(x1, x2, v84, v88, &v89, &v90, &v91);
					VAL v92 = mtw_mirth_type_Type_TMorphism(v91);
					x87 = v92;
					x86 = v90;
					x85 = v89;
				} break;
				default: {
					VAL v93 = mtw_mirth_type_Type_TMorphism(v84);
					VAL v94;
					uint64_t v95;
					VAL v96;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v93, x3, &v94, &v95, &v96);
					x87 = v96;
					x86 = v95;
					x85 = v94;
				} break;
			}
			x10 = x87;
			x9 = x86;
			x8 = x85;
		} break;
		case 11LL: { // TApp
			VAL v97;
			VAL v98;
			mtp_mirth_type_Type_TApp(x4, &v97, &v98);
			VAL x99;
			uint64_t x100;
			VAL x101;
			switch (get_data_tag(x3)) {
				case 11LL: { // TApp
					VAL v102;
					VAL v103;
					mtp_mirth_type_Type_TApp(x3, &v102, &v103);
					VAL v104;
					uint64_t v105;
					VAL v106;
					VAL v107;
					mw_mirth_type_Type_unify2ZBang(x1, x2, v97, v98, v102, v103, &v104, &v105, &v106, &v107);
					VAL v108 = mtw_mirth_type_Type_TApp(v106, v107);
					x101 = v108;
					x100 = v105;
					x99 = v104;
				} break;
				default: {
					VAL v109 = mtw_mirth_type_Type_TApp(v97, v98);
					VAL v110;
					uint64_t v111;
					VAL v112;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v109, x3, &v110, &v111, &v112);
					x101 = v112;
					x100 = v111;
					x99 = v110;
				} break;
			}
			x10 = x101;
			x9 = x100;
			x8 = x99;
		} break;
		case 12LL: { // TMut
			VAL v113 = mtp_mirth_type_Type_TMut(x4);
			VAL x114;
			uint64_t x115;
			VAL x116;
			switch (get_data_tag(x3)) {
				case 12LL: { // TMut
					VAL v117 = mtp_mirth_type_Type_TMut(x3);
					VAL v118;
					uint64_t v119;
					VAL v120;
					mw_mirth_type_Type_unifyZBang(x1, x2, v113, v117, &v118, &v119, &v120);
					VAL v121 = mtw_mirth_type_Type_TMut(v120);
					x116 = v121;
					x115 = v119;
					x114 = v118;
				} break;
				default: {
					VAL v122 = mtw_mirth_type_Type_TMut(v113);
					VAL v123;
					uint64_t v124;
					VAL v125;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v122, x3, &v123, &v124, &v125);
					x116 = v125;
					x115 = v124;
					x114 = v123;
				} break;
			}
			x10 = x116;
			x9 = x115;
			x8 = x114;
		} break;
		default: {
			VAL v126;
			uint64_t v127;
			VAL v128;
			mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, x3, x4, &v126, &v127, &v128);
			x10 = v128;
			x9 = v127;
			x8 = v126;
		} break;
	}
	*x7 = x10;
	*x6 = x9;
	*x5 = x8;
}
static void mw_mirth_type_Type_unifyZ_auxZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(x4)) {
		case 0LL: { // TYPE_ERROR
			VAL v11;
			uint64_t v12;
			VAL v13;
			mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, x3, &v11, &v12, &v13);
			x10 = v13;
			x9 = v12;
			x8 = v11;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			x10 = x3;
			x9 = x2;
			x8 = x1;
		} break;
		case 4LL: { // THole
			uint64_t v14 = mtp_mirth_type_Type_THole(x4);
			VAL v15;
			uint64_t v16;
			VAL v17;
			mw_mirth_type_typeZ_holeZ_unifyZBang(x1, x2, x3, v14, &v15, &v16, &v17);
			x10 = v17;
			x9 = v16;
			x8 = v15;
		} break;
		case 3LL: { // TMeta
			uint64_t v18 = mtp_mirth_type_Type_TMeta(x4);
			VAL x19;
			uint64_t x20;
			VAL x21;
			switch (get_data_tag(x3)) {
				case 0LL: { // TYPE_ERROR
					VAL v22;
					uint64_t v23;
					VAL v24;
					mw_mirth_type_MetaVar_unifyZ_errorZBang(x1, x2, v18, &v22, &v23, &v24);
					x21 = v24;
					x20 = v23;
					x19 = v22;
				} break;
				case 1LL: { // TYPE_DONT_CARE
					VAL v25 = mtw_mirth_type_Type_TMeta(v18);
					x21 = v25;
					x20 = x2;
					x19 = x1;
				} break;
				case 4LL: { // THole
					uint64_t v26 = mtp_mirth_type_Type_THole(x3);
					VAL v27 = mtw_mirth_type_Type_TMeta(v18);
					VAL v28;
					uint64_t v29;
					VAL v30;
					mw_mirth_type_typeZ_holeZ_unifyZBang(x1, x2, v27, v26, &v28, &v29, &v30);
					x21 = v30;
					x20 = v29;
					x19 = v28;
				} break;
				case 3LL: { // TMeta
					uint64_t v31 = mtp_mirth_type_Type_TMeta(x3);
					VAL v32 = mtw_mirth_type_Type_TMeta(v18);
					VAL v33;
					uint64_t v34;
					VAL v35;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v32, v31, &v33, &v34, &v35);
					x21 = v35;
					x20 = v34;
					x19 = v33;
				} break;
				case 13LL: { // TValue
					VAL v36 = mtp_mirth_type_Type_TValue(x3);
					VAL v37 = mtw_mirth_type_Type_TMeta(v18);
					VAL v38;
					uint64_t v39;
					VAL v40;
					mw_mirth_type_Value_unifyZ_typeZBang(x1, x2, v37, v36, &v38, &v39, &v40);
					x21 = v40;
					x20 = v39;
					x19 = v38;
				} break;
				default: {
					VAL v41;
					uint64_t v42;
					VAL v43;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, x3, v18, &v41, &v42, &v43);
					x21 = v43;
					x20 = v42;
					x19 = v41;
				} break;
			}
			x10 = x21;
			x9 = x20;
			x8 = x19;
		} break;
		case 13LL: { // TValue
			VAL v44 = mtp_mirth_type_Type_TValue(x4);
			VAL x45;
			uint64_t x46;
			VAL x47;
			switch (get_data_tag(x3)) {
				case 0LL: { // TYPE_ERROR
					VAL v48;
					uint64_t v49;
					VAL v50;
					mw_mirth_type_Value_unifyZ_errorZBang(x1, x2, v44, &v48, &v49, &v50);
					x47 = v50;
					x46 = v49;
					x45 = v48;
				} break;
				case 1LL: { // TYPE_DONT_CARE
					VAL v51 = mtw_mirth_type_Type_TValue(v44);
					x47 = v51;
					x46 = x2;
					x45 = x1;
				} break;
				case 4LL: { // THole
					uint64_t v52 = mtp_mirth_type_Type_THole(x3);
					VAL v53 = mtw_mirth_type_Type_TValue(v44);
					VAL v54;
					uint64_t v55;
					VAL v56;
					mw_mirth_type_typeZ_holeZ_unifyZBang(x1, x2, v53, v52, &v54, &v55, &v56);
					x47 = v56;
					x46 = v55;
					x45 = v54;
				} break;
				case 3LL: { // TMeta
					uint64_t v57 = mtp_mirth_type_Type_TMeta(x3);
					VAL v58 = mtw_mirth_type_Type_TValue(v44);
					VAL v59;
					uint64_t v60;
					VAL v61;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v58, v57, &v59, &v60, &v61);
					x47 = v61;
					x46 = v60;
					x45 = v59;
				} break;
				case 13LL: { // TValue
					VAL v62 = mtp_mirth_type_Type_TValue(x3);
					VAL v63;
					uint64_t v64;
					VAL v65;
					mw_mirth_type_Value_unifyZBang(x1, x2, v44, v62, &v63, &v64, &v65);
					x47 = v65;
					x46 = v64;
					x45 = v63;
				} break;
				default: {
					VAL v66;
					uint64_t v67;
					VAL v68;
					mw_mirth_type_Value_unifyZ_typeZBang(x1, x2, x3, v44, &v66, &v67, &v68);
					x47 = v68;
					x46 = v67;
					x45 = v66;
				} break;
			}
			x10 = x47;
			x9 = x46;
			x8 = x45;
		} break;
		default: {
			VAL x69;
			uint64_t x70;
			VAL x71;
			switch (get_data_tag(x3)) {
				case 0LL: { // TYPE_ERROR
					VAL v72;
					uint64_t v73;
					VAL v74;
					mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, x4, &v72, &v73, &v74);
					x71 = v74;
					x70 = v73;
					x69 = v72;
				} break;
				case 1LL: { // TYPE_DONT_CARE
					x71 = x4;
					x70 = x2;
					x69 = x1;
				} break;
				case 4LL: { // THole
					uint64_t v75 = mtp_mirth_type_Type_THole(x3);
					VAL v76;
					uint64_t v77;
					VAL v78;
					mw_mirth_type_typeZ_holeZ_unifyZBang(x1, x2, x4, v75, &v76, &v77, &v78);
					x71 = v78;
					x70 = v77;
					x69 = v76;
				} break;
				case 3LL: { // TMeta
					uint64_t v79 = mtp_mirth_type_Type_TMeta(x3);
					VAL v80;
					uint64_t v81;
					VAL v82;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, x4, v79, &v80, &v81, &v82);
					x71 = v82;
					x70 = v81;
					x69 = v80;
				} break;
				case 13LL: { // TValue
					VAL v83 = mtp_mirth_type_Type_TValue(x3);
					VAL v84;
					uint64_t v85;
					VAL v86;
					mw_mirth_type_Value_unifyZ_typeZBang(x1, x2, x4, v83, &v84, &v85, &v86);
					x71 = v86;
					x70 = v85;
					x69 = v84;
				} break;
				default: {
					VAL v87;
					uint64_t v88;
					VAL v89;
					mw_mirth_type_Type_unifyZ_simpleZBang(x1, x2, x4, x3, &v87, &v88, &v89);
					x71 = v89;
					x70 = v88;
					x69 = v87;
				} break;
			}
			x10 = x71;
			x9 = x70;
			x8 = x69;
		} break;
	}
	*x7 = x10;
	*x6 = x9;
	*x5 = x8;
}
static void mw_mirth_type_Type_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_Type_expand(x3);
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 0LL: { // TYPE_ERROR
			VAL v11 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v11;
			x9 = x2;
			x8 = x1;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			VAL v12 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v12;
			x9 = x2;
			x8 = x1;
		} break;
		case 4LL: { // THole
			uint64_t v13 = mtp_mirth_type_Type_THole(v7);
			VAL v14 = MKI64(0LL /* TYPE_ERROR */);
			VAL v15;
			uint64_t v16;
			VAL v17;
			mw_mirth_type_typeZ_holeZ_unifyZBang(x1, x2, v14, v13, &v15, &v16, &v17);
			x10 = v17;
			x9 = v16;
			x8 = v15;
		} break;
		case 3LL: { // TMeta
			uint64_t v18 = mtp_mirth_type_Type_TMeta(v7);
			VAL v19;
			uint64_t v20;
			VAL v21;
			mw_mirth_type_MetaVar_unifyZ_errorZBang(x1, x2, v18, &v19, &v20, &v21);
			x10 = v21;
			x9 = v20;
			x8 = v19;
		} break;
		case 13LL: { // TValue
			VAL v22 = mtp_mirth_type_Type_TValue(v7);
			VAL v23;
			uint64_t v24;
			VAL v25;
			mw_mirth_type_Value_unifyZ_errorZBang(x1, x2, v22, &v23, &v24, &v25);
			x10 = v25;
			x9 = v24;
			x8 = v23;
		} break;
		case 5LL: { // TVar
			uint64_t v26 = mtp_mirth_type_Type_TVar(v7);
			VAL v27 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v27;
			x9 = x2;
			x8 = x1;
		} break;
		case 2LL: { // TPrim
			int64_t v28 = mtp_mirth_type_Type_TPrim(v7);
			VAL v29 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v29;
			x9 = x2;
			x8 = x1;
		} break;
		case 7LL: { // TData
			uint64_t v30 = mtp_mirth_type_Type_TData(v7);
			VAL v31 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v31;
			x9 = x2;
			x8 = x1;
		} break;
		case 8LL: { // TDataPartial
			VAL v32 = mtp_mirth_type_Type_TDataPartial(v7);
			decref(v32);
			VAL v33 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v33;
			x9 = x2;
			x8 = x1;
		} break;
		case 6LL: { // TTable
			uint64_t v34 = mtp_mirth_type_Type_TTable(v7);
			VAL v35 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v35;
			x9 = x2;
			x8 = x1;
		} break;
		case 9LL: { // TTensor
			VAL v36 = mtp_mirth_type_Type_TTensor(v7);
			VAL v37;
			uint64_t v38;
			VAL v39;
			mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v36, &v37, &v38, &v39);
			decref(v39);
			VAL v40 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v40;
			x9 = v38;
			x8 = v37;
		} break;
		case 10LL: { // TMorphism
			VAL v41 = mtp_mirth_type_Type_TMorphism(v7);
			VAL v42;
			uint64_t v43;
			VAL v44;
			mw_mirth_type_ArrowType_unifyZ_errorZBang(x1, x2, v41, &v42, &v43, &v44);
			decref(v44);
			VAL v45 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v45;
			x9 = v43;
			x8 = v42;
		} break;
		case 11LL: { // TApp
			VAL v46;
			VAL v47;
			mtp_mirth_type_Type_TApp(v7, &v46, &v47);
			VAL v48;
			uint64_t v49;
			VAL v50;
			mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, v46, &v48, &v49, &v50);
			decref(v50);
			VAL v51;
			uint64_t v52;
			VAL v53;
			mw_mirth_type_Type_unifyZ_errorZBang(v48, v49, v47, &v51, &v52, &v53);
			decref(v53);
			VAL v54 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v54;
			x9 = v52;
			x8 = v51;
		} break;
		case 12LL: { // TMut
			VAL v55 = mtp_mirth_type_Type_TMut(v7);
			VAL v56;
			uint64_t v57;
			VAL v58;
			mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, v55, &v56, &v57, &v58);
			decref(v58);
			VAL v59 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v59;
			x9 = v57;
			x8 = v56;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_type_Type_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_type_Type_expand(x3);
	VAL v9 = mw_mirth_type_Type_expand(x4);
	VAL v10;
	uint64_t v11;
	VAL v12;
	mw_mirth_type_Type_unifyZ_auxZBang(x1, x2, v8, v9, &v10, &v11, &v12);
	*x7 = v12;
	*x6 = v11;
	*x5 = v10;
}
static void mw_mirth_type_Value_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(x3)) {
		case 0LL: { // VALUE_INT
			int64_t v11 = mtp_mirth_type_Value_VALUEz_INT(x3);
			VAL x12;
			uint64_t x13;
			VAL x14;
			switch (get_data_tag(x4)) {
				case 0LL: { // VALUE_INT
					int64_t v15 = mtp_mirth_type_Value_VALUEz_INT(x4);
					bool v16 = (v11 == v15);
					VAL x17;
					uint64_t x18;
					VAL x19;
					if (v16) {
						VAL v20 = mtw_mirth_type_Value_VALUEz_INT(v11);
						VAL v21 = mtw_mirth_type_Type_TValue(v20);
						x19 = v21;
						x18 = x2;
						x17 = x1;
					} else {
						VAL v22 = mw_mirth_type_TYPEz_INT();
						x19 = v22;
						x18 = x2;
						x17 = x1;
					}
					x14 = x19;
					x13 = x18;
					x12 = x17;
				} break;
				case 2LL: { // VALUE_STR
					VAL v23 = mtp_mirth_type_Value_VALUEz_STR(x4);
					decref(v23);
					STR* v24;
					STRLIT(v24, "Can't unify int value with string value.", 40);
					VAL v25 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v24), x1));
					VAL v26 = MKI64(0LL /* TYPE_ERROR */);
					x14 = v26;
					x13 = x2;
					x12 = v25;
				} break;
				case 1LL: { // VALUE_F64
					double v27 = mtp_mirth_type_Value_VALUEz_F64(x4);
					STR* v28;
					STRLIT(v28, "Can't unify int value with float value.", 39);
					VAL v29 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v28), x1));
					VAL v30 = MKI64(0LL /* TYPE_ERROR */);
					x14 = v30;
					x13 = x2;
					x12 = v29;
				} break;
				case 3LL: { // VALUE_BLOCK
					uint64_t v31 = mtp_mirth_type_Value_VALUEz_BLOCK(x4);
					STR* v32;
					STRLIT(v32, "Can't unify int value with block.", 33);
					VAL v33 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v32), x1));
					VAL v34 = MKI64(0LL /* TYPE_ERROR */);
					x14 = v34;
					x13 = x2;
					x12 = v33;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x10 = x14;
			x9 = x13;
			x8 = x12;
		} break;
		case 2LL: { // VALUE_STR
			VAL v35 = mtp_mirth_type_Value_VALUEz_STR(x3);
			VAL x36;
			uint64_t x37;
			VAL x38;
			switch (get_data_tag(x4)) {
				case 2LL: { // VALUE_STR
					VAL v39 = mtp_mirth_type_Value_VALUEz_STR(x4);
					incref(v35);
					incref(v39);
					bool v40 = (str_cmp(VSTR(v35), VSTR(v39)) == 0);
					VAL x41;
					uint64_t x42;
					VAL x43;
					if (v40) {
						decref(v39);
						VAL v44 = mtw_mirth_type_Value_VALUEz_STR(v35);
						VAL v45 = mtw_mirth_type_Type_TValue(v44);
						x43 = v45;
						x42 = x2;
						x41 = x1;
					} else {
						decref(v39);
						decref(v35);
						VAL v46 = mw_mirth_type_TYPEz_STR();
						x43 = v46;
						x42 = x2;
						x41 = x1;
					}
					x38 = x43;
					x37 = x42;
					x36 = x41;
				} break;
				case 0LL: { // VALUE_INT
					int64_t v47 = mtp_mirth_type_Value_VALUEz_INT(x4);
					decref(v35);
					STR* v48;
					STRLIT(v48, "Can't unify string value with int value.", 40);
					VAL v49 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v48), x1));
					VAL v50 = MKI64(0LL /* TYPE_ERROR */);
					x38 = v50;
					x37 = x2;
					x36 = v49;
				} break;
				case 1LL: { // VALUE_F64
					double v51 = mtp_mirth_type_Value_VALUEz_F64(x4);
					decref(v35);
					STR* v52;
					STRLIT(v52, "Can't unify string value with float value.", 42);
					VAL v53 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v52), x1));
					VAL v54 = MKI64(0LL /* TYPE_ERROR */);
					x38 = v54;
					x37 = x2;
					x36 = v53;
				} break;
				case 3LL: { // VALUE_BLOCK
					uint64_t v55 = mtp_mirth_type_Value_VALUEz_BLOCK(x4);
					decref(v35);
					STR* v56;
					STRLIT(v56, "Can't unify string value with block.", 36);
					VAL v57 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v56), x1));
					VAL v58 = MKI64(0LL /* TYPE_ERROR */);
					x38 = v58;
					x37 = x2;
					x36 = v57;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x10 = x38;
			x9 = x37;
			x8 = x36;
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v59 = mtp_mirth_type_Value_VALUEz_BLOCK(x3);
			VAL x60;
			uint64_t x61;
			VAL x62;
			switch (get_data_tag(x4)) {
				case 3LL: { // VALUE_BLOCK
					uint64_t v63 = mtp_mirth_type_Value_VALUEz_BLOCK(x4);
					int64_t v64 = mw_mirth_arrow_Block_ZEqualZEqual(v59, v63);
					VAL x65;
					uint64_t x66;
					VAL x67;
					if (((bool)v64)) {
						VAL v68 = mtw_mirth_type_Value_VALUEz_BLOCK(v59);
						VAL v69 = mtw_mirth_type_Type_TValue(v68);
						x67 = v69;
						x66 = x2;
						x65 = x1;
					} else {
						VAL v70;
						VAL v71;
						mw_mirth_arrow_Block_arrow(x1, v63, &v70, &v71);
						VAL v72 = mw_mirth_arrow_Arrow_type(v71);
						VAL v73;
						uint64_t v74;
						VAL v75;
						mw_mirth_arrow_blockZ_unifyZ_typeZBang(v70, x2, v59, v72, &v73, &v74, &v75);
						VAL v76 = mw_mirth_type_ArrowType_ZToType(v75);
						x67 = v76;
						x66 = v74;
						x65 = v73;
					}
					x62 = x67;
					x61 = x66;
					x60 = x65;
				} break;
				case 0LL: { // VALUE_INT
					int64_t v77 = mtp_mirth_type_Value_VALUEz_INT(x4);
					STR* v78;
					STRLIT(v78, "Can't unify block with int value.", 33);
					VAL v79 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v78), x1));
					VAL v80 = MKI64(0LL /* TYPE_ERROR */);
					x62 = v80;
					x61 = x2;
					x60 = v79;
				} break;
				case 1LL: { // VALUE_F64
					double v81 = mtp_mirth_type_Value_VALUEz_F64(x4);
					STR* v82;
					STRLIT(v82, "Can't unify block with float value.", 35);
					VAL v83 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v82), x1));
					VAL v84 = MKI64(0LL /* TYPE_ERROR */);
					x62 = v84;
					x61 = x2;
					x60 = v83;
				} break;
				case 2LL: { // VALUE_STR
					VAL v85 = mtp_mirth_type_Value_VALUEz_STR(x4);
					decref(v85);
					STR* v86;
					STRLIT(v86, "Can't unify block with string value.", 36);
					VAL v87 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v86), x1));
					VAL v88 = MKI64(0LL /* TYPE_ERROR */);
					x62 = v88;
					x61 = x2;
					x60 = v87;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x10 = x62;
			x9 = x61;
			x8 = x60;
		} break;
		case 1LL: { // VALUE_F64
			double v89 = mtp_mirth_type_Value_VALUEz_F64(x3);
			VAL x90;
			uint64_t x91;
			VAL x92;
			switch (get_data_tag(x4)) {
				case 1LL: { // VALUE_F64
					double v93 = mtp_mirth_type_Value_VALUEz_F64(x4);
					bool v94 = (v89 == v93);
					VAL x95;
					uint64_t x96;
					VAL x97;
					if (v94) {
						VAL v98 = mtw_mirth_type_Value_VALUEz_F64(v89);
						VAL v99 = mtw_mirth_type_Type_TValue(v98);
						x97 = v99;
						x96 = x2;
						x95 = x1;
					} else {
						VAL v100 = mw_mirth_type_TYPEz_F64();
						x97 = v100;
						x96 = x2;
						x95 = x1;
					}
					x92 = x97;
					x91 = x96;
					x90 = x95;
				} break;
				case 0LL: { // VALUE_INT
					int64_t v101 = mtp_mirth_type_Value_VALUEz_INT(x4);
					STR* v102;
					STRLIT(v102, "Can't unify float value with int value.", 39);
					VAL v103 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v102), x1));
					VAL v104 = MKI64(0LL /* TYPE_ERROR */);
					x92 = v104;
					x91 = x2;
					x90 = v103;
				} break;
				case 3LL: { // VALUE_BLOCK
					uint64_t v105 = mtp_mirth_type_Value_VALUEz_BLOCK(x4);
					STR* v106;
					STRLIT(v106, "Can't unify float value with block.", 35);
					VAL v107 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v106), x1));
					VAL v108 = MKI64(0LL /* TYPE_ERROR */);
					x92 = v108;
					x91 = x2;
					x90 = v107;
				} break;
				case 2LL: { // VALUE_STR
					VAL v109 = mtp_mirth_type_Value_VALUEz_STR(x4);
					decref(v109);
					STR* v110;
					STRLIT(v110, "Can't unify float value with string value.", 42);
					VAL v111 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x2, MKSTR(v110), x1));
					VAL v112 = MKI64(0LL /* TYPE_ERROR */);
					x92 = v112;
					x91 = x2;
					x90 = v111;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x10 = x92;
			x9 = x91;
			x8 = x90;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x10;
	*x6 = x9;
	*x5 = x8;
}
static void mw_mirth_type_Value_unifyZ_typeZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(x4)) {
		case 0LL: { // VALUE_INT
			int64_t v11 = mtp_mirth_type_Value_VALUEz_INT(x4);
			VAL v12 = mw_mirth_type_TYPEz_INT();
			VAL v13;
			uint64_t v14;
			VAL v15;
			mw_mirth_type_Type_unifyZBang(x1, x2, x3, v12, &v13, &v14, &v15);
			x10 = v15;
			x9 = v14;
			x8 = v13;
		} break;
		case 2LL: { // VALUE_STR
			VAL v16 = mtp_mirth_type_Value_VALUEz_STR(x4);
			decref(v16);
			VAL v17 = mw_mirth_type_TYPEz_STR();
			VAL v18;
			uint64_t v19;
			VAL v20;
			mw_mirth_type_Type_unifyZBang(x1, x2, x3, v17, &v18, &v19, &v20);
			x10 = v20;
			x9 = v19;
			x8 = v18;
		} break;
		case 1LL: { // VALUE_F64
			double v21 = mtp_mirth_type_Value_VALUEz_F64(x4);
			VAL v22 = mw_mirth_type_TYPEz_F64();
			VAL v23;
			uint64_t v24;
			VAL v25;
			mw_mirth_type_Type_unifyZBang(x1, x2, x3, v22, &v23, &v24, &v25);
			x10 = v25;
			x9 = v24;
			x8 = v23;
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v26 = mtp_mirth_type_Value_VALUEz_BLOCK(x4);
			VAL v27;
			uint64_t v28;
			VAL v29;
			mw_mirth_type_Type_unifyZ_blockZBang(x1, x2, v26, x3, &v27, &v28, &v29);
			x10 = v29;
			x9 = v28;
			x8 = v27;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x10;
	*x6 = x9;
	*x5 = x8;
}
static void mw_mirth_type_Value_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6) {
	VAL x7;
	uint64_t x8;
	VAL x9;
	switch (get_data_tag(x3)) {
		case 0LL: { // VALUE_INT
			int64_t v10 = mtp_mirth_type_Value_VALUEz_INT(x3);
			VAL v11 = MKI64(0LL /* TYPE_ERROR */);
			x9 = v11;
			x8 = x2;
			x7 = x1;
		} break;
		case 2LL: { // VALUE_STR
			VAL v12 = mtp_mirth_type_Value_VALUEz_STR(x3);
			decref(v12);
			VAL v13 = MKI64(0LL /* TYPE_ERROR */);
			x9 = v13;
			x8 = x2;
			x7 = x1;
		} break;
		case 1LL: { // VALUE_F64
			double v14 = mtp_mirth_type_Value_VALUEz_F64(x3);
			VAL v15 = MKI64(0LL /* TYPE_ERROR */);
			x9 = v15;
			x8 = x2;
			x7 = x1;
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v16 = mtp_mirth_type_Value_VALUEz_BLOCK(x3);
			VAL v17 = MKI64(0LL /* TYPE_ERROR */);
			VAL v18;
			uint64_t v19;
			VAL v20;
			mw_mirth_type_Type_unifyZ_blockZBang(x1, x2, v16, v17, &v18, &v19, &v20);
			x9 = v20;
			x8 = v19;
			x7 = v18;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x9;
	*x5 = x8;
	*x4 = x7;
}
static void mw_mirth_type_Type_unifyZ_blockZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_type_Type_expand(x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	switch (get_data_tag(v8)) {
		case 0LL: { // TYPE_ERROR
			VAL v12 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v13 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v14 = mw_mirth_type_TZ_ZTo(v12, v13);
			VAL v15;
			uint64_t v16;
			VAL v17;
			mw_mirth_arrow_blockZ_unifyZ_typeZBang(x1, x2, x3, v14, &v15, &v16, &v17);
			decref(v17);
			VAL v18 = MKI64(0LL /* TYPE_ERROR */);
			x11 = v18;
			x10 = v16;
			x9 = v15;
		} break;
		case 3LL: { // TMeta
			uint64_t v19 = mtp_mirth_type_Type_TMeta(v8);
			VAL v20 = mw_mirth_arrow_Block_type(x3);
			VAL v21 = mw_mirth_type_ArrowType_ZToType(v20);
			VAL v22;
			uint64_t v23;
			VAL v24;
			mw_mirth_type_MetaVar_unifyZBang(x1, x2, v21, v19, &v22, &v23, &v24);
			decref(v24);
			VAL v25;
			VAL v26;
			mw_mirth_arrow_Block_arrow(v22, x3, &v25, &v26);
			VAL v27 = mw_mirth_arrow_Arrow_type(v26);
			VAL v28 = mw_mirth_type_ArrowType_ZToType(v27);
			x11 = v28;
			x10 = v23;
			x9 = v25;
		} break;
		case 10LL: { // TMorphism
			VAL v29 = mtp_mirth_type_Type_TMorphism(v8);
			VAL v30;
			uint64_t v31;
			VAL v32;
			mw_mirth_arrow_blockZ_unifyZ_typeZBang(x1, x2, x3, v29, &v30, &v31, &v32);
			VAL v33 = mw_mirth_type_ArrowType_ZToType(v32);
			x11 = v33;
			x10 = v31;
			x9 = v30;
		} break;
		default: {
			VAL v34 = mw_mirth_arrow_Block_type(x3);
			VAL v35 = mw_mirth_type_ArrowType_ZToType(v34);
			VAL v36;
			uint64_t v37;
			VAL v38;
			mw_mirth_type_Type_unifyZBang(x1, x2, v35, v8, &v36, &v37, &v38);
			x11 = v38;
			x10 = v37;
			x9 = v36;
		} break;
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_type_Type_unify2ZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, VAL x6, VAL *x7, uint64_t *x8, VAL *x9, VAL *x10) {
	VAL v11;
	uint64_t v12;
	VAL v13;
	mw_mirth_type_Type_unifyZBang(x1, x2, x3, x5, &v11, &v12, &v13);
	VAL v14;
	uint64_t v15;
	VAL v16;
	mw_mirth_type_Type_unifyZBang(v11, v12, x4, x6, &v14, &v15, &v16);
	*x10 = v16;
	*x9 = v13;
	*x8 = v15;
	*x7 = v14;
}
static void mw_mirth_type_PrimType_unifyZBang (VAL x1, uint64_t x2, int64_t x3, int64_t x4, VAL *x5, uint64_t *x6, VAL *x7) {
	int64_t v8 = mw_mirth_type_PrimType_ZEqualZEqual(x3, x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	if (((bool)v8)) {
		VAL v12 = mtw_mirth_type_Type_TPrim(x3);
		x11 = v12;
		x10 = x2;
		x9 = x1;
	} else {
		VAL v13 = mtw_mirth_type_Type_TPrim(x3);
		VAL v14 = mtw_mirth_type_Type_TPrim(x4);
		VAL v15;
		uint64_t v16;
		VAL v17;
		mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v13, v14, &v15, &v16, &v17);
		x11 = v17;
		x10 = v16;
		x9 = v15;
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_data_Data_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7) {
	int64_t v8 = mw_mirth_data_Data_ZEqualZEqual(x3, x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	if (((bool)v8)) {
		VAL v12 = mtw_mirth_type_Type_TData(x3);
		x11 = v12;
		x10 = x2;
		x9 = x1;
	} else {
		VAL v13 = mtw_mirth_type_Type_TData(x3);
		VAL v14 = mtw_mirth_type_Type_TData(x4);
		VAL v15;
		uint64_t v16;
		VAL v17;
		mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v13, v14, &v15, &v16, &v17);
		x11 = v17;
		x10 = v16;
		x9 = v15;
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_data_DataPartial_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	incref(x3);
	incref(x4);
	int64_t v8 = mw_mirth_data_DataPartial_ZEqualZEqual(x3, x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	if (((bool)v8)) {
		decref(x4);
		VAL v12 = mtw_mirth_type_Type_TDataPartial(x3);
		x11 = v12;
		x10 = x2;
		x9 = x1;
	} else {
		VAL v13 = mtw_mirth_type_Type_TDataPartial(x3);
		VAL v14 = mtw_mirth_type_Type_TDataPartial(x4);
		VAL v15;
		uint64_t v16;
		VAL v17;
		mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v13, v14, &v15, &v16, &v17);
		x11 = v17;
		x10 = v16;
		x9 = v15;
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_table_Table_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7) {
	int64_t v8 = mw_mirth_table_Table_ZEqualZEqual(x3, x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	if (((bool)v8)) {
		VAL v12 = mtw_mirth_type_Type_TTable(x3);
		x11 = v12;
		x10 = x2;
		x9 = x1;
	} else {
		VAL v13 = mtw_mirth_type_Type_TTable(x3);
		VAL v14 = mtw_mirth_type_Type_TTable(x4);
		VAL v15;
		uint64_t v16;
		VAL v17;
		mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v13, v14, &v15, &v16, &v17);
		x11 = v17;
		x10 = v16;
		x9 = v15;
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static int64_t mw_mirth_type_Type_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 3LL: { // TMeta
			uint64_t v4 = mtp_mirth_type_Type_TMeta(x2);
			int64_t v5 = mw_mirth_type_MetaVar_hasZ_metaZAsk(x1, v4);
			x3 = v5;
		} break;
		case 0LL: { // TYPE_ERROR
			int64_t v6 = 0LL /* False */;
			x3 = v6;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v7 = 0LL /* False */;
			x3 = v7;
		} break;
		case 2LL: { // TPrim
			int64_t v8 = mtp_mirth_type_Type_TPrim(x2);
			int64_t v9 = 0LL /* False */;
			x3 = v9;
		} break;
		case 5LL: { // TVar
			uint64_t v10 = mtp_mirth_type_Type_TVar(x2);
			int64_t v11 = 0LL /* False */;
			x3 = v11;
		} break;
		case 4LL: { // THole
			uint64_t v12 = mtp_mirth_type_Type_THole(x2);
			int64_t v13 = 0LL /* False */;
			x3 = v13;
		} break;
		case 9LL: { // TTensor
			VAL v14 = mtp_mirth_type_Type_TTensor(x2);
			int64_t v15 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v14);
			x3 = v15;
		} break;
		case 10LL: { // TMorphism
			VAL v16 = mtp_mirth_type_Type_TMorphism(x2);
			int64_t v17 = mw_mirth_type_ArrowType_hasZ_metaZAsk(x1, v16);
			x3 = v17;
		} break;
		case 11LL: { // TApp
			VAL v18;
			VAL v19;
			mtp_mirth_type_Type_TApp(x2, &v18, &v19);
			int64_t v20 = mw_mirth_type_Type_hasZ_meta2ZAsk(x1, v18, v19);
			x3 = v20;
		} break;
		case 7LL: { // TData
			uint64_t v21 = mtp_mirth_type_Type_TData(x2);
			int64_t v22 = 0LL /* False */;
			x3 = v22;
		} break;
		case 8LL: { // TDataPartial
			VAL v23 = mtp_mirth_type_Type_TDataPartial(x2);
			decref(v23);
			int64_t v24 = 0LL /* False */;
			x3 = v24;
		} break;
		case 6LL: { // TTable
			uint64_t v25 = mtp_mirth_type_Type_TTable(x2);
			int64_t v26 = 0LL /* False */;
			x3 = v26;
		} break;
		case 13LL: { // TValue
			VAL v27 = mtp_mirth_type_Type_TValue(x2);
			int64_t v28 = mw_mirth_type_Value_hasZ_metaZAsk(x1, v27);
			x3 = v28;
		} break;
		case 12LL: { // TMut
			VAL v29 = mtp_mirth_type_Type_TMut(x2);
			int64_t v30 = mw_mirth_type_Type_hasZ_metaZAsk(x1, v29);
			x3 = v30;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_type_Type_hasZ_meta2ZAsk (uint64_t x1, VAL x2, VAL x3) {
	int64_t v4 = mw_mirth_type_Type_hasZ_metaZAsk(x1, x3);
	int64_t x5;
	if (((bool)v4)) {
		decref(x2);
		int64_t v6 = 1LL /* True */;
		x5 = v6;
	} else {
		int64_t v7 = mw_mirth_type_Type_hasZ_metaZAsk(x1, x2);
		x5 = v7;
	}
	return x5;
}
static int64_t mw_mirth_type_Value_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_type_Value_type(x2);
	int64_t v4 = mw_mirth_type_Type_hasZ_metaZAsk(x1, v3);
	return v4;
}
static VAL mw_mirth_type_Type_typeZThen (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			STR* v4;
			STRLIT(v4, "<ERROR>", 7);
			VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), x2));
			x3 = v5;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			STR* v6;
			STRLIT(v6, "_", 1);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), x2));
			x3 = v7;
		} break;
		case 2LL: { // TPrim
			int64_t v8 = mtp_mirth_type_Type_TPrim(x1);
			VAL v9 = (mw_mirth_type_PrimType_typeZThen(x2, v8));
			x3 = v9;
		} break;
		case 5LL: { // TVar
			uint64_t v10 = mtp_mirth_type_Type_TVar(x1);
			VAL v11 = (mw_mirth_var_Var_typeZThen(x2, v10));
			x3 = v11;
		} break;
		case 3LL: { // TMeta
			uint64_t v12 = mtp_mirth_type_Type_TMeta(x1);
			VAL v13 = (mw_mirth_type_MetaVar_typeZThen(x2, v12));
			x3 = v13;
		} break;
		case 9LL: { // TTensor
			VAL v14 = mtp_mirth_type_Type_TTensor(x1);
			STR* v15;
			STRLIT(v15, "[", 1);
			VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v15), x2));
			VAL v17 = (mw_mirth_type_StackType_stackZThen(v16, v14));
			STR* v18;
			STRLIT(v18, "]", 1);
			VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), v17));
			x3 = v19;
		} break;
		case 10LL: { // TMorphism
			VAL v20 = mtp_mirth_type_Type_TMorphism(x1);
			STR* v21;
			STRLIT(v21, "[", 1);
			VAL v22 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v21), x2));
			VAL v23 = (mw_mirth_type_ArrowType_sigZThen(v22, v20));
			STR* v24;
			STRLIT(v24, "]", 1);
			VAL v25 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), v23));
			x3 = v25;
		} break;
		case 7LL: { // TData
			uint64_t v26 = mtp_mirth_type_Type_TData(x1);
			uint64_t v27 = mw_mirth_data_Data_name(v26);
			VAL v28 = mw_mirth_name_Name_ZToStr(v27);
			VAL v29 = (mw_std_str_ZPlusStr_pushZ_strZBang(v28, x2));
			x3 = v29;
		} break;
		case 8LL: { // TDataPartial
			VAL v30 = mtp_mirth_type_Type_TDataPartial(x1);
			incref(v30);
			uint64_t v31 = VU64(VTUP(v30)->cells[1]);
			decref(v30);
			uint64_t v32 = mw_mirth_data_Data_name(v31);
			VAL v33 = mw_mirth_name_Name_ZToStr(v32);
			VAL v34 = (mw_std_str_ZPlusStr_pushZ_strZBang(v33, x2));
			STR* v35;
			STRLIT(v35, "/", 1);
			VAL v36 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v35), v34));
			uint64_t v37 = VU64(VTUP(v30)->cells[2]);
			decref(v30);
			uint64_t v38 = mw_mirth_label_Label_name(v37);
			VAL v39 = mw_mirth_name_Name_ZToStr(v38);
			VAL v40 = (mw_std_str_ZPlusStr_pushZ_strZBang(v39, v36));
			x3 = v40;
		} break;
		case 6LL: { // TTable
			uint64_t v41 = mtp_mirth_type_Type_TTable(x1);
			uint64_t v42 = mw_mirth_table_Table_name(v41);
			VAL v43 = mw_mirth_name_Name_ZToStr(v42);
			VAL v44 = (mw_std_str_ZPlusStr_pushZ_strZBang(v43, x2));
			x3 = v44;
		} break;
		case 4LL: { // THole
			uint64_t v45 = mtp_mirth_type_Type_THole(x1);
			VAL v46 = mw_mirth_name_Name_ZToStr(v45);
			VAL v47 = (mw_std_str_ZPlusStr_pushZ_strZBang(v46, x2));
			x3 = v47;
		} break;
		case 11LL: { // TApp
			VAL v48;
			VAL v49;
			mtp_mirth_type_Type_TApp(x1, &v48, &v49);
			VAL v50 = (mw_mirth_type_Type_appZ_typeZThenZThen(x2, v48, v49));
			x3 = v50;
		} break;
		case 13LL: { // TValue
			VAL v51 = mtp_mirth_type_Type_TValue(x1);
			VAL v52 = mw_mirth_type_Value_type(v51);
			VAL v53 = (mw_mirth_type_Type_typeZThen(v52, x2));
			x3 = v53;
		} break;
		case 12LL: { // TMut
			VAL v54 = mtp_mirth_type_Type_TMut(x1);
			STR* v55;
			STRLIT(v55, "Mut(", 4);
			VAL v56 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v55), x2));
			VAL v57 = (mw_mirth_type_Type_typeZThen(v54, v56));
			STR* v58;
			STRLIT(v58, ")", 1);
			VAL v59 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v58), v57));
			x3 = v59;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_Value_type (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // VALUE_INT
			int64_t v3 = mtp_mirth_type_Value_VALUEz_INT(x1);
			int64_t v4 = 3LL /* PRIM_TYPE_INT */;
			VAL v5 = mtw_mirth_type_Type_TPrim(v4);
			x2 = v5;
		} break;
		case 1LL: { // VALUE_F64
			double v6 = mtp_mirth_type_Value_VALUEz_F64(x1);
			int64_t v7 = 5LL /* PRIM_TYPE_F64 */;
			VAL v8 = mtw_mirth_type_Type_TPrim(v7);
			x2 = v8;
		} break;
		case 2LL: { // VALUE_STR
			VAL v9 = mtp_mirth_type_Value_VALUEz_STR(x1);
			decref(v9);
			int64_t v10 = 7LL /* PRIM_TYPE_STR */;
			VAL v11 = mtw_mirth_type_Type_TPrim(v10);
			x2 = v11;
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v12 = mtp_mirth_type_Value_VALUEz_BLOCK(x1);
			VAL v13 = mw_mirth_arrow_Block_type(v12);
			VAL v14 = mw_mirth_type_ArrowType_ZToType(v13);
			x2 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_type_PrimType_typeZThen (VAL x1, int64_t x2) {
	VAL x3;
	VAL x4;
	switch (x2) {
		case 0LL: { // PRIM_TYPE_TYPE
			STR* v5;
			STRLIT(v5, "<TYPE>", 6);
			x4 = MKSTR(v5);
			x3 = x1;
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			STR* v6;
			STRLIT(v6, "<STACK>", 7);
			x4 = MKSTR(v6);
			x3 = x1;
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			STR* v7;
			STRLIT(v7, "<Resource>", 10);
			x4 = MKSTR(v7);
			x3 = x1;
		} break;
		case 3LL: { // PRIM_TYPE_INT
			STR* v8;
			STRLIT(v8, "Int", 3);
			x4 = MKSTR(v8);
			x3 = x1;
		} break;
		case 4LL: { // PRIM_TYPE_F32
			STR* v9;
			STRLIT(v9, "F32", 3);
			x4 = MKSTR(v9);
			x3 = x1;
		} break;
		case 5LL: { // PRIM_TYPE_F64
			STR* v10;
			STRLIT(v10, "F64", 3);
			x4 = MKSTR(v10);
			x3 = x1;
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			STR* v11;
			STRLIT(v11, "Ptr", 3);
			x4 = MKSTR(v11);
			x3 = x1;
		} break;
		case 7LL: { // PRIM_TYPE_STR
			STR* v12;
			STRLIT(v12, "Str", 3);
			x4 = MKSTR(v12);
			x3 = x1;
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			STR* v13;
			STRLIT(v13, "+World", 6);
			x4 = MKSTR(v13);
			x3 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(x4, x3));
	return v14;
}
static void mw_mirth_type_Type_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // TYPE_ERROR
			VAL v7 = MKI64(0LL /* TYPE_ERROR */);
			x6 = v7;
			x5 = x1;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			VAL v8 = MKI64(1LL /* TYPE_DONT_CARE */);
			x6 = v8;
			x5 = x1;
		} break;
		case 2LL: { // TPrim
			int64_t v9 = mtp_mirth_type_Type_TPrim(x2);
			VAL v10 = mtw_mirth_type_Type_TPrim(v9);
			x6 = v10;
			x5 = x1;
		} break;
		case 4LL: { // THole
			uint64_t v11 = mtp_mirth_type_Type_THole(x2);
			VAL v12 = mtw_mirth_type_Type_THole(v11);
			x6 = v12;
			x5 = x1;
		} break;
		case 7LL: { // TData
			uint64_t v13 = mtp_mirth_type_Type_TData(x2);
			VAL v14 = mtw_mirth_type_Type_TData(v13);
			x6 = v14;
			x5 = x1;
		} break;
		case 8LL: { // TDataPartial
			VAL v15 = mtp_mirth_type_Type_TDataPartial(x2);
			VAL v16 = mtw_mirth_type_Type_TDataPartial(v15);
			x6 = v16;
			x5 = x1;
		} break;
		case 6LL: { // TTable
			uint64_t v17 = mtp_mirth_type_Type_TTable(x2);
			VAL v18 = mtw_mirth_type_Type_TTable(v17);
			x6 = v18;
			x5 = x1;
		} break;
		case 13LL: { // TValue
			VAL v19 = mtp_mirth_type_Type_TValue(x2);
			VAL v20 = mtw_mirth_type_Type_TValue(v19);
			x6 = v20;
			x5 = x1;
		} break;
		case 5LL: { // TVar
			uint64_t v21 = mtp_mirth_type_Type_TVar(x2);
			VAL v22;
			VAL v23;
			mw_mirth_var_Var_freshen(x1, v21, &v22, &v23);
			x6 = v23;
			x5 = v22;
		} break;
		case 3LL: { // TMeta
			uint64_t v24 = mtp_mirth_type_Type_TMeta(x2);
			VAL v25;
			VAL v26;
			mw_mirth_type_MetaVar_freshen(x1, v24, &v25, &v26);
			x6 = v26;
			x5 = v25;
		} break;
		case 9LL: { // TTensor
			VAL v27 = mtp_mirth_type_Type_TTensor(x2);
			VAL v28;
			VAL v29;
			mw_mirth_type_StackType_freshen(x1, v27, &v28, &v29);
			VAL v30 = mtw_mirth_type_Type_TTensor(v29);
			x6 = v30;
			x5 = v28;
		} break;
		case 10LL: { // TMorphism
			VAL v31 = mtp_mirth_type_Type_TMorphism(x2);
			VAL v32;
			VAL v33;
			mw_mirth_type_ArrowType_freshen(x1, v31, &v32, &v33);
			VAL v34 = mtw_mirth_type_Type_TMorphism(v33);
			x6 = v34;
			x5 = v32;
		} break;
		case 11LL: { // TApp
			VAL v35;
			VAL v36;
			mtp_mirth_type_Type_TApp(x2, &v35, &v36);
			VAL v37;
			VAL v38;
			VAL v39;
			mw_mirth_type_Type_freshen2(x1, v35, v36, &v37, &v38, &v39);
			VAL v40 = mtw_mirth_type_Type_TApp(v38, v39);
			x6 = v40;
			x5 = v37;
		} break;
		case 12LL: { // TMut
			VAL v41 = mtp_mirth_type_Type_TMut(x2);
			VAL v42;
			VAL v43;
			mw_mirth_type_Type_freshen(x1, v41, &v42, &v43);
			VAL v44 = mtw_mirth_type_Type_TMut(v43);
			x6 = v44;
			x5 = v42;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_type_Type_freshen2 (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	mw_mirth_type_Type_freshen(x1, x2, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_type_Type_freshen(v7, x3, &v9, &v10);
	*x6 = v10;
	*x5 = v8;
	*x4 = v9;
}
static void mw_mirth_type_Type_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(x3)) {
		case 3LL: { // TMeta
			uint64_t v10 = mtp_mirth_type_Type_TMeta(x3);
			VAL v11 = mw_mirth_type_MetaVar_typeZAsk(v10);
			VAL x12;
			VAL x13;
			VAL x14;
			switch (get_data_tag(v11)) {
				case 0LL: { // None
					VAL v15;
					uint64_t v16;
					mw_mirth_var_Ctx_freshZ_typeZ_varZBang(x2, &v15, &v16);
					VAL v17 = mtw_mirth_type_Type_TVar(v16);
					incref(v17);
					VAL v18 = mtw_std_maybe_Maybe_1_Some(v17);
					void* v19 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v10);
					mut_set(v18, v19);
					x14 = v17;
					x13 = v15;
					x12 = x1;
				} break;
				case 1LL: { // Some
					VAL v20 = mtp_std_maybe_Maybe_1_Some(v11);
					x14 = v20;
					x13 = x2;
					x12 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v21;
			VAL v22;
			VAL v23;
			mw_mirth_type_Type_rigidifyZBang(x12, x13, x14, &v21, &v22, &v23);
			x9 = v23;
			x8 = v22;
			x7 = v21;
		} break;
		case 0LL: { // TYPE_ERROR
			VAL v24 = MKI64(0LL /* TYPE_ERROR */);
			x9 = v24;
			x8 = x2;
			x7 = x1;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			VAL v25 = MKI64(1LL /* TYPE_DONT_CARE */);
			x9 = v25;
			x8 = x2;
			x7 = x1;
		} break;
		case 2LL: { // TPrim
			int64_t v26 = mtp_mirth_type_Type_TPrim(x3);
			VAL v27 = mtw_mirth_type_Type_TPrim(v26);
			x9 = v27;
			x8 = x2;
			x7 = x1;
		} break;
		case 4LL: { // THole
			uint64_t v28 = mtp_mirth_type_Type_THole(x3);
			VAL v29 = mtw_mirth_type_Type_THole(v28);
			x9 = v29;
			x8 = x2;
			x7 = x1;
		} break;
		case 5LL: { // TVar
			uint64_t v30 = mtp_mirth_type_Type_TVar(x3);
			VAL v31 = mtw_mirth_type_Type_TVar(v30);
			x9 = v31;
			x8 = x2;
			x7 = x1;
		} break;
		case 6LL: { // TTable
			uint64_t v32 = mtp_mirth_type_Type_TTable(x3);
			VAL v33 = mtw_mirth_type_Type_TTable(v32);
			x9 = v33;
			x8 = x2;
			x7 = x1;
		} break;
		case 7LL: { // TData
			uint64_t v34 = mtp_mirth_type_Type_TData(x3);
			VAL v35 = mtw_mirth_type_Type_TData(v34);
			x9 = v35;
			x8 = x2;
			x7 = x1;
		} break;
		case 8LL: { // TDataPartial
			VAL v36 = mtp_mirth_type_Type_TDataPartial(x3);
			VAL v37 = mtw_mirth_type_Type_TDataPartial(v36);
			x9 = v37;
			x8 = x2;
			x7 = x1;
		} break;
		case 11LL: { // TApp
			VAL v38;
			VAL v39;
			mtp_mirth_type_Type_TApp(x3, &v38, &v39);
			VAL v40;
			VAL v41;
			VAL v42;
			mw_mirth_type_Type_rigidifyZBang(x1, x2, v38, &v40, &v41, &v42);
			VAL v43;
			VAL v44;
			VAL v45;
			mw_mirth_type_Type_rigidifyZBang(v40, v41, v39, &v43, &v44, &v45);
			VAL v46 = mtw_mirth_type_Type_TApp(v42, v45);
			x9 = v46;
			x8 = v44;
			x7 = v43;
		} break;
		case 9LL: { // TTensor
			VAL v47 = mtp_mirth_type_Type_TTensor(x3);
			VAL v48;
			VAL v49;
			VAL v50;
			mw_mirth_type_StackType_rigidifyZBang(x1, x2, v47, &v48, &v49, &v50);
			VAL v51 = mtw_mirth_type_Type_TTensor(v50);
			x9 = v51;
			x8 = v49;
			x7 = v48;
		} break;
		case 10LL: { // TMorphism
			VAL v52 = mtp_mirth_type_Type_TMorphism(x3);
			VAL v53;
			VAL v54;
			VAL v55;
			mw_mirth_type_ArrowType_rigidifyZBang(x1, x2, v52, &v53, &v54, &v55);
			VAL v56 = mtw_mirth_type_Type_TMorphism(v55);
			x9 = v56;
			x8 = v54;
			x7 = v53;
		} break;
		case 13LL: { // TValue
			VAL v57 = mtp_mirth_type_Type_TValue(x3);
			VAL v58;
			VAL v59;
			VAL v60;
			mw_mirth_type_Value_rigidifyZBang(x1, x2, v57, &v58, &v59, &v60);
			x9 = v60;
			x8 = v59;
			x7 = v58;
		} break;
		case 12LL: { // TMut
			VAL v61 = mtp_mirth_type_Type_TMut(x3);
			VAL v62;
			VAL v63;
			VAL v64;
			mw_mirth_type_Type_rigidifyZBang(x1, x2, v61, &v62, &v63, &v64);
			VAL v65 = mtw_mirth_type_Type_TMut(v64);
			x9 = v65;
			x8 = v63;
			x7 = v62;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x9;
	*x5 = x8;
	*x4 = x7;
}
static void mw_mirth_type_Value_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(x3)) {
		case 0LL: { // VALUE_INT
			int64_t v10 = mtp_mirth_type_Value_VALUEz_INT(x3);
			VAL v11 = mtw_mirth_type_Value_VALUEz_INT(v10);
			VAL v12 = mtw_mirth_type_Type_TValue(v11);
			x9 = v12;
			x8 = x2;
			x7 = x1;
		} break;
		case 2LL: { // VALUE_STR
			VAL v13 = mtp_mirth_type_Value_VALUEz_STR(x3);
			VAL v14 = mtw_mirth_type_Value_VALUEz_STR(v13);
			VAL v15 = mtw_mirth_type_Type_TValue(v14);
			x9 = v15;
			x8 = x2;
			x7 = x1;
		} break;
		case 1LL: { // VALUE_F64
			double v16 = mtp_mirth_type_Value_VALUEz_F64(x3);
			VAL v17 = mtw_mirth_type_Value_VALUEz_F64(v16);
			VAL v18 = mtw_mirth_type_Type_TValue(v17);
			x9 = v18;
			x8 = x2;
			x7 = x1;
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v19 = mtp_mirth_type_Value_VALUEz_BLOCK(x3);
			VAL v20;
			VAL v21;
			mw_mirth_arrow_Block_arrow(x1, v19, &v20, &v21);
			VAL v22 = mw_mirth_arrow_Arrow_type(v21);
			VAL v23;
			VAL v24;
			VAL v25;
			mw_mirth_type_ArrowType_rigidifyZBang(v20, x2, v22, &v23, &v24, &v25);
			VAL v26 = mw_mirth_type_ArrowType_ZToType(v25);
			x9 = v26;
			x8 = v24;
			x7 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x9;
	*x5 = x8;
	*x4 = x7;
}
static VAL mw_mirth_type_Type_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3) {
	VAL x4;
	switch (get_data_tag(x3)) {
		case 3LL: { // TMeta
			uint64_t v5 = mtp_mirth_type_Type_TMeta(x3);
			VAL v6 = mw_mirth_type_MetaVar_typeZAsk(v5);
			VAL x7;
			switch (get_data_tag(v6)) {
				case 0LL: { // None
					STR* v8;
					STRLIT(v8, "Type.except-field on metavar", 28);
					push_u64(x1);
					push_u64(x2);
					push_u64(v5);
					do_panic(v8);
					VAL v9 = pop_value();
					x7 = v9;
				} break;
				case 1LL: { // Some
					VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
					VAL v11 = mw_mirth_type_Type_expand(v10);
					incref(v11);
					VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
					void* v13 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v5);
					mut_set(v12, v13);
					VAL v14 = mw_mirth_type_Type_exceptZ_field(x1, x2, v11);
					x7 = v14;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x4 = x7;
		} break;
		case 7LL: { // TData
			uint64_t v15 = mtp_mirth_type_Type_TData(x3);
			VAL v16 = mtw_mirth_data_DataPartial_DataPartial(v15, x1);
			VAL v17 = mtw_mirth_type_Type_TDataPartial(v16);
			x4 = v17;
		} break;
		case 11LL: { // TApp
			VAL v18;
			VAL v19;
			mtp_mirth_type_Type_TApp(x3, &v18, &v19);
			VAL v20 = mw_mirth_type_Type_exceptZ_field(x1, x2, v18);
			VAL v21 = mtw_mirth_type_Type_TApp(v20, v19);
			x4 = v21;
		} break;
		default: {
			STR* v22;
			STRLIT(v22, "Type.except-field on unexpected type", 36);
			push_u64(x1);
			push_u64(x2);
			push_value(x3);
			do_panic(v22);
			VAL v23 = pop_value();
			x4 = v23;
		} break;
	}
	return x4;
}
static int64_t mw_mirth_type_MetaVar_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_type_MetaVar_allocZBang (void) {
	void* v1 = mbuf_mirth_type_MetaVar_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_type_MetaVar_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_type_MetaVar_typeZAsk (uint64_t x1) {
	void* v2 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static int64_t mw_mirth_type_MetaVar_hasZ_metaZAsk (uint64_t x1, uint64_t x2) {
	VAL v3 = mw_mirth_type_MetaVar_typeZAsk(x2);
	int64_t x4;
	switch (get_data_tag(v3)) {
		case 0LL: { // None
			int64_t v5 = mw_mirth_type_MetaVar_ZEqualZEqual(x1, x2);
			x4 = v5;
		} break;
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v3);
			int64_t v7 = mw_mirth_type_Type_hasZ_metaZAsk(x1, v6);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_type_MetaVar_typeZThen (VAL x1, uint64_t x2) {
	VAL v3 = mw_mirth_type_MetaVar_typeZAsk(x2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 0LL: { // None
			STR* v5;
			STRLIT(v5, "?", 1);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), x1));
			int64_t v7 = mw_mirth_type_MetaVar_index(x2);
			STR* v8 = i64_show(v7);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v6));
			x4 = v9;
		} break;
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v11 = (mw_mirth_type_Type_typeZThen(v10, x1));
			x4 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static uint64_t mw_mirth_type_MetaVar_newZBang (void) {
	uint64_t v1 = mw_mirth_type_MetaVar_allocZBang();
	VAL v2 = MKI64(0LL /* None */);
	void* v3 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v1);
	mut_set(v2, v3);
	return v1;
}
static VAL mw_mirth_type_MetaVar_expand (uint64_t x1) {
	VAL v2 = mw_mirth_type_MetaVar_typeZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // None
			VAL v4 = mtw_mirth_type_Type_TMeta(x1);
			x3 = v4;
		} break;
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v6 = mw_mirth_type_Type_expand(v5);
			incref(v6);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			void* v8 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(x1);
			mut_set(v7, v8);
			x3 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_type_MetaVar_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_type_MetaVar_typeZAsk(x4);
	VAL x9;
	uint64_t x10;
	VAL x11;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v13;
			uint64_t v14;
			VAL v15;
			mw_mirth_type_Type_unifyZBang(x1, x2, x3, v12, &v13, &v14, &v15);
			x11 = v15;
			x10 = v14;
			x9 = v13;
		} break;
		case 0LL: { // None
			incref(x3);
			int64_t v16 = mw_mirth_type_Type_metaZEqual(x4, x3);
			VAL x17;
			uint64_t x18;
			VAL x19;
			if (((bool)v16)) {
				x19 = x3;
				x18 = x2;
				x17 = x1;
			} else {
				incref(x3);
				int64_t v20 = mw_mirth_type_Type_hasZ_metaZAsk(x4, x3);
				VAL x21;
				uint64_t x22;
				VAL x23;
				if (((bool)v20)) {
					VAL v24 = mtw_mirth_type_Type_TMeta(x4);
					VAL v25;
					uint64_t v26;
					VAL v27;
					mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, x3, v24, &v25, &v26, &v27);
					x23 = v27;
					x22 = v26;
					x21 = v25;
				} else {
					incref(x3);
					VAL v28 = mtw_std_maybe_Maybe_1_Some(x3);
					void* v29 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(x4);
					mut_set(v28, v29);
					x23 = x3;
					x22 = x2;
					x21 = x1;
				}
				x19 = x23;
				x18 = x22;
				x17 = x21;
			}
			x11 = x19;
			x10 = x18;
			x9 = x17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_type_MetaVar_unifyZ_errorZBang (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, uint64_t *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_MetaVar_typeZAsk(x3);
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v12;
			uint64_t v13;
			VAL v14;
			mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, v11, &v12, &v13, &v14);
			x10 = v14;
			x9 = v13;
			x8 = v12;
		} break;
		case 0LL: { // None
			VAL v15 = MKI64(0LL /* TYPE_ERROR */);
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v15);
			void* v17 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(x3);
			mut_set(v16, v17);
			VAL v18 = MKI64(0LL /* TYPE_ERROR */);
			x10 = v18;
			x9 = x2;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static int64_t mw_mirth_type_MetaVar_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_type_MetaVar_index(x1);
	int64_t v4 = mw_mirth_type_MetaVar_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_type_MetaVar_freshen (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_type_MetaVar_typeZAsk(x2);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 0LL: { // None
			uint64_t v8 = mw_mirth_type_MetaVar_newZBang();
			VAL v9 = mtw_mirth_type_Type_TMeta(v8);
			x7 = v9;
			x6 = x1;
		} break;
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v5);
			VAL v11 = mw_mirth_type_Type_expand(v10);
			incref(v11);
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
			void* v13 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(x2);
			mut_set(v12, v13);
			VAL v14;
			VAL v15;
			mw_mirth_type_Type_freshen(x1, v11, &v14, &v15);
			x7 = v15;
			x6 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_type_typeZ_holeZ_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL *x5, uint64_t *x6, VAL *x7) {
	STR* v8;
	STRLIT(v8, "", 0);
	VAL v9 = mtw_mirth_type_Type_THole(x4);
	VAL v10 = (mw_mirth_type_Type_typeZThen(v9, MKSTR(v8)));
	STR* v11;
	STRLIT(v11, " ~ ", 3);
	VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
	incref(x3);
	VAL v13 = (mw_mirth_type_Type_typeZThen(x3, v12));
	STR* v14;
	STRLIT(v14, "\n", 1);
	VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), v13));
	VAL v16 = (mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang(x2, v15, x1));
	*x7 = x3;
	*x6 = x2;
	*x5 = v16;
}
static VAL mw_mirth_type_Type_appZ_typeZThenZThen (VAL x1, VAL x2, VAL x3) {
	VAL v4 = (mw_mirth_type_Type_appZ_typeZ_openZThenZThen(x1, x2, x3));
	STR* v5;
	STRLIT(v5, ")", 1);
	VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), v4));
	return v6;
}
static VAL mw_mirth_type_Type_appZ_typeZ_openZThenZThen (VAL x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_type_Type_expand(x2);
	VAL x5;
	switch (get_data_tag(v4)) {
		case 11LL: { // TApp
			VAL v6;
			VAL v7;
			mtp_mirth_type_Type_TApp(v4, &v6, &v7);
			VAL v8 = (mw_mirth_type_Type_appZ_typeZ_openZThenZThen(x1, v6, v7));
			STR* v9;
			STRLIT(v9, ", ", 2);
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), v8));
			VAL v11 = (mw_mirth_type_Type_typeZThen(x3, v10));
			x5 = v11;
		} break;
		default: {
			VAL v12 = (mw_mirth_type_Type_typeZThen(v4, x1));
			STR* v13;
			STRLIT(v13, "(", 1);
			VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), v12));
			VAL v15 = (mw_mirth_type_Type_typeZThen(x3, v14));
			x5 = v15;
		} break;
	}
	return x5;
}
static VAL mw_mirth_type_Resource_ZToType (VAL x1) {
	return x1;
}
static VAL mw_mirth_type_Type_ZToResource (VAL x1) {
	return x1;
}
static int64_t mw_mirth_type_Resource_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_type_Resource_ZToType(x2);
	int64_t v4 = mw_mirth_type_Type_hasZ_metaZAsk(x1, v3);
	return v4;
}
static void mw_mirth_type_Resource_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_type_Resource_ZToType(x3);
	VAL v9 = mw_mirth_type_Resource_ZToType(x4);
	VAL v10;
	uint64_t v11;
	VAL v12;
	mw_mirth_type_Type_unifyZBang(x1, x2, v8, v9, &v10, &v11, &v12);
	VAL v13 = mw_mirth_type_Type_ZToResource(v12);
	*x7 = v13;
	*x6 = v11;
	*x5 = v10;
}
static void mw_mirth_type_Resource_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_Resource_ZToType(x3);
	VAL v8;
	uint64_t v9;
	VAL v10;
	mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, v7, &v8, &v9, &v10);
	VAL v11 = mw_mirth_type_Type_ZToResource(v10);
	*x6 = v11;
	*x5 = v9;
	*x4 = v8;
}
static VAL mw_mirth_type_Resource_typeZThen (VAL x1, VAL x2) {
	VAL v3 = mw_mirth_type_Resource_ZToType(x2);
	VAL v4 = (mw_mirth_type_Type_typeZThen(v3, x1));
	return v4;
}
static void mw_mirth_type_Resource_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_type_Resource_ZToType(x2);
	VAL v6;
	VAL v7;
	mw_mirth_type_Type_freshen(x1, v5, &v6, &v7);
	VAL v8 = mw_mirth_type_Type_ZToResource(v7);
	*x4 = v8;
	*x3 = v6;
}
static void mw_mirth_type_Resource_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_Resource_ZToType(x3);
	VAL v8;
	VAL v9;
	VAL v10;
	mw_mirth_type_Type_rigidifyZBang(x1, x2, v7, &v8, &v9, &v10);
	VAL v11 = mw_mirth_type_Type_ZToResource(v10);
	*x6 = v11;
	*x5 = v9;
	*x4 = v8;
}
static VAL mw_mirth_type_Resource_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3) {
	VAL v4 = mw_mirth_type_Type_exceptZ_field(x1, x2, x3);
	return v4;
}
static VAL mw_mirth_type_Type_ZToStackType (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			VAL v3 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x2 = v3;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			VAL v4 = MKI64(1LL /* STACK_TYPE_DONT_CARE */);
			x2 = v4;
		} break;
		case 5LL: { // TVar
			uint64_t v5 = mtp_mirth_type_Type_TVar(x1);
			VAL v6 = mtw_mirth_type_StackType_STVar(v5);
			x2 = v6;
		} break;
		case 3LL: { // TMeta
			uint64_t v7 = mtp_mirth_type_Type_TMeta(x1);
			VAL v8 = mtw_mirth_type_StackType_STMeta(v7);
			x2 = v8;
		} break;
		case 9LL: { // TTensor
			VAL v9 = mtp_mirth_type_Type_TTensor(x1);
			x2 = v9;
		} break;
		default: {
			STR* v10;
			STRLIT(v10, "kind error! expected stack type, got regular type.", 50);
			push_value(x1);
			do_panic(v10);
			VAL v11 = pop_value();
			x2 = v11;
		} break;
	}
	return x2;
}
static VAL mw_mirth_type_StackType_ZToType (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v3 = MKI64(0LL /* TYPE_ERROR */);
			x2 = v3;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v4 = MKI64(1LL /* TYPE_DONT_CARE */);
			x2 = v4;
		} break;
		case 3LL: { // STVar
			uint64_t v5 = mtp_mirth_type_StackType_STVar(x1);
			VAL v6 = mtw_mirth_type_Type_TVar(v5);
			x2 = v6;
		} break;
		case 4LL: { // STMeta
			uint64_t v7 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v8 = mtw_mirth_type_Type_TMeta(v7);
			x2 = v8;
		} break;
		default: {
			VAL v9 = mtw_mirth_type_Type_TTensor(x1);
			x2 = v9;
		} break;
	}
	return x2;
}
static VAL mw_mirth_type_StackType_expand (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 4LL: { // STMeta
			uint64_t v3 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v4 = mw_mirth_type_MetaVar_expand(v3);
			VAL v5 = mw_mirth_type_Type_ZToStackType(v4);
			x2 = v5;
		} break;
		default: {
			x2 = x1;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_type_StackType_unitZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v4 = 1LL /* True */;
			x3 = v4;
		} break;
		default: {
			decref(v2);
			int64_t v5 = 0LL /* False */;
			x3 = v5;
		} break;
	}
	return x3;
}
static void mw_mirth_type_StackType_split4 (VAL x1, VAL *x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = MKI64(0LL /* Nil */);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mw_mirth_type_StackType_expand(x1);
	VAL x10;
	VAL x11;
	VAL x12;
	VAL x13;
	int64_t x14;
	switch (get_data_tag(v9)) {
		case 5LL: { // STCons
			VAL v15;
			VAL v16;
			mtp_mirth_type_StackType_STCons(v9, &v15, &v16);
			VAL v17 = mtw_std_list_List_1_Cons(v16, v6);
			int64_t v18 = 1LL /* True */;
			x14 = v18;
			x13 = v17;
			x12 = v15;
			x11 = v7;
			x10 = v8;
		} break;
		case 7LL: { // STWith
			VAL v19;
			VAL v20;
			mtp_mirth_type_StackType_STWith(v9, &v19, &v20);
			VAL v21 = mtw_std_list_List_1_Cons(v20, v7);
			int64_t v22 = 1LL /* True */;
			x14 = v22;
			x13 = v6;
			x12 = v19;
			x11 = v21;
			x10 = v8;
		} break;
		case 6LL: { // STConsLabel
			VAL v23;
			VAL v24;
			uint64_t v25;
			mtp_mirth_type_StackType_STConsLabel(v9, &v23, &v24, &v25);
			VAL v26 = mtw_std_either_Either_2_Left(v24);
			VAL v27 = MKNIL;
			VAL v28 = mkcons(v27, v26);
			VAL v29 = mkcons(v28, MKU64(v25));
			VAL v30 = mtw_std_list_List_1_Cons(v29, v8);
			int64_t v31 = 1LL /* True */;
			x14 = v31;
			x13 = v6;
			x12 = v23;
			x11 = v7;
			x10 = v30;
		} break;
		case 8LL: { // STWithLabel
			VAL v32;
			VAL v33;
			uint64_t v34;
			mtp_mirth_type_StackType_STWithLabel(v9, &v32, &v33, &v34);
			VAL v35 = mtw_std_either_Either_2_Right(v33);
			VAL v36 = MKNIL;
			VAL v37 = mkcons(v36, v35);
			VAL v38 = mkcons(v37, MKU64(v34));
			VAL v39 = mtw_std_list_List_1_Cons(v38, v8);
			int64_t v40 = 1LL /* True */;
			x14 = v40;
			x13 = v6;
			x12 = v32;
			x11 = v7;
			x10 = v39;
		} break;
		default: {
			int64_t v41 = 0LL /* False */;
			x14 = v41;
			x13 = v6;
			x12 = v9;
			x11 = v7;
			x10 = v8;
		} break;
	}
	VAL v42 = x10;
	VAL v43 = x11;
	VAL v44 = x12;
	VAL v45 = x13;
	int64_t v46 = x14;
	while (((bool)v46)) {
		VAL v47 = v42;
		VAL v48 = v43;
		VAL v49 = v44;
		VAL v50 = v45;
		VAL v51 = mw_mirth_type_StackType_expand(v49);
		VAL x52;
		VAL x53;
		VAL x54;
		VAL x55;
		int64_t x56;
		switch (get_data_tag(v51)) {
			case 5LL: { // STCons
				VAL v57;
				VAL v58;
				mtp_mirth_type_StackType_STCons(v51, &v57, &v58);
				VAL v59 = mtw_std_list_List_1_Cons(v58, v50);
				int64_t v60 = 1LL /* True */;
				x56 = v60;
				x55 = v59;
				x54 = v57;
				x53 = v48;
				x52 = v47;
			} break;
			case 7LL: { // STWith
				VAL v61;
				VAL v62;
				mtp_mirth_type_StackType_STWith(v51, &v61, &v62);
				VAL v63 = mtw_std_list_List_1_Cons(v62, v48);
				int64_t v64 = 1LL /* True */;
				x56 = v64;
				x55 = v50;
				x54 = v61;
				x53 = v63;
				x52 = v47;
			} break;
			case 6LL: { // STConsLabel
				VAL v65;
				VAL v66;
				uint64_t v67;
				mtp_mirth_type_StackType_STConsLabel(v51, &v65, &v66, &v67);
				VAL v68 = mtw_std_either_Either_2_Left(v66);
				VAL v69 = MKNIL;
				VAL v70 = mkcons(v69, v68);
				VAL v71 = mkcons(v70, MKU64(v67));
				VAL v72 = mtw_std_list_List_1_Cons(v71, v47);
				int64_t v73 = 1LL /* True */;
				x56 = v73;
				x55 = v50;
				x54 = v65;
				x53 = v48;
				x52 = v72;
			} break;
			case 8LL: { // STWithLabel
				VAL v74;
				VAL v75;
				uint64_t v76;
				mtp_mirth_type_StackType_STWithLabel(v51, &v74, &v75, &v76);
				VAL v77 = mtw_std_either_Either_2_Right(v75);
				VAL v78 = MKNIL;
				VAL v79 = mkcons(v78, v77);
				VAL v80 = mkcons(v79, MKU64(v76));
				VAL v81 = mtw_std_list_List_1_Cons(v80, v47);
				int64_t v82 = 1LL /* True */;
				x56 = v82;
				x55 = v50;
				x54 = v74;
				x53 = v48;
				x52 = v81;
			} break;
			default: {
				int64_t v83 = 0LL /* False */;
				x56 = v83;
				x55 = v50;
				x54 = v51;
				x53 = v48;
				x52 = v47;
			} break;
		}
		v46 = x56;
		v45 = x55;
		v44 = x54;
		v43 = x53;
		v42 = x52;
	}
	*x5 = v43;
	*x4 = v45;
	*x3 = v42;
	*x2 = v44;
}
static VAL mw_mirth_type_StackType_base (VAL x1) {
	VAL v2;
	VAL v3;
	VAL v4;
	VAL v5;
	mw_mirth_type_StackType_split4(x1, &v2, &v3, &v4, &v5);
	decref(v5);
	decref(v4);
	decref(v3);
	return v2;
}
static VAL mw_mirth_type_StackType_labelZ_topZAsk (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_type_StackType_expand(x2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 5LL: { // STCons
			VAL v5;
			VAL v6;
			mtp_mirth_type_StackType_STCons(v3, &v5, &v6);
			decref(v6);
			VAL v7 = mw_mirth_type_StackType_labelZ_topZAsk(x1, v5);
			x4 = v7;
		} break;
		case 7LL: { // STWith
			VAL v8;
			VAL v9;
			mtp_mirth_type_StackType_STWith(v3, &v8, &v9);
			decref(v9);
			VAL v10 = mw_mirth_type_StackType_labelZ_topZAsk(x1, v8);
			x4 = v10;
		} break;
		case 6LL: { // STConsLabel
			VAL v11;
			VAL v12;
			uint64_t v13;
			mtp_mirth_type_StackType_STConsLabel(v3, &v11, &v12, &v13);
			int64_t v14 = mw_mirth_label_Label_ZEqualZEqual(x1, v13);
			VAL x15;
			if (((bool)v14)) {
				decref(v11);
				VAL v16 = mtw_std_either_Either_2_Left(v12);
				VAL v17 = mtw_std_maybe_Maybe_1_Some(v16);
				x15 = v17;
			} else {
				decref(v12);
				VAL v18 = mw_mirth_type_StackType_labelZ_topZAsk(x1, v11);
				x15 = v18;
			}
			x4 = x15;
		} break;
		case 8LL: { // STWithLabel
			VAL v19;
			VAL v20;
			uint64_t v21;
			mtp_mirth_type_StackType_STWithLabel(v3, &v19, &v20, &v21);
			int64_t v22 = mw_mirth_label_Label_ZEqualZEqual(x1, v21);
			VAL x23;
			if (((bool)v22)) {
				decref(v19);
				VAL v24 = mtw_std_either_Either_2_Right(v20);
				VAL v25 = mtw_std_maybe_Maybe_1_Some(v24);
				x23 = v25;
			} else {
				decref(v20);
				VAL v26 = mw_mirth_type_StackType_labelZ_topZAsk(x1, v19);
				x23 = v26;
			}
			x4 = x23;
		} break;
		default: {
			decref(v3);
			VAL v27 = MKI64(0LL /* None */);
			x4 = v27;
		} break;
	}
	return x4;
}
static VAL mw_mirth_type_StackType_topZ_typeZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 7LL: { // STWith
			VAL v4;
			VAL v5;
			mtp_mirth_type_StackType_STWith(v2, &v4, &v5);
			decref(v5);
			VAL v6 = mw_mirth_type_StackType_topZ_typeZAsk(v4);
			x3 = v6;
		} break;
		case 5LL: { // STCons
			VAL v7;
			VAL v8;
			mtp_mirth_type_StackType_STCons(v2, &v7, &v8);
			decref(v7);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			x3 = v9;
		} break;
		case 6LL: { // STConsLabel
			VAL v10;
			VAL v11;
			uint64_t v12;
			mtp_mirth_type_StackType_STConsLabel(v2, &v10, &v11, &v12);
			decref(v11);
			VAL v13 = mw_mirth_type_StackType_topZ_typeZAsk(v10);
			x3 = v13;
		} break;
		case 8LL: { // STWithLabel
			VAL v14;
			VAL v15;
			uint64_t v16;
			mtp_mirth_type_StackType_STWithLabel(v2, &v14, &v15, &v16);
			decref(v15);
			VAL v17 = mw_mirth_type_StackType_topZ_typeZAsk(v14);
			x3 = v17;
		} break;
		default: {
			decref(v2);
			VAL v18 = MKI64(0LL /* None */);
			x3 = v18;
		} break;
	}
	return x3;
}
static VAL mw_mirth_type_StackType_topZ_tyconZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_topZ_typeZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_mirth_type_Type_tyconZAsk(v4);
			x3 = v5;
		} break;
		case 0LL: { // None
			VAL v6 = MKI64(0LL /* None */);
			x3 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_StackType_topZ_resourceZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 7LL: { // STWith
			VAL v4;
			VAL v5;
			mtp_mirth_type_StackType_STWith(v2, &v4, &v5);
			decref(v4);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			x3 = v6;
		} break;
		case 5LL: { // STCons
			VAL v7;
			VAL v8;
			mtp_mirth_type_StackType_STCons(v2, &v7, &v8);
			decref(v8);
			VAL v9 = mw_mirth_type_StackType_topZ_resourceZAsk(v7);
			x3 = v9;
		} break;
		case 6LL: { // STConsLabel
			VAL v10;
			VAL v11;
			uint64_t v12;
			mtp_mirth_type_StackType_STConsLabel(v2, &v10, &v11, &v12);
			decref(v11);
			VAL v13 = mw_mirth_type_StackType_topZ_resourceZAsk(v10);
			x3 = v13;
		} break;
		case 8LL: { // STWithLabel
			VAL v14;
			VAL v15;
			uint64_t v16;
			mtp_mirth_type_StackType_STWithLabel(v2, &v14, &v15, &v16);
			decref(v15);
			VAL v17 = mw_mirth_type_StackType_topZ_resourceZAsk(v14);
			x3 = v17;
		} break;
		default: {
			decref(v2);
			VAL v18 = MKI64(0LL /* None */);
			x3 = v18;
		} break;
	}
	return x3;
}
static VAL mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_topZ_resourceZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_mirth_type_Resource_ZToType(v4);
			VAL v6 = mw_mirth_type_Type_tyconZAsk(v5);
			x3 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x3 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_StackType_topZ_namespaces (VAL x1) {
	VAL v2 = MKI64(0LL /* Nil */);
	VAL v3 = mw_std_list_List_1_reverse(v2);
	incref(x1);
	VAL v4 = mw_mirth_type_StackType_topZ_tyconZAsk(x1);
	VAL x5;
	VAL x6;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v4);
			VAL v8 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v7);
			VAL v9 = mtw_std_list_List_1_Cons(v8, v3);
			x6 = x1;
			x5 = v9;
		} break;
		case 0LL: { // None
			x6 = x1;
			x5 = v3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v10 = mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk(x6);
	VAL x11;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v13 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v12);
			VAL v14 = mtw_std_list_List_1_Cons(v13, x5);
			x11 = v14;
		} break;
		case 0LL: { // None
			x11 = x5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15 = mw_std_list_List_1_reverse(x11);
	return v15;
}
static int64_t mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk (VAL x1) {
	incref(x1);
	int64_t v2 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(x1);
	VAL x3;
	int64_t x4;
	if (((bool)v2)) {
		incref(x1);
		int64_t v5 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(x1);
		x4 = v5;
		x3 = x1;
	} else {
		int64_t v6 = 0LL /* False */;
		x4 = v6;
		x3 = x1;
	}
	decref(x3);
	return x4;
}
static int64_t mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 5LL: { // STCons
			VAL v4;
			VAL v5;
			mtp_mirth_type_StackType_STCons(v2, &v4, &v5);
			decref(v4);
			int64_t v6 = mw_mirth_type_Type_errorZAsk(v5);
			bool v7 = !((bool)v6);
			x3 = ((int64_t)v7);
		} break;
		case 6LL: { // STConsLabel
			VAL v8;
			VAL v9;
			uint64_t v10;
			mtp_mirth_type_StackType_STConsLabel(v2, &v8, &v9, &v10);
			decref(v9);
			int64_t v11 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(v8);
			x3 = v11;
		} break;
		case 7LL: { // STWith
			VAL v12;
			VAL v13;
			mtp_mirth_type_StackType_STWith(v2, &v12, &v13);
			decref(v13);
			int64_t v14 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(v12);
			x3 = v14;
		} break;
		case 8LL: { // STWithLabel
			VAL v15;
			VAL v16;
			uint64_t v17;
			mtp_mirth_type_StackType_STWithLabel(v2, &v15, &v16, &v17);
			decref(v16);
			int64_t v18 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(v15);
			x3 = v18;
		} break;
		case 4LL: { // STMeta
			uint64_t v19 = mtp_mirth_type_StackType_STMeta(v2);
			int64_t v20 = 1LL /* True */;
			x3 = v20;
		} break;
		case 3LL: { // STVar
			uint64_t v21 = mtp_mirth_type_StackType_STVar(v2);
			int64_t v22 = 1LL /* True */;
			x3 = v22;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v23 = 1LL /* True */;
			x3 = v23;
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v24 = 0LL /* False */;
			x3 = v24;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v25 = 0LL /* False */;
			x3 = v25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 5LL: { // STCons
			VAL v4;
			VAL v5;
			mtp_mirth_type_StackType_STCons(v2, &v4, &v5);
			decref(v5);
			int64_t v6 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v4);
			x3 = v6;
		} break;
		case 6LL: { // STConsLabel
			VAL v7;
			VAL v8;
			uint64_t v9;
			mtp_mirth_type_StackType_STConsLabel(v2, &v7, &v8, &v9);
			decref(v8);
			int64_t v10 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v7);
			x3 = v10;
		} break;
		case 7LL: { // STWith
			VAL v11;
			VAL v12;
			mtp_mirth_type_StackType_STWith(v2, &v11, &v12);
			decref(v11);
			int64_t v13 = mw_mirth_type_Type_errorZAsk(v12);
			bool v14 = !((bool)v13);
			x3 = ((int64_t)v14);
		} break;
		case 8LL: { // STWithLabel
			VAL v15;
			VAL v16;
			uint64_t v17;
			mtp_mirth_type_StackType_STWithLabel(v2, &v15, &v16, &v17);
			decref(v16);
			int64_t v18 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v15);
			x3 = v18;
		} break;
		case 4LL: { // STMeta
			uint64_t v19 = mtp_mirth_type_StackType_STMeta(v2);
			int64_t v20 = 1LL /* True */;
			x3 = v20;
		} break;
		case 3LL: { // STVar
			uint64_t v21 = mtp_mirth_type_StackType_STVar(v2);
			int64_t v22 = 1LL /* True */;
			x3 = v22;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v23 = 1LL /* True */;
			x3 = v23;
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v24 = 0LL /* False */;
			x3 = v24;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v25 = 0LL /* False */;
			x3 = v25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_type_StackType_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_type_StackType_expand(x2);
	int64_t x4;
	switch (get_data_tag(v3)) {
		case 4LL: { // STMeta
			uint64_t v5 = mtp_mirth_type_StackType_STMeta(v3);
			int64_t v6 = mw_mirth_type_MetaVar_ZEqualZEqual(x1, v5);
			x4 = v6;
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v7 = 0LL /* False */;
			x4 = v7;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v8 = 0LL /* False */;
			x4 = v8;
		} break;
		case 3LL: { // STVar
			uint64_t v9 = mtp_mirth_type_StackType_STVar(v3);
			int64_t v10 = 0LL /* False */;
			x4 = v10;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v11 = 0LL /* False */;
			x4 = v11;
		} break;
		case 5LL: { // STCons
			VAL v12;
			VAL v13;
			mtp_mirth_type_StackType_STCons(v3, &v12, &v13);
			int64_t v14 = mw_mirth_type_Type_hasZ_metaZAsk(x1, v13);
			int64_t x15;
			if (((bool)v14)) {
				decref(v12);
				int64_t v16 = 1LL /* True */;
				x15 = v16;
			} else {
				int64_t v17 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v12);
				x15 = v17;
			}
			x4 = x15;
		} break;
		case 6LL: { // STConsLabel
			VAL v18;
			VAL v19;
			uint64_t v20;
			mtp_mirth_type_StackType_STConsLabel(v3, &v18, &v19, &v20);
			int64_t v21 = mw_mirth_type_Type_hasZ_metaZAsk(x1, v19);
			int64_t x22;
			if (((bool)v21)) {
				decref(v18);
				int64_t v23 = 1LL /* True */;
				x22 = v23;
			} else {
				int64_t v24 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v18);
				x22 = v24;
			}
			x4 = x22;
		} break;
		case 7LL: { // STWith
			VAL v25;
			VAL v26;
			mtp_mirth_type_StackType_STWith(v3, &v25, &v26);
			int64_t v27 = mw_mirth_type_Resource_hasZ_metaZAsk(x1, v26);
			int64_t x28;
			if (((bool)v27)) {
				decref(v25);
				int64_t v29 = 1LL /* True */;
				x28 = v29;
			} else {
				int64_t v30 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v25);
				x28 = v30;
			}
			x4 = x28;
		} break;
		case 8LL: { // STWithLabel
			VAL v31;
			VAL v32;
			uint64_t v33;
			mtp_mirth_type_StackType_STWithLabel(v3, &v31, &v32, &v33);
			int64_t v34 = mw_mirth_type_Resource_hasZ_metaZAsk(x1, v32);
			int64_t x35;
			if (((bool)v34)) {
				decref(v31);
				int64_t v36 = 1LL /* True */;
				x35 = v36;
			} else {
				int64_t v37 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v31);
				x35 = v37;
			}
			x4 = x35;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_type_StackType_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_type_StackType_ZToType(x3);
	VAL v9 = mw_mirth_type_StackType_ZToType(x4);
	VAL v10;
	uint64_t v11;
	VAL v12;
	mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, v8, v9, &v10, &v11, &v12);
	VAL v13 = mw_mirth_type_Type_ZToStackType(v12);
	*x7 = v13;
	*x6 = v11;
	*x5 = v10;
}
static void mw_mirth_type_StackType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_type_StackType_expand(x3);
	VAL x9;
	uint64_t x10;
	VAL x11;
	switch (get_data_tag(v8)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v12;
			uint64_t v13;
			VAL v14;
			mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, x4, &v12, &v13, &v14);
			x11 = v14;
			x10 = v13;
			x9 = v12;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			x11 = x4;
			x10 = x2;
			x9 = x1;
		} break;
		case 4LL: { // STMeta
			uint64_t v15 = mtp_mirth_type_StackType_STMeta(v8);
			VAL v16 = mw_mirth_type_StackType_expand(x4);
			VAL x17;
			uint64_t x18;
			VAL x19;
			switch (get_data_tag(v16)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v20 = mtw_mirth_type_StackType_STMeta(v15);
					VAL v21;
					uint64_t v22;
					VAL v23;
					mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v20, &v21, &v22, &v23);
					x19 = v23;
					x18 = v22;
					x17 = v21;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v24 = mtw_mirth_type_StackType_STMeta(v15);
					x19 = v24;
					x18 = x2;
					x17 = x1;
				} break;
				case 4LL: { // STMeta
					uint64_t v25 = mtp_mirth_type_StackType_STMeta(v16);
					VAL v26 = mtw_mirth_type_Type_TMeta(v15);
					VAL v27;
					uint64_t v28;
					VAL v29;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v26, v25, &v27, &v28, &v29);
					VAL v30 = mw_mirth_type_Type_ZToStackType(v29);
					x19 = v30;
					x18 = v28;
					x17 = v27;
				} break;
				default: {
					VAL v31 = mw_mirth_type_StackType_ZToType(v16);
					VAL v32;
					uint64_t v33;
					VAL v34;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v31, v15, &v32, &v33, &v34);
					VAL v35 = mw_mirth_type_Type_ZToStackType(v34);
					x19 = v35;
					x18 = v33;
					x17 = v32;
				} break;
			}
			x11 = x19;
			x10 = x18;
			x9 = x17;
		} break;
		case 3LL: { // STVar
			uint64_t v36 = mtp_mirth_type_StackType_STVar(v8);
			VAL v37 = mw_mirth_type_StackType_expand(x4);
			VAL x38;
			uint64_t x39;
			VAL x40;
			switch (get_data_tag(v37)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v41 = MKI64(0LL /* STACK_TYPE_ERROR */);
					x40 = v41;
					x39 = x2;
					x38 = x1;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v42 = mtw_mirth_type_StackType_STVar(v36);
					x40 = v42;
					x39 = x2;
					x38 = x1;
				} break;
				case 4LL: { // STMeta
					uint64_t v43 = mtp_mirth_type_StackType_STMeta(v37);
					VAL v44 = mtw_mirth_type_Type_TVar(v36);
					VAL v45;
					uint64_t v46;
					VAL v47;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v44, v43, &v45, &v46, &v47);
					VAL v48 = mw_mirth_type_Type_ZToStackType(v47);
					x40 = v48;
					x39 = v46;
					x38 = v45;
				} break;
				case 3LL: { // STVar
					uint64_t v49 = mtp_mirth_type_StackType_STVar(v37);
					VAL v50;
					uint64_t v51;
					VAL v52;
					mw_mirth_var_Var_unifyZBang(x1, x2, v36, v49, &v50, &v51, &v52);
					VAL v53 = mw_mirth_type_Type_ZToStackType(v52);
					x40 = v53;
					x39 = v51;
					x38 = v50;
				} break;
				default: {
					VAL v54 = mtw_mirth_type_StackType_STVar(v36);
					VAL v55;
					uint64_t v56;
					VAL v57;
					mw_mirth_type_StackType_unifyZ_failedZBang(x1, x2, v54, v37, &v55, &v56, &v57);
					x40 = v57;
					x39 = v56;
					x38 = v55;
				} break;
			}
			x11 = x40;
			x10 = x39;
			x9 = x38;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v58 = mw_mirth_type_StackType_expand(x4);
			VAL x59;
			uint64_t x60;
			VAL x61;
			switch (get_data_tag(v58)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v62 = MKI64(0LL /* STACK_TYPE_ERROR */);
					x61 = v62;
					x60 = x2;
					x59 = x1;
				} break;
				case 4LL: { // STMeta
					uint64_t v63 = mtp_mirth_type_StackType_STMeta(v58);
					VAL v64 = MKI64(2LL /* STACK_TYPE_UNIT */);
					VAL v65 = mw_mirth_type_StackType_ZToType(v64);
					VAL v66;
					uint64_t v67;
					VAL v68;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v65, v63, &v66, &v67, &v68);
					VAL v69 = mw_mirth_type_Type_ZToStackType(v68);
					x61 = v69;
					x60 = v67;
					x59 = v66;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v70 = MKI64(2LL /* STACK_TYPE_UNIT */);
					x61 = v70;
					x60 = x2;
					x59 = x1;
				} break;
				case 2LL: { // STACK_TYPE_UNIT
					VAL v71 = MKI64(2LL /* STACK_TYPE_UNIT */);
					x61 = v71;
					x60 = x2;
					x59 = x1;
				} break;
				default: {
					VAL v72 = MKI64(2LL /* STACK_TYPE_UNIT */);
					VAL v73;
					uint64_t v74;
					VAL v75;
					mw_mirth_type_StackType_unifyZ_failedZBang(x1, x2, v58, v72, &v73, &v74, &v75);
					x61 = v75;
					x60 = v74;
					x59 = v73;
				} break;
			}
			x11 = x61;
			x10 = x60;
			x9 = x59;
		} break;
		case 5LL: { // STCons
			VAL v76;
			VAL v77;
			mtp_mirth_type_StackType_STCons(v8, &v76, &v77);
			VAL v78 = mw_mirth_type_StackType_expand(x4);
			VAL x79;
			uint64_t x80;
			VAL x81;
			switch (get_data_tag(v78)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v82 = mtw_mirth_type_StackType_STCons(v76, v77);
					VAL v83;
					uint64_t v84;
					VAL v85;
					mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v82, &v83, &v84, &v85);
					x81 = v85;
					x80 = v84;
					x79 = v83;
				} break;
				case 4LL: { // STMeta
					uint64_t v86 = mtp_mirth_type_StackType_STMeta(v78);
					VAL v87 = mtw_mirth_type_StackType_STCons(v76, v77);
					VAL v88 = mw_mirth_type_StackType_ZToType(v87);
					VAL v89;
					uint64_t v90;
					VAL v91;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v88, v86, &v89, &v90, &v91);
					VAL v92 = mw_mirth_type_Type_ZToStackType(v91);
					x81 = v92;
					x80 = v90;
					x79 = v89;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v93 = mtw_mirth_type_StackType_STCons(v76, v77);
					x81 = v93;
					x80 = x2;
					x79 = x1;
				} break;
				default: {
					incref(v78);
					VAL v94 = mw_mirth_type_StackType_forceZ_consZAskZBang(v78);
					VAL x95;
					uint64_t x96;
					VAL x97;
					switch (get_data_tag(v94)) {
						case 1LL: { // Some
							VAL v98 = mtp_std_maybe_Maybe_1_Some(v94);
							decref(v78);
							VAL v99;
							VAL v100;
							value_uncons(v98, &v99, &v100);
							VAL v101;
							VAL v102;
							value_uncons(v99, &v101, &v102);
							decref(v101);
							VAL v103;
							uint64_t v104;
							VAL v105;
							mw_mirth_type_StackType_unifyZBang(x1, x2, v76, v102, &v103, &v104, &v105);
							VAL v106;
							uint64_t v107;
							VAL v108;
							mw_mirth_type_Type_unifyZBang(v103, v104, v77, v100, &v106, &v107, &v108);
							VAL v109 = mtw_mirth_type_StackType_STCons(v105, v108);
							x97 = v109;
							x96 = v107;
							x95 = v106;
						} break;
						case 0LL: { // None
							VAL v110 = mtw_mirth_type_StackType_STCons(v76, v77);
							VAL v111;
							uint64_t v112;
							VAL v113;
							mw_mirth_type_StackType_unifyZ_failedZBang(x1, x2, v110, v78, &v111, &v112, &v113);
							x97 = v113;
							x96 = v112;
							x95 = v111;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x81 = x97;
					x80 = x96;
					x79 = x95;
				} break;
			}
			x11 = x81;
			x10 = x80;
			x9 = x79;
		} break;
		case 7LL: { // STWith
			VAL v114;
			VAL v115;
			mtp_mirth_type_StackType_STWith(v8, &v114, &v115);
			VAL v116 = mw_mirth_type_StackType_expand(x4);
			VAL x117;
			uint64_t x118;
			VAL x119;
			switch (get_data_tag(v116)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v120 = mtw_mirth_type_StackType_STWith(v114, v115);
					VAL v121;
					uint64_t v122;
					VAL v123;
					mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v120, &v121, &v122, &v123);
					x119 = v123;
					x118 = v122;
					x117 = v121;
				} break;
				case 4LL: { // STMeta
					uint64_t v124 = mtp_mirth_type_StackType_STMeta(v116);
					VAL v125 = mtw_mirth_type_StackType_STWith(v114, v115);
					VAL v126 = mw_mirth_type_StackType_ZToType(v125);
					VAL v127;
					uint64_t v128;
					VAL v129;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v126, v124, &v127, &v128, &v129);
					VAL v130 = mw_mirth_type_Type_ZToStackType(v129);
					x119 = v130;
					x118 = v128;
					x117 = v127;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v131 = mtw_mirth_type_StackType_STWith(v114, v115);
					x119 = v131;
					x118 = x2;
					x117 = x1;
				} break;
				default: {
					incref(v116);
					VAL v132 = mw_mirth_type_StackType_forceZ_withZAskZBang(v116);
					VAL x133;
					uint64_t x134;
					VAL x135;
					switch (get_data_tag(v132)) {
						case 1LL: { // Some
							VAL v136 = mtp_std_maybe_Maybe_1_Some(v132);
							decref(v116);
							VAL v137;
							VAL v138;
							value_uncons(v136, &v137, &v138);
							VAL v139;
							VAL v140;
							value_uncons(v137, &v139, &v140);
							decref(v139);
							VAL v141;
							uint64_t v142;
							VAL v143;
							mw_mirth_type_StackType_unifyZBang(x1, x2, v114, v140, &v141, &v142, &v143);
							VAL v144;
							uint64_t v145;
							VAL v146;
							mw_mirth_type_Resource_unifyZBang(v141, v142, v115, v138, &v144, &v145, &v146);
							VAL v147 = mtw_mirth_type_StackType_STWith(v143, v146);
							x135 = v147;
							x134 = v145;
							x133 = v144;
						} break;
						case 0LL: { // None
							VAL v148 = mtw_mirth_type_StackType_STWith(v114, v115);
							VAL v149;
							uint64_t v150;
							VAL v151;
							mw_mirth_type_StackType_unifyZ_failedZBang(x1, x2, v148, v116, &v149, &v150, &v151);
							x135 = v151;
							x134 = v150;
							x133 = v149;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x119 = x135;
					x118 = x134;
					x117 = x133;
				} break;
			}
			x11 = x119;
			x10 = x118;
			x9 = x117;
		} break;
		case 6LL: { // STConsLabel
			VAL v152;
			VAL v153;
			uint64_t v154;
			mtp_mirth_type_StackType_STConsLabel(v8, &v152, &v153, &v154);
			VAL v155 = mw_mirth_type_StackType_expand(x4);
			VAL x156;
			uint64_t x157;
			VAL x158;
			switch (get_data_tag(v155)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v159 = mtw_mirth_type_StackType_STConsLabel(v152, v153, v154);
					VAL v160;
					uint64_t v161;
					VAL v162;
					mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v159, &v160, &v161, &v162);
					x158 = v162;
					x157 = v161;
					x156 = v160;
				} break;
				case 4LL: { // STMeta
					uint64_t v163 = mtp_mirth_type_StackType_STMeta(v155);
					VAL v164 = mtw_mirth_type_StackType_STConsLabel(v152, v153, v154);
					VAL v165 = mw_mirth_type_StackType_ZToType(v164);
					VAL v166;
					uint64_t v167;
					VAL v168;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v165, v163, &v166, &v167, &v168);
					VAL v169 = mw_mirth_type_Type_ZToStackType(v168);
					x158 = v169;
					x157 = v167;
					x156 = v166;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v170 = mtw_mirth_type_StackType_STConsLabel(v152, v153, v154);
					x158 = v170;
					x157 = x2;
					x156 = x1;
				} break;
				default: {
					incref(v155);
					VAL v171 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(v154, v155);
					VAL x172;
					uint64_t x173;
					VAL x174;
					switch (get_data_tag(v171)) {
						case 1LL: { // Some
							VAL v175 = mtp_std_maybe_Maybe_1_Some(v171);
							decref(v155);
							VAL v176;
							VAL v177;
							value_uncons(v175, &v176, &v177);
							VAL v178;
							VAL v179;
							value_uncons(v176, &v178, &v179);
							decref(v178);
							VAL v180;
							uint64_t v181;
							VAL v182;
							mw_mirth_type_StackType_unifyZBang(x1, x2, v152, v179, &v180, &v181, &v182);
							VAL v183;
							uint64_t v184;
							VAL v185;
							mw_mirth_type_Type_unifyZBang(v180, v181, v153, v177, &v183, &v184, &v185);
							VAL v186 = mtw_mirth_type_StackType_STConsLabel(v182, v185, v154);
							x174 = v186;
							x173 = v184;
							x172 = v183;
						} break;
						case 0LL: { // None
							VAL v187 = mtw_mirth_type_StackType_STConsLabel(v152, v153, v154);
							VAL v188;
							uint64_t v189;
							VAL v190;
							mw_mirth_type_StackType_unifyZ_failedZBang(x1, x2, v187, v155, &v188, &v189, &v190);
							x174 = v190;
							x173 = v189;
							x172 = v188;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x158 = x174;
					x157 = x173;
					x156 = x172;
				} break;
			}
			x11 = x158;
			x10 = x157;
			x9 = x156;
		} break;
		case 8LL: { // STWithLabel
			VAL v191;
			VAL v192;
			uint64_t v193;
			mtp_mirth_type_StackType_STWithLabel(v8, &v191, &v192, &v193);
			VAL v194 = mw_mirth_type_StackType_expand(x4);
			VAL x195;
			uint64_t x196;
			VAL x197;
			switch (get_data_tag(v194)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v198 = mtw_mirth_type_StackType_STWithLabel(v191, v192, v193);
					VAL v199;
					uint64_t v200;
					VAL v201;
					mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v198, &v199, &v200, &v201);
					x197 = v201;
					x196 = v200;
					x195 = v199;
				} break;
				case 4LL: { // STMeta
					uint64_t v202 = mtp_mirth_type_StackType_STMeta(v194);
					VAL v203 = mtw_mirth_type_StackType_STWithLabel(v191, v192, v193);
					VAL v204 = mw_mirth_type_StackType_ZToType(v203);
					VAL v205;
					uint64_t v206;
					VAL v207;
					mw_mirth_type_MetaVar_unifyZBang(x1, x2, v204, v202, &v205, &v206, &v207);
					VAL v208 = mw_mirth_type_Type_ZToStackType(v207);
					x197 = v208;
					x196 = v206;
					x195 = v205;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v209 = mtw_mirth_type_StackType_STWithLabel(v191, v192, v193);
					x197 = v209;
					x196 = x2;
					x195 = x1;
				} break;
				default: {
					incref(v194);
					VAL v210 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(v193, v194);
					VAL x211;
					uint64_t x212;
					VAL x213;
					switch (get_data_tag(v210)) {
						case 1LL: { // Some
							VAL v214 = mtp_std_maybe_Maybe_1_Some(v210);
							decref(v194);
							VAL v215;
							VAL v216;
							value_uncons(v214, &v215, &v216);
							VAL v217;
							VAL v218;
							value_uncons(v215, &v217, &v218);
							decref(v217);
							VAL v219;
							uint64_t v220;
							VAL v221;
							mw_mirth_type_StackType_unifyZBang(x1, x2, v191, v218, &v219, &v220, &v221);
							VAL v222;
							uint64_t v223;
							VAL v224;
							mw_mirth_type_Resource_unifyZBang(v219, v220, v192, v216, &v222, &v223, &v224);
							VAL v225 = mtw_mirth_type_StackType_STWithLabel(v221, v224, v193);
							x213 = v225;
							x212 = v223;
							x211 = v222;
						} break;
						case 0LL: { // None
							VAL v226 = mtw_mirth_type_StackType_STWithLabel(v191, v192, v193);
							VAL v227;
							uint64_t v228;
							VAL v229;
							mw_mirth_type_StackType_unifyZ_failedZBang(x1, x2, v226, v194, &v227, &v228, &v229);
							x213 = v229;
							x212 = v228;
							x211 = v227;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x197 = x213;
					x196 = x212;
					x195 = x211;
				} break;
			}
			x11 = x197;
			x10 = x196;
			x9 = x195;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
}
static void mw_mirth_type_StackType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_StackType_expand(x3);
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v11 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v11;
			x9 = x2;
			x8 = x1;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v12 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v12;
			x9 = x2;
			x8 = x1;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v13 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v13;
			x9 = x2;
			x8 = x1;
		} break;
		case 4LL: { // STMeta
			uint64_t v14 = mtp_mirth_type_StackType_STMeta(v7);
			VAL v15;
			uint64_t v16;
			VAL v17;
			mw_mirth_type_MetaVar_unifyZ_errorZBang(x1, x2, v14, &v15, &v16, &v17);
			VAL v18 = mw_mirth_type_Type_ZToStackType(v17);
			x10 = v18;
			x9 = v16;
			x8 = v15;
		} break;
		case 3LL: { // STVar
			uint64_t v19 = mtp_mirth_type_StackType_STVar(v7);
			VAL v20 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v20;
			x9 = x2;
			x8 = x1;
		} break;
		case 5LL: { // STCons
			VAL v21;
			VAL v22;
			mtp_mirth_type_StackType_STCons(v7, &v21, &v22);
			VAL v23;
			uint64_t v24;
			VAL v25;
			mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v21, &v23, &v24, &v25);
			decref(v25);
			VAL v26;
			uint64_t v27;
			VAL v28;
			mw_mirth_type_Type_unifyZ_errorZBang(v23, v24, v22, &v26, &v27, &v28);
			decref(v28);
			VAL v29 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v29;
			x9 = v27;
			x8 = v26;
		} break;
		case 7LL: { // STWith
			VAL v30;
			VAL v31;
			mtp_mirth_type_StackType_STWith(v7, &v30, &v31);
			VAL v32;
			uint64_t v33;
			VAL v34;
			mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v30, &v32, &v33, &v34);
			decref(v34);
			VAL v35;
			uint64_t v36;
			VAL v37;
			mw_mirth_type_Resource_unifyZ_errorZBang(v32, v33, v31, &v35, &v36, &v37);
			decref(v37);
			VAL v38 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v38;
			x9 = v36;
			x8 = v35;
		} break;
		case 6LL: { // STConsLabel
			VAL v39;
			VAL v40;
			uint64_t v41;
			mtp_mirth_type_StackType_STConsLabel(v7, &v39, &v40, &v41);
			VAL v42;
			uint64_t v43;
			VAL v44;
			mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v39, &v42, &v43, &v44);
			decref(v44);
			VAL v45;
			uint64_t v46;
			VAL v47;
			mw_mirth_type_Type_unifyZ_errorZBang(v42, v43, v40, &v45, &v46, &v47);
			decref(v47);
			VAL v48 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v48;
			x9 = v46;
			x8 = v45;
		} break;
		case 8LL: { // STWithLabel
			VAL v49;
			VAL v50;
			uint64_t v51;
			mtp_mirth_type_StackType_STWithLabel(v7, &v49, &v50, &v51);
			VAL v52;
			uint64_t v53;
			VAL v54;
			mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v49, &v52, &v53, &v54);
			decref(v54);
			VAL v55;
			uint64_t v56;
			VAL v57;
			mw_mirth_type_Resource_unifyZ_errorZBang(v52, v53, v50, &v55, &v56, &v57);
			decref(v57);
			VAL v58 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x10 = v58;
			x9 = v56;
			x8 = v55;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static VAL mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_type_StackType_expand(x2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v5 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v6 = MKI64(0LL /* TYPE_ERROR */);
			VAL v7 = MKNIL;
			VAL v8 = mkcons(v7, v5);
			VAL v9 = mkcons(v8, v6);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			x4 = v10;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v11 = MKI64(1LL /* STACK_TYPE_DONT_CARE */);
			VAL v12 = MKI64(1LL /* TYPE_DONT_CARE */);
			VAL v13 = MKNIL;
			VAL v14 = mkcons(v13, v11);
			VAL v15 = mkcons(v14, v12);
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v15);
			x4 = v16;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v17 = MKI64(0LL /* None */);
			x4 = v17;
		} break;
		case 3LL: { // STVar
			uint64_t v18 = mtp_mirth_type_StackType_STVar(v3);
			VAL v19 = MKI64(0LL /* None */);
			x4 = v19;
		} break;
		case 7LL: { // STWith
			VAL v20;
			VAL v21;
			mtp_mirth_type_StackType_STWith(v3, &v20, &v21);
			VAL v22 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(x1, v20);
			VAL x23;
			VAL x24;
			switch (get_data_tag(v22)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v22);
					VAL v26;
					VAL v27;
					value_uncons(v25, &v26, &v27);
					VAL v28;
					VAL v29;
					value_uncons(v26, &v28, &v29);
					decref(v28);
					incref(v21);
					VAL v30 = mtw_mirth_type_StackType_STWith(v29, v21);
					VAL v31 = MKNIL;
					VAL v32 = mkcons(v31, v30);
					VAL v33 = mkcons(v32, v27);
					VAL v34 = mtw_std_maybe_Maybe_1_Some(v33);
					x24 = v34;
					x23 = v21;
				} break;
				case 0LL: { // None
					VAL v35 = MKI64(0LL /* None */);
					x24 = v35;
					x23 = v21;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x23);
			x4 = x24;
		} break;
		case 5LL: { // STCons
			VAL v36;
			VAL v37;
			mtp_mirth_type_StackType_STCons(v3, &v36, &v37);
			VAL v38 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(x1, v36);
			VAL x39;
			VAL x40;
			switch (get_data_tag(v38)) {
				case 1LL: { // Some
					VAL v41 = mtp_std_maybe_Maybe_1_Some(v38);
					VAL v42;
					VAL v43;
					value_uncons(v41, &v42, &v43);
					VAL v44;
					VAL v45;
					value_uncons(v42, &v44, &v45);
					decref(v44);
					incref(v37);
					VAL v46 = mtw_mirth_type_StackType_STCons(v45, v37);
					VAL v47 = MKNIL;
					VAL v48 = mkcons(v47, v46);
					VAL v49 = mkcons(v48, v43);
					VAL v50 = mtw_std_maybe_Maybe_1_Some(v49);
					x40 = v50;
					x39 = v37;
				} break;
				case 0LL: { // None
					VAL v51 = MKI64(0LL /* None */);
					x40 = v51;
					x39 = v37;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x39);
			x4 = x40;
		} break;
		case 6LL: { // STConsLabel
			VAL v52;
			VAL v53;
			uint64_t v54;
			mtp_mirth_type_StackType_STConsLabel(v3, &v52, &v53, &v54);
			int64_t v55 = mw_mirth_label_Label_ZEqualZEqual(x1, v54);
			VAL x56;
			if (((bool)v55)) {
				VAL v57 = MKNIL;
				VAL v58 = mkcons(v57, v52);
				VAL v59 = mkcons(v58, v53);
				VAL v60 = mtw_std_maybe_Maybe_1_Some(v59);
				x56 = v60;
			} else {
				VAL v61 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(x1, v52);
				VAL x62;
				switch (get_data_tag(v61)) {
					case 1LL: { // Some
						VAL v63 = mtp_std_maybe_Maybe_1_Some(v61);
						VAL v64;
						VAL v65;
						value_uncons(v63, &v64, &v65);
						VAL v66;
						VAL v67;
						value_uncons(v64, &v66, &v67);
						decref(v66);
						VAL v68 = mtw_mirth_type_StackType_STConsLabel(v67, v53, v54);
						VAL v69 = MKNIL;
						VAL v70 = mkcons(v69, v68);
						VAL v71 = mkcons(v70, v65);
						VAL v72 = mtw_std_maybe_Maybe_1_Some(v71);
						x62 = v72;
					} break;
					case 0LL: { // None
						decref(v53);
						VAL v73 = MKI64(0LL /* None */);
						x62 = v73;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x56 = x62;
			}
			x4 = x56;
		} break;
		case 8LL: { // STWithLabel
			VAL v74;
			VAL v75;
			uint64_t v76;
			mtp_mirth_type_StackType_STWithLabel(v3, &v74, &v75, &v76);
			int64_t v77 = mw_mirth_label_Label_ZEqualZEqual(x1, v76);
			VAL x78;
			if (((bool)v77)) {
				decref(v75);
				decref(v74);
				VAL v79 = MKI64(0LL /* None */);
				x78 = v79;
			} else {
				VAL v80 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(x1, v74);
				VAL x81;
				switch (get_data_tag(v80)) {
					case 1LL: { // Some
						VAL v82 = mtp_std_maybe_Maybe_1_Some(v80);
						VAL v83;
						VAL v84;
						value_uncons(v82, &v83, &v84);
						VAL v85;
						VAL v86;
						value_uncons(v83, &v85, &v86);
						decref(v85);
						VAL v87 = mtw_mirth_type_StackType_STWithLabel(v86, v75, v76);
						VAL v88 = MKNIL;
						VAL v89 = mkcons(v88, v87);
						VAL v90 = mkcons(v89, v84);
						VAL v91 = mtw_std_maybe_Maybe_1_Some(v90);
						x81 = v91;
					} break;
					case 0LL: { // None
						decref(v75);
						VAL v92 = MKI64(0LL /* None */);
						x81 = v92;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x78 = x81;
			}
			x4 = x78;
		} break;
		case 4LL: { // STMeta
			uint64_t v93 = mtp_mirth_type_StackType_STMeta(v3);
			uint64_t v94 = mw_mirth_type_MetaVar_newZBang();
			VAL v95 = mtw_mirth_type_StackType_STMeta(v94);
			uint64_t v96 = mw_mirth_type_MetaVar_newZBang();
			VAL v97 = mtw_mirth_type_Type_TMeta(v96);
			incref(v95);
			incref(v97);
			VAL v98 = mtw_mirth_type_StackType_STConsLabel(v95, v97, x1);
			VAL v99 = mw_mirth_type_StackType_ZToType(v98);
			VAL v100 = mtw_std_maybe_Maybe_1_Some(v99);
			void* v101 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v93);
			mut_set(v100, v101);
			VAL v102 = MKNIL;
			VAL v103 = mkcons(v102, v95);
			VAL v104 = mkcons(v103, v97);
			VAL v105 = mtw_std_maybe_Maybe_1_Some(v104);
			x4 = v105;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_type_StackType_expand(x2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v5 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v6 = MKI64(0LL /* TYPE_ERROR */);
			VAL v7 = MKNIL;
			VAL v8 = mkcons(v7, v5);
			VAL v9 = mkcons(v8, v6);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			x4 = v10;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v11 = MKI64(1LL /* STACK_TYPE_DONT_CARE */);
			VAL v12 = MKI64(1LL /* TYPE_DONT_CARE */);
			VAL v13 = MKNIL;
			VAL v14 = mkcons(v13, v11);
			VAL v15 = mkcons(v14, v12);
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v15);
			x4 = v16;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v17 = MKI64(0LL /* None */);
			x4 = v17;
		} break;
		case 3LL: { // STVar
			uint64_t v18 = mtp_mirth_type_StackType_STVar(v3);
			VAL v19 = MKI64(0LL /* None */);
			x4 = v19;
		} break;
		case 7LL: { // STWith
			VAL v20;
			VAL v21;
			mtp_mirth_type_StackType_STWith(v3, &v20, &v21);
			VAL v22 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(x1, v20);
			VAL x23;
			VAL x24;
			switch (get_data_tag(v22)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v22);
					VAL v26;
					VAL v27;
					value_uncons(v25, &v26, &v27);
					VAL v28;
					VAL v29;
					value_uncons(v26, &v28, &v29);
					decref(v28);
					incref(v21);
					VAL v30 = mtw_mirth_type_StackType_STWith(v29, v21);
					VAL v31 = MKNIL;
					VAL v32 = mkcons(v31, v30);
					VAL v33 = mkcons(v32, v27);
					VAL v34 = mtw_std_maybe_Maybe_1_Some(v33);
					x24 = v34;
					x23 = v21;
				} break;
				case 0LL: { // None
					VAL v35 = MKI64(0LL /* None */);
					x24 = v35;
					x23 = v21;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x23);
			x4 = x24;
		} break;
		case 5LL: { // STCons
			VAL v36;
			VAL v37;
			mtp_mirth_type_StackType_STCons(v3, &v36, &v37);
			VAL v38 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(x1, v36);
			VAL x39;
			VAL x40;
			switch (get_data_tag(v38)) {
				case 1LL: { // Some
					VAL v41 = mtp_std_maybe_Maybe_1_Some(v38);
					VAL v42;
					VAL v43;
					value_uncons(v41, &v42, &v43);
					VAL v44;
					VAL v45;
					value_uncons(v42, &v44, &v45);
					decref(v44);
					incref(v37);
					VAL v46 = mtw_mirth_type_StackType_STCons(v45, v37);
					VAL v47 = MKNIL;
					VAL v48 = mkcons(v47, v46);
					VAL v49 = mkcons(v48, v43);
					VAL v50 = mtw_std_maybe_Maybe_1_Some(v49);
					x40 = v50;
					x39 = v37;
				} break;
				case 0LL: { // None
					VAL v51 = MKI64(0LL /* None */);
					x40 = v51;
					x39 = v37;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x39);
			x4 = x40;
		} break;
		case 6LL: { // STConsLabel
			VAL v52;
			VAL v53;
			uint64_t v54;
			mtp_mirth_type_StackType_STConsLabel(v3, &v52, &v53, &v54);
			int64_t v55 = mw_mirth_label_Label_ZEqualZEqual(x1, v54);
			VAL x56;
			if (((bool)v55)) {
				decref(v53);
				decref(v52);
				VAL v57 = MKI64(0LL /* None */);
				x56 = v57;
			} else {
				VAL v58 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(x1, v52);
				VAL x59;
				switch (get_data_tag(v58)) {
					case 1LL: { // Some
						VAL v60 = mtp_std_maybe_Maybe_1_Some(v58);
						VAL v61;
						VAL v62;
						value_uncons(v60, &v61, &v62);
						VAL v63;
						VAL v64;
						value_uncons(v61, &v63, &v64);
						decref(v63);
						VAL v65 = mtw_mirth_type_StackType_STConsLabel(v64, v53, v54);
						VAL v66 = MKNIL;
						VAL v67 = mkcons(v66, v65);
						VAL v68 = mkcons(v67, v62);
						VAL v69 = mtw_std_maybe_Maybe_1_Some(v68);
						x59 = v69;
					} break;
					case 0LL: { // None
						decref(v53);
						VAL v70 = MKI64(0LL /* None */);
						x59 = v70;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x56 = x59;
			}
			x4 = x56;
		} break;
		case 8LL: { // STWithLabel
			VAL v71;
			VAL v72;
			uint64_t v73;
			mtp_mirth_type_StackType_STWithLabel(v3, &v71, &v72, &v73);
			int64_t v74 = mw_mirth_label_Label_ZEqualZEqual(x1, v73);
			VAL x75;
			if (((bool)v74)) {
				VAL v76 = MKNIL;
				VAL v77 = mkcons(v76, v71);
				VAL v78 = mkcons(v77, v72);
				VAL v79 = mtw_std_maybe_Maybe_1_Some(v78);
				x75 = v79;
			} else {
				VAL v80 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(x1, v71);
				VAL x81;
				switch (get_data_tag(v80)) {
					case 1LL: { // Some
						VAL v82 = mtp_std_maybe_Maybe_1_Some(v80);
						VAL v83;
						VAL v84;
						value_uncons(v82, &v83, &v84);
						VAL v85;
						VAL v86;
						value_uncons(v83, &v85, &v86);
						decref(v85);
						VAL v87 = mtw_mirth_type_StackType_STWithLabel(v86, v72, v73);
						VAL v88 = MKNIL;
						VAL v89 = mkcons(v88, v87);
						VAL v90 = mkcons(v89, v84);
						VAL v91 = mtw_std_maybe_Maybe_1_Some(v90);
						x81 = v91;
					} break;
					case 0LL: { // None
						decref(v72);
						VAL v92 = MKI64(0LL /* None */);
						x81 = v92;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x75 = x81;
			}
			x4 = x75;
		} break;
		case 4LL: { // STMeta
			uint64_t v93 = mtp_mirth_type_StackType_STMeta(v3);
			uint64_t v94 = mw_mirth_type_MetaVar_newZBang();
			VAL v95 = mtw_mirth_type_StackType_STMeta(v94);
			uint64_t v96 = mw_mirth_type_MetaVar_newZBang();
			VAL v97 = mtw_mirth_type_Type_TMeta(v96);
			incref(v95);
			incref(v97);
			VAL v98 = mtw_mirth_type_StackType_STWithLabel(v95, v97, x1);
			VAL v99 = mw_mirth_type_StackType_ZToType(v98);
			VAL v100 = mtw_std_maybe_Maybe_1_Some(v99);
			void* v101 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v93);
			mut_set(v100, v101);
			VAL v102 = MKNIL;
			VAL v103 = mkcons(v102, v95);
			VAL v104 = mkcons(v103, v97);
			VAL v105 = mtw_std_maybe_Maybe_1_Some(v104);
			x4 = v105;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_type_StackType_forceZ_consZAskZBang (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v4 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v5 = MKI64(0LL /* TYPE_ERROR */);
			VAL v6 = MKNIL;
			VAL v7 = mkcons(v6, v4);
			VAL v8 = mkcons(v7, v5);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			x3 = v9;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v10 = MKI64(1LL /* STACK_TYPE_DONT_CARE */);
			VAL v11 = MKI64(1LL /* TYPE_DONT_CARE */);
			VAL v12 = MKNIL;
			VAL v13 = mkcons(v12, v10);
			VAL v14 = mkcons(v13, v11);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
			x3 = v15;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v16 = MKI64(0LL /* None */);
			x3 = v16;
		} break;
		case 3LL: { // STVar
			uint64_t v17 = mtp_mirth_type_StackType_STVar(v2);
			VAL v18 = MKI64(0LL /* None */);
			x3 = v18;
		} break;
		case 5LL: { // STCons
			VAL v19;
			VAL v20;
			mtp_mirth_type_StackType_STCons(v2, &v19, &v20);
			VAL v21 = MKNIL;
			VAL v22 = mkcons(v21, v19);
			VAL v23 = mkcons(v22, v20);
			VAL v24 = mtw_std_maybe_Maybe_1_Some(v23);
			x3 = v24;
		} break;
		case 7LL: { // STWith
			VAL v25;
			VAL v26;
			mtp_mirth_type_StackType_STWith(v2, &v25, &v26);
			VAL v27 = mw_mirth_type_StackType_forceZ_consZAskZBang(v25);
			VAL x28;
			VAL x29;
			switch (get_data_tag(v27)) {
				case 1LL: { // Some
					VAL v30 = mtp_std_maybe_Maybe_1_Some(v27);
					VAL v31;
					VAL v32;
					value_uncons(v30, &v31, &v32);
					VAL v33;
					VAL v34;
					value_uncons(v31, &v33, &v34);
					decref(v33);
					incref(v26);
					VAL v35 = mtw_mirth_type_StackType_STWith(v34, v26);
					VAL v36 = MKNIL;
					VAL v37 = mkcons(v36, v35);
					VAL v38 = mkcons(v37, v32);
					VAL v39 = mtw_std_maybe_Maybe_1_Some(v38);
					x29 = v39;
					x28 = v26;
				} break;
				case 0LL: { // None
					VAL v40 = MKI64(0LL /* None */);
					x29 = v40;
					x28 = v26;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x28);
			x3 = x29;
		} break;
		case 6LL: { // STConsLabel
			VAL v41;
			VAL v42;
			uint64_t v43;
			mtp_mirth_type_StackType_STConsLabel(v2, &v41, &v42, &v43);
			VAL v44 = mw_mirth_type_StackType_forceZ_consZAskZBang(v41);
			VAL x45;
			switch (get_data_tag(v44)) {
				case 1LL: { // Some
					VAL v46 = mtp_std_maybe_Maybe_1_Some(v44);
					VAL v47;
					VAL v48;
					value_uncons(v46, &v47, &v48);
					VAL v49;
					VAL v50;
					value_uncons(v47, &v49, &v50);
					decref(v49);
					VAL v51 = mtw_mirth_type_StackType_STConsLabel(v50, v42, v43);
					VAL v52 = MKNIL;
					VAL v53 = mkcons(v52, v51);
					VAL v54 = mkcons(v53, v48);
					VAL v55 = mtw_std_maybe_Maybe_1_Some(v54);
					x45 = v55;
				} break;
				case 0LL: { // None
					decref(v42);
					VAL v56 = MKI64(0LL /* None */);
					x45 = v56;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x45;
		} break;
		case 8LL: { // STWithLabel
			VAL v57;
			VAL v58;
			uint64_t v59;
			mtp_mirth_type_StackType_STWithLabel(v2, &v57, &v58, &v59);
			VAL v60 = mw_mirth_type_StackType_forceZ_consZAskZBang(v57);
			VAL x61;
			switch (get_data_tag(v60)) {
				case 1LL: { // Some
					VAL v62 = mtp_std_maybe_Maybe_1_Some(v60);
					VAL v63;
					VAL v64;
					value_uncons(v62, &v63, &v64);
					VAL v65;
					VAL v66;
					value_uncons(v63, &v65, &v66);
					decref(v65);
					VAL v67 = mtw_mirth_type_StackType_STWithLabel(v66, v58, v59);
					VAL v68 = MKNIL;
					VAL v69 = mkcons(v68, v67);
					VAL v70 = mkcons(v69, v64);
					VAL v71 = mtw_std_maybe_Maybe_1_Some(v70);
					x61 = v71;
				} break;
				case 0LL: { // None
					decref(v58);
					VAL v72 = MKI64(0LL /* None */);
					x61 = v72;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x61;
		} break;
		case 4LL: { // STMeta
			uint64_t v73 = mtp_mirth_type_StackType_STMeta(v2);
			uint64_t v74 = mw_mirth_type_MetaVar_newZBang();
			VAL v75 = mtw_mirth_type_StackType_STMeta(v74);
			uint64_t v76 = mw_mirth_type_MetaVar_newZBang();
			VAL v77 = mtw_mirth_type_Type_TMeta(v76);
			incref(v75);
			incref(v77);
			VAL v78 = mtw_mirth_type_StackType_STCons(v75, v77);
			VAL v79 = mw_mirth_type_StackType_ZToType(v78);
			VAL v80 = mtw_std_maybe_Maybe_1_Some(v79);
			void* v81 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v73);
			mut_set(v80, v81);
			VAL v82 = MKNIL;
			VAL v83 = mkcons(v82, v75);
			VAL v84 = mkcons(v83, v77);
			VAL v85 = mtw_std_maybe_Maybe_1_Some(v84);
			x3 = v85;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_StackType_forceZ_withZAskZBang (VAL x1) {
	VAL v2 = mw_mirth_type_StackType_expand(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v4 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v5 = MKI64(0LL /* TYPE_ERROR */);
			VAL v6 = MKNIL;
			VAL v7 = mkcons(v6, v4);
			VAL v8 = mkcons(v7, v5);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			x3 = v9;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v10 = MKI64(1LL /* STACK_TYPE_DONT_CARE */);
			VAL v11 = MKI64(1LL /* TYPE_DONT_CARE */);
			VAL v12 = MKNIL;
			VAL v13 = mkcons(v12, v10);
			VAL v14 = mkcons(v13, v11);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
			x3 = v15;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v16 = MKI64(0LL /* None */);
			x3 = v16;
		} break;
		case 3LL: { // STVar
			uint64_t v17 = mtp_mirth_type_StackType_STVar(v2);
			VAL v18 = MKI64(0LL /* None */);
			x3 = v18;
		} break;
		case 7LL: { // STWith
			VAL v19;
			VAL v20;
			mtp_mirth_type_StackType_STWith(v2, &v19, &v20);
			VAL v21 = MKNIL;
			VAL v22 = mkcons(v21, v19);
			VAL v23 = mkcons(v22, v20);
			VAL v24 = mtw_std_maybe_Maybe_1_Some(v23);
			x3 = v24;
		} break;
		case 5LL: { // STCons
			VAL v25;
			VAL v26;
			mtp_mirth_type_StackType_STCons(v2, &v25, &v26);
			VAL v27 = mw_mirth_type_StackType_forceZ_withZAskZBang(v25);
			VAL x28;
			VAL x29;
			switch (get_data_tag(v27)) {
				case 1LL: { // Some
					VAL v30 = mtp_std_maybe_Maybe_1_Some(v27);
					VAL v31;
					VAL v32;
					value_uncons(v30, &v31, &v32);
					VAL v33;
					VAL v34;
					value_uncons(v31, &v33, &v34);
					decref(v33);
					incref(v26);
					VAL v35 = mtw_mirth_type_StackType_STCons(v34, v26);
					VAL v36 = MKNIL;
					VAL v37 = mkcons(v36, v35);
					VAL v38 = mkcons(v37, v32);
					VAL v39 = mtw_std_maybe_Maybe_1_Some(v38);
					x29 = v39;
					x28 = v26;
				} break;
				case 0LL: { // None
					VAL v40 = MKI64(0LL /* None */);
					x29 = v40;
					x28 = v26;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x28);
			x3 = x29;
		} break;
		case 6LL: { // STConsLabel
			VAL v41;
			VAL v42;
			uint64_t v43;
			mtp_mirth_type_StackType_STConsLabel(v2, &v41, &v42, &v43);
			VAL v44 = mw_mirth_type_StackType_forceZ_withZAskZBang(v41);
			VAL x45;
			switch (get_data_tag(v44)) {
				case 1LL: { // Some
					VAL v46 = mtp_std_maybe_Maybe_1_Some(v44);
					VAL v47;
					VAL v48;
					value_uncons(v46, &v47, &v48);
					VAL v49;
					VAL v50;
					value_uncons(v47, &v49, &v50);
					decref(v49);
					VAL v51 = mtw_mirth_type_StackType_STConsLabel(v50, v42, v43);
					VAL v52 = MKNIL;
					VAL v53 = mkcons(v52, v51);
					VAL v54 = mkcons(v53, v48);
					VAL v55 = mtw_std_maybe_Maybe_1_Some(v54);
					x45 = v55;
				} break;
				case 0LL: { // None
					decref(v42);
					VAL v56 = MKI64(0LL /* None */);
					x45 = v56;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x45;
		} break;
		case 8LL: { // STWithLabel
			VAL v57;
			VAL v58;
			uint64_t v59;
			mtp_mirth_type_StackType_STWithLabel(v2, &v57, &v58, &v59);
			VAL v60 = mw_mirth_type_StackType_forceZ_withZAskZBang(v57);
			VAL x61;
			switch (get_data_tag(v60)) {
				case 1LL: { // Some
					VAL v62 = mtp_std_maybe_Maybe_1_Some(v60);
					VAL v63;
					VAL v64;
					value_uncons(v62, &v63, &v64);
					VAL v65;
					VAL v66;
					value_uncons(v63, &v65, &v66);
					decref(v65);
					VAL v67 = mtw_mirth_type_StackType_STWithLabel(v66, v58, v59);
					VAL v68 = MKNIL;
					VAL v69 = mkcons(v68, v67);
					VAL v70 = mkcons(v69, v64);
					VAL v71 = mtw_std_maybe_Maybe_1_Some(v70);
					x61 = v71;
				} break;
				case 0LL: { // None
					decref(v58);
					VAL v72 = MKI64(0LL /* None */);
					x61 = v72;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x61;
		} break;
		case 4LL: { // STMeta
			uint64_t v73 = mtp_mirth_type_StackType_STMeta(v2);
			uint64_t v74 = mw_mirth_type_MetaVar_newZBang();
			VAL v75 = mtw_mirth_type_StackType_STMeta(v74);
			uint64_t v76 = mw_mirth_type_MetaVar_newZBang();
			VAL v77 = mtw_mirth_type_Type_TMeta(v76);
			incref(v75);
			incref(v77);
			VAL v78 = mtw_mirth_type_StackType_STWith(v75, v77);
			VAL v79 = mw_mirth_type_StackType_ZToType(v78);
			VAL v80 = mtw_std_maybe_Maybe_1_Some(v79);
			void* v81 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v73);
			mut_set(v80, v81);
			VAL v82 = MKNIL;
			VAL v83 = mkcons(v82, v75);
			VAL v84 = mkcons(v83, v77);
			VAL v85 = mtw_std_maybe_Maybe_1_Some(v84);
			x3 = v85;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_StackType_domZThen (VAL x1, VAL x2) {
	VAL v3 = mw_mirth_type_StackType_expand(x2);
	incref(v3);
	int64_t v4 = mw_mirth_type_StackType_unitZAsk(v3);
	VAL x5;
	if (((bool)v4)) {
		decref(v3);
		x5 = x1;
	} else {
		VAL v6 = (mw_mirth_type_StackType_stackZThen(x1, v3));
		STR* v7;
		STRLIT(v7, " ", 1);
		VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
		x5 = v8;
	}
	return x5;
}
static VAL mw_mirth_type_StackType_codZThen (VAL x1, VAL x2) {
	VAL v3 = mw_mirth_type_StackType_expand(x2);
	incref(v3);
	int64_t v4 = mw_mirth_type_StackType_unitZAsk(v3);
	VAL x5;
	if (((bool)v4)) {
		decref(v3);
		x5 = x1;
	} else {
		STR* v6;
		STRLIT(v6, " ", 1);
		VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), x1));
		VAL v8 = (mw_mirth_type_StackType_stackZThen(v7, v3));
		x5 = v8;
	}
	return x5;
}
static void mw_mirth_type_StackType_baseZThen (VAL x1, VAL x2, VAL *x3, int64_t *x4) {
	VAL x5;
	int64_t x6;
	switch (get_data_tag(x2)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v7 = 0LL /* False */;
			x6 = v7;
			x5 = x1;
		} break;
		case 4LL: { // STMeta
			uint64_t v8 = mtp_mirth_type_StackType_STMeta(x2);
			STR* v9;
			STRLIT(v9, "*", 1);
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), x1));
			VAL v11 = (mw_mirth_type_MetaVar_typeZThen(v10, v8));
			int64_t v12 = 1LL /* True */;
			x6 = v12;
			x5 = v11;
		} break;
		case 3LL: { // STVar
			uint64_t v13 = mtp_mirth_type_StackType_STVar(x2);
			int64_t v14 = mw_mirth_var_Var_isZ_stackZAsk(v13);
			VAL x15;
			uint64_t x16;
			if (((bool)v14)) {
				x16 = v13;
				x15 = x1;
			} else {
				STR* v17;
				STRLIT(v17, "* ", 2);
				VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v17), x1));
				x16 = v13;
				x15 = v18;
			}
			VAL v19 = (mw_mirth_var_Var_typeZThen(x15, x16));
			int64_t v20 = 1LL /* True */;
			x6 = v20;
			x5 = v19;
		} break;
		default: {
			VAL v21 = mw_mirth_type_StackType_ZToType(x2);
			STR* v22;
			STRLIT(v22, "* ", 2);
			VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v22), x1));
			VAL v24 = (mw_mirth_type_Type_typeZThen(v21, v23));
			int64_t v25 = 1LL /* True */;
			x6 = v25;
			x5 = v24;
		} break;
	}
	*x4 = x6;
	*x3 = x5;
}
static VAL mw_mirth_type_StackType_stackZThen (VAL x1, VAL x2) {
	VAL v3;
	VAL v4;
	VAL v5;
	VAL v6;
	mw_mirth_type_StackType_split4(x2, &v3, &v4, &v5, &v6);
	VAL v7;
	int64_t v8;
	mw_mirth_type_StackType_baseZThen(x1, v3, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_std_list_List_1_uncons(v4, &v9, &v10);
	VAL x11;
	int64_t x12;
	VAL x13;
	int64_t x14;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v9);
			VAL x16;
			VAL x17;
			if (((bool)v8)) {
				STR* v18;
				STRLIT(v18, " ", 1);
				VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), v7));
				x17 = v15;
				x16 = v19;
			} else {
				x17 = v15;
				x16 = v7;
			}
			VAL v20;
			VAL v21;
			value_uncons(x17, &v20, &v21);
			VAL v22;
			VAL v23;
			value_uncons(v20, &v22, &v23);
			decref(v22);
			VAL v24 = mw_mirth_label_Label_ZToStr(VU64(v21));
			VAL v25 = (mw_std_str_ZPlusStr_pushZ_strZBang(v24, x16));
			STR* v26;
			STRLIT(v26, ":", 1);
			VAL v27 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v26), v25));
			VAL x28;
			switch (get_data_tag(v23)) {
				case 0LL: { // Left
					VAL v29 = mtp_std_either_Either_2_Left(v23);
					VAL v30 = (mw_mirth_type_Type_typeZThen(v29, v27));
					x28 = v30;
				} break;
				case 1LL: { // Right
					VAL v31 = mtp_std_either_Either_2_Right(v23);
					VAL v32 = (mw_mirth_type_Resource_typeZThen(v27, v31));
					x28 = v32;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v33 = 1LL /* True */;
			int64_t v34 = 1LL /* True */;
			x14 = v34;
			x13 = v10;
			x12 = v33;
			x11 = x28;
		} break;
		case 0LL: { // None
			int64_t v35 = 0LL /* False */;
			x14 = v35;
			x13 = v10;
			x12 = v8;
			x11 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v36 = (x11);
	int64_t v37 = x12;
	VAL v38 = x13;
	int64_t v39 = x14;
	while (((bool)v39)) {
		VAL v40 = (v36);
		int64_t v41 = v37;
		VAL v42 = v38;
		VAL v43;
		VAL v44;
		mw_std_list_List_1_uncons(v42, &v43, &v44);
		VAL x45;
		int64_t x46;
		VAL x47;
		int64_t x48;
		switch (get_data_tag(v43)) {
			case 1LL: { // Some
				VAL v49 = mtp_std_maybe_Maybe_1_Some(v43);
				VAL x50;
				VAL x51;
				if (((bool)v41)) {
					STR* v52;
					STRLIT(v52, " ", 1);
					VAL v53 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v52), v40));
					x51 = v49;
					x50 = v53;
				} else {
					x51 = v49;
					x50 = v40;
				}
				VAL v54;
				VAL v55;
				value_uncons(x51, &v54, &v55);
				VAL v56;
				VAL v57;
				value_uncons(v54, &v56, &v57);
				decref(v56);
				VAL v58 = mw_mirth_label_Label_ZToStr(VU64(v55));
				VAL v59 = (mw_std_str_ZPlusStr_pushZ_strZBang(v58, x50));
				STR* v60;
				STRLIT(v60, ":", 1);
				VAL v61 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v60), v59));
				VAL x62;
				switch (get_data_tag(v57)) {
					case 0LL: { // Left
						VAL v63 = mtp_std_either_Either_2_Left(v57);
						VAL v64 = (mw_mirth_type_Type_typeZThen(v63, v61));
						x62 = v64;
					} break;
					case 1LL: { // Right
						VAL v65 = mtp_std_either_Either_2_Right(v57);
						VAL v66 = (mw_mirth_type_Resource_typeZThen(v61, v65));
						x62 = v66;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v67 = 1LL /* True */;
				int64_t v68 = 1LL /* True */;
				x48 = v68;
				x47 = v44;
				x46 = v67;
				x45 = x62;
			} break;
			case 0LL: { // None
				int64_t v69 = 0LL /* False */;
				x48 = v69;
				x47 = v44;
				x46 = v41;
				x45 = v40;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v39 = x48;
		v38 = x47;
		v37 = x46;
		v36 = x45;
	}
	decref(v38);
	VAL v70;
	VAL v71;
	mw_std_list_List_1_uncons(v5, &v70, &v71);
	VAL x72;
	int64_t x73;
	VAL x74;
	int64_t x75;
	switch (get_data_tag(v70)) {
		case 1LL: { // Some
			VAL v76 = mtp_std_maybe_Maybe_1_Some(v70);
			VAL x77;
			VAL x78;
			if (((bool)v37)) {
				STR* v79;
				STRLIT(v79, " ", 1);
				VAL v80 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v79), v36));
				x78 = v76;
				x77 = v80;
			} else {
				x78 = v76;
				x77 = v36;
			}
			VAL v81 = (mw_mirth_type_Type_typeZThen(x78, x77));
			int64_t v82 = 1LL /* True */;
			int64_t v83 = 1LL /* True */;
			x75 = v83;
			x74 = v71;
			x73 = v82;
			x72 = v81;
		} break;
		case 0LL: { // None
			int64_t v84 = 0LL /* False */;
			x75 = v84;
			x74 = v71;
			x73 = v37;
			x72 = v36;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v85 = (x72);
	int64_t v86 = x73;
	VAL v87 = x74;
	int64_t v88 = x75;
	while (((bool)v88)) {
		VAL v89 = (v85);
		int64_t v90 = v86;
		VAL v91 = v87;
		VAL v92;
		VAL v93;
		mw_std_list_List_1_uncons(v91, &v92, &v93);
		VAL x94;
		int64_t x95;
		VAL x96;
		int64_t x97;
		switch (get_data_tag(v92)) {
			case 1LL: { // Some
				VAL v98 = mtp_std_maybe_Maybe_1_Some(v92);
				VAL x99;
				VAL x100;
				if (((bool)v90)) {
					STR* v101;
					STRLIT(v101, " ", 1);
					VAL v102 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v101), v89));
					x100 = v98;
					x99 = v102;
				} else {
					x100 = v98;
					x99 = v89;
				}
				VAL v103 = (mw_mirth_type_Type_typeZThen(x100, x99));
				int64_t v104 = 1LL /* True */;
				int64_t v105 = 1LL /* True */;
				x97 = v105;
				x96 = v93;
				x95 = v104;
				x94 = v103;
			} break;
			case 0LL: { // None
				int64_t v106 = 0LL /* False */;
				x97 = v106;
				x96 = v93;
				x95 = v90;
				x94 = v89;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v88 = x97;
		v87 = x96;
		v86 = x95;
		v85 = x94;
	}
	decref(v87);
	VAL v107;
	VAL v108;
	mw_std_list_List_1_uncons(v6, &v107, &v108);
	VAL x109;
	int64_t x110;
	VAL x111;
	int64_t x112;
	switch (get_data_tag(v107)) {
		case 1LL: { // Some
			VAL v113 = mtp_std_maybe_Maybe_1_Some(v107);
			VAL x114;
			VAL x115;
			if (((bool)v86)) {
				STR* v116;
				STRLIT(v116, " ", 1);
				VAL v117 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v116), v85));
				x115 = v113;
				x114 = v117;
			} else {
				x115 = v113;
				x114 = v85;
			}
			VAL v118 = (mw_mirth_type_Resource_typeZThen(x114, x115));
			int64_t v119 = 1LL /* True */;
			int64_t v120 = 1LL /* True */;
			x112 = v120;
			x111 = v108;
			x110 = v119;
			x109 = v118;
		} break;
		case 0LL: { // None
			int64_t v121 = 0LL /* False */;
			x112 = v121;
			x111 = v108;
			x110 = v86;
			x109 = v85;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v122 = (x109);
	int64_t v123 = x110;
	VAL v124 = x111;
	int64_t v125 = x112;
	while (((bool)v125)) {
		VAL v126 = (v122);
		int64_t v127 = v123;
		VAL v128 = v124;
		VAL v129;
		VAL v130;
		mw_std_list_List_1_uncons(v128, &v129, &v130);
		VAL x131;
		int64_t x132;
		VAL x133;
		int64_t x134;
		switch (get_data_tag(v129)) {
			case 1LL: { // Some
				VAL v135 = mtp_std_maybe_Maybe_1_Some(v129);
				VAL x136;
				VAL x137;
				if (((bool)v127)) {
					STR* v138;
					STRLIT(v138, " ", 1);
					VAL v139 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v138), v126));
					x137 = v135;
					x136 = v139;
				} else {
					x137 = v135;
					x136 = v126;
				}
				VAL v140 = (mw_mirth_type_Resource_typeZThen(x136, x137));
				int64_t v141 = 1LL /* True */;
				int64_t v142 = 1LL /* True */;
				x134 = v142;
				x133 = v130;
				x132 = v141;
				x131 = v140;
			} break;
			case 0LL: { // None
				int64_t v143 = 0LL /* False */;
				x134 = v143;
				x133 = v130;
				x132 = v127;
				x131 = v126;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v125 = x134;
		v124 = x133;
		v123 = x132;
		v122 = x131;
	}
	decref(v124);
	return v122;
}
static void mw_mirth_type_StackType_semifreshen (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_type_StackType_expand(x2);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 2LL: { // STACK_TYPE_UNIT
			incref(x1);
			x7 = x1;
			x6 = x1;
		} break;
		case 5LL: { // STCons
			VAL v8;
			VAL v9;
			mtp_mirth_type_StackType_STCons(v5, &v8, &v9);
			VAL v10;
			VAL v11;
			mw_mirth_type_StackType_semifreshen(x1, v8, &v10, &v11);
			VAL v12 = mtw_mirth_type_StackType_STCons(v11, v9);
			x7 = v12;
			x6 = v10;
		} break;
		case 7LL: { // STWith
			VAL v13;
			VAL v14;
			mtp_mirth_type_StackType_STWith(v5, &v13, &v14);
			VAL v15;
			VAL v16;
			mw_mirth_type_StackType_semifreshen(x1, v13, &v15, &v16);
			VAL v17 = mtw_mirth_type_StackType_STWith(v16, v14);
			x7 = v17;
			x6 = v15;
		} break;
		case 6LL: { // STConsLabel
			VAL v18;
			VAL v19;
			uint64_t v20;
			mtp_mirth_type_StackType_STConsLabel(v5, &v18, &v19, &v20);
			VAL v21;
			VAL v22;
			mw_mirth_type_StackType_semifreshen(x1, v18, &v21, &v22);
			VAL v23 = mtw_mirth_type_StackType_STConsLabel(v22, v19, v20);
			x7 = v23;
			x6 = v21;
		} break;
		case 8LL: { // STWithLabel
			VAL v24;
			VAL v25;
			uint64_t v26;
			mtp_mirth_type_StackType_STWithLabel(v5, &v24, &v25, &v26);
			VAL v27;
			VAL v28;
			mw_mirth_type_StackType_semifreshen(x1, v24, &v27, &v28);
			VAL v29 = mtw_mirth_type_StackType_STWithLabel(v28, v25, v26);
			x7 = v29;
			x6 = v27;
		} break;
		default: {
			STR* v30;
			STRLIT(v30, "expected unit-based stack in semifreshen!", 41);
			push_value(x1);
			push_value(v5);
			do_panic(v30);
			VAL v31 = pop_value();
			x7 = v31;
			VAL v32 = pop_value();
			x6 = v32;
		} break;
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_type_StackType_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_type_StackType_expand(x2);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 2LL: { // STACK_TYPE_UNIT
			VAL v8 = MKI64(2LL /* STACK_TYPE_UNIT */);
			x7 = v8;
			x6 = x1;
		} break;
		case 5LL: { // STCons
			VAL v9;
			VAL v10;
			mtp_mirth_type_StackType_STCons(v5, &v9, &v10);
			VAL v11;
			VAL v12;
			mw_mirth_type_StackType_freshen(x1, v9, &v11, &v12);
			VAL v13;
			VAL v14;
			mw_mirth_type_Type_freshen(v11, v10, &v13, &v14);
			VAL v15 = mtw_mirth_type_StackType_STCons(v12, v14);
			x7 = v15;
			x6 = v13;
		} break;
		case 7LL: { // STWith
			VAL v16;
			VAL v17;
			mtp_mirth_type_StackType_STWith(v5, &v16, &v17);
			VAL v18;
			VAL v19;
			mw_mirth_type_StackType_freshen(x1, v16, &v18, &v19);
			VAL v20;
			VAL v21;
			mw_mirth_type_Resource_freshen(v18, v17, &v20, &v21);
			VAL v22 = mtw_mirth_type_StackType_STWith(v19, v21);
			x7 = v22;
			x6 = v20;
		} break;
		case 6LL: { // STConsLabel
			VAL v23;
			VAL v24;
			uint64_t v25;
			mtp_mirth_type_StackType_STConsLabel(v5, &v23, &v24, &v25);
			VAL v26;
			VAL v27;
			mw_mirth_type_StackType_freshen(x1, v23, &v26, &v27);
			VAL v28;
			VAL v29;
			mw_mirth_type_Type_freshen(v26, v24, &v28, &v29);
			VAL v30 = mtw_mirth_type_StackType_STConsLabel(v27, v29, v25);
			x7 = v30;
			x6 = v28;
		} break;
		case 8LL: { // STWithLabel
			VAL v31;
			VAL v32;
			uint64_t v33;
			mtp_mirth_type_StackType_STWithLabel(v5, &v31, &v32, &v33);
			VAL v34;
			VAL v35;
			mw_mirth_type_StackType_freshen(x1, v31, &v34, &v35);
			VAL v36;
			VAL v37;
			mw_mirth_type_Resource_freshen(v34, v32, &v36, &v37);
			VAL v38 = mtw_mirth_type_StackType_STWithLabel(v35, v37, v33);
			x7 = v38;
			x6 = v36;
		} break;
		default: {
			VAL v39 = mw_mirth_type_StackType_ZToType(v5);
			VAL v40;
			VAL v41;
			mw_mirth_type_Type_freshen(x1, v39, &v40, &v41);
			VAL v42 = mw_mirth_type_Type_ZToStackType(v41);
			x7 = v42;
			x6 = v40;
		} break;
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_type_StackType_freshenZ_aux (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_StackType_expand(x3);
	VAL x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 2LL: { // STACK_TYPE_UNIT
			incref(x1);
			x10 = x1;
			x9 = x2;
			x8 = x1;
		} break;
		case 5LL: { // STCons
			VAL v11;
			VAL v12;
			mtp_mirth_type_StackType_STCons(v7, &v11, &v12);
			VAL v13;
			VAL v14;
			VAL v15;
			mw_mirth_type_StackType_freshenZ_aux(x1, x2, v11, &v13, &v14, &v15);
			VAL v16;
			VAL v17;
			mw_mirth_type_Type_freshen(v14, v12, &v16, &v17);
			VAL v18 = mtw_mirth_type_StackType_STCons(v15, v17);
			x10 = v18;
			x9 = v16;
			x8 = v13;
		} break;
		case 7LL: { // STWith
			VAL v19;
			VAL v20;
			mtp_mirth_type_StackType_STWith(v7, &v19, &v20);
			VAL v21;
			VAL v22;
			VAL v23;
			mw_mirth_type_StackType_freshenZ_aux(x1, x2, v19, &v21, &v22, &v23);
			VAL v24;
			VAL v25;
			mw_mirth_type_Resource_freshen(v22, v20, &v24, &v25);
			VAL v26 = mtw_mirth_type_StackType_STWith(v23, v25);
			x10 = v26;
			x9 = v24;
			x8 = v21;
		} break;
		case 6LL: { // STConsLabel
			VAL v27;
			VAL v28;
			uint64_t v29;
			mtp_mirth_type_StackType_STConsLabel(v7, &v27, &v28, &v29);
			VAL v30;
			VAL v31;
			VAL v32;
			mw_mirth_type_StackType_freshenZ_aux(x1, x2, v27, &v30, &v31, &v32);
			VAL v33;
			VAL v34;
			mw_mirth_type_Type_freshen(v31, v28, &v33, &v34);
			VAL v35 = mtw_mirth_type_StackType_STConsLabel(v32, v34, v29);
			x10 = v35;
			x9 = v33;
			x8 = v30;
		} break;
		case 8LL: { // STWithLabel
			VAL v36;
			VAL v37;
			uint64_t v38;
			mtp_mirth_type_StackType_STWithLabel(v7, &v36, &v37, &v38);
			VAL v39;
			VAL v40;
			VAL v41;
			mw_mirth_type_StackType_freshenZ_aux(x1, x2, v36, &v39, &v40, &v41);
			VAL v42;
			VAL v43;
			mw_mirth_type_Resource_freshen(v40, v37, &v42, &v43);
			VAL v44 = mtw_mirth_type_StackType_STWithLabel(v41, v43, v38);
			x10 = v44;
			x9 = v42;
			x8 = v39;
		} break;
		default: {
			VAL v45 = mw_mirth_type_StackType_ZToType(v7);
			VAL v46;
			VAL v47;
			mw_mirth_type_Type_freshen(x2, v45, &v46, &v47);
			VAL v48 = mw_mirth_type_Type_ZToStackType(v47);
			x10 = v48;
			x9 = v46;
			x8 = x1;
		} break;
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_type_StackType_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(x3)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v10 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x9 = v10;
			x8 = x2;
			x7 = x1;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v11 = MKI64(1LL /* STACK_TYPE_DONT_CARE */);
			x9 = v11;
			x8 = x2;
			x7 = x1;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v12 = MKI64(2LL /* STACK_TYPE_UNIT */);
			x9 = v12;
			x8 = x2;
			x7 = x1;
		} break;
		case 4LL: { // STMeta
			uint64_t v13 = mtp_mirth_type_StackType_STMeta(x3);
			VAL v14 = mw_mirth_type_MetaVar_typeZAsk(v13);
			VAL x15;
			VAL x16;
			VAL x17;
			switch (get_data_tag(v14)) {
				case 0LL: { // None
					VAL v18;
					uint64_t v19;
					mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang(x2, &v18, &v19);
					VAL v20 = mtw_mirth_type_Type_TVar(v19);
					incref(v20);
					VAL v21 = mtw_std_maybe_Maybe_1_Some(v20);
					void* v22 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v13);
					mut_set(v21, v22);
					x17 = v20;
					x16 = v18;
					x15 = x1;
				} break;
				case 1LL: { // Some
					VAL v23 = mtp_std_maybe_Maybe_1_Some(v14);
					x17 = v23;
					x16 = x2;
					x15 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v24 = mw_mirth_type_Type_ZToStackType(x17);
			VAL v25;
			VAL v26;
			VAL v27;
			mw_mirth_type_StackType_rigidifyZBang(x15, x16, v24, &v25, &v26, &v27);
			x9 = v27;
			x8 = v26;
			x7 = v25;
		} break;
		case 3LL: { // STVar
			uint64_t v28 = mtp_mirth_type_StackType_STVar(x3);
			VAL v29 = mtw_mirth_type_StackType_STVar(v28);
			x9 = v29;
			x8 = x2;
			x7 = x1;
		} break;
		case 5LL: { // STCons
			VAL v30;
			VAL v31;
			mtp_mirth_type_StackType_STCons(x3, &v30, &v31);
			VAL v32;
			VAL v33;
			VAL v34;
			mw_mirth_type_StackType_rigidifyZBang(x1, x2, v30, &v32, &v33, &v34);
			VAL v35;
			VAL v36;
			VAL v37;
			mw_mirth_type_Type_rigidifyZBang(v32, v33, v31, &v35, &v36, &v37);
			VAL v38 = mtw_mirth_type_StackType_STCons(v34, v37);
			x9 = v38;
			x8 = v36;
			x7 = v35;
		} break;
		case 6LL: { // STConsLabel
			VAL v39;
			VAL v40;
			uint64_t v41;
			mtp_mirth_type_StackType_STConsLabel(x3, &v39, &v40, &v41);
			VAL v42;
			VAL v43;
			VAL v44;
			mw_mirth_type_StackType_rigidifyZBang(x1, x2, v39, &v42, &v43, &v44);
			VAL v45;
			VAL v46;
			VAL v47;
			mw_mirth_type_Type_rigidifyZBang(v42, v43, v40, &v45, &v46, &v47);
			VAL v48 = mtw_mirth_type_StackType_STConsLabel(v44, v47, v41);
			x9 = v48;
			x8 = v46;
			x7 = v45;
		} break;
		case 7LL: { // STWith
			VAL v49;
			VAL v50;
			mtp_mirth_type_StackType_STWith(x3, &v49, &v50);
			VAL v51;
			VAL v52;
			VAL v53;
			mw_mirth_type_StackType_rigidifyZBang(x1, x2, v49, &v51, &v52, &v53);
			VAL v54;
			VAL v55;
			VAL v56;
			mw_mirth_type_Resource_rigidifyZBang(v51, v52, v50, &v54, &v55, &v56);
			VAL v57 = mtw_mirth_type_StackType_STWith(v53, v56);
			x9 = v57;
			x8 = v55;
			x7 = v54;
		} break;
		case 8LL: { // STWithLabel
			VAL v58;
			VAL v59;
			uint64_t v60;
			mtp_mirth_type_StackType_STWithLabel(x3, &v58, &v59, &v60);
			VAL v61;
			VAL v62;
			VAL v63;
			mw_mirth_type_StackType_rigidifyZBang(x1, x2, v58, &v61, &v62, &v63);
			VAL v64;
			VAL v65;
			VAL v66;
			mw_mirth_type_Resource_rigidifyZBang(v61, v62, v59, &v64, &v65, &v66);
			VAL v67 = mtw_mirth_type_StackType_STWithLabel(v63, v66, v60);
			x9 = v67;
			x8 = v65;
			x7 = v64;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x9;
	*x5 = x8;
	*x4 = x7;
}
static VAL mw_mirth_type_ArrowType_ZToType (VAL x1) {
	VAL v2 = mtw_mirth_type_Type_TMorphism(x1);
	return v2;
}
static VAL mw_mirth_type_ArrowType_invert (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_type_ArrowType_ARROWz_TYPE(x1, &v2, &v3);
	VAL v4 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v3, v2);
	return v4;
}
static void mw_mirth_type_ArrowType_unpack (VAL x1, VAL *x2, VAL *x3) {
	VAL v4;
	VAL v5;
	mtp_mirth_type_ArrowType_ARROWz_TYPE(x1, &v4, &v5);
	*x3 = v5;
	*x2 = v4;
}
static VAL mw_mirth_type_ArrowType_dom (VAL x1) {
	VAL v2;
	VAL v3;
	mw_mirth_type_ArrowType_unpack(x1, &v2, &v3);
	decref(v3);
	return v2;
}
static VAL mw_mirth_type_ArrowType_cod (VAL x1) {
	VAL v2;
	VAL v3;
	mw_mirth_type_ArrowType_unpack(x1, &v2, &v3);
	decref(v2);
	return v3;
}
static void mw_mirth_type_ArrowType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, uint64_t *x6, VAL *x7) {
	VAL v8;
	VAL v9;
	mw_mirth_type_ArrowType_unpack(x3, &v8, &v9);
	VAL v10;
	VAL v11;
	mw_mirth_type_ArrowType_unpack(x4, &v10, &v11);
	VAL v12;
	uint64_t v13;
	VAL v14;
	mw_mirth_type_StackType_unifyZBang(x1, x2, v8, v10, &v12, &v13, &v14);
	VAL v15;
	uint64_t v16;
	VAL v17;
	mw_mirth_type_StackType_unifyZBang(v12, v13, v9, v11, &v15, &v16, &v17);
	VAL v18 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v14, v17);
	*x7 = v18;
	*x6 = v16;
	*x5 = v15;
}
static void mw_mirth_type_ArrowType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3, VAL *x4, uint64_t *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	mw_mirth_type_ArrowType_unpack(x3, &v7, &v8);
	VAL v9;
	uint64_t v10;
	VAL v11;
	mw_mirth_type_StackType_unifyZ_errorZBang(x1, x2, v7, &v9, &v10, &v11);
	VAL v12;
	uint64_t v13;
	VAL v14;
	mw_mirth_type_StackType_unifyZ_errorZBang(v9, v10, v8, &v12, &v13, &v14);
	VAL v15 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v11, v14);
	*x6 = v15;
	*x5 = v13;
	*x4 = v12;
}
static int64_t mw_mirth_type_ArrowType_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	VAL v3;
	VAL v4;
	mw_mirth_type_ArrowType_unpack(x2, &v3, &v4);
	int64_t v5 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v4);
	int64_t x6;
	if (((bool)v5)) {
		decref(v3);
		int64_t v7 = 1LL /* True */;
		x6 = v7;
	} else {
		int64_t v8 = mw_mirth_type_StackType_hasZ_metaZAsk(x1, v3);
		x6 = v8;
	}
	return x6;
}
static VAL mw_mirth_type_ArrowType_sigZThen (VAL x1, VAL x2) {
	VAL v3;
	VAL v4;
	mw_mirth_type_ArrowType_unpack(x2, &v3, &v4);
	VAL v5 = (mw_mirth_type_StackType_domZThen(x1, v3));
	STR* v6;
	STRLIT(v6, "--", 2);
	VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), v5));
	VAL v8 = (mw_mirth_type_StackType_codZThen(v7, v4));
	return v8;
}
static VAL mw_mirth_type_ArrowType_semifreshenZ_sig (VAL x1) {
	incref(x1);
	int64_t v2 = mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk(x1);
	VAL x3;
	if (((bool)v2)) {
		VAL v4 = mw_mirth_type_ArrowType_semifreshenZ_aux(x1);
		x3 = v4;
	} else {
		x3 = x1;
	}
	return x3;
}
static VAL mw_mirth_type_ArrowType_semifreshenZ_aux (VAL x1) {
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_StackType_STMeta(v2);
	VAL v4;
	VAL v5;
	mw_mirth_type_ArrowType_unpack(x1, &v4, &v5);
	VAL v6;
	VAL v7;
	mw_mirth_type_StackType_semifreshen(v3, v4, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_type_StackType_semifreshen(v6, v5, &v8, &v9);
	VAL v10 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v7, v9);
	decref(v8);
	return v10;
}
static int64_t mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk (VAL x1) {
	VAL v2;
	VAL v3;
	mw_mirth_type_ArrowType_unpack(x1, &v2, &v3);
	VAL v4 = mw_mirth_type_StackType_base(v3);
	int64_t v5 = mw_mirth_type_StackType_unitZAsk(v4);
	int64_t x6;
	if (((bool)v5)) {
		VAL v7 = mw_mirth_type_StackType_base(v2);
		int64_t v8 = mw_mirth_type_StackType_unitZAsk(v7);
		x6 = v8;
	} else {
		decref(v2);
		int64_t v9 = 0LL /* False */;
		x6 = v9;
	}
	return x6;
}
static void mw_mirth_type_ArrowType_freshenZ_sig (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	int64_t v5 = mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk(x2);
	VAL x6;
	VAL x7;
	if (((bool)v5)) {
		VAL v8;
		VAL v9;
		mw_mirth_type_ArrowType_freshenZ_sigZ_aux(x1, x2, &v8, &v9);
		x7 = v9;
		x6 = v8;
	} else {
		VAL v10;
		VAL v11;
		mw_mirth_type_ArrowType_freshen(x1, x2, &v10, &v11);
		x7 = v11;
		x6 = v10;
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_type_ArrowType_freshenZ_sigZ_aux (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = mw_mirth_type_MetaVar_newZBang();
	VAL v6 = mtw_mirth_type_StackType_STMeta(v5);
	VAL v7;
	VAL v8;
	mw_mirth_type_ArrowType_unpack(x2, &v7, &v8);
	VAL v9;
	VAL v10;
	VAL v11;
	mw_mirth_type_StackType_freshenZ_aux(v6, x1, v7, &v9, &v10, &v11);
	VAL v12;
	VAL v13;
	VAL v14;
	mw_mirth_type_StackType_freshenZ_aux(v9, v10, v8, &v12, &v13, &v14);
	VAL v15 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v11, v14);
	decref(v12);
	*x4 = v15;
	*x3 = v13;
}
static void mw_mirth_type_ArrowType_freshen (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_type_ArrowType_unpack(x2, &v5, &v6);
	VAL v7;
	VAL v8;
	mw_mirth_type_StackType_freshen(x1, v5, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_type_StackType_freshen(v7, v6, &v9, &v10);
	VAL v11 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v8, v10);
	*x4 = v11;
	*x3 = v9;
}
static void mw_mirth_type_ArrowType_rigidifyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	mw_mirth_type_ArrowType_unpack(x3, &v7, &v8);
	VAL v9;
	VAL v10;
	VAL v11;
	mw_mirth_type_StackType_rigidifyZBang(x1, x2, v7, &v9, &v10, &v11);
	VAL v12;
	VAL v13;
	VAL v14;
	mw_mirth_type_StackType_rigidifyZBang(v9, v10, v8, &v12, &v13, &v14);
	VAL v15 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v11, v14);
	*x6 = v15;
	*x5 = v13;
	*x4 = v12;
}
static void mw_mirth_type_ArrowType_rigidifyZ_sigZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	VAL v9;
	mw_mirth_type_ArrowType_rigidifyZBang(x1, x2, x3, &v7, &v8, &v9);
	*x6 = v9;
	*x5 = v8;
	*x4 = v7;
}
static VAL mw_mirth_type_Subst_nil (void) {
	VAL v1 = MKI64(0LL /* SUBST_NIL */);
	return v1;
}
static VAL mw_mirth_type_Subst_cons (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = mtw_mirth_type_Subst_SUBSTz_CON(x3, x1, x2);
	return v4;
}
static int64_t mw_mirth_type_Subst_hasZ_varZAsk (uint64_t x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // SUBST_NIL
			int64_t v4 = 0LL /* False */;
			x3 = v4;
		} break;
		case 1LL: { // SUBST_CON
			VAL v5;
			VAL v6;
			uint64_t v7;
			mtp_mirth_type_Subst_SUBSTz_CON(x2, &v5, &v6, &v7);
			decref(v6);
			int64_t v8 = mw_mirth_var_Var_ZEqualZEqual(v7, x1);
			int64_t x9;
			if (((bool)v8)) {
				decref(v5);
				int64_t v10 = 1LL /* True */;
				x9 = v10;
			} else {
				int64_t v11 = mw_mirth_type_Subst_hasZ_varZAsk(x1, v5);
				x9 = v11;
			}
			x3 = x9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_Subst_getZ_var (uint64_t x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // SUBST_NIL
			VAL v4 = MKI64(0LL /* TYPE_ERROR */);
			x3 = v4;
		} break;
		case 1LL: { // SUBST_CON
			VAL v5;
			VAL v6;
			uint64_t v7;
			mtp_mirth_type_Subst_SUBSTz_CON(x2, &v5, &v6, &v7);
			int64_t v8 = mw_mirth_var_Var_ZEqualZEqual(v7, x1);
			VAL x9;
			if (((bool)v8)) {
				decref(v5);
				x9 = v6;
			} else {
				decref(v6);
				VAL v10 = mw_mirth_type_Subst_getZ_var(x1, v5);
				x9 = v10;
			}
			x3 = x9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_type_StackTypePart_cons (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // STPCons
			VAL v4 = mtp_mirth_type_StackTypePart_STPCons(x2);
			VAL v5 = mtw_mirth_type_StackType_STCons(x1, v4);
			x3 = v5;
		} break;
		case 1LL: { // STPConsLabel
			VAL v6;
			uint64_t v7;
			mtp_mirth_type_StackTypePart_STPConsLabel(x2, &v6, &v7);
			VAL v8 = mtw_mirth_type_StackType_STConsLabel(x1, v6, v7);
			x3 = v8;
		} break;
		case 2LL: { // STPWith
			VAL v9 = mtp_mirth_type_StackTypePart_STPWith(x2);
			VAL v10 = mtw_mirth_type_StackType_STWith(x1, v9);
			x3 = v10;
		} break;
		case 3LL: { // STPWithLabel
			VAL v11;
			uint64_t v12;
			mtp_mirth_type_StackTypePart_STPWithLabel(x2, &v11, &v12);
			VAL v13 = mtw_mirth_type_StackType_STWithLabel(x1, v11, v12);
			x3 = v13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_type_StackType_splitZ_parts (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = MKI64(0LL /* Nil */);
	VAL x5;
	VAL x6;
	switch (get_data_tag(x1)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v7 = MKI64(0LL /* STB_ERROR */);
			VAL v8 = mtw_std_either_Either_2_Left(v7);
			x6 = v8;
			x5 = v4;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			VAL v9 = MKI64(1LL /* STB_DONT_CARE */);
			VAL v10 = mtw_std_either_Either_2_Left(v9);
			x6 = v10;
			x5 = v4;
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v11 = MKI64(2LL /* STB_UNIT */);
			VAL v12 = mtw_std_either_Either_2_Left(v11);
			x6 = v12;
			x5 = v4;
		} break;
		case 3LL: { // STVar
			uint64_t v13 = mtp_mirth_type_StackType_STVar(x1);
			VAL v14 = mtw_mirth_type_StackTypeBase_STBVar(v13);
			VAL v15 = mtw_std_either_Either_2_Left(v14);
			x6 = v15;
			x5 = v4;
		} break;
		case 4LL: { // STMeta
			uint64_t v16 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v17 = mw_mirth_type_MetaVar_typeZAsk(v16);
			VAL x18;
			VAL x19;
			switch (get_data_tag(v17)) {
				case 0LL: { // None
					VAL v20 = mtw_mirth_type_StackTypeBase_STBMeta(v16);
					VAL v21 = mtw_std_either_Either_2_Left(v20);
					x19 = v21;
					x18 = v4;
				} break;
				case 1LL: { // Some
					VAL v22 = mtp_std_maybe_Maybe_1_Some(v17);
					VAL v23 = mw_mirth_type_Type_expand(v22);
					incref(v23);
					VAL v24 = mtw_std_maybe_Maybe_1_Some(v23);
					void* v25 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v16);
					mut_set(v24, v25);
					VAL v26 = mw_mirth_type_Type_ZToStackType(v23);
					VAL v27 = mtw_std_either_Either_2_Right(v26);
					x19 = v27;
					x18 = v4;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x19;
			x5 = x18;
		} break;
		case 5LL: { // STCons
			VAL v28;
			VAL v29;
			mtp_mirth_type_StackType_STCons(x1, &v28, &v29);
			VAL v30 = mtw_mirth_type_StackTypePart_STPCons(v29);
			VAL v31 = mtw_std_list_List_1_Cons(v30, v4);
			VAL v32 = mtw_std_either_Either_2_Right(v28);
			x6 = v32;
			x5 = v31;
		} break;
		case 6LL: { // STConsLabel
			VAL v33;
			VAL v34;
			uint64_t v35;
			mtp_mirth_type_StackType_STConsLabel(x1, &v33, &v34, &v35);
			VAL v36 = mtw_mirth_type_StackTypePart_STPConsLabel(v34, v35);
			VAL v37 = mtw_std_list_List_1_Cons(v36, v4);
			VAL v38 = mtw_std_either_Either_2_Right(v33);
			x6 = v38;
			x5 = v37;
		} break;
		case 7LL: { // STWith
			VAL v39;
			VAL v40;
			mtp_mirth_type_StackType_STWith(x1, &v39, &v40);
			VAL v41 = mtw_mirth_type_StackTypePart_STPWith(v40);
			VAL v42 = mtw_std_list_List_1_Cons(v41, v4);
			VAL v43 = mtw_std_either_Either_2_Right(v39);
			x6 = v43;
			x5 = v42;
		} break;
		case 8LL: { // STWithLabel
			VAL v44;
			VAL v45;
			uint64_t v46;
			mtp_mirth_type_StackType_STWithLabel(x1, &v44, &v45, &v46);
			VAL v47 = mtw_mirth_type_StackTypePart_STPWithLabel(v45, v46);
			VAL v48 = mtw_std_list_List_1_Cons(v47, v4);
			VAL v49 = mtw_std_either_Either_2_Right(v44);
			x6 = v49;
			x5 = v48;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	incref(x6);
	VAL v50 = mw_std_either_Either_2_rightZAsk(x6);
	VAL x51;
	VAL x52;
	int64_t x53;
	switch (get_data_tag(v50)) {
		case 1LL: { // Some
			VAL v54 = mtp_std_maybe_Maybe_1_Some(v50);
			decref(x6);
			VAL x55;
			VAL x56;
			switch (get_data_tag(v54)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v57 = MKI64(0LL /* STB_ERROR */);
					VAL v58 = mtw_std_either_Either_2_Left(v57);
					x56 = v58;
					x55 = x5;
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v59 = MKI64(1LL /* STB_DONT_CARE */);
					VAL v60 = mtw_std_either_Either_2_Left(v59);
					x56 = v60;
					x55 = x5;
				} break;
				case 2LL: { // STACK_TYPE_UNIT
					VAL v61 = MKI64(2LL /* STB_UNIT */);
					VAL v62 = mtw_std_either_Either_2_Left(v61);
					x56 = v62;
					x55 = x5;
				} break;
				case 3LL: { // STVar
					uint64_t v63 = mtp_mirth_type_StackType_STVar(v54);
					VAL v64 = mtw_mirth_type_StackTypeBase_STBVar(v63);
					VAL v65 = mtw_std_either_Either_2_Left(v64);
					x56 = v65;
					x55 = x5;
				} break;
				case 4LL: { // STMeta
					uint64_t v66 = mtp_mirth_type_StackType_STMeta(v54);
					VAL v67 = mw_mirth_type_MetaVar_typeZAsk(v66);
					VAL x68;
					VAL x69;
					switch (get_data_tag(v67)) {
						case 0LL: { // None
							VAL v70 = mtw_mirth_type_StackTypeBase_STBMeta(v66);
							VAL v71 = mtw_std_either_Either_2_Left(v70);
							x69 = v71;
							x68 = x5;
						} break;
						case 1LL: { // Some
							VAL v72 = mtp_std_maybe_Maybe_1_Some(v67);
							VAL v73 = mw_mirth_type_Type_expand(v72);
							incref(v73);
							VAL v74 = mtw_std_maybe_Maybe_1_Some(v73);
							void* v75 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v66);
							mut_set(v74, v75);
							VAL v76 = mw_mirth_type_Type_ZToStackType(v73);
							VAL v77 = mtw_std_either_Either_2_Right(v76);
							x69 = v77;
							x68 = x5;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x56 = x69;
					x55 = x68;
				} break;
				case 5LL: { // STCons
					VAL v78;
					VAL v79;
					mtp_mirth_type_StackType_STCons(v54, &v78, &v79);
					VAL v80 = mtw_mirth_type_StackTypePart_STPCons(v79);
					VAL v81 = mtw_std_list_List_1_Cons(v80, x5);
					VAL v82 = mtw_std_either_Either_2_Right(v78);
					x56 = v82;
					x55 = v81;
				} break;
				case 6LL: { // STConsLabel
					VAL v83;
					VAL v84;
					uint64_t v85;
					mtp_mirth_type_StackType_STConsLabel(v54, &v83, &v84, &v85);
					VAL v86 = mtw_mirth_type_StackTypePart_STPConsLabel(v84, v85);
					VAL v87 = mtw_std_list_List_1_Cons(v86, x5);
					VAL v88 = mtw_std_either_Either_2_Right(v83);
					x56 = v88;
					x55 = v87;
				} break;
				case 7LL: { // STWith
					VAL v89;
					VAL v90;
					mtp_mirth_type_StackType_STWith(v54, &v89, &v90);
					VAL v91 = mtw_mirth_type_StackTypePart_STPWith(v90);
					VAL v92 = mtw_std_list_List_1_Cons(v91, x5);
					VAL v93 = mtw_std_either_Either_2_Right(v89);
					x56 = v93;
					x55 = v92;
				} break;
				case 8LL: { // STWithLabel
					VAL v94;
					VAL v95;
					uint64_t v96;
					mtp_mirth_type_StackType_STWithLabel(v54, &v94, &v95, &v96);
					VAL v97 = mtw_mirth_type_StackTypePart_STPWithLabel(v95, v96);
					VAL v98 = mtw_std_list_List_1_Cons(v97, x5);
					VAL v99 = mtw_std_either_Either_2_Right(v94);
					x56 = v99;
					x55 = v98;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v100 = 1LL /* True */;
			x53 = v100;
			x52 = x56;
			x51 = x55;
		} break;
		case 0LL: { // None
			int64_t v101 = 0LL /* False */;
			x53 = v101;
			x52 = x6;
			x51 = x5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v102 = x51;
	VAL v103 = x52;
	int64_t v104 = x53;
	while (((bool)v104)) {
		VAL v105 = v102;
		VAL v106 = v103;
		incref(v106);
		VAL v107 = mw_std_either_Either_2_rightZAsk(v106);
		VAL x108;
		VAL x109;
		int64_t x110;
		switch (get_data_tag(v107)) {
			case 1LL: { // Some
				VAL v111 = mtp_std_maybe_Maybe_1_Some(v107);
				decref(v106);
				VAL x112;
				VAL x113;
				switch (get_data_tag(v111)) {
					case 0LL: { // STACK_TYPE_ERROR
						VAL v114 = MKI64(0LL /* STB_ERROR */);
						VAL v115 = mtw_std_either_Either_2_Left(v114);
						x113 = v115;
						x112 = v105;
					} break;
					case 1LL: { // STACK_TYPE_DONT_CARE
						VAL v116 = MKI64(1LL /* STB_DONT_CARE */);
						VAL v117 = mtw_std_either_Either_2_Left(v116);
						x113 = v117;
						x112 = v105;
					} break;
					case 2LL: { // STACK_TYPE_UNIT
						VAL v118 = MKI64(2LL /* STB_UNIT */);
						VAL v119 = mtw_std_either_Either_2_Left(v118);
						x113 = v119;
						x112 = v105;
					} break;
					case 3LL: { // STVar
						uint64_t v120 = mtp_mirth_type_StackType_STVar(v111);
						VAL v121 = mtw_mirth_type_StackTypeBase_STBVar(v120);
						VAL v122 = mtw_std_either_Either_2_Left(v121);
						x113 = v122;
						x112 = v105;
					} break;
					case 4LL: { // STMeta
						uint64_t v123 = mtp_mirth_type_StackType_STMeta(v111);
						VAL v124 = mw_mirth_type_MetaVar_typeZAsk(v123);
						VAL x125;
						VAL x126;
						switch (get_data_tag(v124)) {
							case 0LL: { // None
								VAL v127 = mtw_mirth_type_StackTypeBase_STBMeta(v123);
								VAL v128 = mtw_std_either_Either_2_Left(v127);
								x126 = v128;
								x125 = v105;
							} break;
							case 1LL: { // Some
								VAL v129 = mtp_std_maybe_Maybe_1_Some(v124);
								VAL v130 = mw_mirth_type_Type_expand(v129);
								incref(v130);
								VAL v131 = mtw_std_maybe_Maybe_1_Some(v130);
								void* v132 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v123);
								mut_set(v131, v132);
								VAL v133 = mw_mirth_type_Type_ZToStackType(v130);
								VAL v134 = mtw_std_either_Either_2_Right(v133);
								x126 = v134;
								x125 = v105;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						x113 = x126;
						x112 = x125;
					} break;
					case 5LL: { // STCons
						VAL v135;
						VAL v136;
						mtp_mirth_type_StackType_STCons(v111, &v135, &v136);
						VAL v137 = mtw_mirth_type_StackTypePart_STPCons(v136);
						VAL v138 = mtw_std_list_List_1_Cons(v137, v105);
						VAL v139 = mtw_std_either_Either_2_Right(v135);
						x113 = v139;
						x112 = v138;
					} break;
					case 6LL: { // STConsLabel
						VAL v140;
						VAL v141;
						uint64_t v142;
						mtp_mirth_type_StackType_STConsLabel(v111, &v140, &v141, &v142);
						VAL v143 = mtw_mirth_type_StackTypePart_STPConsLabel(v141, v142);
						VAL v144 = mtw_std_list_List_1_Cons(v143, v105);
						VAL v145 = mtw_std_either_Either_2_Right(v140);
						x113 = v145;
						x112 = v144;
					} break;
					case 7LL: { // STWith
						VAL v146;
						VAL v147;
						mtp_mirth_type_StackType_STWith(v111, &v146, &v147);
						VAL v148 = mtw_mirth_type_StackTypePart_STPWith(v147);
						VAL v149 = mtw_std_list_List_1_Cons(v148, v105);
						VAL v150 = mtw_std_either_Either_2_Right(v146);
						x113 = v150;
						x112 = v149;
					} break;
					case 8LL: { // STWithLabel
						VAL v151;
						VAL v152;
						uint64_t v153;
						mtp_mirth_type_StackType_STWithLabel(v111, &v151, &v152, &v153);
						VAL v154 = mtw_mirth_type_StackTypePart_STPWithLabel(v152, v153);
						VAL v155 = mtw_std_list_List_1_Cons(v154, v105);
						VAL v156 = mtw_std_either_Either_2_Right(v151);
						x113 = v156;
						x112 = v155;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v157 = 1LL /* True */;
				x110 = v157;
				x109 = x113;
				x108 = x112;
			} break;
			case 0LL: { // None
				int64_t v158 = 0LL /* False */;
				x110 = v158;
				x109 = v106;
				x108 = v105;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v104 = x110;
		v103 = x109;
		v102 = x108;
	}
	VAL v159 = mw_std_either_Either_2_leftZAsk(v103);
	VAL x160;
	VAL x161;
	switch (get_data_tag(v159)) {
		case 1LL: { // Some
			VAL v162 = mtp_std_maybe_Maybe_1_Some(v159);
			x161 = v162;
			x160 = v102;
		} break;
		case 0LL: { // None
			STR* v163;
			STRLIT(v163, "logic error in Either.while-right", 33);
			lpush(&lbl_parts, v102);
			do_panic(v163);
			VAL v164 = pop_value();
			x161 = v164;
			VAL v165 = lpop(&lbl_parts);
			x160 = v165;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x160;
	*x2 = x161;
}
static VAL mw_mirth_type_StackTypePart_typeZDivresource (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // STPCons
			VAL v3 = mtp_mirth_type_StackTypePart_STPCons(x1);
			VAL v4 = mtw_std_either_Either_2_Left(v3);
			x2 = v4;
		} break;
		case 2LL: { // STPWith
			VAL v5 = mtp_mirth_type_StackTypePart_STPWith(x1);
			VAL v6 = mtw_std_either_Either_2_Right(v5);
			x2 = v6;
		} break;
		case 1LL: { // STPConsLabel
			VAL v7;
			uint64_t v8;
			mtp_mirth_type_StackTypePart_STPConsLabel(x1, &v7, &v8);
			VAL v9 = mtw_std_either_Either_2_Left(v7);
			x2 = v9;
		} break;
		case 3LL: { // STPWithLabel
			VAL v10;
			uint64_t v11;
			mtp_mirth_type_StackTypePart_STPWithLabel(x1, &v10, &v11);
			VAL v12 = mtw_std_either_Either_2_Right(v10);
			x2 = v12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_type_CType_cname (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // IntLike
			VAL v3 = mtp_mirth_type_CType_IntLike(x1);
			x2 = v3;
		} break;
		case 1LL: { // F32Like
			VAL v4 = mtp_mirth_type_CType_F32Like(x1);
			x2 = v4;
		} break;
		case 2LL: { // F64Like
			VAL v5 = mtp_mirth_type_CType_F64Like(x1);
			x2 = v5;
		} break;
		case 3LL: { // PtrLike
			VAL v6 = mtp_mirth_type_CType_PtrLike(x1);
			x2 = v6;
		} break;
		case 4LL: { // FnPtr
			VAL v7 = mtp_mirth_type_CType_FnPtr(x1);
			x2 = v7;
		} break;
		case 5LL: { // Phantom
			STR* v8;
			STRLIT(v8, "void", 4);
			x2 = MKSTR(v8);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static int64_t mw_mirth_type_CType_phantomZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 5LL: { // Phantom
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static void mw_mirth_type_Resource_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_type_Type_ctype(x1, x2, &v5, &v6);
	*x4 = v6;
	*x3 = v5;
}
static void mw_mirth_type_Type_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	VAL v5;
	VAL v6;
	mw_mirth_type_Type_ctypeZAsk(x1, x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			decref(x2);
			x8 = v9;
			x7 = v5;
		} break;
		case 0LL: { // None
			STR* v10;
			STRLIT(v10, "", 0);
			VAL v11 = (mw_mirth_type_Type_typeZThen(x2, MKSTR(v10)));
			STR* v12;
			STRLIT(v12, " doesn't have a C representation.", 33);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
			VAL v14 = (mw_mirth_mirth_ZPlusMirth_errorZBang(v13, v5));
			VAL v15 = MKI64(5LL /* Phantom */);
			x8 = v15;
			x7 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static void mw_mirth_type_Resource_ctypeZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_type_Type_ctypeZAsk(x1, x2, &v5, &v6);
	*x4 = v6;
	*x3 = v5;
}
static void mw_mirth_type_Type_ctypeZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_type_Type_expand(x2);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 2LL: { // TPrim
			int64_t v8 = mtp_mirth_type_Type_TPrim(v5);
			VAL v9;
			VAL v10;
			mw_mirth_type_PrimType_ctypeZAsk(x1, v8, &v9, &v10);
			x7 = v10;
			x6 = v9;
		} break;
		case 7LL: { // TData
			uint64_t v11 = mtp_mirth_type_Type_TData(v5);
			VAL v12;
			VAL v13;
			mw_mirth_data_Data_ctypeZAsk(v11, x1, &v12, &v13);
			x7 = v12;
			x6 = v13;
		} break;
		case 10LL: { // TMorphism
			VAL v14 = mtp_mirth_type_Type_TMorphism(v5);
			decref(v14);
			STR* v15;
			STRLIT(v15, "FNPTR", 5);
			VAL v16 = mtw_mirth_type_CType_FnPtr(MKSTR(v15));
			VAL v17 = mtw_std_maybe_Maybe_1_Some(v16);
			x7 = v17;
			x6 = x1;
		} break;
		case 11LL: { // TApp
			VAL v18;
			VAL v19;
			mtp_mirth_type_Type_TApp(v5, &v18, &v19);
			VAL v20;
			VAL v21;
			mw_mirth_type_Type_ctypeZAsk(x1, v19, &v20, &v21);
			VAL x22;
			VAL x23;
			VAL x24;
			switch (get_data_tag(v21)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v21);
					incref(v18);
					VAL v26;
					VAL v27;
					mw_mirth_type_Type_ctype1ZAsk(v20, v25, v18, &v26, &v27);
					x24 = v27;
					x23 = v26;
					x22 = v18;
				} break;
				case 0LL: { // None
					VAL v28 = MKI64(0LL /* None */);
					x24 = v28;
					x23 = v20;
					x22 = v18;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x22);
			x7 = x24;
			x6 = x23;
		} break;
		default: {
			decref(v5);
			VAL v29 = MKI64(0LL /* None */);
			x7 = v29;
			x6 = x1;
		} break;
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_type_Type_ctype1ZAsk (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mw_mirth_type_Type_expand(x3);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 7LL: { // TData
			uint64_t v9 = mtp_mirth_type_Type_TData(v6);
			VAL v10;
			VAL v11;
			mw_mirth_data_Data_ctype1ZAsk(x1, x2, v9, &v10, &v11);
			x8 = v11;
			x7 = v10;
		} break;
		default: {
			decref(v6);
			decref(x2);
			VAL v12 = MKI64(0LL /* None */);
			x8 = v12;
			x7 = x1;
		} break;
	}
	*x5 = x8;
	*x4 = x7;
}
static void mw_mirth_type_PrimType_ctypeZAsk (VAL x1, int64_t x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (x2) {
		case 6LL: { // PRIM_TYPE_PTR
			STR* v7;
			STRLIT(v7, "void*", 5);
			VAL v8 = mtw_mirth_type_CType_PtrLike(MKSTR(v7));
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			x6 = v9;
			x5 = x1;
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			VAL v10 = MKI64(5LL /* Phantom */);
			VAL v11 = mtw_std_maybe_Maybe_1_Some(v10);
			x6 = v11;
			x5 = x1;
		} break;
		case 4LL: { // PRIM_TYPE_F32
			STR* v12;
			STRLIT(v12, "float", 5);
			VAL v13 = mtw_mirth_type_CType_F32Like(MKSTR(v12));
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			x6 = v14;
			x5 = x1;
		} break;
		case 5LL: { // PRIM_TYPE_F64
			STR* v15;
			STRLIT(v15, "double", 6);
			VAL v16 = mtw_mirth_type_CType_F64Like(MKSTR(v15));
			VAL v17 = mtw_std_maybe_Maybe_1_Some(v16);
			x6 = v17;
			x5 = x1;
		} break;
		default: {
			VAL v18 = MKI64(0LL /* None */);
			x6 = v18;
			x5 = x1;
		} break;
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_data_Data_ctype1ZAsk (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x1)->cells[4]);
	incref(v6);
	uint64_t v7 = VU64(VTUP(v6)->cells[52]);
	decref(v6);
	int64_t v8 = mw_mirth_data_Data_ZEqualZEqual(x3, v7);
	VAL x9;
	VAL x10;
	if (((bool)v8)) {
		VAL v11 = mw_mirth_type_CType_cname(x2);
		STR* v12;
		STRLIT(v12, " *", 2);
		STR* v13 = str_cat(VSTR(v11), v12);
		VAL v14 = mtw_mirth_type_CType_PtrLike(MKSTR(v13));
		VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
		x10 = v15;
		x9 = x1;
	} else {
		VAL v16 = VVAL(VTUP(x1)->cells[4]);
		incref(v16);
		uint64_t v17 = VU64(VTUP(v16)->cells[54]);
		decref(v16);
		int64_t v18 = mw_mirth_data_Data_ZEqualZEqual(x3, v17);
		VAL x19;
		VAL x20;
		if (((bool)v18)) {
			VAL x21;
			VAL x22;
			switch (get_data_tag(x2)) {
				case 0LL: { // IntLike
					VAL v23 = mtp_mirth_type_CType_IntLike(x2);
					STR* v24;
					STRLIT(v24, "const ", 6);
					STR* v25 = str_cat(v24, VSTR(v23));
					VAL v26 = mtw_mirth_type_CType_IntLike(MKSTR(v25));
					VAL v27 = mtw_std_maybe_Maybe_1_Some(v26);
					x22 = v27;
					x21 = x1;
				} break;
				case 1LL: { // F32Like
					VAL v28 = mtp_mirth_type_CType_F32Like(x2);
					STR* v29;
					STRLIT(v29, "const ", 6);
					STR* v30 = str_cat(v29, VSTR(v28));
					VAL v31 = mtw_mirth_type_CType_F32Like(MKSTR(v30));
					VAL v32 = mtw_std_maybe_Maybe_1_Some(v31);
					x22 = v32;
					x21 = x1;
				} break;
				case 2LL: { // F64Like
					VAL v33 = mtp_mirth_type_CType_F64Like(x2);
					STR* v34;
					STRLIT(v34, "const ", 6);
					STR* v35 = str_cat(v34, VSTR(v33));
					VAL v36 = mtw_mirth_type_CType_F64Like(MKSTR(v35));
					VAL v37 = mtw_std_maybe_Maybe_1_Some(v36);
					x22 = v37;
					x21 = x1;
				} break;
				case 4LL: { // FnPtr
					VAL v38 = mtp_mirth_type_CType_FnPtr(x2);
					STR* v39;
					STRLIT(v39, "const ", 6);
					STR* v40 = str_cat(v39, VSTR(v38));
					VAL v41 = mtw_mirth_type_CType_FnPtr(MKSTR(v40));
					VAL v42 = mtw_std_maybe_Maybe_1_Some(v41);
					x22 = v42;
					x21 = x1;
				} break;
				case 3LL: { // PtrLike
					VAL v43 = mtp_mirth_type_CType_PtrLike(x2);
					STR* v44;
					STRLIT(v44, " const", 6);
					STR* v45 = str_cat(VSTR(v43), v44);
					VAL v46 = mtw_mirth_type_CType_PtrLike(MKSTR(v45));
					VAL v47 = mtw_std_maybe_Maybe_1_Some(v46);
					x22 = v47;
					x21 = x1;
				} break;
				case 5LL: { // Phantom
					VAL v48 = MKI64(5LL /* Phantom */);
					VAL v49 = mtw_std_maybe_Maybe_1_Some(v48);
					x22 = v49;
					x21 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x20 = x22;
			x19 = x21;
		} else {
			VAL v50 = VVAL(VTUP(x1)->cells[4]);
			incref(v50);
			uint64_t v51 = VU64(VTUP(v50)->cells[56]);
			decref(v50);
			int64_t v52 = mw_mirth_data_Data_ZEqualZEqual(x3, v51);
			VAL x53;
			VAL x54;
			if (((bool)v52)) {
				VAL x55;
				VAL x56;
				switch (get_data_tag(x2)) {
					case 0LL: { // IntLike
						VAL v57 = mtp_mirth_type_CType_IntLike(x2);
						STR* v58;
						STRLIT(v58, "restrict ", 9);
						STR* v59 = str_cat(v58, VSTR(v57));
						VAL v60 = mtw_mirth_type_CType_IntLike(MKSTR(v59));
						VAL v61 = mtw_std_maybe_Maybe_1_Some(v60);
						x56 = v61;
						x55 = x1;
					} break;
					case 1LL: { // F32Like
						VAL v62 = mtp_mirth_type_CType_F32Like(x2);
						STR* v63;
						STRLIT(v63, "restrict ", 9);
						STR* v64 = str_cat(v63, VSTR(v62));
						VAL v65 = mtw_mirth_type_CType_F32Like(MKSTR(v64));
						VAL v66 = mtw_std_maybe_Maybe_1_Some(v65);
						x56 = v66;
						x55 = x1;
					} break;
					case 2LL: { // F64Like
						VAL v67 = mtp_mirth_type_CType_F64Like(x2);
						STR* v68;
						STRLIT(v68, "restrict ", 9);
						STR* v69 = str_cat(v68, VSTR(v67));
						VAL v70 = mtw_mirth_type_CType_F64Like(MKSTR(v69));
						VAL v71 = mtw_std_maybe_Maybe_1_Some(v70);
						x56 = v71;
						x55 = x1;
					} break;
					case 4LL: { // FnPtr
						VAL v72 = mtp_mirth_type_CType_FnPtr(x2);
						STR* v73;
						STRLIT(v73, "restrict ", 9);
						STR* v74 = str_cat(v73, VSTR(v72));
						VAL v75 = mtw_mirth_type_CType_FnPtr(MKSTR(v74));
						VAL v76 = mtw_std_maybe_Maybe_1_Some(v75);
						x56 = v76;
						x55 = x1;
					} break;
					case 3LL: { // PtrLike
						VAL v77 = mtp_mirth_type_CType_PtrLike(x2);
						STR* v78;
						STRLIT(v78, " restrict", 9);
						STR* v79 = str_cat(VSTR(v77), v78);
						VAL v80 = mtw_mirth_type_CType_PtrLike(MKSTR(v79));
						VAL v81 = mtw_std_maybe_Maybe_1_Some(v80);
						x56 = v81;
						x55 = x1;
					} break;
					case 5LL: { // Phantom
						VAL v82 = MKI64(5LL /* Phantom */);
						VAL v83 = mtw_std_maybe_Maybe_1_Some(v82);
						x56 = v83;
						x55 = x1;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x54 = x56;
				x53 = x55;
			} else {
				VAL v84 = VVAL(VTUP(x1)->cells[4]);
				incref(v84);
				uint64_t v85 = VU64(VTUP(v84)->cells[58]);
				decref(v84);
				int64_t v86 = mw_mirth_data_Data_ZEqualZEqual(x3, v85);
				VAL x87;
				VAL x88;
				if (((bool)v86)) {
					VAL x89;
					VAL x90;
					switch (get_data_tag(x2)) {
						case 0LL: { // IntLike
							VAL v91 = mtp_mirth_type_CType_IntLike(x2);
							STR* v92;
							STRLIT(v92, "volatile ", 9);
							STR* v93 = str_cat(v92, VSTR(v91));
							VAL v94 = mtw_mirth_type_CType_IntLike(MKSTR(v93));
							VAL v95 = mtw_std_maybe_Maybe_1_Some(v94);
							x90 = v95;
							x89 = x1;
						} break;
						case 1LL: { // F32Like
							VAL v96 = mtp_mirth_type_CType_F32Like(x2);
							STR* v97;
							STRLIT(v97, "volatile ", 9);
							STR* v98 = str_cat(v97, VSTR(v96));
							VAL v99 = mtw_mirth_type_CType_F32Like(MKSTR(v98));
							VAL v100 = mtw_std_maybe_Maybe_1_Some(v99);
							x90 = v100;
							x89 = x1;
						} break;
						case 2LL: { // F64Like
							VAL v101 = mtp_mirth_type_CType_F64Like(x2);
							STR* v102;
							STRLIT(v102, "volatile ", 9);
							STR* v103 = str_cat(v102, VSTR(v101));
							VAL v104 = mtw_mirth_type_CType_F64Like(MKSTR(v103));
							VAL v105 = mtw_std_maybe_Maybe_1_Some(v104);
							x90 = v105;
							x89 = x1;
						} break;
						case 4LL: { // FnPtr
							VAL v106 = mtp_mirth_type_CType_FnPtr(x2);
							STR* v107;
							STRLIT(v107, "volatile ", 9);
							STR* v108 = str_cat(v107, VSTR(v106));
							VAL v109 = mtw_mirth_type_CType_FnPtr(MKSTR(v108));
							VAL v110 = mtw_std_maybe_Maybe_1_Some(v109);
							x90 = v110;
							x89 = x1;
						} break;
						case 3LL: { // PtrLike
							VAL v111 = mtp_mirth_type_CType_PtrLike(x2);
							STR* v112;
							STRLIT(v112, " volatile", 9);
							STR* v113 = str_cat(VSTR(v111), v112);
							VAL v114 = mtw_mirth_type_CType_PtrLike(MKSTR(v113));
							VAL v115 = mtw_std_maybe_Maybe_1_Some(v114);
							x90 = v115;
							x89 = x1;
						} break;
						case 5LL: { // Phantom
							VAL v116 = MKI64(5LL /* Phantom */);
							VAL v117 = mtw_std_maybe_Maybe_1_Some(v116);
							x90 = v117;
							x89 = x1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x88 = x90;
					x87 = x89;
				} else {
					decref(x2);
					VAL v118 = MKI64(0LL /* None */);
					x88 = v118;
					x87 = x1;
				}
				x54 = x88;
				x53 = x87;
			}
			x20 = x54;
			x19 = x53;
		}
		x10 = x20;
		x9 = x19;
	}
	*x5 = x10;
	*x4 = x9;
}
static VAL mw_mirth_type_CTypeStackPart_ctype (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // CTSPCons
			VAL v3 = mtp_mirth_type_CTypeStackPart_CTSPCons(x1);
			x2 = v3;
		} break;
		case 1LL: { // CTSPConsLabel
			VAL v4;
			uint64_t v5;
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x1, &v4, &v5);
			x2 = v4;
		} break;
		case 2LL: { // CTSPWith
			VAL v6 = mtp_mirth_type_CTypeStackPart_CTSPWith(x1);
			x2 = v6;
		} break;
		case 3LL: { // CTSPWithLabel
			VAL v7;
			uint64_t v8;
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x1, &v7, &v8);
			x2 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_type_CTypeStackPart_labelZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // CTSPCons
			VAL v3 = mtp_mirth_type_CTypeStackPart_CTSPCons(x1);
			decref(v3);
			VAL v4 = MKI64(0LL /* None */);
			x2 = v4;
		} break;
		case 1LL: { // CTSPConsLabel
			VAL v5;
			uint64_t v6;
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x1, &v5, &v6);
			decref(v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(MKU64(v6));
			x2 = v7;
		} break;
		case 2LL: { // CTSPWith
			VAL v8 = mtp_mirth_type_CTypeStackPart_CTSPWith(x1);
			decref(v8);
			VAL v9 = MKI64(0LL /* None */);
			x2 = v9;
		} break;
		case 3LL: { // CTSPWithLabel
			VAL v10;
			uint64_t v11;
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x1, &v10, &v11);
			decref(v10);
			VAL v12 = mtw_std_maybe_Maybe_1_Some(MKU64(v11));
			x2 = v12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_type_StackTypePart_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x1)) {
		case 0LL: { // STPCons
			VAL v7 = mtp_mirth_type_StackTypePart_STPCons(x1);
			VAL v8;
			VAL v9;
			mw_mirth_type_Type_ctype(x2, v7, &v8, &v9);
			VAL v10 = mtw_mirth_type_CTypeStackPart_CTSPCons(v9);
			x6 = v8;
			x5 = v10;
		} break;
		case 1LL: { // STPConsLabel
			VAL v11;
			uint64_t v12;
			mtp_mirth_type_StackTypePart_STPConsLabel(x1, &v11, &v12);
			VAL v13;
			VAL v14;
			mw_mirth_type_Type_ctype(x2, v11, &v13, &v14);
			VAL v15 = mtw_mirth_type_CTypeStackPart_CTSPConsLabel(v14, v12);
			x6 = v13;
			x5 = v15;
		} break;
		case 2LL: { // STPWith
			VAL v16 = mtp_mirth_type_StackTypePart_STPWith(x1);
			VAL v17;
			VAL v18;
			mw_mirth_type_Resource_ctype(x2, v16, &v17, &v18);
			VAL v19 = mtw_mirth_type_CTypeStackPart_CTSPWith(v18);
			x6 = v17;
			x5 = v19;
		} break;
		case 3LL: { // STPWithLabel
			VAL v20;
			uint64_t v21;
			mtp_mirth_type_StackTypePart_STPWithLabel(x1, &v20, &v21);
			VAL v22;
			VAL v23;
			mw_mirth_type_Resource_ctype(x2, v20, &v22, &v23);
			VAL v24 = mtw_mirth_type_CTypeStackPart_CTSPWithLabel(v23, v21);
			x6 = v22;
			x5 = v24;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_type_StackTypeBase_ctypeZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x1)) {
		case 0LL: { // STB_ERROR
			VAL v7 = MKI64(0LL /* None */);
			x6 = x2;
			x5 = v7;
		} break;
		case 1LL: { // STB_DONT_CARE
			VAL v8 = MKI64(0LL /* None */);
			x6 = x2;
			x5 = v8;
		} break;
		case 2LL: { // STB_UNIT
			VAL v9 = MKI64(0LL /* None */);
			x6 = x2;
			x5 = v9;
		} break;
		case 4LL: { // STBMeta
			uint64_t v10 = mtp_mirth_type_StackTypeBase_STBMeta(x1);
			VAL v11 = MKI64(0LL /* None */);
			x6 = x2;
			x5 = v11;
		} break;
		case 3LL: { // STBVar
			uint64_t v12 = mtp_mirth_type_StackTypeBase_STBVar(x1);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(MKU64(v12));
			x6 = x2;
			x5 = v13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_type_StackType_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_type_StackType_splitZ_parts(x1, &v5, &v6);
	VAL v7 = MKI64(0LL /* Nil */);
	VAL v8 = mw_std_list_List_1_reverse(v7);
	VAL v9;
	VAL v10;
	mw_std_list_List_1_uncons(v6, &v9, &v10);
	VAL x11;
	VAL x12;
	VAL x13;
	VAL x14;
	int64_t x15;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v9);
			VAL v17;
			VAL v18;
			mw_mirth_type_StackTypePart_ctype(v16, x2, &v17, &v18);
			VAL v19 = mtw_std_list_List_1_Cons(v17, v8);
			int64_t v20 = 1LL /* True */;
			x15 = v20;
			x14 = v10;
			x13 = v19;
			x12 = v5;
			x11 = v18;
		} break;
		case 0LL: { // None
			int64_t v21 = 0LL /* False */;
			x15 = v21;
			x14 = v10;
			x13 = v8;
			x12 = v5;
			x11 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v22 = (x11);
	VAL v23 = x12;
	VAL v24 = (x13);
	VAL v25 = x14;
	int64_t v26 = x15;
	while (((bool)v26)) {
		VAL v27 = (v22);
		VAL v28 = v23;
		VAL v29 = (v24);
		VAL v30 = v25;
		VAL v31;
		VAL v32;
		mw_std_list_List_1_uncons(v30, &v31, &v32);
		VAL x33;
		VAL x34;
		VAL x35;
		VAL x36;
		int64_t x37;
		switch (get_data_tag(v31)) {
			case 1LL: { // Some
				VAL v38 = mtp_std_maybe_Maybe_1_Some(v31);
				VAL v39;
				VAL v40;
				mw_mirth_type_StackTypePart_ctype(v38, v27, &v39, &v40);
				VAL v41 = mtw_std_list_List_1_Cons(v39, v29);
				int64_t v42 = 1LL /* True */;
				x37 = v42;
				x36 = v32;
				x35 = v41;
				x34 = v28;
				x33 = v40;
			} break;
			case 0LL: { // None
				int64_t v43 = 0LL /* False */;
				x37 = v43;
				x36 = v32;
				x35 = v29;
				x34 = v28;
				x33 = v27;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v26 = x37;
		v25 = x36;
		v24 = x35;
		v23 = x34;
		v22 = x33;
	}
	decref(v25);
	VAL v44 = mw_std_list_List_1_reverse(v24);
	VAL v45;
	VAL v46;
	mw_mirth_type_StackTypeBase_ctypeZAsk(v23, v22, &v45, &v46);
	VAL v47 = mtw_mirth_type_CTypeStack_CTypeStack(v45, v44);
	*x4 = v46;
	*x3 = v47;
}
static void mw_mirth_type_ArrowType_ctype (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_type_ArrowType_unpack(x1, &v5, &v6);
	VAL v7;
	VAL v8;
	mw_mirth_type_StackType_ctype(v5, x2, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_type_StackType_ctype(v6, v8, &v9, &v10);
	VAL v11 = mtw_mirth_type_CTypeArrow_CTypeArrow(v7, v9);
	*x4 = v10;
	*x3 = v11;
}
static void mw_mirth_prim_Prim_qname (VAL x1, int64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_name_Namespace_prim(x1, &v5, &v6);
	uint64_t v7 = mw_mirth_prim_Prim_name(x2);
	int64_t v8 = mw_mirth_prim_Prim_arity(x2);
	VAL v9 = mtw_mirth_name_QName_MKQNAME(v6, v7, v8);
	*x4 = v9;
	*x3 = v5;
}
static uint64_t mw_mirth_prim_Prim_name (int64_t x1) {
	void* v2 = mfld_mirth_prim_Prim_ZTildename(((uint64_t)x1));
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_prim_Prim_type (int64_t x1) {
	void* v2 = mfld_mirth_prim_Prim_ZTildetype(((uint64_t)x1));
	VAL v3 = mut_get(v2);
	return v3;
}
static int64_t mw_mirth_prim_Prim_arity (int64_t x1) {
	void* v2 = mfld_mirth_prim_Prim_ZTildearity(((uint64_t)x1));
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static int64_t mw_mirth_prim_Prim_ZToInt (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_prim_Prim_ZEqualZEqual (int64_t x1, int64_t x2) {
	int64_t v3 = mw_mirth_prim_Prim_ZToInt(x1);
	int64_t v4 = mw_mirth_prim_Prim_ZToInt(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static VAL mw_mirth_prim_defZ_primZBang (VAL x1, int64_t x2, VAL x3, int64_t x4) {
	uint64_t v5 = mw_std_prim_Str_ZToName(x3);
	void* v6 = mfld_mirth_prim_Prim_ZTildename(((uint64_t)x2));
	mut_set(MKU64(v5), v6);
	void* v7 = mfld_mirth_prim_Prim_ZTildearity(((uint64_t)x2));
	mut_set(MKI64(x4), v7);
	VAL v8 = mtw_mirth_def_Def_DefPrim(x2);
	VAL v9 = (mw_mirth_def_Def_register(x1, v8));
	return v9;
}
static void mw_mirth_prim_Prim_ctxZ_typeZBang (VAL x1, VAL x2, int64_t x3) {
	void* v4 = mfld_mirth_prim_Prim_ZTildetype(((uint64_t)x3));
	mut_set(x2, v4);
	void* v5 = mfld_mirth_prim_Prim_ZTildectx(((uint64_t)x3));
	mut_set(x1, v5);
}
static VAL mw_mirth_prim_initZ_primsZBang (VAL x1) {
	int64_t v2 = 102LL /* PRIM_SYNTAX_MODULE */;
	STR* v3;
	STRLIT(v3, "module", 6);
	int64_t v4 = -1LL;
	VAL v5 = (mw_mirth_prim_defZ_primZBang(x1, v2, MKSTR(v3), v4));
	int64_t v6 = 103LL /* PRIM_SYNTAX_IMPORT */;
	STR* v7;
	STRLIT(v7, "import", 6);
	int64_t v8 = -1LL;
	VAL v9 = (mw_mirth_prim_defZ_primZBang(v5, v6, MKSTR(v7), v8));
	int64_t v10 = 105LL /* PRIM_SYNTAX_INLINE */;
	STR* v11;
	STRLIT(v11, "inline", 6);
	int64_t v12 = -1LL;
	VAL v13 = (mw_mirth_prim_defZ_primZBang(v9, v10, MKSTR(v11), v12));
	int64_t v14 = 104LL /* PRIM_SYNTAX_ALIAS */;
	STR* v15;
	STRLIT(v15, "alias", 5);
	int64_t v16 = -1LL;
	VAL v17 = (mw_mirth_prim_defZ_primZBang(v13, v14, MKSTR(v15), v16));
	int64_t v18 = 106LL /* PRIM_SYNTAX_DEF */;
	STR* v19;
	STRLIT(v19, "def", 3);
	int64_t v20 = -1LL;
	VAL v21 = (mw_mirth_prim_defZ_primZBang(v17, v18, MKSTR(v19), v20));
	int64_t v22 = 108LL /* PRIM_SYNTAX_DEF_TYPE */;
	STR* v23;
	STRLIT(v23, "def-type", 8);
	int64_t v24 = -1LL;
	VAL v25 = (mw_mirth_prim_defZ_primZBang(v21, v22, MKSTR(v23), v24));
	int64_t v26 = 107LL /* PRIM_SYNTAX_DEF_MISSING */;
	STR* v27;
	STRLIT(v27, "def-missing", 11);
	int64_t v28 = -1LL;
	VAL v29 = (mw_mirth_prim_defZ_primZBang(v25, v26, MKSTR(v27), v28));
	int64_t v30 = 109LL /* PRIM_SYNTAX_BUFFER */;
	STR* v31;
	STRLIT(v31, "buffer", 6);
	int64_t v32 = -1LL;
	VAL v33 = (mw_mirth_prim_defZ_primZBang(v29, v30, MKSTR(v31), v32));
	int64_t v34 = 112LL /* PRIM_SYNTAX_DEF_EXTERNAL */;
	STR* v35;
	STRLIT(v35, "def-external", 12);
	int64_t v36 = -1LL;
	VAL v37 = (mw_mirth_prim_defZ_primZBang(v33, v34, MKSTR(v35), v36));
	int64_t v38 = 111LL /* PRIM_SYNTAX_EXTERNAL */;
	STR* v39;
	STRLIT(v39, "external", 8);
	int64_t v40 = -1LL;
	VAL v41 = (mw_mirth_prim_defZ_primZBang(v37, v38, MKSTR(v39), v40));
	int64_t v42 = 114LL /* PRIM_SYNTAX_TABLE */;
	STR* v43;
	STRLIT(v43, "table", 5);
	int64_t v44 = -1LL;
	VAL v45 = (mw_mirth_prim_defZ_primZBang(v41, v42, MKSTR(v43), v44));
	int64_t v46 = 115LL /* PRIM_SYNTAX_FIELD */;
	STR* v47;
	STRLIT(v47, "field", 5);
	int64_t v48 = -1LL;
	VAL v49 = (mw_mirth_prim_defZ_primZBang(v45, v46, MKSTR(v47), v48));
	int64_t v50 = 113LL /* PRIM_SYNTAX_EMBED_STR */;
	STR* v51;
	STRLIT(v51, "embed-str", 9);
	int64_t v52 = -1LL;
	VAL v53 = (mw_mirth_prim_defZ_primZBang(v49, v50, MKSTR(v51), v52));
	int64_t v54 = 116LL /* PRIM_SYNTAX_DATA */;
	STR* v55;
	STRLIT(v55, "data", 4);
	int64_t v56 = -1LL;
	VAL v57 = (mw_mirth_prim_defZ_primZBang(v53, v54, MKSTR(v55), v56));
	int64_t v58 = 117LL /* PRIM_SYNTAX_STRUCT */;
	STR* v59;
	STRLIT(v59, "struct", 6);
	int64_t v60 = -1LL;
	VAL v61 = (mw_mirth_prim_defZ_primZBang(v57, v58, MKSTR(v59), v60));
	int64_t v62 = 110LL /* PRIM_SYNTAX_VARIABLE */;
	STR* v63;
	STRLIT(v63, "var", 3);
	int64_t v64 = -1LL;
	VAL v65 = (mw_mirth_prim_defZ_primZBang(v61, v62, MKSTR(v63), v64));
	int64_t v66 = 119LL /* PRIM_SYNTAX_ARROW */;
	STR* v67;
	STRLIT(v67, "->", 2);
	int64_t v68 = -1LL;
	VAL v69 = (mw_mirth_prim_defZ_primZBang(v65, v66, MKSTR(v67), v68));
	int64_t v70 = 118LL /* PRIM_SYNTAX_DASHES */;
	STR* v71;
	STRLIT(v71, "--", 2);
	int64_t v72 = -1LL;
	VAL v73 = (mw_mirth_prim_defZ_primZBang(v69, v70, MKSTR(v71), v72));
	int64_t v74 = 5LL /* PRIM_CORE_DIP */;
	STR* v75;
	STRLIT(v75, "dip", 3);
	int64_t v76 = 1LL;
	VAL v77 = (mw_mirth_prim_defZ_primZBang(v73, v74, MKSTR(v75), v76));
	int64_t v78 = 8LL /* PRIM_CORE_WHILE */;
	STR* v79;
	STRLIT(v79, "while", 5);
	int64_t v80 = 2LL;
	VAL v81 = (mw_mirth_prim_defZ_primZBang(v77, v78, MKSTR(v79), v80));
	int64_t v82 = 12LL /* PRIM_CORE_MATCH */;
	STR* v83;
	STRLIT(v83, "match", 5);
	int64_t v84 = -1LL;
	VAL v85 = (mw_mirth_prim_defZ_primZBang(v81, v82, MKSTR(v83), v84));
	int64_t v86 = 13LL /* PRIM_CORE_LAMBDA */;
	STR* v87;
	STRLIT(v87, "\\", 1);
	int64_t v88 = -1LL;
	VAL v89 = (mw_mirth_prim_defZ_primZBang(v85, v86, MKSTR(v87), v88));
	int64_t v90 = 0LL /* PRIM_CORE_ID */;
	STR* v91;
	STRLIT(v91, "prim-id", 7);
	int64_t v92 = 0LL;
	VAL v93 = (mw_mirth_prim_defZ_primZBang(v89, v90, MKSTR(v91), v92));
	int64_t v94 = 1LL /* PRIM_CORE_DUP */;
	STR* v95;
	STRLIT(v95, "prim-dup", 8);
	int64_t v96 = 0LL;
	VAL v97 = (mw_mirth_prim_defZ_primZBang(v93, v94, MKSTR(v95), v96));
	int64_t v98 = 2LL /* PRIM_CORE_DROP */;
	STR* v99;
	STRLIT(v99, "prim-drop", 9);
	int64_t v100 = 0LL;
	VAL v101 = (mw_mirth_prim_defZ_primZBang(v97, v98, MKSTR(v99), v100));
	int64_t v102 = 3LL /* PRIM_CORE_SWAP */;
	STR* v103;
	STRLIT(v103, "prim-swap", 9);
	int64_t v104 = 0LL;
	VAL v105 = (mw_mirth_prim_defZ_primZBang(v101, v102, MKSTR(v103), v104));
	int64_t v106 = 5LL /* PRIM_CORE_DIP */;
	STR* v107;
	STRLIT(v107, "prim-dip", 8);
	int64_t v108 = 1LL;
	VAL v109 = (mw_mirth_prim_defZ_primZBang(v105, v106, MKSTR(v107), v108));
	int64_t v110 = 7LL /* PRIM_CORE_IF */;
	STR* v111;
	STRLIT(v111, "prim-if", 7);
	int64_t v112 = 2LL;
	VAL v113 = (mw_mirth_prim_defZ_primZBang(v109, v110, MKSTR(v111), v112));
	int64_t v114 = 8LL /* PRIM_CORE_WHILE */;
	STR* v115;
	STRLIT(v115, "prim-while", 10);
	int64_t v116 = 2LL;
	VAL v117 = (mw_mirth_prim_defZ_primZBang(v113, v114, MKSTR(v115), v116));
	int64_t v118 = 9LL /* PRIM_CORE_DEBUG */;
	STR* v119;
	STRLIT(v119, "prim-debug", 10);
	int64_t v120 = 0LL;
	VAL v121 = (mw_mirth_prim_defZ_primZBang(v117, v118, MKSTR(v119), v120));
	int64_t v122 = 10LL /* PRIM_CORE_PANIC */;
	STR* v123;
	STRLIT(v123, "prim-panic", 10);
	int64_t v124 = 0LL;
	VAL v125 = (mw_mirth_prim_defZ_primZBang(v121, v122, MKSTR(v123), v124));
	int64_t v126 = 11LL /* PRIM_CORE_RUN */;
	STR* v127;
	STRLIT(v127, "prim-run", 8);
	int64_t v128 = 0LL;
	VAL v129 = (mw_mirth_prim_defZ_primZBang(v125, v126, MKSTR(v127), v128));
	int64_t v130 = 12LL /* PRIM_CORE_MATCH */;
	STR* v131;
	STRLIT(v131, "prim-match", 10);
	int64_t v132 = -1LL;
	VAL v133 = (mw_mirth_prim_defZ_primZBang(v129, v130, MKSTR(v131), v132));
	int64_t v134 = 13LL /* PRIM_CORE_LAMBDA */;
	STR* v135;
	STRLIT(v135, "prim-lambda", 11);
	int64_t v136 = -1LL;
	VAL v137 = (mw_mirth_prim_defZ_primZBang(v133, v134, MKSTR(v135), v136));
	int64_t v138 = 4LL /* PRIM_CORE_RSWAP */;
	STR* v139;
	STRLIT(v139, "prim-rswap", 10);
	int64_t v140 = 0LL;
	VAL v141 = (mw_mirth_prim_defZ_primZBang(v137, v138, MKSTR(v139), v140));
	int64_t v142 = 6LL /* PRIM_CORE_RDIP */;
	STR* v143;
	STRLIT(v143, "prim-rdip", 9);
	int64_t v144 = 1LL;
	VAL v145 = (mw_mirth_prim_defZ_primZBang(v141, v142, MKSTR(v143), v144));
	int64_t v146 = 20LL /* PRIM_INT_ADD */;
	STR* v147;
	STRLIT(v147, "prim-int-add", 12);
	int64_t v148 = 0LL;
	VAL v149 = (mw_mirth_prim_defZ_primZBang(v145, v146, MKSTR(v147), v148));
	int64_t v150 = 21LL /* PRIM_INT_SUB */;
	STR* v151;
	STRLIT(v151, "prim-int-sub", 12);
	int64_t v152 = 0LL;
	VAL v153 = (mw_mirth_prim_defZ_primZBang(v149, v150, MKSTR(v151), v152));
	int64_t v154 = 22LL /* PRIM_INT_MUL */;
	STR* v155;
	STRLIT(v155, "prim-int-mul", 12);
	int64_t v156 = 0LL;
	VAL v157 = (mw_mirth_prim_defZ_primZBang(v153, v154, MKSTR(v155), v156));
	int64_t v158 = 23LL /* PRIM_INT_DIV */;
	STR* v159;
	STRLIT(v159, "prim-int-div", 12);
	int64_t v160 = 0LL;
	VAL v161 = (mw_mirth_prim_defZ_primZBang(v157, v158, MKSTR(v159), v160));
	int64_t v162 = 24LL /* PRIM_INT_MOD */;
	STR* v163;
	STRLIT(v163, "prim-int-mod", 12);
	int64_t v164 = 0LL;
	VAL v165 = (mw_mirth_prim_defZ_primZBang(v161, v162, MKSTR(v163), v164));
	int64_t v166 = 25LL /* PRIM_INT_AND */;
	STR* v167;
	STRLIT(v167, "prim-int-and", 12);
	int64_t v168 = 0LL;
	VAL v169 = (mw_mirth_prim_defZ_primZBang(v165, v166, MKSTR(v167), v168));
	int64_t v170 = 26LL /* PRIM_INT_OR */;
	STR* v171;
	STRLIT(v171, "prim-int-or", 11);
	int64_t v172 = 0LL;
	VAL v173 = (mw_mirth_prim_defZ_primZBang(v169, v170, MKSTR(v171), v172));
	int64_t v174 = 27LL /* PRIM_INT_XOR */;
	STR* v175;
	STRLIT(v175, "prim-int-xor", 12);
	int64_t v176 = 0LL;
	VAL v177 = (mw_mirth_prim_defZ_primZBang(v173, v174, MKSTR(v175), v176));
	int64_t v178 = 28LL /* PRIM_INT_SHL */;
	STR* v179;
	STRLIT(v179, "prim-int-shl", 12);
	int64_t v180 = 0LL;
	VAL v181 = (mw_mirth_prim_defZ_primZBang(v177, v178, MKSTR(v179), v180));
	int64_t v182 = 29LL /* PRIM_INT_SHR */;
	STR* v183;
	STRLIT(v183, "prim-int-shr", 12);
	int64_t v184 = 0LL;
	VAL v185 = (mw_mirth_prim_defZ_primZBang(v181, v182, MKSTR(v183), v184));
	int64_t v186 = 14LL /* PRIM_INT_EQ */;
	STR* v187;
	STRLIT(v187, "prim-int-eq", 11);
	int64_t v188 = 0LL;
	VAL v189 = (mw_mirth_prim_defZ_primZBang(v185, v186, MKSTR(v187), v188));
	int64_t v190 = 15LL /* PRIM_INT_LT */;
	STR* v191;
	STRLIT(v191, "prim-int-lt", 11);
	int64_t v192 = 0LL;
	VAL v193 = (mw_mirth_prim_defZ_primZBang(v189, v190, MKSTR(v191), v192));
	int64_t v194 = 16LL /* PRIM_INT_LE */;
	STR* v195;
	STRLIT(v195, "prim-int-le", 11);
	int64_t v196 = 0LL;
	VAL v197 = (mw_mirth_prim_defZ_primZBang(v193, v194, MKSTR(v195), v196));
	int64_t v198 = 17LL /* PRIM_INT_GT */;
	STR* v199;
	STRLIT(v199, "prim-int-gt", 11);
	int64_t v200 = 0LL;
	VAL v201 = (mw_mirth_prim_defZ_primZBang(v197, v198, MKSTR(v199), v200));
	int64_t v202 = 18LL /* PRIM_INT_GE */;
	STR* v203;
	STRLIT(v203, "prim-int-ge", 11);
	int64_t v204 = 0LL;
	VAL v205 = (mw_mirth_prim_defZ_primZBang(v201, v202, MKSTR(v203), v204));
	int64_t v206 = 19LL /* PRIM_INT_NE */;
	STR* v207;
	STRLIT(v207, "prim-int-ne", 11);
	int64_t v208 = 0LL;
	VAL v209 = (mw_mirth_prim_defZ_primZBang(v205, v206, MKSTR(v207), v208));
	int64_t v210 = 30LL /* PRIM_INT_TO_STR */;
	STR* v211;
	STRLIT(v211, "prim-int-to-str", 15);
	int64_t v212 = 0LL;
	VAL v213 = (mw_mirth_prim_defZ_primZBang(v209, v210, MKSTR(v211), v212));
	int64_t v214 = 31LL /* PRIM_INT_TO_F32 */;
	STR* v215;
	STRLIT(v215, "prim-int-to-float32", 19);
	int64_t v216 = 0LL;
	VAL v217 = (mw_mirth_prim_defZ_primZBang(v213, v214, MKSTR(v215), v216));
	int64_t v218 = 32LL /* PRIM_INT_TO_F64 */;
	STR* v219;
	STRLIT(v219, "prim-int-to-float64", 19);
	int64_t v220 = 0LL;
	VAL v221 = (mw_mirth_prim_defZ_primZBang(v217, v218, MKSTR(v219), v220));
	int64_t v222 = 31LL /* PRIM_INT_TO_F32 */;
	STR* v223;
	STRLIT(v223, "prim-int-to-f32", 15);
	int64_t v224 = 0LL;
	VAL v225 = (mw_mirth_prim_defZ_primZBang(v221, v222, MKSTR(v223), v224));
	int64_t v226 = 32LL /* PRIM_INT_TO_F64 */;
	STR* v227;
	STRLIT(v227, "prim-int-to-f64", 15);
	int64_t v228 = 0LL;
	VAL v229 = (mw_mirth_prim_defZ_primZBang(v225, v226, MKSTR(v227), v228));
	int64_t v230 = 33LL /* PRIM_F32_EQ */;
	STR* v231;
	STRLIT(v231, "prim-f32-eq", 11);
	int64_t v232 = 0LL;
	VAL v233 = (mw_mirth_prim_defZ_primZBang(v229, v230, MKSTR(v231), v232));
	int64_t v234 = 34LL /* PRIM_F32_LT */;
	STR* v235;
	STRLIT(v235, "prim-f32-lt", 11);
	int64_t v236 = 0LL;
	VAL v237 = (mw_mirth_prim_defZ_primZBang(v233, v234, MKSTR(v235), v236));
	int64_t v238 = 35LL /* PRIM_F32_ADD */;
	STR* v239;
	STRLIT(v239, "prim-f32-add", 12);
	int64_t v240 = 0LL;
	VAL v241 = (mw_mirth_prim_defZ_primZBang(v237, v238, MKSTR(v239), v240));
	int64_t v242 = 36LL /* PRIM_F32_SUB */;
	STR* v243;
	STRLIT(v243, "prim-f32-sub", 12);
	int64_t v244 = 0LL;
	VAL v245 = (mw_mirth_prim_defZ_primZBang(v241, v242, MKSTR(v243), v244));
	int64_t v246 = 37LL /* PRIM_F32_MUL */;
	STR* v247;
	STRLIT(v247, "prim-f32-mul", 12);
	int64_t v248 = 0LL;
	VAL v249 = (mw_mirth_prim_defZ_primZBang(v245, v246, MKSTR(v247), v248));
	int64_t v250 = 38LL /* PRIM_F32_DIV */;
	STR* v251;
	STRLIT(v251, "prim-f32-div", 12);
	int64_t v252 = 0LL;
	VAL v253 = (mw_mirth_prim_defZ_primZBang(v249, v250, MKSTR(v251), v252));
	int64_t v254 = 39LL /* PRIM_F32_TO_INT */;
	STR* v255;
	STRLIT(v255, "prim-f32-to-int", 15);
	int64_t v256 = 0LL;
	VAL v257 = (mw_mirth_prim_defZ_primZBang(v253, v254, MKSTR(v255), v256));
	int64_t v258 = 40LL /* PRIM_F32_TO_STR */;
	STR* v259;
	STRLIT(v259, "prim-f32-to-str", 15);
	int64_t v260 = 0LL;
	VAL v261 = (mw_mirth_prim_defZ_primZBang(v257, v258, MKSTR(v259), v260));
	int64_t v262 = 41LL /* PRIM_F32_TO_F64 */;
	STR* v263;
	STRLIT(v263, "prim-f32-to-f64", 15);
	int64_t v264 = 0LL;
	VAL v265 = (mw_mirth_prim_defZ_primZBang(v261, v262, MKSTR(v263), v264));
	int64_t v266 = 42LL /* PRIM_F64_EQ */;
	STR* v267;
	STRLIT(v267, "prim-f64-eq", 11);
	int64_t v268 = 0LL;
	VAL v269 = (mw_mirth_prim_defZ_primZBang(v265, v266, MKSTR(v267), v268));
	int64_t v270 = 43LL /* PRIM_F64_LT */;
	STR* v271;
	STRLIT(v271, "prim-f64-lt", 11);
	int64_t v272 = 0LL;
	VAL v273 = (mw_mirth_prim_defZ_primZBang(v269, v270, MKSTR(v271), v272));
	int64_t v274 = 44LL /* PRIM_F64_ADD */;
	STR* v275;
	STRLIT(v275, "prim-f64-add", 12);
	int64_t v276 = 0LL;
	VAL v277 = (mw_mirth_prim_defZ_primZBang(v273, v274, MKSTR(v275), v276));
	int64_t v278 = 45LL /* PRIM_F64_SUB */;
	STR* v279;
	STRLIT(v279, "prim-f64-sub", 12);
	int64_t v280 = 0LL;
	VAL v281 = (mw_mirth_prim_defZ_primZBang(v277, v278, MKSTR(v279), v280));
	int64_t v282 = 46LL /* PRIM_F64_MUL */;
	STR* v283;
	STRLIT(v283, "prim-f64-mul", 12);
	int64_t v284 = 0LL;
	VAL v285 = (mw_mirth_prim_defZ_primZBang(v281, v282, MKSTR(v283), v284));
	int64_t v286 = 47LL /* PRIM_F64_DIV */;
	STR* v287;
	STRLIT(v287, "prim-f64-div", 12);
	int64_t v288 = 0LL;
	VAL v289 = (mw_mirth_prim_defZ_primZBang(v285, v286, MKSTR(v287), v288));
	int64_t v290 = 48LL /* PRIM_F64_TO_INT */;
	STR* v291;
	STRLIT(v291, "prim-f64-to-int", 15);
	int64_t v292 = 0LL;
	VAL v293 = (mw_mirth_prim_defZ_primZBang(v289, v290, MKSTR(v291), v292));
	int64_t v294 = 49LL /* PRIM_F64_TO_STR */;
	STR* v295;
	STRLIT(v295, "prim-f64-to-str", 15);
	int64_t v296 = 0LL;
	VAL v297 = (mw_mirth_prim_defZ_primZBang(v293, v294, MKSTR(v295), v296));
	int64_t v298 = 50LL /* PRIM_F64_TO_F32 */;
	STR* v299;
	STRLIT(v299, "prim-f64-to-f32", 15);
	int64_t v300 = 0LL;
	VAL v301 = (mw_mirth_prim_defZ_primZBang(v297, v298, MKSTR(v299), v300));
	int64_t v302 = 51LL /* PRIM_BOOL_AND */;
	STR* v303;
	STRLIT(v303, "prim-bool-and", 13);
	int64_t v304 = 0LL;
	VAL v305 = (mw_mirth_prim_defZ_primZBang(v301, v302, MKSTR(v303), v304));
	int64_t v306 = 52LL /* PRIM_BOOL_OR */;
	STR* v307;
	STRLIT(v307, "prim-bool-or", 12);
	int64_t v308 = 0LL;
	VAL v309 = (mw_mirth_prim_defZ_primZBang(v305, v306, MKSTR(v307), v308));
	int64_t v310 = 53LL /* PRIM_BOOL_NOT */;
	STR* v311;
	STRLIT(v311, "prim-bool-not", 13);
	int64_t v312 = 0LL;
	VAL v313 = (mw_mirth_prim_defZ_primZBang(v309, v310, MKSTR(v311), v312));
	int64_t v314 = 54LL /* PRIM_PACK_NIL */;
	STR* v315;
	STRLIT(v315, "prim-pack-nil", 13);
	int64_t v316 = 0LL;
	VAL v317 = (mw_mirth_prim_defZ_primZBang(v313, v314, MKSTR(v315), v316));
	int64_t v318 = 55LL /* PRIM_PACK_CONS */;
	STR* v319;
	STRLIT(v319, "prim-pack-cons", 14);
	int64_t v320 = 0LL;
	VAL v321 = (mw_mirth_prim_defZ_primZBang(v317, v318, MKSTR(v319), v320));
	int64_t v322 = 56LL /* PRIM_PACK_UNCONS */;
	STR* v323;
	STRLIT(v323, "prim-pack-uncons", 16);
	int64_t v324 = 0LL;
	VAL v325 = (mw_mirth_prim_defZ_primZBang(v321, v322, MKSTR(v323), v324));
	int64_t v326 = 57LL /* PRIM_MUT_GET */;
	STR* v327;
	STRLIT(v327, "prim-mut-get", 12);
	int64_t v328 = 0LL;
	VAL v329 = (mw_mirth_prim_defZ_primZBang(v325, v326, MKSTR(v327), v328));
	int64_t v330 = 58LL /* PRIM_MUT_SET */;
	STR* v331;
	STRLIT(v331, "prim-mut-set", 12);
	int64_t v332 = 0LL;
	VAL v333 = (mw_mirth_prim_defZ_primZBang(v329, v330, MKSTR(v331), v332));
	int64_t v334 = 59LL /* PRIM_MUT_IS_SET */;
	STR* v335;
	STRLIT(v335, "prim-mut-is-set", 15);
	int64_t v336 = 0LL;
	VAL v337 = (mw_mirth_prim_defZ_primZBang(v333, v334, MKSTR(v335), v336));
	int64_t v338 = 60LL /* PRIM_PTR_NIL */;
	STR* v339;
	STRLIT(v339, "prim-ptr-nil", 12);
	int64_t v340 = 0LL;
	VAL v341 = (mw_mirth_prim_defZ_primZBang(v337, v338, MKSTR(v339), v340));
	int64_t v342 = 61LL /* PRIM_PTR_EQ */;
	STR* v343;
	STRLIT(v343, "prim-ptr-eq", 11);
	int64_t v344 = 0LL;
	VAL v345 = (mw_mirth_prim_defZ_primZBang(v341, v342, MKSTR(v343), v344));
	int64_t v346 = 62LL /* PRIM_PTR_ADD */;
	STR* v347;
	STRLIT(v347, "prim-ptr-add", 12);
	int64_t v348 = 0LL;
	VAL v349 = (mw_mirth_prim_defZ_primZBang(v345, v346, MKSTR(v347), v348));
	int64_t v350 = 63LL /* PRIM_PTR_SIZE */;
	STR* v351;
	STRLIT(v351, "prim-ptr-size", 13);
	int64_t v352 = 0LL;
	VAL v353 = (mw_mirth_prim_defZ_primZBang(v349, v350, MKSTR(v351), v352));
	int64_t v354 = 88LL /* PRIM_PTR_GET */;
	STR* v355;
	STRLIT(v355, "prim-ptr-get", 12);
	int64_t v356 = 0LL;
	VAL v357 = (mw_mirth_prim_defZ_primZBang(v353, v354, MKSTR(v355), v356));
	int64_t v358 = 97LL /* PRIM_PTR_SET */;
	STR* v359;
	STRLIT(v359, "prim-ptr-set", 12);
	int64_t v360 = 0LL;
	VAL v361 = (mw_mirth_prim_defZ_primZBang(v357, v358, MKSTR(v359), v360));
	int64_t v362 = 64LL /* PRIM_PTR_ALLOC */;
	STR* v363;
	STRLIT(v363, "prim-ptr-alloc", 14);
	int64_t v364 = 0LL;
	VAL v365 = (mw_mirth_prim_defZ_primZBang(v361, v362, MKSTR(v363), v364));
	int64_t v366 = 65LL /* PRIM_PTR_REALLOC */;
	STR* v367;
	STRLIT(v367, "prim-ptr-realloc", 16);
	int64_t v368 = 0LL;
	VAL v369 = (mw_mirth_prim_defZ_primZBang(v365, v366, MKSTR(v367), v368));
	int64_t v370 = 66LL /* PRIM_PTR_FREE */;
	STR* v371;
	STRLIT(v371, "prim-ptr-free", 13);
	int64_t v372 = 0LL;
	VAL v373 = (mw_mirth_prim_defZ_primZBang(v369, v370, MKSTR(v371), v372));
	int64_t v374 = 68LL /* PRIM_PTR_FILL */;
	STR* v375;
	STRLIT(v375, "prim-ptr-fill", 13);
	int64_t v376 = 0LL;
	VAL v377 = (mw_mirth_prim_defZ_primZBang(v373, v374, MKSTR(v375), v376));
	int64_t v378 = 67LL /* PRIM_PTR_COPY */;
	STR* v379;
	STRLIT(v379, "prim-ptr-copy", 13);
	int64_t v380 = 0LL;
	VAL v381 = (mw_mirth_prim_defZ_primZBang(v377, v378, MKSTR(v379), v380));
	int64_t v382 = 69LL /* PRIM_STR_COPY */;
	STR* v383;
	STRLIT(v383, "prim-str-copy", 13);
	int64_t v384 = 0LL;
	VAL v385 = (mw_mirth_prim_defZ_primZBang(v381, v382, MKSTR(v383), v384));
	int64_t v386 = 70LL /* PRIM_STR_NUM_BYTES */;
	STR* v387;
	STRLIT(v387, "prim-str-num-bytes", 18);
	int64_t v388 = 0LL;
	VAL v389 = (mw_mirth_prim_defZ_primZBang(v385, v386, MKSTR(v387), v388));
	int64_t v390 = 71LL /* PRIM_STR_BASE */;
	STR* v391;
	STRLIT(v391, "prim-str-base", 13);
	int64_t v392 = 0LL;
	VAL v393 = (mw_mirth_prim_defZ_primZBang(v389, v390, MKSTR(v391), v392));
	int64_t v394 = 72LL /* PRIM_STR_CAT */;
	STR* v395;
	STRLIT(v395, "prim-str-cat", 12);
	int64_t v396 = 0LL;
	VAL v397 = (mw_mirth_prim_defZ_primZBang(v393, v394, MKSTR(v395), v396));
	int64_t v398 = 73LL /* PRIM_STR_CMP */;
	STR* v399;
	STRLIT(v399, "prim-str-cmp", 12);
	int64_t v400 = 0LL;
	VAL v401 = (mw_mirth_prim_defZ_primZBang(v397, v398, MKSTR(v399), v400));
	int64_t v402 = 74LL /* PRIM_STR_EQ */;
	STR* v403;
	STRLIT(v403, "prim-str-eq", 11);
	int64_t v404 = 0LL;
	VAL v405 = (mw_mirth_prim_defZ_primZBang(v401, v402, MKSTR(v403), v404));
	int64_t v406 = 75LL /* PRIM_STR_LT */;
	STR* v407;
	STRLIT(v407, "prim-str-lt", 11);
	int64_t v408 = 0LL;
	VAL v409 = (mw_mirth_prim_defZ_primZBang(v405, v406, MKSTR(v407), v408));
	int64_t v410 = 76LL /* PRIM_STR_LE */;
	STR* v411;
	STRLIT(v411, "prim-str-le", 11);
	int64_t v412 = 0LL;
	VAL v413 = (mw_mirth_prim_defZ_primZBang(v409, v410, MKSTR(v411), v412));
	int64_t v414 = 77LL /* PRIM_STR_GT */;
	STR* v415;
	STRLIT(v415, "prim-str-gt", 11);
	int64_t v416 = 0LL;
	VAL v417 = (mw_mirth_prim_defZ_primZBang(v413, v414, MKSTR(v415), v416));
	int64_t v418 = 78LL /* PRIM_STR_GE */;
	STR* v419;
	STRLIT(v419, "prim-str-ge", 11);
	int64_t v420 = 0LL;
	VAL v421 = (mw_mirth_prim_defZ_primZBang(v417, v418, MKSTR(v419), v420));
	int64_t v422 = 79LL /* PRIM_STR_NE */;
	STR* v423;
	STRLIT(v423, "prim-str-ne", 11);
	int64_t v424 = 0LL;
	VAL v425 = (mw_mirth_prim_defZ_primZBang(v421, v422, MKSTR(v423), v424));
	int64_t v426 = 80LL /* PRIM_U8_GET */;
	STR* v427;
	STRLIT(v427, "prim-u8-get", 11);
	int64_t v428 = 0LL;
	VAL v429 = (mw_mirth_prim_defZ_primZBang(v425, v426, MKSTR(v427), v428));
	int64_t v430 = 89LL /* PRIM_U8_SET */;
	STR* v431;
	STRLIT(v431, "prim-u8-set", 11);
	int64_t v432 = 0LL;
	VAL v433 = (mw_mirth_prim_defZ_primZBang(v429, v430, MKSTR(v431), v432));
	int64_t v434 = 81LL /* PRIM_U16_GET */;
	STR* v435;
	STRLIT(v435, "prim-u16-get", 12);
	int64_t v436 = 0LL;
	VAL v437 = (mw_mirth_prim_defZ_primZBang(v433, v434, MKSTR(v435), v436));
	int64_t v438 = 90LL /* PRIM_U16_SET */;
	STR* v439;
	STRLIT(v439, "prim-u16-set", 12);
	int64_t v440 = 0LL;
	VAL v441 = (mw_mirth_prim_defZ_primZBang(v437, v438, MKSTR(v439), v440));
	int64_t v442 = 82LL /* PRIM_U32_GET */;
	STR* v443;
	STRLIT(v443, "prim-u32-get", 12);
	int64_t v444 = 0LL;
	VAL v445 = (mw_mirth_prim_defZ_primZBang(v441, v442, MKSTR(v443), v444));
	int64_t v446 = 91LL /* PRIM_U32_SET */;
	STR* v447;
	STRLIT(v447, "prim-u32-set", 12);
	int64_t v448 = 0LL;
	VAL v449 = (mw_mirth_prim_defZ_primZBang(v445, v446, MKSTR(v447), v448));
	int64_t v450 = 83LL /* PRIM_U64_GET */;
	STR* v451;
	STRLIT(v451, "prim-u64-get", 12);
	int64_t v452 = 0LL;
	VAL v453 = (mw_mirth_prim_defZ_primZBang(v449, v450, MKSTR(v451), v452));
	int64_t v454 = 92LL /* PRIM_U64_SET */;
	STR* v455;
	STRLIT(v455, "prim-u64-set", 12);
	int64_t v456 = 0LL;
	VAL v457 = (mw_mirth_prim_defZ_primZBang(v453, v454, MKSTR(v455), v456));
	int64_t v458 = 84LL /* PRIM_I8_GET */;
	STR* v459;
	STRLIT(v459, "prim-i8-get", 11);
	int64_t v460 = 0LL;
	VAL v461 = (mw_mirth_prim_defZ_primZBang(v457, v458, MKSTR(v459), v460));
	int64_t v462 = 93LL /* PRIM_I8_SET */;
	STR* v463;
	STRLIT(v463, "prim-i8-set", 11);
	int64_t v464 = 0LL;
	VAL v465 = (mw_mirth_prim_defZ_primZBang(v461, v462, MKSTR(v463), v464));
	int64_t v466 = 85LL /* PRIM_I16_GET */;
	STR* v467;
	STRLIT(v467, "prim-i16-get", 12);
	int64_t v468 = 0LL;
	VAL v469 = (mw_mirth_prim_defZ_primZBang(v465, v466, MKSTR(v467), v468));
	int64_t v470 = 94LL /* PRIM_I16_SET */;
	STR* v471;
	STRLIT(v471, "prim-i16-set", 12);
	int64_t v472 = 0LL;
	VAL v473 = (mw_mirth_prim_defZ_primZBang(v469, v470, MKSTR(v471), v472));
	int64_t v474 = 86LL /* PRIM_I32_GET */;
	STR* v475;
	STRLIT(v475, "prim-i32-get", 12);
	int64_t v476 = 0LL;
	VAL v477 = (mw_mirth_prim_defZ_primZBang(v473, v474, MKSTR(v475), v476));
	int64_t v478 = 95LL /* PRIM_I32_SET */;
	STR* v479;
	STRLIT(v479, "prim-i32-set", 12);
	int64_t v480 = 0LL;
	VAL v481 = (mw_mirth_prim_defZ_primZBang(v477, v478, MKSTR(v479), v480));
	int64_t v482 = 87LL /* PRIM_I64_GET */;
	STR* v483;
	STRLIT(v483, "prim-i64-get", 12);
	int64_t v484 = 0LL;
	VAL v485 = (mw_mirth_prim_defZ_primZBang(v481, v482, MKSTR(v483), v484));
	int64_t v486 = 96LL /* PRIM_I64_SET */;
	STR* v487;
	STRLIT(v487, "prim-i64-set", 12);
	int64_t v488 = 0LL;
	VAL v489 = (mw_mirth_prim_defZ_primZBang(v485, v486, MKSTR(v487), v488));
	int64_t v490 = 98LL /* PRIM_SYS_OS */;
	STR* v491;
	STRLIT(v491, "prim-sys-os", 11);
	int64_t v492 = 0LL;
	VAL v493 = (mw_mirth_prim_defZ_primZBang(v489, v490, MKSTR(v491), v492));
	int64_t v494 = 99LL /* PRIM_SYS_ARCH */;
	STR* v495;
	STRLIT(v495, "prim-sys-arch", 13);
	int64_t v496 = 0LL;
	VAL v497 = (mw_mirth_prim_defZ_primZBang(v493, v494, MKSTR(v495), v496));
	int64_t v498 = 100LL /* PRIM_SYS_ARGC */;
	STR* v499;
	STRLIT(v499, "prim-sys-argc", 13);
	int64_t v500 = 0LL;
	VAL v501 = (mw_mirth_prim_defZ_primZBang(v497, v498, MKSTR(v499), v500));
	int64_t v502 = 101LL /* PRIM_SYS_ARGV */;
	STR* v503;
	STRLIT(v503, "prim-sys-argv", 13);
	int64_t v504 = 0LL;
	VAL v505 = (mw_mirth_prim_defZ_primZBang(v501, v502, MKSTR(v503), v504));
	VAL v506 = mw_mirth_var_Ctx0();
	VAL v507 = mw_mirth_type_T0();
	VAL v508 = mw_mirth_type_T0();
	VAL v509 = mw_mirth_type_TZ_ZTo(v507, v508);
	incref(v506);
	incref(v509);
	int64_t v510 = 0LL /* PRIM_CORE_ID */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v506, v509, v510);
	incref(v506);
	incref(v509);
	int64_t v511 = 9LL /* PRIM_CORE_DEBUG */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v506, v509, v511);
	decref(v509);
	decref(v506);
	VAL v512 = mw_mirth_var_Ctx0();
	VAL v513 = mw_mirth_type_TYPEz_INT();
	VAL v514 = mw_mirth_type_TYPEz_INT();
	VAL v515 = mw_mirth_type_T2(v513, v514);
	VAL v516 = mw_mirth_type_TYPEz_INT();
	VAL v517 = mw_mirth_type_T1(v516);
	VAL v518 = mw_mirth_type_TZ_ZTo(v515, v517);
	incref(v512);
	incref(v518);
	int64_t v519 = 20LL /* PRIM_INT_ADD */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v519);
	incref(v512);
	incref(v518);
	int64_t v520 = 21LL /* PRIM_INT_SUB */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v520);
	incref(v512);
	incref(v518);
	int64_t v521 = 22LL /* PRIM_INT_MUL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v521);
	incref(v512);
	incref(v518);
	int64_t v522 = 23LL /* PRIM_INT_DIV */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v522);
	incref(v512);
	incref(v518);
	int64_t v523 = 24LL /* PRIM_INT_MOD */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v523);
	incref(v512);
	incref(v518);
	int64_t v524 = 25LL /* PRIM_INT_AND */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v524);
	incref(v512);
	incref(v518);
	int64_t v525 = 26LL /* PRIM_INT_OR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v525);
	incref(v512);
	incref(v518);
	int64_t v526 = 27LL /* PRIM_INT_XOR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v526);
	incref(v512);
	incref(v518);
	int64_t v527 = 28LL /* PRIM_INT_SHL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v527);
	incref(v512);
	incref(v518);
	int64_t v528 = 29LL /* PRIM_INT_SHR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v518, v528);
	decref(v518);
	decref(v512);
	VAL v529 = mw_mirth_var_Ctx0();
	VAL v530 = mw_mirth_type_TYPEz_INT();
	VAL v531 = mw_mirth_type_TYPEz_INT();
	VAL v532 = mw_mirth_type_T2(v530, v531);
	VAL v533;
	VAL v534;
	mw_mirth_data_TYPEz_BOOL(v505, &v533, &v534);
	VAL v535 = mw_mirth_type_T1(v534);
	VAL v536 = mw_mirth_type_TZ_ZTo(v532, v535);
	incref(v529);
	incref(v536);
	int64_t v537 = 14LL /* PRIM_INT_EQ */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v529, v536, v537);
	incref(v529);
	incref(v536);
	int64_t v538 = 15LL /* PRIM_INT_LT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v529, v536, v538);
	incref(v529);
	incref(v536);
	int64_t v539 = 16LL /* PRIM_INT_LE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v529, v536, v539);
	incref(v529);
	incref(v536);
	int64_t v540 = 17LL /* PRIM_INT_GT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v529, v536, v540);
	incref(v529);
	incref(v536);
	int64_t v541 = 18LL /* PRIM_INT_GE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v529, v536, v541);
	incref(v529);
	incref(v536);
	int64_t v542 = 19LL /* PRIM_INT_NE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v529, v536, v542);
	decref(v536);
	decref(v529);
	VAL v543 = mw_mirth_var_Ctx0();
	VAL v544 = mw_mirth_type_TYPEz_F32();
	VAL v545 = mw_mirth_type_TYPEz_F32();
	VAL v546 = mw_mirth_type_T2(v544, v545);
	VAL v547;
	VAL v548;
	mw_mirth_data_TYPEz_BOOL(v533, &v547, &v548);
	VAL v549 = mw_mirth_type_T1(v548);
	VAL v550 = mw_mirth_type_TZ_ZTo(v546, v549);
	incref(v543);
	incref(v550);
	int64_t v551 = 33LL /* PRIM_F32_EQ */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v543, v550, v551);
	incref(v543);
	incref(v550);
	int64_t v552 = 34LL /* PRIM_F32_LT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v543, v550, v552);
	decref(v550);
	decref(v543);
	VAL v553 = mw_mirth_var_Ctx0();
	VAL v554 = mw_mirth_type_TYPEz_F64();
	VAL v555 = mw_mirth_type_TYPEz_F64();
	VAL v556 = mw_mirth_type_T2(v554, v555);
	VAL v557;
	VAL v558;
	mw_mirth_data_TYPEz_BOOL(v547, &v557, &v558);
	VAL v559 = mw_mirth_type_T1(v558);
	VAL v560 = mw_mirth_type_TZ_ZTo(v556, v559);
	incref(v553);
	incref(v560);
	int64_t v561 = 42LL /* PRIM_F64_EQ */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v553, v560, v561);
	incref(v553);
	incref(v560);
	int64_t v562 = 43LL /* PRIM_F64_LT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v553, v560, v562);
	decref(v560);
	decref(v553);
	VAL v563 = mw_mirth_var_Ctx0();
	VAL v564 = mw_mirth_type_TYPEz_F32();
	VAL v565 = mw_mirth_type_TYPEz_F32();
	VAL v566 = mw_mirth_type_T2(v564, v565);
	VAL v567 = mw_mirth_type_TYPEz_F32();
	VAL v568 = mw_mirth_type_T1(v567);
	VAL v569 = mw_mirth_type_TZ_ZTo(v566, v568);
	incref(v563);
	incref(v569);
	int64_t v570 = 35LL /* PRIM_F32_ADD */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v563, v569, v570);
	incref(v563);
	incref(v569);
	int64_t v571 = 36LL /* PRIM_F32_SUB */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v563, v569, v571);
	incref(v563);
	incref(v569);
	int64_t v572 = 37LL /* PRIM_F32_MUL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v563, v569, v572);
	incref(v563);
	incref(v569);
	int64_t v573 = 38LL /* PRIM_F32_DIV */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v563, v569, v573);
	decref(v569);
	decref(v563);
	VAL v574 = mw_mirth_var_Ctx0();
	VAL v575 = mw_mirth_type_TYPEz_F64();
	VAL v576 = mw_mirth_type_TYPEz_F64();
	VAL v577 = mw_mirth_type_T2(v575, v576);
	VAL v578 = mw_mirth_type_TYPEz_F64();
	VAL v579 = mw_mirth_type_T1(v578);
	VAL v580 = mw_mirth_type_TZ_ZTo(v577, v579);
	incref(v574);
	incref(v580);
	int64_t v581 = 44LL /* PRIM_F64_ADD */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v574, v580, v581);
	incref(v574);
	incref(v580);
	int64_t v582 = 45LL /* PRIM_F64_SUB */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v574, v580, v582);
	incref(v574);
	incref(v580);
	int64_t v583 = 46LL /* PRIM_F64_MUL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v574, v580, v583);
	incref(v574);
	incref(v580);
	int64_t v584 = 47LL /* PRIM_F64_DIV */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v574, v580, v584);
	decref(v580);
	decref(v574);
	VAL v585 = mw_mirth_var_Ctx0();
	VAL v586;
	VAL v587;
	mw_mirth_data_TYPEz_BOOL(v557, &v586, &v587);
	VAL v588;
	VAL v589;
	mw_mirth_data_TYPEz_BOOL(v586, &v588, &v589);
	VAL v590 = mw_mirth_type_T2(v587, v589);
	VAL v591;
	VAL v592;
	mw_mirth_data_TYPEz_BOOL(v588, &v591, &v592);
	VAL v593 = mw_mirth_type_T1(v592);
	VAL v594 = mw_mirth_type_TZ_ZTo(v590, v593);
	incref(v585);
	incref(v594);
	int64_t v595 = 51LL /* PRIM_BOOL_AND */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v585, v594, v595);
	incref(v585);
	incref(v594);
	int64_t v596 = 52LL /* PRIM_BOOL_OR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v585, v594, v596);
	decref(v594);
	decref(v585);
	VAL v597 = mw_mirth_var_Ctx0();
	VAL v598;
	VAL v599;
	mw_mirth_data_TYPEz_BOOL(v591, &v598, &v599);
	VAL v600 = mw_mirth_type_T1(v599);
	VAL v601;
	VAL v602;
	mw_mirth_data_TYPEz_BOOL(v598, &v601, &v602);
	VAL v603 = mw_mirth_type_T1(v602);
	VAL v604 = mw_mirth_type_TZ_ZTo(v600, v603);
	int64_t v605 = 53LL /* PRIM_BOOL_NOT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v597, v604, v605);
	VAL v606 = mw_mirth_var_Ctx0();
	VAL v607 = mw_mirth_type_TYPEz_INT();
	VAL v608 = mw_mirth_type_T1(v607);
	VAL v609 = mw_mirth_type_TYPEz_STR();
	VAL v610 = mw_mirth_type_T1(v609);
	VAL v611 = mw_mirth_type_TZ_ZTo(v608, v610);
	int64_t v612 = 30LL /* PRIM_INT_TO_STR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v606, v611, v612);
	VAL v613 = mw_mirth_var_Ctx0();
	VAL v614 = mw_mirth_type_TYPEz_INT();
	VAL v615 = mw_mirth_type_T1(v614);
	VAL v616 = mw_mirth_type_TYPEz_F32();
	VAL v617 = mw_mirth_type_T1(v616);
	VAL v618 = mw_mirth_type_TZ_ZTo(v615, v617);
	int64_t v619 = 31LL /* PRIM_INT_TO_F32 */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v613, v618, v619);
	VAL v620 = mw_mirth_var_Ctx0();
	VAL v621 = mw_mirth_type_TYPEz_INT();
	VAL v622 = mw_mirth_type_T1(v621);
	VAL v623 = mw_mirth_type_TYPEz_F64();
	VAL v624 = mw_mirth_type_T1(v623);
	VAL v625 = mw_mirth_type_TZ_ZTo(v622, v624);
	int64_t v626 = 32LL /* PRIM_INT_TO_F64 */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v620, v625, v626);
	VAL v627 = mw_mirth_var_Ctx0();
	VAL v628 = mw_mirth_type_TYPEz_F32();
	VAL v629 = mw_mirth_type_T1(v628);
	VAL v630 = mw_mirth_type_TYPEz_STR();
	VAL v631 = mw_mirth_type_T1(v630);
	VAL v632 = mw_mirth_type_TZ_ZTo(v629, v631);
	int64_t v633 = 40LL /* PRIM_F32_TO_STR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v627, v632, v633);
	VAL v634 = mw_mirth_var_Ctx0();
	VAL v635 = mw_mirth_type_TYPEz_F64();
	VAL v636 = mw_mirth_type_T1(v635);
	VAL v637 = mw_mirth_type_TYPEz_STR();
	VAL v638 = mw_mirth_type_T1(v637);
	VAL v639 = mw_mirth_type_TZ_ZTo(v636, v638);
	int64_t v640 = 49LL /* PRIM_F64_TO_STR */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v634, v639, v640);
	VAL v641 = mw_mirth_var_Ctx0();
	VAL v642 = mw_mirth_type_TYPEz_F32();
	VAL v643 = mw_mirth_type_T1(v642);
	VAL v644 = mw_mirth_type_TYPEz_INT();
	VAL v645 = mw_mirth_type_T1(v644);
	VAL v646 = mw_mirth_type_TZ_ZTo(v643, v645);
	int64_t v647 = 39LL /* PRIM_F32_TO_INT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v641, v646, v647);
	VAL v648 = mw_mirth_var_Ctx0();
	VAL v649 = mw_mirth_type_TYPEz_F64();
	VAL v650 = mw_mirth_type_T1(v649);
	VAL v651 = mw_mirth_type_TYPEz_INT();
	VAL v652 = mw_mirth_type_T1(v651);
	VAL v653 = mw_mirth_type_TZ_ZTo(v650, v652);
	int64_t v654 = 48LL /* PRIM_F64_TO_INT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v648, v653, v654);
	VAL v655 = mw_mirth_var_Ctx0();
	VAL v656 = mw_mirth_type_TYPEz_PTR();
	VAL v657 = mw_mirth_type_T1(v656);
	VAL v658 = mw_mirth_type_TYPEz_PTR();
	VAL v659 = mw_mirth_type_T1(v658);
	VAL v660 = mw_mirth_type_TZ_ZTo(v657, v659);
	int64_t v661 = 88LL /* PRIM_PTR_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v655, v660, v661);
	VAL v662 = mw_mirth_var_Ctx0();
	VAL v663 = mw_mirth_type_TYPEz_PTR();
	VAL v664 = mw_mirth_type_T1(v663);
	VAL v665;
	VAL v666;
	mw_mirth_data_TYPEz_U8(v601, &v665, &v666);
	VAL v667 = mw_mirth_type_T1(v666);
	VAL v668 = mw_mirth_type_TZ_ZTo(v664, v667);
	int64_t v669 = 80LL /* PRIM_U8_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v662, v668, v669);
	VAL v670 = mw_mirth_var_Ctx0();
	VAL v671 = mw_mirth_type_TYPEz_PTR();
	VAL v672 = mw_mirth_type_T1(v671);
	VAL v673;
	VAL v674;
	mw_mirth_data_TYPEz_U16(v665, &v673, &v674);
	VAL v675 = mw_mirth_type_T1(v674);
	VAL v676 = mw_mirth_type_TZ_ZTo(v672, v675);
	int64_t v677 = 81LL /* PRIM_U16_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v670, v676, v677);
	VAL v678 = mw_mirth_var_Ctx0();
	VAL v679 = mw_mirth_type_TYPEz_PTR();
	VAL v680 = mw_mirth_type_T1(v679);
	VAL v681;
	VAL v682;
	mw_mirth_data_TYPEz_U32(v673, &v681, &v682);
	VAL v683 = mw_mirth_type_T1(v682);
	VAL v684 = mw_mirth_type_TZ_ZTo(v680, v683);
	int64_t v685 = 82LL /* PRIM_U32_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v678, v684, v685);
	VAL v686 = mw_mirth_var_Ctx0();
	VAL v687 = mw_mirth_type_TYPEz_PTR();
	VAL v688 = mw_mirth_type_T1(v687);
	VAL v689;
	VAL v690;
	mw_mirth_data_TYPEz_U64(v681, &v689, &v690);
	VAL v691 = mw_mirth_type_T1(v690);
	VAL v692 = mw_mirth_type_TZ_ZTo(v688, v691);
	int64_t v693 = 83LL /* PRIM_U64_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v686, v692, v693);
	VAL v694 = mw_mirth_var_Ctx0();
	VAL v695 = mw_mirth_type_TYPEz_PTR();
	VAL v696 = mw_mirth_type_T1(v695);
	VAL v697;
	VAL v698;
	mw_mirth_data_TYPEz_I8(v689, &v697, &v698);
	VAL v699 = mw_mirth_type_T1(v698);
	VAL v700 = mw_mirth_type_TZ_ZTo(v696, v699);
	int64_t v701 = 84LL /* PRIM_I8_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v694, v700, v701);
	VAL v702 = mw_mirth_var_Ctx0();
	VAL v703 = mw_mirth_type_TYPEz_PTR();
	VAL v704 = mw_mirth_type_T1(v703);
	VAL v705;
	VAL v706;
	mw_mirth_data_TYPEz_I16(v697, &v705, &v706);
	VAL v707 = mw_mirth_type_T1(v706);
	VAL v708 = mw_mirth_type_TZ_ZTo(v704, v707);
	int64_t v709 = 85LL /* PRIM_I16_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v702, v708, v709);
	VAL v710 = mw_mirth_var_Ctx0();
	VAL v711 = mw_mirth_type_TYPEz_PTR();
	VAL v712 = mw_mirth_type_T1(v711);
	VAL v713;
	VAL v714;
	mw_mirth_data_TYPEz_I32(v705, &v713, &v714);
	VAL v715 = mw_mirth_type_T1(v714);
	VAL v716 = mw_mirth_type_TZ_ZTo(v712, v715);
	int64_t v717 = 86LL /* PRIM_I32_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v710, v716, v717);
	VAL v718 = mw_mirth_var_Ctx0();
	VAL v719 = mw_mirth_type_TYPEz_PTR();
	VAL v720 = mw_mirth_type_T1(v719);
	VAL v721;
	VAL v722;
	mw_mirth_data_TYPEz_I64(v713, &v721, &v722);
	VAL v723 = mw_mirth_type_T1(v722);
	VAL v724 = mw_mirth_type_TZ_ZTo(v720, v723);
	int64_t v725 = 87LL /* PRIM_I64_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v718, v724, v725);
	VAL v726 = mw_mirth_var_Ctx0();
	VAL v727 = mw_mirth_type_TYPEz_PTR();
	VAL v728 = mw_mirth_type_TYPEz_PTR();
	VAL v729 = mw_mirth_type_T2(v727, v728);
	VAL v730 = mw_mirth_type_T0();
	VAL v731 = mw_mirth_type_TZ_ZTo(v729, v730);
	int64_t v732 = 97LL /* PRIM_PTR_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v726, v731, v732);
	VAL v733 = mw_mirth_var_Ctx0();
	VAL v734;
	VAL v735;
	mw_mirth_data_TYPEz_U8(v721, &v734, &v735);
	VAL v736 = mw_mirth_type_TYPEz_PTR();
	VAL v737 = mw_mirth_type_T2(v735, v736);
	VAL v738 = mw_mirth_type_T0();
	VAL v739 = mw_mirth_type_TZ_ZTo(v737, v738);
	int64_t v740 = 89LL /* PRIM_U8_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v733, v739, v740);
	VAL v741 = mw_mirth_var_Ctx0();
	VAL v742;
	VAL v743;
	mw_mirth_data_TYPEz_U16(v734, &v742, &v743);
	VAL v744 = mw_mirth_type_TYPEz_PTR();
	VAL v745 = mw_mirth_type_T2(v743, v744);
	VAL v746 = mw_mirth_type_T0();
	VAL v747 = mw_mirth_type_TZ_ZTo(v745, v746);
	int64_t v748 = 90LL /* PRIM_U16_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v741, v747, v748);
	VAL v749 = mw_mirth_var_Ctx0();
	VAL v750;
	VAL v751;
	mw_mirth_data_TYPEz_U32(v742, &v750, &v751);
	VAL v752 = mw_mirth_type_TYPEz_PTR();
	VAL v753 = mw_mirth_type_T2(v751, v752);
	VAL v754 = mw_mirth_type_T0();
	VAL v755 = mw_mirth_type_TZ_ZTo(v753, v754);
	int64_t v756 = 91LL /* PRIM_U32_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v749, v755, v756);
	VAL v757 = mw_mirth_var_Ctx0();
	VAL v758;
	VAL v759;
	mw_mirth_data_TYPEz_U64(v750, &v758, &v759);
	VAL v760 = mw_mirth_type_TYPEz_PTR();
	VAL v761 = mw_mirth_type_T2(v759, v760);
	VAL v762 = mw_mirth_type_T0();
	VAL v763 = mw_mirth_type_TZ_ZTo(v761, v762);
	int64_t v764 = 92LL /* PRIM_U64_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v757, v763, v764);
	VAL v765 = mw_mirth_var_Ctx0();
	VAL v766;
	VAL v767;
	mw_mirth_data_TYPEz_I8(v758, &v766, &v767);
	VAL v768 = mw_mirth_type_TYPEz_PTR();
	VAL v769 = mw_mirth_type_T2(v767, v768);
	VAL v770 = mw_mirth_type_T0();
	VAL v771 = mw_mirth_type_TZ_ZTo(v769, v770);
	int64_t v772 = 93LL /* PRIM_I8_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v765, v771, v772);
	VAL v773 = mw_mirth_var_Ctx0();
	VAL v774;
	VAL v775;
	mw_mirth_data_TYPEz_I16(v766, &v774, &v775);
	VAL v776 = mw_mirth_type_TYPEz_PTR();
	VAL v777 = mw_mirth_type_T2(v775, v776);
	VAL v778 = mw_mirth_type_T0();
	VAL v779 = mw_mirth_type_TZ_ZTo(v777, v778);
	int64_t v780 = 94LL /* PRIM_I16_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v773, v779, v780);
	VAL v781 = mw_mirth_var_Ctx0();
	VAL v782;
	VAL v783;
	mw_mirth_data_TYPEz_I32(v774, &v782, &v783);
	VAL v784 = mw_mirth_type_TYPEz_PTR();
	VAL v785 = mw_mirth_type_T2(v783, v784);
	VAL v786 = mw_mirth_type_T0();
	VAL v787 = mw_mirth_type_TZ_ZTo(v785, v786);
	int64_t v788 = 95LL /* PRIM_I32_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v781, v787, v788);
	VAL v789 = mw_mirth_var_Ctx0();
	VAL v790;
	VAL v791;
	mw_mirth_data_TYPEz_I64(v782, &v790, &v791);
	VAL v792 = mw_mirth_type_TYPEz_PTR();
	VAL v793 = mw_mirth_type_T2(v791, v792);
	VAL v794 = mw_mirth_type_T0();
	VAL v795 = mw_mirth_type_TZ_ZTo(v793, v794);
	int64_t v796 = 96LL /* PRIM_I64_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v789, v795, v796);
	VAL v797 = mw_mirth_var_Ctx0();
	VAL v798 = mw_mirth_type_T0();
	VAL v799 = mw_mirth_type_TYPEz_PTR();
	VAL v800 = mw_mirth_type_T1(v799);
	VAL v801 = mw_mirth_type_TZ_ZTo(v798, v800);
	int64_t v802 = 60LL /* PRIM_PTR_NIL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v797, v801, v802);
	VAL v803 = mw_mirth_var_Ctx0();
	VAL v804 = mw_mirth_type_TYPEz_PTR();
	VAL v805 = mw_mirth_type_TYPEz_PTR();
	VAL v806 = mw_mirth_type_T2(v804, v805);
	VAL v807;
	VAL v808;
	mw_mirth_data_TYPEz_BOOL(v790, &v807, &v808);
	VAL v809 = mw_mirth_type_T1(v808);
	VAL v810 = mw_mirth_type_TZ_ZTo(v806, v809);
	int64_t v811 = 61LL /* PRIM_PTR_EQ */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v803, v810, v811);
	VAL v812 = mw_mirth_var_Ctx0();
	VAL v813 = mw_mirth_type_TYPEz_INT();
	VAL v814 = mw_mirth_type_TYPEz_PTR();
	VAL v815 = mw_mirth_type_T2(v813, v814);
	VAL v816 = mw_mirth_type_TYPEz_PTR();
	VAL v817 = mw_mirth_type_T1(v816);
	VAL v818 = mw_mirth_type_TZ_ZTo(v815, v817);
	int64_t v819 = 62LL /* PRIM_PTR_ADD */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v812, v818, v819);
	VAL v820 = mw_mirth_var_Ctx0();
	VAL v821 = mw_mirth_type_T0();
	VAL v822 = mw_mirth_type_TYPEz_INT();
	VAL v823 = mw_mirth_type_T1(v822);
	VAL v824 = mw_mirth_type_TZ_ZTo(v821, v823);
	int64_t v825 = 63LL /* PRIM_PTR_SIZE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v820, v824, v825);
	VAL v826 = mw_mirth_var_Ctx0();
	VAL v827 = mw_mirth_type_TYPEz_INT();
	VAL v828 = mw_mirth_type_T1(v827);
	VAL v829 = mw_mirth_type_TYPEz_PTR();
	VAL v830 = mw_mirth_type_T1(v829);
	VAL v831 = mw_mirth_type_TZ_ZTo(v828, v830);
	int64_t v832 = 64LL /* PRIM_PTR_ALLOC */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v826, v831, v832);
	VAL v833 = mw_mirth_var_Ctx0();
	VAL v834 = mw_mirth_type_TYPEz_PTR();
	VAL v835 = mw_mirth_type_TYPEz_INT();
	VAL v836 = mw_mirth_type_T2(v834, v835);
	VAL v837 = mw_mirth_type_TYPEz_PTR();
	VAL v838 = mw_mirth_type_T1(v837);
	VAL v839 = mw_mirth_type_TZ_ZTo(v836, v838);
	int64_t v840 = 65LL /* PRIM_PTR_REALLOC */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v833, v839, v840);
	VAL v841 = mw_mirth_var_Ctx0();
	VAL v842 = mw_mirth_type_TYPEz_PTR();
	VAL v843 = mw_mirth_type_T1(v842);
	VAL v844 = mw_mirth_type_T0();
	VAL v845 = mw_mirth_type_TZ_ZTo(v843, v844);
	int64_t v846 = 66LL /* PRIM_PTR_FREE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v841, v845, v846);
	VAL v847 = mw_mirth_var_Ctx0();
	VAL v848 = mw_mirth_type_TYPEz_PTR();
	VAL v849 = mw_mirth_type_TYPEz_INT();
	VAL v850 = mw_mirth_type_TYPEz_PTR();
	VAL v851 = mw_mirth_type_T3(v848, v849, v850);
	VAL v852 = mw_mirth_type_T0();
	VAL v853 = mw_mirth_type_TZ_ZTo(v851, v852);
	int64_t v854 = 67LL /* PRIM_PTR_COPY */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v847, v853, v854);
	VAL v855 = mw_mirth_var_Ctx0();
	VAL v856 = mw_mirth_type_TYPEz_INT();
	VAL v857 = mw_mirth_type_TYPEz_INT();
	VAL v858 = mw_mirth_type_TYPEz_PTR();
	VAL v859 = mw_mirth_type_T3(v856, v857, v858);
	VAL v860 = mw_mirth_type_T0();
	VAL v861 = mw_mirth_type_TZ_ZTo(v859, v860);
	int64_t v862 = 68LL /* PRIM_PTR_FILL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v855, v861, v862);
	VAL v863 = mw_mirth_var_Ctx0();
	VAL v864 = mw_mirth_type_TYPEz_PTR();
	VAL v865 = mw_mirth_type_TYPEz_INT();
	VAL v866 = mw_mirth_type_T2(v864, v865);
	VAL v867 = mw_mirth_type_TYPEz_STR();
	VAL v868 = mw_mirth_type_T1(v867);
	VAL v869 = mw_mirth_type_TZ_ZTo(v866, v868);
	int64_t v870 = 69LL /* PRIM_STR_COPY */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v863, v869, v870);
	VAL v871 = mw_mirth_var_Ctx0();
	VAL v872 = mw_mirth_type_TYPEz_STR();
	VAL v873 = mw_mirth_type_T1(v872);
	VAL v874 = mw_mirth_type_TYPEz_INT();
	VAL v875 = mw_mirth_type_T1(v874);
	VAL v876 = mw_mirth_type_TZ_ZTo(v873, v875);
	int64_t v877 = 70LL /* PRIM_STR_NUM_BYTES */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v871, v876, v877);
	VAL v878 = mw_mirth_var_Ctx0();
	VAL v879 = mw_mirth_type_TYPEz_STR();
	VAL v880 = mw_mirth_type_T1(v879);
	VAL v881 = mw_mirth_type_TYPEz_PTR();
	VAL v882 = mw_mirth_type_T1(v881);
	VAL v883 = mw_mirth_type_TZ_ZTo(v880, v882);
	int64_t v884 = 71LL /* PRIM_STR_BASE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v878, v883, v884);
	VAL v885 = mw_mirth_var_Ctx0();
	VAL v886 = mw_mirth_type_TYPEz_STR();
	VAL v887 = mw_mirth_type_TYPEz_STR();
	VAL v888 = mw_mirth_type_T2(v886, v887);
	VAL v889 = mw_mirth_type_TYPEz_STR();
	VAL v890 = mw_mirth_type_T1(v889);
	VAL v891 = mw_mirth_type_TZ_ZTo(v888, v890);
	int64_t v892 = 72LL /* PRIM_STR_CAT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v885, v891, v892);
	VAL v893 = mw_mirth_var_Ctx0();
	VAL v894 = mw_mirth_type_TYPEz_STR();
	VAL v895 = mw_mirth_type_TYPEz_STR();
	VAL v896 = mw_mirth_type_T2(v894, v895);
	VAL v897 = mw_mirth_type_TYPEz_INT();
	VAL v898 = mw_mirth_type_T1(v897);
	VAL v899 = mw_mirth_type_TZ_ZTo(v896, v898);
	int64_t v900 = 73LL /* PRIM_STR_CMP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v893, v899, v900);
	VAL v901 = mw_mirth_var_Ctx0();
	VAL v902 = mw_mirth_type_TYPEz_STR();
	VAL v903 = mw_mirth_type_TYPEz_STR();
	VAL v904 = mw_mirth_type_T2(v902, v903);
	VAL v905;
	VAL v906;
	mw_mirth_data_TYPEz_BOOL(v807, &v905, &v906);
	VAL v907 = mw_mirth_type_T1(v906);
	VAL v908 = mw_mirth_type_TZ_ZTo(v904, v907);
	incref(v901);
	incref(v908);
	int64_t v909 = 74LL /* PRIM_STR_EQ */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v901, v908, v909);
	incref(v901);
	incref(v908);
	int64_t v910 = 75LL /* PRIM_STR_LT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v901, v908, v910);
	incref(v901);
	incref(v908);
	int64_t v911 = 76LL /* PRIM_STR_LE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v901, v908, v911);
	incref(v901);
	incref(v908);
	int64_t v912 = 77LL /* PRIM_STR_GT */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v901, v908, v912);
	incref(v901);
	incref(v908);
	int64_t v913 = 78LL /* PRIM_STR_GE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v901, v908, v913);
	incref(v901);
	incref(v908);
	int64_t v914 = 79LL /* PRIM_STR_NE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v901, v908, v914);
	decref(v908);
	decref(v901);
	VAL v915 = mw_mirth_var_Ctx0();
	VAL v916 = mw_mirth_type_T0();
	VAL v917 = mw_mirth_type_TYPEz_INT();
	VAL v918 = mw_mirth_type_T1(v917);
	VAL v919 = mw_mirth_type_TZ_ZTo(v916, v918);
	int64_t v920 = 98LL /* PRIM_SYS_OS */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v915, v919, v920);
	VAL v921 = mw_mirth_var_Ctx0();
	VAL v922 = mw_mirth_type_T0();
	VAL v923 = mw_mirth_type_TYPEz_INT();
	VAL v924 = mw_mirth_type_T1(v923);
	VAL v925 = mw_mirth_type_TZ_ZTo(v922, v924);
	int64_t v926 = 99LL /* PRIM_SYS_ARCH */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v921, v925, v926);
	VAL v927 = mw_mirth_var_Ctx0();
	VAL v928 = mw_mirth_type_T0();
	VAL v929 = mw_mirth_type_TYPEz_INT();
	VAL v930 = mw_mirth_type_T1(v929);
	VAL v931 = mw_mirth_type_TZ_ZTo(v928, v930);
	int64_t v932 = 100LL /* PRIM_SYS_ARGC */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v927, v931, v932);
	VAL v933 = mw_mirth_var_Ctx0();
	VAL v934 = mw_mirth_type_T0();
	VAL v935 = mw_mirth_type_TYPEz_PTR();
	VAL v936 = mw_mirth_type_T1(v935);
	VAL v937 = mw_mirth_type_TZ_ZTo(v934, v936);
	int64_t v938 = 101LL /* PRIM_SYS_ARGV */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v933, v937, v938);
	VAL v939 = mw_mirth_var_Ctx0();
	VAL v940 = mw_mirth_type_T0();
	VAL v941 = mw_mirth_type_T0();
	VAL v942 = mw_mirth_type_StackType_ZToType(v941);
	VAL v943 = mw_mirth_type_T1(v942);
	VAL v944 = mw_mirth_type_TZ_ZTo(v940, v943);
	int64_t v945 = 54LL /* PRIM_PACK_NIL */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v939, v944, v945);
	VAL v946 = mw_mirth_type_TYPEz_TYPE();
	STR* v947;
	STRLIT(v947, "a", 1);
	uint64_t v948 = mw_std_prim_Str_ZToName(MKSTR(v947));
	uint64_t v949 = mw_mirth_var_Var_newZBang(v946, v948);
	VAL v950 = mw_mirth_type_TYPEz_TYPE();
	STR* v951;
	STRLIT(v951, "b", 1);
	uint64_t v952 = mw_std_prim_Str_ZToName(MKSTR(v951));
	uint64_t v953 = mw_mirth_var_Var_newZBang(v950, v952);
	VAL v954 = mw_mirth_type_TYPEz_TYPE();
	STR* v955;
	STRLIT(v955, "c", 1);
	uint64_t v956 = mw_std_prim_Str_ZToName(MKSTR(v955));
	uint64_t v957 = mw_mirth_var_Var_newZBang(v954, v956);
	VAL v958 = mw_mirth_type_TYPEz_RESOURCE();
	STR* v959;
	STRLIT(v959, "+r", 2);
	uint64_t v960 = mw_std_prim_Str_ZToName(MKSTR(v959));
	uint64_t v961 = mw_mirth_var_Var_newZBang(v958, v960);
	VAL v962 = mw_mirth_type_TYPEz_RESOURCE();
	STR* v963;
	STRLIT(v963, "+s", 2);
	uint64_t v964 = mw_std_prim_Str_ZToName(MKSTR(v963));
	uint64_t v965 = mw_mirth_var_Var_newZBang(v962, v964);
	VAL v966 = mw_mirth_type_TYPEz_STACK();
	STR* v967;
	STRLIT(v967, "*x", 2);
	uint64_t v968 = mw_std_prim_Str_ZToName(MKSTR(v967));
	uint64_t v969 = mw_mirth_var_Var_newZBang(v966, v968);
	VAL v970 = mw_mirth_type_TYPEz_STACK();
	STR* v971;
	STRLIT(v971, "*y", 2);
	uint64_t v972 = mw_std_prim_Str_ZToName(MKSTR(v971));
	uint64_t v973 = mw_mirth_var_Var_newZBang(v970, v972);
	VAL v974 = mtw_mirth_type_Type_TVar(v949);
	VAL v975 = mtw_mirth_type_Type_TVar(v953);
	VAL v976 = mtw_mirth_type_Type_TVar(v957);
	VAL v977 = mtw_mirth_type_Type_TVar(v961);
	VAL v978 = mtw_mirth_type_Type_TVar(v965);
	VAL v979 = mtw_mirth_type_StackType_STVar(v969);
	VAL v980 = mtw_mirth_type_StackType_STVar(v973);
	VAL v981 = mw_mirth_var_Ctx1(v949);
	incref(v974);
	VAL v982 = mw_mirth_type_T1(v974);
	VAL v983 = mw_mirth_type_T0();
	VAL v984 = mw_mirth_type_TZ_ZTo(v982, v983);
	int64_t v985 = 2LL /* PRIM_CORE_DROP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v981, v984, v985);
	VAL v986 = mw_mirth_var_Ctx1(v949);
	incref(v974);
	VAL v987 = mw_mirth_type_T1(v974);
	incref(v974);
	incref(v974);
	VAL v988 = mw_mirth_type_T2(v974, v974);
	VAL v989 = mw_mirth_type_TZ_ZTo(v987, v988);
	int64_t v990 = 1LL /* PRIM_CORE_DUP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v986, v989, v990);
	VAL v991 = mw_mirth_var_Ctx2(v949, v953);
	incref(v974);
	incref(v975);
	VAL v992 = mw_mirth_type_T2(v974, v975);
	incref(v975);
	incref(v974);
	VAL v993 = mw_mirth_type_T2(v975, v974);
	VAL v994 = mw_mirth_type_TZ_ZTo(v992, v993);
	int64_t v995 = 3LL /* PRIM_CORE_SWAP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v991, v994, v995);
	VAL v996 = mw_mirth_var_Ctx2(v969, v973);
	incref(v979);
	incref(v979);
	incref(v980);
	VAL v997 = mw_mirth_type_TZ_ZTo(v979, v980);
	VAL v998 = mtw_mirth_type_Type_TMorphism(v997);
	VAL v999 = mw_mirth_type_TZMul(v979, v998);
	incref(v980);
	VAL v1000 = mw_mirth_type_TZ_ZTo(v999, v980);
	int64_t v1001 = 11LL /* PRIM_CORE_RUN */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v996, v1000, v1001);
	VAL v1002 = mw_mirth_var_Ctx2(v969, v973);
	incref(v979);
	VAL v1003 = mw_mirth_type_TYPEz_STR();
	VAL v1004 = mw_mirth_type_TZMul(v979, v1003);
	incref(v980);
	VAL v1005 = mw_mirth_type_TZ_ZTo(v1004, v980);
	int64_t v1006 = 10LL /* PRIM_CORE_PANIC */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1002, v1005, v1006);
	VAL v1007 = mw_mirth_var_Ctx3(v969, v973, v957);
	incref(v979);
	incref(v976);
	VAL v1008 = mw_mirth_type_TZMul(v979, v976);
	incref(v979);
	incref(v980);
	VAL v1009 = mw_mirth_type_TZ_ZTo(v979, v980);
	VAL v1010 = mtw_mirth_type_Type_TMorphism(v1009);
	VAL v1011 = mw_mirth_type_TZMul(v1008, v1010);
	incref(v980);
	incref(v976);
	VAL v1012 = mw_mirth_type_TZMul(v980, v976);
	VAL v1013 = mw_mirth_type_TZ_ZTo(v1011, v1012);
	int64_t v1014 = 5LL /* PRIM_CORE_DIP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1007, v1013, v1014);
	VAL v1015 = mw_mirth_var_Ctx2(v969, v973);
	incref(v979);
	VAL v1016;
	VAL v1017;
	mw_mirth_data_TYPEz_BOOL(v905, &v1016, &v1017);
	VAL v1018 = mw_mirth_type_TZMul(v979, v1017);
	incref(v979);
	incref(v980);
	VAL v1019 = mw_mirth_type_TZ_ZTo(v979, v980);
	VAL v1020 = mtw_mirth_type_Type_TMorphism(v1019);
	incref(v1020);
	VAL v1021 = mw_mirth_type_TZMul(v1018, v1020);
	VAL v1022 = mw_mirth_type_TZMul(v1021, v1020);
	incref(v980);
	VAL v1023 = mw_mirth_type_TZ_ZTo(v1022, v980);
	int64_t v1024 = 7LL /* PRIM_CORE_IF */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1015, v1023, v1024);
	VAL v1025 = mw_mirth_var_Ctx1(v969);
	incref(v979);
	incref(v979);
	incref(v979);
	VAL v1026;
	VAL v1027;
	mw_mirth_data_TYPEz_BOOL(v1016, &v1026, &v1027);
	VAL v1028 = mw_mirth_type_TZMul(v979, v1027);
	VAL v1029 = mw_mirth_type_TZ_ZTo(v979, v1028);
	VAL v1030 = mtw_mirth_type_Type_TMorphism(v1029);
	VAL v1031 = mw_mirth_type_TZMul(v979, v1030);
	incref(v979);
	incref(v979);
	VAL v1032 = mw_mirth_type_TZ_ZTo(v979, v979);
	VAL v1033 = mtw_mirth_type_Type_TMorphism(v1032);
	VAL v1034 = mw_mirth_type_TZMul(v1031, v1033);
	incref(v979);
	VAL v1035 = mw_mirth_type_TZ_ZTo(v1034, v979);
	int64_t v1036 = 8LL /* PRIM_CORE_WHILE */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1025, v1035, v1036);
	VAL v1037 = mw_mirth_var_Ctx2(v961, v965);
	VAL v1038 = mw_mirth_type_T0();
	incref(v977);
	VAL v1039 = mw_mirth_type_TZPlus(v1038, v977);
	incref(v978);
	VAL v1040 = mw_mirth_type_TZPlus(v1039, v978);
	VAL v1041 = mw_mirth_type_T0();
	incref(v978);
	VAL v1042 = mw_mirth_type_TZPlus(v1041, v978);
	incref(v977);
	VAL v1043 = mw_mirth_type_TZPlus(v1042, v977);
	VAL v1044 = mw_mirth_type_TZ_ZTo(v1040, v1043);
	int64_t v1045 = 4LL /* PRIM_CORE_RSWAP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1037, v1044, v1045);
	VAL v1046 = mw_mirth_var_Ctx3(v969, v973, v961);
	incref(v979);
	incref(v977);
	VAL v1047 = mw_mirth_type_TZPlus(v979, v977);
	incref(v979);
	incref(v980);
	VAL v1048 = mw_mirth_type_TZ_ZTo(v979, v980);
	VAL v1049 = mtw_mirth_type_Type_TMorphism(v1048);
	VAL v1050 = mw_mirth_type_TZMul(v1047, v1049);
	incref(v980);
	incref(v977);
	VAL v1051 = mw_mirth_type_TZPlus(v980, v977);
	VAL v1052 = mw_mirth_type_TZ_ZTo(v1050, v1051);
	int64_t v1053 = 6LL /* PRIM_CORE_RDIP */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1046, v1052, v1053);
	VAL v1054 = mw_mirth_var_Ctx2(v969, v953);
	incref(v979);
	VAL v1055 = mw_mirth_type_StackType_ZToType(v979);
	incref(v975);
	VAL v1056 = mw_mirth_type_T2(v1055, v975);
	incref(v979);
	incref(v975);
	VAL v1057 = mw_mirth_type_TZMul(v979, v975);
	VAL v1058 = mw_mirth_type_StackType_ZToType(v1057);
	VAL v1059 = mw_mirth_type_T1(v1058);
	VAL v1060 = mw_mirth_type_TZ_ZTo(v1056, v1059);
	int64_t v1061 = 55LL /* PRIM_PACK_CONS */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1054, v1060, v1061);
	VAL v1062 = mw_mirth_var_Ctx2(v969, v953);
	incref(v979);
	incref(v975);
	VAL v1063 = mw_mirth_type_TZMul(v979, v975);
	VAL v1064 = mw_mirth_type_StackType_ZToType(v1063);
	VAL v1065 = mw_mirth_type_T1(v1064);
	incref(v979);
	VAL v1066 = mw_mirth_type_StackType_ZToType(v979);
	incref(v975);
	VAL v1067 = mw_mirth_type_T2(v1066, v975);
	VAL v1068 = mw_mirth_type_TZ_ZTo(v1065, v1067);
	int64_t v1069 = 56LL /* PRIM_PACK_UNCONS */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1062, v1068, v1069);
	VAL v1070 = mw_mirth_var_Ctx1(v949);
	incref(v974);
	VAL v1071 = mtw_mirth_type_Type_TMut(v974);
	VAL v1072 = mw_mirth_type_T1(v1071);
	incref(v974);
	VAL v1073 = mw_mirth_type_T1(v974);
	VAL v1074 = mw_mirth_type_TZ_ZTo(v1072, v1073);
	int64_t v1075 = 57LL /* PRIM_MUT_GET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1070, v1074, v1075);
	VAL v1076 = mw_mirth_var_Ctx1(v949);
	incref(v974);
	incref(v974);
	VAL v1077 = mtw_mirth_type_Type_TMut(v974);
	VAL v1078 = mw_mirth_type_T2(v974, v1077);
	VAL v1079 = mw_mirth_type_T0();
	VAL v1080 = mw_mirth_type_TZ_ZTo(v1078, v1079);
	int64_t v1081 = 58LL /* PRIM_MUT_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1076, v1080, v1081);
	VAL v1082 = mw_mirth_var_Ctx1(v949);
	incref(v974);
	VAL v1083 = mtw_mirth_type_Type_TMut(v974);
	VAL v1084 = mw_mirth_type_T1(v1083);
	VAL v1085;
	VAL v1086;
	mw_mirth_data_TYPEz_BOOL(v1026, &v1085, &v1086);
	VAL v1087 = mw_mirth_type_T1(v1086);
	VAL v1088 = mw_mirth_type_TZ_ZTo(v1084, v1087);
	int64_t v1089 = 59LL /* PRIM_MUT_IS_SET */;
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1082, v1088, v1089);
	decref(v976);
	decref(v975);
	decref(v974);
	decref(v978);
	decref(v977);
	decref(v980);
	decref(v979);
	return v1085;
}
static int64_t mw_mirth_token_TokenValue_noneZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // TokenNone
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_commaZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 1LL: { // TokenComma
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_lparenZ_openZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 2LL: { // TokenLParenOpen
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_lparenZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 6LL: { // TokenLParen
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenLParen(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_rparenZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 7LL: { // TokenRParen
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenRParen(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_lsquareZ_openZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 3LL: { // TokenLSquareOpen
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_lsquareZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 8LL: { // TokenLSquare
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenLSquare(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_rsquareZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 9LL: { // TokenRSquare
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenRSquare(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_lcurlyZ_openZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 4LL: { // TokenLCurlyOpen
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_lcurlyZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 10LL: { // TokenLCurly
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenLCurly(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_rcurlyZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 11LL: { // TokenRCurly
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenRCurly(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_lcolonZ_openZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 5LL: { // TokenLColonOpen
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* False */;
			x2 = v4;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_lcolonZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 12LL: { // TokenLColon
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenLColon(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 6LL: { // TokenLParen
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenLParen(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		case 12LL: { // TokenLColon
			uint64_t v5 = mtp_mirth_token_TokenValue_TokenLColon(x1);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(MKU64(v5));
			x2 = v6;
		} break;
		default: {
			decref(x1);
			VAL v7 = MKI64(0LL /* None */);
			x2 = v7;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenName(x1);
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		case 18LL: { // TokenDName
			VAL v5 = mtp_mirth_token_TokenValue_TokenDName(x1);
			decref(v5);
			int64_t v6 = 1LL /* True */;
			x2 = v6;
		} break;
		case 23LL: { // TokenLabelGet
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenLabelGet(x1);
			int64_t v8 = 1LL /* True */;
			x2 = v8;
		} break;
		default: {
			decref(x1);
			int64_t v9 = 0LL /* False */;
			x2 = v9;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_intZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 14LL: { // TokenInt
			int64_t v3 = mtp_mirth_token_TokenValue_TokenInt(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKI64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_strZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 16LL: { // TokenStr
			VAL v3 = mtp_mirth_token_TokenValue_TokenStr(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_nameZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenName(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_dnameZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 18LL: { // TokenDName
			VAL v3 = mtp_mirth_token_TokenValue_TokenDName(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_nameZDivdnameZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenName(x1);
			VAL v4 = mtw_std_either_Either_2_Left(MKU64(v3));
			VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
			x2 = v5;
		} break;
		case 18LL: { // TokenDName
			VAL v6 = mtp_mirth_token_TokenValue_TokenDName(x1);
			VAL v7 = mtw_std_either_Either_2_Right(v6);
			VAL v8 = mtw_std_maybe_Maybe_1_Some(v7);
			x2 = v8;
		} break;
		default: {
			decref(x1);
			VAL v9 = MKI64(0LL /* None */);
			x2 = v9;
		} break;
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_lastZ_nameZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenName(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		case 18LL: { // TokenDName
			VAL v5 = mtp_mirth_token_TokenValue_TokenDName(x1);
			uint64_t v6 = mw_mirth_name_DName_lastZ_name(v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(MKU64(v6));
			x2 = v7;
		} break;
		default: {
			decref(x1);
			VAL v8 = MKI64(0LL /* None */);
			x2 = v8;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_argZ_endZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 1LL: { // TokenComma
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 7LL: { // TokenRParen
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenRParen(x1);
			int64_t v5 = 1LL /* True */;
			x2 = v5;
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenRCurly(x1);
			int64_t v7 = 1LL /* True */;
			x2 = v7;
		} break;
		case 9LL: { // TokenRSquare
			uint64_t v8 = mtp_mirth_token_TokenValue_TokenRSquare(x1);
			int64_t v9 = 1LL /* True */;
			x2 = v9;
		} break;
		case 13LL: { // TokenRColon
			uint64_t v10 = mtp_mirth_token_TokenValue_TokenRColon(x1);
			int64_t v11 = 1LL /* True */;
			x2 = v11;
		} break;
		default: {
			decref(x1);
			int64_t v12 = 0LL /* False */;
			x2 = v12;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_leftZ_enclosureZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 6LL: { // TokenLParen
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenLParen(x1);
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		case 8LL: { // TokenLSquare
			uint64_t v5 = mtp_mirth_token_TokenValue_TokenLSquare(x1);
			int64_t v6 = 1LL /* True */;
			x2 = v6;
		} break;
		case 10LL: { // TokenLCurly
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenLCurly(x1);
			int64_t v8 = 1LL /* True */;
			x2 = v8;
		} break;
		case 12LL: { // TokenLColon
			uint64_t v9 = mtp_mirth_token_TokenValue_TokenLColon(x1);
			int64_t v10 = 1LL /* True */;
			x2 = v10;
		} break;
		default: {
			decref(x1);
			int64_t v11 = 0LL /* False */;
			x2 = v11;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_token_TokenValue_rightZ_enclosureZAsk (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 7LL: { // TokenRParen
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenRParen(x1);
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		case 9LL: { // TokenRSquare
			uint64_t v5 = mtp_mirth_token_TokenValue_TokenRSquare(x1);
			int64_t v6 = 1LL /* True */;
			x2 = v6;
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenRCurly(x1);
			int64_t v8 = 1LL /* True */;
			x2 = v8;
		} break;
		case 13LL: { // TokenRColon
			uint64_t v9 = mtp_mirth_token_TokenValue_TokenRColon(x1);
			int64_t v10 = 1LL /* True */;
			x2 = v10;
		} break;
		default: {
			decref(x1);
			int64_t v11 = 0LL /* False */;
			x2 = v11;
		} break;
	}
	return x2;
}
static uint64_t mw_mirth_token_nameZDivdnameZ_lastZ_name (VAL x1) {
	uint64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Left
			VAL v3 = mtp_std_either_Either_2_Left(x1);
			x2 = VU64(v3);
		} break;
		case 1LL: { // Right
			VAL v4 = mtp_std_either_Either_2_Right(x1);
			uint64_t v5 = mw_mirth_name_DName_lastZ_name(v4);
			x2 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_token_nameZDivdnameZ_penultimateZ_nameZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // Left
			VAL v3 = mtp_std_either_Either_2_Left(x1);
			decref(v3);
			VAL v4 = MKI64(0LL /* None */);
			x2 = v4;
		} break;
		case 1LL: { // Right
			VAL v5 = mtp_std_either_Either_2_Right(x1);
			VAL v6 = mw_mirth_name_DName_penultimateZ_nameZAsk(v5);
			x2 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZDivdnameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			uint64_t v5 = mw_mirth_token_nameZDivdnameZ_lastZ_name(v4);
			int64_t v6 = mw_mirth_name_Name_couldZ_beZ_typeZ_con(v5);
			VAL x7;
			if (((bool)v6)) {
				VAL v8 = mtw_std_maybe_Maybe_1_Some(v4);
				x7 = v8;
			} else {
				decref(v4);
				VAL v9 = MKI64(0LL /* None */);
				x7 = v9;
			}
			x3 = x7;
		} break;
		case 0LL: { // None
			VAL v10 = MKI64(0LL /* None */);
			x3 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			int64_t v5 = mw_mirth_name_Name_isZ_typeZ_hole(VU64(v4));
			VAL x6;
			if (((bool)v5)) {
				VAL v7 = mtw_std_maybe_Maybe_1_Some(v4);
				x6 = v7;
			} else {
				decref(v4);
				VAL v8 = MKI64(0LL /* None */);
				x6 = v8;
			}
			x3 = x6;
		} break;
		case 0LL: { // None
			VAL v9 = MKI64(0LL /* None */);
			x3 = v9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			int64_t v5 = mw_mirth_name_Name_couldZ_beZ_typeZ_var(VU64(v4));
			VAL x6;
			if (((bool)v5)) {
				VAL v7 = mtw_std_maybe_Maybe_1_Some(v4);
				x6 = v7;
			} else {
				decref(v4);
				VAL v8 = MKI64(0LL /* None */);
				x6 = v8;
			}
			x3 = x6;
		} break;
		case 0LL: { // None
			VAL v9 = MKI64(0LL /* None */);
			x3 = v9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk(x1);
	return v2;
}
static VAL mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			int64_t v5 = mw_mirth_name_Name_couldZ_beZ_stackZ_var(VU64(v4));
			VAL x6;
			if (((bool)v5)) {
				VAL v7 = mtw_std_maybe_Maybe_1_Some(v4);
				x6 = v7;
			} else {
				decref(v4);
				VAL v8 = MKI64(0LL /* None */);
				x6 = v8;
			}
			x3 = x6;
		} break;
		case 0LL: { // None
			VAL v9 = MKI64(0LL /* None */);
			x3 = v9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			int64_t v5 = mw_mirth_name_Name_couldZ_beZ_resourceZ_var(VU64(v4));
			VAL x6;
			if (((bool)v5)) {
				VAL v7 = mtw_std_maybe_Maybe_1_Some(v4);
				x6 = v7;
			} else {
				decref(v4);
				VAL v8 = MKI64(0LL /* None */);
				x6 = v8;
			}
			x3 = x6;
		} break;
		case 0LL: { // None
			VAL v9 = MKI64(0LL /* None */);
			x3 = v9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZDivdnameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			uint64_t v5 = mw_mirth_token_nameZDivdnameZ_lastZ_name(v4);
			int64_t v6 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(v5);
			VAL x7;
			if (((bool)v6)) {
				VAL v8 = mtw_std_maybe_Maybe_1_Some(v4);
				x7 = v8;
			} else {
				decref(v4);
				VAL v9 = MKI64(0LL /* None */);
				x7 = v9;
			}
			x3 = x7;
		} break;
		case 0LL: { // None
			VAL v10 = MKI64(0LL /* None */);
			x3 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_token_TokenValue_sigZ_dashesZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			int64_t v5 = 118LL /* PRIM_SYNTAX_DASHES */;
			uint64_t v6 = mw_mirth_prim_Prim_name(v5);
			int64_t v7 = mw_mirth_name_Name_ZEqualZEqual(VU64(v4), v6);
			x3 = v7;
		} break;
		case 0LL: { // None
			int64_t v8 = 0LL /* False */;
			x3 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_token_TokenValue_arrowZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			int64_t v5 = 119LL /* PRIM_SYNTAX_ARROW */;
			uint64_t v6 = mw_mirth_prim_Prim_name(v5);
			int64_t v7 = mw_mirth_name_Name_ZEqualZEqual(VU64(v4), v6);
			x3 = v7;
		} break;
		case 0LL: { // None
			int64_t v8 = 0LL /* False */;
			x3 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_token_TokenValue_patZ_underscoreZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			int64_t v5 = mw_mirth_name_Name_isZ_underscore(VU64(v4));
			x3 = v5;
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			x3 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_token_TokenValue_moduleZ_headerZAsk (VAL x1) {
	VAL v2 = mw_mirth_token_TokenValue_nameZAsk(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_mirth_name_Name_ZToStr(VU64(v4));
			STR* v6;
			STRLIT(v6, "module", 6);
			bool v7 = (str_cmp(VSTR(v5), v6) == 0);
			x3 = ((int64_t)v7);
		} break;
		case 0LL: { // None
			int64_t v8 = 0LL /* False */;
			x3 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static int64_t mw_mirth_token_Token_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_token_Token_succ (uint64_t x1) {
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)x1), v2);
	void* v4 = mbuf_mirth_token_Token_NUM;
	uint64_t v5 = *(uint64_t*)v4;
	int64_t v6 = 1LL;
	int64_t v7 = i64_add(((int64_t)v5), v6);
	int64_t v8 = i64_mod(v3, v7);
	return ((uint64_t)v8);
}
static uint64_t mw_mirth_token_Token_pred (uint64_t x1) {
	int64_t v2 = 0LL;
	bool v3 = (((int64_t)x1) == v2);
	int64_t x4;
	if (v3) {
		x4 = ((int64_t)x1);
	} else {
		int64_t v5 = 1LL;
		int64_t v6 = i64_sub(((int64_t)x1), v5);
		x4 = v6;
	}
	return ((uint64_t)x4);
}
static uint64_t mw_mirth_token_Token_allocZBang (void) {
	void* v1 = mbuf_mirth_token_Token_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_token_Token_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static int64_t mw_mirth_token_Token_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_token_Token_index(x1);
	int64_t v4 = mw_mirth_token_Token_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static VAL mw_mirth_token_Token_value (uint64_t x1) {
	void* v2 = mfld_mirth_token_Token_ZTildevalue(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_token_Token_module (uint64_t x1) {
	void* v2 = mfld_mirth_token_Token_ZTildemodule(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static int64_t mw_mirth_token_Token_col (uint64_t x1) {
	void* v2 = mfld_mirth_token_Token_ZTildecol(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static int64_t mw_mirth_token_Token_row (uint64_t x1) {
	void* v2 = mfld_mirth_token_Token_ZTilderow(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static int64_t mw_mirth_token_Token_noneZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_noneZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_commaZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_commaZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_lparenZ_openZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_lparenZ_openZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_lparenZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_lparenZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_rparenZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_rparenZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_lsquareZ_openZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_lsquareZ_openZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_lsquareZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_lsquareZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_rsquareZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_rsquareZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_lcurlyZ_openZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_lcurlyZ_openZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_lcurlyZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_lcurlyZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_rcurlyZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_rcurlyZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_lcolonZ_openZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_lcolonZ_openZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_lcolonZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_lcolonZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_intZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_intZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_strZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_strZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_nameZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_nameZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_dnameZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_dnameZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_nameZDivdnameZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_nameZDivdnameZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_lastZ_nameZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_lastZ_nameZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_argZ_endZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_argZ_endZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_leftZ_enclosureZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_leftZ_enclosureZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_rightZ_enclosureZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_rightZ_enclosureZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_typeZ_conZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_typeZ_holeZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_typeZ_varZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_paramZ_nameZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_stackZ_varZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_resourceZ_varZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_sigZ_resourceZ_conZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	VAL v3 = mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_sigZ_dashesZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_sigZ_dashesZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_arrowZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_arrowZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_patZ_underscoreZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_patZ_underscoreZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_moduleZ_headerZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_moduleZ_headerZAsk(v2);
	return v3;
}
static int64_t mw_mirth_token_Token_canZ_takeZ_argsZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t v3 = mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk(v2);
	return v3;
}
static uint64_t mw_mirth_token_Token_allocZ_noneZBang (void) {
	uint64_t v1 = mw_mirth_token_Token_allocZBang();
	VAL v2 = MKI64(0LL /* TokenNone */);
	void* v3 = mfld_mirth_token_Token_ZTildevalue(v1);
	mut_set(v2, v3);
	return v1;
}
static VAL mw_mirth_token_Token_location (uint64_t x1) {
	uint64_t v2 = mw_mirth_token_Token_module(x1);
	int64_t v3 = mw_mirth_token_Token_row(x1);
	int64_t v4 = mw_mirth_token_Token_col(x1);
	VAL v5 = mtw_mirth_location_Location_Location(v2, v3, v4);
	return v5;
}
static uint64_t mw_mirth_token_Token_next (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	uint64_t x3;
	switch (get_data_tag(v2)) {
		case 6LL: { // TokenLParen
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenLParen(v2);
			uint64_t v5 = mw_mirth_token_Token_succ(v4);
			x3 = v5;
		} break;
		case 8LL: { // TokenLSquare
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenLSquare(v2);
			uint64_t v7 = mw_mirth_token_Token_succ(v6);
			x3 = v7;
		} break;
		case 10LL: { // TokenLCurly
			uint64_t v8 = mtp_mirth_token_TokenValue_TokenLCurly(v2);
			uint64_t v9 = mw_mirth_token_Token_succ(v8);
			x3 = v9;
		} break;
		case 12LL: { // TokenLColon
			uint64_t v10 = mtp_mirth_token_TokenValue_TokenLColon(v2);
			uint64_t v11 = mw_mirth_token_Token_succ(v10);
			x3 = v11;
		} break;
		default: {
			int64_t v12 = mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk(v2);
			uint64_t x13;
			if (((bool)v12)) {
				uint64_t v14 = mw_mirth_token_Token_succ(x1);
				VAL v15 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v14);
				uint64_t x16;
				switch (get_data_tag(v15)) {
					case 1LL: { // Some
						VAL v17 = mtp_std_maybe_Maybe_1_Some(v15);
						uint64_t v18 = mw_mirth_token_Token_succ(VU64(v17));
						x16 = v18;
					} break;
					case 0LL: { // None
						x16 = v14;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x13 = x16;
			} else {
				uint64_t v19 = mw_mirth_token_Token_succ(x1);
				x13 = v19;
			}
			x3 = x13;
		} break;
	}
	return x3;
}
static uint64_t mw_mirth_token_Token_prev (uint64_t x1) {
	uint64_t v2 = mw_mirth_token_Token_pred(x1);
	VAL v3 = mw_mirth_token_Token_value(v2);
	uint64_t x4;
	switch (get_data_tag(v3)) {
		case 9LL: { // TokenRSquare
			uint64_t v5 = mtp_mirth_token_TokenValue_TokenRSquare(v3);
			x4 = v5;
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenRCurly(v3);
			x4 = v6;
		} break;
		case 7LL: { // TokenRParen
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenRParen(v3);
			uint64_t v8 = mw_mirth_token_Token_pred(v7);
			int64_t v9 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(v8);
			uint64_t x10;
			if (((bool)v9)) {
				uint64_t v11 = mw_mirth_token_Token_pred(v7);
				x10 = v11;
			} else {
				x10 = v7;
			}
			x4 = x10;
		} break;
		case 13LL: { // TokenRColon
			uint64_t v12 = mtp_mirth_token_TokenValue_TokenRColon(v3);
			uint64_t v13 = mw_mirth_token_Token_pred(v12);
			int64_t v14 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(v13);
			uint64_t x15;
			if (((bool)v14)) {
				uint64_t v16 = mw_mirth_token_Token_pred(v12);
				x15 = v16;
			} else {
				x15 = v12;
			}
			x4 = x15;
		} break;
		default: {
			decref(v3);
			x4 = v2;
		} break;
	}
	return x4;
}
static uint64_t mw_mirth_token_Token_nextZ_argZ_end (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_argZ_endZAsk(x1);
	bool v3 = !((bool)v2);
	uint64_t v4 = x1;
	bool v5 = v3;
	while (v5) {
		uint64_t v6 = v4;
		uint64_t v7 = mw_mirth_token_Token_next(v6);
		int64_t v8 = mw_mirth_token_Token_argZ_endZAsk(v7);
		bool v9 = !((bool)v8);
		v5 = v9;
		v4 = v7;
	}
	return v4;
}
static int64_t mw_mirth_token_Token_hasZ_argsZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(x1);
	uint64_t x3;
	if (((bool)v2)) {
		uint64_t v4 = mw_mirth_token_Token_succ(x1);
		x3 = v4;
	} else {
		x3 = x1;
	}
	VAL v5 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(x3);
	int64_t v6 = mw_std_maybe_Maybe_1_ZToBool(v5);
	return v6;
}
static uint64_t mw_mirth_token_Token_argsZ_start (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(x1);
	uint64_t x3;
	int64_t x4;
	if (((bool)v2)) {
		uint64_t v5 = mw_mirth_token_Token_succ(x1);
		VAL v6 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v5);
		int64_t v7 = mw_std_maybe_Maybe_1_ZToBool(v6);
		x4 = v7;
		x3 = x1;
	} else {
		int64_t v8 = 0LL /* False */;
		x4 = v8;
		x3 = x1;
	}
	uint64_t x9;
	if (((bool)x4)) {
		uint64_t v10 = mw_mirth_token_Token_succ(x3);
		x9 = v10;
	} else {
		x9 = x3;
	}
	return x9;
}
static int64_t mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_nameZAsk(x1);
	uint64_t x3;
	int64_t x4;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v2);
			int64_t v6 = mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk(VU64(v5));
			x4 = v6;
			x3 = x1;
		} break;
		case 0LL: { // None
			int64_t v7 = 0LL /* False */;
			x4 = v7;
			x3 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t x8;
	int64_t x9;
	if (((bool)x4)) {
		uint64_t v10 = mw_mirth_token_Token_succ(x3);
		VAL v11 = mw_mirth_token_Token_lcolonZAsk(v10);
		int64_t v12 = mw_std_maybe_Maybe_1_ZToBool(v11);
		x9 = v12;
		x8 = x3;
	} else {
		int64_t v13 = 0LL /* False */;
		x9 = v13;
		x8 = x3;
	}
	return x9;
}
static VAL mw_mirth_token_Token_sigZ_labelZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_nameZAsk(x1);
	uint64_t x3;
	VAL x4;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v5);
			int64_t v6 = mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk(VU64(v5));
			uint64_t x7;
			int64_t x8;
			if (((bool)v6)) {
				uint64_t v9 = mw_mirth_token_Token_succ(x1);
				VAL v10 = mw_mirth_token_Token_lcolonZAsk(v9);
				int64_t v11 = mw_std_maybe_Maybe_1_ZToBool(v10);
				x8 = v11;
				x7 = x1;
			} else {
				int64_t v12 = 0LL /* False */;
				x8 = v12;
				x7 = x1;
			}
			uint64_t x13;
			VAL x14;
			if (((bool)x8)) {
				VAL v15 = mtw_std_maybe_Maybe_1_Some(v5);
				x14 = v15;
				x13 = x7;
			} else {
				decref(v5);
				VAL v16 = MKI64(0LL /* None */);
				x14 = v16;
				x13 = x7;
			}
			x4 = x14;
			x3 = x13;
		} break;
		case 0LL: { // None
			VAL v17 = MKI64(0LL /* None */);
			x4 = v17;
			x3 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t x18;
	VAL x19;
	switch (get_data_tag(x4)) {
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(x4);
			uint64_t v21 = mw_mirth_label_Label_newZBang(VU64(v20));
			VAL v22 = mtw_std_maybe_Maybe_1_Some(MKU64(v21));
			x19 = v22;
			x18 = x3;
		} break;
		case 0LL: { // None
			VAL v23 = MKI64(0LL /* None */);
			x19 = v23;
			x18 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x19;
}
static VAL mw_mirth_token_Token_patternZ_varZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_nameZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v4);
			int64_t v5 = mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk(VU64(v4));
			VAL x6;
			if (((bool)v5)) {
				VAL v7 = mtw_std_maybe_Maybe_1_Some(v4);
				x6 = v7;
			} else {
				decref(v4);
				VAL v8 = MKI64(0LL /* None */);
				x6 = v8;
			}
			x3 = x6;
		} break;
		case 0LL: { // None
			VAL v9 = MKI64(0LL /* None */);
			x3 = v9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_token_Token_patternZ_autoZ_runZ_varZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_lsquareZAsk(x1);
	int64_t v3 = mw_std_maybe_Maybe_1_ZToBool(v2);
	uint64_t v4 = mw_mirth_token_Token_succ(x1);
	uint64_t v5 = mw_mirth_token_Token_succ(v4);
	VAL v6 = mw_mirth_token_Token_rsquareZAsk(v5);
	int64_t v7 = mw_std_maybe_Maybe_1_ZToBool(v6);
	bool v8 = (((bool)v3) && ((bool)v7));
	VAL x9;
	if (v8) {
		uint64_t v10 = mw_mirth_token_Token_succ(x1);
		VAL v11 = mw_mirth_token_Token_patternZ_varZAsk(v10);
		x9 = v11;
	} else {
		VAL v12 = MKI64(0LL /* None */);
		x9 = v12;
	}
	return x9;
}
static VAL mw_mirth_token_Token_argsZ_0 (uint64_t x1, VAL x2) {
	int64_t v3 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v4 = 0LL;
	bool v5 = (v3 == v4);
	VAL x6;
	if (v5) {
		x6 = x2;
	} else {
		STR* v7;
		STRLIT(v7, "expected no args", 16);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v7), x2);
		VAL r8 = pop_resource();
		x6 = r8;
	}
	return x6;
}
static void mw_mirth_token_Token_argsZ_1 (uint64_t x1, VAL x2, uint64_t *x3, VAL *x4) {
	int64_t v5 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v6 = 1LL;
	bool v7 = (v5 == v6);
	VAL x8;
	uint64_t x9;
	if (v7) {
		uint64_t v10 = mw_mirth_token_Token_argsZ_start(x1);
		uint64_t v11 = mw_mirth_token_Token_succ(v10);
		x9 = v11;
		x8 = x2;
	} else {
		int64_t v12 = mw_mirth_token_Token_numZ_args(x1);
		int64_t v13 = 1LL;
		bool v14 = (v12 < v13);
		VAL x15;
		uint64_t x16;
		if (v14) {
			STR* v17;
			STRLIT(v17, "expected 1 arg, got none", 24);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v17), x2);
			uint64_t v18 = pop_u64();
			x16 = v18;
			VAL r19 = pop_resource();
			x15 = r19;
		} else {
			STR* v20;
			STRLIT(v20, "expected 1 arg, got too many", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v20), x2);
			uint64_t v21 = pop_u64();
			x16 = v21;
			VAL r22 = pop_resource();
			x15 = r22;
		}
		x9 = x16;
		x8 = x15;
	}
	*x4 = x8;
	*x3 = x9;
}
static void mw_mirth_token_Token_argsZ_2 (uint64_t x1, VAL x2, uint64_t *x3, uint64_t *x4, VAL *x5) {
	int64_t v6 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v7 = 2LL;
	bool v8 = (v6 == v7);
	VAL x9;
	uint64_t x10;
	uint64_t x11;
	if (v8) {
		uint64_t v12 = mw_mirth_token_Token_argsZ_start(x1);
		uint64_t v13 = mw_mirth_token_Token_succ(v12);
		uint64_t v14 = mw_mirth_token_Token_nextZ_argZ_end(v13);
		uint64_t v15 = mw_mirth_token_Token_succ(v14);
		x11 = v15;
		x10 = v13;
		x9 = x2;
	} else {
		int64_t v16 = mw_mirth_token_Token_numZ_args(x1);
		int64_t v17 = 2LL;
		bool v18 = (v16 < v17);
		VAL x19;
		uint64_t x20;
		uint64_t x21;
		if (v18) {
			STR* v22;
			STRLIT(v22, "expected 2 args, got too few", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v22), x2);
			uint64_t v23 = pop_u64();
			x21 = v23;
			uint64_t v24 = pop_u64();
			x20 = v24;
			VAL r25 = pop_resource();
			x19 = r25;
		} else {
			STR* v26;
			STRLIT(v26, "expected 2 args, got too many", 29);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v26), x2);
			uint64_t v27 = pop_u64();
			x21 = v27;
			uint64_t v28 = pop_u64();
			x20 = v28;
			VAL r29 = pop_resource();
			x19 = r29;
		}
		x11 = x21;
		x10 = x20;
		x9 = x19;
	}
	*x5 = x9;
	*x4 = x11;
	*x3 = x10;
}
static void mw_mirth_token_Token_argsZ_3 (uint64_t x1, VAL x2, uint64_t *x3, uint64_t *x4, uint64_t *x5, VAL *x6) {
	int64_t v7 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v8 = 3LL;
	bool v9 = (v7 == v8);
	VAL x10;
	uint64_t x11;
	uint64_t x12;
	uint64_t x13;
	if (v9) {
		uint64_t v14 = mw_mirth_token_Token_argsZ_start(x1);
		uint64_t v15 = mw_mirth_token_Token_succ(v14);
		uint64_t v16 = mw_mirth_token_Token_nextZ_argZ_end(v15);
		uint64_t v17 = mw_mirth_token_Token_succ(v16);
		uint64_t v18 = mw_mirth_token_Token_nextZ_argZ_end(v17);
		uint64_t v19 = mw_mirth_token_Token_succ(v18);
		x13 = v19;
		x12 = v17;
		x11 = v15;
		x10 = x2;
	} else {
		int64_t v20 = mw_mirth_token_Token_numZ_args(x1);
		int64_t v21 = 3LL;
		bool v22 = (v20 < v21);
		VAL x23;
		uint64_t x24;
		uint64_t x25;
		uint64_t x26;
		if (v22) {
			STR* v27;
			STRLIT(v27, "expected 3 args, got too few", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v27), x2);
			uint64_t v28 = pop_u64();
			x26 = v28;
			uint64_t v29 = pop_u64();
			x25 = v29;
			uint64_t v30 = pop_u64();
			x24 = v30;
			VAL r31 = pop_resource();
			x23 = r31;
		} else {
			STR* v32;
			STRLIT(v32, "expected 3 args, got too many", 29);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v32), x2);
			uint64_t v33 = pop_u64();
			x26 = v33;
			uint64_t v34 = pop_u64();
			x25 = v34;
			uint64_t v35 = pop_u64();
			x24 = v35;
			VAL r36 = pop_resource();
			x23 = r36;
		}
		x13 = x26;
		x12 = x25;
		x11 = x24;
		x10 = x23;
	}
	*x6 = x10;
	*x5 = x13;
	*x4 = x12;
	*x3 = x11;
}
static int64_t mw_mirth_token_Token_numZ_args (uint64_t x1) {
	uint64_t v2 = mw_mirth_token_Token_argsZ_start(x1);
	int64_t v3 = mw_mirth_token_Token_leftZ_enclosureZAsk(v2);
	int64_t x4;
	if (((bool)v3)) {
		int64_t v5 = 0LL;
		int64_t v6 = mw_mirth_token_Token_argsZ_endZAsk(v2);
		bool v7 = !((bool)v6);
		int64_t v8 = v5;
		uint64_t v9 = v2;
		bool v10 = v7;
		while (v10) {
			int64_t v11 = v8;
			uint64_t v12 = v9;
			int64_t v13 = 1LL;
			int64_t v14 = i64_add(v11, v13);
			uint64_t v15 = mw_mirth_token_Token_succ(v12);
			uint64_t v16 = mw_mirth_token_Token_nextZ_argZ_end(v15);
			int64_t v17 = mw_mirth_token_Token_argsZ_endZAsk(v16);
			bool v18 = !((bool)v17);
			v10 = v18;
			v9 = v16;
			v8 = v14;
		}
		x4 = v8;
	} else {
		int64_t v19 = 0LL;
		x4 = v19;
	}
	return x4;
}
static VAL mw_mirth_token_Token_args (uint64_t x1) {
	uint64_t v2 = mw_mirth_token_Token_argsZ_start(x1);
	int64_t v3 = mw_mirth_token_Token_leftZ_enclosureZAsk(v2);
	VAL x4;
	if (((bool)v3)) {
		VAL v5 = MKI64(0LL /* Nil */);
		VAL v6 = mw_std_list_List_1_reverse(v5);
		int64_t v7 = mw_mirth_token_Token_argsZ_endZAsk(v2);
		bool v8 = !((bool)v7);
		uint64_t v9 = v2;
		VAL v10 = (v6);
		bool v11 = v8;
		while (v11) {
			uint64_t v12 = v9;
			VAL v13 = (v10);
			uint64_t v14 = mw_mirth_token_Token_succ(v12);
			uint64_t v15 = mw_mirth_token_Token_nextZ_argZ_end(v14);
			VAL v16 = mtw_std_list_List_1_Cons(MKU64(v14), v13);
			int64_t v17 = mw_mirth_token_Token_argsZ_endZAsk(v15);
			bool v18 = !((bool)v17);
			v11 = v18;
			v10 = v16;
			v9 = v15;
		}
		VAL v19 = mw_std_list_List_1_reverse(v10);
		x4 = v19;
	} else {
		VAL v20 = MKI64(0LL /* Nil */);
		x4 = v20;
	}
	return x4;
}
static int64_t mw_mirth_token_Token_argsZ_endZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_commaZAsk(x1);
	uint64_t x3;
	if (((bool)v2)) {
		uint64_t v4 = mw_mirth_token_Token_succ(x1);
		x3 = v4;
	} else {
		x3 = x1;
	}
	int64_t v5 = mw_mirth_token_Token_rightZ_enclosureZAsk(x3);
	return v5;
}
static void mw_mirth_token_Token_argsZPlus (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_token_Token_args(x1);
	VAL v6 = mw_std_list_List_1_ZToListZPlus(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
			x9 = v10;
			x8 = x1;
			x7 = x2;
		} break;
		case 0LL: { // None
			STR* v11;
			STRLIT(v11, "expected 1 or more args, got none", 33);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v11), x2);
			VAL v12 = pop_value();
			x9 = v12;
			uint64_t v13 = pop_u64();
			x8 = v13;
			VAL r14 = pop_resource();
			x7 = r14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x9;
}
static int64_t mw_mirth_token_Token_moduleZ_endZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_noneZAsk(x1);
	return v2;
}
static int64_t mw_mirth_token_Token_runZ_endZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // TokenNone
			int64_t v4 = 1LL /* True */;
			x3 = v4;
		} break;
		case 1LL: { // TokenComma
			int64_t v5 = 1LL /* True */;
			x3 = v5;
		} break;
		case 7LL: { // TokenRParen
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenRParen(v2);
			int64_t v7 = 1LL /* True */;
			x3 = v7;
		} break;
		case 9LL: { // TokenRSquare
			uint64_t v8 = mtp_mirth_token_TokenValue_TokenRSquare(v2);
			int64_t v9 = 1LL /* True */;
			x3 = v9;
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v10 = mtp_mirth_token_TokenValue_TokenRCurly(v2);
			int64_t v11 = 1LL /* True */;
			x3 = v11;
		} break;
		case 13LL: { // TokenRColon
			uint64_t v12 = mtp_mirth_token_TokenValue_TokenRColon(v2);
			int64_t v13 = 1LL /* True */;
			x3 = v13;
		} break;
		default: {
			decref(v2);
			int64_t v14 = 0LL /* False */;
			x3 = v14;
		} break;
	}
	return x3;
}
static VAL mw_mirth_token_Token_runZ_tokens (uint64_t x1) {
	VAL v2 = MKI64(0LL /* Nil */);
	VAL v3 = mw_std_list_List_1_reverse(v2);
	int64_t v4 = mw_mirth_token_Token_runZ_endZAsk(x1);
	bool v5 = !((bool)v4);
	uint64_t v6 = x1;
	VAL v7 = (v3);
	bool v8 = v5;
	while (v8) {
		uint64_t v9 = v6;
		VAL v10 = (v7);
		uint64_t v11 = mw_mirth_token_Token_next(v9);
		VAL v12 = mtw_std_list_List_1_Cons(MKU64(v9), v10);
		int64_t v13 = mw_mirth_token_Token_runZ_endZAsk(v11);
		bool v14 = !((bool)v13);
		v8 = v14;
		v7 = v12;
		v6 = v11;
	}
	VAL v15 = mw_std_list_List_1_reverse(v7);
	return v15;
}
static int64_t mw_mirth_token_Token_runZ_length (uint64_t x1) {
	int64_t v2 = 0LL;
	int64_t v3 = mw_mirth_token_Token_runZ_endZAsk(x1);
	bool v4 = !((bool)v3);
	int64_t v5 = v2;
	uint64_t v6 = x1;
	bool v7 = v4;
	while (v7) {
		int64_t v8 = v5;
		uint64_t v9 = v6;
		uint64_t v10 = mw_mirth_token_Token_next(v9);
		int64_t v11 = 1LL;
		int64_t v12 = i64_add(v8, v11);
		int64_t v13 = mw_mirth_token_Token_runZ_endZAsk(v10);
		bool v14 = !((bool)v13);
		v7 = v14;
		v6 = v10;
		v5 = v12;
	}
	return v5;
}
static VAL mw_mirth_token_Token_runZ_arrowZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_runZ_tokens(x1);
	VAL v3 = MKI64(0LL /* None */);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v2, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			incref(v9);
			int64_t v10 = mw_mirth_token_Token_arrowZAsk(VU64(v9));
			VAL x11;
			if (((bool)v10)) {
				VAL v12 = mtw_std_maybe_Maybe_1_Some(v9);
				x11 = v12;
			} else {
				decref(v9);
				VAL v13 = MKI64(0LL /* None */);
				x11 = v13;
			}
			VAL x14;
			VAL x15;
			switch (get_data_tag(x11)) {
				case 0LL: { // None
					x15 = v5;
					x14 = v3;
				} break;
				default: {
					decref(v5);
					decref(v3);
					VAL v16 = MKI64(0LL /* Nil */);
					x15 = v16;
					x14 = x11;
				} break;
			}
			int64_t v17 = 1LL /* True */;
			x8 = v17;
			x7 = x15;
			x6 = x14;
		} break;
		case 0LL: { // None
			int64_t v18 = 0LL /* False */;
			x8 = v18;
			x7 = v5;
			x6 = v3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v19 = x6;
	VAL v20 = x7;
	int64_t v21 = x8;
	while (((bool)v21)) {
		VAL v22 = v19;
		VAL v23 = v20;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		VAL x26;
		VAL x27;
		int64_t x28;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v29 = mtp_std_maybe_Maybe_1_Some(v24);
				incref(v29);
				int64_t v30 = mw_mirth_token_Token_arrowZAsk(VU64(v29));
				VAL x31;
				if (((bool)v30)) {
					VAL v32 = mtw_std_maybe_Maybe_1_Some(v29);
					x31 = v32;
				} else {
					decref(v29);
					VAL v33 = MKI64(0LL /* None */);
					x31 = v33;
				}
				VAL x34;
				VAL x35;
				switch (get_data_tag(x31)) {
					case 0LL: { // None
						x35 = v25;
						x34 = v22;
					} break;
					default: {
						decref(v25);
						decref(v22);
						VAL v36 = MKI64(0LL /* Nil */);
						x35 = v36;
						x34 = x31;
					} break;
				}
				int64_t v37 = 1LL /* True */;
				x28 = v37;
				x27 = x35;
				x26 = x34;
			} break;
			case 0LL: { // None
				int64_t v38 = 0LL /* False */;
				x28 = v38;
				x27 = v25;
				x26 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x28;
		v20 = x27;
		v19 = x26;
	}
	decref(v20);
	return v19;
}
static int64_t mw_mirth_token_Token_sigZ_stackZ_endZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_sigZ_dashesZAsk(x1);
	uint64_t x3;
	int64_t x4;
	if (((bool)v2)) {
		int64_t v5 = 1LL /* True */;
		x4 = v5;
		x3 = x1;
	} else {
		int64_t v6 = mw_mirth_token_Token_runZ_endZAsk(x1);
		x4 = v6;
		x3 = x1;
	}
	return x4;
}
static uint64_t mw_mirth_token_Token_sigZ_nextZ_stackZ_end (uint64_t x1) {
	int64_t v2 = mw_mirth_token_Token_sigZ_stackZ_endZAsk(x1);
	bool v3 = !((bool)v2);
	uint64_t v4 = x1;
	bool v5 = v3;
	while (v5) {
		uint64_t v6 = v4;
		uint64_t v7 = mw_mirth_token_Token_next(v6);
		int64_t v8 = mw_mirth_token_Token_sigZ_stackZ_endZAsk(v7);
		bool v9 = !((bool)v8);
		v5 = v9;
		v4 = v7;
	}
	return v4;
}
static int64_t mw_mirth_token_Token_sigZ_hasZ_dashesZAsk (uint64_t x1) {
	uint64_t v2 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(x1);
	int64_t v3 = mw_mirth_token_Token_sigZ_dashesZAsk(v2);
	return v3;
}
static VAL mw_mirth_token_Token_patZ_tokens (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_runZ_tokens(x1);
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v2, &v5, &v6);
	VAL x7;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v8);
			int64_t v9 = mw_mirth_token_Token_arrowZAsk(VU64(v8));
			bool v10 = !((bool)v9);
			VAL x11;
			if (v10) {
				VAL v12 = mtw_std_maybe_Maybe_1_Some(v8);
				x11 = v12;
			} else {
				decref(v8);
				VAL v13 = MKI64(0LL /* None */);
				x11 = v13;
			}
			x7 = x11;
		} break;
		case 0LL: { // None
			VAL v14 = MKI64(0LL /* None */);
			x7 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x15;
	VAL x16;
	int64_t x17;
	switch (get_data_tag(x7)) {
		case 1LL: { // Some
			VAL v18 = mtp_std_maybe_Maybe_1_Some(x7);
			VAL v19 = mtw_std_list_List_1_Cons(v18, v4);
			int64_t v20 = 1LL /* True */;
			x17 = v20;
			x16 = v19;
			x15 = v6;
		} break;
		case 0LL: { // None
			int64_t v21 = 0LL /* False */;
			x17 = v21;
			x16 = v4;
			x15 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v22 = x15;
	VAL v23 = (x16);
	int64_t v24 = x17;
	while (((bool)v24)) {
		VAL v25 = v22;
		VAL v26 = (v23);
		VAL v27;
		VAL v28;
		mw_std_list_List_1_uncons(v25, &v27, &v28);
		VAL x29;
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v27);
				incref(v30);
				int64_t v31 = mw_mirth_token_Token_arrowZAsk(VU64(v30));
				bool v32 = !((bool)v31);
				VAL x33;
				if (v32) {
					VAL v34 = mtw_std_maybe_Maybe_1_Some(v30);
					x33 = v34;
				} else {
					decref(v30);
					VAL v35 = MKI64(0LL /* None */);
					x33 = v35;
				}
				x29 = x33;
			} break;
			case 0LL: { // None
				VAL v36 = MKI64(0LL /* None */);
				x29 = v36;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL x37;
		VAL x38;
		int64_t x39;
		switch (get_data_tag(x29)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(x29);
				VAL v41 = mtw_std_list_List_1_Cons(v40, v26);
				int64_t v42 = 1LL /* True */;
				x39 = v42;
				x38 = v41;
				x37 = v28;
			} break;
			case 0LL: { // None
				int64_t v43 = 0LL /* False */;
				x39 = v43;
				x38 = v26;
				x37 = v28;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v24 = x39;
		v23 = x38;
		v22 = x37;
	}
	VAL v44 = mw_std_list_List_1_reverse(v23);
	decref(v22);
	return v44;
}
static int64_t mw_mirth_module_Module_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_module_Module_allocZBang (void) {
	void* v1 = mbuf_mirth_module_Module_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_module_Module_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_module_Module_package (uint64_t x1) {
	void* v2 = mfld_mirth_module_Module_ZTildepackage(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static uint64_t mw_mirth_module_Module_name (uint64_t x1) {
	void* v2 = mfld_mirth_module_Module_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_module_Module_qname (uint64_t x1) {
	uint64_t v2 = mw_mirth_module_Module_package(x1);
	VAL v3 = mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE(v2);
	uint64_t v4 = mw_mirth_module_Module_name(x1);
	VAL v5 = mw_mirth_name_QNAME0(v3, v4);
	return v5;
}
static VAL mw_mirth_module_Module_path (uint64_t x1) {
	void* v2 = mfld_mirth_module_Module_ZTildepath(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static uint64_t mw_mirth_module_Module_start (uint64_t x1) {
	void* v2 = mfld_mirth_module_Module_ZTildestart(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_module_Module_imports (uint64_t x1) {
	void* v2 = mfld_mirth_module_Module_ZTildeimports(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static int64_t mw_mirth_module_Module_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_module_Module_index(x1);
	int64_t v4 = mw_mirth_module_Module_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_module_Module_prim (VAL x1, VAL *x2, uint64_t *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[2]);
	decref(v4);
	*x3 = v5;
	*x2 = x1;
}
static VAL mw_mirth_module_initZ_modulesZBang (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[4]);
	incref(v2);
	uint64_t v3 = VU64(VTUP(v2)->cells[2]);
	decref(v2);
	VAL v4 = MKI64(0LL /* Nil */);
	void* v5 = mfld_mirth_module_Module_ZTildeimports(v3);
	mut_set(v4, v5);
	STR* v6;
	STRLIT(v6, "<prim>", 6);
	void* v7 = mfld_mirth_module_Module_ZTildepath(v3);
	mut_set(MKSTR(v6), v7);
	VAL v8;
	uint64_t v9;
	mw_mirth_package_Package_std(x1, &v8, &v9);
	void* v10 = mfld_mirth_module_Module_ZTildepackage(v3);
	mut_set(MKU64(v9), v10);
	STR* v11;
	STRLIT(v11, "prim", 4);
	uint64_t v12 = mw_std_prim_Str_ZToName(MKSTR(v11));
	void* v13 = mfld_mirth_module_Module_ZTildename(v3);
	mut_set(MKU64(v12), v13);
	return v8;
}
static void mw_mirth_module_Module_newZBang (VAL x1, VAL x2, VAL *x3, uint64_t *x4) {
	uint64_t v5 = mw_mirth_module_Module_allocZBang();
	VAL v6;
	uint64_t v7;
	mw_mirth_module_Module_prim(x1, &v6, &v7);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mtw_std_list_List_1_Cons(MKU64(v7), v8);
	void* v10 = mfld_mirth_module_Module_ZTildeimports(v5);
	mut_set(v9, v10);
	void* v11 = mfld_mirth_module_Module_ZTildepath(v5);
	mut_set(x2, v11);
	*x4 = v5;
	*x3 = v6;
}
static void mw_mirth_module_Module_addZ_importZBang (uint64_t x1, uint64_t x2) {
	void* v3 = mfld_mirth_module_Module_ZTildeimports(x1);
	VAL v4 = mut_get(v3);
	VAL v5 = mtw_std_list_List_1_Cons(MKU64(x2), v4);
	mut_set(v5, v3);
}
static VAL mw_mirth_module_Module_sourceZ_path (uint64_t x1) {
	VAL v2 = mw_mirth_module_Module_path(x1);
	return v2;
}
static int64_t mw_mirth_module_Module_visible (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_module_Module_ZEqualZEqual(x1, x2);
	int64_t x4;
	if (((bool)v3)) {
		int64_t v5 = 1LL /* True */;
		x4 = v5;
	} else {
		VAL v6 = mw_mirth_module_Module_imports(x2);
		VAL v7 = MKI64(0LL /* None */);
		VAL v8;
		VAL v9;
		mw_std_list_List_1_uncons(v6, &v8, &v9);
		uint64_t x10;
		VAL x11;
		VAL x12;
		int64_t x13;
		switch (get_data_tag(v8)) {
			case 1LL: { // Some
				VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
				incref(v14);
				int64_t v15 = mw_mirth_module_Module_ZEqualZEqual(x1, VU64(v14));
				uint64_t x16;
				VAL x17;
				if (((bool)v15)) {
					VAL v18 = mtw_std_maybe_Maybe_1_Some(v14);
					x17 = v18;
					x16 = x1;
				} else {
					decref(v14);
					VAL v19 = MKI64(0LL /* None */);
					x17 = v19;
					x16 = x1;
				}
				uint64_t x20;
				VAL x21;
				VAL x22;
				switch (get_data_tag(x17)) {
					case 0LL: { // None
						x22 = v9;
						x21 = v7;
						x20 = x16;
					} break;
					default: {
						decref(v9);
						decref(v7);
						VAL v23 = MKI64(0LL /* Nil */);
						x22 = v23;
						x21 = x17;
						x20 = x16;
					} break;
				}
				int64_t v24 = 1LL /* True */;
				x13 = v24;
				x12 = x22;
				x11 = x21;
				x10 = x20;
			} break;
			case 0LL: { // None
				int64_t v25 = 0LL /* False */;
				x13 = v25;
				x12 = v9;
				x11 = v7;
				x10 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v26 = x10;
		VAL v27 = x11;
		VAL v28 = x12;
		int64_t v29 = x13;
		while (((bool)v29)) {
			uint64_t v30 = v26;
			VAL v31 = v27;
			VAL v32 = v28;
			VAL v33;
			VAL v34;
			mw_std_list_List_1_uncons(v32, &v33, &v34);
			uint64_t x35;
			VAL x36;
			VAL x37;
			int64_t x38;
			switch (get_data_tag(v33)) {
				case 1LL: { // Some
					VAL v39 = mtp_std_maybe_Maybe_1_Some(v33);
					incref(v39);
					int64_t v40 = mw_mirth_module_Module_ZEqualZEqual(v30, VU64(v39));
					uint64_t x41;
					VAL x42;
					if (((bool)v40)) {
						VAL v43 = mtw_std_maybe_Maybe_1_Some(v39);
						x42 = v43;
						x41 = v30;
					} else {
						decref(v39);
						VAL v44 = MKI64(0LL /* None */);
						x42 = v44;
						x41 = v30;
					}
					uint64_t x45;
					VAL x46;
					VAL x47;
					switch (get_data_tag(x42)) {
						case 0LL: { // None
							x47 = v34;
							x46 = v31;
							x45 = x41;
						} break;
						default: {
							decref(v34);
							decref(v31);
							VAL v48 = MKI64(0LL /* Nil */);
							x47 = v48;
							x46 = x42;
							x45 = x41;
						} break;
					}
					int64_t v49 = 1LL /* True */;
					x38 = v49;
					x37 = x47;
					x36 = x46;
					x35 = x45;
				} break;
				case 0LL: { // None
					int64_t v50 = 0LL /* False */;
					x38 = v50;
					x37 = v34;
					x36 = v31;
					x35 = v30;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v29 = x38;
			v28 = x37;
			v27 = x36;
			v26 = x35;
		}
		decref(v28);
		int64_t v51 = mw_std_maybe_Maybe_1_someZAsk(v27);
		x4 = v51;
	}
	return x4;
}
static int64_t mw_std_prim_Int_ZToRow (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_location_Row_ZToInt (int64_t x1) {
	return x1;
}
static VAL mw_mirth_location_Row_showZThen (VAL x1, int64_t x2) {
	STR* v3 = i64_show(x2);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), x1));
	return v4;
}
static int64_t mw_std_prim_Int_ZToCol (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_location_Col_ZToInt (int64_t x1) {
	return x1;
}
static VAL mw_mirth_location_Col_showZThen (VAL x1, int64_t x2) {
	STR* v3 = i64_show(x2);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), x1));
	return v4;
}
static VAL mw_mirth_location_Location_emitZThen (VAL x1, VAL x2) {
	uint64_t v3;
	int64_t v4;
	int64_t v5;
	mtp_mirth_location_Location_Location(x2, &v3, &v4, &v5);
	VAL v6 = mw_mirth_module_Module_sourceZ_path(v3);
	VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, x1));
	STR* v8;
	STRLIT(v8, ":", 1);
	VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
	VAL v10 = (mw_mirth_location_Row_showZThen(v9, v4));
	STR* v11;
	STRLIT(v11, ":", 1);
	VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
	VAL v13 = (mw_mirth_location_Col_showZThen(v12, v5));
	return v13;
}
static int64_t mw_mirth_alias_Alias_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_alias_Alias_allocZBang (void) {
	void* v1 = mbuf_mirth_alias_Alias_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_alias_Alias_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_alias_Alias_qnameZ_soft (uint64_t x1) {
	void* v2 = mfld_mirth_alias_Alias_ZTildeqname(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v6 = mw_mirth_mirth_Prop_1_readyZAsk(v5);
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = MKI64(0LL /* None */);
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_alias_Alias_qnameZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_alias_Alias_ZTildeqname(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static void mw_mirth_alias_Alias_namespaceZ_hard (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_alias_Alias_qnameZ_hard(x1, x2, &v5, &v6);
	VAL v7 = VVAL(VTUP(v6)->cells[1]);
	incref(v7);
	decref(v6);
	*x4 = v7;
	*x3 = v5;
}
static uint64_t mw_mirth_alias_Alias_name (uint64_t x1) {
	void* v2 = mfld_mirth_alias_Alias_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static int64_t mw_mirth_alias_Alias_arity (uint64_t x1) {
	void* v2 = mfld_mirth_alias_Alias_ZTildearity(x1);
	VAL v3 = mut_get(v2);
	return VI64(v3);
}
static void mw_mirth_alias_Alias_target (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_alias_Alias_ZTildetarget(x2);
	VAL v6;
	VAL v7;
	mw_mirth_mirth_Prop_1_forceZBang(v5, x1, &v6, &v7);
	*x4 = v6;
	*x3 = v7;
}
static int64_t mw_mirth_alias_Alias_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_alias_Alias_index(x1);
	int64_t v4 = mw_mirth_alias_Alias_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static void mw_mirth_alias_Alias_newZBang (VAL x1, uint64_t x2, uint64_t x3, int64_t x4, VAL *x5, uint64_t *x6) {
	uint64_t v7 = mw_mirth_alias_Alias_allocZBang();
	void* v8 = mfld_mirth_alias_Alias_ZTildename(v7);
	mut_set(MKU64(x3), v8);
	void* v9 = mfld_mirth_alias_Alias_ZTildehead(v7);
	mut_set(MKU64(x2), v9);
	void* v10 = mfld_mirth_alias_Alias_ZTildearity(v7);
	mut_set(MKI64(x4), v10);
	VAL v11 = mtw_mirth_def_Def_DefAlias(v7);
	VAL v12 = (mw_mirth_def_Def_register(x1, v11));
	*x6 = v7;
	*x5 = v12;
}
static VAL mw_mirth_mirth_Builtin_AllocZBang (void) {
	uint64_t v1 = mw_mirth_package_Package_allocZBang();
	uint64_t v2 = mw_mirth_module_Module_allocZBang();
	uint64_t v3 = mw_mirth_data_Data_allocZBang();
	uint64_t v4 = mw_mirth_data_Tag_allocZBang();
	uint64_t v5 = mw_mirth_data_Tag_allocZBang();
	uint64_t v6 = mw_mirth_data_Data_allocZBang();
	uint64_t v7 = mw_mirth_data_Tag_allocZBang();
	uint64_t v8 = mw_mirth_data_Data_allocZBang();
	uint64_t v9 = mw_mirth_data_Tag_allocZBang();
	uint64_t v10 = mw_mirth_data_Data_allocZBang();
	uint64_t v11 = mw_mirth_data_Tag_allocZBang();
	uint64_t v12 = mw_mirth_data_Data_allocZBang();
	uint64_t v13 = mw_mirth_data_Tag_allocZBang();
	uint64_t v14 = mw_mirth_data_Data_allocZBang();
	uint64_t v15 = mw_mirth_data_Tag_allocZBang();
	uint64_t v16 = mw_mirth_data_Data_allocZBang();
	uint64_t v17 = mw_mirth_data_Tag_allocZBang();
	uint64_t v18 = mw_mirth_data_Data_allocZBang();
	uint64_t v19 = mw_mirth_data_Tag_allocZBang();
	uint64_t v20 = mw_mirth_data_Data_allocZBang();
	uint64_t v21 = mw_mirth_data_Tag_allocZBang();
	uint64_t v22 = mw_mirth_data_Data_allocZBang();
	uint64_t v23 = mw_mirth_data_Tag_allocZBang();
	uint64_t v24 = mw_mirth_data_Data_allocZBang();
	uint64_t v25 = mw_mirth_data_Tag_allocZBang();
	uint64_t v26 = mw_mirth_data_Data_allocZBang();
	uint64_t v27 = mw_mirth_data_Tag_allocZBang();
	uint64_t v28 = mw_mirth_data_Data_allocZBang();
	uint64_t v29 = mw_mirth_data_Tag_allocZBang();
	uint64_t v30 = mw_mirth_data_Data_allocZBang();
	uint64_t v31 = mw_mirth_data_Tag_allocZBang();
	uint64_t v32 = mw_mirth_data_Data_allocZBang();
	uint64_t v33 = mw_mirth_data_Tag_allocZBang();
	uint64_t v34 = mw_mirth_data_Data_allocZBang();
	uint64_t v35 = mw_mirth_data_Tag_allocZBang();
	uint64_t v36 = mw_mirth_data_Data_allocZBang();
	uint64_t v37 = mw_mirth_data_Tag_allocZBang();
	uint64_t v38 = mw_mirth_data_Data_allocZBang();
	uint64_t v39 = mw_mirth_data_Tag_allocZBang();
	uint64_t v40 = mw_mirth_data_Data_allocZBang();
	uint64_t v41 = mw_mirth_data_Tag_allocZBang();
	uint64_t v42 = mw_mirth_data_Data_allocZBang();
	uint64_t v43 = mw_mirth_data_Tag_allocZBang();
	uint64_t v44 = mw_mirth_data_Data_allocZBang();
	uint64_t v45 = mw_mirth_data_Tag_allocZBang();
	uint64_t v46 = mw_mirth_data_Data_allocZBang();
	uint64_t v47 = mw_mirth_data_Tag_allocZBang();
	uint64_t v48 = mw_mirth_data_Data_allocZBang();
	uint64_t v49 = mw_mirth_data_Tag_allocZBang();
	uint64_t v50 = mw_mirth_data_Data_allocZBang();
	uint64_t v51 = mw_mirth_data_Tag_allocZBang();
	uint64_t v52 = mw_mirth_data_Data_allocZBang();
	uint64_t v53 = mw_mirth_data_Tag_allocZBang();
	uint64_t v54 = mw_mirth_data_Data_allocZBang();
	uint64_t v55 = mw_mirth_data_Tag_allocZBang();
	uint64_t v56 = mw_mirth_data_Data_allocZBang();
	uint64_t v57 = mw_mirth_data_Tag_allocZBang();
	uint64_t v58 = mw_mirth_data_Data_allocZBang();
	uint64_t v59 = mw_mirth_data_Tag_allocZBang();
	uint64_t v60 = mw_mirth_data_Data_allocZBang();
	uint64_t v61 = mw_mirth_data_Tag_allocZBang();
	VAL v62 = mtw_mirth_mirth_Builtin_Builtin(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61);
	return v62;
}
static VAL mw_mirth_mirth_ZPlusMirth_InitZBang (void) {
	int64_t v1 = 0LL;
	int64_t v2 = 0LL;
	int64_t v3 = 0LL /* False */;
	VAL v4 = mw_mirth_mirth_Builtin_AllocZBang();
	VAL v5 = MKI64(0LL /* None */);
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = MKI64(0LL /* Nil */);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = MKI64(0LL /* None */);
	VAL v10 = (mtw_mirth_mirth_ZPlusMirth_ZPlusMirth(v1, v2, v3, v4, v9, v5, v6, v7, v8));
	VAL v11 = (mw_mirth_package_initZ_packagesZBang(v10));
	VAL v12 = (mw_mirth_module_initZ_modulesZBang(v11));
	VAL v13 = (mw_mirth_mirth_ZPlusMirth_initZ_typesZBang(v12));
	VAL v14 = (mw_mirth_prim_initZ_primsZBang(v13));
	return v14;
}
static void mw_mirth_mirth_ZPlusMirth_rdrop (VAL x1) {
	int64_t v2;
	int64_t v3;
	int64_t v4;
	VAL v5;
	VAL v6;
	VAL v7;
	VAL v8;
	VAL v9;
	VAL v10;
	mtp_mirth_mirth_ZPlusMirth_ZPlusMirth(x1, &v2, &v3, &v4, &v5, &v6, &v7, &v8, &v9, &v10);
	decref(v5);
	decref(v6);
	decref(v7);
	decref(v8);
	VAL v11 = mw_std_list_List_1_reverse(v9);
	decref(v11);
	VAL v12 = mw_std_list_List_1_reverse(v10);
	decref(v12);
}
static void mw_mirth_mirth_ZPlusMirth_mirthZ_baseZ_libZ_path (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[6]);
	incref(v4);
	VAL x5;
	VAL x6;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v4);
			STR* v8;
			STRLIT(v8, "lib", 3);
			VAL v9 = mw_std_path_Path_join(v7, MKSTR(v8));
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			x6 = v10;
			x5 = x1;
		} break;
		case 0LL: { // None
			VAL v11 = MKI64(0LL /* None */);
			x6 = v11;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x6;
	*x2 = x5;
}
static VAL mw_mirth_mirth_Severity_ZToStr (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 0LL: { // Info
			STR* v3;
			STRLIT(v3, "info", 4);
			x2 = MKSTR(v3);
		} break;
		case 1LL: { // Warning
			STR* v4;
			STRLIT(v4, "warning", 7);
			x2 = MKSTR(v4);
		} break;
		case 2LL: { // Error
			STR* v5;
			STRLIT(v5, "error", 5);
			x2 = MKSTR(v5);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang (VAL x1, VAL x2, int64_t x3, VAL x4) {
	VAL x5;
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (x3) {
		case 0LL: { // Info
			x8 = x3;
			x7 = x1;
			x6 = x2;
			x5 = x4;
		} break;
		case 1LL: { // Warning
			int64_t v9 = VI64(VTUP(x4)->cells[2]);
			int64_t v10 = 1LL;
			int64_t v11 = i64_add(v9, v10);
			VTUP(x4)->cells[2] = MKI64(v11);
			x8 = x3;
			x7 = x1;
			x6 = x2;
			x5 = x4;
		} break;
		case 2LL: { // Error
			int64_t v12 = VI64(VTUP(x4)->cells[1]);
			int64_t v13 = 1LL;
			int64_t v14 = i64_add(v12, v13);
			VTUP(x4)->cells[1] = MKI64(v14);
			x8 = x3;
			x7 = x1;
			x6 = x2;
			x5 = x4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15 = mtw_mirth_mirth_Diagnostic_Diagnostic(x8, x7, x6);
	VAL v16 = (VVAL(VTUP(x5)->cells[8]));
	VAL v17 = mtw_std_list_List_1_Cons(v15, v16);
	VTUP(x5)->cells[8] = v17;
	return x5;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v4 = 0LL /* Info */;
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang(x1, x2, v4, x3));
	return v5;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v4 = 1LL /* Warning */;
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang(x1, x2, v4, x3));
	return v5;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v4 = 2LL /* Error */;
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang(x1, x2, v4, x3));
	return v5;
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3) {
	VAL v4 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang(x1, x2, x3));
	mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang(v4);
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_token_Token_location(x1);
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang(v4, x2, x3));
	return v5;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_token_Token_location(x1);
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang(v4, x2, x3));
	return v5;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_token_Token_location(x1);
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang(v4, x2, x3));
	return v5;
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_token_Token_location(x1);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang(v4, x2, x3);
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang (uint64_t x1, VAL x2, VAL x3, VAL x4) {
	STR* v5;
	STRLIT(v5, "", 0);
	VAL v6 = MKI64(36LL /* FGCyan */);
	VAL v7 = (mw_std_terminal_Sgr_emitZThen(v6, MKSTR(v5)));
	VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(x2, v7));
	VAL v9 = MKI64(0LL /* Reset */);
	VAL v10 = (mw_std_terminal_Sgr_emitZThen(v9, v8));
	STR* v11;
	STRLIT(v11, " is deprecated, please use ", 27);
	VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
	VAL v13 = MKI64(36LL /* FGCyan */);
	VAL v14 = (mw_std_terminal_Sgr_emitZThen(v13, v12));
	VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(x3, v14));
	VAL v16 = MKI64(0LL /* Reset */);
	VAL v17 = (mw_std_terminal_Sgr_emitZThen(v16, v15));
	STR* v18;
	STRLIT(v18, " instead.", 9);
	VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), v17));
	VAL v20 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(x1, v19, x4));
	return v20;
}
static VAL mw_mirth_mirth_ZPlusMirth_errorZBang (VAL x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x2)->cells[5]);
	incref(v3);
	VAL x4;
	VAL x5;
	uint64_t x6;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v3);
			x6 = VU64(v7);
			x5 = x2;
			x4 = x1;
		} break;
		case 0LL: { // None
			push_resource(x2);
			do_panic(VSTR(x1));
			uint64_t v8 = pop_u64();
			x6 = v8;
			VAL r9 = pop_resource();
			x5 = r9;
			VAL v10 = pop_value();
			x4 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v11 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x6, x4, x5));
	return v11;
}
static void mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang (VAL x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x2)->cells[5]);
	incref(v3);
	VAL x4;
	VAL x5;
	uint64_t x6;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v3);
			x6 = VU64(v7);
			x5 = x2;
			x4 = x1;
		} break;
		case 0LL: { // None
			push_resource(x2);
			do_panic(VSTR(x1));
			uint64_t v8 = pop_u64();
			x6 = v8;
			VAL r9 = pop_resource();
			x5 = r9;
			VAL v10 = pop_value();
			x4 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x6, x4, x5);
}
static void mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang (VAL x1) {
	VAL v2;
	VAL v3;
	mw_mirth_mirth_ZPlusMirth_popZ_diagnostics(x1, &v2, &v3);
	STR* v4;
	STRLIT(v4, "", 0);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v3, &v5, &v6);
	VAL x7;
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			VAL v12 = (mw_mirth_mirth_Diagnostic_diagnosticZThen(MKSTR(v4), v11));
			STR* v13;
			STRLIT(v13, "\n", 1);
			VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), v12));
			int64_t v15 = 1LL /* True */;
			x10 = v15;
			x9 = v6;
			x8 = v14;
			x7 = v2;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x10 = v16;
			x9 = v6;
			x8 = MKSTR(v4);
			x7 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v17 = (x7);
	VAL v18 = (x8);
	VAL v19 = x9;
	int64_t v20 = x10;
	while (((bool)v20)) {
		VAL v21 = (v17);
		VAL v22 = (v18);
		VAL v23 = v19;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		VAL x26;
		VAL x27;
		VAL x28;
		int64_t x29;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v24);
				VAL v31 = (mw_mirth_mirth_Diagnostic_diagnosticZThen(v22, v30));
				STR* v32;
				STRLIT(v32, "\n", 1);
				VAL v33 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v32), v31));
				int64_t v34 = 1LL /* True */;
				x29 = v34;
				x28 = v25;
				x27 = v33;
				x26 = v21;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x29 = v35;
				x28 = v25;
				x27 = v22;
				x26 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x29;
		v19 = x28;
		v18 = x27;
		v17 = x26;
	}
	decref(v19);
	VAL v36 = MKI64(31LL /* FGRed */);
	VAL v37 = (mw_std_terminal_Sgr_emitZThen(v36, v18));
	STR* v38;
	STRLIT(v38, "Fatal error. Stopping early.", 28);
	VAL v39 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v38), v37));
	VAL v40 = MKI64(0LL /* Reset */);
	VAL v41 = (mw_std_terminal_Sgr_emitZThen(v40, v39));
	push_resource(v17);
	do_panic(VSTR(v41));
}
static void mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang (int64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_mirth_ZPlusMirth_popZ_diagnostics(x2, &v5, &v6);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	int64_t x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			STR* v14;
			STRLIT(v14, "", 0);
			VAL v15 = (mw_mirth_mirth_Diagnostic_diagnosticZThen(MKSTR(v14), v13));
			STR* v16;
			STRLIT(v16, "\n", 1);
			STR* v17 = str_cat(VSTR(v15), v16);
			int64_t v18 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v17), x1));
			int64_t v19 = 1LL /* True */;
			x12 = v19;
			x11 = v8;
			x10 = v5;
			x9 = v18;
		} break;
		case 0LL: { // None
			int64_t v20 = 0LL /* False */;
			x12 = v20;
			x11 = v8;
			x10 = v5;
			x9 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v21 = (x9);
	VAL v22 = (x10);
	VAL v23 = x11;
	int64_t v24 = x12;
	while (((bool)v24)) {
		int64_t v25 = (v21);
		VAL v26 = (v22);
		VAL v27 = v23;
		VAL v28;
		VAL v29;
		mw_std_list_List_1_uncons(v27, &v28, &v29);
		int64_t x30;
		VAL x31;
		VAL x32;
		int64_t x33;
		switch (get_data_tag(v28)) {
			case 1LL: { // Some
				VAL v34 = mtp_std_maybe_Maybe_1_Some(v28);
				STR* v35;
				STRLIT(v35, "", 0);
				VAL v36 = (mw_mirth_mirth_Diagnostic_diagnosticZThen(MKSTR(v35), v34));
				STR* v37;
				STRLIT(v37, "\n", 1);
				STR* v38 = str_cat(VSTR(v36), v37);
				int64_t v39 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v38), v25));
				int64_t v40 = 1LL /* True */;
				x33 = v40;
				x32 = v29;
				x31 = v26;
				x30 = v39;
			} break;
			case 0LL: { // None
				int64_t v41 = 0LL /* False */;
				x33 = v41;
				x32 = v29;
				x31 = v26;
				x30 = v25;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v24 = x33;
		v23 = x32;
		v22 = x31;
		v21 = x30;
	}
	decref(v23);
	*x4 = v22;
	*x3 = v21;
}
static void mw_mirth_mirth_ZPlusMirth_popZ_diagnostics (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = (VVAL(VTUP(x1)->cells[8]));
	VAL v5 = mw_std_list_List_1_reverse(v4);
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	VTUP(x1)->cells[8] = v7;
	*x3 = v5;
	*x2 = x1;
}
static VAL mw_mirth_mirth_Diagnostic_diagnosticZThen (VAL x1, VAL x2) {
	int64_t v3;
	VAL v4;
	VAL v5;
	mtp_mirth_mirth_Diagnostic_Diagnostic(x2, &v3, &v4, &v5);
	VAL v6 = (mw_mirth_location_Location_emitZThen(x1, v4));
	STR* v7;
	STRLIT(v7, ": ", 2);
	VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
	lpush(&lbl_message, v5);
	push_resource(v8);
	VAL v9 = mw_mirth_mirth_Severity_ZToStr(v3);
	VAL r10 = pop_resource();
	VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v9, r10));
	STR* v12;
	STRLIT(v12, ": ", 2);
	VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
	VAL v14 = lpop(&lbl_message);
	VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(v14, v13));
	return v15;
}
static void mw_mirth_mirth_PropLabel_prop (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_mirth_PropState_1_PSReady(x1);
	VAL v7 = mtw_mirth_mirth_Prop_1_Prop(x2, v6);
	*x5 = x3;
	*x4 = v7;
}
static void mw_mirth_mirth_PropLabel_prop2 (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6) {
	VAL v7 = MKNIL;
	VAL v8 = mkcons(v7, x1);
	VAL v9 = mkcons(v8, x2);
	VAL v10;
	VAL v11;
	mw_mirth_mirth_PropLabel_prop(v9, x3, x4, &v10, &v11);
	*x6 = v11;
	*x5 = v10;
}
static void mw_mirth_mirth_PropLabel_prop_1 (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6) {
	push_value(x1);
	push_value(x2);
	push_resource(x3);
	push_value(x4);
	{
		VAL v7 = pop_value();
		VAL var_f = v7;
		VAL v8 = pop_value();
		incref(var_f);
		VAL v9 = var_f;
		VAL v10 = pop_value();
		VAL v11 = mtw_mirth_mirth_PropState_1_PSDelay(v10, v9);
		VAL v12 = mtw_mirth_mirth_Prop_1_Prop(v8, v11);
		decref(var_f);
		push_value(v12);
	}
	VAL r13 = pop_resource();
	*x6 = r13;
	VAL v14 = pop_value();
	*x5 = v14;
}
static VAL mw_mirth_mirth_Prop_1_readyZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[2]);
	incref(v2);
	decref(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // PSReady
			VAL v4 = mtp_mirth_mirth_PropState_1_PSReady(v2);
			VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
			x3 = v5;
		} break;
		default: {
			decref(v2);
			VAL v6 = MKI64(0LL /* None */);
			x3 = v6;
		} break;
	}
	return x3;
}
static void mw_mirth_mirth_Prop_1_tryZ_forceZBang (void* x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mut_get(x1);
	VAL v6 = VVAL(VTUP(v5)->cells[2]);
	incref(v6);
	decref(v5);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 0LL: { // PSReady
			VAL v9 = mtp_mirth_mirth_PropState_1_PSReady(v6);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			x8 = v10;
			x7 = x2;
		} break;
		case 1LL: { // PSDelay
			VAL v11;
			VAL v12;
			mtp_mirth_mirth_PropState_1_PSDelay(v6, &v11, &v12);
			VAL v13 = MKI64(2LL /* PSComputing */);
			VAL v14 = mut_get(x1);
			VAL v15 = tup_replace(v14, 2, v13);
			mut_set(v15, x1);
			push_resource(x2);
			push_value(v11);
			run_value(v12);
			VAL v16 = pop_value();
			incref(v16);
			VAL v17 = mtw_mirth_mirth_PropState_1_PSReady(v16);
			VAL v18 = mut_get(x1);
			VAL v19 = tup_replace(v18, 2, v17);
			mut_set(v19, x1);
			VAL v20 = mtw_std_maybe_Maybe_1_Some(v16);
			x8 = v20;
			VAL r21 = pop_resource();
			x7 = r21;
		} break;
		case 2LL: { // PSComputing
			VAL v22 = MKI64(0LL /* None */);
			x8 = v22;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x8;
}
static void mw_mirth_mirth_Prop_1_forceZBang (void* x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_mirth_Prop_1_tryZ_forceZBang(x1, x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v5);
			x8 = v9;
			x7 = v6;
		} break;
		case 0LL: { // None
			STR* v10;
			STRLIT(v10, "Recursive prop detected!", 24);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v10), v6);
			VAL v11 = pop_value();
			x8 = v11;
			VAL r12 = pop_resource();
			x7 = r12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x8;
}
static VAL mw_mirth_def_Def_packageZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 2LL: { // DefPackage
			uint64_t v3 = mtp_mirth_def_Def_DefPackage(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_moduleZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 1LL: { // DefModule
			uint64_t v3 = mtp_mirth_def_Def_DefModule(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_aliasZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v3 = mtp_mirth_def_Def_DefAlias(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_dataZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 3LL: { // DefData
			uint64_t v3 = mtp_mirth_def_Def_DefData(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_tableZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 4LL: { // DefTable
			uint64_t v3 = mtp_mirth_def_Def_DefTable(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_typedefZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 5LL: { // DefType
			uint64_t v3 = mtp_mirth_def_Def_DefType(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_tagZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 6LL: { // DefTag
			uint64_t v3 = mtp_mirth_def_Def_DefTag(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_primZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 7LL: { // DefPrim
			int64_t v3 = mtp_mirth_def_Def_DefPrim(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKI64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_wordZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 8LL: { // DefWord
			uint64_t v3 = mtp_mirth_def_Def_DefWord(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_bufferZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 9LL: { // DefBuffer
			uint64_t v3 = mtp_mirth_def_Def_DefBuffer(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_variableZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 10LL: { // DefVariable
			uint64_t v3 = mtp_mirth_def_Def_DefVariable(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_externalZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 11LL: { // DefExternal
			uint64_t v3 = mtp_mirth_def_Def_DefExternal(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static VAL mw_mirth_def_Def_fieldZAsk (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 12LL: { // DefField
			uint64_t v3 = mtp_mirth_def_Def_DefField(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			x2 = v4;
		} break;
		default: {
			decref(x1);
			VAL v5 = MKI64(0LL /* None */);
			x2 = v5;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_def_Def_ZEqualZEqual (VAL x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v4 = mtp_mirth_def_Def_DefAlias(x2);
			VAL v5 = mtw_std_maybe_Maybe_1_Some(MKU64(v4));
			VAL v6 = mw_mirth_def_Def_aliasZAsk(x1);
			int64_t x7;
			switch (get_data_tag(v6)) {
				case 0LL: { // None
					int64_t v8 = mw_std_maybe_Maybe_1_noneZAsk(v5);
					x7 = v8;
				} break;
				case 1LL: { // Some
					VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
					int64_t x10;
					switch (get_data_tag(v5)) {
						case 1LL: { // Some
							VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
							int64_t v12 = mw_mirth_alias_Alias_ZEqualZEqual(VU64(v11), VU64(v9));
							x10 = v12;
						} break;
						case 0LL: { // None
							decref(v9);
							int64_t v13 = 0LL /* False */;
							x10 = v13;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x7 = x10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x7;
		} break;
		case 2LL: { // DefPackage
			uint64_t v14 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(MKU64(v14));
			VAL v16 = mw_mirth_def_Def_packageZAsk(x1);
			int64_t x17;
			switch (get_data_tag(v16)) {
				case 0LL: { // None
					int64_t v18 = mw_std_maybe_Maybe_1_noneZAsk(v15);
					x17 = v18;
				} break;
				case 1LL: { // Some
					VAL v19 = mtp_std_maybe_Maybe_1_Some(v16);
					int64_t x20;
					switch (get_data_tag(v15)) {
						case 1LL: { // Some
							VAL v21 = mtp_std_maybe_Maybe_1_Some(v15);
							int64_t v22 = mw_mirth_package_Package_ZEqualZEqual(VU64(v21), VU64(v19));
							x20 = v22;
						} break;
						case 0LL: { // None
							decref(v19);
							int64_t v23 = 0LL /* False */;
							x20 = v23;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x17 = x20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x17;
		} break;
		case 1LL: { // DefModule
			uint64_t v24 = mtp_mirth_def_Def_DefModule(x2);
			VAL v25 = mtw_std_maybe_Maybe_1_Some(MKU64(v24));
			VAL v26 = mw_mirth_def_Def_moduleZAsk(x1);
			int64_t x27;
			switch (get_data_tag(v26)) {
				case 0LL: { // None
					int64_t v28 = mw_std_maybe_Maybe_1_noneZAsk(v25);
					x27 = v28;
				} break;
				case 1LL: { // Some
					VAL v29 = mtp_std_maybe_Maybe_1_Some(v26);
					int64_t x30;
					switch (get_data_tag(v25)) {
						case 1LL: { // Some
							VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
							int64_t v32 = mw_mirth_module_Module_ZEqualZEqual(VU64(v31), VU64(v29));
							x30 = v32;
						} break;
						case 0LL: { // None
							decref(v29);
							int64_t v33 = 0LL /* False */;
							x30 = v33;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x27 = x30;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x27;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v34 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v35 = mtw_std_maybe_Maybe_1_Some(MKU64(v34));
			VAL v36 = mw_mirth_def_Def_bufferZAsk(x1);
			int64_t x37;
			switch (get_data_tag(v36)) {
				case 0LL: { // None
					int64_t v38 = mw_std_maybe_Maybe_1_noneZAsk(v35);
					x37 = v38;
				} break;
				case 1LL: { // Some
					VAL v39 = mtp_std_maybe_Maybe_1_Some(v36);
					int64_t x40;
					switch (get_data_tag(v35)) {
						case 1LL: { // Some
							VAL v41 = mtp_std_maybe_Maybe_1_Some(v35);
							int64_t v42 = mw_mirth_buffer_Buffer_ZEqualZEqual(VU64(v41), VU64(v39));
							x40 = v42;
						} break;
						case 0LL: { // None
							decref(v39);
							int64_t v43 = 0LL /* False */;
							x40 = v43;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x37 = x40;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x37;
		} break;
		case 7LL: { // DefPrim
			int64_t v44 = mtp_mirth_def_Def_DefPrim(x2);
			VAL v45 = mtw_std_maybe_Maybe_1_Some(MKI64(v44));
			VAL v46 = mw_mirth_def_Def_primZAsk(x1);
			int64_t x47;
			switch (get_data_tag(v46)) {
				case 0LL: { // None
					int64_t v48 = mw_std_maybe_Maybe_1_noneZAsk(v45);
					x47 = v48;
				} break;
				case 1LL: { // Some
					VAL v49 = mtp_std_maybe_Maybe_1_Some(v46);
					int64_t x50;
					switch (get_data_tag(v45)) {
						case 1LL: { // Some
							VAL v51 = mtp_std_maybe_Maybe_1_Some(v45);
							int64_t v52 = mw_mirth_prim_Prim_ZEqualZEqual(VI64(v51), VI64(v49));
							x50 = v52;
						} break;
						case 0LL: { // None
							decref(v49);
							int64_t v53 = 0LL /* False */;
							x50 = v53;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x47 = x50;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x47;
		} break;
		case 3LL: { // DefData
			uint64_t v54 = mtp_mirth_def_Def_DefData(x2);
			VAL v55 = mtw_std_maybe_Maybe_1_Some(MKU64(v54));
			VAL v56 = mw_mirth_def_Def_dataZAsk(x1);
			int64_t x57;
			switch (get_data_tag(v56)) {
				case 0LL: { // None
					int64_t v58 = mw_std_maybe_Maybe_1_noneZAsk(v55);
					x57 = v58;
				} break;
				case 1LL: { // Some
					VAL v59 = mtp_std_maybe_Maybe_1_Some(v56);
					int64_t x60;
					switch (get_data_tag(v55)) {
						case 1LL: { // Some
							VAL v61 = mtp_std_maybe_Maybe_1_Some(v55);
							int64_t v62 = mw_mirth_data_Data_ZEqualZEqual(VU64(v61), VU64(v59));
							x60 = v62;
						} break;
						case 0LL: { // None
							decref(v59);
							int64_t v63 = 0LL /* False */;
							x60 = v63;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x57 = x60;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x57;
		} break;
		case 4LL: { // DefTable
			uint64_t v64 = mtp_mirth_def_Def_DefTable(x2);
			VAL v65 = mtw_std_maybe_Maybe_1_Some(MKU64(v64));
			VAL v66 = mw_mirth_def_Def_tableZAsk(x1);
			int64_t x67;
			switch (get_data_tag(v66)) {
				case 0LL: { // None
					int64_t v68 = mw_std_maybe_Maybe_1_noneZAsk(v65);
					x67 = v68;
				} break;
				case 1LL: { // Some
					VAL v69 = mtp_std_maybe_Maybe_1_Some(v66);
					int64_t x70;
					switch (get_data_tag(v65)) {
						case 1LL: { // Some
							VAL v71 = mtp_std_maybe_Maybe_1_Some(v65);
							int64_t v72 = mw_mirth_table_Table_ZEqualZEqual(VU64(v71), VU64(v69));
							x70 = v72;
						} break;
						case 0LL: { // None
							decref(v69);
							int64_t v73 = 0LL /* False */;
							x70 = v73;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x67 = x70;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x67;
		} break;
		case 5LL: { // DefType
			uint64_t v74 = mtp_mirth_def_Def_DefType(x2);
			VAL v75 = mtw_std_maybe_Maybe_1_Some(MKU64(v74));
			VAL v76 = mw_mirth_def_Def_typedefZAsk(x1);
			int64_t x77;
			switch (get_data_tag(v76)) {
				case 0LL: { // None
					int64_t v78 = mw_std_maybe_Maybe_1_noneZAsk(v75);
					x77 = v78;
				} break;
				case 1LL: { // Some
					VAL v79 = mtp_std_maybe_Maybe_1_Some(v76);
					int64_t x80;
					switch (get_data_tag(v75)) {
						case 1LL: { // Some
							VAL v81 = mtp_std_maybe_Maybe_1_Some(v75);
							int64_t v82 = mw_mirth_typedef_TypeDef_ZEqualZEqual(VU64(v81), VU64(v79));
							x80 = v82;
						} break;
						case 0LL: { // None
							decref(v79);
							int64_t v83 = 0LL /* False */;
							x80 = v83;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x77 = x80;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x77;
		} break;
		case 11LL: { // DefExternal
			uint64_t v84 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v85 = mtw_std_maybe_Maybe_1_Some(MKU64(v84));
			VAL v86 = mw_mirth_def_Def_externalZAsk(x1);
			int64_t x87;
			switch (get_data_tag(v86)) {
				case 0LL: { // None
					int64_t v88 = mw_std_maybe_Maybe_1_noneZAsk(v85);
					x87 = v88;
				} break;
				case 1LL: { // Some
					VAL v89 = mtp_std_maybe_Maybe_1_Some(v86);
					int64_t x90;
					switch (get_data_tag(v85)) {
						case 1LL: { // Some
							VAL v91 = mtp_std_maybe_Maybe_1_Some(v85);
							int64_t v92 = mw_mirth_external_External_ZEqualZEqual(VU64(v91), VU64(v89));
							x90 = v92;
						} break;
						case 0LL: { // None
							decref(v89);
							int64_t v93 = 0LL /* False */;
							x90 = v93;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x87 = x90;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x87;
		} break;
		case 8LL: { // DefWord
			uint64_t v94 = mtp_mirth_def_Def_DefWord(x2);
			VAL v95 = mtw_std_maybe_Maybe_1_Some(MKU64(v94));
			VAL v96 = mw_mirth_def_Def_wordZAsk(x1);
			int64_t x97;
			switch (get_data_tag(v96)) {
				case 0LL: { // None
					int64_t v98 = mw_std_maybe_Maybe_1_noneZAsk(v95);
					x97 = v98;
				} break;
				case 1LL: { // Some
					VAL v99 = mtp_std_maybe_Maybe_1_Some(v96);
					int64_t x100;
					switch (get_data_tag(v95)) {
						case 1LL: { // Some
							VAL v101 = mtp_std_maybe_Maybe_1_Some(v95);
							int64_t v102 = mw_mirth_word_Word_ZEqualZEqual(VU64(v101), VU64(v99));
							x100 = v102;
						} break;
						case 0LL: { // None
							decref(v99);
							int64_t v103 = 0LL /* False */;
							x100 = v103;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x97 = x100;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x97;
		} break;
		case 12LL: { // DefField
			uint64_t v104 = mtp_mirth_def_Def_DefField(x2);
			VAL v105 = mtw_std_maybe_Maybe_1_Some(MKU64(v104));
			VAL v106 = mw_mirth_def_Def_fieldZAsk(x1);
			int64_t x107;
			switch (get_data_tag(v106)) {
				case 0LL: { // None
					int64_t v108 = mw_std_maybe_Maybe_1_noneZAsk(v105);
					x107 = v108;
				} break;
				case 1LL: { // Some
					VAL v109 = mtp_std_maybe_Maybe_1_Some(v106);
					int64_t x110;
					switch (get_data_tag(v105)) {
						case 1LL: { // Some
							VAL v111 = mtp_std_maybe_Maybe_1_Some(v105);
							int64_t v112 = mw_mirth_table_Field_ZEqualZEqual(VU64(v111), VU64(v109));
							x110 = v112;
						} break;
						case 0LL: { // None
							decref(v109);
							int64_t v113 = 0LL /* False */;
							x110 = v113;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x107 = x110;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x107;
		} break;
		case 6LL: { // DefTag
			uint64_t v114 = mtp_mirth_def_Def_DefTag(x2);
			VAL v115 = mtw_std_maybe_Maybe_1_Some(MKU64(v114));
			VAL v116 = mw_mirth_def_Def_tagZAsk(x1);
			int64_t x117;
			switch (get_data_tag(v116)) {
				case 0LL: { // None
					int64_t v118 = mw_std_maybe_Maybe_1_noneZAsk(v115);
					x117 = v118;
				} break;
				case 1LL: { // Some
					VAL v119 = mtp_std_maybe_Maybe_1_Some(v116);
					int64_t x120;
					switch (get_data_tag(v115)) {
						case 1LL: { // Some
							VAL v121 = mtp_std_maybe_Maybe_1_Some(v115);
							int64_t v122 = mw_mirth_data_Tag_ZEqualZEqual(VU64(v121), VU64(v119));
							x120 = v122;
						} break;
						case 0LL: { // None
							decref(v119);
							int64_t v123 = 0LL /* False */;
							x120 = v123;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x117 = x120;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x117;
		} break;
		case 10LL: { // DefVariable
			uint64_t v124 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v125 = mtw_std_maybe_Maybe_1_Some(MKU64(v124));
			VAL v126 = mw_mirth_def_Def_variableZAsk(x1);
			int64_t x127;
			switch (get_data_tag(v126)) {
				case 0LL: { // None
					int64_t v128 = mw_std_maybe_Maybe_1_noneZAsk(v125);
					x127 = v128;
				} break;
				case 1LL: { // Some
					VAL v129 = mtp_std_maybe_Maybe_1_Some(v126);
					int64_t x130;
					switch (get_data_tag(v125)) {
						case 1LL: { // Some
							VAL v131 = mtp_std_maybe_Maybe_1_Some(v125);
							int64_t v132 = mw_mirth_variable_Variable_ZEqualZEqual(VU64(v131), VU64(v129));
							x130 = v132;
						} break;
						case 0LL: { // None
							decref(v129);
							int64_t v133 = 0LL /* False */;
							x130 = v133;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x127 = x130;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x127;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_def_Def_typecheckZBang (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v4 = mtp_mirth_def_Def_DefAlias(x2);
			VAL v5;
			VAL v6;
			mw_mirth_alias_Alias_target(x1, v4, &v5, &v6);
			VAL v7 = (mw_mirth_def_Def_typecheckZBang(v5, v6));
			x3 = v7;
		} break;
		case 2LL: { // DefPackage
			uint64_t v8 = mtp_mirth_def_Def_DefPackage(x2);
			x3 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v9 = mtp_mirth_def_Def_DefModule(x2);
			x3 = x1;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v10 = mtp_mirth_def_Def_DefBuffer(x2);
			x3 = x1;
		} break;
		case 7LL: { // DefPrim
			int64_t v11 = mtp_mirth_def_Def_DefPrim(x2);
			x3 = x1;
		} break;
		case 3LL: { // DefData
			uint64_t v12 = mtp_mirth_def_Def_DefData(x2);
			x3 = x1;
		} break;
		case 4LL: { // DefTable
			uint64_t v13 = mtp_mirth_def_Def_DefTable(x2);
			x3 = x1;
		} break;
		case 5LL: { // DefType
			uint64_t v14 = mtp_mirth_def_Def_DefType(x2);
			VAL v15;
			VAL v16;
			mw_mirth_typedef_TypeDef_target(x1, v14, &v15, &v16);
			decref(v16);
			x3 = v15;
		} break;
		case 11LL: { // DefExternal
			uint64_t v17 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v18;
			VAL v19;
			mw_mirth_external_External_type(x1, v17, &v18, &v19);
			decref(v19);
			x3 = v18;
		} break;
		case 8LL: { // DefWord
			uint64_t v20 = mtp_mirth_def_Def_DefWord(x2);
			VAL v21;
			VAL v22;
			mw_mirth_word_Word_type(v20, x1, &v21, &v22);
			decref(v21);
			VAL v23;
			VAL v24;
			mw_mirth_word_Word_arrow(v20, v22, &v23, &v24);
			decref(v23);
			x3 = v24;
		} break;
		case 12LL: { // DefField
			uint64_t v25 = mtp_mirth_def_Def_DefField(x2);
			VAL v26;
			VAL v27;
			mw_mirth_table_Field_type(x1, v25, &v26, &v27);
			decref(v27);
			x3 = v26;
		} break;
		case 6LL: { // DefTag
			uint64_t v28 = mtp_mirth_def_Def_DefTag(x2);
			VAL v29;
			VAL v30;
			mw_mirth_data_Tag_type(x1, v28, &v29, &v30);
			decref(v30);
			x3 = v29;
		} break;
		case 10LL: { // DefVariable
			uint64_t v31 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v32;
			VAL v33;
			mw_mirth_variable_Variable_type(x1, v31, &v32, &v33);
			decref(v33);
			x3 = v32;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_def_Def_callableZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4) {
	VAL x5;
	int64_t x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v7 = mtp_mirth_def_Def_DefAlias(x2);
			void* v8 = mfld_mirth_alias_Alias_ZTildetarget(v7);
			VAL v9;
			VAL v10;
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(v8, x1, &v9, &v10);
			VAL x11;
			int64_t x12;
			switch (get_data_tag(v9)) {
				case 1LL: { // Some
					VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
					VAL v14;
					int64_t v15;
					mw_mirth_def_Def_callableZAsk(v10, v13, &v14, &v15);
					x12 = v15;
					x11 = v14;
				} break;
				case 0LL: { // None
					int64_t v16 = 0LL /* False */;
					x12 = v16;
					x11 = v10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x12;
			x5 = x11;
		} break;
		case 2LL: { // DefPackage
			uint64_t v17 = mtp_mirth_def_Def_DefPackage(x2);
			int64_t v18 = 0LL /* False */;
			x6 = v18;
			x5 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v19 = mtp_mirth_def_Def_DefModule(x2);
			int64_t v20 = 0LL /* False */;
			x6 = v20;
			x5 = x1;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v21 = mtp_mirth_def_Def_DefBuffer(x2);
			int64_t v22 = 1LL /* True */;
			x6 = v22;
			x5 = x1;
		} break;
		case 7LL: { // DefPrim
			int64_t v23 = mtp_mirth_def_Def_DefPrim(x2);
			int64_t v24 = 1LL /* True */;
			x6 = v24;
			x5 = x1;
		} break;
		case 3LL: { // DefData
			uint64_t v25 = mtp_mirth_def_Def_DefData(x2);
			int64_t v26 = 0LL /* False */;
			x6 = v26;
			x5 = x1;
		} break;
		case 4LL: { // DefTable
			uint64_t v27 = mtp_mirth_def_Def_DefTable(x2);
			int64_t v28 = 0LL /* False */;
			x6 = v28;
			x5 = x1;
		} break;
		case 5LL: { // DefType
			uint64_t v29 = mtp_mirth_def_Def_DefType(x2);
			int64_t v30 = 0LL /* False */;
			x6 = v30;
			x5 = x1;
		} break;
		case 11LL: { // DefExternal
			uint64_t v31 = mtp_mirth_def_Def_DefExternal(x2);
			int64_t v32 = 1LL /* True */;
			x6 = v32;
			x5 = x1;
		} break;
		case 8LL: { // DefWord
			uint64_t v33 = mtp_mirth_def_Def_DefWord(x2);
			int64_t v34 = 1LL /* True */;
			x6 = v34;
			x5 = x1;
		} break;
		case 12LL: { // DefField
			uint64_t v35 = mtp_mirth_def_Def_DefField(x2);
			int64_t v36 = 1LL /* True */;
			x6 = v36;
			x5 = x1;
		} break;
		case 6LL: { // DefTag
			uint64_t v37 = mtp_mirth_def_Def_DefTag(x2);
			int64_t v38 = 1LL /* True */;
			x6 = v38;
			x5 = x1;
		} break;
		case 10LL: { // DefVariable
			uint64_t v39 = mtp_mirth_def_Def_DefVariable(x2);
			int64_t v40 = 1LL /* True */;
			x6 = v40;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_def_Def_definesZ_aZ_typeZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4) {
	VAL x5;
	int64_t x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v7 = mtp_mirth_def_Def_DefAlias(x2);
			void* v8 = mfld_mirth_alias_Alias_ZTildetarget(v7);
			VAL v9;
			VAL v10;
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(v8, x1, &v9, &v10);
			VAL x11;
			int64_t x12;
			switch (get_data_tag(v9)) {
				case 1LL: { // Some
					VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
					VAL v14;
					int64_t v15;
					mw_mirth_def_Def_definesZ_aZ_typeZAsk(v10, v13, &v14, &v15);
					x12 = v15;
					x11 = v14;
				} break;
				case 0LL: { // None
					int64_t v16 = 0LL /* False */;
					x12 = v16;
					x11 = v10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x12;
			x5 = x11;
		} break;
		case 2LL: { // DefPackage
			uint64_t v17 = mtp_mirth_def_Def_DefPackage(x2);
			int64_t v18 = 0LL /* False */;
			x6 = v18;
			x5 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v19 = mtp_mirth_def_Def_DefModule(x2);
			int64_t v20 = 0LL /* False */;
			x6 = v20;
			x5 = x1;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v21 = mtp_mirth_def_Def_DefBuffer(x2);
			int64_t v22 = 0LL /* False */;
			x6 = v22;
			x5 = x1;
		} break;
		case 7LL: { // DefPrim
			int64_t v23 = mtp_mirth_def_Def_DefPrim(x2);
			int64_t v24 = 0LL /* False */;
			x6 = v24;
			x5 = x1;
		} break;
		case 3LL: { // DefData
			uint64_t v25 = mtp_mirth_def_Def_DefData(x2);
			int64_t v26 = 1LL /* True */;
			x6 = v26;
			x5 = x1;
		} break;
		case 4LL: { // DefTable
			uint64_t v27 = mtp_mirth_def_Def_DefTable(x2);
			int64_t v28 = 1LL /* True */;
			x6 = v28;
			x5 = x1;
		} break;
		case 5LL: { // DefType
			uint64_t v29 = mtp_mirth_def_Def_DefType(x2);
			int64_t v30 = 1LL /* True */;
			x6 = v30;
			x5 = x1;
		} break;
		case 11LL: { // DefExternal
			uint64_t v31 = mtp_mirth_def_Def_DefExternal(x2);
			int64_t v32 = 0LL /* False */;
			x6 = v32;
			x5 = x1;
		} break;
		case 8LL: { // DefWord
			uint64_t v33 = mtp_mirth_def_Def_DefWord(x2);
			int64_t v34 = 0LL /* False */;
			x6 = v34;
			x5 = x1;
		} break;
		case 12LL: { // DefField
			uint64_t v35 = mtp_mirth_def_Def_DefField(x2);
			int64_t v36 = 0LL /* False */;
			x6 = v36;
			x5 = x1;
		} break;
		case 6LL: { // DefTag
			uint64_t v37 = mtp_mirth_def_Def_DefTag(x2);
			int64_t v38 = 0LL /* False */;
			x6 = v38;
			x5 = x1;
		} break;
		case 10LL: { // DefVariable
			uint64_t v39 = mtp_mirth_def_Def_DefVariable(x2);
			int64_t v40 = 0LL /* False */;
			x6 = v40;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_def_Def_exposedZ_tyconZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v7 = mtp_mirth_def_Def_DefAlias(x2);
			void* v8 = mfld_mirth_alias_Alias_ZTildetarget(v7);
			VAL v9;
			VAL v10;
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(v8, x1, &v9, &v10);
			VAL x11;
			VAL x12;
			switch (get_data_tag(v9)) {
				case 1LL: { // Some
					VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
					VAL v14;
					VAL v15;
					mw_mirth_def_Def_exposedZ_tyconZAsk(v10, v13, &v14, &v15);
					x12 = v15;
					x11 = v14;
				} break;
				case 0LL: { // None
					VAL v16 = MKI64(0LL /* None */);
					x12 = v16;
					x11 = v10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x12;
			x5 = x11;
		} break;
		case 2LL: { // DefPackage
			uint64_t v17 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v18 = MKI64(0LL /* None */);
			x6 = v18;
			x5 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v19 = mtp_mirth_def_Def_DefModule(x2);
			VAL v20 = MKI64(0LL /* None */);
			x6 = v20;
			x5 = x1;
		} break;
		case 3LL: { // DefData
			uint64_t v21 = mtp_mirth_def_Def_DefData(x2);
			VAL v22 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v21);
			VAL v23 = mtw_std_maybe_Maybe_1_Some(v22);
			x6 = v23;
			x5 = x1;
		} break;
		case 4LL: { // DefTable
			uint64_t v24 = mtp_mirth_def_Def_DefTable(x2);
			VAL v25 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v24);
			VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
			x6 = v26;
			x5 = x1;
		} break;
		case 5LL: { // DefType
			uint64_t v27 = mtp_mirth_def_Def_DefType(x2);
			VAL v28;
			VAL v29;
			mw_mirth_typedef_TypeDef_target(x1, v27, &v28, &v29);
			VAL v30 = mw_mirth_type_Type_tyconZAsk(v29);
			x6 = v30;
			x5 = v28;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v31 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v32 = MKI64(0LL /* None */);
			x6 = v32;
			x5 = x1;
		} break;
		case 7LL: { // DefPrim
			int64_t v33 = mtp_mirth_def_Def_DefPrim(x2);
			VAL v34 = MKI64(0LL /* None */);
			x6 = v34;
			x5 = x1;
		} break;
		case 11LL: { // DefExternal
			uint64_t v35 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v36 = MKI64(0LL /* None */);
			x6 = v36;
			x5 = x1;
		} break;
		case 8LL: { // DefWord
			uint64_t v37 = mtp_mirth_def_Def_DefWord(x2);
			VAL v38 = MKI64(0LL /* None */);
			x6 = v38;
			x5 = x1;
		} break;
		case 12LL: { // DefField
			uint64_t v39 = mtp_mirth_def_Def_DefField(x2);
			VAL v40 = MKI64(0LL /* None */);
			x6 = v40;
			x5 = x1;
		} break;
		case 6LL: { // DefTag
			uint64_t v41 = mtp_mirth_def_Def_DefTag(x2);
			VAL v42 = MKI64(0LL /* None */);
			x6 = v42;
			x5 = x1;
		} break;
		case 10LL: { // DefVariable
			uint64_t v43 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v44 = MKI64(0LL /* None */);
			x6 = v44;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_def_Def_sameZ_resolvedZAsk (VAL x1, VAL x2, VAL x3, VAL *x4, int64_t *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_def_Def_resolve(x1, x2, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_def_Def_resolve(v6, x3, &v8, &v9);
	int64_t v10 = mw_mirth_def_Def_ZEqualZEqual(v7, v9);
	*x5 = v10;
	*x4 = v8;
}
static void mw_mirth_def_Def_resolve (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	VAL v5 = mw_mirth_def_Def_aliasZAsk(x2);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v5);
			decref(x2);
			VAL v10;
			VAL v11;
			mw_mirth_alias_Alias_target(x1, VU64(v9), &v10, &v11);
			int64_t v12 = 1LL /* True */;
			x8 = v12;
			x7 = v11;
			x6 = v10;
		} break;
		case 0LL: { // None
			int64_t v13 = 0LL /* False */;
			x8 = v13;
			x7 = x2;
			x6 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v14 = (x6);
	VAL v15 = x7;
	int64_t v16 = x8;
	while (((bool)v16)) {
		VAL v17 = (v14);
		VAL v18 = v15;
		incref(v18);
		VAL v19 = mw_mirth_def_Def_aliasZAsk(v18);
		VAL x20;
		VAL x21;
		int64_t x22;
		switch (get_data_tag(v19)) {
			case 1LL: { // Some
				VAL v23 = mtp_std_maybe_Maybe_1_Some(v19);
				decref(v18);
				VAL v24;
				VAL v25;
				mw_mirth_alias_Alias_target(v17, VU64(v23), &v24, &v25);
				int64_t v26 = 1LL /* True */;
				x22 = v26;
				x21 = v25;
				x20 = v24;
			} break;
			case 0LL: { // None
				int64_t v27 = 0LL /* False */;
				x22 = v27;
				x21 = v18;
				x20 = v17;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v16 = x22;
		v15 = x21;
		v14 = x20;
	}
	*x4 = v15;
	*x3 = v14;
}
static uint64_t mw_mirth_def_Def_name (VAL x1) {
	uint64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v3 = mtp_mirth_def_Def_DefAlias(x1);
			uint64_t v4 = mw_mirth_alias_Alias_name(v3);
			x2 = v4;
		} break;
		case 2LL: { // DefPackage
			uint64_t v5 = mtp_mirth_def_Def_DefPackage(x1);
			uint64_t v6 = mw_mirth_package_Package_name(v5);
			x2 = v6;
		} break;
		case 1LL: { // DefModule
			uint64_t v7 = mtp_mirth_def_Def_DefModule(x1);
			uint64_t v8 = mw_mirth_module_Module_name(v7);
			x2 = v8;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v9 = mtp_mirth_def_Def_DefBuffer(x1);
			uint64_t v10 = mw_mirth_buffer_Buffer_name(v9);
			x2 = v10;
		} break;
		case 7LL: { // DefPrim
			int64_t v11 = mtp_mirth_def_Def_DefPrim(x1);
			uint64_t v12 = mw_mirth_prim_Prim_name(v11);
			x2 = v12;
		} break;
		case 3LL: { // DefData
			uint64_t v13 = mtp_mirth_def_Def_DefData(x1);
			uint64_t v14 = mw_mirth_data_Data_name(v13);
			x2 = v14;
		} break;
		case 4LL: { // DefTable
			uint64_t v15 = mtp_mirth_def_Def_DefTable(x1);
			uint64_t v16 = mw_mirth_table_Table_name(v15);
			x2 = v16;
		} break;
		case 5LL: { // DefType
			uint64_t v17 = mtp_mirth_def_Def_DefType(x1);
			uint64_t v18 = mw_mirth_typedef_TypeDef_name(v17);
			x2 = v18;
		} break;
		case 11LL: { // DefExternal
			uint64_t v19 = mtp_mirth_def_Def_DefExternal(x1);
			uint64_t v20 = mw_mirth_external_External_name(v19);
			x2 = v20;
		} break;
		case 8LL: { // DefWord
			uint64_t v21 = mtp_mirth_def_Def_DefWord(x1);
			uint64_t v22 = mw_mirth_word_Word_name(v21);
			x2 = v22;
		} break;
		case 12LL: { // DefField
			uint64_t v23 = mtp_mirth_def_Def_DefField(x1);
			uint64_t v24 = mw_mirth_table_Field_name(v23);
			x2 = v24;
		} break;
		case 6LL: { // DefTag
			uint64_t v25 = mtp_mirth_def_Def_DefTag(x1);
			uint64_t v26 = mw_mirth_data_Tag_name(v25);
			x2 = v26;
		} break;
		case 10LL: { // DefVariable
			uint64_t v27 = mtp_mirth_def_Def_DefVariable(x1);
			uint64_t v28 = mw_mirth_variable_Variable_name(v27);
			x2 = v28;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static int64_t mw_mirth_def_Def_arity (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v3 = mtp_mirth_def_Def_DefAlias(x1);
			int64_t v4 = mw_mirth_alias_Alias_arity(v3);
			x2 = v4;
		} break;
		case 2LL: { // DefPackage
			uint64_t v5 = mtp_mirth_def_Def_DefPackage(x1);
			int64_t v6 = 0LL;
			x2 = v6;
		} break;
		case 1LL: { // DefModule
			uint64_t v7 = mtp_mirth_def_Def_DefModule(x1);
			int64_t v8 = 0LL;
			x2 = v8;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v9 = mtp_mirth_def_Def_DefBuffer(x1);
			int64_t v10 = 0LL;
			x2 = v10;
		} break;
		case 7LL: { // DefPrim
			int64_t v11 = mtp_mirth_def_Def_DefPrim(x1);
			int64_t v12 = mw_mirth_prim_Prim_arity(v11);
			x2 = v12;
		} break;
		case 3LL: { // DefData
			uint64_t v13 = mtp_mirth_def_Def_DefData(x1);
			int64_t v14 = mw_mirth_data_Data_arity(v13);
			x2 = v14;
		} break;
		case 4LL: { // DefTable
			uint64_t v15 = mtp_mirth_def_Def_DefTable(x1);
			int64_t v16 = 0LL;
			x2 = v16;
		} break;
		case 5LL: { // DefType
			uint64_t v17 = mtp_mirth_def_Def_DefType(x1);
			int64_t v18 = 0LL;
			x2 = v18;
		} break;
		case 11LL: { // DefExternal
			uint64_t v19 = mtp_mirth_def_Def_DefExternal(x1);
			int64_t v20 = mw_mirth_external_External_arity(v19);
			x2 = v20;
		} break;
		case 8LL: { // DefWord
			uint64_t v21 = mtp_mirth_def_Def_DefWord(x1);
			int64_t v22 = mw_mirth_word_Word_arity(v21);
			x2 = v22;
		} break;
		case 12LL: { // DefField
			uint64_t v23 = mtp_mirth_def_Def_DefField(x1);
			int64_t v24 = 0LL;
			x2 = v24;
		} break;
		case 6LL: { // DefTag
			uint64_t v25 = mtp_mirth_def_Def_DefTag(x1);
			int64_t v26 = 0LL;
			x2 = v26;
		} break;
		case 10LL: { // DefVariable
			uint64_t v27 = mtp_mirth_def_Def_DefVariable(x1);
			int64_t v28 = 0LL;
			x2 = v28;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_def_Def_qnameZ_soft (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v7 = mtp_mirth_def_Def_DefAlias(x2);
			VAL v8 = mw_mirth_alias_Alias_qnameZ_soft(v7);
			x6 = v8;
			x5 = x1;
		} break;
		case 2LL: { // DefPackage
			uint64_t v9 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v10 = mw_mirth_package_Package_qname(v9);
			VAL v11 = mtw_std_maybe_Maybe_1_Some(v10);
			x6 = v11;
			x5 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v12 = mtp_mirth_def_Def_DefModule(x2);
			VAL v13 = mw_mirth_module_Module_qname(v12);
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			x6 = v14;
			x5 = x1;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v15 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v16 = mw_mirth_buffer_Buffer_qname(v15);
			VAL v17 = mtw_std_maybe_Maybe_1_Some(v16);
			x6 = v17;
			x5 = x1;
		} break;
		case 7LL: { // DefPrim
			int64_t v18 = mtp_mirth_def_Def_DefPrim(x2);
			VAL v19;
			VAL v20;
			mw_mirth_prim_Prim_qname(x1, v18, &v19, &v20);
			VAL v21 = mtw_std_maybe_Maybe_1_Some(v20);
			x6 = v21;
			x5 = v19;
		} break;
		case 3LL: { // DefData
			uint64_t v22 = mtp_mirth_def_Def_DefData(x2);
			VAL v23 = mw_mirth_data_Data_qnameZ_soft(v22);
			x6 = v23;
			x5 = x1;
		} break;
		case 4LL: { // DefTable
			uint64_t v24 = mtp_mirth_def_Def_DefTable(x2);
			VAL v25 = mw_mirth_table_Table_qnameZ_soft(v24);
			x6 = v25;
			x5 = x1;
		} break;
		case 5LL: { // DefType
			uint64_t v26 = mtp_mirth_def_Def_DefType(x2);
			VAL v27 = mw_mirth_typedef_TypeDef_qnameZ_soft(v26);
			x6 = v27;
			x5 = x1;
		} break;
		case 11LL: { // DefExternal
			uint64_t v28 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v29 = mw_mirth_external_External_qnameZ_soft(v28);
			x6 = v29;
			x5 = x1;
		} break;
		case 8LL: { // DefWord
			uint64_t v30 = mtp_mirth_def_Def_DefWord(x2);
			VAL v31 = mw_mirth_word_Word_qnameZ_soft(v30);
			x6 = v31;
			x5 = x1;
		} break;
		case 12LL: { // DefField
			uint64_t v32 = mtp_mirth_def_Def_DefField(x2);
			VAL v33 = mw_mirth_table_Field_qnameZ_soft(v32);
			x6 = v33;
			x5 = x1;
		} break;
		case 6LL: { // DefTag
			uint64_t v34 = mtp_mirth_def_Def_DefTag(x2);
			VAL v35 = mw_mirth_data_Tag_qname(v34);
			VAL v36 = mtw_std_maybe_Maybe_1_Some(v35);
			x6 = v36;
			x5 = x1;
		} break;
		case 10LL: { // DefVariable
			uint64_t v37 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v38 = mw_mirth_variable_Variable_qname(v37);
			VAL v39 = mtw_std_maybe_Maybe_1_Some(v38);
			x6 = v39;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_def_Def_qnameZ_hard (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v7 = mtp_mirth_def_Def_DefAlias(x2);
			VAL v8;
			VAL v9;
			mw_mirth_alias_Alias_qnameZ_hard(x1, v7, &v8, &v9);
			x6 = v9;
			x5 = v8;
		} break;
		case 2LL: { // DefPackage
			uint64_t v10 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v11 = mw_mirth_package_Package_qname(v10);
			x6 = v11;
			x5 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v12 = mtp_mirth_def_Def_DefModule(x2);
			VAL v13 = mw_mirth_module_Module_qname(v12);
			x6 = v13;
			x5 = x1;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v14 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v15 = mw_mirth_buffer_Buffer_qname(v14);
			x6 = v15;
			x5 = x1;
		} break;
		case 7LL: { // DefPrim
			int64_t v16 = mtp_mirth_def_Def_DefPrim(x2);
			VAL v17;
			VAL v18;
			mw_mirth_prim_Prim_qname(x1, v16, &v17, &v18);
			x6 = v18;
			x5 = v17;
		} break;
		case 3LL: { // DefData
			uint64_t v19 = mtp_mirth_def_Def_DefData(x2);
			VAL v20;
			VAL v21;
			mw_mirth_data_Data_qnameZ_hard(x1, v19, &v20, &v21);
			x6 = v21;
			x5 = v20;
		} break;
		case 4LL: { // DefTable
			uint64_t v22 = mtp_mirth_def_Def_DefTable(x2);
			VAL v23;
			VAL v24;
			mw_mirth_table_Table_qnameZ_hard(x1, v22, &v23, &v24);
			x6 = v24;
			x5 = v23;
		} break;
		case 5LL: { // DefType
			uint64_t v25 = mtp_mirth_def_Def_DefType(x2);
			VAL v26;
			VAL v27;
			mw_mirth_typedef_TypeDef_qnameZ_hard(x1, v25, &v26, &v27);
			x6 = v27;
			x5 = v26;
		} break;
		case 11LL: { // DefExternal
			uint64_t v28 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v29;
			VAL v30;
			mw_mirth_external_External_qnameZ_hard(x1, v28, &v29, &v30);
			x6 = v30;
			x5 = v29;
		} break;
		case 8LL: { // DefWord
			uint64_t v31 = mtp_mirth_def_Def_DefWord(x2);
			VAL v32;
			VAL v33;
			mw_mirth_word_Word_qnameZ_hard(v31, x1, &v32, &v33);
			x6 = v32;
			x5 = v33;
		} break;
		case 12LL: { // DefField
			uint64_t v34 = mtp_mirth_def_Def_DefField(x2);
			VAL v35;
			VAL v36;
			mw_mirth_table_Field_qnameZ_hard(x1, v34, &v35, &v36);
			x6 = v36;
			x5 = v35;
		} break;
		case 6LL: { // DefTag
			uint64_t v37 = mtp_mirth_def_Def_DefTag(x2);
			VAL v38 = mw_mirth_data_Tag_qname(v37);
			x6 = v38;
			x5 = x1;
		} break;
		case 10LL: { // DefVariable
			uint64_t v39 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v40 = mw_mirth_variable_Variable_qname(v39);
			x6 = v40;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_def_Def_asZ_namespaceZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			uint64_t v7 = mtp_mirth_def_Def_DefAlias(x2);
			void* v8 = mfld_mirth_alias_Alias_ZTildetarget(v7);
			VAL v9;
			VAL v10;
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(v8, x1, &v9, &v10);
			VAL x11;
			VAL x12;
			switch (get_data_tag(v9)) {
				case 1LL: { // Some
					VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
					VAL v14;
					VAL v15;
					mw_mirth_def_Def_asZ_namespaceZAsk(v10, v13, &v14, &v15);
					x12 = v15;
					x11 = v14;
				} break;
				case 0LL: { // None
					VAL v16 = MKI64(0LL /* None */);
					x12 = v16;
					x11 = v10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x12;
			x5 = x11;
		} break;
		case 2LL: { // DefPackage
			uint64_t v17 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v18 = mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE(v17);
			VAL v19 = mtw_std_maybe_Maybe_1_Some(v18);
			x6 = v19;
			x5 = x1;
		} break;
		case 1LL: { // DefModule
			uint64_t v20 = mtp_mirth_def_Def_DefModule(x2);
			VAL v21 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v20);
			VAL v22 = mtw_std_maybe_Maybe_1_Some(v21);
			x6 = v22;
			x5 = x1;
		} break;
		case 3LL: { // DefData
			uint64_t v23 = mtp_mirth_def_Def_DefData(x2);
			VAL v24 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v23);
			VAL v25 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v24);
			VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
			x6 = v26;
			x5 = x1;
		} break;
		case 4LL: { // DefTable
			uint64_t v27 = mtp_mirth_def_Def_DefTable(x2);
			VAL v28 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v27);
			VAL v29 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v28);
			VAL v30 = mtw_std_maybe_Maybe_1_Some(v29);
			x6 = v30;
			x5 = x1;
		} break;
		case 5LL: { // DefType
			uint64_t v31 = mtp_mirth_def_Def_DefType(x2);
			VAL v32;
			VAL v33;
			mw_mirth_typedef_TypeDef_target(x1, v31, &v32, &v33);
			VAL v34 = mw_mirth_type_Type_tyconZAsk(v33);
			VAL x35;
			VAL x36;
			switch (get_data_tag(v34)) {
				case 1LL: { // Some
					VAL v37 = mtp_std_maybe_Maybe_1_Some(v34);
					VAL v38 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v37);
					VAL v39 = mtw_std_maybe_Maybe_1_Some(v38);
					x36 = v39;
					x35 = v32;
				} break;
				case 0LL: { // None
					VAL v40 = MKI64(0LL /* None */);
					x36 = v40;
					x35 = v32;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x36;
			x5 = x35;
		} break;
		case 8LL: { // DefWord
			uint64_t v41 = mtp_mirth_def_Def_DefWord(x2);
			VAL v42 = mtw_mirth_name_Namespace_NAMESPACEz_WORD(v41);
			VAL v43 = mtw_std_maybe_Maybe_1_Some(v42);
			x6 = v43;
			x5 = x1;
		} break;
		default: {
			decref(x2);
			VAL v44 = MKI64(0LL /* None */);
			x6 = v44;
			x5 = x1;
		} break;
	}
	*x4 = x6;
	*x3 = x5;
}
static VAL mw_mirth_def_Def_register (VAL x1, VAL x2) {
	incref(x2);
	VAL v3;
	VAL v4;
	mw_mirth_def_Def_qnameZ_soft(x1, x2, &v3, &v4);
	VAL x5;
	VAL x6;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v4);
			incref(v7);
			VAL v8;
			int64_t v9;
			mw_mirth_name_QName_undefinedZ_softZAsk(v3, v7, &v8, &v9);
			VAL x10;
			VAL x11;
			VAL x12;
			if (((bool)v9)) {
				x12 = v8;
				x11 = v7;
				x10 = x2;
			} else {
				VAL v13;
				VAL v14;
				mw_mirth_name_QName_ZToStr(v8, v7, &v13, &v14);
				STR* v15;
				STRLIT(v15, "qualified name already has definition: ", 39);
				STR* v16 = str_cat(v15, VSTR(v14));
				push_value(x2);
				mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v16), v13);
				VAL r17 = pop_resource();
				x12 = r17;
				VAL v18 = pop_value();
				x11 = v18;
				VAL v19 = pop_value();
				x10 = v19;
			}
			decref(x11);
			x6 = x12;
			x5 = x10;
		} break;
		case 0LL: { // None
			x6 = v3;
			x5 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	incref(x5);
	uint64_t v20 = mw_mirth_def_Def_name(x5);
	void* v21 = mfld_mirth_name_Name_ZTildedefs(v20);
	VAL v22 = mut_get(v21);
	VAL v23 = mtw_std_list_List_1_Cons(x5, v22);
	mut_set(v23, v21);
	return x6;
}
static int64_t mw_mirth_name_Name_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_name_Name_fromZ_index (int64_t x1) {
	return ((uint64_t)x1);
}
static uint64_t mw_mirth_name_Name_allocZBang (void) {
	void* v1 = mbuf_mirth_name_Name_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_name_Name_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static VAL mw_mirth_name_Name_ZToStr (uint64_t x1) {
	void* v2 = mfld_mirth_name_Name_ZTildeStr(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static VAL mw_mirth_name_Name_defs (uint64_t x1) {
	void* v2 = mfld_mirth_name_Name_ZTildedefs(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static VAL mw_mirth_name_Name_mangled (uint64_t x1) {
	void* v2 = mfld_mirth_name_Name_ZTildemangled(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	VAL x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = v6;
		x4 = x1;
	} else {
		VAL v7 = mw_mirth_name_Name_mangleZ_computeZBang(x1);
		incref(v7);
		mut_set(v7, v2);
		x5 = v7;
		x4 = x1;
	}
	return x5;
}
static int64_t mw_mirth_name_Name_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_name_Name_index(x1);
	int64_t v4 = mw_mirth_name_Name_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static int64_t mw_mirth_name_Hash_ZToInt (int64_t x1) {
	return x1;
}
static int64_t mw_std_prim_Int_ZToHash (int64_t x1) {
	int64_t v2 = mw_mirth_name_HASHz_MAX();
	uint64_t v3 = (((uint64_t)x1) & ((uint64_t)v2));
	int64_t v4 = 0LL;
	bool v5 = (((int64_t)v3) < v4);
	int64_t x6;
	if (v5) {
		x6 = v4;
	} else {
		x6 = ((int64_t)v3);
	}
	return x6;
}
static int64_t mw_mirth_name_Hash_offset (int64_t x1) {
	int64_t v2 = 8LL;
	int64_t v3 = i64_mul(x1, v2);
	return v3;
}
static int64_t mw_mirth_name_HASHz_MAX (void) {
	int64_t v1 = 65535LL;
	return v1;
}
static VAL mw_mirth_name_hashZ_nameZAt (int64_t x1) {
	int64_t v2 = mw_mirth_name_Hash_offset(x1);
	void* v3 = mbuf_mirth_name_HASHz_BUF;
	int64_t v4 = (0LL /* +Unsafe */);
	void* v5 = (void*)(v2 + (char*)v3);
	int64_t v6 = *(int64_t*)v5;
	int64_t v7 = 0LL;
	bool v8 = (v6 == v7);
	VAL x9;
	if (v8) {
		VAL v10 = MKI64(0LL /* None */);
		x9 = v10;
	} else {
		uint64_t v11 = mw_mirth_name_Name_fromZ_index(v6);
		VAL v12 = mtw_std_maybe_Maybe_1_Some(MKU64(v11));
		x9 = v12;
	}
	return x9;
}
static void mw_mirth_name_hashZ_nameZBang (uint64_t x1, int64_t x2) {
	int64_t v3 = mw_mirth_name_Name_index(x1);
	int64_t v4 = mw_std_prim_Int_ZToI64(v3);
	int64_t v5 = mw_mirth_name_Hash_offset(x2);
	void* v6 = mbuf_mirth_name_HASHz_BUF;
	int64_t v7 = (0LL /* +Unsafe */);
	void* v8 = (void*)(v5 + (char*)v6);
	*(int64_t*)v8 = v4;
}
static int64_t mw_std_prim_Str_hash (VAL x1) {
	int64_t v2 = 0LL;
	incref(x1);
	incref(x1);
	void* v3 = str_base(VSTR(x1));
	uint64_t v4 = str_size(VSTR(x1));
	int64_t v5 = 0LL;
	bool v6 = (((int64_t)v4) < v5);
	int64_t x7;
	if (v6) {
		x7 = v5;
		push_i64(v2);
		push_ptr(v3);
	} else {
		x7 = ((int64_t)v4);
		push_i64(v2);
		push_ptr(v3);
	}
	int64_t v8 = 0LL;
	bool v9 = (x7 > v8);
	int64_t v10 = x7;
	bool v11 = v9;
	while (v11) {
		int64_t v12 = v10;
		void* v13 = pop_ptr();
		int64_t v14 = (0LL /* +Unsafe */);
		int64_t v15;
		int64_t v16;
		mw_std_prim_Ptr_ZAtByte(v13, v14, &v15, &v16);
		int64_t v17 = 17LL;
		int64_t v18 = i64_mul(v15, v17);
		VAL v19 = pop_value();
		incref(v19);
		int64_t v20 = 7LL;
		uint64_t v21 = u64_shl(VU64(v19), ((uint64_t)v20));
		uint64_t v22 = (((uint64_t)v18) ^ v21);
		int64_t v23 = 27LL;
		uint64_t v24 = u64_shr(VU64(v19), ((uint64_t)v23));
		uint64_t v25 = (v22 ^ v24);
		int64_t v26 = 1LL;
		int64_t v27 = (0LL /* +Unsafe */);
		void* v28 = (void*)(v26 + (char*)v13);
		int64_t v29 = 1LL;
		int64_t v30 = i64_sub(v12, v29);
		int64_t v31 = 0LL;
		bool v32 = (v30 < v31);
		int64_t x33;
		if (v32) {
			int64_t v34 = 0LL;
			x33 = v34;
			push_u64(v25);
			push_ptr(v28);
		} else {
			x33 = v30;
			push_u64(v25);
			push_ptr(v28);
		}
		int64_t v35 = 0LL;
		bool v36 = (x33 > v35);
		v11 = v36;
		v10 = x33;
	}
	void* v37 = pop_ptr();
	decref(x1);
	int64_t v38 = pop_i64();
	int64_t v39 = mw_std_prim_Int_ZToHash(v38);
	return v39;
}
static int64_t mw_mirth_name_Hash_next (int64_t x1) {
	int64_t v2 = mw_mirth_name_Hash_ZToInt(x1);
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(v2, v3);
	int64_t v5 = mw_std_prim_Int_ZToHash(v4);
	return v5;
}
static void mw_mirth_name_Hash_keepZ_goingZAsk (VAL x1, int64_t x2, VAL *x3, int64_t *x4, int64_t *x5) {
	VAL v6 = mw_mirth_name_hashZ_nameZAt(x2);
	VAL x7;
	int64_t x8;
	int64_t x9;
	switch (get_data_tag(v6)) {
		case 0LL: { // None
			int64_t v10 = 0LL /* False */;
			x9 = v10;
			x8 = x2;
			x7 = x1;
		} break;
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v12 = mw_mirth_name_Name_ZToStr(VU64(v11));
			incref(x1);
			bool v13 = (str_cmp(VSTR(v12), VSTR(x1)) != 0);
			x9 = ((int64_t)v13);
			x8 = x2;
			x7 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x9;
	*x4 = x8;
	*x3 = x7;
}
static uint64_t mw_std_prim_Str_ZToName (VAL x1) {
	incref(x1);
	int64_t v2 = mw_std_prim_Str_hash(x1);
	VAL v3;
	int64_t v4;
	int64_t v5;
	mw_mirth_name_Hash_keepZ_goingZAsk(x1, v2, &v3, &v4, &v5);
	VAL v6 = v3;
	int64_t v7 = v4;
	int64_t v8 = v5;
	while (((bool)v8)) {
		VAL v9 = v6;
		int64_t v10 = v7;
		int64_t v11 = mw_mirth_name_Hash_next(v10);
		VAL v12;
		int64_t v13;
		int64_t v14;
		mw_mirth_name_Hash_keepZ_goingZAsk(v9, v11, &v12, &v13, &v14);
		v8 = v14;
		v7 = v13;
		v6 = v12;
	}
	VAL v15 = mw_mirth_name_hashZ_nameZAt(v7);
	uint64_t x16;
	switch (get_data_tag(v15)) {
		case 0LL: { // None
			uint64_t v17 = mw_mirth_name_Name_allocZBang();
			mw_mirth_name_hashZ_nameZBang(v17, v7);
			void* v18 = mfld_mirth_name_Name_ZTildeStr(v17);
			mut_set(v6, v18);
			VAL v19 = MKI64(0LL /* Nil */);
			void* v20 = mfld_mirth_name_Name_ZTildedefs(v17);
			mut_set(v19, v20);
			x16 = v17;
		} break;
		case 1LL: { // Some
			VAL v21 = mtp_std_maybe_Maybe_1_Some(v15);
			decref(v6);
			x16 = VU64(v21);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x16;
}
static int64_t mw_mirth_name_Name_head (uint64_t x1) {
	VAL v2 = mw_mirth_name_Name_ZToStr(x1);
	int64_t v3 = 0LL;
	int64_t v4 = mw_std_prim_Str_byteZAt(v3, v2);
	return v4;
}
static int64_t mw_mirth_name_Name_tailZ_head (uint64_t x1) {
	VAL v2 = mw_mirth_name_Name_ZToStr(x1);
	int64_t v3 = 1LL;
	int64_t v4 = mw_std_prim_Str_byteZAt(v3, v2);
	return v4;
}
static int64_t mw_mirth_name_Name_canZ_beZ_relativeZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = mw_std_byte_Byte_isZ_upper(v2);
	bool v4 = !((bool)v3);
	return ((int64_t)v4);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = mw_std_byte_Byte_isZ_lower(v2);
	uint64_t x4;
	int64_t x5;
	if (((bool)v3)) {
		int64_t v6 = 1LL /* True */;
		x5 = v6;
		x4 = x1;
	} else {
		int64_t v7 = mw_mirth_name_Name_head(x1);
		int64_t v8 = 43LL /* B'+' */;
		bool v9 = (v7 == v8);
		uint64_t x10;
		int64_t x11;
		if (v9) {
			int64_t v12 = mw_mirth_name_Name_tailZ_head(x1);
			int64_t v13 = mw_std_byte_Byte_isZ_lower(v12);
			x11 = v13;
			x10 = x1;
		} else {
			int64_t v14 = 0LL /* False */;
			x11 = v14;
			x10 = x1;
		}
		x5 = x11;
		x4 = x10;
	}
	return x5;
}
static int64_t mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = mw_std_byte_Byte_isZ_lower(v2);
	return v3;
}
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_var (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = mw_std_byte_Byte_isZ_lower(v2);
	return v3;
}
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_con (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = mw_std_byte_Byte_isZ_upper(v2);
	return v3;
}
static int64_t mw_mirth_name_Name_isZ_typeZ_hole (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = 63LL /* B'?' */;
	bool v4 = (v2 == v3);
	int64_t v5 = mw_mirth_name_Name_tailZ_head(x1);
	int64_t v6 = 0LL /* BNUL */;
	bool v7 = (v5 == v6);
	int64_t v8 = mw_std_byte_Byte_isZ_lower(v5);
	bool v9 = (v7 || ((bool)v8));
	bool v10 = (v4 && v9);
	return ((int64_t)v10);
}
static int64_t mw_mirth_name_Name_isZ_underscore (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = 95LL /* B'_' */;
	bool v4 = (v2 == v3);
	int64_t v5 = mw_mirth_name_Name_tailZ_head(x1);
	int64_t v6 = 0LL /* BNUL */;
	bool v7 = (v5 == v6);
	bool v8 = (v4 && v7);
	return ((int64_t)v8);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_stackZ_var (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = 42LL /* B'*' */;
	bool v4 = (v2 == v3);
	int64_t v5 = mw_mirth_name_Name_tailZ_head(x1);
	int64_t v6 = mw_std_byte_Byte_isZ_lower(v5);
	bool v7 = (v4 && ((bool)v6));
	return ((int64_t)v7);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_var (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = 43LL /* B'+' */;
	bool v4 = (v2 == v3);
	int64_t v5 = mw_mirth_name_Name_tailZ_head(x1);
	int64_t v6 = mw_std_byte_Byte_isZ_lower(v5);
	bool v7 = (v4 && ((bool)v6));
	return ((int64_t)v7);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_con (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t v3 = 43LL /* B'+' */;
	bool v4 = (v2 == v3);
	int64_t v5 = mw_mirth_name_Name_tailZ_head(x1);
	int64_t v6 = mw_std_byte_Byte_isZ_upper(v5);
	bool v7 = (v4 && ((bool)v6));
	return ((int64_t)v7);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_constructor (uint64_t x1) {
	int64_t v2 = mw_mirth_name_Name_head(x1);
	int64_t x3;
	switch (v2) {
		case 43LL: { // B'+'
			int64_t v4 = mw_mirth_name_Name_tailZ_head(x1);
			int64_t v5 = mw_std_byte_Byte_isZ_upper(v4);
			x3 = v5;
		} break;
		default: {
			int64_t v6 = mw_std_byte_Byte_isZ_upper(v2);
			x3 = v6;
		} break;
	}
	return x3;
}
static VAL mw_mirth_name_Name_mangleZ_computeZBang (uint64_t x1) {
	STR* v2;
	STRLIT(v2, "", 0);
	VAL v3 = mw_mirth_name_Name_ZToStr(x1);
	incref(v3);
	incref(v3);
	void* v4 = str_base(VSTR(v3));
	uint64_t v5 = str_size(VSTR(v3));
	int64_t v6 = 0LL;
	bool v7 = (((int64_t)v5) < v6);
	int64_t x8;
	if (v7) {
		x8 = v6;
		push_resource(MKSTR(v2));
		push_ptr(v4);
	} else {
		x8 = ((int64_t)v5);
		push_resource(MKSTR(v2));
		push_ptr(v4);
	}
	int64_t v9 = 0LL;
	bool v10 = (x8 > v9);
	int64_t v11 = x8;
	bool v12 = v10;
	while (v12) {
		int64_t v13 = v11;
		void* v14 = pop_ptr();
		int64_t v15 = (0LL /* +Unsafe */);
		int64_t v16;
		int64_t v17;
		mw_std_prim_Ptr_ZAtByte(v14, v15, &v16, &v17);
		VAL v18 = mw_std_byte_Byte_zzencode(v16);
		VAL r19 = pop_resource();
		VAL v20 = (mw_std_str_ZPlusStr_pushZ_strZBang(v18, r19));
		int64_t v21 = 1LL;
		int64_t v22 = (0LL /* +Unsafe */);
		void* v23 = (void*)(v21 + (char*)v14);
		int64_t v24 = 1LL;
		int64_t v25 = i64_sub(v13, v24);
		int64_t v26 = 0LL;
		bool v27 = (v25 < v26);
		int64_t x28;
		if (v27) {
			int64_t v29 = 0LL;
			x28 = v29;
			push_resource(v20);
			push_ptr(v23);
		} else {
			x28 = v25;
			push_resource(v20);
			push_ptr(v23);
		}
		int64_t v30 = 0LL;
		bool v31 = (x28 > v30);
		v12 = v31;
		v11 = x28;
	}
	void* v32 = pop_ptr();
	decref(v3);
	VAL r33 = pop_resource();
	return r33;
}
static int64_t mw_mirth_name_Namespace_ZEqualZEqual (VAL x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			int64_t x4;
			switch (get_data_tag(x1)) {
				case 0LL: { // NAMESPACE_ROOT
					int64_t v5 = 1LL /* True */;
					x4 = v5;
				} break;
				default: {
					decref(x1);
					int64_t v6 = 0LL /* False */;
					x4 = v6;
				} break;
			}
			x3 = x4;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v7 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			int64_t x8;
			switch (get_data_tag(x1)) {
				case 1LL: { // NAMESPACE_PACKAGE
					uint64_t v9 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x1);
					int64_t v10 = mw_mirth_package_Package_ZEqualZEqual(v9, v7);
					x8 = v10;
				} break;
				default: {
					decref(x1);
					int64_t v11 = 0LL /* False */;
					x8 = v11;
				} break;
			}
			x3 = x8;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v12 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			int64_t x13;
			switch (get_data_tag(x1)) {
				case 2LL: { // NAMESPACE_MODULE
					uint64_t v14 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x1);
					int64_t v15 = mw_mirth_module_Module_ZEqualZEqual(v14, v12);
					x13 = v15;
				} break;
				default: {
					decref(x1);
					int64_t v16 = 0LL /* False */;
					x13 = v16;
				} break;
			}
			x3 = x13;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v17 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			int64_t x18;
			switch (get_data_tag(x1)) {
				case 3LL: { // NAMESPACE_TYCON
					VAL v19 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x1);
					int64_t v20 = mw_mirth_tycon_Tycon_ZEqualZEqual(v19, v17);
					x18 = v20;
				} break;
				default: {
					decref(x1);
					decref(v17);
					int64_t v21 = 0LL /* False */;
					x18 = v21;
				} break;
			}
			x3 = x18;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v22 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			int64_t x23;
			switch (get_data_tag(x1)) {
				case 4LL: { // NAMESPACE_WORD
					uint64_t v24 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x1);
					int64_t v25 = mw_mirth_word_Word_ZEqualZEqual(v24, v22);
					x23 = v25;
				} break;
				default: {
					decref(x1);
					int64_t v26 = 0LL /* False */;
					x23 = v26;
				} break;
			}
			x3 = x23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_name_Namespace_qname (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			VAL v7 = MKI64(0LL /* None */);
			x6 = v7;
			x5 = x1;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v8 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			VAL v9 = mw_mirth_package_Package_qname(v8);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			x6 = v10;
			x5 = x1;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v12 = mw_mirth_module_Module_qname(v11);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(v12);
			x6 = v13;
			x5 = x1;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v14 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL v15;
			VAL v16;
			mw_mirth_tycon_Tycon_qnameZ_hard(x1, v14, &v15, &v16);
			VAL v17 = mtw_std_maybe_Maybe_1_Some(v16);
			x6 = v17;
			x5 = v15;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v18 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL v19;
			VAL v20;
			mw_mirth_word_Word_qnameZ_hard(v18, x1, &v19, &v20);
			VAL v21 = mtw_std_maybe_Maybe_1_Some(v19);
			x6 = v21;
			x5 = v20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_name_Namespace_moduleZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			VAL v7 = MKI64(0LL /* None */);
			x6 = v7;
			x5 = x1;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v8 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			VAL v9 = MKI64(0LL /* None */);
			x6 = v9;
			x5 = x1;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v10 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v11 = mtw_std_maybe_Maybe_1_Some(MKU64(v10));
			x6 = v11;
			x5 = x1;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v12 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL v13;
			VAL v14;
			mw_mirth_tycon_Tycon_qnameZ_hard(x1, v12, &v13, &v14);
			VAL v15 = VVAL(VTUP(v14)->cells[1]);
			incref(v15);
			decref(v14);
			VAL v16;
			VAL v17;
			mw_mirth_name_Namespace_moduleZAsk(v13, v15, &v16, &v17);
			x6 = v17;
			x5 = v16;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v18 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL v19 = MKI64(0LL /* None */);
			x6 = v19;
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_name_Namespace_prim (VAL x1, VAL *x2, VAL *x3) {
	VAL v4;
	uint64_t v5;
	mw_mirth_module_Module_prim(x1, &v4, &v5);
	VAL v6 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v5);
	*x3 = v6;
	*x2 = v4;
}
static void mw_mirth_name_Namespace_ZToStr (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			STR* v7;
			STRLIT(v7, "<root>", 6);
			x6 = MKSTR(v7);
			x5 = x1;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v8 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			uint64_t v9 = mw_mirth_package_Package_name(v8);
			VAL v10 = mw_mirth_name_Name_ZToStr(v9);
			x6 = v10;
			x5 = x1;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v12 = mw_mirth_module_Module_qname(v11);
			VAL v13;
			VAL v14;
			mw_mirth_name_QName_ZToStr(x1, v12, &v13, &v14);
			x6 = v14;
			x5 = v13;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v15 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL v16;
			VAL v17;
			mw_mirth_tycon_Tycon_qnameZ_hard(x1, v15, &v16, &v17);
			VAL v18;
			VAL v19;
			mw_mirth_name_QName_ZToStr(v16, v17, &v18, &v19);
			x6 = v19;
			x5 = v18;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v20 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL v21;
			VAL v22;
			mw_mirth_word_Word_qnameZ_hard(v20, x1, &v21, &v22);
			VAL v23;
			VAL v24;
			mw_mirth_name_QName_ZToStr(v22, v21, &v23, &v24);
			x6 = v24;
			x5 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_name_Namespace_mangled (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			STR* v7;
			STRLIT(v7, "__root__", 8);
			x6 = MKSTR(v7);
			x5 = x1;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v8 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			uint64_t v9 = mw_mirth_package_Package_name(v8);
			VAL v10 = mw_mirth_name_Name_mangled(v9);
			x6 = v10;
			x5 = x1;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v12 = mw_mirth_module_Module_qname(v11);
			VAL v13;
			VAL v14;
			mw_mirth_name_QName_mangled(x1, v12, &v13, &v14);
			x6 = v14;
			x5 = v13;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v15 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL v16;
			VAL v17;
			mw_mirth_tycon_Tycon_qnameZ_hard(x1, v15, &v16, &v17);
			VAL v18;
			VAL v19;
			mw_mirth_name_QName_mangled(v16, v17, &v18, &v19);
			x6 = v19;
			x5 = v18;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v20 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL v21;
			VAL v22;
			mw_mirth_word_Word_qnameZ_hard(v20, x1, &v21, &v22);
			VAL v23;
			VAL v24;
			mw_mirth_name_QName_mangled(v22, v21, &v23, &v24);
			x6 = v24;
			x5 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static VAL mw_mirth_name_QNAME0 (VAL x1, uint64_t x2) {
	int64_t v3 = 0LL;
	VAL v4 = mtw_mirth_name_QName_MKQNAME(x1, x2, v3);
	return v4;
}
static int64_t mw_mirth_name_QName_ZEqualZEqual (VAL x1, VAL x2) {
	VAL v3;
	uint64_t v4;
	int64_t v5;
	mtp_mirth_name_QName_MKQNAME(x2, &v3, &v4, &v5);
	VAL v6;
	uint64_t v7;
	int64_t v8;
	mtp_mirth_name_QName_MKQNAME(x1, &v6, &v7, &v8);
	int64_t v9 = mw_mirth_name_Name_ZEqualZEqual(v7, v4);
	bool v10 = (v8 == v5);
	bool v11 = (((bool)v9) && v10);
	int64_t v12 = mw_mirth_name_Namespace_ZEqualZEqual(v6, v3);
	bool v13 = (v11 && ((bool)v12));
	return ((int64_t)v13);
}
static void mw_mirth_name_QName_defZ_hardZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	uint64_t v5 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	VAL v6 = mw_mirth_name_Name_defs(v5);
	VAL v7 = MKI64(0LL /* None */);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v6, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	VAL x13;
	int64_t x14;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v8);
			incref(v15);
			incref(x2);
			VAL v16;
			VAL v17;
			mw_mirth_def_Def_qnameZ_hard(x1, v15, &v16, &v17);
			int64_t v18 = mw_mirth_name_QName_ZEqualZEqual(x2, v17);
			VAL x19;
			VAL x20;
			VAL x21;
			if (((bool)v18)) {
				VAL v22 = mtw_std_maybe_Maybe_1_Some(v15);
				x21 = v22;
				x20 = x2;
				x19 = v16;
			} else {
				decref(v15);
				VAL v23 = MKI64(0LL /* None */);
				x21 = v23;
				x20 = x2;
				x19 = v16;
			}
			VAL x24;
			VAL x25;
			VAL x26;
			VAL x27;
			switch (get_data_tag(x21)) {
				case 0LL: { // None
					x27 = v9;
					x26 = v7;
					x25 = x20;
					x24 = x19;
				} break;
				default: {
					decref(v9);
					decref(v7);
					VAL v28 = MKI64(0LL /* Nil */);
					x27 = v28;
					x26 = x21;
					x25 = x20;
					x24 = x19;
				} break;
			}
			int64_t v29 = 1LL /* True */;
			x14 = v29;
			x13 = x27;
			x12 = x26;
			x11 = x25;
			x10 = x24;
		} break;
		case 0LL: { // None
			int64_t v30 = 0LL /* False */;
			x14 = v30;
			x13 = v9;
			x12 = v7;
			x11 = x2;
			x10 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v31 = (x10);
	VAL v32 = x11;
	VAL v33 = x12;
	VAL v34 = x13;
	int64_t v35 = x14;
	while (((bool)v35)) {
		VAL v36 = (v31);
		VAL v37 = v32;
		VAL v38 = v33;
		VAL v39 = v34;
		VAL v40;
		VAL v41;
		mw_std_list_List_1_uncons(v39, &v40, &v41);
		VAL x42;
		VAL x43;
		VAL x44;
		VAL x45;
		int64_t x46;
		switch (get_data_tag(v40)) {
			case 1LL: { // Some
				VAL v47 = mtp_std_maybe_Maybe_1_Some(v40);
				incref(v47);
				incref(v37);
				VAL v48;
				VAL v49;
				mw_mirth_def_Def_qnameZ_hard(v36, v47, &v48, &v49);
				int64_t v50 = mw_mirth_name_QName_ZEqualZEqual(v37, v49);
				VAL x51;
				VAL x52;
				VAL x53;
				if (((bool)v50)) {
					VAL v54 = mtw_std_maybe_Maybe_1_Some(v47);
					x53 = v54;
					x52 = v37;
					x51 = v48;
				} else {
					decref(v47);
					VAL v55 = MKI64(0LL /* None */);
					x53 = v55;
					x52 = v37;
					x51 = v48;
				}
				VAL x56;
				VAL x57;
				VAL x58;
				VAL x59;
				switch (get_data_tag(x53)) {
					case 0LL: { // None
						x59 = v41;
						x58 = v38;
						x57 = x52;
						x56 = x51;
					} break;
					default: {
						decref(v41);
						decref(v38);
						VAL v60 = MKI64(0LL /* Nil */);
						x59 = v60;
						x58 = x53;
						x57 = x52;
						x56 = x51;
					} break;
				}
				int64_t v61 = 1LL /* True */;
				x46 = v61;
				x45 = x59;
				x44 = x58;
				x43 = x57;
				x42 = x56;
			} break;
			case 0LL: { // None
				int64_t v62 = 0LL /* False */;
				x46 = v62;
				x45 = v41;
				x44 = v38;
				x43 = v37;
				x42 = v36;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v35 = x46;
		v34 = x45;
		v33 = x44;
		v32 = x43;
		v31 = x42;
	}
	decref(v34);
	decref(v32);
	*x4 = v33;
	*x3 = v31;
}
static void mw_mirth_name_QName_definedZ_hardZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_name_QName_defZ_hardZAsk(x1, x2, &v5, &v6);
	int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
	*x4 = v7;
	*x3 = v5;
}
static void mw_mirth_name_QName_defZ_softZAsk (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	uint64_t v5 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	VAL v6 = mw_mirth_name_Name_defs(v5);
	VAL v7 = mtw_std_maybe_Maybe_1_Some(x2);
	VAL v8 = MKI64(0LL /* None */);
	VAL v9;
	VAL v10;
	mw_std_list_List_1_uncons(v6, &v9, &v10);
	VAL x11;
	VAL x12;
	VAL x13;
	VAL x14;
	int64_t x15;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v9);
			incref(v16);
			incref(v7);
			VAL v17;
			VAL v18;
			mw_mirth_def_Def_qnameZ_soft(x1, v16, &v17, &v18);
			VAL x19;
			int64_t x20;
			switch (get_data_tag(v18)) {
				case 0LL: { // None
					int64_t v21 = mw_std_maybe_Maybe_1_noneZAsk(v7);
					x20 = v21;
					x19 = v17;
				} break;
				case 1LL: { // Some
					VAL v22 = mtp_std_maybe_Maybe_1_Some(v18);
					VAL x23;
					int64_t x24;
					switch (get_data_tag(v7)) {
						case 1LL: { // Some
							VAL v25 = mtp_std_maybe_Maybe_1_Some(v7);
							int64_t v26 = mw_mirth_name_QName_ZEqualZEqual(v25, v22);
							x24 = v26;
							x23 = v17;
						} break;
						case 0LL: { // None
							decref(v22);
							int64_t v27 = 0LL /* False */;
							x24 = v27;
							x23 = v17;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x20 = x24;
					x19 = x23;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL x28;
			VAL x29;
			VAL x30;
			if (((bool)x20)) {
				VAL v31 = mtw_std_maybe_Maybe_1_Some(v16);
				x30 = v31;
				x29 = v7;
				x28 = x19;
			} else {
				decref(v16);
				VAL v32 = MKI64(0LL /* None */);
				x30 = v32;
				x29 = v7;
				x28 = x19;
			}
			VAL x33;
			VAL x34;
			VAL x35;
			VAL x36;
			switch (get_data_tag(x30)) {
				case 0LL: { // None
					x36 = v10;
					x35 = v8;
					x34 = x29;
					x33 = x28;
				} break;
				default: {
					decref(v10);
					decref(v8);
					VAL v37 = MKI64(0LL /* Nil */);
					x36 = v37;
					x35 = x30;
					x34 = x29;
					x33 = x28;
				} break;
			}
			int64_t v38 = 1LL /* True */;
			x15 = v38;
			x14 = x36;
			x13 = x35;
			x12 = x34;
			x11 = x33;
		} break;
		case 0LL: { // None
			int64_t v39 = 0LL /* False */;
			x15 = v39;
			x14 = v10;
			x13 = v8;
			x12 = v7;
			x11 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v40 = (x11);
	VAL v41 = x12;
	VAL v42 = x13;
	VAL v43 = x14;
	int64_t v44 = x15;
	while (((bool)v44)) {
		VAL v45 = (v40);
		VAL v46 = v41;
		VAL v47 = v42;
		VAL v48 = v43;
		VAL v49;
		VAL v50;
		mw_std_list_List_1_uncons(v48, &v49, &v50);
		VAL x51;
		VAL x52;
		VAL x53;
		VAL x54;
		int64_t x55;
		switch (get_data_tag(v49)) {
			case 1LL: { // Some
				VAL v56 = mtp_std_maybe_Maybe_1_Some(v49);
				incref(v56);
				incref(v46);
				VAL v57;
				VAL v58;
				mw_mirth_def_Def_qnameZ_soft(v45, v56, &v57, &v58);
				VAL x59;
				int64_t x60;
				switch (get_data_tag(v58)) {
					case 0LL: { // None
						int64_t v61 = mw_std_maybe_Maybe_1_noneZAsk(v46);
						x60 = v61;
						x59 = v57;
					} break;
					case 1LL: { // Some
						VAL v62 = mtp_std_maybe_Maybe_1_Some(v58);
						VAL x63;
						int64_t x64;
						switch (get_data_tag(v46)) {
							case 1LL: { // Some
								VAL v65 = mtp_std_maybe_Maybe_1_Some(v46);
								int64_t v66 = mw_mirth_name_QName_ZEqualZEqual(v65, v62);
								x64 = v66;
								x63 = v57;
							} break;
							case 0LL: { // None
								decref(v62);
								int64_t v67 = 0LL /* False */;
								x64 = v67;
								x63 = v57;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						x60 = x64;
						x59 = x63;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL x68;
				VAL x69;
				VAL x70;
				if (((bool)x60)) {
					VAL v71 = mtw_std_maybe_Maybe_1_Some(v56);
					x70 = v71;
					x69 = v46;
					x68 = x59;
				} else {
					decref(v56);
					VAL v72 = MKI64(0LL /* None */);
					x70 = v72;
					x69 = v46;
					x68 = x59;
				}
				VAL x73;
				VAL x74;
				VAL x75;
				VAL x76;
				switch (get_data_tag(x70)) {
					case 0LL: { // None
						x76 = v50;
						x75 = v47;
						x74 = x69;
						x73 = x68;
					} break;
					default: {
						decref(v50);
						decref(v47);
						VAL v77 = MKI64(0LL /* Nil */);
						x76 = v77;
						x75 = x70;
						x74 = x69;
						x73 = x68;
					} break;
				}
				int64_t v78 = 1LL /* True */;
				x55 = v78;
				x54 = x76;
				x53 = x75;
				x52 = x74;
				x51 = x73;
			} break;
			case 0LL: { // None
				int64_t v79 = 0LL /* False */;
				x55 = v79;
				x54 = v50;
				x53 = v47;
				x52 = v46;
				x51 = v45;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v44 = x55;
		v43 = x54;
		v42 = x53;
		v41 = x52;
		v40 = x51;
	}
	decref(v43);
	decref(v41);
	*x4 = v42;
	*x3 = v40;
}
static void mw_mirth_name_QName_definedZ_softZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_name_QName_defZ_softZAsk(x1, x2, &v5, &v6);
	int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
	*x4 = v7;
	*x3 = v5;
}
static void mw_mirth_name_QName_undefinedZ_softZAsk (VAL x1, VAL x2, VAL *x3, int64_t *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_name_QName_defZ_softZAsk(x1, x2, &v5, &v6);
	int64_t v7 = mw_std_maybe_Maybe_1_noneZAsk(v6);
	*x4 = v7;
	*x3 = v5;
}
static void mw_mirth_name_QName_prim (VAL x1, VAL x2, int64_t x3, VAL *x4, VAL *x5) {
	uint64_t v6 = mw_std_prim_Str_ZToName(x2);
	VAL v7;
	VAL v8;
	mw_mirth_name_Namespace_prim(x1, &v7, &v8);
	VAL v9 = mtw_mirth_name_QName_MKQNAME(v8, v6, x3);
	*x5 = v9;
	*x4 = v7;
}
static void mw_mirth_name_QName_ZToStr (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	int64_t v7;
	mtp_mirth_name_QName_MKQNAME(x2, &v5, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_name_Namespace_ZToStr(x1, v5, &v8, &v9);
	STR* v10;
	STRLIT(v10, ".", 1);
	STR* v11 = str_cat(VSTR(v9), v10);
	VAL v12 = mw_mirth_name_Name_ZToStr(v6);
	STR* v13 = str_cat(v11, VSTR(v12));
	int64_t v14 = 0LL;
	bool v15 = (v7 == v14);
	VAL x16;
	VAL x17;
	if (v15) {
		x17 = MKSTR(v13);
		x16 = v8;
	} else {
		STR* v18;
		STRLIT(v18, "/", 1);
		STR* v19 = i64_show(v7);
		STR* v20 = str_cat(v18, v19);
		STR* v21 = str_cat(v13, v20);
		x17 = MKSTR(v21);
		x16 = v8;
	}
	*x4 = x17;
	*x3 = x16;
}
static void mw_mirth_name_QName_toZ_moduleZ_path (VAL x1, int64_t x2, VAL x3, VAL *x4, int64_t *x5, VAL *x6) {
	incref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[1]);
	incref(v7);
	decref(x1);
	int64_t x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(v7);
			int64_t v12;
			VAL v13;
			VAL v14;
			mw_mirth_package_Package_pathZ_orZ_search(x2, x3, v11, &v12, &v13, &v14);
			VAL x15;
			uint64_t x16;
			int64_t x17;
			VAL x18;
			VAL x19;
			switch (get_data_tag(v14)) {
				case 1LL: { // Some
					VAL v20 = mtp_std_maybe_Maybe_1_Some(v14);
					x19 = v20;
					x18 = v13;
					x17 = v12;
					x16 = v11;
					x15 = x1;
				} break;
				case 0LL: { // None
					STR* v21;
					STRLIT(v21, "No path defined for package ", 28);
					uint64_t v22 = mw_mirth_package_Package_name(v11);
					VAL v23 = mw_mirth_name_Name_ZToStr(v22);
					push_value(x1);
					push_resource(MKI64(v12));
					push_str(v21);
					mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(v23, v13);
					VAL v24 = pop_value();
					x19 = v24;
					VAL r25 = pop_resource();
					x18 = r25;
					int64_t r26 = VI64(pop_resource());
					x17 = r26;
					uint64_t v27 = pop_u64();
					x16 = v27;
					VAL v28 = pop_value();
					x15 = v28;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v29 = VU64(VTUP(x15)->cells[2]);
			decref(x15);
			VAL v30 = mw_mirth_name_Name_ZToStr(v29);
			STR* v31;
			STRLIT(v31, ".mth", 4);
			STR* v32 = str_cat(VSTR(v30), v31);
			VAL v33 = mw_std_path_Path_join(x19, MKSTR(v32));
			x10 = v33;
			x9 = x18;
			x8 = x17;
		} break;
		default: {
			decref(v7);
			STR* v34;
			STRLIT(v34, "expected module name in QName.to-module-path", 44);
			push_resource(MKI64(x2));
			push_resource(x3);
			push_value(x1);
			do_panic(v34);
			VAL v35 = pop_value();
			x10 = v35;
			VAL r36 = pop_resource();
			x9 = r36;
			int64_t r37 = VI64(pop_resource());
			x8 = r37;
		} break;
	}
	*x6 = x9;
	*x5 = x8;
	*x4 = x10;
}
static void mw_mirth_name_QName_mangled (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	int64_t v7;
	mtp_mirth_name_QName_MKQNAME(x2, &v5, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_name_Namespace_mangled(x1, v5, &v8, &v9);
	STR* v10;
	STRLIT(v10, "_", 1);
	STR* v11 = str_cat(VSTR(v9), v10);
	VAL v12 = mw_mirth_name_Name_mangled(v6);
	STR* v13 = str_cat(v11, VSTR(v12));
	int64_t v14 = 0LL;
	bool v15 = (v7 > v14);
	VAL x16;
	VAL x17;
	if (v15) {
		STR* v18;
		STRLIT(v18, "_", 1);
		STR* v19 = i64_show(v7);
		STR* v20 = str_cat(v18, v19);
		STR* v21 = str_cat(v13, v20);
		x17 = MKSTR(v21);
		x16 = v8;
	} else {
		x17 = MKSTR(v13);
		x16 = v8;
	}
	*x4 = x17;
	*x3 = x16;
}
static VAL mw_mirth_name_DName_rootZAsk (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_name_DName_DName(x1, &v2, &v3);
	decref(v3);
	return v2;
}
static VAL mw_mirth_name_DName_parts (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_name_DName_DName(x1, &v2, &v3);
	decref(v2);
	return v3;
}
static uint64_t mw_mirth_name_DName_lastZ_name (VAL x1) {
	VAL v2 = mw_mirth_name_DName_parts(x1);
	VAL v3 = mw_std_list_ListZPlus_1_last(v2);
	return VU64(v3);
}
static VAL mw_mirth_name_DName_penultimateZ_nameZAsk (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_name_DName_DName(x1, &v2, &v3);
	VAL v4;
	VAL v5;
	mw_std_list_ListZPlus_1_unsnoc(v3, &v4, &v5);
	decref(v5);
	VAL v6 = mw_std_list_List_1_last(v4);
	VAL x7;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v6);
			decref(v2);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			x7 = v9;
		} break;
		case 0LL: { // None
			x7 = v2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x7;
}
static int64_t mw_mirth_name_DName_isZ_relativeZAsk (VAL x1) {
	VAL v2 = mw_mirth_name_DName_rootZAsk(x1);
	int64_t v3 = mw_std_maybe_Maybe_1_noneZAsk(v2);
	return v3;
}
static int64_t mw_mirth_package_Package_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_package_Package_allocZBang (void) {
	void* v1 = mbuf_mirth_package_Package_NUM;
	uint64_t v2 = *(uint64_t*)v1;
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(((int64_t)v2), v3);
	void* v5 = mbuf_mirth_package_Package_NUM;
	*(uint64_t*)v5 = ((uint64_t)v4);
	return ((uint64_t)v4);
}
static uint64_t mw_mirth_package_Package_name (uint64_t x1) {
	void* v2 = mfld_mirth_package_Package_ZTildename(x1);
	VAL v3 = mut_get(v2);
	return VU64(v3);
}
static VAL mw_mirth_package_Package_qname (uint64_t x1) {
	VAL v2 = MKI64(0LL /* NAMESPACE_ROOT */);
	uint64_t v3 = mw_mirth_package_Package_name(x1);
	VAL v4 = mw_mirth_name_QNAME0(v2, v3);
	return v4;
}
static VAL mw_mirth_package_Package_path (uint64_t x1) {
	void* v2 = mfld_mirth_package_Package_ZTildepath(x1);
	VAL v3 = mut_get(v2);
	return v3;
}
static void mw_mirth_package_Package_std (VAL x1, VAL *x2, uint64_t *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[1]);
	decref(v4);
	*x3 = v5;
	*x2 = x1;
}
static VAL mw_mirth_package_initZ_packagesZBang (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[4]);
	incref(v2);
	uint64_t v3 = VU64(VTUP(v2)->cells[1]);
	decref(v2);
	STR* v4;
	STRLIT(v4, "std", 3);
	uint64_t v5 = mw_std_prim_Str_ZToName(MKSTR(v4));
	void* v6 = mfld_mirth_package_Package_ZTildename(v3);
	mut_set(MKU64(v5), v6);
	VAL v7 = MKI64(0LL /* None */);
	void* v8 = mfld_mirth_package_Package_ZTildepath(v3);
	mut_set(v7, v8);
	return x1;
}
static void mw_mirth_package_Package_pathZ_orZ_search (int64_t x1, VAL x2, uint64_t x3, int64_t *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_package_Package_path(x3);
	int64_t x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
			x10 = v12;
			x9 = x2;
			x8 = x1;
		} break;
		case 0LL: { // None
			VAL v13 = VVAL(VTUP(x2)->cells[7]);
			incref(v13);
			VAL v14 = MKI64(0LL /* Nil */);
			VAL v15 = mw_std_list_List_1_reverse(v14);
			VAL v16;
			VAL v17;
			mw_std_list_List_1_uncons(v13, &v16, &v17);
			int64_t x18;
			uint64_t x19;
			VAL x20;
			VAL x21;
			VAL x22;
			int64_t x23;
			switch (get_data_tag(v16)) {
				case 1LL: { // Some
					VAL v24 = mtp_std_maybe_Maybe_1_Some(v16);
					uint64_t v25 = mw_mirth_package_Package_name(x3);
					VAL v26 = mw_mirth_name_Name_ZToStr(v25);
					VAL v27 = mw_std_path_Path_join(v24, v26);
					VAL v28 = mtw_std_list_List_1_Cons(v27, v15);
					int64_t v29 = 1LL /* True */;
					x23 = v29;
					x22 = v17;
					x21 = v28;
					x20 = x2;
					x19 = x3;
					x18 = x1;
				} break;
				case 0LL: { // None
					int64_t v30 = 0LL /* False */;
					x23 = v30;
					x22 = v17;
					x21 = v15;
					x20 = x2;
					x19 = x3;
					x18 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v31 = (x18);
			uint64_t v32 = x19;
			VAL v33 = (x20);
			VAL v34 = (x21);
			VAL v35 = x22;
			int64_t v36 = x23;
			while (((bool)v36)) {
				int64_t v37 = (v31);
				uint64_t v38 = v32;
				VAL v39 = (v33);
				VAL v40 = (v34);
				VAL v41 = v35;
				VAL v42;
				VAL v43;
				mw_std_list_List_1_uncons(v41, &v42, &v43);
				int64_t x44;
				uint64_t x45;
				VAL x46;
				VAL x47;
				VAL x48;
				int64_t x49;
				switch (get_data_tag(v42)) {
					case 1LL: { // Some
						VAL v50 = mtp_std_maybe_Maybe_1_Some(v42);
						uint64_t v51 = mw_mirth_package_Package_name(v38);
						VAL v52 = mw_mirth_name_Name_ZToStr(v51);
						VAL v53 = mw_std_path_Path_join(v50, v52);
						VAL v54 = mtw_std_list_List_1_Cons(v53, v40);
						int64_t v55 = 1LL /* True */;
						x49 = v55;
						x48 = v43;
						x47 = v54;
						x46 = v39;
						x45 = v38;
						x44 = v37;
					} break;
					case 0LL: { // None
						int64_t v56 = 0LL /* False */;
						x49 = v56;
						x48 = v43;
						x47 = v40;
						x46 = v39;
						x45 = v38;
						x44 = v37;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v36 = x49;
				v35 = x48;
				v34 = x47;
				v33 = x46;
				v32 = x45;
				v31 = x44;
			}
			decref(v35);
			VAL v57 = mw_std_list_List_1_reverse(v34);
			VAL v58 = MKI64(0LL /* None */);
			VAL v59;
			VAL v60;
			mw_std_list_List_1_uncons(v57, &v59, &v60);
			int64_t x61;
			uint64_t x62;
			VAL x63;
			VAL x64;
			VAL x65;
			int64_t x66;
			switch (get_data_tag(v59)) {
				case 1LL: { // Some
					VAL v67 = mtp_std_maybe_Maybe_1_Some(v59);
					incref(v67);
					int64_t v68;
					int64_t v69;
					mw_std_prim_ZPlusWorld_isZ_directoryZAsk(v31, v67, &v68, &v69);
					int64_t x70;
					uint64_t x71;
					VAL x72;
					VAL x73;
					if (((bool)v69)) {
						VAL v74 = mtw_std_maybe_Maybe_1_Some(v67);
						x73 = v74;
						x72 = v33;
						x71 = v32;
						x70 = v68;
					} else {
						decref(v67);
						VAL v75 = MKI64(0LL /* None */);
						x73 = v75;
						x72 = v33;
						x71 = v32;
						x70 = v68;
					}
					int64_t x76;
					uint64_t x77;
					VAL x78;
					VAL x79;
					VAL x80;
					switch (get_data_tag(x73)) {
						case 0LL: { // None
							x80 = v60;
							x79 = v58;
							x78 = x72;
							x77 = x71;
							x76 = x70;
						} break;
						default: {
							decref(v60);
							decref(v58);
							VAL v81 = MKI64(0LL /* Nil */);
							x80 = v81;
							x79 = x73;
							x78 = x72;
							x77 = x71;
							x76 = x70;
						} break;
					}
					int64_t v82 = 1LL /* True */;
					x66 = v82;
					x65 = x80;
					x64 = x79;
					x63 = x78;
					x62 = x77;
					x61 = x76;
				} break;
				case 0LL: { // None
					int64_t v83 = 0LL /* False */;
					x66 = v83;
					x65 = v60;
					x64 = v58;
					x63 = v33;
					x62 = v32;
					x61 = v31;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v84 = (x61);
			uint64_t v85 = x62;
			VAL v86 = (x63);
			VAL v87 = x64;
			VAL v88 = x65;
			int64_t v89 = x66;
			while (((bool)v89)) {
				int64_t v90 = (v84);
				uint64_t v91 = v85;
				VAL v92 = (v86);
				VAL v93 = v87;
				VAL v94 = v88;
				VAL v95;
				VAL v96;
				mw_std_list_List_1_uncons(v94, &v95, &v96);
				int64_t x97;
				uint64_t x98;
				VAL x99;
				VAL x100;
				VAL x101;
				int64_t x102;
				switch (get_data_tag(v95)) {
					case 1LL: { // Some
						VAL v103 = mtp_std_maybe_Maybe_1_Some(v95);
						incref(v103);
						int64_t v104;
						int64_t v105;
						mw_std_prim_ZPlusWorld_isZ_directoryZAsk(v90, v103, &v104, &v105);
						int64_t x106;
						uint64_t x107;
						VAL x108;
						VAL x109;
						if (((bool)v105)) {
							VAL v110 = mtw_std_maybe_Maybe_1_Some(v103);
							x109 = v110;
							x108 = v92;
							x107 = v91;
							x106 = v104;
						} else {
							decref(v103);
							VAL v111 = MKI64(0LL /* None */);
							x109 = v111;
							x108 = v92;
							x107 = v91;
							x106 = v104;
						}
						int64_t x112;
						uint64_t x113;
						VAL x114;
						VAL x115;
						VAL x116;
						switch (get_data_tag(x109)) {
							case 0LL: { // None
								x116 = v96;
								x115 = v93;
								x114 = x108;
								x113 = x107;
								x112 = x106;
							} break;
							default: {
								decref(v96);
								decref(v93);
								VAL v117 = MKI64(0LL /* Nil */);
								x116 = v117;
								x115 = x109;
								x114 = x108;
								x113 = x107;
								x112 = x106;
							} break;
						}
						int64_t v118 = 1LL /* True */;
						x102 = v118;
						x101 = x116;
						x100 = x115;
						x99 = x114;
						x98 = x113;
						x97 = x112;
					} break;
					case 0LL: { // None
						int64_t v119 = 0LL /* False */;
						x102 = v119;
						x101 = v96;
						x100 = v93;
						x99 = v92;
						x98 = v91;
						x97 = v90;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v89 = x102;
				v88 = x101;
				v87 = x100;
				v86 = x99;
				v85 = x98;
				v84 = x97;
			}
			decref(v88);
			incref(v87);
			void* v120 = mfld_mirth_package_Package_ZTildepath(v85);
			mut_set(v87, v120);
			x10 = v87;
			x9 = v86;
			x8 = v84;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static VAL mw_mirth_package_Package_pathZBang (VAL x1, VAL x2, uint64_t x3) {
	VAL v4 = mw_mirth_package_Package_path(x3);
	VAL x5;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v4);
			incref(x2);
			incref(v6);
			bool v7 = (str_cmp(VSTR(x2), VSTR(v6)) == 0);
			VAL x8;
			if (v7) {
				decref(v6);
				decref(x2);
				x8 = x1;
			} else {
				STR* v9;
				STRLIT(v9, "", 0);
				STR* v10;
				STRLIT(v10, "Tried to set different path for the same package ", 49);
				VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), MKSTR(v9)));
				STR* v12;
				STRLIT(v12, "(package = ", 11);
				VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
				uint64_t v14 = mw_mirth_package_Package_name(x3);
				VAL v15 = mw_mirth_name_Name_ZToStr(v14);
				VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(v15, v13));
				STR* v17;
				STRLIT(v17, ", path 1 = ", 11);
				VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v17), v16));
				VAL v19 = (mw_std_prim_Str_showZThen(x2, v18));
				STR* v20;
				STRLIT(v20, ", path 2 = ", 11);
				VAL v21 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v20), v19));
				VAL v22 = (mw_std_prim_Str_showZThen(v6, v21));
				STR* v23;
				STRLIT(v23, ").", 2);
				VAL v24 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v23), v22));
				mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(v24, x1);
				VAL r25 = pop_resource();
				x8 = r25;
			}
			x5 = x8;
		} break;
		case 0LL: { // None
			VAL v26 = mtw_std_maybe_Maybe_1_Some(x2);
			void* v27 = mfld_mirth_package_Package_ZTildepath(x3);
			mut_set(v26, v27);
			x5 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x5;
}
static void mw_mirth_package_Package_newZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, uint64_t *x5) {
	uint64_t v6 = mw_mirth_package_Package_allocZBang();
	void* v7 = mfld_mirth_package_Package_ZTildename(v6);
	mut_set(MKU64(x3), v7);
	void* v8 = mfld_mirth_package_Package_ZTildepath(v6);
	mut_set(x2, v8);
	VAL v9 = mtw_mirth_def_Def_DefPackage(v6);
	VAL v10 = (mw_mirth_def_Def_register(x1, v9));
	*x5 = v6;
	*x4 = v10;
}
static void mw_mirth_package_Package_newZ_orZ_pathZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, uint64_t *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_package_Package_find(x1, x3, &v6, &v7);
	uint64_t x8;
	VAL x9;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v7);
			incref(v10);
			VAL v11 = (mw_mirth_package_Package_pathZBang(v6, x2, VU64(v10)));
			x9 = v11;
			x8 = VU64(v10);
		} break;
		case 0LL: { // None
			VAL v12 = mtw_std_maybe_Maybe_1_Some(x2);
			VAL v13;
			uint64_t v14;
			mw_mirth_package_Package_newZBang(v6, v12, x3, &v13, &v14);
			x9 = v13;
			x8 = v14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x8;
	*x4 = x9;
}
static void mw_mirth_package_Package_find (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = MKI64(0LL /* NAMESPACE_ROOT */);
	VAL v6 = mw_mirth_name_QNAME0(v5, x2);
	VAL v7;
	VAL v8;
	mw_mirth_name_QName_defZ_softZAsk(x1, v6, &v7, &v8);
	VAL x9;
	VAL x10;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v12 = mw_mirth_def_Def_packageZAsk(v11);
			x10 = v12;
			x9 = v7;
		} break;
		case 0LL: { // None
			VAL v13 = MKI64(0LL /* None */);
			x10 = v13;
			x9 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x10;
	*x3 = x9;
}
static void mw_mirth_package_Package_findZ_orZ_newZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_package_Package_find(x1, x2, &v5, &v6);
	uint64_t x7;
	VAL x8;
	uint64_t x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
			x9 = VU64(v10);
			x8 = v5;
			x7 = x2;
		} break;
		case 0LL: { // None
			VAL v11 = MKI64(0LL /* None */);
			VAL v12;
			uint64_t v13;
			mw_mirth_package_Package_newZBang(v5, v11, x2, &v12, &v13);
			x9 = v13;
			x8 = v12;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x9;
	*x3 = x8;
}
static int64_t mw_mirth_package_Package_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v3 = mw_mirth_package_Package_index(x1);
	int64_t v4 = mw_mirth_package_Package_index(x2);
	bool v5 = (v3 == v4);
	return ((int64_t)v5);
}
static VAL mw_mirth_lexer_lexerZ_stackZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x2)->cells[4]);
	incref(v3);
	VAL v4 = mtw_std_list_List_1_Cons(MKU64(x1), v3);
	VAL v5 = VTUP(x2)->cells[4];
	decref(v5);
	VTUP(x2)->cells[4] = v4;
	return x2;
}
static void mw_mirth_lexer_lexerZ_stackZ_popZBang (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v4, &v5, &v6);
	VAL v7 = VTUP(x1)->cells[4];
	decref(v7);
	VTUP(x1)->cells[4] = v6;
	*x3 = x1;
	*x2 = v5;
}
static VAL mw_mirth_lexer_lexerZ_stackZ_drop (VAL x1) {
	VAL v2;
	VAL v3;
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x1, &v2, &v3);
	decref(v2);
	return v3;
}
static void mw_mirth_lexer_lexerZ_stackZ_peek (VAL x1, VAL *x2, VAL *x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	VAL v5 = mw_std_list_List_1_first(v4);
	*x3 = x1;
	*x2 = v5;
}
static void mw_mirth_lexer_runZ_lexerZBang (VAL x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6) {
	VAL v7;
	uint64_t v8;
	mw_mirth_module_Module_newZBang(x3, x1, &v7, &v8);
	VAL v9 = mw_mirth_module_Module_sourceZ_path(v8);
	int64_t v10;
	VAL v11;
	mw_std_prim_ZPlusWorld_openZ_fileZBang(v9, x2, &v10, &v11);
	uint64_t x12;
	VAL x13;
	int64_t x14;
	VAL x15;
	switch (get_data_tag(v11)) {
		case 0LL: { // +FileOk
			VAL v16 = (mtp_std_file_ZPlusFileZAsk_ZPlusFileOk(v11));
			x15 = v16;
			x14 = v10;
			x13 = v7;
			x12 = v8;
		} break;
		case 1LL: { // +FileErr
			VAL v17 = mtp_std_file_ZPlusFileZAsk_ZPlusFileErr(v11);
			lpush(&lbl_lexerZ_module, MKU64(v8));
			push_resource(MKI64(v10));
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(v17, v7);
			VAL r18 = pop_resource();
			x15 = r18;
			int64_t r19 = VI64(pop_resource());
			x14 = r19;
			VAL r20 = pop_resource();
			x13 = r20;
			uint64_t v21 = VU64(lpop(&lbl_lexerZ_module));
			x12 = v21;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v22 = (mw_std_input_ZPlusInput_startZBang(x15));
	int64_t v23 = 1LL;
	int64_t v24 = mw_std_prim_Int_ZToRow(v23);
	int64_t v25 = 1LL;
	int64_t v26 = mw_std_prim_Int_ZToCol(v25);
	VAL v27 = MKI64(0LL /* Nil */);
	uint64_t v28 = mw_mirth_token_Token_allocZ_noneZBang();
	VAL v29 = (mtw_mirth_lexer_ZPlusLexer_ZPlusLexer(x12, v24, v26, v27, v28, v22));
	int64_t v30;
	VAL v31;
	mw_mirth_lexer_ZPlusLexer_doneZAsk(v29, &v30, &v31);
	bool v32 = !((bool)v30);
	int64_t v33 = (x14);
	VAL v34 = (x13);
	uint64_t v35 = v28;
	VAL v36 = (v31);
	bool v37 = v32;
	while (v37) {
		int64_t v38 = (v33);
		VAL v39 = (v34);
		uint64_t v40 = v35;
		VAL v41 = (v36);
		VAL v42;
		VAL v43;
		mw_mirth_lexer_lexerZ_nextZBang(v39, v41, &v42, &v43);
		int64_t v44;
		VAL v45;
		mw_mirth_lexer_ZPlusLexer_doneZAsk(v43, &v44, &v45);
		bool v46 = !((bool)v44);
		v37 = v46;
		v36 = v45;
		v35 = v40;
		v34 = v42;
		v33 = v38;
	}
	VAL v47 = MKI64(0LL /* TokenNone */);
	VAL v48 = (mw_mirth_lexer_lexerZ_emitZBang(v47, v36));
	uint64_t v49;
	int64_t v50;
	int64_t v51;
	VAL v52;
	uint64_t v53;
	VAL v54;
	mtp_mirth_lexer_ZPlusLexer_ZPlusLexer(v48, &v49, &v50, &v51, &v52, &v53, &v54);
	VAL v55 = (mw_std_input_ZPlusInput_endZBang(v54));
	int64_t v56 = (mw_std_file_ZPlusFile_closeZ_fileZBang(v33, v55));
	VAL v57;
	VAL v58;
	mw_std_list_List_1_uncons(v52, &v57, &v58);
	decref(v58);
	uint64_t x59;
	uint64_t x60;
	int64_t x61;
	int64_t x62;
	uint64_t x63;
	int64_t x64;
	VAL x65;
	switch (get_data_tag(v57)) {
		case 1LL: { // Some
			VAL v66 = mtp_std_maybe_Maybe_1_Some(v57);
			STR* v67;
			STRLIT(v67, "Mismatched left parenthesis.", 28);
			push_u64(v35);
			lpush(&lbl_lexerZ_module, MKU64(v49));
			lpush(&lbl_lexerZ_row, MKI64(v50));
			lpush(&lbl_lexerZ_col, MKI64(v51));
			lpush(&lbl_lexerZ_lastZ_token, MKU64(v53));
			push_resource(MKI64(v56));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v66), MKSTR(v67), v34);
			VAL r68 = pop_resource();
			x65 = r68;
			int64_t r69 = VI64(pop_resource());
			x64 = r69;
			uint64_t v70 = VU64(lpop(&lbl_lexerZ_lastZ_token));
			x63 = v70;
			int64_t v71 = VI64(lpop(&lbl_lexerZ_col));
			x62 = v71;
			int64_t v72 = VI64(lpop(&lbl_lexerZ_row));
			x61 = v72;
			uint64_t v73 = VU64(lpop(&lbl_lexerZ_module));
			x60 = v73;
			uint64_t v74 = pop_u64();
			x59 = v74;
		} break;
		case 0LL: { // None
			x65 = v34;
			x64 = v56;
			x63 = v53;
			x62 = v51;
			x61 = v50;
			x60 = v49;
			x59 = v35;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v75 = mw_mirth_token_Token_allocZ_noneZBang();
	void* v76 = mfld_mirth_module_Module_ZTildeend(x60);
	mut_set(MKU64(v75), v76);
	uint64_t v77 = mw_mirth_token_Token_succ(x59);
	void* v78 = mfld_mirth_module_Module_ZTildestart(x60);
	mut_set(MKU64(v77), v78);
	*x6 = x65;
	*x5 = x64;
	*x4 = x60;
}
static void mw_mirth_lexer_ZPlusLexer_doneZAsk (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4 = (VVAL(VTUP(x1)->cells[6]));
	int64_t v5;
	VAL v6;
	mw_std_input_ZPlusInput_doneZAsk(v4, &v5, &v6);
	VTUP(x1)->cells[6] = v6;
	*x3 = x1;
	*x2 = v5;
}
static void mw_mirth_lexer_lexerZ_makeZBang (VAL x1, VAL x2, uint64_t *x3, VAL *x4) {
	uint64_t v5 = mw_mirth_token_Token_allocZBang();
	void* v6 = mfld_mirth_token_Token_ZTildevalue(v5);
	mut_set(x1, v6);
	uint64_t v7 = VU64(VTUP(x2)->cells[1]);
	void* v8 = mfld_mirth_token_Token_ZTildemodule(v5);
	mut_set(MKU64(v7), v8);
	int64_t v9 = VI64(VTUP(x2)->cells[2]);
	void* v10 = mfld_mirth_token_Token_ZTilderow(v5);
	mut_set(MKI64(v9), v10);
	int64_t v11 = VI64(VTUP(x2)->cells[3]);
	void* v12 = mfld_mirth_token_Token_ZTildecol(v5);
	mut_set(MKI64(v11), v12);
	VTUP(x2)->cells[5] = MKU64(v5);
	*x4 = x2;
	*x3 = v5;
}
static VAL mw_mirth_lexer_lexerZ_emitZBang (VAL x1, VAL x2) {
	uint64_t v3;
	VAL v4;
	mw_mirth_lexer_lexerZ_makeZBang(x1, x2, &v3, &v4);
	return v4;
}
static void mw_mirth_lexer_lexerZ_nextZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	int64_t v5;
	VAL v6;
	mw_mirth_lexer_lexerZ_peek(x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (v5) {
		case 10LL: { // BLF
			VAL v9 = (mw_mirth_lexer_lexerZ_newlineZBang(v6));
			VAL v10 = (mw_mirth_lexer_lexerZ_moveZBang(v9));
			x8 = v10;
			x7 = x1;
		} break;
		case 32LL: { // BSPACE
			VAL v11 = (mw_mirth_lexer_lexerZ_moveZBang(v6));
			x8 = v11;
			x7 = x1;
		} break;
		case 9LL: { // BHT
			VAL v12 = (mw_mirth_lexer_lexerZ_moveZBang(v6));
			x8 = v12;
			x7 = x1;
		} break;
		case 11LL: { // BVT
			VAL v13 = (mw_mirth_lexer_lexerZ_moveZBang(v6));
			x8 = v13;
			x7 = x1;
		} break;
		case 13LL: { // BCR
			VAL v14 = (mw_mirth_lexer_lexerZ_moveZBang(v6));
			x8 = v14;
			x7 = x1;
		} break;
		case 35LL: { // BHASH
			VAL v15 = (mw_mirth_lexer_lexerZ_skipZ_commentZBang(v6));
			VAL v16 = (mw_mirth_lexer_lexerZ_moveZBang(v15));
			x8 = v16;
			x7 = x1;
		} break;
		case 44LL: { // BCOMMA
			VAL v17 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(v6));
			VAL v18 = MKI64(1LL /* TokenComma */);
			VAL v19 = (mw_mirth_lexer_lexerZ_emitZBang(v18, v17));
			VAL v20 = (mw_mirth_lexer_lexerZ_moveZBang(v19));
			x8 = v20;
			x7 = x1;
		} break;
		case 41LL: { // BRPAREN
			VAL v21 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(v6));
			VAL v22;
			VAL v23;
			mw_mirth_lexer_lexerZ_emitZ_rparenZBang(x1, v21, &v22, &v23);
			VAL v24 = (mw_mirth_lexer_lexerZ_moveZBang(v23));
			x8 = v24;
			x7 = v22;
		} break;
		case 93LL: { // BRSQUARE
			VAL v25 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(v6));
			VAL v26;
			VAL v27;
			mw_mirth_lexer_lexerZ_emitZ_rsquareZBang(x1, v25, &v26, &v27);
			VAL v28 = (mw_mirth_lexer_lexerZ_moveZBang(v27));
			x8 = v28;
			x7 = v26;
		} break;
		case 125LL: { // BRCURLY
			VAL v29 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(v6));
			VAL v30;
			VAL v31;
			mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang(x1, v29, &v30, &v31);
			VAL v32 = (mw_mirth_lexer_lexerZ_moveZBang(v31));
			x8 = v32;
			x7 = v30;
		} break;
		case 58LL: { // BCOLON
			VAL v33 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang(v6));
			VAL v34 = (mw_mirth_lexer_lexerZ_emitZ_lcolonZBang(v33));
			VAL v35 = (mw_mirth_lexer_lexerZ_moveZBang(v34));
			x8 = v35;
			x7 = x1;
		} break;
		case 40LL: { // BLPAREN
			VAL v36 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang(v6));
			VAL v37 = (mw_mirth_lexer_lexerZ_emitZ_lparenZBang(v36));
			VAL v38 = (mw_mirth_lexer_lexerZ_moveZBang(v37));
			x8 = v38;
			x7 = x1;
		} break;
		case 91LL: { // BLSQUARE
			VAL v39 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(v6));
			VAL v40 = (mw_mirth_lexer_lexerZ_emitZ_lsquareZBang(v39));
			VAL v41 = (mw_mirth_lexer_lexerZ_moveZBang(v40));
			x8 = v41;
			x7 = x1;
		} break;
		case 123LL: { // BLCURLY
			VAL v42 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(v6));
			VAL v43 = (mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang(v42));
			VAL v44 = (mw_mirth_lexer_lexerZ_moveZBang(v43));
			x8 = v44;
			x7 = x1;
		} break;
		case 34LL: { // BQUOTE
			VAL v45 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(v6));
			VAL v46;
			VAL v47;
			mw_mirth_lexer_lexerZ_emitZ_stringZBang(x1, v45, &v46, &v47);
			VAL v48 = (mw_mirth_lexer_lexerZ_moveZBang(v47));
			x8 = v48;
			x7 = v46;
		} break;
		default: {
			int64_t v49 = mw_std_byte_Byte_isZ_nameZ_byte(v5);
			VAL x50;
			VAL x51;
			if (((bool)v49)) {
				VAL v52 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(v6));
				VAL v53 = (mw_mirth_lexer_lexerZ_emitZ_nameZBang(v52));
				x51 = v53;
				x50 = x1;
			} else {
				STR* v54;
				STRLIT(v54, "Unrecognized byte.", 18);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v54), x1, v6);
				VAL r55 = pop_resource();
				x51 = r55;
				VAL r56 = pop_resource();
				x50 = r56;
			}
			x8 = x51;
			x7 = x50;
		} break;
	}
	*x4 = x8;
	*x3 = x7;
}
static VAL mw_mirth_lexer_lexerZ_newlineZBang (VAL x1) {
	int64_t v2 = VI64(VTUP(x1)->cells[2]);
	int64_t v3 = mw_mirth_location_Row_ZToInt(v2);
	int64_t v4 = 1LL;
	int64_t v5 = i64_add(v3, v4);
	int64_t v6 = mw_std_prim_Int_ZToRow(v5);
	VTUP(x1)->cells[2] = MKI64(v6);
	int64_t v7 = 0LL;
	int64_t v8 = mw_std_prim_Int_ZToCol(v7);
	VTUP(x1)->cells[3] = MKI64(v8);
	return x1;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lcolonZBang (VAL x1) {
	VAL v2 = MKI64(5LL /* TokenLColonOpen */);
	uint64_t v3;
	VAL v4;
	mw_mirth_lexer_lexerZ_makeZBang(v2, x1, &v3, &v4);
	VAL v5 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v3, v4));
	return v5;
}
static VAL mw_mirth_lexer_lexerZ_closeZ_colonsZBang (VAL x1) {
	VAL v2;
	VAL v3;
	mw_mirth_lexer_lexerZ_stackZ_peek(x1, &v2, &v3);
	VAL x4;
	VAL x5;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v2);
			incref(v6);
			int64_t v7 = mw_mirth_token_Token_lcolonZ_openZAsk(VU64(v6));
			VAL x8;
			VAL x9;
			if (((bool)v7)) {
				VAL v10 = mtw_std_maybe_Maybe_1_Some(v6);
				x9 = v10;
				x8 = v3;
			} else {
				decref(v6);
				VAL v11 = MKI64(0LL /* None */);
				x9 = v11;
				x8 = v3;
			}
			x5 = x9;
			x4 = x8;
		} break;
		case 0LL: { // None
			VAL v12 = MKI64(0LL /* None */);
			x5 = v12;
			x4 = v3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x13;
	int64_t x14;
	switch (get_data_tag(x5)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(x5);
			VAL v16 = (mw_mirth_lexer_lexerZ_stackZ_drop(x4));
			incref(v15);
			VAL v17 = mtw_mirth_token_TokenValue_TokenRColon(VU64(v15));
			uint64_t v18;
			VAL v19;
			mw_mirth_lexer_lexerZ_makeZBang(v17, v16, &v18, &v19);
			VAL v20 = mtw_mirth_token_TokenValue_TokenLColon(v18);
			void* v21 = mfld_mirth_token_Token_ZTildevalue(VU64(v15));
			mut_set(v20, v21);
			int64_t v22 = 1LL /* True */;
			x14 = v22;
			x13 = v19;
		} break;
		case 0LL: { // None
			int64_t v23 = 0LL /* False */;
			x14 = v23;
			x13 = x4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v24 = (x13);
	int64_t v25 = x14;
	while (((bool)v25)) {
		VAL v26 = (v24);
		VAL v27;
		VAL v28;
		mw_mirth_lexer_lexerZ_stackZ_peek(v26, &v27, &v28);
		VAL x29;
		VAL x30;
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v27);
				incref(v31);
				int64_t v32 = mw_mirth_token_Token_lcolonZ_openZAsk(VU64(v31));
				VAL x33;
				VAL x34;
				if (((bool)v32)) {
					VAL v35 = mtw_std_maybe_Maybe_1_Some(v31);
					x34 = v35;
					x33 = v28;
				} else {
					decref(v31);
					VAL v36 = MKI64(0LL /* None */);
					x34 = v36;
					x33 = v28;
				}
				x30 = x34;
				x29 = x33;
			} break;
			case 0LL: { // None
				VAL v37 = MKI64(0LL /* None */);
				x30 = v37;
				x29 = v28;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL x38;
		int64_t x39;
		switch (get_data_tag(x30)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(x30);
				VAL v41 = (mw_mirth_lexer_lexerZ_stackZ_drop(x29));
				incref(v40);
				VAL v42 = mtw_mirth_token_TokenValue_TokenRColon(VU64(v40));
				uint64_t v43;
				VAL v44;
				mw_mirth_lexer_lexerZ_makeZBang(v42, v41, &v43, &v44);
				VAL v45 = mtw_mirth_token_TokenValue_TokenLColon(v43);
				void* v46 = mfld_mirth_token_Token_ZTildevalue(VU64(v40));
				mut_set(v45, v46);
				int64_t v47 = 1LL /* True */;
				x39 = v47;
				x38 = v44;
			} break;
			case 0LL: { // None
				int64_t v48 = 0LL /* False */;
				x39 = v48;
				x38 = x29;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v25 = x39;
		v24 = x38;
	}
	return v24;
}
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang (VAL x1) {
	uint64_t v2 = VU64(VTUP(x1)->cells[5]);
	int64_t v3 = mw_mirth_token_Token_lcolonZ_openZAsk(v2);
	VAL x4;
	if (((bool)v3)) {
		x4 = x1;
	} else {
		VAL v5 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(x1));
		x4 = v5;
	}
	return x4;
}
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang (VAL x1) {
	uint64_t v2 = VU64(VTUP(x1)->cells[5]);
	VAL v3 = mw_mirth_token_Token_nameZDivdnameZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			decref(v5);
			x4 = x1;
		} break;
		case 0LL: { // None
			VAL v6 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(x1));
			x4 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lparenZBang (VAL x1) {
	VAL v2 = MKI64(2LL /* TokenLParenOpen */);
	uint64_t v3;
	VAL v4;
	mw_mirth_lexer_lexerZ_makeZBang(v2, x1, &v3, &v4);
	VAL v5 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v3, v4));
	return v5;
}
static void mw_mirth_lexer_lexerZ_emitZ_rparenZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v5)) {
		case 0LL: { // None
			STR* v9;
			STRLIT(v9, "Mismatched right parenthesis.", 29);
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v9), x1, v6);
			VAL r10 = pop_resource();
			x8 = r10;
			VAL r11 = pop_resource();
			x7 = r11;
		} break;
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v12);
			int64_t v13 = mw_mirth_token_Token_lparenZ_openZAsk(VU64(v12));
			VAL x14;
			VAL x15;
			if (((bool)v13)) {
				incref(v12);
				VAL v16 = mtw_mirth_token_TokenValue_TokenRParen(VU64(v12));
				uint64_t v17;
				VAL v18;
				mw_mirth_lexer_lexerZ_makeZBang(v16, v6, &v17, &v18);
				VAL v19 = mtw_mirth_token_TokenValue_TokenLParen(v17);
				void* v20 = mfld_mirth_token_Token_ZTildevalue(VU64(v12));
				mut_set(v19, v20);
				x15 = v18;
				x14 = x1;
			} else {
				STR* v21;
				STRLIT(v21, "Mismatched right parenthesis.", 29);
				push_value(v12);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v21), x1, v6);
				VAL r22 = pop_resource();
				x15 = r22;
				VAL r23 = pop_resource();
				x14 = r23;
			}
			x8 = x15;
			x7 = x14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lsquareZBang (VAL x1) {
	VAL v2 = MKI64(3LL /* TokenLSquareOpen */);
	uint64_t v3;
	VAL v4;
	mw_mirth_lexer_lexerZ_makeZBang(v2, x1, &v3, &v4);
	VAL v5 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v3, v4));
	return v5;
}
static void mw_mirth_lexer_lexerZ_emitZ_rsquareZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v5)) {
		case 0LL: { // None
			STR* v9;
			STRLIT(v9, "Mismatched right square bracket.", 32);
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v9), x1, v6);
			VAL r10 = pop_resource();
			x8 = r10;
			VAL r11 = pop_resource();
			x7 = r11;
		} break;
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v12);
			int64_t v13 = mw_mirth_token_Token_lsquareZ_openZAsk(VU64(v12));
			VAL x14;
			VAL x15;
			if (((bool)v13)) {
				incref(v12);
				VAL v16 = mtw_mirth_token_TokenValue_TokenRSquare(VU64(v12));
				uint64_t v17;
				VAL v18;
				mw_mirth_lexer_lexerZ_makeZBang(v16, v6, &v17, &v18);
				VAL v19 = mtw_mirth_token_TokenValue_TokenLSquare(v17);
				void* v20 = mfld_mirth_token_Token_ZTildevalue(VU64(v12));
				mut_set(v19, v20);
				x15 = v18;
				x14 = x1;
			} else {
				STR* v21;
				STRLIT(v21, "Mismatched right square bracket.", 32);
				push_value(v12);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v21), x1, v6);
				VAL r22 = pop_resource();
				x15 = r22;
				VAL r23 = pop_resource();
				x14 = r23;
			}
			x8 = x15;
			x7 = x14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang (VAL x1) {
	VAL v2 = MKI64(4LL /* TokenLCurlyOpen */);
	uint64_t v3;
	VAL v4;
	mw_mirth_lexer_lexerZ_makeZBang(v2, x1, &v3, &v4);
	VAL v5 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v3, v4));
	return v5;
}
static void mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v5)) {
		case 0LL: { // None
			STR* v9;
			STRLIT(v9, "Mismatched right curly brace.", 29);
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v9), x1, v6);
			VAL r10 = pop_resource();
			x8 = r10;
			VAL r11 = pop_resource();
			x7 = r11;
		} break;
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v12);
			int64_t v13 = mw_mirth_token_Token_lcurlyZ_openZAsk(VU64(v12));
			VAL x14;
			VAL x15;
			if (((bool)v13)) {
				incref(v12);
				VAL v16 = mtw_mirth_token_TokenValue_TokenRCurly(VU64(v12));
				uint64_t v17;
				VAL v18;
				mw_mirth_lexer_lexerZ_makeZBang(v16, v6, &v17, &v18);
				VAL v19 = mtw_mirth_token_TokenValue_TokenLCurly(v17);
				void* v20 = mfld_mirth_token_Token_ZTildevalue(VU64(v12));
				mut_set(v19, v20);
				x15 = v18;
				x14 = x1;
			} else {
				STR* v21;
				STRLIT(v21, "Mismatched right curly brace.", 29);
				push_value(v12);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v21), x1, v6);
				VAL r22 = pop_resource();
				x15 = r22;
				VAL r23 = pop_resource();
				x14 = r23;
			}
			x8 = x15;
			x7 = x14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_nameZBang (VAL x1) {
	STR* v2;
	STRLIT(v2, "", 0);
	uint64_t v3 = VU64(VTUP(x1)->cells[1]);
	int64_t v4 = VI64(VTUP(x1)->cells[2]);
	int64_t v5 = VI64(VTUP(x1)->cells[3]);
	int64_t v6;
	VAL v7;
	mw_mirth_lexer_lexerZ_peek(x1, &v6, &v7);
	int64_t v8 = mw_std_byte_Byte_isZ_nameZ_byte(v6);
	STR* v9 = (v2);
	uint64_t v10 = v3;
	int64_t v11 = v4;
	int64_t v12 = v5;
	VAL v13 = (v7);
	int64_t v14 = v6;
	int64_t v15 = v8;
	while (((bool)v15)) {
		STR* v16 = (v9);
		uint64_t v17 = v10;
		int64_t v18 = v11;
		int64_t v19 = v12;
		VAL v20 = (v13);
		int64_t v21 = v14;
		VAL v22 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(v21, MKSTR(v16)));
		VAL v23 = (mw_mirth_lexer_lexerZ_moveZBang(v20));
		int64_t v24;
		VAL v25;
		mw_mirth_lexer_lexerZ_peek(v23, &v24, &v25);
		int64_t v26 = mw_std_byte_Byte_isZ_nameZ_byte(v24);
		v15 = v26;
		v14 = v24;
		v13 = v25;
		v12 = v19;
		v11 = v18;
		v10 = v17;
		v9 = VSTR(v22);
	}
	int64_t v27;
	VAL v28;
	mw_std_str_ZPlusStr_isZ_docZ_startZAsk(MKSTR(v9), &v27, &v28);
	VAL x29;
	VAL x30;
	if (((bool)v27)) {
		VAL v31 = (mw_mirth_lexer_lexerZ_skipZ_docZBang(v13));
		x30 = v31;
		x29 = v28;
	} else {
		int64_t v32;
		VAL v33;
		mw_std_str_ZPlusStr_isZ_floatZAsk(v28, &v32, &v33);
		uint64_t x34;
		int64_t x35;
		int64_t x36;
		VAL x37;
		VAL x38;
		if (((bool)v32)) {
			double v39;
			VAL v40;
			mw_std_str_ZPlusStr_floatZAsk(v33, &v39, &v40);
			VAL v41 = mtw_mirth_token_TokenValue_TokenF64(v39);
			x38 = v41;
			x37 = v40;
			x36 = v12;
			x35 = v11;
			x34 = v10;
		} else {
			int64_t v42;
			VAL v43;
			mw_std_str_ZPlusStr_isZ_intZAsk(v33, &v42, &v43);
			uint64_t x44;
			int64_t x45;
			int64_t x46;
			VAL x47;
			VAL x48;
			if (((bool)v42)) {
				int64_t v49;
				VAL v50;
				mw_std_str_ZPlusStr_intZAsk(v43, &v49, &v50);
				VAL v51 = mtw_mirth_token_TokenValue_TokenInt(v49);
				x48 = v51;
				x47 = v50;
				x46 = v12;
				x45 = v11;
				x44 = v10;
			} else {
				VAL v52;
				VAL v53;
				mw_std_str_ZPlusStr_dnameZAsk(v43, &v52, &v53);
				uint64_t x54;
				int64_t x55;
				int64_t x56;
				VAL x57;
				VAL x58;
				switch (get_data_tag(v52)) {
					case 1LL: { // Some
						VAL v59 = mtp_std_maybe_Maybe_1_Some(v52);
						VAL v60 = mtw_mirth_token_TokenValue_TokenDName(v59);
						x58 = v60;
						x57 = v53;
						x56 = v12;
						x55 = v11;
						x54 = v10;
					} break;
					case 0LL: { // None
						VAL v61;
						VAL v62;
						mw_std_str_ZPlusStr_labelZ_tokenZAsk(v53, &v61, &v62);
						uint64_t x63;
						int64_t x64;
						int64_t x65;
						VAL x66;
						VAL x67;
						switch (get_data_tag(v61)) {
							case 1LL: { // Some
								VAL v68 = mtp_std_maybe_Maybe_1_Some(v61);
								x67 = v68;
								x66 = v62;
								x65 = v12;
								x64 = v11;
								x63 = v10;
							} break;
							case 0LL: { // None
								uint64_t v69;
								VAL v70;
								mw_std_str_ZPlusStr_nameZAsk(v62, &v69, &v70);
								VAL v71 = mtw_mirth_token_TokenValue_TokenName(v69);
								x67 = v71;
								x66 = v70;
								x65 = v12;
								x64 = v11;
								x63 = v10;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						x58 = x67;
						x57 = x66;
						x56 = x65;
						x55 = x64;
						x54 = x63;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x48 = x58;
				x47 = x57;
				x46 = x56;
				x45 = x55;
				x44 = x54;
			}
			x38 = x48;
			x37 = x47;
			x36 = x46;
			x35 = x45;
			x34 = x44;
		}
		uint64_t v72 = mw_mirth_token_Token_allocZBang();
		void* v73 = mfld_mirth_token_Token_ZTildevalue(v72);
		mut_set(x38, v73);
		void* v74 = mfld_mirth_token_Token_ZTildecol(v72);
		mut_set(MKI64(x36), v74);
		void* v75 = mfld_mirth_token_Token_ZTilderow(v72);
		mut_set(MKI64(x35), v75);
		void* v76 = mfld_mirth_token_Token_ZTildemodule(v72);
		mut_set(MKU64(x34), v76);
		VTUP(v13)->cells[5] = MKU64(v72);
		x30 = v13;
		x29 = x37;
	}
	decref(x29);
	return x30;
}
static void mw_std_str_ZPlusStr_nameZAsk (VAL x1, uint64_t *x2, VAL *x3) {
	VAL v4;
	VAL v5;
	mw_std_str_ZPlusStr_dupZBang(x1, &v4, &v5);
	uint64_t v6 = mw_std_prim_Str_ZToName(v4);
	*x3 = v5;
	*x2 = v6;
}
static void mw_std_str_ZPlusStr_firstZ_byte (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 0LL;
	int64_t v5;
	VAL v6;
	mw_std_str_ZPlusStr_byteZAt(v4, x1, &v5, &v6);
	*x3 = v6;
	*x2 = v5;
}
static void mw_std_str_ZPlusStr_secondZ_byte (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 1LL;
	int64_t v5;
	VAL v6;
	mw_std_str_ZPlusStr_byteZAt(v4, x1, &v5, &v6);
	*x3 = v6;
	*x2 = v5;
}
static void mw_std_str_ZPlusStr_thirdZ_byte (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 2LL;
	int64_t v5;
	VAL v6;
	mw_std_str_ZPlusStr_byteZAt(v4, x1, &v5, &v6);
	*x3 = v6;
	*x2 = v5;
}
static void mw_std_str_ZPlusStr_firstZ_twoZ_bytes (VAL x1, int64_t x2, VAL *x3, VAL *x4, int64_t *x5) {
	int64_t v6 = 2LL;
	VAL v7;
	VAL v8;
	int64_t v9;
	mw_std_str_ZPlusStr_takeZ_slice(v6, x1, x2, &v7, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
	*x3 = v7;
}
static void mw_std_str_ZPlusStr_dropZ_firstZ_byte (VAL x1, int64_t x2, VAL *x3, VAL *x4, int64_t *x5) {
	int64_t v6 = 1LL;
	VAL v7;
	VAL v8;
	int64_t v9;
	mw_std_str_ZPlusStr_dropZ_slice(v6, x1, x2, &v7, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
	*x3 = v7;
}
static void mw_std_str_ZPlusStr_dropZ_lastZ_byte (VAL x1, int64_t x2, VAL *x3, VAL *x4, int64_t *x5) {
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x1, &v6, &v7);
	int64_t v8 = 1LL;
	int64_t v9 = i64_sub(v6, v8);
	int64_t v10 = 0LL;
	bool v11 = (v9 < v10);
	int64_t x12;
	if (v11) {
		int64_t v13 = 0LL;
		x12 = v13;
		push_resource(v7);
		push_resource(MKI64(x2));
	} else {
		x12 = v9;
		push_resource(v7);
		push_resource(MKI64(x2));
	}
	int64_t r14 = VI64(pop_resource());
	VAL r15 = pop_resource();
	VAL v16;
	VAL v17;
	int64_t v18;
	mw_std_str_ZPlusStr_takeZ_slice(x12, r15, r14, &v16, &v17, &v18);
	*x5 = v18;
	*x4 = v17;
	*x3 = v16;
}
static void mw_std_str_ZPlusStr_labelZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	VAL v4;
	VAL v5;
	mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk(x1, &v4, &v5);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v4);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			x7 = v9;
			x6 = v5;
		} break;
		case 0LL: { // None
			VAL v10;
			VAL v11;
			mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk(v5, &v10, &v11);
			x7 = v10;
			x6 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x12;
	VAL x13;
	switch (get_data_tag(x7)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(x7);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
			x13 = v15;
			x12 = x6;
		} break;
		case 0LL: { // None
			VAL v16;
			VAL v17;
			mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk(x6, &v16, &v17);
			x13 = v16;
			x12 = v17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x18;
	VAL x19;
	switch (get_data_tag(x13)) {
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(x13);
			VAL v21 = mtw_std_maybe_Maybe_1_Some(v20);
			x19 = v21;
			x18 = x12;
		} break;
		case 0LL: { // None
			VAL v22;
			VAL v23;
			mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk(x12, &v22, &v23);
			x19 = v22;
			x18 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x24;
	VAL x25;
	switch (get_data_tag(x19)) {
		case 1LL: { // Some
			VAL v26 = mtp_std_maybe_Maybe_1_Some(x19);
			VAL v27 = mtw_std_maybe_Maybe_1_Some(v26);
			x25 = v27;
			x24 = x18;
		} break;
		case 0LL: { // None
			VAL v28;
			VAL v29;
			mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk(x18, &v28, &v29);
			x25 = v28;
			x24 = v29;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x30;
	VAL x31;
	switch (get_data_tag(x25)) {
		case 1LL: { // Some
			VAL v32 = mtp_std_maybe_Maybe_1_Some(x25);
			VAL v33 = mtw_std_maybe_Maybe_1_Some(v32);
			x31 = v33;
			x30 = x24;
		} break;
		case 0LL: { // None
			VAL v34;
			VAL v35;
			mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk(x24, &v34, &v35);
			x31 = v34;
			x30 = v35;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x30;
	*x2 = x31;
}
static void mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_firstZ_byte(x1, &v4, &v5);
	int64_t v6 = mw_std_byte_Byte_isZ_lower(v4);
	VAL x7;
	int64_t x8;
	if (((bool)v6)) {
		int64_t v9;
		VAL v10;
		mw_std_str_ZPlusStr_lastZ_byte(v5, &v9, &v10);
		int64_t v11 = 62LL /* B'>' */;
		bool v12 = (v9 == v11);
		x8 = ((int64_t)v12);
		x7 = v10;
	} else {
		int64_t v13 = 0LL /* False */;
		x8 = v13;
		x7 = v5;
	}
	VAL x14;
	VAL x15;
	if (((bool)x8)) {
		int64_t v16 = (0LL /* +Unsafe */);
		VAL v17;
		VAL v18;
		int64_t v19;
		mw_std_str_ZPlusStr_dropZ_lastZ_byte(x7, v16, &v17, &v18, &v19);
		uint64_t v20 = mw_std_prim_Str_ZToName(v17);
		uint64_t v21 = mw_mirth_label_Label_newZBang(v20);
		VAL v22 = mtw_mirth_token_TokenValue_TokenLabelPop(v21);
		VAL v23 = mtw_std_maybe_Maybe_1_Some(v22);
		x15 = v23;
		x14 = v18;
	} else {
		VAL v24 = MKI64(0LL /* None */);
		x15 = v24;
		x14 = x7;
	}
	*x3 = x14;
	*x2 = x15;
}
static void mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_firstZ_byte(x1, &v4, &v5);
	int64_t v6 = 43LL /* B'+' */;
	bool v7 = (v4 == v6);
	VAL x8;
	int64_t x9;
	if (v7) {
		int64_t v10;
		VAL v11;
		mw_std_str_ZPlusStr_secondZ_byte(v5, &v10, &v11);
		int64_t v12 = mw_std_byte_Byte_isZ_lower(v10);
		VAL x13;
		int64_t x14;
		if (((bool)v12)) {
			int64_t v15;
			VAL v16;
			mw_std_str_ZPlusStr_lastZ_byte(v11, &v15, &v16);
			int64_t v17 = 62LL /* B'>' */;
			bool v18 = (v15 == v17);
			x14 = ((int64_t)v18);
			x13 = v16;
		} else {
			int64_t v19 = 0LL /* False */;
			x14 = v19;
			x13 = v11;
		}
		x9 = x14;
		x8 = x13;
	} else {
		int64_t v20 = 0LL /* False */;
		x9 = v20;
		x8 = v5;
	}
	VAL x21;
	VAL x22;
	if (((bool)x9)) {
		int64_t v23 = (0LL /* +Unsafe */);
		VAL v24;
		VAL v25;
		int64_t v26;
		mw_std_str_ZPlusStr_dropZ_lastZ_byte(x8, v23, &v24, &v25, &v26);
		uint64_t v27 = mw_std_prim_Str_ZToName(v24);
		uint64_t v28 = mw_mirth_label_Label_newZBang(v27);
		VAL v29 = mtw_mirth_token_TokenValue_TokenLabelPopR(v28);
		VAL v30 = mtw_std_maybe_Maybe_1_Some(v29);
		x22 = v30;
		x21 = v25;
	} else {
		VAL v31 = MKI64(0LL /* None */);
		x22 = v31;
		x21 = x8;
	}
	*x3 = x21;
	*x2 = x22;
}
static void mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_firstZ_byte(x1, &v4, &v5);
	int64_t v6 = 62LL /* B'>' */;
	bool v7 = (v4 == v6);
	VAL x8;
	int64_t x9;
	if (v7) {
		int64_t v10;
		VAL v11;
		mw_std_str_ZPlusStr_secondZ_byte(v5, &v10, &v11);
		int64_t v12 = mw_std_byte_Byte_isZ_lower(v10);
		x9 = v12;
		x8 = v11;
	} else {
		int64_t v13 = 0LL /* False */;
		x9 = v13;
		x8 = v5;
	}
	VAL x14;
	VAL x15;
	if (((bool)x9)) {
		int64_t v16 = (0LL /* +Unsafe */);
		VAL v17;
		VAL v18;
		int64_t v19;
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(x8, v16, &v17, &v18, &v19);
		uint64_t v20 = mw_std_prim_Str_ZToName(v17);
		uint64_t v21 = mw_mirth_label_Label_newZBang(v20);
		VAL v22 = mtw_mirth_token_TokenValue_TokenLabelPush(v21);
		VAL v23 = mtw_std_maybe_Maybe_1_Some(v22);
		x15 = v23;
		x14 = v18;
	} else {
		VAL v24 = MKI64(0LL /* None */);
		x15 = v24;
		x14 = x8;
	}
	*x3 = x14;
	*x2 = x15;
}
static void mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4 = (0LL /* +Unsafe */);
	VAL v5;
	VAL v6;
	int64_t v7;
	mw_std_str_ZPlusStr_firstZ_twoZ_bytes(x1, v4, &v5, &v6, &v7);
	STR* v8;
	STRLIT(v8, ">+", 2);
	bool v9 = (str_cmp(VSTR(v5), v8) == 0);
	VAL x10;
	int64_t x11;
	if (v9) {
		int64_t v12;
		VAL v13;
		mw_std_str_ZPlusStr_thirdZ_byte(v6, &v12, &v13);
		int64_t v14 = mw_std_byte_Byte_isZ_lower(v12);
		x11 = v14;
		x10 = v13;
	} else {
		int64_t v15 = 0LL /* False */;
		x11 = v15;
		x10 = v6;
	}
	VAL x16;
	VAL x17;
	if (((bool)x11)) {
		int64_t v18 = (0LL /* +Unsafe */);
		VAL v19;
		VAL v20;
		int64_t v21;
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(x10, v18, &v19, &v20, &v21);
		uint64_t v22 = mw_std_prim_Str_ZToName(v19);
		uint64_t v23 = mw_mirth_label_Label_newZBang(v22);
		VAL v24 = mtw_mirth_token_TokenValue_TokenLabelPushR(v23);
		VAL v25 = mtw_std_maybe_Maybe_1_Some(v24);
		x17 = v25;
		x16 = v20;
	} else {
		VAL v26 = MKI64(0LL /* None */);
		x17 = v26;
		x16 = x10;
	}
	*x3 = x16;
	*x2 = x17;
}
static void mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_firstZ_byte(x1, &v4, &v5);
	int64_t v6 = 64LL /* B'@' */;
	bool v7 = (v4 == v6);
	VAL x8;
	int64_t x9;
	if (v7) {
		int64_t v10;
		VAL v11;
		mw_std_str_ZPlusStr_secondZ_byte(v5, &v10, &v11);
		int64_t v12 = mw_std_byte_Byte_isZ_lower(v10);
		VAL x13;
		int64_t x14;
		if (((bool)v12)) {
			int64_t v15 = 1LL /* True */;
			x14 = v15;
			x13 = v11;
		} else {
			int64_t v16;
			VAL v17;
			mw_std_str_ZPlusStr_secondZ_byte(v11, &v16, &v17);
			int64_t v18 = 43LL /* B'+' */;
			bool v19 = (v16 == v18);
			VAL x20;
			int64_t x21;
			if (v19) {
				int64_t v22;
				VAL v23;
				mw_std_str_ZPlusStr_thirdZ_byte(v17, &v22, &v23);
				int64_t v24 = mw_std_byte_Byte_isZ_lower(v22);
				x21 = v24;
				x20 = v23;
			} else {
				int64_t v25 = 0LL /* False */;
				x21 = v25;
				x20 = v17;
			}
			x14 = x21;
			x13 = x20;
		}
		x9 = x14;
		x8 = x13;
	} else {
		int64_t v26 = 0LL /* False */;
		x9 = v26;
		x8 = v5;
	}
	VAL x27;
	VAL x28;
	if (((bool)x9)) {
		int64_t v29 = (0LL /* +Unsafe */);
		VAL v30;
		VAL v31;
		int64_t v32;
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(x8, v29, &v30, &v31, &v32);
		uint64_t v33 = mw_std_prim_Str_ZToName(v30);
		uint64_t v34 = mw_mirth_label_Label_newZBang(v33);
		VAL v35 = mtw_mirth_token_TokenValue_TokenLabelGet(v34);
		VAL v36 = mtw_std_maybe_Maybe_1_Some(v35);
		x28 = v36;
		x27 = v31;
	} else {
		VAL v37 = MKI64(0LL /* None */);
		x28 = v37;
		x27 = x8;
	}
	*x3 = x27;
	*x2 = x28;
}
static void mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_firstZ_byte(x1, &v4, &v5);
	int64_t v6 = 33LL /* B'!' */;
	bool v7 = (v4 == v6);
	VAL x8;
	int64_t x9;
	if (v7) {
		int64_t v10;
		VAL v11;
		mw_std_str_ZPlusStr_secondZ_byte(v5, &v10, &v11);
		int64_t v12 = mw_std_byte_Byte_isZ_lower(v10);
		x9 = v12;
		x8 = v11;
	} else {
		int64_t v13 = 0LL /* False */;
		x9 = v13;
		x8 = v5;
	}
	VAL x14;
	VAL x15;
	if (((bool)x9)) {
		int64_t v16 = (0LL /* +Unsafe */);
		VAL v17;
		VAL v18;
		int64_t v19;
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(x8, v16, &v17, &v18, &v19);
		uint64_t v20 = mw_std_prim_Str_ZToName(v17);
		uint64_t v21 = mw_mirth_label_Label_newZBang(v20);
		VAL v22 = mtw_mirth_token_TokenValue_TokenLabelSet(v21);
		VAL v23 = mtw_std_maybe_Maybe_1_Some(v22);
		x15 = v23;
		x14 = v18;
	} else {
		VAL v24 = MKI64(0LL /* None */);
		x15 = v24;
		x14 = x8;
	}
	*x3 = x14;
	*x2 = x15;
}
static void mw_std_str_ZPlusStr_dnameZAsk (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4 = 46LL /* BDOT */;
	VAL v5;
	VAL v6;
	mw_std_str_ZPlusStr_splitZ_byte(v4, x1, &v5, &v6);
	VAL v7;
	VAL v8;
	mw_std_list_ListZPlus_1_uncons(v5, &v7, &v8);
	VAL v9 = mw_std_list_List_1_ZToListZPlus(v8);
	VAL x10;
	VAL x11;
	switch (get_data_tag(v9)) {
		case 0LL: { // None
			decref(v7);
			VAL v12 = MKI64(0LL /* None */);
			x11 = v12;
			x10 = v6;
		} break;
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
			incref(v7);
			uint64_t v14 = str_size(VSTR(v7));
			int64_t v15 = 0LL;
			bool v16 = (((int64_t)v14) < v15);
			int64_t x17;
			if (v16) {
				x17 = v15;
				push_resource(v6);
				push_value(v7);
			} else {
				x17 = ((int64_t)v14);
				push_resource(v6);
				push_value(v7);
			}
			int64_t v18 = 0LL;
			bool v19 = (x17 == v18);
			VAL x20;
			VAL x21;
			if (v19) {
				VAL v22 = pop_value();
				decref(v22);
				VAL v23 = MKI64(0LL /* None */);
				x21 = v23;
				VAL r24 = pop_resource();
				x20 = r24;
			} else {
				VAL v25 = pop_value();
				uint64_t v26 = mw_std_prim_Str_ZToName(v25);
				VAL v27 = mtw_std_maybe_Maybe_1_Some(MKU64(v26));
				x21 = v27;
				VAL r28 = pop_resource();
				x20 = r28;
			}
			VAL v29;
			VAL v30;
			mw_std_list_ListZPlus_1_uncons(v13, &v29, &v30);
			uint64_t v31 = mw_std_prim_Str_ZToName(v29);
			VAL v32 = MKI64(0LL /* Nil */);
			VAL v33 = mw_std_list_List_1_reverse(v32);
			VAL v34;
			VAL v35;
			mw_std_list_List_1_uncons(v30, &v34, &v35);
			VAL x36;
			VAL x37;
			VAL x38;
			VAL x39;
			int64_t x40;
			switch (get_data_tag(v34)) {
				case 1LL: { // Some
					VAL v41 = mtp_std_maybe_Maybe_1_Some(v34);
					uint64_t v42 = mw_std_prim_Str_ZToName(v41);
					VAL v43 = mtw_std_list_List_1_Cons(MKU64(v42), v33);
					int64_t v44 = 1LL /* True */;
					x40 = v44;
					x39 = v35;
					x38 = v43;
					x37 = x21;
					x36 = x20;
				} break;
				case 0LL: { // None
					int64_t v45 = 0LL /* False */;
					x40 = v45;
					x39 = v35;
					x38 = v33;
					x37 = x21;
					x36 = x20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v46 = (x36);
			VAL v47 = x37;
			VAL v48 = (x38);
			VAL v49 = x39;
			int64_t v50 = x40;
			while (((bool)v50)) {
				VAL v51 = (v46);
				VAL v52 = v47;
				VAL v53 = (v48);
				VAL v54 = v49;
				VAL v55;
				VAL v56;
				mw_std_list_List_1_uncons(v54, &v55, &v56);
				VAL x57;
				VAL x58;
				VAL x59;
				VAL x60;
				int64_t x61;
				switch (get_data_tag(v55)) {
					case 1LL: { // Some
						VAL v62 = mtp_std_maybe_Maybe_1_Some(v55);
						uint64_t v63 = mw_std_prim_Str_ZToName(v62);
						VAL v64 = mtw_std_list_List_1_Cons(MKU64(v63), v53);
						int64_t v65 = 1LL /* True */;
						x61 = v65;
						x60 = v56;
						x59 = v64;
						x58 = v52;
						x57 = v51;
					} break;
					case 0LL: { // None
						int64_t v66 = 0LL /* False */;
						x61 = v66;
						x60 = v56;
						x59 = v53;
						x58 = v52;
						x57 = v51;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v50 = x61;
				v49 = x60;
				v48 = x59;
				v47 = x58;
				v46 = x57;
			}
			decref(v49);
			VAL v67 = mw_std_list_List_1_reverse(v48);
			VAL v68 = mtw_std_list_ListZPlus_1_ListZPlus(MKU64(v31), v67);
			VAL v69 = mtw_mirth_name_DName_DName(v47, v68);
			VAL v70 = mtw_std_maybe_Maybe_1_Some(v69);
			x11 = v70;
			x10 = v46;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x10;
	*x2 = x11;
}
static void mw_std_str_ZPlusStr_isZ_docZ_startZAsk (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4;
	VAL v5;
	mw_std_str_ZPlusStr_dupZBang(x1, &v4, &v5);
	STR* v6;
	STRLIT(v6, "|||", 3);
	bool v7 = (str_cmp(VSTR(v4), v6) == 0);
	*x3 = v5;
	*x2 = ((int64_t)v7);
}
static void mw_std_str_ZPlusStr_isZ_floatZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 0LL;
	int64_t v5 = 0LL;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_byteZAt(v5, x1, &v6, &v7);
	int64_t v8 = mw_std_byte_Byte_isZ_sign(v6);
	int64_t x9;
	VAL x10;
	int64_t x11;
	if (((bool)v8)) {
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v5, v12);
		x11 = v13;
		x10 = v7;
		x9 = v4;
	} else {
		x11 = v5;
		x10 = v7;
		x9 = v4;
	}
	int64_t v14;
	VAL v15;
	mw_std_str_ZPlusStr_byteZAt(x11, x10, &v14, &v15);
	int64_t v16 = mw_std_byte_Byte_isZ_digit(v14);
	int64_t v17 = x9;
	int64_t v18 = x11;
	VAL v19 = (v15);
	int64_t v20 = v16;
	while (((bool)v20)) {
		int64_t v21 = v17;
		int64_t v22 = v18;
		VAL v23 = (v19);
		int64_t v24 = 1LL;
		int64_t v25 = i64_add(v21, v24);
		int64_t v26 = 1LL;
		int64_t v27 = i64_add(v22, v26);
		int64_t v28;
		VAL v29;
		mw_std_str_ZPlusStr_byteZAt(v27, v23, &v28, &v29);
		int64_t v30 = mw_std_byte_Byte_isZ_digit(v28);
		v20 = v30;
		v19 = v29;
		v18 = v27;
		v17 = v25;
	}
	int64_t v31;
	VAL v32;
	mw_std_str_ZPlusStr_byteZAt(v18, v19, &v31, &v32);
	int64_t v33 = 46LL /* BDOT */;
	bool v34 = (v31 == v33);
	VAL x35;
	int64_t x36;
	if (v34) {
		int64_t v37 = 1LL;
		int64_t v38 = i64_add(v17, v37);
		int64_t v39 = 1LL;
		int64_t v40 = i64_add(v18, v39);
		int64_t v41;
		VAL v42;
		mw_std_str_ZPlusStr_byteZAt(v40, v32, &v41, &v42);
		int64_t v43 = mw_std_byte_Byte_isZ_digit(v41);
		int64_t v44 = v38;
		int64_t v45 = v40;
		VAL v46 = (v42);
		int64_t v47 = v43;
		while (((bool)v47)) {
			int64_t v48 = v44;
			int64_t v49 = v45;
			VAL v50 = (v46);
			int64_t v51 = 1LL;
			int64_t v52 = i64_add(v48, v51);
			int64_t v53 = 1LL;
			int64_t v54 = i64_add(v49, v53);
			int64_t v55;
			VAL v56;
			mw_std_str_ZPlusStr_byteZAt(v54, v50, &v55, &v56);
			int64_t v57 = mw_std_byte_Byte_isZ_digit(v55);
			v47 = v57;
			v46 = v56;
			v45 = v54;
			v44 = v52;
		}
		int64_t v58 = 3LL;
		bool v59 = (v44 >= v58);
		VAL x60;
		int64_t x61;
		if (v59) {
			int64_t v62;
			VAL v63;
			mw_std_str_ZPlusStr_numZ_bytesZAsk(v46, &v62, &v63);
			bool v64 = (v45 == v62);
			x61 = ((int64_t)v64);
			x60 = v63;
		} else {
			int64_t v65 = 0LL /* False */;
			x61 = v65;
			x60 = v46;
		}
		x36 = x61;
		x35 = x60;
	} else {
		int64_t v66 = 0LL /* False */;
		x36 = v66;
		x35 = v32;
	}
	*x3 = x35;
	*x2 = x36;
}
static void mw_std_str_ZPlusStr_floatZ_sign (VAL x1, int64_t *x2, int64_t *x3, VAL *x4) {
	int64_t v5 = 0LL;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_byteZAt(v5, x1, &v6, &v7);
	int64_t v8;
	int64_t v9;
	mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float(v6, &v8, &v9);
	*x4 = v7;
	*x3 = v9;
	*x2 = v8;
}
static void mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float (int64_t x1, int64_t *x2, int64_t *x3) {
	int64_t x4;
	int64_t x5;
	switch (x1) {
		case 45LL: { // B'-'
			int64_t v6 = 45LL /* B'-' */;
			int64_t v7 = 1LL;
			x5 = v7;
			x4 = v6;
		} break;
		case 43LL: { // B'+'
			int64_t v8 = 43LL /* B'+' */;
			int64_t v9 = 1LL;
			x5 = v9;
			x4 = v8;
		} break;
		default: {
			int64_t v10 = 43LL /* B'+' */;
			int64_t v11 = 0LL;
			x5 = v11;
			x4 = v10;
		} break;
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_std_str_ZPlusStr_floatZAsk (VAL x1, double *x2, VAL *x3) {
	STR* v4;
	STRLIT(v4, "", 0);
	int64_t v5 = 0LL;
	int64_t v6;
	int64_t v7;
	VAL v8;
	mw_std_str_ZPlusStr_floatZ_sign(x1, &v6, &v7, &v8);
	VAL v9 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v6, MKSTR(v4)));
	int64_t v10 = i64_add(v5, v7);
	int64_t v11;
	VAL v12;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(v8, &v11, &v12);
	bool v13 = (v10 < v11);
	VAL v14 = (v9);
	int64_t v15 = v10;
	VAL v16 = (v12);
	bool v17 = v13;
	while (v17) {
		VAL v18 = (v14);
		int64_t v19 = v15;
		VAL v20 = (v16);
		int64_t v21;
		VAL v22;
		mw_std_str_ZPlusStr_byteZAt(v19, v20, &v21, &v22);
		VAL v23 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v21, v18));
		int64_t v24 = 1LL;
		int64_t v25 = i64_add(v19, v24);
		int64_t v26;
		VAL v27;
		mw_std_str_ZPlusStr_numZ_bytesZAsk(v22, &v26, &v27);
		bool v28 = (v25 < v26);
		v17 = v28;
		v16 = v27;
		v15 = v25;
		v14 = v23;
	}
	incref(v14);
	incref(v14);
	void* v29 = str_base(VSTR(v14));
	uint64_t v30 = str_size(VSTR(v14));
	int64_t v31 = 0LL;
	bool v32 = (((int64_t)v30) < v31);
	int64_t x33;
	if (v32) {
		x33 = v31;
		push_resource(v16);
		push_ptr(v29);
	} else {
		x33 = ((int64_t)v30);
		push_resource(v16);
		push_ptr(v29);
	}
	VAL v34 = pop_value();
	incref(v34);
	int64_t v35 = (0LL /* +Unsafe */);
	void* v36 = (void*)(x33 + (char*)VPTR(v34));
	uint8_t v37 = *(uint8_t*)v36;
	int64_t v38 = 0LL;
	bool v39 = (((int64_t)v37) == v38);
	void* x40;
	if (v39) {
		x40 = VPTR(v34);
	} else {
		STR* v41;
		STRLIT(v41, "tried to use Str as CStr, but Str is not zero terminated", 56);
		push_value(v34);
		do_panic(v41);
		void* v42 = pop_ptr();
		x40 = v42;
	}
	double v43 = mext_mirth_lexer_stringz_toz_float64(x40);
	decref(v14);
	VAL r44 = pop_resource();
	*x3 = r44;
	*x2 = v43;
}
static void mw_std_str_ZPlusStr_isZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_isZ_decZ_intZAsk(x1, &v4, &v5);
	VAL x6;
	int64_t x7;
	if (((bool)v4)) {
		int64_t v8 = 1LL /* True */;
		x7 = v8;
		x6 = v5;
	} else {
		int64_t v9;
		VAL v10;
		mw_std_str_ZPlusStr_isZ_hexZ_intZAsk(v5, &v9, &v10);
		x7 = v9;
		x6 = v10;
	}
	VAL x11;
	int64_t x12;
	if (((bool)x7)) {
		int64_t v13 = 1LL /* True */;
		x12 = v13;
		x11 = x6;
	} else {
		int64_t v14;
		VAL v15;
		mw_std_str_ZPlusStr_isZ_octZ_intZAsk(x6, &v14, &v15);
		x12 = v14;
		x11 = v15;
	}
	*x3 = x11;
	*x2 = x12;
}
static void mw_std_str_ZPlusStr_isZ_decZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 0LL;
	int64_t v5 = 0LL;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_byteZAt(v5, x1, &v6, &v7);
	int64_t v8 = mw_std_byte_Byte_isZ_sign(v6);
	int64_t x9;
	VAL x10;
	int64_t x11;
	if (((bool)v8)) {
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v5, v12);
		x11 = v13;
		x10 = v7;
		x9 = v4;
	} else {
		x11 = v5;
		x10 = v7;
		x9 = v4;
	}
	int64_t v14;
	VAL v15;
	mw_std_str_ZPlusStr_byteZAt(x11, x10, &v14, &v15);
	int64_t v16 = mw_std_byte_Byte_isZ_digit(v14);
	int64_t v17 = x9;
	int64_t v18 = x11;
	VAL v19 = (v15);
	int64_t v20 = v16;
	while (((bool)v20)) {
		int64_t v21 = v17;
		int64_t v22 = v18;
		VAL v23 = (v19);
		int64_t v24 = 1LL;
		int64_t v25 = i64_add(v21, v24);
		int64_t v26 = 1LL;
		int64_t v27 = i64_add(v22, v26);
		int64_t v28;
		VAL v29;
		mw_std_str_ZPlusStr_byteZAt(v27, v23, &v28, &v29);
		int64_t v30 = mw_std_byte_Byte_isZ_digit(v28);
		v20 = v30;
		v19 = v29;
		v18 = v27;
		v17 = v25;
	}
	int64_t v31 = 0LL;
	bool v32 = (v17 > v31);
	VAL x33;
	int64_t x34;
	if (v32) {
		int64_t v35;
		VAL v36;
		mw_std_str_ZPlusStr_numZ_bytesZAsk(v19, &v35, &v36);
		bool v37 = (v18 == v35);
		x34 = ((int64_t)v37);
		x33 = v36;
	} else {
		int64_t v38 = 0LL /* False */;
		x34 = v38;
		x33 = v19;
	}
	*x3 = x33;
	*x2 = x34;
}
static void mw_std_str_ZPlusStr_isZ_hexZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 0LL;
	int64_t v5 = 0LL;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_byteZAt(v5, x1, &v6, &v7);
	int64_t v8 = mw_std_byte_Byte_isZ_sign(v6);
	int64_t x9;
	VAL x10;
	int64_t x11;
	if (((bool)v8)) {
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v5, v12);
		x11 = v13;
		x10 = v7;
		x9 = v4;
	} else {
		x11 = v5;
		x10 = v7;
		x9 = v4;
	}
	int64_t v14;
	VAL v15;
	mw_std_str_ZPlusStr_byteZAt(x11, x10, &v14, &v15);
	int64_t v16 = 48LL /* B'0' */;
	bool v17 = (v14 == v16);
	VAL x18;
	int64_t x19;
	if (v17) {
		int64_t v20 = 1LL;
		int64_t v21 = i64_add(x11, v20);
		int64_t v22;
		VAL v23;
		mw_std_str_ZPlusStr_byteZAt(v21, v15, &v22, &v23);
		int64_t v24 = 120LL /* B'x' */;
		bool v25 = (v22 == v24);
		VAL x26;
		int64_t x27;
		if (v25) {
			int64_t v28 = 1LL;
			int64_t v29 = i64_add(v21, v28);
			int64_t v30;
			VAL v31;
			mw_std_str_ZPlusStr_byteZAt(v29, v23, &v30, &v31);
			int64_t v32 = mw_std_byte_Byte_isZ_hexdigit(v30);
			int64_t v33 = x9;
			int64_t v34 = v29;
			VAL v35 = (v31);
			int64_t v36 = v32;
			while (((bool)v36)) {
				int64_t v37 = v33;
				int64_t v38 = v34;
				VAL v39 = (v35);
				int64_t v40 = 1LL;
				int64_t v41 = i64_add(v37, v40);
				int64_t v42 = 1LL;
				int64_t v43 = i64_add(v38, v42);
				int64_t v44;
				VAL v45;
				mw_std_str_ZPlusStr_byteZAt(v43, v39, &v44, &v45);
				int64_t v46 = mw_std_byte_Byte_isZ_hexdigit(v44);
				v36 = v46;
				v35 = v45;
				v34 = v43;
				v33 = v41;
			}
			int64_t v47 = 0LL;
			bool v48 = (v33 > v47);
			VAL x49;
			int64_t x50;
			if (v48) {
				int64_t v51;
				VAL v52;
				mw_std_str_ZPlusStr_numZ_bytesZAsk(v35, &v51, &v52);
				bool v53 = (v34 == v51);
				x50 = ((int64_t)v53);
				x49 = v52;
			} else {
				int64_t v54 = 0LL /* False */;
				x50 = v54;
				x49 = v35;
			}
			x27 = x50;
			x26 = x49;
		} else {
			int64_t v55 = 0LL /* False */;
			x27 = v55;
			x26 = v23;
		}
		x19 = x27;
		x18 = x26;
	} else {
		int64_t v56 = 0LL /* False */;
		x19 = v56;
		x18 = v15;
	}
	*x3 = x18;
	*x2 = x19;
}
static void mw_std_str_ZPlusStr_isZ_octZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = 0LL;
	int64_t v5 = 0LL;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_byteZAt(v5, x1, &v6, &v7);
	int64_t v8 = mw_std_byte_Byte_isZ_sign(v6);
	int64_t x9;
	VAL x10;
	int64_t x11;
	if (((bool)v8)) {
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v5, v12);
		x11 = v13;
		x10 = v7;
		x9 = v4;
	} else {
		x11 = v5;
		x10 = v7;
		x9 = v4;
	}
	int64_t v14;
	VAL v15;
	mw_std_str_ZPlusStr_byteZAt(x11, x10, &v14, &v15);
	int64_t v16 = 48LL /* B'0' */;
	bool v17 = (v14 == v16);
	VAL x18;
	int64_t x19;
	if (v17) {
		int64_t v20 = 1LL;
		int64_t v21 = i64_add(x11, v20);
		int64_t v22;
		VAL v23;
		mw_std_str_ZPlusStr_byteZAt(v21, v15, &v22, &v23);
		int64_t v24 = 111LL /* B'o' */;
		bool v25 = (v22 == v24);
		VAL x26;
		int64_t x27;
		if (v25) {
			int64_t v28 = 1LL;
			int64_t v29 = i64_add(v21, v28);
			int64_t v30;
			VAL v31;
			mw_std_str_ZPlusStr_byteZAt(v29, v23, &v30, &v31);
			int64_t v32 = 48LL /* B'0' */;
			int64_t v33 = 55LL /* B'7' */;
			bool v34 = (v30 >= v32);
			bool v35 = (v30 <= v33);
			bool v36 = (v34 && v35);
			int64_t v37 = x9;
			int64_t v38 = v29;
			VAL v39 = (v31);
			bool v40 = v36;
			while (v40) {
				int64_t v41 = v37;
				int64_t v42 = v38;
				VAL v43 = (v39);
				int64_t v44 = 1LL;
				int64_t v45 = i64_add(v41, v44);
				int64_t v46 = 1LL;
				int64_t v47 = i64_add(v42, v46);
				int64_t v48;
				VAL v49;
				mw_std_str_ZPlusStr_byteZAt(v47, v43, &v48, &v49);
				int64_t v50 = 48LL /* B'0' */;
				int64_t v51 = 55LL /* B'7' */;
				bool v52 = (v48 >= v50);
				bool v53 = (v48 <= v51);
				bool v54 = (v52 && v53);
				v40 = v54;
				v39 = v49;
				v38 = v47;
				v37 = v45;
			}
			int64_t v55 = 0LL;
			bool v56 = (v37 > v55);
			VAL x57;
			int64_t x58;
			if (v56) {
				int64_t v59;
				VAL v60;
				mw_std_str_ZPlusStr_numZ_bytesZAsk(v39, &v59, &v60);
				bool v61 = (v38 == v59);
				x58 = ((int64_t)v61);
				x57 = v60;
			} else {
				int64_t v62 = 0LL /* False */;
				x58 = v62;
				x57 = v39;
			}
			x27 = x58;
			x26 = x57;
		} else {
			int64_t v63 = 0LL /* False */;
			x27 = v63;
			x26 = v23;
		}
		x19 = x27;
		x18 = x26;
	} else {
		int64_t v64 = 0LL /* False */;
		x19 = v64;
		x18 = v15;
	}
	*x3 = x18;
	*x2 = x19;
}
static void mw_std_str_ZPlusStr_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_std_str_ZPlusStr_isZ_decZ_intZAsk(x1, &v4, &v5);
	int64_t x6;
	VAL x7;
	if (((bool)v4)) {
		int64_t v8;
		VAL v9;
		mw_std_str_ZPlusStr_decZ_intZAsk(v5, &v8, &v9);
		x7 = v9;
		x6 = v8;
	} else {
		int64_t v10;
		VAL v11;
		mw_std_str_ZPlusStr_isZ_hexZ_intZAsk(v5, &v10, &v11);
		int64_t x12;
		VAL x13;
		if (((bool)v10)) {
			int64_t v14;
			VAL v15;
			mw_std_str_ZPlusStr_hexZ_intZAsk(v11, &v14, &v15);
			x13 = v15;
			x12 = v14;
		} else {
			int64_t v16;
			VAL v17;
			mw_std_str_ZPlusStr_octZ_intZAsk(v11, &v16, &v17);
			x13 = v17;
			x12 = v16;
		}
		x7 = x13;
		x6 = x12;
	}
	*x3 = x7;
	*x2 = x6;
}
static void mw_std_str_ZPlusStr_intZ_sign (VAL x1, int64_t *x2, int64_t *x3, int64_t *x4, VAL *x5) {
	int64_t v6 = 0LL;
	int64_t v7;
	VAL v8;
	mw_std_str_ZPlusStr_byteZAt(v6, x1, &v7, &v8);
	int64_t v9;
	int64_t v10;
	int64_t v11;
	mw_mirth_lexer_byteZ_signZ_valueZ_index(v7, &v9, &v10, &v11);
	*x5 = v8;
	*x4 = v11;
	*x3 = v10;
	*x2 = v9;
}
static void mw_mirth_lexer_byteZ_signZ_valueZ_index (int64_t x1, int64_t *x2, int64_t *x3, int64_t *x4) {
	int64_t x5;
	int64_t x6;
	int64_t x7;
	switch (x1) {
		case 45LL: { // B'-'
			int64_t v8 = -1LL;
			int64_t v9 = 0LL;
			int64_t v10 = 1LL;
			x7 = v10;
			x6 = v9;
			x5 = v8;
		} break;
		case 43LL: { // B'+'
			int64_t v11 = 1LL;
			int64_t v12 = 0LL;
			int64_t v13 = 1LL;
			x7 = v13;
			x6 = v12;
			x5 = v11;
		} break;
		default: {
			int64_t v14 = 1LL;
			int64_t v15 = 0LL;
			int64_t v16 = 0LL;
			x7 = v16;
			x6 = v15;
			x5 = v14;
		} break;
	}
	*x4 = x7;
	*x3 = x6;
	*x2 = x5;
}
static void mw_std_str_ZPlusStr_decZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	int64_t v5;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_intZ_sign(x1, &v4, &v5, &v6, &v7);
	int64_t v8;
	VAL v9;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(v7, &v8, &v9);
	bool v10 = (v6 < v8);
	int64_t v11 = v4;
	int64_t v12 = v5;
	int64_t v13 = v6;
	VAL v14 = (v9);
	bool v15 = v10;
	while (v15) {
		int64_t v16 = v11;
		int64_t v17 = v12;
		int64_t v18 = v13;
		VAL v19 = (v14);
		int64_t v20;
		VAL v21;
		mw_std_str_ZPlusStr_byteZAt(v18, v19, &v20, &v21);
		int64_t v22 = 10LL;
		int64_t v23 = i64_mul(v17, v22);
		int64_t v24 = 48LL;
		int64_t v25 = i64_sub(v20, v24);
		int64_t v26 = i64_add(v23, v25);
		int64_t v27 = 1LL;
		int64_t v28 = i64_add(v18, v27);
		int64_t v29;
		VAL v30;
		mw_std_str_ZPlusStr_numZ_bytesZAsk(v21, &v29, &v30);
		bool v31 = (v28 < v29);
		v15 = v31;
		v14 = v30;
		v13 = v28;
		v12 = v26;
		v11 = v16;
	}
	int64_t v32 = i64_mul(v11, v12);
	*x3 = v14;
	*x2 = v32;
}
static void mw_std_str_ZPlusStr_hexZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	int64_t v5;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_intZ_sign(x1, &v4, &v5, &v6, &v7);
	int64_t v8 = 1LL;
	int64_t v9 = i64_add(v6, v8);
	int64_t v10 = 1LL;
	int64_t v11 = i64_add(v9, v10);
	int64_t v12;
	VAL v13;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(v7, &v12, &v13);
	bool v14 = (v11 < v12);
	int64_t v15 = v4;
	int64_t v16 = v5;
	int64_t v17 = v11;
	VAL v18 = (v13);
	bool v19 = v14;
	while (v19) {
		int64_t v20 = v15;
		int64_t v21 = v16;
		int64_t v22 = v17;
		VAL v23 = (v18);
		int64_t v24;
		VAL v25;
		mw_std_str_ZPlusStr_byteZAt(v22, v23, &v24, &v25);
		int64_t v26 = 16LL;
		int64_t v27 = i64_mul(v21, v26);
		int64_t v28 = mw_mirth_lexer_hexdigitZ_value(v24);
		int64_t v29 = i64_add(v27, v28);
		int64_t v30 = 1LL;
		int64_t v31 = i64_add(v22, v30);
		int64_t v32;
		VAL v33;
		mw_std_str_ZPlusStr_numZ_bytesZAsk(v25, &v32, &v33);
		bool v34 = (v31 < v32);
		v19 = v34;
		v18 = v33;
		v17 = v31;
		v16 = v29;
		v15 = v20;
	}
	int64_t v35 = i64_mul(v15, v16);
	*x3 = v18;
	*x2 = v35;
}
static void mw_std_str_ZPlusStr_octZ_intZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	int64_t v5;
	int64_t v6;
	VAL v7;
	mw_std_str_ZPlusStr_intZ_sign(x1, &v4, &v5, &v6, &v7);
	int64_t v8 = 1LL;
	int64_t v9 = i64_add(v6, v8);
	int64_t v10 = 1LL;
	int64_t v11 = i64_add(v9, v10);
	int64_t v12;
	VAL v13;
	mw_std_str_ZPlusStr_numZ_bytesZAsk(v7, &v12, &v13);
	bool v14 = (v11 < v12);
	int64_t v15 = v4;
	int64_t v16 = v5;
	int64_t v17 = v11;
	VAL v18 = (v13);
	bool v19 = v14;
	while (v19) {
		int64_t v20 = v15;
		int64_t v21 = v16;
		int64_t v22 = v17;
		VAL v23 = (v18);
		int64_t v24;
		VAL v25;
		mw_std_str_ZPlusStr_byteZAt(v22, v23, &v24, &v25);
		int64_t v26 = 8LL;
		int64_t v27 = i64_mul(v21, v26);
		int64_t v28 = 48LL;
		int64_t v29 = i64_sub(v24, v28);
		int64_t v30 = i64_add(v27, v29);
		int64_t v31 = 1LL;
		int64_t v32 = i64_add(v22, v31);
		int64_t v33;
		VAL v34;
		mw_std_str_ZPlusStr_numZ_bytesZAsk(v25, &v33, &v34);
		bool v35 = (v32 < v33);
		v19 = v35;
		v18 = v34;
		v17 = v32;
		v16 = v30;
		v15 = v20;
	}
	int64_t v36 = i64_mul(v15, v16);
	*x3 = v18;
	*x2 = v36;
}
static int64_t mw_mirth_lexer_hexdigitZ_value (int64_t x1) {
	int64_t v2 = mw_std_byte_Byte_isZ_digit(x1);
	int64_t x3;
	if (((bool)v2)) {
		int64_t v4 = 48LL;
		int64_t v5 = i64_sub(x1, v4);
		x3 = v5;
	} else {
		int64_t v6 = 55LL;
		int64_t v7 = i64_sub(x1, v6);
		x3 = v7;
	}
	return x3;
}
static void mw_mirth_lexer_lexerZ_emitZ_stringZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	STR* v5;
	STRLIT(v5, "", 0);
	VAL v6 = MKI64(0LL /* TokenNone */);
	uint64_t v7;
	VAL v8;
	mw_mirth_lexer_lexerZ_makeZBang(v6, x2, &v7, &v8);
	VAL v9 = (mw_mirth_lexer_lexerZ_moveZBang(v8));
	int64_t v10;
	VAL v11;
	mw_mirth_lexer_lexerZ_peek(v9, &v10, &v11);
	int64_t v12 = mw_std_byte_Byte_isZ_stringZ_end(v10);
	bool v13 = !((bool)v12);
	VAL v14 = (x1);
	STR* v15 = (v5);
	uint64_t v16 = v7;
	VAL v17 = (v11);
	int64_t v18 = v10;
	bool v19 = v13;
	while (v19) {
		VAL v20 = (v14);
		STR* v21 = (v15);
		uint64_t v22 = v16;
		VAL v23 = (v17);
		int64_t v24 = v18;
		VAL v25;
		VAL v26;
		VAL v27;
		mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang(v20, MKSTR(v21), v23, v24, &v25, &v26, &v27);
		VAL v28 = (mw_mirth_lexer_lexerZ_moveZBang(v27));
		int64_t v29;
		VAL v30;
		mw_mirth_lexer_lexerZ_peek(v28, &v29, &v30);
		int64_t v31 = mw_std_byte_Byte_isZ_stringZ_end(v29);
		bool v32 = !((bool)v31);
		v19 = v32;
		v18 = v29;
		v17 = v30;
		v16 = v22;
		v15 = VSTR(v26);
		v14 = v25;
	}
	int64_t v33 = 34LL /* BQUOTE */;
	bool v34 = (v18 == v33);
	VAL x35;
	VAL x36;
	uint64_t x37;
	VAL x38;
	if (v34) {
		x38 = v17;
		x37 = v16;
		x36 = MKSTR(v15);
		x35 = v14;
	} else {
		STR* v39;
		STRLIT(v39, "String literal is missing end quote (\").", 40);
		push_u64(v16);
		mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v39), v14, v17);
		VAL r40 = pop_resource();
		x38 = r40;
		uint64_t v41 = pop_u64();
		x37 = v41;
		x36 = MKSTR(v15);
		VAL r42 = pop_resource();
		x35 = r42;
	}
	VAL v43 = mtw_mirth_token_TokenValue_TokenStr(x36);
	void* v44 = mfld_mirth_token_Token_ZTildevalue(x37);
	mut_set(v43, v44);
	*x4 = x38;
	*x3 = x35;
}
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, VAL *x7) {
	VAL x8;
	VAL x9;
	VAL x10;
	switch (x4) {
		case 92LL: { // B'\'
			VAL v11 = (mw_mirth_lexer_lexerZ_moveZBang(x3));
			int64_t v12;
			VAL v13;
			mw_mirth_lexer_lexerZ_peek(v11, &v12, &v13);
			VAL v14;
			VAL v15;
			VAL v16;
			mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang(x1, x2, v13, v12, &v14, &v15, &v16);
			x10 = v16;
			x9 = v15;
			x8 = v14;
		} break;
		default: {
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(x4, x2));
			x10 = x3;
			x9 = v17;
			x8 = x1;
		} break;
	}
	*x7 = x10;
	*x6 = x9;
	*x5 = x8;
}
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4, VAL *x5, VAL *x6, VAL *x7) {
	VAL x8;
	VAL x9;
	VAL x10;
	switch (x4) {
		case 10LL: { // BLF
			VAL v11 = (mw_mirth_lexer_lexerZ_newlineZBang(x3));
			x10 = v11;
			x9 = x2;
			x8 = x1;
		} break;
		case 110LL: { // B'n'
			int64_t v12 = 10LL /* BLF */;
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v12, x2));
			x10 = x3;
			x9 = v13;
			x8 = x1;
		} break;
		case 114LL: { // B'r'
			int64_t v14 = 13LL /* BCR */;
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v14, x2));
			x10 = x3;
			x9 = v15;
			x8 = x1;
		} break;
		case 116LL: { // B't'
			int64_t v16 = 9LL /* BHT */;
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v16, x2));
			x10 = x3;
			x9 = v17;
			x8 = x1;
		} break;
		case 92LL: { // B'\'
			int64_t v18 = 92LL /* B'\' */;
			VAL v19 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v18, x2));
			x10 = x3;
			x9 = v19;
			x8 = x1;
		} break;
		case 34LL: { // BQUOTE
			int64_t v20 = 34LL /* BQUOTE */;
			VAL v21 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v20, x2));
			x10 = x3;
			x9 = v21;
			x8 = x1;
		} break;
		default: {
			VAL v22 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(x4, x2));
			STR* v23;
			STRLIT(v23, "Unknown character escape sequence.", 34);
			VAL v24;
			VAL v25;
			mw_mirth_lexer_lexerZ_emitZ_warningZBang(MKSTR(v23), x1, x3, &v24, &v25);
			x10 = v25;
			x9 = v22;
			x8 = v24;
		} break;
	}
	*x7 = x10;
	*x6 = x9;
	*x5 = x8;
}
static VAL mw_mirth_lexer_lexerZ_skipZ_commentZBang (VAL x1) {
	int64_t v2;
	VAL v3;
	mw_mirth_lexer_lexerZ_commentZ_endZAsk(x1, &v2, &v3);
	bool v4 = !((bool)v2);
	VAL v5 = (v3);
	bool v6 = v4;
	while (v6) {
		VAL v7 = (v5);
		VAL v8 = (mw_mirth_lexer_lexerZ_moveZBang(v7));
		int64_t v9;
		VAL v10;
		mw_mirth_lexer_lexerZ_commentZ_endZAsk(v8, &v9, &v10);
		bool v11 = !((bool)v9);
		v6 = v11;
		v5 = v10;
	}
	int64_t v12;
	VAL v13;
	mw_mirth_lexer_lexerZ_peek(v5, &v12, &v13);
	int64_t v14 = 10LL /* BLF */;
	bool v15 = (v12 == v14);
	VAL x16;
	if (v15) {
		VAL v17 = (mw_mirth_lexer_lexerZ_newlineZBang(v13));
		x16 = v17;
	} else {
		x16 = v13;
	}
	return x16;
}
static VAL mw_mirth_lexer_lexerZ_skipZ_docZBang (VAL x1) {
	int64_t v2;
	VAL v3;
	mw_mirth_lexer_lexerZ_commentZ_endZAsk(x1, &v2, &v3);
	bool v4 = !((bool)v2);
	VAL v5 = (v3);
	bool v6 = v4;
	while (v6) {
		VAL v7 = (v5);
		VAL v8 = (mw_mirth_lexer_lexerZ_moveZBang(v7));
		int64_t v9;
		VAL v10;
		mw_mirth_lexer_lexerZ_commentZ_endZAsk(v8, &v9, &v10);
		bool v11 = !((bool)v9);
		v6 = v11;
		v5 = v10;
	}
	return v5;
}
static void mw_mirth_lexer_lexerZ_commentZ_endZAsk (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4;
	VAL v5;
	mw_mirth_lexer_ZPlusLexer_doneZAsk(x1, &v4, &v5);
	VAL x6;
	int64_t x7;
	if (((bool)v4)) {
		int64_t v8 = 1LL /* True */;
		x7 = v8;
		x6 = v5;
	} else {
		int64_t v9;
		VAL v10;
		mw_mirth_lexer_lexerZ_peek(v5, &v9, &v10);
		int64_t v11 = 10LL /* BLF */;
		bool v12 = (v9 == v11);
		x7 = ((int64_t)v12);
		x6 = v10;
	}
	*x3 = x6;
	*x2 = x7;
}
static void mw_mirth_lexer_lexerZ_peek (VAL x1, int64_t *x2, VAL *x3) {
	VAL v4 = (VVAL(VTUP(x1)->cells[6]));
	int64_t v5;
	VAL v6;
	mw_std_input_ZPlusInput_peek(v4, &v5, &v6);
	VTUP(x1)->cells[6] = v6;
	*x3 = x1;
	*x2 = v5;
}
static VAL mw_mirth_lexer_lexerZ_moveZBang (VAL x1) {
	VAL v2 = (VVAL(VTUP(x1)->cells[6]));
	VAL v3 = (mw_std_input_ZPlusInput_moveZBang(v2));
	VTUP(x1)->cells[6] = v3;
	int64_t v4 = VI64(VTUP(x1)->cells[3]);
	int64_t v5 = mw_mirth_location_Col_ZToInt(v4);
	int64_t v6 = 1LL;
	int64_t v7 = i64_add(v5, v6);
	int64_t v8 = mw_std_prim_Int_ZToCol(v7);
	VTUP(x1)->cells[3] = MKI64(v8);
	return x1;
}
static void mw_mirth_lexer_lexerZ_location (VAL x1, VAL *x2, VAL *x3) {
	uint64_t v4 = VU64(VTUP(x1)->cells[1]);
	int64_t v5 = VI64(VTUP(x1)->cells[2]);
	int64_t v6 = VI64(VTUP(x1)->cells[3]);
	VAL v7 = mtw_mirth_location_Location_Location(v4, v5, v6);
	*x3 = x1;
	*x2 = v7;
}
static void mw_mirth_lexer_lexerZ_emitZ_warningZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_lexer_lexerZ_location(x3, &v6, &v7);
	VAL v8 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang(v6, x1, x2));
	*x5 = v7;
	*x4 = v8;
}
static void mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang (VAL x1, VAL x2, VAL x3) {
	VAL v4;
	VAL v5;
	mw_mirth_lexer_lexerZ_location(x3, &v4, &v5);
	push_resource(v5);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang(v4, x1, x2);
}
static VAL mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang (uint64_t x1) {
	VAL v2 = mw_mirth_var_Ctx0();
	int64_t v3 = 0LL /* False */;
	int64_t v4 = 1LL /* True */;
	VAL v5 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v2, x1, v3, v4));
	return v5;
}
static void mw_mirth_elab_ZPlusTypeElab_rdrop (VAL x1) {
	VAL v2;
	uint64_t v3;
	int64_t v4;
	int64_t v5;
	mtp_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(x1, &v2, &v3, &v4, &v5);
	decref(v2);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	int64_t v7 = mw_mirth_token_Token_runZ_endZAsk(v6);
	VAL x8;
	VAL x9;
	if (((bool)v7)) {
		uint64_t v10 = VU64(VTUP(x2)->cells[2]);
		STR* v11;
		STRLIT(v11, "expected type signature", 23);
		VAL v12 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v10, MKSTR(v11), x1));
		x9 = x2;
		x8 = v12;
	} else {
		x9 = x2;
		x8 = x1;
	}
	VAL v13;
	VAL v14;
	VAL v15;
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang(x8, x9, &v13, &v14, &v15);
	VAL v16;
	VAL v17;
	VAL v18;
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(v13, v14, &v16, &v17, &v18);
	uint64_t v19 = VU64(VTUP(v17)->cells[2]);
	int64_t v20 = mw_mirth_token_Token_sigZ_dashesZAsk(v19);
	VAL x21;
	VAL x22;
	VAL x23;
	VAL x24;
	VAL x25;
	if (((bool)v20)) {
		uint64_t v26 = VU64(VTUP(v17)->cells[2]);
		uint64_t v27 = mw_mirth_token_Token_succ(v26);
		VTUP(v17)->cells[2] = MKU64(v27);
		VAL v28;
		VAL v29;
		VAL v30;
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(v16, v17, &v28, &v29, &v30);
		x25 = v30;
		x24 = v29;
		x23 = v28;
		x22 = v18;
		x21 = v15;
	} else {
		VAL v31 = mw_mirth_type_T0();
		x25 = v18;
		x24 = v17;
		x23 = v16;
		x22 = v31;
		x21 = v15;
	}
	uint64_t v32 = VU64(VTUP(x24)->cells[2]);
	int64_t v33 = mw_mirth_token_Token_runZ_endZAsk(v32);
	VAL x34;
	VAL x35;
	VAL x36;
	VAL x37;
	VAL x38;
	if (((bool)v33)) {
		x38 = x24;
		x37 = x25;
		x36 = x23;
		x35 = x22;
		x34 = x21;
	} else {
		uint64_t v39 = VU64(VTUP(x24)->cells[2]);
		STR* v40;
		STRLIT(v40, "expected right paren or comma", 29);
		VAL v41 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v39, MKSTR(v40), x23));
		x38 = x24;
		x37 = x25;
		x36 = v41;
		x35 = x22;
		x34 = x21;
	}
	VAL v42;
	VAL v43;
	mw_std_list_List_1_uncons(x34, &v42, &v43);
	VAL x44;
	VAL x45;
	VAL x46;
	VAL x47;
	int64_t x48;
	switch (get_data_tag(v42)) {
		case 1LL: { // Some
			VAL v49 = mtp_std_maybe_Maybe_1_Some(v42);
			VAL v50 = mw_mirth_type_TZMul(x35, v49);
			int64_t v51 = 1LL /* True */;
			x48 = v51;
			x47 = v43;
			x46 = v50;
			x45 = x38;
			x44 = x36;
		} break;
		case 0LL: { // None
			int64_t v52 = 0LL /* False */;
			x48 = v52;
			x47 = v43;
			x46 = x35;
			x45 = x38;
			x44 = x36;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v53 = (x44);
	VAL v54 = (x45);
	VAL v55 = x46;
	VAL v56 = x47;
	int64_t v57 = x48;
	while (((bool)v57)) {
		VAL v58 = (v53);
		VAL v59 = (v54);
		VAL v60 = v55;
		VAL v61 = v56;
		VAL v62;
		VAL v63;
		mw_std_list_List_1_uncons(v61, &v62, &v63);
		VAL x64;
		VAL x65;
		VAL x66;
		VAL x67;
		int64_t x68;
		switch (get_data_tag(v62)) {
			case 1LL: { // Some
				VAL v69 = mtp_std_maybe_Maybe_1_Some(v62);
				VAL v70 = mw_mirth_type_TZMul(v60, v69);
				int64_t v71 = 1LL /* True */;
				x68 = v71;
				x67 = v63;
				x66 = v70;
				x65 = v59;
				x64 = v58;
			} break;
			case 0LL: { // None
				int64_t v72 = 0LL /* False */;
				x68 = v72;
				x67 = v63;
				x66 = v60;
				x65 = v59;
				x64 = v58;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v57 = x68;
		v56 = x67;
		v55 = x66;
		v54 = x65;
		v53 = x64;
	}
	decref(v56);
	VAL v73 = mw_mirth_type_TZ_ZTo(v55, x37);
	*x5 = v73;
	*x4 = v54;
	*x3 = v53;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	VAL v7 = mw_mirth_token_Token_lparenZAsk(v6);
	VAL x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			decref(v11);
			uint64_t v12 = VU64(VTUP(x2)->cells[2]);
			uint64_t v13 = mw_mirth_token_Token_next(v12);
			uint64_t v14 = VU64(VTUP(x2)->cells[2]);
			VAL v15 = mw_mirth_token_Token_args(v14);
			VAL v16 = MKI64(0LL /* Nil */);
			VAL v17 = mw_std_list_List_1_reverse(v16);
			VAL v18;
			VAL v19;
			mw_std_list_List_1_uncons(v15, &v18, &v19);
			VAL x20;
			uint64_t x21;
			VAL x22;
			VAL x23;
			VAL x24;
			int64_t x25;
			switch (get_data_tag(v18)) {
				case 1LL: { // Some
					VAL v26 = mtp_std_maybe_Maybe_1_Some(v18);
					VTUP(x2)->cells[2] = v26;
					VAL v27;
					VAL v28;
					VAL v29;
					mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(x1, x2, &v27, &v28, &v29);
					VAL v30 = mtw_mirth_type_Type_TMorphism(v29);
					VAL v31 = mtw_std_list_List_1_Cons(v30, v17);
					int64_t v32 = 1LL /* True */;
					x25 = v32;
					x24 = v19;
					x23 = v31;
					x22 = v28;
					x21 = v13;
					x20 = v27;
				} break;
				case 0LL: { // None
					int64_t v33 = 0LL /* False */;
					x25 = v33;
					x24 = v19;
					x23 = v17;
					x22 = x2;
					x21 = v13;
					x20 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v34 = (x20);
			uint64_t v35 = x21;
			VAL v36 = (x22);
			VAL v37 = (x23);
			VAL v38 = x24;
			int64_t v39 = x25;
			while (((bool)v39)) {
				VAL v40 = (v34);
				uint64_t v41 = v35;
				VAL v42 = (v36);
				VAL v43 = (v37);
				VAL v44 = v38;
				VAL v45;
				VAL v46;
				mw_std_list_List_1_uncons(v44, &v45, &v46);
				VAL x47;
				uint64_t x48;
				VAL x49;
				VAL x50;
				VAL x51;
				int64_t x52;
				switch (get_data_tag(v45)) {
					case 1LL: { // Some
						VAL v53 = mtp_std_maybe_Maybe_1_Some(v45);
						VTUP(v42)->cells[2] = v53;
						VAL v54;
						VAL v55;
						VAL v56;
						mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(v40, v42, &v54, &v55, &v56);
						VAL v57 = mtw_mirth_type_Type_TMorphism(v56);
						VAL v58 = mtw_std_list_List_1_Cons(v57, v43);
						int64_t v59 = 1LL /* True */;
						x52 = v59;
						x51 = v46;
						x50 = v58;
						x49 = v55;
						x48 = v41;
						x47 = v54;
					} break;
					case 0LL: { // None
						int64_t v60 = 0LL /* False */;
						x52 = v60;
						x51 = v46;
						x50 = v43;
						x49 = v42;
						x48 = v41;
						x47 = v40;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v39 = x52;
				v38 = x51;
				v37 = x50;
				v36 = x49;
				v35 = x48;
				v34 = x47;
			}
			decref(v38);
			VAL v61 = mw_std_list_List_1_reverse(v37);
			VTUP(v36)->cells[2] = MKU64(v35);
			x10 = v61;
			x9 = v36;
			x8 = v34;
		} break;
		case 0LL: { // None
			VAL v62 = MKI64(0LL /* Nil */);
			x10 = v62;
			x9 = x2;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x10;
	*x4 = x9;
	*x3 = x8;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	VAL v7 = mw_mirth_token_Token_sigZ_stackZ_varZAsk(v6);
	VAL x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v12;
			VAL v13;
			VAL v14;
			mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang(x1, x2, VU64(v11), &v12, &v13, &v14);
			x10 = v14;
			x9 = v13;
			x8 = v12;
		} break;
		case 0LL: { // None
			VAL v15 = mw_mirth_type_T0();
			x10 = v15;
			x9 = x2;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v16;
	VAL v17;
	VAL v18;
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang(x8, x9, x10, &v16, &v17, &v18);
	*x5 = v18;
	*x4 = v17;
	*x3 = v16;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	uint64_t v7 = VU64(VTUP(x2)->cells[2]);
	int64_t v8 = mw_mirth_token_Token_sigZ_stackZ_endZAsk(v7);
	bool v9 = !((bool)v8);
	VAL v10 = (x1);
	VAL v11 = x3;
	VAL v12 = (x2);
	bool v13 = v9;
	while (v13) {
		VAL v14 = (v10);
		VAL v15 = v11;
		VAL v16 = (v12);
		VAL v17;
		VAL v18;
		VAL v19;
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang(v14, v16, &v17, &v18, &v19);
		VAL v20 = mw_mirth_type_StackTypePart_cons(v15, v19);
		uint64_t v21 = VU64(VTUP(v18)->cells[2]);
		int64_t v22 = mw_mirth_token_Token_sigZ_stackZ_endZAsk(v21);
		bool v23 = !((bool)v22);
		v13 = v23;
		v12 = v18;
		v11 = v20;
		v10 = v17;
	}
	*x6 = v11;
	*x5 = v12;
	*x4 = v10;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	VAL v7;
	VAL v8;
	VAL v9;
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang(x1, x2, &v7, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 0LL: { // STPCons
			VAL v13 = mtp_mirth_type_StackTypePart_STPCons(v9);
			x12 = v13;
			x11 = v8;
			x10 = v7;
		} break;
		case 1LL: { // STPConsLabel
			VAL v14;
			uint64_t v15;
			mtp_mirth_type_StackTypePart_STPConsLabel(v9, &v14, &v15);
			decref(v14);
			STR* v16;
			STRLIT(v16, "Expected type, not label.", 25);
			VAL v17 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v16), v7));
			VAL v18 = MKI64(0LL /* TYPE_ERROR */);
			x12 = v18;
			x11 = v8;
			x10 = v17;
		} break;
		case 2LL: { // STPWith
			VAL v19 = mtp_mirth_type_StackTypePart_STPWith(v9);
			decref(v19);
			STR* v20;
			STRLIT(v20, "Expected type, not resource.", 28);
			VAL v21 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v20), v7));
			VAL v22 = MKI64(0LL /* TYPE_ERROR */);
			x12 = v22;
			x11 = v8;
			x10 = v21;
		} break;
		case 3LL: { // STPWithLabel
			VAL v23;
			uint64_t v24;
			mtp_mirth_type_StackTypePart_STPWithLabel(v9, &v23, &v24);
			decref(v23);
			STR* v25;
			STRLIT(v25, "Expected type, not labelled resource.", 37);
			VAL v26 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v25), v7));
			VAL v27 = MKI64(0LL /* TYPE_ERROR */);
			x12 = v27;
			x11 = v8;
			x10 = v26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v28 = VU64(VTUP(x11)->cells[2]);
	int64_t v29 = mw_mirth_token_Token_argZ_endZAsk(v28);
	VAL x30;
	VAL x31;
	VAL x32;
	if (((bool)v29)) {
		x32 = x11;
		x31 = x12;
		x30 = x10;
	} else {
		uint64_t v33 = VU64(VTUP(x11)->cells[2]);
		STR* v34;
		STRLIT(v34, "Unexpected token after type.", 28);
		VAL v35 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v33, MKSTR(v34), x10));
		x32 = x11;
		x31 = x12;
		x30 = v35;
	}
	*x5 = x31;
	*x4 = x32;
	*x3 = x30;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	VAL v7;
	VAL v8;
	VAL v9;
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang(x1, x2, &v7, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 0LL: { // STPCons
			VAL v13 = mtp_mirth_type_StackTypePart_STPCons(v9);
			decref(v13);
			STR* v14;
			STRLIT(v14, "Expected resource, not type.", 28);
			VAL v15 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v14), v7));
			VAL v16 = MKI64(0LL /* TYPE_ERROR */);
			x12 = v16;
			x11 = v8;
			x10 = v15;
		} break;
		case 1LL: { // STPConsLabel
			VAL v17;
			uint64_t v18;
			mtp_mirth_type_StackTypePart_STPConsLabel(v9, &v17, &v18);
			decref(v17);
			STR* v19;
			STRLIT(v19, "Expected resource, not label.", 29);
			VAL v20 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v19), v7));
			VAL v21 = MKI64(0LL /* TYPE_ERROR */);
			x12 = v21;
			x11 = v8;
			x10 = v20;
		} break;
		case 2LL: { // STPWith
			VAL v22 = mtp_mirth_type_StackTypePart_STPWith(v9);
			x12 = v22;
			x11 = v8;
			x10 = v7;
		} break;
		case 3LL: { // STPWithLabel
			VAL v23;
			uint64_t v24;
			mtp_mirth_type_StackTypePart_STPWithLabel(v9, &v23, &v24);
			decref(v23);
			STR* v25;
			STRLIT(v25, "Expected resource, not label.", 29);
			VAL v26 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v25), v7));
			VAL v27 = MKI64(0LL /* TYPE_ERROR */);
			x12 = v27;
			x11 = v8;
			x10 = v26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v28 = VU64(VTUP(x11)->cells[2]);
	int64_t v29 = mw_mirth_token_Token_argZ_endZAsk(v28);
	VAL x30;
	VAL x31;
	VAL x32;
	if (((bool)v29)) {
		x32 = x11;
		x31 = x12;
		x30 = x10;
	} else {
		uint64_t v33 = VU64(VTUP(x11)->cells[2]);
		STR* v34;
		STRLIT(v34, "Unexpected token after resource.", 32);
		VAL v35 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v33, MKSTR(v34), x10));
		x32 = x11;
		x31 = x12;
		x30 = v35;
	}
	*x5 = x31;
	*x4 = x32;
	*x3 = x30;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	VAL v7 = mw_mirth_token_Token_sigZ_labelZAsk(v6);
	VAL x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v12;
			VAL v13;
			VAL v14;
			mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang(x1, x2, VU64(v11), &v12, &v13, &v14);
			x10 = v14;
			x9 = v13;
			x8 = v12;
		} break;
		case 0LL: { // None
			uint64_t v15 = VU64(VTUP(x2)->cells[2]);
			VAL v16 = mw_mirth_token_Token_sigZ_typeZ_varZAsk(v15);
			VAL x17;
			VAL x18;
			VAL x19;
			switch (get_data_tag(v16)) {
				case 1LL: { // Some
					VAL v20 = mtp_std_maybe_Maybe_1_Some(v16);
					VAL v21;
					VAL v22;
					VAL v23;
					mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang(x1, x2, VU64(v20), &v21, &v22, &v23);
					VAL v24 = mtw_mirth_type_StackTypePart_STPCons(v23);
					x19 = v24;
					x18 = v22;
					x17 = v21;
				} break;
				case 0LL: { // None
					uint64_t v25 = VU64(VTUP(x2)->cells[2]);
					VAL v26 = mw_mirth_token_Token_sigZ_typeZ_conZAsk(v25);
					VAL x27;
					VAL x28;
					VAL x29;
					switch (get_data_tag(v26)) {
						case 1LL: { // Some
							VAL v30 = mtp_std_maybe_Maybe_1_Some(v26);
							VAL v31;
							VAL v32;
							VAL v33;
							mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang(x1, x2, v30, &v31, &v32, &v33);
							VAL v34 = mtw_mirth_type_StackTypePart_STPCons(v33);
							x29 = v34;
							x28 = v32;
							x27 = v31;
						} break;
						case 0LL: { // None
							uint64_t v35 = VU64(VTUP(x2)->cells[2]);
							VAL v36 = mw_mirth_token_Token_sigZ_resourceZ_varZAsk(v35);
							VAL x37;
							VAL x38;
							VAL x39;
							switch (get_data_tag(v36)) {
								case 1LL: { // Some
									VAL v40 = mtp_std_maybe_Maybe_1_Some(v36);
									VAL v41;
									VAL v42;
									VAL v43;
									mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang(x1, x2, VU64(v40), &v41, &v42, &v43);
									VAL v44 = mtw_mirth_type_StackTypePart_STPWith(v43);
									x39 = v44;
									x38 = v42;
									x37 = v41;
								} break;
								case 0LL: { // None
									uint64_t v45 = VU64(VTUP(x2)->cells[2]);
									VAL v46 = mw_mirth_token_Token_sigZ_resourceZ_conZAsk(v45);
									VAL x47;
									VAL x48;
									VAL x49;
									switch (get_data_tag(v46)) {
										case 1LL: { // Some
											VAL v50 = mtp_std_maybe_Maybe_1_Some(v46);
											VAL v51;
											VAL v52;
											VAL v53;
											mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang(x1, x2, v50, &v51, &v52, &v53);
											VAL v54 = mtw_mirth_type_StackTypePart_STPWith(v53);
											x49 = v54;
											x48 = v52;
											x47 = v51;
										} break;
										case 0LL: { // None
											uint64_t v55 = VU64(VTUP(x2)->cells[2]);
											int64_t v56 = mw_mirth_token_Token_patZ_underscoreZAsk(v55);
											VAL x57;
											VAL x58;
											VAL x59;
											if (((bool)v56)) {
												VAL v60;
												VAL v61;
												VAL v62;
												mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang(x1, x2, &v60, &v61, &v62);
												VAL v63 = mtw_mirth_type_StackTypePart_STPCons(v62);
												x59 = v63;
												x58 = v61;
												x57 = v60;
											} else {
												uint64_t v64 = VU64(VTUP(x2)->cells[2]);
												VAL v65 = mw_mirth_token_Token_sigZ_typeZ_holeZAsk(v64);
												VAL x66;
												VAL x67;
												VAL x68;
												switch (get_data_tag(v65)) {
													case 1LL: { // Some
														VAL v69 = mtp_std_maybe_Maybe_1_Some(v65);
														VAL v70;
														VAL v71;
														VAL v72;
														mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang(x1, x2, VU64(v69), &v70, &v71, &v72);
														VAL v73 = mtw_mirth_type_StackTypePart_STPCons(v72);
														x68 = v73;
														x67 = v71;
														x66 = v70;
													} break;
													case 0LL: { // None
														uint64_t v74 = VU64(VTUP(x2)->cells[2]);
														VAL v75 = mw_mirth_token_Token_lsquareZAsk(v74);
														VAL x76;
														VAL x77;
														VAL x78;
														switch (get_data_tag(v75)) {
															case 1LL: { // Some
																VAL v79 = mtp_std_maybe_Maybe_1_Some(v75);
																decref(v79);
																VAL v80;
																VAL v81;
																VAL v82;
																mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang(x1, x2, &v80, &v81, &v82);
																VAL v83 = mtw_mirth_type_StackTypePart_STPCons(v82);
																x78 = v83;
																x77 = v81;
																x76 = v80;
															} break;
															case 0LL: { // None
																uint64_t v84 = VU64(VTUP(x2)->cells[2]);
																STR* v85;
																STRLIT(v85, "Expected type, got unknown token.", 33);
																VAL v86 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v84, MKSTR(v85), x1));
																uint64_t v87 = VU64(VTUP(x2)->cells[2]);
																uint64_t v88 = mw_mirth_token_Token_next(v87);
																VTUP(x2)->cells[2] = MKU64(v88);
																VAL v89 = MKI64(0LL /* TYPE_ERROR */);
																VAL v90 = mtw_mirth_type_StackTypePart_STPCons(v89);
																x78 = v90;
																x77 = x2;
																x76 = v86;
															} break;
															default: {
																do_panic(str_make("unexpected fallthrough in match\n", 32));
															}
														}
														x68 = x78;
														x67 = x77;
														x66 = x76;
													} break;
													default: {
														do_panic(str_make("unexpected fallthrough in match\n", 32));
													}
												}
												x59 = x68;
												x58 = x67;
												x57 = x66;
											}
											x49 = x59;
											x48 = x58;
											x47 = x57;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									x39 = x49;
									x38 = x48;
									x37 = x47;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							x29 = x39;
							x28 = x38;
							x27 = x37;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x19 = x29;
					x18 = x28;
					x17 = x27;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x10 = x19;
			x9 = x18;
			x8 = x17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x10;
	*x4 = x9;
	*x3 = x8;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6) {
	uint64_t v7 = VU64(VTUP(x2)->cells[2]);
	uint64_t v8 = mw_mirth_token_Token_next(v7);
	uint64_t v9 = VU64(VTUP(x2)->cells[2]);
	uint64_t v10;
	VAL v11;
	mw_mirth_token_Token_argsZ_1(v9, x1, &v10, &v11);
	VTUP(x2)->cells[2] = MKU64(v10);
	int64_t v12 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(x3);
	VAL x13;
	VAL x14;
	VAL x15;
	if (((bool)v12)) {
		VAL v16;
		VAL v17;
		VAL v18;
		mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang(v11, x2, &v16, &v17, &v18);
		VAL v19 = mtw_mirth_type_StackTypePart_STPWithLabel(v18, x3);
		x15 = v19;
		x14 = v17;
		x13 = v16;
	} else {
		VAL v20;
		VAL v21;
		VAL v22;
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(v11, x2, &v20, &v21, &v22);
		VAL v23 = mtw_mirth_type_StackTypePart_STPConsLabel(v22, x3);
		x15 = v23;
		x14 = v21;
		x13 = v20;
	}
	VTUP(x14)->cells[2] = MKU64(v8);
	*x6 = x15;
	*x5 = x14;
	*x4 = x13;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_TYPEz_STACK();
	VAL v8;
	VAL v9;
	VAL v10;
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang(x1, x2, x3, v7, &v8, &v9, &v10);
	VAL x11;
	VAL x12;
	VAL x13;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v15 = mtw_mirth_type_StackType_STVar(VU64(v14));
			x13 = v15;
			x12 = v9;
			x11 = v8;
		} break;
		case 0LL: { // None
			VAL v16 = MKI64(0LL /* STACK_TYPE_ERROR */);
			x13 = v16;
			x12 = v9;
			x11 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x13;
	*x5 = x12;
	*x4 = x11;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_TYPEz_TYPE();
	VAL v8;
	VAL v9;
	VAL v10;
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang(x1, x2, x3, v7, &v8, &v9, &v10);
	VAL x11;
	VAL x12;
	VAL x13;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v15 = mtw_mirth_type_Type_TVar(VU64(v14));
			x13 = v15;
			x12 = v9;
			x11 = v8;
		} break;
		case 0LL: { // None
			VAL v16 = MKI64(0LL /* TYPE_ERROR */);
			x13 = v16;
			x12 = v9;
			x11 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x13;
	*x5 = x12;
	*x4 = x11;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_TYPEz_RESOURCE();
	VAL v8;
	VAL v9;
	VAL v10;
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang(x1, x2, x3, v7, &v8, &v9, &v10);
	VAL x11;
	VAL x12;
	VAL x13;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v15 = mtw_mirth_type_Type_TVar(VU64(v14));
			x13 = v15;
			x12 = v9;
			x11 = v8;
		} break;
		case 0LL: { // None
			VAL v16 = MKI64(0LL /* TYPE_ERROR */);
			x13 = v16;
			x12 = v9;
			x11 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x13;
	*x5 = x12;
	*x4 = x11;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL *x5, VAL *x6, VAL *x7) {
	VAL v8 = VVAL(VTUP(x2)->cells[1]);
	incref(v8);
	VAL v9 = mw_mirth_var_Ctx_lookup(x3, v8);
	VAL x10;
	VAL x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
			incref(v13);
			VAL v14 = mw_mirth_var_Var_type(VU64(v13));
			uint64_t v15 = VU64(VTUP(x2)->cells[2]);
			VAL v16;
			uint64_t v17;
			VAL v18;
			mw_mirth_type_Type_unifyZBang(x1, v15, x4, v14, &v16, &v17, &v18);
			mw_mirth_type_ZPlusGamma_rdrop(v17);
			decref(v18);
			VAL v19 = mtw_std_maybe_Maybe_1_Some(v13);
			x12 = v19;
			x11 = x2;
			x10 = v16;
		} break;
		case 0LL: { // None
			int64_t v20 = VI64(VTUP(x2)->cells[4]);
			VAL x21;
			VAL x22;
			VAL x23;
			if (((bool)v20)) {
				uint64_t v24 = mw_mirth_var_Var_newZBang(x4, x3);
				VAL v25 = VVAL(VTUP(x2)->cells[1]);
				incref(v25);
				VAL v26 = mw_mirth_var_Ctx_new(v25, v24);
				VAL v27 = VTUP(x2)->cells[1];
				decref(v27);
				VTUP(x2)->cells[1] = v26;
				VAL v28 = mtw_std_maybe_Maybe_1_Some(MKU64(v24));
				x23 = v28;
				x22 = x2;
				x21 = x1;
			} else {
				uint64_t v29 = VU64(VTUP(x2)->cells[2]);
				STR* v30;
				STRLIT(v30, "Implicit type variable not allowed here.", 40);
				VAL v31 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v29, MKSTR(v30), x1));
				decref(x4);
				VAL v32 = MKI64(0LL /* None */);
				x23 = v32;
				x22 = x2;
				x21 = v31;
			}
			x12 = x23;
			x11 = x22;
			x10 = x21;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v33 = VU64(VTUP(x11)->cells[2]);
	VAL v34 = (mw_mirth_token_Token_argsZ_0(v33, x10));
	uint64_t v35 = VU64(VTUP(x11)->cells[2]);
	uint64_t v36 = mw_mirth_token_Token_succ(v35);
	VTUP(x11)->cells[2] = MKU64(v36);
	*x7 = x12;
	*x6 = x11;
	*x5 = v34;
}
static void mw_mirth_elab_resolveZ_defZ_beginZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, int64_t x5, VAL x6, VAL *x7, VAL *x8) {
	VAL x9;
	uint64_t x10;
	int64_t x11;
	VAL x12;
	int64_t x13;
	VAL x14;
	uint64_t x15;
	if (((bool)x4)) {
		incref(x3);
		VAL v16 = mw_mirth_token_nameZDivdnameZ_penultimateZ_nameZAsk(x3);
		VAL x17;
		uint64_t x18;
		int64_t x19;
		VAL x20;
		int64_t x21;
		VAL x22;
		uint64_t x23;
		switch (get_data_tag(v16)) {
			case 1LL: { // Some
				VAL v24 = mtp_std_maybe_Maybe_1_Some(v16);
				x23 = VU64(v24);
				x22 = x3;
				x21 = x4;
				x20 = x6;
				x19 = x5;
				x18 = x2;
				x17 = x1;
			} break;
			case 0LL: { // None
				STR* v25;
				STRLIT(v25, "Expected a namespace.", 21);
				lpush(&lbl_sort, x1);
				lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKI64(x5));
				lpush(&lbl_ignoreZ_lastZ_name, MKI64(x4));
				lpush(&lbl_nameZDivdname, x3);
				lpush(&lbl_token, MKU64(x2));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v25), x6);
				uint64_t v26 = pop_u64();
				x23 = v26;
				VAL v27 = lpop(&lbl_nameZDivdname);
				x22 = v27;
				int64_t v28 = VI64(lpop(&lbl_ignoreZ_lastZ_name));
				x21 = v28;
				VAL r29 = pop_resource();
				x20 = r29;
				int64_t v30 = VI64(lpop(&lbl_reportZ_ambiguousZ_asZ_warning));
				x19 = v30;
				uint64_t v31 = VU64(lpop(&lbl_token));
				x18 = v31;
				VAL v32 = lpop(&lbl_sort);
				x17 = v32;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x15 = x23;
		x14 = x22;
		x13 = x21;
		x12 = x20;
		x11 = x19;
		x10 = x18;
		x9 = x17;
	} else {
		incref(x3);
		uint64_t v33 = mw_mirth_token_nameZDivdnameZ_lastZ_name(x3);
		x15 = v33;
		x14 = x3;
		x13 = x4;
		x12 = x6;
		x11 = x5;
		x10 = x2;
		x9 = x1;
	}
	VAL v34 = mw_mirth_name_Name_defs(x15);
	VAL v35 = MKI64(0LL /* Nil */);
	VAL v36 = (mtw_mirth_elab_ZPlusResolveDef_ZPlusResolveDef(x9, x10, x14, v34, v35, x13, x11));
	*x8 = v36;
	*x7 = x12;
}
static void mw_mirth_elab_resolveZ_defZ_endZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x2)->cells[4]);
	incref(v5);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 0LL: { // Nil
			VAL v8 = (mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown(x1, x2));
			VAL v9 = MKI64(0LL /* None */);
			x7 = v9;
			x6 = v8;
		} break;
		case 1LL: { // Cons
			VAL v10;
			VAL v11;
			mtp_std_list_List_1_Cons(v5, &v10, &v11);
			VAL x12;
			VAL x13;
			switch (get_data_tag(v11)) {
				case 0LL: { // Nil
					mw_mirth_elab_ZPlusResolveDef_rdrop(x2);
					VAL v14 = mtw_std_maybe_Maybe_1_Some(v10);
					x13 = v14;
					x12 = x1;
				} break;
				default: {
					VAL v15 = MKI64(0LL /* Nil */);
					VAL v16 = mw_std_list_List_1_reverse(v15);
					VAL v17;
					VAL v18;
					mw_std_list_List_1_uncons(v11, &v17, &v18);
					VAL x19;
					VAL x20;
					VAL x21;
					VAL x22;
					VAL x23;
					int64_t x24;
					switch (get_data_tag(v17)) {
						case 1LL: { // Some
							VAL v25 = mtp_std_maybe_Maybe_1_Some(v17);
							incref(v25);
							incref(v10);
							VAL v26;
							int64_t v27;
							mw_mirth_def_Def_sameZ_resolvedZAsk(x1, v25, v10, &v26, &v27);
							bool v28 = !((bool)v27);
							VAL x29;
							VAL x30;
							VAL x31;
							VAL x32;
							if (v28) {
								VAL v33 = mtw_std_maybe_Maybe_1_Some(v25);
								x32 = v33;
								x31 = v10;
								x30 = x2;
								x29 = v26;
							} else {
								decref(v25);
								VAL v34 = MKI64(0LL /* None */);
								x32 = v34;
								x31 = v10;
								x30 = x2;
								x29 = v26;
							}
							VAL x35;
							switch (get_data_tag(x32)) {
								case 1LL: { // Some
									VAL v36 = mtp_std_maybe_Maybe_1_Some(x32);
									VAL v37 = mtw_std_list_List_1_Cons(v36, v16);
									x35 = v37;
									push_resource(x29);
									push_resource(x30);
									push_value(x31);
								} break;
								case 0LL: { // None
									x35 = v16;
									push_resource(x29);
									push_resource(x30);
									push_value(x31);
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v38 = 1LL /* True */;
							x24 = v38;
							x23 = v18;
							x22 = x35;
							VAL v39 = pop_value();
							x21 = v39;
							VAL r40 = pop_resource();
							x20 = r40;
							VAL r41 = pop_resource();
							x19 = r41;
						} break;
						case 0LL: { // None
							int64_t v42 = 0LL /* False */;
							x24 = v42;
							x23 = v18;
							x22 = v16;
							x21 = v10;
							x20 = x2;
							x19 = x1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v43 = (x19);
					VAL v44 = (x20);
					VAL v45 = x21;
					VAL v46 = (x22);
					VAL v47 = x23;
					int64_t v48 = x24;
					while (((bool)v48)) {
						VAL v49 = (v43);
						VAL v50 = (v44);
						VAL v51 = v45;
						VAL v52 = (v46);
						VAL v53 = v47;
						VAL v54;
						VAL v55;
						mw_std_list_List_1_uncons(v53, &v54, &v55);
						VAL x56;
						VAL x57;
						VAL x58;
						VAL x59;
						VAL x60;
						int64_t x61;
						switch (get_data_tag(v54)) {
							case 1LL: { // Some
								VAL v62 = mtp_std_maybe_Maybe_1_Some(v54);
								incref(v62);
								incref(v51);
								VAL v63;
								int64_t v64;
								mw_mirth_def_Def_sameZ_resolvedZAsk(v49, v62, v51, &v63, &v64);
								bool v65 = !((bool)v64);
								VAL x66;
								VAL x67;
								VAL x68;
								VAL x69;
								if (v65) {
									VAL v70 = mtw_std_maybe_Maybe_1_Some(v62);
									x69 = v70;
									x68 = v51;
									x67 = v50;
									x66 = v63;
								} else {
									decref(v62);
									VAL v71 = MKI64(0LL /* None */);
									x69 = v71;
									x68 = v51;
									x67 = v50;
									x66 = v63;
								}
								VAL x72;
								switch (get_data_tag(x69)) {
									case 1LL: { // Some
										VAL v73 = mtp_std_maybe_Maybe_1_Some(x69);
										VAL v74 = mtw_std_list_List_1_Cons(v73, v52);
										x72 = v74;
										push_resource(x66);
										push_resource(x67);
										push_value(x68);
									} break;
									case 0LL: { // None
										x72 = v52;
										push_resource(x66);
										push_resource(x67);
										push_value(x68);
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								int64_t v75 = 1LL /* True */;
								x61 = v75;
								x60 = v55;
								x59 = x72;
								VAL v76 = pop_value();
								x58 = v76;
								VAL r77 = pop_resource();
								x57 = r77;
								VAL r78 = pop_resource();
								x56 = r78;
							} break;
							case 0LL: { // None
								int64_t v79 = 0LL /* False */;
								x61 = v79;
								x60 = v55;
								x59 = v52;
								x58 = v51;
								x57 = v50;
								x56 = v49;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v48 = x61;
						v47 = x60;
						v46 = x59;
						v45 = x58;
						v44 = x57;
						v43 = x56;
					}
					decref(v47);
					VAL v80 = mw_std_list_List_1_reverse(v46);
					VAL x81;
					VAL x82;
					switch (get_data_tag(v80)) {
						case 0LL: { // Nil
							mw_mirth_elab_ZPlusResolveDef_rdrop(v44);
							VAL v83 = mtw_std_maybe_Maybe_1_Some(v45);
							x82 = v83;
							x81 = v43;
						} break;
						default: {
							decref(v80);
							decref(v45);
							VAL v84 = (mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous(v43, v44));
							VAL v85 = MKI64(0LL /* None */);
							x82 = v85;
							x81 = v84;
						} break;
					}
					x13 = x82;
					x12 = x81;
				} break;
			}
			x7 = x13;
			x6 = x12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_elab_ZPlusResolveDef_rdrop (VAL x1) {
	VAL v2;
	uint64_t v3;
	VAL v4;
	VAL v5;
	VAL v6;
	int64_t v7;
	int64_t v8;
	mtp_mirth_elab_ZPlusResolveDef_ZPlusResolveDef(x1, &v2, &v3, &v4, &v5, &v6, &v7, &v8);
	decref(v4);
	decref(v2);
	decref(v6);
	decref(v5);
}
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous (VAL x1, VAL x2) {
	int64_t v3 = VI64(VTUP(x2)->cells[7]);
	VAL x4;
	VAL x5;
	if (((bool)v3)) {
		uint64_t v6 = VU64(VTUP(x2)->cells[2]);
		STR* v7;
		STRLIT(v7, "", 0);
		STR* v8;
		STRLIT(v8, "Can't resolve ", 14);
		VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), MKSTR(v7)));
		VAL v10 = VVAL(VTUP(x2)->cells[1]);
		incref(v10);
		VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, v9));
		STR* v12;
		STRLIT(v12, " due to previous errors. Candidates are:", 40);
		VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
		STR* v14;
		STRLIT(v14, " ", 1);
		VAL v15 = VVAL(VTUP(x2)->cells[4]);
		incref(v15);
		VAL v16;
		VAL v17;
		mw_std_list_List_1_uncons(v15, &v16, &v17);
		VAL x18;
		uint64_t x19;
		VAL x20;
		VAL x21;
		VAL x22;
		VAL x23;
		int64_t x24;
		switch (get_data_tag(v16)) {
			case 1LL: { // Some
				VAL v25 = mtp_std_maybe_Maybe_1_Some(v16);
				VAL v26 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), v13));
				VAL v27;
				VAL v28;
				mw_mirth_def_Def_qnameZ_hard(x1, v25, &v27, &v28);
				VAL v29;
				VAL v30;
				mw_mirth_name_QName_ZToStr(v27, v28, &v29, &v30);
				VAL v31 = (mw_std_str_ZPlusStr_pushZ_strZBang(v30, v26));
				STR* v32;
				STRLIT(v32, ", ", 2);
				int64_t v33 = 1LL /* True */;
				x24 = v33;
				x23 = v17;
				x22 = v31;
				x21 = x2;
				x20 = MKSTR(v32);
				x19 = v6;
				x18 = v29;
			} break;
			case 0LL: { // None
				int64_t v34 = 0LL /* False */;
				x24 = v34;
				x23 = v17;
				x22 = v13;
				x21 = x2;
				x20 = MKSTR(v14);
				x19 = v6;
				x18 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v35 = (x18);
		uint64_t v36 = x19;
		VAL v37 = x20;
		VAL v38 = (x21);
		VAL v39 = (x22);
		VAL v40 = x23;
		int64_t v41 = x24;
		while (((bool)v41)) {
			VAL v42 = (v35);
			uint64_t v43 = v36;
			VAL v44 = v37;
			VAL v45 = (v38);
			VAL v46 = (v39);
			VAL v47 = v40;
			VAL v48;
			VAL v49;
			mw_std_list_List_1_uncons(v47, &v48, &v49);
			VAL x50;
			uint64_t x51;
			VAL x52;
			VAL x53;
			VAL x54;
			VAL x55;
			int64_t x56;
			switch (get_data_tag(v48)) {
				case 1LL: { // Some
					VAL v57 = mtp_std_maybe_Maybe_1_Some(v48);
					VAL v58 = (mw_std_str_ZPlusStr_pushZ_strZBang(v44, v46));
					VAL v59;
					VAL v60;
					mw_mirth_def_Def_qnameZ_hard(v42, v57, &v59, &v60);
					VAL v61;
					VAL v62;
					mw_mirth_name_QName_ZToStr(v59, v60, &v61, &v62);
					VAL v63 = (mw_std_str_ZPlusStr_pushZ_strZBang(v62, v58));
					STR* v64;
					STRLIT(v64, ", ", 2);
					int64_t v65 = 1LL /* True */;
					x56 = v65;
					x55 = v49;
					x54 = v63;
					x53 = v45;
					x52 = MKSTR(v64);
					x51 = v43;
					x50 = v61;
				} break;
				case 0LL: { // None
					int64_t v66 = 0LL /* False */;
					x56 = v66;
					x55 = v49;
					x54 = v46;
					x53 = v45;
					x52 = v44;
					x51 = v43;
					x50 = v42;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v41 = x56;
			v40 = x55;
			v39 = x54;
			v38 = x53;
			v37 = x52;
			v36 = x51;
			v35 = x50;
		}
		decref(v40);
		decref(v37);
		VAL v67 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(v36, v39, v35));
		x5 = v38;
		x4 = v67;
	} else {
		uint64_t v68 = VU64(VTUP(x2)->cells[2]);
		STR* v69;
		STRLIT(v69, "", 0);
		STR* v70;
		STRLIT(v70, "Ambiguous ", 10);
		VAL v71 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v70), MKSTR(v69)));
		VAL v72 = VVAL(VTUP(x2)->cells[1]);
		incref(v72);
		VAL v73 = (mw_std_str_ZPlusStr_pushZ_strZBang(v72, v71));
		STR* v74;
		STRLIT(v74, ". Can't decide between:", 23);
		VAL v75 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v74), v73));
		STR* v76;
		STRLIT(v76, " ", 1);
		VAL v77 = VVAL(VTUP(x2)->cells[4]);
		incref(v77);
		VAL v78;
		VAL v79;
		mw_std_list_List_1_uncons(v77, &v78, &v79);
		VAL x80;
		uint64_t x81;
		VAL x82;
		VAL x83;
		VAL x84;
		VAL x85;
		int64_t x86;
		switch (get_data_tag(v78)) {
			case 1LL: { // Some
				VAL v87 = mtp_std_maybe_Maybe_1_Some(v78);
				VAL v88 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v76), v75));
				VAL v89;
				VAL v90;
				mw_mirth_def_Def_qnameZ_hard(x1, v87, &v89, &v90);
				VAL v91;
				VAL v92;
				mw_mirth_name_QName_ZToStr(v89, v90, &v91, &v92);
				VAL v93 = (mw_std_str_ZPlusStr_pushZ_strZBang(v92, v88));
				STR* v94;
				STRLIT(v94, ", ", 2);
				int64_t v95 = 1LL /* True */;
				x86 = v95;
				x85 = v79;
				x84 = v93;
				x83 = x2;
				x82 = MKSTR(v94);
				x81 = v68;
				x80 = v91;
			} break;
			case 0LL: { // None
				int64_t v96 = 0LL /* False */;
				x86 = v96;
				x85 = v79;
				x84 = v75;
				x83 = x2;
				x82 = MKSTR(v76);
				x81 = v68;
				x80 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v97 = (x80);
		uint64_t v98 = x81;
		VAL v99 = x82;
		VAL v100 = (x83);
		VAL v101 = (x84);
		VAL v102 = x85;
		int64_t v103 = x86;
		while (((bool)v103)) {
			VAL v104 = (v97);
			uint64_t v105 = v98;
			VAL v106 = v99;
			VAL v107 = (v100);
			VAL v108 = (v101);
			VAL v109 = v102;
			VAL v110;
			VAL v111;
			mw_std_list_List_1_uncons(v109, &v110, &v111);
			VAL x112;
			uint64_t x113;
			VAL x114;
			VAL x115;
			VAL x116;
			VAL x117;
			int64_t x118;
			switch (get_data_tag(v110)) {
				case 1LL: { // Some
					VAL v119 = mtp_std_maybe_Maybe_1_Some(v110);
					VAL v120 = (mw_std_str_ZPlusStr_pushZ_strZBang(v106, v108));
					VAL v121;
					VAL v122;
					mw_mirth_def_Def_qnameZ_hard(v104, v119, &v121, &v122);
					VAL v123;
					VAL v124;
					mw_mirth_name_QName_ZToStr(v121, v122, &v123, &v124);
					VAL v125 = (mw_std_str_ZPlusStr_pushZ_strZBang(v124, v120));
					STR* v126;
					STRLIT(v126, ", ", 2);
					int64_t v127 = 1LL /* True */;
					x118 = v127;
					x117 = v111;
					x116 = v125;
					x115 = v107;
					x114 = MKSTR(v126);
					x113 = v105;
					x112 = v123;
				} break;
				case 0LL: { // None
					int64_t v128 = 0LL /* False */;
					x118 = v128;
					x117 = v111;
					x116 = v108;
					x115 = v107;
					x114 = v106;
					x113 = v105;
					x112 = v104;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v103 = x118;
			v102 = x117;
			v101 = x116;
			v100 = x115;
			v99 = x114;
			v98 = x113;
			v97 = x112;
		}
		decref(v102);
		decref(v99);
		VAL v129 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v98, v101, v97));
		x5 = v100;
		x4 = v129;
	}
	mw_mirth_elab_ZPlusResolveDef_rdrop(x5);
	return x4;
}
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown (VAL x1, VAL x2) {
	uint64_t v3 = VU64(VTUP(x2)->cells[2]);
	STR* v4;
	STRLIT(v4, "", 0);
	VAL v5 = VVAL(VTUP(x2)->cells[5]);
	incref(v5);
	VAL x6;
	uint64_t x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(v5)) {
		case 0LL: { // Nil
			STR* v10;
			STRLIT(v10, "Unknown ", 8);
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), MKSTR(v4)));
			VAL v12 = VVAL(VTUP(x2)->cells[1]);
			incref(v12);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(v12, v11));
			STR* v14;
			STRLIT(v14, " name, possibly a misspelling.", 30);
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), v13));
			x9 = v15;
			x8 = x2;
			x7 = v3;
			x6 = x1;
		} break;
		case 1LL: { // Cons
			VAL v16;
			VAL v17;
			mtp_std_list_List_1_Cons(v5, &v16, &v17);
			uint64_t x18;
			VAL x19;
			VAL x20;
			VAL x21;
			switch (get_data_tag(v17)) {
				case 0LL: { // Nil
					uint64_t x22;
					VAL x23;
					VAL x24;
					VAL x25;
					switch (get_data_tag(v16)) {
						case 0LL: { // RD_WRONG_SORT
							VAL v26 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v16);
							STR* v27;
							STRLIT(v27, "Expected a ", 11);
							VAL v28 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v27), MKSTR(v4)));
							VAL v29 = VVAL(VTUP(x2)->cells[1]);
							incref(v29);
							VAL v30 = (mw_std_str_ZPlusStr_pushZ_strZBang(v29, v28));
							STR* v31;
							STRLIT(v31, ", but ", 6);
							VAL v32 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v31), v30));
							VAL v33;
							VAL v34;
							mw_mirth_def_Def_qnameZ_hard(x1, v26, &v33, &v34);
							VAL v35;
							VAL v36;
							mw_mirth_name_QName_ZToStr(v33, v34, &v35, &v36);
							VAL v37 = (mw_std_str_ZPlusStr_pushZ_strZBang(v36, v32));
							STR* v38;
							STRLIT(v38, " is not a ", 10);
							VAL v39 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v38), v37));
							VAL v40 = VVAL(VTUP(x2)->cells[1]);
							incref(v40);
							VAL v41 = (mw_std_str_ZPlusStr_pushZ_strZBang(v40, v39));
							STR* v42;
							STRLIT(v42, ".", 1);
							VAL v43 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v42), v41));
							x25 = v43;
							x24 = x2;
							x23 = v35;
							x22 = v3;
						} break;
						case 2LL: { // RD_NOT_VISIBLE
							VAL v44 = mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE(v16);
							STR* v45;
							STRLIT(v45, "Not visible in current scope: ", 30);
							VAL v46 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v45), MKSTR(v4)));
							VAL v47;
							VAL v48;
							mw_mirth_def_Def_qnameZ_hard(x1, v44, &v47, &v48);
							VAL v49;
							VAL v50;
							mw_mirth_name_QName_ZToStr(v47, v48, &v49, &v50);
							VAL v51 = (mw_std_str_ZPlusStr_pushZ_strZBang(v50, v46));
							x25 = v51;
							x24 = x2;
							x23 = v49;
							x22 = v3;
						} break;
						case 3LL: { // RD_NOT_IMPORTED
							VAL v52 = mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v16);
							STR* v53;
							STRLIT(v53, "Not imported in current scope: ", 31);
							VAL v54 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v53), MKSTR(v4)));
							VAL v55;
							VAL v56;
							mw_mirth_def_Def_qnameZ_hard(x1, v52, &v55, &v56);
							VAL v57;
							VAL v58;
							mw_mirth_name_QName_ZToStr(v55, v56, &v57, &v58);
							VAL v59 = (mw_std_str_ZPlusStr_pushZ_strZBang(v58, v54));
							x25 = v59;
							x24 = x2;
							x23 = v57;
							x22 = v3;
						} break;
						case 1LL: { // RD_WRONG_ARITY
							VAL v60 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v16);
							VAL v61;
							VAL v62;
							mw_mirth_def_Def_qnameZ_hard(x1, v60, &v61, &v62);
							incref(v62);
							VAL v63;
							VAL v64;
							mw_mirth_name_QName_ZToStr(v61, v62, &v63, &v64);
							VAL v65 = (mw_std_str_ZPlusStr_pushZ_strZBang(v64, MKSTR(v4)));
							STR* v66;
							STRLIT(v66, " expects ", 9);
							VAL v67 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v66), v65));
							int64_t v68 = VI64(VTUP(v62)->cells[3]);
							decref(v62);
							STR* v69 = i64_show(v68);
							VAL v70 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v69), v67));
							STR* v71;
							STRLIT(v71, " arguments, but got ", 20);
							VAL v72 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v71), v70));
							uint64_t v73 = VU64(VTUP(x2)->cells[2]);
							int64_t v74 = mw_mirth_token_Token_numZ_args(v73);
							STR* v75 = i64_show(v74);
							VAL v76 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v75), v72));
							STR* v77;
							STRLIT(v77, ".", 1);
							VAL v78 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v77), v76));
							x25 = v78;
							x24 = x2;
							x23 = v63;
							x22 = v3;
						} break;
						case 4LL: { // RD_WRONG_QUALIFIER
							VAL v79 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v16);
							STR* v80;
							STRLIT(v80, "Qualified name not found. Perhaps you meant: ", 45);
							VAL v81 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v80), MKSTR(v4)));
							VAL v82;
							VAL v83;
							mw_mirth_def_Def_qnameZ_hard(x1, v79, &v82, &v83);
							VAL v84;
							VAL v85;
							mw_mirth_name_QName_ZToStr(v82, v83, &v84, &v85);
							VAL v86 = (mw_std_str_ZPlusStr_pushZ_strZBang(v85, v81));
							x25 = v86;
							x24 = x2;
							x23 = v84;
							x22 = v3;
						} break;
						case 5LL: { // RD_WRONG_CONSTRUCTOR
							VAL v87 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v16);
							STR* v88;
							STRLIT(v88, "Constructor is for a different type: ", 37);
							VAL v89 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v88), MKSTR(v4)));
							VAL v90;
							VAL v91;
							mw_mirth_def_Def_qnameZ_hard(x1, v87, &v90, &v91);
							VAL v92;
							VAL v93;
							mw_mirth_name_QName_ZToStr(v90, v91, &v92, &v93);
							VAL v94 = (mw_std_str_ZPlusStr_pushZ_strZBang(v93, v89));
							x25 = v94;
							x24 = x2;
							x23 = v92;
							x22 = v3;
						} break;
						case 7LL: { // RD_METHOD_WRONG_TYPE
							VAL v95 = mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v16);
							STR* v96;
							STRLIT(v96, "Method is for a different type: ", 32);
							VAL v97 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v96), MKSTR(v4)));
							VAL v98;
							VAL v99;
							mw_mirth_def_Def_qnameZ_hard(x1, v95, &v98, &v99);
							VAL v100;
							VAL v101;
							mw_mirth_name_QName_ZToStr(v98, v99, &v100, &v101);
							VAL v102 = (mw_std_str_ZPlusStr_pushZ_strZBang(v101, v97));
							x25 = v102;
							x24 = x2;
							x23 = v100;
							x22 = v3;
						} break;
						case 6LL: { // RD_METHOD_NOT_AVAILABLE
							VAL v103 = mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v16);
							STR* v104;
							STRLIT(v104, "Method is not available for current stack: ", 43);
							VAL v105 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v104), MKSTR(v4)));
							VAL v106;
							VAL v107;
							mw_mirth_def_Def_qnameZ_hard(x1, v103, &v106, &v107);
							VAL v108;
							VAL v109;
							mw_mirth_name_QName_ZToStr(v106, v107, &v108, &v109);
							VAL v110 = (mw_std_str_ZPlusStr_pushZ_strZBang(v109, v105));
							x25 = v110;
							x24 = x2;
							x23 = v108;
							x22 = v3;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x21 = x25;
					x20 = x24;
					x19 = x23;
					x18 = x22;
				} break;
				default: {
					VAL v111 = mtw_std_list_List_1_Cons(v16, v17);
					STR* v112;
					STRLIT(v112, "Multiple definitions for name, but none are suitable:", 53);
					VAL v113 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v112), MKSTR(v4)));
					STR* v114;
					STRLIT(v114, " ", 1);
					VAL v115;
					VAL v116;
					mw_std_list_List_1_uncons(v111, &v115, &v116);
					VAL x117;
					uint64_t x118;
					VAL x119;
					VAL x120;
					VAL x121;
					VAL x122;
					int64_t x123;
					switch (get_data_tag(v115)) {
						case 1LL: { // Some
							VAL v124 = mtp_std_maybe_Maybe_1_Some(v115);
							VAL v125 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v114), v113));
							uint64_t x126;
							VAL x127;
							VAL x128;
							VAL x129;
							switch (get_data_tag(v124)) {
								case 0LL: { // RD_WRONG_SORT
									VAL v130 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v124);
									VAL v131;
									VAL v132;
									mw_mirth_def_Def_qnameZ_hard(x1, v130, &v131, &v132);
									VAL v133;
									VAL v134;
									mw_mirth_name_QName_ZToStr(v131, v132, &v133, &v134);
									VAL v135 = (mw_std_str_ZPlusStr_pushZ_strZBang(v134, v125));
									STR* v136;
									STRLIT(v136, " is not a ", 10);
									VAL v137 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v136), v135));
									VAL v138 = VVAL(VTUP(x2)->cells[1]);
									incref(v138);
									VAL v139 = (mw_std_str_ZPlusStr_pushZ_strZBang(v138, v137));
									x129 = v139;
									x128 = x2;
									x127 = v133;
									x126 = v3;
								} break;
								case 2LL: { // RD_NOT_VISIBLE
									VAL v140 = mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE(v124);
									VAL v141;
									VAL v142;
									mw_mirth_def_Def_qnameZ_hard(x1, v140, &v141, &v142);
									VAL v143;
									VAL v144;
									mw_mirth_name_QName_ZToStr(v141, v142, &v143, &v144);
									VAL v145 = (mw_std_str_ZPlusStr_pushZ_strZBang(v144, v125));
									STR* v146;
									STRLIT(v146, " is not visible in current scope", 32);
									VAL v147 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v146), v145));
									x129 = v147;
									x128 = x2;
									x127 = v143;
									x126 = v3;
								} break;
								case 3LL: { // RD_NOT_IMPORTED
									VAL v148 = mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v124);
									VAL v149;
									VAL v150;
									mw_mirth_def_Def_qnameZ_hard(x1, v148, &v149, &v150);
									VAL v151;
									VAL v152;
									mw_mirth_name_QName_ZToStr(v149, v150, &v151, &v152);
									VAL v153 = (mw_std_str_ZPlusStr_pushZ_strZBang(v152, v125));
									STR* v154;
									STRLIT(v154, " is not imported in current scope", 33);
									VAL v155 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v154), v153));
									x129 = v155;
									x128 = x2;
									x127 = v151;
									x126 = v3;
								} break;
								case 1LL: { // RD_WRONG_ARITY
									VAL v156 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v124);
									VAL v157;
									VAL v158;
									mw_mirth_def_Def_qnameZ_hard(x1, v156, &v157, &v158);
									incref(v158);
									VAL v159;
									VAL v160;
									mw_mirth_name_QName_ZToStr(v157, v158, &v159, &v160);
									VAL v161 = (mw_std_str_ZPlusStr_pushZ_strZBang(v160, v125));
									STR* v162;
									STRLIT(v162, " expects ", 9);
									VAL v163 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v162), v161));
									int64_t v164 = VI64(VTUP(v158)->cells[3]);
									decref(v158);
									STR* v165 = i64_show(v164);
									VAL v166 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v165), v163));
									STR* v167;
									STRLIT(v167, " arguments", 10);
									VAL v168 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v167), v166));
									x129 = v168;
									x128 = x2;
									x127 = v159;
									x126 = v3;
								} break;
								case 4LL: { // RD_WRONG_QUALIFIER
									VAL v169 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v124);
									VAL v170;
									VAL v171;
									mw_mirth_def_Def_qnameZ_hard(x1, v169, &v170, &v171);
									VAL v172;
									VAL v173;
									mw_mirth_name_QName_ZToStr(v170, v171, &v172, &v173);
									VAL v174 = (mw_std_str_ZPlusStr_pushZ_strZBang(v173, v125));
									STR* v175;
									STRLIT(v175, " doesn't match the given qualified name", 39);
									VAL v176 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v175), v174));
									x129 = v176;
									x128 = x2;
									x127 = v172;
									x126 = v3;
								} break;
								case 5LL: { // RD_WRONG_CONSTRUCTOR
									VAL v177 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v124);
									VAL v178;
									VAL v179;
									mw_mirth_def_Def_qnameZ_hard(x1, v177, &v178, &v179);
									VAL v180;
									VAL v181;
									mw_mirth_name_QName_ZToStr(v178, v179, &v180, &v181);
									VAL v182 = (mw_std_str_ZPlusStr_pushZ_strZBang(v181, v125));
									STR* v183;
									STRLIT(v183, " is constructor for a different type", 36);
									VAL v184 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v183), v182));
									x129 = v184;
									x128 = x2;
									x127 = v180;
									x126 = v3;
								} break;
								case 7LL: { // RD_METHOD_WRONG_TYPE
									VAL v185 = mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v124);
									VAL v186;
									VAL v187;
									mw_mirth_def_Def_qnameZ_hard(x1, v185, &v186, &v187);
									VAL v188;
									VAL v189;
									mw_mirth_name_QName_ZToStr(v186, v187, &v188, &v189);
									VAL v190 = (mw_std_str_ZPlusStr_pushZ_strZBang(v189, v125));
									STR* v191;
									STRLIT(v191, " is method for a different type", 31);
									VAL v192 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v191), v190));
									x129 = v192;
									x128 = x2;
									x127 = v188;
									x126 = v3;
								} break;
								case 6LL: { // RD_METHOD_NOT_AVAILABLE
									VAL v193 = mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v124);
									VAL v194;
									VAL v195;
									mw_mirth_def_Def_qnameZ_hard(x1, v193, &v194, &v195);
									VAL v196;
									VAL v197;
									mw_mirth_name_QName_ZToStr(v194, v195, &v196, &v197);
									VAL v198 = (mw_std_str_ZPlusStr_pushZ_strZBang(v197, v125));
									STR* v199;
									STRLIT(v199, " is not avaliable for current stack", 35);
									VAL v200 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v199), v198));
									x129 = v200;
									x128 = x2;
									x127 = v196;
									x126 = v3;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							STR* v201;
							STRLIT(v201, ", ", 2);
							int64_t v202 = 1LL /* True */;
							x123 = v202;
							x122 = v116;
							x121 = MKSTR(v201);
							x120 = x129;
							x119 = x128;
							x118 = x126;
							x117 = x127;
						} break;
						case 0LL: { // None
							int64_t v203 = 0LL /* False */;
							x123 = v203;
							x122 = v116;
							x121 = MKSTR(v114);
							x120 = v113;
							x119 = x2;
							x118 = v3;
							x117 = x1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v204 = (x117);
					uint64_t v205 = x118;
					VAL v206 = (x119);
					VAL v207 = (x120);
					VAL v208 = x121;
					VAL v209 = x122;
					int64_t v210 = x123;
					while (((bool)v210)) {
						VAL v211 = (v204);
						uint64_t v212 = v205;
						VAL v213 = (v206);
						VAL v214 = (v207);
						VAL v215 = v208;
						VAL v216 = v209;
						VAL v217;
						VAL v218;
						mw_std_list_List_1_uncons(v216, &v217, &v218);
						VAL x219;
						uint64_t x220;
						VAL x221;
						VAL x222;
						VAL x223;
						VAL x224;
						int64_t x225;
						switch (get_data_tag(v217)) {
							case 1LL: { // Some
								VAL v226 = mtp_std_maybe_Maybe_1_Some(v217);
								VAL v227 = (mw_std_str_ZPlusStr_pushZ_strZBang(v215, v214));
								uint64_t x228;
								VAL x229;
								VAL x230;
								VAL x231;
								switch (get_data_tag(v226)) {
									case 0LL: { // RD_WRONG_SORT
										VAL v232 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v226);
										VAL v233;
										VAL v234;
										mw_mirth_def_Def_qnameZ_hard(v211, v232, &v233, &v234);
										VAL v235;
										VAL v236;
										mw_mirth_name_QName_ZToStr(v233, v234, &v235, &v236);
										VAL v237 = (mw_std_str_ZPlusStr_pushZ_strZBang(v236, v227));
										STR* v238;
										STRLIT(v238, " is not a ", 10);
										VAL v239 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v238), v237));
										VAL v240 = VVAL(VTUP(v213)->cells[1]);
										incref(v240);
										VAL v241 = (mw_std_str_ZPlusStr_pushZ_strZBang(v240, v239));
										x231 = v241;
										x230 = v213;
										x229 = v235;
										x228 = v212;
									} break;
									case 2LL: { // RD_NOT_VISIBLE
										VAL v242 = mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE(v226);
										VAL v243;
										VAL v244;
										mw_mirth_def_Def_qnameZ_hard(v211, v242, &v243, &v244);
										VAL v245;
										VAL v246;
										mw_mirth_name_QName_ZToStr(v243, v244, &v245, &v246);
										VAL v247 = (mw_std_str_ZPlusStr_pushZ_strZBang(v246, v227));
										STR* v248;
										STRLIT(v248, " is not visible in current scope", 32);
										VAL v249 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v248), v247));
										x231 = v249;
										x230 = v213;
										x229 = v245;
										x228 = v212;
									} break;
									case 3LL: { // RD_NOT_IMPORTED
										VAL v250 = mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v226);
										VAL v251;
										VAL v252;
										mw_mirth_def_Def_qnameZ_hard(v211, v250, &v251, &v252);
										VAL v253;
										VAL v254;
										mw_mirth_name_QName_ZToStr(v251, v252, &v253, &v254);
										VAL v255 = (mw_std_str_ZPlusStr_pushZ_strZBang(v254, v227));
										STR* v256;
										STRLIT(v256, " is not imported in current scope", 33);
										VAL v257 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v256), v255));
										x231 = v257;
										x230 = v213;
										x229 = v253;
										x228 = v212;
									} break;
									case 1LL: { // RD_WRONG_ARITY
										VAL v258 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v226);
										VAL v259;
										VAL v260;
										mw_mirth_def_Def_qnameZ_hard(v211, v258, &v259, &v260);
										incref(v260);
										VAL v261;
										VAL v262;
										mw_mirth_name_QName_ZToStr(v259, v260, &v261, &v262);
										VAL v263 = (mw_std_str_ZPlusStr_pushZ_strZBang(v262, v227));
										STR* v264;
										STRLIT(v264, " expects ", 9);
										VAL v265 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v264), v263));
										int64_t v266 = VI64(VTUP(v260)->cells[3]);
										decref(v260);
										STR* v267 = i64_show(v266);
										VAL v268 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v267), v265));
										STR* v269;
										STRLIT(v269, " arguments", 10);
										VAL v270 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v269), v268));
										x231 = v270;
										x230 = v213;
										x229 = v261;
										x228 = v212;
									} break;
									case 4LL: { // RD_WRONG_QUALIFIER
										VAL v271 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v226);
										VAL v272;
										VAL v273;
										mw_mirth_def_Def_qnameZ_hard(v211, v271, &v272, &v273);
										VAL v274;
										VAL v275;
										mw_mirth_name_QName_ZToStr(v272, v273, &v274, &v275);
										VAL v276 = (mw_std_str_ZPlusStr_pushZ_strZBang(v275, v227));
										STR* v277;
										STRLIT(v277, " doesn't match the given qualified name", 39);
										VAL v278 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v277), v276));
										x231 = v278;
										x230 = v213;
										x229 = v274;
										x228 = v212;
									} break;
									case 5LL: { // RD_WRONG_CONSTRUCTOR
										VAL v279 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v226);
										VAL v280;
										VAL v281;
										mw_mirth_def_Def_qnameZ_hard(v211, v279, &v280, &v281);
										VAL v282;
										VAL v283;
										mw_mirth_name_QName_ZToStr(v280, v281, &v282, &v283);
										VAL v284 = (mw_std_str_ZPlusStr_pushZ_strZBang(v283, v227));
										STR* v285;
										STRLIT(v285, " is constructor for a different type", 36);
										VAL v286 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v285), v284));
										x231 = v286;
										x230 = v213;
										x229 = v282;
										x228 = v212;
									} break;
									case 7LL: { // RD_METHOD_WRONG_TYPE
										VAL v287 = mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v226);
										VAL v288;
										VAL v289;
										mw_mirth_def_Def_qnameZ_hard(v211, v287, &v288, &v289);
										VAL v290;
										VAL v291;
										mw_mirth_name_QName_ZToStr(v288, v289, &v290, &v291);
										VAL v292 = (mw_std_str_ZPlusStr_pushZ_strZBang(v291, v227));
										STR* v293;
										STRLIT(v293, " is method for a different type", 31);
										VAL v294 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v293), v292));
										x231 = v294;
										x230 = v213;
										x229 = v290;
										x228 = v212;
									} break;
									case 6LL: { // RD_METHOD_NOT_AVAILABLE
										VAL v295 = mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v226);
										VAL v296;
										VAL v297;
										mw_mirth_def_Def_qnameZ_hard(v211, v295, &v296, &v297);
										VAL v298;
										VAL v299;
										mw_mirth_name_QName_ZToStr(v296, v297, &v298, &v299);
										VAL v300 = (mw_std_str_ZPlusStr_pushZ_strZBang(v299, v227));
										STR* v301;
										STRLIT(v301, " is not avaliable for current stack", 35);
										VAL v302 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v301), v300));
										x231 = v302;
										x230 = v213;
										x229 = v298;
										x228 = v212;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								STR* v303;
								STRLIT(v303, ", ", 2);
								int64_t v304 = 1LL /* True */;
								x225 = v304;
								x224 = v218;
								x223 = MKSTR(v303);
								x222 = x231;
								x221 = x230;
								x220 = x228;
								x219 = x229;
							} break;
							case 0LL: { // None
								int64_t v305 = 0LL /* False */;
								x225 = v305;
								x224 = v218;
								x223 = v215;
								x222 = v214;
								x221 = v213;
								x220 = v212;
								x219 = v211;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v210 = x225;
						v209 = x224;
						v208 = x223;
						v207 = x222;
						v206 = x221;
						v205 = x220;
						v204 = x219;
					}
					decref(v209);
					decref(v208);
					x21 = v207;
					x20 = v206;
					x19 = v204;
					x18 = v205;
				} break;
			}
			x9 = x21;
			x8 = x20;
			x7 = x18;
			x6 = x19;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v306 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x7, x9, x6));
	mw_mirth_elab_ZPlusResolveDef_rdrop(x8);
	return v306;
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_arity (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = VU64(VTUP(x2)->cells[2]);
	int64_t v6 = mw_mirth_token_Token_numZ_args(v5);
	VAL v7 = VVAL(VTUP(x2)->cells[4]);
	incref(v7);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = MKI64(0LL /* Nil */);
	VAL v10;
	VAL v11;
	mw_std_list_List_1_uncons(v7, &v10, &v11);
	VAL x12;
	int64_t x13;
	VAL x14;
	VAL x15;
	VAL x16;
	VAL x17;
	int64_t x18;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v19 = mtp_std_maybe_Maybe_1_Some(v10);
			incref(v19);
			int64_t v20 = mw_mirth_def_Def_arity(v19);
			int64_t v21 = mw_mirth_elab_arityZ_compatibleZAsk(v6, v20);
			VAL x22;
			int64_t x23;
			VAL x24;
			VAL x25;
			if (((bool)v21)) {
				VAL v26 = mtw_std_either_Either_2_Right(v19);
				x25 = v26;
				x24 = x2;
				x23 = v6;
				x22 = x1;
			} else {
				VAL v27 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v19);
				VAL v28 = mtw_std_either_Either_2_Left(v27);
				x25 = v28;
				x24 = x2;
				x23 = v6;
				x22 = x1;
			}
			VAL x29;
			int64_t x30;
			VAL x31;
			VAL x32;
			VAL x33;
			switch (get_data_tag(x25)) {
				case 0LL: { // Left
					VAL v34 = mtp_std_either_Either_2_Left(x25);
					VAL v35 = mtw_std_list_List_1_Cons(v34, v8);
					x33 = v9;
					x32 = v35;
					x31 = x24;
					x30 = x23;
					x29 = x22;
				} break;
				case 1LL: { // Right
					VAL v36 = mtp_std_either_Either_2_Right(x25);
					VAL v37 = mtw_std_list_List_1_Cons(v36, v9);
					x33 = v37;
					x32 = v8;
					x31 = x24;
					x30 = x23;
					x29 = x22;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v38 = 1LL /* True */;
			x18 = v38;
			x17 = v11;
			x16 = x33;
			x15 = x32;
			x14 = x31;
			x13 = x30;
			x12 = x29;
		} break;
		case 0LL: { // None
			int64_t v39 = 0LL /* False */;
			x18 = v39;
			x17 = v11;
			x16 = v9;
			x15 = v8;
			x14 = x2;
			x13 = v6;
			x12 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v40 = (x12);
	int64_t v41 = x13;
	VAL v42 = (x14);
	VAL v43 = x15;
	VAL v44 = x16;
	VAL v45 = x17;
	int64_t v46 = x18;
	while (((bool)v46)) {
		VAL v47 = (v40);
		int64_t v48 = v41;
		VAL v49 = (v42);
		VAL v50 = v43;
		VAL v51 = v44;
		VAL v52 = v45;
		VAL v53;
		VAL v54;
		mw_std_list_List_1_uncons(v52, &v53, &v54);
		VAL x55;
		int64_t x56;
		VAL x57;
		VAL x58;
		VAL x59;
		VAL x60;
		int64_t x61;
		switch (get_data_tag(v53)) {
			case 1LL: { // Some
				VAL v62 = mtp_std_maybe_Maybe_1_Some(v53);
				incref(v62);
				int64_t v63 = mw_mirth_def_Def_arity(v62);
				int64_t v64 = mw_mirth_elab_arityZ_compatibleZAsk(v48, v63);
				VAL x65;
				int64_t x66;
				VAL x67;
				VAL x68;
				if (((bool)v64)) {
					VAL v69 = mtw_std_either_Either_2_Right(v62);
					x68 = v69;
					x67 = v49;
					x66 = v48;
					x65 = v47;
				} else {
					VAL v70 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v62);
					VAL v71 = mtw_std_either_Either_2_Left(v70);
					x68 = v71;
					x67 = v49;
					x66 = v48;
					x65 = v47;
				}
				VAL x72;
				int64_t x73;
				VAL x74;
				VAL x75;
				VAL x76;
				switch (get_data_tag(x68)) {
					case 0LL: { // Left
						VAL v77 = mtp_std_either_Either_2_Left(x68);
						VAL v78 = mtw_std_list_List_1_Cons(v77, v50);
						x76 = v51;
						x75 = v78;
						x74 = x67;
						x73 = x66;
						x72 = x65;
					} break;
					case 1LL: { // Right
						VAL v79 = mtp_std_either_Either_2_Right(x68);
						VAL v80 = mtw_std_list_List_1_Cons(v79, v51);
						x76 = v80;
						x75 = v50;
						x74 = x67;
						x73 = x66;
						x72 = x65;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v81 = 1LL /* True */;
				x61 = v81;
				x60 = v54;
				x59 = x76;
				x58 = x75;
				x57 = x74;
				x56 = x73;
				x55 = x72;
			} break;
			case 0LL: { // None
				int64_t v82 = 0LL /* False */;
				x61 = v82;
				x60 = v54;
				x59 = v51;
				x58 = v50;
				x57 = v49;
				x56 = v48;
				x55 = v47;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v46 = x61;
		v45 = x60;
		v44 = x59;
		v43 = x58;
		v42 = x57;
		v41 = x56;
		v40 = x55;
	}
	decref(v45);
	VAL v83 = mw_std_list_List_1_reverse(v43);
	VAL v84 = mw_std_list_List_1_reverse(v44);
	VAL v85 = VVAL(VTUP(v42)->cells[5]);
	incref(v85);
	VAL v86 = mw_std_list_List_1_cat(v83, v85);
	VAL v87 = VTUP(v42)->cells[5];
	decref(v87);
	VTUP(v42)->cells[5] = v86;
	VAL v88 = VTUP(v42)->cells[4];
	decref(v88);
	VTUP(v42)->cells[4] = v84;
	*x4 = v42;
	*x3 = v40;
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = VU64(VTUP(x2)->cells[2]);
	VAL v6 = mw_mirth_token_Token_dnameZAsk(v5);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v10 = VVAL(VTUP(x2)->cells[4]);
			incref(v10);
			VAL v11 = MKI64(0LL /* Nil */);
			VAL v12 = MKI64(0LL /* Nil */);
			VAL v13;
			VAL v14;
			mw_std_list_List_1_uncons(v10, &v13, &v14);
			VAL x15;
			VAL x16;
			VAL x17;
			VAL x18;
			VAL x19;
			VAL x20;
			int64_t x21;
			switch (get_data_tag(v13)) {
				case 1LL: { // Some
					VAL v22 = mtp_std_maybe_Maybe_1_Some(v13);
					incref(v9);
					incref(v22);
					VAL v23;
					VAL v24;
					mw_mirth_def_Def_qnameZ_hard(x1, v22, &v23, &v24);
					VAL v25;
					VAL v26;
					VAL v27;
					mw_mirth_name_QName_climbZ_upZ_dnameZAsk(v23, x2, v9, v24, &v25, &v26, &v27);
					int64_t v28 = mw_std_list_List_1_emptyZAsk(v27);
					bool v29 = !((bool)v28);
					VAL x30;
					VAL x31;
					VAL x32;
					VAL x33;
					if (v29) {
						VAL v34 = mtw_std_either_Either_2_Right(v22);
						x33 = v34;
						x32 = v26;
						x31 = v9;
						x30 = v25;
					} else {
						VAL v35 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v22);
						VAL v36 = mtw_std_either_Either_2_Left(v35);
						x33 = v36;
						x32 = v26;
						x31 = v9;
						x30 = v25;
					}
					VAL x37;
					VAL x38;
					VAL x39;
					VAL x40;
					VAL x41;
					switch (get_data_tag(x33)) {
						case 0LL: { // Left
							VAL v42 = mtp_std_either_Either_2_Left(x33);
							VAL v43 = mtw_std_list_List_1_Cons(v42, v11);
							x41 = v12;
							x40 = v43;
							x39 = x32;
							x38 = x31;
							x37 = x30;
						} break;
						case 1LL: { // Right
							VAL v44 = mtp_std_either_Either_2_Right(x33);
							VAL v45 = mtw_std_list_List_1_Cons(v44, v12);
							x41 = v45;
							x40 = v11;
							x39 = x32;
							x38 = x31;
							x37 = x30;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					int64_t v46 = 1LL /* True */;
					x21 = v46;
					x20 = v14;
					x19 = x41;
					x18 = x40;
					x17 = x39;
					x16 = x38;
					x15 = x37;
				} break;
				case 0LL: { // None
					int64_t v47 = 0LL /* False */;
					x21 = v47;
					x20 = v14;
					x19 = v12;
					x18 = v11;
					x17 = x2;
					x16 = v9;
					x15 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v48 = (x15);
			VAL v49 = x16;
			VAL v50 = (x17);
			VAL v51 = x18;
			VAL v52 = x19;
			VAL v53 = x20;
			int64_t v54 = x21;
			while (((bool)v54)) {
				VAL v55 = (v48);
				VAL v56 = v49;
				VAL v57 = (v50);
				VAL v58 = v51;
				VAL v59 = v52;
				VAL v60 = v53;
				VAL v61;
				VAL v62;
				mw_std_list_List_1_uncons(v60, &v61, &v62);
				VAL x63;
				VAL x64;
				VAL x65;
				VAL x66;
				VAL x67;
				VAL x68;
				int64_t x69;
				switch (get_data_tag(v61)) {
					case 1LL: { // Some
						VAL v70 = mtp_std_maybe_Maybe_1_Some(v61);
						incref(v56);
						incref(v70);
						VAL v71;
						VAL v72;
						mw_mirth_def_Def_qnameZ_hard(v55, v70, &v71, &v72);
						VAL v73;
						VAL v74;
						VAL v75;
						mw_mirth_name_QName_climbZ_upZ_dnameZAsk(v71, v57, v56, v72, &v73, &v74, &v75);
						int64_t v76 = mw_std_list_List_1_emptyZAsk(v75);
						bool v77 = !((bool)v76);
						VAL x78;
						VAL x79;
						VAL x80;
						VAL x81;
						if (v77) {
							VAL v82 = mtw_std_either_Either_2_Right(v70);
							x81 = v82;
							x80 = v74;
							x79 = v56;
							x78 = v73;
						} else {
							VAL v83 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v70);
							VAL v84 = mtw_std_either_Either_2_Left(v83);
							x81 = v84;
							x80 = v74;
							x79 = v56;
							x78 = v73;
						}
						VAL x85;
						VAL x86;
						VAL x87;
						VAL x88;
						VAL x89;
						switch (get_data_tag(x81)) {
							case 0LL: { // Left
								VAL v90 = mtp_std_either_Either_2_Left(x81);
								VAL v91 = mtw_std_list_List_1_Cons(v90, v58);
								x89 = v59;
								x88 = v91;
								x87 = x80;
								x86 = x79;
								x85 = x78;
							} break;
							case 1LL: { // Right
								VAL v92 = mtp_std_either_Either_2_Right(x81);
								VAL v93 = mtw_std_list_List_1_Cons(v92, v59);
								x89 = v93;
								x88 = v58;
								x87 = x80;
								x86 = x79;
								x85 = x78;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v94 = 1LL /* True */;
						x69 = v94;
						x68 = v62;
						x67 = x89;
						x66 = x88;
						x65 = x87;
						x64 = x86;
						x63 = x85;
					} break;
					case 0LL: { // None
						int64_t v95 = 0LL /* False */;
						x69 = v95;
						x68 = v62;
						x67 = v59;
						x66 = v58;
						x65 = v57;
						x64 = v56;
						x63 = v55;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v54 = x69;
				v53 = x68;
				v52 = x67;
				v51 = x66;
				v50 = x65;
				v49 = x64;
				v48 = x63;
			}
			decref(v53);
			VAL v96 = mw_std_list_List_1_reverse(v51);
			VAL v97 = mw_std_list_List_1_reverse(v52);
			VAL v98 = VVAL(VTUP(v50)->cells[5]);
			incref(v98);
			VAL v99 = mw_std_list_List_1_cat(v96, v98);
			VAL v100 = VTUP(v50)->cells[5];
			decref(v100);
			VTUP(v50)->cells[5] = v99;
			VAL v101 = VTUP(v50)->cells[4];
			decref(v101);
			VTUP(v50)->cells[4] = v97;
			decref(v49);
			x8 = v50;
			x7 = v48;
		} break;
		case 0LL: { // None
			x8 = x2;
			x7 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_roots (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x3)->cells[3]);
	incref(v6);
	VAL x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 0LL: { // Left
			VAL v10 = mtp_std_either_Either_2_Left(v6);
			VAL v11 = VVAL(VTUP(x3)->cells[4]);
			incref(v11);
			VAL v12 = MKI64(0LL /* Nil */);
			VAL v13 = MKI64(0LL /* Nil */);
			VAL v14;
			VAL v15;
			mw_std_list_List_1_uncons(v11, &v14, &v15);
			VAL x16;
			VAL x17;
			uint64_t x18;
			VAL x19;
			VAL x20;
			VAL x21;
			VAL x22;
			int64_t x23;
			switch (get_data_tag(v14)) {
				case 1LL: { // Some
					VAL v24 = mtp_std_maybe_Maybe_1_Some(v14);
					incref(x1);
					incref(v24);
					VAL v25;
					VAL v26;
					mw_mirth_def_Def_qnameZ_hard(x2, v24, &v25, &v26);
					VAL v27 = VVAL(VTUP(v26)->cells[1]);
					incref(v27);
					decref(v26);
					VAL v28 = MKI64(0LL /* None */);
					VAL v29;
					VAL v30;
					mw_std_list_List_1_uncons(x1, &v29, &v30);
					uint64_t x31;
					VAL x32;
					VAL x33;
					VAL x34;
					VAL x35;
					VAL x36;
					VAL x37;
					VAL x38;
					int64_t x39;
					switch (get_data_tag(v29)) {
						case 1LL: { // Some
							VAL v40 = mtp_std_maybe_Maybe_1_Some(v29);
							incref(v40);
							incref(v27);
							int64_t v41 = mw_mirth_name_Namespace_ZEqualZEqual(v27, v40);
							uint64_t x42;
							VAL x43;
							VAL x44;
							VAL x45;
							VAL x46;
							VAL x47;
							VAL x48;
							if (((bool)v41)) {
								VAL v49 = mtw_std_maybe_Maybe_1_Some(v40);
								x48 = v49;
								x47 = v27;
								x46 = x3;
								x45 = v25;
								x44 = v24;
								x43 = x1;
								x42 = VU64(v10);
							} else {
								decref(v40);
								VAL v50 = MKI64(0LL /* None */);
								x48 = v50;
								x47 = v27;
								x46 = x3;
								x45 = v25;
								x44 = v24;
								x43 = x1;
								x42 = VU64(v10);
							}
							uint64_t x51;
							VAL x52;
							VAL x53;
							VAL x54;
							VAL x55;
							VAL x56;
							VAL x57;
							VAL x58;
							switch (get_data_tag(x48)) {
								case 0LL: { // None
									x58 = v30;
									x57 = v28;
									x56 = x47;
									x55 = x46;
									x54 = x45;
									x53 = x44;
									x52 = x43;
									x51 = x42;
								} break;
								default: {
									decref(v30);
									decref(v28);
									VAL v59 = MKI64(0LL /* Nil */);
									x58 = v59;
									x57 = x48;
									x56 = x47;
									x55 = x46;
									x54 = x45;
									x53 = x44;
									x52 = x43;
									x51 = x42;
								} break;
							}
							int64_t v60 = 1LL /* True */;
							x39 = v60;
							x38 = x58;
							x37 = x57;
							x36 = x56;
							x35 = x55;
							x34 = x54;
							x33 = x53;
							x32 = x52;
							x31 = x51;
						} break;
						case 0LL: { // None
							int64_t v61 = 0LL /* False */;
							x39 = v61;
							x38 = v30;
							x37 = v28;
							x36 = v27;
							x35 = x3;
							x34 = v25;
							x33 = v24;
							x32 = x1;
							x31 = VU64(v10);
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					uint64_t v62 = x31;
					VAL v63 = x32;
					VAL v64 = x33;
					VAL v65 = (x34);
					VAL v66 = (x35);
					VAL v67 = x36;
					VAL v68 = x37;
					VAL v69 = x38;
					int64_t v70 = x39;
					while (((bool)v70)) {
						uint64_t v71 = v62;
						VAL v72 = v63;
						VAL v73 = v64;
						VAL v74 = (v65);
						VAL v75 = (v66);
						VAL v76 = v67;
						VAL v77 = v68;
						VAL v78 = v69;
						VAL v79;
						VAL v80;
						mw_std_list_List_1_uncons(v78, &v79, &v80);
						uint64_t x81;
						VAL x82;
						VAL x83;
						VAL x84;
						VAL x85;
						VAL x86;
						VAL x87;
						VAL x88;
						int64_t x89;
						switch (get_data_tag(v79)) {
							case 1LL: { // Some
								VAL v90 = mtp_std_maybe_Maybe_1_Some(v79);
								incref(v90);
								incref(v76);
								int64_t v91 = mw_mirth_name_Namespace_ZEqualZEqual(v76, v90);
								uint64_t x92;
								VAL x93;
								VAL x94;
								VAL x95;
								VAL x96;
								VAL x97;
								VAL x98;
								if (((bool)v91)) {
									VAL v99 = mtw_std_maybe_Maybe_1_Some(v90);
									x98 = v99;
									x97 = v76;
									x96 = v75;
									x95 = v74;
									x94 = v73;
									x93 = v72;
									x92 = v71;
								} else {
									decref(v90);
									VAL v100 = MKI64(0LL /* None */);
									x98 = v100;
									x97 = v76;
									x96 = v75;
									x95 = v74;
									x94 = v73;
									x93 = v72;
									x92 = v71;
								}
								uint64_t x101;
								VAL x102;
								VAL x103;
								VAL x104;
								VAL x105;
								VAL x106;
								VAL x107;
								VAL x108;
								switch (get_data_tag(x98)) {
									case 0LL: { // None
										x108 = v80;
										x107 = v77;
										x106 = x97;
										x105 = x96;
										x104 = x95;
										x103 = x94;
										x102 = x93;
										x101 = x92;
									} break;
									default: {
										decref(v80);
										decref(v77);
										VAL v109 = MKI64(0LL /* Nil */);
										x108 = v109;
										x107 = x98;
										x106 = x97;
										x105 = x96;
										x104 = x95;
										x103 = x94;
										x102 = x93;
										x101 = x92;
									} break;
								}
								int64_t v110 = 1LL /* True */;
								x89 = v110;
								x88 = x108;
								x87 = x107;
								x86 = x106;
								x85 = x105;
								x84 = x104;
								x83 = x103;
								x82 = x102;
								x81 = x101;
							} break;
							case 0LL: { // None
								int64_t v111 = 0LL /* False */;
								x89 = v111;
								x88 = v80;
								x87 = v77;
								x86 = v76;
								x85 = v75;
								x84 = v74;
								x83 = v73;
								x82 = v72;
								x81 = v71;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v70 = x89;
						v69 = x88;
						v68 = x87;
						v67 = x86;
						v66 = x85;
						v65 = x84;
						v64 = x83;
						v63 = x82;
						v62 = x81;
					}
					decref(v69);
					decref(v67);
					int64_t v112 = mw_std_maybe_Maybe_1_someZAsk(v68);
					uint64_t x113;
					VAL x114;
					VAL x115;
					VAL x116;
					VAL x117;
					int64_t x118;
					if (((bool)v112)) {
						int64_t v119 = 1LL /* True */;
						x118 = v119;
						x117 = v66;
						x116 = v65;
						x115 = v64;
						x114 = v63;
						x113 = v62;
					} else {
						uint64_t v120 = VU64(VTUP(v66)->cells[2]);
						incref(v64);
						VAL v121;
						int64_t v122;
						mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk(v65, v120, v64, &v121, &v122);
						x118 = v122;
						x117 = v66;
						x116 = v121;
						x115 = v64;
						x114 = v63;
						x113 = v62;
					}
					VAL x123;
					VAL x124;
					uint64_t x125;
					VAL x126;
					VAL x127;
					if (((bool)x118)) {
						VAL v128 = mtw_std_either_Either_2_Right(x115);
						x127 = v128;
						x126 = x117;
						x125 = x113;
						x124 = x116;
						x123 = x114;
					} else {
						incref(x115);
						VAL v129;
						VAL v130;
						mw_mirth_def_Def_qnameZ_hard(x116, x115, &v129, &v130);
						VAL v131 = VVAL(VTUP(v130)->cells[1]);
						incref(v131);
						decref(v130);
						VAL x132;
						VAL x133;
						uint64_t x134;
						VAL x135;
						VAL x136;
						switch (get_data_tag(v131)) {
							case 3LL: { // NAMESPACE_TYCON
								VAL v137 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v131);
								decref(v137);
								int64_t v138 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(x113);
								VAL x139;
								VAL x140;
								uint64_t x141;
								VAL x142;
								VAL x143;
								if (((bool)v138)) {
									incref(x114);
									int64_t v144 = mw_std_list_List_1_emptyZAsk(x114);
									VAL x145;
									VAL x146;
									uint64_t x147;
									VAL x148;
									VAL x149;
									if (((bool)v144)) {
										VAL v150 = mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(x115);
										x149 = v150;
										x148 = x114;
										x147 = x113;
										x146 = x117;
										x145 = v129;
									} else {
										VAL v151 = mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(x115);
										x149 = v151;
										x148 = x114;
										x147 = x113;
										x146 = x117;
										x145 = v129;
									}
									x143 = x149;
									x142 = x148;
									x141 = x147;
									x140 = x146;
									x139 = x145;
								} else {
									VAL v152 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(x115);
									x143 = v152;
									x142 = x114;
									x141 = x113;
									x140 = x117;
									x139 = v129;
								}
								x136 = x143;
								x135 = x142;
								x134 = x141;
								x133 = x140;
								x132 = x139;
							} break;
							default: {
								decref(v131);
								VAL v153 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(x115);
								x136 = v153;
								x135 = x114;
								x134 = x113;
								x133 = x117;
								x132 = v129;
							} break;
						}
						VAL v154 = mtw_std_either_Either_2_Left(x136);
						x127 = v154;
						x126 = x133;
						x125 = x134;
						x124 = x132;
						x123 = x135;
					}
					VAL x155;
					VAL x156;
					uint64_t x157;
					VAL x158;
					VAL x159;
					VAL x160;
					switch (get_data_tag(x127)) {
						case 0LL: { // Left
							VAL v161 = mtp_std_either_Either_2_Left(x127);
							VAL v162 = mtw_std_list_List_1_Cons(v161, v12);
							x160 = v13;
							x159 = v162;
							x158 = x126;
							x157 = x125;
							x156 = x124;
							x155 = x123;
						} break;
						case 1LL: { // Right
							VAL v163 = mtp_std_either_Either_2_Right(x127);
							VAL v164 = mtw_std_list_List_1_Cons(v163, v13);
							x160 = v164;
							x159 = v12;
							x158 = x126;
							x157 = x125;
							x156 = x124;
							x155 = x123;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					int64_t v165 = 1LL /* True */;
					x23 = v165;
					x22 = v15;
					x21 = x160;
					x20 = x159;
					x19 = x158;
					x18 = x157;
					x17 = x156;
					x16 = x155;
				} break;
				case 0LL: { // None
					int64_t v166 = 0LL /* False */;
					x23 = v166;
					x22 = v15;
					x21 = v13;
					x20 = v12;
					x19 = x3;
					x18 = VU64(v10);
					x17 = x2;
					x16 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v167 = x16;
			VAL v168 = (x17);
			uint64_t v169 = x18;
			VAL v170 = (x19);
			VAL v171 = x20;
			VAL v172 = x21;
			VAL v173 = x22;
			int64_t v174 = x23;
			while (((bool)v174)) {
				VAL v175 = v167;
				VAL v176 = (v168);
				uint64_t v177 = v169;
				VAL v178 = (v170);
				VAL v179 = v171;
				VAL v180 = v172;
				VAL v181 = v173;
				VAL v182;
				VAL v183;
				mw_std_list_List_1_uncons(v181, &v182, &v183);
				VAL x184;
				VAL x185;
				uint64_t x186;
				VAL x187;
				VAL x188;
				VAL x189;
				VAL x190;
				int64_t x191;
				switch (get_data_tag(v182)) {
					case 1LL: { // Some
						VAL v192 = mtp_std_maybe_Maybe_1_Some(v182);
						incref(v175);
						incref(v192);
						VAL v193;
						VAL v194;
						mw_mirth_def_Def_qnameZ_hard(v176, v192, &v193, &v194);
						VAL v195 = VVAL(VTUP(v194)->cells[1]);
						incref(v195);
						decref(v194);
						VAL v196 = MKI64(0LL /* None */);
						VAL v197;
						VAL v198;
						mw_std_list_List_1_uncons(v175, &v197, &v198);
						uint64_t x199;
						VAL x200;
						VAL x201;
						VAL x202;
						VAL x203;
						VAL x204;
						VAL x205;
						VAL x206;
						int64_t x207;
						switch (get_data_tag(v197)) {
							case 1LL: { // Some
								VAL v208 = mtp_std_maybe_Maybe_1_Some(v197);
								incref(v208);
								incref(v195);
								int64_t v209 = mw_mirth_name_Namespace_ZEqualZEqual(v195, v208);
								uint64_t x210;
								VAL x211;
								VAL x212;
								VAL x213;
								VAL x214;
								VAL x215;
								VAL x216;
								if (((bool)v209)) {
									VAL v217 = mtw_std_maybe_Maybe_1_Some(v208);
									x216 = v217;
									x215 = v195;
									x214 = v178;
									x213 = v193;
									x212 = v192;
									x211 = v175;
									x210 = v177;
								} else {
									decref(v208);
									VAL v218 = MKI64(0LL /* None */);
									x216 = v218;
									x215 = v195;
									x214 = v178;
									x213 = v193;
									x212 = v192;
									x211 = v175;
									x210 = v177;
								}
								uint64_t x219;
								VAL x220;
								VAL x221;
								VAL x222;
								VAL x223;
								VAL x224;
								VAL x225;
								VAL x226;
								switch (get_data_tag(x216)) {
									case 0LL: { // None
										x226 = v198;
										x225 = v196;
										x224 = x215;
										x223 = x214;
										x222 = x213;
										x221 = x212;
										x220 = x211;
										x219 = x210;
									} break;
									default: {
										decref(v198);
										decref(v196);
										VAL v227 = MKI64(0LL /* Nil */);
										x226 = v227;
										x225 = x216;
										x224 = x215;
										x223 = x214;
										x222 = x213;
										x221 = x212;
										x220 = x211;
										x219 = x210;
									} break;
								}
								int64_t v228 = 1LL /* True */;
								x207 = v228;
								x206 = x226;
								x205 = x225;
								x204 = x224;
								x203 = x223;
								x202 = x222;
								x201 = x221;
								x200 = x220;
								x199 = x219;
							} break;
							case 0LL: { // None
								int64_t v229 = 0LL /* False */;
								x207 = v229;
								x206 = v198;
								x205 = v196;
								x204 = v195;
								x203 = v178;
								x202 = v193;
								x201 = v192;
								x200 = v175;
								x199 = v177;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						uint64_t v230 = x199;
						VAL v231 = x200;
						VAL v232 = x201;
						VAL v233 = (x202);
						VAL v234 = (x203);
						VAL v235 = x204;
						VAL v236 = x205;
						VAL v237 = x206;
						int64_t v238 = x207;
						while (((bool)v238)) {
							uint64_t v239 = v230;
							VAL v240 = v231;
							VAL v241 = v232;
							VAL v242 = (v233);
							VAL v243 = (v234);
							VAL v244 = v235;
							VAL v245 = v236;
							VAL v246 = v237;
							VAL v247;
							VAL v248;
							mw_std_list_List_1_uncons(v246, &v247, &v248);
							uint64_t x249;
							VAL x250;
							VAL x251;
							VAL x252;
							VAL x253;
							VAL x254;
							VAL x255;
							VAL x256;
							int64_t x257;
							switch (get_data_tag(v247)) {
								case 1LL: { // Some
									VAL v258 = mtp_std_maybe_Maybe_1_Some(v247);
									incref(v258);
									incref(v244);
									int64_t v259 = mw_mirth_name_Namespace_ZEqualZEqual(v244, v258);
									uint64_t x260;
									VAL x261;
									VAL x262;
									VAL x263;
									VAL x264;
									VAL x265;
									VAL x266;
									if (((bool)v259)) {
										VAL v267 = mtw_std_maybe_Maybe_1_Some(v258);
										x266 = v267;
										x265 = v244;
										x264 = v243;
										x263 = v242;
										x262 = v241;
										x261 = v240;
										x260 = v239;
									} else {
										decref(v258);
										VAL v268 = MKI64(0LL /* None */);
										x266 = v268;
										x265 = v244;
										x264 = v243;
										x263 = v242;
										x262 = v241;
										x261 = v240;
										x260 = v239;
									}
									uint64_t x269;
									VAL x270;
									VAL x271;
									VAL x272;
									VAL x273;
									VAL x274;
									VAL x275;
									VAL x276;
									switch (get_data_tag(x266)) {
										case 0LL: { // None
											x276 = v248;
											x275 = v245;
											x274 = x265;
											x273 = x264;
											x272 = x263;
											x271 = x262;
											x270 = x261;
											x269 = x260;
										} break;
										default: {
											decref(v248);
											decref(v245);
											VAL v277 = MKI64(0LL /* Nil */);
											x276 = v277;
											x275 = x266;
											x274 = x265;
											x273 = x264;
											x272 = x263;
											x271 = x262;
											x270 = x261;
											x269 = x260;
										} break;
									}
									int64_t v278 = 1LL /* True */;
									x257 = v278;
									x256 = x276;
									x255 = x275;
									x254 = x274;
									x253 = x273;
									x252 = x272;
									x251 = x271;
									x250 = x270;
									x249 = x269;
								} break;
								case 0LL: { // None
									int64_t v279 = 0LL /* False */;
									x257 = v279;
									x256 = v248;
									x255 = v245;
									x254 = v244;
									x253 = v243;
									x252 = v242;
									x251 = v241;
									x250 = v240;
									x249 = v239;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v238 = x257;
							v237 = x256;
							v236 = x255;
							v235 = x254;
							v234 = x253;
							v233 = x252;
							v232 = x251;
							v231 = x250;
							v230 = x249;
						}
						decref(v237);
						decref(v235);
						int64_t v280 = mw_std_maybe_Maybe_1_someZAsk(v236);
						uint64_t x281;
						VAL x282;
						VAL x283;
						VAL x284;
						VAL x285;
						int64_t x286;
						if (((bool)v280)) {
							int64_t v287 = 1LL /* True */;
							x286 = v287;
							x285 = v234;
							x284 = v233;
							x283 = v232;
							x282 = v231;
							x281 = v230;
						} else {
							uint64_t v288 = VU64(VTUP(v234)->cells[2]);
							incref(v232);
							VAL v289;
							int64_t v290;
							mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk(v233, v288, v232, &v289, &v290);
							x286 = v290;
							x285 = v234;
							x284 = v289;
							x283 = v232;
							x282 = v231;
							x281 = v230;
						}
						VAL x291;
						VAL x292;
						uint64_t x293;
						VAL x294;
						VAL x295;
						if (((bool)x286)) {
							VAL v296 = mtw_std_either_Either_2_Right(x283);
							x295 = v296;
							x294 = x285;
							x293 = x281;
							x292 = x284;
							x291 = x282;
						} else {
							incref(x283);
							VAL v297;
							VAL v298;
							mw_mirth_def_Def_qnameZ_hard(x284, x283, &v297, &v298);
							VAL v299 = VVAL(VTUP(v298)->cells[1]);
							incref(v299);
							decref(v298);
							VAL x300;
							VAL x301;
							uint64_t x302;
							VAL x303;
							VAL x304;
							switch (get_data_tag(v299)) {
								case 3LL: { // NAMESPACE_TYCON
									VAL v305 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v299);
									decref(v305);
									int64_t v306 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(x281);
									VAL x307;
									VAL x308;
									uint64_t x309;
									VAL x310;
									VAL x311;
									if (((bool)v306)) {
										incref(x282);
										int64_t v312 = mw_std_list_List_1_emptyZAsk(x282);
										VAL x313;
										VAL x314;
										uint64_t x315;
										VAL x316;
										VAL x317;
										if (((bool)v312)) {
											VAL v318 = mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(x283);
											x317 = v318;
											x316 = x282;
											x315 = x281;
											x314 = x285;
											x313 = v297;
										} else {
											VAL v319 = mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(x283);
											x317 = v319;
											x316 = x282;
											x315 = x281;
											x314 = x285;
											x313 = v297;
										}
										x311 = x317;
										x310 = x316;
										x309 = x315;
										x308 = x314;
										x307 = x313;
									} else {
										VAL v320 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(x283);
										x311 = v320;
										x310 = x282;
										x309 = x281;
										x308 = x285;
										x307 = v297;
									}
									x304 = x311;
									x303 = x310;
									x302 = x309;
									x301 = x308;
									x300 = x307;
								} break;
								default: {
									decref(v299);
									VAL v321 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(x283);
									x304 = v321;
									x303 = x282;
									x302 = x281;
									x301 = x285;
									x300 = v297;
								} break;
							}
							VAL v322 = mtw_std_either_Either_2_Left(x304);
							x295 = v322;
							x294 = x301;
							x293 = x302;
							x292 = x300;
							x291 = x303;
						}
						VAL x323;
						VAL x324;
						uint64_t x325;
						VAL x326;
						VAL x327;
						VAL x328;
						switch (get_data_tag(x295)) {
							case 0LL: { // Left
								VAL v329 = mtp_std_either_Either_2_Left(x295);
								VAL v330 = mtw_std_list_List_1_Cons(v329, v179);
								x328 = v180;
								x327 = v330;
								x326 = x294;
								x325 = x293;
								x324 = x292;
								x323 = x291;
							} break;
							case 1LL: { // Right
								VAL v331 = mtp_std_either_Either_2_Right(x295);
								VAL v332 = mtw_std_list_List_1_Cons(v331, v180);
								x328 = v332;
								x327 = v179;
								x326 = x294;
								x325 = x293;
								x324 = x292;
								x323 = x291;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v333 = 1LL /* True */;
						x191 = v333;
						x190 = v183;
						x189 = x328;
						x188 = x327;
						x187 = x326;
						x186 = x325;
						x185 = x324;
						x184 = x323;
					} break;
					case 0LL: { // None
						int64_t v334 = 0LL /* False */;
						x191 = v334;
						x190 = v183;
						x189 = v180;
						x188 = v179;
						x187 = v178;
						x186 = v177;
						x185 = v176;
						x184 = v175;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v174 = x191;
				v173 = x190;
				v172 = x189;
				v171 = x188;
				v170 = x187;
				v169 = x186;
				v168 = x185;
				v167 = x184;
			}
			decref(v173);
			VAL v335 = mw_std_list_List_1_reverse(v171);
			VAL v336 = mw_std_list_List_1_reverse(v172);
			VAL v337 = VVAL(VTUP(v170)->cells[5]);
			incref(v337);
			VAL v338 = mw_std_list_List_1_cat(v335, v337);
			VAL v339 = VTUP(v170)->cells[5];
			decref(v339);
			VTUP(v170)->cells[5] = v338;
			VAL v340 = VTUP(v170)->cells[4];
			decref(v340);
			VTUP(v170)->cells[4] = v336;
			x9 = v170;
			x8 = v168;
			x7 = v167;
		} break;
		case 1LL: { // Right
			VAL v341 = mtp_std_either_Either_2_Right(v6);
			incref(v341);
			int64_t v342 = mw_mirth_name_DName_isZ_relativeZAsk(v341);
			VAL x343;
			VAL x344;
			VAL x345;
			VAL x346;
			int64_t x347;
			if (((bool)v342)) {
				int64_t v348 = VI64(VTUP(x3)->cells[6]);
				bool v349 = !((bool)v348);
				x347 = ((int64_t)v349);
				x346 = v341;
				x345 = x3;
				x344 = x2;
				x343 = x1;
			} else {
				int64_t v350 = 0LL /* False */;
				x347 = v350;
				x346 = v341;
				x345 = x3;
				x344 = x2;
				x343 = x1;
			}
			VAL x351;
			VAL x352;
			VAL x353;
			VAL x354;
			if (((bool)x347)) {
				VAL v355 = VVAL(VTUP(x345)->cells[4]);
				incref(v355);
				VAL v356 = MKI64(0LL /* Nil */);
				VAL v357 = MKI64(0LL /* Nil */);
				VAL v358;
				VAL v359;
				mw_std_list_List_1_uncons(v355, &v358, &v359);
				VAL x360;
				VAL x361;
				VAL x362;
				VAL x363;
				VAL x364;
				VAL x365;
				VAL x366;
				int64_t x367;
				switch (get_data_tag(v358)) {
					case 1LL: { // Some
						VAL v368 = mtp_std_maybe_Maybe_1_Some(v358);
						incref(x346);
						incref(v368);
						VAL v369;
						VAL v370;
						mw_mirth_def_Def_qnameZ_hard(x344, v368, &v369, &v370);
						VAL v371;
						VAL v372;
						VAL v373;
						mw_mirth_name_QName_climbZ_upZ_dnameZAsk(v369, x345, x346, v370, &v371, &v372, &v373);
						VAL v374 = MKI64(0LL /* None */);
						VAL v375;
						VAL v376;
						mw_std_list_List_1_uncons(v373, &v375, &v376);
						VAL x377;
						VAL x378;
						VAL x379;
						VAL x380;
						VAL x381;
						VAL x382;
						VAL x383;
						int64_t x384;
						switch (get_data_tag(v375)) {
							case 1LL: { // Some
								VAL v385 = mtp_std_maybe_Maybe_1_Some(v375);
								incref(v385);
								incref(x343);
								VAL v386 = MKI64(0LL /* None */);
								VAL v387;
								VAL v388;
								mw_std_list_List_1_uncons(x343, &v387, &v388);
								VAL x389;
								VAL x390;
								VAL x391;
								VAL x392;
								VAL x393;
								VAL x394;
								VAL x395;
								VAL x396;
								int64_t x397;
								switch (get_data_tag(v387)) {
									case 1LL: { // Some
										VAL v398 = mtp_std_maybe_Maybe_1_Some(v387);
										incref(v398);
										incref(v385);
										int64_t v399 = mw_mirth_name_Namespace_ZEqualZEqual(v385, v398);
										VAL x400;
										VAL x401;
										VAL x402;
										VAL x403;
										VAL x404;
										VAL x405;
										VAL x406;
										if (((bool)v399)) {
											VAL v407 = mtw_std_maybe_Maybe_1_Some(v398);
											x406 = v407;
											x405 = v385;
											x404 = v368;
											x403 = x346;
											x402 = x343;
											x401 = v372;
											x400 = v371;
										} else {
											decref(v398);
											VAL v408 = MKI64(0LL /* None */);
											x406 = v408;
											x405 = v385;
											x404 = v368;
											x403 = x346;
											x402 = x343;
											x401 = v372;
											x400 = v371;
										}
										VAL x409;
										VAL x410;
										VAL x411;
										VAL x412;
										VAL x413;
										VAL x414;
										VAL x415;
										VAL x416;
										switch (get_data_tag(x406)) {
											case 0LL: { // None
												x416 = v388;
												x415 = v386;
												x414 = x405;
												x413 = x404;
												x412 = x403;
												x411 = x402;
												x410 = x401;
												x409 = x400;
											} break;
											default: {
												decref(v388);
												decref(v386);
												VAL v417 = MKI64(0LL /* Nil */);
												x416 = v417;
												x415 = x406;
												x414 = x405;
												x413 = x404;
												x412 = x403;
												x411 = x402;
												x410 = x401;
												x409 = x400;
											} break;
										}
										int64_t v418 = 1LL /* True */;
										x397 = v418;
										x396 = x416;
										x395 = x415;
										x394 = x414;
										x393 = x413;
										x392 = x412;
										x391 = x411;
										x390 = x410;
										x389 = x409;
									} break;
									case 0LL: { // None
										int64_t v419 = 0LL /* False */;
										x397 = v419;
										x396 = v388;
										x395 = v386;
										x394 = v385;
										x393 = v368;
										x392 = x346;
										x391 = x343;
										x390 = v372;
										x389 = v371;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								VAL v420 = (x389);
								VAL v421 = (x390);
								VAL v422 = x391;
								VAL v423 = x392;
								VAL v424 = x393;
								VAL v425 = x394;
								VAL v426 = x395;
								VAL v427 = x396;
								int64_t v428 = x397;
								while (((bool)v428)) {
									VAL v429 = (v420);
									VAL v430 = (v421);
									VAL v431 = v422;
									VAL v432 = v423;
									VAL v433 = v424;
									VAL v434 = v425;
									VAL v435 = v426;
									VAL v436 = v427;
									VAL v437;
									VAL v438;
									mw_std_list_List_1_uncons(v436, &v437, &v438);
									VAL x439;
									VAL x440;
									VAL x441;
									VAL x442;
									VAL x443;
									VAL x444;
									VAL x445;
									VAL x446;
									int64_t x447;
									switch (get_data_tag(v437)) {
										case 1LL: { // Some
											VAL v448 = mtp_std_maybe_Maybe_1_Some(v437);
											incref(v448);
											incref(v434);
											int64_t v449 = mw_mirth_name_Namespace_ZEqualZEqual(v434, v448);
											VAL x450;
											VAL x451;
											VAL x452;
											VAL x453;
											VAL x454;
											VAL x455;
											VAL x456;
											if (((bool)v449)) {
												VAL v457 = mtw_std_maybe_Maybe_1_Some(v448);
												x456 = v457;
												x455 = v434;
												x454 = v433;
												x453 = v432;
												x452 = v431;
												x451 = v430;
												x450 = v429;
											} else {
												decref(v448);
												VAL v458 = MKI64(0LL /* None */);
												x456 = v458;
												x455 = v434;
												x454 = v433;
												x453 = v432;
												x452 = v431;
												x451 = v430;
												x450 = v429;
											}
											VAL x459;
											VAL x460;
											VAL x461;
											VAL x462;
											VAL x463;
											VAL x464;
											VAL x465;
											VAL x466;
											switch (get_data_tag(x456)) {
												case 0LL: { // None
													x466 = v438;
													x465 = v435;
													x464 = x455;
													x463 = x454;
													x462 = x453;
													x461 = x452;
													x460 = x451;
													x459 = x450;
												} break;
												default: {
													decref(v438);
													decref(v435);
													VAL v467 = MKI64(0LL /* Nil */);
													x466 = v467;
													x465 = x456;
													x464 = x455;
													x463 = x454;
													x462 = x453;
													x461 = x452;
													x460 = x451;
													x459 = x450;
												} break;
											}
											int64_t v468 = 1LL /* True */;
											x447 = v468;
											x446 = x466;
											x445 = x465;
											x444 = x464;
											x443 = x463;
											x442 = x462;
											x441 = x461;
											x440 = x460;
											x439 = x459;
										} break;
										case 0LL: { // None
											int64_t v469 = 0LL /* False */;
											x447 = v469;
											x446 = v438;
											x445 = v435;
											x444 = v434;
											x443 = v433;
											x442 = v432;
											x441 = v431;
											x440 = v430;
											x439 = v429;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									v428 = x447;
									v427 = x446;
									v426 = x445;
									v425 = x444;
									v424 = x443;
									v423 = x442;
									v422 = x441;
									v421 = x440;
									v420 = x439;
								}
								decref(v427);
								decref(v425);
								int64_t v470 = mw_std_maybe_Maybe_1_someZAsk(v426);
								VAL x471;
								VAL x472;
								VAL x473;
								VAL x474;
								VAL x475;
								VAL x476;
								if (((bool)v470)) {
									VAL v477 = mtw_std_maybe_Maybe_1_Some(v385);
									x476 = v477;
									x475 = v421;
									x474 = v420;
									x473 = v424;
									x472 = v423;
									x471 = v422;
								} else {
									decref(v385);
									VAL v478 = MKI64(0LL /* None */);
									x476 = v478;
									x475 = v421;
									x474 = v420;
									x473 = v424;
									x472 = v423;
									x471 = v422;
								}
								VAL x479;
								VAL x480;
								VAL x481;
								VAL x482;
								VAL x483;
								VAL x484;
								VAL x485;
								switch (get_data_tag(x476)) {
									case 0LL: { // None
										x485 = v376;
										x484 = v374;
										x483 = x475;
										x482 = x474;
										x481 = x473;
										x480 = x472;
										x479 = x471;
									} break;
									default: {
										decref(v376);
										decref(v374);
										VAL v486 = MKI64(0LL /* Nil */);
										x485 = v486;
										x484 = x476;
										x483 = x475;
										x482 = x474;
										x481 = x473;
										x480 = x472;
										x479 = x471;
									} break;
								}
								int64_t v487 = 1LL /* True */;
								x384 = v487;
								x383 = x485;
								x382 = x484;
								x381 = x483;
								x380 = x482;
								x379 = x481;
								x378 = x480;
								x377 = x479;
							} break;
							case 0LL: { // None
								int64_t v488 = 0LL /* False */;
								x384 = v488;
								x383 = v376;
								x382 = v374;
								x381 = v372;
								x380 = v371;
								x379 = v368;
								x378 = x346;
								x377 = x343;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v489 = x377;
						VAL v490 = x378;
						VAL v491 = x379;
						VAL v492 = (x380);
						VAL v493 = (x381);
						VAL v494 = x382;
						VAL v495 = x383;
						int64_t v496 = x384;
						while (((bool)v496)) {
							VAL v497 = v489;
							VAL v498 = v490;
							VAL v499 = v491;
							VAL v500 = (v492);
							VAL v501 = (v493);
							VAL v502 = v494;
							VAL v503 = v495;
							VAL v504;
							VAL v505;
							mw_std_list_List_1_uncons(v503, &v504, &v505);
							VAL x506;
							VAL x507;
							VAL x508;
							VAL x509;
							VAL x510;
							VAL x511;
							VAL x512;
							int64_t x513;
							switch (get_data_tag(v504)) {
								case 1LL: { // Some
									VAL v514 = mtp_std_maybe_Maybe_1_Some(v504);
									incref(v514);
									incref(v497);
									VAL v515 = MKI64(0LL /* None */);
									VAL v516;
									VAL v517;
									mw_std_list_List_1_uncons(v497, &v516, &v517);
									VAL x518;
									VAL x519;
									VAL x520;
									VAL x521;
									VAL x522;
									VAL x523;
									VAL x524;
									VAL x525;
									int64_t x526;
									switch (get_data_tag(v516)) {
										case 1LL: { // Some
											VAL v527 = mtp_std_maybe_Maybe_1_Some(v516);
											incref(v527);
											incref(v514);
											int64_t v528 = mw_mirth_name_Namespace_ZEqualZEqual(v514, v527);
											VAL x529;
											VAL x530;
											VAL x531;
											VAL x532;
											VAL x533;
											VAL x534;
											VAL x535;
											if (((bool)v528)) {
												VAL v536 = mtw_std_maybe_Maybe_1_Some(v527);
												x535 = v536;
												x534 = v514;
												x533 = v499;
												x532 = v498;
												x531 = v497;
												x530 = v501;
												x529 = v500;
											} else {
												decref(v527);
												VAL v537 = MKI64(0LL /* None */);
												x535 = v537;
												x534 = v514;
												x533 = v499;
												x532 = v498;
												x531 = v497;
												x530 = v501;
												x529 = v500;
											}
											VAL x538;
											VAL x539;
											VAL x540;
											VAL x541;
											VAL x542;
											VAL x543;
											VAL x544;
											VAL x545;
											switch (get_data_tag(x535)) {
												case 0LL: { // None
													x545 = v517;
													x544 = v515;
													x543 = x534;
													x542 = x533;
													x541 = x532;
													x540 = x531;
													x539 = x530;
													x538 = x529;
												} break;
												default: {
													decref(v517);
													decref(v515);
													VAL v546 = MKI64(0LL /* Nil */);
													x545 = v546;
													x544 = x535;
													x543 = x534;
													x542 = x533;
													x541 = x532;
													x540 = x531;
													x539 = x530;
													x538 = x529;
												} break;
											}
											int64_t v547 = 1LL /* True */;
											x526 = v547;
											x525 = x545;
											x524 = x544;
											x523 = x543;
											x522 = x542;
											x521 = x541;
											x520 = x540;
											x519 = x539;
											x518 = x538;
										} break;
										case 0LL: { // None
											int64_t v548 = 0LL /* False */;
											x526 = v548;
											x525 = v517;
											x524 = v515;
											x523 = v514;
											x522 = v499;
											x521 = v498;
											x520 = v497;
											x519 = v501;
											x518 = v500;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									VAL v549 = (x518);
									VAL v550 = (x519);
									VAL v551 = x520;
									VAL v552 = x521;
									VAL v553 = x522;
									VAL v554 = x523;
									VAL v555 = x524;
									VAL v556 = x525;
									int64_t v557 = x526;
									while (((bool)v557)) {
										VAL v558 = (v549);
										VAL v559 = (v550);
										VAL v560 = v551;
										VAL v561 = v552;
										VAL v562 = v553;
										VAL v563 = v554;
										VAL v564 = v555;
										VAL v565 = v556;
										VAL v566;
										VAL v567;
										mw_std_list_List_1_uncons(v565, &v566, &v567);
										VAL x568;
										VAL x569;
										VAL x570;
										VAL x571;
										VAL x572;
										VAL x573;
										VAL x574;
										VAL x575;
										int64_t x576;
										switch (get_data_tag(v566)) {
											case 1LL: { // Some
												VAL v577 = mtp_std_maybe_Maybe_1_Some(v566);
												incref(v577);
												incref(v563);
												int64_t v578 = mw_mirth_name_Namespace_ZEqualZEqual(v563, v577);
												VAL x579;
												VAL x580;
												VAL x581;
												VAL x582;
												VAL x583;
												VAL x584;
												VAL x585;
												if (((bool)v578)) {
													VAL v586 = mtw_std_maybe_Maybe_1_Some(v577);
													x585 = v586;
													x584 = v563;
													x583 = v562;
													x582 = v561;
													x581 = v560;
													x580 = v559;
													x579 = v558;
												} else {
													decref(v577);
													VAL v587 = MKI64(0LL /* None */);
													x585 = v587;
													x584 = v563;
													x583 = v562;
													x582 = v561;
													x581 = v560;
													x580 = v559;
													x579 = v558;
												}
												VAL x588;
												VAL x589;
												VAL x590;
												VAL x591;
												VAL x592;
												VAL x593;
												VAL x594;
												VAL x595;
												switch (get_data_tag(x585)) {
													case 0LL: { // None
														x595 = v567;
														x594 = v564;
														x593 = x584;
														x592 = x583;
														x591 = x582;
														x590 = x581;
														x589 = x580;
														x588 = x579;
													} break;
													default: {
														decref(v567);
														decref(v564);
														VAL v596 = MKI64(0LL /* Nil */);
														x595 = v596;
														x594 = x585;
														x593 = x584;
														x592 = x583;
														x591 = x582;
														x590 = x581;
														x589 = x580;
														x588 = x579;
													} break;
												}
												int64_t v597 = 1LL /* True */;
												x576 = v597;
												x575 = x595;
												x574 = x594;
												x573 = x593;
												x572 = x592;
												x571 = x591;
												x570 = x590;
												x569 = x589;
												x568 = x588;
											} break;
											case 0LL: { // None
												int64_t v598 = 0LL /* False */;
												x576 = v598;
												x575 = v567;
												x574 = v564;
												x573 = v563;
												x572 = v562;
												x571 = v561;
												x570 = v560;
												x569 = v559;
												x568 = v558;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										v557 = x576;
										v556 = x575;
										v555 = x574;
										v554 = x573;
										v553 = x572;
										v552 = x571;
										v551 = x570;
										v550 = x569;
										v549 = x568;
									}
									decref(v556);
									decref(v554);
									int64_t v599 = mw_std_maybe_Maybe_1_someZAsk(v555);
									VAL x600;
									VAL x601;
									VAL x602;
									VAL x603;
									VAL x604;
									VAL x605;
									if (((bool)v599)) {
										VAL v606 = mtw_std_maybe_Maybe_1_Some(v514);
										x605 = v606;
										x604 = v550;
										x603 = v549;
										x602 = v553;
										x601 = v552;
										x600 = v551;
									} else {
										decref(v514);
										VAL v607 = MKI64(0LL /* None */);
										x605 = v607;
										x604 = v550;
										x603 = v549;
										x602 = v553;
										x601 = v552;
										x600 = v551;
									}
									VAL x608;
									VAL x609;
									VAL x610;
									VAL x611;
									VAL x612;
									VAL x613;
									VAL x614;
									switch (get_data_tag(x605)) {
										case 0LL: { // None
											x614 = v505;
											x613 = v502;
											x612 = x604;
											x611 = x603;
											x610 = x602;
											x609 = x601;
											x608 = x600;
										} break;
										default: {
											decref(v505);
											decref(v502);
											VAL v615 = MKI64(0LL /* Nil */);
											x614 = v615;
											x613 = x605;
											x612 = x604;
											x611 = x603;
											x610 = x602;
											x609 = x601;
											x608 = x600;
										} break;
									}
									int64_t v616 = 1LL /* True */;
									x513 = v616;
									x512 = x614;
									x511 = x613;
									x510 = x612;
									x509 = x611;
									x508 = x610;
									x507 = x609;
									x506 = x608;
								} break;
								case 0LL: { // None
									int64_t v617 = 0LL /* False */;
									x513 = v617;
									x512 = v505;
									x511 = v502;
									x510 = v501;
									x509 = v500;
									x508 = v499;
									x507 = v498;
									x506 = v497;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v496 = x513;
							v495 = x512;
							v494 = x511;
							v493 = x510;
							v492 = x509;
							v491 = x508;
							v490 = x507;
							v489 = x506;
						}
						decref(v495);
						int64_t v618 = mw_std_maybe_Maybe_1_someZAsk(v494);
						VAL x619;
						VAL x620;
						VAL x621;
						VAL x622;
						VAL x623;
						if (((bool)v618)) {
							VAL v624 = mtw_std_either_Either_2_Right(v491);
							x623 = v624;
							x622 = v493;
							x621 = v490;
							x620 = v492;
							x619 = v489;
						} else {
							incref(v489);
							int64_t v625 = mw_std_list_List_1_emptyZAsk(v489);
							VAL x626;
							VAL x627;
							VAL x628;
							VAL x629;
							VAL x630;
							if (((bool)v625)) {
								VAL v631 = mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v491);
								x630 = v631;
								x629 = v490;
								x628 = v489;
								x627 = v493;
								x626 = v492;
							} else {
								VAL v632 = mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v491);
								x630 = v632;
								x629 = v490;
								x628 = v489;
								x627 = v493;
								x626 = v492;
							}
							VAL v633 = mtw_std_either_Either_2_Left(x630);
							x623 = v633;
							x622 = x627;
							x621 = x629;
							x620 = x626;
							x619 = x628;
						}
						VAL x634;
						VAL x635;
						VAL x636;
						VAL x637;
						VAL x638;
						VAL x639;
						switch (get_data_tag(x623)) {
							case 0LL: { // Left
								VAL v640 = mtp_std_either_Either_2_Left(x623);
								VAL v641 = mtw_std_list_List_1_Cons(v640, v356);
								x639 = v357;
								x638 = v641;
								x637 = x622;
								x636 = x621;
								x635 = x620;
								x634 = x619;
							} break;
							case 1LL: { // Right
								VAL v642 = mtp_std_either_Either_2_Right(x623);
								VAL v643 = mtw_std_list_List_1_Cons(v642, v357);
								x639 = v643;
								x638 = v356;
								x637 = x622;
								x636 = x621;
								x635 = x620;
								x634 = x619;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v644 = 1LL /* True */;
						x367 = v644;
						x366 = v359;
						x365 = x639;
						x364 = x638;
						x363 = x637;
						x362 = x636;
						x361 = x635;
						x360 = x634;
					} break;
					case 0LL: { // None
						int64_t v645 = 0LL /* False */;
						x367 = v645;
						x366 = v359;
						x365 = v357;
						x364 = v356;
						x363 = x345;
						x362 = x346;
						x361 = x344;
						x360 = x343;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v646 = x360;
				VAL v647 = (x361);
				VAL v648 = x362;
				VAL v649 = (x363);
				VAL v650 = x364;
				VAL v651 = x365;
				VAL v652 = x366;
				int64_t v653 = x367;
				while (((bool)v653)) {
					VAL v654 = v646;
					VAL v655 = (v647);
					VAL v656 = v648;
					VAL v657 = (v649);
					VAL v658 = v650;
					VAL v659 = v651;
					VAL v660 = v652;
					VAL v661;
					VAL v662;
					mw_std_list_List_1_uncons(v660, &v661, &v662);
					VAL x663;
					VAL x664;
					VAL x665;
					VAL x666;
					VAL x667;
					VAL x668;
					VAL x669;
					int64_t x670;
					switch (get_data_tag(v661)) {
						case 1LL: { // Some
							VAL v671 = mtp_std_maybe_Maybe_1_Some(v661);
							incref(v656);
							incref(v671);
							VAL v672;
							VAL v673;
							mw_mirth_def_Def_qnameZ_hard(v655, v671, &v672, &v673);
							VAL v674;
							VAL v675;
							VAL v676;
							mw_mirth_name_QName_climbZ_upZ_dnameZAsk(v672, v657, v656, v673, &v674, &v675, &v676);
							VAL v677 = MKI64(0LL /* None */);
							VAL v678;
							VAL v679;
							mw_std_list_List_1_uncons(v676, &v678, &v679);
							VAL x680;
							VAL x681;
							VAL x682;
							VAL x683;
							VAL x684;
							VAL x685;
							VAL x686;
							int64_t x687;
							switch (get_data_tag(v678)) {
								case 1LL: { // Some
									VAL v688 = mtp_std_maybe_Maybe_1_Some(v678);
									incref(v688);
									incref(v654);
									VAL v689 = MKI64(0LL /* None */);
									VAL v690;
									VAL v691;
									mw_std_list_List_1_uncons(v654, &v690, &v691);
									VAL x692;
									VAL x693;
									VAL x694;
									VAL x695;
									VAL x696;
									VAL x697;
									VAL x698;
									VAL x699;
									int64_t x700;
									switch (get_data_tag(v690)) {
										case 1LL: { // Some
											VAL v701 = mtp_std_maybe_Maybe_1_Some(v690);
											incref(v701);
											incref(v688);
											int64_t v702 = mw_mirth_name_Namespace_ZEqualZEqual(v688, v701);
											VAL x703;
											VAL x704;
											VAL x705;
											VAL x706;
											VAL x707;
											VAL x708;
											VAL x709;
											if (((bool)v702)) {
												VAL v710 = mtw_std_maybe_Maybe_1_Some(v701);
												x709 = v710;
												x708 = v688;
												x707 = v671;
												x706 = v656;
												x705 = v654;
												x704 = v675;
												x703 = v674;
											} else {
												decref(v701);
												VAL v711 = MKI64(0LL /* None */);
												x709 = v711;
												x708 = v688;
												x707 = v671;
												x706 = v656;
												x705 = v654;
												x704 = v675;
												x703 = v674;
											}
											VAL x712;
											VAL x713;
											VAL x714;
											VAL x715;
											VAL x716;
											VAL x717;
											VAL x718;
											VAL x719;
											switch (get_data_tag(x709)) {
												case 0LL: { // None
													x719 = v691;
													x718 = v689;
													x717 = x708;
													x716 = x707;
													x715 = x706;
													x714 = x705;
													x713 = x704;
													x712 = x703;
												} break;
												default: {
													decref(v691);
													decref(v689);
													VAL v720 = MKI64(0LL /* Nil */);
													x719 = v720;
													x718 = x709;
													x717 = x708;
													x716 = x707;
													x715 = x706;
													x714 = x705;
													x713 = x704;
													x712 = x703;
												} break;
											}
											int64_t v721 = 1LL /* True */;
											x700 = v721;
											x699 = x719;
											x698 = x718;
											x697 = x717;
											x696 = x716;
											x695 = x715;
											x694 = x714;
											x693 = x713;
											x692 = x712;
										} break;
										case 0LL: { // None
											int64_t v722 = 0LL /* False */;
											x700 = v722;
											x699 = v691;
											x698 = v689;
											x697 = v688;
											x696 = v671;
											x695 = v656;
											x694 = v654;
											x693 = v675;
											x692 = v674;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									VAL v723 = (x692);
									VAL v724 = (x693);
									VAL v725 = x694;
									VAL v726 = x695;
									VAL v727 = x696;
									VAL v728 = x697;
									VAL v729 = x698;
									VAL v730 = x699;
									int64_t v731 = x700;
									while (((bool)v731)) {
										VAL v732 = (v723);
										VAL v733 = (v724);
										VAL v734 = v725;
										VAL v735 = v726;
										VAL v736 = v727;
										VAL v737 = v728;
										VAL v738 = v729;
										VAL v739 = v730;
										VAL v740;
										VAL v741;
										mw_std_list_List_1_uncons(v739, &v740, &v741);
										VAL x742;
										VAL x743;
										VAL x744;
										VAL x745;
										VAL x746;
										VAL x747;
										VAL x748;
										VAL x749;
										int64_t x750;
										switch (get_data_tag(v740)) {
											case 1LL: { // Some
												VAL v751 = mtp_std_maybe_Maybe_1_Some(v740);
												incref(v751);
												incref(v737);
												int64_t v752 = mw_mirth_name_Namespace_ZEqualZEqual(v737, v751);
												VAL x753;
												VAL x754;
												VAL x755;
												VAL x756;
												VAL x757;
												VAL x758;
												VAL x759;
												if (((bool)v752)) {
													VAL v760 = mtw_std_maybe_Maybe_1_Some(v751);
													x759 = v760;
													x758 = v737;
													x757 = v736;
													x756 = v735;
													x755 = v734;
													x754 = v733;
													x753 = v732;
												} else {
													decref(v751);
													VAL v761 = MKI64(0LL /* None */);
													x759 = v761;
													x758 = v737;
													x757 = v736;
													x756 = v735;
													x755 = v734;
													x754 = v733;
													x753 = v732;
												}
												VAL x762;
												VAL x763;
												VAL x764;
												VAL x765;
												VAL x766;
												VAL x767;
												VAL x768;
												VAL x769;
												switch (get_data_tag(x759)) {
													case 0LL: { // None
														x769 = v741;
														x768 = v738;
														x767 = x758;
														x766 = x757;
														x765 = x756;
														x764 = x755;
														x763 = x754;
														x762 = x753;
													} break;
													default: {
														decref(v741);
														decref(v738);
														VAL v770 = MKI64(0LL /* Nil */);
														x769 = v770;
														x768 = x759;
														x767 = x758;
														x766 = x757;
														x765 = x756;
														x764 = x755;
														x763 = x754;
														x762 = x753;
													} break;
												}
												int64_t v771 = 1LL /* True */;
												x750 = v771;
												x749 = x769;
												x748 = x768;
												x747 = x767;
												x746 = x766;
												x745 = x765;
												x744 = x764;
												x743 = x763;
												x742 = x762;
											} break;
											case 0LL: { // None
												int64_t v772 = 0LL /* False */;
												x750 = v772;
												x749 = v741;
												x748 = v738;
												x747 = v737;
												x746 = v736;
												x745 = v735;
												x744 = v734;
												x743 = v733;
												x742 = v732;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										v731 = x750;
										v730 = x749;
										v729 = x748;
										v728 = x747;
										v727 = x746;
										v726 = x745;
										v725 = x744;
										v724 = x743;
										v723 = x742;
									}
									decref(v730);
									decref(v728);
									int64_t v773 = mw_std_maybe_Maybe_1_someZAsk(v729);
									VAL x774;
									VAL x775;
									VAL x776;
									VAL x777;
									VAL x778;
									VAL x779;
									if (((bool)v773)) {
										VAL v780 = mtw_std_maybe_Maybe_1_Some(v688);
										x779 = v780;
										x778 = v724;
										x777 = v723;
										x776 = v727;
										x775 = v726;
										x774 = v725;
									} else {
										decref(v688);
										VAL v781 = MKI64(0LL /* None */);
										x779 = v781;
										x778 = v724;
										x777 = v723;
										x776 = v727;
										x775 = v726;
										x774 = v725;
									}
									VAL x782;
									VAL x783;
									VAL x784;
									VAL x785;
									VAL x786;
									VAL x787;
									VAL x788;
									switch (get_data_tag(x779)) {
										case 0LL: { // None
											x788 = v679;
											x787 = v677;
											x786 = x778;
											x785 = x777;
											x784 = x776;
											x783 = x775;
											x782 = x774;
										} break;
										default: {
											decref(v679);
											decref(v677);
											VAL v789 = MKI64(0LL /* Nil */);
											x788 = v789;
											x787 = x779;
											x786 = x778;
											x785 = x777;
											x784 = x776;
											x783 = x775;
											x782 = x774;
										} break;
									}
									int64_t v790 = 1LL /* True */;
									x687 = v790;
									x686 = x788;
									x685 = x787;
									x684 = x786;
									x683 = x785;
									x682 = x784;
									x681 = x783;
									x680 = x782;
								} break;
								case 0LL: { // None
									int64_t v791 = 0LL /* False */;
									x687 = v791;
									x686 = v679;
									x685 = v677;
									x684 = v675;
									x683 = v674;
									x682 = v671;
									x681 = v656;
									x680 = v654;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v792 = x680;
							VAL v793 = x681;
							VAL v794 = x682;
							VAL v795 = (x683);
							VAL v796 = (x684);
							VAL v797 = x685;
							VAL v798 = x686;
							int64_t v799 = x687;
							while (((bool)v799)) {
								VAL v800 = v792;
								VAL v801 = v793;
								VAL v802 = v794;
								VAL v803 = (v795);
								VAL v804 = (v796);
								VAL v805 = v797;
								VAL v806 = v798;
								VAL v807;
								VAL v808;
								mw_std_list_List_1_uncons(v806, &v807, &v808);
								VAL x809;
								VAL x810;
								VAL x811;
								VAL x812;
								VAL x813;
								VAL x814;
								VAL x815;
								int64_t x816;
								switch (get_data_tag(v807)) {
									case 1LL: { // Some
										VAL v817 = mtp_std_maybe_Maybe_1_Some(v807);
										incref(v817);
										incref(v800);
										VAL v818 = MKI64(0LL /* None */);
										VAL v819;
										VAL v820;
										mw_std_list_List_1_uncons(v800, &v819, &v820);
										VAL x821;
										VAL x822;
										VAL x823;
										VAL x824;
										VAL x825;
										VAL x826;
										VAL x827;
										VAL x828;
										int64_t x829;
										switch (get_data_tag(v819)) {
											case 1LL: { // Some
												VAL v830 = mtp_std_maybe_Maybe_1_Some(v819);
												incref(v830);
												incref(v817);
												int64_t v831 = mw_mirth_name_Namespace_ZEqualZEqual(v817, v830);
												VAL x832;
												VAL x833;
												VAL x834;
												VAL x835;
												VAL x836;
												VAL x837;
												VAL x838;
												if (((bool)v831)) {
													VAL v839 = mtw_std_maybe_Maybe_1_Some(v830);
													x838 = v839;
													x837 = v817;
													x836 = v802;
													x835 = v801;
													x834 = v800;
													x833 = v804;
													x832 = v803;
												} else {
													decref(v830);
													VAL v840 = MKI64(0LL /* None */);
													x838 = v840;
													x837 = v817;
													x836 = v802;
													x835 = v801;
													x834 = v800;
													x833 = v804;
													x832 = v803;
												}
												VAL x841;
												VAL x842;
												VAL x843;
												VAL x844;
												VAL x845;
												VAL x846;
												VAL x847;
												VAL x848;
												switch (get_data_tag(x838)) {
													case 0LL: { // None
														x848 = v820;
														x847 = v818;
														x846 = x837;
														x845 = x836;
														x844 = x835;
														x843 = x834;
														x842 = x833;
														x841 = x832;
													} break;
													default: {
														decref(v820);
														decref(v818);
														VAL v849 = MKI64(0LL /* Nil */);
														x848 = v849;
														x847 = x838;
														x846 = x837;
														x845 = x836;
														x844 = x835;
														x843 = x834;
														x842 = x833;
														x841 = x832;
													} break;
												}
												int64_t v850 = 1LL /* True */;
												x829 = v850;
												x828 = x848;
												x827 = x847;
												x826 = x846;
												x825 = x845;
												x824 = x844;
												x823 = x843;
												x822 = x842;
												x821 = x841;
											} break;
											case 0LL: { // None
												int64_t v851 = 0LL /* False */;
												x829 = v851;
												x828 = v820;
												x827 = v818;
												x826 = v817;
												x825 = v802;
												x824 = v801;
												x823 = v800;
												x822 = v804;
												x821 = v803;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										VAL v852 = (x821);
										VAL v853 = (x822);
										VAL v854 = x823;
										VAL v855 = x824;
										VAL v856 = x825;
										VAL v857 = x826;
										VAL v858 = x827;
										VAL v859 = x828;
										int64_t v860 = x829;
										while (((bool)v860)) {
											VAL v861 = (v852);
											VAL v862 = (v853);
											VAL v863 = v854;
											VAL v864 = v855;
											VAL v865 = v856;
											VAL v866 = v857;
											VAL v867 = v858;
											VAL v868 = v859;
											VAL v869;
											VAL v870;
											mw_std_list_List_1_uncons(v868, &v869, &v870);
											VAL x871;
											VAL x872;
											VAL x873;
											VAL x874;
											VAL x875;
											VAL x876;
											VAL x877;
											VAL x878;
											int64_t x879;
											switch (get_data_tag(v869)) {
												case 1LL: { // Some
													VAL v880 = mtp_std_maybe_Maybe_1_Some(v869);
													incref(v880);
													incref(v866);
													int64_t v881 = mw_mirth_name_Namespace_ZEqualZEqual(v866, v880);
													VAL x882;
													VAL x883;
													VAL x884;
													VAL x885;
													VAL x886;
													VAL x887;
													VAL x888;
													if (((bool)v881)) {
														VAL v889 = mtw_std_maybe_Maybe_1_Some(v880);
														x888 = v889;
														x887 = v866;
														x886 = v865;
														x885 = v864;
														x884 = v863;
														x883 = v862;
														x882 = v861;
													} else {
														decref(v880);
														VAL v890 = MKI64(0LL /* None */);
														x888 = v890;
														x887 = v866;
														x886 = v865;
														x885 = v864;
														x884 = v863;
														x883 = v862;
														x882 = v861;
													}
													VAL x891;
													VAL x892;
													VAL x893;
													VAL x894;
													VAL x895;
													VAL x896;
													VAL x897;
													VAL x898;
													switch (get_data_tag(x888)) {
														case 0LL: { // None
															x898 = v870;
															x897 = v867;
															x896 = x887;
															x895 = x886;
															x894 = x885;
															x893 = x884;
															x892 = x883;
															x891 = x882;
														} break;
														default: {
															decref(v870);
															decref(v867);
															VAL v899 = MKI64(0LL /* Nil */);
															x898 = v899;
															x897 = x888;
															x896 = x887;
															x895 = x886;
															x894 = x885;
															x893 = x884;
															x892 = x883;
															x891 = x882;
														} break;
													}
													int64_t v900 = 1LL /* True */;
													x879 = v900;
													x878 = x898;
													x877 = x897;
													x876 = x896;
													x875 = x895;
													x874 = x894;
													x873 = x893;
													x872 = x892;
													x871 = x891;
												} break;
												case 0LL: { // None
													int64_t v901 = 0LL /* False */;
													x879 = v901;
													x878 = v870;
													x877 = v867;
													x876 = v866;
													x875 = v865;
													x874 = v864;
													x873 = v863;
													x872 = v862;
													x871 = v861;
												} break;
												default: {
													do_panic(str_make("unexpected fallthrough in match\n", 32));
												}
											}
											v860 = x879;
											v859 = x878;
											v858 = x877;
											v857 = x876;
											v856 = x875;
											v855 = x874;
											v854 = x873;
											v853 = x872;
											v852 = x871;
										}
										decref(v859);
										decref(v857);
										int64_t v902 = mw_std_maybe_Maybe_1_someZAsk(v858);
										VAL x903;
										VAL x904;
										VAL x905;
										VAL x906;
										VAL x907;
										VAL x908;
										if (((bool)v902)) {
											VAL v909 = mtw_std_maybe_Maybe_1_Some(v817);
											x908 = v909;
											x907 = v853;
											x906 = v852;
											x905 = v856;
											x904 = v855;
											x903 = v854;
										} else {
											decref(v817);
											VAL v910 = MKI64(0LL /* None */);
											x908 = v910;
											x907 = v853;
											x906 = v852;
											x905 = v856;
											x904 = v855;
											x903 = v854;
										}
										VAL x911;
										VAL x912;
										VAL x913;
										VAL x914;
										VAL x915;
										VAL x916;
										VAL x917;
										switch (get_data_tag(x908)) {
											case 0LL: { // None
												x917 = v808;
												x916 = v805;
												x915 = x907;
												x914 = x906;
												x913 = x905;
												x912 = x904;
												x911 = x903;
											} break;
											default: {
												decref(v808);
												decref(v805);
												VAL v918 = MKI64(0LL /* Nil */);
												x917 = v918;
												x916 = x908;
												x915 = x907;
												x914 = x906;
												x913 = x905;
												x912 = x904;
												x911 = x903;
											} break;
										}
										int64_t v919 = 1LL /* True */;
										x816 = v919;
										x815 = x917;
										x814 = x916;
										x813 = x915;
										x812 = x914;
										x811 = x913;
										x810 = x912;
										x809 = x911;
									} break;
									case 0LL: { // None
										int64_t v920 = 0LL /* False */;
										x816 = v920;
										x815 = v808;
										x814 = v805;
										x813 = v804;
										x812 = v803;
										x811 = v802;
										x810 = v801;
										x809 = v800;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v799 = x816;
								v798 = x815;
								v797 = x814;
								v796 = x813;
								v795 = x812;
								v794 = x811;
								v793 = x810;
								v792 = x809;
							}
							decref(v798);
							int64_t v921 = mw_std_maybe_Maybe_1_someZAsk(v797);
							VAL x922;
							VAL x923;
							VAL x924;
							VAL x925;
							VAL x926;
							if (((bool)v921)) {
								VAL v927 = mtw_std_either_Either_2_Right(v794);
								x926 = v927;
								x925 = v796;
								x924 = v793;
								x923 = v795;
								x922 = v792;
							} else {
								incref(v792);
								int64_t v928 = mw_std_list_List_1_emptyZAsk(v792);
								VAL x929;
								VAL x930;
								VAL x931;
								VAL x932;
								VAL x933;
								if (((bool)v928)) {
									VAL v934 = mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v794);
									x933 = v934;
									x932 = v793;
									x931 = v792;
									x930 = v796;
									x929 = v795;
								} else {
									VAL v935 = mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v794);
									x933 = v935;
									x932 = v793;
									x931 = v792;
									x930 = v796;
									x929 = v795;
								}
								VAL v936 = mtw_std_either_Either_2_Left(x933);
								x926 = v936;
								x925 = x930;
								x924 = x932;
								x923 = x929;
								x922 = x931;
							}
							VAL x937;
							VAL x938;
							VAL x939;
							VAL x940;
							VAL x941;
							VAL x942;
							switch (get_data_tag(x926)) {
								case 0LL: { // Left
									VAL v943 = mtp_std_either_Either_2_Left(x926);
									VAL v944 = mtw_std_list_List_1_Cons(v943, v658);
									x942 = v659;
									x941 = v944;
									x940 = x925;
									x939 = x924;
									x938 = x923;
									x937 = x922;
								} break;
								case 1LL: { // Right
									VAL v945 = mtp_std_either_Either_2_Right(x926);
									VAL v946 = mtw_std_list_List_1_Cons(v945, v659);
									x942 = v946;
									x941 = v658;
									x940 = x925;
									x939 = x924;
									x938 = x923;
									x937 = x922;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v947 = 1LL /* True */;
							x670 = v947;
							x669 = v662;
							x668 = x942;
							x667 = x941;
							x666 = x940;
							x665 = x939;
							x664 = x938;
							x663 = x937;
						} break;
						case 0LL: { // None
							int64_t v948 = 0LL /* False */;
							x670 = v948;
							x669 = v662;
							x668 = v659;
							x667 = v658;
							x666 = v657;
							x665 = v656;
							x664 = v655;
							x663 = v654;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v653 = x670;
					v652 = x669;
					v651 = x668;
					v650 = x667;
					v649 = x666;
					v648 = x665;
					v647 = x664;
					v646 = x663;
				}
				decref(v652);
				VAL v949 = mw_std_list_List_1_reverse(v650);
				VAL v950 = mw_std_list_List_1_reverse(v651);
				VAL v951 = VVAL(VTUP(v649)->cells[5]);
				incref(v951);
				VAL v952 = mw_std_list_List_1_cat(v949, v951);
				VAL v953 = VTUP(v649)->cells[5];
				decref(v953);
				VTUP(v649)->cells[5] = v952;
				VAL v954 = VTUP(v649)->cells[4];
				decref(v954);
				VTUP(v649)->cells[4] = v950;
				x354 = v649;
				x353 = v648;
				x352 = v647;
				x351 = v646;
			} else {
				VAL v955 = VVAL(VTUP(x345)->cells[4]);
				incref(v955);
				VAL v956 = MKI64(0LL /* Nil */);
				VAL v957 = MKI64(0LL /* Nil */);
				VAL v958;
				VAL v959;
				mw_std_list_List_1_uncons(v955, &v958, &v959);
				VAL x960;
				VAL x961;
				VAL x962;
				VAL x963;
				VAL x964;
				VAL x965;
				VAL x966;
				int64_t x967;
				switch (get_data_tag(v958)) {
					case 1LL: { // Some
						VAL v968 = mtp_std_maybe_Maybe_1_Some(v958);
						incref(x346);
						incref(v968);
						VAL v969;
						VAL v970;
						mw_mirth_def_Def_qnameZ_hard(x344, v968, &v969, &v970);
						VAL v971;
						VAL v972;
						VAL v973;
						mw_mirth_name_QName_climbZ_upZ_dnameZAsk(v969, x345, x346, v970, &v971, &v972, &v973);
						VAL v974 = MKI64(0LL /* None */);
						VAL v975;
						VAL v976;
						mw_std_list_List_1_uncons(v973, &v975, &v976);
						VAL x977;
						VAL x978;
						VAL x979;
						VAL x980;
						VAL x981;
						VAL x982;
						VAL x983;
						int64_t x984;
						switch (get_data_tag(v975)) {
							case 1LL: { // Some
								VAL v985 = mtp_std_maybe_Maybe_1_Some(v975);
								incref(v985);
								uint64_t v986 = VU64(VTUP(v972)->cells[2]);
								VAL v987;
								int64_t v988;
								mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(v971, v986, v985, &v987, &v988);
								VAL x989;
								VAL x990;
								VAL x991;
								VAL x992;
								VAL x993;
								VAL x994;
								if (((bool)v988)) {
									VAL v995 = mtw_std_maybe_Maybe_1_Some(v985);
									x994 = v995;
									x993 = v972;
									x992 = v987;
									x991 = v968;
									x990 = x346;
									x989 = x343;
								} else {
									decref(v985);
									VAL v996 = MKI64(0LL /* None */);
									x994 = v996;
									x993 = v972;
									x992 = v987;
									x991 = v968;
									x990 = x346;
									x989 = x343;
								}
								VAL x997;
								VAL x998;
								VAL x999;
								VAL x1000;
								VAL x1001;
								VAL x1002;
								VAL x1003;
								switch (get_data_tag(x994)) {
									case 0LL: { // None
										x1003 = v976;
										x1002 = v974;
										x1001 = x993;
										x1000 = x992;
										x999 = x991;
										x998 = x990;
										x997 = x989;
									} break;
									default: {
										decref(v976);
										decref(v974);
										VAL v1004 = MKI64(0LL /* Nil */);
										x1003 = v1004;
										x1002 = x994;
										x1001 = x993;
										x1000 = x992;
										x999 = x991;
										x998 = x990;
										x997 = x989;
									} break;
								}
								int64_t v1005 = 1LL /* True */;
								x984 = v1005;
								x983 = x1003;
								x982 = x1002;
								x981 = x1001;
								x980 = x1000;
								x979 = x999;
								x978 = x998;
								x977 = x997;
							} break;
							case 0LL: { // None
								int64_t v1006 = 0LL /* False */;
								x984 = v1006;
								x983 = v976;
								x982 = v974;
								x981 = v972;
								x980 = v971;
								x979 = v968;
								x978 = x346;
								x977 = x343;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v1007 = x977;
						VAL v1008 = x978;
						VAL v1009 = x979;
						VAL v1010 = (x980);
						VAL v1011 = (x981);
						VAL v1012 = x982;
						VAL v1013 = x983;
						int64_t v1014 = x984;
						while (((bool)v1014)) {
							VAL v1015 = v1007;
							VAL v1016 = v1008;
							VAL v1017 = v1009;
							VAL v1018 = (v1010);
							VAL v1019 = (v1011);
							VAL v1020 = v1012;
							VAL v1021 = v1013;
							VAL v1022;
							VAL v1023;
							mw_std_list_List_1_uncons(v1021, &v1022, &v1023);
							VAL x1024;
							VAL x1025;
							VAL x1026;
							VAL x1027;
							VAL x1028;
							VAL x1029;
							VAL x1030;
							int64_t x1031;
							switch (get_data_tag(v1022)) {
								case 1LL: { // Some
									VAL v1032 = mtp_std_maybe_Maybe_1_Some(v1022);
									incref(v1032);
									uint64_t v1033 = VU64(VTUP(v1019)->cells[2]);
									VAL v1034;
									int64_t v1035;
									mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(v1018, v1033, v1032, &v1034, &v1035);
									VAL x1036;
									VAL x1037;
									VAL x1038;
									VAL x1039;
									VAL x1040;
									VAL x1041;
									if (((bool)v1035)) {
										VAL v1042 = mtw_std_maybe_Maybe_1_Some(v1032);
										x1041 = v1042;
										x1040 = v1019;
										x1039 = v1034;
										x1038 = v1017;
										x1037 = v1016;
										x1036 = v1015;
									} else {
										decref(v1032);
										VAL v1043 = MKI64(0LL /* None */);
										x1041 = v1043;
										x1040 = v1019;
										x1039 = v1034;
										x1038 = v1017;
										x1037 = v1016;
										x1036 = v1015;
									}
									VAL x1044;
									VAL x1045;
									VAL x1046;
									VAL x1047;
									VAL x1048;
									VAL x1049;
									VAL x1050;
									switch (get_data_tag(x1041)) {
										case 0LL: { // None
											x1050 = v1023;
											x1049 = v1020;
											x1048 = x1040;
											x1047 = x1039;
											x1046 = x1038;
											x1045 = x1037;
											x1044 = x1036;
										} break;
										default: {
											decref(v1023);
											decref(v1020);
											VAL v1051 = MKI64(0LL /* Nil */);
											x1050 = v1051;
											x1049 = x1041;
											x1048 = x1040;
											x1047 = x1039;
											x1046 = x1038;
											x1045 = x1037;
											x1044 = x1036;
										} break;
									}
									int64_t v1052 = 1LL /* True */;
									x1031 = v1052;
									x1030 = x1050;
									x1029 = x1049;
									x1028 = x1048;
									x1027 = x1047;
									x1026 = x1046;
									x1025 = x1045;
									x1024 = x1044;
								} break;
								case 0LL: { // None
									int64_t v1053 = 0LL /* False */;
									x1031 = v1053;
									x1030 = v1023;
									x1029 = v1020;
									x1028 = v1019;
									x1027 = v1018;
									x1026 = v1017;
									x1025 = v1016;
									x1024 = v1015;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v1014 = x1031;
							v1013 = x1030;
							v1012 = x1029;
							v1011 = x1028;
							v1010 = x1027;
							v1009 = x1026;
							v1008 = x1025;
							v1007 = x1024;
						}
						decref(v1013);
						int64_t v1054 = mw_std_maybe_Maybe_1_someZAsk(v1012);
						VAL x1055;
						VAL x1056;
						VAL x1057;
						VAL x1058;
						VAL x1059;
						if (((bool)v1054)) {
							VAL v1060 = mtw_std_either_Either_2_Right(v1009);
							x1059 = v1060;
							x1058 = v1011;
							x1057 = v1008;
							x1056 = v1010;
							x1055 = v1007;
						} else {
							VAL v1061 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v1009);
							VAL v1062 = mtw_std_either_Either_2_Left(v1061);
							x1059 = v1062;
							x1058 = v1011;
							x1057 = v1008;
							x1056 = v1010;
							x1055 = v1007;
						}
						VAL x1063;
						VAL x1064;
						VAL x1065;
						VAL x1066;
						VAL x1067;
						VAL x1068;
						switch (get_data_tag(x1059)) {
							case 0LL: { // Left
								VAL v1069 = mtp_std_either_Either_2_Left(x1059);
								VAL v1070 = mtw_std_list_List_1_Cons(v1069, v956);
								x1068 = v957;
								x1067 = v1070;
								x1066 = x1058;
								x1065 = x1057;
								x1064 = x1056;
								x1063 = x1055;
							} break;
							case 1LL: { // Right
								VAL v1071 = mtp_std_either_Either_2_Right(x1059);
								VAL v1072 = mtw_std_list_List_1_Cons(v1071, v957);
								x1068 = v1072;
								x1067 = v956;
								x1066 = x1058;
								x1065 = x1057;
								x1064 = x1056;
								x1063 = x1055;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v1073 = 1LL /* True */;
						x967 = v1073;
						x966 = v959;
						x965 = x1068;
						x964 = x1067;
						x963 = x1066;
						x962 = x1065;
						x961 = x1064;
						x960 = x1063;
					} break;
					case 0LL: { // None
						int64_t v1074 = 0LL /* False */;
						x967 = v1074;
						x966 = v959;
						x965 = v957;
						x964 = v956;
						x963 = x345;
						x962 = x346;
						x961 = x344;
						x960 = x343;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v1075 = x960;
				VAL v1076 = (x961);
				VAL v1077 = x962;
				VAL v1078 = (x963);
				VAL v1079 = x964;
				VAL v1080 = x965;
				VAL v1081 = x966;
				int64_t v1082 = x967;
				while (((bool)v1082)) {
					VAL v1083 = v1075;
					VAL v1084 = (v1076);
					VAL v1085 = v1077;
					VAL v1086 = (v1078);
					VAL v1087 = v1079;
					VAL v1088 = v1080;
					VAL v1089 = v1081;
					VAL v1090;
					VAL v1091;
					mw_std_list_List_1_uncons(v1089, &v1090, &v1091);
					VAL x1092;
					VAL x1093;
					VAL x1094;
					VAL x1095;
					VAL x1096;
					VAL x1097;
					VAL x1098;
					int64_t x1099;
					switch (get_data_tag(v1090)) {
						case 1LL: { // Some
							VAL v1100 = mtp_std_maybe_Maybe_1_Some(v1090);
							incref(v1085);
							incref(v1100);
							VAL v1101;
							VAL v1102;
							mw_mirth_def_Def_qnameZ_hard(v1084, v1100, &v1101, &v1102);
							VAL v1103;
							VAL v1104;
							VAL v1105;
							mw_mirth_name_QName_climbZ_upZ_dnameZAsk(v1101, v1086, v1085, v1102, &v1103, &v1104, &v1105);
							VAL v1106 = MKI64(0LL /* None */);
							VAL v1107;
							VAL v1108;
							mw_std_list_List_1_uncons(v1105, &v1107, &v1108);
							VAL x1109;
							VAL x1110;
							VAL x1111;
							VAL x1112;
							VAL x1113;
							VAL x1114;
							VAL x1115;
							int64_t x1116;
							switch (get_data_tag(v1107)) {
								case 1LL: { // Some
									VAL v1117 = mtp_std_maybe_Maybe_1_Some(v1107);
									incref(v1117);
									uint64_t v1118 = VU64(VTUP(v1104)->cells[2]);
									VAL v1119;
									int64_t v1120;
									mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(v1103, v1118, v1117, &v1119, &v1120);
									VAL x1121;
									VAL x1122;
									VAL x1123;
									VAL x1124;
									VAL x1125;
									VAL x1126;
									if (((bool)v1120)) {
										VAL v1127 = mtw_std_maybe_Maybe_1_Some(v1117);
										x1126 = v1127;
										x1125 = v1104;
										x1124 = v1119;
										x1123 = v1100;
										x1122 = v1085;
										x1121 = v1083;
									} else {
										decref(v1117);
										VAL v1128 = MKI64(0LL /* None */);
										x1126 = v1128;
										x1125 = v1104;
										x1124 = v1119;
										x1123 = v1100;
										x1122 = v1085;
										x1121 = v1083;
									}
									VAL x1129;
									VAL x1130;
									VAL x1131;
									VAL x1132;
									VAL x1133;
									VAL x1134;
									VAL x1135;
									switch (get_data_tag(x1126)) {
										case 0LL: { // None
											x1135 = v1108;
											x1134 = v1106;
											x1133 = x1125;
											x1132 = x1124;
											x1131 = x1123;
											x1130 = x1122;
											x1129 = x1121;
										} break;
										default: {
											decref(v1108);
											decref(v1106);
											VAL v1136 = MKI64(0LL /* Nil */);
											x1135 = v1136;
											x1134 = x1126;
											x1133 = x1125;
											x1132 = x1124;
											x1131 = x1123;
											x1130 = x1122;
											x1129 = x1121;
										} break;
									}
									int64_t v1137 = 1LL /* True */;
									x1116 = v1137;
									x1115 = x1135;
									x1114 = x1134;
									x1113 = x1133;
									x1112 = x1132;
									x1111 = x1131;
									x1110 = x1130;
									x1109 = x1129;
								} break;
								case 0LL: { // None
									int64_t v1138 = 0LL /* False */;
									x1116 = v1138;
									x1115 = v1108;
									x1114 = v1106;
									x1113 = v1104;
									x1112 = v1103;
									x1111 = v1100;
									x1110 = v1085;
									x1109 = v1083;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v1139 = x1109;
							VAL v1140 = x1110;
							VAL v1141 = x1111;
							VAL v1142 = (x1112);
							VAL v1143 = (x1113);
							VAL v1144 = x1114;
							VAL v1145 = x1115;
							int64_t v1146 = x1116;
							while (((bool)v1146)) {
								VAL v1147 = v1139;
								VAL v1148 = v1140;
								VAL v1149 = v1141;
								VAL v1150 = (v1142);
								VAL v1151 = (v1143);
								VAL v1152 = v1144;
								VAL v1153 = v1145;
								VAL v1154;
								VAL v1155;
								mw_std_list_List_1_uncons(v1153, &v1154, &v1155);
								VAL x1156;
								VAL x1157;
								VAL x1158;
								VAL x1159;
								VAL x1160;
								VAL x1161;
								VAL x1162;
								int64_t x1163;
								switch (get_data_tag(v1154)) {
									case 1LL: { // Some
										VAL v1164 = mtp_std_maybe_Maybe_1_Some(v1154);
										incref(v1164);
										uint64_t v1165 = VU64(VTUP(v1151)->cells[2]);
										VAL v1166;
										int64_t v1167;
										mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(v1150, v1165, v1164, &v1166, &v1167);
										VAL x1168;
										VAL x1169;
										VAL x1170;
										VAL x1171;
										VAL x1172;
										VAL x1173;
										if (((bool)v1167)) {
											VAL v1174 = mtw_std_maybe_Maybe_1_Some(v1164);
											x1173 = v1174;
											x1172 = v1151;
											x1171 = v1166;
											x1170 = v1149;
											x1169 = v1148;
											x1168 = v1147;
										} else {
											decref(v1164);
											VAL v1175 = MKI64(0LL /* None */);
											x1173 = v1175;
											x1172 = v1151;
											x1171 = v1166;
											x1170 = v1149;
											x1169 = v1148;
											x1168 = v1147;
										}
										VAL x1176;
										VAL x1177;
										VAL x1178;
										VAL x1179;
										VAL x1180;
										VAL x1181;
										VAL x1182;
										switch (get_data_tag(x1173)) {
											case 0LL: { // None
												x1182 = v1155;
												x1181 = v1152;
												x1180 = x1172;
												x1179 = x1171;
												x1178 = x1170;
												x1177 = x1169;
												x1176 = x1168;
											} break;
											default: {
												decref(v1155);
												decref(v1152);
												VAL v1183 = MKI64(0LL /* Nil */);
												x1182 = v1183;
												x1181 = x1173;
												x1180 = x1172;
												x1179 = x1171;
												x1178 = x1170;
												x1177 = x1169;
												x1176 = x1168;
											} break;
										}
										int64_t v1184 = 1LL /* True */;
										x1163 = v1184;
										x1162 = x1182;
										x1161 = x1181;
										x1160 = x1180;
										x1159 = x1179;
										x1158 = x1178;
										x1157 = x1177;
										x1156 = x1176;
									} break;
									case 0LL: { // None
										int64_t v1185 = 0LL /* False */;
										x1163 = v1185;
										x1162 = v1155;
										x1161 = v1152;
										x1160 = v1151;
										x1159 = v1150;
										x1158 = v1149;
										x1157 = v1148;
										x1156 = v1147;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v1146 = x1163;
								v1145 = x1162;
								v1144 = x1161;
								v1143 = x1160;
								v1142 = x1159;
								v1141 = x1158;
								v1140 = x1157;
								v1139 = x1156;
							}
							decref(v1145);
							int64_t v1186 = mw_std_maybe_Maybe_1_someZAsk(v1144);
							VAL x1187;
							VAL x1188;
							VAL x1189;
							VAL x1190;
							VAL x1191;
							if (((bool)v1186)) {
								VAL v1192 = mtw_std_either_Either_2_Right(v1141);
								x1191 = v1192;
								x1190 = v1143;
								x1189 = v1140;
								x1188 = v1142;
								x1187 = v1139;
							} else {
								VAL v1193 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v1141);
								VAL v1194 = mtw_std_either_Either_2_Left(v1193);
								x1191 = v1194;
								x1190 = v1143;
								x1189 = v1140;
								x1188 = v1142;
								x1187 = v1139;
							}
							VAL x1195;
							VAL x1196;
							VAL x1197;
							VAL x1198;
							VAL x1199;
							VAL x1200;
							switch (get_data_tag(x1191)) {
								case 0LL: { // Left
									VAL v1201 = mtp_std_either_Either_2_Left(x1191);
									VAL v1202 = mtw_std_list_List_1_Cons(v1201, v1087);
									x1200 = v1088;
									x1199 = v1202;
									x1198 = x1190;
									x1197 = x1189;
									x1196 = x1188;
									x1195 = x1187;
								} break;
								case 1LL: { // Right
									VAL v1203 = mtp_std_either_Either_2_Right(x1191);
									VAL v1204 = mtw_std_list_List_1_Cons(v1203, v1088);
									x1200 = v1204;
									x1199 = v1087;
									x1198 = x1190;
									x1197 = x1189;
									x1196 = x1188;
									x1195 = x1187;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v1205 = 1LL /* True */;
							x1099 = v1205;
							x1098 = v1091;
							x1097 = x1200;
							x1096 = x1199;
							x1095 = x1198;
							x1094 = x1197;
							x1093 = x1196;
							x1092 = x1195;
						} break;
						case 0LL: { // None
							int64_t v1206 = 0LL /* False */;
							x1099 = v1206;
							x1098 = v1091;
							x1097 = v1088;
							x1096 = v1087;
							x1095 = v1086;
							x1094 = v1085;
							x1093 = v1084;
							x1092 = v1083;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v1082 = x1099;
					v1081 = x1098;
					v1080 = x1097;
					v1079 = x1096;
					v1078 = x1095;
					v1077 = x1094;
					v1076 = x1093;
					v1075 = x1092;
				}
				decref(v1081);
				VAL v1207 = mw_std_list_List_1_reverse(v1079);
				VAL v1208 = mw_std_list_List_1_reverse(v1080);
				VAL v1209 = VVAL(VTUP(v1078)->cells[5]);
				incref(v1209);
				VAL v1210 = mw_std_list_List_1_cat(v1207, v1209);
				VAL v1211 = VTUP(v1078)->cells[5];
				decref(v1211);
				VTUP(v1078)->cells[5] = v1210;
				VAL v1212 = VTUP(v1078)->cells[4];
				decref(v1212);
				VTUP(v1078)->cells[4] = v1208;
				x354 = v1078;
				x353 = v1077;
				x352 = v1076;
				x351 = v1075;
			}
			decref(x353);
			x9 = x354;
			x8 = x352;
			x7 = x351;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	decref(x7);
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3, VAL *x4, int64_t *x5) {
	incref(x3);
	VAL v6;
	VAL v7;
	mw_mirth_def_Def_qnameZ_hard(x1, x3, &v6, &v7);
	VAL v8 = VVAL(VTUP(v7)->cells[1]);
	incref(v8);
	decref(v7);
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v8)) {
		case 0LL: { // NAMESPACE_ROOT
			decref(x3);
			int64_t v11 = 1LL /* True */;
			x10 = v11;
			x9 = v6;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v12 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(v8);
			decref(x3);
			int64_t v13 = 1LL /* True */;
			x10 = v13;
			x9 = v6;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v14 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(v8);
			decref(x3);
			int64_t v15 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(x2, v14);
			x10 = v15;
			x9 = v6;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v16 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v8);
			int64_t v17 = mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk(x2, v16);
			VAL x18;
			int64_t x19;
			if (((bool)v17)) {
				VAL v20 = mw_mirth_def_Def_tagZAsk(x3);
				int64_t v21 = mw_std_maybe_Maybe_1_ZToBool(v20);
				x19 = v21;
				x18 = v6;
			} else {
				decref(x3);
				int64_t v22 = 0LL /* False */;
				x19 = v22;
				x18 = v6;
			}
			x10 = x19;
			x9 = x18;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v23 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(v8);
			decref(x3);
			int64_t v24 = 0LL /* False */;
			x10 = v24;
			x9 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x10;
	*x4 = x9;
}
static int64_t mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk (uint64_t x1, VAL x2) {
	int64_t x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			uint64_t v4 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			VAL v5 = mw_mirth_data_Data_headZAsk(v4);
			int64_t x6;
			switch (get_data_tag(v5)) {
				case 1LL: { // Some
					VAL v7 = mtp_std_maybe_Maybe_1_Some(v5);
					uint64_t v8 = mw_mirth_token_Token_module(VU64(v7));
					int64_t v9 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(x1, v8);
					x6 = v9;
				} break;
				case 0LL: { // None
					int64_t v10 = 1LL /* True */;
					x6 = v10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x6;
		} break;
		case 1LL: { // TYCON_TABLE
			uint64_t v11 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			uint64_t v12 = mw_mirth_table_Table_head(v11);
			uint64_t v13 = mw_mirth_token_Token_module(v12);
			int64_t v14 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(x1, v13);
			x3 = v14;
		} break;
		case 2LL: { // TYCON_PRIM
			int64_t v15 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			int64_t v16 = 1LL /* True */;
			x3 = v16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3, VAL *x4, int64_t *x5) {
	VAL x6;
	int64_t x7;
	switch (get_data_tag(x3)) {
		case 0LL: { // NAMESPACE_ROOT
			int64_t v8 = 1LL /* True */;
			x7 = v8;
			x6 = x1;
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v9 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x3);
			int64_t v10 = 1LL /* True */;
			x7 = v10;
			x6 = x1;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x3);
			int64_t v12 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(x2, v11);
			x7 = v12;
			x6 = x1;
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v13 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x3);
			VAL v14;
			VAL v15;
			mw_mirth_tycon_Tycon_qnameZ_hard(x1, v13, &v14, &v15);
			VAL v16 = VVAL(VTUP(v15)->cells[1]);
			incref(v16);
			decref(v15);
			VAL v17;
			int64_t v18;
			mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(v14, x2, v16, &v17, &v18);
			x7 = v18;
			x6 = v17;
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v19 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x3);
			int64_t v20 = 0LL /* False */;
			x7 = v20;
			x6 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_name_QName_climbZ_upZ_nameZAsk (VAL x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x3);
	uint64_t v6 = VU64(VTUP(x3)->cells[2]);
	decref(x3);
	int64_t v7 = mw_mirth_name_Name_ZEqualZEqual(v6, x2);
	VAL x8;
	uint64_t x9;
	VAL x10;
	VAL x11;
	if (((bool)v7)) {
		incref(x3);
		VAL v12 = VVAL(VTUP(x3)->cells[1]);
		incref(v12);
		decref(x3);
		VAL v13 = MKI64(0LL /* Nil */);
		VAL v14 = mtw_std_list_List_1_Cons(v12, v13);
		x11 = v14;
		x10 = x3;
		x9 = x2;
		x8 = x1;
	} else {
		VAL v15 = MKI64(0LL /* Nil */);
		x11 = v15;
		x10 = x3;
		x9 = x2;
		x8 = x1;
	}
	VAL v16 = mw_mirth_name_Name_defs(x9);
	VAL v17;
	VAL v18;
	mw_std_list_List_1_uncons(v16, &v17, &v18);
	VAL x19;
	VAL x20;
	VAL x21;
	VAL x22;
	int64_t x23;
	switch (get_data_tag(v17)) {
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v17);
			VAL x25;
			VAL x26;
			VAL x27;
			switch (get_data_tag(v24)) {
				case 0LL: { // DefAlias
					uint64_t v28 = mtp_mirth_def_Def_DefAlias(v24);
					VAL v29;
					VAL v30;
					mw_mirth_alias_Alias_target(x8, v28, &v29, &v30);
					VAL v31;
					VAL v32;
					mw_mirth_def_Def_qnameZ_hard(v29, v30, &v31, &v32);
					incref(x10);
					int64_t v33 = mw_mirth_name_QName_ZEqualZEqual(v32, x10);
					VAL x34;
					VAL x35;
					VAL x36;
					if (((bool)v33)) {
						VAL v37;
						VAL v38;
						mw_mirth_alias_Alias_namespaceZ_hard(v31, v28, &v37, &v38);
						VAL v39 = mtw_std_list_List_1_Cons(v38, x11);
						x36 = v39;
						x35 = v37;
						x34 = x10;
					} else {
						x36 = x11;
						x35 = v31;
						x34 = x10;
					}
					x27 = x36;
					x26 = x35;
					x25 = x34;
				} break;
				case 5LL: { // DefType
					uint64_t v40 = mtp_mirth_def_Def_DefType(v24);
					VAL v41;
					VAL v42;
					mw_mirth_typedef_TypeDef_target(x8, v40, &v41, &v42);
					VAL v43 = mw_mirth_type_Type_tyconZAsk(v42);
					VAL x44;
					VAL x45;
					uint64_t x46;
					VAL x47;
					int64_t x48;
					switch (get_data_tag(v43)) {
						case 1LL: { // Some
							VAL v49 = mtp_std_maybe_Maybe_1_Some(v43);
							VAL v50;
							VAL v51;
							mw_mirth_tycon_Tycon_qnameZ_hard(v41, v49, &v50, &v51);
							incref(x10);
							int64_t v52 = mw_mirth_name_QName_ZEqualZEqual(v51, x10);
							x48 = v52;
							x47 = v50;
							x46 = v40;
							x45 = x11;
							x44 = x10;
						} break;
						case 0LL: { // None
							int64_t v53 = 0LL /* False */;
							x48 = v53;
							x47 = v41;
							x46 = v40;
							x45 = x11;
							x44 = x10;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL x54;
					VAL x55;
					VAL x56;
					if (((bool)x48)) {
						VAL v57;
						VAL v58;
						mw_mirth_typedef_TypeDef_namespace(x47, x46, &v57, &v58);
						VAL v59 = mtw_std_list_List_1_Cons(v58, x45);
						x56 = v59;
						x55 = v57;
						x54 = x44;
					} else {
						x56 = x45;
						x55 = x47;
						x54 = x44;
					}
					x27 = x56;
					x26 = x55;
					x25 = x54;
				} break;
				default: {
					decref(v24);
					x27 = x11;
					x26 = x8;
					x25 = x10;
				} break;
			}
			int64_t v60 = 1LL /* True */;
			x23 = v60;
			x22 = v18;
			x21 = x27;
			x20 = x25;
			x19 = x26;
		} break;
		case 0LL: { // None
			int64_t v61 = 0LL /* False */;
			x23 = v61;
			x22 = v18;
			x21 = x11;
			x20 = x10;
			x19 = x8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v62 = (x19);
	VAL v63 = x20;
	VAL v64 = x21;
	VAL v65 = x22;
	int64_t v66 = x23;
	while (((bool)v66)) {
		VAL v67 = (v62);
		VAL v68 = v63;
		VAL v69 = v64;
		VAL v70 = v65;
		VAL v71;
		VAL v72;
		mw_std_list_List_1_uncons(v70, &v71, &v72);
		VAL x73;
		VAL x74;
		VAL x75;
		VAL x76;
		int64_t x77;
		switch (get_data_tag(v71)) {
			case 1LL: { // Some
				VAL v78 = mtp_std_maybe_Maybe_1_Some(v71);
				VAL x79;
				VAL x80;
				VAL x81;
				switch (get_data_tag(v78)) {
					case 0LL: { // DefAlias
						uint64_t v82 = mtp_mirth_def_Def_DefAlias(v78);
						VAL v83;
						VAL v84;
						mw_mirth_alias_Alias_target(v67, v82, &v83, &v84);
						VAL v85;
						VAL v86;
						mw_mirth_def_Def_qnameZ_hard(v83, v84, &v85, &v86);
						incref(v68);
						int64_t v87 = mw_mirth_name_QName_ZEqualZEqual(v86, v68);
						VAL x88;
						VAL x89;
						VAL x90;
						if (((bool)v87)) {
							VAL v91;
							VAL v92;
							mw_mirth_alias_Alias_namespaceZ_hard(v85, v82, &v91, &v92);
							VAL v93 = mtw_std_list_List_1_Cons(v92, v69);
							x90 = v93;
							x89 = v91;
							x88 = v68;
						} else {
							x90 = v69;
							x89 = v85;
							x88 = v68;
						}
						x81 = x90;
						x80 = x89;
						x79 = x88;
					} break;
					case 5LL: { // DefType
						uint64_t v94 = mtp_mirth_def_Def_DefType(v78);
						VAL v95;
						VAL v96;
						mw_mirth_typedef_TypeDef_target(v67, v94, &v95, &v96);
						VAL v97 = mw_mirth_type_Type_tyconZAsk(v96);
						VAL x98;
						VAL x99;
						uint64_t x100;
						VAL x101;
						int64_t x102;
						switch (get_data_tag(v97)) {
							case 1LL: { // Some
								VAL v103 = mtp_std_maybe_Maybe_1_Some(v97);
								VAL v104;
								VAL v105;
								mw_mirth_tycon_Tycon_qnameZ_hard(v95, v103, &v104, &v105);
								incref(v68);
								int64_t v106 = mw_mirth_name_QName_ZEqualZEqual(v105, v68);
								x102 = v106;
								x101 = v104;
								x100 = v94;
								x99 = v69;
								x98 = v68;
							} break;
							case 0LL: { // None
								int64_t v107 = 0LL /* False */;
								x102 = v107;
								x101 = v95;
								x100 = v94;
								x99 = v69;
								x98 = v68;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL x108;
						VAL x109;
						VAL x110;
						if (((bool)x102)) {
							VAL v111;
							VAL v112;
							mw_mirth_typedef_TypeDef_namespace(x101, x100, &v111, &v112);
							VAL v113 = mtw_std_list_List_1_Cons(v112, x99);
							x110 = v113;
							x109 = v111;
							x108 = x98;
						} else {
							x110 = x99;
							x109 = x101;
							x108 = x98;
						}
						x81 = x110;
						x80 = x109;
						x79 = x108;
					} break;
					default: {
						decref(v78);
						x81 = v69;
						x80 = v67;
						x79 = v68;
					} break;
				}
				int64_t v114 = 1LL /* True */;
				x77 = v114;
				x76 = v72;
				x75 = x81;
				x74 = x79;
				x73 = x80;
			} break;
			case 0LL: { // None
				int64_t v115 = 0LL /* False */;
				x77 = v115;
				x76 = v72;
				x75 = v69;
				x74 = v68;
				x73 = v67;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v66 = x77;
		v65 = x76;
		v64 = x75;
		v63 = x74;
		v62 = x73;
	}
	decref(v65);
	decref(v63);
	*x5 = v64;
	*x4 = v62;
}
static void mw_mirth_name_QName_climbZ_upZ_dnameZAsk (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6, VAL *x7) {
	incref(x3);
	VAL v8 = mw_mirth_name_DName_rootZAsk(x3);
	VAL v9 = mw_std_maybe_Maybe_1_ZToList(v8);
	VAL v10 = mw_mirth_name_DName_parts(x3);
	VAL v11;
	VAL v12;
	mw_std_list_ListZPlus_1_unsnoc(v10, &v11, &v12);
	VAL v13 = mw_std_list_List_1_cat(v9, v11);
	int64_t v14 = VI64(VTUP(x2)->cells[6]);
	VAL x15;
	VAL x16;
	uint64_t x17;
	VAL x18;
	if (((bool)v14)) {
		decref(v12);
		VAL v19;
		VAL v20;
		mw_std_list_List_1_unsnoc(v13, &v19, &v20);
		VAL x21;
		VAL x22;
		VAL x23;
		uint64_t x24;
		switch (get_data_tag(v20)) {
			case 1LL: { // Some
				VAL v25 = mtp_std_maybe_Maybe_1_Some(v20);
				x24 = VU64(v25);
				x23 = v19;
				x22 = x2;
				x21 = x1;
			} break;
			case 0LL: { // None
				uint64_t v26 = VU64(VTUP(x2)->cells[2]);
				STR* v27;
				STRLIT(v27, "Error, expected a namespace in QName.climb-up-dname?", 52);
				push_value(v19);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v26, MKSTR(v27), x1);
				uint64_t v28 = pop_u64();
				x24 = v28;
				VAL v29 = pop_value();
				x23 = v29;
				x22 = x2;
				VAL r30 = pop_resource();
				x21 = r30;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x18 = x22;
		x17 = x24;
		x16 = x23;
		x15 = x21;
	} else {
		x18 = x2;
		x17 = VU64(v12);
		x16 = v13;
		x15 = x1;
	}
	VAL v31;
	VAL v32;
	mw_mirth_name_QName_climbZ_upZ_nameZAsk(x15, x17, x4, &v31, &v32);
	VAL v33 = mw_std_list_List_1_reverse(x16);
	VAL v34;
	VAL v35;
	mw_std_list_List_1_uncons(v33, &v34, &v35);
	VAL x36;
	VAL x37;
	VAL x38;
	VAL x39;
	int64_t x40;
	switch (get_data_tag(v34)) {
		case 1LL: { // Some
			VAL v41 = mtp_std_maybe_Maybe_1_Some(v34);
			VAL v42 = MKI64(0LL /* Nil */);
			VAL v43 = mw_std_list_List_1_reverse(v42);
			VAL v44;
			VAL v45;
			mw_std_list_List_1_uncons(v32, &v44, &v45);
			VAL x46;
			VAL x47;
			uint64_t x48;
			VAL x49;
			VAL x50;
			int64_t x51;
			switch (get_data_tag(v44)) {
				case 1LL: { // Some
					VAL v52 = mtp_std_maybe_Maybe_1_Some(v44);
					VAL v53;
					VAL v54;
					mw_mirth_name_Namespace_qname(v31, v52, &v53, &v54);
					uint64_t x55;
					VAL x56;
					VAL x57;
					VAL x58;
					switch (get_data_tag(v54)) {
						case 1LL: { // Some
							VAL v59 = mtp_std_maybe_Maybe_1_Some(v54);
							incref(v41);
							VAL v60;
							VAL v61;
							mw_mirth_name_QName_climbZ_upZ_nameZAsk(v53, VU64(v41), v59, &v60, &v61);
							x58 = x18;
							x57 = v61;
							x56 = v60;
							x55 = VU64(v41);
						} break;
						case 0LL: { // None
							VAL v62 = MKI64(0LL /* Nil */);
							x58 = x18;
							x57 = v62;
							x56 = v53;
							x55 = VU64(v41);
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v63;
					VAL v64;
					mw_std_list_List_1_uncons(x57, &v63, &v64);
					VAL x65;
					VAL x66;
					int64_t x67;
					switch (get_data_tag(v63)) {
						case 1LL: { // Some
							VAL v68 = mtp_std_maybe_Maybe_1_Some(v63);
							VAL v69 = mtw_std_list_List_1_Cons(v68, v43);
							int64_t v70 = 1LL /* True */;
							x67 = v70;
							x66 = v64;
							x65 = v69;
							push_u64(x55);
							push_resource(x56);
							push_resource(x58);
						} break;
						case 0LL: { // None
							int64_t v71 = 0LL /* False */;
							x67 = v71;
							x66 = v64;
							x65 = v43;
							push_u64(x55);
							push_resource(x56);
							push_resource(x58);
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v72 = (x65);
					VAL v73 = x66;
					int64_t v74 = x67;
					while (((bool)v74)) {
						VAL v75 = (v72);
						VAL v76 = v73;
						VAL v77;
						VAL v78;
						mw_std_list_List_1_uncons(v76, &v77, &v78);
						VAL x79;
						VAL x80;
						int64_t x81;
						switch (get_data_tag(v77)) {
							case 1LL: { // Some
								VAL v82 = mtp_std_maybe_Maybe_1_Some(v77);
								VAL v83 = mtw_std_list_List_1_Cons(v82, v75);
								int64_t v84 = 1LL /* True */;
								x81 = v84;
								x80 = v78;
								x79 = v83;
							} break;
							case 0LL: { // None
								int64_t v85 = 0LL /* False */;
								x81 = v85;
								x80 = v78;
								x79 = v75;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						v74 = x81;
						v73 = x80;
						v72 = x79;
					}
					decref(v73);
					int64_t v86 = 1LL /* True */;
					x51 = v86;
					x50 = v45;
					x49 = v72;
					uint64_t v87 = pop_u64();
					x48 = v87;
					VAL r88 = pop_resource();
					x47 = r88;
					VAL r89 = pop_resource();
					x46 = r89;
				} break;
				case 0LL: { // None
					int64_t v90 = 0LL /* False */;
					x51 = v90;
					x50 = v45;
					x49 = v43;
					x48 = VU64(v41);
					x47 = x18;
					x46 = v31;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v91 = (x46);
			VAL v92 = (x47);
			uint64_t v93 = x48;
			VAL v94 = (x49);
			VAL v95 = x50;
			int64_t v96 = x51;
			while (((bool)v96)) {
				VAL v97 = (v91);
				VAL v98 = (v92);
				uint64_t v99 = v93;
				VAL v100 = (v94);
				VAL v101 = v95;
				VAL v102;
				VAL v103;
				mw_std_list_List_1_uncons(v101, &v102, &v103);
				VAL x104;
				VAL x105;
				uint64_t x106;
				VAL x107;
				VAL x108;
				int64_t x109;
				switch (get_data_tag(v102)) {
					case 1LL: { // Some
						VAL v110 = mtp_std_maybe_Maybe_1_Some(v102);
						VAL v111;
						VAL v112;
						mw_mirth_name_Namespace_qname(v97, v110, &v111, &v112);
						uint64_t x113;
						VAL x114;
						VAL x115;
						VAL x116;
						switch (get_data_tag(v112)) {
							case 1LL: { // Some
								VAL v117 = mtp_std_maybe_Maybe_1_Some(v112);
								VAL v118;
								VAL v119;
								mw_mirth_name_QName_climbZ_upZ_nameZAsk(v111, v99, v117, &v118, &v119);
								x116 = v98;
								x115 = v119;
								x114 = v118;
								x113 = v99;
							} break;
							case 0LL: { // None
								VAL v120 = MKI64(0LL /* Nil */);
								x116 = v98;
								x115 = v120;
								x114 = v111;
								x113 = v99;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v121;
						VAL v122;
						mw_std_list_List_1_uncons(x115, &v121, &v122);
						VAL x123;
						VAL x124;
						int64_t x125;
						switch (get_data_tag(v121)) {
							case 1LL: { // Some
								VAL v126 = mtp_std_maybe_Maybe_1_Some(v121);
								VAL v127 = mtw_std_list_List_1_Cons(v126, v100);
								int64_t v128 = 1LL /* True */;
								x125 = v128;
								x124 = v122;
								x123 = v127;
								push_u64(x113);
								push_resource(x114);
								push_resource(x116);
							} break;
							case 0LL: { // None
								int64_t v129 = 0LL /* False */;
								x125 = v129;
								x124 = v122;
								x123 = v100;
								push_u64(x113);
								push_resource(x114);
								push_resource(x116);
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v130 = (x123);
						VAL v131 = x124;
						int64_t v132 = x125;
						while (((bool)v132)) {
							VAL v133 = (v130);
							VAL v134 = v131;
							VAL v135;
							VAL v136;
							mw_std_list_List_1_uncons(v134, &v135, &v136);
							VAL x137;
							VAL x138;
							int64_t x139;
							switch (get_data_tag(v135)) {
								case 1LL: { // Some
									VAL v140 = mtp_std_maybe_Maybe_1_Some(v135);
									VAL v141 = mtw_std_list_List_1_Cons(v140, v133);
									int64_t v142 = 1LL /* True */;
									x139 = v142;
									x138 = v136;
									x137 = v141;
								} break;
								case 0LL: { // None
									int64_t v143 = 0LL /* False */;
									x139 = v143;
									x138 = v136;
									x137 = v133;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v132 = x139;
							v131 = x138;
							v130 = x137;
						}
						decref(v131);
						int64_t v144 = 1LL /* True */;
						x109 = v144;
						x108 = v103;
						x107 = v130;
						uint64_t v145 = pop_u64();
						x106 = v145;
						VAL r146 = pop_resource();
						x105 = r146;
						VAL r147 = pop_resource();
						x104 = r147;
					} break;
					case 0LL: { // None
						int64_t v148 = 0LL /* False */;
						x109 = v148;
						x108 = v103;
						x107 = v100;
						x106 = v99;
						x105 = v98;
						x104 = v97;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v96 = x109;
				v95 = x108;
				v94 = x107;
				v93 = x106;
				v92 = x105;
				v91 = x104;
			}
			decref(v95);
			VAL v149 = mw_std_list_List_1_reverse(v94);
			int64_t v150 = 1LL /* True */;
			x40 = v150;
			x39 = v35;
			x38 = v149;
			x37 = v92;
			x36 = v91;
		} break;
		case 0LL: { // None
			int64_t v151 = 0LL /* False */;
			x40 = v151;
			x39 = v35;
			x38 = v32;
			x37 = x18;
			x36 = v31;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v152 = (x36);
	VAL v153 = (x37);
	VAL v154 = x38;
	VAL v155 = x39;
	int64_t v156 = x40;
	while (((bool)v156)) {
		VAL v157 = (v152);
		VAL v158 = (v153);
		VAL v159 = v154;
		VAL v160 = v155;
		VAL v161;
		VAL v162;
		mw_std_list_List_1_uncons(v160, &v161, &v162);
		VAL x163;
		VAL x164;
		VAL x165;
		VAL x166;
		int64_t x167;
		switch (get_data_tag(v161)) {
			case 1LL: { // Some
				VAL v168 = mtp_std_maybe_Maybe_1_Some(v161);
				VAL v169 = MKI64(0LL /* Nil */);
				VAL v170 = mw_std_list_List_1_reverse(v169);
				VAL v171;
				VAL v172;
				mw_std_list_List_1_uncons(v159, &v171, &v172);
				VAL x173;
				VAL x174;
				uint64_t x175;
				VAL x176;
				VAL x177;
				int64_t x178;
				switch (get_data_tag(v171)) {
					case 1LL: { // Some
						VAL v179 = mtp_std_maybe_Maybe_1_Some(v171);
						VAL v180;
						VAL v181;
						mw_mirth_name_Namespace_qname(v157, v179, &v180, &v181);
						uint64_t x182;
						VAL x183;
						VAL x184;
						VAL x185;
						switch (get_data_tag(v181)) {
							case 1LL: { // Some
								VAL v186 = mtp_std_maybe_Maybe_1_Some(v181);
								incref(v168);
								VAL v187;
								VAL v188;
								mw_mirth_name_QName_climbZ_upZ_nameZAsk(v180, VU64(v168), v186, &v187, &v188);
								x185 = v158;
								x184 = v188;
								x183 = v187;
								x182 = VU64(v168);
							} break;
							case 0LL: { // None
								VAL v189 = MKI64(0LL /* Nil */);
								x185 = v158;
								x184 = v189;
								x183 = v180;
								x182 = VU64(v168);
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v190;
						VAL v191;
						mw_std_list_List_1_uncons(x184, &v190, &v191);
						VAL x192;
						VAL x193;
						int64_t x194;
						switch (get_data_tag(v190)) {
							case 1LL: { // Some
								VAL v195 = mtp_std_maybe_Maybe_1_Some(v190);
								VAL v196 = mtw_std_list_List_1_Cons(v195, v170);
								int64_t v197 = 1LL /* True */;
								x194 = v197;
								x193 = v191;
								x192 = v196;
								push_u64(x182);
								push_resource(x183);
								push_resource(x185);
							} break;
							case 0LL: { // None
								int64_t v198 = 0LL /* False */;
								x194 = v198;
								x193 = v191;
								x192 = v170;
								push_u64(x182);
								push_resource(x183);
								push_resource(x185);
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v199 = (x192);
						VAL v200 = x193;
						int64_t v201 = x194;
						while (((bool)v201)) {
							VAL v202 = (v199);
							VAL v203 = v200;
							VAL v204;
							VAL v205;
							mw_std_list_List_1_uncons(v203, &v204, &v205);
							VAL x206;
							VAL x207;
							int64_t x208;
							switch (get_data_tag(v204)) {
								case 1LL: { // Some
									VAL v209 = mtp_std_maybe_Maybe_1_Some(v204);
									VAL v210 = mtw_std_list_List_1_Cons(v209, v202);
									int64_t v211 = 1LL /* True */;
									x208 = v211;
									x207 = v205;
									x206 = v210;
								} break;
								case 0LL: { // None
									int64_t v212 = 0LL /* False */;
									x208 = v212;
									x207 = v205;
									x206 = v202;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v201 = x208;
							v200 = x207;
							v199 = x206;
						}
						decref(v200);
						int64_t v213 = 1LL /* True */;
						x178 = v213;
						x177 = v172;
						x176 = v199;
						uint64_t v214 = pop_u64();
						x175 = v214;
						VAL r215 = pop_resource();
						x174 = r215;
						VAL r216 = pop_resource();
						x173 = r216;
					} break;
					case 0LL: { // None
						int64_t v217 = 0LL /* False */;
						x178 = v217;
						x177 = v172;
						x176 = v170;
						x175 = VU64(v168);
						x174 = v158;
						x173 = v157;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v218 = (x173);
				VAL v219 = (x174);
				uint64_t v220 = x175;
				VAL v221 = (x176);
				VAL v222 = x177;
				int64_t v223 = x178;
				while (((bool)v223)) {
					VAL v224 = (v218);
					VAL v225 = (v219);
					uint64_t v226 = v220;
					VAL v227 = (v221);
					VAL v228 = v222;
					VAL v229;
					VAL v230;
					mw_std_list_List_1_uncons(v228, &v229, &v230);
					VAL x231;
					VAL x232;
					uint64_t x233;
					VAL x234;
					VAL x235;
					int64_t x236;
					switch (get_data_tag(v229)) {
						case 1LL: { // Some
							VAL v237 = mtp_std_maybe_Maybe_1_Some(v229);
							VAL v238;
							VAL v239;
							mw_mirth_name_Namespace_qname(v224, v237, &v238, &v239);
							uint64_t x240;
							VAL x241;
							VAL x242;
							VAL x243;
							switch (get_data_tag(v239)) {
								case 1LL: { // Some
									VAL v244 = mtp_std_maybe_Maybe_1_Some(v239);
									VAL v245;
									VAL v246;
									mw_mirth_name_QName_climbZ_upZ_nameZAsk(v238, v226, v244, &v245, &v246);
									x243 = v225;
									x242 = v246;
									x241 = v245;
									x240 = v226;
								} break;
								case 0LL: { // None
									VAL v247 = MKI64(0LL /* Nil */);
									x243 = v225;
									x242 = v247;
									x241 = v238;
									x240 = v226;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v248;
							VAL v249;
							mw_std_list_List_1_uncons(x242, &v248, &v249);
							VAL x250;
							VAL x251;
							int64_t x252;
							switch (get_data_tag(v248)) {
								case 1LL: { // Some
									VAL v253 = mtp_std_maybe_Maybe_1_Some(v248);
									VAL v254 = mtw_std_list_List_1_Cons(v253, v227);
									int64_t v255 = 1LL /* True */;
									x252 = v255;
									x251 = v249;
									x250 = v254;
									push_u64(x240);
									push_resource(x241);
									push_resource(x243);
								} break;
								case 0LL: { // None
									int64_t v256 = 0LL /* False */;
									x252 = v256;
									x251 = v249;
									x250 = v227;
									push_u64(x240);
									push_resource(x241);
									push_resource(x243);
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v257 = (x250);
							VAL v258 = x251;
							int64_t v259 = x252;
							while (((bool)v259)) {
								VAL v260 = (v257);
								VAL v261 = v258;
								VAL v262;
								VAL v263;
								mw_std_list_List_1_uncons(v261, &v262, &v263);
								VAL x264;
								VAL x265;
								int64_t x266;
								switch (get_data_tag(v262)) {
									case 1LL: { // Some
										VAL v267 = mtp_std_maybe_Maybe_1_Some(v262);
										VAL v268 = mtw_std_list_List_1_Cons(v267, v260);
										int64_t v269 = 1LL /* True */;
										x266 = v269;
										x265 = v263;
										x264 = v268;
									} break;
									case 0LL: { // None
										int64_t v270 = 0LL /* False */;
										x266 = v270;
										x265 = v263;
										x264 = v260;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v259 = x266;
								v258 = x265;
								v257 = x264;
							}
							decref(v258);
							int64_t v271 = 1LL /* True */;
							x236 = v271;
							x235 = v230;
							x234 = v257;
							uint64_t v272 = pop_u64();
							x233 = v272;
							VAL r273 = pop_resource();
							x232 = r273;
							VAL r274 = pop_resource();
							x231 = r274;
						} break;
						case 0LL: { // None
							int64_t v275 = 0LL /* False */;
							x236 = v275;
							x235 = v230;
							x234 = v227;
							x233 = v226;
							x232 = v225;
							x231 = v224;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v223 = x236;
					v222 = x235;
					v221 = x234;
					v220 = x233;
					v219 = x232;
					v218 = x231;
				}
				decref(v222);
				VAL v276 = mw_std_list_List_1_reverse(v221);
				int64_t v277 = 1LL /* True */;
				x167 = v277;
				x166 = v162;
				x165 = v276;
				x164 = v219;
				x163 = v218;
			} break;
			case 0LL: { // None
				int64_t v278 = 0LL /* False */;
				x167 = v278;
				x166 = v162;
				x165 = v159;
				x164 = v158;
				x163 = v157;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v156 = x167;
		v155 = x166;
		v154 = x165;
		v153 = x164;
		v152 = x163;
	}
	decref(v155);
	*x7 = v154;
	*x6 = v153;
	*x5 = v152;
}
static void mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	int64_t v7 = 0LL /* False */;
	int64_t v8 = 0LL /* False */;
	uint64_t v9 = VU64(VTUP(x2)->cells[2]);
	STR* v10;
	STRLIT(v10, "type", 4);
	VAL v11;
	VAL v12;
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v10), v9, x3, v8, v7, x1, &v11, &v12);
	VAL v13 = VVAL(VTUP(v12)->cells[4]);
	incref(v13);
	VAL v14 = MKI64(0LL /* Nil */);
	VAL v15 = MKI64(0LL /* Nil */);
	VAL v16;
	VAL v17;
	mw_std_list_List_1_uncons(v13, &v16, &v17);
	VAL x18;
	VAL x19;
	VAL x20;
	VAL x21;
	VAL x22;
	int64_t x23;
	switch (get_data_tag(v16)) {
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v16);
			incref(v24);
			VAL v25;
			int64_t v26;
			mw_mirth_def_Def_definesZ_aZ_typeZAsk(v11, v24, &v25, &v26);
			VAL x27;
			VAL x28;
			VAL x29;
			if (((bool)v26)) {
				VAL v30 = mtw_std_either_Either_2_Right(v24);
				x29 = v30;
				x28 = v12;
				x27 = v25;
			} else {
				VAL v31 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v24);
				VAL v32 = mtw_std_either_Either_2_Left(v31);
				x29 = v32;
				x28 = v12;
				x27 = v25;
			}
			VAL x33;
			VAL x34;
			VAL x35;
			VAL x36;
			switch (get_data_tag(x29)) {
				case 0LL: { // Left
					VAL v37 = mtp_std_either_Either_2_Left(x29);
					VAL v38 = mtw_std_list_List_1_Cons(v37, v14);
					x36 = v15;
					x35 = v38;
					x34 = x28;
					x33 = x27;
				} break;
				case 1LL: { // Right
					VAL v39 = mtp_std_either_Either_2_Right(x29);
					VAL v40 = mtw_std_list_List_1_Cons(v39, v15);
					x36 = v40;
					x35 = v14;
					x34 = x28;
					x33 = x27;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v41 = 1LL /* True */;
			x23 = v41;
			x22 = v17;
			x21 = x36;
			x20 = x35;
			x19 = x34;
			x18 = x33;
		} break;
		case 0LL: { // None
			int64_t v42 = 0LL /* False */;
			x23 = v42;
			x22 = v17;
			x21 = v15;
			x20 = v14;
			x19 = v12;
			x18 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v43 = (x18);
	VAL v44 = (x19);
	VAL v45 = x20;
	VAL v46 = x21;
	VAL v47 = x22;
	int64_t v48 = x23;
	while (((bool)v48)) {
		VAL v49 = (v43);
		VAL v50 = (v44);
		VAL v51 = v45;
		VAL v52 = v46;
		VAL v53 = v47;
		VAL v54;
		VAL v55;
		mw_std_list_List_1_uncons(v53, &v54, &v55);
		VAL x56;
		VAL x57;
		VAL x58;
		VAL x59;
		VAL x60;
		int64_t x61;
		switch (get_data_tag(v54)) {
			case 1LL: { // Some
				VAL v62 = mtp_std_maybe_Maybe_1_Some(v54);
				incref(v62);
				VAL v63;
				int64_t v64;
				mw_mirth_def_Def_definesZ_aZ_typeZAsk(v49, v62, &v63, &v64);
				VAL x65;
				VAL x66;
				VAL x67;
				if (((bool)v64)) {
					VAL v68 = mtw_std_either_Either_2_Right(v62);
					x67 = v68;
					x66 = v50;
					x65 = v63;
				} else {
					VAL v69 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v62);
					VAL v70 = mtw_std_either_Either_2_Left(v69);
					x67 = v70;
					x66 = v50;
					x65 = v63;
				}
				VAL x71;
				VAL x72;
				VAL x73;
				VAL x74;
				switch (get_data_tag(x67)) {
					case 0LL: { // Left
						VAL v75 = mtp_std_either_Either_2_Left(x67);
						VAL v76 = mtw_std_list_List_1_Cons(v75, v51);
						x74 = v52;
						x73 = v76;
						x72 = x66;
						x71 = x65;
					} break;
					case 1LL: { // Right
						VAL v77 = mtp_std_either_Either_2_Right(x67);
						VAL v78 = mtw_std_list_List_1_Cons(v77, v52);
						x74 = v78;
						x73 = v51;
						x72 = x66;
						x71 = x65;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v79 = 1LL /* True */;
				x61 = v79;
				x60 = v55;
				x59 = x74;
				x58 = x73;
				x57 = x72;
				x56 = x71;
			} break;
			case 0LL: { // None
				int64_t v80 = 0LL /* False */;
				x61 = v80;
				x60 = v55;
				x59 = v52;
				x58 = v51;
				x57 = v50;
				x56 = v49;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v48 = x61;
		v47 = x60;
		v46 = x59;
		v45 = x58;
		v44 = x57;
		v43 = x56;
	}
	decref(v47);
	VAL v81 = mw_std_list_List_1_reverse(v45);
	VAL v82 = mw_std_list_List_1_reverse(v46);
	VAL v83 = VVAL(VTUP(v44)->cells[5]);
	incref(v83);
	VAL v84 = mw_std_list_List_1_cat(v81, v83);
	VAL v85 = VTUP(v44)->cells[5];
	decref(v85);
	VTUP(v44)->cells[5] = v84;
	VAL v86 = VTUP(v44)->cells[4];
	decref(v86);
	VTUP(v44)->cells[4] = v82;
	VAL v87;
	VAL v88;
	mw_mirth_elab_ZPlusResolveDef_filterZ_arity(v43, v44, &v87, &v88);
	VAL v89;
	VAL v90;
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(v87, v88, &v89, &v90);
	VAL v91 = MKI64(0LL /* Nil */);
	VAL v92;
	VAL v93;
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v91, v89, v90, &v92, &v93);
	VAL v94;
	VAL v95;
	mw_mirth_elab_resolveZ_defZ_endZBang(v92, v93, &v94, &v95);
	VAL x96;
	VAL x97;
	VAL x98;
	switch (get_data_tag(v95)) {
		case 1LL: { // Some
			VAL v99 = mtp_std_maybe_Maybe_1_Some(v95);
			VAL x100;
			VAL x101;
			VAL x102;
			switch (get_data_tag(v99)) {
				case 3LL: { // DefData
					uint64_t v103 = mtp_mirth_def_Def_DefData(v99);
					VAL v104 = mtw_mirth_type_Type_TData(v103);
					x102 = v104;
					x101 = x2;
					x100 = v94;
				} break;
				case 4LL: { // DefTable
					uint64_t v105 = mtp_mirth_def_Def_DefTable(v99);
					VAL v106 = mtw_mirth_type_Type_TTable(v105);
					x102 = v106;
					x101 = x2;
					x100 = v94;
				} break;
				case 5LL: { // DefType
					uint64_t v107 = mtp_mirth_def_Def_DefType(v99);
					VAL v108;
					VAL v109;
					mw_mirth_typedef_TypeDef_target(v94, v107, &v108, &v109);
					x102 = v109;
					x101 = x2;
					x100 = v108;
				} break;
				default: {
					decref(v99);
					uint64_t v110 = VU64(VTUP(x2)->cells[2]);
					STR* v111;
					STRLIT(v111, "compiler bug: resolve-type-con-name! doesn't understand type", 60);
					VAL v112 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v110, MKSTR(v111), v94));
					VAL v113 = MKI64(0LL /* TYPE_ERROR */);
					x102 = v113;
					x101 = x2;
					x100 = v112;
				} break;
			}
			VAL v114 = mtw_std_maybe_Maybe_1_Some(x102);
			x98 = v114;
			x97 = x101;
			x96 = x100;
		} break;
		case 0LL: { // None
			VAL v115 = MKI64(0LL /* None */);
			x98 = v115;
			x97 = x2;
			x96 = v94;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x116;
	VAL x117;
	VAL x118;
	switch (get_data_tag(x98)) {
		case 1LL: { // Some
			VAL v119 = mtp_std_maybe_Maybe_1_Some(x98);
			x118 = v119;
			x117 = x97;
			x116 = x96;
		} break;
		case 0LL: { // None
			VAL v120 = MKI64(0LL /* TYPE_ERROR */);
			x118 = v120;
			x117 = x97;
			x116 = x96;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x118;
	*x5 = x117;
	*x4 = x116;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	incref(x3);
	VAL v7 = mw_std_either_Either_2_leftZAsk(x3);
	VAL x8;
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v13 = mw_mirth_name_Name_ZToStr(VU64(v12));
			STR* v14;
			STRLIT(v14, "Mut", 3);
			bool v15 = (str_cmp(VSTR(v13), v14) == 0);
			x11 = ((int64_t)v15);
			x10 = x3;
			x9 = x2;
			x8 = x1;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x11 = v16;
			x10 = x3;
			x9 = x2;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x17;
	VAL x18;
	VAL x19;
	if (((bool)x11)) {
		decref(x10);
		uint64_t v20 = VU64(VTUP(x9)->cells[2]);
		uint64_t v21 = mw_mirth_token_Token_next(v20);
		uint64_t v22 = VU64(VTUP(x9)->cells[2]);
		uint64_t v23;
		VAL v24;
		mw_mirth_token_Token_argsZ_1(v22, x8, &v23, &v24);
		VTUP(x9)->cells[2] = MKU64(v23);
		VAL v25;
		VAL v26;
		VAL v27;
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(v24, x9, &v25, &v26, &v27);
		VAL v28 = mtw_mirth_type_Type_TMut(v27);
		VTUP(v26)->cells[2] = MKU64(v21);
		x19 = v26;
		x18 = v28;
		x17 = v25;
	} else {
		VAL v29;
		VAL v30;
		VAL v31;
		mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang(x8, x9, x10, &v29, &v30, &v31);
		VAL v32;
		VAL v33;
		VAL v34;
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang(v29, v30, v31, &v32, &v33, &v34);
		uint64_t v35 = VU64(VTUP(v33)->cells[2]);
		uint64_t v36 = mw_mirth_token_Token_next(v35);
		VTUP(v33)->cells[2] = MKU64(v36);
		x19 = v33;
		x18 = v34;
		x17 = v32;
	}
	*x6 = x18;
	*x5 = x19;
	*x4 = x17;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	VAL v9;
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang(x1, x2, x3, &v7, &v8, &v9);
	*x6 = v9;
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	uint64_t v7 = VU64(VTUP(x2)->cells[2]);
	int64_t v8 = mw_mirth_token_Token_hasZ_argsZAsk(v7);
	VAL x9;
	VAL x10;
	VAL x11;
	if (((bool)v8)) {
		uint64_t v12 = VU64(VTUP(x2)->cells[2]);
		uint64_t v13 = VU64(VTUP(x2)->cells[2]);
		VAL v14 = mw_mirth_token_Token_args(v13);
		VAL v15;
		VAL v16;
		mw_std_list_List_1_uncons(v14, &v15, &v16);
		VAL x17;
		VAL x18;
		VAL x19;
		VAL x20;
		int64_t x21;
		switch (get_data_tag(v15)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v15);
				VTUP(x2)->cells[2] = v22;
				VAL v23;
				VAL v24;
				VAL v25;
				mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(x1, x2, &v23, &v24, &v25);
				VAL v26 = mtw_mirth_type_Type_TApp(x3, v25);
				int64_t v27 = 1LL /* True */;
				x21 = v27;
				x20 = v16;
				x19 = v24;
				x18 = v26;
				x17 = v23;
			} break;
			case 0LL: { // None
				int64_t v28 = 0LL /* False */;
				x21 = v28;
				x20 = v16;
				x19 = x2;
				x18 = x3;
				x17 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v29 = (x17);
		VAL v30 = x18;
		VAL v31 = (x19);
		VAL v32 = x20;
		int64_t v33 = x21;
		while (((bool)v33)) {
			VAL v34 = (v29);
			VAL v35 = v30;
			VAL v36 = (v31);
			VAL v37 = v32;
			VAL v38;
			VAL v39;
			mw_std_list_List_1_uncons(v37, &v38, &v39);
			VAL x40;
			VAL x41;
			VAL x42;
			VAL x43;
			int64_t x44;
			switch (get_data_tag(v38)) {
				case 1LL: { // Some
					VAL v45 = mtp_std_maybe_Maybe_1_Some(v38);
					VTUP(v36)->cells[2] = v45;
					VAL v46;
					VAL v47;
					VAL v48;
					mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(v34, v36, &v46, &v47, &v48);
					VAL v49 = mtw_mirth_type_Type_TApp(v35, v48);
					int64_t v50 = 1LL /* True */;
					x44 = v50;
					x43 = v39;
					x42 = v47;
					x41 = v49;
					x40 = v46;
				} break;
				case 0LL: { // None
					int64_t v51 = 0LL /* False */;
					x44 = v51;
					x43 = v39;
					x42 = v36;
					x41 = v35;
					x40 = v34;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v33 = x44;
			v32 = x43;
			v31 = x42;
			v30 = x41;
			v29 = x40;
		}
		decref(v32);
		VTUP(v31)->cells[2] = MKU64(v12);
		x11 = v31;
		x10 = v30;
		x9 = v29;
	} else {
		x11 = x2;
		x10 = x3;
		x9 = x1;
	}
	*x6 = x10;
	*x5 = x11;
	*x4 = x9;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6) {
	int64_t v7 = VI64(VTUP(x2)->cells[3]);
	VAL x8;
	VAL x9;
	VAL x10;
	if (((bool)v7)) {
		uint64_t v11 = VU64(VTUP(x2)->cells[2]);
		VAL v12 = (mw_mirth_token_Token_argsZ_0(v11, x1));
		VAL v13 = mtw_mirth_type_Type_THole(x3);
		x10 = v13;
		x9 = x2;
		x8 = v12;
	} else {
		uint64_t v14 = VU64(VTUP(x2)->cells[2]);
		STR* v15;
		STRLIT(v15, "type holes are not allowed here", 31);
		VAL v16 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v14, MKSTR(v15), x1));
		VAL v17 = MKI64(0LL /* TYPE_ERROR */);
		x10 = v17;
		x9 = x2;
		x8 = v16;
	}
	uint64_t v18 = VU64(VTUP(x9)->cells[2]);
	uint64_t v19 = mw_mirth_token_Token_next(v18);
	VTUP(x9)->cells[2] = MKU64(v19);
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	int64_t v6 = VI64(VTUP(x2)->cells[3]);
	VAL x7;
	VAL x8;
	VAL x9;
	if (((bool)v6)) {
		uint64_t v10 = VU64(VTUP(x2)->cells[2]);
		VAL v11 = (mw_mirth_token_Token_argsZ_0(v10, x1));
		VAL v12 = MKI64(1LL /* TYPE_DONT_CARE */);
		x9 = v12;
		x8 = x2;
		x7 = v11;
	} else {
		uint64_t v13 = VU64(VTUP(x2)->cells[2]);
		STR* v14;
		STRLIT(v14, "underscore is not allowed here", 30);
		VAL v15 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v13, MKSTR(v14), x1));
		VAL v16 = MKI64(0LL /* TYPE_ERROR */);
		x9 = v16;
		x8 = x2;
		x7 = v15;
	}
	uint64_t v17 = VU64(VTUP(x8)->cells[2]);
	uint64_t v18 = mw_mirth_token_Token_next(v17);
	VTUP(x8)->cells[2] = MKU64(v18);
	*x5 = x9;
	*x4 = x8;
	*x3 = x7;
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	uint64_t v6 = VU64(VTUP(x2)->cells[2]);
	uint64_t v7 = mw_mirth_token_Token_next(v6);
	uint64_t v8 = VU64(VTUP(x2)->cells[2]);
	uint64_t v9;
	VAL v10;
	mw_mirth_token_Token_argsZ_1(v8, x1, &v9, &v10);
	VTUP(x2)->cells[2] = MKU64(v9);
	uint64_t v11 = VU64(VTUP(x2)->cells[2]);
	int64_t v12 = mw_mirth_token_Token_sigZ_hasZ_dashesZAsk(v11);
	VAL x13;
	VAL x14;
	VAL x15;
	if (((bool)v12)) {
		VAL v16;
		VAL v17;
		VAL v18;
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(v10, x2, &v16, &v17, &v18);
		VAL v19 = mw_mirth_type_ArrowType_ZToType(v18);
		x15 = v19;
		x14 = v17;
		x13 = v16;
	} else {
		VAL v20;
		VAL v21;
		VAL v22;
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(v10, x2, &v20, &v21, &v22);
		VAL v23 = mw_mirth_type_StackType_ZToType(v22);
		x15 = v23;
		x14 = v21;
		x13 = v20;
	}
	VTUP(x14)->cells[2] = MKU64(v7);
	*x5 = x15;
	*x4 = x14;
	*x3 = x13;
}
static void mw_mirth_elab_elabZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6, uint64_t *x7) {
	VAL v8;
	uint64_t v9;
	VAL v10;
	mw_mirth_type_Type_unifyZBang(x1, x4, x2, x3, &v8, &v9, &v10);
	*x7 = v9;
	*x6 = v10;
	*x5 = v8;
}
static void mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6, uint64_t *x7) {
	VAL v8;
	uint64_t v9;
	VAL v10;
	mw_mirth_type_StackType_unifyZBang(x1, x4, x2, x3, &v8, &v9, &v10);
	*x7 = v9;
	*x6 = v10;
	*x5 = v8;
}
static void mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_var_Ctx0();
	int64_t v6 = 0LL /* False */;
	int64_t v7 = 0LL /* False */;
	VAL v8 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v5, x2, v6, v7));
	VAL v9;
	VAL v10;
	VAL v11;
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(x1, v8, &v9, &v10, &v11);
	mw_mirth_elab_ZPlusTypeElab_rdrop(v10);
	*x4 = v11;
	*x3 = v9;
}
static void mw_mirth_elab_abZ_tokenZAt (VAL x1, VAL *x2, uint64_t *x3) {
	incref(x1);
	uint64_t v4 = VU64(VTUP(x1)->cells[3]);
	decref(x1);
	*x3 = v4;
	*x2 = x1;
}
static VAL mw_mirth_elab_abZ_tokenZBang (VAL x1, uint64_t x2) {
	incref(x1);
	VAL v3 = tup_replace(x1, 3, MKU64(x2));
	decref(x1);
	return v3;
}
static void mw_mirth_elab_abZ_typeZAt (VAL x1, VAL *x2, VAL *x3) {
	incref(x1);
	VAL v4 = VVAL(VTUP(x1)->cells[6]);
	incref(v4);
	decref(x1);
	*x3 = v4;
	*x2 = x1;
}
static VAL mw_mirth_elab_abZ_typeZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v3 = tup_replace(x1, 6, x2);
	decref(x1);
	return v3;
}
static void mw_mirth_elab_abZ_ctxZAt (VAL x1, VAL *x2, VAL *x3) {
	incref(x1);
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	decref(x1);
	*x3 = v4;
	*x2 = x1;
}
static void mw_mirth_elab_abZ_homeZAt (VAL x1, VAL *x2, VAL *x3) {
	incref(x1);
	VAL v4 = VVAL(VTUP(x1)->cells[1]);
	incref(v4);
	decref(x1);
	*x3 = v4;
	*x2 = x1;
}
static void mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5, uint64_t *x6, VAL *x7, uint64_t *x8) {
	void* v9 = mfld_mirth_word_Word_ZTildectxZ_type(x2);
	VAL v10;
	VAL v11;
	mw_mirth_mirth_Prop_1_tryZ_forceZBang(v9, x1, &v10, &v11);
	uint64_t x12;
	VAL x13;
	VAL x14;
	VAL x15;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v17;
			VAL v18;
			value_uncons(v16, &v17, &v18);
			VAL v19;
			VAL v20;
			value_uncons(v17, &v19, &v20);
			decref(v19);
			x15 = v18;
			x14 = v20;
			x13 = v11;
			x12 = x2;
		} break;
		case 0LL: { // None
			VAL v21;
			VAL v22;
			VAL v23;
			uint64_t v24;
			mw_mirth_elab_guessZ_initialZ_ctxZ_type(v11, x2, &v21, &v22, &v23, &v24);
			x15 = v23;
			x14 = v22;
			x13 = v21;
			x12 = v24;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v25 = mw_mirth_word_Word_body(x12);
	VAL v26 = mtw_mirth_arrow_Home_HomeWord(x12);
	*x8 = x12;
	*x7 = v26;
	*x6 = v25;
	*x5 = x15;
	*x4 = x14;
	*x3 = x13;
}
static void mw_mirth_elab_finalizzeZ_wordZ_arrow (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	int64_t v6 = mw_mirth_word_Word_inferringZ_typeZAsk(x3);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (((bool)v6)) {
		incref(x2);
		VAL v10;
		VAL v11;
		mw_mirth_arrow_Arrow_ctxZ_type(x2, &v10, &v11);
		VAL v12;
		VAL v13;
		VAL v14;
		mw_mirth_type_ArrowType_rigidifyZ_sigZBang(x1, v10, v11, &v12, &v13, &v14);
		incref(v13);
		incref(v14);
		VAL v15 = MKNIL;
		VAL v16 = mkcons(v15, v13);
		VAL v17 = mkcons(v16, v14);
		VAL v18 = mtw_mirth_mirth_PropLabel_WordType(x3);
		VAL v19;
		VAL v20;
		mw_mirth_mirth_PropLabel_prop(v17, v18, v12, &v19, &v20);
		void* v21 = mfld_mirth_word_Word_ZTildectxZ_type(x3);
		mut_set(v19, v21);
		int64_t v22 = 0LL /* False */;
		void* v23 = mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk(x3);
		mut_set(MKI64(v22), v23);
		VAL v24;
		VAL v25;
		mw_mirth_type_ArrowType_unpack(v14, &v24, &v25);
		VAL v26 = tup_replace(x2, 6, v25);
		VAL v27 = tup_replace(v26, 5, v24);
		VAL v28 = tup_replace(v27, 4, v13);
		x9 = v28;
		x8 = x3;
		x7 = v20;
	} else {
		x9 = x2;
		x8 = x3;
		x7 = x1;
	}
	*x5 = x9;
	*x4 = x7;
}
static void mw_mirth_elab_guessZ_initialZ_ctxZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4, VAL *x5, uint64_t *x6) {
	VAL v7 = mw_mirth_var_Ctx0();
	uint64_t v8 = mw_mirth_type_MetaVar_newZBang();
	VAL v9 = mtw_mirth_type_StackType_STMeta(v8);
	uint64_t v10 = mw_mirth_type_MetaVar_newZBang();
	VAL v11 = mtw_mirth_type_StackType_STMeta(v10);
	VAL v12;
	VAL v13;
	mw_mirth_word_Word_namespaceZ_hard(x2, x1, &v12, &v13);
	VAL x14;
	VAL x15;
	VAL x16;
	uint64_t x17;
	VAL x18;
	switch (get_data_tag(v12)) {
		case 3LL: { // NAMESPACE_TYCON
			VAL v19 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v12);
			VAL v20;
			VAL v21;
			mw_mirth_tycon_Tycon_fullZ_typeZ_fresh(v13, v19, &v20, &v21);
			uint64_t v22 = mw_mirth_word_Word_name(x2);
			int64_t v23 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(v22);
			VAL x24;
			VAL x25;
			VAL x26;
			uint64_t x27;
			VAL x28;
			if (((bool)v23)) {
				VAL v29 = mw_mirth_type_TZMulZPlus(v9, v21);
				x28 = v29;
				x27 = x2;
				x26 = v20;
				x25 = v11;
				x24 = v7;
			} else {
				VAL v30 = mw_mirth_type_TZMulZPlus(v11, v21);
				x28 = v9;
				x27 = x2;
				x26 = v20;
				x25 = v30;
				x24 = v7;
			}
			x18 = x28;
			x17 = x27;
			x16 = x26;
			x15 = x25;
			x14 = x24;
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v31 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(v12);
			uint64_t v32 = mw_mirth_word_Word_name(x2);
			VAL v33 = mw_mirth_name_Name_ZToStr(v32);
			STR* v34;
			STRLIT(v34, "main", 4);
			bool v35 = (str_cmp(VSTR(v33), v34) == 0);
			VAL x36;
			VAL x37;
			VAL x38;
			VAL x39;
			uint64_t x40;
			if (v35) {
				VAL v41 = mw_mirth_type_T0();
				VAL v42 = mw_mirth_type_RESOURCEz_WORLD();
				VAL v43 = mw_mirth_type_TZPlus(v41, v42);
				decref(v9);
				VAL v44 = mw_mirth_type_T0();
				VAL v45 = mw_mirth_type_RESOURCEz_WORLD();
				VAL v46 = mw_mirth_type_TZPlus(v44, v45);
				decref(v11);
				x40 = x2;
				x39 = v13;
				x38 = v46;
				x37 = v43;
				x36 = v7;
			} else {
				x40 = x2;
				x39 = v13;
				x38 = v11;
				x37 = v9;
				x36 = v7;
			}
			x18 = x37;
			x17 = x40;
			x16 = x39;
			x15 = x38;
			x14 = x36;
		} break;
		default: {
			decref(v12);
			x18 = v9;
			x17 = x2;
			x16 = v13;
			x15 = v11;
			x14 = v7;
		} break;
	}
	int64_t v47 = mw_mirth_word_Word_arity(x17);
	int64_t v48 = 0LL;
	bool v49 = (v47 > v48);
	VAL v50 = x14;
	VAL v51 = x15;
	VAL v52 = (x16);
	VAL v53 = x18;
	uint64_t v54 = x17;
	int64_t v55 = v47;
	bool v56 = v49;
	while (v56) {
		VAL v57 = v50;
		VAL v58 = v51;
		VAL v59 = (v52);
		VAL v60 = v53;
		uint64_t v61 = v54;
		int64_t v62 = v55;
		uint64_t v63 = mw_mirth_type_MetaVar_newZBang();
		VAL v64 = mtw_mirth_type_StackType_STMeta(v63);
		uint64_t v65 = mw_mirth_type_MetaVar_newZBang();
		VAL v66 = mtw_mirth_type_StackType_STMeta(v65);
		VAL v67 = mw_mirth_type_TZ_ZTo(v64, v66);
		VAL v68 = mw_mirth_type_ArrowType_ZToType(v67);
		VAL v69 = mw_mirth_type_TZMul(v60, v68);
		int64_t v70 = 1LL;
		int64_t v71 = i64_sub(v62, v70);
		int64_t v72 = 0LL;
		bool v73 = (v71 < v72);
		int64_t x74;
		if (v73) {
			int64_t v75 = 0LL;
			x74 = v75;
			lpush(&lbl_ctx, v57);
			lpush(&lbl_cod, v58);
			push_resource(v59);
			lpush(&lbl_word, MKU64(v61));
			lpush(&lbl_dom, v69);
		} else {
			x74 = v71;
			lpush(&lbl_ctx, v57);
			lpush(&lbl_cod, v58);
			push_resource(v59);
			lpush(&lbl_word, MKU64(v61));
			lpush(&lbl_dom, v69);
		}
		int64_t v76 = 0LL;
		bool v77 = (x74 > v76);
		v56 = v77;
		v55 = x74;
		uint64_t v78 = VU64(lpop(&lbl_word));
		v54 = v78;
		VAL v79 = lpop(&lbl_dom);
		v53 = v79;
		VAL r80 = pop_resource();
		v52 = r80;
		VAL v81 = lpop(&lbl_cod);
		v51 = v81;
		VAL v82 = lpop(&lbl_ctx);
		v50 = v82;
	}
	VAL v83 = mw_mirth_type_TZ_ZTo(v53, v51);
	incref(v50);
	incref(v83);
	VAL v84 = MKNIL;
	VAL v85 = mkcons(v84, v50);
	VAL v86 = mkcons(v85, v83);
	VAL v87 = mtw_mirth_mirth_PropLabel_WordType(v54);
	VAL v88;
	VAL v89;
	mw_mirth_mirth_PropLabel_prop(v86, v87, v52, &v88, &v89);
	void* v90 = mfld_mirth_word_Word_ZTildectxZ_type(v54);
	mut_set(v88, v90);
	int64_t v91 = 1LL /* True */;
	void* v92 = mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk(v54);
	mut_set(MKI64(v91), v92);
	*x6 = v54;
	*x5 = v83;
	*x4 = v50;
	*x3 = v89;
}
static void mw_mirth_elab_abZ_unifyZ_typeZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_elab_abZ_typeZAt(x3, &v6, &v7);
	VAL v8;
	uint64_t v9;
	mw_mirth_elab_abZ_tokenZAt(v6, &v8, &v9);
	VAL v10;
	uint64_t v11;
	VAL v12;
	mw_mirth_type_StackType_unifyZBang(x2, v9, v7, x1, &v10, &v11, &v12);
	mw_mirth_type_ZPlusGamma_rdrop(v11);
	VAL v13 = (mw_mirth_elab_abZ_typeZBang(v8, v12));
	*x5 = v13;
	*x4 = v10;
}
static VAL mw_mirth_elab_abZ_atomZBang (VAL x1, VAL x2) {
	incref(x1);
	uint64_t v3 = VU64(VTUP(x1)->cells[2]);
	decref(x1);
	VAL v4 = (mw_mirth_elab_abZ_tokenZBang(x2, v3));
	incref(x1);
	VAL v5 = VVAL(VTUP(x1)->cells[7]);
	incref(v5);
	decref(x1);
	VAL v6 = (mw_mirth_elab_abZ_typeZBang(v4, v5));
	incref(v6);
	incref(v6);
	VAL v7 = VVAL(VTUP(v6)->cells[7]);
	incref(v7);
	decref(v6);
	VAL v8 = mw_mirth_elab_abZ_optimizzedZ_snocZBang(v7, x1);
	VAL v9 = tup_replace(v6, 7, v8);
	decref(v6);
	return v9;
}
static VAL mw_mirth_elab_abZ_optimizzedZ_snocZBang (VAL x1, VAL x2) {
	incref(x1);
	int64_t v3 = mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk(x1);
	VAL x4;
	VAL x5;
	int64_t x6;
	if (((bool)v3)) {
		VAL v7;
		int64_t v8;
		mw_mirth_elab_atomZ_acceptsZ_argsZAsk(x2, &v7, &v8);
		x6 = v8;
		x5 = v7;
		x4 = x1;
	} else {
		int64_t v9 = 0LL /* False */;
		x6 = v9;
		x5 = x2;
		x4 = x1;
	}
	VAL v10 = x4;
	VAL v11 = x5;
	int64_t v12 = x6;
	while (((bool)v12)) {
		VAL v13 = v10;
		VAL v14 = v11;
		VAL v15;
		VAL v16;
		mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg(v14, v13, &v15, &v16);
		incref(v16);
		int64_t v17 = mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk(v16);
		VAL x18;
		VAL x19;
		int64_t x20;
		if (((bool)v17)) {
			VAL v21;
			int64_t v22;
			mw_mirth_elab_atomZ_acceptsZ_argsZAsk(v15, &v21, &v22);
			x20 = v22;
			x19 = v21;
			x18 = v16;
		} else {
			int64_t v23 = 0LL /* False */;
			x20 = v23;
			x19 = v15;
			x18 = v16;
		}
		v12 = x20;
		v11 = x19;
		v10 = x18;
	}
	VAL v24 = mw_std_list_List_1_reverse(v10);
	VAL v25 = mtw_std_list_List_1_Cons(v11, v24);
	VAL v26 = mw_std_list_List_1_reverse(v25);
	return v26;
}
static void mw_mirth_elab_atomZ_acceptsZ_argsZAsk (VAL x1, VAL *x2, int64_t *x3) {
	incref(x1);
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	decref(x1);
	VAL x5;
	int64_t x6;
	switch (get_data_tag(v4)) {
		case 2LL: { // OpWord
			uint64_t v7 = mtp_mirth_arrow_Op_OpWord(v4);
			incref(x1);
			VAL v8 = VVAL(VTUP(x1)->cells[5]);
			incref(v8);
			decref(x1);
			int64_t v9 = mw_std_list_List_1_len(v8);
			int64_t v10 = mw_mirth_word_Word_arity(v7);
			bool v11 = (v9 < v10);
			x6 = ((int64_t)v11);
			x5 = x1;
		} break;
		case 1LL: { // OpPrim
			int64_t v12 = mtp_mirth_arrow_Op_OpPrim(v4);
			VAL x13;
			int64_t x14;
			switch (v12) {
				case 5LL: { // PRIM_CORE_DIP
					incref(x1);
					VAL v15 = VVAL(VTUP(x1)->cells[5]);
					incref(v15);
					decref(x1);
					int64_t v16 = mw_std_list_List_1_len(v15);
					int64_t v17 = 1LL;
					bool v18 = (v16 < v17);
					x14 = ((int64_t)v18);
					x13 = x1;
				} break;
				case 6LL: { // PRIM_CORE_RDIP
					incref(x1);
					VAL v19 = VVAL(VTUP(x1)->cells[5]);
					incref(v19);
					decref(x1);
					int64_t v20 = mw_std_list_List_1_len(v19);
					int64_t v21 = 1LL;
					bool v22 = (v20 < v21);
					x14 = ((int64_t)v22);
					x13 = x1;
				} break;
				case 7LL: { // PRIM_CORE_IF
					incref(x1);
					VAL v23 = VVAL(VTUP(x1)->cells[5]);
					incref(v23);
					decref(x1);
					int64_t v24 = mw_std_list_List_1_len(v23);
					int64_t v25 = 2LL;
					bool v26 = (v24 < v25);
					x14 = ((int64_t)v26);
					x13 = x1;
				} break;
				case 8LL: { // PRIM_CORE_WHILE
					incref(x1);
					VAL v27 = VVAL(VTUP(x1)->cells[5]);
					incref(v27);
					decref(x1);
					int64_t v28 = mw_std_list_List_1_len(v27);
					int64_t v29 = 2LL;
					bool v30 = (v28 < v29);
					x14 = ((int64_t)v30);
					x13 = x1;
				} break;
				default: {
					int64_t v31 = 0LL /* False */;
					x14 = v31;
					x13 = x1;
				} break;
			}
			x6 = x14;
			x5 = x13;
		} break;
		default: {
			decref(v4);
			int64_t v32 = 0LL /* False */;
			x6 = v32;
			x5 = x1;
		} break;
	}
	*x3 = x6;
	*x2 = x5;
}
static int64_t mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk (VAL x1) {
	VAL v2 = mw_std_list_List_1_last(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // None
			int64_t v4 = 0LL /* False */;
			x3 = v4;
		} break;
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v6 = VVAL(VTUP(v5)->cells[4]);
			incref(v6);
			decref(v5);
			int64_t x7;
			switch (get_data_tag(v6)) {
				case 14LL: { // OpBlockPush
					uint64_t v8 = mtp_mirth_arrow_Op_OpBlockPush(v6);
					int64_t v9 = 1LL /* True */;
					x7 = v9;
				} break;
				default: {
					decref(v6);
					int64_t v10 = 0LL /* False */;
					x7 = v10;
				} break;
			}
			x3 = x7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_std_list_List_1_ZToListZPlus(x2);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 0LL: { // None
			VAL v8 = MKI64(0LL /* Nil */);
			x7 = v8;
			x6 = x1;
		} break;
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v5);
			VAL v10;
			VAL v11;
			mw_std_list_ListZPlus_1_unsnoc(v9, &v10, &v11);
			incref(v11);
			VAL v12 = VVAL(VTUP(v11)->cells[4]);
			incref(v12);
			decref(v11);
			VAL x13;
			VAL x14;
			switch (get_data_tag(v12)) {
				case 14LL: { // OpBlockPush
					uint64_t v15 = mtp_mirth_arrow_Op_OpBlockPush(v12);
					VAL v16 = VVAL(VTUP(v11)->cells[6]);
					incref(v16);
					decref(v11);
					VAL v17 = tup_replace(x1, 6, v16);
					incref(v17);
					VAL v18 = VVAL(VTUP(v17)->cells[5]);
					incref(v18);
					decref(v17);
					VAL v19 = mtw_std_list_List_1_Cons(MKU64(v15), v18);
					VAL v20 = tup_replace(v17, 5, v19);
					x14 = v10;
					x13 = v20;
				} break;
				default: {
					decref(v12);
					VAL v21 = mw_std_list_List_1_reverse(v10);
					VAL v22 = mtw_std_list_List_1_Cons(v11, v21);
					VAL v23 = mw_std_list_List_1_reverse(v22);
					x14 = v23;
					x13 = x1;
				} break;
			}
			x7 = x14;
			x6 = x13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_elab_abZ_opZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_elab_abZ_ctxZAt(x3, &v6, &v7);
	VAL v8;
	uint64_t v9;
	mw_mirth_elab_abZ_tokenZAt(v6, &v8, &v9);
	VAL v10;
	VAL v11;
	mw_mirth_elab_abZ_homeZAt(v8, &v10, &v11);
	incref(x1);
	VAL v12;
	VAL v13;
	VAL v14;
	mw_mirth_elab_elabZ_opZ_freshZ_sigZBang(x2, x1, &v12, &v13, &v14);
	VAL v15;
	VAL v16;
	VAL v17;
	VAL v18;
	mw_mirth_elab_abZ_expandZ_opsigZBang(v14, v12, v10, &v15, &v16, &v17, &v18);
	VAL v19 = MKI64(0LL /* Nil */);
	VAL v20 = mtw_mirth_arrow_Atom_Atom(v11, v9, v7, x1, v19, v15, v16, v13);
	VAL v21 = (mw_mirth_elab_abZ_atomZBang(v20, v18));
	*x5 = v21;
	*x4 = v17;
}
static void mw_mirth_elab_abZ_expandZ_opsigZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6, VAL *x7) {
	VAL x8;
	VAL x9;
	VAL x10;
	VAL x11;
	switch (get_data_tag(x1)) {
		case 0LL: { // OPSIG_ID
			VAL v12;
			VAL v13;
			mw_mirth_elab_abZ_typeZAt(x3, &v12, &v13);
			incref(v13);
			x11 = v12;
			x10 = x2;
			x9 = v13;
			x8 = v13;
		} break;
		case 1LL: { // OPSIG_PUSH
			VAL v14 = mtp_mirth_elab_OpSig_OPSIGz_PUSH(x1);
			VAL v15;
			VAL v16;
			mw_mirth_elab_abZ_typeZAt(x3, &v15, &v16);
			incref(v16);
			VAL v17 = mtw_mirth_type_StackType_STCons(v16, v14);
			x11 = v15;
			x10 = x2;
			x9 = v17;
			x8 = v16;
		} break;
		case 2LL: { // OPSIG_APPLY
			VAL v18 = mtp_mirth_elab_OpSig_OPSIGz_APPLY(x1);
			VAL v19;
			VAL v20;
			mw_mirth_elab_abZ_typeZAt(x3, &v19, &v20);
			VAL v21;
			VAL v22;
			mw_mirth_type_ArrowType_unpack(v18, &v21, &v22);
			VAL v23;
			uint64_t v24;
			mw_mirth_elab_abZ_tokenZAt(v19, &v23, &v24);
			VAL v25;
			VAL v26;
			uint64_t v27;
			mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang(x2, v20, v21, v24, &v25, &v26, &v27);
			x11 = v23;
			x10 = v25;
			x9 = v22;
			x8 = v26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x11;
	*x6 = x10;
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_elab_abZ_intZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpInt(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_f64ZBang (double x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpF64(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_strZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpStr(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_bufferZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpBuffer(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_variableZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpVariable(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_fieldZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpField(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_varZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpVar(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_tagZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpTag(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_primZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	void* v6 = mfld_mirth_prim_Prim_ZTildetype(((uint64_t)x1));
	bool v7 = mut_is_set(v6);
	VAL x8;
	VAL x9;
	if (v7) {
		VAL v10 = mtw_mirth_arrow_Op_OpPrim(x1);
		VAL v11;
		VAL v12;
		mw_mirth_elab_abZ_opZBang(v10, x2, x3, &v11, &v12);
		x9 = v12;
		x8 = v11;
	} else {
		VAL v13;
		uint64_t v14;
		mw_mirth_elab_abZ_tokenZAt(x3, &v13, &v14);
		STR* v15;
		STRLIT(v15, "prim does not have type", 23);
		push_i64(x1);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v14, MKSTR(v15), x2);
		x9 = v13;
		VAL r16 = pop_resource();
		x8 = r16;
	}
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_elab_abZ_wordZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpWord(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_externalZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpExternal(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_coerceZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpCoerce(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_labelZ_pushZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpLabelPush(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_labelZ_popZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpLabelPop(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_labelZ_pushZ_rZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpLabelPushR(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_abZ_labelZ_popZ_rZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_mirth_arrow_Op_OpLabelPopR(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_opZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_elab_elabZ_opZ_freshZ_sigZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6 = mw_mirth_type_Subst_nil();
	VAL x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			VAL v10 = MKI64(0LL /* OPSIG_ID */);
			x9 = v10;
			x8 = v6;
			x7 = x1;
		} break;
		case 7LL: { // OpInt
			int64_t v11 = mtp_mirth_arrow_Op_OpInt(x2);
			VAL v12 = mtw_mirth_type_Value_VALUEz_INT(v11);
			VAL v13 = mtw_mirth_type_Type_TValue(v12);
			VAL v14 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v13);
			x9 = v14;
			x8 = v6;
			x7 = x1;
		} break;
		case 8LL: { // OpF64
			double v15 = mtp_mirth_arrow_Op_OpF64(x2);
			VAL v16 = mtw_mirth_type_Value_VALUEz_F64(v15);
			VAL v17 = mtw_mirth_type_Type_TValue(v16);
			VAL v18 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v17);
			x9 = v18;
			x8 = v6;
			x7 = x1;
		} break;
		case 9LL: { // OpStr
			VAL v19 = mtp_mirth_arrow_Op_OpStr(x2);
			VAL v20 = mtw_mirth_type_Value_VALUEz_STR(v19);
			VAL v21 = mtw_mirth_type_Type_TValue(v20);
			VAL v22 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v21);
			x9 = v22;
			x8 = v6;
			x7 = x1;
		} break;
		case 4LL: { // OpBuffer
			uint64_t v23 = mtp_mirth_arrow_Op_OpBuffer(x2);
			VAL v24 = mw_mirth_type_TYPEz_PTR();
			VAL v25 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v24);
			x9 = v25;
			x8 = v6;
			x7 = x1;
		} break;
		case 5LL: { // OpVariable
			uint64_t v26 = mtp_mirth_arrow_Op_OpVariable(x2);
			VAL v27;
			VAL v28;
			mw_mirth_variable_Variable_type(x1, v26, &v27, &v28);
			VAL v29 = mtw_mirth_type_Type_TMut(v28);
			VAL v30 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v29);
			x9 = v30;
			x8 = v6;
			x7 = v27;
		} break;
		case 10LL: { // OpTag
			uint64_t v31 = mtp_mirth_arrow_Op_OpTag(x2);
			VAL v32;
			VAL v33;
			mw_mirth_data_Tag_type(x1, v31, &v32, &v33);
			VAL v34;
			VAL v35;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v33, &v34, &v35);
			VAL v36 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v35);
			x9 = v36;
			x8 = v34;
			x7 = v32;
		} break;
		case 2LL: { // OpWord
			uint64_t v37 = mtp_mirth_arrow_Op_OpWord(x2);
			int64_t v38 = mw_mirth_word_Word_inferringZ_typeZAsk(v37);
			VAL x39;
			VAL x40;
			VAL x41;
			if (((bool)v38)) {
				VAL v42;
				VAL v43;
				mw_mirth_word_Word_type(v37, x1, &v42, &v43);
				x41 = v43;
				x40 = v42;
				x39 = v6;
			} else {
				VAL v44;
				VAL v45;
				mw_mirth_word_Word_type(v37, x1, &v44, &v45);
				VAL v46;
				VAL v47;
				mw_mirth_type_ArrowType_freshenZ_sig(v6, v44, &v46, &v47);
				x41 = v45;
				x40 = v47;
				x39 = v46;
			}
			VAL v48 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(x40);
			x9 = v48;
			x8 = x39;
			x7 = x41;
		} break;
		case 1LL: { // OpPrim
			int64_t v49 = mtp_mirth_arrow_Op_OpPrim(x2);
			VAL v50 = mw_mirth_prim_Prim_type(v49);
			VAL v51;
			VAL v52;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v50, &v51, &v52);
			VAL v53 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v52);
			x9 = v53;
			x8 = v51;
			x7 = x1;
		} break;
		case 3LL: { // OpExternal
			uint64_t v54 = mtp_mirth_arrow_Op_OpExternal(x2);
			VAL v55;
			VAL v56;
			mw_mirth_external_External_type(x1, v54, &v55, &v56);
			VAL v57;
			VAL v58;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v56, &v57, &v58);
			VAL v59 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v58);
			x9 = v59;
			x8 = v57;
			x7 = v55;
		} break;
		case 6LL: { // OpField
			uint64_t v60 = mtp_mirth_arrow_Op_OpField(x2);
			VAL v61;
			VAL v62;
			mw_mirth_table_Field_type(x1, v60, &v61, &v62);
			VAL v63;
			VAL v64;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v62, &v63, &v64);
			VAL v65 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v64);
			x9 = v65;
			x8 = v63;
			x7 = v61;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v66 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			VAL v67 = mw_mirth_elab_elabZ_blockZ_sigZBang(v66);
			x9 = v67;
			x8 = v6;
			x7 = x1;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v68 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			VAL v69 = mw_mirth_arrow_Block_type(v68);
			VAL v70 = mw_mirth_type_ArrowType_semifreshenZ_sig(v69);
			VAL v71 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v70);
			x9 = v71;
			x8 = v6;
			x7 = x1;
		} break;
		case 13LL: { // OpVar
			uint64_t v72 = mtp_mirth_arrow_Op_OpVar(x2);
			VAL v73 = mw_mirth_elab_elabZ_varZ_sigZBang(v72);
			x9 = v73;
			x8 = v6;
			x7 = x1;
		} break;
		case 11LL: { // OpMatch
			VAL v74 = mtp_mirth_arrow_Op_OpMatch(x2);
			VAL v75 = mw_mirth_elab_elabZ_matchZ_sigZBang(v74);
			x9 = v75;
			x8 = v6;
			x7 = x1;
		} break;
		case 12LL: { // OpLambda
			VAL v76 = mtp_mirth_arrow_Op_OpLambda(x2);
			VAL v77 = mw_mirth_elab_elabZ_lambdaZ_sigZBang(v76);
			x9 = v77;
			x8 = v6;
			x7 = x1;
		} break;
		case 16LL: { // OpCoerce
			int64_t v78 = mtp_mirth_arrow_Op_OpCoerce(x2);
			VAL v79 = mw_mirth_elab_elabZ_coerceZ_sigZBang(v78);
			x9 = v79;
			x8 = v6;
			x7 = x1;
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v80 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			VAL v81 = mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang(v80);
			x9 = v81;
			x8 = v6;
			x7 = x1;
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v82 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			VAL v83 = mw_mirth_elab_elabZ_labelZ_popZ_sigZBang(v82);
			x9 = v83;
			x8 = v6;
			x7 = x1;
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v84 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			VAL v85 = mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang(v84);
			x9 = v85;
			x8 = v6;
			x7 = x1;
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v86 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			VAL v87 = mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang(v86);
			x9 = v87;
			x8 = v6;
			x7 = x1;
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v88 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			VAL v89;
			VAL v90;
			mw_mirth_elab_dataZ_getZ_tagZ_type(x1, v88, &v89, &v90);
			VAL v91;
			VAL v92;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v90, &v91, &v92);
			VAL v93 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v92);
			x9 = v93;
			x8 = v91;
			x7 = v89;
		} break;
		case 22LL: { // OpDataGetLabel
			VAL v94 = mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			VAL v95;
			VAL v96;
			mw_mirth_elab_dataZ_getZ_labelZ_type(x1, v94, &v95, &v96);
			VAL v97;
			VAL v98;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v96, &v97, &v98);
			VAL v99 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v98);
			x9 = v99;
			x8 = v97;
			x7 = v95;
		} break;
		case 23LL: { // OpDataSetLabel
			VAL v100 = mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			VAL v101;
			VAL v102;
			mw_mirth_elab_dataZ_setZ_labelZ_type(x1, v100, &v101, &v102);
			VAL v103;
			VAL v104;
			mw_mirth_type_ArrowType_freshenZ_sig(v6, v102, &v103, &v104);
			VAL v105 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v104);
			x9 = v105;
			x8 = v103;
			x7 = v101;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x9;
	*x4 = x8;
	*x3 = x7;
}
static void mw_mirth_elab_dataZ_getZ_tagZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_data_Data_fullZ_type(x1, x2, &v5, &v6);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 0LL: { // Left
			VAL v9 = mtp_std_either_Either_2_Left(v6);
			VAL v10 = mw_mirth_type_T1(v9);
			VAL v11 = mw_mirth_type_TYPEz_INT();
			VAL v12 = mw_mirth_type_T1(v11);
			VAL v13 = mw_mirth_type_TZ_ZTo(v10, v12);
			x8 = v13;
			x7 = v5;
		} break;
		case 1LL: { // Right
			VAL v14 = mtp_std_either_Either_2_Right(v6);
			VAL v15 = mw_mirth_type_T0();
			incref(v14);
			VAL v16 = mw_mirth_type_TZPlus(v15, v14);
			VAL v17 = mw_mirth_type_TYPEz_INT();
			VAL v18 = mw_mirth_type_T1(v17);
			VAL v19 = mw_mirth_type_TZPlus(v18, v14);
			VAL v20 = mw_mirth_type_TZ_ZTo(v16, v19);
			x8 = v20;
			x7 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static VAL mw_mirth_elab_elabZ_coerceZ_sigZBang (int64_t x1) {
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_StackType_STMeta(v2);
	incref(v3);
	uint64_t v4 = mw_mirth_type_MetaVar_newZBang();
	VAL v5 = mtw_mirth_type_Type_TMeta(v4);
	VAL v6 = mw_mirth_type_TZMul(v3, v5);
	uint64_t v7 = mw_mirth_type_MetaVar_newZBang();
	VAL v8 = mtw_mirth_type_Type_TMeta(v7);
	VAL v9 = mw_mirth_type_TZMul(v3, v8);
	VAL v10 = mw_mirth_type_TZ_ZTo(v6, v9);
	VAL v11 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v10);
	return v11;
}
static VAL mw_mirth_elab_elabZ_blockZ_sigZBang (uint64_t x1) {
	VAL v2 = mtw_mirth_type_Value_VALUEz_BLOCK(x1);
	VAL v3 = mtw_mirth_type_Type_TValue(v2);
	VAL v4 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v3);
	return v4;
}
static VAL mw_mirth_elab_elabZ_matchZ_sigZBang (VAL x1) {
	incref(x1);
	VAL v2 = VVAL(VTUP(x1)->cells[5]);
	incref(v2);
	decref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[6]);
	incref(v3);
	decref(x1);
	VAL v4 = mw_mirth_type_TZ_ZTo(v2, v3);
	VAL v5 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v4);
	return v5;
}
static VAL mw_mirth_elab_elabZ_lambdaZ_sigZBang (VAL x1) {
	incref(x1);
	VAL v2 = VVAL(VTUP(x1)->cells[3]);
	incref(v2);
	decref(x1);
	VAL v3 = mw_mirth_arrow_Lambda_cod(x1);
	VAL v4 = mw_mirth_type_TZ_ZTo(v2, v3);
	VAL v5 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v4);
	return v5;
}
static VAL mw_mirth_elab_elabZ_varZ_sigZBang (uint64_t x1) {
	VAL v2 = mw_mirth_var_Var_autoZ_runZAsk(x1);
	VAL x3;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v5 = mw_mirth_type_ArrowType_semifreshenZ_sig(v4);
			VAL v6 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v5);
			x3 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = mw_mirth_var_Var_type(x1);
			VAL v8 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v7);
			x3 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang (uint64_t x1) {
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_StackType_STMeta(v2);
	uint64_t v4 = mw_mirth_type_MetaVar_newZBang();
	VAL v5 = mtw_mirth_type_Type_TMeta(v4);
	incref(v3);
	incref(v5);
	VAL v6 = mtw_mirth_type_StackType_STConsLabel(v3, v5, x1);
	VAL v7 = mtw_mirth_type_StackType_STCons(v3, v5);
	VAL v8 = mw_mirth_type_TZ_ZTo(v7, v6);
	VAL v9 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v8);
	return v9;
}
static VAL mw_mirth_elab_elabZ_labelZ_popZ_sigZBang (uint64_t x1) {
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_StackType_STMeta(v2);
	uint64_t v4 = mw_mirth_type_MetaVar_newZBang();
	VAL v5 = mtw_mirth_type_Type_TMeta(v4);
	incref(v3);
	incref(v5);
	VAL v6 = mtw_mirth_type_StackType_STConsLabel(v3, v5, x1);
	VAL v7 = mtw_mirth_type_StackType_STCons(v3, v5);
	VAL v8 = mw_mirth_type_TZ_ZTo(v6, v7);
	VAL v9 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v8);
	return v9;
}
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang (uint64_t x1) {
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_StackType_STMeta(v2);
	uint64_t v4 = mw_mirth_type_MetaVar_newZBang();
	VAL v5 = mtw_mirth_type_Type_TMeta(v4);
	incref(v3);
	incref(v5);
	VAL v6 = mtw_mirth_type_StackType_STWithLabel(v3, v5, x1);
	VAL v7 = mtw_mirth_type_StackType_STWith(v3, v5);
	VAL v8 = mw_mirth_type_TZ_ZTo(v7, v6);
	VAL v9 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v8);
	return v9;
}
static VAL mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang (uint64_t x1) {
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_StackType_STMeta(v2);
	uint64_t v4 = mw_mirth_type_MetaVar_newZBang();
	VAL v5 = mtw_mirth_type_Type_TMeta(v4);
	incref(v3);
	incref(v5);
	VAL v6 = mtw_mirth_type_StackType_STWithLabel(v3, v5, x1);
	VAL v7 = mtw_mirth_type_StackType_STWith(v3, v5);
	VAL v8 = mw_mirth_type_TZ_ZTo(v6, v7);
	VAL v9 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v8);
	return v9;
}
static void mw_mirth_elab_elabZ_arrowZ_homZBang (VAL x1, VAL x2, VAL x3, VAL x4, uint64_t x5, VAL x6, VAL *x7, VAL *x8) {
	VAL v9;
	VAL v10;
	mw_mirth_elab_elabZ_arrowZ_fwdZBang(x1, x2, x3, x5, x6, &v9, &v10);
	incref(v10);
	uint64_t v11 = VU64(VTUP(v10)->cells[3]);
	decref(v10);
	incref(v10);
	VAL v12 = VVAL(VTUP(v10)->cells[6]);
	incref(v12);
	decref(v10);
	VAL v13;
	uint64_t v14;
	VAL v15;
	mw_mirth_type_StackType_unifyZBang(v9, v11, v12, x4, &v13, &v14, &v15);
	mw_mirth_type_ZPlusGamma_rdrop(v14);
	decref(v15);
	*x8 = v10;
	*x7 = v13;
}
static void mw_mirth_elab_elabZ_arrowZ_fwdZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5, VAL *x6, VAL *x7) {
	incref(x3);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mtw_mirth_arrow_Arrow_Arrow(x5, x4, x4, x2, x3, x3, v8);
	VAL v10;
	VAL v11;
	mw_mirth_elab_elabZ_atomsZBang(x1, v9, &v10, &v11);
	*x7 = v11;
	*x6 = v10;
}
static void mw_mirth_elab_elabZ_atomsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	int64_t v7 = mw_mirth_token_Token_runZ_endZAsk(v6);
	bool v8 = !((bool)v7);
	VAL v9 = (x1);
	VAL v10 = (v5);
	bool v11 = v8;
	while (v11) {
		VAL v12 = (v9);
		VAL v13 = (v10);
		VAL v14;
		VAL v15;
		mw_mirth_elab_elabZ_atomZBang(v12, v13, &v14, &v15);
		VAL v16;
		uint64_t v17;
		mw_mirth_elab_abZ_tokenZAt(v15, &v16, &v17);
		uint64_t v18 = mw_mirth_token_Token_next(v17);
		VAL v19 = (mw_mirth_elab_abZ_tokenZBang(v16, v18));
		VAL v20;
		uint64_t v21;
		mw_mirth_elab_abZ_tokenZAt(v19, &v20, &v21);
		int64_t v22 = mw_mirth_token_Token_runZ_endZAsk(v21);
		bool v23 = !((bool)v22);
		v11 = v23;
		v10 = v20;
		v9 = v14;
	}
	*x4 = v10;
	*x3 = v9;
}
static void mw_mirth_elab_elabZ_atomZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	VAL v7 = mw_mirth_token_Token_value(v6);
	VAL x8;
	VAL x9;
	switch (get_data_tag(v7)) {
		case 17LL: { // TokenName
			uint64_t v10 = mtp_mirth_token_TokenValue_TokenName(v7);
			VAL v11;
			VAL v12;
			mw_mirth_elab_elabZ_atomZ_nameZBang(v10, x1, v5, &v11, &v12);
			x9 = v12;
			x8 = v11;
		} break;
		case 18LL: { // TokenDName
			VAL v13 = mtp_mirth_token_TokenValue_TokenDName(v7);
			VAL v14;
			VAL v15;
			mw_mirth_elab_elabZ_atomZ_dnameZBang(v13, x1, v5, &v14, &v15);
			x9 = v15;
			x8 = v14;
		} break;
		case 14LL: { // TokenInt
			int64_t v16 = mtp_mirth_token_TokenValue_TokenInt(v7);
			VAL v17;
			VAL v18;
			mw_mirth_elab_abZ_intZBang(v16, x1, v5, &v17, &v18);
			x9 = v18;
			x8 = v17;
		} break;
		case 16LL: { // TokenStr
			VAL v19 = mtp_mirth_token_TokenValue_TokenStr(v7);
			VAL v20;
			VAL v21;
			mw_mirth_elab_abZ_strZBang(v19, x1, v5, &v20, &v21);
			x9 = v21;
			x8 = v20;
		} break;
		case 15LL: { // TokenF64
			double v22 = mtp_mirth_token_TokenValue_TokenF64(v7);
			VAL v23;
			VAL v24;
			mw_mirth_elab_abZ_f64ZBang(v22, x1, v5, &v23, &v24);
			x9 = v24;
			x8 = v23;
		} break;
		case 8LL: { // TokenLSquare
			uint64_t v25 = mtp_mirth_token_TokenValue_TokenLSquare(v7);
			VAL v26;
			VAL v27;
			mw_mirth_elab_elabZ_atomZ_blockZBang(x1, v5, &v26, &v27);
			x9 = v27;
			x8 = v26;
		} break;
		case 10LL: { // TokenLCurly
			uint64_t v28 = mtp_mirth_token_TokenValue_TokenLCurly(v7);
			VAL v29;
			VAL v30;
			mw_mirth_elab_elabZ_atomZ_assertZBang(x1, v5, &v29, &v30);
			x9 = v30;
			x8 = v29;
		} break;
		case 20LL: { // TokenLabelPush
			uint64_t v31 = mtp_mirth_token_TokenValue_TokenLabelPush(v7);
			VAL v32;
			uint64_t v33;
			mw_mirth_elab_abZ_tokenZAt(v5, &v32, &v33);
			VAL v34 = (mw_mirth_token_Token_argsZ_0(v33, x1));
			VAL v35;
			VAL v36;
			mw_mirth_elab_abZ_labelZ_pushZBang(v31, v34, v32, &v35, &v36);
			x9 = v36;
			x8 = v35;
		} break;
		case 19LL: { // TokenLabelPop
			uint64_t v37 = mtp_mirth_token_TokenValue_TokenLabelPop(v7);
			VAL v38;
			uint64_t v39;
			mw_mirth_elab_abZ_tokenZAt(v5, &v38, &v39);
			VAL v40 = (mw_mirth_token_Token_argsZ_0(v39, x1));
			VAL v41;
			VAL v42;
			mw_mirth_elab_abZ_labelZ_popZBang(v37, v40, v38, &v41, &v42);
			x9 = v42;
			x8 = v41;
		} break;
		case 22LL: { // TokenLabelPushR
			uint64_t v43 = mtp_mirth_token_TokenValue_TokenLabelPushR(v7);
			VAL v44;
			uint64_t v45;
			mw_mirth_elab_abZ_tokenZAt(v5, &v44, &v45);
			VAL v46 = (mw_mirth_token_Token_argsZ_0(v45, x1));
			VAL v47;
			VAL v48;
			mw_mirth_elab_abZ_labelZ_pushZ_rZBang(v43, v46, v44, &v47, &v48);
			x9 = v48;
			x8 = v47;
		} break;
		case 21LL: { // TokenLabelPopR
			uint64_t v49 = mtp_mirth_token_TokenValue_TokenLabelPopR(v7);
			VAL v50;
			uint64_t v51;
			mw_mirth_elab_abZ_tokenZAt(v5, &v50, &v51);
			VAL v52 = (mw_mirth_token_Token_argsZ_0(v51, x1));
			VAL v53;
			VAL v54;
			mw_mirth_elab_abZ_labelZ_popZ_rZBang(v49, v52, v50, &v53, &v54);
			x9 = v54;
			x8 = v53;
		} break;
		case 23LL: { // TokenLabelGet
			uint64_t v55 = mtp_mirth_token_TokenValue_TokenLabelGet(v7);
			VAL v56;
			VAL v57;
			mw_mirth_elab_elabZ_labelZ_getZBang(v55, x1, v5, &v56, &v57);
			x9 = v57;
			x8 = v56;
		} break;
		case 24LL: { // TokenLabelSet
			uint64_t v58 = mtp_mirth_token_TokenValue_TokenLabelSet(v7);
			VAL v59;
			VAL v60;
			mw_mirth_elab_elabZ_labelZ_setZBang(v58, x1, v5, &v59, &v60);
			x9 = v60;
			x8 = v59;
		} break;
		default: {
			VAL v61;
			uint64_t v62;
			mw_mirth_elab_abZ_tokenZAt(v5, &v61, &v62);
			STR* v63;
			STRLIT(v63, "Unexpected token in elab-atom!", 30);
			push_value(v7);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v62, MKSTR(v63), x1);
			x9 = v61;
			VAL r64 = pop_resource();
			x8 = r64;
		} break;
	}
	*x4 = x9;
	*x3 = x8;
}
static void mw_mirth_elab_elabZ_labelZ_getZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	int64_t v6 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(x1);
	VAL x7;
	VAL x8;
	if (((bool)v6)) {
		VAL v9;
		VAL v10;
		mw_mirth_elab_abZ_labelZ_popZ_rZBang(x1, x2, x3, &v9, &v10);
		VAL v11;
		uint64_t v12;
		mw_mirth_elab_abZ_tokenZAt(v10, &v11, &v12);
		uint64_t v13;
		VAL v14;
		mw_mirth_token_Token_argsZ_1(v12, v9, &v13, &v14);
		VAL v15 = (mw_mirth_elab_abZ_tokenZBang(v11, v13));
		VAL v16;
		VAL v17;
		mw_mirth_elab_elabZ_atomsZBang(v14, v15, &v16, &v17);
		VAL v18 = (mw_mirth_elab_abZ_tokenZBang(v17, v12));
		VAL v19;
		VAL v20;
		mw_mirth_elab_abZ_labelZ_pushZ_rZBang(x1, v16, v18, &v19, &v20);
		x8 = v20;
		x7 = v19;
	} else {
		VAL v21;
		VAL v22;
		mw_mirth_elab_abZ_labelZ_popZBang(x1, x2, x3, &v21, &v22);
		VAL v23;
		uint64_t v24;
		mw_mirth_elab_abZ_tokenZAt(v22, &v23, &v24);
		int64_t v25 = mw_mirth_token_Token_numZ_args(v24);
		int64_t v26 = 0LL;
		bool v27 = (v25 == v26);
		uint64_t x28;
		VAL x29;
		VAL x30;
		if (v27) {
			int64_t v31 = 1LL /* PRIM_CORE_DUP */;
			VAL v32;
			VAL v33;
			mw_mirth_elab_abZ_primZBang(v31, v21, v23, &v32, &v33);
			x30 = v33;
			x29 = v32;
			x28 = x1;
		} else {
			VAL v34;
			uint64_t v35;
			mw_mirth_elab_abZ_tokenZAt(v23, &v34, &v35);
			uint64_t v36;
			VAL v37;
			mw_mirth_token_Token_argsZ_1(v35, v21, &v36, &v37);
			VAL v38 = (mw_mirth_elab_abZ_tokenZBang(v34, v36));
			VAL v39;
			VAL v40;
			mw_mirth_elab_elabZ_atomsZBang(v37, v38, &v39, &v40);
			VAL v41 = (mw_mirth_elab_abZ_tokenZBang(v40, v35));
			x30 = v41;
			x29 = v39;
			x28 = x1;
		}
		VAL v42;
		VAL v43;
		mw_mirth_elab_abZ_labelZ_pushZBang(x28, x29, x30, &v42, &v43);
		x8 = v43;
		x7 = v42;
	}
	*x5 = x8;
	*x4 = x7;
}
static void mw_mirth_elab_elabZ_labelZ_setZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	uint64_t v7;
	mw_mirth_elab_abZ_tokenZAt(x3, &v6, &v7);
	VAL v8 = (mw_mirth_token_Token_argsZ_0(v7, x2));
	VAL v9;
	VAL v10;
	mw_mirth_elab_abZ_labelZ_popZBang(x1, v8, v6, &v9, &v10);
	int64_t v11 = 2LL /* PRIM_CORE_DROP */;
	VAL v12;
	VAL v13;
	mw_mirth_elab_abZ_primZBang(v11, v9, v10, &v12, &v13);
	VAL v14;
	VAL v15;
	mw_mirth_elab_abZ_labelZ_pushZBang(x1, v12, v13, &v14, &v15);
	*x5 = v15;
	*x4 = v14;
}
static void mw_mirth_elab_elabZ_atomZ_blockZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	uint64_t v7;
	VAL v8;
	mw_mirth_token_Token_argsZ_1(v6, x1, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_elab_elabZ_blockZ_atZBang(v7, v8, v5, &v9, &v10);
	*x4 = v10;
	*x3 = v9;
}
static void mw_mirth_elab_elabZ_blockZ_atZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_elab_abZ_ctxZAt(x3, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_elab_abZ_homeZAt(v6, &v8, &v9);
	FNPTR v10 = &mb_mirth_elab_elabZ_blockZ_atZBang_1;
	VAL v11;
	uint64_t v12;
	mw_mirth_arrow_Block_newZ_deferredZBang_1(x2, v7, x1, v9, MKFNPTR(v10), &v11, &v12);
	VAL v13 = mtw_mirth_arrow_Op_OpBlockPush(v12);
	VAL v14;
	VAL v15;
	mw_mirth_elab_abZ_opZBang(v13, v11, v8, &v14, &v15);
	*x5 = v15;
	*x4 = v14;
}
static void mw_mirth_elab_elabZ_argsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	VAL v7 = mw_mirth_token_Token_args(v6);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v7, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v15;
			VAL v16;
			mw_mirth_elab_elabZ_blockZ_atZBang(VU64(v14), x1, v5, &v15, &v16);
			int64_t v17 = 1LL /* True */;
			x13 = v17;
			x12 = v9;
			x11 = v16;
			x10 = v15;
		} break;
		case 0LL: { // None
			int64_t v18 = 0LL /* False */;
			x13 = v18;
			x12 = v9;
			x11 = v5;
			x10 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v19 = (x10);
	VAL v20 = (x11);
	VAL v21 = x12;
	int64_t v22 = x13;
	while (((bool)v22)) {
		VAL v23 = (v19);
		VAL v24 = (v20);
		VAL v25 = v21;
		VAL v26;
		VAL v27;
		mw_std_list_List_1_uncons(v25, &v26, &v27);
		VAL x28;
		VAL x29;
		VAL x30;
		int64_t x31;
		switch (get_data_tag(v26)) {
			case 1LL: { // Some
				VAL v32 = mtp_std_maybe_Maybe_1_Some(v26);
				VAL v33;
				VAL v34;
				mw_mirth_elab_elabZ_blockZ_atZBang(VU64(v32), v23, v24, &v33, &v34);
				int64_t v35 = 1LL /* True */;
				x31 = v35;
				x30 = v27;
				x29 = v34;
				x28 = v33;
			} break;
			case 0LL: { // None
				int64_t v36 = 0LL /* False */;
				x31 = v36;
				x30 = v27;
				x29 = v24;
				x28 = v23;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v22 = x31;
		v21 = x30;
		v20 = x29;
		v19 = x28;
	}
	decref(v21);
	*x4 = v20;
	*x3 = v19;
}
static void mw_mirth_elab_elabZ_noZ_argsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	VAL v7 = (mw_mirth_token_Token_argsZ_0(v6, x1));
	*x4 = v5;
	*x3 = v7;
}
static int64_t mw_mirth_elab_arityZ_compatibleZAsk (int64_t x1, int64_t x2) {
	int64_t v3 = -1LL;
	bool v4 = (x2 == v3);
	bool v5 = (x1 == x2);
	bool v6 = (v5 || v4);
	return ((int64_t)v6);
}
static void mw_mirth_elab_elabZ_atomZ_nameZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_elab_abZ_ctxZAt(x3, &v6, &v7);
	VAL v8 = mw_mirth_var_Ctx_lookup(x1, v7);
	VAL x9;
	VAL x10;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v12;
			VAL v13;
			mw_mirth_elab_elabZ_argsZBang(x2, v6, &v12, &v13);
			VAL v14;
			VAL v15;
			mw_mirth_elab_abZ_varZBang(VU64(v11), v12, v13, &v14, &v15);
			x10 = v15;
			x9 = v14;
		} break;
		case 0LL: { // None
			VAL v16 = mtw_std_either_Either_2_Left(MKU64(x1));
			VAL v17;
			VAL v18;
			mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang(x2, v6, v16, &v17, &v18);
			x10 = v18;
			x9 = v17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x10;
	*x4 = x9;
}
static void mw_mirth_elab_elabZ_atomZ_dnameZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mtw_std_either_Either_2_Right(x1);
	VAL v7;
	VAL v8;
	mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang(x2, x3, v6, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static int64_t mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk (uint64_t x1) {
	VAL v2 = mw_mirth_token_Token_value(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 17LL: { // TokenName
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenName(v2);
			int64_t v5 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(v4);
			x3 = v5;
		} break;
		case 18LL: { // TokenDName
			VAL v6 = mtp_mirth_token_TokenValue_TokenDName(v2);
			int64_t v7 = mw_mirth_name_DName_isZ_relativeZAsk(v6);
			x3 = v7;
		} break;
		default: {
			decref(v2);
			int64_t v8 = 0LL /* False */;
			x3 = v8;
		} break;
	}
	return x3;
}
static void mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_elab_abZ_typeZAt(x2, &v6, &v7);
	int64_t v8 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v7);
	bool v9 = !((bool)v8);
	VAL v10;
	uint64_t v11;
	mw_mirth_elab_abZ_tokenZAt(v6, &v10, &v11);
	STR* v12;
	STRLIT(v12, "word", 4);
	int64_t v13 = 0LL /* False */;
	VAL v14;
	VAL v15;
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v12), v11, x3, v13, ((int64_t)v9), x1, &v14, &v15);
	VAL v16 = VVAL(VTUP(v15)->cells[4]);
	incref(v16);
	VAL v17 = MKI64(0LL /* Nil */);
	VAL v18 = MKI64(0LL /* Nil */);
	VAL v19;
	VAL v20;
	mw_std_list_List_1_uncons(v16, &v19, &v20);
	VAL x21;
	VAL x22;
	VAL x23;
	VAL x24;
	VAL x25;
	VAL x26;
	int64_t x27;
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v28 = mtp_std_maybe_Maybe_1_Some(v19);
			incref(v28);
			VAL v29;
			int64_t v30;
			mw_mirth_def_Def_callableZAsk(v14, v28, &v29, &v30);
			VAL x31;
			VAL x32;
			VAL x33;
			VAL x34;
			if (((bool)v30)) {
				VAL v35 = mtw_std_either_Either_2_Right(v28);
				x34 = v35;
				x33 = v15;
				x32 = v29;
				x31 = v10;
			} else {
				VAL v36 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v28);
				VAL v37 = mtw_std_either_Either_2_Left(v36);
				x34 = v37;
				x33 = v15;
				x32 = v29;
				x31 = v10;
			}
			VAL x38;
			VAL x39;
			VAL x40;
			VAL x41;
			VAL x42;
			switch (get_data_tag(x34)) {
				case 0LL: { // Left
					VAL v43 = mtp_std_either_Either_2_Left(x34);
					VAL v44 = mtw_std_list_List_1_Cons(v43, v17);
					x42 = v18;
					x41 = v44;
					x40 = x33;
					x39 = x32;
					x38 = x31;
				} break;
				case 1LL: { // Right
					VAL v45 = mtp_std_either_Either_2_Right(x34);
					VAL v46 = mtw_std_list_List_1_Cons(v45, v18);
					x42 = v46;
					x41 = v17;
					x40 = x33;
					x39 = x32;
					x38 = x31;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v47 = 1LL /* True */;
			x27 = v47;
			x26 = v20;
			x25 = x42;
			x24 = x41;
			x23 = x40;
			x22 = x39;
			x21 = x38;
		} break;
		case 0LL: { // None
			int64_t v48 = 0LL /* False */;
			x27 = v48;
			x26 = v20;
			x25 = v18;
			x24 = v17;
			x23 = v15;
			x22 = v14;
			x21 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v49 = x21;
	VAL v50 = (x22);
	VAL v51 = (x23);
	VAL v52 = x24;
	VAL v53 = x25;
	VAL v54 = x26;
	int64_t v55 = x27;
	while (((bool)v55)) {
		VAL v56 = v49;
		VAL v57 = (v50);
		VAL v58 = (v51);
		VAL v59 = v52;
		VAL v60 = v53;
		VAL v61 = v54;
		VAL v62;
		VAL v63;
		mw_std_list_List_1_uncons(v61, &v62, &v63);
		VAL x64;
		VAL x65;
		VAL x66;
		VAL x67;
		VAL x68;
		VAL x69;
		int64_t x70;
		switch (get_data_tag(v62)) {
			case 1LL: { // Some
				VAL v71 = mtp_std_maybe_Maybe_1_Some(v62);
				incref(v71);
				VAL v72;
				int64_t v73;
				mw_mirth_def_Def_callableZAsk(v57, v71, &v72, &v73);
				VAL x74;
				VAL x75;
				VAL x76;
				VAL x77;
				if (((bool)v73)) {
					VAL v78 = mtw_std_either_Either_2_Right(v71);
					x77 = v78;
					x76 = v58;
					x75 = v72;
					x74 = v56;
				} else {
					VAL v79 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v71);
					VAL v80 = mtw_std_either_Either_2_Left(v79);
					x77 = v80;
					x76 = v58;
					x75 = v72;
					x74 = v56;
				}
				VAL x81;
				VAL x82;
				VAL x83;
				VAL x84;
				VAL x85;
				switch (get_data_tag(x77)) {
					case 0LL: { // Left
						VAL v86 = mtp_std_either_Either_2_Left(x77);
						VAL v87 = mtw_std_list_List_1_Cons(v86, v59);
						x85 = v60;
						x84 = v87;
						x83 = x76;
						x82 = x75;
						x81 = x74;
					} break;
					case 1LL: { // Right
						VAL v88 = mtp_std_either_Either_2_Right(x77);
						VAL v89 = mtw_std_list_List_1_Cons(v88, v60);
						x85 = v89;
						x84 = v59;
						x83 = x76;
						x82 = x75;
						x81 = x74;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v90 = 1LL /* True */;
				x70 = v90;
				x69 = v63;
				x68 = x85;
				x67 = x84;
				x66 = x83;
				x65 = x82;
				x64 = x81;
			} break;
			case 0LL: { // None
				int64_t v91 = 0LL /* False */;
				x70 = v91;
				x69 = v63;
				x68 = v60;
				x67 = v59;
				x66 = v58;
				x65 = v57;
				x64 = v56;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v55 = x70;
		v54 = x69;
		v53 = x68;
		v52 = x67;
		v51 = x66;
		v50 = x65;
		v49 = x64;
	}
	decref(v54);
	VAL v92 = mw_std_list_List_1_reverse(v52);
	VAL v93 = mw_std_list_List_1_reverse(v53);
	VAL v94 = VVAL(VTUP(v51)->cells[5]);
	incref(v94);
	VAL v95 = mw_std_list_List_1_cat(v92, v94);
	VAL v96 = VTUP(v51)->cells[5];
	decref(v96);
	VTUP(v51)->cells[5] = v95;
	VAL v97 = VTUP(v51)->cells[4];
	decref(v97);
	VTUP(v51)->cells[4] = v93;
	VAL v98;
	VAL v99;
	mw_mirth_elab_ZPlusResolveDef_filterZ_arity(v50, v51, &v98, &v99);
	VAL v100;
	VAL v101;
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(v98, v99, &v100, &v101);
	uint64_t v102 = VU64(VTUP(v101)->cells[2]);
	int64_t v103 = mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk(v102);
	VAL x104;
	VAL x105;
	VAL x106;
	if (((bool)v103)) {
		VAL v107;
		VAL v108;
		mw_mirth_elab_abZ_typeZAt(v49, &v107, &v108);
		int64_t v109 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v108);
		VAL x110;
		VAL x111;
		VAL x112;
		if (((bool)v109)) {
			VAL v113;
			VAL v114;
			mw_mirth_elab_abZ_typeZAt(v107, &v113, &v114);
			VAL v115 = mw_mirth_type_StackType_topZ_namespaces(v114);
			VAL v116;
			VAL v117;
			mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v115, v100, v101, &v116, &v117);
			x112 = v113;
			x111 = v117;
			x110 = v116;
		} else {
			x112 = v107;
			x111 = v101;
			x110 = v100;
		}
		x106 = x112;
		x105 = x111;
		x104 = x110;
	} else {
		VAL v118 = MKI64(0LL /* Nil */);
		VAL v119;
		VAL v120;
		mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v118, v100, v101, &v119, &v120);
		x106 = v49;
		x105 = v120;
		x104 = v119;
	}
	VAL v121;
	VAL v122;
	mw_mirth_elab_resolveZ_defZ_endZBang(x104, x105, &v121, &v122);
	VAL x123;
	VAL x124;
	switch (get_data_tag(v122)) {
		case 0LL: { // None
			VAL v125;
			VAL v126;
			mw_mirth_elab_elabZ_atomZ_failedZBang(v121, x106, &v125, &v126);
			x124 = v126;
			x123 = v125;
		} break;
		case 1LL: { // Some
			VAL v127 = mtp_std_maybe_Maybe_1_Some(v122);
			VAL v128;
			VAL v129;
			mw_mirth_elab_elabZ_atomZ_defZBang(v127, v121, x106, &v128, &v129);
			x124 = v129;
			x123 = v128;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x124;
	*x4 = x123;
}
static void mw_mirth_elab_elabZ_atomZ_failedZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = MKI64(0LL /* STACK_TYPE_ERROR */);
	VAL v6 = (mw_mirth_elab_abZ_typeZBang(x2, v5));
	*x4 = v6;
	*x3 = x1;
}
static void mw_mirth_elab_elabZ_atomZ_defZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL x6;
	VAL x7;
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v8 = mtp_mirth_def_Def_DefAlias(x1);
			VAL v9;
			VAL v10;
			mw_mirth_alias_Alias_target(x2, v8, &v9, &v10);
			VAL v11;
			VAL v12;
			mw_mirth_elab_elabZ_atomZ_defZBang(v10, v9, x3, &v11, &v12);
			x7 = v12;
			x6 = v11;
		} break;
		case 9LL: { // DefBuffer
			uint64_t v13 = mtp_mirth_def_Def_DefBuffer(x1);
			VAL v14;
			VAL v15;
			mw_mirth_elab_elabZ_noZ_argsZBang(x2, x3, &v14, &v15);
			VAL v16;
			VAL v17;
			mw_mirth_elab_abZ_bufferZBang(v13, v14, v15, &v16, &v17);
			x7 = v17;
			x6 = v16;
		} break;
		case 10LL: { // DefVariable
			uint64_t v18 = mtp_mirth_def_Def_DefVariable(x1);
			VAL v19;
			VAL v20;
			mw_mirth_elab_elabZ_noZ_argsZBang(x2, x3, &v19, &v20);
			VAL v21;
			VAL v22;
			mw_mirth_elab_abZ_variableZBang(v18, v19, v20, &v21, &v22);
			x7 = v22;
			x6 = v21;
		} break;
		case 11LL: { // DefExternal
			uint64_t v23 = mtp_mirth_def_Def_DefExternal(x1);
			VAL v24;
			VAL v25;
			mw_mirth_elab_elabZ_noZ_argsZBang(x2, x3, &v24, &v25);
			VAL v26;
			VAL v27;
			mw_mirth_elab_abZ_externalZBang(v23, v24, v25, &v26, &v27);
			x7 = v27;
			x6 = v26;
		} break;
		case 12LL: { // DefField
			uint64_t v28 = mtp_mirth_def_Def_DefField(x1);
			VAL v29;
			VAL v30;
			mw_mirth_elab_elabZ_noZ_argsZBang(x2, x3, &v29, &v30);
			VAL v31;
			VAL v32;
			mw_mirth_elab_abZ_fieldZBang(v28, v29, v30, &v31, &v32);
			x7 = v32;
			x6 = v31;
		} break;
		case 8LL: { // DefWord
			uint64_t v33 = mtp_mirth_def_Def_DefWord(x1);
			VAL v34;
			VAL v35;
			mw_mirth_elab_elabZ_argsZBang(x2, x3, &v34, &v35);
			VAL v36;
			VAL v37;
			mw_mirth_elab_abZ_wordZBang(v33, v34, v35, &v36, &v37);
			x7 = v37;
			x6 = v36;
		} break;
		case 6LL: { // DefTag
			uint64_t v38 = mtp_mirth_def_Def_DefTag(x1);
			VAL v39;
			VAL v40;
			mw_mirth_elab_elabZ_argsZBang(x2, x3, &v39, &v40);
			VAL v41;
			VAL v42;
			mw_mirth_elab_abZ_tagZBang(v38, v39, v40, &v41, &v42);
			x7 = v42;
			x6 = v41;
		} break;
		case 7LL: { // DefPrim
			int64_t v43 = mtp_mirth_def_Def_DefPrim(x1);
			VAL v44;
			VAL v45;
			mw_mirth_elab_elabZ_primZBang(v43, x2, x3, &v44, &v45);
			x7 = v45;
			x6 = v44;
		} break;
		default: {
			VAL v46;
			VAL v47;
			mw_mirth_def_Def_qnameZ_hard(x2, x1, &v46, &v47);
			VAL v48;
			VAL v49;
			mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang(v47, v46, x3, &v48, &v49);
			x7 = v49;
			x6 = v48;
		} break;
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_elab_abZ_typeZAt(x3, &v6, &v7);
	int64_t v8 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v7);
	VAL x9;
	VAL x10;
	if (((bool)v8)) {
		VAL v11;
		uint64_t v12;
		mw_mirth_elab_abZ_tokenZAt(v6, &v11, &v12);
		STR* v13;
		STRLIT(v13, "Not a word: ", 12);
		VAL v14;
		VAL v15;
		mw_mirth_name_QName_ZToStr(x2, x1, &v14, &v15);
		STR* v16 = str_cat(v13, VSTR(v15));
		VAL v17 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v12, MKSTR(v16), v14));
		x10 = v11;
		x9 = v17;
	} else {
		decref(x1);
		x10 = v6;
		x9 = x2;
	}
	VAL v18;
	VAL v19;
	mw_mirth_elab_elabZ_atomZ_failedZBang(x9, x10, &v18, &v19);
	*x5 = v19;
	*x4 = v18;
}
static void mw_mirth_elab_elabZ_primZBang (int64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL x6;
	VAL x7;
	switch (x1) {
		case 12LL: { // PRIM_CORE_MATCH
			VAL v8;
			VAL v9;
			mw_mirth_elab_elabZ_atomZ_matchZBang(x2, x3, &v8, &v9);
			x7 = v9;
			x6 = v8;
		} break;
		case 13LL: { // PRIM_CORE_LAMBDA
			VAL v10;
			VAL v11;
			mw_mirth_elab_elabZ_atomZ_lambdaZBang(x2, x3, &v10, &v11);
			x7 = v11;
			x6 = v10;
		} break;
		default: {
			VAL v12;
			VAL v13;
			mw_mirth_elab_elabZ_argsZBang(x2, x3, &v12, &v13);
			VAL v14;
			VAL v15;
			mw_mirth_elab_abZ_primZBang(x1, v12, v13, &v14, &v15);
			x7 = v15;
			x6 = v14;
		} break;
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_elab_elabZ_atomZ_assertZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	uint64_t v7;
	VAL v8;
	mw_mirth_token_Token_argsZ_1(v6, x1, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_elab_abZ_ctxZAt(v5, &v9, &v10);
	int64_t v11 = 1LL /* True */;
	int64_t v12 = 0LL /* False */;
	VAL v13 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v10, v7, v11, v12));
	VAL v14;
	VAL v15;
	VAL v16;
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(v8, v13, &v14, &v15, &v16);
	mw_mirth_elab_ZPlusTypeElab_rdrop(v15);
	VAL v17;
	VAL v18;
	mw_mirth_elab_abZ_typeZAt(v9, &v17, &v18);
	VAL v19;
	uint64_t v20;
	mw_mirth_elab_abZ_tokenZAt(v17, &v19, &v20);
	VAL v21;
	uint64_t v22;
	VAL v23;
	mw_mirth_type_StackType_unifyZBang(v14, v20, v18, v16, &v21, &v22, &v23);
	mw_mirth_type_ZPlusGamma_rdrop(v22);
	decref(v23);
	*x4 = v19;
	*x3 = v21;
}
static void mw_mirth_elab_elabZ_atomZ_matchZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = mw_mirth_type_MetaVar_newZBang();
	VAL v6 = mtw_mirth_type_StackType_STMeta(v5);
	VAL v7;
	uint64_t v8;
	mw_mirth_elab_abZ_tokenZAt(x2, &v7, &v8);
	uint64_t v9 = mw_mirth_token_Token_succ(v8);
	VAL v10 = mw_mirth_token_Token_lcurlyZAsk(v9);
	VAL x11;
	VAL x12;
	uint64_t x13;
	VAL x14;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v10);
			decref(v15);
			VAL v16;
			uint64_t v17;
			mw_mirth_elab_abZ_tokenZAt(v7, &v16, &v17);
			uint64_t v18 = mw_mirth_token_Token_succ(v17);
			uint64_t v19 = mw_mirth_token_Token_succ(v18);
			VAL v20;
			uint64_t v21;
			mw_mirth_elab_abZ_tokenZAt(v16, &v20, &v21);
			uint64_t v22 = mw_mirth_token_Token_succ(v21);
			VAL v23 = (mw_mirth_elab_abZ_tokenZBang(v20, v22));
			x14 = v23;
			x13 = v19;
			x12 = v6;
			x11 = x1;
		} break;
		case 0LL: { // None
			VAL v24;
			uint64_t v25;
			mw_mirth_elab_abZ_tokenZAt(v7, &v24, &v25);
			VAL v26;
			VAL v27;
			mw_mirth_token_Token_argsZPlus(v25, x1, &v26, &v27);
			VAL v28 = mw_std_list_ListZPlus_1_first(v26);
			x14 = v24;
			x13 = VU64(v28);
			x12 = v6;
			x11 = v27;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v29;
	VAL v30;
	mw_mirth_elab_elabZ_matchZ_atZBang(x12, x13, x11, x14, &v29, &v30);
	*x4 = v30;
	*x3 = v29;
}
static void mw_mirth_elab_elabZ_matchZ_atZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	mw_mirth_elab_abZ_ctxZAt(x4, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_elab_abZ_typeZAt(v7, &v9, &v10);
	VAL v11;
	uint64_t v12;
	mw_mirth_elab_abZ_tokenZAt(v9, &v11, &v12);
	VAL v13;
	VAL v14;
	mw_mirth_elab_abZ_homeZAt(v11, &v13, &v14);
	VAL v15 = MKI64(0LL /* Nil */);
	VAL v16 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v14, v12, x2, v8, v10, x1, v15));
	VAL v17;
	VAL v18;
	mw_mirth_elab_elabZ_matchZ_casesZBang(x3, v16, &v17, &v18);
	VAL v19;
	VAL v20;
	mw_mirth_elab_elabZ_matchZ_exhaustiveZBang(v17, v18, &v19, &v20);
	VAL v21 = mw_mirth_match_ZPlusMatch_freezze(v20);
	VAL v22 = mtw_mirth_arrow_Op_OpMatch(v21);
	VAL v23;
	VAL v24;
	mw_mirth_elab_abZ_opZBang(v22, v19, v13, &v23, &v24);
	*x6 = v24;
	*x5 = v23;
}
static void mw_mirth_elab_elabZ_matchZ_casesZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = VU64(VTUP(x2)->cells[3]);
	VAL v6 = mw_mirth_token_Token_lcurlyZAsk(v5);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			decref(v9);
			VAL v10;
			VAL v11;
			mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang(x1, x2, &v10, &v11);
			x8 = v11;
			x7 = v10;
		} break;
		case 0LL: { // None
			VAL v12;
			VAL v13;
			mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang(x1, x2, &v12, &v13);
			x8 = v13;
			x7 = v12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x8;
	*x3 = x7;
}
static void mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = VU64(VTUP(x2)->cells[3]);
	VAL v6 = mw_mirth_token_Token_runZ_tokens(v5);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			incref(v13);
			VAL v14 = mw_mirth_token_Token_lcurlyZAsk(VU64(v13));
			VAL x15;
			VAL x16;
			uint64_t x17;
			switch (get_data_tag(v14)) {
				case 1LL: { // Some
					VAL v18 = mtp_std_maybe_Maybe_1_Some(v14);
					decref(v18);
					x17 = VU64(v13);
					x16 = x2;
					x15 = x1;
				} break;
				case 0LL: { // None
					STR* v19;
					STRLIT(v19, "Expected a pattern match case of the form { ... -> ... }", 56);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v13), MKSTR(v19), x1);
					uint64_t v20 = pop_u64();
					x17 = v20;
					x16 = x2;
					VAL r21 = pop_resource();
					x15 = r21;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v22;
			VAL v23;
			mw_mirth_token_Token_argsZ_1(x17, x15, &v22, &v23);
			uint64_t v24;
			VAL v25;
			VAL v26;
			mw_mirth_elab_elabZ_matchZ_caseZBang(v22, v23, x16, &v24, &v25, &v26);
			int64_t v27 = 1LL /* True */;
			x12 = v27;
			x11 = v8;
			x10 = v26;
			x9 = v25;
		} break;
		case 0LL: { // None
			int64_t v28 = 0LL /* False */;
			x12 = v28;
			x11 = v8;
			x10 = x2;
			x9 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v29 = (x9);
	VAL v30 = (x10);
	VAL v31 = x11;
	int64_t v32 = x12;
	while (((bool)v32)) {
		VAL v33 = (v29);
		VAL v34 = (v30);
		VAL v35 = v31;
		VAL v36;
		VAL v37;
		mw_std_list_List_1_uncons(v35, &v36, &v37);
		VAL x38;
		VAL x39;
		VAL x40;
		int64_t x41;
		switch (get_data_tag(v36)) {
			case 1LL: { // Some
				VAL v42 = mtp_std_maybe_Maybe_1_Some(v36);
				incref(v42);
				VAL v43 = mw_mirth_token_Token_lcurlyZAsk(VU64(v42));
				VAL x44;
				VAL x45;
				uint64_t x46;
				switch (get_data_tag(v43)) {
					case 1LL: { // Some
						VAL v47 = mtp_std_maybe_Maybe_1_Some(v43);
						decref(v47);
						x46 = VU64(v42);
						x45 = v34;
						x44 = v33;
					} break;
					case 0LL: { // None
						STR* v48;
						STRLIT(v48, "Expected a pattern match case of the form { ... -> ... }", 56);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v42), MKSTR(v48), v33);
						uint64_t v49 = pop_u64();
						x46 = v49;
						x45 = v34;
						VAL r50 = pop_resource();
						x44 = r50;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				uint64_t v51;
				VAL v52;
				mw_mirth_token_Token_argsZ_1(x46, x44, &v51, &v52);
				uint64_t v53;
				VAL v54;
				VAL v55;
				mw_mirth_elab_elabZ_matchZ_caseZBang(v51, v52, x45, &v53, &v54, &v55);
				int64_t v56 = 1LL /* True */;
				x41 = v56;
				x40 = v37;
				x39 = v55;
				x38 = v54;
			} break;
			case 0LL: { // None
				int64_t v57 = 0LL /* False */;
				x41 = v57;
				x40 = v37;
				x39 = v34;
				x38 = v33;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v32 = x41;
		v31 = x40;
		v30 = x39;
		v29 = x38;
	}
	decref(v31);
	*x4 = v30;
	*x3 = v29;
}
static void mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5 = VU64(VTUP(x2)->cells[3]);
	int64_t v6 = mw_mirth_token_Token_argsZ_endZAsk(v5);
	bool v7 = !((bool)v6);
	VAL v8 = (x1);
	VAL v9 = (x2);
	uint64_t v10 = v5;
	bool v11 = v7;
	while (v11) {
		VAL v12 = (v8);
		VAL v13 = (v9);
		uint64_t v14 = v10;
		uint64_t v15;
		VAL v16;
		VAL v17;
		mw_mirth_elab_elabZ_matchZ_caseZBang(v14, v12, v13, &v15, &v16, &v17);
		int64_t v18 = mw_mirth_token_Token_argsZ_endZAsk(v15);
		bool v19 = !((bool)v18);
		v11 = v19;
		v10 = v15;
		v9 = v17;
		v8 = v16;
	}
	*x4 = v9;
	*x3 = v8;
}
static void mw_mirth_elab_elabZ_matchZ_caseZBang (uint64_t x1, VAL x2, VAL x3, uint64_t *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_token_Token_runZ_arrowZAsk(x1);
	VAL x8;
	VAL x9;
	uint64_t x10;
	uint64_t x11;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v7);
			x11 = VU64(v12);
			x10 = x1;
			x9 = x3;
			x8 = x2;
		} break;
		case 0LL: { // None
			STR* v13;
			STRLIT(v13, "Expected pattern match case ... -> ...", 38);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v13), x2);
			uint64_t v14 = pop_u64();
			x11 = v14;
			uint64_t v15 = pop_u64();
			x10 = v15;
			x9 = x3;
			VAL r16 = pop_resource();
			x8 = r16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v17 = mw_mirth_token_Token_ZEqualZEqual(x10, x11);
	VAL x18;
	VAL x19;
	uint64_t x20;
	uint64_t x21;
	if (((bool)v17)) {
		STR* v22;
		STRLIT(v22, "expected pattern", 16);
		push_u64(x10);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x11, MKSTR(v22), x8);
		uint64_t v23 = pop_u64();
		x21 = v23;
		uint64_t v24 = pop_u64();
		x20 = v24;
		x19 = x9;
		VAL r25 = pop_resource();
		x18 = r25;
	} else {
		x21 = x11;
		x20 = x10;
		x19 = x9;
		x18 = x8;
	}
	uint64_t v26 = mw_mirth_token_Token_prev(x21);
	int64_t v27 = mw_mirth_token_Token_ZEqualZEqual(x20, v26);
	VAL x28;
	VAL x29;
	uint64_t x30;
	uint64_t x31;
	if (((bool)v27)) {
		x31 = x21;
		x30 = x20;
		x29 = x19;
		x28 = x18;
	} else {
		STR* v32;
		STRLIT(v32, "multi-part pattern not supported", 32);
		push_u64(x20);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x21, MKSTR(v32), x18);
		uint64_t v33 = pop_u64();
		x31 = v33;
		uint64_t v34 = pop_u64();
		x30 = v34;
		x29 = x19;
		VAL r35 = pop_resource();
		x28 = r35;
	}
	VAL v36 = mw_mirth_token_Token_patZ_tokens(x30);
	uint64_t v37 = mw_mirth_token_Token_prev(x31);
	uint64_t v38 = mw_mirth_token_Token_succ(x31);
	VAL v39 = VVAL(VTUP(x29)->cells[1]);
	incref(v39);
	VAL v40 = VVAL(VTUP(x29)->cells[4]);
	incref(v40);
	incref(v40);
	VAL v41 = MKI64(0LL /* Nil */);
	VAL v42 = VVAL(VTUP(x29)->cells[5]);
	incref(v42);
	incref(v42);
	VAL v43 = MKI64(0LL /* Nil */);
	VAL v44 = mtw_mirth_match_Pattern_Pattern(v39, v37, v37, v40, v40, v41, v42, v42, v43);
	VAL v45 = (mw_mirth_match_Pattern_thaw(v44));
	VAL v46;
	VAL v47;
	mw_mirth_elab_elabZ_patternZBang(v36, x28, v45, &v46, &v47);
	VAL v48 = mw_mirth_match_ZPlusPattern_freezze(v47);
	incref(v48);
	VAL v49 = VVAL(VTUP(v48)->cells[5]);
	incref(v49);
	decref(v48);
	incref(v48);
	VAL v50 = mw_mirth_match_Pattern_dom(v48);
	VAL v51 = VVAL(VTUP(x29)->cells[6]);
	incref(v51);
	VAL v52 = mw_mirth_type_TZ_ZTo(v50, v51);
	VAL v53 = VVAL(VTUP(x29)->cells[1]);
	incref(v53);
	VAL v54;
	VAL v55;
	mw_mirth_type_ArrowType_unpack(v52, &v54, &v55);
	incref(v54);
	VAL v56 = MKI64(0LL /* Nil */);
	VAL v57 = mtw_mirth_arrow_Arrow_Arrow(v53, v38, v38, v49, v54, v54, v56);
	VAL v58;
	VAL v59;
	mw_mirth_elab_elabZ_atomsZBang(v46, v57, &v58, &v59);
	VAL v60;
	uint64_t v61;
	mw_mirth_elab_abZ_tokenZAt(v59, &v60, &v61);
	int64_t v62 = mw_mirth_token_Token_commaZAsk(v61);
	VAL x63;
	VAL x64;
	uint64_t x65;
	if (((bool)v62)) {
		uint64_t v66 = mw_mirth_token_Token_succ(v61);
		x65 = v66;
		x64 = v60;
		x63 = v58;
	} else {
		x65 = v61;
		x64 = v60;
		x63 = v58;
	}
	VAL v67;
	VAL v68;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v55, x63, x64, &v67, &v68);
	VAL v69 = mtw_mirth_match_Case_CASE(v48, v68);
	VAL v70;
	VAL v71;
	mw_mirth_match_ZPlusMatch_addZ_case(v67, x29, v69, &v70, &v71);
	*x6 = v71;
	*x5 = v70;
	*x4 = x65;
}
static void mw_mirth_elab_elabZ_patternZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = mw_std_list_List_1_reverse(x1);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14;
			VAL v15;
			mw_mirth_elab_elabZ_patternZ_atomZBang(VU64(v13), x2, x3, &v14, &v15);
			int64_t v16 = 1LL /* True */;
			x12 = v16;
			x11 = v8;
			x10 = v15;
			x9 = v14;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x12 = v17;
			x11 = v8;
			x10 = x3;
			x9 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x9);
	VAL v19 = (x10);
	VAL v20 = x11;
	int64_t v21 = x12;
	while (((bool)v21)) {
		VAL v22 = (v18);
		VAL v23 = (v19);
		VAL v24 = v20;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
				VAL v32;
				VAL v33;
				mw_mirth_elab_elabZ_patternZ_atomZBang(VU64(v31), v22, v23, &v32, &v33);
				int64_t v34 = 1LL /* True */;
				x30 = v34;
				x29 = v26;
				x28 = v33;
				x27 = v32;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x30 = v35;
				x29 = v26;
				x28 = v23;
				x27 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x30;
		v20 = x29;
		v19 = x28;
		v18 = x27;
	}
	decref(v20);
	*x5 = v19;
	*x4 = v18;
}
static void mw_mirth_elab_elabZ_patternZ_atomZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x3);
	VAL v6 = tup_replace(x3, 2, MKU64(x1));
	decref(x3);
	int64_t v7 = mw_mirth_token_Token_patZ_underscoreZAsk(x1);
	VAL x8;
	VAL x9;
	if (((bool)v7)) {
		VAL v10;
		VAL v11;
		mw_mirth_match_ZPlusPattern_underscoreZBang(x2, v6, &v10, &v11);
		x9 = v11;
		x8 = v10;
	} else {
		VAL v12 = mw_mirth_token_Token_nameZDivdnameZAsk(x1);
		VAL x13;
		VAL x14;
		switch (get_data_tag(v12)) {
			case 1LL: { // Some
				VAL v15 = mtp_std_maybe_Maybe_1_Some(v12);
				STR* v16;
				STRLIT(v16, "constructor", 11);
				incref(v6);
				VAL v17 = VVAL(VTUP(v6)->cells[7]);
				incref(v17);
				decref(v6);
				int64_t v18 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v17);
				bool v19 = !((bool)v18);
				int64_t v20 = 0LL /* False */;
				VAL v21;
				VAL v22;
				mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v16), x1, v15, v20, ((int64_t)v19), x2, &v21, &v22);
				VAL v23 = VVAL(VTUP(v22)->cells[4]);
				incref(v23);
				VAL v24 = MKI64(0LL /* Nil */);
				VAL v25 = MKI64(0LL /* Nil */);
				VAL v26;
				VAL v27;
				mw_std_list_List_1_uncons(v23, &v26, &v27);
				VAL x28;
				VAL x29;
				VAL x30;
				VAL x31;
				VAL x32;
				VAL x33;
				int64_t x34;
				switch (get_data_tag(v26)) {
					case 1LL: { // Some
						VAL v35 = mtp_std_maybe_Maybe_1_Some(v26);
						incref(v35);
						VAL v36 = mw_mirth_def_Def_tagZAsk(v35);
						int64_t v37 = mw_std_maybe_Maybe_1_someZAsk(v36);
						VAL x38;
						VAL x39;
						VAL x40;
						VAL x41;
						if (((bool)v37)) {
							VAL v42 = mtw_std_either_Either_2_Right(v35);
							x41 = v42;
							x40 = v22;
							x39 = v21;
							x38 = v6;
						} else {
							VAL v43 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v35);
							VAL v44 = mtw_std_either_Either_2_Left(v43);
							x41 = v44;
							x40 = v22;
							x39 = v21;
							x38 = v6;
						}
						VAL x45;
						VAL x46;
						VAL x47;
						VAL x48;
						VAL x49;
						switch (get_data_tag(x41)) {
							case 0LL: { // Left
								VAL v50 = mtp_std_either_Either_2_Left(x41);
								VAL v51 = mtw_std_list_List_1_Cons(v50, v24);
								x49 = v25;
								x48 = v51;
								x47 = x40;
								x46 = x39;
								x45 = x38;
							} break;
							case 1LL: { // Right
								VAL v52 = mtp_std_either_Either_2_Right(x41);
								VAL v53 = mtw_std_list_List_1_Cons(v52, v25);
								x49 = v53;
								x48 = v24;
								x47 = x40;
								x46 = x39;
								x45 = x38;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						int64_t v54 = 1LL /* True */;
						x34 = v54;
						x33 = v27;
						x32 = x49;
						x31 = x48;
						x30 = x47;
						x29 = x46;
						x28 = x45;
					} break;
					case 0LL: { // None
						int64_t v55 = 0LL /* False */;
						x34 = v55;
						x33 = v27;
						x32 = v25;
						x31 = v24;
						x30 = v22;
						x29 = v21;
						x28 = v6;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v56 = x28;
				VAL v57 = (x29);
				VAL v58 = (x30);
				VAL v59 = x31;
				VAL v60 = x32;
				VAL v61 = x33;
				int64_t v62 = x34;
				while (((bool)v62)) {
					VAL v63 = v56;
					VAL v64 = (v57);
					VAL v65 = (v58);
					VAL v66 = v59;
					VAL v67 = v60;
					VAL v68 = v61;
					VAL v69;
					VAL v70;
					mw_std_list_List_1_uncons(v68, &v69, &v70);
					VAL x71;
					VAL x72;
					VAL x73;
					VAL x74;
					VAL x75;
					VAL x76;
					int64_t x77;
					switch (get_data_tag(v69)) {
						case 1LL: { // Some
							VAL v78 = mtp_std_maybe_Maybe_1_Some(v69);
							incref(v78);
							VAL v79 = mw_mirth_def_Def_tagZAsk(v78);
							int64_t v80 = mw_std_maybe_Maybe_1_someZAsk(v79);
							VAL x81;
							VAL x82;
							VAL x83;
							VAL x84;
							if (((bool)v80)) {
								VAL v85 = mtw_std_either_Either_2_Right(v78);
								x84 = v85;
								x83 = v65;
								x82 = v64;
								x81 = v63;
							} else {
								VAL v86 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v78);
								VAL v87 = mtw_std_either_Either_2_Left(v86);
								x84 = v87;
								x83 = v65;
								x82 = v64;
								x81 = v63;
							}
							VAL x88;
							VAL x89;
							VAL x90;
							VAL x91;
							VAL x92;
							switch (get_data_tag(x84)) {
								case 0LL: { // Left
									VAL v93 = mtp_std_either_Either_2_Left(x84);
									VAL v94 = mtw_std_list_List_1_Cons(v93, v66);
									x92 = v67;
									x91 = v94;
									x90 = x83;
									x89 = x82;
									x88 = x81;
								} break;
								case 1LL: { // Right
									VAL v95 = mtp_std_either_Either_2_Right(x84);
									VAL v96 = mtw_std_list_List_1_Cons(v95, v67);
									x92 = v96;
									x91 = v66;
									x90 = x83;
									x89 = x82;
									x88 = x81;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							int64_t v97 = 1LL /* True */;
							x77 = v97;
							x76 = v70;
							x75 = x92;
							x74 = x91;
							x73 = x90;
							x72 = x89;
							x71 = x88;
						} break;
						case 0LL: { // None
							int64_t v98 = 0LL /* False */;
							x77 = v98;
							x76 = v70;
							x75 = v67;
							x74 = v66;
							x73 = v65;
							x72 = v64;
							x71 = v63;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v62 = x77;
					v61 = x76;
					v60 = x75;
					v59 = x74;
					v58 = x73;
					v57 = x72;
					v56 = x71;
				}
				decref(v61);
				VAL v99 = mw_std_list_List_1_reverse(v59);
				VAL v100 = mw_std_list_List_1_reverse(v60);
				VAL v101 = VVAL(VTUP(v58)->cells[5]);
				incref(v101);
				VAL v102 = mw_std_list_List_1_cat(v99, v101);
				VAL v103 = VTUP(v58)->cells[5];
				decref(v103);
				VTUP(v58)->cells[5] = v102;
				VAL v104 = VTUP(v58)->cells[4];
				decref(v104);
				VTUP(v58)->cells[4] = v100;
				VAL v105;
				VAL v106;
				mw_mirth_elab_ZPlusResolveDef_filterZ_arity(v57, v58, &v105, &v106);
				VAL v107;
				VAL v108;
				mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(v105, v106, &v107, &v108);
				incref(v56);
				VAL v109 = VVAL(VTUP(v56)->cells[7]);
				incref(v109);
				decref(v56);
				int64_t v110 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v109);
				VAL x111;
				VAL x112;
				VAL x113;
				if (((bool)v110)) {
					incref(v56);
					VAL v114 = VVAL(VTUP(v56)->cells[7]);
					incref(v114);
					decref(v56);
					VAL v115 = mw_mirth_type_StackType_topZ_namespaces(v114);
					uint64_t v116 = VU64(VTUP(v108)->cells[2]);
					VAL v117 = mw_mirth_token_Token_nameZAsk(v116);
					VAL x118;
					VAL x119;
					VAL x120;
					switch (get_data_tag(v117)) {
						case 1LL: { // Some
							VAL v121 = mtp_std_maybe_Maybe_1_Some(v117);
							decref(v121);
							VAL v122 = VVAL(VTUP(v108)->cells[4]);
							incref(v122);
							VAL v123 = MKI64(0LL /* Nil */);
							VAL v124 = MKI64(0LL /* Nil */);
							VAL v125;
							VAL v126;
							mw_std_list_List_1_uncons(v122, &v125, &v126);
							VAL x127;
							VAL x128;
							VAL x129;
							VAL x130;
							VAL x131;
							VAL x132;
							VAL x133;
							int64_t x134;
							switch (get_data_tag(v125)) {
								case 1LL: { // Some
									VAL v135 = mtp_std_maybe_Maybe_1_Some(v125);
									incref(v115);
									incref(v135);
									VAL v136;
									VAL v137;
									mw_mirth_def_Def_qnameZ_hard(v107, v135, &v136, &v137);
									VAL v138 = VVAL(VTUP(v137)->cells[1]);
									incref(v138);
									decref(v137);
									VAL v139 = MKI64(0LL /* None */);
									VAL v140;
									VAL v141;
									mw_std_list_List_1_uncons(v115, &v140, &v141);
									VAL x142;
									VAL x143;
									VAL x144;
									VAL x145;
									VAL x146;
									VAL x147;
									VAL x148;
									VAL x149;
									int64_t x150;
									switch (get_data_tag(v140)) {
										case 1LL: { // Some
											VAL v151 = mtp_std_maybe_Maybe_1_Some(v140);
											incref(v151);
											incref(v138);
											int64_t v152 = mw_mirth_name_Namespace_ZEqualZEqual(v138, v151);
											VAL x153;
											VAL x154;
											VAL x155;
											VAL x156;
											VAL x157;
											VAL x158;
											VAL x159;
											if (((bool)v152)) {
												VAL v160 = mtw_std_maybe_Maybe_1_Some(v151);
												x159 = v160;
												x158 = v138;
												x157 = v108;
												x156 = v136;
												x155 = v135;
												x154 = v115;
												x153 = v56;
											} else {
												decref(v151);
												VAL v161 = MKI64(0LL /* None */);
												x159 = v161;
												x158 = v138;
												x157 = v108;
												x156 = v136;
												x155 = v135;
												x154 = v115;
												x153 = v56;
											}
											VAL x162;
											VAL x163;
											VAL x164;
											VAL x165;
											VAL x166;
											VAL x167;
											VAL x168;
											VAL x169;
											switch (get_data_tag(x159)) {
												case 0LL: { // None
													x169 = v141;
													x168 = v139;
													x167 = x158;
													x166 = x157;
													x165 = x156;
													x164 = x155;
													x163 = x154;
													x162 = x153;
												} break;
												default: {
													decref(v141);
													decref(v139);
													VAL v170 = MKI64(0LL /* Nil */);
													x169 = v170;
													x168 = x159;
													x167 = x158;
													x166 = x157;
													x165 = x156;
													x164 = x155;
													x163 = x154;
													x162 = x153;
												} break;
											}
											int64_t v171 = 1LL /* True */;
											x150 = v171;
											x149 = x169;
											x148 = x168;
											x147 = x167;
											x146 = x166;
											x145 = x165;
											x144 = x164;
											x143 = x163;
											x142 = x162;
										} break;
										case 0LL: { // None
											int64_t v172 = 0LL /* False */;
											x150 = v172;
											x149 = v141;
											x148 = v139;
											x147 = v138;
											x146 = v108;
											x145 = v136;
											x144 = v135;
											x143 = v115;
											x142 = v56;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									VAL v173 = x142;
									VAL v174 = x143;
									VAL v175 = x144;
									VAL v176 = (x145);
									VAL v177 = (x146);
									VAL v178 = x147;
									VAL v179 = x148;
									VAL v180 = x149;
									int64_t v181 = x150;
									while (((bool)v181)) {
										VAL v182 = v173;
										VAL v183 = v174;
										VAL v184 = v175;
										VAL v185 = (v176);
										VAL v186 = (v177);
										VAL v187 = v178;
										VAL v188 = v179;
										VAL v189 = v180;
										VAL v190;
										VAL v191;
										mw_std_list_List_1_uncons(v189, &v190, &v191);
										VAL x192;
										VAL x193;
										VAL x194;
										VAL x195;
										VAL x196;
										VAL x197;
										VAL x198;
										VAL x199;
										int64_t x200;
										switch (get_data_tag(v190)) {
											case 1LL: { // Some
												VAL v201 = mtp_std_maybe_Maybe_1_Some(v190);
												incref(v201);
												incref(v187);
												int64_t v202 = mw_mirth_name_Namespace_ZEqualZEqual(v187, v201);
												VAL x203;
												VAL x204;
												VAL x205;
												VAL x206;
												VAL x207;
												VAL x208;
												VAL x209;
												if (((bool)v202)) {
													VAL v210 = mtw_std_maybe_Maybe_1_Some(v201);
													x209 = v210;
													x208 = v187;
													x207 = v186;
													x206 = v185;
													x205 = v184;
													x204 = v183;
													x203 = v182;
												} else {
													decref(v201);
													VAL v211 = MKI64(0LL /* None */);
													x209 = v211;
													x208 = v187;
													x207 = v186;
													x206 = v185;
													x205 = v184;
													x204 = v183;
													x203 = v182;
												}
												VAL x212;
												VAL x213;
												VAL x214;
												VAL x215;
												VAL x216;
												VAL x217;
												VAL x218;
												VAL x219;
												switch (get_data_tag(x209)) {
													case 0LL: { // None
														x219 = v191;
														x218 = v188;
														x217 = x208;
														x216 = x207;
														x215 = x206;
														x214 = x205;
														x213 = x204;
														x212 = x203;
													} break;
													default: {
														decref(v191);
														decref(v188);
														VAL v220 = MKI64(0LL /* Nil */);
														x219 = v220;
														x218 = x209;
														x217 = x208;
														x216 = x207;
														x215 = x206;
														x214 = x205;
														x213 = x204;
														x212 = x203;
													} break;
												}
												int64_t v221 = 1LL /* True */;
												x200 = v221;
												x199 = x219;
												x198 = x218;
												x197 = x217;
												x196 = x216;
												x195 = x215;
												x194 = x214;
												x193 = x213;
												x192 = x212;
											} break;
											case 0LL: { // None
												int64_t v222 = 0LL /* False */;
												x200 = v222;
												x199 = v191;
												x198 = v188;
												x197 = v187;
												x196 = v186;
												x195 = v185;
												x194 = v184;
												x193 = v183;
												x192 = v182;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										v181 = x200;
										v180 = x199;
										v179 = x198;
										v178 = x197;
										v177 = x196;
										v176 = x195;
										v175 = x194;
										v174 = x193;
										v173 = x192;
									}
									decref(v180);
									decref(v178);
									int64_t v223 = mw_std_maybe_Maybe_1_someZAsk(v179);
									VAL x224;
									VAL x225;
									VAL x226;
									VAL x227;
									VAL x228;
									if (((bool)v223)) {
										VAL v229 = mtw_std_either_Either_2_Right(v175);
										x228 = v229;
										x227 = v177;
										x226 = v174;
										x225 = v173;
										x224 = v176;
									} else {
										VAL v230 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v175);
										VAL v231 = mtw_std_either_Either_2_Left(v230);
										x228 = v231;
										x227 = v177;
										x226 = v174;
										x225 = v173;
										x224 = v176;
									}
									VAL x232;
									VAL x233;
									VAL x234;
									VAL x235;
									VAL x236;
									VAL x237;
									switch (get_data_tag(x228)) {
										case 0LL: { // Left
											VAL v238 = mtp_std_either_Either_2_Left(x228);
											VAL v239 = mtw_std_list_List_1_Cons(v238, v123);
											x237 = v124;
											x236 = v239;
											x235 = x227;
											x234 = x226;
											x233 = x225;
											x232 = x224;
										} break;
										case 1LL: { // Right
											VAL v240 = mtp_std_either_Either_2_Right(x228);
											VAL v241 = mtw_std_list_List_1_Cons(v240, v124);
											x237 = v241;
											x236 = v123;
											x235 = x227;
											x234 = x226;
											x233 = x225;
											x232 = x224;
										} break;
										default: {
											do_panic(str_make("unexpected fallthrough in match\n", 32));
										}
									}
									int64_t v242 = 1LL /* True */;
									x134 = v242;
									x133 = v126;
									x132 = x237;
									x131 = x236;
									x130 = x235;
									x129 = x234;
									x128 = x233;
									x127 = x232;
								} break;
								case 0LL: { // None
									int64_t v243 = 0LL /* False */;
									x134 = v243;
									x133 = v126;
									x132 = v124;
									x131 = v123;
									x130 = v108;
									x129 = v115;
									x128 = v56;
									x127 = v107;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v244 = (x127);
							VAL v245 = x128;
							VAL v246 = x129;
							VAL v247 = (x130);
							VAL v248 = x131;
							VAL v249 = x132;
							VAL v250 = x133;
							int64_t v251 = x134;
							while (((bool)v251)) {
								VAL v252 = (v244);
								VAL v253 = v245;
								VAL v254 = v246;
								VAL v255 = (v247);
								VAL v256 = v248;
								VAL v257 = v249;
								VAL v258 = v250;
								VAL v259;
								VAL v260;
								mw_std_list_List_1_uncons(v258, &v259, &v260);
								VAL x261;
								VAL x262;
								VAL x263;
								VAL x264;
								VAL x265;
								VAL x266;
								VAL x267;
								int64_t x268;
								switch (get_data_tag(v259)) {
									case 1LL: { // Some
										VAL v269 = mtp_std_maybe_Maybe_1_Some(v259);
										incref(v254);
										incref(v269);
										VAL v270;
										VAL v271;
										mw_mirth_def_Def_qnameZ_hard(v252, v269, &v270, &v271);
										VAL v272 = VVAL(VTUP(v271)->cells[1]);
										incref(v272);
										decref(v271);
										VAL v273 = MKI64(0LL /* None */);
										VAL v274;
										VAL v275;
										mw_std_list_List_1_uncons(v254, &v274, &v275);
										VAL x276;
										VAL x277;
										VAL x278;
										VAL x279;
										VAL x280;
										VAL x281;
										VAL x282;
										VAL x283;
										int64_t x284;
										switch (get_data_tag(v274)) {
											case 1LL: { // Some
												VAL v285 = mtp_std_maybe_Maybe_1_Some(v274);
												incref(v285);
												incref(v272);
												int64_t v286 = mw_mirth_name_Namespace_ZEqualZEqual(v272, v285);
												VAL x287;
												VAL x288;
												VAL x289;
												VAL x290;
												VAL x291;
												VAL x292;
												VAL x293;
												if (((bool)v286)) {
													VAL v294 = mtw_std_maybe_Maybe_1_Some(v285);
													x293 = v294;
													x292 = v272;
													x291 = v255;
													x290 = v270;
													x289 = v269;
													x288 = v254;
													x287 = v253;
												} else {
													decref(v285);
													VAL v295 = MKI64(0LL /* None */);
													x293 = v295;
													x292 = v272;
													x291 = v255;
													x290 = v270;
													x289 = v269;
													x288 = v254;
													x287 = v253;
												}
												VAL x296;
												VAL x297;
												VAL x298;
												VAL x299;
												VAL x300;
												VAL x301;
												VAL x302;
												VAL x303;
												switch (get_data_tag(x293)) {
													case 0LL: { // None
														x303 = v275;
														x302 = v273;
														x301 = x292;
														x300 = x291;
														x299 = x290;
														x298 = x289;
														x297 = x288;
														x296 = x287;
													} break;
													default: {
														decref(v275);
														decref(v273);
														VAL v304 = MKI64(0LL /* Nil */);
														x303 = v304;
														x302 = x293;
														x301 = x292;
														x300 = x291;
														x299 = x290;
														x298 = x289;
														x297 = x288;
														x296 = x287;
													} break;
												}
												int64_t v305 = 1LL /* True */;
												x284 = v305;
												x283 = x303;
												x282 = x302;
												x281 = x301;
												x280 = x300;
												x279 = x299;
												x278 = x298;
												x277 = x297;
												x276 = x296;
											} break;
											case 0LL: { // None
												int64_t v306 = 0LL /* False */;
												x284 = v306;
												x283 = v275;
												x282 = v273;
												x281 = v272;
												x280 = v255;
												x279 = v270;
												x278 = v269;
												x277 = v254;
												x276 = v253;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										VAL v307 = x276;
										VAL v308 = x277;
										VAL v309 = x278;
										VAL v310 = (x279);
										VAL v311 = (x280);
										VAL v312 = x281;
										VAL v313 = x282;
										VAL v314 = x283;
										int64_t v315 = x284;
										while (((bool)v315)) {
											VAL v316 = v307;
											VAL v317 = v308;
											VAL v318 = v309;
											VAL v319 = (v310);
											VAL v320 = (v311);
											VAL v321 = v312;
											VAL v322 = v313;
											VAL v323 = v314;
											VAL v324;
											VAL v325;
											mw_std_list_List_1_uncons(v323, &v324, &v325);
											VAL x326;
											VAL x327;
											VAL x328;
											VAL x329;
											VAL x330;
											VAL x331;
											VAL x332;
											VAL x333;
											int64_t x334;
											switch (get_data_tag(v324)) {
												case 1LL: { // Some
													VAL v335 = mtp_std_maybe_Maybe_1_Some(v324);
													incref(v335);
													incref(v321);
													int64_t v336 = mw_mirth_name_Namespace_ZEqualZEqual(v321, v335);
													VAL x337;
													VAL x338;
													VAL x339;
													VAL x340;
													VAL x341;
													VAL x342;
													VAL x343;
													if (((bool)v336)) {
														VAL v344 = mtw_std_maybe_Maybe_1_Some(v335);
														x343 = v344;
														x342 = v321;
														x341 = v320;
														x340 = v319;
														x339 = v318;
														x338 = v317;
														x337 = v316;
													} else {
														decref(v335);
														VAL v345 = MKI64(0LL /* None */);
														x343 = v345;
														x342 = v321;
														x341 = v320;
														x340 = v319;
														x339 = v318;
														x338 = v317;
														x337 = v316;
													}
													VAL x346;
													VAL x347;
													VAL x348;
													VAL x349;
													VAL x350;
													VAL x351;
													VAL x352;
													VAL x353;
													switch (get_data_tag(x343)) {
														case 0LL: { // None
															x353 = v325;
															x352 = v322;
															x351 = x342;
															x350 = x341;
															x349 = x340;
															x348 = x339;
															x347 = x338;
															x346 = x337;
														} break;
														default: {
															decref(v325);
															decref(v322);
															VAL v354 = MKI64(0LL /* Nil */);
															x353 = v354;
															x352 = x343;
															x351 = x342;
															x350 = x341;
															x349 = x340;
															x348 = x339;
															x347 = x338;
															x346 = x337;
														} break;
													}
													int64_t v355 = 1LL /* True */;
													x334 = v355;
													x333 = x353;
													x332 = x352;
													x331 = x351;
													x330 = x350;
													x329 = x349;
													x328 = x348;
													x327 = x347;
													x326 = x346;
												} break;
												case 0LL: { // None
													int64_t v356 = 0LL /* False */;
													x334 = v356;
													x333 = v325;
													x332 = v322;
													x331 = v321;
													x330 = v320;
													x329 = v319;
													x328 = v318;
													x327 = v317;
													x326 = v316;
												} break;
												default: {
													do_panic(str_make("unexpected fallthrough in match\n", 32));
												}
											}
											v315 = x334;
											v314 = x333;
											v313 = x332;
											v312 = x331;
											v311 = x330;
											v310 = x329;
											v309 = x328;
											v308 = x327;
											v307 = x326;
										}
										decref(v314);
										decref(v312);
										int64_t v357 = mw_std_maybe_Maybe_1_someZAsk(v313);
										VAL x358;
										VAL x359;
										VAL x360;
										VAL x361;
										VAL x362;
										if (((bool)v357)) {
											VAL v363 = mtw_std_either_Either_2_Right(v309);
											x362 = v363;
											x361 = v311;
											x360 = v308;
											x359 = v307;
											x358 = v310;
										} else {
											VAL v364 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v309);
											VAL v365 = mtw_std_either_Either_2_Left(v364);
											x362 = v365;
											x361 = v311;
											x360 = v308;
											x359 = v307;
											x358 = v310;
										}
										VAL x366;
										VAL x367;
										VAL x368;
										VAL x369;
										VAL x370;
										VAL x371;
										switch (get_data_tag(x362)) {
											case 0LL: { // Left
												VAL v372 = mtp_std_either_Either_2_Left(x362);
												VAL v373 = mtw_std_list_List_1_Cons(v372, v256);
												x371 = v257;
												x370 = v373;
												x369 = x361;
												x368 = x360;
												x367 = x359;
												x366 = x358;
											} break;
											case 1LL: { // Right
												VAL v374 = mtp_std_either_Either_2_Right(x362);
												VAL v375 = mtw_std_list_List_1_Cons(v374, v257);
												x371 = v375;
												x370 = v256;
												x369 = x361;
												x368 = x360;
												x367 = x359;
												x366 = x358;
											} break;
											default: {
												do_panic(str_make("unexpected fallthrough in match\n", 32));
											}
										}
										int64_t v376 = 1LL /* True */;
										x268 = v376;
										x267 = v260;
										x266 = x371;
										x265 = x370;
										x264 = x369;
										x263 = x368;
										x262 = x367;
										x261 = x366;
									} break;
									case 0LL: { // None
										int64_t v377 = 0LL /* False */;
										x268 = v377;
										x267 = v260;
										x266 = v257;
										x265 = v256;
										x264 = v255;
										x263 = v254;
										x262 = v253;
										x261 = v252;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v251 = x268;
								v250 = x267;
								v249 = x266;
								v248 = x265;
								v247 = x264;
								v246 = x263;
								v245 = x262;
								v244 = x261;
							}
							decref(v250);
							VAL v378 = mw_std_list_List_1_reverse(v248);
							VAL v379 = mw_std_list_List_1_reverse(v249);
							VAL v380 = VVAL(VTUP(v247)->cells[5]);
							incref(v380);
							VAL v381 = mw_std_list_List_1_cat(v378, v380);
							VAL v382 = VTUP(v247)->cells[5];
							decref(v382);
							VTUP(v247)->cells[5] = v381;
							VAL v383 = VTUP(v247)->cells[4];
							decref(v383);
							VTUP(v247)->cells[4] = v379;
							decref(v246);
							x120 = v247;
							x119 = v245;
							x118 = v244;
						} break;
						case 0LL: { // None
							VAL v384;
							VAL v385;
							mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v115, v107, v108, &v384, &v385);
							x120 = v385;
							x119 = v56;
							x118 = v384;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x113 = x119;
					x112 = x120;
					x111 = x118;
				} else {
					x113 = v56;
					x112 = v108;
					x111 = v107;
				}
				VAL v386;
				VAL v387;
				mw_mirth_elab_resolveZ_defZ_endZBang(x111, x112, &v386, &v387);
				VAL x388;
				VAL x389;
				VAL x390;
				switch (get_data_tag(v387)) {
					case 1LL: { // Some
						VAL v391 = mtp_std_maybe_Maybe_1_Some(v387);
						VAL v392 = mw_mirth_def_Def_tagZAsk(v391);
						x390 = v392;
						x389 = x113;
						x388 = v386;
					} break;
					case 0LL: { // None
						VAL v393 = MKI64(0LL /* None */);
						x390 = v393;
						x389 = x113;
						x388 = v386;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL x394;
				VAL x395;
				switch (get_data_tag(x390)) {
					case 1LL: { // Some
						VAL v396 = mtp_std_maybe_Maybe_1_Some(x390);
						VAL v397;
						VAL v398;
						mw_mirth_match_ZPlusPattern_tagZBang(x388, x389, VU64(v396), &v397, &v398);
						x395 = v398;
						x394 = v397;
					} break;
					case 0LL: { // None
						VAL v399 = MKI64(0LL /* STACK_TYPE_ERROR */);
						incref(x389);
						VAL v400 = tup_replace(x389, 7, v399);
						decref(x389);
						x395 = v400;
						x394 = x388;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x14 = x395;
				x13 = x394;
			} break;
			case 0LL: { // None
				STR* v401;
				STRLIT(v401, "Expected constructor name.", 26);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v401), x2);
				x14 = v6;
				VAL r402 = pop_resource();
				x13 = r402;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x9 = x14;
		x8 = x13;
	}
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_elab_elabZ_expandZ_tensorZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5, VAL *x6, uint64_t *x7) {
	VAL v8 = mw_mirth_type_StackType_forceZ_consZAskZBang(x2);
	VAL x9;
	VAL x10;
	VAL x11;
	uint64_t x12;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v14;
			VAL v15;
			value_uncons(v13, &v14, &v15);
			VAL v16;
			VAL v17;
			value_uncons(v14, &v16, &v17);
			decref(v16);
			x12 = x3;
			x11 = v15;
			x10 = v17;
			x9 = x1;
		} break;
		case 0LL: { // None
			VAL v18 = MKI64(0LL /* STACK_TYPE_ERROR */);
			VAL v19 = MKI64(0LL /* TYPE_ERROR */);
			STR* v20;
			STRLIT(v20, "expected tuple type", 19);
			VAL v21 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x3, MKSTR(v20), x1));
			x12 = x3;
			x11 = v19;
			x10 = v18;
			x9 = v21;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x12;
	*x6 = x11;
	*x5 = x10;
	*x4 = x9;
}
static void mw_mirth_elab_elabZ_lambdaZ_paramZAsk (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	VAL v6 = mw_mirth_token_Token_patternZ_varZAsk(x2);
	VAL x7;
	uint64_t x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v11 = (mw_mirth_token_Token_argsZ_0(x2, x1));
			uint64_t v12 = mw_mirth_token_Token_next(x2);
			uint64_t v13 = mw_mirth_type_MetaVar_newZBang();
			VAL v14 = mtw_mirth_type_Type_TMeta(v13);
			uint64_t v15 = mw_mirth_var_Var_newZBang(v14, VU64(v10));
			VAL v16 = mtw_std_maybe_Maybe_1_Some(MKU64(v15));
			x9 = v16;
			x8 = v12;
			x7 = v11;
		} break;
		case 0LL: { // None
			VAL v17 = mw_mirth_token_Token_patternZ_autoZ_runZ_varZAsk(x2);
			VAL x18;
			uint64_t x19;
			VAL x20;
			switch (get_data_tag(v17)) {
				case 1LL: { // Some
					VAL v21 = mtp_std_maybe_Maybe_1_Some(v17);
					uint64_t v22 = mw_mirth_token_Token_succ(x2);
					VAL v23 = (mw_mirth_token_Token_argsZ_0(v22, x1));
					uint64_t v24 = mw_mirth_token_Token_next(x2);
					uint64_t v25 = mw_mirth_type_MetaVar_newZBang();
					VAL v26 = mtw_mirth_type_StackType_STMeta(v25);
					uint64_t v27 = mw_mirth_type_MetaVar_newZBang();
					VAL v28 = mtw_mirth_type_StackType_STMeta(v27);
					VAL v29 = mw_mirth_type_TZ_ZTo(v26, v28);
					uint64_t v30 = mw_mirth_var_Var_newZ_autoZ_runZBang(v29, VU64(v21));
					VAL v31 = mtw_std_maybe_Maybe_1_Some(MKU64(v30));
					x20 = v31;
					x19 = v24;
					x18 = v23;
				} break;
				case 0LL: { // None
					VAL v32 = MKI64(0LL /* None */);
					x20 = v32;
					x19 = x2;
					x18 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x9 = x20;
			x8 = x19;
			x7 = x18;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x9;
	*x4 = x8;
	*x3 = x7;
}
static void mw_mirth_elab_elabZ_atomZ_lambdaZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	mw_mirth_elab_abZ_tokenZAt(x2, &v5, &v6);
	uint64_t v7;
	VAL v8;
	mw_mirth_token_Token_argsZ_1(v6, x1, &v7, &v8);
	VAL v9 = MKI64(0LL /* Nil */);
	VAL v10 = mw_std_list_List_1_reverse(v9);
	VAL v11;
	uint64_t v12;
	VAL v13;
	mw_mirth_elab_elabZ_lambdaZ_paramZAsk(v8, v7, &v11, &v12, &v13);
	uint64_t x14;
	VAL x15;
	VAL x16;
	VAL x17;
	int64_t x18;
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v19 = mtp_std_maybe_Maybe_1_Some(v13);
			VAL v20 = mtw_std_list_List_1_Cons(v19, v10);
			int64_t v21 = 1LL /* True */;
			x18 = v21;
			x17 = v20;
			x16 = v5;
			x15 = v11;
			x14 = v12;
		} break;
		case 0LL: { // None
			int64_t v22 = 0LL /* False */;
			x18 = v22;
			x17 = v10;
			x16 = v5;
			x15 = v11;
			x14 = v12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v23 = x14;
	VAL v24 = (x15);
	VAL v25 = (x16);
	VAL v26 = (x17);
	int64_t v27 = x18;
	while (((bool)v27)) {
		uint64_t v28 = v23;
		VAL v29 = (v24);
		VAL v30 = (v25);
		VAL v31 = (v26);
		VAL v32;
		uint64_t v33;
		VAL v34;
		mw_mirth_elab_elabZ_lambdaZ_paramZAsk(v29, v28, &v32, &v33, &v34);
		uint64_t x35;
		VAL x36;
		VAL x37;
		VAL x38;
		int64_t x39;
		switch (get_data_tag(v34)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(v34);
				VAL v41 = mtw_std_list_List_1_Cons(v40, v31);
				int64_t v42 = 1LL /* True */;
				x39 = v42;
				x38 = v41;
				x37 = v30;
				x36 = v32;
				x35 = v33;
			} break;
			case 0LL: { // None
				int64_t v43 = 0LL /* False */;
				x39 = v43;
				x38 = v31;
				x37 = v30;
				x36 = v32;
				x35 = v33;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v27 = x39;
		v26 = x38;
		v25 = x37;
		v24 = x36;
		v23 = x35;
	}
	VAL v44 = mw_std_list_List_1_reverse(v26);
	VAL v45;
	uint64_t v46;
	mw_mirth_elab_expectZ_tokenZ_arrow(v24, v23, &v45, &v46);
	uint64_t v47 = mw_mirth_token_Token_succ(v46);
	incref(v44);
	VAL v48;
	VAL v49;
	mw_mirth_elab_abZ_ctxZAt(v25, &v48, &v49);
	VAL v50;
	VAL v51;
	mw_mirth_elab_abZ_typeZAt(v48, &v50, &v51);
	VAL v52 = mw_std_list_List_1_reverse(v44);
	VAL v53;
	VAL v54;
	mw_std_list_List_1_uncons(v52, &v53, &v54);
	uint64_t x55;
	VAL x56;
	VAL x57;
	VAL x58;
	VAL x59;
	VAL x60;
	int64_t x61;
	switch (get_data_tag(v53)) {
		case 1LL: { // Some
			VAL v62 = mtp_std_maybe_Maybe_1_Some(v53);
			incref(v62);
			VAL v63 = mw_mirth_var_Ctx_new(v49, VU64(v62));
			VAL v64;
			uint64_t v65;
			mw_mirth_elab_abZ_tokenZAt(v50, &v64, &v65);
			VAL v66;
			VAL v67;
			VAL v68;
			uint64_t v69;
			mw_mirth_elab_elabZ_expandZ_tensorZBang(v45, v51, v65, &v66, &v67, &v68, &v69);
			VAL v70 = mw_mirth_var_Var_type(VU64(v62));
			VAL v71;
			VAL v72;
			uint64_t v73;
			mw_mirth_elab_elabZ_typeZ_unifyZBang(v66, v68, v70, v69, &v71, &v72, &v73);
			decref(v72);
			int64_t v74 = 1LL /* True */;
			x61 = v74;
			x60 = v54;
			x59 = v67;
			x58 = v64;
			x57 = v63;
			x56 = v71;
			x55 = v47;
		} break;
		case 0LL: { // None
			int64_t v75 = 0LL /* False */;
			x61 = v75;
			x60 = v54;
			x59 = v51;
			x58 = v50;
			x57 = v49;
			x56 = v45;
			x55 = v47;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v76 = x55;
	VAL v77 = (x56);
	VAL v78 = x57;
	VAL v79 = (x58);
	VAL v80 = x59;
	VAL v81 = x60;
	int64_t v82 = x61;
	while (((bool)v82)) {
		uint64_t v83 = v76;
		VAL v84 = (v77);
		VAL v85 = v78;
		VAL v86 = (v79);
		VAL v87 = v80;
		VAL v88 = v81;
		VAL v89;
		VAL v90;
		mw_std_list_List_1_uncons(v88, &v89, &v90);
		uint64_t x91;
		VAL x92;
		VAL x93;
		VAL x94;
		VAL x95;
		VAL x96;
		int64_t x97;
		switch (get_data_tag(v89)) {
			case 1LL: { // Some
				VAL v98 = mtp_std_maybe_Maybe_1_Some(v89);
				incref(v98);
				VAL v99 = mw_mirth_var_Ctx_new(v85, VU64(v98));
				VAL v100;
				uint64_t v101;
				mw_mirth_elab_abZ_tokenZAt(v86, &v100, &v101);
				VAL v102;
				VAL v103;
				VAL v104;
				uint64_t v105;
				mw_mirth_elab_elabZ_expandZ_tensorZBang(v84, v87, v101, &v102, &v103, &v104, &v105);
				VAL v106 = mw_mirth_var_Var_type(VU64(v98));
				VAL v107;
				VAL v108;
				uint64_t v109;
				mw_mirth_elab_elabZ_typeZ_unifyZBang(v102, v104, v106, v105, &v107, &v108, &v109);
				decref(v108);
				int64_t v110 = 1LL /* True */;
				x97 = v110;
				x96 = v90;
				x95 = v103;
				x94 = v100;
				x93 = v99;
				x92 = v107;
				x91 = v83;
			} break;
			case 0LL: { // None
				int64_t v111 = 0LL /* False */;
				x97 = v111;
				x96 = v90;
				x95 = v87;
				x94 = v86;
				x93 = v85;
				x92 = v84;
				x91 = v83;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v82 = x97;
		v81 = x96;
		v80 = x95;
		v79 = x94;
		v78 = x93;
		v77 = x92;
		v76 = x91;
	}
	decref(v81);
	VAL v112;
	VAL v113;
	mw_mirth_elab_abZ_homeZAt(v79, &v112, &v113);
	incref(v80);
	VAL v114 = MKI64(0LL /* Nil */);
	VAL v115 = mtw_mirth_arrow_Arrow_Arrow(v113, v76, v76, v78, v80, v80, v114);
	VAL v116;
	VAL v117;
	mw_mirth_elab_elabZ_atomsZBang(v77, v115, &v116, &v117);
	VAL v118;
	VAL v119;
	mw_mirth_elab_abZ_ctxZAt(v112, &v118, &v119);
	VAL v120;
	VAL v121;
	mw_mirth_elab_abZ_typeZAt(v118, &v120, &v121);
	VAL v122;
	uint64_t v123;
	mw_mirth_elab_abZ_tokenZAt(v120, &v122, &v123);
	VAL v124 = mtw_mirth_arrow_Lambda_Lambda(v123, v119, v121, v44, v117);
	VAL v125 = mtw_mirth_arrow_Op_OpLambda(v124);
	VAL v126;
	VAL v127;
	mw_mirth_elab_abZ_opZBang(v125, v116, v122, &v126, &v127);
	*x4 = v127;
	*x3 = v126;
}
static void mw_mirth_elab_elabZ_matchZ_exhaustiveZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_match_ZPlusMatch_freezze(x2);
	incref(v5);
	int64_t v6 = mw_mirth_match_Match_isZ_exhaustiveZAsk(v5);
	VAL x7;
	VAL x8;
	if (((bool)v6)) {
		x8 = v5;
		x7 = x1;
	} else {
		incref(v5);
		uint64_t v9 = VU64(VTUP(v5)->cells[2]);
		decref(v5);
		STR* v10;
		STRLIT(v10, "Pattern match not exhaustive.", 29);
		VAL v11 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v9, MKSTR(v10), x1));
		x8 = v5;
		x7 = v11;
	}
	VAL v12 = (mw_mirth_match_Match_thaw(x8));
	*x4 = v12;
	*x3 = x7;
}
static void mw_mirth_elab_elabZ_moduleZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6) {
	uint64_t v7 = mw_mirth_module_Module_start(x1);
	int64_t v8;
	VAL v9;
	uint64_t v10;
	mw_mirth_elab_elabZ_moduleZ_headerZBang(x2, x3, v7, &v8, &v9, &v10);
	int64_t v11 = mw_mirth_token_Token_moduleZ_endZAsk(v10);
	bool v12 = !((bool)v11);
	uint64_t v13 = x1;
	int64_t v14 = (v8);
	VAL v15 = (v9);
	uint64_t v16 = v10;
	bool v17 = v12;
	while (v17) {
		uint64_t v18 = v13;
		int64_t v19 = (v14);
		VAL v20 = (v15);
		uint64_t v21 = v16;
		uint64_t v22;
		int64_t v23;
		VAL v24;
		mw_mirth_elab_elabZ_moduleZ_declZBang(v21, v19, v20, &v22, &v23, &v24);
		int64_t v25 = mw_mirth_token_Token_moduleZ_endZAsk(v22);
		bool v26 = !((bool)v25);
		v17 = v26;
		v16 = v22;
		v15 = v24;
		v14 = v23;
		v13 = v18;
	}
	*x6 = v15;
	*x5 = v14;
	*x4 = v13;
}
static void mw_mirth_elab_elabZ_moduleZ_packageZ_name (uint64_t x1, VAL x2, uint64_t *x3, uint64_t *x4, VAL *x5) {
	VAL v6 = mw_mirth_token_Token_dnameZAsk(x1);
	VAL x7;
	uint64_t x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
			x9 = v10;
			x8 = x1;
			x7 = x2;
		} break;
		case 0LL: { // None
			STR* v11;
			STRLIT(v11, "Expected module name. (1)", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v11), x2);
			VAL v12 = pop_value();
			x9 = v12;
			uint64_t v13 = pop_u64();
			x8 = v13;
			VAL r14 = pop_resource();
			x7 = r14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15 = (mw_mirth_token_Token_argsZ_0(x8, x7));
	incref(x9);
	VAL v16 = mw_mirth_name_DName_rootZAsk(x9);
	uint64_t x17;
	VAL x18;
	VAL x19;
	uint64_t x20;
	switch (get_data_tag(v16)) {
		case 1LL: { // Some
			VAL v21 = mtp_std_maybe_Maybe_1_Some(v16);
			x20 = VU64(v21);
			x19 = x9;
			x18 = v15;
			x17 = x8;
		} break;
		case 0LL: { // None
			decref(x9);
			STR* v22;
			STRLIT(v22, "Expected module name. (2)", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x8, MKSTR(v22), v15);
			uint64_t v23 = pop_u64();
			x20 = v23;
			VAL v24 = pop_value();
			x19 = v24;
			VAL r25 = pop_resource();
			x18 = r25;
			uint64_t v26 = pop_u64();
			x17 = v26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v27 = mw_mirth_name_DName_parts(x19);
	VAL v28;
	VAL v29;
	mtp_std_list_ListZPlus_1_ListZPlus(v27, &v28, &v29);
	int64_t v30 = mw_std_list_List_1_ZDivL0(v29);
	VAL x31;
	if (((bool)v30)) {
		VAL v32 = mtw_std_maybe_Maybe_1_Some(v28);
		x31 = v32;
		push_u64(x17);
		push_resource(x18);
		push_u64(x20);
	} else {
		decref(v28);
		VAL v33 = MKI64(0LL /* None */);
		x31 = v33;
		push_u64(x17);
		push_resource(x18);
		push_u64(x20);
	}
	uint64_t x34;
	VAL x35;
	uint64_t x36;
	uint64_t x37;
	switch (get_data_tag(x31)) {
		case 1LL: { // Some
			VAL v38 = mtp_std_maybe_Maybe_1_Some(x31);
			x37 = VU64(v38);
			uint64_t v39 = pop_u64();
			x36 = v39;
			VAL r40 = pop_resource();
			x35 = r40;
			uint64_t v41 = pop_u64();
			x34 = v41;
		} break;
		case 0LL: { // None
			uint64_t v42 = pop_u64();
			STR* v43;
			STRLIT(v43, "Expected module name. (3)", 25);
			VAL r44 = pop_resource();
			uint64_t v45 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v45, MKSTR(v43), r44);
			uint64_t v46 = pop_u64();
			x37 = v46;
			uint64_t v47 = pop_u64();
			x36 = v47;
			VAL r48 = pop_resource();
			x35 = r48;
			uint64_t v49 = pop_u64();
			x34 = v49;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v50;
	uint64_t v51;
	mw_mirth_package_Package_findZ_orZ_newZBang(x35, x36, &v50, &v51);
	*x5 = v50;
	*x4 = x37;
	*x3 = v51;
}
static void mw_mirth_elab_elabZ_moduleZ_qname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	uint64_t v5;
	uint64_t v6;
	VAL v7;
	mw_mirth_elab_elabZ_moduleZ_packageZ_name(x2, x1, &v5, &v6, &v7);
	VAL v8 = mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE(v5);
	VAL v9 = mw_mirth_name_QNAME0(v8, v6);
	*x4 = v9;
	*x3 = v7;
}
static void mw_mirth_elab_elabZ_moduleZ_headerZBang (int64_t x1, VAL x2, uint64_t x3, int64_t *x4, VAL *x5, uint64_t *x6) {
	VAL v7 = mtw_std_maybe_Maybe_1_Some(MKU64(x3));
	VAL v8 = VTUP(x2)->cells[5];
	decref(v8);
	VTUP(x2)->cells[5] = v7;
	int64_t v9 = mw_mirth_token_Token_moduleZ_headerZAsk(x3);
	uint64_t x10;
	int64_t x11;
	VAL x12;
	if (((bool)v9)) {
		uint64_t v13 = mw_mirth_token_Token_next(x3);
		uint64_t v14;
		VAL v15;
		mw_mirth_token_Token_argsZ_1(x3, x2, &v14, &v15);
		uint64_t v16;
		uint64_t v17;
		VAL v18;
		mw_mirth_elab_elabZ_moduleZ_packageZ_name(v14, v15, &v16, &v17, &v18);
		uint64_t v19 = mw_mirth_token_Token_module(v14);
		void* v20 = mfld_mirth_module_Module_ZTildename(v19);
		mut_set(MKU64(v17), v20);
		void* v21 = mfld_mirth_module_Module_ZTildepackage(v19);
		mut_set(MKU64(v16), v21);
		VAL v22 = mw_mirth_module_Module_qname(v19);
		VAL v23;
		int64_t v24;
		mw_mirth_name_QName_definedZ_softZAsk(v18, v22, &v23, &v24);
		int64_t x25;
		uint64_t x26;
		uint64_t x27;
		uint64_t x28;
		VAL x29;
		if (((bool)v24)) {
			STR* v30;
			STRLIT(v30, "Module name already taken.", 26);
			push_resource(MKI64(x1));
			push_u64(v13);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v14, MKSTR(v30), v23);
			VAL r31 = pop_resource();
			x29 = r31;
			uint64_t v32 = pop_u64();
			x28 = v32;
			uint64_t v33 = pop_u64();
			x27 = v33;
			uint64_t v34 = pop_u64();
			x26 = v34;
			int64_t r35 = VI64(pop_resource());
			x25 = r35;
		} else {
			x29 = v23;
			x28 = v19;
			x27 = v14;
			x26 = v13;
			x25 = x1;
		}
		VAL v36 = mtw_mirth_def_Def_DefModule(x28);
		VAL v37 = (mw_mirth_def_Def_register(x29, v36));
		int64_t v38;
		VAL v39;
		mw_mirth_elab_checkZ_moduleZ_path(x27, x28, x25, v37, &v38, &v39);
		x12 = v39;
		x11 = v38;
		x10 = x26;
	} else {
		STR* v40;
		STRLIT(v40, "Expected module header.", 23);
		push_resource(MKI64(x1));
		push_u64(x3);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x3, MKSTR(v40), x2);
		VAL r41 = pop_resource();
		x12 = r41;
		int64_t r42 = VI64(pop_resource());
		x11 = r42;
		uint64_t v43 = pop_u64();
		x10 = v43;
	}
	*x6 = x10;
	*x5 = x12;
	*x4 = x11;
}
static void mw_mirth_elab_checkZ_moduleZ_path (uint64_t x1, uint64_t x2, int64_t x3, VAL x4, int64_t *x5, VAL *x6) {
	VAL v7 = mw_mirth_module_Module_path(x2);
	VAL v8;
	VAL v9;
	mw_std_path_Path_splitZ_last(v7, &v8, &v9);
	int64_t x10;
	VAL x11;
	switch (get_data_tag(v9)) {
		case 0LL: { // None
			VAL v12 = mw_mirth_module_Module_qname(x2);
			VAL v13;
			int64_t v14;
			VAL v15;
			mw_mirth_name_QName_toZ_moduleZ_path(v12, x3, x4, &v13, &v14, &v15);
			incref(v8);
			incref(v13);
			bool v16 = (str_cmp(VSTR(v8), VSTR(v13)) == 0);
			uint64_t x17;
			int64_t x18;
			VAL x19;
			VAL x20;
			VAL x21;
			if (v16) {
				x21 = v13;
				x20 = v8;
				x19 = v15;
				x18 = v14;
				x17 = x1;
			} else {
				STR* v22;
				STRLIT(v22, "expected module name to match path\n", 35);
				STR* v23 = str_cat(v22, VSTR(v13));
				STR* v24;
				STRLIT(v24, "\n", 1);
				STR* v25 = str_cat(v23, v24);
				STR* v26 = str_cat(v25, VSTR(v8));
				push_resource(MKI64(v14));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v26), v15);
				VAL v27 = pop_value();
				x21 = v27;
				VAL v28 = pop_value();
				x20 = v28;
				VAL r29 = pop_resource();
				x19 = r29;
				int64_t r30 = VI64(pop_resource());
				x18 = r30;
				uint64_t v31 = pop_u64();
				x17 = v31;
			}
			decref(x21);
			decref(x20);
			x11 = x19;
			x10 = x18;
		} break;
		case 1LL: { // Some
			VAL v32 = mtp_std_maybe_Maybe_1_Some(v9);
			int64_t v33;
			VAL v34;
			mw_std_str_ZPlusStr_numZ_bytesZAsk(v32, &v33, &v34);
			VAL v35 = MKI64(0LL /* None */);
			incref(v35);
			int64_t v36 = mw_std_maybe_Maybe_1_noneZAsk(v35);
			uint64_t x37;
			int64_t x38;
			VAL x39;
			uint64_t x40;
			VAL x41;
			VAL x42;
			int64_t x43;
			VAL x44;
			int64_t x45;
			if (((bool)v36)) {
				int64_t v46 = 0LL;
				bool v47 = (v33 > v46);
				x45 = ((int64_t)v47);
				x44 = v35;
				x43 = v33;
				x42 = v34;
				x41 = v8;
				x40 = x2;
				x39 = x4;
				x38 = x3;
				x37 = x1;
			} else {
				int64_t v48 = 0LL /* False */;
				x45 = v48;
				x44 = v35;
				x43 = v33;
				x42 = v34;
				x41 = v8;
				x40 = x2;
				x39 = x4;
				x38 = x3;
				x37 = x1;
			}
			uint64_t v49 = x37;
			int64_t v50 = (x38);
			VAL v51 = (x39);
			uint64_t v52 = x40;
			VAL v53 = x41;
			VAL v54 = (x42);
			int64_t v55 = x43;
			VAL v56 = x44;
			int64_t v57 = x45;
			while (((bool)v57)) {
				uint64_t v58 = v49;
				int64_t v59 = (v50);
				VAL v60 = (v51);
				uint64_t v61 = v52;
				VAL v62 = v53;
				VAL v63 = (v54);
				int64_t v64 = v55;
				VAL v65 = v56;
				decref(v65);
				int64_t v66 = 1LL;
				int64_t v67 = i64_sub(v64, v66);
				int64_t v68 = 0LL;
				bool v69 = (v67 < v68);
				int64_t x70;
				if (v69) {
					int64_t v71 = 0LL;
					x70 = v71;
					push_u64(v58);
					push_resource(MKI64(v59));
					push_resource(v60);
					push_u64(v61);
					push_value(v62);
					push_resource(v63);
				} else {
					x70 = v67;
					push_u64(v58);
					push_resource(MKI64(v59));
					push_resource(v60);
					push_u64(v61);
					push_value(v62);
					push_resource(v63);
				}
				VAL r72 = pop_resource();
				int64_t v73;
				VAL v74;
				mw_std_str_ZPlusStr_byteZAt(x70, r72, &v73, &v74);
				int64_t v75 = 46LL /* BDOT */;
				bool v76 = (v73 == v75);
				uint64_t x77;
				int64_t x78;
				VAL x79;
				uint64_t x80;
				VAL x81;
				VAL x82;
				int64_t x83;
				VAL x84;
				if (v76) {
					VAL v85 = mtw_std_maybe_Maybe_1_Some(MKI64(x70));
					x84 = v85;
					x83 = x70;
					x82 = v74;
					VAL v86 = pop_value();
					x81 = v86;
					uint64_t v87 = pop_u64();
					x80 = v87;
					VAL r88 = pop_resource();
					x79 = r88;
					int64_t r89 = VI64(pop_resource());
					x78 = r89;
					uint64_t v90 = pop_u64();
					x77 = v90;
				} else {
					VAL v91 = MKI64(0LL /* None */);
					x84 = v91;
					x83 = x70;
					x82 = v74;
					VAL v92 = pop_value();
					x81 = v92;
					uint64_t v93 = pop_u64();
					x80 = v93;
					VAL r94 = pop_resource();
					x79 = r94;
					int64_t r95 = VI64(pop_resource());
					x78 = r95;
					uint64_t v96 = pop_u64();
					x77 = v96;
				}
				incref(x84);
				int64_t v97 = mw_std_maybe_Maybe_1_noneZAsk(x84);
				uint64_t x98;
				int64_t x99;
				VAL x100;
				uint64_t x101;
				VAL x102;
				VAL x103;
				int64_t x104;
				VAL x105;
				int64_t x106;
				if (((bool)v97)) {
					int64_t v107 = 0LL;
					bool v108 = (x83 > v107);
					x106 = ((int64_t)v108);
					x105 = x84;
					x104 = x83;
					x103 = x82;
					x102 = x81;
					x101 = x80;
					x100 = x79;
					x99 = x78;
					x98 = x77;
				} else {
					int64_t v109 = 0LL /* False */;
					x106 = v109;
					x105 = x84;
					x104 = x83;
					x103 = x82;
					x102 = x81;
					x101 = x80;
					x100 = x79;
					x99 = x78;
					x98 = x77;
				}
				v57 = x106;
				v56 = x105;
				v55 = x104;
				v54 = x103;
				v53 = x102;
				v52 = x101;
				v51 = x100;
				v50 = x99;
				v49 = x98;
			}
			uint64_t x110;
			int64_t x111;
			VAL x112;
			uint64_t x113;
			VAL x114;
			VAL x115;
			VAL x116;
			switch (get_data_tag(v56)) {
				case 1LL: { // Some
					VAL v117 = mtp_std_maybe_Maybe_1_Some(v56);
					int64_t v118 = (0LL /* +Unsafe */);
					incref(v117);
					incref(v54);
					int64_t v119 = 1LL;
					int64_t v120 = i64_add(VI64(v117), v119);
					VAL v121;
					int64_t v122;
					mw_std_prim_Str_dropZ_slice(v120, v54, v118, &v121, &v122);
					VAL v123;
					int64_t v124;
					mw_std_prim_Str_takeZ_slice(VI64(v117), v54, v122, &v123, &v124);
					VAL v125 = mtw_std_maybe_Maybe_1_Some(v121);
					x116 = v125;
					x115 = v123;
					x114 = v53;
					x113 = v52;
					x112 = v51;
					x111 = v50;
					x110 = v49;
				} break;
				case 0LL: { // None
					VAL v126 = MKI64(0LL /* None */);
					x116 = v126;
					x115 = v54;
					x114 = v53;
					x113 = v52;
					x112 = v51;
					x111 = v50;
					x110 = v49;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			STR* v127;
			STRLIT(v127, "mth", 3);
			VAL v128 = mtw_std_maybe_Maybe_1_Some(MKSTR(v127));
			uint64_t x129;
			int64_t x130;
			VAL x131;
			uint64_t x132;
			VAL x133;
			VAL x134;
			int64_t x135;
			switch (get_data_tag(v128)) {
				case 0LL: { // None
					int64_t v136 = mw_std_maybe_Maybe_1_noneZAsk(x116);
					x135 = v136;
					x134 = x115;
					x133 = x114;
					x132 = x113;
					x131 = x112;
					x130 = x111;
					x129 = x110;
				} break;
				case 1LL: { // Some
					VAL v137 = mtp_std_maybe_Maybe_1_Some(v128);
					uint64_t x138;
					int64_t x139;
					VAL x140;
					uint64_t x141;
					VAL x142;
					VAL x143;
					int64_t x144;
					switch (get_data_tag(x116)) {
						case 1LL: { // Some
							VAL v145 = mtp_std_maybe_Maybe_1_Some(x116);
							bool v146 = (str_cmp(VSTR(v145), VSTR(v137)) == 0);
							x144 = ((int64_t)v146);
							x143 = x115;
							x142 = x114;
							x141 = x113;
							x140 = x112;
							x139 = x111;
							x138 = x110;
						} break;
						case 0LL: { // None
							decref(v137);
							int64_t v147 = 0LL /* False */;
							x144 = v147;
							x143 = x115;
							x142 = x114;
							x141 = x113;
							x140 = x112;
							x139 = x111;
							x138 = x110;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x135 = x144;
					x134 = x143;
					x133 = x142;
					x132 = x141;
					x131 = x140;
					x130 = x139;
					x129 = x138;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t x148;
			int64_t x149;
			VAL x150;
			uint64_t x151;
			VAL x152;
			VAL x153;
			if (((bool)x135)) {
				x153 = x134;
				x152 = x133;
				x151 = x132;
				x150 = x131;
				x149 = x130;
				x148 = x129;
			} else {
				STR* v154;
				STRLIT(v154, "expected .mth extension for mirth file", 38);
				VAL v155 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(x129, MKSTR(v154), x131));
				x153 = x134;
				x152 = x133;
				x151 = x132;
				x150 = v155;
				x149 = x130;
				x148 = x129;
			}
			uint64_t v156 = mw_mirth_module_Module_name(x151);
			VAL v157 = mw_mirth_name_Name_ZToStr(v156);
			bool v158 = (str_cmp(VSTR(x153), VSTR(v157)) == 0);
			uint64_t x159;
			int64_t x160;
			VAL x161;
			uint64_t x162;
			VAL x163;
			if (v158) {
				x163 = x152;
				x162 = x151;
				x161 = x150;
				x160 = x149;
				x159 = x148;
			} else {
				STR* v164;
				STRLIT(v164, "expected module name to match file name", 39);
				push_resource(MKI64(x149));
				push_u64(x148);
				push_u64(x151);
				push_value(x152);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x148, MKSTR(v164), x150);
				VAL v165 = pop_value();
				x163 = v165;
				uint64_t v166 = pop_u64();
				x162 = v166;
				VAL r167 = pop_resource();
				x161 = r167;
				int64_t r168 = VI64(pop_resource());
				x160 = r168;
				uint64_t v169 = pop_u64();
				x159 = v169;
			}
			uint64_t v170 = mw_mirth_module_Module_package(x162);
			VAL v171 = (mw_mirth_package_Package_pathZBang(x161, x163, v170));
			x11 = v171;
			x10 = x160;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x11;
	*x5 = x10;
}
static void mw_mirth_elab_elabZ_moduleZ_declZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6) {
	VAL v7 = mtw_std_maybe_Maybe_1_Some(MKU64(x1));
	VAL v8 = VTUP(x3)->cells[5];
	decref(v8);
	VTUP(x3)->cells[5] = v7;
	VAL v9 = mw_mirth_token_Token_nameZAsk(x1);
	int64_t x10;
	VAL x11;
	uint64_t x12;
	uint64_t x13;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v9);
			x13 = VU64(v14);
			x12 = x1;
			x11 = x3;
			x10 = x2;
		} break;
		case 0LL: { // None
			STR* v15;
			STRLIT(v15, "unknown declaration", 19);
			push_resource(MKI64(x2));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v15), x3);
			uint64_t v16 = pop_u64();
			x13 = v16;
			uint64_t v17 = pop_u64();
			x12 = v17;
			VAL r18 = pop_resource();
			x11 = r18;
			int64_t r19 = VI64(pop_resource());
			x10 = r19;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v20 = mw_mirth_name_Name_defs(x13);
	VAL v21 = MKI64(0LL /* None */);
	VAL v22;
	VAL v23;
	mw_std_list_List_1_uncons(v20, &v22, &v23);
	int64_t x24;
	VAL x25;
	uint64_t x26;
	VAL x27;
	VAL x28;
	int64_t x29;
	switch (get_data_tag(v22)) {
		case 1LL: { // Some
			VAL v30 = mtp_std_maybe_Maybe_1_Some(v22);
			VAL v31 = mw_mirth_def_Def_primZAsk(v30);
			int64_t x32;
			VAL x33;
			uint64_t x34;
			VAL x35;
			VAL x36;
			switch (get_data_tag(v31)) {
				case 0LL: { // None
					x36 = v23;
					x35 = v21;
					x34 = x12;
					x33 = x11;
					x32 = x10;
				} break;
				default: {
					decref(v23);
					decref(v21);
					VAL v37 = MKI64(0LL /* Nil */);
					x36 = v37;
					x35 = v31;
					x34 = x12;
					x33 = x11;
					x32 = x10;
				} break;
			}
			int64_t v38 = 1LL /* True */;
			x29 = v38;
			x28 = x36;
			x27 = x35;
			x26 = x34;
			x25 = x33;
			x24 = x32;
		} break;
		case 0LL: { // None
			int64_t v39 = 0LL /* False */;
			x29 = v39;
			x28 = v23;
			x27 = v21;
			x26 = x12;
			x25 = x11;
			x24 = x10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v40 = (x24);
	VAL v41 = (x25);
	uint64_t v42 = x26;
	VAL v43 = x27;
	VAL v44 = x28;
	int64_t v45 = x29;
	while (((bool)v45)) {
		int64_t v46 = (v40);
		VAL v47 = (v41);
		uint64_t v48 = v42;
		VAL v49 = v43;
		VAL v50 = v44;
		VAL v51;
		VAL v52;
		mw_std_list_List_1_uncons(v50, &v51, &v52);
		int64_t x53;
		VAL x54;
		uint64_t x55;
		VAL x56;
		VAL x57;
		int64_t x58;
		switch (get_data_tag(v51)) {
			case 1LL: { // Some
				VAL v59 = mtp_std_maybe_Maybe_1_Some(v51);
				VAL v60 = mw_mirth_def_Def_primZAsk(v59);
				int64_t x61;
				VAL x62;
				uint64_t x63;
				VAL x64;
				VAL x65;
				switch (get_data_tag(v60)) {
					case 0LL: { // None
						x65 = v52;
						x64 = v49;
						x63 = v48;
						x62 = v47;
						x61 = v46;
					} break;
					default: {
						decref(v52);
						decref(v49);
						VAL v66 = MKI64(0LL /* Nil */);
						x65 = v66;
						x64 = v60;
						x63 = v48;
						x62 = v47;
						x61 = v46;
					} break;
				}
				int64_t v67 = 1LL /* True */;
				x58 = v67;
				x57 = x65;
				x56 = x64;
				x55 = x63;
				x54 = x62;
				x53 = x61;
			} break;
			case 0LL: { // None
				int64_t v68 = 0LL /* False */;
				x58 = v68;
				x57 = v52;
				x56 = v49;
				x55 = v48;
				x54 = v47;
				x53 = v46;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v45 = x58;
		v44 = x57;
		v43 = x56;
		v42 = x55;
		v41 = x54;
		v40 = x53;
	}
	decref(v44);
	int64_t x69;
	VAL x70;
	uint64_t x71;
	int64_t x72;
	switch (get_data_tag(v43)) {
		case 1LL: { // Some
			VAL v73 = mtp_std_maybe_Maybe_1_Some(v43);
			x72 = VI64(v73);
			x71 = v42;
			x70 = v41;
			x69 = v40;
		} break;
		case 0LL: { // None
			STR* v74;
			STRLIT(v74, "unknown declaration", 19);
			push_resource(MKI64(v40));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v42, MKSTR(v74), v41);
			int64_t v75 = pop_i64();
			x72 = v75;
			uint64_t v76 = pop_u64();
			x71 = v76;
			VAL r77 = pop_resource();
			x70 = r77;
			int64_t r78 = VI64(pop_resource());
			x69 = r78;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t x79;
	int64_t x80;
	VAL x81;
	switch (x72) {
		case 103LL: { // PRIM_SYNTAX_IMPORT
			uint64_t v82;
			int64_t v83;
			VAL v84;
			mw_mirth_elab_elabZ_moduleZ_importZBang(x71, x69, x70, &v82, &v83, &v84);
			x81 = v84;
			x80 = v83;
			x79 = v82;
		} break;
		case 104LL: { // PRIM_SYNTAX_ALIAS
			VAL v85;
			uint64_t v86;
			mw_mirth_elab_elabZ_aliasZBang(x70, x71, &v85, &v86);
			x81 = v85;
			x80 = x69;
			x79 = v86;
		} break;
		case 105LL: { // PRIM_SYNTAX_INLINE
			uint64_t v87;
			int64_t v88;
			VAL v89;
			mw_mirth_elab_elabZ_inlineZBang(x71, x69, x70, &v87, &v88, &v89);
			x81 = v89;
			x80 = v88;
			x79 = v87;
		} break;
		case 106LL: { // PRIM_SYNTAX_DEF
			VAL v90;
			uint64_t v91;
			mw_mirth_elab_elabZ_defZBang(x70, x71, &v90, &v91);
			x81 = v90;
			x80 = x69;
			x79 = v91;
		} break;
		case 107LL: { // PRIM_SYNTAX_DEF_MISSING
			VAL v92;
			uint64_t v93;
			mw_mirth_elab_elabZ_defZ_missingZBang(x70, x71, &v92, &v93);
			x81 = v92;
			x80 = x69;
			x79 = v93;
		} break;
		case 108LL: { // PRIM_SYNTAX_DEF_TYPE
			VAL v94;
			uint64_t v95;
			mw_mirth_elab_elabZ_defZ_typeZBang(x70, x71, &v94, &v95);
			x81 = v94;
			x80 = x69;
			x79 = v95;
		} break;
		case 112LL: { // PRIM_SYNTAX_DEF_EXTERNAL
			STR* v96;
			STRLIT(v96, "def-external", 12);
			STR* v97;
			STRLIT(v97, "external", 8);
			VAL v98 = (mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang(x71, MKSTR(v96), MKSTR(v97), x70));
			VAL v99;
			uint64_t v100;
			mw_mirth_elab_elabZ_externalZBang(v98, x71, &v99, &v100);
			x81 = v99;
			x80 = x69;
			x79 = v100;
		} break;
		case 111LL: { // PRIM_SYNTAX_EXTERNAL
			VAL v101;
			uint64_t v102;
			mw_mirth_elab_elabZ_externalZBang(x70, x71, &v101, &v102);
			x81 = v101;
			x80 = x69;
			x79 = v102;
		} break;
		case 109LL: { // PRIM_SYNTAX_BUFFER
			VAL v103;
			uint64_t v104;
			mw_mirth_elab_elabZ_bufferZBang(x70, x71, &v103, &v104);
			x81 = v103;
			x80 = x69;
			x79 = v104;
		} break;
		case 110LL: { // PRIM_SYNTAX_VARIABLE
			VAL v105;
			uint64_t v106;
			mw_mirth_elab_elabZ_variableZBang(x70, x71, &v105, &v106);
			x81 = v105;
			x80 = x69;
			x79 = v106;
		} break;
		case 114LL: { // PRIM_SYNTAX_TABLE
			VAL v107;
			uint64_t v108;
			mw_mirth_elab_elabZ_tableZBang(x70, x71, &v107, &v108);
			x81 = v107;
			x80 = x69;
			x79 = v108;
		} break;
		case 115LL: { // PRIM_SYNTAX_FIELD
			VAL v109;
			uint64_t v110;
			mw_mirth_elab_elabZ_fieldZBang(x70, x71, &v109, &v110);
			x81 = v109;
			x80 = x69;
			x79 = v110;
		} break;
		case 116LL: { // PRIM_SYNTAX_DATA
			push_resource(MKI64(x69));
			uint64_t v111;
			VAL v112;
			mw_mirth_elab_elabZ_dataZBang(x70, x71, &v111, &v112);
			x81 = v112;
			int64_t r113 = VI64(pop_resource());
			x80 = r113;
			x79 = v111;
		} break;
		case 117LL: { // PRIM_SYNTAX_STRUCT
			push_resource(MKI64(x69));
			uint64_t v114;
			VAL v115;
			mw_mirth_elab_elabZ_structZBang(x70, x71, &v114, &v115);
			x81 = v115;
			int64_t r116 = VI64(pop_resource());
			x80 = r116;
			x79 = v114;
		} break;
		case 113LL: { // PRIM_SYNTAX_EMBED_STR
			uint64_t v117;
			int64_t v118;
			VAL v119;
			mw_mirth_elab_elabZ_embedZ_strZBang(x71, x69, x70, &v117, &v118, &v119);
			x81 = v119;
			x80 = v118;
			x79 = v117;
		} break;
		default: {
			STR* v120;
			STRLIT(v120, "unknown declaration", 19);
			push_resource(MKI64(x69));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x71, MKSTR(v120), x70);
			VAL r121 = pop_resource();
			x81 = r121;
			int64_t r122 = VI64(pop_resource());
			x80 = r122;
			uint64_t v123 = pop_u64();
			x79 = v123;
		} break;
	}
	*x6 = x81;
	*x5 = x80;
	*x4 = x79;
}
static void mw_mirth_elab_loadZ_module (uint64_t x1, VAL x2, int64_t x3, VAL x4, uint64_t *x5, uint64_t *x6, int64_t *x7, VAL *x8) {
	incref(x2);
	VAL v9;
	VAL v10;
	mw_mirth_name_QName_defZ_softZAsk(x4, x2, &v9, &v10);
	uint64_t x11;
	int64_t x12;
	VAL x13;
	uint64_t x14;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v16 = mw_mirth_def_Def_moduleZAsk(v15);
			uint64_t x17;
			int64_t x18;
			VAL x19;
			VAL x20;
			uint64_t x21;
			switch (get_data_tag(v16)) {
				case 1LL: { // Some
					VAL v22 = mtp_std_maybe_Maybe_1_Some(v16);
					x21 = VU64(v22);
					x20 = v9;
					x19 = x2;
					x18 = x3;
					x17 = x1;
				} break;
				case 0LL: { // None
					decref(x2);
					STR* v23;
					STRLIT(v23, "module name already taken", 25);
					push_resource(MKI64(x3));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x1, MKSTR(v23), v9);
					uint64_t v24 = pop_u64();
					x21 = v24;
					VAL r25 = pop_resource();
					x20 = r25;
					VAL v26 = pop_value();
					x19 = v26;
					int64_t r27 = VI64(pop_resource());
					x18 = r27;
					uint64_t v28 = pop_u64();
					x17 = v28;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x19);
			x14 = x21;
			x13 = x20;
			x12 = x18;
			x11 = x17;
		} break;
		case 0LL: { // None
			VAL v29;
			int64_t v30;
			VAL v31;
			mw_mirth_name_QName_toZ_moduleZ_path(x2, x3, v9, &v29, &v30, &v31);
			uint64_t v32;
			int64_t v33;
			VAL v34;
			mw_mirth_lexer_runZ_lexerZBang(v29, v30, v31, &v32, &v33, &v34);
			uint64_t v35;
			int64_t v36;
			VAL v37;
			mw_mirth_elab_elabZ_moduleZBang(v32, v33, v34, &v35, &v36, &v37);
			x14 = v35;
			x13 = v37;
			x12 = v36;
			x11 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x8 = x13;
	*x7 = x12;
	*x6 = x14;
	*x5 = x11;
}
static void mw_mirth_elab_elabZ_moduleZ_importZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6) {
	uint64_t v7 = mw_mirth_token_Token_next(x1);
	uint64_t v8;
	VAL v9;
	mw_mirth_token_Token_argsZ_1(x1, x3, &v8, &v9);
	VAL v10;
	VAL v11;
	mw_mirth_elab_elabZ_moduleZ_qname(v9, v8, &v10, &v11);
	uint64_t v12;
	uint64_t v13;
	int64_t v14;
	VAL v15;
	mw_mirth_elab_loadZ_module(v8, v11, x2, v10, &v12, &v13, &v14, &v15);
	uint64_t v16 = mw_mirth_token_Token_module(v12);
	mw_mirth_module_Module_addZ_importZBang(v16, v13);
	*x6 = v15;
	*x5 = v14;
	*x4 = v7;
}
static void mw_mirth_elab_parseZ_data (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	int64_t v6 = mw_mirth_token_Token_numZ_args(x2);
	int64_t v7 = 0LL;
	bool v8 = (v6 > v7);
	uint64_t x9;
	VAL x10;
	VAL x11;
	uint64_t x12;
	if (v8) {
		uint64_t v13 = mw_mirth_token_Token_succ(x2);
		VAL v14 = mw_mirth_token_Token_lparenZAsk(v13);
		VAL x15;
		uint64_t x16;
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				VAL v17 = mtp_std_maybe_Maybe_1_Some(v14);
				decref(v17);
				x16 = v13;
				x15 = x1;
			} break;
			case 0LL: { // None
				STR* v18;
				STRLIT(v18, "expected left parenthesis '('", 29);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v13, MKSTR(v18), x1);
				uint64_t v19 = pop_u64();
				x16 = v19;
				VAL r20 = pop_resource();
				x15 = r20;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v21 = mw_mirth_token_Token_succ(x16);
		VAL v22;
		uint64_t v23;
		uint64_t v24;
		mw_mirth_elab_parseZ_dataZ_header(x15, v21, &v22, &v23, &v24);
		int64_t v25 = mw_mirth_token_Token_commaZAsk(v23);
		VAL x26;
		uint64_t x27;
		uint64_t x28;
		if (((bool)v25)) {
			uint64_t v29 = mw_mirth_token_Token_succ(v23);
			x28 = v29;
			x27 = v24;
			x26 = v22;
		} else {
			x28 = v23;
			x27 = v24;
			x26 = v22;
		}
		VAL v30;
		uint64_t v31;
		VAL v32;
		mw_mirth_elab_parseZ_dataZ_tags(x26, x28, &v30, &v31, &v32);
		VAL v33 = mw_mirth_token_Token_rparenZAsk(v31);
		uint64_t x34;
		VAL x35;
		VAL x36;
		uint64_t x37;
		switch (get_data_tag(v33)) {
			case 1LL: { // Some
				VAL v38 = mtp_std_maybe_Maybe_1_Some(v33);
				decref(v38);
				x37 = v31;
				x36 = v32;
				x35 = v30;
				x34 = x27;
			} break;
			case 0LL: { // None
				STR* v39;
				STRLIT(v39, "expected right parenthesis ')'", 30);
				lpush(&lbl_header, MKU64(x27));
				lpush(&lbl_tags, v32);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v31, MKSTR(v39), v30);
				uint64_t v40 = pop_u64();
				x37 = v40;
				VAL v41 = lpop(&lbl_tags);
				x36 = v41;
				VAL r42 = pop_resource();
				x35 = r42;
				uint64_t v43 = VU64(lpop(&lbl_header));
				x34 = v43;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v44 = mw_mirth_token_Token_succ(x37);
		x12 = v44;
		x11 = x36;
		x10 = x35;
		x9 = x34;
	} else {
		uint64_t v45 = mw_mirth_token_Token_succ(x2);
		VAL v46;
		uint64_t v47;
		uint64_t v48;
		mw_mirth_elab_parseZ_dataZ_header(x1, v45, &v46, &v47, &v48);
		VAL v49 = mw_mirth_token_Token_lcurlyZAsk(v47);
		VAL x50;
		uint64_t x51;
		uint64_t x52;
		switch (get_data_tag(v49)) {
			case 1LL: { // Some
				VAL v53 = mtp_std_maybe_Maybe_1_Some(v49);
				decref(v53);
				x52 = v47;
				x51 = v48;
				x50 = v46;
			} break;
			case 0LL: { // None
				STR* v54;
				STRLIT(v54, "expected left curly brace '{'", 29);
				lpush(&lbl_header, MKU64(v48));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v47, MKSTR(v54), v46);
				uint64_t v55 = pop_u64();
				x52 = v55;
				uint64_t v56 = VU64(lpop(&lbl_header));
				x51 = v56;
				VAL r57 = pop_resource();
				x50 = r57;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v58 = mw_mirth_token_Token_succ(x52);
		VAL v59;
		uint64_t v60;
		VAL v61;
		mw_mirth_elab_parseZ_dataZ_tags(x50, v58, &v59, &v60, &v61);
		VAL v62 = mw_mirth_token_Token_rcurlyZAsk(v60);
		uint64_t x63;
		VAL x64;
		VAL x65;
		uint64_t x66;
		switch (get_data_tag(v62)) {
			case 1LL: { // Some
				VAL v67 = mtp_std_maybe_Maybe_1_Some(v62);
				decref(v67);
				x66 = v60;
				x65 = v61;
				x64 = v59;
				x63 = x51;
			} break;
			case 0LL: { // None
				STR* v68;
				STRLIT(v68, "expected right curly brace '}'", 30);
				lpush(&lbl_header, MKU64(x51));
				lpush(&lbl_tags, v61);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v60, MKSTR(v68), v59);
				uint64_t v69 = pop_u64();
				x66 = v69;
				VAL v70 = lpop(&lbl_tags);
				x65 = v70;
				VAL r71 = pop_resource();
				x64 = r71;
				uint64_t v72 = VU64(lpop(&lbl_header));
				x63 = v72;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v73 = mw_mirth_token_Token_succ(x66);
		x12 = v73;
		x11 = x65;
		x10 = x64;
		x9 = x63;
	}
	VAL v74 = mtw_mirth_elab_SyntaxData_SyntaxData(x9, x11);
	*x5 = v74;
	*x4 = x12;
	*x3 = x10;
}
static void mw_mirth_elab_parseZ_dataZ_header (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5) {
	uint64_t v6 = mw_mirth_token_Token_next(x2);
	VAL v7 = mw_mirth_token_Token_lastZ_nameZAsk(x2);
	VAL x8;
	uint64_t x9;
	uint64_t x10;
	int64_t x11;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v7);
			int64_t v13 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v12));
			x11 = v13;
			x10 = x2;
			x9 = v6;
			x8 = x1;
		} break;
		case 0LL: { // None
			int64_t v14 = 0LL /* False */;
			x11 = v14;
			x10 = x2;
			x9 = v6;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x15;
	uint64_t x16;
	uint64_t x17;
	if (((bool)x11)) {
		x17 = x10;
		x16 = x9;
		x15 = x8;
	} else {
		STR* v18;
		STRLIT(v18, "Expected type name.", 19);
		push_u64(x9);
		lpush(&lbl_head, MKU64(x10));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x10, MKSTR(v18), x8);
		uint64_t v19 = VU64(lpop(&lbl_head));
		x17 = v19;
		uint64_t v20 = pop_u64();
		x16 = v20;
		VAL r21 = pop_resource();
		x15 = r21;
	}
	*x5 = x17;
	*x4 = x16;
	*x3 = x15;
}
static void mw_mirth_elab_parseZ_dataZ_tags (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = mw_std_list_List_1_reverse(v6);
	int64_t v8 = mw_mirth_token_Token_argZ_endZAsk(x2);
	bool v9 = !((bool)v8);
	VAL v10 = (x1);
	uint64_t v11 = x2;
	VAL v12 = (v7);
	bool v13 = v9;
	while (v13) {
		VAL v14 = (v10);
		uint64_t v15 = v11;
		VAL v16 = (v12);
		VAL v17;
		uint64_t v18;
		VAL v19;
		mw_mirth_elab_parseZ_dataZ_tag(v14, v15, &v17, &v18, &v19);
		VAL v20 = mtw_std_list_List_1_Cons(v19, v16);
		int64_t v21 = mw_mirth_token_Token_argZ_endZAsk(v18);
		bool v22 = !((bool)v21);
		v13 = v22;
		v12 = v20;
		v11 = v18;
		v10 = v17;
	}
	VAL v23 = mw_std_list_List_1_reverse(v12);
	*x5 = v23;
	*x4 = v11;
	*x3 = v10;
}
static void mw_mirth_elab_parseZ_dataZ_tag (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	VAL v6 = mw_mirth_token_Token_intZAsk(x2);
	incref(v6);
	VAL x7;
	uint64_t x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v6);
			decref(v11);
			uint64_t v12 = mw_mirth_token_Token_succ(x2);
			x10 = v6;
			x9 = v12;
			x8 = x2;
			x7 = x1;
		} break;
		case 0LL: { // None
			x10 = v6;
			x9 = x2;
			x8 = x2;
			x7 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v13 = mw_mirth_token_Token_nameZAsk(x9);
	VAL x14;
	uint64_t x15;
	VAL x16;
	uint64_t x17;
	VAL x18;
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v19 = mtp_std_maybe_Maybe_1_Some(v13);
			incref(v19);
			int64_t v20 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v19));
			VAL x21;
			uint64_t x22;
			VAL x23;
			uint64_t x24;
			VAL x25;
			if (((bool)v20)) {
				VAL v26 = mtw_std_maybe_Maybe_1_Some(v19);
				x25 = v26;
				x24 = x9;
				x23 = x10;
				x22 = x8;
				x21 = x7;
			} else {
				decref(v19);
				VAL v27 = MKI64(0LL /* None */);
				x25 = v27;
				x24 = x9;
				x23 = x10;
				x22 = x8;
				x21 = x7;
			}
			x18 = x25;
			x17 = x24;
			x16 = x23;
			x15 = x22;
			x14 = x21;
		} break;
		case 0LL: { // None
			VAL v28 = MKI64(0LL /* None */);
			x18 = v28;
			x17 = x9;
			x16 = x10;
			x15 = x8;
			x14 = x7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x29;
	uint64_t x30;
	VAL x31;
	uint64_t x32;
	uint64_t x33;
	switch (get_data_tag(x18)) {
		case 1LL: { // Some
			VAL v34 = mtp_std_maybe_Maybe_1_Some(x18);
			x33 = VU64(v34);
			x32 = x17;
			x31 = x16;
			x30 = x15;
			x29 = x14;
		} break;
		case 0LL: { // None
			STR* v35;
			STRLIT(v35, "Expected constructor name.", 26);
			lpush(&lbl_head, MKU64(x15));
			lpush(&lbl_valueZAsk, x16);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x17, MKSTR(v35), x14);
			uint64_t v36 = pop_u64();
			x33 = v36;
			uint64_t v37 = pop_u64();
			x32 = v37;
			VAL v38 = lpop(&lbl_valueZAsk);
			x31 = v38;
			uint64_t v39 = VU64(lpop(&lbl_head));
			x30 = v39;
			VAL r40 = pop_resource();
			x29 = r40;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v41 = mw_mirth_token_Token_succ(x32);
	int64_t v42 = mw_mirth_token_Token_arrowZAsk(v41);
	VAL x43;
	uint64_t x44;
	VAL x45;
	uint64_t x46;
	VAL x47;
	uint64_t x48;
	if (((bool)v42)) {
		uint64_t v49 = mw_mirth_token_Token_succ(v41);
		VAL v50 = mtw_std_maybe_Maybe_1_Some(MKU64(v49));
		uint64_t v51 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(v49);
		int64_t v52 = mw_mirth_token_Token_argZ_endZAsk(v51);
		VAL x53;
		uint64_t x54;
		VAL x55;
		uint64_t x56;
		VAL x57;
		uint64_t x58;
		if (((bool)v52)) {
			x58 = v51;
			x57 = v50;
			x56 = x33;
			x55 = x31;
			x54 = x30;
			x53 = x29;
		} else {
			STR* v59;
			STRLIT(v59, "Expected comma.", 15);
			lpush(&lbl_head, MKU64(x30));
			lpush(&lbl_valueZAsk, x31);
			lpush(&lbl_name, MKU64(x33));
			lpush(&lbl_sigZAsk, v50);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v51, MKSTR(v59), x29);
			uint64_t v60 = pop_u64();
			x58 = v60;
			VAL v61 = lpop(&lbl_sigZAsk);
			x57 = v61;
			uint64_t v62 = VU64(lpop(&lbl_name));
			x56 = v62;
			VAL v63 = lpop(&lbl_valueZAsk);
			x55 = v63;
			uint64_t v64 = VU64(lpop(&lbl_head));
			x54 = v64;
			VAL r65 = pop_resource();
			x53 = r65;
		}
		x48 = x58;
		x47 = x57;
		x46 = x56;
		x45 = x55;
		x44 = x54;
		x43 = x53;
	} else {
		VAL v66 = mw_mirth_token_Token_lsquareZAsk(v41);
		VAL x67;
		uint64_t x68;
		VAL x69;
		uint64_t x70;
		VAL x71;
		uint64_t x72;
		switch (get_data_tag(v66)) {
			case 1LL: { // Some
				VAL v73 = mtp_std_maybe_Maybe_1_Some(v66);
				decref(v73);
				uint64_t v74 = mw_mirth_token_Token_succ(v41);
				VAL v75 = mtw_std_maybe_Maybe_1_Some(MKU64(v74));
				uint64_t v76 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(v74);
				VAL v77 = mw_mirth_token_Token_rsquareZAsk(v76);
				VAL x78;
				uint64_t x79;
				VAL x80;
				uint64_t x81;
				VAL x82;
				uint64_t x83;
				switch (get_data_tag(v77)) {
					case 1LL: { // Some
						VAL v84 = mtp_std_maybe_Maybe_1_Some(v77);
						decref(v84);
						x83 = v76;
						x82 = v75;
						x81 = x33;
						x80 = x31;
						x79 = x30;
						x78 = x29;
					} break;
					case 0LL: { // None
						STR* v85;
						STRLIT(v85, "Expected right square bracket ']'", 33);
						lpush(&lbl_head, MKU64(x30));
						lpush(&lbl_valueZAsk, x31);
						lpush(&lbl_name, MKU64(x33));
						lpush(&lbl_sigZAsk, v75);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v76, MKSTR(v85), x29);
						uint64_t v86 = pop_u64();
						x83 = v86;
						VAL v87 = lpop(&lbl_sigZAsk);
						x82 = v87;
						uint64_t v88 = VU64(lpop(&lbl_name));
						x81 = v88;
						VAL v89 = lpop(&lbl_valueZAsk);
						x80 = v89;
						uint64_t v90 = VU64(lpop(&lbl_head));
						x79 = v90;
						VAL r91 = pop_resource();
						x78 = r91;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				uint64_t v92 = mw_mirth_token_Token_succ(x83);
				x72 = v92;
				x71 = x82;
				x70 = x81;
				x69 = x80;
				x68 = x79;
				x67 = x78;
			} break;
			case 0LL: { // None
				VAL v93 = MKI64(0LL /* None */);
				x72 = v41;
				x71 = v93;
				x70 = x33;
				x69 = x31;
				x68 = x30;
				x67 = x29;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x48 = x72;
		x47 = x71;
		x46 = x70;
		x45 = x69;
		x44 = x68;
		x43 = x67;
	}
	int64_t v94 = mw_mirth_token_Token_commaZAsk(x48);
	VAL x95;
	uint64_t x96;
	VAL x97;
	uint64_t x98;
	VAL x99;
	uint64_t x100;
	if (((bool)v94)) {
		uint64_t v101 = mw_mirth_token_Token_succ(x48);
		x100 = v101;
		x99 = x47;
		x98 = x46;
		x97 = x45;
		x96 = x44;
		x95 = x43;
	} else {
		x100 = x48;
		x99 = x47;
		x98 = x46;
		x97 = x45;
		x96 = x44;
		x95 = x43;
	}
	VAL v102 = mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag(x96, x97, x98, x99);
	*x5 = v102;
	*x4 = x100;
	*x3 = x95;
}
static void mw_mirth_elab_parseZ_struct (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	int64_t v6 = mw_mirth_token_Token_numZ_args(x2);
	int64_t v7 = 0LL;
	bool v8 = (v6 > v7);
	VAL x9;
	uint64_t x10;
	VAL x11;
	uint64_t x12;
	if (v8) {
		uint64_t v13 = mw_mirth_token_Token_succ(x2);
		VAL v14 = mw_mirth_token_Token_lparenZAsk(v13);
		VAL x15;
		uint64_t x16;
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				VAL v17 = mtp_std_maybe_Maybe_1_Some(v14);
				decref(v17);
				STR* v18;
				STRLIT(v18, "Expected left parenthesis '('", 29);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v13, MKSTR(v18), x1);
				uint64_t v19 = pop_u64();
				x16 = v19;
				VAL r20 = pop_resource();
				x15 = r20;
			} break;
			case 0LL: { // None
				x16 = v13;
				x15 = x1;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v21 = mw_mirth_token_Token_succ(x16);
		VAL v22;
		uint64_t v23;
		uint64_t v24;
		mw_mirth_elab_parseZ_dataZ_header(x15, v21, &v22, &v23, &v24);
		int64_t v25 = mw_mirth_token_Token_commaZAsk(v23);
		VAL x26;
		uint64_t x27;
		uint64_t x28;
		if (((bool)v25)) {
			uint64_t v29 = mw_mirth_token_Token_succ(v23);
			x28 = v29;
			x27 = v24;
			x26 = v22;
		} else {
			x28 = v23;
			x27 = v24;
			x26 = v22;
		}
		VAL v30;
		uint64_t v31;
		uint64_t v32;
		VAL v33;
		mw_mirth_elab_parseZ_structZ_tag(x26, x28, x27, &v30, &v31, &v32, &v33);
		VAL v34 = MKI64(0LL /* Nil */);
		VAL v35 = mtw_std_list_List_1_Cons(v33, v34);
		VAL v36 = mw_mirth_token_Token_rparenZAsk(v31);
		VAL x37;
		uint64_t x38;
		VAL x39;
		uint64_t x40;
		switch (get_data_tag(v36)) {
			case 1LL: { // Some
				VAL v41 = mtp_std_maybe_Maybe_1_Some(v36);
				decref(v41);
				STR* v42;
				STRLIT(v42, "Expected right parenthesis ')'", 30);
				lpush(&lbl_header, MKU64(v32));
				lpush(&lbl_tags, v35);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v31, MKSTR(v42), v30);
				uint64_t v43 = pop_u64();
				x40 = v43;
				VAL v44 = lpop(&lbl_tags);
				x39 = v44;
				uint64_t v45 = VU64(lpop(&lbl_header));
				x38 = v45;
				VAL r46 = pop_resource();
				x37 = r46;
			} break;
			case 0LL: { // None
				x40 = v31;
				x39 = v35;
				x38 = v32;
				x37 = v30;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v47 = mw_mirth_token_Token_succ(x40);
		x12 = v47;
		x11 = x39;
		x10 = x38;
		x9 = x37;
	} else {
		uint64_t v48 = mw_mirth_token_Token_succ(x2);
		VAL v49;
		uint64_t v50;
		uint64_t v51;
		mw_mirth_elab_parseZ_dataZ_header(x1, v48, &v49, &v50, &v51);
		VAL v52 = mw_mirth_token_Token_lcurlyZAsk(v50);
		VAL x53;
		uint64_t x54;
		uint64_t x55;
		switch (get_data_tag(v52)) {
			case 1LL: { // Some
				VAL v56 = mtp_std_maybe_Maybe_1_Some(v52);
				decref(v56);
				x55 = v50;
				x54 = v51;
				x53 = v49;
			} break;
			case 0LL: { // None
				STR* v57;
				STRLIT(v57, "expected left curly brace '{'", 29);
				lpush(&lbl_header, MKU64(v51));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v50, MKSTR(v57), v49);
				uint64_t v58 = pop_u64();
				x55 = v58;
				uint64_t v59 = VU64(lpop(&lbl_header));
				x54 = v59;
				VAL r60 = pop_resource();
				x53 = r60;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v61 = mw_mirth_token_Token_succ(x55);
		VAL v62;
		uint64_t v63;
		uint64_t v64;
		VAL v65;
		mw_mirth_elab_parseZ_structZ_tag(x53, v61, x54, &v62, &v63, &v64, &v65);
		VAL v66 = MKI64(0LL /* Nil */);
		VAL v67 = mtw_std_list_List_1_Cons(v65, v66);
		VAL v68 = mw_mirth_token_Token_rcurlyZAsk(v63);
		VAL x69;
		uint64_t x70;
		VAL x71;
		uint64_t x72;
		switch (get_data_tag(v68)) {
			case 1LL: { // Some
				VAL v73 = mtp_std_maybe_Maybe_1_Some(v68);
				decref(v73);
				x72 = v63;
				x71 = v67;
				x70 = v64;
				x69 = v62;
			} break;
			case 0LL: { // None
				STR* v74;
				STRLIT(v74, "expected right curly brace '}'", 30);
				lpush(&lbl_header, MKU64(v64));
				lpush(&lbl_tags, v67);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v63, MKSTR(v74), v62);
				uint64_t v75 = pop_u64();
				x72 = v75;
				VAL v76 = lpop(&lbl_tags);
				x71 = v76;
				uint64_t v77 = VU64(lpop(&lbl_header));
				x70 = v77;
				VAL r78 = pop_resource();
				x69 = r78;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v79 = mw_mirth_token_Token_succ(x72);
		x12 = v79;
		x11 = x71;
		x10 = x70;
		x9 = x69;
	}
	VAL v80 = mtw_mirth_elab_SyntaxData_SyntaxData(x10, x11);
	*x5 = v80;
	*x4 = x12;
	*x3 = x9;
}
static void mw_mirth_elab_parseZ_structZ_tag (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, uint64_t *x5, uint64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_token_Token_lastZ_nameZAsk(x3);
	VAL x9;
	uint64_t x10;
	uint64_t x11;
	uint64_t x12;
	VAL x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			incref(v14);
			int64_t v15 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v14));
			VAL x16;
			uint64_t x17;
			uint64_t x18;
			uint64_t x19;
			VAL x20;
			if (((bool)v15)) {
				VAL v21 = mtw_std_maybe_Maybe_1_Some(v14);
				x20 = v21;
				x19 = x3;
				x18 = x3;
				x17 = x2;
				x16 = x1;
			} else {
				decref(v14);
				VAL v22 = MKI64(0LL /* None */);
				x20 = v22;
				x19 = x3;
				x18 = x3;
				x17 = x2;
				x16 = x1;
			}
			x13 = x20;
			x12 = x19;
			x11 = x18;
			x10 = x17;
			x9 = x16;
		} break;
		case 0LL: { // None
			VAL v23 = MKI64(0LL /* None */);
			x13 = v23;
			x12 = x3;
			x11 = x3;
			x10 = x2;
			x9 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x24;
	uint64_t x25;
	uint64_t x26;
	uint64_t x27;
	uint64_t x28;
	switch (get_data_tag(x13)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(x13);
			x28 = VU64(v29);
			x27 = x12;
			x26 = x11;
			x25 = x10;
			x24 = x9;
		} break;
		case 0LL: { // None
			STR* v30;
			STRLIT(v30, "Expected constructor name.", 26);
			push_u64(x10);
			lpush(&lbl_head, MKU64(x12));
			lpush(&lbl_header, MKU64(x11));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x11, MKSTR(v30), x9);
			uint64_t v31 = pop_u64();
			x28 = v31;
			uint64_t v32 = VU64(lpop(&lbl_head));
			x27 = v32;
			uint64_t v33 = VU64(lpop(&lbl_header));
			x26 = v33;
			uint64_t v34 = pop_u64();
			x25 = v34;
			VAL r35 = pop_resource();
			x24 = r35;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v36 = MKI64(0LL /* None */);
	VAL v37 = mtw_std_maybe_Maybe_1_Some(MKU64(x25));
	uint64_t v38 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(x25);
	VAL v39 = mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag(x27, v36, x28, v37);
	*x7 = v39;
	*x6 = x26;
	*x5 = v38;
	*x4 = x24;
}
static void mw_mirth_elab_elabZ_dataZBang (VAL x1, uint64_t x2, uint64_t *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	VAL v7;
	mw_mirth_elab_parseZ_data(x1, x2, &v5, &v6, &v7);
	VAL v8 = (mw_mirth_elab_elabZ_dataZ_auxZBang(v7, v5));
	*x4 = v8;
	*x3 = v6;
}
static void mw_mirth_elab_elabZ_structZBang (VAL x1, uint64_t x2, uint64_t *x3, VAL *x4) {
	VAL v5;
	uint64_t v6;
	VAL v7;
	mw_mirth_elab_parseZ_struct(x1, x2, &v5, &v6, &v7);
	VAL v8 = (mw_mirth_elab_elabZ_dataZ_auxZBang(v7, v5));
	*x4 = v8;
	*x3 = v6;
}
static VAL mw_mirth_elab_elabZ_dataZ_auxZBang (VAL x1, VAL x2) {
	uint64_t v3;
	VAL v4;
	mtp_mirth_elab_SyntaxData_SyntaxData(x1, &v3, &v4);
	uint64_t v5 = mw_mirth_data_Data_allocZBang();
	VAL v6 = MKI64(0LL /* Nil */);
	void* v7 = mfld_mirth_data_Data_ZTildetags(v5);
	mut_set(v6, v7);
	uint64_t v8;
	VAL v9;
	mw_mirth_elab_elabZ_dataZ_headerZBang(v5, v3, x2, &v8, &v9);
	VAL v10;
	VAL v11;
	mw_std_list_List_1_uncons(v4, &v10, &v11);
	uint64_t x12;
	VAL x13;
	VAL x14;
	int64_t x15;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v10);
			uint64_t v17;
			VAL v18;
			mw_mirth_elab_elabZ_dataZ_tagZBang(v8, v16, v9, &v17, &v18);
			int64_t v19 = 1LL /* True */;
			x15 = v19;
			x14 = v11;
			x13 = v18;
			x12 = v17;
		} break;
		case 0LL: { // None
			int64_t v20 = 0LL /* False */;
			x15 = v20;
			x14 = v11;
			x13 = v9;
			x12 = v8;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v21 = x12;
	VAL v22 = (x13);
	VAL v23 = x14;
	int64_t v24 = x15;
	while (((bool)v24)) {
		uint64_t v25 = v21;
		VAL v26 = (v22);
		VAL v27 = v23;
		VAL v28;
		VAL v29;
		mw_std_list_List_1_uncons(v27, &v28, &v29);
		uint64_t x30;
		VAL x31;
		VAL x32;
		int64_t x33;
		switch (get_data_tag(v28)) {
			case 1LL: { // Some
				VAL v34 = mtp_std_maybe_Maybe_1_Some(v28);
				uint64_t v35;
				VAL v36;
				mw_mirth_elab_elabZ_dataZ_tagZBang(v25, v34, v26, &v35, &v36);
				int64_t v37 = 1LL /* True */;
				x33 = v37;
				x32 = v29;
				x31 = v36;
				x30 = v35;
			} break;
			case 0LL: { // None
				int64_t v38 = 0LL /* False */;
				x33 = v38;
				x32 = v29;
				x31 = v26;
				x30 = v25;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v24 = x33;
		v23 = x32;
		v22 = x31;
		v21 = x30;
	}
	decref(v23);
	VAL v39 = (mw_mirth_elab_elabZ_dataZ_doneZBang(v22, v21));
	return v39;
}
static void mw_mirth_elab_elabZ_dataZ_headerZBang (uint64_t x1, uint64_t x2, VAL x3, uint64_t *x4, VAL *x5) {
	VAL v6 = mw_mirth_token_Token_lastZ_nameZAsk(x2);
	VAL x7;
	uint64_t x8;
	uint64_t x9;
	int64_t x10;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v6);
			int64_t v12 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v11));
			x10 = v12;
			x9 = x2;
			x8 = x1;
			x7 = x3;
		} break;
		case 0LL: { // None
			int64_t v13 = 0LL /* False */;
			x10 = v13;
			x9 = x2;
			x8 = x1;
			x7 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x14;
	uint64_t x15;
	uint64_t x16;
	if (((bool)x10)) {
		x16 = x9;
		x15 = x8;
		x14 = x7;
	} else {
		STR* v17;
		STRLIT(v17, "Expected type name.", 19);
		lpush(&lbl_data, MKU64(x8));
		lpush(&lbl_head, MKU64(x9));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x9, MKSTR(v17), x7);
		uint64_t v18 = VU64(lpop(&lbl_head));
		x16 = v18;
		uint64_t v19 = VU64(lpop(&lbl_data));
		x15 = v19;
		VAL r20 = pop_resource();
		x14 = r20;
	}
	VAL v21;
	uint64_t v22;
	uint64_t v23;
	int64_t v24;
	VAL v25;
	mw_mirth_elab_elabZ_defZ_head(x14, x16, &v21, &v22, &v23, &v24, &v25);
	VAL v26 = mtw_std_maybe_Maybe_1_Some(MKU64(v22));
	void* v27 = mfld_mirth_data_Data_ZTildeheadZAsk(x15);
	mut_set(v26, v27);
	void* v28 = mfld_mirth_data_Data_ZTildearity(x15);
	mut_set(MKI64(v24), v28);
	void* v29 = mfld_mirth_data_Data_ZTildename(x15);
	mut_set(MKU64(v23), v29);
	VAL v30 = mtw_mirth_mirth_PropLabel_DataQName(x15);
	VAL v31 = mtw_mirth_mirth_Prop_1_Prop(v30, v25);
	void* v32 = mfld_mirth_data_Data_ZTildeqname(x15);
	mut_set(v31, v32);
	VAL v33 = mw_mirth_token_Token_args(v22);
	VAL v34 = mtw_mirth_mirth_PropLabel_DataParams(x15);
	FNPTR v35 = &mb_mirth_elab_elabZ_dataZ_headerZBang_2;
	VAL v36;
	VAL v37;
	mw_mirth_mirth_PropLabel_prop_1(v33, v34, v21, MKFNPTR(v35), &v36, &v37);
	void* v38 = mfld_mirth_data_Data_ZTildeparams(x15);
	mut_set(v36, v38);
	VAL v39 = mtw_mirth_def_Def_DefData(x15);
	VAL v40 = (mw_mirth_def_Def_register(v37, v39));
	*x5 = v40;
	*x4 = x15;
}
static void mw_mirth_elab_elabZ_dataZ_paramsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_var_Ctx0();
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(x1, &v6, &v7);
	VAL x8;
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v6);
			incref(v12);
			VAL v13 = mw_mirth_token_Token_sigZ_typeZ_varZAsk(VU64(v12));
			VAL x14;
			VAL x15;
			uint64_t x16;
			uint64_t x17;
			switch (get_data_tag(v13)) {
				case 1LL: { // Some
					VAL v18 = mtp_std_maybe_Maybe_1_Some(v13);
					x17 = VU64(v18);
					x16 = VU64(v12);
					x15 = v5;
					x14 = x2;
				} break;
				case 0LL: { // None
					STR* v19;
					STRLIT(v19, "Expected a type variable.", 25);
					push_value(v5);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v12), MKSTR(v19), x2);
					uint64_t v20 = pop_u64();
					x17 = v20;
					uint64_t v21 = pop_u64();
					x16 = v21;
					VAL v22 = pop_value();
					x15 = v22;
					VAL r23 = pop_resource();
					x14 = r23;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			incref(x15);
			VAL v24 = mw_mirth_var_Ctx_lookup(x17, x15);
			VAL x25;
			VAL x26;
			uint64_t x27;
			uint64_t x28;
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v29 = mtp_std_maybe_Maybe_1_Some(v24);
					decref(v29);
					STR* v30;
					STRLIT(v30, "Duplicate parameter name.", 25);
					push_value(x15);
					push_u64(x17);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x16, MKSTR(v30), x14);
					uint64_t v31 = pop_u64();
					x28 = v31;
					uint64_t v32 = pop_u64();
					x27 = v32;
					VAL v33 = pop_value();
					x26 = v33;
					VAL r34 = pop_resource();
					x25 = r34;
				} break;
				case 0LL: { // None
					x28 = x17;
					x27 = x16;
					x26 = x15;
					x25 = x14;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v35 = mw_mirth_type_TYPEz_TYPE();
			uint64_t v36 = mw_mirth_var_Var_newZBang(v35, x28);
			VAL v37 = mw_mirth_var_Ctx_new(x26, v36);
			int64_t v38 = 1LL /* True */;
			x11 = v38;
			x10 = v7;
			x9 = v37;
			x8 = x25;
		} break;
		case 0LL: { // None
			int64_t v39 = 0LL /* False */;
			x11 = v39;
			x10 = v7;
			x9 = v5;
			x8 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v40 = (x8);
	VAL v41 = x9;
	VAL v42 = x10;
	int64_t v43 = x11;
	while (((bool)v43)) {
		VAL v44 = (v40);
		VAL v45 = v41;
		VAL v46 = v42;
		VAL v47;
		VAL v48;
		mw_std_list_List_1_uncons(v46, &v47, &v48);
		VAL x49;
		VAL x50;
		VAL x51;
		int64_t x52;
		switch (get_data_tag(v47)) {
			case 1LL: { // Some
				VAL v53 = mtp_std_maybe_Maybe_1_Some(v47);
				incref(v53);
				VAL v54 = mw_mirth_token_Token_sigZ_typeZ_varZAsk(VU64(v53));
				VAL x55;
				VAL x56;
				uint64_t x57;
				uint64_t x58;
				switch (get_data_tag(v54)) {
					case 1LL: { // Some
						VAL v59 = mtp_std_maybe_Maybe_1_Some(v54);
						x58 = VU64(v59);
						x57 = VU64(v53);
						x56 = v45;
						x55 = v44;
					} break;
					case 0LL: { // None
						STR* v60;
						STRLIT(v60, "Expected a type variable.", 25);
						push_value(v45);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v53), MKSTR(v60), v44);
						uint64_t v61 = pop_u64();
						x58 = v61;
						uint64_t v62 = pop_u64();
						x57 = v62;
						VAL v63 = pop_value();
						x56 = v63;
						VAL r64 = pop_resource();
						x55 = r64;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				incref(x56);
				VAL v65 = mw_mirth_var_Ctx_lookup(x58, x56);
				VAL x66;
				VAL x67;
				uint64_t x68;
				uint64_t x69;
				switch (get_data_tag(v65)) {
					case 1LL: { // Some
						VAL v70 = mtp_std_maybe_Maybe_1_Some(v65);
						decref(v70);
						STR* v71;
						STRLIT(v71, "Duplicate parameter name.", 25);
						push_value(x56);
						push_u64(x58);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x57, MKSTR(v71), x55);
						uint64_t v72 = pop_u64();
						x69 = v72;
						uint64_t v73 = pop_u64();
						x68 = v73;
						VAL v74 = pop_value();
						x67 = v74;
						VAL r75 = pop_resource();
						x66 = r75;
					} break;
					case 0LL: { // None
						x69 = x58;
						x68 = x57;
						x67 = x56;
						x66 = x55;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v76 = mw_mirth_type_TYPEz_TYPE();
				uint64_t v77 = mw_mirth_var_Var_newZBang(v76, x69);
				VAL v78 = mw_mirth_var_Ctx_new(x67, v77);
				int64_t v79 = 1LL /* True */;
				x52 = v79;
				x51 = v48;
				x50 = v78;
				x49 = x66;
			} break;
			case 0LL: { // None
				int64_t v80 = 0LL /* False */;
				x52 = v80;
				x51 = v48;
				x50 = v45;
				x49 = v44;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v43 = x52;
		v42 = x51;
		v41 = x50;
		v40 = x49;
	}
	decref(v42);
	VAL v81 = mw_mirth_var_Ctx_ZToList(v41);
	*x4 = v40;
	*x3 = v81;
}
static void mw_mirth_elab_elabZ_dataZ_tagZBang (uint64_t x1, VAL x2, VAL x3, uint64_t *x4, VAL *x5) {
	uint64_t v6 = mw_mirth_data_Tag_allocZBang();
	incref(x2);
	uint64_t v7 = VU64(VTUP(x2)->cells[3]);
	decref(x2);
	int64_t v8 = 0LL;
	VAL v9 = mw_mirth_data_dataZ_qname(x1, v7, v8);
	void* v10 = mfld_mirth_data_Tag_ZTildeqname(v6);
	mut_set(v9, v10);
	incref(x2);
	VAL v11 = VVAL(VTUP(x2)->cells[4]);
	incref(v11);
	decref(x2);
	void* v12 = mfld_mirth_data_Tag_ZTildesigZAsk(v6);
	mut_set(v11, v12);
	incref(x2);
	VAL v13 = VVAL(VTUP(x2)->cells[2]);
	incref(v13);
	decref(x2);
	VAL x14;
	uint64_t x15;
	uint64_t x16;
	VAL x17;
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v18 = mtp_std_maybe_Maybe_1_Some(v13);
			void* v19 = mfld_mirth_data_Tag_ZTildevalue(v6);
			mut_set(v18, v19);
			x17 = x2;
			x16 = v6;
			x15 = x1;
			x14 = x3;
		} break;
		case 0LL: { // None
			x17 = x2;
			x16 = v6;
			x15 = x1;
			x14 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	void* v20 = mfld_mirth_data_Tag_ZTildedata(x16);
	mut_set(MKU64(x15), v20);
	VAL v21 = (mw_mirth_data_Data_addZ_tagZBang(x14, x16, x15));
	VAL v22 = mtw_mirth_def_Def_DefTag(x16);
	VAL v23 = (mw_mirth_def_Def_register(v21, v22));
	incref(x17);
	uint64_t v24 = VU64(VTUP(x17)->cells[1]);
	decref(x17);
	VAL v25 = mtw_mirth_mirth_PropLabel_TagType(x16);
	VAL v26 = MKNIL;
	VAL v27 = mkcons(v26, MKU64(v24));
	VAL v28 = mkcons(v27, MKU64(x16));
	FNPTR v29 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_dataZ_tagZBangZDot42ZRParen_1;
	VAL v30;
	VAL v31;
	mw_mirth_mirth_PropLabel_prop_1(v28, v25, v23, MKFNPTR(v29), &v30, &v31);
	void* v32 = mfld_mirth_data_Tag_ZTildectxZ_type(x16);
	mut_set(v30, v32);
	int64_t v33 = mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig(x16);
	void* v34 = mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs(x16);
	mut_set(MKI64(v33), v34);
	int64_t v35 = mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig(x16);
	void* v36 = mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs(x16);
	mut_set(MKI64(v35), v36);
	VAL v37 = mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig(x16);
	void* v38 = mfld_mirth_data_Tag_ZTildelabelZ_inputs(x16);
	mut_set(v37, v38);
	int64_t v39 = mw_mirth_data_Tag_outputsZ_resourceZAsk(x16);
	bool v40 = !((bool)v39);
	uint64_t x41;
	VAL x42;
	VAL x43;
	uint64_t x44;
	if (v40) {
		VAL v45 = mw_mirth_data_Tag_sigZAsk(x16);
		uint64_t x46;
		VAL x47;
		VAL x48;
		uint64_t x49;
		switch (get_data_tag(v45)) {
			case 1LL: { // Some
				VAL v50 = mtp_std_maybe_Maybe_1_Some(v45);
				VAL v51 = mw_mirth_token_Token_runZ_tokens(VU64(v50));
				VAL v52 = MKI64(0LL /* None */);
				VAL v53;
				VAL v54;
				mw_std_list_List_1_uncons(v51, &v53, &v54);
				uint64_t x55;
				VAL x56;
				VAL x57;
				uint64_t x58;
				VAL x59;
				VAL x60;
				int64_t x61;
				switch (get_data_tag(v53)) {
					case 1LL: { // Some
						VAL v62 = mtp_std_maybe_Maybe_1_Some(v53);
						incref(v62);
						incref(v62);
						VAL v63 = mw_mirth_token_Token_sigZ_resourceZ_conZAsk(VU64(v62));
						int64_t v64 = mw_std_maybe_Maybe_1_ZToBool(v63);
						uint64_t x65;
						VAL x66;
						VAL x67;
						uint64_t x68;
						int64_t x69;
						if (((bool)v64)) {
							decref(v62);
							int64_t v70 = 1LL /* True */;
							x69 = v70;
							x68 = x16;
							x67 = v31;
							x66 = x17;
							x65 = x15;
						} else {
							VAL v71 = mw_mirth_token_Token_sigZ_resourceZ_varZAsk(VU64(v62));
							int64_t v72 = mw_std_maybe_Maybe_1_ZToBool(v71);
							x69 = v72;
							x68 = x16;
							x67 = v31;
							x66 = x17;
							x65 = x15;
						}
						uint64_t x73;
						VAL x74;
						VAL x75;
						uint64_t x76;
						VAL x77;
						if (((bool)x69)) {
							VAL v78 = mtw_std_maybe_Maybe_1_Some(v62);
							x77 = v78;
							x76 = x68;
							x75 = x67;
							x74 = x66;
							x73 = x65;
						} else {
							decref(v62);
							VAL v79 = MKI64(0LL /* None */);
							x77 = v79;
							x76 = x68;
							x75 = x67;
							x74 = x66;
							x73 = x65;
						}
						uint64_t x80;
						VAL x81;
						VAL x82;
						uint64_t x83;
						VAL x84;
						VAL x85;
						switch (get_data_tag(x77)) {
							case 0LL: { // None
								x85 = v54;
								x84 = v52;
								x83 = x76;
								x82 = x75;
								x81 = x74;
								x80 = x73;
							} break;
							default: {
								decref(v54);
								decref(v52);
								VAL v86 = MKI64(0LL /* Nil */);
								x85 = v86;
								x84 = x77;
								x83 = x76;
								x82 = x75;
								x81 = x74;
								x80 = x73;
							} break;
						}
						int64_t v87 = 1LL /* True */;
						x61 = v87;
						x60 = x85;
						x59 = x84;
						x58 = x83;
						x57 = x82;
						x56 = x81;
						x55 = x80;
					} break;
					case 0LL: { // None
						int64_t v88 = 0LL /* False */;
						x61 = v88;
						x60 = v54;
						x59 = v52;
						x58 = x16;
						x57 = v31;
						x56 = x17;
						x55 = x15;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				uint64_t v89 = x55;
				VAL v90 = x56;
				VAL v91 = (x57);
				uint64_t v92 = x58;
				VAL v93 = x59;
				VAL v94 = x60;
				int64_t v95 = x61;
				while (((bool)v95)) {
					uint64_t v96 = v89;
					VAL v97 = v90;
					VAL v98 = (v91);
					uint64_t v99 = v92;
					VAL v100 = v93;
					VAL v101 = v94;
					VAL v102;
					VAL v103;
					mw_std_list_List_1_uncons(v101, &v102, &v103);
					uint64_t x104;
					VAL x105;
					VAL x106;
					uint64_t x107;
					VAL x108;
					VAL x109;
					int64_t x110;
					switch (get_data_tag(v102)) {
						case 1LL: { // Some
							VAL v111 = mtp_std_maybe_Maybe_1_Some(v102);
							incref(v111);
							incref(v111);
							VAL v112 = mw_mirth_token_Token_sigZ_resourceZ_conZAsk(VU64(v111));
							int64_t v113 = mw_std_maybe_Maybe_1_ZToBool(v112);
							uint64_t x114;
							VAL x115;
							VAL x116;
							uint64_t x117;
							int64_t x118;
							if (((bool)v113)) {
								decref(v111);
								int64_t v119 = 1LL /* True */;
								x118 = v119;
								x117 = v99;
								x116 = v98;
								x115 = v97;
								x114 = v96;
							} else {
								VAL v120 = mw_mirth_token_Token_sigZ_resourceZ_varZAsk(VU64(v111));
								int64_t v121 = mw_std_maybe_Maybe_1_ZToBool(v120);
								x118 = v121;
								x117 = v99;
								x116 = v98;
								x115 = v97;
								x114 = v96;
							}
							uint64_t x122;
							VAL x123;
							VAL x124;
							uint64_t x125;
							VAL x126;
							if (((bool)x118)) {
								VAL v127 = mtw_std_maybe_Maybe_1_Some(v111);
								x126 = v127;
								x125 = x117;
								x124 = x116;
								x123 = x115;
								x122 = x114;
							} else {
								decref(v111);
								VAL v128 = MKI64(0LL /* None */);
								x126 = v128;
								x125 = x117;
								x124 = x116;
								x123 = x115;
								x122 = x114;
							}
							uint64_t x129;
							VAL x130;
							VAL x131;
							uint64_t x132;
							VAL x133;
							VAL x134;
							switch (get_data_tag(x126)) {
								case 0LL: { // None
									x134 = v103;
									x133 = v100;
									x132 = x125;
									x131 = x124;
									x130 = x123;
									x129 = x122;
								} break;
								default: {
									decref(v103);
									decref(v100);
									VAL v135 = MKI64(0LL /* Nil */);
									x134 = v135;
									x133 = x126;
									x132 = x125;
									x131 = x124;
									x130 = x123;
									x129 = x122;
								} break;
							}
							int64_t v136 = 1LL /* True */;
							x110 = v136;
							x109 = x134;
							x108 = x133;
							x107 = x132;
							x106 = x131;
							x105 = x130;
							x104 = x129;
						} break;
						case 0LL: { // None
							int64_t v137 = 0LL /* False */;
							x110 = v137;
							x109 = v103;
							x108 = v100;
							x107 = v99;
							x106 = v98;
							x105 = v97;
							x104 = v96;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v95 = x110;
					v94 = x109;
					v93 = x108;
					v92 = x107;
					v91 = x106;
					v90 = x105;
					v89 = x104;
				}
				decref(v94);
				uint64_t x138;
				VAL x139;
				VAL x140;
				uint64_t x141;
				switch (get_data_tag(v93)) {
					case 1LL: { // Some
						VAL v142 = mtp_std_maybe_Maybe_1_Some(v93);
						STR* v143;
						STRLIT(v143, "Value type cannot contain resource.", 35);
						VAL v144 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(VU64(v142), MKSTR(v143), v91));
						x141 = v92;
						x140 = v144;
						x139 = v90;
						x138 = v89;
					} break;
					case 0LL: { // None
						x141 = v92;
						x140 = v91;
						x139 = v90;
						x138 = v89;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x49 = x141;
				x48 = x140;
				x47 = x139;
				x46 = x138;
			} break;
			case 0LL: { // None
				x49 = x16;
				x48 = v31;
				x47 = x17;
				x46 = x15;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x44 = x49;
		x43 = x48;
		x42 = x47;
		x41 = x46;
	} else {
		x44 = x16;
		x43 = v31;
		x42 = x17;
		x41 = x15;
	}
	decref(x42);
	*x5 = x43;
	*x4 = x41;
}
static void mw_mirth_elab_dataZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, uint64_t *x6) {
	incref(x3);
	uint64_t v7 = mw_std_prim_Str_ZToName(x3);
	VAL v8 = mw_mirth_data_Data_headZAsk(x2);
	VAL x9;
	int64_t x10;
	uint64_t x11;
	uint64_t x12;
	uint64_t x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			x13 = VU64(v14);
			x12 = x2;
			x11 = v7;
			x10 = x4;
			x9 = x1;
		} break;
		case 0LL: { // None
			STR* v15;
			STRLIT(v15, "Missing data token information.", 31);
			lpush(&lbl_arity, MKI64(x4));
			lpush(&lbl_name, MKU64(v7));
			push_u64(x2);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v15), x1);
			uint64_t v16 = pop_u64();
			x13 = v16;
			uint64_t v17 = pop_u64();
			x12 = v17;
			uint64_t v18 = VU64(lpop(&lbl_name));
			x11 = v18;
			int64_t v19 = VI64(lpop(&lbl_arity));
			x10 = v19;
			VAL r20 = pop_resource();
			x9 = r20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v21 = mw_mirth_data_dataZ_wordZ_qname(x12, x3, x4);
	VAL v22 = MKI64(0LL /* None */);
	uint64_t v23;
	VAL v24;
	mw_mirth_word_Word_newZBang(x13, v22, x13, x11, x10, x9, &v23, &v24);
	VAL v25 = mtw_mirth_mirth_PropLabel_WordQName(v23);
	VAL v26;
	VAL v27;
	mw_mirth_mirth_PropLabel_prop(v21, v25, v24, &v26, &v27);
	void* v28 = mfld_mirth_word_Word_ZTildeqname(v23);
	mut_set(v26, v28);
	*x6 = v23;
	*x5 = v27;
}
static VAL mw_mirth_elab_elabZ_dataZ_doneZBang (VAL x1, uint64_t x2) {
	int64_t v3 = mw_mirth_data_Data_isZ_valueZ_typeZAsk(x2);
	VAL x4;
	uint64_t x5;
	if (((bool)v3)) {
		STR* v6;
		STRLIT(v6, "tag", 3);
		int64_t v7 = 0LL;
		VAL v8;
		uint64_t v9;
		mw_mirth_elab_dataZ_wordZ_newZBang(x1, x2, MKSTR(v6), v7, &v8, &v9);
		VAL v10;
		VAL v11;
		mw_mirth_data_Data_params(v8, x2, &v10, &v11);
		VAL v12 = mw_std_list_List_1_ZToCtx(v11);
		VAL v13;
		VAL v14;
		mw_mirth_elab_dataZ_getZ_tagZ_type(v10, x2, &v13, &v14);
		VAL v15 = mtw_mirth_mirth_PropLabel_WordType(v9);
		VAL v16;
		VAL v17;
		mw_mirth_mirth_PropLabel_prop2(v12, v14, v15, v13, &v16, &v17);
		void* v18 = mfld_mirth_word_Word_ZTildectxZ_type(v9);
		mut_set(v16, v18);
		VAL v19;
		VAL v20;
		VAL v21;
		uint64_t v22;
		VAL v23;
		uint64_t v24;
		mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v17, v9, &v19, &v20, &v21, &v22, &v23, &v24);
		VAL v25;
		VAL v26;
		mw_mirth_type_ArrowType_unpack(v21, &v25, &v26);
		incref(v25);
		VAL v27 = MKI64(0LL /* Nil */);
		VAL v28 = mtw_mirth_arrow_Arrow_Arrow(v23, v22, v22, v20, v25, v25, v27);
		VAL v29 = mtw_mirth_arrow_Op_OpDataGetTag(x2);
		VAL v30;
		VAL v31;
		mw_mirth_elab_abZ_opZBang(v29, v19, v28, &v30, &v31);
		VAL v32;
		VAL v33;
		mw_mirth_elab_abZ_unifyZ_typeZBang(v26, v30, v31, &v32, &v33);
		VAL v34;
		VAL v35;
		mw_mirth_elab_finalizzeZ_wordZ_arrow(v32, v33, v24, &v34, &v35);
		VAL v36 = mtw_mirth_mirth_PropLabel_WordArrow(v9);
		VAL v37;
		VAL v38;
		mw_mirth_mirth_PropLabel_prop(v35, v36, v34, &v37, &v38);
		void* v39 = mfld_mirth_word_Word_ZTildearrow(v9);
		mut_set(v37, v39);
		mw_mirth_word_Word_makeZ_inlineZBang(v9);
		x5 = x2;
		x4 = v38;
	} else {
		x5 = x2;
		x4 = x1;
	}
	int64_t v40 = mw_mirth_data_Data_isZ_enumZAsk(x5);
	VAL x41;
	uint64_t x42;
	if (((bool)v40)) {
		STR* v43;
		STRLIT(v43, "from-tag-unsafe", 15);
		int64_t v44 = 0LL;
		VAL v45;
		uint64_t v46;
		mw_mirth_elab_dataZ_wordZ_newZBang(x4, x5, MKSTR(v43), v44, &v45, &v46);
		VAL v47 = mw_mirth_var_Ctx0();
		VAL v48 = mw_mirth_type_TYPEz_INT();
		VAL v49 = mw_mirth_type_T1(v48);
		VAL v50 = mtw_mirth_type_Type_TData(x5);
		VAL v51 = mw_mirth_type_T1(v50);
		VAL v52 = mw_mirth_type_TZ_ZTo(v49, v51);
		VAL v53 = mtw_mirth_mirth_PropLabel_WordType(v46);
		VAL v54;
		VAL v55;
		mw_mirth_mirth_PropLabel_prop2(v47, v52, v53, v45, &v54, &v55);
		void* v56 = mfld_mirth_word_Word_ZTildectxZ_type(v46);
		mut_set(v54, v56);
		VAL v57;
		VAL v58;
		VAL v59;
		uint64_t v60;
		VAL v61;
		uint64_t v62;
		mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v55, v46, &v57, &v58, &v59, &v60, &v61, &v62);
		VAL v63;
		VAL v64;
		mw_mirth_type_ArrowType_unpack(v59, &v63, &v64);
		incref(v63);
		VAL v65 = MKI64(0LL /* Nil */);
		VAL v66 = mtw_mirth_arrow_Arrow_Arrow(v61, v60, v60, v58, v63, v63, v65);
		int64_t v67 = 0LL /* CoerceUnsafe */;
		VAL v68;
		VAL v69;
		mw_mirth_elab_abZ_coerceZBang(v67, v57, v66, &v68, &v69);
		VAL v70;
		VAL v71;
		mw_mirth_elab_abZ_unifyZ_typeZBang(v64, v68, v69, &v70, &v71);
		VAL v72;
		VAL v73;
		mw_mirth_elab_finalizzeZ_wordZ_arrow(v70, v71, v62, &v72, &v73);
		VAL v74 = mtw_mirth_mirth_PropLabel_WordArrow(v46);
		VAL v75;
		VAL v76;
		mw_mirth_mirth_PropLabel_prop(v73, v74, v72, &v75, &v76);
		void* v77 = mfld_mirth_word_Word_ZTildearrow(v46);
		mut_set(v75, v77);
		mw_mirth_word_Word_makeZ_inlineZBang(v46);
		x42 = x5;
		x41 = v76;
	} else {
		x42 = x5;
		x41 = x4;
	}
	VAL v78 = mw_mirth_data_Data_tags(x42);
	VAL v79 = mw_std_list_List_1_ZDivL1(v78);
	VAL x80;
	uint64_t x81;
	switch (get_data_tag(v79)) {
		case 1LL: { // Some
			VAL v82 = mtp_std_maybe_Maybe_1_Some(v79);
			STR* v83;
			STRLIT(v83, "/", 1);
			incref(v82);
			uint64_t v84 = mw_mirth_data_Tag_name(VU64(v82));
			VAL v85 = mw_mirth_name_Name_ZToStr(v84);
			STR* v86 = str_cat(v83, VSTR(v85));
			int64_t v87 = 0LL;
			VAL v88;
			uint64_t v89;
			mw_mirth_elab_dataZ_wordZ_newZBang(x41, x42, MKSTR(v86), v87, &v88, &v89);
			VAL v90 = mtw_std_maybe_Maybe_1_Some(MKU64(v89));
			incref(v82);
			void* v91 = mfld_mirth_data_Tag_ZTildeuntag(VU64(v82));
			mut_set(v90, v91);
			incref(v82);
			VAL v92 = mtw_mirth_mirth_PropLabel_WordType(v89);
			FNPTR v93 = &mb_mirth_elab_elabZ_dataZ_doneZBang_5;
			VAL v94;
			VAL v95;
			mw_mirth_mirth_PropLabel_prop_1(v82, v92, v88, MKFNPTR(v93), &v94, &v95);
			void* v96 = mfld_mirth_word_Word_ZTildectxZ_type(v89);
			mut_set(v94, v96);
			incref(v82);
			VAL v97 = mtw_mirth_mirth_PropLabel_WordArrow(v89);
			VAL v98 = MKNIL;
			VAL v99 = mkcons(v98, v82);
			VAL v100 = mkcons(v99, MKU64(v89));
			FNPTR v101 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot104ZRParen_1;
			VAL v102;
			VAL v103;
			mw_mirth_mirth_PropLabel_prop_1(v100, v97, v95, MKFNPTR(v101), &v102, &v103);
			void* v104 = mfld_mirth_word_Word_ZTildearrow(v89);
			mut_set(v102, v104);
			mw_mirth_word_Word_makeZ_inlineZBang(v89);
			incref(v82);
			VAL v105 = (mw_mirth_elab_createZ_projectorsZBang(v103, VU64(v82)));
			decref(v82);
			x81 = x42;
			x80 = v105;
		} break;
		case 0LL: { // None
			x81 = x42;
			x80 = x41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v106 = mtw_mirth_mirth_PropLabel_DataCType(x81);
	FNPTR v107 = &mb_mirth_elab_elabZ_dataZ_doneZBang_14;
	VAL v108;
	VAL v109;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(x81), v106, x80, MKFNPTR(v107), &v108, &v109);
	void* v110 = mfld_mirth_data_Data_ZTildectypeZAsk(x81);
	mut_set(v108, v110);
	return v109;
}
static void mw_mirth_data_Tag_outputZ_type (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Tag_ZTildeoutputZ_type(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11;
		VAL v12;
		mw_mirth_data_Tag_type(x1, x2, &v11, &v12);
		VAL v13 = mw_mirth_type_ArrowType_cod(v12);
		VAL v14 = mw_mirth_type_StackType_expand(v13);
		uint64_t x15;
		VAL x16;
		VAL x17;
		switch (get_data_tag(v14)) {
			case 5LL: { // STCons
				VAL v18;
				VAL v19;
				mtp_mirth_type_StackType_STCons(v14, &v18, &v19);
				decref(v18);
				VAL v20 = mtw_std_either_Either_2_Left(v19);
				x17 = v20;
				x16 = v11;
				x15 = x2;
			} break;
			case 7LL: { // STWith
				VAL v21;
				VAL v22;
				mtp_mirth_type_StackType_STWith(v14, &v21, &v22);
				decref(v21);
				VAL v23 = mtw_std_either_Either_2_Right(v22);
				x17 = v23;
				x16 = v11;
				x15 = x2;
			} break;
			default: {
				decref(v14);
				STR* v24;
				STRLIT(v24, "Unexpected output type for constructor ", 39);
				VAL v25 = mw_mirth_data_Tag_qname(x2);
				VAL v26;
				VAL v27;
				mw_mirth_name_QName_ZToStr(v11, v25, &v26, &v27);
				STR* v28 = str_cat(v24, VSTR(v27));
				uint64_t v29 = mw_mirth_data_Tag_data(x2);
				VAL v30 = mw_mirth_data_Data_headZAsk(v29);
				uint64_t x31;
				VAL x32;
				switch (get_data_tag(v30)) {
					case 1LL: { // Some
						VAL v33 = mtp_std_maybe_Maybe_1_Some(v30);
						VAL v34 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(VU64(v33), MKSTR(v28), v26));
						x32 = v34;
						x31 = x2;
					} break;
					case 0LL: { // None
						VAL v35 = (mw_mirth_mirth_ZPlusMirth_errorZBang(MKSTR(v28), v26));
						x32 = v35;
						x31 = x2;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v36 = MKI64(0LL /* TYPE_ERROR */);
				uint64_t v37 = mw_mirth_data_Tag_data(x31);
				int64_t v38 = mw_mirth_data_Data_isZ_resourceZAsk(v37);
				VAL x39;
				uint64_t x40;
				VAL x41;
				if (((bool)v38)) {
					VAL v42 = mtw_std_either_Either_2_Right(v36);
					x41 = v42;
					x40 = x31;
					x39 = x32;
				} else {
					VAL v43 = mtw_std_either_Either_2_Left(v36);
					x41 = v43;
					x40 = x31;
					x39 = x32;
				}
				x17 = x41;
				x16 = x39;
				x15 = x40;
			} break;
		}
		incref(x17);
		mut_set(x17, v5);
		x9 = x17;
		x8 = x15;
		x7 = x16;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_outputZ_type(x1, x3, &v6, &v7);
	VAL x8;
	VAL x9;
	switch (get_data_tag(v7)) {
		case 0LL: { // Left
			VAL v10 = mtp_std_either_Either_2_Left(v7);
			VAL v11 = mw_mirth_type_Type_exceptZ_field(x2, x3, v10);
			VAL v12 = mtw_std_either_Either_2_Left(v11);
			x9 = v12;
			x8 = v6;
		} break;
		case 1LL: { // Right
			VAL v13 = mtp_std_either_Either_2_Right(v7);
			VAL v14 = mw_mirth_type_Resource_exceptZ_field(x2, x3, v13);
			VAL v15 = mtw_std_either_Either_2_Right(v14);
			x9 = v15;
			x8 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_data_Tag_projectZ_inputZ_label (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_type(x1, x3, &v6, &v7);
	VAL v8 = mw_mirth_type_ArrowType_dom(v7);
	VAL v9 = mw_mirth_type_StackType_labelZ_topZAsk(x2, v8);
	*x5 = v9;
	*x4 = v6;
}
static void mw_mirth_data_Tag_projectZ_tagZ_field (VAL x1, uint64_t x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_projectZ_inputZ_label(x1, x2, x3, &v6, &v7);
	VAL x8;
	VAL x9;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v11 = mtw_mirth_data_TagField_TagField(x3, x2, v10);
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
			x9 = v12;
			x8 = v6;
		} break;
		case 0LL: { // None
			VAL v13 = MKI64(0LL /* None */);
			x9 = v13;
			x8 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x9;
	*x4 = x8;
}
static void mw_mirth_elab_dataZ_getZ_labelZ_type (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5;
	uint64_t v6;
	VAL v7;
	mtp_mirth_data_TagField_TagField(x2, &v5, &v6, &v7);
	uint64_t x8;
	VAL x9;
	uint64_t x10;
	VAL x11;
	switch (get_data_tag(v7)) {
		case 0LL: { // Left
			VAL v12 = mtp_std_either_Either_2_Left(v7);
			VAL v13 = mw_mirth_type_T0();
			VAL v14;
			VAL v15;
			mw_mirth_data_Tag_outputZ_type(x1, v5, &v14, &v15);
			VAL v16 = mw_mirth_type_TZMulZPlus(v13, v15);
			VAL v17 = mw_mirth_type_T1(v12);
			uint64_t v18 = mw_mirth_data_Tag_data(v5);
			int64_t v19 = mw_mirth_data_Data_isZ_resourceZAsk(v18);
			uint64_t x20;
			VAL x21;
			VAL x22;
			VAL x23;
			uint64_t x24;
			if (((bool)v19)) {
				VAL v25;
				VAL v26;
				mw_mirth_data_Tag_outputZ_type(v14, v5, &v25, &v26);
				VAL v27 = mw_mirth_type_TZMulZPlus(v17, v26);
				x24 = v5;
				x23 = v27;
				x22 = v16;
				x21 = v25;
				x20 = v6;
			} else {
				x24 = v5;
				x23 = v17;
				x22 = v16;
				x21 = v14;
				x20 = v6;
			}
			VAL v28 = mw_mirth_type_TZ_ZTo(x22, x23);
			x11 = v28;
			x10 = x24;
			x9 = x21;
			x8 = x20;
		} break;
		case 1LL: { // Right
			VAL v29 = mtp_std_either_Either_2_Right(v7);
			VAL v30 = mw_mirth_type_T0();
			VAL v31;
			VAL v32;
			mw_mirth_data_Tag_outputZ_type(x1, v5, &v31, &v32);
			VAL v33 = mw_mirth_type_TZMulZPlus(v30, v32);
			VAL v34 = mw_mirth_type_T0();
			VAL v35 = mw_mirth_type_TZPlus(v34, v29);
			VAL v36;
			VAL v37;
			mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field(v31, v6, v5, &v36, &v37);
			VAL v38 = mw_mirth_type_TZMulZPlus(v35, v37);
			VAL v39 = mw_mirth_type_TZ_ZTo(v33, v38);
			x11 = v39;
			x10 = v5;
			x9 = v36;
			x8 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x11;
	*x3 = x9;
}
static void mw_mirth_elab_dataZ_setZ_labelZ_type (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	uint64_t v5;
	uint64_t v6;
	VAL v7;
	mtp_mirth_data_TagField_TagField(x2, &v5, &v6, &v7);
	uint64_t x8;
	uint64_t x9;
	VAL x10;
	VAL x11;
	switch (get_data_tag(v7)) {
		case 0LL: { // Left
			VAL v12 = mtp_std_either_Either_2_Left(v7);
			VAL v13 = mw_mirth_type_T1(v12);
			VAL v14;
			VAL v15;
			mw_mirth_data_Tag_outputZ_type(x1, v5, &v14, &v15);
			VAL v16 = mw_mirth_type_TZMulZPlus(v13, v15);
			VAL v17 = mw_mirth_type_T0();
			VAL v18;
			VAL v19;
			mw_mirth_data_Tag_outputZ_type(v14, v5, &v18, &v19);
			VAL v20 = mw_mirth_type_TZMulZPlus(v17, v19);
			VAL v21 = mw_mirth_type_TZ_ZTo(v16, v20);
			x11 = v21;
			x10 = v18;
			x9 = v5;
			x8 = v6;
		} break;
		case 1LL: { // Right
			VAL v22 = mtp_std_either_Either_2_Right(v7);
			VAL v23 = mw_mirth_type_T0();
			VAL v24 = mw_mirth_type_TZPlus(v23, v22);
			VAL v25;
			VAL v26;
			mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field(x1, v6, v5, &v25, &v26);
			VAL v27 = mw_mirth_type_TZMulZPlus(v24, v26);
			VAL v28 = mw_mirth_type_T0();
			VAL v29;
			VAL v30;
			mw_mirth_data_Tag_outputZ_type(v25, v5, &v29, &v30);
			VAL v31 = mw_mirth_type_TZMulZPlus(v28, v30);
			VAL v32 = mw_mirth_type_TZ_ZTo(v27, v31);
			x11 = v32;
			x10 = v29;
			x9 = v5;
			x8 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x11;
	*x3 = x10;
}
static VAL mw_mirth_elab_createZ_projectorsZBang (VAL x1, uint64_t x2) {
	uint64_t v3 = mw_mirth_data_Tag_data(x2);
	VAL v4 = mw_mirth_data_Tag_labelZ_inputs(x2);
	VAL v5 = mw_std_list_List_1_reverse(v4);
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(v5, &v6, &v7);
	VAL x8;
	uint64_t x9;
	uint64_t x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v6);
			incref(v13);
			uint64_t v14 = mw_mirth_label_Label_name(VU64(v13));
			int64_t v15 = 0LL;
			VAL v16 = mw_mirth_data_dataZ_qname(v3, v14, v15);
			VAL v17;
			int64_t v18;
			mw_mirth_name_QName_undefinedZ_softZAsk(x1, v16, &v17, &v18);
			uint64_t x19;
			uint64_t x20;
			uint64_t x21;
			VAL x22;
			if (((bool)v18)) {
				incref(v13);
				VAL v23 = mw_mirth_label_Label_ZToStr(VU64(v13));
				int64_t v24 = 0LL;
				VAL v25;
				uint64_t v26;
				mw_mirth_elab_dataZ_wordZ_newZBang(v17, v3, v23, v24, &v25, &v26);
				incref(v13);
				VAL v27 = mw_mirth_label_Label_ZToStr(VU64(v13));
				STR* v28;
				STRLIT(v28, "!", 1);
				STR* v29 = str_cat(VSTR(v27), v28);
				int64_t v30 = 0LL;
				VAL v31;
				uint64_t v32;
				mw_mirth_elab_dataZ_wordZ_newZBang(v25, v3, MKSTR(v29), v30, &v31, &v32);
				incref(v13);
				VAL v33 = mw_mirth_label_Label_ZToStr(VU64(v13));
				int64_t v34 = 1LL;
				VAL v35;
				uint64_t v36;
				mw_mirth_elab_dataZ_wordZ_newZBang(v31, v3, v33, v34, &v35, &v36);
				mw_mirth_word_Word_makeZ_inlineZBang(v26);
				incref(v13);
				VAL v37 = mtw_mirth_mirth_PropLabel_WordType(v26);
				VAL v38 = MKNIL;
				VAL v39 = mkcons(v38, MKU64(x2));
				VAL v40 = mkcons(v39, v13);
				FNPTR v41 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1;
				VAL v42;
				VAL v43;
				mw_mirth_mirth_PropLabel_prop_1(v40, v37, v35, MKFNPTR(v41), &v42, &v43);
				void* v44 = mfld_mirth_word_Word_ZTildectxZ_type(v26);
				mut_set(v42, v44);
				incref(v13);
				VAL v45 = mtw_mirth_mirth_PropLabel_WordArrow(v26);
				VAL v46 = MKNIL;
				VAL v47 = mkcons(v46, MKU64(x2));
				VAL v48 = mkcons(v47, v13);
				VAL v49 = mkcons(v48, MKU64(v26));
				FNPTR v50 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot73ZRParen_1;
				VAL v51;
				VAL v52;
				mw_mirth_mirth_PropLabel_prop_1(v49, v45, v43, MKFNPTR(v50), &v51, &v52);
				void* v53 = mfld_mirth_word_Word_ZTildearrow(v26);
				mut_set(v51, v53);
				mw_mirth_word_Word_makeZ_inlineZBang(v32);
				incref(v13);
				VAL v54 = mtw_mirth_mirth_PropLabel_WordType(v32);
				VAL v55 = MKNIL;
				VAL v56 = mkcons(v55, MKU64(x2));
				VAL v57 = mkcons(v56, v13);
				FNPTR v58 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot106ZRParen_1;
				VAL v59;
				VAL v60;
				mw_mirth_mirth_PropLabel_prop_1(v57, v54, v52, MKFNPTR(v58), &v59, &v60);
				void* v61 = mfld_mirth_word_Word_ZTildectxZ_type(v32);
				mut_set(v59, v61);
				incref(v13);
				VAL v62 = mtw_mirth_mirth_PropLabel_WordArrow(v32);
				VAL v63 = MKNIL;
				VAL v64 = mkcons(v63, MKU64(x2));
				VAL v65 = mkcons(v64, v13);
				VAL v66 = mkcons(v65, MKU64(v32));
				FNPTR v67 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot134ZRParen_1;
				VAL v68;
				VAL v69;
				mw_mirth_mirth_PropLabel_prop_1(v66, v62, v60, MKFNPTR(v67), &v68, &v69);
				void* v70 = mfld_mirth_word_Word_ZTildearrow(v32);
				mut_set(v68, v70);
				mw_mirth_word_Word_makeZ_inlineZBang(v36);
				incref(v13);
				VAL v71 = mtw_mirth_mirth_PropLabel_WordType(v36);
				VAL v72 = MKNIL;
				VAL v73 = mkcons(v72, MKU64(x2));
				VAL v74 = mkcons(v73, v13);
				FNPTR v75 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot167ZRParen_1;
				VAL v76;
				VAL v77;
				mw_mirth_mirth_PropLabel_prop_1(v74, v71, v69, MKFNPTR(v75), &v76, &v77);
				void* v78 = mfld_mirth_word_Word_ZTildectxZ_type(v36);
				mut_set(v76, v78);
				VAL v79 = mtw_mirth_mirth_PropLabel_WordParams(v36);
				FNPTR v80 = &mb_mirth_elab_createZ_projectorsZBang_24;
				VAL v81;
				VAL v82;
				mw_mirth_mirth_PropLabel_prop_1(MKU64(v36), v79, v77, MKFNPTR(v80), &v81, &v82);
				void* v83 = mfld_mirth_word_Word_ZTildeparams(v36);
				mut_set(v81, v83);
				VAL v84 = mtw_mirth_mirth_PropLabel_WordArrow(v36);
				VAL v85 = MKNIL;
				VAL v86 = mkcons(v85, MKU64(v3));
				VAL v87 = mkcons(v86, MKU64(v26));
				VAL v88 = mkcons(v87, MKU64(v32));
				VAL v89 = mkcons(v88, MKU64(v36));
				FNPTR v90 = &mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot267ZRParen_1;
				VAL v91;
				VAL v92;
				mw_mirth_mirth_PropLabel_prop_1(v89, v84, v82, MKFNPTR(v90), &v91, &v92);
				void* v93 = mfld_mirth_word_Word_ZTildearrow(v36);
				mut_set(v91, v93);
				x22 = v92;
				x21 = VU64(v13);
				x20 = v3;
				x19 = x2;
			} else {
				x22 = v17;
				x21 = VU64(v13);
				x20 = v3;
				x19 = x2;
			}
			int64_t v94 = 1LL /* True */;
			x12 = v94;
			x11 = v7;
			x10 = x19;
			x9 = x20;
			x8 = x22;
		} break;
		case 0LL: { // None
			int64_t v95 = 0LL /* False */;
			x12 = v95;
			x11 = v7;
			x10 = x2;
			x9 = v3;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v96 = (x8);
	uint64_t v97 = x9;
	uint64_t v98 = x10;
	VAL v99 = x11;
	int64_t v100 = x12;
	while (((bool)v100)) {
		VAL v101 = (v96);
		uint64_t v102 = v97;
		uint64_t v103 = v98;
		VAL v104 = v99;
		VAL v105;
		VAL v106;
		mw_std_list_List_1_uncons(v104, &v105, &v106);
		VAL x107;
		uint64_t x108;
		uint64_t x109;
		VAL x110;
		int64_t x111;
		switch (get_data_tag(v105)) {
			case 1LL: { // Some
				VAL v112 = mtp_std_maybe_Maybe_1_Some(v105);
				incref(v112);
				uint64_t v113 = mw_mirth_label_Label_name(VU64(v112));
				int64_t v114 = 0LL;
				VAL v115 = mw_mirth_data_dataZ_qname(v102, v113, v114);
				VAL v116;
				int64_t v117;
				mw_mirth_name_QName_undefinedZ_softZAsk(v101, v115, &v116, &v117);
				uint64_t x118;
				uint64_t x119;
				uint64_t x120;
				VAL x121;
				if (((bool)v117)) {
					incref(v112);
					VAL v122 = mw_mirth_label_Label_ZToStr(VU64(v112));
					int64_t v123 = 0LL;
					VAL v124;
					uint64_t v125;
					mw_mirth_elab_dataZ_wordZ_newZBang(v116, v102, v122, v123, &v124, &v125);
					incref(v112);
					VAL v126 = mw_mirth_label_Label_ZToStr(VU64(v112));
					STR* v127;
					STRLIT(v127, "!", 1);
					STR* v128 = str_cat(VSTR(v126), v127);
					int64_t v129 = 0LL;
					VAL v130;
					uint64_t v131;
					mw_mirth_elab_dataZ_wordZ_newZBang(v124, v102, MKSTR(v128), v129, &v130, &v131);
					incref(v112);
					VAL v132 = mw_mirth_label_Label_ZToStr(VU64(v112));
					int64_t v133 = 1LL;
					VAL v134;
					uint64_t v135;
					mw_mirth_elab_dataZ_wordZ_newZBang(v130, v102, v132, v133, &v134, &v135);
					mw_mirth_word_Word_makeZ_inlineZBang(v125);
					incref(v112);
					VAL v136 = mtw_mirth_mirth_PropLabel_WordType(v125);
					VAL v137 = MKNIL;
					VAL v138 = mkcons(v137, MKU64(v103));
					VAL v139 = mkcons(v138, v112);
					FNPTR v140 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1;
					VAL v141;
					VAL v142;
					mw_mirth_mirth_PropLabel_prop_1(v139, v136, v134, MKFNPTR(v140), &v141, &v142);
					void* v143 = mfld_mirth_word_Word_ZTildectxZ_type(v125);
					mut_set(v141, v143);
					incref(v112);
					VAL v144 = mtw_mirth_mirth_PropLabel_WordArrow(v125);
					VAL v145 = MKNIL;
					VAL v146 = mkcons(v145, MKU64(v103));
					VAL v147 = mkcons(v146, v112);
					VAL v148 = mkcons(v147, MKU64(v125));
					FNPTR v149 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot73ZRParen_1;
					VAL v150;
					VAL v151;
					mw_mirth_mirth_PropLabel_prop_1(v148, v144, v142, MKFNPTR(v149), &v150, &v151);
					void* v152 = mfld_mirth_word_Word_ZTildearrow(v125);
					mut_set(v150, v152);
					mw_mirth_word_Word_makeZ_inlineZBang(v131);
					incref(v112);
					VAL v153 = mtw_mirth_mirth_PropLabel_WordType(v131);
					VAL v154 = MKNIL;
					VAL v155 = mkcons(v154, MKU64(v103));
					VAL v156 = mkcons(v155, v112);
					FNPTR v157 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot106ZRParen_1;
					VAL v158;
					VAL v159;
					mw_mirth_mirth_PropLabel_prop_1(v156, v153, v151, MKFNPTR(v157), &v158, &v159);
					void* v160 = mfld_mirth_word_Word_ZTildectxZ_type(v131);
					mut_set(v158, v160);
					incref(v112);
					VAL v161 = mtw_mirth_mirth_PropLabel_WordArrow(v131);
					VAL v162 = MKNIL;
					VAL v163 = mkcons(v162, MKU64(v103));
					VAL v164 = mkcons(v163, v112);
					VAL v165 = mkcons(v164, MKU64(v131));
					FNPTR v166 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot134ZRParen_1;
					VAL v167;
					VAL v168;
					mw_mirth_mirth_PropLabel_prop_1(v165, v161, v159, MKFNPTR(v166), &v167, &v168);
					void* v169 = mfld_mirth_word_Word_ZTildearrow(v131);
					mut_set(v167, v169);
					mw_mirth_word_Word_makeZ_inlineZBang(v135);
					incref(v112);
					VAL v170 = mtw_mirth_mirth_PropLabel_WordType(v135);
					VAL v171 = MKNIL;
					VAL v172 = mkcons(v171, MKU64(v103));
					VAL v173 = mkcons(v172, v112);
					FNPTR v174 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot167ZRParen_1;
					VAL v175;
					VAL v176;
					mw_mirth_mirth_PropLabel_prop_1(v173, v170, v168, MKFNPTR(v174), &v175, &v176);
					void* v177 = mfld_mirth_word_Word_ZTildectxZ_type(v135);
					mut_set(v175, v177);
					VAL v178 = mtw_mirth_mirth_PropLabel_WordParams(v135);
					FNPTR v179 = &mb_mirth_elab_createZ_projectorsZBang_24;
					VAL v180;
					VAL v181;
					mw_mirth_mirth_PropLabel_prop_1(MKU64(v135), v178, v176, MKFNPTR(v179), &v180, &v181);
					void* v182 = mfld_mirth_word_Word_ZTildeparams(v135);
					mut_set(v180, v182);
					VAL v183 = mtw_mirth_mirth_PropLabel_WordArrow(v135);
					VAL v184 = MKNIL;
					VAL v185 = mkcons(v184, MKU64(v102));
					VAL v186 = mkcons(v185, MKU64(v125));
					VAL v187 = mkcons(v186, MKU64(v131));
					VAL v188 = mkcons(v187, MKU64(v135));
					FNPTR v189 = &mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot267ZRParen_1;
					VAL v190;
					VAL v191;
					mw_mirth_mirth_PropLabel_prop_1(v188, v183, v181, MKFNPTR(v189), &v190, &v191);
					void* v192 = mfld_mirth_word_Word_ZTildearrow(v135);
					mut_set(v190, v192);
					x121 = v191;
					x120 = VU64(v112);
					x119 = v102;
					x118 = v103;
				} else {
					x121 = v116;
					x120 = VU64(v112);
					x119 = v102;
					x118 = v103;
				}
				int64_t v193 = 1LL /* True */;
				x111 = v193;
				x110 = v106;
				x109 = x118;
				x108 = x119;
				x107 = x121;
			} break;
			case 0LL: { // None
				int64_t v194 = 0LL /* False */;
				x111 = v194;
				x110 = v106;
				x109 = v103;
				x108 = v102;
				x107 = v101;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v100 = x111;
		v99 = x110;
		v98 = x109;
		v97 = x108;
		v96 = x107;
	}
	decref(v99);
	return v96;
}
static void mw_mirth_elab_expectZ_tokenZ_arrow (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	int64_t v5 = mw_mirth_token_Token_arrowZAsk(x2);
	VAL x6;
	uint64_t x7;
	if (((bool)v5)) {
		x7 = x2;
		x6 = x1;
	} else {
		STR* v8;
		STRLIT(v8, "Expected arrow.", 15);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v8), x1);
		uint64_t v9 = pop_u64();
		x7 = v9;
		VAL r10 = pop_resource();
		x6 = r10;
	}
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_elab_parseZ_alias (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5, uint64_t *x6, VAL *x7) {
	uint64_t v8 = mw_mirth_token_Token_succ(x2);
	VAL v9 = mw_mirth_token_Token_lparenZAsk(v8);
	int64_t v10 = mw_std_maybe_Maybe_1_ZToBool(v9);
	int64_t x11;
	uint64_t x12;
	VAL x13;
	uint64_t x14;
	uint64_t x15;
	if (((bool)v10)) {
		uint64_t v16 = mw_mirth_token_Token_next(x2);
		uint64_t v17;
		uint64_t v18;
		VAL v19;
		mw_mirth_token_Token_argsZ_2(x2, x1, &v17, &v18, &v19);
		x15 = v17;
		x14 = v18;
		x13 = v19;
		x12 = v16;
		x11 = v10;
	} else {
		uint64_t v20 = mw_mirth_token_Token_next(x2);
		uint64_t v21 = mw_mirth_token_Token_next(v20);
		uint64_t v22 = mw_mirth_token_Token_next(v21);
		x15 = v20;
		x14 = v21;
		x13 = x1;
		x12 = v22;
		x11 = v10;
	}
	VAL v23 = mw_mirth_token_Token_nameZDivdnameZAsk(x15);
	int64_t x24;
	uint64_t x25;
	VAL x26;
	uint64_t x27;
	uint64_t x28;
	switch (get_data_tag(v23)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(v23);
			decref(v29);
			x28 = x15;
			x27 = x14;
			x26 = x13;
			x25 = x12;
			x24 = x11;
		} break;
		case 0LL: { // None
			STR* v30;
			STRLIT(v30, "expected alias name", 19);
			lpush(&lbl_hasZ_paren, MKI64(x11));
			push_u64(x12);
			lpush(&lbl_target, MKU64(x14));
			lpush(&lbl_head, MKU64(x15));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x15, MKSTR(v30), x13);
			uint64_t v31 = VU64(lpop(&lbl_head));
			x28 = v31;
			uint64_t v32 = VU64(lpop(&lbl_target));
			x27 = v32;
			VAL r33 = pop_resource();
			x26 = r33;
			uint64_t v34 = pop_u64();
			x25 = v34;
			int64_t v35 = VI64(lpop(&lbl_hasZ_paren));
			x24 = v35;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v36 = mw_mirth_token_Token_nameZDivdnameZAsk(x27);
	int64_t x37;
	uint64_t x38;
	VAL x39;
	uint64_t x40;
	uint64_t x41;
	VAL x42;
	switch (get_data_tag(v36)) {
		case 1LL: { // Some
			VAL v43 = mtp_std_maybe_Maybe_1_Some(v36);
			x42 = v43;
			x41 = x27;
			x40 = x28;
			x39 = x26;
			x38 = x25;
			x37 = x24;
		} break;
		case 0LL: { // None
			STR* v44;
			STRLIT(v44, "expected alias target, which must be a name", 43);
			lpush(&lbl_hasZ_paren, MKI64(x24));
			push_u64(x25);
			lpush(&lbl_head, MKU64(x28));
			lpush(&lbl_target, MKU64(x27));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x27, MKSTR(v44), x26);
			VAL v45 = pop_value();
			x42 = v45;
			uint64_t v46 = VU64(lpop(&lbl_target));
			x41 = v46;
			uint64_t v47 = VU64(lpop(&lbl_head));
			x40 = v47;
			VAL r48 = pop_resource();
			x39 = r48;
			uint64_t v49 = pop_u64();
			x38 = v49;
			int64_t v50 = VI64(lpop(&lbl_hasZ_paren));
			x37 = v50;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v51 = (mw_mirth_token_Token_argsZ_0(x41, x39));
	uint64_t x52;
	uint64_t x53;
	VAL x54;
	uint64_t x55;
	VAL x56;
	int64_t x57;
	if (((bool)x37)) {
		uint64_t v58 = mw_mirth_token_Token_next(x40);
		int64_t v59 = mw_mirth_token_Token_argZ_endZAsk(v58);
		uint64_t x60;
		VAL x61;
		uint64_t x62;
		VAL x63;
		int64_t x64;
		uint64_t x65;
		if (((bool)v59)) {
			x65 = x40;
			x64 = x37;
			x63 = v51;
			x62 = x41;
			x61 = x42;
			x60 = x38;
		} else {
			STR* v66;
			STRLIT(v66, "expected comma after alias name", 31);
			push_u64(x38);
			lpush(&lbl_nameZDivdname, x42);
			lpush(&lbl_target, MKU64(x41));
			lpush(&lbl_hasZ_paren, MKI64(x37));
			lpush(&lbl_head, MKU64(x40));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x40, MKSTR(v66), v51);
			uint64_t v67 = VU64(lpop(&lbl_head));
			x65 = v67;
			int64_t v68 = VI64(lpop(&lbl_hasZ_paren));
			x64 = v68;
			VAL r69 = pop_resource();
			x63 = r69;
			uint64_t v70 = VU64(lpop(&lbl_target));
			x62 = v70;
			VAL v71 = lpop(&lbl_nameZDivdname);
			x61 = v71;
			uint64_t v72 = pop_u64();
			x60 = v72;
		}
		uint64_t v73 = mw_mirth_token_Token_succ(x62);
		int64_t v74 = mw_mirth_token_Token_argZ_endZAsk(v73);
		uint64_t x75;
		VAL x76;
		VAL x77;
		int64_t x78;
		uint64_t x79;
		uint64_t x80;
		if (((bool)v74)) {
			x80 = x62;
			x79 = x65;
			x78 = x64;
			x77 = x63;
			x76 = x61;
			x75 = x60;
		} else {
			STR* v81;
			STRLIT(v81, "expected end of arguments after alias target", 44);
			push_u64(x60);
			lpush(&lbl_nameZDivdname, x61);
			lpush(&lbl_hasZ_paren, MKI64(x64));
			lpush(&lbl_target, MKU64(x62));
			lpush(&lbl_head, MKU64(x65));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x65, MKSTR(v81), x63);
			uint64_t v82 = VU64(lpop(&lbl_target));
			x80 = v82;
			uint64_t v83 = VU64(lpop(&lbl_head));
			x79 = v83;
			int64_t v84 = VI64(lpop(&lbl_hasZ_paren));
			x78 = v84;
			VAL r85 = pop_resource();
			x77 = r85;
			VAL v86 = lpop(&lbl_nameZDivdname);
			x76 = v86;
			uint64_t v87 = pop_u64();
			x75 = v87;
		}
		x57 = x78;
		x56 = x77;
		x55 = x80;
		x54 = x76;
		x53 = x79;
		x52 = x75;
	} else {
		x57 = x37;
		x56 = v51;
		x55 = x41;
		x54 = x42;
		x53 = x40;
		x52 = x38;
	}
	*x7 = x54;
	*x6 = x55;
	*x5 = x53;
	*x4 = x52;
	*x3 = x56;
}
static void mw_mirth_elab_elabZ_aliasZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	uint64_t v6;
	uint64_t v7;
	uint64_t v8;
	VAL v9;
	mw_mirth_elab_parseZ_alias(x1, x2, &v5, &v6, &v7, &v8, &v9);
	VAL v10;
	uint64_t v11;
	uint64_t v12;
	int64_t v13;
	VAL v14;
	mw_mirth_elab_elabZ_defZ_head(v5, v7, &v10, &v11, &v12, &v13, &v14);
	VAL v15;
	uint64_t v16;
	mw_mirth_alias_Alias_newZBang(v10, v11, v12, v13, &v15, &v16);
	VAL v17 = mtw_mirth_mirth_PropLabel_AliasQName(v16);
	VAL v18 = mtw_mirth_mirth_Prop_1_Prop(v17, v14);
	void* v19 = mfld_mirth_alias_Alias_ZTildeqname(v16);
	mut_set(v18, v19);
	VAL v20 = mtw_mirth_mirth_PropLabel_AliasTarget(v16);
	VAL v21 = MKNIL;
	VAL v22 = mkcons(v21, v9);
	VAL v23 = mkcons(v22, MKU64(v8));
	VAL v24 = mkcons(v23, MKU64(v16));
	FNPTR v25 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotelabZ_aliasZBangZDot21ZRParen_1;
	VAL v26;
	VAL v27;
	mw_mirth_mirth_PropLabel_prop_1(v24, v20, v15, MKFNPTR(v25), &v26, &v27);
	void* v28 = mfld_mirth_alias_Alias_ZTildetarget(v16);
	mut_set(v26, v28);
	*x4 = v6;
	*x3 = v27;
}
static void mw_mirth_elab_elabZ_defZ_missingZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	VAL v5 = mw_mirth_token_Token_args(x2);
	int64_t v6 = mw_std_list_List_1_len(v5);
	int64_t v7 = 3LL;
	bool v8 = (v6 < v7);
	VAL x9;
	uint64_t x10;
	if (v8) {
		STR* v11;
		STRLIT(v11, "def-missing expects at least three arguments", 44);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v11), x1);
		uint64_t v12 = pop_u64();
		x10 = v12;
		VAL r13 = pop_resource();
		x9 = r13;
	} else {
		x10 = x2;
		x9 = x1;
	}
	uint64_t v14 = mw_mirth_token_Token_succ(x10);
	uint64_t v15 = mw_mirth_token_Token_succ(v14);
	VAL v16;
	VAL v17;
	mw_mirth_elab_elabZ_defZ_qname(x9, v15, &v16, &v17);
	VAL v18;
	int64_t v19;
	mw_mirth_name_QName_definedZ_hardZAsk(v16, v17, &v18, &v19);
	VAL x20;
	uint64_t x21;
	if (((bool)v19)) {
		uint64_t v22 = mw_mirth_token_Token_next(x10);
		x21 = v22;
		x20 = v18;
	} else {
		VAL v23;
		uint64_t v24;
		mw_mirth_elab_elabZ_defZBang(v18, x10, &v23, &v24);
		x21 = v24;
		x20 = v23;
	}
	*x4 = x21;
	*x3 = x20;
}
static void mw_mirth_elab_elabZ_inlineZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6) {
	uint64_t v7 = mw_mirth_token_Token_next(x1);
	uint64_t v8;
	VAL v9;
	mw_mirth_token_Token_argsZ_1(x1, x3, &v8, &v9);
	int64_t v10 = VI64(VTUP(v9)->cells[3]);
	int64_t v11 = 1LL /* True */;
	VTUP(v9)->cells[3] = MKI64(v11);
	int64_t v12 = mw_mirth_token_Token_argZ_endZAsk(v8);
	bool v13 = !((bool)v12);
	int64_t v14 = (x2);
	uint64_t v15 = v7;
	int64_t v16 = v10;
	VAL v17 = (v9);
	uint64_t v18 = v8;
	bool v19 = v13;
	while (v19) {
		int64_t v20 = (v14);
		uint64_t v21 = v15;
		int64_t v22 = v16;
		VAL v23 = (v17);
		uint64_t v24 = v18;
		uint64_t v25;
		int64_t v26;
		VAL v27;
		mw_mirth_elab_elabZ_moduleZ_declZBang(v24, v20, v23, &v25, &v26, &v27);
		int64_t v28 = mw_mirth_token_Token_argZ_endZAsk(v25);
		bool v29 = !((bool)v28);
		v19 = v29;
		v18 = v25;
		v17 = v27;
		v16 = v22;
		v15 = v21;
		v14 = v26;
	}
	VTUP(v17)->cells[3] = MKI64(v16);
	*x6 = v17;
	*x5 = v14;
	*x4 = v15;
}
static void mw_mirth_elab_parseZ_def (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	VAL v6 = mtw_std_maybe_Maybe_1_Some(MKU64(x2));
	VAL v7 = VTUP(x1)->cells[5];
	decref(v7);
	VTUP(x1)->cells[5] = v6;
	VAL v8 = mw_mirth_token_Token_args(x2);
	int64_t v9 = mw_std_list_List_1_emptyZAsk(v8);
	uint64_t x10;
	VAL x11;
	VAL x12;
	VAL x13;
	uint64_t x14;
	if (((bool)v9)) {
		uint64_t v15 = mw_mirth_token_Token_next(x2);
		uint64_t v16 = mw_mirth_token_Token_next(v15);
		VAL v17 = mw_mirth_token_Token_lsquareZAsk(v16);
		uint64_t x18;
		VAL x19;
		VAL x20;
		uint64_t x21;
		switch (get_data_tag(v17)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v17);
				decref(v22);
				uint64_t v23;
				VAL v24;
				mw_mirth_token_Token_argsZ_1(v16, x1, &v23, &v24);
				VAL v25 = mtw_std_maybe_Maybe_1_Some(MKU64(v23));
				uint64_t v26 = mw_mirth_token_Token_next(v16);
				x21 = v26;
				x20 = v25;
				x19 = v24;
				x18 = v15;
			} break;
			case 0LL: { // None
				VAL v27 = MKI64(0LL /* None */);
				x21 = v16;
				x20 = v27;
				x19 = x1;
				x18 = v15;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v28 = mw_mirth_token_Token_lcurlyZAsk(x21);
		uint64_t x29;
		VAL x30;
		VAL x31;
		uint64_t x32;
		switch (get_data_tag(v28)) {
			case 1LL: { // Some
				VAL v33 = mtp_std_maybe_Maybe_1_Some(v28);
				decref(v33);
				x32 = x21;
				x31 = x20;
				x30 = x19;
				x29 = x18;
			} break;
			case 0LL: { // None
				STR* v34;
				STRLIT(v34, "expected { ... }", 16);
				lpush(&lbl_head, MKU64(x18));
				lpush(&lbl_sigZAsk, x20);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x21, MKSTR(v34), x19);
				uint64_t v35 = pop_u64();
				x32 = v35;
				VAL v36 = lpop(&lbl_sigZAsk);
				x31 = v36;
				VAL r37 = pop_resource();
				x30 = r37;
				uint64_t v38 = VU64(lpop(&lbl_head));
				x29 = v38;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v39;
		VAL v40;
		mw_mirth_token_Token_argsZPlus(x32, x30, &v39, &v40);
		uint64_t v41 = mw_mirth_token_Token_next(x32);
		x14 = v41;
		x13 = v39;
		x12 = v40;
		x11 = x31;
		x10 = x29;
	} else {
		uint64_t v42 = mw_mirth_token_Token_next(x2);
		VAL v43 = mw_mirth_token_Token_args(x2);
		incref(v43);
		int64_t v44 = mw_std_list_List_1_len(v43);
		int64_t v45 = 3LL;
		bool v46 = (v44 < v45);
		VAL x47;
		uint64_t x48;
		uint64_t x49;
		VAL x50;
		if (v46) {
			decref(v43);
			STR* v51;
			STRLIT(v51, "def(...) expects at least three arguments", 41);
			push_u64(v42);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v51), x1);
			VAL v52 = pop_value();
			x50 = v52;
			uint64_t v53 = pop_u64();
			x49 = v53;
			uint64_t v54 = pop_u64();
			x48 = v54;
			VAL r55 = pop_resource();
			x47 = r55;
		} else {
			x50 = v43;
			x49 = x2;
			x48 = v42;
			x47 = x1;
		}
		VAL v56 = mw_std_list_List_1_ZToListZPlus(x50);
		VAL x57;
		uint64_t x58;
		VAL x59;
		switch (get_data_tag(v56)) {
			case 1LL: { // Some
				VAL v60 = mtp_std_maybe_Maybe_1_Some(v56);
				x59 = v60;
				x58 = x48;
				x57 = x47;
			} break;
			case 0LL: { // None
				STR* v61;
				STRLIT(v61, "logic error in parse-def", 24);
				push_resource(x47);
				push_u64(x48);
				do_panic(v61);
				VAL v62 = pop_value();
				x59 = v62;
				uint64_t v63 = pop_u64();
				x58 = v63;
				VAL r64 = pop_resource();
				x57 = r64;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v65;
		VAL v66;
		mw_std_list_ListZPlus_1_uncons(x59, &v65, &v66);
		VAL v67 = mw_std_list_List_1_ZToListZPlus(v66);
		VAL x68;
		uint64_t x69;
		uint64_t x70;
		VAL x71;
		switch (get_data_tag(v67)) {
			case 1LL: { // Some
				VAL v72 = mtp_std_maybe_Maybe_1_Some(v67);
				x71 = v72;
				x70 = VU64(v65);
				x69 = x58;
				x68 = x57;
			} break;
			case 0LL: { // None
				STR* v73;
				STRLIT(v73, "logic error in parse-def", 24);
				push_resource(x57);
				push_u64(x58);
				lpush(&lbl_head, v65);
				do_panic(v73);
				VAL v74 = pop_value();
				x71 = v74;
				uint64_t v75 = VU64(lpop(&lbl_head));
				x70 = v75;
				uint64_t v76 = pop_u64();
				x69 = v76;
				VAL r77 = pop_resource();
				x68 = r77;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v78;
		VAL v79;
		mw_std_list_ListZPlus_1_uncons(x71, &v78, &v79);
		VAL v80 = mtw_std_maybe_Maybe_1_Some(v78);
		VAL v81 = mw_std_list_List_1_ZToListZPlus(v79);
		VAL x82;
		uint64_t x83;
		uint64_t x84;
		VAL x85;
		VAL x86;
		switch (get_data_tag(v81)) {
			case 1LL: { // Some
				VAL v87 = mtp_std_maybe_Maybe_1_Some(v81);
				x86 = v87;
				x85 = v80;
				x84 = x70;
				x83 = x69;
				x82 = x68;
			} break;
			case 0LL: { // None
				STR* v88;
				STRLIT(v88, "logic error in parse-def", 24);
				push_resource(x68);
				push_u64(x69);
				lpush(&lbl_head, MKU64(x70));
				lpush(&lbl_sigZAsk, v80);
				do_panic(v88);
				VAL v89 = pop_value();
				x86 = v89;
				VAL v90 = lpop(&lbl_sigZAsk);
				x85 = v90;
				uint64_t v91 = VU64(lpop(&lbl_head));
				x84 = v91;
				uint64_t v92 = pop_u64();
				x83 = v92;
				VAL r93 = pop_resource();
				x82 = r93;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v94 = mw_mirth_token_Token_next(x84);
		int64_t v95 = mw_mirth_token_Token_argZ_endZAsk(v94);
		VAL x96;
		uint64_t x97;
		VAL x98;
		VAL x99;
		uint64_t x100;
		if (((bool)v95)) {
			x100 = x84;
			x99 = x86;
			x98 = x85;
			x97 = x83;
			x96 = x82;
		} else {
			uint64_t v101 = mw_mirth_token_Token_next(x84);
			STR* v102;
			STRLIT(v102, "expected comma after word name", 30);
			push_u64(x83);
			lpush(&lbl_sigZAsk, x85);
			lpush(&lbl_body, x86);
			lpush(&lbl_head, MKU64(x84));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v101, MKSTR(v102), x82);
			uint64_t v103 = VU64(lpop(&lbl_head));
			x100 = v103;
			VAL v104 = lpop(&lbl_body);
			x99 = v104;
			VAL v105 = lpop(&lbl_sigZAsk);
			x98 = v105;
			uint64_t v106 = pop_u64();
			x97 = v106;
			VAL r107 = pop_resource();
			x96 = r107;
		}
		x14 = x97;
		x13 = x99;
		x12 = x96;
		x11 = x98;
		x10 = x100;
	}
	VAL v108;
	VAL v109;
	mw_std_list_ListZPlus_1_uncons(x13, &v108, &v109);
	int64_t v110 = mw_std_list_List_1_emptyZAsk(v109);
	uint64_t x111;
	VAL x112;
	VAL x113;
	uint64_t x114;
	uint64_t x115;
	int64_t x116;
	if (((bool)v110)) {
		int64_t v117 = 1LL /* True */;
		x116 = v117;
		x115 = VU64(v108);
		x114 = x14;
		x113 = x12;
		x112 = x11;
		x111 = x10;
	} else {
		incref(v108);
		VAL v118 = mw_mirth_token_Token_runZ_arrowZAsk(VU64(v108));
		int64_t v119 = mw_std_maybe_Maybe_1_ZToBool(v118);
		x116 = v119;
		x115 = VU64(v108);
		x114 = x14;
		x113 = x12;
		x112 = x11;
		x111 = x10;
	}
	uint64_t x120;
	VAL x121;
	VAL x122;
	uint64_t x123;
	uint64_t x124;
	if (((bool)x116)) {
		x124 = x115;
		x123 = x114;
		x122 = x113;
		x121 = x112;
		x120 = x111;
	} else {
		STR* v125;
		STRLIT(v125, "expected match case", 19);
		lpush(&lbl_head, MKU64(x111));
		lpush(&lbl_sigZAsk, x112);
		push_u64(x114);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x115, MKSTR(v125), x113);
		uint64_t v126 = pop_u64();
		x124 = v126;
		uint64_t v127 = pop_u64();
		x123 = v127;
		VAL r128 = pop_resource();
		x122 = r128;
		VAL v129 = lpop(&lbl_sigZAsk);
		x121 = v129;
		uint64_t v130 = VU64(lpop(&lbl_head));
		x120 = v130;
	}
	VAL v131 = mtw_mirth_elab_SyntaxDef_SyntaxDef(x120, x121, x124);
	*x5 = v131;
	*x4 = x123;
	*x3 = x122;
}
static void mw_mirth_elab_elabZ_defZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	uint64_t v6;
	VAL v7;
	mw_mirth_elab_parseZ_def(x1, x2, &v5, &v6, &v7);
	uint64_t v8;
	VAL v9;
	uint64_t v10;
	mtp_mirth_elab_SyntaxDef_SyntaxDef(v7, &v8, &v9, &v10);
	VAL v11;
	uint64_t v12;
	uint64_t v13;
	int64_t v14;
	VAL v15;
	mw_mirth_elab_elabZ_defZ_head(v5, v8, &v11, &v12, &v13, &v14, &v15);
	uint64_t v16;
	VAL v17;
	mw_mirth_word_Word_newZBang(v12, v9, v10, v13, v14, v11, &v16, &v17);
	VAL v18 = mtw_mirth_mirth_PropLabel_WordQName(v16);
	VAL v19 = mtw_mirth_mirth_Prop_1_Prop(v18, v15);
	void* v20 = mfld_mirth_word_Word_ZTildeqname(v16);
	mut_set(v19, v20);
	int64_t v21 = VI64(VTUP(v17)->cells[3]);
	void* v22 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(v16);
	mut_set(MKI64(v21), v22);
	VAL v23 = mtw_mirth_mirth_PropLabel_WordType(v16);
	FNPTR v24 = &mb_mirth_elab_elabZ_defZBang_0;
	VAL v25;
	VAL v26;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(v16), v23, v17, MKFNPTR(v24), &v25, &v26);
	void* v27 = mfld_mirth_word_Word_ZTildectxZ_type(v16);
	mut_set(v25, v27);
	VAL v28 = mtw_mirth_mirth_PropLabel_WordParams(v16);
	FNPTR v29 = &mb_mirth_elab_elabZ_defZBang_2;
	VAL v30;
	VAL v31;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(v16), v28, v26, MKFNPTR(v29), &v30, &v31);
	void* v32 = mfld_mirth_word_Word_ZTildeparams(v16);
	mut_set(v30, v32);
	VAL v33 = mtw_mirth_mirth_PropLabel_WordArrow(v16);
	FNPTR v34 = &mb_mirth_elab_elabZ_defZBang_3;
	VAL v35;
	VAL v36;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(v16), v33, v31, MKFNPTR(v34), &v35, &v36);
	void* v37 = mfld_mirth_word_Word_ZTildearrow(v16);
	mut_set(v35, v37);
	*x4 = v6;
	*x3 = v36;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = VVAL(VTUP(x3)->cells[7]);
	incref(v4);
	decref(x3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v4, &v5, &v6);
	VAL x7;
	uint64_t x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			VAL v12 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang(x1, x2, v11));
			int64_t v13 = 1LL /* True */;
			x10 = v13;
			x9 = v6;
			x8 = x2;
			x7 = v12;
		} break;
		case 0LL: { // None
			int64_t v14 = 0LL /* False */;
			x10 = v14;
			x9 = v6;
			x8 = x2;
			x7 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15 = (x7);
	uint64_t v16 = x8;
	VAL v17 = x9;
	int64_t v18 = x10;
	while (((bool)v18)) {
		VAL v19 = (v15);
		uint64_t v20 = v16;
		VAL v21 = v17;
		VAL v22;
		VAL v23;
		mw_std_list_List_1_uncons(v21, &v22, &v23);
		VAL x24;
		uint64_t x25;
		VAL x26;
		int64_t x27;
		switch (get_data_tag(v22)) {
			case 1LL: { // Some
				VAL v28 = mtp_std_maybe_Maybe_1_Some(v22);
				VAL v29 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang(v19, v20, v28));
				int64_t v30 = 1LL /* True */;
				x27 = v30;
				x26 = v23;
				x25 = v20;
				x24 = v29;
			} break;
			case 0LL: { // None
				int64_t v31 = 0LL /* False */;
				x27 = v31;
				x26 = v23;
				x25 = v20;
				x24 = v19;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v18 = x27;
		v17 = x26;
		v16 = x25;
		v15 = x24;
	}
	decref(v17);
	return v15;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang (VAL x1, uint64_t x2, VAL x3) {
	int64_t v4 = mw_mirth_word_Word_preferZ_inlineZAsk(x2);
	VAL x5;
	if (((bool)v4)) {
		incref(x3);
		VAL v6 = VVAL(VTUP(x3)->cells[4]);
		incref(v6);
		decref(x3);
		VAL v7 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang(x1, x2, v6));
		VAL v8 = VVAL(VTUP(x3)->cells[5]);
		incref(v8);
		decref(x3);
		VAL v9;
		VAL v10;
		mw_std_list_List_1_uncons(v8, &v9, &v10);
		uint64_t x11;
		VAL x12;
		VAL x13;
		int64_t x14;
		switch (get_data_tag(v9)) {
			case 1LL: { // Some
				VAL v15 = mtp_std_maybe_Maybe_1_Some(v9);
				VAL v16 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang(v7, x2, VU64(v15)));
				int64_t v17 = 1LL /* True */;
				x14 = v17;
				x13 = v10;
				x12 = v16;
				x11 = x2;
			} break;
			case 0LL: { // None
				int64_t v18 = 0LL /* False */;
				x14 = v18;
				x13 = v10;
				x12 = v7;
				x11 = x2;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v19 = x11;
		VAL v20 = (x12);
		VAL v21 = x13;
		int64_t v22 = x14;
		while (((bool)v22)) {
			uint64_t v23 = v19;
			VAL v24 = (v20);
			VAL v25 = v21;
			VAL v26;
			VAL v27;
			mw_std_list_List_1_uncons(v25, &v26, &v27);
			uint64_t x28;
			VAL x29;
			VAL x30;
			int64_t x31;
			switch (get_data_tag(v26)) {
				case 1LL: { // Some
					VAL v32 = mtp_std_maybe_Maybe_1_Some(v26);
					VAL v33 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang(v24, v23, VU64(v32)));
					int64_t v34 = 1LL /* True */;
					x31 = v34;
					x30 = v27;
					x29 = v33;
					x28 = v23;
				} break;
				case 0LL: { // None
					int64_t v35 = 0LL /* False */;
					x31 = v35;
					x30 = v27;
					x29 = v24;
					x28 = v23;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v22 = x31;
			v21 = x30;
			v20 = x29;
			v19 = x28;
		}
		decref(v21);
		x5 = v20;
	} else {
		decref(x3);
		x5 = x1;
	}
	return x5;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang (VAL x1, uint64_t x2, uint64_t x3) {
	VAL v4;
	VAL v5;
	mw_mirth_arrow_Block_arrow(x1, x3, &v4, &v5);
	VAL v6 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(v4, x2, v5));
	return v6;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL x4;
	switch (get_data_tag(x3)) {
		case 15LL: { // OpBlockRun
			uint64_t v5 = mtp_mirth_arrow_Op_OpBlockRun(x3);
			VAL v6;
			VAL v7;
			mw_mirth_arrow_Block_arrow(x1, v5, &v6, &v7);
			VAL v8 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(v6, x2, v7));
			x4 = v8;
		} break;
		case 2LL: { // OpWord
			uint64_t v9 = mtp_mirth_arrow_Op_OpWord(x3);
			int64_t v10 = mw_mirth_word_Word_ZEqualZEqual(x2, v9);
			VAL x11;
			if (((bool)v10)) {
				VAL v12 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang(x1, x2));
				x11 = v12;
			} else {
				int64_t v13 = mw_mirth_word_Word_preferZ_inlineZAsk(v9);
				VAL x14;
				if (((bool)v13)) {
					void* v15 = mfld_mirth_word_Word_ZTildearrow(v9);
					VAL v16;
					VAL v17;
					mw_mirth_mirth_Prop_1_tryZ_forceZBang(v15, x1, &v16, &v17);
					VAL x18;
					switch (get_data_tag(v16)) {
						case 1LL: { // Some
							VAL v19 = mtp_std_maybe_Maybe_1_Some(v16);
							VAL v20 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(v17, x2, v19));
							x18 = v20;
						} break;
						case 0LL: { // None
							VAL v21 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang(v17, x2));
							x18 = v21;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x14 = x18;
				} else {
					x14 = x1;
				}
				x11 = x14;
			}
			x4 = x11;
		} break;
		case 11LL: { // OpMatch
			VAL v22 = mtp_mirth_arrow_Op_OpMatch(x3);
			VAL v23 = VVAL(VTUP(v22)->cells[7]);
			incref(v23);
			decref(v22);
			VAL v24;
			VAL v25;
			mw_std_list_List_1_uncons(v23, &v24, &v25);
			VAL x26;
			uint64_t x27;
			VAL x28;
			int64_t x29;
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v30 = mtp_std_maybe_Maybe_1_Some(v24);
					VAL v31 = VVAL(VTUP(v30)->cells[2]);
					incref(v31);
					decref(v30);
					VAL v32 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(x1, x2, v31));
					int64_t v33 = 1LL /* True */;
					x29 = v33;
					x28 = v25;
					x27 = x2;
					x26 = v32;
				} break;
				case 0LL: { // None
					int64_t v34 = 0LL /* False */;
					x29 = v34;
					x28 = v25;
					x27 = x2;
					x26 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v35 = (x26);
			uint64_t v36 = x27;
			VAL v37 = x28;
			int64_t v38 = x29;
			while (((bool)v38)) {
				VAL v39 = (v35);
				uint64_t v40 = v36;
				VAL v41 = v37;
				VAL v42;
				VAL v43;
				mw_std_list_List_1_uncons(v41, &v42, &v43);
				VAL x44;
				uint64_t x45;
				VAL x46;
				int64_t x47;
				switch (get_data_tag(v42)) {
					case 1LL: { // Some
						VAL v48 = mtp_std_maybe_Maybe_1_Some(v42);
						VAL v49 = VVAL(VTUP(v48)->cells[2]);
						incref(v49);
						decref(v48);
						VAL v50 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(v39, v40, v49));
						int64_t v51 = 1LL /* True */;
						x47 = v51;
						x46 = v43;
						x45 = v40;
						x44 = v50;
					} break;
					case 0LL: { // None
						int64_t v52 = 0LL /* False */;
						x47 = v52;
						x46 = v43;
						x45 = v40;
						x44 = v39;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v38 = x47;
				v37 = x46;
				v36 = x45;
				v35 = x44;
			}
			decref(v37);
			x4 = v35;
		} break;
		case 12LL: { // OpLambda
			VAL v53 = mtp_mirth_arrow_Op_OpLambda(x3);
			VAL v54 = VVAL(VTUP(v53)->cells[5]);
			incref(v54);
			decref(v53);
			VAL v55 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(x1, x2, v54));
			x4 = v55;
		} break;
		default: {
			decref(x3);
			x4 = x1;
		} break;
	}
	return x4;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang (VAL x1, uint64_t x2) {
	int64_t v3 = mw_mirth_word_Word_preferZ_inlineZAsk(x2);
	VAL x4;
	if (((bool)v3)) {
		int64_t v5 = 0LL /* False */;
		void* v6 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(x2);
		mut_set(MKI64(v5), v6);
		uint64_t v7 = mw_mirth_word_Word_head(x2);
		STR* v8;
		STRLIT(v8, "recursive word cannot be inlined", 32);
		VAL v9 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(v7, MKSTR(v8), x1));
		x4 = v9;
	} else {
		x4 = x1;
	}
	return x4;
}
static void mw_mirth_elab_elabZ_defZ_paramsZBang (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = MKI64(0LL /* Nil */);
	VAL v6;
	VAL v7;
	mw_mirth_word_Word_type(x2, x1, &v6, &v7);
	uint64_t v8 = mw_mirth_word_Word_head(x2);
	VAL v9;
	VAL v10;
	mw_mirth_type_ArrowType_unpack(v6, &v9, &v10);
	decref(v10);
	VAL v11 = mw_mirth_token_Token_args(v8);
	VAL v12 = mw_std_list_List_1_reverse(v11);
	VAL v13;
	VAL v14;
	mw_std_list_List_1_uncons(v12, &v13, &v14);
	VAL x15;
	VAL x16;
	VAL x17;
	VAL x18;
	int64_t x19;
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(v13);
			incref(v20);
			VAL v21 = mw_mirth_token_Token_sigZ_paramZ_nameZAsk(VU64(v20));
			VAL x22;
			VAL x23;
			VAL x24;
			uint64_t x25;
			uint64_t x26;
			switch (get_data_tag(v21)) {
				case 1LL: { // Some
					VAL v27 = mtp_std_maybe_Maybe_1_Some(v21);
					x26 = VU64(v27);
					x25 = VU64(v20);
					x24 = v9;
					x23 = v5;
					x22 = v7;
				} break;
				case 0LL: { // None
					STR* v28;
					STRLIT(v28, "expected parameter name", 23);
					push_value(v5);
					push_value(v9);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v20), MKSTR(v28), v7);
					uint64_t v29 = pop_u64();
					x26 = v29;
					uint64_t v30 = pop_u64();
					x25 = v30;
					VAL v31 = pop_value();
					x24 = v31;
					VAL v32 = pop_value();
					x23 = v32;
					VAL r33 = pop_resource();
					x22 = r33;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v34 = mw_mirth_token_Token_succ(x25);
			int64_t v35 = mw_mirth_token_Token_runZ_endZAsk(v34);
			VAL x36;
			VAL x37;
			VAL x38;
			uint64_t x39;
			uint64_t x40;
			if (((bool)v35)) {
				x40 = x25;
				x39 = x26;
				x38 = x24;
				x37 = x23;
				x36 = x22;
			} else {
				STR* v41;
				STRLIT(v41, "expected right paren or comma", 29);
				push_value(x23);
				push_value(x24);
				lpush(&lbl_name, MKU64(x26));
				push_u64(x25);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v34, MKSTR(v41), x22);
				uint64_t v42 = pop_u64();
				x40 = v42;
				uint64_t v43 = VU64(lpop(&lbl_name));
				x39 = v43;
				VAL v44 = pop_value();
				x38 = v44;
				VAL v45 = pop_value();
				x37 = v45;
				VAL r46 = pop_resource();
				x36 = r46;
			}
			VAL v47;
			VAL v48;
			VAL v49;
			uint64_t v50;
			mw_mirth_elab_elabZ_expandZ_tensorZBang(x36, x38, x40, &v47, &v48, &v49, &v50);
			VAL v51 = mw_mirth_type_Type_morphismZAsk(v49);
			VAL x52;
			uint64_t x53;
			VAL x54;
			VAL x55;
			uint64_t x56;
			VAL x57;
			switch (get_data_tag(v51)) {
				case 1LL: { // Some
					VAL v58 = mtp_std_maybe_Maybe_1_Some(v51);
					x57 = v58;
					x56 = v50;
					x55 = v48;
					x54 = v47;
					x53 = x39;
					x52 = x37;
				} break;
				case 0LL: { // None
					STR* v59;
					STRLIT(v59, "need function type for param", 28);
					push_value(x37);
					lpush(&lbl_name, MKU64(x39));
					push_value(v48);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v50, MKSTR(v59), v47);
					VAL v60 = pop_value();
					x57 = v60;
					uint64_t v61 = pop_u64();
					x56 = v61;
					VAL v62 = pop_value();
					x55 = v62;
					VAL r63 = pop_resource();
					x54 = r63;
					uint64_t v64 = VU64(lpop(&lbl_name));
					x53 = v64;
					VAL v65 = pop_value();
					x52 = v65;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v66 = mw_mirth_var_Var_newZ_autoZ_runZBang(x57, x53);
			VAL v67 = mtw_std_list_List_1_Cons(MKU64(v66), x52);
			int64_t v68 = 1LL /* True */;
			x19 = v68;
			x18 = v14;
			x17 = x55;
			x16 = v67;
			x15 = x54;
		} break;
		case 0LL: { // None
			int64_t v69 = 0LL /* False */;
			x19 = v69;
			x18 = v14;
			x17 = v9;
			x16 = v5;
			x15 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v70 = (x15);
	VAL v71 = x16;
	VAL v72 = x17;
	VAL v73 = x18;
	int64_t v74 = x19;
	while (((bool)v74)) {
		VAL v75 = (v70);
		VAL v76 = v71;
		VAL v77 = v72;
		VAL v78 = v73;
		VAL v79;
		VAL v80;
		mw_std_list_List_1_uncons(v78, &v79, &v80);
		VAL x81;
		VAL x82;
		VAL x83;
		VAL x84;
		int64_t x85;
		switch (get_data_tag(v79)) {
			case 1LL: { // Some
				VAL v86 = mtp_std_maybe_Maybe_1_Some(v79);
				incref(v86);
				VAL v87 = mw_mirth_token_Token_sigZ_paramZ_nameZAsk(VU64(v86));
				VAL x88;
				VAL x89;
				VAL x90;
				uint64_t x91;
				uint64_t x92;
				switch (get_data_tag(v87)) {
					case 1LL: { // Some
						VAL v93 = mtp_std_maybe_Maybe_1_Some(v87);
						x92 = VU64(v93);
						x91 = VU64(v86);
						x90 = v77;
						x89 = v76;
						x88 = v75;
					} break;
					case 0LL: { // None
						STR* v94;
						STRLIT(v94, "expected parameter name", 23);
						push_value(v76);
						push_value(v77);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v86), MKSTR(v94), v75);
						uint64_t v95 = pop_u64();
						x92 = v95;
						uint64_t v96 = pop_u64();
						x91 = v96;
						VAL v97 = pop_value();
						x90 = v97;
						VAL v98 = pop_value();
						x89 = v98;
						VAL r99 = pop_resource();
						x88 = r99;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				uint64_t v100 = mw_mirth_token_Token_succ(x91);
				int64_t v101 = mw_mirth_token_Token_runZ_endZAsk(v100);
				VAL x102;
				VAL x103;
				VAL x104;
				uint64_t x105;
				uint64_t x106;
				if (((bool)v101)) {
					x106 = x91;
					x105 = x92;
					x104 = x90;
					x103 = x89;
					x102 = x88;
				} else {
					STR* v107;
					STRLIT(v107, "expected right paren or comma", 29);
					push_value(x89);
					push_value(x90);
					lpush(&lbl_name, MKU64(x92));
					push_u64(x91);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v100, MKSTR(v107), x88);
					uint64_t v108 = pop_u64();
					x106 = v108;
					uint64_t v109 = VU64(lpop(&lbl_name));
					x105 = v109;
					VAL v110 = pop_value();
					x104 = v110;
					VAL v111 = pop_value();
					x103 = v111;
					VAL r112 = pop_resource();
					x102 = r112;
				}
				VAL v113;
				VAL v114;
				VAL v115;
				uint64_t v116;
				mw_mirth_elab_elabZ_expandZ_tensorZBang(x102, x104, x106, &v113, &v114, &v115, &v116);
				VAL v117 = mw_mirth_type_Type_morphismZAsk(v115);
				VAL x118;
				uint64_t x119;
				VAL x120;
				VAL x121;
				uint64_t x122;
				VAL x123;
				switch (get_data_tag(v117)) {
					case 1LL: { // Some
						VAL v124 = mtp_std_maybe_Maybe_1_Some(v117);
						x123 = v124;
						x122 = v116;
						x121 = v114;
						x120 = v113;
						x119 = x105;
						x118 = x103;
					} break;
					case 0LL: { // None
						STR* v125;
						STRLIT(v125, "need function type for param", 28);
						push_value(x103);
						lpush(&lbl_name, MKU64(x105));
						push_value(v114);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v116, MKSTR(v125), v113);
						VAL v126 = pop_value();
						x123 = v126;
						uint64_t v127 = pop_u64();
						x122 = v127;
						VAL v128 = pop_value();
						x121 = v128;
						VAL r129 = pop_resource();
						x120 = r129;
						uint64_t v130 = VU64(lpop(&lbl_name));
						x119 = v130;
						VAL v131 = pop_value();
						x118 = v131;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				uint64_t v132 = mw_mirth_var_Var_newZ_autoZ_runZBang(x123, x119);
				VAL v133 = mtw_std_list_List_1_Cons(MKU64(v132), x118);
				int64_t v134 = 1LL /* True */;
				x85 = v134;
				x84 = v80;
				x83 = x121;
				x82 = v133;
				x81 = x120;
			} break;
			case 0LL: { // None
				int64_t v135 = 0LL /* False */;
				x85 = v135;
				x84 = v80;
				x83 = v77;
				x82 = v76;
				x81 = v75;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v74 = x85;
		v73 = x84;
		v72 = x83;
		v71 = x82;
		v70 = x81;
	}
	decref(v73);
	decref(v72);
	*x4 = v71;
	*x3 = v70;
}
static void mw_mirth_elab_elabZ_defZ_bodyZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7;
	uint64_t v8;
	mw_mirth_elab_abZ_tokenZAt(x3, &v7, &v8);
	VAL v9 = mw_mirth_token_Token_runZ_arrowZAsk(v8);
	VAL x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v9);
			decref(v14);
			int64_t v15 = 1LL /* True */;
			x13 = v15;
			x12 = v7;
			x11 = x2;
			x10 = x1;
		} break;
		case 0LL: { // None
			VAL v16;
			uint64_t v17;
			mw_mirth_elab_abZ_tokenZAt(v7, &v16, &v17);
			VAL v18 = mw_mirth_token_Token_lcurlyZAsk(v17);
			int64_t v19 = mw_std_maybe_Maybe_1_someZAsk(v18);
			x13 = v19;
			x12 = v16;
			x11 = x2;
			x10 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x20;
	VAL x21;
	VAL x22;
	if (((bool)x13)) {
		incref(x10);
		VAL v23;
		uint64_t v24;
		mw_mirth_elab_abZ_tokenZAt(x12, &v23, &v24);
		VAL v25;
		VAL v26;
		mw_mirth_elab_elabZ_matchZ_atZBang(x10, v24, x11, v23, &v25, &v26);
		x22 = v26;
		x21 = v25;
		x20 = x10;
	} else {
		VAL v27;
		VAL v28;
		mw_mirth_elab_elabZ_atomsZBang(x11, x12, &v27, &v28);
		x22 = v28;
		x21 = v27;
		x20 = x10;
	}
	*x6 = x22;
	*x5 = x21;
	*x4 = x20;
}
static void mw_mirth_elab_parseZ_externalZ_decl (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	uint64_t v6 = mw_mirth_token_Token_next(x2);
	uint64_t v7 = mw_mirth_token_Token_succ(x2);
	VAL v8 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v7);
	VAL x9;
	uint64_t x10;
	uint64_t x11;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v8);
			decref(v12);
			x11 = v7;
			x10 = v6;
			x9 = x1;
		} break;
		case 0LL: { // None
			uint64_t v13 = mw_mirth_token_Token_pred(v7);
			STR* v14;
			STRLIT(v14, "", 0);
			VAL v15 = MKI64(36LL /* FGCyan */);
			VAL v16 = (mw_std_terminal_Sgr_emitZThen(v15, MKSTR(v14)));
			STR* v17;
			STRLIT(v17, "external", 8);
			VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v17), v16));
			VAL v19 = MKI64(0LL /* Reset */);
			VAL v20 = (mw_std_terminal_Sgr_emitZThen(v19, v18));
			STR* v21;
			STRLIT(v21, " requires arguments", 19);
			VAL v22 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v21), v20));
			push_u64(v6);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v13, v22, x1);
			uint64_t v23 = pop_u64();
			x11 = v23;
			uint64_t v24 = pop_u64();
			x10 = v24;
			VAL r25 = pop_resource();
			x9 = r25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v26 = MKI64(0LL /* Nil */);
	VAL v27 = mw_std_list_List_1_reverse(v26);
	uint64_t v28 = mw_mirth_token_Token_succ(x11);
	int64_t v29 = mw_mirth_token_Token_argsZ_endZAsk(v28);
	bool v30 = !((bool)v29);
	VAL v31 = (x9);
	uint64_t v32 = x10;
	VAL v33 = (v27);
	uint64_t v34 = v28;
	bool v35 = v30;
	while (v35) {
		VAL v36 = (v31);
		uint64_t v37 = v32;
		VAL v38 = (v33);
		uint64_t v39 = v34;
		VAL v40;
		uint64_t v41;
		VAL v42;
		mw_mirth_elab_parseZ_externalZ_declZ_part(v36, v39, &v40, &v41, &v42);
		VAL v43 = mtw_std_list_List_1_Cons(v42, v38);
		int64_t v44 = mw_mirth_token_Token_argsZ_endZAsk(v41);
		bool v45 = !((bool)v44);
		v35 = v45;
		v34 = v41;
		v33 = v43;
		v32 = v37;
		v31 = v40;
	}
	VAL v46 = mw_std_list_List_1_reverse(v33);
	*x5 = v46;
	*x4 = v32;
	*x3 = v31;
}
static void mw_mirth_elab_parseZ_externalZ_declZ_part (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, VAL *x5) {
	VAL v6 = mw_mirth_token_Token_strZAsk(x2);
	VAL x7;
	uint64_t x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
			uint64_t v11 = mw_mirth_token_Token_succ(x2);
			VAL v12 = mtw_mirth_elab_ExternalDeclPart_EDPCode(x2, v10);
			x9 = v12;
			x8 = v11;
			x7 = x1;
		} break;
		case 0LL: { // None
			VAL v13 = mw_mirth_token_Token_nameZDivdnameZAsk(x2);
			VAL x14;
			uint64_t x15;
			uint64_t x16;
			switch (get_data_tag(v13)) {
				case 1LL: { // Some
					VAL v17 = mtp_std_maybe_Maybe_1_Some(v13);
					decref(v17);
					x16 = x2;
					x15 = x2;
					x14 = x1;
				} break;
				case 0LL: { // None
					STR* v18;
					STRLIT(v18, "expected external word name", 27);
					lpush(&lbl_head, MKU64(x2));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v18), x1);
					uint64_t v19 = pop_u64();
					x16 = v19;
					uint64_t v20 = VU64(lpop(&lbl_head));
					x15 = v20;
					VAL r21 = pop_resource();
					x14 = r21;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v22 = mw_mirth_token_Token_succ(x16);
			int64_t v23 = mw_mirth_token_Token_arrowZAsk(v22);
			VAL x24;
			uint64_t x25;
			VAL x26;
			uint64_t x27;
			if (((bool)v23)) {
				uint64_t v28 = mw_mirth_token_Token_succ(v22);
				VAL v29 = mw_mirth_token_Token_nameZAsk(v28);
				VAL x30;
				uint64_t x31;
				uint64_t x32;
				switch (get_data_tag(v29)) {
					case 1LL: { // Some
						VAL v33 = mtp_std_maybe_Maybe_1_Some(v29);
						decref(v33);
						x32 = v28;
						x31 = x15;
						x30 = x14;
					} break;
					case 0LL: { // None
						STR* v34;
						STRLIT(v34, "expected external symbol name", 29);
						lpush(&lbl_head, MKU64(x15));
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v28, MKSTR(v34), x14);
						uint64_t v35 = pop_u64();
						x32 = v35;
						uint64_t v36 = VU64(lpop(&lbl_head));
						x31 = v36;
						VAL r37 = pop_resource();
						x30 = r37;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v38 = mtw_std_maybe_Maybe_1_Some(MKU64(x32));
				uint64_t v39 = mw_mirth_token_Token_succ(x32);
				x27 = v39;
				x26 = v38;
				x25 = x31;
				x24 = x30;
			} else {
				VAL v40 = MKI64(0LL /* None */);
				x27 = v22;
				x26 = v40;
				x25 = x15;
				x24 = x14;
			}
			VAL v41 = mw_mirth_token_Token_lsquareZAsk(x27);
			uint64_t x42;
			VAL x43;
			VAL x44;
			uint64_t x45;
			uint64_t x46;
			switch (get_data_tag(v41)) {
				case 1LL: { // Some
					VAL v47 = mtp_std_maybe_Maybe_1_Some(v41);
					decref(v47);
					uint64_t v48;
					VAL v49;
					mw_mirth_token_Token_argsZ_1(x27, x24, &v48, &v49);
					uint64_t v50 = mw_mirth_token_Token_next(x27);
					x46 = v50;
					x45 = v48;
					x44 = v49;
					x43 = x26;
					x42 = x25;
				} break;
				case 0LL: { // None
					int64_t v51 = mw_mirth_token_Token_commaZAsk(x27);
					VAL x52;
					uint64_t x53;
					VAL x54;
					uint64_t x55;
					if (((bool)v51)) {
						x55 = x27;
						x54 = x26;
						x53 = x25;
						x52 = x24;
					} else {
						STR* v56;
						STRLIT(v56, "expected type signature", 23);
						lpush(&lbl_head, MKU64(x25));
						lpush(&lbl_symbol, x26);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x27, MKSTR(v56), x24);
						uint64_t v57 = pop_u64();
						x55 = v57;
						VAL v58 = lpop(&lbl_symbol);
						x54 = v58;
						uint64_t v59 = VU64(lpop(&lbl_head));
						x53 = v59;
						VAL r60 = pop_resource();
						x52 = r60;
					}
					uint64_t v61 = mw_mirth_token_Token_succ(x55);
					int64_t v62 = mw_mirth_token_Token_argZ_endZAsk(v61);
					VAL x63;
					uint64_t x64;
					VAL x65;
					uint64_t x66;
					if (((bool)v62)) {
						STR* v67;
						STRLIT(v67, "expected type signature", 23);
						lpush(&lbl_head, MKU64(x53));
						lpush(&lbl_symbol, x54);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v61, MKSTR(v67), x52);
						uint64_t v68 = pop_u64();
						x66 = v68;
						VAL v69 = lpop(&lbl_symbol);
						x65 = v69;
						uint64_t v70 = VU64(lpop(&lbl_head));
						x64 = v70;
						VAL r71 = pop_resource();
						x63 = r71;
					} else {
						x66 = v61;
						x65 = x54;
						x64 = x53;
						x63 = x52;
					}
					uint64_t v72 = mw_mirth_token_Token_nextZ_argZ_end(x66);
					x46 = v72;
					x45 = x66;
					x44 = x63;
					x43 = x65;
					x42 = x64;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v73 = mtw_mirth_elab_ExternalDeclPart_EDPDef(x42, x43, x45);
			x9 = v73;
			x8 = x46;
			x7 = x44;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v74 = mw_mirth_token_Token_commaZAsk(x8);
	VAL x75;
	uint64_t x76;
	if (((bool)v74)) {
		uint64_t v77 = mw_mirth_token_Token_succ(x8);
		x76 = v77;
		x75 = x7;
	} else {
		x76 = x8;
		x75 = x7;
	}
	*x5 = x9;
	*x4 = x76;
	*x3 = x75;
}
static void mw_mirth_elab_elabZ_externalZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	uint64_t v6;
	VAL v7;
	mw_mirth_elab_parseZ_externalZ_decl(x1, x2, &v5, &v6, &v7);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mw_std_list_List_1_reverse(v8);
	VAL v10;
	VAL v11;
	mw_std_list_List_1_uncons(v7, &v10, &v11);
	uint64_t x12;
	VAL x13;
	uint64_t x14;
	VAL x15;
	VAL x16;
	int64_t x17;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v18 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v19;
			VAL v20;
			mw_mirth_elab_elabZ_externalZ_blockZ_partZBang(v5, v18, &v19, &v20);
			VAL v21 = mtw_std_list_List_1_Cons(v20, v9);
			int64_t v22 = 1LL /* True */;
			x17 = v22;
			x16 = v11;
			x15 = v21;
			x14 = v6;
			x13 = v19;
			x12 = x2;
		} break;
		case 0LL: { // None
			int64_t v23 = 0LL /* False */;
			x17 = v23;
			x16 = v11;
			x15 = v9;
			x14 = v6;
			x13 = v5;
			x12 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v24 = x12;
	VAL v25 = (x13);
	uint64_t v26 = x14;
	VAL v27 = (x15);
	VAL v28 = x16;
	int64_t v29 = x17;
	while (((bool)v29)) {
		uint64_t v30 = v24;
		VAL v31 = (v25);
		uint64_t v32 = v26;
		VAL v33 = (v27);
		VAL v34 = v28;
		VAL v35;
		VAL v36;
		mw_std_list_List_1_uncons(v34, &v35, &v36);
		uint64_t x37;
		VAL x38;
		uint64_t x39;
		VAL x40;
		VAL x41;
		int64_t x42;
		switch (get_data_tag(v35)) {
			case 1LL: { // Some
				VAL v43 = mtp_std_maybe_Maybe_1_Some(v35);
				VAL v44;
				VAL v45;
				mw_mirth_elab_elabZ_externalZ_blockZ_partZBang(v31, v43, &v44, &v45);
				VAL v46 = mtw_std_list_List_1_Cons(v45, v33);
				int64_t v47 = 1LL /* True */;
				x42 = v47;
				x41 = v36;
				x40 = v46;
				x39 = v32;
				x38 = v44;
				x37 = v30;
			} break;
			case 0LL: { // None
				int64_t v48 = 0LL /* False */;
				x42 = v48;
				x41 = v36;
				x40 = v33;
				x39 = v32;
				x38 = v31;
				x37 = v30;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v29 = x42;
		v28 = x41;
		v27 = x40;
		v26 = x39;
		v25 = x38;
		v24 = x37;
	}
	decref(v28);
	VAL v49 = mw_std_list_List_1_reverse(v27);
	uint64_t v50 = mw_mirth_external_ExternalBlock_allocZBang();
	void* v51 = mfld_mirth_external_ExternalBlock_ZTildetoken(v50);
	mut_set(MKU64(v24), v51);
	void* v52 = mfld_mirth_external_ExternalBlock_ZTildeparts(v50);
	mut_set(v49, v52);
	*x4 = v26;
	*x3 = v25;
}
static void mw_mirth_elab_elabZ_externalZ_blockZ_partZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x2)) {
		case 0LL: { // EDPCode
			uint64_t v7;
			VAL v8;
			mtp_mirth_elab_ExternalDeclPart_EDPCode(x2, &v7, &v8);
			VAL v9 = mtw_mirth_external_ExternalBlockPart_EBPCode(v8);
			x6 = v9;
			x5 = x1;
		} break;
		case 1LL: { // EDPDef
			uint64_t v10;
			VAL v11;
			uint64_t v12;
			mtp_mirth_elab_ExternalDeclPart_EDPDef(x2, &v10, &v11, &v12);
			VAL v13;
			uint64_t v14;
			mw_mirth_elab_elabZ_externalZ_defZBang(x1, v10, v11, v12, &v13, &v14);
			VAL v15 = mtw_mirth_external_ExternalBlockPart_EBPDef(v14);
			x6 = v15;
			x5 = v13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static void mw_mirth_elab_elabZ_externalZ_defZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL *x5, uint64_t *x6) {
	VAL v7;
	uint64_t v8;
	uint64_t v9;
	int64_t v10;
	VAL v11;
	mw_mirth_elab_elabZ_defZ_head(x1, x2, &v7, &v8, &v9, &v10, &v11);
	uint64_t x12;
	VAL x13;
	uint64_t x14;
	uint64_t x15;
	int64_t x16;
	VAL x17;
	VAL x18;
	switch (get_data_tag(x3)) {
		case 1LL: { // Some
			VAL v19 = mtp_std_maybe_Maybe_1_Some(x3);
			VAL v20 = mw_mirth_token_Token_nameZAsk(VU64(v19));
			x18 = v20;
			x17 = v11;
			x16 = v10;
			x15 = v9;
			x14 = v8;
			x13 = v7;
			x12 = x4;
		} break;
		case 0LL: { // None
			VAL v21 = MKI64(0LL /* None */);
			x18 = v21;
			x17 = v11;
			x16 = v10;
			x15 = v9;
			x14 = v8;
			x13 = v7;
			x12 = x4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t x22;
	VAL x23;
	uint64_t x24;
	uint64_t x25;
	int64_t x26;
	VAL x27;
	uint64_t x28;
	switch (get_data_tag(x18)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(x18);
			x28 = VU64(v29);
			x27 = x17;
			x26 = x16;
			x25 = x15;
			x24 = x14;
			x23 = x13;
			x22 = x12;
		} break;
		case 0LL: { // None
			x28 = x15;
			x27 = x17;
			x26 = x16;
			x25 = x15;
			x24 = x14;
			x23 = x13;
			x22 = x12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v30 = mw_mirth_name_Name_ZToStr(x28);
	uint64_t v31 = mw_mirth_external_External_allocZBang();
	void* v32 = mfld_mirth_external_External_ZTildename(v31);
	mut_set(MKU64(x25), v32);
	void* v33 = mfld_mirth_external_External_ZTildearity(v31);
	mut_set(MKI64(x26), v33);
	VAL v34 = mtw_mirth_mirth_PropLabel_ExternalQName(v31);
	VAL v35 = mtw_mirth_mirth_Prop_1_Prop(v34, x27);
	void* v36 = mfld_mirth_external_External_ZTildeqname(v31);
	mut_set(v35, v36);
	void* v37 = mfld_mirth_external_External_ZTildesymbol(v31);
	mut_set(v30, v37);
	void* v38 = mfld_mirth_external_External_ZTildesig(v31);
	mut_set(MKU64(x22), v38);
	void* v39 = mfld_mirth_external_External_ZTildehead(v31);
	mut_set(MKU64(x24), v39);
	VAL v40 = mtw_mirth_mirth_PropLabel_ExternalType(v31);
	FNPTR v41 = &mb_mirth_elab_elabZ_externalZ_defZBang_2;
	VAL v42;
	VAL v43;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(v31), v40, x23, MKFNPTR(v41), &v42, &v43);
	void* v44 = mfld_mirth_external_External_ZTildectxZ_type(v31);
	mut_set(v42, v44);
	VAL v45 = mtw_mirth_mirth_PropLabel_ExternalCType(v31);
	FNPTR v46 = &mb_mirth_elab_elabZ_externalZ_defZBang_4;
	VAL v47;
	VAL v48;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(v31), v45, v43, MKFNPTR(v46), &v47, &v48);
	void* v49 = mfld_mirth_external_External_ZTildectype(v31);
	mut_set(v47, v49);
	VAL v50 = mtw_mirth_def_Def_DefExternal(v31);
	VAL v51 = (mw_mirth_def_Def_register(v48, v50));
	*x6 = v31;
	*x5 = v51;
}
static void mw_mirth_elab_elabZ_defZ_externalZ_ctype (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	uint64_t v5 = mw_mirth_external_External_head(x2);
	VAL v6 = VVAL(VTUP(x1)->cells[5]);
	incref(v6);
	VAL v7 = mtw_std_maybe_Maybe_1_Some(MKU64(v5));
	VAL v8 = VTUP(x1)->cells[5];
	decref(v8);
	VTUP(x1)->cells[5] = v7;
	VAL v9;
	VAL v10;
	mw_mirth_external_External_type(x1, x2, &v9, &v10);
	VAL v11;
	VAL v12;
	mw_mirth_type_ArrowType_ctype(v10, v9, &v11, &v12);
	incref(v11);
	VAL v13 = VVAL(VTUP(v11)->cells[2]);
	incref(v13);
	decref(v11);
	VAL v14 = VVAL(VTUP(v13)->cells[2]);
	incref(v14);
	decref(v13);
	VAL v15 = MKI64(0LL /* Nil */);
	VAL v16 = mw_std_list_List_1_reverse(v15);
	VAL v17;
	VAL v18;
	mw_std_list_List_1_uncons(v14, &v17, &v18);
	VAL x19;
	VAL x20;
	VAL x21;
	VAL x22;
	int64_t x23;
	switch (get_data_tag(v17)) {
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v17);
			incref(v24);
			VAL v25 = mw_mirth_type_CTypeStackPart_labelZAsk(v24);
			int64_t v26 = mw_std_maybe_Maybe_1_noneZAsk(v25);
			VAL x27;
			VAL x28;
			VAL x29;
			if (((bool)v26)) {
				VAL v30 = mtw_std_maybe_Maybe_1_Some(v24);
				x29 = v30;
				x28 = v11;
				x27 = v12;
			} else {
				decref(v24);
				VAL v31 = MKI64(0LL /* None */);
				x29 = v31;
				x28 = v11;
				x27 = v12;
			}
			VAL x32;
			switch (get_data_tag(x29)) {
				case 1LL: { // Some
					VAL v33 = mtp_std_maybe_Maybe_1_Some(x29);
					VAL v34 = mtw_std_list_List_1_Cons(v33, v16);
					x32 = v34;
					push_resource(x27);
					push_value(x28);
				} break;
				case 0LL: { // None
					x32 = v16;
					push_resource(x27);
					push_value(x28);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v35 = 1LL /* True */;
			x23 = v35;
			x22 = v18;
			x21 = x32;
			VAL v36 = pop_value();
			x20 = v36;
			VAL r37 = pop_resource();
			x19 = r37;
		} break;
		case 0LL: { // None
			int64_t v38 = 0LL /* False */;
			x23 = v38;
			x22 = v18;
			x21 = v16;
			x20 = v11;
			x19 = v12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v39 = (x19);
	VAL v40 = x20;
	VAL v41 = (x21);
	VAL v42 = x22;
	int64_t v43 = x23;
	while (((bool)v43)) {
		VAL v44 = (v39);
		VAL v45 = v40;
		VAL v46 = (v41);
		VAL v47 = v42;
		VAL v48;
		VAL v49;
		mw_std_list_List_1_uncons(v47, &v48, &v49);
		VAL x50;
		VAL x51;
		VAL x52;
		VAL x53;
		int64_t x54;
		switch (get_data_tag(v48)) {
			case 1LL: { // Some
				VAL v55 = mtp_std_maybe_Maybe_1_Some(v48);
				incref(v55);
				VAL v56 = mw_mirth_type_CTypeStackPart_labelZAsk(v55);
				int64_t v57 = mw_std_maybe_Maybe_1_noneZAsk(v56);
				VAL x58;
				VAL x59;
				VAL x60;
				if (((bool)v57)) {
					VAL v61 = mtw_std_maybe_Maybe_1_Some(v55);
					x60 = v61;
					x59 = v45;
					x58 = v44;
				} else {
					decref(v55);
					VAL v62 = MKI64(0LL /* None */);
					x60 = v62;
					x59 = v45;
					x58 = v44;
				}
				VAL x63;
				switch (get_data_tag(x60)) {
					case 1LL: { // Some
						VAL v64 = mtp_std_maybe_Maybe_1_Some(x60);
						VAL v65 = mtw_std_list_List_1_Cons(v64, v46);
						x63 = v65;
						push_resource(x58);
						push_value(x59);
					} break;
					case 0LL: { // None
						x63 = v46;
						push_resource(x58);
						push_value(x59);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v66 = 1LL /* True */;
				x54 = v66;
				x53 = v49;
				x52 = x63;
				VAL v67 = pop_value();
				x51 = v67;
				VAL r68 = pop_resource();
				x50 = r68;
			} break;
			case 0LL: { // None
				int64_t v69 = 0LL /* False */;
				x54 = v69;
				x53 = v49;
				x52 = v46;
				x51 = v45;
				x50 = v44;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v43 = x54;
		v42 = x53;
		v41 = x52;
		v40 = x51;
		v39 = x50;
	}
	decref(v42);
	VAL v70 = mw_std_list_List_1_reverse(v41);
	VAL v71 = MKI64(0LL /* Nil */);
	VAL v72 = mw_std_list_List_1_reverse(v71);
	VAL v73;
	VAL v74;
	mw_std_list_List_1_uncons(v70, &v73, &v74);
	VAL x75;
	VAL x76;
	VAL x77;
	VAL x78;
	int64_t x79;
	switch (get_data_tag(v73)) {
		case 1LL: { // Some
			VAL v80 = mtp_std_maybe_Maybe_1_Some(v73);
			incref(v80);
			VAL v81 = mw_mirth_type_CTypeStackPart_ctype(v80);
			int64_t v82 = mw_mirth_type_CType_phantomZAsk(v81);
			bool v83 = !((bool)v82);
			VAL x84;
			VAL x85;
			VAL x86;
			if (v83) {
				VAL v87 = mtw_std_maybe_Maybe_1_Some(v80);
				x86 = v87;
				x85 = v40;
				x84 = v39;
			} else {
				decref(v80);
				VAL v88 = MKI64(0LL /* None */);
				x86 = v88;
				x85 = v40;
				x84 = v39;
			}
			VAL x89;
			switch (get_data_tag(x86)) {
				case 1LL: { // Some
					VAL v90 = mtp_std_maybe_Maybe_1_Some(x86);
					VAL v91 = mtw_std_list_List_1_Cons(v90, v72);
					x89 = v91;
					push_resource(x84);
					push_value(x85);
				} break;
				case 0LL: { // None
					x89 = v72;
					push_resource(x84);
					push_value(x85);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v92 = 1LL /* True */;
			x79 = v92;
			x78 = v74;
			x77 = x89;
			VAL v93 = pop_value();
			x76 = v93;
			VAL r94 = pop_resource();
			x75 = r94;
		} break;
		case 0LL: { // None
			int64_t v95 = 0LL /* False */;
			x79 = v95;
			x78 = v74;
			x77 = v72;
			x76 = v40;
			x75 = v39;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v96 = (x75);
	VAL v97 = x76;
	VAL v98 = (x77);
	VAL v99 = x78;
	int64_t v100 = x79;
	while (((bool)v100)) {
		VAL v101 = (v96);
		VAL v102 = v97;
		VAL v103 = (v98);
		VAL v104 = v99;
		VAL v105;
		VAL v106;
		mw_std_list_List_1_uncons(v104, &v105, &v106);
		VAL x107;
		VAL x108;
		VAL x109;
		VAL x110;
		int64_t x111;
		switch (get_data_tag(v105)) {
			case 1LL: { // Some
				VAL v112 = mtp_std_maybe_Maybe_1_Some(v105);
				incref(v112);
				VAL v113 = mw_mirth_type_CTypeStackPart_ctype(v112);
				int64_t v114 = mw_mirth_type_CType_phantomZAsk(v113);
				bool v115 = !((bool)v114);
				VAL x116;
				VAL x117;
				VAL x118;
				if (v115) {
					VAL v119 = mtw_std_maybe_Maybe_1_Some(v112);
					x118 = v119;
					x117 = v102;
					x116 = v101;
				} else {
					decref(v112);
					VAL v120 = MKI64(0LL /* None */);
					x118 = v120;
					x117 = v102;
					x116 = v101;
				}
				VAL x121;
				switch (get_data_tag(x118)) {
					case 1LL: { // Some
						VAL v122 = mtp_std_maybe_Maybe_1_Some(x118);
						VAL v123 = mtw_std_list_List_1_Cons(v122, v103);
						x121 = v123;
						push_resource(x116);
						push_value(x117);
					} break;
					case 0LL: { // None
						x121 = v103;
						push_resource(x116);
						push_value(x117);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v124 = 1LL /* True */;
				x111 = v124;
				x110 = v106;
				x109 = x121;
				VAL v125 = pop_value();
				x108 = v125;
				VAL r126 = pop_resource();
				x107 = r126;
			} break;
			case 0LL: { // None
				int64_t v127 = 0LL /* False */;
				x111 = v127;
				x110 = v106;
				x109 = v103;
				x108 = v102;
				x107 = v101;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v100 = x111;
		v99 = x110;
		v98 = x109;
		v97 = x108;
		v96 = x107;
	}
	decref(v99);
	VAL v128 = mw_std_list_List_1_reverse(v98);
	int64_t v129 = mw_std_list_List_1_len(v128);
	int64_t v130 = 1LL;
	bool v131 = (v129 > v130);
	VAL x132;
	VAL x133;
	if (v131) {
		STR* v134;
		STRLIT(v134, "External has too many outputs.", 30);
		VAL v135 = (mw_mirth_mirth_ZPlusMirth_errorZBang(MKSTR(v134), v96));
		x133 = v97;
		x132 = v135;
	} else {
		x133 = v97;
		x132 = v96;
	}
	incref(x133);
	VAL v136 = VVAL(VTUP(x133)->cells[1]);
	incref(v136);
	decref(x133);
	VAL v137 = VVAL(VTUP(v136)->cells[2]);
	incref(v137);
	decref(v136);
	VAL v138 = MKI64(0LL /* Nil */);
	VAL v139 = mw_std_list_List_1_reverse(v138);
	VAL v140;
	VAL v141;
	mw_std_list_List_1_uncons(v137, &v140, &v141);
	VAL x142;
	VAL x143;
	VAL x144;
	VAL x145;
	int64_t x146;
	switch (get_data_tag(v140)) {
		case 1LL: { // Some
			VAL v147 = mtp_std_maybe_Maybe_1_Some(v140);
			VAL v148 = mw_mirth_type_CTypeStackPart_labelZAsk(v147);
			VAL x149;
			switch (get_data_tag(v148)) {
				case 1LL: { // Some
					VAL v150 = mtp_std_maybe_Maybe_1_Some(v148);
					VAL v151 = mtw_std_list_List_1_Cons(v150, v139);
					x149 = v151;
					push_resource(x132);
					push_value(x133);
				} break;
				case 0LL: { // None
					x149 = v139;
					push_resource(x132);
					push_value(x133);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v152 = 1LL /* True */;
			x146 = v152;
			x145 = v141;
			x144 = x149;
			VAL v153 = pop_value();
			x143 = v153;
			VAL r154 = pop_resource();
			x142 = r154;
		} break;
		case 0LL: { // None
			int64_t v155 = 0LL /* False */;
			x146 = v155;
			x145 = v141;
			x144 = v139;
			x143 = x133;
			x142 = x132;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v156 = (x142);
	VAL v157 = x143;
	VAL v158 = (x144);
	VAL v159 = x145;
	int64_t v160 = x146;
	while (((bool)v160)) {
		VAL v161 = (v156);
		VAL v162 = v157;
		VAL v163 = (v158);
		VAL v164 = v159;
		VAL v165;
		VAL v166;
		mw_std_list_List_1_uncons(v164, &v165, &v166);
		VAL x167;
		VAL x168;
		VAL x169;
		VAL x170;
		int64_t x171;
		switch (get_data_tag(v165)) {
			case 1LL: { // Some
				VAL v172 = mtp_std_maybe_Maybe_1_Some(v165);
				VAL v173 = mw_mirth_type_CTypeStackPart_labelZAsk(v172);
				VAL x174;
				switch (get_data_tag(v173)) {
					case 1LL: { // Some
						VAL v175 = mtp_std_maybe_Maybe_1_Some(v173);
						VAL v176 = mtw_std_list_List_1_Cons(v175, v163);
						x174 = v176;
						push_resource(v161);
						push_value(v162);
					} break;
					case 0LL: { // None
						x174 = v163;
						push_resource(v161);
						push_value(v162);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v177 = 1LL /* True */;
				x171 = v177;
				x170 = v166;
				x169 = x174;
				VAL v178 = pop_value();
				x168 = v178;
				VAL r179 = pop_resource();
				x167 = r179;
			} break;
			case 0LL: { // None
				int64_t v180 = 0LL /* False */;
				x171 = v180;
				x170 = v166;
				x169 = v163;
				x168 = v162;
				x167 = v161;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v160 = x171;
		v159 = x170;
		v158 = x169;
		v157 = x168;
		v156 = x167;
	}
	decref(v159);
	VAL v181 = mw_std_list_List_1_reverse(v158);
	incref(v157);
	VAL v182 = VVAL(VTUP(v157)->cells[2]);
	incref(v182);
	decref(v157);
	VAL v183 = VVAL(VTUP(v182)->cells[2]);
	incref(v183);
	decref(v182);
	VAL v184 = MKI64(0LL /* Nil */);
	VAL v185 = mw_std_list_List_1_reverse(v184);
	VAL v186;
	VAL v187;
	mw_std_list_List_1_uncons(v183, &v186, &v187);
	VAL x188;
	VAL x189;
	VAL x190;
	VAL x191;
	VAL x192;
	int64_t x193;
	switch (get_data_tag(v186)) {
		case 1LL: { // Some
			VAL v194 = mtp_std_maybe_Maybe_1_Some(v186);
			VAL v195 = mw_mirth_type_CTypeStackPart_labelZAsk(v194);
			VAL x196;
			switch (get_data_tag(v195)) {
				case 1LL: { // Some
					VAL v197 = mtp_std_maybe_Maybe_1_Some(v195);
					VAL v198 = mtw_std_list_List_1_Cons(v197, v185);
					x196 = v198;
					push_resource(v156);
					push_value(v157);
					push_value(v181);
				} break;
				case 0LL: { // None
					x196 = v185;
					push_resource(v156);
					push_value(v157);
					push_value(v181);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v199 = 1LL /* True */;
			x193 = v199;
			x192 = v187;
			x191 = x196;
			VAL v200 = pop_value();
			x190 = v200;
			VAL v201 = pop_value();
			x189 = v201;
			VAL r202 = pop_resource();
			x188 = r202;
		} break;
		case 0LL: { // None
			int64_t v203 = 0LL /* False */;
			x193 = v203;
			x192 = v187;
			x191 = v185;
			x190 = v181;
			x189 = v157;
			x188 = v156;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v204 = (x188);
	VAL v205 = x189;
	VAL v206 = x190;
	VAL v207 = (x191);
	VAL v208 = x192;
	int64_t v209 = x193;
	while (((bool)v209)) {
		VAL v210 = (v204);
		VAL v211 = v205;
		VAL v212 = v206;
		VAL v213 = (v207);
		VAL v214 = v208;
		VAL v215;
		VAL v216;
		mw_std_list_List_1_uncons(v214, &v215, &v216);
		VAL x217;
		VAL x218;
		VAL x219;
		VAL x220;
		VAL x221;
		int64_t x222;
		switch (get_data_tag(v215)) {
			case 1LL: { // Some
				VAL v223 = mtp_std_maybe_Maybe_1_Some(v215);
				VAL v224 = mw_mirth_type_CTypeStackPart_labelZAsk(v223);
				VAL x225;
				switch (get_data_tag(v224)) {
					case 1LL: { // Some
						VAL v226 = mtp_std_maybe_Maybe_1_Some(v224);
						VAL v227 = mtw_std_list_List_1_Cons(v226, v213);
						x225 = v227;
						push_resource(v210);
						push_value(v211);
						push_value(v212);
					} break;
					case 0LL: { // None
						x225 = v213;
						push_resource(v210);
						push_value(v211);
						push_value(v212);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v228 = 1LL /* True */;
				x222 = v228;
				x221 = v216;
				x220 = x225;
				VAL v229 = pop_value();
				x219 = v229;
				VAL v230 = pop_value();
				x218 = v230;
				VAL r231 = pop_resource();
				x217 = r231;
			} break;
			case 0LL: { // None
				int64_t v232 = 0LL /* False */;
				x222 = v232;
				x221 = v216;
				x220 = v213;
				x219 = v212;
				x218 = v211;
				x217 = v210;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v209 = x222;
		v208 = x221;
		v207 = x220;
		v206 = x219;
		v205 = x218;
		v204 = x217;
	}
	decref(v208);
	VAL v233 = mw_std_list_List_1_reverse(v207);
	VAL v234 = MKI64(0LL /* Nil */);
	VAL v235 = mw_std_list_List_1_reverse(v234);
	VAL v236;
	VAL v237;
	mw_std_list_List_1_uncons(v233, &v236, &v237);
	VAL x238;
	VAL x239;
	VAL x240;
	VAL x241;
	VAL x242;
	int64_t x243;
	switch (get_data_tag(v236)) {
		case 1LL: { // Some
			VAL v244 = mtp_std_maybe_Maybe_1_Some(v236);
			incref(v244);
			incref(v206);
			VAL v245 = MKI64(0LL /* None */);
			VAL v246;
			VAL v247;
			mw_std_list_List_1_uncons(v206, &v246, &v247);
			VAL x248;
			VAL x249;
			uint64_t x250;
			VAL x251;
			VAL x252;
			int64_t x253;
			switch (get_data_tag(v246)) {
				case 1LL: { // Some
					VAL v254 = mtp_std_maybe_Maybe_1_Some(v246);
					incref(v254);
					incref(v244);
					int64_t v255 = mw_mirth_label_Label_ZEqualZEqual(VU64(v244), VU64(v254));
					VAL x256;
					VAL x257;
					uint64_t x258;
					VAL x259;
					if (((bool)v255)) {
						VAL v260 = mtw_std_maybe_Maybe_1_Some(v254);
						x259 = v260;
						x258 = VU64(v244);
						x257 = v205;
						x256 = v204;
					} else {
						decref(v254);
						VAL v261 = MKI64(0LL /* None */);
						x259 = v261;
						x258 = VU64(v244);
						x257 = v205;
						x256 = v204;
					}
					VAL x262;
					VAL x263;
					uint64_t x264;
					VAL x265;
					VAL x266;
					switch (get_data_tag(x259)) {
						case 0LL: { // None
							x266 = v247;
							x265 = v245;
							x264 = x258;
							x263 = x257;
							x262 = x256;
						} break;
						default: {
							decref(v247);
							decref(v245);
							VAL v267 = MKI64(0LL /* Nil */);
							x266 = v267;
							x265 = x259;
							x264 = x258;
							x263 = x257;
							x262 = x256;
						} break;
					}
					int64_t v268 = 1LL /* True */;
					x253 = v268;
					x252 = x266;
					x251 = x265;
					x250 = x264;
					x249 = x263;
					x248 = x262;
				} break;
				case 0LL: { // None
					int64_t v269 = 0LL /* False */;
					x253 = v269;
					x252 = v247;
					x251 = v245;
					x250 = VU64(v244);
					x249 = v205;
					x248 = v204;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v270 = (x248);
			VAL v271 = x249;
			uint64_t v272 = x250;
			VAL v273 = x251;
			VAL v274 = x252;
			int64_t v275 = x253;
			while (((bool)v275)) {
				VAL v276 = (v270);
				VAL v277 = v271;
				uint64_t v278 = v272;
				VAL v279 = v273;
				VAL v280 = v274;
				VAL v281;
				VAL v282;
				mw_std_list_List_1_uncons(v280, &v281, &v282);
				VAL x283;
				VAL x284;
				uint64_t x285;
				VAL x286;
				VAL x287;
				int64_t x288;
				switch (get_data_tag(v281)) {
					case 1LL: { // Some
						VAL v289 = mtp_std_maybe_Maybe_1_Some(v281);
						incref(v289);
						int64_t v290 = mw_mirth_label_Label_ZEqualZEqual(v278, VU64(v289));
						VAL x291;
						VAL x292;
						uint64_t x293;
						VAL x294;
						if (((bool)v290)) {
							VAL v295 = mtw_std_maybe_Maybe_1_Some(v289);
							x294 = v295;
							x293 = v278;
							x292 = v277;
							x291 = v276;
						} else {
							decref(v289);
							VAL v296 = MKI64(0LL /* None */);
							x294 = v296;
							x293 = v278;
							x292 = v277;
							x291 = v276;
						}
						VAL x297;
						VAL x298;
						uint64_t x299;
						VAL x300;
						VAL x301;
						switch (get_data_tag(x294)) {
							case 0LL: { // None
								x301 = v282;
								x300 = v279;
								x299 = x293;
								x298 = x292;
								x297 = x291;
							} break;
							default: {
								decref(v282);
								decref(v279);
								VAL v302 = MKI64(0LL /* Nil */);
								x301 = v302;
								x300 = x294;
								x299 = x293;
								x298 = x292;
								x297 = x291;
							} break;
						}
						int64_t v303 = 1LL /* True */;
						x288 = v303;
						x287 = x301;
						x286 = x300;
						x285 = x299;
						x284 = x298;
						x283 = x297;
					} break;
					case 0LL: { // None
						int64_t v304 = 0LL /* False */;
						x288 = v304;
						x287 = v282;
						x286 = v279;
						x285 = v278;
						x284 = v277;
						x283 = v276;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v275 = x288;
				v274 = x287;
				v273 = x286;
				v272 = x285;
				v271 = x284;
				v270 = x283;
			}
			decref(v274);
			int64_t v305 = mw_std_maybe_Maybe_1_someZAsk(v273);
			bool v306 = !((bool)v305);
			VAL x307;
			VAL x308;
			VAL x309;
			VAL x310;
			if (v306) {
				VAL v311 = mtw_std_maybe_Maybe_1_Some(v244);
				x310 = v311;
				x309 = v206;
				x308 = v271;
				x307 = v270;
			} else {
				decref(v244);
				VAL v312 = MKI64(0LL /* None */);
				x310 = v312;
				x309 = v206;
				x308 = v271;
				x307 = v270;
			}
			VAL x313;
			switch (get_data_tag(x310)) {
				case 1LL: { // Some
					VAL v314 = mtp_std_maybe_Maybe_1_Some(x310);
					VAL v315 = mtw_std_list_List_1_Cons(v314, v235);
					x313 = v315;
					push_resource(x307);
					push_value(x308);
					push_value(x309);
				} break;
				case 0LL: { // None
					x313 = v235;
					push_resource(x307);
					push_value(x308);
					push_value(x309);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v316 = 1LL /* True */;
			x243 = v316;
			x242 = v237;
			x241 = x313;
			VAL v317 = pop_value();
			x240 = v317;
			VAL v318 = pop_value();
			x239 = v318;
			VAL r319 = pop_resource();
			x238 = r319;
		} break;
		case 0LL: { // None
			int64_t v320 = 0LL /* False */;
			x243 = v320;
			x242 = v237;
			x241 = v235;
			x240 = v206;
			x239 = v205;
			x238 = v204;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v321 = (x238);
	VAL v322 = x239;
	VAL v323 = x240;
	VAL v324 = (x241);
	VAL v325 = x242;
	int64_t v326 = x243;
	while (((bool)v326)) {
		VAL v327 = (v321);
		VAL v328 = v322;
		VAL v329 = v323;
		VAL v330 = (v324);
		VAL v331 = v325;
		VAL v332;
		VAL v333;
		mw_std_list_List_1_uncons(v331, &v332, &v333);
		VAL x334;
		VAL x335;
		VAL x336;
		VAL x337;
		VAL x338;
		int64_t x339;
		switch (get_data_tag(v332)) {
			case 1LL: { // Some
				VAL v340 = mtp_std_maybe_Maybe_1_Some(v332);
				incref(v340);
				incref(v329);
				VAL v341 = MKI64(0LL /* None */);
				VAL v342;
				VAL v343;
				mw_std_list_List_1_uncons(v329, &v342, &v343);
				VAL x344;
				VAL x345;
				uint64_t x346;
				VAL x347;
				VAL x348;
				int64_t x349;
				switch (get_data_tag(v342)) {
					case 1LL: { // Some
						VAL v350 = mtp_std_maybe_Maybe_1_Some(v342);
						incref(v350);
						incref(v340);
						int64_t v351 = mw_mirth_label_Label_ZEqualZEqual(VU64(v340), VU64(v350));
						VAL x352;
						VAL x353;
						uint64_t x354;
						VAL x355;
						if (((bool)v351)) {
							VAL v356 = mtw_std_maybe_Maybe_1_Some(v350);
							x355 = v356;
							x354 = VU64(v340);
							x353 = v328;
							x352 = v327;
						} else {
							decref(v350);
							VAL v357 = MKI64(0LL /* None */);
							x355 = v357;
							x354 = VU64(v340);
							x353 = v328;
							x352 = v327;
						}
						VAL x358;
						VAL x359;
						uint64_t x360;
						VAL x361;
						VAL x362;
						switch (get_data_tag(x355)) {
							case 0LL: { // None
								x362 = v343;
								x361 = v341;
								x360 = x354;
								x359 = x353;
								x358 = x352;
							} break;
							default: {
								decref(v343);
								decref(v341);
								VAL v363 = MKI64(0LL /* Nil */);
								x362 = v363;
								x361 = x355;
								x360 = x354;
								x359 = x353;
								x358 = x352;
							} break;
						}
						int64_t v364 = 1LL /* True */;
						x349 = v364;
						x348 = x362;
						x347 = x361;
						x346 = x360;
						x345 = x359;
						x344 = x358;
					} break;
					case 0LL: { // None
						int64_t v365 = 0LL /* False */;
						x349 = v365;
						x348 = v343;
						x347 = v341;
						x346 = VU64(v340);
						x345 = v328;
						x344 = v327;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v366 = (x344);
				VAL v367 = x345;
				uint64_t v368 = x346;
				VAL v369 = x347;
				VAL v370 = x348;
				int64_t v371 = x349;
				while (((bool)v371)) {
					VAL v372 = (v366);
					VAL v373 = v367;
					uint64_t v374 = v368;
					VAL v375 = v369;
					VAL v376 = v370;
					VAL v377;
					VAL v378;
					mw_std_list_List_1_uncons(v376, &v377, &v378);
					VAL x379;
					VAL x380;
					uint64_t x381;
					VAL x382;
					VAL x383;
					int64_t x384;
					switch (get_data_tag(v377)) {
						case 1LL: { // Some
							VAL v385 = mtp_std_maybe_Maybe_1_Some(v377);
							incref(v385);
							int64_t v386 = mw_mirth_label_Label_ZEqualZEqual(v374, VU64(v385));
							VAL x387;
							VAL x388;
							uint64_t x389;
							VAL x390;
							if (((bool)v386)) {
								VAL v391 = mtw_std_maybe_Maybe_1_Some(v385);
								x390 = v391;
								x389 = v374;
								x388 = v373;
								x387 = v372;
							} else {
								decref(v385);
								VAL v392 = MKI64(0LL /* None */);
								x390 = v392;
								x389 = v374;
								x388 = v373;
								x387 = v372;
							}
							VAL x393;
							VAL x394;
							uint64_t x395;
							VAL x396;
							VAL x397;
							switch (get_data_tag(x390)) {
								case 0LL: { // None
									x397 = v378;
									x396 = v375;
									x395 = x389;
									x394 = x388;
									x393 = x387;
								} break;
								default: {
									decref(v378);
									decref(v375);
									VAL v398 = MKI64(0LL /* Nil */);
									x397 = v398;
									x396 = x390;
									x395 = x389;
									x394 = x388;
									x393 = x387;
								} break;
							}
							int64_t v399 = 1LL /* True */;
							x384 = v399;
							x383 = x397;
							x382 = x396;
							x381 = x395;
							x380 = x394;
							x379 = x393;
						} break;
						case 0LL: { // None
							int64_t v400 = 0LL /* False */;
							x384 = v400;
							x383 = v378;
							x382 = v375;
							x381 = v374;
							x380 = v373;
							x379 = v372;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v371 = x384;
					v370 = x383;
					v369 = x382;
					v368 = x381;
					v367 = x380;
					v366 = x379;
				}
				decref(v370);
				int64_t v401 = mw_std_maybe_Maybe_1_someZAsk(v369);
				bool v402 = !((bool)v401);
				VAL x403;
				VAL x404;
				VAL x405;
				VAL x406;
				if (v402) {
					VAL v407 = mtw_std_maybe_Maybe_1_Some(v340);
					x406 = v407;
					x405 = v329;
					x404 = v367;
					x403 = v366;
				} else {
					decref(v340);
					VAL v408 = MKI64(0LL /* None */);
					x406 = v408;
					x405 = v329;
					x404 = v367;
					x403 = v366;
				}
				VAL x409;
				switch (get_data_tag(x406)) {
					case 1LL: { // Some
						VAL v410 = mtp_std_maybe_Maybe_1_Some(x406);
						VAL v411 = mtw_std_list_List_1_Cons(v410, v330);
						x409 = v411;
						push_resource(x403);
						push_value(x404);
						push_value(x405);
					} break;
					case 0LL: { // None
						x409 = v330;
						push_resource(x403);
						push_value(x404);
						push_value(x405);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v412 = 1LL /* True */;
				x339 = v412;
				x338 = v333;
				x337 = x409;
				VAL v413 = pop_value();
				x336 = v413;
				VAL v414 = pop_value();
				x335 = v414;
				VAL r415 = pop_resource();
				x334 = r415;
			} break;
			case 0LL: { // None
				int64_t v416 = 0LL /* False */;
				x339 = v416;
				x338 = v333;
				x337 = v330;
				x336 = v329;
				x335 = v328;
				x334 = v327;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v326 = x339;
		v325 = x338;
		v324 = x337;
		v323 = x336;
		v322 = x335;
		v321 = x334;
	}
	decref(v325);
	VAL v417 = mw_std_list_List_1_reverse(v324);
	decref(v323);
	VAL v418;
	VAL v419;
	mw_std_list_List_1_uncons(v417, &v418, &v419);
	VAL x420;
	VAL x421;
	VAL x422;
	int64_t x423;
	switch (get_data_tag(v418)) {
		case 1LL: { // Some
			VAL v424 = mtp_std_maybe_Maybe_1_Some(v418);
			STR* v425;
			STRLIT(v425, "", 0);
			STR* v426;
			STRLIT(v426, "Output label ", 13);
			VAL v427 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v426), MKSTR(v425)));
			uint64_t v428 = mw_mirth_label_Label_name(VU64(v424));
			VAL v429 = mw_mirth_name_Name_ZToStr(v428);
			VAL v430 = (mw_std_str_ZPlusStr_pushZ_strZBang(v429, v427));
			STR* v431;
			STRLIT(v431, " not present in input", 21);
			VAL v432 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v431), v430));
			VAL v433 = (mw_mirth_mirth_ZPlusMirth_errorZBang(v432, v321));
			int64_t v434 = 1LL /* True */;
			x423 = v434;
			x422 = v419;
			x421 = v322;
			x420 = v433;
		} break;
		case 0LL: { // None
			int64_t v435 = 0LL /* False */;
			x423 = v435;
			x422 = v419;
			x421 = v322;
			x420 = v321;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v436 = (x420);
	VAL v437 = x421;
	VAL v438 = x422;
	int64_t v439 = x423;
	while (((bool)v439)) {
		VAL v440 = (v436);
		VAL v441 = v437;
		VAL v442 = v438;
		VAL v443;
		VAL v444;
		mw_std_list_List_1_uncons(v442, &v443, &v444);
		VAL x445;
		VAL x446;
		VAL x447;
		int64_t x448;
		switch (get_data_tag(v443)) {
			case 1LL: { // Some
				VAL v449 = mtp_std_maybe_Maybe_1_Some(v443);
				STR* v450;
				STRLIT(v450, "", 0);
				STR* v451;
				STRLIT(v451, "Output label ", 13);
				VAL v452 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v451), MKSTR(v450)));
				uint64_t v453 = mw_mirth_label_Label_name(VU64(v449));
				VAL v454 = mw_mirth_name_Name_ZToStr(v453);
				VAL v455 = (mw_std_str_ZPlusStr_pushZ_strZBang(v454, v452));
				STR* v456;
				STRLIT(v456, " not present in input", 21);
				VAL v457 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v456), v455));
				VAL v458 = (mw_mirth_mirth_ZPlusMirth_errorZBang(v457, v440));
				int64_t v459 = 1LL /* True */;
				x448 = v459;
				x447 = v444;
				x446 = v441;
				x445 = v458;
			} break;
			case 0LL: { // None
				int64_t v460 = 0LL /* False */;
				x448 = v460;
				x447 = v444;
				x446 = v441;
				x445 = v440;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v439 = x448;
		v438 = x447;
		v437 = x446;
		v436 = x445;
	}
	decref(v438);
	VAL v461 = VTUP(v436)->cells[5];
	decref(v461);
	VTUP(v436)->cells[5] = v6;
	*x4 = v437;
	*x3 = v436;
}
static void mw_mirth_elab_elabZ_defZ_typeZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	uint64_t v5 = mw_mirth_token_Token_next(x2);
	uint64_t v6;
	uint64_t v7;
	VAL v8;
	mw_mirth_token_Token_argsZ_2(x2, x1, &v6, &v7, &v8);
	VAL v9 = (mw_mirth_token_Token_argsZ_0(v6, v8));
	VAL v10 = mw_mirth_token_Token_sigZ_typeZ_conZAsk(v6);
	uint64_t x11;
	uint64_t x12;
	VAL x13;
	uint64_t x14;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v10);
			decref(v15);
			x14 = v6;
			x13 = v9;
			x12 = v7;
			x11 = v5;
		} break;
		case 0LL: { // None
			STR* v16;
			STRLIT(v16, "expected type constructor", 25);
			lpush(&lbl_target, MKU64(v7));
			lpush(&lbl_head, MKU64(v6));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v5, MKSTR(v16), v9);
			uint64_t v17 = VU64(lpop(&lbl_head));
			x14 = v17;
			VAL r18 = pop_resource();
			x13 = r18;
			uint64_t v19 = VU64(lpop(&lbl_target));
			x12 = v19;
			uint64_t v20 = pop_u64();
			x11 = v20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v21;
	uint64_t v22;
	uint64_t v23;
	int64_t v24;
	VAL v25;
	mw_mirth_elab_elabZ_defZ_head(x13, x14, &v21, &v22, &v23, &v24, &v25);
	VAL v26 = mtw_std_maybe_Maybe_1_Some(MKU64(v22));
	VAL v27;
	uint64_t v28;
	mw_mirth_typedef_TypeDef_newZBang(v21, v26, v23, v25, &v27, &v28);
	VAL v29 = mtw_mirth_mirth_PropLabel_TypeDefTarget(v28);
	FNPTR v30 = &mb_mirth_elab_elabZ_defZ_typeZBang_2;
	VAL v31;
	VAL v32;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(x12), v29, v27, MKFNPTR(v30), &v31, &v32);
	void* v33 = mfld_mirth_typedef_TypeDef_ZTildetarget(v28);
	mut_set(v31, v33);
	*x4 = x11;
	*x3 = v32;
}
static void mw_mirth_elab_elabZ_bufferZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	uint64_t v5 = mw_mirth_token_Token_next(x2);
	uint64_t v6;
	uint64_t v7;
	VAL v8;
	mw_mirth_token_Token_argsZ_2(x2, x1, &v6, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined(v8, v6, &v9, &v10);
	VAL v11 = mw_mirth_token_Token_intZAsk(v7);
	uint64_t x12;
	VAL x13;
	uint64_t x14;
	VAL x15;
	uint64_t x16;
	int64_t x17;
	switch (get_data_tag(v11)) {
		case 1LL: { // Some
			VAL v18 = mtp_std_maybe_Maybe_1_Some(v11);
			x17 = VI64(v18);
			x16 = v7;
			x15 = v10;
			x14 = v6;
			x13 = v9;
			x12 = v5;
		} break;
		case 0LL: { // None
			STR* v19;
			STRLIT(v19, "expected buffer size", 20);
			push_u64(v5);
			push_u64(v6);
			push_value(v10);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v7, MKSTR(v19), v9);
			int64_t v20 = pop_i64();
			x17 = v20;
			uint64_t v21 = pop_u64();
			x16 = v21;
			VAL v22 = pop_value();
			x15 = v22;
			uint64_t v23 = pop_u64();
			x14 = v23;
			VAL r24 = pop_resource();
			x13 = r24;
			uint64_t v25 = pop_u64();
			x12 = v25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v26 = 0LL;
	bool v27 = (x17 < v26);
	uint64_t x28;
	VAL x29;
	uint64_t x30;
	VAL x31;
	int64_t x32;
	if (v27) {
		STR* v33;
		STRLIT(v33, "buffer size must not be negative", 32);
		VAL v34 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(x16, MKSTR(v33), x13));
		int64_t v35 = 0LL;
		x32 = v35;
		x31 = x15;
		x30 = x14;
		x29 = v34;
		x28 = x12;
	} else {
		x32 = x17;
		x31 = x15;
		x30 = x14;
		x29 = x13;
		x28 = x12;
	}
	VAL v36;
	uint64_t v37;
	mw_mirth_buffer_Buffer_newZBang(x29, x30, x31, x32, &v36, &v37);
	*x4 = x28;
	*x3 = v36;
}
static void mw_mirth_elab_elabZ_variableZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	uint64_t v5 = mw_mirth_token_Token_next(x2);
	uint64_t v6;
	uint64_t v7;
	VAL v8;
	mw_mirth_token_Token_argsZ_2(x2, x1, &v6, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined(v8, v6, &v9, &v10);
	VAL v11;
	uint64_t v12;
	mw_mirth_variable_Variable_newZBang(v9, v6, v10, &v11, &v12);
	VAL v13 = mtw_mirth_mirth_PropLabel_VariableType(v12);
	FNPTR v14 = &mb_mirth_elab_elabZ_variableZBang_1;
	VAL v15;
	VAL v16;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(v7), v13, v11, MKFNPTR(v14), &v15, &v16);
	void* v17 = mfld_mirth_variable_Variable_ZTildetype(v12);
	mut_set(v15, v17);
	*x4 = v5;
	*x3 = v16;
}
static void mw_mirth_elab_elabZ_tableZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	uint64_t v5 = mw_mirth_token_Token_next(x2);
	uint64_t v6;
	VAL v7;
	mw_mirth_token_Token_argsZ_1(x2, x1, &v6, &v7);
	VAL v8 = mw_mirth_token_Token_sigZ_typeZ_conZAsk(v6);
	uint64_t x9;
	VAL x10;
	uint64_t x11;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v8);
			decref(v12);
			x11 = v6;
			x10 = v7;
			x9 = v5;
		} break;
		case 0LL: { // None
			STR* v13;
			STRLIT(v13, "expected type name", 18);
			push_u64(v5);
			lpush(&lbl_head, MKU64(v6));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v6, MKSTR(v13), v7);
			uint64_t v14 = VU64(lpop(&lbl_head));
			x11 = v14;
			VAL r15 = pop_resource();
			x10 = r15;
			uint64_t v16 = pop_u64();
			x9 = v16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v17 = (mw_mirth_token_Token_argsZ_0(x11, x10));
	uint64_t v18 = mw_mirth_token_Token_succ(x11);
	int64_t v19 = mw_mirth_token_Token_argZ_endZAsk(v18);
	uint64_t x20;
	VAL x21;
	uint64_t x22;
	if (((bool)v19)) {
		x22 = x11;
		x21 = v17;
		x20 = x9;
	} else {
		uint64_t v23 = mw_mirth_token_Token_succ(x11);
		STR* v24;
		STRLIT(v24, "expected end of argument after table name", 41);
		push_u64(x9);
		lpush(&lbl_head, MKU64(x11));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v23, MKSTR(v24), v17);
		uint64_t v25 = VU64(lpop(&lbl_head));
		x22 = v25;
		VAL r26 = pop_resource();
		x21 = r26;
		uint64_t v27 = pop_u64();
		x20 = v27;
	}
	VAL v28;
	uint64_t v29;
	uint64_t v30;
	int64_t v31;
	VAL v32;
	mw_mirth_elab_elabZ_defZ_head(x21, x22, &v28, &v29, &v30, &v31, &v32);
	VAL v33;
	uint64_t v34;
	mw_mirth_elab_tableZ_newZBang(v28, v29, v30, v32, &v33, &v34);
	*x4 = x20;
	*x3 = v33;
}
static void mw_mirth_elab_elabZ_entryZ_point (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x1);
	VAL v5;
	VAL v6;
	mw_mirth_name_QName_defZ_hardZAsk(x2, x1, &v5, &v6);
	VAL x7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v11 = mw_mirth_def_Def_wordZAsk(v10);
			x9 = v11;
			x8 = v5;
			x7 = x1;
		} break;
		case 0LL: { // None
			VAL v12 = MKI64(0LL /* None */);
			x9 = v12;
			x8 = v5;
			x7 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x13;
	VAL x14;
	uint64_t x15;
	switch (get_data_tag(x9)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(x9);
			x15 = VU64(v16);
			x14 = x8;
			x13 = x7;
		} break;
		case 0LL: { // None
			incref(x7);
			VAL v17 = VVAL(VTUP(x7)->cells[1]);
			incref(v17);
			decref(x7);
			VAL v18;
			VAL v19;
			mw_mirth_name_Namespace_moduleZAsk(x8, v17, &v18, &v19);
			VAL x20;
			switch (get_data_tag(v19)) {
				case 1LL: { // Some
					VAL v21 = mtp_std_maybe_Maybe_1_Some(v19);
					uint64_t v22 = mw_mirth_module_Module_start(VU64(v21));
					VAL v23 = mtw_std_maybe_Maybe_1_Some(MKU64(v22));
					VAL v24 = VTUP(v18)->cells[5];
					decref(v24);
					VTUP(v18)->cells[5] = v23;
					x20 = v18;
				} break;
				case 0LL: { // None
					x20 = v18;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			STR* v25;
			STRLIT(v25, "can't find entry point ", 23);
			VAL v26;
			VAL v27;
			mw_mirth_name_QName_ZToStr(x20, x7, &v26, &v27);
			STR* v28 = str_cat(v25, VSTR(v27));
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v28), v26);
			uint64_t v29 = pop_u64();
			x15 = v29;
			VAL r30 = pop_resource();
			x14 = r30;
			VAL v31 = pop_value();
			x13 = v31;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	decref(x13);
	VAL v32 = mw_mirth_var_Ctx0();
	VAL v33 = mw_mirth_type_T0();
	VAL v34 = mw_mirth_type_RESOURCEz_WORLD();
	VAL v35 = mw_mirth_type_TZPlus(v33, v34);
	VAL v36 = mw_mirth_type_T0();
	VAL v37 = mw_mirth_type_RESOURCEz_WORLD();
	VAL v38 = mw_mirth_type_TZPlus(v36, v37);
	VAL v39 = mw_mirth_type_TZ_ZTo(v35, v38);
	uint64_t v40 = mw_mirth_word_Word_head(x15);
	VAL v41 = mtw_mirth_arrow_Home_HomeMain(v40);
	VAL v42;
	VAL v43;
	mw_mirth_type_ArrowType_unpack(v39, &v42, &v43);
	incref(v42);
	VAL v44 = MKI64(0LL /* Nil */);
	VAL v45 = mtw_mirth_arrow_Arrow_Arrow(v41, v40, v40, v32, v42, v42, v44);
	VAL v46;
	VAL v47;
	mw_mirth_elab_abZ_wordZBang(x15, x14, v45, &v46, &v47);
	VAL v48;
	VAL v49;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v43, v46, v47, &v48, &v49);
	*x4 = v48;
	*x3 = v49;
}
static void mw_mirth_elab_elabZ_embedZ_strZBang (uint64_t x1, int64_t x2, VAL x3, uint64_t *x4, int64_t *x5, VAL *x6) {
	uint64_t v7 = mw_mirth_token_Token_next(x1);
	uint64_t v8;
	uint64_t v9;
	VAL v10;
	mw_mirth_token_Token_argsZ_2(x1, x3, &v8, &v9, &v10);
	VAL v11;
	uint64_t v12;
	uint64_t v13;
	int64_t v14;
	VAL v15;
	mw_mirth_elab_elabZ_defZ_head(v10, v8, &v11, &v12, &v13, &v14, &v15);
	int64_t v16 = 0LL;
	bool v17 = (v14 == v16);
	int64_t x18;
	uint64_t x19;
	uint64_t x20;
	VAL x21;
	uint64_t x22;
	uint64_t x23;
	VAL x24;
	int64_t x25;
	if (v17) {
		x25 = v14;
		x24 = v15;
		x23 = v13;
		x22 = v12;
		x21 = v11;
		x20 = v9;
		x19 = v7;
		x18 = x2;
	} else {
		STR* v26;
		STRLIT(v26, "expected no arguments", 21);
		push_resource(MKI64(x2));
		push_u64(v7);
		push_u64(v9);
		lpush(&lbl_name, MKU64(v13));
		lpush(&lbl_state, v15);
		lpush(&lbl_arity, MKI64(v14));
		lpush(&lbl_head, MKU64(v12));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v12, MKSTR(v26), v11);
		int64_t v27 = VI64(lpop(&lbl_arity));
		x25 = v27;
		VAL v28 = lpop(&lbl_state);
		x24 = v28;
		uint64_t v29 = VU64(lpop(&lbl_name));
		x23 = v29;
		uint64_t v30 = VU64(lpop(&lbl_head));
		x22 = v30;
		VAL r31 = pop_resource();
		x21 = r31;
		uint64_t v32 = pop_u64();
		x20 = v32;
		uint64_t v33 = pop_u64();
		x19 = v33;
		int64_t r34 = VI64(pop_resource());
		x18 = r34;
	}
	VAL v35 = MKI64(0LL /* None */);
	VAL v36 = mw_mirth_token_Token_strZAsk(x20);
	int64_t x37;
	uint64_t x38;
	VAL x39;
	uint64_t x40;
	uint64_t x41;
	VAL x42;
	int64_t x43;
	uint64_t x44;
	VAL x45;
	uint64_t x46;
	VAL x47;
	switch (get_data_tag(v36)) {
		case 1LL: { // Some
			VAL v48 = mtp_std_maybe_Maybe_1_Some(v36);
			x47 = v48;
			x46 = x20;
			x45 = v35;
			x44 = x20;
			x43 = x25;
			x42 = x24;
			x41 = x23;
			x40 = x22;
			x39 = x21;
			x38 = x19;
			x37 = x18;
		} break;
		case 0LL: { // None
			STR* v49;
			STRLIT(v49, "expected source path", 20);
			push_resource(MKI64(x18));
			push_u64(x19);
			lpush(&lbl_head, MKU64(x22));
			lpush(&lbl_name, MKU64(x23));
			lpush(&lbl_state, x24);
			lpush(&lbl_arity, MKI64(x25));
			lpush(&lbl_body, MKU64(x20));
			lpush(&lbl_sigZAsk, v35);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x20, MKSTR(v49), x21);
			VAL v50 = pop_value();
			x47 = v50;
			uint64_t v51 = pop_u64();
			x46 = v51;
			VAL v52 = lpop(&lbl_sigZAsk);
			x45 = v52;
			uint64_t v53 = VU64(lpop(&lbl_body));
			x44 = v53;
			int64_t v54 = VI64(lpop(&lbl_arity));
			x43 = v54;
			VAL v55 = lpop(&lbl_state);
			x42 = v55;
			uint64_t v56 = VU64(lpop(&lbl_name));
			x41 = v56;
			uint64_t v57 = VU64(lpop(&lbl_head));
			x40 = v57;
			VAL r58 = pop_resource();
			x39 = r58;
			uint64_t v59 = pop_u64();
			x38 = v59;
			int64_t r60 = VI64(pop_resource());
			x37 = r60;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v61;
	VAL v62;
	mw_std_prim_ZPlusWorld_openZ_fileZBang(x47, x37, &v61, &v62);
	uint64_t x63;
	uint64_t x64;
	uint64_t x65;
	VAL x66;
	int64_t x67;
	uint64_t x68;
	VAL x69;
	uint64_t x70;
	VAL x71;
	int64_t x72;
	VAL x73;
	switch (get_data_tag(v62)) {
		case 0LL: { // +FileOk
			VAL v74 = (mtp_std_file_ZPlusFileZAsk_ZPlusFileOk(v62));
			x73 = v74;
			x72 = v61;
			x71 = x39;
			x70 = x46;
			x69 = x45;
			x68 = x44;
			x67 = x43;
			x66 = x42;
			x65 = x41;
			x64 = x40;
			x63 = x38;
		} break;
		case 1LL: { // +FileErr
			VAL v75 = mtp_std_file_ZPlusFileZAsk_ZPlusFileErr(v62);
			push_u64(x38);
			lpush(&lbl_head, MKU64(x40));
			lpush(&lbl_name, MKU64(x41));
			lpush(&lbl_state, x42);
			lpush(&lbl_arity, MKI64(x43));
			lpush(&lbl_body, MKU64(x44));
			lpush(&lbl_sigZAsk, x45);
			push_u64(x46);
			push_resource(MKI64(v61));
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(v75, x39);
			VAL r76 = pop_resource();
			x73 = r76;
			int64_t r77 = VI64(pop_resource());
			x72 = r77;
			VAL v78 = (lpop(&lbl_ZPlusmirth));
			x71 = v78;
			uint64_t v79 = pop_u64();
			x70 = v79;
			VAL v80 = lpop(&lbl_sigZAsk);
			x69 = v80;
			uint64_t v81 = VU64(lpop(&lbl_body));
			x68 = v81;
			int64_t v82 = VI64(lpop(&lbl_arity));
			x67 = v82;
			VAL v83 = lpop(&lbl_state);
			x66 = v83;
			uint64_t v84 = VU64(lpop(&lbl_name));
			x65 = v84;
			uint64_t v85 = VU64(lpop(&lbl_head));
			x64 = v85;
			uint64_t v86 = pop_u64();
			x63 = v86;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v87;
	VAL v88;
	mw_std_file_ZPlusFile_readZ_fileZBang(x73, &v87, &v88);
	int64_t v89 = (mw_std_file_ZPlusFile_closeZ_fileZBang(x72, v88));
	uint64_t v90;
	VAL v91;
	mw_mirth_word_Word_newZBang(x64, x69, x68, x65, x67, x71, &v90, &v91);
	VAL v92 = mtw_mirth_mirth_PropLabel_WordQName(v90);
	VAL v93 = mtw_mirth_mirth_Prop_1_Prop(v92, x66);
	void* v94 = mfld_mirth_word_Word_ZTildeqname(v90);
	mut_set(v93, v94);
	VAL v95 = mw_mirth_var_Ctx0();
	VAL v96 = mw_mirth_type_T0();
	VAL v97 = mw_mirth_type_TYPEz_STR();
	VAL v98 = mw_mirth_type_T1(v97);
	VAL v99 = mw_mirth_type_TZ_ZTo(v96, v98);
	VAL v100 = mtw_mirth_mirth_PropLabel_WordType(v90);
	VAL v101;
	VAL v102;
	mw_mirth_mirth_PropLabel_prop2(v95, v99, v100, v91, &v101, &v102);
	void* v103 = mfld_mirth_word_Word_ZTildectxZ_type(v90);
	mut_set(v101, v103);
	VAL v104;
	VAL v105;
	VAL v106;
	uint64_t v107;
	VAL v108;
	uint64_t v109;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v102, v90, &v104, &v105, &v106, &v107, &v108, &v109);
	VAL v110;
	VAL v111;
	mw_mirth_type_ArrowType_unpack(v106, &v110, &v111);
	incref(v110);
	VAL v112 = MKI64(0LL /* Nil */);
	VAL v113 = mtw_mirth_arrow_Arrow_Arrow(v108, v107, v107, v105, v110, v110, v112);
	VAL v114;
	VAL v115;
	mw_mirth_elab_abZ_strZBang(v87, v104, v113, &v114, &v115);
	VAL v116;
	VAL v117;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v111, v114, v115, &v116, &v117);
	VAL v118;
	VAL v119;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v116, v117, v109, &v118, &v119);
	VAL v120 = mtw_mirth_mirth_PropLabel_WordArrow(v90);
	VAL v121;
	VAL v122;
	mw_mirth_mirth_PropLabel_prop(v119, v120, v118, &v121, &v122);
	void* v123 = mfld_mirth_word_Word_ZTildearrow(v90);
	mut_set(v121, v123);
	*x6 = v122;
	*x5 = v89;
	*x4 = x63;
}
static VAL mw_mirth_elab_typecheckZ_everythingZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_name_Name_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = mw_mirth_name_Name_defs(((uint64_t)v10));
		VAL v12;
		VAL v13;
		mw_std_list_List_1_uncons(v11, &v12, &v13);
		VAL x14;
		VAL x15;
		int64_t x16;
		switch (get_data_tag(v12)) {
			case 1LL: { // Some
				VAL v17 = mtp_std_maybe_Maybe_1_Some(v12);
				incref(v17);
				VAL v18;
				VAL v19;
				mw_mirth_def_Def_qnameZ_hard(v9, v17, &v18, &v19);
				decref(v19);
				VAL v20 = (mw_mirth_def_Def_typecheckZBang(v18, v17));
				int64_t v21 = 1LL /* True */;
				x16 = v21;
				x15 = v13;
				x14 = v20;
			} break;
			case 0LL: { // None
				int64_t v22 = 0LL /* False */;
				x16 = v22;
				x15 = v13;
				x14 = v9;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v23 = (x14);
		VAL v24 = x15;
		int64_t v25 = x16;
		while (((bool)v25)) {
			VAL v26 = (v23);
			VAL v27 = v24;
			VAL v28;
			VAL v29;
			mw_std_list_List_1_uncons(v27, &v28, &v29);
			VAL x30;
			VAL x31;
			int64_t x32;
			switch (get_data_tag(v28)) {
				case 1LL: { // Some
					VAL v33 = mtp_std_maybe_Maybe_1_Some(v28);
					incref(v33);
					VAL v34;
					VAL v35;
					mw_mirth_def_Def_qnameZ_hard(v26, v33, &v34, &v35);
					decref(v35);
					VAL v36 = (mw_mirth_def_Def_typecheckZBang(v34, v33));
					int64_t v37 = 1LL /* True */;
					x32 = v37;
					x31 = v29;
					x30 = v36;
				} break;
				case 0LL: { // None
					int64_t v38 = 0LL /* False */;
					x32 = v38;
					x31 = v29;
					x30 = v26;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v25 = x32;
			v24 = x31;
			v23 = x30;
		}
		decref(v24);
		int64_t v39 = 1LL;
		int64_t v40 = i64_add(v10, v39);
		void* v41 = mbuf_mirth_name_Name_NUM;
		int64_t v42 = *(int64_t*)v41;
		bool v43 = (v40 <= v42);
		v8 = v43;
		v7 = v40;
		v6 = v23;
	}
	int64_t v44 = 1LL;
	void* v45 = mbuf_mirth_arrow_Block_NUM;
	int64_t v46 = *(int64_t*)v45;
	bool v47 = (v44 <= v46);
	VAL v48 = (v6);
	int64_t v49 = v44;
	bool v50 = v47;
	while (v50) {
		VAL v51 = (v48);
		int64_t v52 = v49;
		VAL v53 = (mw_mirth_arrow_Block_typecheckZBang(v51, ((uint64_t)v52)));
		int64_t v54 = 1LL;
		int64_t v55 = i64_add(v52, v54);
		void* v56 = mbuf_mirth_arrow_Block_NUM;
		int64_t v57 = *(int64_t*)v56;
		bool v58 = (v55 <= v57);
		v50 = v58;
		v49 = v55;
		v48 = v53;
	}
	int64_t v59 = 1LL;
	void* v60 = mbuf_mirth_external_External_NUM;
	int64_t v61 = *(int64_t*)v60;
	bool v62 = (v59 <= v61);
	VAL v63 = (v48);
	int64_t v64 = v59;
	bool v65 = v62;
	while (v65) {
		VAL v66 = (v63);
		int64_t v67 = v64;
		VAL v68;
		VAL v69;
		mw_mirth_external_External_ctype(v66, ((uint64_t)v67), &v68, &v69);
		decref(v69);
		int64_t v70 = 1LL;
		int64_t v71 = i64_add(v67, v70);
		void* v72 = mbuf_mirth_external_External_NUM;
		int64_t v73 = *(int64_t*)v72;
		bool v74 = (v71 <= v73);
		v65 = v74;
		v64 = v71;
		v63 = v68;
	}
	return v63;
}
static int64_t mw_mirth_elab_TABLEz_MAXz_COUNT (void) {
	int64_t v1 = 524288LL;
	int64_t v2 = 0LL;
	bool v3 = (v1 < v2);
	int64_t x4;
	if (v3) {
		x4 = v2;
	} else {
		x4 = v1;
	}
	return x4;
}
static VAL mw_mirth_elab_tableZ_qname (uint64_t x1, VAL x2, int64_t x3) {
	uint64_t v4 = mw_std_prim_Str_ZToName(x2);
	VAL v5 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(x1);
	VAL v6 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v5);
	VAL v7 = mtw_mirth_name_QName_MKQNAME(v6, v4, x3);
	return v7;
}
static void mw_mirth_elab_tableZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, uint64_t *x6) {
	uint64_t v7 = mw_mirth_table_Table_head(x2);
	VAL v8 = MKI64(0LL /* None */);
	incref(x3);
	uint64_t v9 = mw_std_prim_Str_ZToName(x3);
	VAL v10 = mw_mirth_elab_tableZ_qname(x2, x3, x4);
	uint64_t v11;
	VAL v12;
	mw_mirth_word_Word_newZBang(v7, v8, v7, v9, x4, x1, &v11, &v12);
	VAL v13 = mtw_mirth_mirth_PropLabel_WordQName(v11);
	VAL v14;
	VAL v15;
	mw_mirth_mirth_PropLabel_prop(v10, v13, v12, &v14, &v15);
	void* v16 = mfld_mirth_word_Word_ZTildeqname(v11);
	mut_set(v14, v16);
	*x6 = v11;
	*x5 = v15;
}
static void mw_mirth_elab_tableZ_newZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL *x5, uint64_t *x6) {
	uint64_t v7 = mw_mirth_table_Table_allocZBang();
	VAL v8 = mtw_mirth_mirth_PropLabel_TableQName(v7);
	VAL v9 = mtw_mirth_mirth_Prop_1_Prop(v8, x4);
	void* v10 = mfld_mirth_table_Table_ZTildeqname(v7);
	mut_set(v9, v10);
	void* v11 = mfld_mirth_table_Table_ZTildehead(v7);
	mut_set(MKU64(x2), v11);
	void* v12 = mfld_mirth_table_Table_ZTildename(v7);
	mut_set(MKU64(x3), v12);
	push_resource(x1);
	lpush(&lbl_tbl, MKU64(v7));
	int64_t v13 = mw_mirth_elab_TABLEz_MAXz_COUNT();
	uint64_t v14 = VU64(lpop(&lbl_tbl));
	void* v15 = mfld_mirth_table_Table_ZTildemaxZ_count(v14);
	mut_set(MKI64(v13), v15);
	VAL v16 = mtw_mirth_def_Def_DefTable(v14);
	VAL r17 = pop_resource();
	VAL v18 = (mw_mirth_def_Def_register(r17, v16));
	STR* v19;
	STRLIT(v19, "MAX", 3);
	int64_t v20 = 0LL;
	VAL v21;
	uint64_t v22;
	mw_mirth_elab_tableZ_wordZ_newZBang(v18, v14, MKSTR(v19), v20, &v21, &v22);
	VAL v23 = MKI64(0LL /* Nil */);
	VAL v24 = mw_mirth_type_T0();
	VAL v25 = mw_mirth_type_TYPEz_INT();
	VAL v26 = mw_mirth_type_T1(v25);
	VAL v27 = mw_mirth_type_TZ_ZTo(v24, v26);
	VAL v28 = mtw_mirth_mirth_PropLabel_WordType(v22);
	VAL v29;
	VAL v30;
	mw_mirth_mirth_PropLabel_prop2(v23, v27, v28, v21, &v29, &v30);
	void* v31 = mfld_mirth_word_Word_ZTildectxZ_type(v22);
	mut_set(v29, v31);
	VAL v32;
	VAL v33;
	VAL v34;
	uint64_t v35;
	VAL v36;
	uint64_t v37;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v30, v22, &v32, &v33, &v34, &v35, &v36, &v37);
	VAL v38;
	VAL v39;
	mw_mirth_type_ArrowType_unpack(v34, &v38, &v39);
	incref(v38);
	VAL v40 = MKI64(0LL /* Nil */);
	VAL v41 = mtw_mirth_arrow_Arrow_Arrow(v36, v35, v35, v33, v38, v38, v40);
	uint64_t v42 = mw_mirth_table_Table_head(v14);
	VAL v43 = (mw_mirth_elab_abZ_tokenZBang(v41, v42));
	push_resource(v32);
	lpush(&lbl_tbl, MKU64(v14));
	push_resource(v43);
	int64_t v44 = mw_mirth_elab_TABLEz_MAXz_COUNT();
	VAL r45 = pop_resource();
	VAL r46 = pop_resource();
	VAL v47;
	VAL v48;
	mw_mirth_elab_abZ_intZBang(v44, r46, r45, &v47, &v48);
	VAL v49;
	VAL v50;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v39, v47, v48, &v49, &v50);
	VAL v51;
	VAL v52;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v49, v50, v37, &v51, &v52);
	VAL v53 = mtw_mirth_mirth_PropLabel_WordArrow(v22);
	VAL v54;
	VAL v55;
	mw_mirth_mirth_PropLabel_prop(v52, v53, v51, &v54, &v55);
	void* v56 = mfld_mirth_word_Word_ZTildearrow(v22);
	mut_set(v54, v56);
	uint64_t v57 = VU64(lpop(&lbl_tbl));
	STR* v58;
	STRLIT(v58, "nil", 3);
	int64_t v59 = 0LL;
	VAL v60;
	uint64_t v61;
	mw_mirth_elab_tableZ_wordZ_newZBang(v55, v57, MKSTR(v58), v59, &v60, &v61);
	VAL v62 = MKI64(0LL /* Nil */);
	VAL v63 = mw_mirth_type_T0();
	VAL v64 = mtw_mirth_type_Type_TTable(v57);
	VAL v65 = mw_mirth_type_T1(v64);
	VAL v66 = mw_mirth_type_TZ_ZTo(v63, v65);
	VAL v67 = mtw_mirth_mirth_PropLabel_WordType(v61);
	VAL v68;
	VAL v69;
	mw_mirth_mirth_PropLabel_prop2(v62, v66, v67, v60, &v68, &v69);
	void* v70 = mfld_mirth_word_Word_ZTildectxZ_type(v61);
	mut_set(v68, v70);
	VAL v71;
	VAL v72;
	VAL v73;
	uint64_t v74;
	VAL v75;
	uint64_t v76;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v69, v61, &v71, &v72, &v73, &v74, &v75, &v76);
	VAL v77;
	VAL v78;
	mw_mirth_type_ArrowType_unpack(v73, &v77, &v78);
	incref(v77);
	VAL v79 = MKI64(0LL /* Nil */);
	VAL v80 = mtw_mirth_arrow_Arrow_Arrow(v75, v74, v74, v72, v77, v77, v79);
	uint64_t v81 = mw_mirth_table_Table_head(v57);
	VAL v82 = (mw_mirth_elab_abZ_tokenZBang(v80, v81));
	int64_t v83 = 0LL;
	VAL v84;
	VAL v85;
	mw_mirth_elab_abZ_intZBang(v83, v71, v82, &v84, &v85);
	int64_t v86 = 0LL /* CoerceUnsafe */;
	VAL v87;
	VAL v88;
	mw_mirth_elab_abZ_coerceZBang(v86, v84, v85, &v87, &v88);
	VAL v89;
	VAL v90;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v78, v87, v88, &v89, &v90);
	VAL v91;
	VAL v92;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v89, v90, v76, &v91, &v92);
	VAL v93 = mtw_mirth_mirth_PropLabel_WordArrow(v61);
	VAL v94;
	VAL v95;
	mw_mirth_mirth_PropLabel_prop(v92, v93, v91, &v94, &v95);
	void* v96 = mfld_mirth_word_Word_ZTildearrow(v61);
	mut_set(v94, v96);
	uint64_t v97 = mw_mirth_table_Table_head(v57);
	STR* v98;
	STRLIT(v98, "NUM", 3);
	int64_t v99 = 0LL;
	VAL v100 = mw_mirth_elab_tableZ_qname(v57, MKSTR(v98), v99);
	int64_t v101 = 8LL;
	VAL v102;
	uint64_t v103;
	mw_mirth_buffer_Buffer_newZBang(v95, v97, v100, v101, &v102, &v103);
	void* v104 = mfld_mirth_table_Table_ZTildenumZ_buffer(v57);
	mut_set(MKU64(v103), v104);
	STR* v105;
	STRLIT(v105, "index", 5);
	int64_t v106 = 0LL;
	VAL v107;
	uint64_t v108;
	mw_mirth_elab_tableZ_wordZ_newZBang(v102, v57, MKSTR(v105), v106, &v107, &v108);
	VAL v109 = MKI64(0LL /* Nil */);
	VAL v110 = mtw_mirth_type_Type_TTable(v57);
	VAL v111 = mw_mirth_type_T1(v110);
	VAL v112 = mw_mirth_type_TYPEz_INT();
	VAL v113 = mw_mirth_type_T1(v112);
	VAL v114 = mw_mirth_type_TZ_ZTo(v111, v113);
	VAL v115 = mtw_mirth_mirth_PropLabel_WordType(v108);
	VAL v116;
	VAL v117;
	mw_mirth_mirth_PropLabel_prop2(v109, v114, v115, v107, &v116, &v117);
	void* v118 = mfld_mirth_word_Word_ZTildectxZ_type(v108);
	mut_set(v116, v118);
	VAL v119;
	VAL v120;
	VAL v121;
	uint64_t v122;
	VAL v123;
	uint64_t v124;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v117, v108, &v119, &v120, &v121, &v122, &v123, &v124);
	VAL v125;
	VAL v126;
	mw_mirth_type_ArrowType_unpack(v121, &v125, &v126);
	incref(v125);
	VAL v127 = MKI64(0LL /* Nil */);
	VAL v128 = mtw_mirth_arrow_Arrow_Arrow(v123, v122, v122, v120, v125, v125, v127);
	uint64_t v129 = mw_mirth_table_Table_head(v57);
	VAL v130 = (mw_mirth_elab_abZ_tokenZBang(v128, v129));
	int64_t v131 = 0LL /* CoerceUnsafe */;
	VAL v132;
	VAL v133;
	mw_mirth_elab_abZ_coerceZBang(v131, v119, v130, &v132, &v133);
	VAL v134;
	VAL v135;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v126, v132, v133, &v134, &v135);
	VAL v136;
	VAL v137;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v134, v135, v124, &v136, &v137);
	VAL v138 = mtw_mirth_mirth_PropLabel_WordArrow(v108);
	VAL v139;
	VAL v140;
	mw_mirth_mirth_PropLabel_prop(v137, v138, v136, &v139, &v140);
	void* v141 = mfld_mirth_word_Word_ZTildearrow(v108);
	mut_set(v139, v141);
	STR* v142;
	STRLIT(v142, "from-index", 10);
	int64_t v143 = 0LL;
	VAL v144;
	uint64_t v145;
	mw_mirth_elab_tableZ_wordZ_newZBang(v140, v57, MKSTR(v142), v143, &v144, &v145);
	VAL v146 = MKI64(0LL /* Nil */);
	VAL v147 = mtw_mirth_type_Type_TTable(v57);
	VAL v148 = mw_mirth_type_T1(v147);
	VAL v149 = mw_mirth_type_TYPEz_INT();
	VAL v150 = mw_mirth_type_T1(v149);
	VAL v151 = mw_mirth_type_TZ_ZTo(v150, v148);
	VAL v152 = mtw_mirth_mirth_PropLabel_WordType(v145);
	VAL v153;
	VAL v154;
	mw_mirth_mirth_PropLabel_prop2(v146, v151, v152, v144, &v153, &v154);
	void* v155 = mfld_mirth_word_Word_ZTildectxZ_type(v145);
	mut_set(v153, v155);
	VAL v156;
	VAL v157;
	VAL v158;
	uint64_t v159;
	VAL v160;
	uint64_t v161;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v154, v145, &v156, &v157, &v158, &v159, &v160, &v161);
	VAL v162;
	VAL v163;
	mw_mirth_type_ArrowType_unpack(v158, &v162, &v163);
	incref(v162);
	VAL v164 = MKI64(0LL /* Nil */);
	VAL v165 = mtw_mirth_arrow_Arrow_Arrow(v160, v159, v159, v157, v162, v162, v164);
	uint64_t v166 = mw_mirth_table_Table_head(v57);
	VAL v167 = (mw_mirth_elab_abZ_tokenZBang(v165, v166));
	int64_t v168 = 0LL /* CoerceUnsafe */;
	VAL v169;
	VAL v170;
	mw_mirth_elab_abZ_coerceZBang(v168, v156, v167, &v169, &v170);
	VAL v171;
	VAL v172;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v163, v169, v170, &v171, &v172);
	VAL v173;
	VAL v174;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v171, v172, v161, &v173, &v174);
	VAL v175 = mtw_mirth_mirth_PropLabel_WordArrow(v145);
	VAL v176;
	VAL v177;
	mw_mirth_mirth_PropLabel_prop(v174, v175, v173, &v176, &v177);
	void* v178 = mfld_mirth_word_Word_ZTildearrow(v145);
	mut_set(v176, v178);
	STR* v179;
	STRLIT(v179, "succ", 4);
	int64_t v180 = 0LL;
	VAL v181;
	uint64_t v182;
	mw_mirth_elab_tableZ_wordZ_newZBang(v177, v57, MKSTR(v179), v180, &v181, &v182);
	VAL v183 = MKI64(0LL /* Nil */);
	VAL v184 = mtw_mirth_type_Type_TTable(v57);
	VAL v185 = mw_mirth_type_T1(v184);
	incref(v185);
	VAL v186 = mw_mirth_type_TZ_ZTo(v185, v185);
	VAL v187 = mtw_mirth_mirth_PropLabel_WordType(v182);
	VAL v188;
	VAL v189;
	mw_mirth_mirth_PropLabel_prop2(v183, v186, v187, v181, &v188, &v189);
	void* v190 = mfld_mirth_word_Word_ZTildectxZ_type(v182);
	mut_set(v188, v190);
	VAL v191;
	VAL v192;
	VAL v193;
	uint64_t v194;
	VAL v195;
	uint64_t v196;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v189, v182, &v191, &v192, &v193, &v194, &v195, &v196);
	VAL v197;
	VAL v198;
	mw_mirth_type_ArrowType_unpack(v193, &v197, &v198);
	incref(v197);
	VAL v199 = MKI64(0LL /* Nil */);
	VAL v200 = mtw_mirth_arrow_Arrow_Arrow(v195, v194, v194, v192, v197, v197, v199);
	uint64_t v201 = mw_mirth_table_Table_head(v57);
	VAL v202 = (mw_mirth_elab_abZ_tokenZBang(v200, v201));
	int64_t v203 = 0LL /* CoerceUnsafe */;
	VAL v204;
	VAL v205;
	mw_mirth_elab_abZ_coerceZBang(v203, v191, v202, &v204, &v205);
	int64_t v206 = 1LL;
	VAL v207;
	VAL v208;
	mw_mirth_elab_abZ_intZBang(v206, v204, v205, &v207, &v208);
	int64_t v209 = 20LL /* PRIM_INT_ADD */;
	VAL v210;
	VAL v211;
	mw_mirth_elab_abZ_primZBang(v209, v207, v208, &v210, &v211);
	uint64_t v212 = mw_mirth_table_Table_numZ_buffer(v57);
	VAL v213;
	VAL v214;
	mw_mirth_elab_abZ_bufferZBang(v212, v210, v211, &v213, &v214);
	int64_t v215 = 83LL /* PRIM_U64_GET */;
	VAL v216;
	VAL v217;
	mw_mirth_elab_abZ_primZBang(v215, v213, v214, &v216, &v217);
	int64_t v218 = 0LL /* CoerceUnsafe */;
	VAL v219;
	VAL v220;
	mw_mirth_elab_abZ_coerceZBang(v218, v216, v217, &v219, &v220);
	int64_t v221 = 1LL;
	VAL v222;
	VAL v223;
	mw_mirth_elab_abZ_intZBang(v221, v219, v220, &v222, &v223);
	int64_t v224 = 20LL /* PRIM_INT_ADD */;
	VAL v225;
	VAL v226;
	mw_mirth_elab_abZ_primZBang(v224, v222, v223, &v225, &v226);
	int64_t v227 = 24LL /* PRIM_INT_MOD */;
	VAL v228;
	VAL v229;
	mw_mirth_elab_abZ_primZBang(v227, v225, v226, &v228, &v229);
	int64_t v230 = 0LL /* CoerceUnsafe */;
	VAL v231;
	VAL v232;
	mw_mirth_elab_abZ_coerceZBang(v230, v228, v229, &v231, &v232);
	VAL v233;
	VAL v234;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v198, v231, v232, &v233, &v234);
	VAL v235;
	VAL v236;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v233, v234, v196, &v235, &v236);
	VAL v237 = mtw_mirth_mirth_PropLabel_WordArrow(v182);
	VAL v238;
	VAL v239;
	mw_mirth_mirth_PropLabel_prop(v236, v237, v235, &v238, &v239);
	void* v240 = mfld_mirth_word_Word_ZTildearrow(v182);
	mut_set(v238, v240);
	STR* v241;
	STRLIT(v241, "pred", 4);
	int64_t v242 = 0LL;
	VAL v243;
	uint64_t v244;
	mw_mirth_elab_tableZ_wordZ_newZBang(v239, v57, MKSTR(v241), v242, &v243, &v244);
	VAL v245 = MKI64(0LL /* Nil */);
	VAL v246 = mtw_mirth_type_Type_TTable(v57);
	VAL v247 = mw_mirth_type_T1(v246);
	incref(v247);
	VAL v248 = mw_mirth_type_TZ_ZTo(v247, v247);
	VAL v249 = mtw_mirth_mirth_PropLabel_WordType(v244);
	VAL v250;
	VAL v251;
	mw_mirth_mirth_PropLabel_prop2(v245, v248, v249, v243, &v250, &v251);
	void* v252 = mfld_mirth_word_Word_ZTildectxZ_type(v244);
	mut_set(v250, v252);
	VAL v253;
	VAL v254;
	VAL v255;
	uint64_t v256;
	VAL v257;
	uint64_t v258;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v251, v244, &v253, &v254, &v255, &v256, &v257, &v258);
	VAL v259;
	VAL v260;
	mw_mirth_type_ArrowType_unpack(v255, &v259, &v260);
	incref(v259);
	VAL v261 = MKI64(0LL /* Nil */);
	VAL v262 = mtw_mirth_arrow_Arrow_Arrow(v257, v256, v256, v254, v259, v259, v261);
	uint64_t v263 = mw_mirth_table_Table_head(v57);
	VAL v264 = (mw_mirth_elab_abZ_tokenZBang(v262, v263));
	int64_t v265 = 0LL /* CoerceUnsafe */;
	VAL v266;
	VAL v267;
	mw_mirth_elab_abZ_coerceZBang(v265, v253, v264, &v266, &v267);
	int64_t v268 = 1LL /* PRIM_CORE_DUP */;
	VAL v269;
	VAL v270;
	mw_mirth_elab_abZ_primZBang(v268, v266, v267, &v269, &v270);
	int64_t v271 = 0LL;
	VAL v272;
	VAL v273;
	mw_mirth_elab_abZ_intZBang(v271, v269, v270, &v272, &v273);
	int64_t v274 = 14LL /* PRIM_INT_EQ */;
	VAL v275;
	VAL v276;
	mw_mirth_elab_abZ_primZBang(v274, v272, v273, &v275, &v276);
	VAL v277;
	uint64_t v278;
	mw_mirth_elab_abZ_tokenZAt(v276, &v277, &v278);
	VAL v279;
	VAL v280;
	mw_mirth_elab_abZ_ctxZAt(v277, &v279, &v280);
	uint64_t v281 = mw_mirth_type_MetaVar_newZBang();
	VAL v282 = mtw_mirth_type_StackType_STMeta(v281);
	VAL v283;
	VAL v284;
	mw_mirth_elab_abZ_homeZAt(v279, &v283, &v284);
	incref(v282);
	VAL v285 = MKI64(0LL /* Nil */);
	VAL v286 = mtw_mirth_arrow_Arrow_Arrow(v284, v278, v278, v280, v282, v282, v285);
	VAL v287;
	uint64_t v288;
	mw_mirth_arrow_Block_newZBang(v275, v286, &v287, &v288);
	VAL v289 = mtw_mirth_arrow_Op_OpBlockPush(v288);
	VAL v290;
	VAL v291;
	mw_mirth_elab_abZ_opZBang(v289, v287, v283, &v290, &v291);
	VAL v292;
	uint64_t v293;
	mw_mirth_elab_abZ_tokenZAt(v291, &v292, &v293);
	VAL v294;
	VAL v295;
	mw_mirth_elab_abZ_ctxZAt(v292, &v294, &v295);
	uint64_t v296 = mw_mirth_type_MetaVar_newZBang();
	VAL v297 = mtw_mirth_type_StackType_STMeta(v296);
	VAL v298;
	VAL v299;
	mw_mirth_elab_abZ_homeZAt(v294, &v298, &v299);
	incref(v297);
	VAL v300 = MKI64(0LL /* Nil */);
	VAL v301 = mtw_mirth_arrow_Arrow_Arrow(v299, v293, v293, v295, v297, v297, v300);
	int64_t v302 = 1LL;
	VAL v303;
	VAL v304;
	mw_mirth_elab_abZ_intZBang(v302, v290, v301, &v303, &v304);
	int64_t v305 = 21LL /* PRIM_INT_SUB */;
	VAL v306;
	VAL v307;
	mw_mirth_elab_abZ_primZBang(v305, v303, v304, &v306, &v307);
	VAL v308;
	uint64_t v309;
	mw_mirth_arrow_Block_newZBang(v306, v307, &v308, &v309);
	VAL v310 = mtw_mirth_arrow_Op_OpBlockPush(v309);
	VAL v311;
	VAL v312;
	mw_mirth_elab_abZ_opZBang(v310, v308, v298, &v311, &v312);
	int64_t v313 = 7LL /* PRIM_CORE_IF */;
	VAL v314;
	VAL v315;
	mw_mirth_elab_abZ_primZBang(v313, v311, v312, &v314, &v315);
	int64_t v316 = 0LL /* CoerceUnsafe */;
	VAL v317;
	VAL v318;
	mw_mirth_elab_abZ_coerceZBang(v316, v314, v315, &v317, &v318);
	VAL v319;
	VAL v320;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v260, v317, v318, &v319, &v320);
	VAL v321;
	VAL v322;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v319, v320, v258, &v321, &v322);
	VAL v323 = mtw_mirth_mirth_PropLabel_WordArrow(v244);
	VAL v324;
	VAL v325;
	mw_mirth_mirth_PropLabel_prop(v322, v323, v321, &v324, &v325);
	void* v326 = mfld_mirth_word_Word_ZTildearrow(v244);
	mut_set(v324, v326);
	STR* v327;
	STRLIT(v327, "for", 3);
	int64_t v328 = 1LL;
	VAL v329;
	uint64_t v330;
	mw_mirth_elab_tableZ_wordZ_newZBang(v325, v57, MKSTR(v327), v328, &v329, &v330);
	VAL v331 = mw_mirth_type_TYPEz_STACK();
	STR* v332;
	STRLIT(v332, "*a", 2);
	uint64_t v333 = mw_std_prim_Str_ZToName(MKSTR(v332));
	uint64_t v334 = mw_mirth_var_Var_newZBang(v331, v333);
	VAL v335 = mtw_mirth_type_StackType_STVar(v334);
	VAL v336 = mtw_mirth_type_Type_TTable(v57);
	VAL v337 = mw_mirth_type_TZMul(v335, v336);
	VAL v338 = mtw_mirth_type_StackType_STVar(v334);
	VAL v339 = mw_mirth_type_TZ_ZTo(v337, v338);
	STR* v340;
	STRLIT(v340, "f", 1);
	uint64_t v341 = mw_std_prim_Str_ZToName(MKSTR(v340));
	uint64_t v342 = mw_mirth_var_Var_newZ_autoZ_runZBang(v339, v341);
	VAL v343 = mw_mirth_var_Ctx1(v334);
	VAL v344 = mtw_mirth_type_StackType_STVar(v334);
	VAL v345 = mw_mirth_var_Var_type(v342);
	VAL v346 = mw_mirth_type_TZMul(v344, v345);
	VAL v347 = mtw_mirth_type_StackType_STVar(v334);
	VAL v348 = mw_mirth_type_TZ_ZTo(v346, v347);
	VAL v349 = mtw_mirth_mirth_PropLabel_WordType(v330);
	VAL v350;
	VAL v351;
	mw_mirth_mirth_PropLabel_prop2(v343, v348, v349, v329, &v350, &v351);
	void* v352 = mfld_mirth_word_Word_ZTildectxZ_type(v330);
	mut_set(v350, v352);
	VAL v353 = MKI64(0LL /* Nil */);
	VAL v354 = mtw_std_list_List_1_Cons(MKU64(v342), v353);
	VAL v355 = mtw_mirth_mirth_PropLabel_WordParams(v330);
	VAL v356;
	VAL v357;
	mw_mirth_mirth_PropLabel_prop(v354, v355, v351, &v356, &v357);
	void* v358 = mfld_mirth_word_Word_ZTildeparams(v330);
	mut_set(v356, v358);
	mw_mirth_word_Word_makeZ_inlineZBang(v330);
	VAL v359;
	VAL v360;
	VAL v361;
	uint64_t v362;
	VAL v363;
	uint64_t v364;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v357, v330, &v359, &v360, &v361, &v362, &v363, &v364);
	VAL v365;
	VAL v366;
	mw_mirth_type_ArrowType_unpack(v361, &v365, &v366);
	incref(v365);
	VAL v367 = MKI64(0LL /* Nil */);
	VAL v368 = mtw_mirth_arrow_Arrow_Arrow(v363, v362, v362, v360, v365, v365, v367);
	uint64_t v369 = mw_mirth_table_Table_head(v57);
	VAL v370 = (mw_mirth_elab_abZ_tokenZBang(v368, v369));
	VAL v371 = MKI64(0LL /* Nil */);
	VAL v372 = mtw_std_list_List_1_Cons(MKU64(v342), v371);
	VAL v373;
	uint64_t v374;
	mw_mirth_elab_abZ_tokenZAt(v370, &v373, &v374);
	incref(v372);
	VAL v375;
	VAL v376;
	mw_mirth_elab_abZ_ctxZAt(v373, &v375, &v376);
	VAL v377;
	VAL v378;
	mw_mirth_elab_abZ_typeZAt(v375, &v377, &v378);
	VAL v379 = mw_std_list_List_1_reverse(v372);
	VAL v380;
	VAL v381;
	mw_std_list_List_1_uncons(v379, &v380, &v381);
	uint64_t x382;
	VAL x383;
	VAL x384;
	VAL x385;
	VAL x386;
	VAL x387;
	int64_t x388;
	switch (get_data_tag(v380)) {
		case 1LL: { // Some
			VAL v389 = mtp_std_maybe_Maybe_1_Some(v380);
			incref(v389);
			VAL v390 = mw_mirth_var_Ctx_new(v376, VU64(v389));
			VAL v391;
			uint64_t v392;
			mw_mirth_elab_abZ_tokenZAt(v377, &v391, &v392);
			VAL v393;
			VAL v394;
			VAL v395;
			uint64_t v396;
			mw_mirth_elab_elabZ_expandZ_tensorZBang(v359, v378, v392, &v393, &v394, &v395, &v396);
			VAL v397 = mw_mirth_var_Var_type(VU64(v389));
			VAL v398;
			VAL v399;
			uint64_t v400;
			mw_mirth_elab_elabZ_typeZ_unifyZBang(v393, v395, v397, v396, &v398, &v399, &v400);
			decref(v399);
			int64_t v401 = 1LL /* True */;
			x388 = v401;
			x387 = v381;
			x386 = v394;
			x385 = v391;
			x384 = v390;
			x383 = v398;
			x382 = v374;
			lpush(&lbl_va, MKU64(v334));
			lpush(&lbl_tbl, MKU64(v57));
			lpush(&lbl_vx, MKU64(v342));
		} break;
		case 0LL: { // None
			int64_t v402 = 0LL /* False */;
			x388 = v402;
			x387 = v381;
			x386 = v378;
			x385 = v377;
			x384 = v376;
			x383 = v359;
			x382 = v374;
			lpush(&lbl_va, MKU64(v334));
			lpush(&lbl_tbl, MKU64(v57));
			lpush(&lbl_vx, MKU64(v342));
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v403 = x382;
	VAL v404 = (x383);
	VAL v405 = x384;
	VAL v406 = (x385);
	VAL v407 = x386;
	VAL v408 = x387;
	int64_t v409 = x388;
	while (((bool)v409)) {
		uint64_t v410 = v403;
		VAL v411 = (v404);
		VAL v412 = v405;
		VAL v413 = (v406);
		VAL v414 = v407;
		VAL v415 = v408;
		VAL v416;
		VAL v417;
		mw_std_list_List_1_uncons(v415, &v416, &v417);
		uint64_t x418;
		VAL x419;
		VAL x420;
		VAL x421;
		VAL x422;
		VAL x423;
		int64_t x424;
		switch (get_data_tag(v416)) {
			case 1LL: { // Some
				VAL v425 = mtp_std_maybe_Maybe_1_Some(v416);
				incref(v425);
				VAL v426 = mw_mirth_var_Ctx_new(v412, VU64(v425));
				VAL v427;
				uint64_t v428;
				mw_mirth_elab_abZ_tokenZAt(v413, &v427, &v428);
				VAL v429;
				VAL v430;
				VAL v431;
				uint64_t v432;
				mw_mirth_elab_elabZ_expandZ_tensorZBang(v411, v414, v428, &v429, &v430, &v431, &v432);
				VAL v433 = mw_mirth_var_Var_type(VU64(v425));
				VAL v434;
				VAL v435;
				uint64_t v436;
				mw_mirth_elab_elabZ_typeZ_unifyZBang(v429, v431, v433, v432, &v434, &v435, &v436);
				decref(v435);
				int64_t v437 = 1LL /* True */;
				x424 = v437;
				x423 = v417;
				x422 = v430;
				x421 = v427;
				x420 = v426;
				x419 = v434;
				x418 = v410;
			} break;
			case 0LL: { // None
				int64_t v438 = 0LL /* False */;
				x424 = v438;
				x423 = v417;
				x422 = v414;
				x421 = v413;
				x420 = v412;
				x419 = v411;
				x418 = v410;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v409 = x424;
		v408 = x423;
		v407 = x422;
		v406 = x421;
		v405 = x420;
		v404 = x419;
		v403 = x418;
	}
	decref(v408);
	VAL v439;
	VAL v440;
	mw_mirth_elab_abZ_homeZAt(v406, &v439, &v440);
	incref(v407);
	VAL v441 = MKI64(0LL /* Nil */);
	VAL v442 = mtw_mirth_arrow_Arrow_Arrow(v440, v403, v403, v405, v407, v407, v441);
	int64_t v443 = 1LL;
	VAL v444;
	VAL v445;
	mw_mirth_elab_abZ_intZBang(v443, v404, v442, &v444, &v445);
	VAL v446;
	uint64_t v447;
	mw_mirth_elab_abZ_tokenZAt(v445, &v446, &v447);
	VAL v448;
	VAL v449;
	mw_mirth_elab_abZ_ctxZAt(v446, &v448, &v449);
	uint64_t v450 = mw_mirth_type_MetaVar_newZBang();
	VAL v451 = mtw_mirth_type_StackType_STMeta(v450);
	VAL v452;
	VAL v453;
	mw_mirth_elab_abZ_homeZAt(v448, &v452, &v453);
	incref(v451);
	VAL v454 = MKI64(0LL /* Nil */);
	VAL v455 = mtw_mirth_arrow_Arrow_Arrow(v453, v447, v447, v449, v451, v451, v454);
	int64_t v456 = 1LL /* PRIM_CORE_DUP */;
	VAL v457;
	VAL v458;
	mw_mirth_elab_abZ_primZBang(v456, v444, v455, &v457, &v458);
	uint64_t v459 = VU64(lpop(&lbl_tbl));
	uint64_t v460 = mw_mirth_table_Table_numZ_buffer(v459);
	VAL v461;
	VAL v462;
	mw_mirth_elab_abZ_bufferZBang(v460, v457, v458, &v461, &v462);
	int64_t v463 = 87LL /* PRIM_I64_GET */;
	VAL v464;
	VAL v465;
	mw_mirth_elab_abZ_primZBang(v463, v461, v462, &v464, &v465);
	int64_t v466 = 0LL /* CoerceUnsafe */;
	VAL v467;
	VAL v468;
	mw_mirth_elab_abZ_coerceZBang(v466, v464, v465, &v467, &v468);
	int64_t v469 = 16LL /* PRIM_INT_LE */;
	VAL v470;
	VAL v471;
	mw_mirth_elab_abZ_primZBang(v469, v467, v468, &v470, &v471);
	VAL v472;
	uint64_t v473;
	mw_mirth_arrow_Block_newZBang(v470, v471, &v472, &v473);
	VAL v474 = mtw_mirth_arrow_Op_OpBlockPush(v473);
	VAL v475;
	VAL v476;
	mw_mirth_elab_abZ_opZBang(v474, v472, v452, &v475, &v476);
	VAL v477;
	uint64_t v478;
	mw_mirth_elab_abZ_tokenZAt(v476, &v477, &v478);
	VAL v479;
	VAL v480;
	mw_mirth_elab_abZ_ctxZAt(v477, &v479, &v480);
	uint64_t v481 = mw_mirth_type_MetaVar_newZBang();
	VAL v482 = mtw_mirth_type_StackType_STMeta(v481);
	VAL v483;
	VAL v484;
	mw_mirth_elab_abZ_homeZAt(v479, &v483, &v484);
	incref(v482);
	VAL v485 = MKI64(0LL /* Nil */);
	VAL v486 = mtw_mirth_arrow_Arrow_Arrow(v484, v478, v478, v480, v482, v482, v485);
	int64_t v487 = 1LL /* PRIM_CORE_DUP */;
	VAL v488;
	VAL v489;
	mw_mirth_elab_abZ_primZBang(v487, v475, v486, &v488, &v489);
	VAL v490;
	uint64_t v491;
	mw_mirth_elab_abZ_tokenZAt(v489, &v490, &v491);
	VAL v492;
	VAL v493;
	mw_mirth_elab_abZ_ctxZAt(v490, &v492, &v493);
	uint64_t v494 = mw_mirth_type_MetaVar_newZBang();
	VAL v495 = mtw_mirth_type_StackType_STMeta(v494);
	VAL v496;
	VAL v497;
	mw_mirth_elab_abZ_homeZAt(v492, &v496, &v497);
	incref(v495);
	VAL v498 = MKI64(0LL /* Nil */);
	VAL v499 = mtw_mirth_arrow_Arrow_Arrow(v497, v491, v491, v493, v495, v495, v498);
	int64_t v500 = 0LL /* CoerceUnsafe */;
	VAL v501;
	VAL v502;
	mw_mirth_elab_abZ_coerceZBang(v500, v488, v499, &v501, &v502);
	uint64_t v503 = VU64(lpop(&lbl_vx));
	VAL v504;
	VAL v505;
	mw_mirth_elab_abZ_varZBang(v503, v501, v502, &v504, &v505);
	VAL v506;
	uint64_t v507;
	mw_mirth_arrow_Block_newZBang(v504, v505, &v506, &v507);
	VAL v508 = mtw_mirth_arrow_Op_OpBlockPush(v507);
	VAL v509;
	VAL v510;
	mw_mirth_elab_abZ_opZBang(v508, v506, v496, &v509, &v510);
	int64_t v511 = 5LL /* PRIM_CORE_DIP */;
	VAL v512;
	VAL v513;
	mw_mirth_elab_abZ_primZBang(v511, v509, v510, &v512, &v513);
	int64_t v514 = 1LL;
	VAL v515;
	VAL v516;
	mw_mirth_elab_abZ_intZBang(v514, v512, v513, &v515, &v516);
	int64_t v517 = 20LL /* PRIM_INT_ADD */;
	VAL v518;
	VAL v519;
	mw_mirth_elab_abZ_primZBang(v517, v515, v516, &v518, &v519);
	VAL v520;
	uint64_t v521;
	mw_mirth_arrow_Block_newZBang(v518, v519, &v520, &v521);
	VAL v522 = mtw_mirth_arrow_Op_OpBlockPush(v521);
	VAL v523;
	VAL v524;
	mw_mirth_elab_abZ_opZBang(v522, v520, v483, &v523, &v524);
	int64_t v525 = 8LL /* PRIM_CORE_WHILE */;
	VAL v526;
	VAL v527;
	mw_mirth_elab_abZ_primZBang(v525, v523, v524, &v526, &v527);
	int64_t v528 = 2LL /* PRIM_CORE_DROP */;
	VAL v529;
	VAL v530;
	mw_mirth_elab_abZ_primZBang(v528, v526, v527, &v529, &v530);
	VAL v531;
	VAL v532;
	mw_mirth_elab_abZ_ctxZAt(v439, &v531, &v532);
	VAL v533;
	VAL v534;
	mw_mirth_elab_abZ_typeZAt(v531, &v533, &v534);
	VAL v535;
	uint64_t v536;
	mw_mirth_elab_abZ_tokenZAt(v533, &v535, &v536);
	VAL v537 = mtw_mirth_arrow_Lambda_Lambda(v536, v532, v534, v372, v530);
	VAL v538 = mtw_mirth_arrow_Op_OpLambda(v537);
	VAL v539;
	VAL v540;
	mw_mirth_elab_abZ_opZBang(v538, v529, v535, &v539, &v540);
	VAL v541;
	VAL v542;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v366, v539, v540, &v541, &v542);
	VAL v543;
	VAL v544;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v541, v542, v364, &v543, &v544);
	VAL v545 = mtw_mirth_mirth_PropLabel_WordArrow(v330);
	VAL v546;
	VAL v547;
	mw_mirth_mirth_PropLabel_prop(v544, v545, v543, &v546, &v547);
	void* v548 = mfld_mirth_word_Word_ZTildearrow(v330);
	mut_set(v546, v548);
	uint64_t v549 = VU64(lpop(&lbl_va));
	STR* v550;
	STRLIT(v550, "alloc!", 6);
	int64_t v551 = 0LL;
	VAL v552;
	uint64_t v553;
	mw_mirth_elab_tableZ_wordZ_newZBang(v547, v459, MKSTR(v550), v551, &v552, &v553);
	VAL v554 = MKI64(0LL /* Nil */);
	VAL v555 = mw_mirth_type_T0();
	VAL v556 = mtw_mirth_type_Type_TTable(v459);
	VAL v557 = mw_mirth_type_T1(v556);
	VAL v558 = mw_mirth_type_TZ_ZTo(v555, v557);
	VAL v559 = mtw_mirth_mirth_PropLabel_WordType(v553);
	VAL v560;
	VAL v561;
	mw_mirth_mirth_PropLabel_prop2(v554, v558, v559, v552, &v560, &v561);
	void* v562 = mfld_mirth_word_Word_ZTildectxZ_type(v553);
	mut_set(v560, v562);
	VAL v563;
	VAL v564;
	VAL v565;
	uint64_t v566;
	VAL v567;
	uint64_t v568;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(v561, v553, &v563, &v564, &v565, &v566, &v567, &v568);
	VAL v569;
	VAL v570;
	mw_mirth_type_ArrowType_unpack(v565, &v569, &v570);
	incref(v569);
	VAL v571 = MKI64(0LL /* Nil */);
	VAL v572 = mtw_mirth_arrow_Arrow_Arrow(v567, v566, v566, v564, v569, v569, v571);
	uint64_t v573 = mw_mirth_table_Table_head(v459);
	VAL v574 = (mw_mirth_elab_abZ_tokenZBang(v572, v573));
	uint64_t v575 = mw_mirth_table_Table_numZ_buffer(v459);
	VAL v576;
	VAL v577;
	mw_mirth_elab_abZ_bufferZBang(v575, v563, v574, &v576, &v577);
	int64_t v578 = 83LL /* PRIM_U64_GET */;
	VAL v579;
	VAL v580;
	mw_mirth_elab_abZ_primZBang(v578, v576, v577, &v579, &v580);
	int64_t v581 = 0LL /* CoerceUnsafe */;
	VAL v582;
	VAL v583;
	mw_mirth_elab_abZ_coerceZBang(v581, v579, v580, &v582, &v583);
	int64_t v584 = 1LL;
	VAL v585;
	VAL v586;
	mw_mirth_elab_abZ_intZBang(v584, v582, v583, &v585, &v586);
	int64_t v587 = 20LL /* PRIM_INT_ADD */;
	VAL v588;
	VAL v589;
	mw_mirth_elab_abZ_primZBang(v587, v585, v586, &v588, &v589);
	int64_t v590 = 1LL /* PRIM_CORE_DUP */;
	VAL v591;
	VAL v592;
	mw_mirth_elab_abZ_primZBang(v590, v588, v589, &v591, &v592);
	int64_t v593 = 0LL /* CoerceUnsafe */;
	VAL v594;
	VAL v595;
	mw_mirth_elab_abZ_coerceZBang(v593, v591, v592, &v594, &v595);
	uint64_t v596 = mw_mirth_table_Table_numZ_buffer(v459);
	VAL v597;
	VAL v598;
	mw_mirth_elab_abZ_bufferZBang(v596, v594, v595, &v597, &v598);
	int64_t v599 = 92LL /* PRIM_U64_SET */;
	VAL v600;
	VAL v601;
	mw_mirth_elab_abZ_primZBang(v599, v597, v598, &v600, &v601);
	int64_t v602 = 0LL /* CoerceUnsafe */;
	VAL v603;
	VAL v604;
	mw_mirth_elab_abZ_coerceZBang(v602, v600, v601, &v603, &v604);
	VAL v605;
	VAL v606;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v570, v603, v604, &v605, &v606);
	VAL v607;
	VAL v608;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v605, v606, v568, &v607, &v608);
	VAL v609 = mtw_mirth_mirth_PropLabel_WordArrow(v553);
	VAL v610;
	VAL v611;
	mw_mirth_mirth_PropLabel_prop(v608, v609, v607, &v610, &v611);
	void* v612 = mfld_mirth_word_Word_ZTildearrow(v553);
	mut_set(v610, v612);
	*x6 = v459;
	*x5 = v611;
}
static void mw_mirth_elab_resolveZ_defZ_namespace (VAL x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5) {
	STR* v6;
	STRLIT(v6, "namespace", 9);
	int64_t v7 = 1LL /* True */;
	int64_t v8 = 0LL /* False */;
	VAL v9;
	VAL v10;
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v6), x2, x3, v7, v8, x1, &v9, &v10);
	VAL v11 = VVAL(VTUP(v10)->cells[4]);
	incref(v11);
	VAL v12 = MKI64(0LL /* Nil */);
	VAL v13 = MKI64(0LL /* Nil */);
	VAL v14;
	VAL v15;
	mw_std_list_List_1_uncons(v11, &v14, &v15);
	VAL x16;
	VAL x17;
	VAL x18;
	VAL x19;
	VAL x20;
	int64_t x21;
	switch (get_data_tag(v14)) {
		case 1LL: { // Some
			VAL v22 = mtp_std_maybe_Maybe_1_Some(v14);
			incref(v22);
			VAL v23;
			VAL v24;
			mw_mirth_def_Def_exposedZ_tyconZAsk(v9, v22, &v23, &v24);
			int64_t v25 = mw_std_maybe_Maybe_1_ZToBool(v24);
			VAL x26;
			VAL x27;
			VAL x28;
			if (((bool)v25)) {
				VAL v29 = mtw_std_either_Either_2_Right(v22);
				x28 = v29;
				x27 = v10;
				x26 = v23;
			} else {
				VAL v30 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v22);
				VAL v31 = mtw_std_either_Either_2_Left(v30);
				x28 = v31;
				x27 = v10;
				x26 = v23;
			}
			VAL x32;
			VAL x33;
			VAL x34;
			VAL x35;
			switch (get_data_tag(x28)) {
				case 0LL: { // Left
					VAL v36 = mtp_std_either_Either_2_Left(x28);
					VAL v37 = mtw_std_list_List_1_Cons(v36, v12);
					x35 = v13;
					x34 = v37;
					x33 = x27;
					x32 = x26;
				} break;
				case 1LL: { // Right
					VAL v38 = mtp_std_either_Either_2_Right(x28);
					VAL v39 = mtw_std_list_List_1_Cons(v38, v13);
					x35 = v39;
					x34 = v12;
					x33 = x27;
					x32 = x26;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v40 = 1LL /* True */;
			x21 = v40;
			x20 = v15;
			x19 = x35;
			x18 = x34;
			x17 = x33;
			x16 = x32;
		} break;
		case 0LL: { // None
			int64_t v41 = 0LL /* False */;
			x21 = v41;
			x20 = v15;
			x19 = v13;
			x18 = v12;
			x17 = v10;
			x16 = v9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v42 = (x16);
	VAL v43 = (x17);
	VAL v44 = x18;
	VAL v45 = x19;
	VAL v46 = x20;
	int64_t v47 = x21;
	while (((bool)v47)) {
		VAL v48 = (v42);
		VAL v49 = (v43);
		VAL v50 = v44;
		VAL v51 = v45;
		VAL v52 = v46;
		VAL v53;
		VAL v54;
		mw_std_list_List_1_uncons(v52, &v53, &v54);
		VAL x55;
		VAL x56;
		VAL x57;
		VAL x58;
		VAL x59;
		int64_t x60;
		switch (get_data_tag(v53)) {
			case 1LL: { // Some
				VAL v61 = mtp_std_maybe_Maybe_1_Some(v53);
				incref(v61);
				VAL v62;
				VAL v63;
				mw_mirth_def_Def_exposedZ_tyconZAsk(v48, v61, &v62, &v63);
				int64_t v64 = mw_std_maybe_Maybe_1_ZToBool(v63);
				VAL x65;
				VAL x66;
				VAL x67;
				if (((bool)v64)) {
					VAL v68 = mtw_std_either_Either_2_Right(v61);
					x67 = v68;
					x66 = v49;
					x65 = v62;
				} else {
					VAL v69 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v61);
					VAL v70 = mtw_std_either_Either_2_Left(v69);
					x67 = v70;
					x66 = v49;
					x65 = v62;
				}
				VAL x71;
				VAL x72;
				VAL x73;
				VAL x74;
				switch (get_data_tag(x67)) {
					case 0LL: { // Left
						VAL v75 = mtp_std_either_Either_2_Left(x67);
						VAL v76 = mtw_std_list_List_1_Cons(v75, v50);
						x74 = v51;
						x73 = v76;
						x72 = x66;
						x71 = x65;
					} break;
					case 1LL: { // Right
						VAL v77 = mtp_std_either_Either_2_Right(x67);
						VAL v78 = mtw_std_list_List_1_Cons(v77, v51);
						x74 = v78;
						x73 = v50;
						x72 = x66;
						x71 = x65;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v79 = 1LL /* True */;
				x60 = v79;
				x59 = v54;
				x58 = x74;
				x57 = x73;
				x56 = x72;
				x55 = x71;
			} break;
			case 0LL: { // None
				int64_t v80 = 0LL /* False */;
				x60 = v80;
				x59 = v54;
				x58 = v51;
				x57 = v50;
				x56 = v49;
				x55 = v48;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v47 = x60;
		v46 = x59;
		v45 = x58;
		v44 = x57;
		v43 = x56;
		v42 = x55;
	}
	decref(v46);
	VAL v81 = mw_std_list_List_1_reverse(v44);
	VAL v82 = mw_std_list_List_1_reverse(v45);
	VAL v83 = VVAL(VTUP(v43)->cells[5]);
	incref(v83);
	VAL v84 = mw_std_list_List_1_cat(v81, v83);
	VAL v85 = VTUP(v43)->cells[5];
	decref(v85);
	VTUP(v43)->cells[5] = v84;
	VAL v86 = VTUP(v43)->cells[4];
	decref(v86);
	VTUP(v43)->cells[4] = v82;
	VAL v87;
	VAL v88;
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(v42, v43, &v87, &v88);
	VAL v89 = MKI64(0LL /* Nil */);
	VAL v90;
	VAL v91;
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v89, v87, v88, &v90, &v91);
	VAL v92;
	VAL v93;
	mw_mirth_elab_resolveZ_defZ_endZBang(v90, v91, &v92, &v93);
	VAL x94;
	VAL x95;
	switch (get_data_tag(v93)) {
		case 1LL: { // Some
			VAL v96 = mtp_std_maybe_Maybe_1_Some(v93);
			VAL v97;
			VAL v98;
			mw_mirth_def_Def_asZ_namespaceZAsk(v92, v96, &v97, &v98);
			x95 = v98;
			x94 = v97;
		} break;
		case 0LL: { // None
			VAL v99 = MKI64(0LL /* None */);
			x95 = v99;
			x94 = v92;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x95;
	*x4 = x94;
}
static void mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname (VAL x1, uint64_t x2, VAL x3, int64_t x4, VAL *x5, VAL *x6) {
	incref(x3);
	VAL v7 = mtw_std_either_Either_2_Right(x3);
	incref(x3);
	VAL v8 = mw_mirth_name_DName_rootZAsk(x3);
	VAL x9;
	uint64_t x10;
	int64_t x11;
	VAL x12;
	VAL x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			decref(v14);
			x13 = x3;
			x12 = v7;
			x11 = x4;
			x10 = x2;
			x9 = x1;
		} break;
		case 0LL: { // None
			decref(x3);
			STR* v15;
			STRLIT(v15, "relative name not allowed", 25);
			lpush(&lbl_arity, MKI64(x4));
			lpush(&lbl_nameZDivdname, v7);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v15), x1);
			VAL v16 = pop_value();
			x13 = v16;
			VAL v17 = lpop(&lbl_nameZDivdname);
			x12 = v17;
			int64_t v18 = VI64(lpop(&lbl_arity));
			x11 = v18;
			uint64_t v19 = pop_u64();
			x10 = v19;
			VAL r20 = pop_resource();
			x9 = r20;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v21 = mw_mirth_name_DName_lastZ_name(x13);
	VAL v22;
	VAL v23;
	mw_mirth_elab_resolveZ_defZ_namespace(x9, x10, x12, &v22, &v23);
	int64_t x24;
	uint64_t x25;
	uint64_t x26;
	VAL x27;
	VAL x28;
	switch (get_data_tag(v23)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(v23);
			x28 = v29;
			x27 = v22;
			x26 = x10;
			x25 = v21;
			x24 = x11;
		} break;
		case 0LL: { // None
			lpush(&lbl_arity, MKI64(x11));
			lpush(&lbl_name, MKU64(v21));
			push_u64(x10);
			mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang(v22);
			VAL v30 = pop_value();
			x28 = v30;
			VAL r31 = pop_resource();
			x27 = r31;
			uint64_t v32 = pop_u64();
			x26 = v32;
			uint64_t v33 = VU64(lpop(&lbl_name));
			x25 = v33;
			int64_t v34 = VI64(lpop(&lbl_arity));
			x24 = v34;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v35 = mtw_mirth_name_QName_MKQNAME(x28, x25, x24);
	*x6 = v35;
	*x5 = x27;
}
static int64_t mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk (uint64_t x1, uint64_t x2) {
	uint64_t v3 = mw_mirth_token_Token_module(x1);
	int64_t v4 = mw_mirth_module_Module_visible(x2, v3);
	return v4;
}
static void mw_mirth_elab_elabZ_defZ_qname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = mw_mirth_token_Token_nameZDivdnameZAsk(x2);
	VAL x6;
	uint64_t x7;
	VAL x8;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v5);
			x8 = v9;
			x7 = x2;
			x6 = x1;
		} break;
		case 0LL: { // None
			STR* v10;
			STRLIT(v10, "expected name", 13);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v10), x1);
			VAL v11 = pop_value();
			x8 = v11;
			uint64_t v12 = pop_u64();
			x7 = v12;
			VAL r13 = pop_resource();
			x6 = r13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x14;
	VAL x15;
	switch (get_data_tag(x8)) {
		case 0LL: { // Left
			VAL v16 = mtp_std_either_Either_2_Left(x8);
			uint64_t v17 = mw_mirth_token_Token_module(x7);
			VAL v18 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v17);
			int64_t v19 = mw_mirth_token_Token_numZ_args(x7);
			VAL v20 = mtw_mirth_name_QName_MKQNAME(v18, VU64(v16), v19);
			x15 = v20;
			x14 = x6;
		} break;
		case 1LL: { // Right
			VAL v21 = mtp_std_either_Either_2_Right(x8);
			int64_t v22 = mw_mirth_token_Token_numZ_args(x7);
			VAL v23;
			VAL v24;
			mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname(x6, x7, v21, v22, &v23, &v24);
			x15 = v24;
			x14 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x15;
	*x3 = x14;
}
static void mw_mirth_elab_elabZ_defZ_qnameZ_undefined (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_elab_elabZ_defZ_qname(x1, x2, &v5, &v6);
	incref(v6);
	VAL v7;
	int64_t v8;
	mw_mirth_name_QName_definedZ_softZAsk(v5, v6, &v7, &v8);
	uint64_t x9;
	VAL x10;
	VAL x11;
	if (((bool)v8)) {
		decref(v6);
		STR* v12;
		STRLIT(v12, "name already defined", 20);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v12), v7);
		VAL r13 = pop_resource();
		x11 = r13;
		VAL v14 = pop_value();
		x10 = v14;
		uint64_t v15 = pop_u64();
		x9 = v15;
	} else {
		x11 = v7;
		x10 = v6;
		x9 = x2;
	}
	*x4 = x10;
	*x3 = x11;
}
static void mw_mirth_elab_elabZ_defZ_head (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5, int64_t *x6, VAL *x7) {
	VAL v8 = mw_mirth_token_Token_nameZDivdnameZAsk(x2);
	VAL x9;
	uint64_t x10;
	VAL x11;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v8);
			x11 = v12;
			x10 = x2;
			x9 = x1;
		} break;
		case 0LL: { // None
			STR* v13;
			STRLIT(v13, "expected name", 13);
			lpush(&lbl_head, MKU64(x2));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x2, MKSTR(v13), x1);
			VAL v14 = pop_value();
			x11 = v14;
			uint64_t v15 = VU64(lpop(&lbl_head));
			x10 = v15;
			VAL r16 = pop_resource();
			x9 = r16;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x17;
	uint64_t x18;
	uint64_t x19;
	switch (get_data_tag(x11)) {
		case 0LL: { // Left
			VAL v20 = mtp_std_either_Either_2_Left(x11);
			x19 = VU64(v20);
			x18 = x10;
			x17 = x9;
		} break;
		case 1LL: { // Right
			VAL v21 = mtp_std_either_Either_2_Right(x11);
			VAL v22 = mw_mirth_name_DName_parts(v21);
			VAL v23 = mw_std_list_ListZPlus_1_last(v22);
			x19 = VU64(v23);
			x18 = x10;
			x17 = x9;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v24 = mw_mirth_token_Token_numZ_args(x18);
	FNPTR v25 = &mb_mirth_elab_elabZ_defZ_head_3;
	VAL v26 = mtw_mirth_mirth_PropState_1_PSDelay(MKU64(x18), MKFNPTR(v25));
	*x7 = v26;
	*x6 = v24;
	*x5 = x19;
	*x4 = x18;
	*x3 = x17;
}
static void mw_mirth_elab_parseZ_field (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4, uint64_t *x5, uint64_t *x6, uint64_t *x7) {
	uint64_t v8 = mw_mirth_token_Token_next(x2);
	uint64_t v9;
	uint64_t v10;
	uint64_t v11;
	VAL v12;
	mw_mirth_token_Token_argsZ_3(x2, x1, &v9, &v10, &v11, &v12);
	VAL v13 = mw_mirth_token_Token_nameZDivdnameZAsk(v9);
	uint64_t x14;
	VAL x15;
	uint64_t x16;
	uint64_t x17;
	uint64_t x18;
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v19 = mtp_std_maybe_Maybe_1_Some(v13);
			decref(v19);
			x18 = v9;
			x17 = v10;
			x16 = v11;
			x15 = v12;
			x14 = v8;
		} break;
		case 0LL: { // None
			STR* v20;
			STRLIT(v20, "expected field name", 19);
			push_u64(v8);
			lpush(&lbl_valueZ_type, MKU64(v11));
			lpush(&lbl_indexZ_type, MKU64(v10));
			lpush(&lbl_head, MKU64(v9));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v9, MKSTR(v20), v12);
			uint64_t v21 = VU64(lpop(&lbl_head));
			x18 = v21;
			uint64_t v22 = VU64(lpop(&lbl_indexZ_type));
			x17 = v22;
			uint64_t v23 = VU64(lpop(&lbl_valueZ_type));
			x16 = v23;
			VAL r24 = pop_resource();
			x15 = r24;
			uint64_t v25 = pop_u64();
			x14 = v25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v26 = (mw_mirth_token_Token_argsZ_0(x18, x15));
	*x7 = x16;
	*x6 = x17;
	*x5 = x18;
	*x4 = x14;
	*x3 = v26;
}
static void mw_mirth_elab_elabZ_fieldZBang (VAL x1, uint64_t x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	uint64_t v6;
	uint64_t v7;
	uint64_t v8;
	uint64_t v9;
	mw_mirth_elab_parseZ_field(x1, x2, &v5, &v6, &v7, &v8, &v9);
	VAL v10;
	uint64_t v11;
	uint64_t v12;
	int64_t v13;
	VAL v14;
	mw_mirth_elab_elabZ_defZ_head(v5, v7, &v10, &v11, &v12, &v13, &v14);
	uint64_t v15 = mw_mirth_table_Field_allocZBang();
	void* v16 = mfld_mirth_table_Field_ZTildename(v15);
	mut_set(MKU64(v12), v16);
	void* v17 = mfld_mirth_table_Field_ZTildehead(v15);
	mut_set(MKU64(v11), v17);
	int64_t v18 = 0LL;
	bool v19 = (v13 == v18);
	uint64_t x20;
	uint64_t x21;
	uint64_t x22;
	VAL x23;
	VAL x24;
	uint64_t x25;
	if (v19) {
		x25 = v15;
		x24 = v14;
		x23 = v10;
		x22 = v9;
		x21 = v8;
		x20 = v6;
	} else {
		uint64_t v26 = mw_mirth_table_Field_head(v15);
		STR* v27;
		STRLIT(v27, "Field cannot take arguments.", 28);
		VAL v28 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v26, MKSTR(v27), v10));
		x25 = v15;
		x24 = v14;
		x23 = v28;
		x22 = v9;
		x21 = v8;
		x20 = v6;
	}
	VAL v29 = mtw_mirth_mirth_PropLabel_FieldQName(x25);
	VAL v30 = mtw_mirth_mirth_Prop_1_Prop(v29, x24);
	void* v31 = mfld_mirth_table_Field_ZTildeqname(x25);
	mut_set(v30, v31);
	VAL v32 = mtw_mirth_mirth_PropLabel_FieldIndexType(x25);
	FNPTR v33 = &mb_mirth_elab_elabZ_fieldZBang_1;
	VAL v34;
	VAL v35;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(x21), v32, x23, MKFNPTR(v33), &v34, &v35);
	void* v36 = mfld_mirth_table_Field_ZTildeindexZ_type(x25);
	mut_set(v34, v36);
	VAL v37 = mtw_mirth_mirth_PropLabel_FieldValueType(x25);
	FNPTR v38 = &mb_mirth_elab_elabZ_fieldZBang_2;
	VAL v39;
	VAL v40;
	mw_mirth_mirth_PropLabel_prop_1(MKU64(x22), v37, v35, MKFNPTR(v38), &v39, &v40);
	void* v41 = mfld_mirth_table_Field_ZTildevalueZ_type(x25);
	mut_set(v39, v41);
	VAL v42 = mtw_mirth_def_Def_DefField(x25);
	VAL v43 = (mw_mirth_def_Def_register(v40, v42));
	*x4 = x20;
	*x3 = v43;
}
static VAL mw_std_map_Map_2_empty (void) {
	VAL v1 = MKI64(0LL /* Nil */);
	return v1;
}
static VAL mw_std_map_Map_2_insert (VAL x1, VAL x2) {
	VAL v3 = mtw_std_list_List_1_Cons(x1, x2);
	return v3;
}
static void mw_mirth_specializzer_runZ_specializzerZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = (mw_mirth_specializzer_ZPlusSPCheck_beginZBang());
	VAL v6;
	VAL v7;
	VAL v8;
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(x2, x1, v5, &v6, &v7, &v8);
	VAL v9;
	VAL v10;
	mw_mirth_specializzer_ZPlusSPCheck_loopZBang(v7, v8, &v9, &v10);
	mw_mirth_specializzer_ZPlusSPCheck_endZBang(v10);
	*x4 = v6;
	*x3 = v9;
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_beginZBang (void) {
	VAL v1 = MKI64(0LL /* Nil */);
	return v1;
}
static void mw_mirth_specializzer_ZPlusSPCheck_endZBang (VAL x1) {
	decref(x1);
}
static void mw_mirth_specializzer_ZPlusSPCheck_loopZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x2);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(x2, &v5, &v6);
	decref(x2);
	VAL x7;
	VAL x8;
	int64_t x9;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v5);
			VAL v11;
			VAL v12;
			mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang(v10, x1, v6, &v11, &v12);
			int64_t v13 = 1LL /* True */;
			x9 = v13;
			x8 = v12;
			x7 = v11;
		} break;
		case 0LL: { // None
			int64_t v14 = 0LL /* False */;
			x9 = v14;
			x8 = v6;
			x7 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15 = (x7);
	VAL v16 = (x8);
	int64_t v17 = x9;
	while (((bool)v17)) {
		VAL v18 = (v15);
		VAL v19 = (v16);
		incref(v19);
		VAL v20;
		VAL v21;
		mw_std_list_List_1_uncons(v19, &v20, &v21);
		decref(v19);
		VAL x22;
		VAL x23;
		int64_t x24;
		switch (get_data_tag(v20)) {
			case 1LL: { // Some
				VAL v25 = mtp_std_maybe_Maybe_1_Some(v20);
				VAL v26;
				VAL v27;
				mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang(v25, v18, v21, &v26, &v27);
				int64_t v28 = 1LL /* True */;
				x24 = v28;
				x23 = v27;
				x22 = v26;
			} break;
			case 0LL: { // None
				int64_t v29 = 0LL /* False */;
				x24 = v29;
				x23 = v21;
				x22 = v18;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v17 = x24;
		v16 = x23;
		v15 = x22;
	}
	*x4 = v16;
	*x3 = v15;
}
static void mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL x6;
	VAL x7;
	switch (get_data_tag(x1)) {
		case 0LL: { // SPCHECK_WORD
			uint64_t v8 = mtp_mirth_specializzer_SPCheckItem_SPCHECKz_WORD(x1);
			VAL v9;
			VAL v10;
			mw_mirth_word_Word_arrow(v8, x2, &v9, &v10);
			VAL v11;
			VAL v12;
			VAL v13;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v9, v10, x3, &v11, &v12, &v13);
			VAL v14 = mtw_mirth_mirth_PropLabel_WordArrow(v8);
			VAL v15;
			VAL v16;
			mw_mirth_mirth_PropLabel_prop(v11, v14, v12, &v15, &v16);
			void* v17 = mfld_mirth_word_Word_ZTildearrow(v8);
			mut_set(v15, v17);
			x7 = v13;
			x6 = v16;
		} break;
		case 1LL: { // SPCHECK_BLOCK
			uint64_t v18 = mtp_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK(x1);
			VAL v19;
			VAL v20;
			mw_mirth_arrow_Block_arrow(x2, v18, &v19, &v20);
			VAL v21;
			VAL v22;
			VAL v23;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v20, v19, x3, &v21, &v22, &v23);
			VAL v24 = mtw_mirth_mirth_PropLabel_BlockArrow(v18);
			VAL v25;
			VAL v26;
			mw_mirth_mirth_PropLabel_prop(v21, v24, v22, &v25, &v26);
			void* v27 = mfld_mirth_arrow_Block_ZTildearrow(v18);
			mut_set(v25, v27);
			x7 = v23;
			x6 = v26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	incref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[7]);
	incref(v7);
	decref(x1);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mw_std_list_List_1_reverse(v8);
	VAL v10;
	VAL v11;
	mw_std_list_List_1_uncons(v7, &v10, &v11);
	VAL x12;
	VAL x13;
	VAL x14;
	VAL x15;
	int64_t x16;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v17 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v18;
			VAL v19;
			VAL v20;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang(v17, x2, x3, &v18, &v19, &v20);
			VAL v21;
			VAL v22;
			mw_std_list_List_1_uncons(v18, &v21, &v22);
			VAL x23;
			VAL x24;
			VAL x25;
			VAL x26;
			int64_t x27;
			switch (get_data_tag(v21)) {
				case 1LL: { // Some
					VAL v28 = mtp_std_maybe_Maybe_1_Some(v21);
					VAL v29 = mtw_std_list_List_1_Cons(v28, v9);
					int64_t v30 = 1LL /* True */;
					x27 = v30;
					x26 = v22;
					x25 = v29;
					x24 = v20;
					x23 = v19;
				} break;
				case 0LL: { // None
					int64_t v31 = 0LL /* False */;
					x27 = v31;
					x26 = v22;
					x25 = v9;
					x24 = v20;
					x23 = v19;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v32 = (x23);
			VAL v33 = (x24);
			VAL v34 = (x25);
			VAL v35 = x26;
			int64_t v36 = x27;
			while (((bool)v36)) {
				VAL v37 = (v32);
				VAL v38 = (v33);
				VAL v39 = (v34);
				VAL v40 = v35;
				VAL v41;
				VAL v42;
				mw_std_list_List_1_uncons(v40, &v41, &v42);
				VAL x43;
				VAL x44;
				VAL x45;
				VAL x46;
				int64_t x47;
				switch (get_data_tag(v41)) {
					case 1LL: { // Some
						VAL v48 = mtp_std_maybe_Maybe_1_Some(v41);
						VAL v49 = mtw_std_list_List_1_Cons(v48, v39);
						int64_t v50 = 1LL /* True */;
						x47 = v50;
						x46 = v42;
						x45 = v49;
						x44 = v38;
						x43 = v37;
					} break;
					case 0LL: { // None
						int64_t v51 = 0LL /* False */;
						x47 = v51;
						x46 = v42;
						x45 = v39;
						x44 = v38;
						x43 = v37;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v36 = x47;
				v35 = x46;
				v34 = x45;
				v33 = x44;
				v32 = x43;
			}
			decref(v35);
			int64_t v52 = 1LL /* True */;
			x16 = v52;
			x15 = v11;
			x14 = v34;
			x13 = v33;
			x12 = v32;
		} break;
		case 0LL: { // None
			int64_t v53 = 0LL /* False */;
			x16 = v53;
			x15 = v11;
			x14 = v9;
			x13 = x3;
			x12 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v54 = (x12);
	VAL v55 = (x13);
	VAL v56 = (x14);
	VAL v57 = x15;
	int64_t v58 = x16;
	while (((bool)v58)) {
		VAL v59 = (v54);
		VAL v60 = (v55);
		VAL v61 = (v56);
		VAL v62 = v57;
		VAL v63;
		VAL v64;
		mw_std_list_List_1_uncons(v62, &v63, &v64);
		VAL x65;
		VAL x66;
		VAL x67;
		VAL x68;
		int64_t x69;
		switch (get_data_tag(v63)) {
			case 1LL: { // Some
				VAL v70 = mtp_std_maybe_Maybe_1_Some(v63);
				VAL v71;
				VAL v72;
				VAL v73;
				mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang(v70, v59, v60, &v71, &v72, &v73);
				VAL v74;
				VAL v75;
				mw_std_list_List_1_uncons(v71, &v74, &v75);
				VAL x76;
				VAL x77;
				VAL x78;
				VAL x79;
				int64_t x80;
				switch (get_data_tag(v74)) {
					case 1LL: { // Some
						VAL v81 = mtp_std_maybe_Maybe_1_Some(v74);
						VAL v82 = mtw_std_list_List_1_Cons(v81, v61);
						int64_t v83 = 1LL /* True */;
						x80 = v83;
						x79 = v75;
						x78 = v82;
						x77 = v73;
						x76 = v72;
					} break;
					case 0LL: { // None
						int64_t v84 = 0LL /* False */;
						x80 = v84;
						x79 = v75;
						x78 = v61;
						x77 = v73;
						x76 = v72;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v85 = (x76);
				VAL v86 = (x77);
				VAL v87 = (x78);
				VAL v88 = x79;
				int64_t v89 = x80;
				while (((bool)v89)) {
					VAL v90 = (v85);
					VAL v91 = (v86);
					VAL v92 = (v87);
					VAL v93 = v88;
					VAL v94;
					VAL v95;
					mw_std_list_List_1_uncons(v93, &v94, &v95);
					VAL x96;
					VAL x97;
					VAL x98;
					VAL x99;
					int64_t x100;
					switch (get_data_tag(v94)) {
						case 1LL: { // Some
							VAL v101 = mtp_std_maybe_Maybe_1_Some(v94);
							VAL v102 = mtw_std_list_List_1_Cons(v101, v92);
							int64_t v103 = 1LL /* True */;
							x100 = v103;
							x99 = v95;
							x98 = v102;
							x97 = v91;
							x96 = v90;
						} break;
						case 0LL: { // None
							int64_t v104 = 0LL /* False */;
							x100 = v104;
							x99 = v95;
							x98 = v92;
							x97 = v91;
							x96 = v90;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v89 = x100;
					v88 = x99;
					v87 = x98;
					v86 = x97;
					v85 = x96;
				}
				decref(v88);
				int64_t v105 = 1LL /* True */;
				x69 = v105;
				x68 = v64;
				x67 = v87;
				x66 = v86;
				x65 = v85;
			} break;
			case 0LL: { // None
				int64_t v106 = 0LL /* False */;
				x69 = v106;
				x68 = v64;
				x67 = v61;
				x66 = v60;
				x65 = v59;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v58 = x69;
		v57 = x68;
		v56 = x67;
		v55 = x66;
		v54 = x65;
	}
	decref(v57);
	VAL v107 = mw_std_list_List_1_reverse(v56);
	VAL v108 = tup_replace(x1, 7, v107);
	*x6 = v55;
	*x5 = v54;
	*x4 = v108;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	incref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[4]);
	incref(v7);
	decref(x1);
	VAL x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 0LL: { // OpNone
			VAL v11 = MKI64(0LL /* Nil */);
			VAL v12 = mtw_std_list_List_1_Cons(x1, v11);
			x10 = v12;
			x9 = x3;
			x8 = x2;
		} break;
		case 1LL: { // OpPrim
			int64_t v13 = mtp_mirth_arrow_Op_OpPrim(v7);
			VAL v14;
			VAL v15;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang(x1, v13, x3, &v14, &v15);
			x10 = v14;
			x9 = v15;
			x8 = x2;
		} break;
		case 2LL: { // OpWord
			uint64_t v16 = mtp_mirth_arrow_Op_OpWord(v7);
			VAL v17;
			VAL v18;
			VAL v19;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang(x2, x3, x1, v16, &v17, &v18, &v19);
			x10 = v19;
			x9 = v18;
			x8 = v17;
		} break;
		case 3LL: { // OpExternal
			uint64_t v20 = mtp_mirth_arrow_Op_OpExternal(v7);
			VAL v21 = MKI64(0LL /* Nil */);
			VAL v22 = mtw_std_list_List_1_Cons(x1, v21);
			x10 = v22;
			x9 = x3;
			x8 = x2;
		} break;
		case 4LL: { // OpBuffer
			uint64_t v23 = mtp_mirth_arrow_Op_OpBuffer(v7);
			VAL v24 = MKI64(0LL /* Nil */);
			VAL v25 = mtw_std_list_List_1_Cons(x1, v24);
			x10 = v25;
			x9 = x3;
			x8 = x2;
		} break;
		case 5LL: { // OpVariable
			uint64_t v26 = mtp_mirth_arrow_Op_OpVariable(v7);
			VAL v27 = MKI64(0LL /* Nil */);
			VAL v28 = mtw_std_list_List_1_Cons(x1, v27);
			x10 = v28;
			x9 = x3;
			x8 = x2;
		} break;
		case 6LL: { // OpField
			uint64_t v29 = mtp_mirth_arrow_Op_OpField(v7);
			VAL v30 = MKI64(0LL /* Nil */);
			VAL v31 = mtw_std_list_List_1_Cons(x1, v30);
			x10 = v31;
			x9 = x3;
			x8 = x2;
		} break;
		case 7LL: { // OpInt
			int64_t v32 = mtp_mirth_arrow_Op_OpInt(v7);
			VAL v33 = MKI64(0LL /* Nil */);
			VAL v34 = mtw_std_list_List_1_Cons(x1, v33);
			x10 = v34;
			x9 = x3;
			x8 = x2;
		} break;
		case 8LL: { // OpF64
			double v35 = mtp_mirth_arrow_Op_OpF64(v7);
			VAL v36 = MKI64(0LL /* Nil */);
			VAL v37 = mtw_std_list_List_1_Cons(x1, v36);
			x10 = v37;
			x9 = x3;
			x8 = x2;
		} break;
		case 9LL: { // OpStr
			VAL v38 = mtp_mirth_arrow_Op_OpStr(v7);
			decref(v38);
			VAL v39 = MKI64(0LL /* Nil */);
			VAL v40 = mtw_std_list_List_1_Cons(x1, v39);
			x10 = v40;
			x9 = x3;
			x8 = x2;
		} break;
		case 10LL: { // OpTag
			uint64_t v41 = mtp_mirth_arrow_Op_OpTag(v7);
			VAL v42 = MKI64(0LL /* Nil */);
			VAL v43 = mtw_std_list_List_1_Cons(x1, v42);
			x10 = v43;
			x9 = x3;
			x8 = x2;
		} break;
		case 11LL: { // OpMatch
			VAL v44 = mtp_mirth_arrow_Op_OpMatch(v7);
			VAL v45;
			VAL v46;
			VAL v47;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang(v44, x2, x3, &v45, &v46, &v47);
			VAL v48 = mtw_mirth_arrow_Op_OpMatch(v45);
			VAL v49 = tup_replace(x1, 4, v48);
			VAL v50 = MKI64(0LL /* Nil */);
			VAL v51 = mtw_std_list_List_1_Cons(v49, v50);
			x10 = v51;
			x9 = v47;
			x8 = v46;
		} break;
		case 12LL: { // OpLambda
			VAL v52 = mtp_mirth_arrow_Op_OpLambda(v7);
			VAL v53;
			VAL v54;
			VAL v55;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang(v52, x2, x3, &v53, &v54, &v55);
			VAL v56 = mtw_mirth_arrow_Op_OpLambda(v53);
			VAL v57 = tup_replace(x1, 4, v56);
			VAL v58 = MKI64(0LL /* Nil */);
			VAL v59 = mtw_std_list_List_1_Cons(v57, v58);
			x10 = v59;
			x9 = v55;
			x8 = v54;
		} break;
		case 13LL: { // OpVar
			uint64_t v60 = mtp_mirth_arrow_Op_OpVar(v7);
			VAL v61 = MKI64(0LL /* Nil */);
			VAL v62 = mtw_std_list_List_1_Cons(x1, v61);
			x10 = v62;
			x9 = x3;
			x8 = x2;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v63 = mtp_mirth_arrow_Op_OpBlockPush(v7);
			VAL v64 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang(v63, x3));
			VAL v65 = MKI64(0LL /* Nil */);
			VAL v66 = mtw_std_list_List_1_Cons(x1, v65);
			x10 = v66;
			x9 = v64;
			x8 = x2;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v67 = mtp_mirth_arrow_Op_OpBlockRun(v7);
			VAL v68 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang(v67, x3));
			VAL v69 = MKI64(0LL /* Nil */);
			VAL v70 = mtw_std_list_List_1_Cons(x1, v69);
			x10 = v70;
			x9 = v68;
			x8 = x2;
		} break;
		case 16LL: { // OpCoerce
			int64_t v71 = mtp_mirth_arrow_Op_OpCoerce(v7);
			VAL v72 = MKI64(0LL /* Nil */);
			VAL v73 = mtw_std_list_List_1_Cons(x1, v72);
			x10 = v73;
			x9 = x3;
			x8 = x2;
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v74 = mtp_mirth_arrow_Op_OpLabelPush(v7);
			VAL v75 = MKI64(0LL /* Nil */);
			VAL v76 = mtw_std_list_List_1_Cons(x1, v75);
			x10 = v76;
			x9 = x3;
			x8 = x2;
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v77 = mtp_mirth_arrow_Op_OpLabelPop(v7);
			VAL v78 = MKI64(0LL /* Nil */);
			VAL v79 = mtw_std_list_List_1_Cons(x1, v78);
			x10 = v79;
			x9 = x3;
			x8 = x2;
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v80 = mtp_mirth_arrow_Op_OpLabelPushR(v7);
			VAL v81 = MKI64(0LL /* Nil */);
			VAL v82 = mtw_std_list_List_1_Cons(x1, v81);
			x10 = v82;
			x9 = x3;
			x8 = x2;
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v83 = mtp_mirth_arrow_Op_OpLabelPopR(v7);
			VAL v84 = MKI64(0LL /* Nil */);
			VAL v85 = mtw_std_list_List_1_Cons(x1, v84);
			x10 = v85;
			x9 = x3;
			x8 = x2;
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v86 = mtp_mirth_arrow_Op_OpDataGetTag(v7);
			VAL v87 = MKI64(0LL /* Nil */);
			VAL v88 = mtw_std_list_List_1_Cons(x1, v87);
			x10 = v88;
			x9 = x3;
			x8 = x2;
		} break;
		case 22LL: { // OpDataGetLabel
			VAL v89 = mtp_mirth_arrow_Op_OpDataGetLabel(v7);
			decref(v89);
			VAL v90 = MKI64(0LL /* Nil */);
			VAL v91 = mtw_std_list_List_1_Cons(x1, v90);
			x10 = v91;
			x9 = x3;
			x8 = x2;
		} break;
		case 23LL: { // OpDataSetLabel
			VAL v92 = mtp_mirth_arrow_Op_OpDataSetLabel(v7);
			decref(v92);
			VAL v93 = MKI64(0LL /* Nil */);
			VAL v94 = mtw_std_list_List_1_Cons(x1, v93);
			x10 = v94;
			x9 = x3;
			x8 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x9;
	*x5 = x8;
	*x4 = x10;
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang(x1, x2));
	return v3;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang (VAL x1, int64_t x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x1);
	VAL v6 = VVAL(VTUP(x1)->cells[5]);
	incref(v6);
	decref(x1);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v13), x3));
			int64_t v15 = 1LL /* True */;
			x12 = v15;
			x11 = v8;
			x10 = x1;
			x9 = v14;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x12 = v16;
			x11 = v8;
			x10 = x1;
			x9 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v17 = (x9);
	VAL v18 = x10;
	VAL v19 = x11;
	int64_t v20 = x12;
	while (((bool)v20)) {
		VAL v21 = (v17);
		VAL v22 = v18;
		VAL v23 = v19;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		VAL x26;
		VAL x27;
		VAL x28;
		int64_t x29;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v24);
				VAL v31 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v30), v21));
				int64_t v32 = 1LL /* True */;
				x29 = v32;
				x28 = v25;
				x27 = v22;
				x26 = v31;
			} break;
			case 0LL: { // None
				int64_t v33 = 0LL /* False */;
				x29 = v33;
				x28 = v25;
				x27 = v22;
				x26 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x29;
		v19 = x28;
		v18 = x27;
		v17 = x26;
	}
	decref(v19);
	VAL v34 = MKI64(0LL /* Nil */);
	VAL v35 = mtw_std_list_List_1_Cons(v18, v34);
	*x5 = v17;
	*x4 = v35;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6, VAL *x7) {
	VAL v8 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang(x4, x2));
	incref(x3);
	VAL v9 = VVAL(VTUP(x3)->cells[5]);
	incref(v9);
	decref(x3);
	VAL v10 = mw_std_list_List_1_ZToListZPlus(v9);
	VAL x11;
	VAL x12;
	VAL x13;
	switch (get_data_tag(v10)) {
		case 0LL: { // None
			VAL v14 = MKI64(0LL /* Nil */);
			VAL v15 = mtw_std_list_List_1_Cons(x3, v14);
			x13 = v15;
			x12 = v8;
			x11 = x1;
		} break;
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v10);
			incref(v16);
			VAL v17;
			VAL v18;
			mw_std_list_ListZPlus_1_uncons(v16, &v17, &v18);
			VAL v19 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v17), v8));
			VAL v20;
			VAL v21;
			mw_std_list_List_1_uncons(v18, &v20, &v21);
			VAL x22;
			VAL x23;
			VAL x24;
			uint64_t x25;
			VAL x26;
			VAL x27;
			int64_t x28;
			switch (get_data_tag(v20)) {
				case 1LL: { // Some
					VAL v29 = mtp_std_maybe_Maybe_1_Some(v20);
					VAL v30 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v29), v19));
					int64_t v31 = 1LL /* True */;
					x28 = v31;
					x27 = v21;
					x26 = v16;
					x25 = x4;
					x24 = x3;
					x23 = v30;
					x22 = x1;
				} break;
				case 0LL: { // None
					int64_t v32 = 0LL /* False */;
					x28 = v32;
					x27 = v21;
					x26 = v16;
					x25 = x4;
					x24 = x3;
					x23 = v19;
					x22 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v33 = (x22);
			VAL v34 = (x23);
			VAL v35 = x24;
			uint64_t v36 = x25;
			VAL v37 = x26;
			VAL v38 = x27;
			int64_t v39 = x28;
			while (((bool)v39)) {
				VAL v40 = (v33);
				VAL v41 = (v34);
				VAL v42 = v35;
				uint64_t v43 = v36;
				VAL v44 = v37;
				VAL v45 = v38;
				VAL v46;
				VAL v47;
				mw_std_list_List_1_uncons(v45, &v46, &v47);
				VAL x48;
				VAL x49;
				VAL x50;
				uint64_t x51;
				VAL x52;
				VAL x53;
				int64_t x54;
				switch (get_data_tag(v46)) {
					case 1LL: { // Some
						VAL v55 = mtp_std_maybe_Maybe_1_Some(v46);
						VAL v56 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v55), v41));
						int64_t v57 = 1LL /* True */;
						x54 = v57;
						x53 = v47;
						x52 = v44;
						x51 = v43;
						x50 = v42;
						x49 = v56;
						x48 = v40;
					} break;
					case 0LL: { // None
						int64_t v58 = 0LL /* False */;
						x54 = v58;
						x53 = v47;
						x52 = v44;
						x51 = v43;
						x50 = v42;
						x49 = v41;
						x48 = v40;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v39 = x54;
				v38 = x53;
				v37 = x52;
				v36 = x51;
				v35 = x50;
				v34 = x49;
				v33 = x48;
			}
			decref(v38);
			int64_t v59 = mw_mirth_word_Word_preferZ_inlineZAsk(v36);
			bool v60 = !((bool)v59);
			VAL x61;
			VAL x62;
			VAL x63;
			uint64_t x64;
			VAL x65;
			int64_t x66;
			if (v60) {
				int64_t v67 = 1LL /* True */;
				x66 = v67;
				x65 = v37;
				x64 = v36;
				x63 = v35;
				x62 = v34;
				x61 = v33;
			} else {
				incref(v37);
				VAL v68;
				VAL v69;
				mtp_std_list_ListZPlus_1_ListZPlus(v37, &v68, &v69);
				VAL v70 = mtw_std_list_List_1_Cons(v68, v69);
				VAL v71 = MKI64(0LL /* None */);
				VAL v72;
				VAL v73;
				mw_std_list_List_1_uncons(v70, &v72, &v73);
				VAL x74;
				VAL x75;
				VAL x76;
				uint64_t x77;
				VAL x78;
				VAL x79;
				VAL x80;
				int64_t x81;
				switch (get_data_tag(v72)) {
					case 1LL: { // Some
						VAL v82 = mtp_std_maybe_Maybe_1_Some(v72);
						incref(v82);
						VAL v83;
						VAL v84;
						mw_mirth_arrow_Arg_freeZ_vars(v33, VU64(v82), &v83, &v84);
						VAL v85 = MKI64(0LL /* None */);
						VAL v86;
						VAL v87;
						mw_std_list_List_1_uncons(v84, &v86, &v87);
						VAL x88;
						uint64_t x89;
						VAL x90;
						VAL x91;
						VAL x92;
						VAL x93;
						VAL x94;
						int64_t x95;
						switch (get_data_tag(v86)) {
							case 1LL: { // Some
								VAL v96 = mtp_std_maybe_Maybe_1_Some(v86);
								incref(v96);
								int64_t v97 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v96));
								VAL x98;
								uint64_t x99;
								VAL x100;
								VAL x101;
								VAL x102;
								VAL x103;
								if (((bool)v97)) {
									VAL v104 = mtw_std_maybe_Maybe_1_Some(v96);
									x103 = v104;
									x102 = v34;
									x101 = v83;
									x100 = v37;
									x99 = v36;
									x98 = v35;
								} else {
									decref(v96);
									VAL v105 = MKI64(0LL /* None */);
									x103 = v105;
									x102 = v34;
									x101 = v83;
									x100 = v37;
									x99 = v36;
									x98 = v35;
								}
								VAL x106;
								uint64_t x107;
								VAL x108;
								VAL x109;
								VAL x110;
								VAL x111;
								VAL x112;
								switch (get_data_tag(x103)) {
									case 0LL: { // None
										x112 = v87;
										x111 = v85;
										x110 = x102;
										x109 = x101;
										x108 = x100;
										x107 = x99;
										x106 = x98;
									} break;
									default: {
										decref(v87);
										decref(v85);
										VAL v113 = MKI64(0LL /* Nil */);
										x112 = v113;
										x111 = x103;
										x110 = x102;
										x109 = x101;
										x108 = x100;
										x107 = x99;
										x106 = x98;
									} break;
								}
								int64_t v114 = 1LL /* True */;
								x95 = v114;
								x94 = x112;
								x93 = x111;
								x92 = x110;
								x91 = x109;
								x90 = x108;
								x89 = x107;
								x88 = x106;
							} break;
							case 0LL: { // None
								int64_t v115 = 0LL /* False */;
								x95 = v115;
								x94 = v87;
								x93 = v85;
								x92 = v34;
								x91 = v83;
								x90 = v37;
								x89 = v36;
								x88 = v35;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						VAL v116 = x88;
						uint64_t v117 = x89;
						VAL v118 = x90;
						VAL v119 = (x91);
						VAL v120 = (x92);
						VAL v121 = x93;
						VAL v122 = x94;
						int64_t v123 = x95;
						while (((bool)v123)) {
							VAL v124 = v116;
							uint64_t v125 = v117;
							VAL v126 = v118;
							VAL v127 = (v119);
							VAL v128 = (v120);
							VAL v129 = v121;
							VAL v130 = v122;
							VAL v131;
							VAL v132;
							mw_std_list_List_1_uncons(v130, &v131, &v132);
							VAL x133;
							uint64_t x134;
							VAL x135;
							VAL x136;
							VAL x137;
							VAL x138;
							VAL x139;
							int64_t x140;
							switch (get_data_tag(v131)) {
								case 1LL: { // Some
									VAL v141 = mtp_std_maybe_Maybe_1_Some(v131);
									incref(v141);
									int64_t v142 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v141));
									VAL x143;
									uint64_t x144;
									VAL x145;
									VAL x146;
									VAL x147;
									VAL x148;
									if (((bool)v142)) {
										VAL v149 = mtw_std_maybe_Maybe_1_Some(v141);
										x148 = v149;
										x147 = v128;
										x146 = v127;
										x145 = v126;
										x144 = v125;
										x143 = v124;
									} else {
										decref(v141);
										VAL v150 = MKI64(0LL /* None */);
										x148 = v150;
										x147 = v128;
										x146 = v127;
										x145 = v126;
										x144 = v125;
										x143 = v124;
									}
									VAL x151;
									uint64_t x152;
									VAL x153;
									VAL x154;
									VAL x155;
									VAL x156;
									VAL x157;
									switch (get_data_tag(x148)) {
										case 0LL: { // None
											x157 = v132;
											x156 = v129;
											x155 = x147;
											x154 = x146;
											x153 = x145;
											x152 = x144;
											x151 = x143;
										} break;
										default: {
											decref(v132);
											decref(v129);
											VAL v158 = MKI64(0LL /* Nil */);
											x157 = v158;
											x156 = x148;
											x155 = x147;
											x154 = x146;
											x153 = x145;
											x152 = x144;
											x151 = x143;
										} break;
									}
									int64_t v159 = 1LL /* True */;
									x140 = v159;
									x139 = x157;
									x138 = x156;
									x137 = x155;
									x136 = x154;
									x135 = x153;
									x134 = x152;
									x133 = x151;
								} break;
								case 0LL: { // None
									int64_t v160 = 0LL /* False */;
									x140 = v160;
									x139 = v132;
									x138 = v129;
									x137 = v128;
									x136 = v127;
									x135 = v126;
									x134 = v125;
									x133 = v124;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							v123 = x140;
							v122 = x139;
							v121 = x138;
							v120 = x137;
							v119 = x136;
							v118 = x135;
							v117 = x134;
							v116 = x133;
						}
						decref(v122);
						int64_t v161 = mw_std_maybe_Maybe_1_someZAsk(v121);
						VAL x162;
						VAL x163;
						VAL x164;
						uint64_t x165;
						VAL x166;
						VAL x167;
						if (((bool)v161)) {
							VAL v168 = mtw_std_maybe_Maybe_1_Some(v82);
							x167 = v168;
							x166 = v118;
							x165 = v117;
							x164 = v116;
							x163 = v120;
							x162 = v119;
						} else {
							decref(v82);
							VAL v169 = MKI64(0LL /* None */);
							x167 = v169;
							x166 = v118;
							x165 = v117;
							x164 = v116;
							x163 = v120;
							x162 = v119;
						}
						VAL x170;
						VAL x171;
						VAL x172;
						uint64_t x173;
						VAL x174;
						VAL x175;
						VAL x176;
						switch (get_data_tag(x167)) {
							case 0LL: { // None
								x176 = v73;
								x175 = v71;
								x174 = x166;
								x173 = x165;
								x172 = x164;
								x171 = x163;
								x170 = x162;
							} break;
							default: {
								decref(v73);
								decref(v71);
								VAL v177 = MKI64(0LL /* Nil */);
								x176 = v177;
								x175 = x167;
								x174 = x166;
								x173 = x165;
								x172 = x164;
								x171 = x163;
								x170 = x162;
							} break;
						}
						int64_t v178 = 1LL /* True */;
						x81 = v178;
						x80 = x176;
						x79 = x175;
						x78 = x174;
						x77 = x173;
						x76 = x172;
						x75 = x171;
						x74 = x170;
					} break;
					case 0LL: { // None
						int64_t v179 = 0LL /* False */;
						x81 = v179;
						x80 = v73;
						x79 = v71;
						x78 = v37;
						x77 = v36;
						x76 = v35;
						x75 = v34;
						x74 = v33;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v180 = (x74);
				VAL v181 = (x75);
				VAL v182 = x76;
				uint64_t v183 = x77;
				VAL v184 = x78;
				VAL v185 = x79;
				VAL v186 = x80;
				int64_t v187 = x81;
				while (((bool)v187)) {
					VAL v188 = (v180);
					VAL v189 = (v181);
					VAL v190 = v182;
					uint64_t v191 = v183;
					VAL v192 = v184;
					VAL v193 = v185;
					VAL v194 = v186;
					VAL v195;
					VAL v196;
					mw_std_list_List_1_uncons(v194, &v195, &v196);
					VAL x197;
					VAL x198;
					VAL x199;
					uint64_t x200;
					VAL x201;
					VAL x202;
					VAL x203;
					int64_t x204;
					switch (get_data_tag(v195)) {
						case 1LL: { // Some
							VAL v205 = mtp_std_maybe_Maybe_1_Some(v195);
							incref(v205);
							VAL v206;
							VAL v207;
							mw_mirth_arrow_Arg_freeZ_vars(v188, VU64(v205), &v206, &v207);
							VAL v208 = MKI64(0LL /* None */);
							VAL v209;
							VAL v210;
							mw_std_list_List_1_uncons(v207, &v209, &v210);
							VAL x211;
							uint64_t x212;
							VAL x213;
							VAL x214;
							VAL x215;
							VAL x216;
							VAL x217;
							int64_t x218;
							switch (get_data_tag(v209)) {
								case 1LL: { // Some
									VAL v219 = mtp_std_maybe_Maybe_1_Some(v209);
									incref(v219);
									int64_t v220 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v219));
									VAL x221;
									uint64_t x222;
									VAL x223;
									VAL x224;
									VAL x225;
									VAL x226;
									if (((bool)v220)) {
										VAL v227 = mtw_std_maybe_Maybe_1_Some(v219);
										x226 = v227;
										x225 = v189;
										x224 = v206;
										x223 = v192;
										x222 = v191;
										x221 = v190;
									} else {
										decref(v219);
										VAL v228 = MKI64(0LL /* None */);
										x226 = v228;
										x225 = v189;
										x224 = v206;
										x223 = v192;
										x222 = v191;
										x221 = v190;
									}
									VAL x229;
									uint64_t x230;
									VAL x231;
									VAL x232;
									VAL x233;
									VAL x234;
									VAL x235;
									switch (get_data_tag(x226)) {
										case 0LL: { // None
											x235 = v210;
											x234 = v208;
											x233 = x225;
											x232 = x224;
											x231 = x223;
											x230 = x222;
											x229 = x221;
										} break;
										default: {
											decref(v210);
											decref(v208);
											VAL v236 = MKI64(0LL /* Nil */);
											x235 = v236;
											x234 = x226;
											x233 = x225;
											x232 = x224;
											x231 = x223;
											x230 = x222;
											x229 = x221;
										} break;
									}
									int64_t v237 = 1LL /* True */;
									x218 = v237;
									x217 = x235;
									x216 = x234;
									x215 = x233;
									x214 = x232;
									x213 = x231;
									x212 = x230;
									x211 = x229;
								} break;
								case 0LL: { // None
									int64_t v238 = 0LL /* False */;
									x218 = v238;
									x217 = v210;
									x216 = v208;
									x215 = v189;
									x214 = v206;
									x213 = v192;
									x212 = v191;
									x211 = v190;
								} break;
								default: {
									do_panic(str_make("unexpected fallthrough in match\n", 32));
								}
							}
							VAL v239 = x211;
							uint64_t v240 = x212;
							VAL v241 = x213;
							VAL v242 = (x214);
							VAL v243 = (x215);
							VAL v244 = x216;
							VAL v245 = x217;
							int64_t v246 = x218;
							while (((bool)v246)) {
								VAL v247 = v239;
								uint64_t v248 = v240;
								VAL v249 = v241;
								VAL v250 = (v242);
								VAL v251 = (v243);
								VAL v252 = v244;
								VAL v253 = v245;
								VAL v254;
								VAL v255;
								mw_std_list_List_1_uncons(v253, &v254, &v255);
								VAL x256;
								uint64_t x257;
								VAL x258;
								VAL x259;
								VAL x260;
								VAL x261;
								VAL x262;
								int64_t x263;
								switch (get_data_tag(v254)) {
									case 1LL: { // Some
										VAL v264 = mtp_std_maybe_Maybe_1_Some(v254);
										incref(v264);
										int64_t v265 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v264));
										VAL x266;
										uint64_t x267;
										VAL x268;
										VAL x269;
										VAL x270;
										VAL x271;
										if (((bool)v265)) {
											VAL v272 = mtw_std_maybe_Maybe_1_Some(v264);
											x271 = v272;
											x270 = v251;
											x269 = v250;
											x268 = v249;
											x267 = v248;
											x266 = v247;
										} else {
											decref(v264);
											VAL v273 = MKI64(0LL /* None */);
											x271 = v273;
											x270 = v251;
											x269 = v250;
											x268 = v249;
											x267 = v248;
											x266 = v247;
										}
										VAL x274;
										uint64_t x275;
										VAL x276;
										VAL x277;
										VAL x278;
										VAL x279;
										VAL x280;
										switch (get_data_tag(x271)) {
											case 0LL: { // None
												x280 = v255;
												x279 = v252;
												x278 = x270;
												x277 = x269;
												x276 = x268;
												x275 = x267;
												x274 = x266;
											} break;
											default: {
												decref(v255);
												decref(v252);
												VAL v281 = MKI64(0LL /* Nil */);
												x280 = v281;
												x279 = x271;
												x278 = x270;
												x277 = x269;
												x276 = x268;
												x275 = x267;
												x274 = x266;
											} break;
										}
										int64_t v282 = 1LL /* True */;
										x263 = v282;
										x262 = x280;
										x261 = x279;
										x260 = x278;
										x259 = x277;
										x258 = x276;
										x257 = x275;
										x256 = x274;
									} break;
									case 0LL: { // None
										int64_t v283 = 0LL /* False */;
										x263 = v283;
										x262 = v255;
										x261 = v252;
										x260 = v251;
										x259 = v250;
										x258 = v249;
										x257 = v248;
										x256 = v247;
									} break;
									default: {
										do_panic(str_make("unexpected fallthrough in match\n", 32));
									}
								}
								v246 = x263;
								v245 = x262;
								v244 = x261;
								v243 = x260;
								v242 = x259;
								v241 = x258;
								v240 = x257;
								v239 = x256;
							}
							decref(v245);
							int64_t v284 = mw_std_maybe_Maybe_1_someZAsk(v244);
							VAL x285;
							VAL x286;
							VAL x287;
							uint64_t x288;
							VAL x289;
							VAL x290;
							if (((bool)v284)) {
								VAL v291 = mtw_std_maybe_Maybe_1_Some(v205);
								x290 = v291;
								x289 = v241;
								x288 = v240;
								x287 = v239;
								x286 = v243;
								x285 = v242;
							} else {
								decref(v205);
								VAL v292 = MKI64(0LL /* None */);
								x290 = v292;
								x289 = v241;
								x288 = v240;
								x287 = v239;
								x286 = v243;
								x285 = v242;
							}
							VAL x293;
							VAL x294;
							VAL x295;
							uint64_t x296;
							VAL x297;
							VAL x298;
							VAL x299;
							switch (get_data_tag(x290)) {
								case 0LL: { // None
									x299 = v196;
									x298 = v193;
									x297 = x289;
									x296 = x288;
									x295 = x287;
									x294 = x286;
									x293 = x285;
								} break;
								default: {
									decref(v196);
									decref(v193);
									VAL v300 = MKI64(0LL /* Nil */);
									x299 = v300;
									x298 = x290;
									x297 = x289;
									x296 = x288;
									x295 = x287;
									x294 = x286;
									x293 = x285;
								} break;
							}
							int64_t v301 = 1LL /* True */;
							x204 = v301;
							x203 = x299;
							x202 = x298;
							x201 = x297;
							x200 = x296;
							x199 = x295;
							x198 = x294;
							x197 = x293;
						} break;
						case 0LL: { // None
							int64_t v302 = 0LL /* False */;
							x204 = v302;
							x203 = v196;
							x202 = v193;
							x201 = v192;
							x200 = v191;
							x199 = v190;
							x198 = v189;
							x197 = v188;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v187 = x204;
					v186 = x203;
					v185 = x202;
					v184 = x201;
					v183 = x200;
					v182 = x199;
					v181 = x198;
					v180 = x197;
				}
				decref(v186);
				int64_t v303 = mw_std_maybe_Maybe_1_someZAsk(v185);
				x66 = v303;
				x65 = v184;
				x64 = v183;
				x63 = v182;
				x62 = v181;
				x61 = v180;
			}
			VAL x304;
			VAL x305;
			VAL x306;
			if (((bool)x66)) {
				decref(x65);
				VAL v307 = MKI64(0LL /* Nil */);
				VAL v308 = mtw_std_list_List_1_Cons(x63, v307);
				x306 = v308;
				x305 = x62;
				x304 = x61;
			} else {
				VAL v309;
				uint64_t v310;
				mw_mirth_specializzer_specializzeZ_wordZBang(x61, x65, x64, &v309, &v310);
				VAL v311 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang(v310, x62));
				VAL v312;
				uint64_t v313;
				VAL v314;
				VAL v315;
				VAL v316;
				VAL v317;
				VAL v318;
				VAL v319;
				mtp_mirth_arrow_Atom_Atom(x63, &v312, &v313, &v314, &v315, &v316, &v317, &v318, &v319);
				VAL v320 = mw_mirth_type_TZ_ZTo(v317, v318);
				decref(v316);
				decref(v315);
				decref(v319);
				VAL v321;
				VAL v322;
				mw_mirth_type_ArrowType_unpack(v320, &v321, &v322);
				incref(v321);
				VAL v323 = MKI64(0LL /* Nil */);
				VAL v324 = mtw_mirth_arrow_Arrow_Arrow(v312, v313, v313, v314, v321, v321, v323);
				VAL v325;
				VAL v326;
				mw_mirth_elab_abZ_wordZBang(v310, v309, v324, &v325, &v326);
				VAL v327;
				VAL v328;
				mw_mirth_elab_abZ_unifyZ_typeZBang(v322, v325, v326, &v327, &v328);
				VAL v329 = VVAL(VTUP(v328)->cells[7]);
				incref(v329);
				decref(v328);
				x306 = v329;
				x305 = v311;
				x304 = v327;
			}
			x13 = x306;
			x12 = x305;
			x11 = x304;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x7 = x13;
	*x6 = x12;
	*x5 = x11;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	incref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[7]);
	incref(v7);
	decref(x1);
	VAL v8 = MKI64(0LL /* Nil */);
	VAL v9 = mw_std_list_List_1_reverse(v8);
	VAL v10;
	VAL v11;
	mw_std_list_List_1_uncons(v7, &v10, &v11);
	VAL x12;
	VAL x13;
	VAL x14;
	VAL x15;
	int64_t x16;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v17 = mtp_std_maybe_Maybe_1_Some(v10);
			VAL v18;
			VAL v19;
			VAL v20;
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang(v17, x2, x3, &v18, &v19, &v20);
			VAL v21 = mtw_std_list_List_1_Cons(v18, v9);
			int64_t v22 = 1LL /* True */;
			x16 = v22;
			x15 = v11;
			x14 = v21;
			x13 = v20;
			x12 = v19;
		} break;
		case 0LL: { // None
			int64_t v23 = 0LL /* False */;
			x16 = v23;
			x15 = v11;
			x14 = v9;
			x13 = x3;
			x12 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v24 = (x12);
	VAL v25 = (x13);
	VAL v26 = (x14);
	VAL v27 = x15;
	int64_t v28 = x16;
	while (((bool)v28)) {
		VAL v29 = (v24);
		VAL v30 = (v25);
		VAL v31 = (v26);
		VAL v32 = v27;
		VAL v33;
		VAL v34;
		mw_std_list_List_1_uncons(v32, &v33, &v34);
		VAL x35;
		VAL x36;
		VAL x37;
		VAL x38;
		int64_t x39;
		switch (get_data_tag(v33)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(v33);
				VAL v41;
				VAL v42;
				VAL v43;
				mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang(v40, v29, v30, &v41, &v42, &v43);
				VAL v44 = mtw_std_list_List_1_Cons(v41, v31);
				int64_t v45 = 1LL /* True */;
				x39 = v45;
				x38 = v34;
				x37 = v44;
				x36 = v43;
				x35 = v42;
			} break;
			case 0LL: { // None
				int64_t v46 = 0LL /* False */;
				x39 = v46;
				x38 = v34;
				x37 = v31;
				x36 = v30;
				x35 = v29;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v28 = x39;
		v27 = x38;
		v26 = x37;
		v25 = x36;
		v24 = x35;
	}
	decref(v27);
	VAL v47 = mw_std_list_List_1_reverse(v26);
	VAL v48 = tup_replace(x1, 7, v47);
	*x6 = v25;
	*x5 = v24;
	*x4 = v48;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	incref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[2]);
	incref(v7);
	decref(x1);
	VAL v8;
	VAL v9;
	VAL v10;
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v7, x2, x3, &v8, &v9, &v10);
	VAL v11 = tup_replace(x1, 2, v8);
	*x6 = v10;
	*x5 = v9;
	*x4 = v11;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	incref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[5]);
	incref(v7);
	decref(x1);
	VAL v8;
	VAL v9;
	VAL v10;
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v7, x2, x3, &v8, &v9, &v10);
	VAL v11 = tup_replace(x1, 5, v8);
	*x6 = v10;
	*x5 = v9;
	*x4 = v11;
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang (uint64_t x1, VAL x2) {
	void* v3 = mfld_mirth_word_Word_ZTildespZ_checked(x1);
	VAL v4 = mw_std_prelude_ZAtZAsk(v3);
	VAL x5;
	uint64_t x6;
	int64_t x7;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v4);
			x7 = VI64(v8);
			x6 = x1;
			x5 = x2;
		} break;
		case 0LL: { // None
			int64_t v9 = 0LL /* False */;
			x7 = v9;
			x6 = x1;
			x5 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x10;
	if (((bool)x7)) {
		x10 = x5;
	} else {
		int64_t v11 = 1LL /* True */;
		void* v12 = mfld_mirth_word_Word_ZTildespZ_checked(x6);
		mut_set(MKI64(v11), v12);
		VAL v13 = mtw_mirth_specializzer_SPCheckItem_SPCHECKz_WORD(x6);
		incref(x5);
		VAL v14 = mtw_std_list_List_1_Cons(v13, x5);
		decref(x5);
		x10 = v14;
	}
	return x10;
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang (uint64_t x1, VAL x2) {
	void* v3 = mfld_mirth_arrow_Block_ZTildespZ_checked(x1);
	VAL v4 = mw_std_prelude_ZAtZAsk(v3);
	VAL x5;
	uint64_t x6;
	int64_t x7;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v4);
			x7 = VI64(v8);
			x6 = x1;
			x5 = x2;
		} break;
		case 0LL: { // None
			int64_t v9 = 0LL /* False */;
			x7 = v9;
			x6 = x1;
			x5 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x10;
	if (((bool)x7)) {
		x10 = x5;
	} else {
		int64_t v11 = 1LL /* True */;
		void* v12 = mfld_mirth_arrow_Block_ZTildespZ_checked(x6);
		mut_set(MKI64(v11), v12);
		VAL v13 = mtw_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK(x6);
		incref(x5);
		VAL v14 = mtw_std_list_List_1_Cons(v13, x5);
		decref(x5);
		x10 = v14;
	}
	return x10;
}
static int64_t mw_mirth_specializzer_SPKey_ZEqualZEqual (VAL x1, VAL x2) {
	VAL v3;
	VAL v4;
	mtp_std_list_ListZPlus_1_ListZPlus(x1, &v3, &v4);
	VAL v5 = mtw_std_list_List_1_Cons(v3, v4);
	VAL v6;
	VAL v7;
	mtp_std_list_ListZPlus_1_ListZPlus(x2, &v6, &v7);
	VAL v8 = mtw_std_list_List_1_Cons(v6, v7);
	int64_t v9 = 1LL /* True */;
	VAL v10;
	VAL v11;
	mw_std_list_List_1_uncons(v5, &v10, &v11);
	VAL v12;
	VAL v13;
	mw_std_list_List_1_uncons(v8, &v12, &v13);
	int64_t x14;
	switch (get_data_tag(v12)) {
		case 0LL: { // None
			int64_t v15 = mw_std_maybe_Maybe_1_noneZAsk(v10);
			x14 = v15;
		} break;
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v12);
			int64_t x17;
			switch (get_data_tag(v10)) {
				case 1LL: { // Some
					VAL v18 = mtp_std_maybe_Maybe_1_Some(v10);
					int64_t v19 = mw_mirth_arrow_Arg_ZEqualZEqual(VU64(v18), VU64(v16));
					x17 = v19;
				} break;
				case 0LL: { // None
					decref(v16);
					int64_t v20 = 0LL /* False */;
					x17 = v20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x14 = x17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	bool v21 = (((bool)x14) && ((bool)v9));
	incref(v11);
	int64_t v22 = mw_std_list_List_1_emptyZAsk(v11);
	incref(v13);
	int64_t v23 = mw_std_list_List_1_emptyZAsk(v13);
	bool v24 = (((bool)v22) && ((bool)v23));
	bool v25 = !v24;
	bool v26 = (v25 && v21);
	VAL v27 = v11;
	VAL v28 = v13;
	bool v29 = v21;
	bool v30 = v26;
	while (v30) {
		VAL v31 = v27;
		VAL v32 = v28;
		bool v33 = v29;
		VAL v34;
		VAL v35;
		mw_std_list_List_1_uncons(v31, &v34, &v35);
		VAL v36;
		VAL v37;
		mw_std_list_List_1_uncons(v32, &v36, &v37);
		int64_t x38;
		switch (get_data_tag(v36)) {
			case 0LL: { // None
				int64_t v39 = mw_std_maybe_Maybe_1_noneZAsk(v34);
				x38 = v39;
			} break;
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(v36);
				int64_t x41;
				switch (get_data_tag(v34)) {
					case 1LL: { // Some
						VAL v42 = mtp_std_maybe_Maybe_1_Some(v34);
						int64_t v43 = mw_mirth_arrow_Arg_ZEqualZEqual(VU64(v42), VU64(v40));
						x41 = v43;
					} break;
					case 0LL: { // None
						decref(v40);
						int64_t v44 = 0LL /* False */;
						x41 = v44;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x38 = x41;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		bool v45 = (((bool)x38) && v33);
		incref(v35);
		int64_t v46 = mw_std_list_List_1_emptyZAsk(v35);
		incref(v37);
		int64_t v47 = mw_std_list_List_1_emptyZAsk(v37);
		bool v48 = (((bool)v46) && ((bool)v47));
		bool v49 = !v48;
		bool v50 = (v49 && v45);
		v30 = v50;
		v29 = v45;
		v28 = v37;
		v27 = v35;
	}
	decref(v28);
	decref(v27);
	return ((int64_t)v29);
}
static void mw_mirth_specializzer_SPKey_ZToStr (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	STR* v5;
	STRLIT(v5, "", 0);
	STR* v6;
	STRLIT(v6, "(", 1);
	VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), MKSTR(v5)));
	STR* v8;
	STRLIT(v8, "", 0);
	VAL v9;
	VAL v10;
	mw_std_list_ListZPlus_1_uncons(x2, &v9, &v10);
	VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
	VAL v12;
	VAL v13;
	mw_mirth_arrow_Arg_ZToStr(x1, VU64(v9), &v12, &v13);
	VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(v13, v11));
	STR* v15;
	STRLIT(v15, ",", 1);
	VAL v16;
	VAL v17;
	mw_std_list_List_1_uncons(v10, &v16, &v17);
	VAL x18;
	VAL x19;
	VAL x20;
	VAL x21;
	int64_t x22;
	switch (get_data_tag(v16)) {
		case 1LL: { // Some
			VAL v23 = mtp_std_maybe_Maybe_1_Some(v16);
			VAL v24 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v15), v14));
			VAL v25;
			VAL v26;
			mw_mirth_arrow_Arg_ZToStr(v12, VU64(v23), &v25, &v26);
			VAL v27 = (mw_std_str_ZPlusStr_pushZ_strZBang(v26, v24));
			STR* v28;
			STRLIT(v28, ",", 1);
			int64_t v29 = 1LL /* True */;
			x22 = v29;
			x21 = v17;
			x20 = MKSTR(v28);
			x19 = v27;
			x18 = v25;
		} break;
		case 0LL: { // None
			int64_t v30 = 0LL /* False */;
			x22 = v30;
			x21 = v17;
			x20 = MKSTR(v15);
			x19 = v14;
			x18 = v12;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v31 = (x18);
	VAL v32 = (x19);
	VAL v33 = x20;
	VAL v34 = x21;
	int64_t v35 = x22;
	while (((bool)v35)) {
		VAL v36 = (v31);
		VAL v37 = (v32);
		VAL v38 = v33;
		VAL v39 = v34;
		VAL v40;
		VAL v41;
		mw_std_list_List_1_uncons(v39, &v40, &v41);
		VAL x42;
		VAL x43;
		VAL x44;
		VAL x45;
		int64_t x46;
		switch (get_data_tag(v40)) {
			case 1LL: { // Some
				VAL v47 = mtp_std_maybe_Maybe_1_Some(v40);
				VAL v48 = (mw_std_str_ZPlusStr_pushZ_strZBang(v38, v37));
				VAL v49;
				VAL v50;
				mw_mirth_arrow_Arg_ZToStr(v36, VU64(v47), &v49, &v50);
				VAL v51 = (mw_std_str_ZPlusStr_pushZ_strZBang(v50, v48));
				STR* v52;
				STRLIT(v52, ",", 1);
				int64_t v53 = 1LL /* True */;
				x46 = v53;
				x45 = v41;
				x44 = MKSTR(v52);
				x43 = v51;
				x42 = v49;
			} break;
			case 0LL: { // None
				int64_t v54 = 0LL /* False */;
				x46 = v54;
				x45 = v41;
				x44 = v38;
				x43 = v37;
				x42 = v36;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v35 = x46;
		v34 = x45;
		v33 = x44;
		v32 = x43;
		v31 = x42;
	}
	decref(v34);
	decref(v33);
	STR* v55;
	STRLIT(v55, ")", 1);
	VAL v56 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v55), v32));
	*x4 = v56;
	*x3 = v31;
}
static void mw_mirth_specializzer_SPKey_ZToName (VAL x1, VAL x2, VAL *x3, uint64_t *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_specializzer_SPKey_ZToStr(x1, x2, &v5, &v6);
	uint64_t v7 = mw_std_prim_Str_ZToName(v6);
	*x4 = v7;
	*x3 = v5;
}
static VAL mw_mirth_word_Word_spZ_synthed (uint64_t x1) {
	void* v2 = mfld_mirth_word_Word_ZTildespZ_synthed(x1);
	VAL v3 = mw_std_prelude_ZAtZAsk(v2);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			x4 = v5;
		} break;
		case 0LL: { // None
			VAL v6 = mw_std_map_Map_2_empty();
			x4 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static void mw_mirth_specializzer_specializzeZ_wordZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, uint64_t *x5) {
	incref(x2);
	VAL v6 = mw_mirth_word_Word_spZ_synthed(x3);
	VAL v7 = MKI64(0LL /* None */);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v6, &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			incref(v14);
			incref(x2);
			VAL v15 = VVAL(VTUP(v14)->cells[1]);
			incref(v15);
			decref(v14);
			int64_t v16 = mw_mirth_specializzer_SPKey_ZEqualZEqual(x2, v15);
			VAL x17;
			VAL x18;
			if (((bool)v16)) {
				VAL v19 = mtw_std_maybe_Maybe_1_Some(v14);
				x18 = v19;
				x17 = x2;
				push_resource(x1);
				lpush(&lbl_key, x2);
				lpush(&lbl_word, MKU64(x3));
			} else {
				decref(v14);
				VAL v20 = MKI64(0LL /* None */);
				x18 = v20;
				x17 = x2;
				push_resource(x1);
				lpush(&lbl_key, x2);
				lpush(&lbl_word, MKU64(x3));
			}
			VAL x21;
			VAL x22;
			VAL x23;
			switch (get_data_tag(x18)) {
				case 0LL: { // None
					x23 = v9;
					x22 = v7;
					x21 = x17;
				} break;
				default: {
					decref(v9);
					decref(v7);
					VAL v24 = MKI64(0LL /* Nil */);
					x23 = v24;
					x22 = x18;
					x21 = x17;
				} break;
			}
			int64_t v25 = 1LL /* True */;
			x13 = v25;
			x12 = x23;
			x11 = x22;
			x10 = x21;
		} break;
		case 0LL: { // None
			int64_t v26 = 0LL /* False */;
			x13 = v26;
			x12 = v9;
			x11 = v7;
			x10 = x2;
			push_resource(x1);
			lpush(&lbl_key, x2);
			lpush(&lbl_word, MKU64(x3));
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v27 = x10;
	VAL v28 = x11;
	VAL v29 = x12;
	int64_t v30 = x13;
	while (((bool)v30)) {
		VAL v31 = v27;
		VAL v32 = v28;
		VAL v33 = v29;
		VAL v34;
		VAL v35;
		mw_std_list_List_1_uncons(v33, &v34, &v35);
		VAL x36;
		VAL x37;
		VAL x38;
		int64_t x39;
		switch (get_data_tag(v34)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(v34);
				incref(v40);
				incref(v31);
				VAL v41 = VVAL(VTUP(v40)->cells[1]);
				incref(v41);
				decref(v40);
				int64_t v42 = mw_mirth_specializzer_SPKey_ZEqualZEqual(v31, v41);
				VAL x43;
				VAL x44;
				if (((bool)v42)) {
					VAL v45 = mtw_std_maybe_Maybe_1_Some(v40);
					x44 = v45;
					x43 = v31;
				} else {
					decref(v40);
					VAL v46 = MKI64(0LL /* None */);
					x44 = v46;
					x43 = v31;
				}
				VAL x47;
				VAL x48;
				VAL x49;
				switch (get_data_tag(x44)) {
					case 0LL: { // None
						x49 = v35;
						x48 = v32;
						x47 = x43;
					} break;
					default: {
						decref(v35);
						decref(v32);
						VAL v50 = MKI64(0LL /* Nil */);
						x49 = v50;
						x48 = x44;
						x47 = x43;
					} break;
				}
				int64_t v51 = 1LL /* True */;
				x39 = v51;
				x38 = x49;
				x37 = x48;
				x36 = x47;
			} break;
			case 0LL: { // None
				int64_t v52 = 0LL /* False */;
				x39 = v52;
				x38 = v35;
				x37 = v32;
				x36 = v31;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v30 = x39;
		v29 = x38;
		v28 = x37;
		v27 = x36;
	}
	decref(v29);
	decref(v27);
	VAL x53;
	switch (get_data_tag(v28)) {
		case 1LL: { // Some
			VAL v54 = mtp_std_maybe_Maybe_1_Some(v28);
			VAL v55 = VVAL(VTUP(v54)->cells[2]);
			incref(v55);
			decref(v54);
			VAL v56 = mtw_std_maybe_Maybe_1_Some(v55);
			x53 = v56;
		} break;
		case 0LL: { // None
			VAL v57 = MKI64(0LL /* None */);
			x53 = v57;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x58;
	VAL x59;
	uint64_t x60;
	uint64_t x61;
	switch (get_data_tag(x53)) {
		case 1LL: { // Some
			VAL v62 = mtp_std_maybe_Maybe_1_Some(x53);
			int64_t v63 = 0LL /* False */;
			incref(v62);
			void* v64 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(VU64(v62));
			mut_set(MKI64(v63), v64);
			x61 = VU64(v62);
			uint64_t v65 = VU64(lpop(&lbl_word));
			x60 = v65;
			VAL v66 = lpop(&lbl_key);
			x59 = v66;
			VAL r67 = pop_resource();
			x58 = r67;
		} break;
		case 0LL: { // None
			uint64_t v68 = VU64(lpop(&lbl_word));
			uint64_t v69 = mw_mirth_word_Word_head(v68);
			VAL v70 = MKI64(0LL /* None */);
			uint64_t v71 = mw_mirth_word_Word_body(v68);
			VAL v72 = lpop(&lbl_key);
			incref(v72);
			VAL r73 = pop_resource();
			VAL v74;
			uint64_t v75;
			mw_mirth_specializzer_SPKey_ZToName(r73, v72, &v74, &v75);
			int64_t v76 = 0LL;
			uint64_t v77;
			VAL v78;
			mw_mirth_word_Word_newZBang(v69, v70, v71, v75, v76, v74, &v77, &v78);
			VAL v79 = mtw_mirth_name_Namespace_NAMESPACEz_WORD(v68);
			incref(v72);
			VAL v80;
			uint64_t v81;
			mw_mirth_specializzer_SPKey_ZToName(v78, v72, &v80, &v81);
			VAL v82 = mw_mirth_name_QNAME0(v79, v81);
			VAL v83 = mtw_mirth_mirth_PropLabel_WordQName(v77);
			VAL v84;
			VAL v85;
			mw_mirth_mirth_PropLabel_prop(v82, v83, v80, &v84, &v85);
			void* v86 = mfld_mirth_word_Word_ZTildeqname(v77);
			mut_set(v84, v86);
			incref(v72);
			VAL v87 = mtw_std_map_KVPair_2_KVPair(v72, MKU64(v77));
			VAL v88 = mw_mirth_word_Word_spZ_synthed(v68);
			VAL v89 = mw_std_map_Map_2_insert(v87, v88);
			void* v90 = mfld_mirth_word_Word_ZTildespZ_synthed(v68);
			mut_set(v89, v90);
			incref(v72);
			VAL v91 = mtw_mirth_mirth_PropLabel_WordType(v77);
			VAL v92 = MKNIL;
			VAL v93 = mkcons(v92, v72);
			VAL v94 = mkcons(v93, MKU64(v68));
			FNPTR v95 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot63ZRParen_1;
			VAL v96;
			VAL v97;
			mw_mirth_mirth_PropLabel_prop_1(v94, v91, v85, MKFNPTR(v95), &v96, &v97);
			void* v98 = mfld_mirth_word_Word_ZTildectxZ_type(v77);
			mut_set(v96, v98);
			int64_t v99 = 1LL /* True */;
			void* v100 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(v77);
			mut_set(MKI64(v99), v100);
			incref(v72);
			VAL v101 = mtw_mirth_mirth_PropLabel_WordArrow(v77);
			VAL v102 = MKNIL;
			VAL v103 = mkcons(v102, v72);
			VAL v104 = mkcons(v103, MKU64(v68));
			VAL v105 = mkcons(v104, MKU64(v77));
			FNPTR v106 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot81ZRParen_1;
			VAL v107;
			VAL v108;
			mw_mirth_mirth_PropLabel_prop_1(v105, v101, v97, MKFNPTR(v106), &v107, &v108);
			void* v109 = mfld_mirth_word_Word_ZTildearrow(v77);
			mut_set(v107, v109);
			x61 = v77;
			x60 = v68;
			x59 = v72;
			x58 = v108;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	decref(x59);
	*x5 = x61;
	*x4 = x58;
}
static void mw_mirth_specializzer_specializzeZ_ctxZ_type (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6, VAL *x7) {
	decref(x3);
	VAL v8 = MKI64(0LL /* SUBST_NIL */);
	VAL v9;
	VAL v10;
	mw_mirth_type_ArrowType_freshen(v8, x4, &v9, &v10);
	decref(v9);
	incref(x2);
	VAL v11 = mw_std_list_ListZPlus_1_first(x2);
	uint64_t v12 = mw_mirth_arrow_Arg_token(VU64(v11));
	VAL v13 = MKI64(0LL /* SUBST_NIL */);
	decref(v13);
	VAL v14;
	VAL v15;
	mw_mirth_type_ArrowType_unpack(v10, &v14, &v15);
	VAL v16;
	VAL v17;
	mw_std_list_ListZPlus_1_uncons(x2, &v16, &v17);
	VAL v18 = mw_std_list_List_1_reverse(v17);
	VAL v19;
	VAL v20;
	mw_std_list_List_1_uncons(v18, &v19, &v20);
	VAL x21;
	uint64_t x22;
	VAL x23;
	VAL x24;
	VAL x25;
	int64_t x26;
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v27 = mtp_std_maybe_Maybe_1_Some(v19);
			VAL v28 = mw_mirth_type_StackType_forceZ_consZAskZBang(v14);
			VAL x29;
			uint64_t x30;
			VAL x31;
			VAL x32;
			switch (get_data_tag(v28)) {
				case 1LL: { // Some
					VAL v33 = mtp_std_maybe_Maybe_1_Some(v28);
					x32 = v33;
					x31 = v15;
					x30 = v12;
					x29 = x1;
				} break;
				case 0LL: { // None
					STR* v34;
					STRLIT(v34, "unexpected domain in specialize-ctx-type", 40);
					push_resource(x1);
					push_resource(MKU64(v12));
					push_value(v15);
					do_panic(v34);
					VAL v35 = pop_value();
					x32 = v35;
					VAL v36 = pop_value();
					x31 = v36;
					uint64_t r37 = VU64(pop_resource());
					x30 = r37;
					VAL r38 = pop_resource();
					x29 = r38;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v39;
			VAL v40;
			value_uncons(x32, &v39, &v40);
			VAL v41;
			VAL v42;
			value_uncons(v39, &v41, &v42);
			decref(v41);
			VAL v43 = mw_mirth_arrow_Block_type(VU64(v27));
			VAL v44 = mtw_mirth_type_Type_TMorphism(v43);
			VAL v45;
			uint64_t v46;
			VAL v47;
			mw_mirth_type_Type_unifyZBang(x29, x30, v40, v44, &v45, &v46, &v47);
			decref(v47);
			int64_t v48 = 1LL /* True */;
			x26 = v48;
			x25 = v20;
			x24 = v42;
			x23 = x31;
			x22 = v46;
			x21 = v45;
		} break;
		case 0LL: { // None
			int64_t v49 = 0LL /* False */;
			x26 = v49;
			x25 = v20;
			x24 = v14;
			x23 = v15;
			x22 = v12;
			x21 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v50 = (x21);
	uint64_t v51 = (x22);
	VAL v52 = x23;
	VAL v53 = x24;
	VAL v54 = x25;
	int64_t v55 = x26;
	while (((bool)v55)) {
		VAL v56 = (v50);
		uint64_t v57 = (v51);
		VAL v58 = v52;
		VAL v59 = v53;
		VAL v60 = v54;
		VAL v61;
		VAL v62;
		mw_std_list_List_1_uncons(v60, &v61, &v62);
		VAL x63;
		uint64_t x64;
		VAL x65;
		VAL x66;
		VAL x67;
		int64_t x68;
		switch (get_data_tag(v61)) {
			case 1LL: { // Some
				VAL v69 = mtp_std_maybe_Maybe_1_Some(v61);
				VAL v70 = mw_mirth_type_StackType_forceZ_consZAskZBang(v59);
				VAL x71;
				uint64_t x72;
				VAL x73;
				VAL x74;
				switch (get_data_tag(v70)) {
					case 1LL: { // Some
						VAL v75 = mtp_std_maybe_Maybe_1_Some(v70);
						x74 = v75;
						x73 = v58;
						x72 = v57;
						x71 = v56;
					} break;
					case 0LL: { // None
						STR* v76;
						STRLIT(v76, "unexpected domain in specialize-ctx-type", 40);
						push_resource(v56);
						push_resource(MKU64(v57));
						push_value(v58);
						do_panic(v76);
						VAL v77 = pop_value();
						x74 = v77;
						VAL v78 = pop_value();
						x73 = v78;
						uint64_t r79 = VU64(pop_resource());
						x72 = r79;
						VAL r80 = pop_resource();
						x71 = r80;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v81;
				VAL v82;
				value_uncons(x74, &v81, &v82);
				VAL v83;
				VAL v84;
				value_uncons(v81, &v83, &v84);
				decref(v83);
				VAL v85 = mw_mirth_arrow_Block_type(VU64(v69));
				VAL v86 = mtw_mirth_type_Type_TMorphism(v85);
				VAL v87;
				uint64_t v88;
				VAL v89;
				mw_mirth_type_Type_unifyZBang(x71, x72, v82, v86, &v87, &v88, &v89);
				decref(v89);
				int64_t v90 = 1LL /* True */;
				x68 = v90;
				x67 = v62;
				x66 = v84;
				x65 = x73;
				x64 = v88;
				x63 = v87;
			} break;
			case 0LL: { // None
				int64_t v91 = 0LL /* False */;
				x68 = v91;
				x67 = v62;
				x66 = v59;
				x65 = v58;
				x64 = v57;
				x63 = v56;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v55 = x68;
		v54 = x67;
		v53 = x66;
		v52 = x65;
		v51 = x64;
		v50 = x63;
	}
	decref(v54);
	VAL v92 = mw_mirth_type_StackType_forceZ_consZAskZBang(v53);
	VAL x93;
	uint64_t x94;
	VAL x95;
	VAL x96;
	switch (get_data_tag(v92)) {
		case 1LL: { // Some
			VAL v97 = mtp_std_maybe_Maybe_1_Some(v92);
			x96 = v97;
			x95 = v52;
			x94 = v51;
			x93 = v50;
		} break;
		case 0LL: { // None
			STR* v98;
			STRLIT(v98, "unexpected domain in specialize-ctx-type", 40);
			push_resource(v50);
			push_resource(MKU64(v51));
			push_value(v52);
			do_panic(v98);
			VAL v99 = pop_value();
			x96 = v99;
			VAL v100 = pop_value();
			x95 = v100;
			uint64_t r101 = VU64(pop_resource());
			x94 = r101;
			VAL r102 = pop_resource();
			x93 = r102;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v103;
	VAL v104;
	value_uncons(x96, &v103, &v104);
	VAL v105;
	VAL v106;
	value_uncons(v103, &v105, &v106);
	decref(v105);
	VAL v107 = mw_mirth_arrow_Block_type(VU64(v16));
	VAL v108 = mtw_mirth_type_Type_TMorphism(v107);
	VAL v109;
	uint64_t v110;
	VAL v111;
	mw_mirth_type_Type_unifyZBang(x93, x94, v104, v108, &v109, &v110, &v111);
	decref(v111);
	mw_mirth_type_ZPlusGamma_rdrop(v110);
	VAL v112 = mw_mirth_type_TZ_ZTo(v106, x95);
	VAL v113 = mw_mirth_var_Ctx0();
	VAL v114;
	VAL v115;
	VAL v116;
	mw_mirth_type_ArrowType_rigidifyZ_sigZBang(v109, v113, v112, &v114, &v115, &v116);
	*x7 = v116;
	*x6 = v115;
	*x5 = v114;
}
static void mw_mirth_specializzer_synthZ_specializzedZ_wordZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL *x5, VAL *x6) {
	VAL v7;
	VAL v8;
	mw_mirth_word_Word_arrow(x4, x1, &v7, &v8);
	VAL v9 = VVAL(VTUP(v7)->cells[7]);
	incref(v9);
	decref(v7);
	VAL v10 = mw_std_list_List_1_ZDivL1(v9);
	uint64_t x11;
	VAL x12;
	VAL x13;
	VAL x14;
	VAL x15;
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v10);
			x15 = v16;
			x14 = x2;
			x13 = v8;
			x12 = x3;
			x11 = x4;
		} break;
		case 0LL: { // None
			STR* v17;
			STRLIT(v17, "unexpected shape for synth-specialized-word!", 44);
			lpush(&lbl_spword, MKU64(x4));
			lpush(&lbl_spkey, x3);
			push_resource(v8);
			push_resource(x2);
			do_panic(v17);
			VAL v18 = pop_value();
			x15 = v18;
			VAL r19 = pop_resource();
			x14 = r19;
			VAL r20 = pop_resource();
			x13 = r20;
			VAL v21 = lpop(&lbl_spkey);
			x12 = v21;
			uint64_t v22 = VU64(lpop(&lbl_spword));
			x11 = v22;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v23 = VVAL(VTUP(x15)->cells[4]);
	incref(v23);
	decref(x15);
	VAL x24;
	VAL x25;
	switch (get_data_tag(v23)) {
		case 12LL: { // OpLambda
			VAL v26 = mtp_mirth_arrow_Op_OpLambda(v23);
			incref(v26);
			VAL v27 = VVAL(VTUP(v26)->cells[4]);
			incref(v27);
			decref(v26);
			incref(x12);
			VAL v28;
			VAL v29;
			mtp_std_list_ListZPlus_1_ListZPlus(x12, &v28, &v29);
			VAL v30 = mtw_std_list_List_1_Cons(v28, v29);
			incref(v27);
			int64_t v31 = mw_std_list_List_1_len(v27);
			incref(v30);
			int64_t v32 = mw_std_list_List_1_len(v30);
			bool v33 = (v31 == v32);
			uint64_t x34;
			VAL x35;
			VAL x36;
			VAL x37;
			VAL x38;
			VAL x39;
			VAL x40;
			if (v33) {
				x40 = v30;
				x39 = x12;
				x38 = v27;
				x37 = v26;
				x36 = x14;
				x35 = x13;
				x34 = x11;
			} else {
				STR* v41;
				STRLIT(v41, "wrong number of lambda params in synth-specialized-word!", 56);
				STR* v42;
				STRLIT(v42, "assertion failed: ", 18);
				STR* v43 = str_cat(v42, v41);
				lpush(&lbl_spword, MKU64(x11));
				push_resource(x13);
				push_resource(x14);
				push_value(v26);
				lpush(&lbl_spkey, x12);
				push_value(v27);
				push_value(v30);
				do_panic(v43);
				VAL v44 = pop_value();
				x40 = v44;
				VAL v45 = lpop(&lbl_spkey);
				x39 = v45;
				VAL v46 = pop_value();
				x38 = v46;
				VAL v47 = pop_value();
				x37 = v47;
				VAL r48 = pop_resource();
				x36 = r48;
				VAL r49 = pop_resource();
				x35 = r49;
				uint64_t v50 = VU64(lpop(&lbl_spword));
				x34 = v50;
			}
			VAL v51 = MKI64(0LL /* Nil */);
			VAL v52 = mw_std_list_List_1_reverse(v51);
			VAL v53;
			VAL v54;
			mw_std_list_List_1_uncons(x40, &v53, &v54);
			VAL v55;
			VAL v56;
			mw_std_list_List_1_uncons(x38, &v55, &v56);
			uint64_t x57;
			VAL x58;
			VAL x59;
			VAL x60;
			VAL x61;
			VAL x62;
			switch (get_data_tag(v53)) {
				case 0LL: { // None
					decref(v55);
					VAL v63 = MKI64(0LL /* None */);
					x62 = v63;
					x61 = x39;
					x60 = x37;
					x59 = x36;
					x58 = x35;
					x57 = x34;
				} break;
				case 1LL: { // Some
					VAL v64 = mtp_std_maybe_Maybe_1_Some(v53);
					uint64_t x65;
					VAL x66;
					VAL x67;
					VAL x68;
					VAL x69;
					VAL x70;
					switch (get_data_tag(v55)) {
						case 0LL: { // None
							decref(v64);
							VAL v71 = MKI64(0LL /* None */);
							x70 = v71;
							x69 = x39;
							x68 = x37;
							x67 = x36;
							x66 = x35;
							x65 = x34;
						} break;
						case 1LL: { // Some
							VAL v72 = mtp_std_maybe_Maybe_1_Some(v55);
							VAL v73 = mtw_std_map_KVPair_2_KVPair(v72, v64);
							VAL v74 = mtw_std_maybe_Maybe_1_Some(v73);
							x70 = v74;
							x69 = x39;
							x68 = x37;
							x67 = x36;
							x66 = x35;
							x65 = x34;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x62 = x70;
					x61 = x69;
					x60 = x68;
					x59 = x67;
					x58 = x66;
					x57 = x65;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t x75;
			VAL x76;
			VAL x77;
			VAL x78;
			VAL x79;
			VAL x80;
			VAL x81;
			VAL x82;
			int64_t x83;
			switch (get_data_tag(x62)) {
				case 1LL: { // Some
					VAL v84 = mtp_std_maybe_Maybe_1_Some(x62);
					VAL v85 = mtw_std_list_List_1_Cons(v84, v52);
					int64_t v86 = 1LL /* True */;
					x83 = v86;
					x82 = v85;
					x81 = v54;
					x80 = v56;
					x79 = x61;
					x78 = x60;
					x77 = x59;
					x76 = x58;
					x75 = x57;
				} break;
				case 0LL: { // None
					int64_t v87 = 0LL /* False */;
					x83 = v87;
					x82 = v52;
					x81 = v54;
					x80 = v56;
					x79 = x61;
					x78 = x60;
					x77 = x59;
					x76 = x58;
					x75 = x57;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v88 = x75;
			VAL v89 = (x76);
			VAL v90 = (x77);
			VAL v91 = x78;
			VAL v92 = x79;
			VAL v93 = x80;
			VAL v94 = x81;
			VAL v95 = (x82);
			int64_t v96 = x83;
			while (((bool)v96)) {
				uint64_t v97 = v88;
				VAL v98 = (v89);
				VAL v99 = (v90);
				VAL v100 = v91;
				VAL v101 = v92;
				VAL v102 = v93;
				VAL v103 = v94;
				VAL v104 = (v95);
				VAL v105;
				VAL v106;
				mw_std_list_List_1_uncons(v103, &v105, &v106);
				VAL v107;
				VAL v108;
				mw_std_list_List_1_uncons(v102, &v107, &v108);
				uint64_t x109;
				VAL x110;
				VAL x111;
				VAL x112;
				VAL x113;
				VAL x114;
				switch (get_data_tag(v105)) {
					case 0LL: { // None
						decref(v107);
						VAL v115 = MKI64(0LL /* None */);
						x114 = v115;
						x113 = v101;
						x112 = v100;
						x111 = v99;
						x110 = v98;
						x109 = v97;
					} break;
					case 1LL: { // Some
						VAL v116 = mtp_std_maybe_Maybe_1_Some(v105);
						uint64_t x117;
						VAL x118;
						VAL x119;
						VAL x120;
						VAL x121;
						VAL x122;
						switch (get_data_tag(v107)) {
							case 0LL: { // None
								decref(v116);
								VAL v123 = MKI64(0LL /* None */);
								x122 = v123;
								x121 = v101;
								x120 = v100;
								x119 = v99;
								x118 = v98;
								x117 = v97;
							} break;
							case 1LL: { // Some
								VAL v124 = mtp_std_maybe_Maybe_1_Some(v107);
								VAL v125 = mtw_std_map_KVPair_2_KVPair(v124, v116);
								VAL v126 = mtw_std_maybe_Maybe_1_Some(v125);
								x122 = v126;
								x121 = v101;
								x120 = v100;
								x119 = v99;
								x118 = v98;
								x117 = v97;
							} break;
							default: {
								do_panic(str_make("unexpected fallthrough in match\n", 32));
							}
						}
						x114 = x122;
						x113 = x121;
						x112 = x120;
						x111 = x119;
						x110 = x118;
						x109 = x117;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				uint64_t x127;
				VAL x128;
				VAL x129;
				VAL x130;
				VAL x131;
				VAL x132;
				VAL x133;
				VAL x134;
				int64_t x135;
				switch (get_data_tag(x114)) {
					case 1LL: { // Some
						VAL v136 = mtp_std_maybe_Maybe_1_Some(x114);
						VAL v137 = mtw_std_list_List_1_Cons(v136, v104);
						int64_t v138 = 1LL /* True */;
						x135 = v138;
						x134 = v137;
						x133 = v106;
						x132 = v108;
						x131 = x113;
						x130 = x112;
						x129 = x111;
						x128 = x110;
						x127 = x109;
					} break;
					case 0LL: { // None
						int64_t v139 = 0LL /* False */;
						x135 = v139;
						x134 = v104;
						x133 = v106;
						x132 = v108;
						x131 = x113;
						x130 = x112;
						x129 = x111;
						x128 = x110;
						x127 = x109;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v96 = x135;
				v95 = x134;
				v94 = x133;
				v93 = x132;
				v92 = x131;
				v91 = x130;
				v90 = x129;
				v89 = x128;
				v88 = x127;
			}
			VAL v140 = mw_std_list_List_1_reverse(v95);
			decref(v94);
			decref(v93);
			VAL v141 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v92, v88, v140, v90));
			VAL v142 = VVAL(VTUP(v91)->cells[5]);
			incref(v142);
			decref(v91);
			VAL v143;
			VAL v144;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(v89, v141, v142, &v143, &v144);
			VAL v145;
			uint64_t v146;
			VAL v147;
			VAL v148;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v144, &v145, &v146, &v147, &v148);
			decref(v147);
			decref(v145);
			x25 = v148;
			x24 = v143;
		} break;
		default: {
			STR* v149;
			STRLIT(v149, "unexpected shape", 16);
			lpush(&lbl_spword, MKU64(x11));
			lpush(&lbl_spkey, x12);
			push_resource(x13);
			push_resource(x14);
			push_value(v23);
			do_panic(v149);
			VAL r150 = pop_resource();
			x25 = r150;
			VAL r151 = pop_resource();
			x24 = r151;
		} break;
	}
	*x6 = x25;
	*x5 = x24;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x3)->cells[7]);
	incref(v6);
	decref(x3);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14;
			VAL v15;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang(x1, x2, v13, &v14, &v15);
			int64_t v16 = 1LL /* True */;
			x12 = v16;
			x11 = v8;
			x10 = v15;
			x9 = v14;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x12 = v17;
			x11 = v8;
			x10 = x2;
			x9 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x9);
	VAL v19 = (x10);
	VAL v20 = x11;
	int64_t v21 = x12;
	while (((bool)v21)) {
		VAL v22 = (v18);
		VAL v23 = (v19);
		VAL v24 = v20;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
				VAL v32;
				VAL v33;
				mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang(v22, v23, v31, &v32, &v33);
				int64_t v34 = 1LL /* True */;
				x30 = v34;
				x29 = v26;
				x28 = v33;
				x27 = v32;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x30 = v35;
				x29 = v26;
				x28 = v23;
				x27 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x30;
		v20 = x29;
		v19 = x28;
		v18 = x27;
	}
	decref(v20);
	*x5 = v19;
	*x4 = v18;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x3);
	uint64_t v6 = VU64(VTUP(x3)->cells[2]);
	decref(x3);
	VAL v7;
	uint64_t v8;
	VAL v9;
	VAL v10;
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2, &v7, &v8, &v9, &v10);
	VAL v11 = (mw_mirth_elab_abZ_tokenZBang(v10, v6));
	VAL v12 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v7, v8, v9, v11));
	incref(x3);
	VAL v13 = VVAL(VTUP(x3)->cells[5]);
	incref(v13);
	decref(x3);
	VAL v14;
	VAL v15;
	mw_std_list_List_1_uncons(v13, &v14, &v15);
	VAL x16;
	VAL x17;
	VAL x18;
	VAL x19;
	int64_t x20;
	switch (get_data_tag(v14)) {
		case 1LL: { // Some
			VAL v21 = mtp_std_maybe_Maybe_1_Some(v14);
			VAL v22;
			VAL v23;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang(x1, v12, VU64(v21), &v22, &v23);
			int64_t v24 = 1LL /* True */;
			x20 = v24;
			x19 = v15;
			x18 = x3;
			x17 = v23;
			x16 = v22;
		} break;
		case 0LL: { // None
			int64_t v25 = 0LL /* False */;
			x20 = v25;
			x19 = v15;
			x18 = x3;
			x17 = v12;
			x16 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v26 = (x16);
	VAL v27 = (x17);
	VAL v28 = x18;
	VAL v29 = x19;
	int64_t v30 = x20;
	while (((bool)v30)) {
		VAL v31 = (v26);
		VAL v32 = (v27);
		VAL v33 = v28;
		VAL v34 = v29;
		VAL v35;
		VAL v36;
		mw_std_list_List_1_uncons(v34, &v35, &v36);
		VAL x37;
		VAL x38;
		VAL x39;
		VAL x40;
		int64_t x41;
		switch (get_data_tag(v35)) {
			case 1LL: { // Some
				VAL v42 = mtp_std_maybe_Maybe_1_Some(v35);
				VAL v43;
				VAL v44;
				mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang(v31, v32, VU64(v42), &v43, &v44);
				int64_t v45 = 1LL /* True */;
				x41 = v45;
				x40 = v36;
				x39 = v33;
				x38 = v44;
				x37 = v43;
			} break;
			case 0LL: { // None
				int64_t v46 = 0LL /* False */;
				x41 = v46;
				x40 = v36;
				x39 = v33;
				x38 = v32;
				x37 = v31;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v30 = x41;
		v29 = x40;
		v28 = x39;
		v27 = x38;
		v26 = x37;
	}
	decref(v29);
	VAL v47 = VVAL(VTUP(v28)->cells[4]);
	incref(v47);
	decref(v28);
	VAL v48;
	VAL v49;
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang(v26, v27, v47, &v48, &v49);
	*x5 = v49;
	*x4 = v48;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang(x1, x2, x3, &v6, &v7);
	*x5 = v7;
	*x4 = v6;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL x6;
	VAL x7;
	switch (get_data_tag(x3)) {
		case 11LL: { // OpMatch
			VAL v8 = mtp_mirth_arrow_Op_OpMatch(x3);
			VAL v9;
			VAL v10;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang(x1, x2, v8, &v9, &v10);
			x7 = v10;
			x6 = v9;
		} break;
		case 12LL: { // OpLambda
			VAL v11 = mtp_mirth_arrow_Op_OpLambda(x3);
			VAL v12;
			VAL v13;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang(x1, x2, v11, &v12, &v13);
			x7 = v13;
			x6 = v12;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v14 = mtp_mirth_arrow_Op_OpBlockPush(x3);
			VAL v15;
			VAL v16;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang(x1, x2, v14, &v15, &v16);
			x7 = v16;
			x6 = v15;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v17 = mtp_mirth_arrow_Op_OpBlockRun(x3);
			VAL v18;
			VAL v19;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang(x1, x2, v17, &v18, &v19);
			x7 = v19;
			x6 = v18;
		} break;
		case 13LL: { // OpVar
			uint64_t v20 = mtp_mirth_arrow_Op_OpVar(x3);
			VAL v21;
			VAL v22;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang(x1, x2, v20, &v21, &v22);
			x7 = v22;
			x6 = v21;
		} break;
		default: {
			VAL v23;
			uint64_t v24;
			VAL v25;
			VAL v26;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2, &v23, &v24, &v25, &v26);
			VAL v27;
			VAL v28;
			mw_mirth_elab_abZ_opZBang(x3, x1, v26, &v27, &v28);
			VAL v29 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v23, v24, v25, v28));
			x7 = v29;
			x6 = v27;
		} break;
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_arrow_Block_toZ_runZ_var(x1, x3, &v6, &v7);
	uint64_t x8;
	VAL x9;
	VAL x10;
	VAL x11;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v13 = VVAL(VTUP(x2)->cells[4]);
			incref(v13);
			VAL v14 = MKI64(0LL /* None */);
			VAL v15;
			VAL v16;
			mw_std_list_List_1_uncons(v13, &v15, &v16);
			uint64_t x17;
			VAL x18;
			VAL x19;
			int64_t x20;
			switch (get_data_tag(v15)) {
				case 1LL: { // Some
					VAL v21 = mtp_std_maybe_Maybe_1_Some(v15);
					incref(v21);
					incref(v12);
					VAL v22 = VVAL(VTUP(v21)->cells[1]);
					incref(v22);
					decref(v21);
					int64_t v23 = mw_mirth_var_Var_ZEqualZEqual(VU64(v12), VU64(v22));
					uint64_t x24;
					VAL x25;
					if (((bool)v23)) {
						VAL v26 = mtw_std_maybe_Maybe_1_Some(v21);
						x25 = v26;
						x24 = VU64(v12);
						push_u64(x3);
						push_resource(v6);
						push_resource(x2);
					} else {
						decref(v21);
						VAL v27 = MKI64(0LL /* None */);
						x25 = v27;
						x24 = VU64(v12);
						push_u64(x3);
						push_resource(v6);
						push_resource(x2);
					}
					uint64_t x28;
					VAL x29;
					VAL x30;
					switch (get_data_tag(x25)) {
						case 0LL: { // None
							x30 = v16;
							x29 = v14;
							x28 = x24;
						} break;
						default: {
							decref(v16);
							decref(v14);
							VAL v31 = MKI64(0LL /* Nil */);
							x30 = v31;
							x29 = x25;
							x28 = x24;
						} break;
					}
					int64_t v32 = 1LL /* True */;
					x20 = v32;
					x19 = x30;
					x18 = x29;
					x17 = x28;
				} break;
				case 0LL: { // None
					int64_t v33 = 0LL /* False */;
					x20 = v33;
					x19 = v16;
					x18 = v14;
					x17 = VU64(v12);
					push_u64(x3);
					push_resource(v6);
					push_resource(x2);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t v34 = x17;
			VAL v35 = x18;
			VAL v36 = x19;
			int64_t v37 = x20;
			while (((bool)v37)) {
				uint64_t v38 = v34;
				VAL v39 = v35;
				VAL v40 = v36;
				VAL v41;
				VAL v42;
				mw_std_list_List_1_uncons(v40, &v41, &v42);
				uint64_t x43;
				VAL x44;
				VAL x45;
				int64_t x46;
				switch (get_data_tag(v41)) {
					case 1LL: { // Some
						VAL v47 = mtp_std_maybe_Maybe_1_Some(v41);
						incref(v47);
						VAL v48 = VVAL(VTUP(v47)->cells[1]);
						incref(v48);
						decref(v47);
						int64_t v49 = mw_mirth_var_Var_ZEqualZEqual(v38, VU64(v48));
						uint64_t x50;
						VAL x51;
						if (((bool)v49)) {
							VAL v52 = mtw_std_maybe_Maybe_1_Some(v47);
							x51 = v52;
							x50 = v38;
						} else {
							decref(v47);
							VAL v53 = MKI64(0LL /* None */);
							x51 = v53;
							x50 = v38;
						}
						uint64_t x54;
						VAL x55;
						VAL x56;
						switch (get_data_tag(x51)) {
							case 0LL: { // None
								x56 = v42;
								x55 = v39;
								x54 = x50;
							} break;
							default: {
								decref(v42);
								decref(v39);
								VAL v57 = MKI64(0LL /* Nil */);
								x56 = v57;
								x55 = x51;
								x54 = x50;
							} break;
						}
						int64_t v58 = 1LL /* True */;
						x46 = v58;
						x45 = x56;
						x44 = x55;
						x43 = x54;
					} break;
					case 0LL: { // None
						int64_t v59 = 0LL /* False */;
						x46 = v59;
						x45 = v42;
						x44 = v39;
						x43 = v38;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v37 = x46;
				v36 = x45;
				v35 = x44;
				v34 = x43;
			}
			decref(v36);
			VAL x60;
			switch (get_data_tag(v35)) {
				case 1LL: { // Some
					VAL v61 = mtp_std_maybe_Maybe_1_Some(v35);
					VAL v62 = VVAL(VTUP(v61)->cells[2]);
					incref(v62);
					decref(v61);
					VAL v63 = mtw_std_maybe_Maybe_1_Some(v62);
					x60 = v63;
				} break;
				case 0LL: { // None
					VAL v64 = MKI64(0LL /* None */);
					x60 = v64;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x11 = x60;
			VAL r65 = pop_resource();
			x10 = r65;
			VAL r66 = pop_resource();
			x9 = r66;
			uint64_t v67 = pop_u64();
			x8 = v67;
		} break;
		case 0LL: { // None
			VAL v68 = MKI64(0LL /* None */);
			x11 = v68;
			x10 = x2;
			x9 = v6;
			x8 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x69;
	VAL x70;
	switch (get_data_tag(x11)) {
		case 0LL: { // None
			VAL v71;
			uint64_t v72;
			VAL v73;
			VAL v74;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x10, &v71, &v72, &v73, &v74);
			VAL v75;
			uint64_t v76;
			mw_mirth_elab_abZ_tokenZAt(v74, &v75, &v76);
			VAL v77;
			VAL v78;
			mw_mirth_elab_abZ_ctxZAt(v75, &v77, &v78);
			uint64_t v79 = mw_mirth_type_MetaVar_newZBang();
			VAL v80 = mtw_mirth_type_StackType_STMeta(v79);
			VAL v81;
			VAL v82;
			mw_mirth_elab_abZ_homeZAt(v77, &v81, &v82);
			incref(v80);
			VAL v83 = MKI64(0LL /* Nil */);
			VAL v84 = mtw_mirth_arrow_Arrow_Arrow(v82, v76, v76, v78, v80, v80, v83);
			VAL v85 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v71, v72, v73, v84));
			VAL v86;
			VAL v87;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang(x9, v85, x8, &v86, &v87);
			VAL v88;
			uint64_t v89;
			VAL v90;
			VAL v91;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v87, &v88, &v89, &v90, &v91);
			VAL v92;
			uint64_t v93;
			mw_mirth_arrow_Block_newZBang(v86, v91, &v92, &v93);
			VAL v94 = mtw_mirth_arrow_Op_OpBlockPush(v93);
			VAL v95;
			VAL v96;
			mw_mirth_elab_abZ_opZBang(v94, v92, v81, &v95, &v96);
			VAL v97 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v88, v89, v90, v96));
			x70 = v97;
			x69 = v95;
		} break;
		case 1LL: { // Some
			VAL v98 = mtp_std_maybe_Maybe_1_Some(x11);
			VAL v99 = mtw_mirth_arrow_Op_OpBlockPush(VU64(v98));
			VAL v100;
			uint64_t v101;
			VAL v102;
			VAL v103;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x10, &v100, &v101, &v102, &v103);
			VAL v104;
			VAL v105;
			mw_mirth_elab_abZ_opZBang(v99, x9, v103, &v104, &v105);
			VAL v106 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v100, v101, v102, v105));
			x70 = v106;
			x69 = v104;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x70;
	*x4 = x69;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_arrow_Block_arrow(x1, x3, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(v6, x2, v7, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang (VAL x1, VAL x2, uint64_t x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x2)->cells[4]);
	incref(v6);
	VAL v7 = MKI64(0LL /* None */);
	VAL v8;
	VAL v9;
	mw_std_list_List_1_uncons(v6, &v8, &v9);
	uint64_t x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v8);
			incref(v14);
			VAL v15 = VVAL(VTUP(v14)->cells[1]);
			incref(v15);
			decref(v14);
			int64_t v16 = mw_mirth_var_Var_ZEqualZEqual(x3, VU64(v15));
			uint64_t x17;
			VAL x18;
			if (((bool)v16)) {
				VAL v19 = mtw_std_maybe_Maybe_1_Some(v14);
				x18 = v19;
				x17 = x3;
				push_resource(x1);
				push_u64(x3);
				push_resource(x2);
			} else {
				decref(v14);
				VAL v20 = MKI64(0LL /* None */);
				x18 = v20;
				x17 = x3;
				push_resource(x1);
				push_u64(x3);
				push_resource(x2);
			}
			uint64_t x21;
			VAL x22;
			VAL x23;
			switch (get_data_tag(x18)) {
				case 0LL: { // None
					x23 = v9;
					x22 = v7;
					x21 = x17;
				} break;
				default: {
					decref(v9);
					decref(v7);
					VAL v24 = MKI64(0LL /* Nil */);
					x23 = v24;
					x22 = x18;
					x21 = x17;
				} break;
			}
			int64_t v25 = 1LL /* True */;
			x13 = v25;
			x12 = x23;
			x11 = x22;
			x10 = x21;
		} break;
		case 0LL: { // None
			int64_t v26 = 0LL /* False */;
			x13 = v26;
			x12 = v9;
			x11 = v7;
			x10 = x3;
			push_resource(x1);
			push_u64(x3);
			push_resource(x2);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v27 = x10;
	VAL v28 = x11;
	VAL v29 = x12;
	int64_t v30 = x13;
	while (((bool)v30)) {
		uint64_t v31 = v27;
		VAL v32 = v28;
		VAL v33 = v29;
		VAL v34;
		VAL v35;
		mw_std_list_List_1_uncons(v33, &v34, &v35);
		uint64_t x36;
		VAL x37;
		VAL x38;
		int64_t x39;
		switch (get_data_tag(v34)) {
			case 1LL: { // Some
				VAL v40 = mtp_std_maybe_Maybe_1_Some(v34);
				incref(v40);
				VAL v41 = VVAL(VTUP(v40)->cells[1]);
				incref(v41);
				decref(v40);
				int64_t v42 = mw_mirth_var_Var_ZEqualZEqual(v31, VU64(v41));
				uint64_t x43;
				VAL x44;
				if (((bool)v42)) {
					VAL v45 = mtw_std_maybe_Maybe_1_Some(v40);
					x44 = v45;
					x43 = v31;
				} else {
					decref(v40);
					VAL v46 = MKI64(0LL /* None */);
					x44 = v46;
					x43 = v31;
				}
				uint64_t x47;
				VAL x48;
				VAL x49;
				switch (get_data_tag(x44)) {
					case 0LL: { // None
						x49 = v35;
						x48 = v32;
						x47 = x43;
					} break;
					default: {
						decref(v35);
						decref(v32);
						VAL v50 = MKI64(0LL /* Nil */);
						x49 = v50;
						x48 = x44;
						x47 = x43;
					} break;
				}
				int64_t v51 = 1LL /* True */;
				x39 = v51;
				x38 = x49;
				x37 = x48;
				x36 = x47;
			} break;
			case 0LL: { // None
				int64_t v52 = 0LL /* False */;
				x39 = v52;
				x38 = v35;
				x37 = v32;
				x36 = v31;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v30 = x39;
		v29 = x38;
		v28 = x37;
		v27 = x36;
	}
	decref(v29);
	VAL x53;
	switch (get_data_tag(v28)) {
		case 1LL: { // Some
			VAL v54 = mtp_std_maybe_Maybe_1_Some(v28);
			VAL v55 = VVAL(VTUP(v54)->cells[2]);
			incref(v55);
			decref(v54);
			VAL v56 = mtw_std_maybe_Maybe_1_Some(v55);
			x53 = v56;
		} break;
		case 0LL: { // None
			VAL v57 = MKI64(0LL /* None */);
			x53 = v57;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL x58;
	VAL x59;
	switch (get_data_tag(x53)) {
		case 1LL: { // Some
			VAL v60 = mtp_std_maybe_Maybe_1_Some(x53);
			VAL v61 = pop_value();
			decref(v61);
			VAL v62 = mtw_mirth_arrow_Op_OpBlockRun(VU64(v60));
			VAL r63 = pop_resource();
			VAL v64;
			uint64_t v65;
			VAL v66;
			VAL v67;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r63, &v64, &v65, &v66, &v67);
			VAL r68 = pop_resource();
			VAL v69;
			VAL v70;
			mw_mirth_elab_abZ_opZBang(v62, r68, v67, &v69, &v70);
			VAL v71 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v64, v65, v66, v70));
			x59 = v71;
			x58 = v69;
		} break;
		case 0LL: { // None
			VAL r72 = pop_resource();
			VAL v73;
			uint64_t v74;
			VAL v75;
			VAL v76;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r72, &v73, &v74, &v75, &v76);
			VAL r77 = pop_resource();
			uint64_t v78 = pop_u64();
			VAL v79;
			VAL v80;
			mw_mirth_elab_abZ_varZBang(v78, r77, v76, &v79, &v80);
			VAL v81 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v73, v74, v75, v80));
			x59 = v81;
			x58 = v79;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x59;
	*x4 = x58;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	uint64_t v6 = mw_mirth_type_MetaVar_newZBang();
	VAL v7 = mtw_mirth_type_StackType_STMeta(v6);
	incref(x3);
	uint64_t v8 = VU64(VTUP(x3)->cells[3]);
	decref(x3);
	VAL v9 = VVAL(VTUP(x3)->cells[7]);
	incref(v9);
	decref(x3);
	VAL v10;
	uint64_t v11;
	VAL v12;
	VAL v13;
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2, &v10, &v11, &v12, &v13);
	VAL v14;
	VAL v15;
	mw_mirth_elab_abZ_ctxZAt(v13, &v14, &v15);
	VAL v16;
	VAL v17;
	mw_mirth_elab_abZ_typeZAt(v14, &v16, &v17);
	VAL v18;
	uint64_t v19;
	mw_mirth_elab_abZ_tokenZAt(v16, &v18, &v19);
	VAL v20;
	VAL v21;
	mw_mirth_elab_abZ_homeZAt(v18, &v20, &v21);
	VAL v22 = MKI64(0LL /* Nil */);
	VAL v23 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v21, v19, v8, v15, v17, v7, v22));
	VAL v24;
	VAL v25;
	mw_std_list_List_1_uncons(v9, &v24, &v25);
	VAL x26;
	uint64_t x27;
	VAL x28;
	VAL x29;
	VAL x30;
	VAL x31;
	int64_t x32;
	switch (get_data_tag(v24)) {
		case 1LL: { // Some
			VAL v33 = mtp_std_maybe_Maybe_1_Some(v24);
			incref(v33);
			VAL v34 = VVAL(VTUP(v33)->cells[1]);
			incref(v34);
			decref(v33);
			uint64_t v35 = VU64(VTUP(v34)->cells[2]);
			decref(v34);
			incref(v33);
			VAL v36 = VVAL(VTUP(v33)->cells[2]);
			incref(v36);
			decref(v33);
			uint64_t v37 = VU64(VTUP(v36)->cells[2]);
			decref(v36);
			VAL v38 = VVAL(VTUP(v23)->cells[1]);
			incref(v38);
			VAL v39 = VVAL(VTUP(v23)->cells[4]);
			incref(v39);
			incref(v39);
			VAL v40 = MKI64(0LL /* Nil */);
			VAL v41 = VVAL(VTUP(v23)->cells[5]);
			incref(v41);
			incref(v41);
			VAL v42 = MKI64(0LL /* Nil */);
			VAL v43 = mtw_mirth_match_Pattern_Pattern(v38, v35, v35, v39, v39, v40, v41, v41, v42);
			VAL v44 = (mw_mirth_match_Pattern_thaw(v43));
			incref(v33);
			VAL v45 = VVAL(VTUP(v33)->cells[1]);
			incref(v45);
			decref(v33);
			VAL v46 = VVAL(VTUP(v45)->cells[9]);
			incref(v46);
			decref(v45);
			VAL v47 = mw_std_list_List_1_reverse(v46);
			VAL v48;
			VAL v49;
			mw_std_list_List_1_uncons(v47, &v48, &v49);
			VAL x50;
			uint64_t x51;
			VAL x52;
			VAL x53;
			VAL x54;
			VAL x55;
			VAL x56;
			int64_t x57;
			switch (get_data_tag(v48)) {
				case 1LL: { // Some
					VAL v58 = mtp_std_maybe_Maybe_1_Some(v48);
					VAL v59 = VVAL(VTUP(v58)->cells[7]);
					incref(v59);
					decref(v58);
					VAL v60;
					VAL v61;
					mw_mirth_match_ZPlusPattern_opZBang(v59, x1, v44, &v60, &v61);
					int64_t v62 = 1LL /* True */;
					x57 = v62;
					x56 = v49;
					x55 = v33;
					x54 = v61;
					x53 = v60;
					x52 = v12;
					x51 = v11;
					x50 = v10;
				} break;
				case 0LL: { // None
					int64_t v63 = 0LL /* False */;
					x57 = v63;
					x56 = v49;
					x55 = v33;
					x54 = v44;
					x53 = x1;
					x52 = v12;
					x51 = v11;
					x50 = v10;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v64 = x50;
			uint64_t v65 = x51;
			VAL v66 = x52;
			VAL v67 = (x53);
			VAL v68 = (x54);
			VAL v69 = x55;
			VAL v70 = x56;
			int64_t v71 = x57;
			while (((bool)v71)) {
				VAL v72 = v64;
				uint64_t v73 = v65;
				VAL v74 = v66;
				VAL v75 = (v67);
				VAL v76 = (v68);
				VAL v77 = v69;
				VAL v78 = v70;
				VAL v79;
				VAL v80;
				mw_std_list_List_1_uncons(v78, &v79, &v80);
				VAL x81;
				uint64_t x82;
				VAL x83;
				VAL x84;
				VAL x85;
				VAL x86;
				VAL x87;
				int64_t x88;
				switch (get_data_tag(v79)) {
					case 1LL: { // Some
						VAL v89 = mtp_std_maybe_Maybe_1_Some(v79);
						VAL v90 = VVAL(VTUP(v89)->cells[7]);
						incref(v90);
						decref(v89);
						VAL v91;
						VAL v92;
						mw_mirth_match_ZPlusPattern_opZBang(v90, v75, v76, &v91, &v92);
						int64_t v93 = 1LL /* True */;
						x88 = v93;
						x87 = v80;
						x86 = v77;
						x85 = v92;
						x84 = v91;
						x83 = v74;
						x82 = v73;
						x81 = v72;
					} break;
					case 0LL: { // None
						int64_t v94 = 0LL /* False */;
						x88 = v94;
						x87 = v80;
						x86 = v77;
						x85 = v76;
						x84 = v75;
						x83 = v74;
						x82 = v73;
						x81 = v72;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v71 = x88;
				v70 = x87;
				v69 = x86;
				v68 = x85;
				v67 = x84;
				v66 = x83;
				v65 = x82;
				v64 = x81;
			}
			decref(v70);
			VAL v95 = mw_mirth_match_ZPlusPattern_freezze(v68);
			incref(v95);
			VAL v96 = VVAL(VTUP(v95)->cells[5]);
			incref(v96);
			decref(v95);
			incref(v95);
			VAL v97 = mw_mirth_match_Pattern_dom(v95);
			VAL v98 = VVAL(VTUP(v23)->cells[6]);
			incref(v98);
			VAL v99 = mw_mirth_type_TZ_ZTo(v97, v98);
			VAL v100 = VVAL(VTUP(v23)->cells[1]);
			incref(v100);
			VAL v101;
			VAL v102;
			mw_mirth_type_ArrowType_unpack(v99, &v101, &v102);
			incref(v101);
			VAL v103 = MKI64(0LL /* Nil */);
			VAL v104 = mtw_mirth_arrow_Arrow_Arrow(v100, v37, v37, v96, v101, v101, v103);
			VAL v105 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v64, v65, v66, v104));
			VAL v106 = VVAL(VTUP(v69)->cells[2]);
			incref(v106);
			decref(v69);
			VAL v107;
			VAL v108;
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(v67, v105, v106, &v107, &v108);
			VAL v109;
			uint64_t v110;
			VAL v111;
			VAL v112;
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v108, &v109, &v110, &v111, &v112);
			VAL v113;
			VAL v114;
			mw_mirth_elab_abZ_unifyZ_typeZBang(v102, v107, v112, &v113, &v114);
			VAL v115 = mtw_mirth_match_Case_CASE(v95, v114);
			VAL v116;
			VAL v117;
			mw_mirth_match_ZPlusMatch_addZ_case(v113, v23, v115, &v116, &v117);
			int64_t v118 = 1LL /* True */;
			x32 = v118;
			x31 = v25;
			x30 = v117;
			x29 = v116;
			x28 = v111;
			x27 = v110;
			x26 = v109;
		} break;
		case 0LL: { // None
			int64_t v119 = 0LL /* False */;
			x32 = v119;
			x31 = v25;
			x30 = v23;
			x29 = x1;
			x28 = v12;
			x27 = v11;
			x26 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v120 = x26;
	uint64_t v121 = x27;
	VAL v122 = x28;
	VAL v123 = (x29);
	VAL v124 = (x30);
	VAL v125 = x31;
	int64_t v126 = x32;
	while (((bool)v126)) {
		VAL v127 = v120;
		uint64_t v128 = v121;
		VAL v129 = v122;
		VAL v130 = (v123);
		VAL v131 = (v124);
		VAL v132 = v125;
		VAL v133;
		VAL v134;
		mw_std_list_List_1_uncons(v132, &v133, &v134);
		VAL x135;
		uint64_t x136;
		VAL x137;
		VAL x138;
		VAL x139;
		VAL x140;
		int64_t x141;
		switch (get_data_tag(v133)) {
			case 1LL: { // Some
				VAL v142 = mtp_std_maybe_Maybe_1_Some(v133);
				incref(v142);
				VAL v143 = VVAL(VTUP(v142)->cells[1]);
				incref(v143);
				decref(v142);
				uint64_t v144 = VU64(VTUP(v143)->cells[2]);
				decref(v143);
				incref(v142);
				VAL v145 = VVAL(VTUP(v142)->cells[2]);
				incref(v145);
				decref(v142);
				uint64_t v146 = VU64(VTUP(v145)->cells[2]);
				decref(v145);
				VAL v147 = VVAL(VTUP(v131)->cells[1]);
				incref(v147);
				VAL v148 = VVAL(VTUP(v131)->cells[4]);
				incref(v148);
				incref(v148);
				VAL v149 = MKI64(0LL /* Nil */);
				VAL v150 = VVAL(VTUP(v131)->cells[5]);
				incref(v150);
				incref(v150);
				VAL v151 = MKI64(0LL /* Nil */);
				VAL v152 = mtw_mirth_match_Pattern_Pattern(v147, v144, v144, v148, v148, v149, v150, v150, v151);
				VAL v153 = (mw_mirth_match_Pattern_thaw(v152));
				incref(v142);
				VAL v154 = VVAL(VTUP(v142)->cells[1]);
				incref(v154);
				decref(v142);
				VAL v155 = VVAL(VTUP(v154)->cells[9]);
				incref(v155);
				decref(v154);
				VAL v156 = mw_std_list_List_1_reverse(v155);
				VAL v157;
				VAL v158;
				mw_std_list_List_1_uncons(v156, &v157, &v158);
				VAL x159;
				uint64_t x160;
				VAL x161;
				VAL x162;
				VAL x163;
				VAL x164;
				VAL x165;
				int64_t x166;
				switch (get_data_tag(v157)) {
					case 1LL: { // Some
						VAL v167 = mtp_std_maybe_Maybe_1_Some(v157);
						VAL v168 = VVAL(VTUP(v167)->cells[7]);
						incref(v168);
						decref(v167);
						VAL v169;
						VAL v170;
						mw_mirth_match_ZPlusPattern_opZBang(v168, v130, v153, &v169, &v170);
						int64_t v171 = 1LL /* True */;
						x166 = v171;
						x165 = v158;
						x164 = v142;
						x163 = v170;
						x162 = v169;
						x161 = v129;
						x160 = v128;
						x159 = v127;
					} break;
					case 0LL: { // None
						int64_t v172 = 0LL /* False */;
						x166 = v172;
						x165 = v158;
						x164 = v142;
						x163 = v153;
						x162 = v130;
						x161 = v129;
						x160 = v128;
						x159 = v127;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v173 = x159;
				uint64_t v174 = x160;
				VAL v175 = x161;
				VAL v176 = (x162);
				VAL v177 = (x163);
				VAL v178 = x164;
				VAL v179 = x165;
				int64_t v180 = x166;
				while (((bool)v180)) {
					VAL v181 = v173;
					uint64_t v182 = v174;
					VAL v183 = v175;
					VAL v184 = (v176);
					VAL v185 = (v177);
					VAL v186 = v178;
					VAL v187 = v179;
					VAL v188;
					VAL v189;
					mw_std_list_List_1_uncons(v187, &v188, &v189);
					VAL x190;
					uint64_t x191;
					VAL x192;
					VAL x193;
					VAL x194;
					VAL x195;
					VAL x196;
					int64_t x197;
					switch (get_data_tag(v188)) {
						case 1LL: { // Some
							VAL v198 = mtp_std_maybe_Maybe_1_Some(v188);
							VAL v199 = VVAL(VTUP(v198)->cells[7]);
							incref(v199);
							decref(v198);
							VAL v200;
							VAL v201;
							mw_mirth_match_ZPlusPattern_opZBang(v199, v184, v185, &v200, &v201);
							int64_t v202 = 1LL /* True */;
							x197 = v202;
							x196 = v189;
							x195 = v186;
							x194 = v201;
							x193 = v200;
							x192 = v183;
							x191 = v182;
							x190 = v181;
						} break;
						case 0LL: { // None
							int64_t v203 = 0LL /* False */;
							x197 = v203;
							x196 = v189;
							x195 = v186;
							x194 = v185;
							x193 = v184;
							x192 = v183;
							x191 = v182;
							x190 = v181;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v180 = x197;
					v179 = x196;
					v178 = x195;
					v177 = x194;
					v176 = x193;
					v175 = x192;
					v174 = x191;
					v173 = x190;
				}
				decref(v179);
				VAL v204 = mw_mirth_match_ZPlusPattern_freezze(v177);
				incref(v204);
				VAL v205 = VVAL(VTUP(v204)->cells[5]);
				incref(v205);
				decref(v204);
				incref(v204);
				VAL v206 = mw_mirth_match_Pattern_dom(v204);
				VAL v207 = VVAL(VTUP(v131)->cells[6]);
				incref(v207);
				VAL v208 = mw_mirth_type_TZ_ZTo(v206, v207);
				VAL v209 = VVAL(VTUP(v131)->cells[1]);
				incref(v209);
				VAL v210;
				VAL v211;
				mw_mirth_type_ArrowType_unpack(v208, &v210, &v211);
				incref(v210);
				VAL v212 = MKI64(0LL /* Nil */);
				VAL v213 = mtw_mirth_arrow_Arrow_Arrow(v209, v146, v146, v205, v210, v210, v212);
				VAL v214 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v173, v174, v175, v213));
				VAL v215 = VVAL(VTUP(v178)->cells[2]);
				incref(v215);
				decref(v178);
				VAL v216;
				VAL v217;
				mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(v176, v214, v215, &v216, &v217);
				VAL v218;
				uint64_t v219;
				VAL v220;
				VAL v221;
				mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v217, &v218, &v219, &v220, &v221);
				VAL v222;
				VAL v223;
				mw_mirth_elab_abZ_unifyZ_typeZBang(v211, v216, v221, &v222, &v223);
				VAL v224 = mtw_mirth_match_Case_CASE(v204, v223);
				VAL v225;
				VAL v226;
				mw_mirth_match_ZPlusMatch_addZ_case(v222, v131, v224, &v225, &v226);
				int64_t v227 = 1LL /* True */;
				x141 = v227;
				x140 = v134;
				x139 = v226;
				x138 = v225;
				x137 = v220;
				x136 = v219;
				x135 = v218;
			} break;
			case 0LL: { // None
				int64_t v228 = 0LL /* False */;
				x141 = v228;
				x140 = v134;
				x139 = v131;
				x138 = v130;
				x137 = v129;
				x136 = v128;
				x135 = v127;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v126 = x141;
		v125 = x140;
		v124 = x139;
		v123 = x138;
		v122 = x137;
		v121 = x136;
		v120 = x135;
	}
	decref(v125);
	VAL v229 = mw_mirth_match_ZPlusMatch_freezze(v124);
	VAL v230 = mtw_mirth_arrow_Op_OpMatch(v229);
	VAL v231;
	VAL v232;
	mw_mirth_elab_abZ_opZBang(v230, v123, v20, &v231, &v232);
	VAL v233 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v120, v121, v122, v232));
	*x5 = v233;
	*x4 = v231;
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x3);
	VAL v6 = VVAL(VTUP(x3)->cells[4]);
	incref(v6);
	decref(x3);
	VAL v7;
	uint64_t v8;
	VAL v9;
	VAL v10;
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2, &v7, &v8, &v9, &v10);
	VAL v11;
	uint64_t v12;
	mw_mirth_elab_abZ_tokenZAt(v10, &v11, &v12);
	incref(v6);
	VAL v13;
	VAL v14;
	mw_mirth_elab_abZ_ctxZAt(v11, &v13, &v14);
	VAL v15;
	VAL v16;
	mw_mirth_elab_abZ_typeZAt(v13, &v15, &v16);
	VAL v17 = mw_std_list_List_1_reverse(v6);
	VAL v18;
	VAL v19;
	mw_std_list_List_1_uncons(v17, &v18, &v19);
	VAL x20;
	VAL x21;
	uint64_t x22;
	VAL x23;
	uint64_t x24;
	VAL x25;
	VAL x26;
	VAL x27;
	VAL x28;
	VAL x29;
	int64_t x30;
	switch (get_data_tag(v18)) {
		case 1LL: { // Some
			VAL v31 = mtp_std_maybe_Maybe_1_Some(v18);
			incref(v31);
			VAL v32 = mw_mirth_var_Ctx_new(v14, VU64(v31));
			VAL v33;
			uint64_t v34;
			mw_mirth_elab_abZ_tokenZAt(v15, &v33, &v34);
			VAL v35;
			VAL v36;
			VAL v37;
			uint64_t v38;
			mw_mirth_elab_elabZ_expandZ_tensorZBang(x1, v16, v34, &v35, &v36, &v37, &v38);
			VAL v39 = mw_mirth_var_Var_type(VU64(v31));
			VAL v40;
			VAL v41;
			uint64_t v42;
			mw_mirth_elab_elabZ_typeZ_unifyZBang(v35, v37, v39, v38, &v40, &v41, &v42);
			decref(v41);
			int64_t v43 = 1LL /* True */;
			x30 = v43;
			x29 = v19;
			x28 = v33;
			x27 = v40;
			x26 = v36;
			x25 = v32;
			x24 = v12;
			x23 = v9;
			x22 = v8;
			x21 = v7;
			x20 = x3;
		} break;
		case 0LL: { // None
			int64_t v44 = 0LL /* False */;
			x30 = v44;
			x29 = v19;
			x28 = v15;
			x27 = x1;
			x26 = v16;
			x25 = v14;
			x24 = v12;
			x23 = v9;
			x22 = v8;
			x21 = v7;
			x20 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v45 = x20;
	VAL v46 = x21;
	uint64_t v47 = x22;
	VAL v48 = x23;
	uint64_t v49 = x24;
	VAL v50 = x25;
	VAL v51 = x26;
	VAL v52 = (x27);
	VAL v53 = (x28);
	VAL v54 = x29;
	int64_t v55 = x30;
	while (((bool)v55)) {
		VAL v56 = v45;
		VAL v57 = v46;
		uint64_t v58 = v47;
		VAL v59 = v48;
		uint64_t v60 = v49;
		VAL v61 = v50;
		VAL v62 = v51;
		VAL v63 = (v52);
		VAL v64 = (v53);
		VAL v65 = v54;
		VAL v66;
		VAL v67;
		mw_std_list_List_1_uncons(v65, &v66, &v67);
		VAL x68;
		VAL x69;
		uint64_t x70;
		VAL x71;
		uint64_t x72;
		VAL x73;
		VAL x74;
		VAL x75;
		VAL x76;
		VAL x77;
		int64_t x78;
		switch (get_data_tag(v66)) {
			case 1LL: { // Some
				VAL v79 = mtp_std_maybe_Maybe_1_Some(v66);
				incref(v79);
				VAL v80 = mw_mirth_var_Ctx_new(v61, VU64(v79));
				VAL v81;
				uint64_t v82;
				mw_mirth_elab_abZ_tokenZAt(v64, &v81, &v82);
				VAL v83;
				VAL v84;
				VAL v85;
				uint64_t v86;
				mw_mirth_elab_elabZ_expandZ_tensorZBang(v63, v62, v82, &v83, &v84, &v85, &v86);
				VAL v87 = mw_mirth_var_Var_type(VU64(v79));
				VAL v88;
				VAL v89;
				uint64_t v90;
				mw_mirth_elab_elabZ_typeZ_unifyZBang(v83, v85, v87, v86, &v88, &v89, &v90);
				decref(v89);
				int64_t v91 = 1LL /* True */;
				x78 = v91;
				x77 = v67;
				x76 = v81;
				x75 = v88;
				x74 = v84;
				x73 = v80;
				x72 = v60;
				x71 = v59;
				x70 = v58;
				x69 = v57;
				x68 = v56;
			} break;
			case 0LL: { // None
				int64_t v92 = 0LL /* False */;
				x78 = v92;
				x77 = v67;
				x76 = v64;
				x75 = v63;
				x74 = v62;
				x73 = v61;
				x72 = v60;
				x71 = v59;
				x70 = v58;
				x69 = v57;
				x68 = v56;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v55 = x78;
		v54 = x77;
		v53 = x76;
		v52 = x75;
		v51 = x74;
		v50 = x73;
		v49 = x72;
		v48 = x71;
		v47 = x70;
		v46 = x69;
		v45 = x68;
	}
	decref(v54);
	VAL v93;
	VAL v94;
	mw_mirth_elab_abZ_homeZAt(v53, &v93, &v94);
	incref(v51);
	VAL v95 = MKI64(0LL /* Nil */);
	VAL v96 = mtw_mirth_arrow_Arrow_Arrow(v94, v49, v49, v50, v51, v51, v95);
	VAL v97 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v46, v47, v48, v96));
	VAL v98 = VVAL(VTUP(v45)->cells[5]);
	incref(v98);
	decref(v45);
	VAL v99;
	VAL v100;
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(v52, v97, v98, &v99, &v100);
	VAL v101;
	uint64_t v102;
	VAL v103;
	VAL v104;
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v100, &v101, &v102, &v103, &v104);
	VAL v105;
	VAL v106;
	mw_mirth_elab_abZ_ctxZAt(v93, &v105, &v106);
	VAL v107;
	VAL v108;
	mw_mirth_elab_abZ_typeZAt(v105, &v107, &v108);
	VAL v109;
	uint64_t v110;
	mw_mirth_elab_abZ_tokenZAt(v107, &v109, &v110);
	VAL v111 = mtw_mirth_arrow_Lambda_Lambda(v110, v106, v108, v6, v104);
	VAL v112 = mtw_mirth_arrow_Op_OpLambda(v111);
	VAL v113;
	VAL v114;
	mw_mirth_elab_abZ_opZBang(v112, v99, v109, &v113, &v114);
	VAL v115 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v101, v102, v103, v114));
	*x5 = v115;
	*x4 = v113;
}
static int64_t mw_std_set_SETz_INITIALz_SIZZE (void) {
	int64_t v1 = 256LL;
	return v1;
}
static VAL mw_std_set_ZPlusSet_new (void) {
	int64_t v1 = mw_std_set_SETz_INITIALz_SIZZE();
	VAL v2 = (mw_std_buffer_ZPlusBuffer_new(v1));
	return v2;
}
static void mw_std_set_ZPlusSet_rdrop (VAL x1) {
	mw_std_buffer_ZPlusBuffer_rdrop(x1);
}
static void mw_std_set_ZPlusSet_offsetZ_mask (int64_t x1, VAL x2, int64_t *x3, int64_t *x4, VAL *x5) {
	int64_t v6 = 8LL;
	int64_t v7 = i64_mod(x1, v6);
	int64_t v8 = i64_div(x1, v6);
	int64_t v9 = 1LL;
	uint64_t v10 = u64_shl(((uint64_t)v9), ((uint64_t)v7));
	int64_t v11 = mw_std_prim_Int_ZToU8(((int64_t)v10));
	*x5 = x2;
	*x4 = v11;
	*x3 = v8;
}
static void mw_std_set_ZPlusSet_memberZAsk (int64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	int64_t v5;
	int64_t v6;
	VAL v7;
	mw_std_set_ZPlusSet_offsetZ_mask(x1, x2, &v5, &v6, &v7);
	int64_t v8 = (0);
	int64_t v9;
	VAL v10;
	mw_std_buffer_ZPlusBuffer_ZAtU8(v5, v7, &v9, &v10);
	uint64_t v11 = (((uint64_t)v6) & ((uint64_t)v9));
	int64_t v12 = 0LL;
	bool v13 = (((int64_t)v11) != v12);
	*x4 = v10;
	*x3 = ((int64_t)v13);
}
static VAL mw_std_set_ZPlusSet_insertZBang (int64_t x1, VAL x2) {
	int64_t v3;
	int64_t v4;
	VAL v5;
	mw_std_set_ZPlusSet_offsetZ_mask(x1, x2, &v3, &v4, &v5);
	int64_t v6 = (0);
	int64_t v7;
	VAL v8;
	mw_std_buffer_ZPlusBuffer_ZAtU8(v3, v5, &v7, &v8);
	uint64_t v9 = (((uint64_t)v4) | ((uint64_t)v7));
	VAL v10 = (mw_std_buffer_ZPlusBuffer_ZBangU8(((int64_t)v9), v3, v8));
	return v10;
}
static int64_t mw_mirth_need_Need_ZToNat (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // NEED_WORD
			uint64_t v3 = mtp_mirth_need_Need_NEEDz_WORD(x1);
			int64_t v4 = mw_mirth_word_Word_index(v3);
			int64_t v5 = 0LL;
			bool v6 = (v4 < v5);
			int64_t x7;
			if (v6) {
				x7 = v5;
			} else {
				x7 = v4;
			}
			int64_t v8 = 4LL;
			int64_t v9 = i64_mul(x7, v8);
			x2 = v9;
		} break;
		case 1LL: { // NEED_BLOCK
			uint64_t v10 = mtp_mirth_need_Need_NEEDz_BLOCK(x1);
			int64_t v11 = mw_mirth_arrow_Block_index(v10);
			int64_t v12 = 0LL;
			bool v13 = (v11 < v12);
			int64_t x14;
			if (v13) {
				x14 = v12;
			} else {
				x14 = v11;
			}
			int64_t v15 = 4LL;
			int64_t v16 = i64_mul(x14, v15);
			int64_t v17 = 1LL;
			int64_t v18 = i64_add(v16, v17);
			x2 = v18;
		} break;
		case 2LL: { // NEED_TAGW
			uint64_t v19 = mtp_mirth_need_Need_NEEDz_TAGW(x1);
			int64_t v20 = mw_mirth_data_Tag_index(v19);
			int64_t v21 = 0LL;
			bool v22 = (v20 < v21);
			int64_t x23;
			if (v22) {
				x23 = v21;
			} else {
				x23 = v20;
			}
			int64_t v24 = 4LL;
			int64_t v25 = i64_mul(x23, v24);
			int64_t v26 = 2LL;
			int64_t v27 = i64_add(v25, v26);
			x2 = v27;
		} break;
		case 3LL: { // NEED_TAGP
			uint64_t v28 = mtp_mirth_need_Need_NEEDz_TAGP(x1);
			int64_t v29 = mw_mirth_data_Tag_index(v28);
			int64_t v30 = 0LL;
			bool v31 = (v29 < v30);
			int64_t x32;
			if (v31) {
				x32 = v30;
			} else {
				x32 = v29;
			}
			int64_t v33 = 4LL;
			int64_t v34 = i64_mul(x32, v33);
			int64_t v35 = 3LL;
			int64_t v36 = i64_add(v34, v35);
			x2 = v36;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_need_ZPlusNeeds_new (void) {
	VAL v1 = MKI64(0LL /* Nil */);
	VAL v2 = (mw_std_set_ZPlusSet_new());
	VAL v3 = (mtw_mirth_need_ZPlusNeeds_ZPlusNeeds(v1, v2));
	return v3;
}
static void mw_mirth_need_ZPlusNeeds_rdrop (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_need_ZPlusNeeds_ZPlusNeeds(x1, &v2, &v3);
	mw_std_set_ZPlusSet_rdrop(v3);
	decref(v2);
}
static void mw_mirth_need_Need_neededZAsk (VAL x1, VAL x2, int64_t *x3, VAL *x4) {
	int64_t v5 = mw_mirth_need_Need_ZToNat(x1);
	VAL v6 = (VVAL(VTUP(x2)->cells[2]));
	int64_t v7;
	VAL v8;
	mw_std_set_ZPlusSet_memberZAsk(v5, v6, &v7, &v8);
	VTUP(x2)->cells[2] = v8;
	*x4 = x2;
	*x3 = v7;
}
static void mw_mirth_word_Word_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = mtw_mirth_need_Need_NEEDz_WORD(x1);
	int64_t v6;
	VAL v7;
	mw_mirth_need_Need_neededZAsk(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_arrow_Block_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = mtw_mirth_need_Need_NEEDz_BLOCK(x1);
	int64_t v6;
	VAL v7;
	mw_mirth_need_Need_neededZAsk(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_data_Tag_wordZ_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = mtw_mirth_need_Need_NEEDz_TAGW(x1);
	int64_t v6;
	VAL v7;
	mw_mirth_need_Need_neededZAsk(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_data_Tag_patZ_neededZAsk (uint64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = mtw_mirth_need_Need_NEEDz_TAGP(x1);
	int64_t v6;
	VAL v7;
	mw_mirth_need_Need_neededZAsk(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static VAL mw_mirth_need_ZPlusNeeds_needZBang (VAL x1, VAL x2) {
	incref(x1);
	int64_t v3;
	VAL v4;
	mw_mirth_need_Need_neededZAsk(x1, x2, &v3, &v4);
	VAL x5;
	if (((bool)v3)) {
		decref(x1);
		x5 = v4;
	} else {
		incref(x1);
		int64_t v6 = mw_mirth_need_Need_ZToNat(x1);
		VAL v7 = (VVAL(VTUP(v4)->cells[2]));
		VAL v8 = (mw_std_set_ZPlusSet_insertZBang(v6, v7));
		VTUP(v4)->cells[2] = v8;
		VAL v9 = VVAL(VTUP(v4)->cells[1]);
		incref(v9);
		VAL v10 = mtw_std_list_List_1_Cons(x1, v9);
		VAL v11 = VTUP(v4)->cells[1];
		decref(v11);
		VTUP(v4)->cells[1] = v10;
		x5 = v4;
	}
	return x5;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_wordZBang (uint64_t x1, VAL x2) {
	VAL v3 = mtw_mirth_need_Need_NEEDz_WORD(x1);
	VAL v4 = (mw_mirth_need_ZPlusNeeds_needZBang(v3, x2));
	return v4;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_blockZBang (uint64_t x1, VAL x2) {
	VAL v3 = mtw_mirth_need_Need_NEEDz_BLOCK(x1);
	VAL v4 = (mw_mirth_need_ZPlusNeeds_needZBang(v3, x2));
	return v4;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang (uint64_t x1, VAL x2) {
	VAL v3 = mtw_mirth_need_Need_NEEDz_TAGW(x1);
	VAL v4 = (mw_mirth_need_ZPlusNeeds_needZBang(v3, x2));
	return v4;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang (uint64_t x1, VAL x2) {
	VAL v3 = mtw_mirth_need_Need_NEEDz_TAGP(x1);
	VAL v4 = (mw_mirth_need_ZPlusNeeds_needZBang(v3, x2));
	return v4;
}
static void mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(x1, x2, x3, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang(v6, v7, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
}
static void mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = VVAL(VTUP(x2)->cells[1]);
	incref(v5);
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(v5, &v6, &v7);
	VAL v8 = VTUP(x2)->cells[1];
	decref(v8);
	VTUP(x2)->cells[1] = v7;
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v13;
			VAL v14;
			mw_mirth_need_ZPlusNeeds_runZ_needZBang(v12, x1, x2, &v13, &v14);
			int64_t v15 = 1LL /* True */;
			x11 = v15;
			x10 = v14;
			x9 = v13;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x11 = v16;
			x10 = x2;
			x9 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v17 = (x9);
	VAL v18 = (x10);
	int64_t v19 = x11;
	while (((bool)v19)) {
		VAL v20 = (v17);
		VAL v21 = (v18);
		VAL v22 = VVAL(VTUP(v21)->cells[1]);
		incref(v22);
		VAL v23;
		VAL v24;
		mw_std_list_List_1_uncons(v22, &v23, &v24);
		VAL v25 = VTUP(v21)->cells[1];
		decref(v25);
		VTUP(v21)->cells[1] = v24;
		VAL x26;
		VAL x27;
		int64_t x28;
		switch (get_data_tag(v23)) {
			case 1LL: { // Some
				VAL v29 = mtp_std_maybe_Maybe_1_Some(v23);
				VAL v30;
				VAL v31;
				mw_mirth_need_ZPlusNeeds_runZ_needZBang(v29, v20, v21, &v30, &v31);
				int64_t v32 = 1LL /* True */;
				x28 = v32;
				x27 = v31;
				x26 = v30;
			} break;
			case 0LL: { // None
				int64_t v33 = 0LL /* False */;
				x28 = v33;
				x27 = v21;
				x26 = v20;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v19 = x28;
		v18 = x27;
		v17 = x26;
	}
	*x4 = v18;
	*x3 = v17;
}
static void mw_mirth_need_ZPlusNeeds_runZ_needZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL x6;
	VAL x7;
	switch (get_data_tag(x1)) {
		case 1LL: { // NEED_BLOCK
			uint64_t v8 = mtp_mirth_need_Need_NEEDz_BLOCK(x1);
			VAL v9;
			VAL v10;
			mw_mirth_need_ZPlusNeeds_runZ_blockZBang(v8, x2, x3, &v9, &v10);
			x7 = v10;
			x6 = v9;
		} break;
		case 0LL: { // NEED_WORD
			uint64_t v11 = mtp_mirth_need_Need_NEEDz_WORD(x1);
			VAL v12;
			VAL v13;
			mw_mirth_need_ZPlusNeeds_runZ_wordZBang(v11, x2, x3, &v12, &v13);
			x7 = v13;
			x6 = v12;
		} break;
		case 2LL: { // NEED_TAGW
			uint64_t v14 = mtp_mirth_need_Need_NEEDz_TAGW(x1);
			x7 = x3;
			x6 = x2;
		} break;
		case 3LL: { // NEED_TAGP
			uint64_t v15 = mtp_mirth_need_Need_NEEDz_TAGP(x1);
			x7 = x3;
			x6 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x7;
	*x4 = x6;
}
static void mw_mirth_need_ZPlusNeeds_runZ_argsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(x1, &v6, &v7);
	VAL x8;
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v13;
			VAL v14;
			mw_mirth_need_ZPlusNeeds_runZ_argZBang(VU64(v12), x2, x3, &v13, &v14);
			int64_t v15 = 1LL /* True */;
			x11 = v15;
			x10 = v7;
			x9 = v14;
			x8 = v13;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x11 = v16;
			x10 = v7;
			x9 = x3;
			x8 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v17 = (x8);
	VAL v18 = (x9);
	VAL v19 = x10;
	int64_t v20 = x11;
	while (((bool)v20)) {
		VAL v21 = (v17);
		VAL v22 = (v18);
		VAL v23 = v19;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		VAL x26;
		VAL x27;
		VAL x28;
		int64_t x29;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v24);
				VAL v31;
				VAL v32;
				mw_mirth_need_ZPlusNeeds_runZ_argZBang(VU64(v30), v21, v22, &v31, &v32);
				int64_t v33 = 1LL /* True */;
				x29 = v33;
				x28 = v25;
				x27 = v32;
				x26 = v31;
			} break;
			case 0LL: { // None
				int64_t v34 = 0LL /* False */;
				x29 = v34;
				x28 = v25;
				x27 = v22;
				x26 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x29;
		v19 = x28;
		v18 = x27;
		v17 = x26;
	}
	decref(v19);
	*x5 = v18;
	*x4 = v17;
}
static void mw_mirth_need_ZPlusNeeds_runZ_argZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_need_ZPlusNeeds_runZ_blockZBang(x1, x2, x3, &v6, &v7);
	*x5 = v7;
	*x4 = v6;
}
static void mw_mirth_need_ZPlusNeeds_runZ_blockZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_arrow_Block_arrow(x2, x1, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v7, v6, x3, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
}
static void mw_mirth_need_ZPlusNeeds_runZ_wordZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_word_Word_arrow(x1, x2, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v6, v7, x3, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
}
static void mw_mirth_need_ZPlusNeeds_runZ_arrowZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x1)->cells[7]);
	incref(v6);
	decref(x1);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14;
			VAL v15;
			mw_mirth_need_ZPlusNeeds_runZ_atomZBang(v13, x2, x3, &v14, &v15);
			int64_t v16 = 1LL /* True */;
			x12 = v16;
			x11 = v8;
			x10 = v15;
			x9 = v14;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x12 = v17;
			x11 = v8;
			x10 = x3;
			x9 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x9);
	VAL v19 = (x10);
	VAL v20 = x11;
	int64_t v21 = x12;
	while (((bool)v21)) {
		VAL v22 = (v18);
		VAL v23 = (v19);
		VAL v24 = v20;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
				VAL v32;
				VAL v33;
				mw_mirth_need_ZPlusNeeds_runZ_atomZBang(v31, v22, v23, &v32, &v33);
				int64_t v34 = 1LL /* True */;
				x30 = v34;
				x29 = v26;
				x28 = v33;
				x27 = v32;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x30 = v35;
				x29 = v26;
				x28 = v23;
				x27 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x30;
		v20 = x29;
		v19 = x28;
		v18 = x27;
	}
	decref(v20);
	*x5 = v19;
	*x4 = v18;
}
static void mw_mirth_need_ZPlusNeeds_runZ_atomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x1);
	VAL v6 = VVAL(VTUP(x1)->cells[5]);
	incref(v6);
	decref(x1);
	VAL v7 = VVAL(VTUP(x1)->cells[4]);
	incref(v7);
	decref(x1);
	VAL v8;
	VAL v9;
	mw_mirth_need_ZPlusNeeds_runZ_opZBang(v6, v7, x2, x3, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
}
static void mw_mirth_need_ZPlusNeeds_runZ_opZBang (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6) {
	VAL x7;
	VAL x8;
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 7LL: { // OpInt
			int64_t v9 = mtp_mirth_arrow_Op_OpInt(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 8LL: { // OpF64
			double v10 = mtp_mirth_arrow_Op_OpF64(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 9LL: { // OpStr
			VAL v11 = mtp_mirth_arrow_Op_OpStr(x2);
			decref(v11);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 2LL: { // OpWord
			uint64_t v12 = mtp_mirth_arrow_Op_OpWord(x2);
			int64_t v13 = mw_mirth_word_Word_preferZ_inlineZAsk(v12);
			VAL x14;
			VAL x15;
			VAL x16;
			if (((bool)v13)) {
				VAL v17;
				VAL v18;
				mw_mirth_need_ZPlusNeeds_runZ_wordZBang(v12, x3, x4, &v17, &v18);
				x16 = v18;
				x15 = v17;
				x14 = x1;
			} else {
				VAL v19 = (mw_mirth_need_ZPlusNeeds_needZ_wordZBang(v12, x4));
				x16 = v19;
				x15 = x3;
				x14 = x1;
			}
			VAL v20;
			VAL v21;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x14, x15, x16, &v20, &v21);
			x8 = v21;
			x7 = v20;
		} break;
		case 3LL: { // OpExternal
			uint64_t v22 = mtp_mirth_arrow_Op_OpExternal(x2);
			VAL v23;
			VAL v24;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v23, &v24);
			x8 = v24;
			x7 = v23;
		} break;
		case 4LL: { // OpBuffer
			uint64_t v25 = mtp_mirth_arrow_Op_OpBuffer(x2);
			VAL v26;
			VAL v27;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v26, &v27);
			x8 = v27;
			x7 = v26;
		} break;
		case 5LL: { // OpVariable
			uint64_t v28 = mtp_mirth_arrow_Op_OpVariable(x2);
			VAL v29;
			VAL v30;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v29, &v30);
			x8 = v30;
			x7 = v29;
		} break;
		case 6LL: { // OpField
			uint64_t v31 = mtp_mirth_arrow_Op_OpField(x2);
			VAL v32;
			VAL v33;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v32, &v33);
			x8 = v33;
			x7 = v32;
		} break;
		case 10LL: { // OpTag
			uint64_t v34 = mtp_mirth_arrow_Op_OpTag(x2);
			VAL v35 = (mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang(v34, x4));
			VAL v36;
			VAL v37;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, v35, &v36, &v37);
			x8 = v37;
			x7 = v36;
		} break;
		case 1LL: { // OpPrim
			int64_t v38 = mtp_mirth_arrow_Op_OpPrim(x2);
			VAL v39;
			VAL v40;
			mw_mirth_need_ZPlusNeeds_runZ_primZBang(x1, v38, x3, x4, &v39, &v40);
			x8 = v40;
			x7 = v39;
		} break;
		case 11LL: { // OpMatch
			VAL v41 = mtp_mirth_arrow_Op_OpMatch(x2);
			decref(x1);
			VAL v42;
			VAL v43;
			mw_mirth_need_ZPlusNeeds_runZ_matchZBang(v41, x3, x4, &v42, &v43);
			x8 = v43;
			x7 = v42;
		} break;
		case 12LL: { // OpLambda
			VAL v44 = mtp_mirth_arrow_Op_OpLambda(x2);
			decref(x1);
			VAL v45;
			VAL v46;
			mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang(v44, x3, x4, &v45, &v46);
			x8 = v46;
			x7 = v45;
		} break;
		case 13LL: { // OpVar
			uint64_t v47 = mtp_mirth_arrow_Op_OpVar(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v48 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			decref(x1);
			VAL v49;
			VAL v50;
			mw_mirth_need_ZPlusNeeds_pushZ_blockZBang(v48, x3, x4, &v49, &v50);
			x8 = v50;
			x7 = v49;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v51 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			decref(x1);
			VAL v52;
			VAL v53;
			mw_mirth_need_ZPlusNeeds_runZ_blockZBang(v51, x3, x4, &v52, &v53);
			x8 = v53;
			x7 = v52;
		} break;
		case 16LL: { // OpCoerce
			int64_t v54 = mtp_mirth_arrow_Op_OpCoerce(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v55 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v56 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v57 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v58 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v59 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 22LL: { // OpDataGetLabel
			VAL v60 = mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			decref(v60);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		case 23LL: { // OpDataSetLabel
			VAL v61 = mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			decref(v61);
			decref(x1);
			x8 = x4;
			x7 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x8;
	*x5 = x7;
}
static void mw_mirth_need_ZPlusNeeds_runZ_primZBang (VAL x1, int64_t x2, VAL x3, VAL x4, VAL *x5, VAL *x6) {
	VAL x7;
	VAL x8;
	switch (x2) {
		case 5LL: { // PRIM_CORE_DIP
			incref(x1);
			VAL v9 = mw_std_list_List_1_ZDivL1(x1);
			VAL x10;
			VAL x11;
			switch (get_data_tag(v9)) {
				case 1LL: { // Some
					VAL v12 = mtp_std_maybe_Maybe_1_Some(v9);
					decref(v12);
					VAL v13;
					VAL v14;
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(x1, x3, x4, &v13, &v14);
					x11 = v14;
					x10 = v13;
				} break;
				case 0LL: { // None
					VAL v15;
					VAL v16;
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v15, &v16);
					x11 = v16;
					x10 = v15;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x11;
			x7 = x10;
		} break;
		case 6LL: { // PRIM_CORE_RDIP
			incref(x1);
			VAL v17 = mw_std_list_List_1_ZDivL1(x1);
			VAL x18;
			VAL x19;
			switch (get_data_tag(v17)) {
				case 1LL: { // Some
					VAL v20 = mtp_std_maybe_Maybe_1_Some(v17);
					decref(v20);
					VAL v21;
					VAL v22;
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(x1, x3, x4, &v21, &v22);
					x19 = v22;
					x18 = v21;
				} break;
				case 0LL: { // None
					VAL v23;
					VAL v24;
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v23, &v24);
					x19 = v24;
					x18 = v23;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x19;
			x7 = x18;
		} break;
		case 7LL: { // PRIM_CORE_IF
			incref(x1);
			VAL v25 = mw_std_list_List_1_ZDivL2(x1);
			VAL x26;
			VAL x27;
			switch (get_data_tag(v25)) {
				case 1LL: { // Some
					VAL v28 = mtp_std_maybe_Maybe_1_Some(v25);
					decref(v28);
					VAL v29;
					VAL v30;
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(x1, x3, x4, &v29, &v30);
					x27 = v30;
					x26 = v29;
				} break;
				case 0LL: { // None
					VAL v31;
					VAL v32;
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v31, &v32);
					x27 = v32;
					x26 = v31;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x27;
			x7 = x26;
		} break;
		case 8LL: { // PRIM_CORE_WHILE
			incref(x1);
			VAL v33 = mw_std_list_List_1_ZDivL2(x1);
			VAL x34;
			VAL x35;
			switch (get_data_tag(v33)) {
				case 1LL: { // Some
					VAL v36 = mtp_std_maybe_Maybe_1_Some(v33);
					decref(v36);
					VAL v37;
					VAL v38;
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(x1, x3, x4, &v37, &v38);
					x35 = v38;
					x34 = v37;
				} break;
				case 0LL: { // None
					VAL v39;
					VAL v40;
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v39, &v40);
					x35 = v40;
					x34 = v39;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x35;
			x7 = x34;
		} break;
		default: {
			VAL v41;
			VAL v42;
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4, &v41, &v42);
			x8 = v42;
			x7 = v41;
		} break;
	}
	*x6 = x8;
	*x5 = x7;
}
static void mw_mirth_need_ZPlusNeeds_runZ_matchZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x1)->cells[7]);
	incref(v6);
	decref(x1);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14;
			VAL v15;
			mw_mirth_need_ZPlusNeeds_runZ_caseZBang(v13, x2, x3, &v14, &v15);
			int64_t v16 = 1LL /* True */;
			x12 = v16;
			x11 = v8;
			x10 = v15;
			x9 = v14;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x12 = v17;
			x11 = v8;
			x10 = x3;
			x9 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x9);
	VAL v19 = (x10);
	VAL v20 = x11;
	int64_t v21 = x12;
	while (((bool)v21)) {
		VAL v22 = (v18);
		VAL v23 = (v19);
		VAL v24 = v20;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
				VAL v32;
				VAL v33;
				mw_mirth_need_ZPlusNeeds_runZ_caseZBang(v31, v22, v23, &v32, &v33);
				int64_t v34 = 1LL /* True */;
				x30 = v34;
				x29 = v26;
				x28 = v33;
				x27 = v32;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x30 = v35;
				x29 = v26;
				x28 = v23;
				x27 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x30;
		v20 = x29;
		v19 = x28;
		v18 = x27;
	}
	decref(v20);
	*x5 = v19;
	*x4 = v18;
}
static void mw_mirth_need_ZPlusNeeds_runZ_caseZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	incref(x1);
	VAL v6 = VVAL(VTUP(x1)->cells[1]);
	incref(v6);
	decref(x1);
	VAL v7;
	VAL v8;
	mw_mirth_need_ZPlusNeeds_runZ_patternZBang(v6, x2, x3, &v7, &v8);
	VAL v9 = VVAL(VTUP(x1)->cells[2]);
	incref(v9);
	decref(x1);
	VAL v10;
	VAL v11;
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v9, v7, v8, &v10, &v11);
	*x5 = v11;
	*x4 = v10;
}
static void mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x1)->cells[5]);
	incref(v6);
	decref(x1);
	VAL v7;
	VAL v8;
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v6, x2, x3, &v7, &v8);
	*x5 = v8;
	*x4 = v7;
}
static void mw_mirth_need_ZPlusNeeds_runZ_patternZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x1)->cells[9]);
	incref(v6);
	decref(x1);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v6, &v7, &v8);
	VAL x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14;
			VAL v15;
			mw_mirth_need_ZPlusNeeds_runZ_patatomZBang(v13, x2, x3, &v14, &v15);
			int64_t v16 = 1LL /* True */;
			x12 = v16;
			x11 = v8;
			x10 = v15;
			x9 = v14;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x12 = v17;
			x11 = v8;
			x10 = x3;
			x9 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x9);
	VAL v19 = (x10);
	VAL v20 = x11;
	int64_t v21 = x12;
	while (((bool)v21)) {
		VAL v22 = (v18);
		VAL v23 = (v19);
		VAL v24 = v20;
		VAL v25;
		VAL v26;
		mw_std_list_List_1_uncons(v24, &v25, &v26);
		VAL x27;
		VAL x28;
		VAL x29;
		int64_t x30;
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v25);
				VAL v32;
				VAL v33;
				mw_mirth_need_ZPlusNeeds_runZ_patatomZBang(v31, v22, v23, &v32, &v33);
				int64_t v34 = 1LL /* True */;
				x30 = v34;
				x29 = v26;
				x28 = v33;
				x27 = v32;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x30 = v35;
				x29 = v26;
				x28 = v23;
				x27 = v22;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v21 = x30;
		v20 = x29;
		v19 = x28;
		v18 = x27;
	}
	decref(v20);
	*x5 = v19;
	*x4 = v18;
}
static void mw_mirth_need_ZPlusNeeds_runZ_patatomZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = VVAL(VTUP(x1)->cells[7]);
	incref(v6);
	decref(x1);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 0LL: { // PatOpUnderscore
			x8 = x3;
			x7 = x2;
		} break;
		case 1LL: { // PatOpTag
			uint64_t v9 = mtp_mirth_match_PatternOp_PatOpTag(v6);
			VAL v10 = (mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang(v9, x3));
			x8 = v10;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x8;
	*x4 = x7;
}
static void mw_mirth_need_ZPlusNeeds_pushZ_argsZBang (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_std_list_List_1_uncons(x1, &v6, &v7);
	VAL x8;
	VAL x9;
	VAL x10;
	int64_t x11;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v13;
			VAL v14;
			mw_mirth_need_ZPlusNeeds_pushZ_argZBang(VU64(v12), x2, x3, &v13, &v14);
			int64_t v15 = 1LL /* True */;
			x11 = v15;
			x10 = v7;
			x9 = v14;
			x8 = v13;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x11 = v16;
			x10 = v7;
			x9 = x3;
			x8 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v17 = (x8);
	VAL v18 = (x9);
	VAL v19 = x10;
	int64_t v20 = x11;
	while (((bool)v20)) {
		VAL v21 = (v17);
		VAL v22 = (v18);
		VAL v23 = v19;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		VAL x26;
		VAL x27;
		VAL x28;
		int64_t x29;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v24);
				VAL v31;
				VAL v32;
				mw_mirth_need_ZPlusNeeds_pushZ_argZBang(VU64(v30), v21, v22, &v31, &v32);
				int64_t v33 = 1LL /* True */;
				x29 = v33;
				x28 = v25;
				x27 = v32;
				x26 = v31;
			} break;
			case 0LL: { // None
				int64_t v34 = 0LL /* False */;
				x29 = v34;
				x28 = v25;
				x27 = v22;
				x26 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x29;
		v19 = x28;
		v18 = x27;
		v17 = x26;
	}
	decref(v19);
	*x5 = v18;
	*x4 = v17;
}
static void mw_mirth_need_ZPlusNeeds_pushZ_argZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_need_ZPlusNeeds_pushZ_blockZBang(x1, x2, x3, &v6, &v7);
	*x5 = v7;
	*x4 = v6;
}
static void mw_mirth_need_ZPlusNeeds_pushZ_blockZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_arrow_Block_toZ_runZ_var(x2, x1, &v6, &v7);
	VAL x8;
	VAL x9;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v7);
			decref(v10);
			x9 = x3;
			x8 = v6;
		} break;
		case 0LL: { // None
			VAL v11 = (mw_mirth_need_ZPlusNeeds_needZ_blockZBang(x1, x3));
			x9 = v11;
			x8 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x9;
	*x4 = x8;
}
static VAL mw_mirth_c99_ZPlusC99_put (VAL x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[5]));
	VAL v4 = (mw_std_output_ZPlusOutput_put(x1, v3));
	VTUP(x2)->cells[5] = v4;
	return x2;
}
static VAL mw_mirth_c99_ZPlusC99_putZ_byte (int64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[5]));
	VAL v4 = (mw_std_output_ZPlusOutput_putZ_byte(x1, v3));
	VTUP(x2)->cells[5] = v4;
	return x2;
}
static VAL mw_mirth_c99_ZPlusC99_line (VAL x1) {
	VAL v2 = (VVAL(VTUP(x1)->cells[5]));
	VAL v3 = (mw_std_output_ZPlusOutput_line(v2));
	VTUP(x1)->cells[5] = v3;
	return x1;
}
static void mw_mirth_c99_c99Z_startZBang (VAL x1, VAL x2, int64_t x3, VAL x4, VAL *x5, int64_t *x6, VAL *x7) {
	int64_t v8 = 0LL;
	int64_t v9 = 0LL;
	VAL v10 = (mw_mirth_need_ZPlusNeeds_new());
	incref(x1);
	VAL v11;
	VAL v12;
	mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang(x1, x4, v10, &v11, &v12);
	incref(x2);
	VAL v13 = VVAL(VTUP(x2)->cells[1]);
	incref(v13);
	decref(x2);
	int64_t v14;
	VAL v15;
	mw_std_prim_ZPlusWorld_createZ_fileZBang(v13, x3, &v14, &v15);
	int64_t x16;
	int64_t x17;
	VAL x18;
	VAL x19;
	VAL x20;
	VAL x21;
	int64_t x22;
	VAL x23;
	switch (get_data_tag(v15)) {
		case 0LL: { // +FileOk
			VAL v24 = (mtp_std_file_ZPlusFileZAsk_ZPlusFileOk(v15));
			x23 = v24;
			x22 = v14;
			x21 = x2;
			x20 = v11;
			x19 = v12;
			x18 = x1;
			x17 = v9;
			x16 = v8;
		} break;
		case 1LL: { // +FileErr
			VAL v25 = mtp_std_file_ZPlusFileZAsk_ZPlusFileErr(v15);
			lpush(&lbl_depth, MKI64(v8));
			lpush(&lbl_freshZ_counter, MKI64(v9));
			push_value(x1);
			lpush(&lbl_ZPlusneeds, v12);
			lpush(&lbl_options, x2);
			push_resource(MKI64(v14));
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(v25, v11);
			VAL r26 = pop_resource();
			x23 = r26;
			int64_t r27 = VI64(pop_resource());
			x22 = r27;
			VAL v28 = lpop(&lbl_options);
			x21 = v28;
			VAL v29 = (lpop(&lbl_ZPlusmirth));
			x20 = v29;
			VAL v30 = (lpop(&lbl_ZPlusneeds));
			x19 = v30;
			VAL v31 = pop_value();
			x18 = v31;
			int64_t v32 = VI64(lpop(&lbl_freshZ_counter));
			x17 = v32;
			int64_t v33 = VI64(lpop(&lbl_depth));
			x16 = v33;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v34 = (mw_std_output_ZPlusOutput_startZBang(x23));
	VAL v35 = (mtw_mirth_c99_ZPlusC99_ZPlusC99(x21, x16, x17, x19, v34, x20));
	*x7 = v35;
	*x6 = x22;
	*x5 = x18;
}
static void mw_mirth_c99_c99Z_endZBang (int64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5;
	int64_t v6;
	int64_t v7;
	VAL v8;
	VAL v9;
	VAL v10;
	mtp_mirth_c99_ZPlusC99_ZPlusC99(x2, &v5, &v6, &v7, &v8, &v9, &v10);
	decref(v5);
	mw_mirth_need_ZPlusNeeds_rdrop(v8);
	VAL v11 = (mw_std_output_ZPlusOutput_endZBang(v9));
	int64_t v12 = (mw_std_file_ZPlusFile_closeZ_fileZBang(x1, v11));
	*x4 = v10;
	*x3 = v12;
}
static VAL mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang (VAL x1) {
	int64_t v2 = 0LL;
	VTUP(x1)->cells[3] = MKI64(v2);
	return x1;
}
static void mw_mirth_c99_ZPlusC99_freshZ_natZBang (VAL x1, int64_t *x2, VAL *x3) {
	int64_t v4 = VI64(VTUP(x1)->cells[3]);
	int64_t v5 = 1LL;
	int64_t v6 = i64_add(v4, v5);
	VTUP(x1)->cells[3] = MKI64(v6);
	*x3 = x1;
	*x2 = v4;
}
static void mw_mirth_c99_ZPlusC99_freshZ_nameZBang (VAL x1, VAL *x2, VAL *x3) {
	STR* v4;
	STRLIT(v4, "v", 1);
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang(MKSTR(v4), x1, &v5, &v6);
	*x3 = v6;
	*x2 = v5;
}
static void mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang (VAL x1, VAL *x2, VAL *x3) {
	STR* v4;
	STRLIT(v4, "r", 1);
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang(MKSTR(v4), x1, &v5, &v6);
	*x3 = v6;
	*x2 = v5;
}
static void mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang (VAL x1, VAL *x2, VAL *x3) {
	STR* v4;
	STRLIT(v4, "x", 1);
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang(MKSTR(v4), x1, &v5, &v6);
	*x3 = v6;
	*x2 = v5;
}
static void mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	int64_t v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_natZBang(x2, &v5, &v6);
	STR* v7 = i64_show(v5);
	STR* v8 = str_cat(VSTR(x1), v7);
	*x4 = v6;
	*x3 = MKSTR(v8);
}
static void mw_mirth_c99_runZ_outputZ_c99ZBang (VAL x1, VAL x2, int64_t x3, VAL x4, int64_t *x5, VAL *x6) {
	int64_t v7 = VI64(VTUP(x4)->cells[1]);
	int64_t v8 = 0LL;
	bool v9 = (v7 > v8);
	int64_t x10;
	VAL x11;
	if (v9) {
		decref(x2);
		decref(x1);
		x11 = x4;
		x10 = x3;
	} else {
		VAL v12;
		int64_t v13;
		VAL v14;
		mw_mirth_c99_c99Z_startZBang(x1, x2, x3, x4, &v12, &v13, &v14);
		VAL v15 = (mw_mirth_c99_c99Z_headerZBang(v14));
		VAL v16 = (mw_mirth_c99_c99Z_labelZ_defsZBang(v15));
		VAL v17 = (mw_mirth_c99_c99Z_tagZ_defsZBang(v16));
		VAL v18 = (mw_mirth_c99_c99Z_buffersZBang(v17));
		VAL v19 = (mw_mirth_c99_c99Z_variablesZBang(v18));
		VAL v20 = (mw_mirth_c99_c99Z_externalZ_blocksZBang(v19));
		VAL v21 = (mw_mirth_c99_c99Z_wordZ_sigsZBang(v20));
		VAL v22 = (mw_mirth_c99_c99Z_blockZ_sigsZBang(v21));
		VAL v23 = (mw_mirth_c99_c99Z_fieldZ_sigsZBang(v22));
		VAL v24 = (mw_mirth_c99_c99Z_mainZBang(v12, v23));
		VAL v25 = (mw_mirth_c99_c99Z_fieldZ_defsZBang(v24));
		VAL v26 = (mw_mirth_c99_c99Z_wordZ_defsZBang(v25));
		VAL v27 = (mw_mirth_c99_c99Z_blockZ_defsZBang(v26));
		int64_t v28;
		VAL v29;
		mw_mirth_c99_c99Z_endZBang(v13, v27, &v28, &v29);
		x11 = v29;
		x10 = v28;
	}
	*x6 = x11;
	*x5 = x10;
}
static void mw_mirth_data_Tag_wordZ_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Tag_ZTildewordZ_cname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		STR* v11;
		STRLIT(v11, "", 0);
		STR* v12;
		STRLIT(v12, "mtw_", 4);
		VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), MKSTR(v11)));
		VAL v14 = mw_mirth_data_Tag_qname(x2);
		VAL v15;
		VAL v16;
		mw_mirth_name_QName_mangled(x1, v14, &v15, &v16);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(v16, v13));
		incref(v17);
		mut_set(v17, v5);
		x9 = v17;
		x8 = x2;
		x7 = v15;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_data_Tag_patZ_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Tag_ZTildepatZ_cname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		STR* v11;
		STRLIT(v11, "", 0);
		STR* v12;
		STRLIT(v12, "mtp_", 4);
		VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), MKSTR(v11)));
		VAL v14 = mw_mirth_data_Tag_qname(x2);
		VAL v15;
		VAL v16;
		mw_mirth_name_QName_mangled(x1, v14, &v15, &v16);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(v16, v13));
		incref(v17);
		mut_set(v17, v5);
		x9 = v17;
		x8 = x2;
		x7 = v15;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_buffer_Buffer_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_buffer_Buffer_ZTildecname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		STR* v11;
		STRLIT(v11, "", 0);
		STR* v12;
		STRLIT(v12, "mbuf_", 5);
		VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), MKSTR(v11)));
		VAL v14 = mw_mirth_buffer_Buffer_qname(x2);
		VAL v15;
		VAL v16;
		mw_mirth_name_QName_mangled(x1, v14, &v15, &v16);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(v16, v13));
		incref(v17);
		mut_set(v17, v5);
		x9 = v17;
		x8 = x2;
		x7 = v15;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_variable_Variable_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_variable_Variable_ZTildecname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		STR* v11;
		STRLIT(v11, "", 0);
		STR* v12;
		STRLIT(v12, "mvar_", 5);
		VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), MKSTR(v11)));
		VAL v14 = mw_mirth_variable_Variable_qname(x2);
		VAL v15;
		VAL v16;
		mw_mirth_name_QName_mangled(x1, v14, &v15, &v16);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(v16, v13));
		incref(v17);
		mut_set(v17, v5);
		x9 = v17;
		x8 = x2;
		x7 = v15;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_table_Field_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_table_Field_ZTildecname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11;
		VAL v12;
		mw_mirth_table_Field_qnameZ_hard(x1, x2, &v11, &v12);
		VAL v13;
		VAL v14;
		mw_mirth_name_QName_mangled(v11, v12, &v13, &v14);
		STR* v15;
		STRLIT(v15, "", 0);
		STR* v16;
		STRLIT(v16, "mfld_", 5);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), MKSTR(v15)));
		VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(v14, v17));
		incref(v18);
		mut_set(v18, v5);
		x9 = v18;
		x8 = x2;
		x7 = v13;
	}
	*x4 = x9;
	*x3 = x7;
}
static void mw_mirth_external_External_cname (VAL x1, uint64_t x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_external_External_ZTildecname(x2);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x2;
		x7 = x1;
	} else {
		VAL v11;
		VAL v12;
		mw_mirth_external_External_qnameZ_hard(x1, x2, &v11, &v12);
		VAL v13;
		VAL v14;
		mw_mirth_name_QName_mangled(v11, v12, &v13, &v14);
		STR* v15;
		STRLIT(v15, "", 0);
		STR* v16;
		STRLIT(v16, "mext_", 5);
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), MKSTR(v15)));
		VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(v14, v17));
		incref(v18);
		mut_set(v18, v5);
		x9 = v18;
		x8 = x2;
		x7 = v13;
	}
	*x4 = x9;
	*x3 = x7;
}
static VAL mw_mirth_c99_ZPlusC99_sigZ_put (VAL x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "static void ", 12);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(x1, v4));
	STR* v6;
	STRLIT(v6, " (void)", 7);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	return v7;
}
static VAL mw_mirth_c99_c99Z_headerZ_str (void) {
	STR* v1;
	STRLIT(v1,
		"/* MIRTH HEADER */\n"
		"// #line 3 \"src/mirth.h\"\n"
		"\n"
		"#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n"
		"#define MIRTH_WINDOWS 1\n"
		"#elif defined(__linux__)\n"
		"#define MIRTH_LINUX 1\n"
		"#elif defined(__APPLE__)\n"
		"#define MIRTH_MACOS 1\n"
		"#else\n"
		"#error \"Platform not supported.\"\n"
		"#endif\n"
		"\n"
		"#if defined(__x86_64__) || defined(_M_X64)\n"
		"#define MIRTH_AMD64\n"
		"#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n"
		"#define MIRTH_I386\n"
		"#elif defined(__aarch64__) || defined(_M_ARM64)\n"
		"#define MIRTH_ARM64\n"
		"#else\n"
		"#error \"Architecture not supported.\"\n"
		"#endif\n"
		"\n"
		"#include <stdint.h>\n"
		"#include <stdbool.h>\n"
		"#include <stddef.h>\n"
		"#include <float.h>\n"
		"\n"
		"extern void* malloc(size_t);\n"
		"extern void* calloc(size_t, size_t);\n"
		"extern void* realloc(void*, size_t);\n"
		"extern void* memset(void*, int, size_t);\n"
		"extern void* memcpy(void*, const void*, size_t);\n"
		"extern int memcmp(const void*, const void*, size_t);\n"
		"extern int strcmp(const char*, const char*);\n"
		"extern size_t strlen(const char*);\n"
		"extern void free(void*);\n"
		"extern int read(int, void*, size_t);\n"
		"extern int write(int, const char*, size_t);\n"
		"extern int close(int);\n"
		"extern int open(const char*, int, ...);\n"
		"extern void exit(int);\n"
		"extern int sprintf (char * s, const char * format, ...);\n"
		"\n"
		"typedef uint16_t TAG;\n"
		"#define REFS_FLAG \t 0x8000\n"
		"#define TUP_FLAG \t 0x4000\n"
		"#define TUP_LEN_MASK 0x3FFF\n"
		"#define TUP_LEN_MAX  0x3FFF\n"
		"\n"
		"#define TAG_INT 1\n"
		"#define TAG_PTR 1\n"
		"#define TAG_STR (2 | REFS_FLAG)\n"
		"#define TAG_FNPTR 3\n"
		"#define TAG_F32 4\n"
		"#define TAG_F64 5\n"
		"#define TAG_TUP_NIL TUP_FLAG\n"
		"#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)\n"
		"#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (TAG)(n))\n"
		"\n"
		"typedef uint32_t REFS;\n"
		"typedef uint64_t USIZE;\n"
		"typedef void (*FNPTR)(void);\n"
		"\n"
		"typedef union DATA {\n"
		"\tUSIZE usize;\n"
		"\tuint64_t u64;\n"
		"\tuint32_t u32;\n"
		"\tuint16_t u16;\n"
		"\tuint8_t u8;\n"
		"\tint64_t i64;\n"
		"\tint32_t i32;\n"
		"\tint16_t i16;\n"
		"\tint8_t i8;\n"
		"\tfloat f32;\n"
		"\tdouble f64;\n"
		"\tvoid* ptr;\n"
		"\tFNPTR fnptr;\n"
		"\tREFS* refs;\n"
		"\tstruct TUP* tup;\n"
		"\tstruct STR* str;\n"
		"} DATA;\n"
		"\n"
		"typedef struct VAL {\n"
		"\tDATA data;\n"
		"\tTAG tag;\n"
		"} VAL;\n"
		"\n"
		"#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))\n"
		"\n"
		"#define VREFS(v)  (*(v).data.refs)\n"
		"#define VVAL(v)   (v)\n"
		"#define VINT(v)   ((v).data.i64)\n"
		"#define VI64(v)   ((v).data.i64)\n"
		"#define VI32(v)   ((v).data.i32)\n"
		"#define VI16(v)   ((v).data.i16)\n"
		"#define VI8(v)    ((v).data.i8)\n"
		"#define VU64(v)   ((v).data.u64)\n"
		"#define VU32(v)   ((v).data.u32)\n"
		"#define VU16(v)   ((v).data.u16)\n"
		"#define VU8(v)    ((v).data.u8)\n"
		"#define VBOOL(v)  ((_Bool)((v).data.u64))\n"
		"#define VF32(v)   ((v).data.f32)\n"
		"#define VF64(v)   ((v).data.f64)\n"
		"#define VPTR(v)   ((v).data.ptr)\n"
		"#define VFNPTR(v) ((v).data.fnptr)\n"
		"#define VSTR(v)   ((v).data.str)\n"
		"#define VTUP(v)   ((v).data.tup)\n"
		"#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))\n"
		"\n"
		"#define HAS_REFS(v) ((v).tag & REFS_FLAG)\n"
		"#define IS_VAL(v)   (1)\n"
		"#define IS_INT(v)   ((v).tag == TAG_INT)\n"
		"#define IS_I64(v)   ((v).tag == TAG_INT)\n"
		"#define IS_U64(v)   ((v).tag == TAG_INT)\n"
		"#define IS_BOOL(v)  ((v).tag == TAG_INT)\n"
		"#define IS_F32(v)   ((v).tag == TAG_F32)\n"
		"#define IS_F64(v)   ((v).tag == TAG_F64)\n"
		"#define IS_PTR(v)   ((v).tag == TAG_PTR)\n"
		"#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)\n"
		"#define IS_STR(v)   ((v).tag == TAG_STR)\n"
		"#define IS_TUP(v)   ((v).tag & TUP_FLAG)\n"
		"#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))\n"
		"\n"
		"#define MKVAL(x)   (x)\n"
		"#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI32(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI16(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI8(x)    ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKU32(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKU16(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKU8(x)    ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKBOOL(x)  ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKF32(x)   ((VAL){.tag=TAG_F32, .data={.f32=(x)}})\n"
		"#define MKF64(x)   ((VAL){.tag=TAG_F64, .data={.f64=(x)}})\n"
		"#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})\n"
		"#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})\n"
		"#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})\n"
		"#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})\n"
		"#define MKNIL_C\t         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}\n"
		"#define MKNIL      ((VAL)MKNIL_C)\n"
		"\n"
		"#define STRLIT(v,x,n) \\\n"
		"\tdo { \\\n"
		"\t\tstatic STR* mval = 0; \\\n"
		"\t\tif (!mval) mval = str_make(x,n); \\\n"
		"\t\tincref(MKSTR(mval)); \\\n"
		"\t\tv = mval; \\\n"
		"\t} while(0)\n"
		"\n"
		"typedef uint16_t TUPLEN;\n"
		"typedef struct TUP {\n"
		"\tREFS refs;\n"
		"\tTUPLEN cap;\n"
		"\tTUPLEN size;\n"
		"\tVAL cells[];\n"
		"} TUP;\n"
		"\n"
		"typedef struct STR {\n"
		"\tREFS refs;\n"
		"\tUSIZE cap;\n"
		"\tUSIZE size;\n"
		"\tchar data[];\n"
		"} STR;\n"
		"\n"
		"#define STACK_MAX 0x80000\n"
		"static USIZE stack_counter = STACK_MAX;\n"
		"static VAL stack [STACK_MAX] = {0};\n"
		"static USIZE rstack_counter = STACK_MAX;\n"
		"static VAL rstack [STACK_MAX] = {0};\n"
		"\n"
		"static int global_argc;\n"
		"static char** global_argv;\n"
		"\n"
		"static void push_value(VAL v);\n"
		"static void trace_stack(void);\n"
		"static void trace_rstack(void);\n"
		"\n"
		"#if MIRTH_DEBUG\n"
		"\ttypedef struct LOC {\n"
		"\t\tconst char* word;\n"
		"\t\tconst char* path;\n"
		"\t\tUSIZE line, col;\n"
		"\t\tconst char* atom;\n"
		"\t} LOC;\n"
		"\tstatic USIZE fstack_counter = 0;\n"
		"\tstatic LOC fstack [STACK_MAX] = {\n"
		"\t\t{\n"
		"\t\t\t.word=\"<word>\",\n"
		"\t\t\t.path=\"<path>\",\n"
		"\t\t\t.line=0, .col=0,\n"
		"\t\t\t.atom=\"<atom>\"\n"
		"\t\t},\n"
		"\t};\n"
		"\n"
		"\t#define WORD_ENTER(_w,_p,_l,_c) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tfstack[fstack_counter].word = (_w); \\\n"
		"\t\t\tfstack[fstack_counter].path = (_p); \\\n"
		"\t\t\tfstack[fstack_counter].line = (_l); \\\n"
		"\t\t\tfstack[fstack_counter].col = (_c); \\\n"
		"\t\t\tfstack[fstack_counter].atom = \"\"; \\\n"
		"\t\t\tfstack_counter++; \\\n"
		"\t\t} while(0)\n"
		"\n"
		"\t#define WORD_ATOM(_l,_c,_n) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tif (fstack_counter > 0) { \\\n"
		"\t\t\t\tfstack[fstack_counter-1].line = (_l); \\\n"
		"\t\t\t\tfstack[fstack_counter-1].col = (_c); \\\n"
		"\t\t\t\tfstack[fstack_counter-1].atom = (_n); \\\n"
		"\t\t\t} \\\n"
		"\t\t} while(0)\n"
		"\n"
		"\t#define WORD_EXIT \\\n"
		"\t\tdo { \\\n"
		"\t\t\tif (fstack_counter == 0) { \\\n"
		"\t\t\t\tTRACE(\"mismatched WORD_EXIT\\n\"); \\\n"
		"\t\t\t\texit(1); \\\n"
		"\t\t\t} \\\n"
		"\t\t\tfstack_counter--; \\\n"
		"\t\t} while(0)\n"
		"#endif\n"
		"\n"
		"#define TRACE(x) write(2,x,strlen(x))\n"
		"#define _STR(x) #x\n"
		"#define STR(x) _STR(x)\n"
		"\n"
		"#define EXPECT(test,msg) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\ttrace_stack(); \\\n"
		"\t\t\ttrace_rstack(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define EXPECT1(test,msg,v1) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tpush_value(v1); \\\n"
		"\t\t\ttrace_stack(); \\\n"
		"\t\t\ttrace_rstack(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define EXPECT2(test,msg,v1,v2) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tpush_value(v1); \\\n"
		"\t\t\tpush_value(v2); \\\n"
		"\t\t\ttrace_stack(); \\\n"
		"\t\t\ttrace_rstack(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define ASSERT(test) \\\n"
		"\tEXPECT(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\")\n"
		"#define ASSERT1(test,v) \\\n"
		"\tEXPECT1(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v)\n"
		"#define ASSERT2(test,v1,v2) \\\n"
		"\tEXPECT2(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v1, v2)\n"
		"\n"
		"#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)\n"
		"#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)\n"
		"static void free_value(VAL v) {\n"
		"\tASSERT(HAS_REFS(v));\n"
		"\tASSERT(VREFS(v) == 0);\n"
		"\tASSERT1(IS_TUP(v)||IS_STR(v), v);\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tTUP* tup = VTUP(v);\n"
		"\t\tASSERT(tup);\n"
		"\t\tfor (TUPLEN i = 0; i < tup->size; i++) {\n"
		"\t\t\tdecref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tfree(tup);\n"
		"\t} else if (IS_STR(v)) {\n"
		"\t\tSTR* str = VSTR(v);\n"
		"\t\tASSERT(str);\n"
		"\t\tfree(str);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void tup_decref_outer(TUP* tup, size_t n) {\n"
		"\tif (tup->refs == 1) {\n"
		"\t\tfor (size_t i = n; i < tup->size; i++) {\n"
		"\t\t\tdecref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tfree(tup);\n"
		"\t} else {\n"
		"\t\tfor (size_t i = 0; i < n; i++) {\n"
		"\t\t\tincref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tif (!--tup->refs) free_value(MKTUP(tup,n));\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void value_uncons(VAL val, VAL* tail, VAL* head) {\n"
		"\tif (IS_TUP(val)) {\n"
		"\t\tTUPLEN len = VTUPLEN(val);\n"
		"\t\tTUP* tup = VTUP(val);\n"
		"\t\tASSERT1((len > 0) && tup, val);\n"
		"\t\tVAL tailval = MKTUP(tup, len-1);\n"
		"\t\tVAL headval = tup->cells[len-1];\n"
		"\t\tif (len == 1) {\n"
		"\t\t\tincref(headval);\n"
		"\t\t\tdecref(val);\n"
		"\t\t\ttailval = MKNIL;\n"
		"\t\t} else {\n"
		"\t\t\tif (tup->refs == 1) {\n"
		"\t\t\t\tfor (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }\n"
		"\t\t\t\tmemset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));\n"
		"\t\t\t\ttup->size = len-1;\n"
		"\t\t\t} else {\n"
		"\t\t\t\tincref(headval);\n"
		"\t\t\t}\n"
		"\t\t\tif (len == 2) {\n"
		"\t\t\t\tVAL ptval = tup->cells[0];\n"
		"\t\t\t\tif (!IS_TUP(ptval)) {\n"
		"\t\t\t\t\tincref(ptval);\n"
		"\t\t\t\t\tdecref(tailval);\n"
		"\t\t\t\t\ttailval = ptval;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t\t*tail = tailval;\n"
		"\t\t*head = headval;\n"
		"\t} else {\n"
		"\t\t*tail = MKNIL;\n"
		"\t\t*head = val;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static uint64_t value_u64 (VAL v) {\n"
		"\tASSERT1(IS_INT(v),v);\n"
		"\treturn VU64(v);\n"
		"}\n"
		"\n"
		"static int64_t value_i64 (VAL v) {\n"
		"\tASSERT1(IS_INT(v),v);\n"
		"\treturn VI64(v);\n"
		"}\n"
		"\n"
		"static float value_f32 (VAL v) {\n"
		"\tASSERT1(IS_F32(v), v);\n"
		"\treturn VF32(v);\n"
		"}\n"
		"\n"
		"static double value_f64 (VAL v) {\n"
		"\tASSERT1(IS_F64(v), v);\n"
		"\treturn VF64(v);\n"
		"}\n"
		"\n"
		"static void* value_ptr (VAL v) {\n"
		"\tASSERT1(IS_PTR(v),v);\n"
		"\treturn VPTR(v);\n"
		"}\n"
		"\n"
		"static FNPTR value_fnptr (VAL v) {\n"
		"\tASSERT1(IS_FNPTR(v),v);\n"
		"\treturn VFNPTR(v);\n"
		"}\n"
		"\n"
		"static STR* value_str (VAL v) {\n"
		"\tASSERT1(IS_STR(v),v);\n"
		"\treturn VSTR(v);\n"
		"}\n"
		"\n"
		"#define pop_u8() ((uint8_t)pop_u64())\n"
		"#define pop_u16() ((uint16_t)pop_u64())\n"
		"#define pop_u32() ((uint32_t)pop_u64())\n"
		"#define pop_u64() (value_u64(pop_value()))\n"
		"#define pop_i8() ((int8_t)pop_i64())\n"
		"#define pop_i16() ((int16_t)pop_i64())\n"
		"#define pop_i32() ((int32_t)pop_i64())\n"
		"#define pop_i64() (value_i64(pop_value()))\n"
		"#define pop_usize() (pop_u64())\n"
		"#define pop_f32() (value_f32(pop_value()))\n"
		"#define pop_f64() (value_f64(pop_value()))\n"
		"#define pop_bool() ((bool)pop_u64())\n"
		"#define pop_str() (value_str(pop_value()))\n"
		"#define pop_ptr() (value_ptr(pop_value()))\n"
		"#define pop_fnptr() (value_fnptr(pop_value()))\n"
		"\n"
		"#define push_u64(v) push_value(MKU64(v))\n"
		"#define push_i64(v) push_value(MKI64(v))\n"
		"#define push_usize(v) push_u64((uint64_t)(v))\n"
		"#define push_bool(b) push_u64((uint64_t)((bool)(b)))\n"
		"#define push_u8(b) push_u64((uint64_t)(b))\n"
		"#define push_u16(b) push_u64((uint64_t)(b))\n"
		"#define push_u32(b) push_u64((uint64_t)(b))\n"
		"#define push_i8(b) push_i64((int64_t)(b))\n"
		"#define push_i16(b) push_i64((int64_t)(b))\n"
		"#define push_i32(b) push_i64((int64_t)(b))\n"
		"#define push_f32(f) push_value(MKF32(f))\n"
		"#define push_f64(f) push_value(MKF64(f))\n"
		"#define push_str(p) push_value(MKSTR(p))\n"
		"#define push_ptr(p) push_value(MKPTR(p))\n"
		"#define push_fnptr(p) push_value(MKFNPTR(p))\n"
		"\n"
		"static void push_value(VAL x) {\n"
		"\tASSERT(stack_counter > 0);\n"
		"\tstack[--stack_counter] = x;\n"
		"}\n"
		"\n"
		"static VAL top_value(void) {\n"
		"\tASSERT(stack_counter < STACK_MAX);\n"
		"\treturn stack[stack_counter];\n"
		"}\n"
		"\n"
		"static VAL pop_value(void) {\n"
		"\tASSERT(stack_counter < STACK_MAX);\n"
		"\treturn stack[stack_counter++];\n"
		"}\n"
		"\n"
		"static void push_resource(VAL x) {\n"
		"\tASSERT(rstack_counter > 0);\n"
		"\trstack[--rstack_counter] = x;\n"
		"}\n"
		"\n"
		"static VAL top_resource(void) {\n"
		"\tASSERT(rstack_counter < STACK_MAX);\n"
		"\treturn rstack[rstack_counter];\n"
		"}\n"
		"\n"
		"static VAL pop_resource(void) {\n"
		"\tASSERT(rstack_counter < STACK_MAX);\n"
		"\treturn rstack[rstack_counter++];\n"
		"}\n"
		"\n"
		"// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.\n"
		"static TUP* tup_new (TUPLEN cap_hint) {\n"
		"\tif (cap_hint < 3) cap_hint = 3;\n"
		"\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
		"\tTUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
		"\tASSERT(new_tup);\n"
		"\tnew_tup->refs = 1;\n"
		"\tnew_tup->cap = cap_hint;\n"
		"\treturn new_tup;\n"
		"}\n"
		"\n"
		"// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.\n"
		"// Consume old_tup and copy its elements over to the new tuple.\n"
		"static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {\n"
		"\tASSERT(old_tup);\n"
		"\tif (cap_hint < old_tup->size) cap_hint = old_tup->size;\n"
		"\tif (old_tup->refs == 1) {\n"
		"\t\tif (cap_hint < 3) cap_hint = 3;\n"
		"\t\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
		"\t\tTUPLEN old_cap = old_tup->cap;\n"
		"\t\tTUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
		"\t\tASSERT(new_tup);\n"
		"\t\tif (old_cap < cap_hint) {\n"
		"\t\t\tmemset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));\n"
		"\t\t}\n"
		"\t\tnew_tup->cap = cap_hint;\n"
		"\t\treturn new_tup;\n"
		"\t} else {\n"
		"\t\tTUP* new_tup = tup_new(cap_hint);\n"
		"\t\tfor (TUPLEN i = 0; i < old_tup->size; i++) {\n"
		"\t\t\tVAL v = old_tup->cells[i];\n"
		"\t\t\tnew_tup->cells[i] = v;\n"
		"\t\t\tincref(v);\n"
		"\t\t}\n"
		"\t\tnew_tup->size = old_tup->size;\n"
		"\t\told_tup->refs--;\n"
		"\t\treturn new_tup;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static VAL tup_replace (VAL tup, TUPLEN i, VAL v) {\n"
		"\tASSERT(IS_TUP(tup));\n"
		"\tTUPLEN n = VTUPLEN(tup);\n"
		"\tASSERT(i < n);\n"
		"\tif (VTUP(tup)->refs > 1) {\n"
		"\t\tTUP* newtup = tup_new(n);\n"
		"\t\tnewtup->size = n;\n"
		"\t\tmemcpy(newtup->cells, VTUP(tup)->cells, n*sizeof(VAL));\n"
		"\t\tfor (TUPLEN j=0; j<n; j++) incref(newtup->cells[j]);\n"
		"\t\tdecref(tup);\n"
		"\t\ttup = MKTUP(newtup, n);\n"
		"\t}\n"
		"\tVAL u = VTUP(tup)->cells[i];\n"
		"\tVTUP(tup)->cells[i] = v;\n"
		"\tdecref(u);\n"
		"\treturn tup;\n"
		"}\n"
		"\n"
		"static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {\n"
		"\tif (IS_TUP(tail) && HAS_REFS(tail)) {\n"
		"\t\tTUPLEN tail_len = VTUPLEN(tail);\n"
		"\t\tTUP *tail_tup = VTUP(tail);\n"
		"\t\tASSERT1(tail_tup, tail);\n"
		"\t\tASSERT1(tail_len <= tail_tup->size, tail);\n"
		"\t\tif (tail_len < tail_tup->size) {\n"
		"\t\t\tASSERT1(tail_tup->refs >= 1, tail);\n"
		"\t\t\tif (tail_tup->refs == 1) {\n"
		"\t\t\t\tdecref(tail_tup->cells[tail_len]);\n"
		"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
		"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t} else {\n"
		"\t\t\t\tVAL *cmp = &tail_tup->cells[tail_len];\n"
		"\t\t\t\tif (VALEQ(*cmp, head)) {\n"
		"\t\t\t\t\tdecref(head);\n"
		"\t\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t\t} else {\n"
		"\t\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
		"\t\t\t\t\tTUP* new_tup = tup_new(cap_hint);\n"
		"\t\t\t\t\tfor (TUPLEN i = 0; i < tail_len; i++) {\n"
		"\t\t\t\t\t\tVAL v = tail_tup->cells[i];\n"
		"\t\t\t\t\t\tnew_tup->cells[i] = v;\n"
		"\t\t\t\t\t\tincref(v);\n"
		"\t\t\t\t\t}\n"
		"\t\t\t\t\tnew_tup->cells[tail_len] = head;\n"
		"\t\t\t\t\tnew_tup->size = tail_len+1;\n"
		"\t\t\t\t\ttail_tup->refs--;\n"
		"\t\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t} else {\n"
		"\t\t\tASSERT1(tail_len < TUP_LEN_MAX, tail);\n"
		"\t\t\tASSERT1(tail_len <= tail_tup->cap, tail);\n"
		"\t\t\tif (tail_len < tail_tup->cap) {\n"
		"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
		"\t\t\t\ttail_tup->size = tail_len+1;\n"
		"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t} else {\n"
		"\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
		"\t\t\t\tTUP* new_tup = tup_resize(tail_tup, cap_hint);\n"
		"\t\t\t\tASSERT(tail_len < new_tup->cap);\n"
		"\t\t\t\tnew_tup->size = tail_len+1;\n"
		"\t\t\t\tnew_tup->cells[tail_len] = head;\n"
		"\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t} else if (IS_TUP(tail)) { // cons onto nil\n"
		"\t\tASSERT(IS_NIL(tail));\n"
		"\t\tif (IS_TUP(head)) {\n"
		"\t\t\tTUP* tup = tup_new(cap_hint);\n"
		"\t\t\ttup->size = 1;\n"
		"\t\t\ttup->cells[0] = head;\n"
		"\t\t\treturn MKTUP(tup,1);\n"
		"\t\t} else { // non-tup value pretends to be unary tuple\n"
		"\t\t\treturn head;\n"
		"\t\t}\n"
		"\t} else { // cons onto non-tup value pretending to be unary tuple\n"
		"\t\tTUP* tup = tup_new(cap_hint);\n"
		"\t\ttup->size = 2;\n"
		"\t\ttup->cells[0] = tail;\n"
		"\t\ttup->cells[1] = head;\n"
		"\t\treturn MKTUP(tup,2);\n"
		"\t}\n"
		"}\n"
		"static VAL mkcons(VAL tail, VAL head) {\n"
		"\tVAL v = mkcons_hint(tail,head,3);\n"
		"\treturn v;\n"
		"}\n"
		"\n"
		"static VAL lpop(VAL* stk) {\n"
		"\tVAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);\n"
		"\t*stk=lcar; return lcdr;\n"
		"}\n"
		"static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }\n"
		"#define LPOP(v) push_value(lpop(&(v)))\n"
		"#define LPUSH(v) lpush(&(v),pop_value())\n"
		"#define LPOPR(v) push_resource(lpop(&(v)))\n"
		"#define LPUSHR(v) lpush(&(v),pop_resource())\n"
		"\n"
		"static STR* str_alloc (USIZE cap) {\n"
		"\tASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);\n"
		"\tSTR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));\n"
		"\tEXPECT(str, \"failed to allocate string\");\n"
		"\tstr->refs = 1;\n"
		"\tstr->cap = cap;\n"
		"\treturn str;\n"
		"}\n"
		"\n"
		"static STR* str_make (const char* data, USIZE size) {\n"
		"\tASSERT(data);\n"
		"\tASSERT(size <= SIZE_MAX - sizeof(STR) - 4);\n"
		"\tSTR* str = str_alloc(size);\n"
		"\tstr->size = size;\n"
		"\tmemcpy(str->data, data, (size_t)size);\n"
		"\treturn str;\n"
		"}\n"
		"#define mkstr(x,n) MKSTR(str_make((x), (n)))\n"
		"\n"
		"static STR* str_cat (STR* s1, STR* s2) {\n"
		"\tEXPECT(s1 && s2, \"invalid strings in prim-str-cat\");\n"
		"\tUSIZE m = s1->cap;\n"
		"\tUSIZE n1 = s1->size;\n"
		"\tUSIZE n2 = s2->size;\n"
		"\tif ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {\n"
		"\t\tASSERT(n2 <= SIZE_MAX);\n"
		"\t\tmemcpy(s1->data + n1, s2->data, (size_t)n2);\n"
		"\t\ts1->size += n2;\n"
		"\t\tASSERT(s1->size + 4 <= s1->cap);\n"
		"\t\tdecref(MKSTR(s2));\n"
		"\t\treturn s1;\n"
		"\t} else {\n"
		"\t\tUSIZE m2 = n1 + n2 + 4;\n"
		"\t\tif ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;\n"
		"\t\tSTR* str = str_alloc(m2);\n"
		"\t\tstr->size = n1+n2;\n"
		"\t\tASSERT(n1 <= SIZE_MAX);\n"
		"\t\tASSERT(n2 <= SIZE_MAX);\n"
		"\t\tmemcpy(str->data, s1->data, (size_t)n1);\n"
		"\t\tmemcpy(str->data+n1, s2->data, (size_t)n2);\n"
		"\t\tdecref(MKSTR(s1));\n"
		"\t\tdecref(MKSTR(s2));\n"
		"\t\treturn str;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static USIZE get_data_tag(VAL v) {\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tASSERT(VTUPLEN(v) > 0);\n"
		"\t\treturn VU64(VTUP(v)->cells[0]);\n"
		"\t} else {\n"
		"\t\treturn VU64(v);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static USIZE get_top_data_tag(void) {\n"
		"\treturn get_data_tag(top_value());\n"
		"}\n"
		"\n"
		"static USIZE get_top_resource_data_tag(void) {\n"
		"\treturn get_data_tag(top_resource());\n"
		"}\n"
		"\n"
		"static int str_cmp(STR* s1, STR* s2) {\n"
		"\tASSERT(s1 && s2);\n"
		"\tUSIZE n1 = s1->size;\n"
		"\tUSIZE n2 = s2->size;\n"
		"\tUSIZE n = (n1 < n2 ? n1 : n2);\n"
		"\tASSERT(n < SIZE_MAX);\n"
		"\tint r = memcmp(s1->data, s2->data, (size_t)n);\n"
		"\tdecref(MKSTR(s1));\n"
		"\tdecref(MKSTR(s2));\n"
		"\tif (r) return r;\n"
		"\tif (n1 < n2) return -1;\n"
		"\tif (n1 > n2) return 1;\n"
		"\treturn 0;\n"
		"}\n"
		"\n"
		"static void run_value(VAL v) {\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tVAL h = VTUP(v)->cells[0];\n"
		"\t\tASSERT(IS_FNPTR(h));\n"
		"\t\tpush_value(v);\n"
		"\t\tVFNPTR(h)();\n"
		"\t} else {\n"
		"\t\tASSERT(IS_FNPTR(v));\n"
		"\t\tVFNPTR(v)();\n"
		"\t}\n"
		"}\n"
		"\n"
		"static int64_t i64_add (int64_t a, int64_t b) {\n"
		"\tEXPECT(((b >= 0) && (a <= INT64_MAX - b))\n"
		"\t\t|| ((b <  0) && (a >= INT64_MIN - b)),\n"
		"\t\t\"overflow during integer addition\");\n"
		"\treturn a + b;\n"
		"}\n"
		"\n"
		"static int64_t i64_sub (int64_t a, int64_t b) {\n"
		"\tEXPECT(((b >= 0) && (a >= INT64_MIN + b))\n"
		"\t\t|| ((b <  0) && (a <= INT64_MAX + b)),\n"
		"\t\t\"overflow during integer subtraction\");\n"
		"\treturn a - b;\n"
		"}\n"
		"\n"
		"static int64_t i64_mul (int64_t a, int64_t b) {\n"
		"\tEXPECT((a == 0) || (b == 0) ||\n"
		"\t\t((a > 0) && (b > 0) && (a <= INT64_MAX/b)) ||\n"
		"\t\t((a > 0) && (b < 0) && (a <= INT64_MIN/b)) ||\n"
		"\t\t((a < 0) && (b > 0) && (a >= INT64_MIN/b)) ||\n"
		"\t\t((a < 0) && (b < 0) && (a >= INT64_MAX/b)),\n"
		"\t\t\"overflow during integer multiplication\"\n"
		"\t);\n"
		"\treturn a * b;\n"
		"}\n"
		"\n"
		"static int64_t i64_div (int64_t a, int64_t b) {\n"
		"\tEXPECT(b != 0, \"divide by zero\");\n"
		"\tEXPECT(!((b == -1) && (a == INT64_MIN)), \"overflow during integer division\");\n"
		"\tint64_t r = a % b;\n"
		"\tint64_t q = a / b;\n"
		"\tif (((a < 0) ^ (b < 0)) && r) q--;\n"
		"\treturn q;\n"
		"}\n"
		"\n"
		"static int64_t i64_mod (int64_t a, int64_t b) {\n"
		"\tEXPECT(b != 0, \"divide by zero\");\n"
		"\tEXPECT(!((b == -1) && (a == INT64_MIN)), \"overflow during integer division\");\n"
		"\tint64_t r = a % b;\n"
		"\tint64_t q = a / b;\n"
		"\tif (((a < 0) ^ (b < 0)) && r) r += b;\n"
		"\treturn r;\n"
		"}\n"
		"\n"
		"static uint64_t u64_shl (uint64_t a, uint64_t b) {\n"
		"\tif (b >= 64) return 0;\n"
		"\treturn (a << b);\n"
		"}\n"
		"\n"
		"static uint64_t u64_shr (uint64_t a, uint64_t b) {\n"
		"\tif (b >= 64) return 0;\n"
		"\treturn (a >> b);\n"
		"}\n"
		"\n"
		"static STR* f32_show (float d) {\n"
		" \tchar result[DBL_DIG+32] = {0};\n"
		"\tint len = sprintf(result, \"%.*g\", DBL_DIG, d);\n"
		"\treturn str_make(result, len);\n"
		"}\n"
		"\n"
		"static STR* f64_show (double d) {\n"
		" \tchar result[DBL_DIG+32] = {0};\n"
		"\tint len = sprintf(result, \"%.*g\", DBL_DIG, d);\n"
		"\treturn str_make(result, len);\n"
		"}\n"
		"\n"
		"void int_repr(int64_t y, char** out_ptr, size_t *out_size) {\n"
		"\tstatic char c[32] = {0};\n"
		"\tmemset(c, 0, 32);\n"
		"\tchar* p = c+30;\n"
		"\tsize_t n = 0;\n"
		"\tuint64_t x;\n"
		"\tif (y < 0) {\n"
		"\t\tif (y == INT64_MIN) {\n"
		"\t\t\tx = 1+(uint64_t)INT64_MAX;\n"
		"\t\t} else {\n"
		"\t\t\tx = (uint64_t)-y;\n"
		"\t\t}\n"
		"\t} else {\n"
		"\t\tx = (uint64_t)y;\n"
		"\t}\n"
		"\tdo {\n"
		"\t\t*--p = '0' + (x % 10);\n"
		"\t\tx /= 10;\n"
		"\t\tn++;\n"
		"\t} while (x);\n"
		"\tif (y < 0) {\n"
		"\t\t*--p = '-';\n"
		"\t\tn++;\n"
		"\t}\n"
		"\t*out_ptr = p;\n"
		"\t*out_size = n;\n"
		"}\n"
		"\n"
		"void int_trace_(int64_t y, int fd) {\n"
		"\tchar* p; size_t n;\n"
		"\tint_repr(y, &p, &n);\n"
		"\twrite(fd, p, n);\n"
		"}\n"
		"\n"
		"STR* i64_show (int64_t x) {\n"
		"\tbool cache = (0 <= x) && (x <= 255);\n"
		"\tstatic STR* scache[256] = {0};\n"
		"\tif (cache && scache[x]) {\n"
		"\t\tSTR* s = scache[x];\n"
		"\t\tincref(MKSTR(s));\n"
		"\t\treturn s;\n"
		"\t} else {\n"
		"\t\tchar* p; size_t n;\n"
		"\t\tint_repr(x,&p,&n);\n"
		"\t\tSTR* s = str_make(p,n);\n"
		"\t\tif (cache) {\n"
		"\t\t\tscache[x] = s;\n"
		"\t\t\tincref(MKSTR(s));\n"
		"\t\t}\n"
		"\t\treturn s;\n"
		"\t}\n"
		"}\n"
		"\n"
		"void str_trace_(STR* str, int fd) {\n"
		"\tASSERT(str->size <= SIZE_MAX);\n"
		"\twrite(fd, \"\\\"\", 1);\n"
		"\tUSIZE i0 = 0;\n"
		"\tchar xb[4]={'\\\\','x'};\n"
		"\tUSIZE i;\n"
		"\tfor (i = 0; i < str->size; i++) {\n"
		"\t\tconst char* c = NULL; size_t n=0;\n"
		"\t\tuint8_t v=str->data[i];\n"
		"\t\tswitch(v) {\n"
		"\t\t\tcase '\\n': c=\"\\\\n\"; n=2; break;\n"
		"\t\t\tcase '\\r': c=\"\\\\r\"; n=2; break;\n"
		"\t\t\tcase '\\t': c=\"\\\\t\"; n=2; break;\n"
		"\t\t\tcase '\\\\': c=\"\\\\\\\\\"; n=2; break;\n"
		"\t\t\tcase '\\\"': c=\"\\\\\\\"\"; n=2; break;\n"
		"\t\t\tdefault:\n"
		"\t\t\t\tif (!((' ' <= v) && (v < 0x7F))) {\n"
		"\t\t\t\t\txb[2] = '0' + (v&15) + ('A'-'9'-1)*((v&15) > 9);\n"
		"\t\t\t\t\txb[3] = '0' + (v/16) + ('A'-'9'-1)*((v/16) > 9);\n"
		"\t\t\t\t\tc=xb; n=4;\n"
		"\t\t\t\t}\n"
		"\t\t}\n"
		"\t\tif ((n > 0) && (i0 < i)) {\n"
		"\t\t\twrite(fd, str->data+i0, (size_t)(i-i0));\n"
		"\t\t\ti0=i+1;\n"
		"\t\t}\n"
		"\t\twrite(fd, c, n);\n"
		"\t}\n"
		"\tif (i0 < i) write(fd, str->data+i0, (size_t)(i-i0));\n"
		"\twrite(fd, \"\\\"\", 1);\n"
		"}\n"
		"\n"
		"void value_trace_(VAL val, int fd) {\n"
		"\tif (IS_INT(val)) {\n"
		"\t\tint_trace_(VINT(val), fd);\n"
		"\t} else if (IS_STR(val)) {\n"
		"\t\tstr_trace_(VSTR(val), fd);\n"
		"\t} else if (IS_FNPTR(val)) {\n"
		"\t\twrite(fd, \"<fnptr>\", 7);\n"
		"\t} else if (IS_TUP(val)) {\n"
		"\t\tTUPLEN len = VTUPLEN(val);\n"
		"\t\tTUP* tup = VTUP(val);\n"
		"\t\tif (VTUPLEN(val) == 0) {\n"
		"\t\t\twrite(fd, \"[]\", 2);\n"
		"\t\t} else {\n"
		"\t\t\twrite(fd, \"[ \", 2);\n"
		"\t\t\tfor(TUPLEN i = 0; i < len; i++) {\n"
		"\t\t\t\tif (i > 0) write(fd, \" \", 1);\n"
		"\t\t\t\tvalue_trace_(tup->cells[i], fd);\n"
		"\t\t\t}\n"
		"\t\t\twrite(fd, \" ]\", 2);\n"
		"\t\t}\n"
		"\t} else {\n"
		"\t\tTRACE(\"value cannot be traced\");\n"
		"\t\texit(1);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void trace_stack (void) {\n"
		"\tTRACE(\"??\");\n"
		"\tfor (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {\n"
		"\t\tTRACE(\" \");\n"
		"\t\tvalue_trace_(stack[i], 2);\n"
		"\t}\n"
		"\tTRACE(\"\\n\");\n"
		"}\n"
		"\n"
		"static void trace_rstack (void) {\n"
		"\t#if MIRTH_DEBUG\n"
		"\t\tTRACE(\"call stack:\\n\");\n"
		"\t\tfor (USIZE i = fstack_counter; i --> 1;) {\n"
		"\t\t\tTRACE(\"    \");\n"
		"\t\t\tif (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {\n"
		"\t\t\t\tTRACE(fstack[i-1].atom);\n"
		"\t\t\t\tTRACE(\" -> \");\n"
		"\t\t\t}\n"
		"\t\t\tTRACE(fstack[i].word);\n"
		"\t\t\tTRACE(\" at \");\n"
		"\t\t\tTRACE(fstack[i-1].path);\n"
		"\t\t\tTRACE(\":\");\n"
		"\t\t\tint_trace_((int64_t)fstack[i-1].line, 2);\n"
		"\t\t\tTRACE(\":\");\n"
		"\t\t\tint_trace_((int64_t)fstack[i-1].col, 2);\n"
		"\t\t\tTRACE(\"\\n\");\n"
		"\t\t}\n"
		"\t#endif\n"
		"}\n"
		"\n"
		"static void do_panic(STR* m) {\n"
		"\tif (m) {\n"
		"\t\tsize_t n = (m->size < 2048) ? (size_t)(m->size) : 2048;\n"
		"\t\twrite(2, m->data, n);\n"
		"\t\tTRACE(\"\\n\");\n"
		"\t} else {\n"
		"\t\tTRACE(\"panic!\\n\");\n"
		"\t}\n"
		"\ttrace_stack();\n"
		"\ttrace_rstack();\n"
		"\texit(1);\n"
		"}\n"
		"\n"
		"#if defined(MIRTH_WINDOWS)\n"
		"#define RUNNING_OS 1\n"
		"#elif defined(MIRTH_LINUX)\n"
		"#define RUNNING_OS 2\n"
		"#elif defined(MIRTH_MACOS)\n"
		"#define RUNNING_OS 3\n"
		"#else\n"
		"#define RUNNING_OS 0\n"
		"#endif\n"
		"\n"
		"#if defined(MIRTH_I386)\n"
		"#define RUNNING_ARCH 1\n"
		"#elif defined(MIRTH_AMD64)\n"
		"#define RUNNING_ARCH 2\n"
		"#elif defined(MIRTH_ARM64)\n"
		"#define RUNNING_ARCH 3\n"
		"#else\n"
		"#define RUNNING_ARCH 0\n"
		"#endif\n"
		"\n"
		"static void* ptr_alloc (uint64_t n) {\n"
		"\tEXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), \"invalid size in prim-ptr-alloc\");\n"
		"\tvoid* p = malloc((size_t)n);\n"
		"\tEXPECT(p, \"failed to allocate in prim-ptr-alloc\");\n"
		"\treturn p;\n"
		"}\n"
		"\n"
		"static void* ptr_realloc (void* p, uint64_t n) {\n"
		"\tEXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), \"invalid size in prim-ptr-realloc\");\n"
		"\tvoid* p2 = realloc(p, (size_t)n);\n"
		"\tEXPECT(p2, \"failed to reallocate in prim-ptr-realloc\");\n"
		"\treturn p2;\n"
		"}\n"
		"\n"
		"static void ptr_copy (void* src, uint64_t len, void* dst) {\n"
		"\tif (len > 0) {\n"
		"\t\tEXPECT(len <= SIZE_MAX, \"invalid size in prim-ptr-copy\");\n"
		"\t\tEXPECT(src && dst, \"invalid pointer in prim-ptr-copy\");\n"
		"\t\tmemcpy(dst, src, (size_t)len);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void ptr_fill (uint8_t val, uint64_t len, void* dst) {\n"
		"\tif (len > 0) {\n"
		"\t\tEXPECT(len <= SIZE_MAX, \"invalid size in prim-ptr-fill\");\n"
		"\t\tEXPECT(dst, \"invalid pointer in prim-ptr-fill\");\n"
		"\t\tmemset(dst, (int)val, (size_t)len);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void* str_base (STR* s) {\n"
		"\tEXPECT(s && (s->refs > 1), \"invalid string for prim-str-base\");\n"
		"\ts->refs--;\n"
		"\treturn s->data;\n"
		"}\n"
		"\n"
		"static uint64_t str_size (STR* s) {\n"
		"\tEXPECT(s, \"invalid string for prim-str-size\");\n"
		"\tuint64_t n = s->size;\n"
		"\tdecref(MKSTR(s));\n"
		"\treturn n;\n"
		"}\n"
		"\n"
		"static VAL mut_get (void* mut) {\n"
		"\tEXPECT(mut, \"invalid pointer in prim-mut-get\");\n"
		"\tVAL v = *(VAL*)mut;\n"
		"\tEXPECT(v.tag, \"tried to read uninitialized value\");\n"
		"\tincref(v);\n"
		"\treturn v;\n"
		"}\n"
		"\n"
		"static void mut_set (VAL newval, void* mut) {\n"
		"\tEXPECT(mut, \"invalid pointer in prim-mut-set\");\n"
		"\tVAL oldval = *(VAL*)mut;\n"
		"\t*(VAL*)mut = newval;\n"
		"\tif (oldval.tag) {\n"
		"\t\tdecref(oldval);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static bool mut_is_set (void* mut) {\n"
		"\tEXPECT(mut, \"invalid pointer in prim-mut-is-set\");\n"
		"\tVAL val = *(VAL*)mut;\n"
		"\treturn (val.tag != 0);\n"
		"}\n"
		"\n"
		"/* GENERATED C99 */\n",
		23868
	);
	return MKSTR(v1);
}
static VAL mw_mirth_c99_c99Z_headerZBang (VAL x1) {
	STR* v2;
	STRLIT(v2, "#define MIRTH_DEBUG ", 20);
	VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v2), x1));
	VAL v4 = VVAL(VTUP(v3)->cells[1]);
	incref(v4);
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	decref(v4);
	VAL x6;
	VAL x7;
	if (((bool)v5)) {
		STR* v8;
		STRLIT(v8, "1", 1);
		x7 = MKSTR(v8);
		x6 = v3;
	} else {
		STR* v9;
		STRLIT(v9, "0", 1);
		x7 = MKSTR(v9);
		x6 = v3;
	}
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(x7, x6));
	VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
	VAL v12 = mw_mirth_c99_c99Z_headerZ_str();
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(v12, v11));
	VAL v14 = (mw_mirth_c99_ZPlusC99_line(v13));
	return v14;
}
static VAL mw_mirth_c99_c99Z_buffersZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_buffer_Buffer_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_bufferZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_buffer_Buffer_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_bufferZBang (uint64_t x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "static char ", 12);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	VAL v5 = (VVAL(VTUP(v4)->cells[6]));
	VAL v6;
	VAL v7;
	mw_mirth_buffer_Buffer_cname(v5, x1, &v6, &v7);
	VTUP(v4)->cells[6] = v6;
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(v7, v4));
	STR* v9;
	STRLIT(v9, "[", 1);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	int64_t v11 = mw_mirth_buffer_Buffer_sizze(x1);
	STR* v12 = i64_show(v11);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v10));
	STR* v14;
	STRLIT(v14, "] = {0};", 8);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
	VAL v16 = (mw_mirth_c99_ZPlusC99_line(v15));
	return v16;
}
static VAL mw_mirth_c99_c99Z_bufferZ_callZBang (uint64_t x1, VAL x2) {
	int64_t v3 = 13LL /* C99RT_PTR */;
	VAL v4 = (VVAL(VTUP(x2)->cells[1]));
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v4, &v5, &v6);
	VAL v7 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v3, v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v6));
	int64_t v9 = VI64(VTUP(v7)->cells[1]);
	VAL v10 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v9);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v8));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL v14 = VVAL(VTUP(v7)->cells[2]);
	incref(v14);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(v14, v13));
	STR* v16;
	STRLIT(v16, " = ", 3);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = (VVAL(VTUP(v17)->cells[6]));
	VAL v19;
	VAL v20;
	mw_mirth_buffer_Buffer_cname(v18, x1, &v19, &v20);
	VTUP(v17)->cells[6] = v19;
	VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v17));
	STR* v22;
	STRLIT(v22, ";", 1);
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
	VAL v24 = (mw_mirth_c99_ZPlusC99_line(v23));
	VTUP(x2)->cells[1] = v24;
	VAL v25 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v7));
	return v25;
}
static VAL mw_mirth_c99_c99Z_variablesZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_variable_Variable_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_variableZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_variable_Variable_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_variableZBang (uint64_t x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "static VAL ", 11);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	VAL v5 = (VVAL(VTUP(v4)->cells[6]));
	VAL v6;
	VAL v7;
	mw_mirth_variable_Variable_cname(v5, x1, &v6, &v7);
	VTUP(v4)->cells[6] = v6;
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(v7, v4));
	STR* v9;
	STRLIT(v9, " = {0};", 7);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
	return v11;
}
static VAL mw_mirth_c99_c99Z_variableZ_callZBang (uint64_t x1, VAL x2) {
	int64_t v3 = 13LL /* C99RT_PTR */;
	VAL v4 = (VVAL(VTUP(x2)->cells[1]));
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v4, &v5, &v6);
	VAL v7 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v3, v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v6));
	int64_t v9 = VI64(VTUP(v7)->cells[1]);
	VAL v10 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v9);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v8));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL v14 = VVAL(VTUP(v7)->cells[2]);
	incref(v14);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(v14, v13));
	STR* v16;
	STRLIT(v16, " = ", 3);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	STR* v18;
	STRLIT(v18, "&", 1);
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
	VAL v20 = (VVAL(VTUP(v19)->cells[6]));
	VAL v21;
	VAL v22;
	mw_mirth_variable_Variable_cname(v20, x1, &v21, &v22);
	VTUP(v19)->cells[6] = v21;
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(v22, v19));
	STR* v24;
	STRLIT(v24, ";", 1);
	VAL v25 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v24), v23));
	VAL v26 = (mw_mirth_c99_ZPlusC99_line(v25));
	VTUP(x2)->cells[1] = v26;
	VAL v27 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v7));
	return v27;
}
static VAL mw_mirth_c99_c99Z_tagZ_defsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_data_Tag_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_tagZ_defZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_data_Tag_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_tagZ_bodyZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	VAL v6;
	mw_mirth_data_Tag_semiZ_transparentZAsk(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VTUP(x2)->cells[1] = v3;
	uint64_t x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v10 = VVAL(VTUP(v9)->cells[2]);
			incref(v10);
			decref(v9);
			uint64_t x11;
			VAL x12;
			switch (get_data_tag(v10)) {
				case 1LL: { // STPConsLabel
					VAL v13;
					uint64_t v14;
					mtp_mirth_type_StackTypePart_STPConsLabel(v10, &v13, &v14);
					int64_t v15;
					VAL v16;
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v13, x2, &v15, &v16);
					VAL v17;
					VAL v18;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v15, v14, v16, &v17, &v18);
					int64_t v19 = mw_mirth_data_Tag_outputsZ_resourceZAsk(x1);
					uint64_t x20;
					VAL x21;
					if (((bool)v19)) {
						VAL v22 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v18));
						VAL v23 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v17, v22));
						x21 = v23;
						x20 = x1;
					} else {
						VAL v24 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v17, v18));
						x21 = v24;
						x20 = x1;
					}
					x12 = x21;
					x11 = x20;
				} break;
				case 3LL: { // STPWithLabel
					VAL v25;
					uint64_t v26;
					mtp_mirth_type_StackTypePart_STPWithLabel(v10, &v25, &v26);
					int64_t v27;
					VAL v28;
					mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v25, x2, &v27, &v28);
					VAL v29;
					VAL v30;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v27, v26, v28, &v29, &v30);
					VAL v31 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v29, v30));
					x12 = v31;
					x11 = x1;
				} break;
				case 0LL: { // STPCons
					VAL v32 = mtp_mirth_type_StackTypePart_STPCons(v10);
					int64_t v33;
					VAL v34;
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v32, x2, &v33, &v34);
					VAL v35;
					VAL v36;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v34, v33, &v35, &v36);
					int64_t v37 = mw_mirth_data_Tag_outputsZ_resourceZAsk(x1);
					uint64_t x38;
					VAL x39;
					if (((bool)v37)) {
						VAL v40 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v36));
						VAL v41 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v35, v40));
						x39 = v41;
						x38 = x1;
					} else {
						VAL v42 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v35, v36));
						x39 = v42;
						x38 = x1;
					}
					x12 = x39;
					x11 = x38;
				} break;
				case 2LL: { // STPWith
					VAL v43 = mtp_mirth_type_StackTypePart_STPWith(v10);
					int64_t v44;
					VAL v45;
					mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v43, x2, &v44, &v45);
					VAL v46;
					VAL v47;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v45, v44, &v46, &v47);
					VAL v48 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v46, v47));
					x12 = v48;
					x11 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x12;
			x7 = x11;
		} break;
		case 0LL: { // None
			int64_t v49 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
			int64_t v50 = 0LL;
			bool v51 = (v49 == v50);
			uint64_t x52;
			VAL x53;
			if (v51) {
				uint64_t v54 = mw_mirth_data_Tag_data(x1);
				int64_t v55 = mw_mirth_data_Data_isZ_enumZ_orZ_unitZAsk(v54);
				VAL x56;
				uint64_t x57;
				int64_t x58;
				VAL x59;
				VAL x60;
				if (((bool)v55)) {
					int64_t v61 = 2LL /* C99RT_I64 */;
					STR* v62;
					STRLIT(v62, "", 0);
					STR* v63;
					STRLIT(v63, "", 0);
					x60 = MKSTR(v63);
					x59 = MKSTR(v62);
					x58 = v61;
					x57 = x1;
					x56 = x2;
				} else {
					int64_t v64 = 0LL /* C99RT_VAL */;
					STR* v65;
					STRLIT(v65, "MKI64(", 6);
					STR* v66;
					STRLIT(v66, ")", 1);
					x60 = MKSTR(v66);
					x59 = MKSTR(v65);
					x58 = v64;
					x57 = x1;
					x56 = x2;
				}
				int64_t v67 = mw_mirth_data_Tag_outputsZ_resourceZAsk(x57);
				uint64_t x68;
				VAL x69;
				if (((bool)v67)) {
					VAL v70 = (VVAL(VTUP(x56)->cells[1]));
					VAL v71;
					VAL v72;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v70, &v71, &v72);
					VAL v73 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x58, v71));
					VAL v74 = (mw_mirth_c99_ZPlusC99_indent(v72));
					int64_t v75 = VI64(VTUP(v73)->cells[1]);
					VAL v76 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v75);
					VAL v77 = (mw_mirth_c99_ZPlusC99_put(v76, v74));
					STR* v78;
					STRLIT(v78, " ", 1);
					VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
					VAL v80 = VVAL(VTUP(v73)->cells[2]);
					incref(v80);
					VAL v81 = (mw_mirth_c99_ZPlusC99_put(v80, v79));
					STR* v82;
					STRLIT(v82, " = (", 4);
					VAL v83 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v82), v81));
					VAL v84 = (mw_mirth_c99_ZPlusC99_put(x59, v83));
					VAL v85 = mw_mirth_data_Tag_valueZ_show(x57);
					VAL v86 = (mw_mirth_c99_ZPlusC99_put(v85, v84));
					STR* v87;
					STRLIT(v87, "LL /* ", 6);
					VAL v88 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v87), v86));
					uint64_t v89 = mw_mirth_data_Tag_name(x57);
					VAL v90 = mw_mirth_name_Name_ZToStr(v89);
					VAL v91 = (mw_mirth_c99_ZPlusC99_put(v90, v88));
					STR* v92;
					STRLIT(v92, " */", 3);
					VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
					VAL v94 = (mw_mirth_c99_ZPlusC99_put(x60, v93));
					STR* v95;
					STRLIT(v95, ");", 2);
					VAL v96 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v95), v94));
					VAL v97 = (mw_mirth_c99_ZPlusC99_line(v96));
					VTUP(x56)->cells[1] = v97;
					VAL v98 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x56, v73));
					x69 = v98;
					x68 = x57;
				} else {
					VAL v99 = (VVAL(VTUP(x56)->cells[1]));
					VAL v100;
					VAL v101;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v99, &v100, &v101);
					VAL v102 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(x58, v100));
					VAL v103 = (mw_mirth_c99_ZPlusC99_indent(v101));
					int64_t v104 = VI64(VTUP(v102)->cells[1]);
					VAL v105 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v104);
					VAL v106 = (mw_mirth_c99_ZPlusC99_put(v105, v103));
					STR* v107;
					STRLIT(v107, " ", 1);
					VAL v108 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v107), v106));
					VAL v109 = VVAL(VTUP(v102)->cells[2]);
					incref(v109);
					VAL v110 = (mw_mirth_c99_ZPlusC99_put(v109, v108));
					STR* v111;
					STRLIT(v111, " = ", 3);
					VAL v112 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v111), v110));
					VAL v113 = (mw_mirth_c99_ZPlusC99_put(x59, v112));
					VAL v114 = mw_mirth_data_Tag_valueZ_show(x57);
					VAL v115 = (mw_mirth_c99_ZPlusC99_put(v114, v113));
					STR* v116;
					STRLIT(v116, "LL /* ", 6);
					VAL v117 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v116), v115));
					uint64_t v118 = mw_mirth_data_Tag_name(x57);
					VAL v119 = mw_mirth_name_Name_ZToStr(v118);
					VAL v120 = (mw_mirth_c99_ZPlusC99_put(v119, v117));
					STR* v121;
					STRLIT(v121, " */", 3);
					VAL v122 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v121), v120));
					VAL v123 = (mw_mirth_c99_ZPlusC99_put(x60, v122));
					STR* v124;
					STRLIT(v124, ";", 1);
					VAL v125 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v124), v123));
					VAL v126 = (mw_mirth_c99_ZPlusC99_line(v125));
					VTUP(x56)->cells[1] = v126;
					VAL v127 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x56, v102));
					x69 = v127;
					x68 = x57;
				}
				x53 = x69;
				x52 = x68;
			} else {
				VAL v128 = (VVAL(VTUP(x2)->cells[1]));
				VAL v129 = (mw_mirth_c99_ZPlusC99_indent(v128));
				VAL v130;
				VAL v131;
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v129, &v130, &v131);
				STR* v132;
				STRLIT(v132, "TUP* ", 5);
				VAL v133 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v132), v131));
				incref(v130);
				VAL v134 = (mw_mirth_c99_ZPlusC99_put(v130, v133));
				STR* v135;
				STRLIT(v135, " = tup_new(", 11);
				VAL v136 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v135), v134));
				int64_t v137 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
				int64_t v138 = 1LL;
				int64_t v139 = i64_add(v137, v138);
				STR* v140 = i64_show(v139);
				VAL v141 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v140), v136));
				STR* v142;
				STRLIT(v142, ");", 2);
				VAL v143 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v142), v141));
				VAL v144 = (mw_mirth_c99_ZPlusC99_line(v143));
				VTUP(x2)->cells[1] = v144;
				VAL v145 = (VVAL(VTUP(x2)->cells[1]));
				VAL v146 = (mw_mirth_c99_ZPlusC99_indent(v145));
				incref(v130);
				VAL v147 = (mw_mirth_c99_ZPlusC99_put(v130, v146));
				STR* v148;
				STRLIT(v148, "->size = ", 9);
				VAL v149 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v148), v147));
				int64_t v150 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
				int64_t v151 = 1LL;
				int64_t v152 = i64_add(v150, v151);
				STR* v153 = i64_show(v152);
				VAL v154 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v153), v149));
				STR* v155;
				STRLIT(v155, ";", 1);
				VAL v156 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v155), v154));
				VAL v157 = (mw_mirth_c99_ZPlusC99_line(v156));
				VTUP(x2)->cells[1] = v157;
				VAL v158 = (VVAL(VTUP(x2)->cells[1]));
				VAL v159 = (mw_mirth_c99_ZPlusC99_indent(v158));
				incref(v130);
				VAL v160 = (mw_mirth_c99_ZPlusC99_put(v130, v159));
				STR* v161;
				STRLIT(v161, "->cells[0] = MKI64(", 19);
				VAL v162 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v161), v160));
				VAL v163 = mw_mirth_data_Tag_valueZ_show(x1);
				VAL v164 = (mw_mirth_c99_ZPlusC99_put(v163, v162));
				STR* v165;
				STRLIT(v165, "LL /* ", 6);
				VAL v166 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v165), v164));
				uint64_t v167 = mw_mirth_data_Tag_name(x1);
				VAL v168 = mw_mirth_name_Name_ZToStr(v167);
				VAL v169 = (mw_mirth_c99_ZPlusC99_put(v168, v166));
				STR* v170;
				STRLIT(v170, " */);", 5);
				VAL v171 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v170), v169));
				VAL v172 = (mw_mirth_c99_ZPlusC99_line(v171));
				VTUP(x2)->cells[1] = v172;
				int64_t v173 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
				VAL v174 = mw_mirth_data_Tag_labelZ_inputs(x1);
				VAL v175 = mw_std_list_List_1_reverse(v174);
				VAL v176;
				VAL v177;
				mw_std_list_List_1_uncons(v175, &v176, &v177);
				VAL x178;
				VAL x179;
				int64_t x180;
				uint64_t x181;
				VAL x182;
				int64_t x183;
				switch (get_data_tag(v176)) {
					case 1LL: { // Some
						VAL v184 = mtp_std_maybe_Maybe_1_Some(v176);
						incref(v184);
						int64_t v185 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(VU64(v184));
						VAL x186;
						int64_t x187;
						uint64_t x188;
						VAL x189;
						VAL x190;
						if (((bool)v185)) {
							int64_t v191 = 0LL /* C99RT_VAL */;
							VAL v192;
							VAL v193;
							mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v191, VU64(v184), x2, &v192, &v193);
							VAL v194 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v193);
							x190 = v194;
							x189 = v192;
							x188 = x1;
							x187 = v173;
							x186 = v130;
						} else {
							int64_t v195 = 0LL /* C99RT_VAL */;
							VAL v196;
							VAL v197;
							mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v195, VU64(v184), x2, &v196, &v197);
							VAL v198 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v197);
							x190 = v198;
							x189 = v196;
							x188 = x1;
							x187 = v173;
							x186 = v130;
						}
						VAL v199 = (VVAL(VTUP(x189)->cells[1]));
						VAL v200 = (mw_mirth_c99_ZPlusC99_indent(v199));
						incref(x186);
						VAL v201 = (mw_mirth_c99_ZPlusC99_put(x186, v200));
						STR* v202;
						STRLIT(v202, "->cells[", 8);
						VAL v203 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v202), v201));
						STR* v204 = i64_show(x187);
						VAL v205 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v204), v203));
						STR* v206;
						STRLIT(v206, "] = ", 4);
						VAL v207 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v206), v205));
						VAL v208 = (mw_mirth_c99_ZPlusC99_put(x190, v207));
						STR* v209;
						STRLIT(v209, ";", 1);
						VAL v210 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v209), v208));
						VAL v211 = (mw_mirth_c99_ZPlusC99_line(v210));
						VTUP(x189)->cells[1] = v211;
						int64_t v212 = 1LL;
						int64_t v213 = i64_sub(x187, v212);
						int64_t v214 = 0LL;
						bool v215 = (v213 < v214);
						int64_t x216;
						if (v215) {
							int64_t v217 = 0LL;
							x216 = v217;
							lpush(&lbl_tag, MKU64(x188));
							lpush(&lbl_tup, x186);
							push_resource(x189);
						} else {
							x216 = v213;
							lpush(&lbl_tag, MKU64(x188));
							lpush(&lbl_tup, x186);
							push_resource(x189);
						}
						int64_t v218 = 1LL /* True */;
						x183 = v218;
						x182 = v177;
						uint64_t v219 = VU64(lpop(&lbl_tag));
						x181 = v219;
						x180 = x216;
						VAL r220 = pop_resource();
						x179 = r220;
						VAL v221 = lpop(&lbl_tup);
						x178 = v221;
					} break;
					case 0LL: { // None
						int64_t v222 = 0LL /* False */;
						x183 = v222;
						x182 = v177;
						x181 = x1;
						x180 = v173;
						x179 = x2;
						x178 = v130;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v223 = x178;
				VAL v224 = (x179);
				int64_t v225 = x180;
				uint64_t v226 = x181;
				VAL v227 = x182;
				int64_t v228 = x183;
				while (((bool)v228)) {
					VAL v229 = v223;
					VAL v230 = (v224);
					int64_t v231 = v225;
					uint64_t v232 = v226;
					VAL v233 = v227;
					VAL v234;
					VAL v235;
					mw_std_list_List_1_uncons(v233, &v234, &v235);
					VAL x236;
					VAL x237;
					int64_t x238;
					uint64_t x239;
					VAL x240;
					int64_t x241;
					switch (get_data_tag(v234)) {
						case 1LL: { // Some
							VAL v242 = mtp_std_maybe_Maybe_1_Some(v234);
							incref(v242);
							int64_t v243 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(VU64(v242));
							VAL x244;
							int64_t x245;
							uint64_t x246;
							VAL x247;
							VAL x248;
							if (((bool)v243)) {
								int64_t v249 = 0LL /* C99RT_VAL */;
								VAL v250;
								VAL v251;
								mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v249, VU64(v242), v230, &v250, &v251);
								VAL v252 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v251);
								x248 = v252;
								x247 = v250;
								x246 = v232;
								x245 = v231;
								x244 = v229;
							} else {
								int64_t v253 = 0LL /* C99RT_VAL */;
								VAL v254;
								VAL v255;
								mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v253, VU64(v242), v230, &v254, &v255);
								VAL v256 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v255);
								x248 = v256;
								x247 = v254;
								x246 = v232;
								x245 = v231;
								x244 = v229;
							}
							VAL v257 = (VVAL(VTUP(x247)->cells[1]));
							VAL v258 = (mw_mirth_c99_ZPlusC99_indent(v257));
							incref(x244);
							VAL v259 = (mw_mirth_c99_ZPlusC99_put(x244, v258));
							STR* v260;
							STRLIT(v260, "->cells[", 8);
							VAL v261 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v260), v259));
							STR* v262 = i64_show(x245);
							VAL v263 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v262), v261));
							STR* v264;
							STRLIT(v264, "] = ", 4);
							VAL v265 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v264), v263));
							VAL v266 = (mw_mirth_c99_ZPlusC99_put(x248, v265));
							STR* v267;
							STRLIT(v267, ";", 1);
							VAL v268 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v267), v266));
							VAL v269 = (mw_mirth_c99_ZPlusC99_line(v268));
							VTUP(x247)->cells[1] = v269;
							int64_t v270 = 1LL;
							int64_t v271 = i64_sub(x245, v270);
							int64_t v272 = 0LL;
							bool v273 = (v271 < v272);
							int64_t x274;
							if (v273) {
								int64_t v275 = 0LL;
								x274 = v275;
								lpush(&lbl_tag, MKU64(x246));
								lpush(&lbl_tup, x244);
								push_resource(x247);
							} else {
								x274 = v271;
								lpush(&lbl_tag, MKU64(x246));
								lpush(&lbl_tup, x244);
								push_resource(x247);
							}
							int64_t v276 = 1LL /* True */;
							x241 = v276;
							x240 = v235;
							uint64_t v277 = VU64(lpop(&lbl_tag));
							x239 = v277;
							x238 = x274;
							VAL r278 = pop_resource();
							x237 = r278;
							VAL v279 = lpop(&lbl_tup);
							x236 = v279;
						} break;
						case 0LL: { // None
							int64_t v280 = 0LL /* False */;
							x241 = v280;
							x240 = v235;
							x239 = v232;
							x238 = v231;
							x237 = v230;
							x236 = v229;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v228 = x241;
					v227 = x240;
					v226 = x239;
					v225 = x238;
					v224 = x237;
					v223 = x236;
				}
				decref(v227);
				int64_t v281 = mw_mirth_data_Tag_numZ_resourceZ_inputs(v226);
				int64_t v282 = 0LL;
				bool v283 = (v281 > v282);
				VAL v284 = v223;
				VAL v285 = (v224);
				int64_t v286 = v225;
				uint64_t v287 = v226;
				int64_t v288 = v281;
				bool v289 = v283;
				while (v289) {
					VAL v290 = v284;
					VAL v291 = (v285);
					int64_t v292 = v286;
					uint64_t v293 = v287;
					int64_t v294 = v288;
					int64_t v295 = 0LL /* C99RT_VAL */;
					VAL v296;
					VAL v297;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v291, v295, &v296, &v297);
					VAL v298 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v297);
					VAL v299 = (VVAL(VTUP(v296)->cells[1]));
					VAL v300 = (mw_mirth_c99_ZPlusC99_indent(v299));
					incref(v290);
					VAL v301 = (mw_mirth_c99_ZPlusC99_put(v290, v300));
					STR* v302;
					STRLIT(v302, "->cells[", 8);
					VAL v303 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v302), v301));
					STR* v304 = i64_show(v292);
					VAL v305 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v304), v303));
					STR* v306;
					STRLIT(v306, "] = ", 4);
					VAL v307 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v306), v305));
					VAL v308 = (mw_mirth_c99_ZPlusC99_put(v298, v307));
					STR* v309;
					STRLIT(v309, ";", 1);
					VAL v310 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v309), v308));
					VAL v311 = (mw_mirth_c99_ZPlusC99_line(v310));
					VTUP(v296)->cells[1] = v311;
					int64_t v312 = 1LL;
					int64_t v313 = i64_sub(v292, v312);
					int64_t v314 = 0LL;
					bool v315 = (v313 < v314);
					int64_t x316;
					if (v315) {
						int64_t v317 = 0LL;
						x316 = v317;
						lpush(&lbl_tag, MKU64(v293));
						lpush(&lbl_tup, v290);
						push_resource(v296);
					} else {
						x316 = v313;
						lpush(&lbl_tag, MKU64(v293));
						lpush(&lbl_tup, v290);
						push_resource(v296);
					}
					int64_t v318 = 1LL;
					int64_t v319 = i64_sub(v294, v318);
					int64_t v320 = 0LL;
					bool v321 = (v319 < v320);
					int64_t x322;
					if (v321) {
						int64_t v323 = 0LL;
						x322 = v323;
						lpush(&lbl_i, MKI64(x316));
					} else {
						x322 = v319;
						lpush(&lbl_i, MKI64(x316));
					}
					int64_t v324 = 0LL;
					bool v325 = (x322 > v324);
					v289 = v325;
					v288 = x322;
					uint64_t v326 = VU64(lpop(&lbl_tag));
					v287 = v326;
					int64_t v327 = VI64(lpop(&lbl_i));
					v286 = v327;
					VAL r328 = pop_resource();
					v285 = r328;
					VAL v329 = lpop(&lbl_tup);
					v284 = v329;
				}
				int64_t v330 = mw_mirth_data_Tag_numZ_typeZ_inputs(v287);
				int64_t v331 = 0LL;
				bool v332 = (v330 > v331);
				VAL v333 = v284;
				VAL v334 = (v285);
				int64_t v335 = v286;
				uint64_t v336 = v287;
				int64_t v337 = v330;
				bool v338 = v332;
				while (v338) {
					VAL v339 = v333;
					VAL v340 = (v334);
					int64_t v341 = v335;
					uint64_t v342 = v336;
					int64_t v343 = v337;
					int64_t v344 = 0LL /* C99RT_VAL */;
					VAL v345;
					VAL v346;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v340, v344, &v345, &v346);
					VAL v347 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v346);
					VAL v348 = (VVAL(VTUP(v345)->cells[1]));
					VAL v349 = (mw_mirth_c99_ZPlusC99_indent(v348));
					incref(v339);
					VAL v350 = (mw_mirth_c99_ZPlusC99_put(v339, v349));
					STR* v351;
					STRLIT(v351, "->cells[", 8);
					VAL v352 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v351), v350));
					STR* v353 = i64_show(v341);
					VAL v354 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v353), v352));
					STR* v355;
					STRLIT(v355, "] = ", 4);
					VAL v356 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v355), v354));
					VAL v357 = (mw_mirth_c99_ZPlusC99_put(v347, v356));
					STR* v358;
					STRLIT(v358, ";", 1);
					VAL v359 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v358), v357));
					VAL v360 = (mw_mirth_c99_ZPlusC99_line(v359));
					VTUP(v345)->cells[1] = v360;
					int64_t v361 = 1LL;
					int64_t v362 = i64_sub(v341, v361);
					int64_t v363 = 0LL;
					bool v364 = (v362 < v363);
					int64_t x365;
					if (v364) {
						int64_t v366 = 0LL;
						x365 = v366;
						lpush(&lbl_tag, MKU64(v342));
						lpush(&lbl_tup, v339);
						push_resource(v345);
					} else {
						x365 = v362;
						lpush(&lbl_tag, MKU64(v342));
						lpush(&lbl_tup, v339);
						push_resource(v345);
					}
					int64_t v367 = 1LL;
					int64_t v368 = i64_sub(v343, v367);
					int64_t v369 = 0LL;
					bool v370 = (v368 < v369);
					int64_t x371;
					if (v370) {
						int64_t v372 = 0LL;
						x371 = v372;
						lpush(&lbl_i, MKI64(x365));
					} else {
						x371 = v368;
						lpush(&lbl_i, MKI64(x365));
					}
					int64_t v373 = 0LL;
					bool v374 = (x371 > v373);
					v338 = v374;
					v337 = x371;
					uint64_t v375 = VU64(lpop(&lbl_tag));
					v336 = v375;
					int64_t v376 = VI64(lpop(&lbl_i));
					v335 = v376;
					VAL r377 = pop_resource();
					v334 = r377;
					VAL v378 = lpop(&lbl_tup);
					v333 = v378;
				}
				int64_t v379 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v336);
				uint64_t x380;
				VAL x381;
				if (((bool)v379)) {
					int64_t v382 = 0LL /* C99RT_VAL */;
					VAL v383 = (VVAL(VTUP(v334)->cells[1]));
					VAL v384;
					VAL v385;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v383, &v384, &v385);
					VAL v386 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v382, v384));
					VAL v387 = (mw_mirth_c99_ZPlusC99_indent(v385));
					int64_t v388 = VI64(VTUP(v386)->cells[1]);
					VAL v389 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v388);
					VAL v390 = (mw_mirth_c99_ZPlusC99_put(v389, v387));
					STR* v391;
					STRLIT(v391, " ", 1);
					VAL v392 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v391), v390));
					VAL v393 = VVAL(VTUP(v386)->cells[2]);
					incref(v393);
					VAL v394 = (mw_mirth_c99_ZPlusC99_put(v393, v392));
					STR* v395;
					STRLIT(v395, " = (", 4);
					VAL v396 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v395), v394));
					STR* v397;
					STRLIT(v397, "MKTUP(", 6);
					VAL v398 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v397), v396));
					VAL v399 = (mw_mirth_c99_ZPlusC99_put(v333, v398));
					STR* v400;
					STRLIT(v400, ", ", 2);
					VAL v401 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v400), v399));
					int64_t v402 = mw_mirth_data_Tag_numZ_totalZ_inputs(v336);
					int64_t v403 = 1LL;
					int64_t v404 = i64_add(v402, v403);
					STR* v405 = i64_show(v404);
					VAL v406 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v405), v401));
					STR* v407;
					STRLIT(v407, ")", 1);
					VAL v408 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v407), v406));
					STR* v409;
					STRLIT(v409, ");", 2);
					VAL v410 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v409), v408));
					VAL v411 = (mw_mirth_c99_ZPlusC99_line(v410));
					VTUP(v334)->cells[1] = v411;
					VAL v412 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v334, v386));
					x381 = v412;
					x380 = v336;
				} else {
					int64_t v413 = 0LL /* C99RT_VAL */;
					VAL v414 = (VVAL(VTUP(v334)->cells[1]));
					VAL v415;
					VAL v416;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v414, &v415, &v416);
					VAL v417 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v413, v415));
					VAL v418 = (mw_mirth_c99_ZPlusC99_indent(v416));
					int64_t v419 = VI64(VTUP(v417)->cells[1]);
					VAL v420 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v419);
					VAL v421 = (mw_mirth_c99_ZPlusC99_put(v420, v418));
					STR* v422;
					STRLIT(v422, " ", 1);
					VAL v423 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v422), v421));
					VAL v424 = VVAL(VTUP(v417)->cells[2]);
					incref(v424);
					VAL v425 = (mw_mirth_c99_ZPlusC99_put(v424, v423));
					STR* v426;
					STRLIT(v426, " = ", 3);
					VAL v427 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v426), v425));
					STR* v428;
					STRLIT(v428, "MKTUP(", 6);
					VAL v429 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v428), v427));
					VAL v430 = (mw_mirth_c99_ZPlusC99_put(v333, v429));
					STR* v431;
					STRLIT(v431, ", ", 2);
					VAL v432 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v431), v430));
					int64_t v433 = mw_mirth_data_Tag_numZ_totalZ_inputs(v336);
					int64_t v434 = 1LL;
					int64_t v435 = i64_add(v433, v434);
					STR* v436 = i64_show(v435);
					VAL v437 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v436), v432));
					STR* v438;
					STRLIT(v438, ")", 1);
					VAL v439 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v438), v437));
					STR* v440;
					STRLIT(v440, ";", 1);
					VAL v441 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v440), v439));
					VAL v442 = (mw_mirth_c99_ZPlusC99_line(v441));
					VTUP(v334)->cells[1] = v442;
					VAL v443 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v334, v417));
					x381 = v443;
					x380 = v336;
				}
				x53 = x381;
				x52 = x380;
			}
			x8 = x53;
			x7 = x52;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x8;
}
static VAL mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	VAL v6;
	mw_mirth_data_Tag_semiZ_transparentZAsk(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VTUP(x2)->cells[1] = v3;
	uint64_t x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v10 = VVAL(VTUP(v9)->cells[2]);
			incref(v10);
			decref(v9);
			uint64_t x11;
			VAL x12;
			switch (get_data_tag(v10)) {
				case 1LL: { // STPConsLabel
					VAL v13;
					uint64_t v14;
					mtp_mirth_type_StackTypePart_STPConsLabel(v10, &v13, &v14);
					int64_t v15;
					VAL v16;
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v13, x2, &v15, &v16);
					int64_t v17 = mw_mirth_data_Tag_outputsZ_resourceZAsk(x1);
					uint64_t x18;
					uint64_t x19;
					VAL x20;
					VAL x21;
					if (((bool)v17)) {
						VAL v22;
						VAL v23;
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v16, v15, &v22, &v23);
						VAL v24 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v23));
						x21 = v24;
						x20 = v22;
						x19 = x1;
						x18 = v14;
					} else {
						VAL v25;
						VAL v26;
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v16, v15, &v25, &v26);
						x21 = v26;
						x20 = v25;
						x19 = x1;
						x18 = v14;
					}
					VAL v27 = (mw_mirth_c99_pushZ_localZ_labelZBang(x18, x20, x21));
					x12 = v27;
					x11 = x19;
				} break;
				case 3LL: { // STPWithLabel
					VAL v28;
					uint64_t v29;
					mtp_mirth_type_StackTypePart_STPWithLabel(v10, &v28, &v29);
					int64_t v30;
					VAL v31;
					mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v28, x2, &v30, &v31);
					VAL v32;
					VAL v33;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v31, v30, &v32, &v33);
					VAL v34 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v29, v32, v33));
					x12 = v34;
					x11 = x1;
				} break;
				case 0LL: { // STPCons
					VAL v35 = mtp_mirth_type_StackTypePart_STPCons(v10);
					int64_t v36;
					VAL v37;
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v35, x2, &v36, &v37);
					int64_t v38 = mw_mirth_data_Tag_outputsZ_resourceZAsk(x1);
					uint64_t x39;
					VAL x40;
					VAL x41;
					if (((bool)v38)) {
						VAL v42;
						VAL v43;
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v37, v36, &v42, &v43);
						VAL v44 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v43));
						x41 = v44;
						x40 = v42;
						x39 = x1;
					} else {
						VAL v45;
						VAL v46;
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v37, v36, &v45, &v46);
						x41 = v46;
						x40 = v45;
						x39 = x1;
					}
					VAL v47 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x40, x41));
					x12 = v47;
					x11 = x39;
				} break;
				case 2LL: { // STPWith
					VAL v48 = mtp_mirth_type_StackTypePart_STPWith(v10);
					int64_t v49;
					VAL v50;
					mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v48, x2, &v49, &v50);
					VAL v51;
					VAL v52;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v50, v49, &v51, &v52);
					VAL v53 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v51, v52));
					x12 = v53;
					x11 = x1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x12;
			x7 = x11;
		} break;
		case 0LL: { // None
			int64_t v54 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
			int64_t v55 = 0LL;
			bool v56 = (v54 == v55);
			uint64_t x57;
			VAL x58;
			if (v56) {
				uint64_t v59 = mw_mirth_data_Tag_data(x1);
				VAL v60;
				VAL v61;
				mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v59, x2, &v60, &v61);
				mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop(v61);
				x58 = v60;
				x57 = x1;
			} else {
				uint64_t v62 = mw_mirth_data_Tag_data(x1);
				VAL v63;
				VAL v64;
				mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v62, x2, &v63, &v64);
				VAL v65 = mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL(v64);
				STR* v66;
				STRLIT(v66, "", 0);
				STR* v67;
				STRLIT(v67, "VTUP(", 5);
				VAL v68 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v67), MKSTR(v66)));
				VAL v69 = (mw_std_str_ZPlusStr_pushZ_strZBang(v65, v68));
				STR* v70;
				STRLIT(v70, ")", 1);
				VAL v71 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v70), v69));
				int64_t v72 = 1LL;
				int64_t v73 = mw_mirth_data_Tag_numZ_typeZ_inputs(x1);
				int64_t v74 = 0LL;
				bool v75 = (v73 > v74);
				VAL v76 = (v63);
				VAL v77 = v71;
				int64_t v78 = v72;
				uint64_t v79 = x1;
				int64_t v80 = v73;
				bool v81 = v75;
				while (v81) {
					VAL v82 = (v76);
					VAL v83 = v77;
					int64_t v84 = v78;
					uint64_t v85 = v79;
					int64_t v86 = v80;
					int64_t v87 = 0LL /* C99RT_VAL */;
					VAL v88 = (VVAL(VTUP(v82)->cells[1]));
					VAL v89;
					VAL v90;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v88, &v89, &v90);
					VAL v91 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v87, v89));
					VAL v92 = (mw_mirth_c99_ZPlusC99_indent(v90));
					int64_t v93 = VI64(VTUP(v91)->cells[1]);
					VAL v94 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v93);
					VAL v95 = (mw_mirth_c99_ZPlusC99_put(v94, v92));
					STR* v96;
					STRLIT(v96, " ", 1);
					VAL v97 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v96), v95));
					VAL v98 = VVAL(VTUP(v91)->cells[2]);
					incref(v98);
					VAL v99 = (mw_mirth_c99_ZPlusC99_put(v98, v97));
					STR* v100;
					STRLIT(v100, " = ", 3);
					VAL v101 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v100), v99));
					incref(v83);
					VAL v102 = (mw_mirth_c99_ZPlusC99_put(v83, v101));
					STR* v103;
					STRLIT(v103, "->cells[", 8);
					VAL v104 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v103), v102));
					STR* v105 = i64_show(v84);
					VAL v106 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v105), v104));
					STR* v107;
					STRLIT(v107, "]", 1);
					VAL v108 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v107), v106));
					STR* v109;
					STRLIT(v109, ";", 1);
					VAL v110 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v109), v108));
					VAL v111 = (mw_mirth_c99_ZPlusC99_line(v110));
					VTUP(v82)->cells[1] = v111;
					VAL v112 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v82, v91));
					int64_t v113 = 1LL;
					int64_t v114 = i64_add(v84, v113);
					int64_t v115 = 1LL;
					int64_t v116 = i64_sub(v86, v115);
					int64_t v117 = 0LL;
					bool v118 = (v116 < v117);
					int64_t x119;
					if (v118) {
						int64_t v120 = 0LL;
						x119 = v120;
						lpush(&lbl_tag, MKU64(v85));
						lpush(&lbl_tup, v83);
						push_resource(v112);
						lpush(&lbl_i, MKI64(v114));
					} else {
						x119 = v116;
						lpush(&lbl_tag, MKU64(v85));
						lpush(&lbl_tup, v83);
						push_resource(v112);
						lpush(&lbl_i, MKI64(v114));
					}
					int64_t v121 = 0LL;
					bool v122 = (x119 > v121);
					v81 = v122;
					v80 = x119;
					uint64_t v123 = VU64(lpop(&lbl_tag));
					v79 = v123;
					int64_t v124 = VI64(lpop(&lbl_i));
					v78 = v124;
					VAL v125 = lpop(&lbl_tup);
					v77 = v125;
					VAL r126 = pop_resource();
					v76 = r126;
				}
				int64_t v127 = mw_mirth_data_Tag_numZ_resourceZ_inputs(v79);
				int64_t v128 = 0LL;
				bool v129 = (v127 > v128);
				VAL v130 = (v76);
				VAL v131 = v77;
				int64_t v132 = v78;
				uint64_t v133 = v79;
				int64_t v134 = v127;
				bool v135 = v129;
				while (v135) {
					VAL v136 = (v130);
					VAL v137 = v131;
					int64_t v138 = v132;
					uint64_t v139 = v133;
					int64_t v140 = v134;
					int64_t v141 = 0LL /* C99RT_VAL */;
					VAL v142 = (VVAL(VTUP(v136)->cells[1]));
					VAL v143;
					VAL v144;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v142, &v143, &v144);
					VAL v145 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v141, v143));
					VAL v146 = (mw_mirth_c99_ZPlusC99_indent(v144));
					int64_t v147 = VI64(VTUP(v145)->cells[1]);
					VAL v148 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v147);
					VAL v149 = (mw_mirth_c99_ZPlusC99_put(v148, v146));
					STR* v150;
					STRLIT(v150, " ", 1);
					VAL v151 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v150), v149));
					VAL v152 = VVAL(VTUP(v145)->cells[2]);
					incref(v152);
					VAL v153 = (mw_mirth_c99_ZPlusC99_put(v152, v151));
					STR* v154;
					STRLIT(v154, " = (", 4);
					VAL v155 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v154), v153));
					incref(v137);
					VAL v156 = (mw_mirth_c99_ZPlusC99_put(v137, v155));
					STR* v157;
					STRLIT(v157, "->cells[", 8);
					VAL v158 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v157), v156));
					STR* v159 = i64_show(v138);
					VAL v160 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v159), v158));
					STR* v161;
					STRLIT(v161, "]", 1);
					VAL v162 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v161), v160));
					STR* v163;
					STRLIT(v163, ");", 2);
					VAL v164 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v163), v162));
					VAL v165 = (mw_mirth_c99_ZPlusC99_line(v164));
					VTUP(v136)->cells[1] = v165;
					VAL v166 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v136, v145));
					int64_t v167 = 1LL;
					int64_t v168 = i64_add(v138, v167);
					int64_t v169 = 1LL;
					int64_t v170 = i64_sub(v140, v169);
					int64_t v171 = 0LL;
					bool v172 = (v170 < v171);
					int64_t x173;
					if (v172) {
						int64_t v174 = 0LL;
						x173 = v174;
						lpush(&lbl_tag, MKU64(v139));
						lpush(&lbl_tup, v137);
						push_resource(v166);
						lpush(&lbl_i, MKI64(v168));
					} else {
						x173 = v170;
						lpush(&lbl_tag, MKU64(v139));
						lpush(&lbl_tup, v137);
						push_resource(v166);
						lpush(&lbl_i, MKI64(v168));
					}
					int64_t v175 = 0LL;
					bool v176 = (x173 > v175);
					v135 = v176;
					v134 = x173;
					uint64_t v177 = VU64(lpop(&lbl_tag));
					v133 = v177;
					int64_t v178 = VI64(lpop(&lbl_i));
					v132 = v178;
					VAL v179 = lpop(&lbl_tup);
					v131 = v179;
					VAL r180 = pop_resource();
					v130 = r180;
				}
				VAL v181 = mw_mirth_data_Tag_labelZ_inputs(v133);
				VAL v182;
				VAL v183;
				mw_std_list_List_1_uncons(v181, &v182, &v183);
				VAL x184;
				VAL x185;
				int64_t x186;
				uint64_t x187;
				VAL x188;
				int64_t x189;
				switch (get_data_tag(v182)) {
					case 1LL: { // Some
						VAL v190 = mtp_std_maybe_Maybe_1_Some(v182);
						int64_t v191 = 0LL /* C99RT_VAL */;
						VAL v192 = (VVAL(VTUP(v130)->cells[1]));
						VAL v193;
						VAL v194;
						mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v192, &v193, &v194);
						VAL v195 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v191, v193));
						VAL v196 = (mw_mirth_c99_ZPlusC99_indent(v194));
						int64_t v197 = VI64(VTUP(v195)->cells[1]);
						VAL v198 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v197);
						VAL v199 = (mw_mirth_c99_ZPlusC99_put(v198, v196));
						STR* v200;
						STRLIT(v200, " ", 1);
						VAL v201 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v200), v199));
						VAL v202 = VVAL(VTUP(v195)->cells[2]);
						incref(v202);
						VAL v203 = (mw_mirth_c99_ZPlusC99_put(v202, v201));
						STR* v204;
						STRLIT(v204, " = ", 3);
						VAL v205 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v204), v203));
						incref(v131);
						VAL v206 = (mw_mirth_c99_ZPlusC99_put(v131, v205));
						STR* v207;
						STRLIT(v207, "->cells[", 8);
						VAL v208 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v207), v206));
						STR* v209 = i64_show(v132);
						VAL v210 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v209), v208));
						STR* v211;
						STRLIT(v211, "]", 1);
						VAL v212 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v211), v210));
						STR* v213;
						STRLIT(v213, ";", 1);
						VAL v214 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v213), v212));
						VAL v215 = (mw_mirth_c99_ZPlusC99_line(v214));
						VTUP(v130)->cells[1] = v215;
						incref(v190);
						int64_t v216 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(VU64(v190));
						uint64_t x217;
						VAL x218;
						int64_t x219;
						VAL x220;
						if (((bool)v216)) {
							VAL v221 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v195));
							VAL v222 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(VU64(v190), v130, v221));
							x220 = v222;
							x219 = v132;
							x218 = v131;
							x217 = v133;
						} else {
							VAL v223 = (mw_mirth_c99_pushZ_localZ_labelZBang(VU64(v190), v130, v195));
							x220 = v223;
							x219 = v132;
							x218 = v131;
							x217 = v133;
						}
						int64_t v224 = 1LL;
						int64_t v225 = i64_add(x219, v224);
						int64_t v226 = 1LL /* True */;
						x189 = v226;
						x188 = v183;
						x187 = x217;
						x186 = v225;
						x185 = x218;
						x184 = x220;
					} break;
					case 0LL: { // None
						int64_t v227 = 0LL /* False */;
						x189 = v227;
						x188 = v183;
						x187 = v133;
						x186 = v132;
						x185 = v131;
						x184 = v130;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v228 = (x184);
				VAL v229 = x185;
				int64_t v230 = x186;
				uint64_t v231 = x187;
				VAL v232 = x188;
				int64_t v233 = x189;
				while (((bool)v233)) {
					VAL v234 = (v228);
					VAL v235 = v229;
					int64_t v236 = v230;
					uint64_t v237 = v231;
					VAL v238 = v232;
					VAL v239;
					VAL v240;
					mw_std_list_List_1_uncons(v238, &v239, &v240);
					VAL x241;
					VAL x242;
					int64_t x243;
					uint64_t x244;
					VAL x245;
					int64_t x246;
					switch (get_data_tag(v239)) {
						case 1LL: { // Some
							VAL v247 = mtp_std_maybe_Maybe_1_Some(v239);
							int64_t v248 = 0LL /* C99RT_VAL */;
							VAL v249 = (VVAL(VTUP(v234)->cells[1]));
							VAL v250;
							VAL v251;
							mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v249, &v250, &v251);
							VAL v252 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v248, v250));
							VAL v253 = (mw_mirth_c99_ZPlusC99_indent(v251));
							int64_t v254 = VI64(VTUP(v252)->cells[1]);
							VAL v255 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v254);
							VAL v256 = (mw_mirth_c99_ZPlusC99_put(v255, v253));
							STR* v257;
							STRLIT(v257, " ", 1);
							VAL v258 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v257), v256));
							VAL v259 = VVAL(VTUP(v252)->cells[2]);
							incref(v259);
							VAL v260 = (mw_mirth_c99_ZPlusC99_put(v259, v258));
							STR* v261;
							STRLIT(v261, " = ", 3);
							VAL v262 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v261), v260));
							incref(v235);
							VAL v263 = (mw_mirth_c99_ZPlusC99_put(v235, v262));
							STR* v264;
							STRLIT(v264, "->cells[", 8);
							VAL v265 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v264), v263));
							STR* v266 = i64_show(v236);
							VAL v267 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v266), v265));
							STR* v268;
							STRLIT(v268, "]", 1);
							VAL v269 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v268), v267));
							STR* v270;
							STRLIT(v270, ";", 1);
							VAL v271 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v270), v269));
							VAL v272 = (mw_mirth_c99_ZPlusC99_line(v271));
							VTUP(v234)->cells[1] = v272;
							incref(v247);
							int64_t v273 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(VU64(v247));
							uint64_t x274;
							VAL x275;
							int64_t x276;
							VAL x277;
							if (((bool)v273)) {
								VAL v278 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v252));
								VAL v279 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(VU64(v247), v234, v278));
								x277 = v279;
								x276 = v236;
								x275 = v235;
								x274 = v237;
							} else {
								VAL v280 = (mw_mirth_c99_pushZ_localZ_labelZBang(VU64(v247), v234, v252));
								x277 = v280;
								x276 = v236;
								x275 = v235;
								x274 = v237;
							}
							int64_t v281 = 1LL;
							int64_t v282 = i64_add(x276, v281);
							int64_t v283 = 1LL /* True */;
							x246 = v283;
							x245 = v240;
							x244 = x274;
							x243 = v282;
							x242 = x275;
							x241 = x277;
						} break;
						case 0LL: { // None
							int64_t v284 = 0LL /* False */;
							x246 = v284;
							x245 = v240;
							x244 = v237;
							x243 = v236;
							x242 = v235;
							x241 = v234;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v233 = x246;
					v232 = x245;
					v231 = x244;
					v230 = x243;
					v229 = x242;
					v228 = x241;
				}
				decref(v232);
				VAL v285 = (VVAL(VTUP(v228)->cells[1]));
				VAL v286 = (mw_mirth_c99_ZPlusC99_indent(v285));
				STR* v287;
				STRLIT(v287, "tup_decref_outer(", 17);
				VAL v288 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v287), v286));
				VAL v289 = (mw_mirth_c99_ZPlusC99_put(v229, v288));
				STR* v290;
				STRLIT(v290, ",", 1);
				VAL v291 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v290), v289));
				STR* v292 = i64_show(v230);
				VAL v293 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v292), v291));
				STR* v294;
				STRLIT(v294, ");", 2);
				VAL v295 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v294), v293));
				VAL v296 = (mw_mirth_c99_ZPlusC99_line(v295));
				VTUP(v228)->cells[1] = v296;
				x58 = v228;
				x57 = v231;
			}
			x8 = x58;
			x7 = x57;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x8;
}
static VAL mw_mirth_c99_c99Z_tagZ_defZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[6]));
	VAL v4;
	int64_t v5;
	mw_mirth_data_Tag_preferZ_inlineZAsk(v3, x1, &v4, &v5);
	VTUP(x2)->cells[6] = v4;
	uint64_t x6;
	VAL x7;
	if (((bool)v5)) {
		x7 = x2;
		x6 = x1;
	} else {
		VAL v8 = (VVAL(VTUP(x2)->cells[4]));
		int64_t v9;
		VAL v10;
		mw_mirth_data_Tag_wordZ_neededZAsk(x1, v8, &v9, &v10);
		VTUP(x2)->cells[4] = v10;
		uint64_t x11;
		VAL x12;
		if (((bool)v9)) {
			VAL v13;
			VAL v14;
			mw_mirth_data_Tag_wordZ_c99Z_api(x1, x2, &v13, &v14);
			VAL v15 = (mw_mirth_c99_ZPlusC99_indent(v14));
			incref(v13);
			VAL v16 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v13, v15));
			STR* v17;
			STRLIT(v17, " {", 2);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
			VAL v19 = (mw_mirth_c99_ZPlusC99_line(v18));
			int64_t v20 = VI64(VTUP(v19)->cells[2]);
			int64_t v21 = 1LL;
			int64_t v22 = i64_add(v20, v21);
			VTUP(v19)->cells[2] = MKI64(v22);
			incref(v13);
			VAL v23 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v13, v19));
			VAL v24 = (mw_mirth_c99_c99Z_tagZ_bodyZBang(x1, v23));
			VAL v25 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v13, v24));
			int64_t v26 = VI64(VTUP(v25)->cells[2]);
			int64_t v27 = 1LL;
			int64_t v28 = i64_sub(v26, v27);
			int64_t v29 = 0LL;
			bool v30 = (v28 < v29);
			int64_t x31;
			if (v30) {
				int64_t v32 = 0LL;
				x31 = v32;
				lpush(&lbl_tag, MKU64(x1));
			} else {
				x31 = v28;
				lpush(&lbl_tag, MKU64(x1));
			}
			VTUP(v25)->cells[2] = MKI64(x31);
			VAL v33 = (mw_mirth_c99_ZPlusC99_indent(v25));
			STR* v34;
			STRLIT(v34, "}", 1);
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v34), v33));
			VAL v36 = (mw_mirth_c99_ZPlusC99_line(v35));
			x12 = v36;
			uint64_t v37 = VU64(lpop(&lbl_tag));
			x11 = v37;
		} else {
			x12 = x2;
			x11 = x1;
		}
		VAL v38 = (VVAL(VTUP(x12)->cells[4]));
		int64_t v39;
		VAL v40;
		mw_mirth_data_Tag_patZ_neededZAsk(x11, v38, &v39, &v40);
		VTUP(x12)->cells[4] = v40;
		uint64_t x41;
		VAL x42;
		if (((bool)v39)) {
			VAL v43;
			VAL v44;
			mw_mirth_data_Tag_patZ_c99Z_api(x11, x12, &v43, &v44);
			VAL v45 = (mw_mirth_c99_ZPlusC99_indent(v44));
			incref(v43);
			VAL v46 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v43, v45));
			STR* v47;
			STRLIT(v47, " {", 2);
			VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), v46));
			VAL v49 = (mw_mirth_c99_ZPlusC99_line(v48));
			int64_t v50 = VI64(VTUP(v49)->cells[2]);
			int64_t v51 = 1LL;
			int64_t v52 = i64_add(v50, v51);
			VTUP(v49)->cells[2] = MKI64(v52);
			incref(v43);
			VAL v53 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v43, v49));
			VAL v54 = (mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang(x11, v53));
			VAL v55 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v43, v54));
			int64_t v56 = VI64(VTUP(v55)->cells[2]);
			int64_t v57 = 1LL;
			int64_t v58 = i64_sub(v56, v57);
			int64_t v59 = 0LL;
			bool v60 = (v58 < v59);
			int64_t x61;
			if (v60) {
				int64_t v62 = 0LL;
				x61 = v62;
				lpush(&lbl_tag, MKU64(x11));
			} else {
				x61 = v58;
				lpush(&lbl_tag, MKU64(x11));
			}
			VTUP(v55)->cells[2] = MKI64(x61);
			VAL v63 = (mw_mirth_c99_ZPlusC99_indent(v55));
			STR* v64;
			STRLIT(v64, "}", 1);
			VAL v65 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v64), v63));
			VAL v66 = (mw_mirth_c99_ZPlusC99_line(v65));
			x42 = v66;
			uint64_t v67 = VU64(lpop(&lbl_tag));
			x41 = v67;
		} else {
			x42 = x12;
			x41 = x11;
		}
		x7 = x42;
		x6 = x41;
	}
	return x7;
}
static void mw_mirth_c99_c99Z_tagZ_labelZ_index (uint64_t x1, uint64_t x2, VAL x3, int64_t *x4, VAL *x5) {
	int64_t v6 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
	int64_t v7 = 1LL;
	int64_t v8 = i64_add(v6, v7);
	VAL v9 = mw_mirth_data_Tag_labelZ_inputs(x1);
	VAL v10 = mw_std_list_List_1_reverse(v9);
	VAL v11 = MKI64(0LL /* None */);
	VAL v12;
	VAL v13;
	mw_std_list_List_1_uncons(v10, &v12, &v13);
	VAL x14;
	uint64_t x15;
	uint64_t x16;
	int64_t x17;
	VAL x18;
	VAL x19;
	int64_t x20;
	switch (get_data_tag(v12)) {
		case 1LL: { // Some
			VAL v21 = mtp_std_maybe_Maybe_1_Some(v12);
			incref(v21);
			int64_t v22 = 1LL;
			int64_t v23 = i64_sub(v8, v22);
			int64_t v24 = 0LL;
			bool v25 = (v23 < v24);
			int64_t x26;
			if (v25) {
				int64_t v27 = 0LL;
				x26 = v27;
				push_resource(x3);
				push_u64(x1);
				push_u64(x2);
			} else {
				x26 = v23;
				push_resource(x3);
				push_u64(x1);
				push_u64(x2);
			}
			VAL v28 = pop_value();
			incref(v28);
			int64_t v29 = mw_mirth_label_Label_ZEqualZEqual(VU64(v28), VU64(v21));
			VAL x30;
			uint64_t x31;
			uint64_t x32;
			int64_t x33;
			VAL x34;
			if (((bool)v29)) {
				VAL v35 = mtw_std_maybe_Maybe_1_Some(v21);
				x34 = v35;
				x33 = x26;
				x32 = VU64(v28);
				uint64_t v36 = pop_u64();
				x31 = v36;
				VAL r37 = pop_resource();
				x30 = r37;
			} else {
				decref(v21);
				VAL v38 = MKI64(0LL /* None */);
				x34 = v38;
				x33 = x26;
				x32 = VU64(v28);
				uint64_t v39 = pop_u64();
				x31 = v39;
				VAL r40 = pop_resource();
				x30 = r40;
			}
			VAL x41;
			uint64_t x42;
			uint64_t x43;
			int64_t x44;
			VAL x45;
			VAL x46;
			switch (get_data_tag(x34)) {
				case 0LL: { // None
					x46 = v13;
					x45 = v11;
					x44 = x33;
					x43 = x32;
					x42 = x31;
					x41 = x30;
				} break;
				default: {
					decref(v13);
					decref(v11);
					VAL v47 = MKI64(0LL /* Nil */);
					x46 = v47;
					x45 = x34;
					x44 = x33;
					x43 = x32;
					x42 = x31;
					x41 = x30;
				} break;
			}
			int64_t v48 = 1LL /* True */;
			x20 = v48;
			x19 = x46;
			x18 = x45;
			x17 = x44;
			x16 = x43;
			x15 = x42;
			x14 = x41;
		} break;
		case 0LL: { // None
			int64_t v49 = 0LL /* False */;
			x20 = v49;
			x19 = v13;
			x18 = v11;
			x17 = v8;
			x16 = x2;
			x15 = x1;
			x14 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v50 = (x14);
	uint64_t v51 = x15;
	uint64_t v52 = x16;
	int64_t v53 = x17;
	VAL v54 = x18;
	VAL v55 = x19;
	int64_t v56 = x20;
	while (((bool)v56)) {
		VAL v57 = (v50);
		uint64_t v58 = v51;
		uint64_t v59 = v52;
		int64_t v60 = v53;
		VAL v61 = v54;
		VAL v62 = v55;
		VAL v63;
		VAL v64;
		mw_std_list_List_1_uncons(v62, &v63, &v64);
		VAL x65;
		uint64_t x66;
		uint64_t x67;
		int64_t x68;
		VAL x69;
		VAL x70;
		int64_t x71;
		switch (get_data_tag(v63)) {
			case 1LL: { // Some
				VAL v72 = mtp_std_maybe_Maybe_1_Some(v63);
				incref(v72);
				int64_t v73 = 1LL;
				int64_t v74 = i64_sub(v60, v73);
				int64_t v75 = 0LL;
				bool v76 = (v74 < v75);
				int64_t x77;
				if (v76) {
					int64_t v78 = 0LL;
					x77 = v78;
					push_resource(v57);
					push_u64(v58);
					push_u64(v59);
				} else {
					x77 = v74;
					push_resource(v57);
					push_u64(v58);
					push_u64(v59);
				}
				VAL v79 = pop_value();
				incref(v79);
				int64_t v80 = mw_mirth_label_Label_ZEqualZEqual(VU64(v79), VU64(v72));
				VAL x81;
				uint64_t x82;
				uint64_t x83;
				int64_t x84;
				VAL x85;
				if (((bool)v80)) {
					VAL v86 = mtw_std_maybe_Maybe_1_Some(v72);
					x85 = v86;
					x84 = x77;
					x83 = VU64(v79);
					uint64_t v87 = pop_u64();
					x82 = v87;
					VAL r88 = pop_resource();
					x81 = r88;
				} else {
					decref(v72);
					VAL v89 = MKI64(0LL /* None */);
					x85 = v89;
					x84 = x77;
					x83 = VU64(v79);
					uint64_t v90 = pop_u64();
					x82 = v90;
					VAL r91 = pop_resource();
					x81 = r91;
				}
				VAL x92;
				uint64_t x93;
				uint64_t x94;
				int64_t x95;
				VAL x96;
				VAL x97;
				switch (get_data_tag(x85)) {
					case 0LL: { // None
						x97 = v64;
						x96 = v61;
						x95 = x84;
						x94 = x83;
						x93 = x82;
						x92 = x81;
					} break;
					default: {
						decref(v64);
						decref(v61);
						VAL v98 = MKI64(0LL /* Nil */);
						x97 = v98;
						x96 = x85;
						x95 = x84;
						x94 = x83;
						x93 = x82;
						x92 = x81;
					} break;
				}
				int64_t v99 = 1LL /* True */;
				x71 = v99;
				x70 = x97;
				x69 = x96;
				x68 = x95;
				x67 = x94;
				x66 = x93;
				x65 = x92;
			} break;
			case 0LL: { // None
				int64_t v100 = 0LL /* False */;
				x71 = v100;
				x70 = v64;
				x69 = v61;
				x68 = v60;
				x67 = v59;
				x66 = v58;
				x65 = v57;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v56 = x71;
		v55 = x70;
		v54 = x69;
		v53 = x68;
		v52 = x67;
		v51 = x66;
		v50 = x65;
	}
	decref(v55);
	decref(v54);
	*x5 = v50;
	*x4 = v53;
}
static VAL mw_mirth_c99_c99Z_tagZ_getZ_labelZBang (VAL x1, VAL x2) {
	uint64_t v3;
	uint64_t v4;
	VAL v5;
	mtp_mirth_data_TagField_TagField(x1, &v3, &v4, &v5);
	VAL v6 = (VVAL(VTUP(x2)->cells[1]));
	VAL v7 = (VVAL(VTUP(v6)->cells[6]));
	VAL v8;
	VAL v9;
	mw_mirth_data_Tag_semiZ_transparentZAsk(v7, v3, &v8, &v9);
	VTUP(v6)->cells[6] = v8;
	VTUP(x2)->cells[1] = v6;
	uint64_t x10;
	uint64_t x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
			decref(v13);
			uint64_t x14;
			uint64_t x15;
			VAL x16;
			switch (get_data_tag(v5)) {
				case 0LL: { // Left
					VAL v17 = mtp_std_either_Either_2_Left(v5);
					int64_t v18 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v3);
					uint64_t x19;
					uint64_t x20;
					VAL x21;
					if (((bool)v18)) {
						int64_t v22;
						VAL v23;
						mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v17, x2, &v22, &v23);
						VAL v24;
						VAL v25;
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v23, v22, &v24, &v25);
						VAL v26;
						VAL v27;
						VAL v28;
						mw_mirth_c99_ZPlusC99LocalResource_dupZ_localZ_resourceZ_asZ_valueZBang(v24, v25, &v26, &v27, &v28);
						VAL v29 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v26, v27));
						VAL v30 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v29, v28));
						x21 = v30;
						x20 = v3;
						x19 = v4;
					} else {
						decref(v17);
						x21 = x2;
						x20 = v3;
						x19 = v4;
					}
					x16 = x21;
					x15 = x20;
					x14 = x19;
				} break;
				case 1LL: { // Right
					VAL v31 = mtp_std_either_Either_2_Right(v5);
					decref(v31);
					int64_t v32 = 2LL /* C99RT_I64 */;
					VAL v33 = (VVAL(VTUP(x2)->cells[1]));
					VAL v34;
					VAL v35;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v33, &v34, &v35);
					VAL v36 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v32, v34));
					VAL v37 = (mw_mirth_c99_ZPlusC99_indent(v35));
					int64_t v38 = VI64(VTUP(v36)->cells[1]);
					VAL v39 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v38);
					VAL v40 = (mw_mirth_c99_ZPlusC99_put(v39, v37));
					STR* v41;
					STRLIT(v41, " ", 1);
					VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), v40));
					VAL v43 = VVAL(VTUP(v36)->cells[2]);
					incref(v43);
					VAL v44 = (mw_mirth_c99_ZPlusC99_put(v43, v42));
					STR* v45;
					STRLIT(v45, " = (", 4);
					VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v44));
					STR* v47;
					STRLIT(v47, "0", 1);
					VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), v46));
					STR* v49;
					STRLIT(v49, ");", 2);
					VAL v50 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v49), v48));
					VAL v51 = (mw_mirth_c99_ZPlusC99_line(v50));
					VTUP(x2)->cells[1] = v51;
					VAL v52 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x2, v36));
					x16 = v52;
					x15 = v3;
					x14 = v4;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x12 = x16;
			x11 = x15;
			x10 = x14;
		} break;
		case 0LL: { // None
			uint64_t v53 = mw_mirth_data_Tag_data(v3);
			VAL v54;
			VAL v55;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v53, x2, &v54, &v55);
			uint64_t x56;
			uint64_t x57;
			VAL x58;
			switch (get_data_tag(v5)) {
				case 0LL: { // Left
					VAL v59 = mtp_std_either_Either_2_Left(v5);
					int64_t v60;
					VAL v61;
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v59, v54, &v60, &v61);
					VAL v62 = (VVAL(VTUP(v61)->cells[1]));
					VAL v63;
					VAL v64;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v62, &v63, &v64);
					VAL v65 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v60, v63));
					VAL v66 = (mw_mirth_c99_ZPlusC99_indent(v64));
					int64_t v67 = VI64(VTUP(v65)->cells[1]);
					VAL v68 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v67);
					VAL v69 = (mw_mirth_c99_ZPlusC99_put(v68, v66));
					STR* v70;
					STRLIT(v70, " ", 1);
					VAL v71 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v70), v69));
					VAL v72 = VVAL(VTUP(v65)->cells[2]);
					incref(v72);
					VAL v73 = (mw_mirth_c99_ZPlusC99_put(v72, v71));
					STR* v74;
					STRLIT(v74, " = ", 3);
					VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v73));
					VAL v76 = mw_mirth_c99_C99ReprType_vZ_macro(v60);
					VAL v77 = (mw_mirth_c99_ZPlusC99_put(v76, v75));
					STR* v78;
					STRLIT(v78, "(VTUP(", 6);
					VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
					VAL v80;
					VAL v81;
					mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v55, &v80, &v81);
					VAL v82 = mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL(v80);
					VAL v83 = (mw_mirth_c99_ZPlusC99_put(v82, v79));
					STR* v84;
					STRLIT(v84, ")->cells[", 9);
					VAL v85 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v84), v83));
					int64_t v86;
					VAL v87;
					mw_mirth_c99_c99Z_tagZ_labelZ_index(v3, v4, v85, &v86, &v87);
					STR* v88 = i64_show(v86);
					VAL v89 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v88), v87));
					STR* v90;
					STRLIT(v90, "])", 2);
					VAL v91 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v90), v89));
					STR* v92;
					STRLIT(v92, ";", 1);
					VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
					VAL v94 = (mw_mirth_c99_ZPlusC99_line(v93));
					VTUP(v61)->cells[1] = v94;
					VAL v95;
					VAL v96;
					VAL v97;
					mw_mirth_c99_ZPlusC99Local_dupZ_localZBang(v61, v65, &v95, &v96, &v97);
					mw_mirth_c99_ZPlusC99Local_rdrop(v97);
					VAL v98 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v95, v96));
					uint64_t x99;
					uint64_t x100;
					VAL x101;
					switch (get_data_tag(v81)) {
						case 0LL: { // +Left
							VAL v102 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v81));
							VAL v103 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(v98, v102));
							x101 = v103;
							x100 = v4;
							x99 = v3;
						} break;
						case 1LL: { // +Right
							VAL v104 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v81));
							VAL v105 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v98, v104));
							x101 = v105;
							x100 = v4;
							x99 = v3;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x58 = x101;
					x57 = x100;
					x56 = x99;
				} break;
				case 1LL: { // Right
					VAL v106 = mtp_std_either_Either_2_Right(v5);
					int64_t v107;
					VAL v108;
					mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v106, v54, &v107, &v108);
					VAL v109 = (VVAL(VTUP(v108)->cells[1]));
					VAL v110;
					VAL v111;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v109, &v110, &v111);
					VAL v112 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v107, v110));
					VAL v113 = (mw_mirth_c99_ZPlusC99_indent(v111));
					int64_t v114 = VI64(VTUP(v112)->cells[1]);
					VAL v115 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v114);
					VAL v116 = (mw_mirth_c99_ZPlusC99_put(v115, v113));
					STR* v117;
					STRLIT(v117, " ", 1);
					VAL v118 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v117), v116));
					VAL v119 = VVAL(VTUP(v112)->cells[2]);
					incref(v119);
					VAL v120 = (mw_mirth_c99_ZPlusC99_put(v119, v118));
					STR* v121;
					STRLIT(v121, " = (", 4);
					VAL v122 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v121), v120));
					VAL v123 = mw_mirth_c99_C99ReprType_vZ_macro(v107);
					VAL v124 = (mw_mirth_c99_ZPlusC99_put(v123, v122));
					STR* v125;
					STRLIT(v125, "(VTUP(", 6);
					VAL v126 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v125), v124));
					VAL v127;
					VAL v128;
					mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v55, &v127, &v128);
					VAL v129 = mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL(v127);
					VAL v130 = (mw_mirth_c99_ZPlusC99_put(v129, v126));
					STR* v131;
					STRLIT(v131, ")->cells[", 9);
					VAL v132 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v131), v130));
					int64_t v133;
					VAL v134;
					mw_mirth_c99_c99Z_tagZ_labelZ_index(v3, v4, v132, &v133, &v134);
					STR* v135 = i64_show(v133);
					VAL v136 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v135), v134));
					STR* v137;
					STRLIT(v137, "])", 2);
					VAL v138 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v137), v136));
					STR* v139;
					STRLIT(v139, ");", 2);
					VAL v140 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v139), v138));
					VAL v141 = (mw_mirth_c99_ZPlusC99_line(v140));
					VTUP(v108)->cells[1] = v141;
					VAL v142 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v108, v112));
					lpush(&lbl_tag, MKU64(v3));
					lpush(&lbl_label, MKU64(v4));
					VAL v143 = (mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang(v142, v128));
					x58 = v143;
					uint64_t v144 = VU64(lpop(&lbl_label));
					x57 = v144;
					uint64_t v145 = VU64(lpop(&lbl_tag));
					x56 = v145;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x12 = x58;
			x11 = x56;
			x10 = x57;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x12;
}
static VAL mw_mirth_c99_c99Z_tagZ_setZ_labelZBang (VAL x1, VAL x2) {
	uint64_t v3;
	uint64_t v4;
	VAL v5;
	mtp_mirth_data_TagField_TagField(x1, &v3, &v4, &v5);
	VAL v6 = (VVAL(VTUP(x2)->cells[1]));
	VAL v7 = (VVAL(VTUP(v6)->cells[6]));
	VAL v8;
	VAL v9;
	mw_mirth_data_Tag_semiZ_transparentZAsk(v7, v3, &v8, &v9);
	VTUP(v6)->cells[6] = v8;
	VTUP(x2)->cells[1] = v6;
	uint64_t x10;
	uint64_t x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
			decref(v13);
			uint64_t x14;
			uint64_t x15;
			VAL x16;
			switch (get_data_tag(v5)) {
				case 0LL: { // Left
					VAL v17 = mtp_std_either_Either_2_Left(v5);
					uint64_t v18 = mw_mirth_data_Tag_data(v3);
					VAL v19;
					VAL v20;
					mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v18, x2, &v19, &v20);
					uint64_t x21;
					uint64_t x22;
					VAL x23;
					switch (get_data_tag(v20)) {
						case 1LL: { // +Right
							VAL v24 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v20));
							VAL v25 = (mw_mirth_c99_ZPlusC99LocalResource_dropZ_localZ_resourceZ_asZ_valueZBang(v19, v24));
							int64_t v26;
							VAL v27;
							mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v17, v25, &v26, &v27);
							VAL v28;
							VAL v29;
							mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v27, v26, &v28, &v29);
							VAL v30 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v29));
							VAL v31 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v28, v30));
							x23 = v31;
							x22 = v3;
							x21 = v4;
						} break;
						case 0LL: { // +Left
							VAL v32 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v20));
							decref(v17);
							VAL v33 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(v19, v32));
							x23 = v33;
							x22 = v3;
							x21 = v4;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x16 = x23;
					x15 = x22;
					x14 = x21;
				} break;
				case 1LL: { // Right
					VAL v34 = mtp_std_either_Either_2_Right(v5);
					int64_t v35 = 2LL /* C99RT_I64 */;
					VAL v36;
					VAL v37;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(x2, v35, &v36, &v37);
					mw_mirth_c99_ZPlusC99LocalResource_rdrop(v37);
					decref(v34);
					x16 = v36;
					x15 = v3;
					x14 = v4;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x12 = x16;
			x11 = x15;
			x10 = x14;
		} break;
		case 0LL: { // None
			uint64_t v38 = mw_mirth_data_Tag_data(v3);
			VAL v39;
			VAL v40;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v38, x2, &v39, &v40);
			incref(v5);
			uint64_t x41;
			uint64_t x42;
			VAL x43;
			VAL x44;
			VAL x45;
			VAL x46;
			switch (get_data_tag(v5)) {
				case 0LL: { // Left
					VAL v47 = mtp_std_either_Either_2_Left(v5);
					int64_t v48;
					VAL v49;
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v47, v39, &v48, &v49);
					VAL v50;
					VAL v51;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v49, v48, &v50, &v51);
					VAL v52 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v51);
					x46 = v52;
					x45 = v50;
					x44 = v5;
					x43 = v40;
					x42 = v3;
					x41 = v4;
				} break;
				case 1LL: { // Right
					VAL v53 = mtp_std_either_Either_2_Right(v5);
					int64_t v54;
					VAL v55;
					mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v53, v39, &v54, &v55);
					VAL v56;
					VAL v57;
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v55, v54, &v56, &v57);
					VAL v58 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v57);
					x46 = v58;
					x45 = v56;
					x44 = v5;
					x43 = v40;
					x42 = v3;
					x41 = v4;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			uint64_t x59;
			uint64_t x60;
			VAL x61;
			switch (get_data_tag(x43)) {
				case 0LL: { // +Left
					VAL v62 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x43));
					VAL v63 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v62);
					int64_t v64 = 0LL /* C99RT_VAL */;
					VAL v65 = (VVAL(VTUP(x45)->cells[1]));
					VAL v66;
					VAL v67;
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v65, &v66, &v67);
					VAL v68 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v64, v66));
					VAL v69 = (mw_mirth_c99_ZPlusC99_indent(v67));
					int64_t v70 = VI64(VTUP(v68)->cells[1]);
					VAL v71 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v70);
					VAL v72 = (mw_mirth_c99_ZPlusC99_put(v71, v69));
					STR* v73;
					STRLIT(v73, " ", 1);
					VAL v74 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v73), v72));
					VAL v75 = VVAL(VTUP(v68)->cells[2]);
					incref(v75);
					VAL v76 = (mw_mirth_c99_ZPlusC99_put(v75, v74));
					STR* v77;
					STRLIT(v77, " = ", 3);
					VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v77), v76));
					STR* v79;
					STRLIT(v79, "tup_replace(", 12);
					VAL v80 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v79), v78));
					VAL v81 = (mw_mirth_c99_ZPlusC99_put(v63, v80));
					STR* v82;
					STRLIT(v82, ", ", 2);
					VAL v83 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v82), v81));
					int64_t v84;
					VAL v85;
					mw_mirth_c99_c99Z_tagZ_labelZ_index(x42, x41, v83, &v84, &v85);
					STR* v86 = i64_show(v84);
					VAL v87 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v86), v85));
					STR* v88;
					STRLIT(v88, ", ", 2);
					VAL v89 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v88), v87));
					VAL v90 = (mw_mirth_c99_ZPlusC99_put(x46, v89));
					STR* v91;
					STRLIT(v91, ")", 1);
					VAL v92 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v91), v90));
					STR* v93;
					STRLIT(v93, ";", 1);
					VAL v94 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v93), v92));
					VAL v95 = (mw_mirth_c99_ZPlusC99_line(v94));
					VTUP(x45)->cells[1] = v95;
					VAL v96 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x45, v68));
					decref(x44);
					x61 = v96;
					x60 = x41;
					x59 = x42;
				} break;
				case 1LL: { // +Right
					VAL v97 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x43));
					uint64_t x98;
					uint64_t x99;
					VAL x100;
					VAL x101;
					VAL x102;
					switch (get_data_tag(x44)) {
						case 0LL: { // Left
							VAL v103 = mtp_std_either_Either_2_Left(x44);
							int64_t v104;
							VAL v105;
							mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v103, x45, &v104, &v105);
							int64_t v106 = mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk(v104);
							uint64_t x107;
							uint64_t x108;
							VAL x109;
							VAL x110;
							VAL x111;
							int64_t x112;
							if (((bool)v106)) {
								VAL v113 = (VVAL(VTUP(v105)->cells[1]));
								VAL v114;
								VAL v115;
								mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v113, &v114, &v115);
								VAL v116 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v104, v114));
								VAL v117 = (mw_mirth_c99_ZPlusC99_indent(v115));
								int64_t v118 = VI64(VTUP(v116)->cells[1]);
								VAL v119 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v118);
								VAL v120 = (mw_mirth_c99_ZPlusC99_put(v119, v117));
								STR* v121;
								STRLIT(v121, " ", 1);
								VAL v122 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v121), v120));
								VAL v123 = VVAL(VTUP(v116)->cells[2]);
								incref(v123);
								VAL v124 = (mw_mirth_c99_ZPlusC99_put(v123, v122));
								STR* v125;
								STRLIT(v125, " = ", 3);
								VAL v126 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v125), v124));
								STR* v127;
								STRLIT(v127, "VTUP(", 5);
								VAL v128 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v127), v126));
								VAL v129;
								VAL v130;
								mw_mirth_c99_ZPlusC99LocalResource_rdup(v97, &v129, &v130);
								VAL v131 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v129);
								VAL v132 = (mw_mirth_c99_ZPlusC99_put(v131, v128));
								STR* v133;
								STRLIT(v133, ")->cells[", 9);
								VAL v134 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v133), v132));
								int64_t v135;
								VAL v136;
								mw_mirth_c99_c99Z_tagZ_labelZ_index(x42, x41, v134, &v135, &v136);
								STR* v137 = i64_show(v135);
								VAL v138 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v137), v136));
								STR* v139;
								STRLIT(v139, "]", 1);
								VAL v140 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v139), v138));
								STR* v141;
								STRLIT(v141, ";", 1);
								VAL v142 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v141), v140));
								VAL v143 = (mw_mirth_c99_ZPlusC99_line(v142));
								VTUP(v105)->cells[1] = v143;
								VAL v144 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(v105, v116));
								x112 = v104;
								x111 = v144;
								x110 = v130;
								x109 = x46;
								x108 = x42;
								x107 = x41;
							} else {
								x112 = v104;
								x111 = v105;
								x110 = v97;
								x109 = x46;
								x108 = x42;
								x107 = x41;
							}
							x102 = x111;
							x101 = x110;
							x100 = x109;
							x99 = x108;
							x98 = x107;
						} break;
						case 1LL: { // Right
							VAL v145 = mtp_std_either_Either_2_Right(x44);
							decref(v145);
							x102 = x45;
							x101 = v97;
							x100 = x46;
							x99 = x42;
							x98 = x41;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v146 = (VVAL(VTUP(x102)->cells[1]));
					VAL v147 = (mw_mirth_c99_ZPlusC99_indent(v146));
					STR* v148;
					STRLIT(v148, "VTUP(", 5);
					VAL v149 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v148), v147));
					VAL v150;
					VAL v151;
					mw_mirth_c99_ZPlusC99LocalResource_rdup(x101, &v150, &v151);
					VAL v152 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v150);
					VAL v153 = (mw_mirth_c99_ZPlusC99_put(v152, v149));
					STR* v154;
					STRLIT(v154, ")->cells[", 9);
					VAL v155 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v154), v153));
					int64_t v156;
					VAL v157;
					mw_mirth_c99_c99Z_tagZ_labelZ_index(x99, x98, v155, &v156, &v157);
					STR* v158 = i64_show(v156);
					VAL v159 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v158), v157));
					STR* v160;
					STRLIT(v160, "] = ", 4);
					VAL v161 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v160), v159));
					VAL v162 = (mw_mirth_c99_ZPlusC99_put(x100, v161));
					STR* v163;
					STRLIT(v163, ";", 1);
					VAL v164 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v163), v162));
					VAL v165 = (mw_mirth_c99_ZPlusC99_line(v164));
					VTUP(x102)->cells[1] = v165;
					VAL v166 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x102, v151));
					x61 = v166;
					x60 = x98;
					x59 = x99;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x12 = x61;
			x11 = x59;
			x10 = x60;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x12;
}
static VAL mw_mirth_c99_c99Z_externalZ_blocksZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_external_ExternalBlock_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_externalZ_blockZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_external_ExternalBlock_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_externalZ_blockZBang (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_external_ExternalBlock_parts(x1);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v3, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			VAL x10;
			switch (get_data_tag(v9)) {
				case 0LL: { // EBPCode
					VAL v11 = mtp_mirth_external_ExternalBlockPart_EBPCode(v9);
					VAL v12 = (mw_mirth_c99_ZPlusC99_put(v11, x2));
					VAL v13 = (mw_mirth_c99_ZPlusC99_line(v12));
					x10 = v13;
				} break;
				case 1LL: { // EBPDef
					uint64_t v14 = mtp_mirth_external_ExternalBlockPart_EBPDef(v9);
					VAL v15 = (mw_mirth_c99_c99Z_externalZ_defZBang(v14, x2));
					x10 = v15;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v16 = 1LL /* True */;
			x8 = v16;
			x7 = v5;
			x6 = x10;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x8 = v17;
			x7 = v5;
			x6 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x6);
	VAL v19 = x7;
	int64_t v20 = x8;
	while (((bool)v20)) {
		VAL v21 = (v18);
		VAL v22 = v19;
		VAL v23;
		VAL v24;
		mw_std_list_List_1_uncons(v22, &v23, &v24);
		VAL x25;
		VAL x26;
		int64_t x27;
		switch (get_data_tag(v23)) {
			case 1LL: { // Some
				VAL v28 = mtp_std_maybe_Maybe_1_Some(v23);
				VAL x29;
				switch (get_data_tag(v28)) {
					case 0LL: { // EBPCode
						VAL v30 = mtp_mirth_external_ExternalBlockPart_EBPCode(v28);
						VAL v31 = (mw_mirth_c99_ZPlusC99_put(v30, v21));
						VAL v32 = (mw_mirth_c99_ZPlusC99_line(v31));
						x29 = v32;
					} break;
					case 1LL: { // EBPDef
						uint64_t v33 = mtp_mirth_external_ExternalBlockPart_EBPDef(v28);
						VAL v34 = (mw_mirth_c99_c99Z_externalZ_defZBang(v33, v21));
						x29 = v34;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v35 = 1LL /* True */;
				x27 = v35;
				x26 = v24;
				x25 = x29;
			} break;
			case 0LL: { // None
				int64_t v36 = 0LL /* False */;
				x27 = v36;
				x26 = v24;
				x25 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x27;
		v19 = x26;
		v18 = x25;
	}
	decref(v19);
	return v18;
}
static void mw_mirth_external_External_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_external_External_cname(x2, x1, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_external_External_type(v6, x1, &v8, &v9);
	*x5 = v8;
	*x4 = v9;
	*x3 = v7;
}
static void mw_mirth_external_External_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_external_External_ZTildec99Z_api(x1);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x1;
		x7 = x2;
	} else {
		VAL v11 = (VVAL(VTUP(x2)->cells[6]));
		VAL v12;
		VAL v13;
		VAL v14;
		mw_mirth_external_External_cnameZ_type(x1, v11, &v12, &v13, &v14);
		VTUP(x2)->cells[6] = v14;
		VAL v15;
		VAL v16;
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v12, v13, x2, &v15, &v16);
		incref(v15);
		mut_set(v15, v5);
		x9 = v15;
		x8 = x1;
		x7 = v16;
	}
	*x4 = x7;
	*x3 = x9;
}
static VAL mw_mirth_c99_c99Z_externalZ_callZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = (VVAL(VTUP(x3)->cells[1]));
	VAL v5;
	VAL v6;
	mw_mirth_external_External_c99Z_api(x2, v4, &v5, &v6);
	VTUP(x3)->cells[1] = v6;
	VAL v7 = (mw_mirth_c99_c99Z_smartZ_callZBang(x1, v5, x3));
	return v7;
}
static VAL mw_mirth_c99_c99Z_externalZ_defZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[6]));
	VAL v4;
	VAL v5;
	mw_mirth_external_External_ctype(v3, x1, &v4, &v5);
	VTUP(x2)->cells[6] = v4;
	incref(v5);
	VAL v6 = VVAL(VTUP(v5)->cells[2]);
	incref(v6);
	decref(v5);
	VAL v7 = VVAL(VTUP(v6)->cells[2]);
	incref(v7);
	decref(v6);
	VAL v8 = MKI64(0LL /* None */);
	VAL v9;
	VAL v10;
	mw_std_list_List_1_uncons(v7, &v9, &v10);
	uint64_t x11;
	VAL x12;
	VAL x13;
	VAL x14;
	VAL x15;
	int64_t x16;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v17 = mtp_std_maybe_Maybe_1_Some(v9);
			incref(v17);
			incref(v17);
			VAL v18 = mw_mirth_type_CTypeStackPart_labelZAsk(v17);
			int64_t v19 = mw_std_maybe_Maybe_1_noneZAsk(v18);
			uint64_t x20;
			VAL x21;
			VAL x22;
			int64_t x23;
			if (((bool)v19)) {
				VAL v24 = mw_mirth_type_CTypeStackPart_ctype(v17);
				int64_t v25 = mw_mirth_type_CType_phantomZAsk(v24);
				bool v26 = !((bool)v25);
				x23 = ((int64_t)v26);
				x22 = v5;
				x21 = x2;
				x20 = x1;
			} else {
				decref(v17);
				int64_t v27 = 0LL /* False */;
				x23 = v27;
				x22 = v5;
				x21 = x2;
				x20 = x1;
			}
			uint64_t x28;
			VAL x29;
			VAL x30;
			VAL x31;
			if (((bool)x23)) {
				VAL v32 = mtw_std_maybe_Maybe_1_Some(v17);
				x31 = v32;
				x30 = x22;
				x29 = x21;
				x28 = x20;
			} else {
				decref(v17);
				VAL v33 = MKI64(0LL /* None */);
				x31 = v33;
				x30 = x22;
				x29 = x21;
				x28 = x20;
			}
			uint64_t x34;
			VAL x35;
			VAL x36;
			VAL x37;
			VAL x38;
			switch (get_data_tag(x31)) {
				case 0LL: { // None
					x38 = v10;
					x37 = v8;
					x36 = x30;
					x35 = x29;
					x34 = x28;
				} break;
				default: {
					decref(v10);
					decref(v8);
					VAL v39 = MKI64(0LL /* Nil */);
					x38 = v39;
					x37 = x31;
					x36 = x30;
					x35 = x29;
					x34 = x28;
				} break;
			}
			int64_t v40 = 1LL /* True */;
			x16 = v40;
			x15 = x38;
			x14 = x37;
			x13 = x36;
			x12 = x35;
			x11 = x34;
		} break;
		case 0LL: { // None
			int64_t v41 = 0LL /* False */;
			x16 = v41;
			x15 = v10;
			x14 = v8;
			x13 = v5;
			x12 = x2;
			x11 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v42 = x11;
	VAL v43 = (x12);
	VAL v44 = x13;
	VAL v45 = x14;
	VAL v46 = x15;
	int64_t v47 = x16;
	while (((bool)v47)) {
		uint64_t v48 = v42;
		VAL v49 = (v43);
		VAL v50 = v44;
		VAL v51 = v45;
		VAL v52 = v46;
		VAL v53;
		VAL v54;
		mw_std_list_List_1_uncons(v52, &v53, &v54);
		uint64_t x55;
		VAL x56;
		VAL x57;
		VAL x58;
		VAL x59;
		int64_t x60;
		switch (get_data_tag(v53)) {
			case 1LL: { // Some
				VAL v61 = mtp_std_maybe_Maybe_1_Some(v53);
				incref(v61);
				incref(v61);
				VAL v62 = mw_mirth_type_CTypeStackPart_labelZAsk(v61);
				int64_t v63 = mw_std_maybe_Maybe_1_noneZAsk(v62);
				uint64_t x64;
				VAL x65;
				VAL x66;
				int64_t x67;
				if (((bool)v63)) {
					VAL v68 = mw_mirth_type_CTypeStackPart_ctype(v61);
					int64_t v69 = mw_mirth_type_CType_phantomZAsk(v68);
					bool v70 = !((bool)v69);
					x67 = ((int64_t)v70);
					x66 = v50;
					x65 = v49;
					x64 = v48;
				} else {
					decref(v61);
					int64_t v71 = 0LL /* False */;
					x67 = v71;
					x66 = v50;
					x65 = v49;
					x64 = v48;
				}
				uint64_t x72;
				VAL x73;
				VAL x74;
				VAL x75;
				if (((bool)x67)) {
					VAL v76 = mtw_std_maybe_Maybe_1_Some(v61);
					x75 = v76;
					x74 = x66;
					x73 = x65;
					x72 = x64;
				} else {
					decref(v61);
					VAL v77 = MKI64(0LL /* None */);
					x75 = v77;
					x74 = x66;
					x73 = x65;
					x72 = x64;
				}
				uint64_t x78;
				VAL x79;
				VAL x80;
				VAL x81;
				VAL x82;
				switch (get_data_tag(x75)) {
					case 0LL: { // None
						x82 = v54;
						x81 = v51;
						x80 = x74;
						x79 = x73;
						x78 = x72;
					} break;
					default: {
						decref(v54);
						decref(v51);
						VAL v83 = MKI64(0LL /* Nil */);
						x82 = v83;
						x81 = x75;
						x80 = x74;
						x79 = x73;
						x78 = x72;
					} break;
				}
				int64_t v84 = 1LL /* True */;
				x60 = v84;
				x59 = x82;
				x58 = x81;
				x57 = x80;
				x56 = x79;
				x55 = x78;
			} break;
			case 0LL: { // None
				int64_t v85 = 0LL /* False */;
				x60 = v85;
				x59 = v54;
				x58 = v51;
				x57 = v50;
				x56 = v49;
				x55 = v48;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v47 = x60;
		v46 = x59;
		v45 = x58;
		v44 = x57;
		v43 = x56;
		v42 = x55;
	}
	decref(v46);
	incref(v45);
	uint64_t x86;
	VAL x87;
	VAL x88;
	VAL x89;
	VAL x90;
	switch (get_data_tag(v45)) {
		case 1LL: { // Some
			VAL v91 = mtp_std_maybe_Maybe_1_Some(v45);
			VAL v92 = mw_mirth_type_CTypeStackPart_ctype(v91);
			x90 = v92;
			x89 = v45;
			x88 = v44;
			x87 = v43;
			x86 = v42;
		} break;
		case 0LL: { // None
			VAL v93 = MKI64(5LL /* Phantom */);
			x90 = v93;
			x89 = v45;
			x88 = v44;
			x87 = v43;
			x86 = v42;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v94 = mw_mirth_type_CType_cname(x90);
	VAL v95 = (mw_mirth_c99_ZPlusC99_put(v94, x87));
	STR* v96;
	STRLIT(v96, " ", 1);
	VAL v97 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v96), v95));
	VAL v98 = mw_mirth_external_External_symbol(x86);
	VAL v99 = (mw_mirth_c99_ZPlusC99_put(v98, v97));
	STR* v100;
	STRLIT(v100, " (", 2);
	VAL v101 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v100), v99));
	incref(x88);
	VAL v102 = VVAL(VTUP(x88)->cells[1]);
	incref(v102);
	decref(x88);
	VAL v103 = VVAL(VTUP(v102)->cells[2]);
	incref(v103);
	decref(v102);
	VAL v104 = MKI64(0LL /* Nil */);
	VAL v105 = mw_std_list_List_1_reverse(v104);
	VAL v106;
	VAL v107;
	mw_std_list_List_1_uncons(v103, &v106, &v107);
	VAL x108;
	uint64_t x109;
	VAL x110;
	VAL x111;
	VAL x112;
	VAL x113;
	int64_t x114;
	switch (get_data_tag(v106)) {
		case 1LL: { // Some
			VAL v115 = mtp_std_maybe_Maybe_1_Some(v106);
			incref(v115);
			VAL v116 = mw_mirth_type_CTypeStackPart_ctype(v115);
			int64_t v117 = mw_mirth_type_CType_phantomZAsk(v116);
			bool v118 = !((bool)v117);
			VAL x119;
			uint64_t x120;
			VAL x121;
			VAL x122;
			VAL x123;
			if (v118) {
				VAL v124 = mtw_std_maybe_Maybe_1_Some(v115);
				x123 = v124;
				x122 = x88;
				x121 = v101;
				x120 = x86;
				x119 = x89;
			} else {
				decref(v115);
				VAL v125 = MKI64(0LL /* None */);
				x123 = v125;
				x122 = x88;
				x121 = v101;
				x120 = x86;
				x119 = x89;
			}
			VAL x126;
			switch (get_data_tag(x123)) {
				case 1LL: { // Some
					VAL v127 = mtp_std_maybe_Maybe_1_Some(x123);
					VAL v128 = mtw_std_list_List_1_Cons(v127, v105);
					x126 = v128;
					lpush(&lbl_outty, x119);
					lpush(&lbl_ext, MKU64(x120));
					push_resource(x121);
					lpush(&lbl_cty, x122);
				} break;
				case 0LL: { // None
					x126 = v105;
					lpush(&lbl_outty, x119);
					lpush(&lbl_ext, MKU64(x120));
					push_resource(x121);
					lpush(&lbl_cty, x122);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v129 = 1LL /* True */;
			x114 = v129;
			x113 = v107;
			x112 = x126;
			VAL v130 = lpop(&lbl_cty);
			x111 = v130;
			VAL r131 = pop_resource();
			x110 = r131;
			uint64_t v132 = VU64(lpop(&lbl_ext));
			x109 = v132;
			VAL v133 = lpop(&lbl_outty);
			x108 = v133;
		} break;
		case 0LL: { // None
			int64_t v134 = 0LL /* False */;
			x114 = v134;
			x113 = v107;
			x112 = v105;
			x111 = x88;
			x110 = v101;
			x109 = x86;
			x108 = x89;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v135 = x108;
	uint64_t v136 = x109;
	VAL v137 = (x110);
	VAL v138 = x111;
	VAL v139 = (x112);
	VAL v140 = x113;
	int64_t v141 = x114;
	while (((bool)v141)) {
		VAL v142 = v135;
		uint64_t v143 = v136;
		VAL v144 = (v137);
		VAL v145 = v138;
		VAL v146 = (v139);
		VAL v147 = v140;
		VAL v148;
		VAL v149;
		mw_std_list_List_1_uncons(v147, &v148, &v149);
		VAL x150;
		uint64_t x151;
		VAL x152;
		VAL x153;
		VAL x154;
		VAL x155;
		int64_t x156;
		switch (get_data_tag(v148)) {
			case 1LL: { // Some
				VAL v157 = mtp_std_maybe_Maybe_1_Some(v148);
				incref(v157);
				VAL v158 = mw_mirth_type_CTypeStackPart_ctype(v157);
				int64_t v159 = mw_mirth_type_CType_phantomZAsk(v158);
				bool v160 = !((bool)v159);
				VAL x161;
				uint64_t x162;
				VAL x163;
				VAL x164;
				VAL x165;
				if (v160) {
					VAL v166 = mtw_std_maybe_Maybe_1_Some(v157);
					x165 = v166;
					x164 = v145;
					x163 = v144;
					x162 = v143;
					x161 = v142;
				} else {
					decref(v157);
					VAL v167 = MKI64(0LL /* None */);
					x165 = v167;
					x164 = v145;
					x163 = v144;
					x162 = v143;
					x161 = v142;
				}
				VAL x168;
				switch (get_data_tag(x165)) {
					case 1LL: { // Some
						VAL v169 = mtp_std_maybe_Maybe_1_Some(x165);
						VAL v170 = mtw_std_list_List_1_Cons(v169, v146);
						x168 = v170;
						lpush(&lbl_outty, x161);
						lpush(&lbl_ext, MKU64(x162));
						push_resource(x163);
						lpush(&lbl_cty, x164);
					} break;
					case 0LL: { // None
						x168 = v146;
						lpush(&lbl_outty, x161);
						lpush(&lbl_ext, MKU64(x162));
						push_resource(x163);
						lpush(&lbl_cty, x164);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v171 = 1LL /* True */;
				x156 = v171;
				x155 = v149;
				x154 = x168;
				VAL v172 = lpop(&lbl_cty);
				x153 = v172;
				VAL r173 = pop_resource();
				x152 = r173;
				uint64_t v174 = VU64(lpop(&lbl_ext));
				x151 = v174;
				VAL v175 = lpop(&lbl_outty);
				x150 = v175;
			} break;
			case 0LL: { // None
				int64_t v176 = 0LL /* False */;
				x156 = v176;
				x155 = v149;
				x154 = v146;
				x153 = v145;
				x152 = v144;
				x151 = v143;
				x150 = v142;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v141 = x156;
		v140 = x155;
		v139 = x154;
		v138 = x153;
		v137 = x152;
		v136 = x151;
		v135 = x150;
	}
	decref(v140);
	VAL v177 = mw_std_list_List_1_reverse(v139);
	VAL x178;
	uint64_t x179;
	VAL x180;
	VAL x181;
	switch (get_data_tag(v177)) {
		case 0LL: { // Nil
			STR* v182;
			STRLIT(v182, "void", 4);
			VAL v183 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v182), v137));
			x181 = v183;
			x180 = v138;
			x179 = v136;
			x178 = v135;
		} break;
		default: {
			VAL v184;
			VAL v185;
			mw_std_list_List_1_uncons(v177, &v184, &v185);
			VAL x186;
			uint64_t x187;
			VAL x188;
			VAL x189;
			switch (get_data_tag(v184)) {
				case 1LL: { // Some
					VAL v190 = mtp_std_maybe_Maybe_1_Some(v184);
					VAL v191 = mw_mirth_type_CTypeStackPart_ctype(v190);
					VAL v192 = mw_mirth_type_CType_cname(v191);
					VAL v193 = (mw_mirth_c99_ZPlusC99_put(v192, v137));
					x189 = v138;
					x188 = v193;
					x187 = v136;
					x186 = v135;
				} break;
				case 0LL: { // None
					x189 = v138;
					x188 = v137;
					x187 = v136;
					x186 = v135;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v194;
			VAL v195;
			mw_std_list_List_1_uncons(v185, &v194, &v195);
			VAL x196;
			uint64_t x197;
			VAL x198;
			VAL x199;
			VAL x200;
			int64_t x201;
			switch (get_data_tag(v194)) {
				case 1LL: { // Some
					VAL v202 = mtp_std_maybe_Maybe_1_Some(v194);
					STR* v203;
					STRLIT(v203, ", ", 2);
					VAL v204 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v203), x188));
					VAL v205 = mw_mirth_type_CTypeStackPart_ctype(v202);
					VAL v206 = mw_mirth_type_CType_cname(v205);
					VAL v207 = (mw_mirth_c99_ZPlusC99_put(v206, v204));
					int64_t v208 = 1LL /* True */;
					x201 = v208;
					x200 = v195;
					x199 = x189;
					x198 = v207;
					x197 = x187;
					x196 = x186;
				} break;
				case 0LL: { // None
					int64_t v209 = 0LL /* False */;
					x201 = v209;
					x200 = v195;
					x199 = x189;
					x198 = x188;
					x197 = x187;
					x196 = x186;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v210 = x196;
			uint64_t v211 = x197;
			VAL v212 = (x198);
			VAL v213 = x199;
			VAL v214 = x200;
			int64_t v215 = x201;
			while (((bool)v215)) {
				VAL v216 = v210;
				uint64_t v217 = v211;
				VAL v218 = (v212);
				VAL v219 = v213;
				VAL v220 = v214;
				VAL v221;
				VAL v222;
				mw_std_list_List_1_uncons(v220, &v221, &v222);
				VAL x223;
				uint64_t x224;
				VAL x225;
				VAL x226;
				VAL x227;
				int64_t x228;
				switch (get_data_tag(v221)) {
					case 1LL: { // Some
						VAL v229 = mtp_std_maybe_Maybe_1_Some(v221);
						STR* v230;
						STRLIT(v230, ", ", 2);
						VAL v231 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v230), v218));
						VAL v232 = mw_mirth_type_CTypeStackPart_ctype(v229);
						VAL v233 = mw_mirth_type_CType_cname(v232);
						VAL v234 = (mw_mirth_c99_ZPlusC99_put(v233, v231));
						int64_t v235 = 1LL /* True */;
						x228 = v235;
						x227 = v222;
						x226 = v219;
						x225 = v234;
						x224 = v217;
						x223 = v216;
					} break;
					case 0LL: { // None
						int64_t v236 = 0LL /* False */;
						x228 = v236;
						x227 = v222;
						x226 = v219;
						x225 = v218;
						x224 = v217;
						x223 = v216;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v215 = x228;
				v214 = x227;
				v213 = x226;
				v212 = x225;
				v211 = x224;
				v210 = x223;
			}
			decref(v214);
			x181 = v212;
			x180 = v213;
			x179 = v211;
			x178 = v210;
		} break;
	}
	STR* v237;
	STRLIT(v237, ");", 2);
	VAL v238 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v237), x181));
	VAL v239 = (mw_mirth_c99_ZPlusC99_line(v238));
	VAL v240;
	VAL v241;
	mw_mirth_external_External_c99Z_api(x179, v239, &v240, &v241);
	VAL v242 = (mw_mirth_c99_ZPlusC99_indent(v241));
	incref(v240);
	VAL v243 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v240, v242));
	STR* v244;
	STRLIT(v244, " {", 2);
	VAL v245 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v244), v243));
	VAL v246 = (mw_mirth_c99_ZPlusC99_line(v245));
	int64_t v247 = VI64(VTUP(v246)->cells[2]);
	int64_t v248 = 1LL;
	int64_t v249 = i64_add(v247, v248);
	VTUP(v246)->cells[2] = MKI64(v249);
	incref(v240);
	VAL v250 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v240, v246));
	incref(x180);
	VAL v251 = VVAL(VTUP(x180)->cells[1]);
	incref(v251);
	decref(x180);
	VAL v252 = VVAL(VTUP(v251)->cells[2]);
	incref(v252);
	decref(v251);
	incref(v252);
	int64_t v253 = mw_std_list_List_1_len(v252);
	VAL v254 = mw_std_list_List_1_reverse(v252);
	VAL v255;
	VAL v256;
	mw_std_list_List_1_uncons(v254, &v255, &v256);
	VAL x257;
	uint64_t x258;
	VAL x259;
	VAL x260;
	int64_t x261;
	VAL x262;
	int64_t x263;
	switch (get_data_tag(v255)) {
		case 1LL: { // Some
			VAL v264 = mtp_std_maybe_Maybe_1_Some(v255);
			incref(v264);
			VAL v265;
			VAL v266;
			mw_mirth_type_CTypeStackPart_c99Z_pop(v264, v250, &v265, &v266);
			incref(v264);
			VAL v267 = mw_mirth_type_CTypeStackPart_ctype(v264);
			int64_t v268 = mw_mirth_type_CType_phantomZAsk(v267);
			VAL x269;
			uint64_t x270;
			VAL x271;
			int64_t x272;
			VAL x273;
			VAL x274;
			if (((bool)v268)) {
				decref(v265);
				x274 = v264;
				x273 = v266;
				x272 = v253;
				x271 = x180;
				x270 = x179;
				x269 = x178;
			} else {
				VAL v275 = (VVAL(VTUP(v266)->cells[1]));
				VAL v276 = (mw_mirth_c99_ZPlusC99_indent(v275));
				incref(v264);
				VAL v277 = mw_mirth_type_CTypeStackPart_ctype(v264);
				VAL v278 = mw_mirth_type_CType_cname(v277);
				VAL v279 = (mw_mirth_c99_ZPlusC99_put(v278, v276));
				STR* v280;
				STRLIT(v280, " ", 1);
				VAL v281 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v280), v279));
				incref(v264);
				int64_t v282;
				VAL v283;
				VAL v284;
				mw_mirth_type_CTypeStackPart_c99Z_argZ_name(v253, v264, v281, &v282, &v283, &v284);
				VAL v285 = (mw_mirth_c99_ZPlusC99_put(v283, v284));
				STR* v286;
				STRLIT(v286, " = (", 4);
				VAL v287 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v286), v285));
				incref(v264);
				VAL v288 = mw_mirth_type_CTypeStackPart_ctype(v264);
				VAL v289 = mw_mirth_type_CType_cname(v288);
				VAL v290 = (mw_mirth_c99_ZPlusC99_put(v289, v287));
				STR* v291;
				STRLIT(v291, ")(", 2);
				VAL v292 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v291), v290));
				VAL v293 = (mw_mirth_c99_ZPlusC99_put(v265, v292));
				STR* v294;
				STRLIT(v294, ");", 2);
				VAL v295 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v294), v293));
				VAL v296 = (mw_mirth_c99_ZPlusC99_line(v295));
				VTUP(v266)->cells[1] = v296;
				x274 = v264;
				x273 = v266;
				x272 = v282;
				x271 = x180;
				x270 = x179;
				x269 = x178;
			}
			decref(x274);
			int64_t v297 = 1LL;
			int64_t v298 = i64_sub(x272, v297);
			int64_t v299 = 0LL;
			bool v300 = (v298 < v299);
			int64_t x301;
			if (v300) {
				int64_t v302 = 0LL;
				x301 = v302;
				lpush(&lbl_outty, x269);
				lpush(&lbl_ext, MKU64(x270));
				lpush(&lbl_cty, x271);
				push_resource(x273);
			} else {
				x301 = v298;
				lpush(&lbl_outty, x269);
				lpush(&lbl_ext, MKU64(x270));
				lpush(&lbl_cty, x271);
				push_resource(x273);
			}
			int64_t v303 = 1LL /* True */;
			x263 = v303;
			x262 = v256;
			x261 = x301;
			VAL v304 = lpop(&lbl_cty);
			x260 = v304;
			VAL r305 = pop_resource();
			x259 = r305;
			uint64_t v306 = VU64(lpop(&lbl_ext));
			x258 = v306;
			VAL v307 = lpop(&lbl_outty);
			x257 = v307;
		} break;
		case 0LL: { // None
			int64_t v308 = 0LL /* False */;
			x263 = v308;
			x262 = v256;
			x261 = v253;
			x260 = x180;
			x259 = v250;
			x258 = x179;
			x257 = x178;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v309 = x257;
	uint64_t v310 = x258;
	VAL v311 = (x259);
	VAL v312 = x260;
	int64_t v313 = x261;
	VAL v314 = x262;
	int64_t v315 = x263;
	while (((bool)v315)) {
		VAL v316 = v309;
		uint64_t v317 = v310;
		VAL v318 = (v311);
		VAL v319 = v312;
		int64_t v320 = v313;
		VAL v321 = v314;
		VAL v322;
		VAL v323;
		mw_std_list_List_1_uncons(v321, &v322, &v323);
		VAL x324;
		uint64_t x325;
		VAL x326;
		VAL x327;
		int64_t x328;
		VAL x329;
		int64_t x330;
		switch (get_data_tag(v322)) {
			case 1LL: { // Some
				VAL v331 = mtp_std_maybe_Maybe_1_Some(v322);
				incref(v331);
				VAL v332;
				VAL v333;
				mw_mirth_type_CTypeStackPart_c99Z_pop(v331, v318, &v332, &v333);
				incref(v331);
				VAL v334 = mw_mirth_type_CTypeStackPart_ctype(v331);
				int64_t v335 = mw_mirth_type_CType_phantomZAsk(v334);
				VAL x336;
				uint64_t x337;
				VAL x338;
				int64_t x339;
				VAL x340;
				VAL x341;
				if (((bool)v335)) {
					decref(v332);
					x341 = v331;
					x340 = v333;
					x339 = v320;
					x338 = v319;
					x337 = v317;
					x336 = v316;
				} else {
					VAL v342 = (VVAL(VTUP(v333)->cells[1]));
					VAL v343 = (mw_mirth_c99_ZPlusC99_indent(v342));
					incref(v331);
					VAL v344 = mw_mirth_type_CTypeStackPart_ctype(v331);
					VAL v345 = mw_mirth_type_CType_cname(v344);
					VAL v346 = (mw_mirth_c99_ZPlusC99_put(v345, v343));
					STR* v347;
					STRLIT(v347, " ", 1);
					VAL v348 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v347), v346));
					incref(v331);
					int64_t v349;
					VAL v350;
					VAL v351;
					mw_mirth_type_CTypeStackPart_c99Z_argZ_name(v320, v331, v348, &v349, &v350, &v351);
					VAL v352 = (mw_mirth_c99_ZPlusC99_put(v350, v351));
					STR* v353;
					STRLIT(v353, " = (", 4);
					VAL v354 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v353), v352));
					incref(v331);
					VAL v355 = mw_mirth_type_CTypeStackPart_ctype(v331);
					VAL v356 = mw_mirth_type_CType_cname(v355);
					VAL v357 = (mw_mirth_c99_ZPlusC99_put(v356, v354));
					STR* v358;
					STRLIT(v358, ")(", 2);
					VAL v359 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v358), v357));
					VAL v360 = (mw_mirth_c99_ZPlusC99_put(v332, v359));
					STR* v361;
					STRLIT(v361, ");", 2);
					VAL v362 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v361), v360));
					VAL v363 = (mw_mirth_c99_ZPlusC99_line(v362));
					VTUP(v333)->cells[1] = v363;
					x341 = v331;
					x340 = v333;
					x339 = v349;
					x338 = v319;
					x337 = v317;
					x336 = v316;
				}
				decref(x341);
				int64_t v364 = 1LL;
				int64_t v365 = i64_sub(x339, v364);
				int64_t v366 = 0LL;
				bool v367 = (v365 < v366);
				int64_t x368;
				if (v367) {
					int64_t v369 = 0LL;
					x368 = v369;
					lpush(&lbl_outty, x336);
					lpush(&lbl_ext, MKU64(x337));
					lpush(&lbl_cty, x338);
					push_resource(x340);
				} else {
					x368 = v365;
					lpush(&lbl_outty, x336);
					lpush(&lbl_ext, MKU64(x337));
					lpush(&lbl_cty, x338);
					push_resource(x340);
				}
				int64_t v370 = 1LL /* True */;
				x330 = v370;
				x329 = v323;
				x328 = x368;
				VAL v371 = lpop(&lbl_cty);
				x327 = v371;
				VAL r372 = pop_resource();
				x326 = r372;
				uint64_t v373 = VU64(lpop(&lbl_ext));
				x325 = v373;
				VAL v374 = lpop(&lbl_outty);
				x324 = v374;
			} break;
			case 0LL: { // None
				int64_t v375 = 0LL /* False */;
				x330 = v375;
				x329 = v323;
				x328 = v320;
				x327 = v319;
				x326 = v318;
				x325 = v317;
				x324 = v316;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v315 = x330;
		v314 = x329;
		v313 = x328;
		v312 = x327;
		v311 = x326;
		v310 = x325;
		v309 = x324;
	}
	decref(v314);
	VAL v376 = (VVAL(VTUP(v311)->cells[1]));
	VAL v377 = (mw_mirth_c99_ZPlusC99_indent(v376));
	incref(v309);
	uint64_t x378;
	VAL x379;
	int64_t x380;
	VAL x381;
	VAL x382;
	switch (get_data_tag(v309)) {
		case 1LL: { // Some
			VAL v383 = mtp_std_maybe_Maybe_1_Some(v309);
			VAL v384 = mw_mirth_type_CTypeStackPart_ctype(v383);
			VAL v385 = mw_mirth_type_CType_cname(v384);
			VAL v386 = (mw_mirth_c99_ZPlusC99_put(v385, v377));
			STR* v387;
			STRLIT(v387, " Y = ", 5);
			VAL v388 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v387), v386));
			x382 = v309;
			x381 = v388;
			x380 = v313;
			x379 = v312;
			x378 = v310;
		} break;
		case 0LL: { // None
			x382 = v309;
			x381 = v377;
			x380 = v313;
			x379 = v312;
			x378 = v310;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v389 = mw_mirth_external_External_symbol(x378);
	VAL v390 = (mw_mirth_c99_ZPlusC99_put(v389, x381));
	STR* v391;
	STRLIT(v391, "(", 1);
	VAL v392 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v391), v390));
	int64_t v393 = 1LL;
	incref(x379);
	VAL v394 = VVAL(VTUP(x379)->cells[1]);
	incref(v394);
	decref(x379);
	VAL v395 = VVAL(VTUP(v394)->cells[2]);
	incref(v395);
	decref(v394);
	VAL v396 = MKI64(0LL /* Nil */);
	VAL v397 = mw_std_list_List_1_reverse(v396);
	VAL v398;
	VAL v399;
	mw_std_list_List_1_uncons(v395, &v398, &v399);
	VAL x400;
	uint64_t x401;
	VAL x402;
	int64_t x403;
	VAL x404;
	VAL x405;
	VAL x406;
	int64_t x407;
	switch (get_data_tag(v398)) {
		case 1LL: { // Some
			VAL v408 = mtp_std_maybe_Maybe_1_Some(v398);
			incref(v408);
			VAL v409 = mw_mirth_type_CTypeStackPart_ctype(v408);
			int64_t v410 = mw_mirth_type_CType_phantomZAsk(v409);
			VAL x411;
			uint64_t x412;
			VAL x413;
			int64_t x414;
			VAL x415;
			VAL x416;
			if (((bool)v410)) {
				decref(v408);
				VAL v417 = MKI64(0LL /* None */);
				x416 = v417;
				x415 = x379;
				x414 = v393;
				x413 = v392;
				x412 = x378;
				x411 = x382;
			} else {
				int64_t v418;
				VAL v419;
				VAL v420;
				mw_mirth_type_CTypeStackPart_c99Z_argZ_name(v393, v408, v392, &v418, &v419, &v420);
				VAL v421 = mtw_std_maybe_Maybe_1_Some(v419);
				x416 = v421;
				x415 = x379;
				x414 = v418;
				x413 = v420;
				x412 = x378;
				x411 = x382;
			}
			int64_t v422 = 1LL;
			int64_t v423 = i64_add(x414, v422);
			VAL x424;
			switch (get_data_tag(x416)) {
				case 1LL: { // Some
					VAL v425 = mtp_std_maybe_Maybe_1_Some(x416);
					VAL v426 = mtw_std_list_List_1_Cons(v425, v397);
					x424 = v426;
					lpush(&lbl_outty, x411);
					lpush(&lbl_ext, MKU64(x412));
					push_resource(x413);
					lpush(&lbl_cty, x415);
					lpush(&lbl_argZ_index, MKI64(v423));
				} break;
				case 0LL: { // None
					x424 = v397;
					lpush(&lbl_outty, x411);
					lpush(&lbl_ext, MKU64(x412));
					push_resource(x413);
					lpush(&lbl_cty, x415);
					lpush(&lbl_argZ_index, MKI64(v423));
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v427 = 1LL /* True */;
			x407 = v427;
			x406 = v399;
			x405 = x424;
			VAL v428 = lpop(&lbl_cty);
			x404 = v428;
			int64_t v429 = VI64(lpop(&lbl_argZ_index));
			x403 = v429;
			VAL r430 = pop_resource();
			x402 = r430;
			uint64_t v431 = VU64(lpop(&lbl_ext));
			x401 = v431;
			VAL v432 = lpop(&lbl_outty);
			x400 = v432;
		} break;
		case 0LL: { // None
			int64_t v433 = 0LL /* False */;
			x407 = v433;
			x406 = v399;
			x405 = v397;
			x404 = x379;
			x403 = v393;
			x402 = v392;
			x401 = x378;
			x400 = x382;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v434 = x400;
	uint64_t v435 = x401;
	VAL v436 = (x402);
	int64_t v437 = x403;
	VAL v438 = x404;
	VAL v439 = (x405);
	VAL v440 = x406;
	int64_t v441 = x407;
	while (((bool)v441)) {
		VAL v442 = v434;
		uint64_t v443 = v435;
		VAL v444 = (v436);
		int64_t v445 = v437;
		VAL v446 = v438;
		VAL v447 = (v439);
		VAL v448 = v440;
		VAL v449;
		VAL v450;
		mw_std_list_List_1_uncons(v448, &v449, &v450);
		VAL x451;
		uint64_t x452;
		VAL x453;
		int64_t x454;
		VAL x455;
		VAL x456;
		VAL x457;
		int64_t x458;
		switch (get_data_tag(v449)) {
			case 1LL: { // Some
				VAL v459 = mtp_std_maybe_Maybe_1_Some(v449);
				incref(v459);
				VAL v460 = mw_mirth_type_CTypeStackPart_ctype(v459);
				int64_t v461 = mw_mirth_type_CType_phantomZAsk(v460);
				VAL x462;
				uint64_t x463;
				VAL x464;
				int64_t x465;
				VAL x466;
				VAL x467;
				if (((bool)v461)) {
					decref(v459);
					VAL v468 = MKI64(0LL /* None */);
					x467 = v468;
					x466 = v446;
					x465 = v445;
					x464 = v444;
					x463 = v443;
					x462 = v442;
				} else {
					int64_t v469;
					VAL v470;
					VAL v471;
					mw_mirth_type_CTypeStackPart_c99Z_argZ_name(v445, v459, v444, &v469, &v470, &v471);
					VAL v472 = mtw_std_maybe_Maybe_1_Some(v470);
					x467 = v472;
					x466 = v446;
					x465 = v469;
					x464 = v471;
					x463 = v443;
					x462 = v442;
				}
				int64_t v473 = 1LL;
				int64_t v474 = i64_add(x465, v473);
				VAL x475;
				switch (get_data_tag(x467)) {
					case 1LL: { // Some
						VAL v476 = mtp_std_maybe_Maybe_1_Some(x467);
						VAL v477 = mtw_std_list_List_1_Cons(v476, v447);
						x475 = v477;
						lpush(&lbl_outty, x462);
						lpush(&lbl_ext, MKU64(x463));
						push_resource(x464);
						lpush(&lbl_cty, x466);
						lpush(&lbl_argZ_index, MKI64(v474));
					} break;
					case 0LL: { // None
						x475 = v447;
						lpush(&lbl_outty, x462);
						lpush(&lbl_ext, MKU64(x463));
						push_resource(x464);
						lpush(&lbl_cty, x466);
						lpush(&lbl_argZ_index, MKI64(v474));
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v478 = 1LL /* True */;
				x458 = v478;
				x457 = v450;
				x456 = x475;
				VAL v479 = lpop(&lbl_cty);
				x455 = v479;
				int64_t v480 = VI64(lpop(&lbl_argZ_index));
				x454 = v480;
				VAL r481 = pop_resource();
				x453 = r481;
				uint64_t v482 = VU64(lpop(&lbl_ext));
				x452 = v482;
				VAL v483 = lpop(&lbl_outty);
				x451 = v483;
			} break;
			case 0LL: { // None
				int64_t v484 = 0LL /* False */;
				x458 = v484;
				x457 = v450;
				x456 = v447;
				x455 = v446;
				x454 = v445;
				x453 = v444;
				x452 = v443;
				x451 = v442;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v441 = x458;
		v440 = x457;
		v439 = x456;
		v438 = x455;
		v437 = x454;
		v436 = x453;
		v435 = x452;
		v434 = x451;
	}
	decref(v440);
	VAL v485 = mw_std_list_List_1_reverse(v439);
	VAL v486;
	VAL v487;
	mw_std_list_List_1_uncons(v485, &v486, &v487);
	VAL x488;
	uint64_t x489;
	VAL x490;
	int64_t x491;
	VAL x492;
	switch (get_data_tag(v486)) {
		case 1LL: { // Some
			VAL v493 = mtp_std_maybe_Maybe_1_Some(v486);
			VAL v494 = (mw_mirth_c99_ZPlusC99_put(v493, v436));
			x492 = v438;
			x491 = v437;
			x490 = v494;
			x489 = v435;
			x488 = v434;
		} break;
		case 0LL: { // None
			x492 = v438;
			x491 = v437;
			x490 = v436;
			x489 = v435;
			x488 = v434;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v495;
	VAL v496;
	mw_std_list_List_1_uncons(v487, &v495, &v496);
	VAL x497;
	uint64_t x498;
	VAL x499;
	int64_t x500;
	VAL x501;
	VAL x502;
	int64_t x503;
	switch (get_data_tag(v495)) {
		case 1LL: { // Some
			VAL v504 = mtp_std_maybe_Maybe_1_Some(v495);
			STR* v505;
			STRLIT(v505, ", ", 2);
			VAL v506 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v505), x490));
			VAL v507 = (mw_mirth_c99_ZPlusC99_put(v504, v506));
			int64_t v508 = 1LL /* True */;
			x503 = v508;
			x502 = v496;
			x501 = x492;
			x500 = x491;
			x499 = v507;
			x498 = x489;
			x497 = x488;
		} break;
		case 0LL: { // None
			int64_t v509 = 0LL /* False */;
			x503 = v509;
			x502 = v496;
			x501 = x492;
			x500 = x491;
			x499 = x490;
			x498 = x489;
			x497 = x488;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v510 = x497;
	uint64_t v511 = x498;
	VAL v512 = (x499);
	int64_t v513 = x500;
	VAL v514 = x501;
	VAL v515 = x502;
	int64_t v516 = x503;
	while (((bool)v516)) {
		VAL v517 = v510;
		uint64_t v518 = v511;
		VAL v519 = (v512);
		int64_t v520 = v513;
		VAL v521 = v514;
		VAL v522 = v515;
		VAL v523;
		VAL v524;
		mw_std_list_List_1_uncons(v522, &v523, &v524);
		VAL x525;
		uint64_t x526;
		VAL x527;
		int64_t x528;
		VAL x529;
		VAL x530;
		int64_t x531;
		switch (get_data_tag(v523)) {
			case 1LL: { // Some
				VAL v532 = mtp_std_maybe_Maybe_1_Some(v523);
				STR* v533;
				STRLIT(v533, ", ", 2);
				VAL v534 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v533), v519));
				VAL v535 = (mw_mirth_c99_ZPlusC99_put(v532, v534));
				int64_t v536 = 1LL /* True */;
				x531 = v536;
				x530 = v524;
				x529 = v521;
				x528 = v520;
				x527 = v535;
				x526 = v518;
				x525 = v517;
			} break;
			case 0LL: { // None
				int64_t v537 = 0LL /* False */;
				x531 = v537;
				x530 = v524;
				x529 = v521;
				x528 = v520;
				x527 = v519;
				x526 = v518;
				x525 = v517;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v516 = x531;
		v515 = x530;
		v514 = x529;
		v513 = x528;
		v512 = x527;
		v511 = x526;
		v510 = x525;
	}
	decref(v515);
	STR* v538;
	STRLIT(v538, ");", 2);
	VAL v539 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v538), v512));
	VAL v540 = (mw_mirth_c99_ZPlusC99_line(v539));
	VTUP(v311)->cells[1] = v540;
	incref(v514);
	VAL v541 = VVAL(VTUP(v514)->cells[2]);
	incref(v541);
	decref(v514);
	VAL v542 = VVAL(VTUP(v541)->cells[2]);
	incref(v542);
	decref(v541);
	VAL v543;
	VAL v544;
	mw_std_list_List_1_uncons(v542, &v543, &v544);
	VAL x545;
	uint64_t x546;
	int64_t x547;
	VAL x548;
	VAL x549;
	VAL x550;
	int64_t x551;
	switch (get_data_tag(v543)) {
		case 1LL: { // Some
			VAL v552 = mtp_std_maybe_Maybe_1_Some(v543);
			incref(v552);
			incref(v552);
			VAL v553 = mw_mirth_type_CTypeStackPart_ctype(v552);
			int64_t v554 = mw_mirth_type_CType_phantomZAsk(v553);
			VAL x555;
			uint64_t x556;
			int64_t x557;
			VAL x558;
			VAL x559;
			VAL x560;
			if (((bool)v554)) {
				decref(v552);
				STR* v561;
				STRLIT(v561, "0", 1);
				x560 = MKSTR(v561);
				x559 = v514;
				x558 = v311;
				x557 = v513;
				x556 = v511;
				x555 = v510;
			} else {
				VAL v562 = mw_mirth_type_CTypeStackPart_labelZAsk(v552);
				VAL x563;
				uint64_t x564;
				int64_t x565;
				VAL x566;
				VAL x567;
				VAL x568;
				switch (get_data_tag(v562)) {
					case 1LL: { // Some
						VAL v569 = mtp_std_maybe_Maybe_1_Some(v562);
						uint64_t v570 = mw_mirth_label_Label_name(VU64(v569));
						VAL v571 = mw_mirth_name_Name_mangled(v570);
						x568 = v571;
						x567 = v514;
						x566 = v311;
						x565 = v513;
						x564 = v511;
						x563 = v510;
					} break;
					case 0LL: { // None
						STR* v572;
						STRLIT(v572, "Y", 1);
						x568 = MKSTR(v572);
						x567 = v514;
						x566 = v311;
						x565 = v513;
						x564 = v511;
						x563 = v510;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x560 = x568;
				x559 = x567;
				x558 = x566;
				x557 = x565;
				x556 = x564;
				x555 = x563;
			}
			VAL v573 = (mw_mirth_type_CTypeStackPart_c99Z_push(x560, v552, x558));
			int64_t v574 = 1LL /* True */;
			x551 = v574;
			x550 = v544;
			x549 = x559;
			x548 = v573;
			x547 = x557;
			x546 = x556;
			x545 = x555;
		} break;
		case 0LL: { // None
			int64_t v575 = 0LL /* False */;
			x551 = v575;
			x550 = v544;
			x549 = v514;
			x548 = v311;
			x547 = v513;
			x546 = v511;
			x545 = v510;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v576 = x545;
	uint64_t v577 = x546;
	int64_t v578 = x547;
	VAL v579 = (x548);
	VAL v580 = x549;
	VAL v581 = x550;
	int64_t v582 = x551;
	while (((bool)v582)) {
		VAL v583 = v576;
		uint64_t v584 = v577;
		int64_t v585 = v578;
		VAL v586 = (v579);
		VAL v587 = v580;
		VAL v588 = v581;
		VAL v589;
		VAL v590;
		mw_std_list_List_1_uncons(v588, &v589, &v590);
		VAL x591;
		uint64_t x592;
		int64_t x593;
		VAL x594;
		VAL x595;
		VAL x596;
		int64_t x597;
		switch (get_data_tag(v589)) {
			case 1LL: { // Some
				VAL v598 = mtp_std_maybe_Maybe_1_Some(v589);
				incref(v598);
				incref(v598);
				VAL v599 = mw_mirth_type_CTypeStackPart_ctype(v598);
				int64_t v600 = mw_mirth_type_CType_phantomZAsk(v599);
				VAL x601;
				uint64_t x602;
				int64_t x603;
				VAL x604;
				VAL x605;
				VAL x606;
				if (((bool)v600)) {
					decref(v598);
					STR* v607;
					STRLIT(v607, "0", 1);
					x606 = MKSTR(v607);
					x605 = v587;
					x604 = v586;
					x603 = v585;
					x602 = v584;
					x601 = v583;
				} else {
					VAL v608 = mw_mirth_type_CTypeStackPart_labelZAsk(v598);
					VAL x609;
					uint64_t x610;
					int64_t x611;
					VAL x612;
					VAL x613;
					VAL x614;
					switch (get_data_tag(v608)) {
						case 1LL: { // Some
							VAL v615 = mtp_std_maybe_Maybe_1_Some(v608);
							uint64_t v616 = mw_mirth_label_Label_name(VU64(v615));
							VAL v617 = mw_mirth_name_Name_mangled(v616);
							x614 = v617;
							x613 = v587;
							x612 = v586;
							x611 = v585;
							x610 = v584;
							x609 = v583;
						} break;
						case 0LL: { // None
							STR* v618;
							STRLIT(v618, "Y", 1);
							x614 = MKSTR(v618);
							x613 = v587;
							x612 = v586;
							x611 = v585;
							x610 = v584;
							x609 = v583;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x606 = x614;
					x605 = x613;
					x604 = x612;
					x603 = x611;
					x602 = x610;
					x601 = x609;
				}
				VAL v619 = (mw_mirth_type_CTypeStackPart_c99Z_push(x606, v598, x604));
				int64_t v620 = 1LL /* True */;
				x597 = v620;
				x596 = v590;
				x595 = x605;
				x594 = v619;
				x593 = x603;
				x592 = x602;
				x591 = x601;
			} break;
			case 0LL: { // None
				int64_t v621 = 0LL /* False */;
				x597 = v621;
				x596 = v590;
				x595 = v587;
				x594 = v586;
				x593 = v585;
				x592 = v584;
				x591 = v583;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v582 = x597;
		v581 = x596;
		v580 = x595;
		v579 = x594;
		v578 = x593;
		v577 = x592;
		v576 = x591;
	}
	decref(v581);
	VAL v622 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v240, v579));
	int64_t v623 = VI64(VTUP(v622)->cells[2]);
	int64_t v624 = 1LL;
	int64_t v625 = i64_sub(v623, v624);
	int64_t v626 = 0LL;
	bool v627 = (v625 < v626);
	int64_t x628;
	if (v627) {
		int64_t v629 = 0LL;
		x628 = v629;
		lpush(&lbl_outty, v576);
		lpush(&lbl_ext, MKU64(v577));
		lpush(&lbl_argZ_index, MKI64(v578));
		lpush(&lbl_cty, v580);
	} else {
		x628 = v625;
		lpush(&lbl_outty, v576);
		lpush(&lbl_ext, MKU64(v577));
		lpush(&lbl_argZ_index, MKI64(v578));
		lpush(&lbl_cty, v580);
	}
	VTUP(v622)->cells[2] = MKI64(x628);
	VAL v630 = (mw_mirth_c99_ZPlusC99_indent(v622));
	STR* v631;
	STRLIT(v631, "}", 1);
	VAL v632 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v631), v630));
	VAL v633 = (mw_mirth_c99_ZPlusC99_line(v632));
	int64_t v634 = VI64(lpop(&lbl_argZ_index));
	uint64_t v635 = VU64(lpop(&lbl_ext));
	VAL v636 = lpop(&lbl_cty);
	VAL v637 = lpop(&lbl_outty);
	decref(v637);
	decref(v636);
	return v633;
}
static void mw_mirth_type_CTypeStackPart_c99Z_argZ_name (int64_t x1, VAL x2, VAL x3, int64_t *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_CTypeStackPart_labelZAsk(x2);
	int64_t x8;
	VAL x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			uint64_t v12 = mw_mirth_label_Label_name(VU64(v11));
			VAL v13 = mw_mirth_name_Name_mangled(v12);
			x10 = v13;
			x9 = x3;
			x8 = x1;
		} break;
		case 0LL: { // None
			STR* v14;
			STRLIT(v14, "", 0);
			STR* v15;
			STRLIT(v15, "X", 1);
			VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v15), MKSTR(v14)));
			STR* v17 = i64_show(x1);
			VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v17), v16));
			x10 = v18;
			x9 = x3;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x6 = x9;
	*x5 = x10;
	*x4 = x8;
}
static int64_t mw_mirth_type_CType_ZToC99ReprType (VAL x1) {
	int64_t x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // IntLike
			VAL v3 = mtp_mirth_type_CType_IntLike(x1);
			decref(v3);
			int64_t v4 = 2LL /* C99RT_I64 */;
			x2 = v4;
		} break;
		case 1LL: { // F32Like
			VAL v5 = mtp_mirth_type_CType_F32Like(x1);
			decref(v5);
			int64_t v6 = 11LL /* C99RT_F32 */;
			x2 = v6;
		} break;
		case 2LL: { // F64Like
			VAL v7 = mtp_mirth_type_CType_F64Like(x1);
			decref(v7);
			int64_t v8 = 10LL /* C99RT_F64 */;
			x2 = v8;
		} break;
		case 3LL: { // PtrLike
			VAL v9 = mtp_mirth_type_CType_PtrLike(x1);
			decref(v9);
			int64_t v10 = 13LL /* C99RT_PTR */;
			x2 = v10;
		} break;
		case 4LL: { // FnPtr
			VAL v11 = mtp_mirth_type_CType_FnPtr(x1);
			decref(v11);
			int64_t v12 = 14LL /* C99RT_FNPTR */;
			x2 = v12;
		} break;
		case 5LL: { // Phantom
			int64_t v13 = 2LL /* C99RT_I64 */;
			x2 = v13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_type_CTypeStackPart_c99Z_pop (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL x5;
	VAL x6;
	switch (get_data_tag(x1)) {
		case 0LL: { // CTSPCons
			VAL v7 = mtp_mirth_type_CTypeStackPart_CTSPCons(x1);
			int64_t v8 = mw_mirth_type_CType_ZToC99ReprType(v7);
			VAL v9;
			VAL v10;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v8, &v9, &v10);
			VAL v11 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v8, v10);
			x6 = v9;
			x5 = v11;
		} break;
		case 2LL: { // CTSPWith
			VAL v12 = mtp_mirth_type_CTypeStackPart_CTSPWith(x1);
			int64_t v13 = mw_mirth_type_CType_ZToC99ReprType(v12);
			VAL v14;
			VAL v15;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(x2, v13, &v14, &v15);
			VAL v16 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v15));
			VAL v17 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v13, v16);
			x6 = v14;
			x5 = v17;
		} break;
		case 1LL: { // CTSPConsLabel
			VAL v18;
			uint64_t v19;
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x1, &v18, &v19);
			int64_t v20 = mw_mirth_type_CType_ZToC99ReprType(v18);
			VAL v21;
			VAL v22;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v20, v19, x2, &v21, &v22);
			VAL v23 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v20, v22);
			x6 = v21;
			x5 = v23;
		} break;
		case 3LL: { // CTSPWithLabel
			VAL v24;
			uint64_t v25;
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x1, &v24, &v25);
			int64_t v26 = mw_mirth_type_CType_ZToC99ReprType(v24);
			VAL v27;
			VAL v28;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v26, v25, x2, &v27, &v28);
			VAL v29 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v28));
			VAL v30 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v26, v29);
			x6 = v27;
			x5 = v30;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static VAL mw_mirth_type_CTypeStackPart_c99Z_push (VAL x1, VAL x2, VAL x3) {
	VAL x4;
	switch (get_data_tag(x2)) {
		case 0LL: { // CTSPCons
			VAL v5 = mtp_mirth_type_CTypeStackPart_CTSPCons(x2);
			int64_t v6 = mw_mirth_type_CType_ZToC99ReprType(v5);
			VAL v7 = (VVAL(VTUP(x3)->cells[1]));
			VAL v8;
			VAL v9;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v7, &v8, &v9);
			VAL v10 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v6, v8));
			VAL v11 = (mw_mirth_c99_ZPlusC99_indent(v9));
			int64_t v12 = VI64(VTUP(v10)->cells[1]);
			VAL v13 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v12);
			VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v11));
			STR* v15;
			STRLIT(v15, " ", 1);
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
			VAL v17 = VVAL(VTUP(v10)->cells[2]);
			incref(v17);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(v17, v16));
			STR* v19;
			STRLIT(v19, " = ", 3);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
			STR* v21;
			STRLIT(v21, "(", 1);
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
			VAL v23 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v6);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v22));
			STR* v25;
			STRLIT(v25, ")(", 2);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(x1, v26));
			STR* v28;
			STRLIT(v28, ")", 1);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
			STR* v30;
			STRLIT(v30, ";", 1);
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
			VAL v32 = (mw_mirth_c99_ZPlusC99_line(v31));
			VTUP(x3)->cells[1] = v32;
			VAL v33 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v10));
			x4 = v33;
		} break;
		case 2LL: { // CTSPWith
			VAL v34 = mtp_mirth_type_CTypeStackPart_CTSPWith(x2);
			int64_t v35 = mw_mirth_type_CType_ZToC99ReprType(v34);
			VAL v36 = (VVAL(VTUP(x3)->cells[1]));
			VAL v37;
			VAL v38;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v36, &v37, &v38);
			VAL v39 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v35, v37));
			VAL v40 = (mw_mirth_c99_ZPlusC99_indent(v38));
			int64_t v41 = VI64(VTUP(v39)->cells[1]);
			VAL v42 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v41);
			VAL v43 = (mw_mirth_c99_ZPlusC99_put(v42, v40));
			STR* v44;
			STRLIT(v44, " ", 1);
			VAL v45 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v44), v43));
			VAL v46 = VVAL(VTUP(v39)->cells[2]);
			incref(v46);
			VAL v47 = (mw_mirth_c99_ZPlusC99_put(v46, v45));
			STR* v48;
			STRLIT(v48, " = (", 4);
			VAL v49 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v48), v47));
			STR* v50;
			STRLIT(v50, "(", 1);
			VAL v51 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v50), v49));
			VAL v52 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v35);
			VAL v53 = (mw_mirth_c99_ZPlusC99_put(v52, v51));
			STR* v54;
			STRLIT(v54, ")(", 2);
			VAL v55 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v54), v53));
			VAL v56 = (mw_mirth_c99_ZPlusC99_put(x1, v55));
			STR* v57;
			STRLIT(v57, ")", 1);
			VAL v58 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v57), v56));
			STR* v59;
			STRLIT(v59, ");", 2);
			VAL v60 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v59), v58));
			VAL v61 = (mw_mirth_c99_ZPlusC99_line(v60));
			VTUP(x3)->cells[1] = v61;
			VAL v62 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x3, v39));
			x4 = v62;
		} break;
		case 1LL: { // CTSPConsLabel
			VAL v63;
			uint64_t v64;
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x2, &v63, &v64);
			int64_t v65 = mw_mirth_type_CType_ZToC99ReprType(v63);
			VAL v66 = (VVAL(VTUP(x3)->cells[1]));
			VAL v67;
			VAL v68;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v66, &v67, &v68);
			VAL v69 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v65, v67));
			VAL v70 = (mw_mirth_c99_ZPlusC99_indent(v68));
			int64_t v71 = VI64(VTUP(v69)->cells[1]);
			VAL v72 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v71);
			VAL v73 = (mw_mirth_c99_ZPlusC99_put(v72, v70));
			STR* v74;
			STRLIT(v74, " ", 1);
			VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v73));
			VAL v76 = VVAL(VTUP(v69)->cells[2]);
			incref(v76);
			VAL v77 = (mw_mirth_c99_ZPlusC99_put(v76, v75));
			STR* v78;
			STRLIT(v78, " = ", 3);
			VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
			STR* v80;
			STRLIT(v80, "(", 1);
			VAL v81 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v80), v79));
			VAL v82 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v65);
			VAL v83 = (mw_mirth_c99_ZPlusC99_put(v82, v81));
			STR* v84;
			STRLIT(v84, ")(", 2);
			VAL v85 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v84), v83));
			VAL v86 = (mw_mirth_c99_ZPlusC99_put(x1, v85));
			STR* v87;
			STRLIT(v87, ")", 1);
			VAL v88 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v87), v86));
			STR* v89;
			STRLIT(v89, ";", 1);
			VAL v90 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v89), v88));
			VAL v91 = (mw_mirth_c99_ZPlusC99_line(v90));
			VTUP(x3)->cells[1] = v91;
			int64_t v92 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v64);
			VAL x93;
			if (((bool)v92)) {
				VAL v94 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v69));
				VAL v95 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v64, x3, v94));
				x93 = v95;
			} else {
				VAL v96 = (mw_mirth_c99_pushZ_localZ_labelZBang(v64, x3, v69));
				x93 = v96;
			}
			x4 = x93;
		} break;
		case 3LL: { // CTSPWithLabel
			VAL v97;
			uint64_t v98;
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x2, &v97, &v98);
			int64_t v99 = mw_mirth_type_CType_ZToC99ReprType(v97);
			VAL v100 = (VVAL(VTUP(x3)->cells[1]));
			VAL v101;
			VAL v102;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v100, &v101, &v102);
			VAL v103 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v99, v101));
			VAL v104 = (mw_mirth_c99_ZPlusC99_indent(v102));
			int64_t v105 = VI64(VTUP(v103)->cells[1]);
			VAL v106 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v105);
			VAL v107 = (mw_mirth_c99_ZPlusC99_put(v106, v104));
			STR* v108;
			STRLIT(v108, " ", 1);
			VAL v109 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v108), v107));
			VAL v110 = VVAL(VTUP(v103)->cells[2]);
			incref(v110);
			VAL v111 = (mw_mirth_c99_ZPlusC99_put(v110, v109));
			STR* v112;
			STRLIT(v112, " = ", 3);
			VAL v113 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v112), v111));
			STR* v114;
			STRLIT(v114, "(", 1);
			VAL v115 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v114), v113));
			VAL v116 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v99);
			VAL v117 = (mw_mirth_c99_ZPlusC99_put(v116, v115));
			STR* v118;
			STRLIT(v118, ")(", 2);
			VAL v119 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v118), v117));
			VAL v120 = (mw_mirth_c99_ZPlusC99_put(x1, v119));
			STR* v121;
			STRLIT(v121, ")", 1);
			VAL v122 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v121), v120));
			STR* v123;
			STRLIT(v123, ";", 1);
			VAL v124 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v123), v122));
			VAL v125 = (mw_mirth_c99_ZPlusC99_line(v124));
			VTUP(x3)->cells[1] = v125;
			int64_t v126 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v98);
			VAL x127;
			if (((bool)v126)) {
				VAL v128 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v103));
				VAL v129 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v98, x3, v128));
				x127 = v129;
			} else {
				VAL v130 = (mw_mirth_c99_pushZ_localZ_labelZBang(v98, x3, v103));
				x127 = v130;
			}
			x4 = x127;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_c99_ZPlusC99_indent (VAL x1) {
	int64_t v2 = VI64(VTUP(x1)->cells[2]);
	int64_t v3 = 0LL;
	bool v4 = (v2 > v3);
	VAL v5 = (x1);
	int64_t v6 = v2;
	bool v7 = v4;
	while (v7) {
		VAL v8 = (v5);
		int64_t v9 = v6;
		STR* v10;
		STRLIT(v10, "\t", 1);
		VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v8));
		int64_t v12 = 1LL;
		int64_t v13 = i64_sub(v9, v12);
		int64_t v14 = 0LL;
		bool v15 = (v13 < v14);
		int64_t x16;
		if (v15) {
			int64_t v17 = 0LL;
			x16 = v17;
			push_resource(v11);
		} else {
			x16 = v13;
			push_resource(v11);
		}
		int64_t v18 = 0LL;
		bool v19 = (x16 > v18);
		v7 = v19;
		v6 = x16;
		VAL r20 = pop_resource();
		v5 = r20;
	}
	return v5;
}
static void mw_mirth_c99_C99APIArg_popZ_consumeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	int64_t v6;
	VAL v7;
	mtp_mirth_c99_C99APIArg_C99APIArg(x1, &v5, &v6, &v7);
	decref(v7);
	VAL x8;
	VAL x9;
	switch (get_data_tag(v5)) {
		case 0LL: { // C99AAS_Value
			VAL v10;
			VAL v11;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v6, &v10, &v11);
			VAL v12 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v6, v11);
			x9 = v12;
			x8 = v10;
		} break;
		case 2LL: { // C99AAS_Resource
			VAL v13;
			VAL v14;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(x2, v6, &v13, &v14);
			VAL v15 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v14));
			VAL v16 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v6, v15);
			x9 = v16;
			x8 = v13;
		} break;
		case 1LL: { // C99AAS_ValueLabel
			uint64_t v17 = mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v5);
			VAL v18;
			VAL v19;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v6, v17, x2, &v18, &v19);
			VAL v20 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v6, v19);
			x9 = v20;
			x8 = v18;
		} break;
		case 3LL: { // C99AAS_ResourceLabel
			uint64_t v21 = mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v5);
			VAL v22;
			VAL v23;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v6, v21, x2, &v22, &v23);
			VAL v24 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v23));
			VAL v25 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v6, v24);
			x9 = v25;
			x8 = v22;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x9;
	*x3 = x8;
}
static VAL mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v3;
	VAL v4;
	mw_mirth_c99_C99APIArg_popZ_consumeZBang(x1, x2, &v3, &v4);
	VAL v5 = (VVAL(VTUP(v3)->cells[1]));
	VAL v6 = (mw_mirth_c99_ZPlusC99_indent(v5));
	VAL v7 = VVAL(VTUP(x1)->cells[3]);
	incref(v7);
	decref(x1);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(v7, v6));
	STR* v9;
	STRLIT(v9, " = ", 3);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v4, v10));
	STR* v12;
	STRLIT(v12, ";", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL v14 = (mw_mirth_c99_ZPlusC99_line(v13));
	VTUP(v3)->cells[1] = v14;
	return v3;
}
static VAL mw_mirth_c99_C99APIArg_pushZ_toZBang (VAL x1, VAL x2, VAL x3) {
	VAL v4;
	int64_t v5;
	VAL v6;
	mtp_mirth_c99_C99APIArg_C99APIArg(x2, &v4, &v5, &v6);
	decref(v6);
	VAL x7;
	switch (get_data_tag(v4)) {
		case 0LL: { // C99AAS_Value
			VAL v8 = (VVAL(VTUP(x3)->cells[1]));
			VAL v9;
			VAL v10;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v8, &v9, &v10);
			VAL v11 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v5, v9));
			VAL v12 = (mw_mirth_c99_ZPlusC99_indent(v10));
			int64_t v13 = VI64(VTUP(v11)->cells[1]);
			VAL v14 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v13);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(v14, v12));
			STR* v16;
			STRLIT(v16, " ", 1);
			VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
			VAL v18 = VVAL(VTUP(v11)->cells[2]);
			incref(v18);
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(v18, v17));
			STR* v20;
			STRLIT(v20, " = ", 3);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(x1, v21));
			STR* v23;
			STRLIT(v23, ";", 1);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
			VAL v25 = (mw_mirth_c99_ZPlusC99_line(v24));
			VTUP(x3)->cells[1] = v25;
			VAL v26 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v11));
			x7 = v26;
		} break;
		case 2LL: { // C99AAS_Resource
			VAL v27 = (VVAL(VTUP(x3)->cells[1]));
			VAL v28;
			VAL v29;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v27, &v28, &v29);
			VAL v30 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v5, v28));
			VAL v31 = (mw_mirth_c99_ZPlusC99_indent(v29));
			int64_t v32 = VI64(VTUP(v30)->cells[1]);
			VAL v33 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v32);
			VAL v34 = (mw_mirth_c99_ZPlusC99_put(v33, v31));
			STR* v35;
			STRLIT(v35, " ", 1);
			VAL v36 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), v34));
			VAL v37 = VVAL(VTUP(v30)->cells[2]);
			incref(v37);
			VAL v38 = (mw_mirth_c99_ZPlusC99_put(v37, v36));
			STR* v39;
			STRLIT(v39, " = (", 4);
			VAL v40 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v39), v38));
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(x1, v40));
			STR* v42;
			STRLIT(v42, ");", 2);
			VAL v43 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), v41));
			VAL v44 = (mw_mirth_c99_ZPlusC99_line(v43));
			VTUP(x3)->cells[1] = v44;
			VAL v45 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x3, v30));
			x7 = v45;
		} break;
		case 1LL: { // C99AAS_ValueLabel
			uint64_t v46 = mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v4);
			VAL v47 = (VVAL(VTUP(x3)->cells[1]));
			VAL v48;
			VAL v49;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v47, &v48, &v49);
			VAL v50 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v5, v48));
			VAL v51 = (mw_mirth_c99_ZPlusC99_indent(v49));
			int64_t v52 = VI64(VTUP(v50)->cells[1]);
			VAL v53 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v52);
			VAL v54 = (mw_mirth_c99_ZPlusC99_put(v53, v51));
			STR* v55;
			STRLIT(v55, " ", 1);
			VAL v56 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v55), v54));
			VAL v57 = VVAL(VTUP(v50)->cells[2]);
			incref(v57);
			VAL v58 = (mw_mirth_c99_ZPlusC99_put(v57, v56));
			STR* v59;
			STRLIT(v59, " = ", 3);
			VAL v60 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v59), v58));
			VAL v61 = (mw_mirth_c99_ZPlusC99_put(x1, v60));
			STR* v62;
			STRLIT(v62, ";", 1);
			VAL v63 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v62), v61));
			VAL v64 = (mw_mirth_c99_ZPlusC99_line(v63));
			VTUP(x3)->cells[1] = v64;
			int64_t v65 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v46);
			VAL x66;
			if (((bool)v65)) {
				VAL v67 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v50));
				VAL v68 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v46, x3, v67));
				x66 = v68;
			} else {
				VAL v69 = (mw_mirth_c99_pushZ_localZ_labelZBang(v46, x3, v50));
				x66 = v69;
			}
			x7 = x66;
		} break;
		case 3LL: { // C99AAS_ResourceLabel
			uint64_t v70 = mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v4);
			VAL v71 = (VVAL(VTUP(x3)->cells[1]));
			VAL v72;
			VAL v73;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v71, &v72, &v73);
			VAL v74 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v5, v72));
			VAL v75 = (mw_mirth_c99_ZPlusC99_indent(v73));
			int64_t v76 = VI64(VTUP(v74)->cells[1]);
			VAL v77 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v76);
			VAL v78 = (mw_mirth_c99_ZPlusC99_put(v77, v75));
			STR* v79;
			STRLIT(v79, " ", 1);
			VAL v80 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v79), v78));
			VAL v81 = VVAL(VTUP(v74)->cells[2]);
			incref(v81);
			VAL v82 = (mw_mirth_c99_ZPlusC99_put(v81, v80));
			STR* v83;
			STRLIT(v83, " = ", 3);
			VAL v84 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v83), v82));
			VAL v85 = (mw_mirth_c99_ZPlusC99_put(x1, v84));
			STR* v86;
			STRLIT(v86, ";", 1);
			VAL v87 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v86), v85));
			VAL v88 = (mw_mirth_c99_ZPlusC99_line(v87));
			VTUP(x3)->cells[1] = v88;
			int64_t v89 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v70);
			VAL x90;
			if (((bool)v89)) {
				VAL v91 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v74));
				VAL v92 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v70, x3, v91));
				x90 = v92;
			} else {
				VAL v93 = (mw_mirth_c99_pushZ_localZ_labelZBang(v70, x3, v74));
				x90 = v93;
			}
			x7 = x90;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x7;
}
static VAL mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang (VAL x1, VAL x2) {
	VAL v3;
	int64_t v4;
	VAL v5;
	mtp_mirth_c99_C99APIArg_C99APIArg(x1, &v3, &v4, &v5);
	VAL v6 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v4, v5));
	VAL x7;
	switch (get_data_tag(v3)) {
		case 0LL: { // C99AAS_Value
			VAL v8 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v6));
			x7 = v8;
		} break;
		case 1LL: { // C99AAS_ValueLabel
			uint64_t v9 = mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v3);
			VAL v10 = (mw_mirth_c99_pushZ_localZ_labelZBang(v9, x2, v6));
			x7 = v10;
		} break;
		case 2LL: { // C99AAS_Resource
			VAL v11 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v6));
			VAL v12 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x2, v11));
			x7 = v12;
		} break;
		case 3LL: { // C99AAS_ResourceLabel
			uint64_t v13 = mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v3);
			VAL v14 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v6));
			VAL v15 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v13, x2, v14));
			x7 = v15;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x7;
}
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux (VAL x1, VAL x2, int64_t *x3, VAL *x4, VAL *x5) {
	int64_t x6;
	VAL x7;
	VAL x8;
	switch (get_data_tag(x1)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v9 = 0LL /* False */;
			VAL v10 = MKI64(0LL /* Nil */);
			x8 = x2;
			x7 = v10;
			x6 = v9;
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v11 = 1LL /* True */;
			VAL v12 = MKI64(0LL /* Nil */);
			x8 = x2;
			x7 = v12;
			x6 = v11;
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v13 = 1LL /* True */;
			VAL v14 = MKI64(0LL /* Nil */);
			x8 = x2;
			x7 = v14;
			x6 = v13;
		} break;
		case 4LL: { // STMeta
			uint64_t v15 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v16 = mw_mirth_type_MetaVar_typeZAsk(v15);
			int64_t x17;
			VAL x18;
			VAL x19;
			switch (get_data_tag(v16)) {
				case 0LL: { // None
					int64_t v20 = 1LL /* True */;
					VAL v21 = MKI64(0LL /* Nil */);
					x19 = x2;
					x18 = v21;
					x17 = v20;
				} break;
				case 1LL: { // Some
					VAL v22 = mtp_std_maybe_Maybe_1_Some(v16);
					VAL v23 = mw_mirth_type_Type_expand(v22);
					incref(v23);
					VAL v24 = mtw_std_maybe_Maybe_1_Some(v23);
					void* v25 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v15);
					mut_set(v24, v25);
					VAL v26 = mw_mirth_type_Type_ZToStackType(v23);
					int64_t v27;
					VAL v28;
					VAL v29;
					mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v26, x2, &v27, &v28, &v29);
					x19 = v29;
					x18 = v28;
					x17 = v27;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x8 = x19;
			x7 = x18;
			x6 = x17;
		} break;
		case 3LL: { // STVar
			uint64_t v30 = mtp_mirth_type_StackType_STVar(x1);
			int64_t v31 = 1LL /* True */;
			VAL v32 = MKI64(0LL /* Nil */);
			x8 = x2;
			x7 = v32;
			x6 = v31;
		} break;
		case 5LL: { // STCons
			VAL v33;
			VAL v34;
			mtp_mirth_type_StackType_STCons(x1, &v33, &v34);
			VAL v35 = MKI64(0LL /* C99AAS_Value */);
			VAL v36 = (VVAL(VTUP(x2)->cells[6]));
			int64_t v37;
			VAL v38;
			mw_mirth_type_Type_c99Z_repr(v34, v36, &v37, &v38);
			VTUP(x2)->cells[6] = v38;
			int64_t v39;
			VAL v40;
			VAL v41;
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v33, x2, &v39, &v40, &v41);
			VAL v42;
			VAL v43;
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(v41, &v42, &v43);
			VAL v44 = mtw_mirth_c99_C99APIArg_C99APIArg(v35, v37, v42);
			VAL v45 = mtw_std_list_List_1_Cons(v44, v40);
			x8 = v43;
			x7 = v45;
			x6 = v39;
		} break;
		case 7LL: { // STWith
			VAL v46;
			VAL v47;
			mtp_mirth_type_StackType_STWith(x1, &v46, &v47);
			VAL v48 = MKI64(2LL /* C99AAS_Resource */);
			VAL v49 = (VVAL(VTUP(x2)->cells[6]));
			int64_t v50;
			VAL v51;
			mw_mirth_type_Resource_c99Z_repr(v47, v49, &v50, &v51);
			VTUP(x2)->cells[6] = v51;
			int64_t v52;
			VAL v53;
			VAL v54;
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v46, x2, &v52, &v53, &v54);
			VAL v55;
			VAL v56;
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(v54, &v55, &v56);
			VAL v57 = mtw_mirth_c99_C99APIArg_C99APIArg(v48, v50, v55);
			VAL v58 = mtw_std_list_List_1_Cons(v57, v53);
			x8 = v56;
			x7 = v58;
			x6 = v52;
		} break;
		case 6LL: { // STConsLabel
			VAL v59;
			VAL v60;
			uint64_t v61;
			mtp_mirth_type_StackType_STConsLabel(x1, &v59, &v60, &v61);
			VAL v62 = mtw_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v61);
			VAL v63 = (VVAL(VTUP(x2)->cells[6]));
			int64_t v64;
			VAL v65;
			mw_mirth_type_Type_c99Z_repr(v60, v63, &v64, &v65);
			VTUP(x2)->cells[6] = v65;
			int64_t v66;
			VAL v67;
			VAL v68;
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v59, x2, &v66, &v67, &v68);
			VAL v69;
			VAL v70;
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(v68, &v69, &v70);
			VAL v71 = mtw_mirth_c99_C99APIArg_C99APIArg(v62, v64, v69);
			VAL v72 = mtw_std_list_List_1_Cons(v71, v67);
			x8 = v70;
			x7 = v72;
			x6 = v66;
		} break;
		case 8LL: { // STWithLabel
			VAL v73;
			VAL v74;
			uint64_t v75;
			mtp_mirth_type_StackType_STWithLabel(x1, &v73, &v74, &v75);
			VAL v76 = mtw_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v75);
			VAL v77 = (VVAL(VTUP(x2)->cells[6]));
			int64_t v78;
			VAL v79;
			mw_mirth_type_Resource_c99Z_repr(v74, v77, &v78, &v79);
			VTUP(x2)->cells[6] = v79;
			int64_t v80;
			VAL v81;
			VAL v82;
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v73, x2, &v80, &v81, &v82);
			VAL v83;
			VAL v84;
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(v82, &v83, &v84);
			VAL v85 = mtw_mirth_c99_C99APIArg_C99APIArg(v76, v78, v83);
			VAL v86 = mtw_std_list_List_1_Cons(v85, v81);
			x8 = v84;
			x7 = v86;
			x6 = v80;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x8;
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params (VAL x1, VAL x2, int64_t *x3, VAL *x4, VAL *x5) {
	int64_t v6;
	VAL v7;
	VAL v8;
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(x1, x2, &v6, &v7, &v8);
	VAL v9 = mw_std_list_List_1_reverse(v7);
	*x5 = v8;
	*x4 = v9;
	*x3 = v6;
}
static void mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api (VAL x1, VAL x2, VAL x3, VAL *x4, VAL *x5) {
	int64_t v6 = 1LL;
	int64_t v7 = VI64(VTUP(x3)->cells[3]);
	VTUP(x3)->cells[3] = MKI64(v6);
	incref(x2);
	VAL v8 = mw_mirth_type_ArrowType_dom(x2);
	int64_t v9;
	VAL v10;
	VAL v11;
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params(v8, x3, &v9, &v10, &v11);
	incref(x2);
	VAL v12 = mw_mirth_type_ArrowType_cod(x2);
	int64_t v13;
	VAL v14;
	VAL v15;
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params(v12, v11, &v13, &v14, &v15);
	incref(v14);
	VAL v16 = mw_std_list_List_1_ZDivL1(v14);
	incref(v16);
	VAL x17;
	int64_t x18;
	VAL x19;
	VAL x20;
	int64_t x21;
	VAL x22;
	VAL x23;
	VAL x24;
	switch (get_data_tag(v16)) {
		case 1LL: { // Some
			VAL v25 = mtp_std_maybe_Maybe_1_Some(v16);
			decref(v25);
			decref(v14);
			VAL v26 = MKI64(0LL /* Nil */);
			x24 = v16;
			x23 = v26;
			x22 = v15;
			x21 = v13;
			x20 = x2;
			x19 = v10;
			x18 = v9;
			x17 = x1;
		} break;
		case 0LL: { // None
			x24 = v16;
			x23 = v14;
			x22 = v15;
			x21 = v13;
			x20 = x2;
			x19 = v10;
			x18 = v9;
			x17 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v27 = VI64(VTUP(x22)->cells[3]);
	VTUP(x22)->cells[3] = MKI64(v7);
	bool v28 = (((bool)x18) || ((bool)x21));
	VAL v29 = mtw_mirth_c99_C99API_C99API(x17, x20, x19, x23, x24, ((int64_t)v28));
	*x5 = x22;
	*x4 = v29;
}
static void mw_mirth_c99_C99APIArg_reserveZ_asZ_newZ_localZBang (VAL x1, VAL x2, VAL *x3, VAL *x4) {
	incref(x1);
	int64_t v5 = VI64(VTUP(x1)->cells[2]);
	decref(x1);
	VAL v6;
	VAL v7;
	mw_mirth_c99_C99ReprType_newZ_localZBang(v5, x2, &v6, &v7);
	VAL v8 = mw_mirth_c99_ZPlusC99Local_consume(v7);
	VAL v9 = tup_replace(x1, 3, v8);
	*x4 = v6;
	*x3 = v9;
}
static VAL mw_mirth_c99_C99APIArg_reserveZ_asZ_isZBang (VAL x1, VAL x2) {
	VAL v3;
	int64_t v4;
	VAL v5;
	mtp_mirth_c99_C99APIArg_C99APIArg(x1, &v3, &v4, &v5);
	VAL v6 = (VVAL(VTUP(x2)->cells[1]));
	VAL v7 = (mw_mirth_c99_ZPlusC99_indent(v6));
	VAL v8 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v4);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
	STR* v10;
	STRLIT(v10, " ", 1);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v5, v11));
	STR* v13;
	STRLIT(v13, ";", 1);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = (mw_mirth_c99_ZPlusC99_line(v14));
	VTUP(x2)->cells[1] = v15;
	decref(v3);
	return x2;
}
static VAL mw_mirth_c99_c99Z_smartZ_callZBang (VAL x1, VAL x2, VAL x3) {
	VAL v4 = (mw_mirth_c99_c99Z_argsZ_pushZBang(x1, x3));
	incref(x2);
	VAL v5 = VVAL(VTUP(x2)->cells[3]);
	incref(v5);
	decref(x2);
	VAL v6 = mw_std_list_List_1_reverse(v5);
	VAL v7 = MKI64(0LL /* Nil */);
	VAL v8 = mw_std_list_List_1_reverse(v7);
	VAL v9;
	VAL v10;
	mw_std_list_List_1_uncons(v6, &v9, &v10);
	VAL x11;
	VAL x12;
	VAL x13;
	VAL x14;
	int64_t x15;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(v9);
			VAL v17;
			VAL v18;
			mw_mirth_c99_C99APIArg_popZ_consumeZBang(v16, v4, &v17, &v18);
			VAL v19 = mtw_std_list_List_1_Cons(v18, v8);
			int64_t v20 = 1LL /* True */;
			x15 = v20;
			x14 = v10;
			x13 = v19;
			x12 = x2;
			x11 = v17;
		} break;
		case 0LL: { // None
			int64_t v21 = 0LL /* False */;
			x15 = v21;
			x14 = v10;
			x13 = v8;
			x12 = x2;
			x11 = v4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v22 = (x11);
	VAL v23 = x12;
	VAL v24 = (x13);
	VAL v25 = x14;
	int64_t v26 = x15;
	while (((bool)v26)) {
		VAL v27 = (v22);
		VAL v28 = v23;
		VAL v29 = (v24);
		VAL v30 = v25;
		VAL v31;
		VAL v32;
		mw_std_list_List_1_uncons(v30, &v31, &v32);
		VAL x33;
		VAL x34;
		VAL x35;
		VAL x36;
		int64_t x37;
		switch (get_data_tag(v31)) {
			case 1LL: { // Some
				VAL v38 = mtp_std_maybe_Maybe_1_Some(v31);
				VAL v39;
				VAL v40;
				mw_mirth_c99_C99APIArg_popZ_consumeZBang(v38, v27, &v39, &v40);
				VAL v41 = mtw_std_list_List_1_Cons(v40, v29);
				int64_t v42 = 1LL /* True */;
				x37 = v42;
				x36 = v32;
				x35 = v41;
				x34 = v28;
				x33 = v39;
			} break;
			case 0LL: { // None
				int64_t v43 = 0LL /* False */;
				x37 = v43;
				x36 = v32;
				x35 = v29;
				x34 = v28;
				x33 = v27;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v26 = x37;
		v25 = x36;
		v24 = x35;
		v23 = x34;
		v22 = x33;
	}
	decref(v25);
	VAL v44 = mw_std_list_List_1_reverse(v24);
	VAL v45 = mw_std_list_List_1_reverse(v44);
	incref(v23);
	int64_t v46 = VI64(VTUP(v23)->cells[6]);
	decref(v23);
	VAL x47;
	VAL x48;
	VAL x49;
	if (((bool)v46)) {
		VAL v50 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(v22));
		x49 = v23;
		x48 = v45;
		x47 = v50;
	} else {
		x49 = v23;
		x48 = v45;
		x47 = v22;
	}
	incref(x49);
	VAL v51 = VVAL(VTUP(x49)->cells[4]);
	incref(v51);
	decref(x49);
	VAL v52 = MKI64(0LL /* Nil */);
	VAL v53 = mw_std_list_List_1_reverse(v52);
	VAL v54;
	VAL v55;
	mw_std_list_List_1_uncons(v51, &v54, &v55);
	VAL x56;
	VAL x57;
	VAL x58;
	VAL x59;
	VAL x60;
	int64_t x61;
	switch (get_data_tag(v54)) {
		case 1LL: { // Some
			VAL v62 = mtp_std_maybe_Maybe_1_Some(v54);
			VAL v63;
			VAL v64;
			mw_mirth_c99_C99APIArg_reserveZ_asZ_newZ_localZBang(v62, x47, &v63, &v64);
			VAL v65 = mtw_std_list_List_1_Cons(v63, v53);
			int64_t v66 = 1LL /* True */;
			x61 = v66;
			x60 = v55;
			x59 = v65;
			x58 = x49;
			x57 = x48;
			x56 = v64;
		} break;
		case 0LL: { // None
			int64_t v67 = 0LL /* False */;
			x61 = v67;
			x60 = v55;
			x59 = v53;
			x58 = x49;
			x57 = x48;
			x56 = x47;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v68 = (x56);
	VAL v69 = x57;
	VAL v70 = x58;
	VAL v71 = (x59);
	VAL v72 = x60;
	int64_t v73 = x61;
	while (((bool)v73)) {
		VAL v74 = (v68);
		VAL v75 = v69;
		VAL v76 = v70;
		VAL v77 = (v71);
		VAL v78 = v72;
		VAL v79;
		VAL v80;
		mw_std_list_List_1_uncons(v78, &v79, &v80);
		VAL x81;
		VAL x82;
		VAL x83;
		VAL x84;
		VAL x85;
		int64_t x86;
		switch (get_data_tag(v79)) {
			case 1LL: { // Some
				VAL v87 = mtp_std_maybe_Maybe_1_Some(v79);
				VAL v88;
				VAL v89;
				mw_mirth_c99_C99APIArg_reserveZ_asZ_newZ_localZBang(v87, v74, &v88, &v89);
				VAL v90 = mtw_std_list_List_1_Cons(v88, v77);
				int64_t v91 = 1LL /* True */;
				x86 = v91;
				x85 = v80;
				x84 = v90;
				x83 = v76;
				x82 = v75;
				x81 = v89;
			} break;
			case 0LL: { // None
				int64_t v92 = 0LL /* False */;
				x86 = v92;
				x85 = v80;
				x84 = v77;
				x83 = v76;
				x82 = v75;
				x81 = v74;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v73 = x86;
		v72 = x85;
		v71 = x84;
		v70 = x83;
		v69 = x82;
		v68 = x81;
	}
	decref(v72);
	VAL v93 = mw_std_list_List_1_reverse(v71);
	STR* v94;
	STRLIT(v94, "", 0);
	incref(v70);
	VAL v95 = VVAL(VTUP(v70)->cells[1]);
	incref(v95);
	decref(v70);
	VAL v96 = (mw_std_str_ZPlusStr_pushZ_strZBang(v95, MKSTR(v94)));
	STR* v97;
	STRLIT(v97, "(", 1);
	VAL v98 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v97), v96));
	STR* v99;
	STRLIT(v99, "", 0);
	VAL v100;
	VAL v101;
	mw_std_list_List_1_uncons(v69, &v100, &v101);
	VAL x102;
	VAL x103;
	VAL x104;
	VAL x105;
	VAL x106;
	VAL x107;
	int64_t x108;
	switch (get_data_tag(v100)) {
		case 1LL: { // Some
			VAL v109 = mtp_std_maybe_Maybe_1_Some(v100);
			VAL v110 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v99), v98));
			STR* v111;
			STRLIT(v111, ", ", 2);
			VAL v112 = (mw_std_str_ZPlusStr_pushZ_strZBang(v109, v110));
			int64_t v113 = 1LL /* True */;
			x108 = v113;
			x107 = v101;
			x106 = MKSTR(v111);
			x105 = v112;
			x104 = v70;
			x103 = v93;
			x102 = v68;
		} break;
		case 0LL: { // None
			int64_t v114 = 0LL /* False */;
			x108 = v114;
			x107 = v101;
			x106 = MKSTR(v99);
			x105 = v98;
			x104 = v70;
			x103 = v93;
			x102 = v68;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v115 = (x102);
	VAL v116 = x103;
	VAL v117 = x104;
	VAL v118 = (x105);
	VAL v119 = x106;
	VAL v120 = x107;
	int64_t v121 = x108;
	while (((bool)v121)) {
		VAL v122 = (v115);
		VAL v123 = v116;
		VAL v124 = v117;
		VAL v125 = (v118);
		VAL v126 = v119;
		VAL v127 = v120;
		VAL v128;
		VAL v129;
		mw_std_list_List_1_uncons(v127, &v128, &v129);
		VAL x130;
		VAL x131;
		VAL x132;
		VAL x133;
		VAL x134;
		VAL x135;
		int64_t x136;
		switch (get_data_tag(v128)) {
			case 1LL: { // Some
				VAL v137 = mtp_std_maybe_Maybe_1_Some(v128);
				VAL v138 = (mw_std_str_ZPlusStr_pushZ_strZBang(v126, v125));
				STR* v139;
				STRLIT(v139, ", ", 2);
				VAL v140 = (mw_std_str_ZPlusStr_pushZ_strZBang(v137, v138));
				int64_t v141 = 1LL /* True */;
				x136 = v141;
				x135 = v129;
				x134 = MKSTR(v139);
				x133 = v140;
				x132 = v124;
				x131 = v123;
				x130 = v122;
			} break;
			case 0LL: { // None
				int64_t v142 = 0LL /* False */;
				x136 = v142;
				x135 = v129;
				x134 = v126;
				x133 = v125;
				x132 = v124;
				x131 = v123;
				x130 = v122;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v121 = x136;
		v120 = x135;
		v119 = x134;
		v118 = x133;
		v117 = x132;
		v116 = x131;
		v115 = x130;
	}
	decref(v120);
	incref(v116);
	VAL v143;
	VAL v144;
	mw_std_list_List_1_uncons(v116, &v143, &v144);
	VAL x145;
	VAL x146;
	VAL x147;
	VAL x148;
	VAL x149;
	VAL x150;
	int64_t x151;
	switch (get_data_tag(v143)) {
		case 1LL: { // Some
			VAL v152 = mtp_std_maybe_Maybe_1_Some(v143);
			VAL v153 = (mw_std_str_ZPlusStr_pushZ_strZBang(v119, v118));
			STR* v154;
			STRLIT(v154, ", ", 2);
			STR* v155;
			STRLIT(v155, "&", 1);
			VAL v156 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v155), v153));
			VAL v157 = VVAL(VTUP(v152)->cells[3]);
			incref(v157);
			decref(v152);
			VAL v158 = (mw_std_str_ZPlusStr_pushZ_strZBang(v157, v156));
			int64_t v159 = 1LL /* True */;
			x151 = v159;
			x150 = v144;
			x149 = v116;
			x148 = MKSTR(v154);
			x147 = v158;
			x146 = v117;
			x145 = v115;
		} break;
		case 0LL: { // None
			int64_t v160 = 0LL /* False */;
			x151 = v160;
			x150 = v144;
			x149 = v116;
			x148 = v119;
			x147 = v118;
			x146 = v117;
			x145 = v115;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v161 = (x145);
	VAL v162 = x146;
	VAL v163 = (x147);
	VAL v164 = x148;
	VAL v165 = x149;
	VAL v166 = x150;
	int64_t v167 = x151;
	while (((bool)v167)) {
		VAL v168 = (v161);
		VAL v169 = v162;
		VAL v170 = (v163);
		VAL v171 = v164;
		VAL v172 = v165;
		VAL v173 = v166;
		VAL v174;
		VAL v175;
		mw_std_list_List_1_uncons(v173, &v174, &v175);
		VAL x176;
		VAL x177;
		VAL x178;
		VAL x179;
		VAL x180;
		VAL x181;
		int64_t x182;
		switch (get_data_tag(v174)) {
			case 1LL: { // Some
				VAL v183 = mtp_std_maybe_Maybe_1_Some(v174);
				VAL v184 = (mw_std_str_ZPlusStr_pushZ_strZBang(v171, v170));
				STR* v185;
				STRLIT(v185, ", ", 2);
				STR* v186;
				STRLIT(v186, "&", 1);
				VAL v187 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v186), v184));
				VAL v188 = VVAL(VTUP(v183)->cells[3]);
				incref(v188);
				decref(v183);
				VAL v189 = (mw_std_str_ZPlusStr_pushZ_strZBang(v188, v187));
				int64_t v190 = 1LL /* True */;
				x182 = v190;
				x181 = v175;
				x180 = v172;
				x179 = MKSTR(v185);
				x178 = v189;
				x177 = v169;
				x176 = v168;
			} break;
			case 0LL: { // None
				int64_t v191 = 0LL /* False */;
				x182 = v191;
				x181 = v175;
				x180 = v172;
				x179 = v171;
				x178 = v170;
				x177 = v169;
				x176 = v168;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v167 = x182;
		v166 = x181;
		v165 = x180;
		v164 = x179;
		v163 = x178;
		v162 = x177;
		v161 = x176;
	}
	decref(v166);
	decref(v164);
	STR* v192;
	STRLIT(v192, ")", 1);
	VAL v193 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v192), v163));
	incref(v162);
	VAL v194 = VVAL(VTUP(v162)->cells[5]);
	incref(v194);
	decref(v162);
	VAL x195;
	VAL x196;
	VAL x197;
	switch (get_data_tag(v194)) {
		case 1LL: { // Some
			VAL v198 = mtp_std_maybe_Maybe_1_Some(v194);
			VAL v199 = (mw_mirth_c99_C99APIArg_pushZ_toZBang(v193, v198, v161));
			x197 = v199;
			x196 = v162;
			x195 = v165;
		} break;
		case 0LL: { // None
			VAL v200 = (VVAL(VTUP(v161)->cells[1]));
			VAL v201 = (mw_mirth_c99_ZPlusC99_indent(v200));
			VAL v202 = (mw_mirth_c99_ZPlusC99_put(v193, v201));
			STR* v203;
			STRLIT(v203, ";", 1);
			VAL v204 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v203), v202));
			VAL v205 = (mw_mirth_c99_ZPlusC99_line(v204));
			VTUP(v161)->cells[1] = v205;
			x197 = v161;
			x196 = v162;
			x195 = v165;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v206;
	VAL v207;
	mw_std_list_List_1_uncons(x195, &v206, &v207);
	VAL x208;
	VAL x209;
	VAL x210;
	int64_t x211;
	switch (get_data_tag(v206)) {
		case 1LL: { // Some
			VAL v212 = mtp_std_maybe_Maybe_1_Some(v206);
			VAL v213 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v212, x197));
			int64_t v214 = 1LL /* True */;
			x211 = v214;
			x210 = v207;
			x209 = v213;
			x208 = x196;
		} break;
		case 0LL: { // None
			int64_t v215 = 0LL /* False */;
			x211 = v215;
			x210 = v207;
			x209 = x197;
			x208 = x196;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v216 = x208;
	VAL v217 = (x209);
	VAL v218 = x210;
	int64_t v219 = x211;
	while (((bool)v219)) {
		VAL v220 = v216;
		VAL v221 = (v217);
		VAL v222 = v218;
		VAL v223;
		VAL v224;
		mw_std_list_List_1_uncons(v222, &v223, &v224);
		VAL x225;
		VAL x226;
		VAL x227;
		int64_t x228;
		switch (get_data_tag(v223)) {
			case 1LL: { // Some
				VAL v229 = mtp_std_maybe_Maybe_1_Some(v223);
				VAL v230 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v229, v221));
				int64_t v231 = 1LL /* True */;
				x228 = v231;
				x227 = v224;
				x226 = v230;
				x225 = v220;
			} break;
			case 0LL: { // None
				int64_t v232 = 0LL /* False */;
				x228 = v232;
				x227 = v224;
				x226 = v221;
				x225 = v220;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v219 = x228;
		v218 = x227;
		v217 = x226;
		v216 = x225;
	}
	decref(v218);
	decref(v216);
	return v217;
}
static VAL mw_mirth_c99_ZPlusC99_smartZ_sigZ_put (VAL x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "static ", 7);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	incref(x1);
	VAL v5 = VVAL(VTUP(x1)->cells[5]);
	incref(v5);
	decref(x1);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v5);
			int64_t v9 = VI64(VTUP(v8)->cells[2]);
			decref(v8);
			VAL v10 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v9);
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v4));
			x7 = v11;
			x6 = x1;
		} break;
		case 0LL: { // None
			STR* v12;
			STRLIT(v12, "void", 4);
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v4));
			x7 = v13;
			x6 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	STR* v14;
	STRLIT(v14, " ", 1);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), x7));
	incref(x6);
	VAL v16 = VVAL(VTUP(x6)->cells[1]);
	incref(v16);
	decref(x6);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(v16, v15));
	STR* v18;
	STRLIT(v18, " (", 2);
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
	STR* v20;
	STRLIT(v20, "", 0);
	incref(x6);
	VAL v21 = VVAL(VTUP(x6)->cells[3]);
	incref(v21);
	decref(x6);
	VAL v22;
	VAL v23;
	mw_std_list_List_1_uncons(v21, &v22, &v23);
	VAL x24;
	VAL x25;
	VAL x26;
	VAL x27;
	int64_t x28;
	switch (get_data_tag(v22)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(v22);
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
			STR* v31;
			STRLIT(v31, ", ", 2);
			incref(v29);
			int64_t v32 = VI64(VTUP(v29)->cells[2]);
			decref(v29);
			VAL v33 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v32);
			VAL v34 = (mw_mirth_c99_ZPlusC99_put(v33, v30));
			STR* v35;
			STRLIT(v35, " ", 1);
			VAL v36 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), v34));
			VAL v37 = VVAL(VTUP(v29)->cells[3]);
			incref(v37);
			decref(v29);
			VAL v38 = (mw_mirth_c99_ZPlusC99_put(v37, v36));
			int64_t v39 = 1LL /* True */;
			x28 = v39;
			x27 = v23;
			x26 = x6;
			x25 = MKSTR(v31);
			x24 = v38;
		} break;
		case 0LL: { // None
			int64_t v40 = 0LL /* False */;
			x28 = v40;
			x27 = v23;
			x26 = x6;
			x25 = MKSTR(v20);
			x24 = v19;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v41 = (x24);
	VAL v42 = x25;
	VAL v43 = x26;
	VAL v44 = x27;
	int64_t v45 = x28;
	while (((bool)v45)) {
		VAL v46 = (v41);
		VAL v47 = v42;
		VAL v48 = v43;
		VAL v49 = v44;
		VAL v50;
		VAL v51;
		mw_std_list_List_1_uncons(v49, &v50, &v51);
		VAL x52;
		VAL x53;
		VAL x54;
		VAL x55;
		int64_t x56;
		switch (get_data_tag(v50)) {
			case 1LL: { // Some
				VAL v57 = mtp_std_maybe_Maybe_1_Some(v50);
				VAL v58 = (mw_mirth_c99_ZPlusC99_put(v47, v46));
				STR* v59;
				STRLIT(v59, ", ", 2);
				incref(v57);
				int64_t v60 = VI64(VTUP(v57)->cells[2]);
				decref(v57);
				VAL v61 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v60);
				VAL v62 = (mw_mirth_c99_ZPlusC99_put(v61, v58));
				STR* v63;
				STRLIT(v63, " ", 1);
				VAL v64 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v63), v62));
				VAL v65 = VVAL(VTUP(v57)->cells[3]);
				incref(v65);
				decref(v57);
				VAL v66 = (mw_mirth_c99_ZPlusC99_put(v65, v64));
				int64_t v67 = 1LL /* True */;
				x56 = v67;
				x55 = v51;
				x54 = v48;
				x53 = MKSTR(v59);
				x52 = v66;
			} break;
			case 0LL: { // None
				int64_t v68 = 0LL /* False */;
				x56 = v68;
				x55 = v51;
				x54 = v48;
				x53 = v47;
				x52 = v46;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v45 = x56;
		v44 = x55;
		v43 = x54;
		v42 = x53;
		v41 = x52;
	}
	decref(v44);
	incref(v43);
	VAL v69 = VVAL(VTUP(v43)->cells[4]);
	incref(v69);
	decref(v43);
	VAL v70;
	VAL v71;
	mw_std_list_List_1_uncons(v69, &v70, &v71);
	VAL x72;
	VAL x73;
	VAL x74;
	VAL x75;
	int64_t x76;
	switch (get_data_tag(v70)) {
		case 1LL: { // Some
			VAL v77 = mtp_std_maybe_Maybe_1_Some(v70);
			VAL v78 = (mw_mirth_c99_ZPlusC99_put(v42, v41));
			STR* v79;
			STRLIT(v79, ", ", 2);
			incref(v77);
			int64_t v80 = VI64(VTUP(v77)->cells[2]);
			decref(v77);
			VAL v81 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v80);
			VAL v82 = (mw_mirth_c99_ZPlusC99_put(v81, v78));
			STR* v83;
			STRLIT(v83, " *", 2);
			VAL v84 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v83), v82));
			VAL v85 = VVAL(VTUP(v77)->cells[3]);
			incref(v85);
			decref(v77);
			VAL v86 = (mw_mirth_c99_ZPlusC99_put(v85, v84));
			int64_t v87 = 1LL /* True */;
			x76 = v87;
			x75 = v71;
			x74 = v43;
			x73 = MKSTR(v79);
			x72 = v86;
		} break;
		case 0LL: { // None
			int64_t v88 = 0LL /* False */;
			x76 = v88;
			x75 = v71;
			x74 = v43;
			x73 = v42;
			x72 = v41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v89 = (x72);
	VAL v90 = x73;
	VAL v91 = x74;
	VAL v92 = x75;
	int64_t v93 = x76;
	while (((bool)v93)) {
		VAL v94 = (v89);
		VAL v95 = v90;
		VAL v96 = v91;
		VAL v97 = v92;
		VAL v98;
		VAL v99;
		mw_std_list_List_1_uncons(v97, &v98, &v99);
		VAL x100;
		VAL x101;
		VAL x102;
		VAL x103;
		int64_t x104;
		switch (get_data_tag(v98)) {
			case 1LL: { // Some
				VAL v105 = mtp_std_maybe_Maybe_1_Some(v98);
				VAL v106 = (mw_mirth_c99_ZPlusC99_put(v95, v94));
				STR* v107;
				STRLIT(v107, ", ", 2);
				incref(v105);
				int64_t v108 = VI64(VTUP(v105)->cells[2]);
				decref(v105);
				VAL v109 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v108);
				VAL v110 = (mw_mirth_c99_ZPlusC99_put(v109, v106));
				STR* v111;
				STRLIT(v111, " *", 2);
				VAL v112 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v111), v110));
				VAL v113 = VVAL(VTUP(v105)->cells[3]);
				incref(v113);
				decref(v105);
				VAL v114 = (mw_mirth_c99_ZPlusC99_put(v113, v112));
				int64_t v115 = 1LL /* True */;
				x104 = v115;
				x103 = v99;
				x102 = v96;
				x101 = MKSTR(v107);
				x100 = v114;
			} break;
			case 0LL: { // None
				int64_t v116 = 0LL /* False */;
				x104 = v116;
				x103 = v99;
				x102 = v96;
				x101 = v95;
				x100 = v94;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v93 = x104;
		v92 = x103;
		v91 = x102;
		v90 = x101;
		v89 = x100;
	}
	decref(v92);
	uint64_t v117 = str_size(VSTR(v90));
	int64_t v118 = 0LL;
	bool v119 = (((int64_t)v117) < v118);
	int64_t x120;
	if (v119) {
		x120 = v118;
		push_resource(v89);
		lpush(&lbl_api, v91);
	} else {
		x120 = ((int64_t)v117);
		push_resource(v89);
		lpush(&lbl_api, v91);
	}
	int64_t v121 = 0LL;
	bool v122 = (x120 == v121);
	VAL x123;
	VAL x124;
	if (v122) {
		STR* v125;
		STRLIT(v125, "void", 4);
		VAL r126 = pop_resource();
		VAL v127 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v125), r126));
		VAL v128 = lpop(&lbl_api);
		x124 = v128;
		x123 = v127;
	} else {
		VAL v129 = lpop(&lbl_api);
		x124 = v129;
		VAL r130 = pop_resource();
		x123 = r130;
	}
	STR* v131;
	STRLIT(v131, ")", 1);
	VAL v132 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v131), x123));
	decref(x124);
	return v132;
}
static VAL mw_mirth_c99_c99Z_smartZ_sigZBang (VAL x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(x2));
	VAL v4 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(x1, v3));
	STR* v5;
	STRLIT(v5, ";", 1);
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
	VAL v7 = (mw_mirth_c99_ZPlusC99_line(v6));
	return v7;
}
static VAL mw_mirth_c99_c99Z_apiZ_enterZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[3]);
	incref(v3);
	decref(x1);
	int64_t v4 = mw_std_list_List_1_len(v3);
	incref(x1);
	VAL v5 = VVAL(VTUP(x1)->cells[4]);
	incref(v5);
	decref(x1);
	int64_t v6 = mw_std_list_List_1_len(v5);
	int64_t v7 = i64_add(v4, v6);
	int64_t v8 = 1LL;
	int64_t v9 = i64_add(v7, v8);
	VTUP(x2)->cells[3] = MKI64(v9);
	VAL v10 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(x2));
	incref(x1);
	VAL v11 = VVAL(VTUP(x1)->cells[3]);
	incref(v11);
	decref(x1);
	VAL v12;
	VAL v13;
	mw_std_list_List_1_uncons(v11, &v12, &v13);
	VAL x14;
	VAL x15;
	VAL x16;
	int64_t x17;
	switch (get_data_tag(v12)) {
		case 1LL: { // Some
			VAL v18 = mtp_std_maybe_Maybe_1_Some(v12);
			VAL v19 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v18, v10));
			int64_t v20 = 1LL /* True */;
			x17 = v20;
			x16 = v13;
			x15 = x1;
			x14 = v19;
		} break;
		case 0LL: { // None
			int64_t v21 = 0LL /* False */;
			x17 = v21;
			x16 = v13;
			x15 = x1;
			x14 = v10;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v22 = (x14);
	VAL v23 = x15;
	VAL v24 = x16;
	int64_t v25 = x17;
	while (((bool)v25)) {
		VAL v26 = (v22);
		VAL v27 = v23;
		VAL v28 = v24;
		VAL v29;
		VAL v30;
		mw_std_list_List_1_uncons(v28, &v29, &v30);
		VAL x31;
		VAL x32;
		VAL x33;
		int64_t x34;
		switch (get_data_tag(v29)) {
			case 1LL: { // Some
				VAL v35 = mtp_std_maybe_Maybe_1_Some(v29);
				VAL v36 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v35, v26));
				int64_t v37 = 1LL /* True */;
				x34 = v37;
				x33 = v30;
				x32 = v27;
				x31 = v36;
			} break;
			case 0LL: { // None
				int64_t v38 = 0LL /* False */;
				x34 = v38;
				x33 = v30;
				x32 = v27;
				x31 = v26;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v25 = x34;
		v24 = x33;
		v23 = x32;
		v22 = x31;
	}
	decref(v24);
	decref(v23);
	return v22;
}
static VAL mw_mirth_c99_c99Z_apiZ_exitZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[4]);
	incref(v3);
	decref(x1);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(v4, &v5, &v6);
	VAL x7;
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v11);
			VAL v12;
			VAL v13;
			mw_mirth_c99_C99APIArg_popZ_consumeZBang(v11, x2, &v12, &v13);
			VAL v14 = VVAL(VTUP(v11)->cells[3]);
			incref(v14);
			decref(v11);
			VAL v15 = (VVAL(VTUP(v12)->cells[1]));
			VAL v16 = (mw_mirth_c99_ZPlusC99_indent(v15));
			STR* v17;
			STRLIT(v17, "*", 1);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(v14, v18));
			STR* v20;
			STRLIT(v20, " = ", 3);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(v13, v21));
			STR* v23;
			STRLIT(v23, ";", 1);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
			VAL v25 = (mw_mirth_c99_ZPlusC99_line(v24));
			VTUP(v12)->cells[1] = v25;
			int64_t v26 = 1LL /* True */;
			x10 = v26;
			x9 = v6;
			x8 = x1;
			x7 = v12;
		} break;
		case 0LL: { // None
			int64_t v27 = 0LL /* False */;
			x10 = v27;
			x9 = v6;
			x8 = x1;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v28 = (x7);
	VAL v29 = x8;
	VAL v30 = x9;
	int64_t v31 = x10;
	while (((bool)v31)) {
		VAL v32 = (v28);
		VAL v33 = v29;
		VAL v34 = v30;
		VAL v35;
		VAL v36;
		mw_std_list_List_1_uncons(v34, &v35, &v36);
		VAL x37;
		VAL x38;
		VAL x39;
		int64_t x40;
		switch (get_data_tag(v35)) {
			case 1LL: { // Some
				VAL v41 = mtp_std_maybe_Maybe_1_Some(v35);
				incref(v41);
				VAL v42;
				VAL v43;
				mw_mirth_c99_C99APIArg_popZ_consumeZBang(v41, v32, &v42, &v43);
				VAL v44 = VVAL(VTUP(v41)->cells[3]);
				incref(v44);
				decref(v41);
				VAL v45 = (VVAL(VTUP(v42)->cells[1]));
				VAL v46 = (mw_mirth_c99_ZPlusC99_indent(v45));
				STR* v47;
				STRLIT(v47, "*", 1);
				VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), v46));
				VAL v49 = (mw_mirth_c99_ZPlusC99_put(v44, v48));
				STR* v50;
				STRLIT(v50, " = ", 3);
				VAL v51 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v50), v49));
				VAL v52 = (mw_mirth_c99_ZPlusC99_put(v43, v51));
				STR* v53;
				STRLIT(v53, ";", 1);
				VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v53), v52));
				VAL v55 = (mw_mirth_c99_ZPlusC99_line(v54));
				VTUP(v42)->cells[1] = v55;
				int64_t v56 = 1LL /* True */;
				x40 = v56;
				x39 = v36;
				x38 = v33;
				x37 = v42;
			} break;
			case 0LL: { // None
				int64_t v57 = 0LL /* False */;
				x40 = v57;
				x39 = v36;
				x38 = v33;
				x37 = v32;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v31 = x40;
		v30 = x39;
		v29 = x38;
		v28 = x37;
	}
	decref(v30);
	incref(v29);
	VAL v58 = VVAL(VTUP(v29)->cells[5]);
	incref(v58);
	decref(v29);
	VAL x59;
	VAL x60;
	VAL x61;
	switch (get_data_tag(v58)) {
		case 1LL: { // Some
			VAL v62 = mtp_std_maybe_Maybe_1_Some(v58);
			VAL v63;
			VAL v64;
			mw_mirth_c99_C99APIArg_popZ_consumeZBang(v62, v28, &v63, &v64);
			VAL v65 = mtw_std_maybe_Maybe_1_Some(v64);
			x61 = v65;
			x60 = v29;
			x59 = v63;
		} break;
		case 0LL: { // None
			VAL v66 = MKI64(0LL /* None */);
			x61 = v66;
			x60 = v29;
			x59 = v28;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v67 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x59));
	VAL x68;
	VAL x69;
	switch (get_data_tag(x61)) {
		case 1LL: { // Some
			VAL v70 = mtp_std_maybe_Maybe_1_Some(x61);
			VAL v71 = (mw_mirth_c99_ZPlusC99_indent(v67));
			STR* v72;
			STRLIT(v72, "return ", 7);
			VAL v73 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v72), v71));
			VAL v74 = (mw_mirth_c99_ZPlusC99_put(v70, v73));
			STR* v75;
			STRLIT(v75, ";", 1);
			VAL v76 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v75), v74));
			VAL v77 = (mw_mirth_c99_ZPlusC99_line(v76));
			x69 = v77;
			x68 = x60;
		} break;
		case 0LL: { // None
			x69 = v67;
			x68 = x60;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	decref(x68);
	return x69;
}
static VAL mw_mirth_c99_c99Z_arrowZBang (VAL x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x1)->cells[7]);
	incref(v3);
	decref(x1);
	VAL v4;
	VAL v5;
	mw_std_list_List_1_uncons(v3, &v4, &v5);
	VAL x6;
	VAL x7;
	int64_t x8;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			VAL v10 = (mw_mirth_c99_c99Z_atomZBang(v9, x2));
			int64_t v11 = 1LL /* True */;
			x8 = v11;
			x7 = v5;
			x6 = v10;
		} break;
		case 0LL: { // None
			int64_t v12 = 0LL /* False */;
			x8 = v12;
			x7 = v5;
			x6 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v13 = (x6);
	VAL v14 = x7;
	int64_t v15 = x8;
	while (((bool)v15)) {
		VAL v16 = (v13);
		VAL v17 = v14;
		VAL v18;
		VAL v19;
		mw_std_list_List_1_uncons(v17, &v18, &v19);
		VAL x20;
		VAL x21;
		int64_t x22;
		switch (get_data_tag(v18)) {
			case 1LL: { // Some
				VAL v23 = mtp_std_maybe_Maybe_1_Some(v18);
				VAL v24 = (mw_mirth_c99_c99Z_atomZBang(v23, v16));
				int64_t v25 = 1LL /* True */;
				x22 = v25;
				x21 = v19;
				x20 = v24;
			} break;
			case 0LL: { // None
				int64_t v26 = 0LL /* False */;
				x22 = v26;
				x21 = v19;
				x20 = v16;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v15 = x22;
		v14 = x21;
		v13 = x20;
	}
	decref(v14);
	return v13;
}
static VAL mw_mirth_c99_c99Z_atomZBang (VAL x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = VVAL(VTUP(v3)->cells[1]);
	incref(v4);
	VTUP(x2)->cells[1] = v3;
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	decref(v4);
	VAL x6;
	VAL x7;
	int64_t x8;
	if (((bool)v5)) {
		incref(x1);
		int64_t v9 = mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk(x1);
		x8 = v9;
		x7 = x2;
		x6 = x1;
	} else {
		int64_t v10 = 0LL /* False */;
		x8 = v10;
		x7 = x2;
		x6 = x1;
	}
	VAL x11;
	VAL x12;
	if (((bool)x8)) {
		VAL v13 = (VVAL(VTUP(x7)->cells[1]));
		VAL v14 = (mw_mirth_c99_ZPlusC99_indent(v13));
		STR* v15;
		STRLIT(v15, "WORD_ATOM(", 10);
		VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
		incref(x6);
		uint64_t v17 = VU64(VTUP(x6)->cells[2]);
		decref(x6);
		int64_t v18 = mw_mirth_token_Token_row(v17);
		int64_t v19 = mw_mirth_location_Row_ZToInt(v18);
		STR* v20 = i64_show(v19);
		VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v16));
		STR* v22;
		STRLIT(v22, ", ", 2);
		VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
		incref(x6);
		uint64_t v24 = VU64(VTUP(x6)->cells[2]);
		decref(x6);
		int64_t v25 = mw_mirth_token_Token_col(v24);
		int64_t v26 = mw_mirth_location_Col_ZToInt(v25);
		STR* v27 = i64_show(v26);
		VAL v28 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v27), v23));
		STR* v29;
		STRLIT(v29, ", ", 2);
		VAL v30 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v29), v28));
		incref(x6);
		uint64_t v31 = VU64(VTUP(x6)->cells[2]);
		decref(x6);
		VAL v32 = mw_mirth_token_Token_nameZAsk(v31);
		VAL x33;
		VAL x34;
		VAL x35;
		switch (get_data_tag(v32)) {
			case 1LL: { // Some
				VAL v36 = mtp_std_maybe_Maybe_1_Some(v32);
				VAL v37 = mw_mirth_name_Name_ZToStr(VU64(v36));
				x35 = v37;
				x34 = x6;
				x33 = v30;
			} break;
			case 0LL: { // None
				STR* v38;
				STRLIT(v38, "", 0);
				x35 = MKSTR(v38);
				x34 = x6;
				x33 = v30;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v39 = (mw_mirth_c99_ZPlusC99_putZ_cstr(x35, x33));
		STR* v40;
		STRLIT(v40, ");", 2);
		VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), v39));
		VAL v42 = (mw_mirth_c99_ZPlusC99_line(v41));
		VTUP(x7)->cells[1] = v42;
		x12 = x7;
		x11 = x34;
	} else {
		x12 = x7;
		x11 = x6;
	}
	incref(x11);
	VAL v43 = VVAL(VTUP(x11)->cells[4]);
	incref(v43);
	decref(x11);
	VAL v44 = (mw_mirth_c99_c99Z_atomZ_opZBang(x11, v43, x12));
	return v44;
}
static int64_t mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk (VAL x1) {
	VAL v2 = VVAL(VTUP(x1)->cells[4]);
	incref(v2);
	decref(x1);
	int64_t x3;
	switch (get_data_tag(v2)) {
		case 0LL: { // OpNone
			int64_t v4 = 0LL /* False */;
			x3 = v4;
		} break;
		case 7LL: { // OpInt
			int64_t v5 = mtp_mirth_arrow_Op_OpInt(v2);
			int64_t v6 = 0LL /* False */;
			x3 = v6;
		} break;
		case 8LL: { // OpF64
			double v7 = mtp_mirth_arrow_Op_OpF64(v2);
			int64_t v8 = 0LL /* False */;
			x3 = v8;
		} break;
		case 9LL: { // OpStr
			VAL v9 = mtp_mirth_arrow_Op_OpStr(v2);
			decref(v9);
			int64_t v10 = 0LL /* False */;
			x3 = v10;
		} break;
		case 2LL: { // OpWord
			uint64_t v11 = mtp_mirth_arrow_Op_OpWord(v2);
			int64_t v12 = mw_mirth_word_Word_preferZ_inlineZAsk(v11);
			bool v13 = !((bool)v12);
			x3 = ((int64_t)v13);
		} break;
		case 3LL: { // OpExternal
			uint64_t v14 = mtp_mirth_arrow_Op_OpExternal(v2);
			int64_t v15 = 1LL /* True */;
			x3 = v15;
		} break;
		case 4LL: { // OpBuffer
			uint64_t v16 = mtp_mirth_arrow_Op_OpBuffer(v2);
			int64_t v17 = 0LL /* False */;
			x3 = v17;
		} break;
		case 5LL: { // OpVariable
			uint64_t v18 = mtp_mirth_arrow_Op_OpVariable(v2);
			int64_t v19 = 0LL /* False */;
			x3 = v19;
		} break;
		case 6LL: { // OpField
			uint64_t v20 = mtp_mirth_arrow_Op_OpField(v2);
			int64_t v21 = 0LL /* False */;
			x3 = v21;
		} break;
		case 10LL: { // OpTag
			uint64_t v22 = mtp_mirth_arrow_Op_OpTag(v2);
			int64_t v23 = 0LL /* False */;
			x3 = v23;
		} break;
		case 1LL: { // OpPrim
			int64_t v24 = mtp_mirth_arrow_Op_OpPrim(v2);
			int64_t v25 = 1LL /* True */;
			x3 = v25;
		} break;
		case 11LL: { // OpMatch
			VAL v26 = mtp_mirth_arrow_Op_OpMatch(v2);
			decref(v26);
			int64_t v27 = 0LL /* False */;
			x3 = v27;
		} break;
		case 12LL: { // OpLambda
			VAL v28 = mtp_mirth_arrow_Op_OpLambda(v2);
			decref(v28);
			int64_t v29 = 0LL /* False */;
			x3 = v29;
		} break;
		case 13LL: { // OpVar
			uint64_t v30 = mtp_mirth_arrow_Op_OpVar(v2);
			int64_t v31 = 0LL /* False */;
			x3 = v31;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v32 = mtp_mirth_arrow_Op_OpBlockPush(v2);
			int64_t v33 = 0LL /* False */;
			x3 = v33;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v34 = mtp_mirth_arrow_Op_OpBlockRun(v2);
			int64_t v35 = 0LL /* False */;
			x3 = v35;
		} break;
		case 16LL: { // OpCoerce
			int64_t v36 = mtp_mirth_arrow_Op_OpCoerce(v2);
			int64_t v37 = 0LL /* False */;
			x3 = v37;
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v38 = mtp_mirth_arrow_Op_OpLabelPush(v2);
			int64_t v39 = 0LL /* False */;
			x3 = v39;
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v40 = mtp_mirth_arrow_Op_OpLabelPop(v2);
			int64_t v41 = 0LL /* False */;
			x3 = v41;
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v42 = mtp_mirth_arrow_Op_OpLabelPushR(v2);
			int64_t v43 = 0LL /* False */;
			x3 = v43;
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v44 = mtp_mirth_arrow_Op_OpLabelPopR(v2);
			int64_t v45 = 0LL /* False */;
			x3 = v45;
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v46 = mtp_mirth_arrow_Op_OpDataGetTag(v2);
			int64_t v47 = 0LL /* False */;
			x3 = v47;
		} break;
		case 22LL: { // OpDataGetLabel
			VAL v48 = mtp_mirth_arrow_Op_OpDataGetLabel(v2);
			decref(v48);
			int64_t v49 = 0LL /* False */;
			x3 = v49;
		} break;
		case 23LL: { // OpDataSetLabel
			VAL v50 = mtp_mirth_arrow_Op_OpDataSetLabel(v2);
			decref(v50);
			int64_t v51 = 0LL /* False */;
			x3 = v51;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_c99_c99Z_atomZ_opZBang (VAL x1, VAL x2, VAL x3) {
	VAL x4;
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			decref(x1);
			x4 = x3;
		} break;
		case 7LL: { // OpInt
			int64_t v5 = mtp_mirth_arrow_Op_OpInt(x2);
			decref(x1);
			VAL v6 = (mw_mirth_c99_c99Z_intZBang(v5, x3));
			x4 = v6;
		} break;
		case 8LL: { // OpF64
			double v7 = mtp_mirth_arrow_Op_OpF64(x2);
			decref(x1);
			VAL v8 = (mw_mirth_c99_c99Z_f64ZBang(v7, x3));
			x4 = v8;
		} break;
		case 9LL: { // OpStr
			VAL v9 = mtp_mirth_arrow_Op_OpStr(x2);
			decref(x1);
			VAL v10 = (mw_mirth_c99_c99Z_strZBang(v9, x3));
			x4 = v10;
		} break;
		case 2LL: { // OpWord
			uint64_t v11 = mtp_mirth_arrow_Op_OpWord(x2);
			VAL v12 = VVAL(VTUP(x1)->cells[5]);
			incref(v12);
			decref(x1);
			VAL v13 = (mw_mirth_c99_c99Z_wordZBang(v12, v11, x3));
			x4 = v13;
		} break;
		case 3LL: { // OpExternal
			uint64_t v14 = mtp_mirth_arrow_Op_OpExternal(x2);
			VAL v15 = VVAL(VTUP(x1)->cells[5]);
			incref(v15);
			decref(x1);
			VAL v16 = (mw_mirth_c99_c99Z_externalZ_callZBang(v15, v14, x3));
			x4 = v16;
		} break;
		case 4LL: { // OpBuffer
			uint64_t v17 = mtp_mirth_arrow_Op_OpBuffer(x2);
			decref(x1);
			VAL v18 = (mw_mirth_c99_c99Z_bufferZ_callZBang(v17, x3));
			x4 = v18;
		} break;
		case 5LL: { // OpVariable
			uint64_t v19 = mtp_mirth_arrow_Op_OpVariable(x2);
			decref(x1);
			VAL v20 = (mw_mirth_c99_c99Z_variableZ_callZBang(v19, x3));
			x4 = v20;
		} break;
		case 6LL: { // OpField
			uint64_t v21 = mtp_mirth_arrow_Op_OpField(x2);
			decref(x1);
			VAL v22 = (mw_mirth_c99_c99Z_fieldZ_callZBang(v21, x3));
			x4 = v22;
		} break;
		case 10LL: { // OpTag
			uint64_t v23 = mtp_mirth_arrow_Op_OpTag(x2);
			VAL v24 = VVAL(VTUP(x1)->cells[5]);
			incref(v24);
			decref(x1);
			VAL v25 = (mw_mirth_c99_c99Z_tagZ_callZBang(v24, v23, x3));
			x4 = v25;
		} break;
		case 1LL: { // OpPrim
			int64_t v26 = mtp_mirth_arrow_Op_OpPrim(x2);
			VAL v27 = (mw_mirth_c99_c99Z_primZBang(x1, v26, x3));
			x4 = v27;
		} break;
		case 11LL: { // OpMatch
			VAL v28 = mtp_mirth_arrow_Op_OpMatch(x2);
			decref(x1);
			VAL v29 = (mw_mirth_c99_c99Z_matchZBang(v28, x3));
			x4 = v29;
		} break;
		case 12LL: { // OpLambda
			VAL v30 = mtp_mirth_arrow_Op_OpLambda(x2);
			decref(x1);
			VAL v31 = (mw_mirth_c99_c99Z_lambdaZBang(v30, x3));
			x4 = v31;
		} break;
		case 13LL: { // OpVar
			uint64_t v32 = mtp_mirth_arrow_Op_OpVar(x2);
			decref(x1);
			VAL v33 = (mw_mirth_c99_c99Z_varZBang(v32, x3));
			x4 = v33;
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v34 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			decref(x1);
			VAL v35 = (mw_mirth_c99_c99Z_blockZ_pushZBang(v34, x3));
			x4 = v35;
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v36 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			decref(x1);
			VAL v37 = (mw_mirth_c99_c99Z_blockZ_runZBang(v36, x3));
			x4 = v37;
		} break;
		case 16LL: { // OpCoerce
			int64_t v38 = mtp_mirth_arrow_Op_OpCoerce(x2);
			decref(x1);
			x4 = x3;
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v39 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			VAL v40 = (mw_mirth_c99_c99Z_labelZ_pushZBang(x1, v39, x3));
			x4 = v40;
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v41 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			VAL v42 = (mw_mirth_c99_c99Z_labelZ_popZBang(x1, v41, x3));
			x4 = v42;
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v43 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			VAL v44 = (mw_mirth_c99_c99Z_labelZ_pushZ_rZBang(x1, v43, x3));
			x4 = v44;
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v45 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			VAL v46 = (mw_mirth_c99_c99Z_labelZ_popZ_rZBang(x1, v45, x3));
			x4 = v46;
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v47 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			decref(x1);
			VAL v48 = (mw_mirth_c99_c99Z_getZ_dataZ_tagZBang(v47, x3));
			x4 = v48;
		} break;
		case 22LL: { // OpDataGetLabel
			VAL v49 = mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			VAL v50 = (mw_mirth_c99_c99Z_tagZ_getZ_labelZBang(v49, x3));
			decref(x1);
			x4 = v50;
		} break;
		case 23LL: { // OpDataSetLabel
			VAL v51 = mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			VAL v52 = (mw_mirth_c99_c99Z_tagZ_setZ_labelZBang(v51, x3));
			decref(x1);
			x4 = v52;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_c99_c99Z_getZ_dataZ_tagZBang (uint64_t x1, VAL x2) {
	int64_t v3 = mw_mirth_data_Data_isZ_enumZ_orZ_unitZAsk(x1);
	VAL x4;
	uint64_t x5;
	if (((bool)v3)) {
		x5 = x1;
		x4 = x2;
	} else {
		VAL v6 = mtw_mirth_type_Type_TData(x1);
		int64_t v7;
		VAL v8;
		mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v6, x2, &v7, &v8);
		VAL v9;
		VAL v10;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v8, v7, &v9, &v10);
		VAL v11 = (VVAL(VTUP(v9)->cells[1]));
		VAL v12 = (VVAL(VTUP(v11)->cells[6]));
		VAL v13;
		VAL v14;
		mw_mirth_data_Data_semiZ_transparentZAsk(v12, x1, &v13, &v14);
		VTUP(v11)->cells[6] = v13;
		VTUP(v9)->cells[1] = v11;
		VAL x15;
		uint64_t x16;
		VAL x17;
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				VAL v18 = mtp_std_maybe_Maybe_1_Some(v14);
				int64_t v19 = 2LL /* C99RT_I64 */;
				VAL v20 = (VVAL(VTUP(v9)->cells[1]));
				VAL v21;
				VAL v22;
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v20, &v21, &v22);
				VAL v23 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v19, v21));
				VAL v24 = (mw_mirth_c99_ZPlusC99_indent(v22));
				int64_t v25 = VI64(VTUP(v23)->cells[1]);
				VAL v26 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v25);
				VAL v27 = (mw_mirth_c99_ZPlusC99_put(v26, v24));
				STR* v28;
				STRLIT(v28, " ", 1);
				VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
				VAL v30 = VVAL(VTUP(v23)->cells[2]);
				incref(v30);
				VAL v31 = (mw_mirth_c99_ZPlusC99_put(v30, v29));
				STR* v32;
				STRLIT(v32, " = ", 3);
				VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v31));
				uint64_t v34 = VU64(VTUP(v18)->cells[1]);
				decref(v18);
				int64_t v35 = mw_mirth_data_Tag_value(v34);
				STR* v36 = i64_show(v35);
				VAL v37 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v36), v33));
				STR* v38;
				STRLIT(v38, "LL", 2);
				VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
				STR* v40;
				STRLIT(v40, ";", 1);
				VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), v39));
				VAL v42 = (mw_mirth_c99_ZPlusC99_line(v41));
				VTUP(v9)->cells[1] = v42;
				VAL v43 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v9, v23));
				x17 = v43;
				x16 = x1;
				x15 = v10;
			} break;
			case 0LL: { // None
				int64_t v44 = 2LL /* C99RT_I64 */;
				VAL v45 = (VVAL(VTUP(v9)->cells[1]));
				VAL v46;
				VAL v47;
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v45, &v46, &v47);
				VAL v48 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v44, v46));
				VAL v49 = (mw_mirth_c99_ZPlusC99_indent(v47));
				int64_t v50 = VI64(VTUP(v48)->cells[1]);
				VAL v51 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v50);
				VAL v52 = (mw_mirth_c99_ZPlusC99_put(v51, v49));
				STR* v53;
				STRLIT(v53, " ", 1);
				VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v53), v52));
				VAL v55 = VVAL(VTUP(v48)->cells[2]);
				incref(v55);
				VAL v56 = (mw_mirth_c99_ZPlusC99_put(v55, v54));
				STR* v57;
				STRLIT(v57, " = ", 3);
				VAL v58 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v57), v56));
				STR* v59;
				STRLIT(v59, "get_data_tag(", 13);
				VAL v60 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v59), v58));
				VAL v61;
				VAL v62;
				mw_mirth_c99_ZPlusC99Local_rdup(v10, &v61, &v62);
				VAL v63 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v61);
				VAL v64 = (mw_mirth_c99_ZPlusC99_put(v63, v60));
				STR* v65;
				STRLIT(v65, ")", 1);
				VAL v66 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v65), v64));
				STR* v67;
				STRLIT(v67, ";", 1);
				VAL v68 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v67), v66));
				VAL v69 = (mw_mirth_c99_ZPlusC99_line(v68));
				VTUP(v9)->cells[1] = v69;
				VAL v70 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v9, v48));
				x17 = v70;
				x16 = x1;
				x15 = v62;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v71 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(x17, x15));
		x5 = x16;
		x4 = v71;
	}
	return x4;
}
static VAL mw_mirth_c99_c99Z_wordZBang (VAL x1, uint64_t x2, VAL x3) {
	int64_t v4 = mw_mirth_word_Word_preferZ_inlineZAsk(x2);
	VAL x5;
	if (((bool)v4)) {
		VAL v6 = (mw_mirth_c99_c99Z_argsZ_pushZBang(x1, x3));
		VAL v7 = (VVAL(VTUP(v6)->cells[1]));
		VAL v8 = (VVAL(VTUP(v7)->cells[6]));
		VAL v9;
		VAL v10;
		mw_mirth_word_Word_arrow(x2, v8, &v9, &v10);
		VTUP(v7)->cells[6] = v10;
		VTUP(v6)->cells[1] = v7;
		VAL v11 = (mw_mirth_c99_c99Z_arrowZBang(v9, v6));
		x5 = v11;
	} else {
		VAL v12 = (VVAL(VTUP(x3)->cells[1]));
		VAL v13;
		VAL v14;
		mw_mirth_word_Word_c99Z_api(x2, v12, &v13, &v14);
		VTUP(x3)->cells[1] = v14;
		VAL v15 = (mw_mirth_c99_c99Z_smartZ_callZBang(x1, v13, x3));
		x5 = v15;
	}
	return x5;
}
static VAL mw_mirth_data_Tag_valueZ_show (uint64_t x1) {
	void* v2 = mfld_mirth_data_Tag_ZTildevalueZ_show(x1);
	bool v3 = mut_is_set(v2);
	uint64_t x4;
	VAL x5;
	if (v3) {
		VAL v6 = mut_get(v2);
		x5 = v6;
		x4 = x1;
	} else {
		int64_t v7 = mw_mirth_data_Tag_value(x1);
		STR* v8 = i64_show(v7);
		incref(MKSTR(v8));
		mut_set(MKSTR(v8), v2);
		x5 = MKSTR(v8);
		x4 = x1;
	}
	return x5;
}
static VAL mw_mirth_c99_c99Z_tagZ_callZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = (VVAL(VTUP(x3)->cells[1]));
	VAL v5 = (VVAL(VTUP(v4)->cells[6]));
	VAL v6;
	int64_t v7;
	mw_mirth_data_Tag_preferZ_inlineZAsk(v5, x2, &v6, &v7);
	VTUP(v4)->cells[6] = v6;
	VTUP(x3)->cells[1] = v4;
	VAL x8;
	if (((bool)v7)) {
		decref(x1);
		VAL v9 = (mw_mirth_c99_c99Z_tagZ_bodyZBang(x2, x3));
		x8 = v9;
	} else {
		VAL v10 = (VVAL(VTUP(x3)->cells[1]));
		VAL v11;
		VAL v12;
		mw_mirth_data_Tag_wordZ_c99Z_api(x2, v10, &v11, &v12);
		VTUP(x3)->cells[1] = v12;
		VAL v13 = (mw_mirth_c99_c99Z_smartZ_callZBang(x1, v11, x3));
		x8 = v13;
	}
	return x8;
}
static VAL mw_mirth_c99_c99Z_reverseZ_tagZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	int64_t v6;
	mw_mirth_data_Tag_preferZ_inlineZAsk(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VTUP(x2)->cells[1] = v3;
	VAL x7;
	if (((bool)v6)) {
		VAL v8 = (mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang(x1, x2));
		x7 = v8;
	} else {
		VAL v9 = MKI64(0LL /* Nil */);
		VAL v10 = (VVAL(VTUP(x2)->cells[1]));
		VAL v11;
		VAL v12;
		mw_mirth_data_Tag_patZ_c99Z_api(x1, v10, &v11, &v12);
		VTUP(x2)->cells[1] = v12;
		VAL v13 = (mw_mirth_c99_c99Z_smartZ_callZBang(v9, v11, x2));
		x7 = v13;
	}
	return x7;
}
static VAL mw_mirth_c99_c99Z_labelZ_defsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_label_Label_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_labelZ_defZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_label_Label_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_labelZ_defZBang (uint64_t x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "static VAL lbl_", 15);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	uint64_t v5 = mw_mirth_label_Label_name(x1);
	VAL v6 = mw_mirth_name_Name_mangled(v5);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(v6, v4));
	STR* v8;
	STRLIT(v8, " = MKNIL_C;", 11);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
	VAL v10 = (mw_mirth_c99_ZPlusC99_line(v9));
	return v10;
}
static VAL mw_mirth_c99_pushZ_localZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(x3);
	VAL v5 = (mw_mirth_c99_ZPlusC99_indent(x2));
	STR* v6;
	STRLIT(v6, "lpush(&lbl_", 11);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	uint64_t v8 = mw_mirth_label_Label_name(x1);
	VAL v9 = mw_mirth_name_Name_mangled(v8);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v9, v7));
	STR* v11;
	STRLIT(v11, ", ", 2);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(v4, v12));
	STR* v14;
	STRLIT(v14, ");", 2);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
	VAL v16 = (mw_mirth_c99_ZPlusC99_line(v15));
	return v16;
}
static VAL mw_mirth_c99_pushZ_localZ_labelZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = (VVAL(VTUP(x2)->cells[2]));
	VAL v5 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v4, x3, x1));
	VTUP(x2)->cells[2] = v5;
	return x2;
}
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(x3);
	VAL v5 = (mw_mirth_c99_ZPlusC99_indent(x2));
	STR* v6;
	STRLIT(v6, "lpush(&lbl_", 11);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	uint64_t v8 = mw_mirth_label_Label_name(x1);
	VAL v9 = mw_mirth_name_Name_mangled(v8);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v9, v7));
	STR* v11;
	STRLIT(v11, ", ", 2);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(v4, v12));
	STR* v14;
	STRLIT(v14, ");", 2);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
	VAL v16 = (mw_mirth_c99_ZPlusC99_line(v15));
	return v16;
}
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v4 = (VVAL(VTUP(x2)->cells[2]));
	VAL v5 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v4, x3, x1));
	VTUP(x2)->cells[2] = v5;
	return x2;
}
static void mw_mirth_c99_popZ_localZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(x3, &v6, &v7);
	VAL v8 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_indent(v7));
	int64_t v10 = VI64(VTUP(v8)->cells[1]);
	VAL v11 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v10);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v11, v9));
	STR* v13;
	STRLIT(v13, " ", 1);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = VVAL(VTUP(v8)->cells[2]);
	incref(v15);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v14));
	STR* v17;
	STRLIT(v17, " = ", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL x19;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v20;
			STRLIT(v20, "lpop(&lbl_", 10);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v18));
			uint64_t v22 = mw_mirth_label_Label_name(x2);
			VAL v23 = mw_mirth_name_Name_mangled(v22);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v21));
			STR* v25;
			STRLIT(v25, ")", 1);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			x19 = v26;
		} break;
		default: {
			VAL v27 = mw_mirth_c99_C99ReprType_vZ_macro(x1);
			VAL v28 = (mw_mirth_c99_ZPlusC99_put(v27, v18));
			STR* v29;
			STRLIT(v29, "(lpop(&lbl_", 11);
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v29), v28));
			uint64_t v31 = mw_mirth_label_Label_name(x2);
			VAL v32 = mw_mirth_name_Name_mangled(v31);
			VAL v33 = (mw_mirth_c99_ZPlusC99_put(v32, v30));
			STR* v34;
			STRLIT(v34, "))", 2);
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v34), v33));
			x19 = v35;
		} break;
	}
	STR* v36;
	STRLIT(v36, ";", 1);
	VAL v37 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v36), x19));
	VAL v38 = (mw_mirth_c99_ZPlusC99_line(v37));
	*x5 = v8;
	*x4 = v38;
}
static void mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(x3, &v6, &v7);
	VAL v8 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1, v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_indent(v7));
	int64_t v10 = VI64(VTUP(v8)->cells[1]);
	VAL v11 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v10);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v11, v9));
	STR* v13;
	STRLIT(v13, " ", 1);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = VVAL(VTUP(v8)->cells[2]);
	incref(v15);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v14));
	STR* v17;
	STRLIT(v17, " = (", 4);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL x19;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v20;
			STRLIT(v20, "lpop(&lbl_", 10);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v18));
			uint64_t v22 = mw_mirth_label_Label_name(x2);
			VAL v23 = mw_mirth_name_Name_mangled(v22);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v21));
			STR* v25;
			STRLIT(v25, ")", 1);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			x19 = v26;
		} break;
		default: {
			VAL v27 = mw_mirth_c99_C99ReprType_vZ_macro(x1);
			VAL v28 = (mw_mirth_c99_ZPlusC99_put(v27, v18));
			STR* v29;
			STRLIT(v29, "(lpop(&lbl_", 11);
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v29), v28));
			uint64_t v31 = mw_mirth_label_Label_name(x2);
			VAL v32 = mw_mirth_name_Name_mangled(v31);
			VAL v33 = (mw_mirth_c99_ZPlusC99_put(v32, v30));
			STR* v34;
			STRLIT(v34, "))", 2);
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v34), v33));
			x19 = v35;
		} break;
	}
	STR* v36;
	STRLIT(v36, ");", 2);
	VAL v37 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v36), x19));
	VAL v38 = (mw_mirth_c99_ZPlusC99_line(v37));
	*x5 = v8;
	*x4 = v38;
}
static VAL mw_mirth_c99_c99Z_labelZ_pushZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[6]);
	incref(v4);
	decref(x1);
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v4, x3, &v5, &v6, &v7);
	decref(v5);
	VAL v8 = (mw_mirth_c99_pushZ_localZ_labelZBang(x2, v6, v7));
	return v8;
}
static VAL mw_mirth_c99_c99Z_labelZ_pushZ_rZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[6]);
	incref(v4);
	decref(x1);
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v4, x3, &v5, &v6, &v7);
	decref(v5);
	VAL v8 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(x2, v6, v7));
	return v8;
}
static VAL mw_mirth_c99_c99Z_labelZ_popZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[6]);
	incref(v4);
	decref(x1);
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZ_fromZ_stackZ_typeZBang(x2, v4, x3, &v5, &v6, &v7);
	decref(v5);
	VAL v8 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v6, v7));
	return v8;
}
static VAL mw_mirth_c99_c99Z_labelZ_popZ_rZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v4 = VVAL(VTUP(x1)->cells[6]);
	incref(v4);
	decref(x1);
	VAL v5;
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZ_fromZ_stackZ_typeZBang(x2, v4, x3, &v5, &v6, &v7);
	decref(v5);
	VAL v8 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v6, v7));
	return v8;
}
static VAL mw_mirth_c99_c99Z_intZBang (int64_t x1, VAL x2) {
	int64_t v3 = 2LL /* C99RT_I64 */;
	VAL v4 = (VVAL(VTUP(x2)->cells[1]));
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v4, &v5, &v6);
	VAL v7 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v3, v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v6));
	int64_t v9 = VI64(VTUP(v7)->cells[1]);
	VAL v10 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v9);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v8));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL v14 = VVAL(VTUP(v7)->cells[2]);
	incref(v14);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(v14, v13));
	STR* v16;
	STRLIT(v16, " = ", 3);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	STR* v18 = i64_show(x1);
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
	STR* v20;
	STRLIT(v20, "LL", 2);
	VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
	STR* v22;
	STRLIT(v22, ";", 1);
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
	VAL v24 = (mw_mirth_c99_ZPlusC99_line(v23));
	VTUP(x2)->cells[1] = v24;
	VAL v25 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v7));
	return v25;
}
static VAL mw_mirth_c99_c99Z_f64ZBang (double x1, VAL x2) {
	int64_t v3 = 10LL /* C99RT_F64 */;
	VAL v4 = (VVAL(VTUP(x2)->cells[1]));
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v4, &v5, &v6);
	VAL v7 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v3, v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v6));
	int64_t v9 = VI64(VTUP(v7)->cells[1]);
	VAL v10 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v9);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v8));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL v14 = VVAL(VTUP(v7)->cells[2]);
	incref(v14);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(v14, v13));
	STR* v16;
	STRLIT(v16, " = ", 3);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	STR* v18 = f64_show(x1);
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
	STR* v20;
	STRLIT(v20, ";", 1);
	VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
	VAL v22 = (mw_mirth_c99_ZPlusC99_line(v21));
	VTUP(x2)->cells[1] = v22;
	VAL v23 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v7));
	return v23;
}
static VAL mw_mirth_c99_c99Z_strZBang (VAL x1, VAL x2) {
	int64_t v3 = 1LL /* C99RT_STR */;
	VAL v4;
	VAL v5;
	mw_mirth_c99_C99ReprType_newZ_localZBang(v3, x2, &v4, &v5);
	incref(x1);
	uint64_t v6 = str_size(VSTR(x1));
	int64_t v7 = 0LL;
	bool v8 = (((int64_t)v6) < v7);
	int64_t x9;
	if (v8) {
		x9 = v7;
		push_resource(v4);
		lpush(&lbl_ZPlusstr, v5);
		push_value(x1);
	} else {
		x9 = ((int64_t)v6);
		push_resource(v4);
		lpush(&lbl_ZPlusstr, v5);
		push_value(x1);
	}
	int64_t v10 = 4090LL;
	int64_t v11 = 0LL;
	bool v12 = (v10 < v11);
	int64_t x13;
	if (v12) {
		x13 = v11;
		push_i64(x9);
	} else {
		x13 = v10;
		push_i64(x9);
	}
	int64_t v14 = pop_i64();
	bool v15 = (v14 > x13);
	VAL x16;
	VAL x17;
	VAL x18;
	if (v15) {
		VAL r19 = pop_resource();
		VAL v20 = (VVAL(VTUP(r19)->cells[1]));
		VAL v21 = (mw_mirth_c99_ZPlusC99_indent(v20));
		STR* v22;
		STRLIT(v22, "STRLIT(", 7);
		VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
		VAL v24 = (lpop(&lbl_ZPlusstr));
		VAL v25;
		VAL v26;
		mw_mirth_c99_ZPlusC99Local_rdup(v24, &v25, &v26);
		VAL v27 = mw_mirth_c99_ZPlusC99Local_consume(v25);
		VAL v28 = (mw_mirth_c99_ZPlusC99_put(v27, v23));
		STR* v29;
		STRLIT(v29, ",", 1);
		VAL v30 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v29), v28));
		VAL v31 = (mw_mirth_c99_ZPlusC99_line(v30));
		VTUP(r19)->cells[1] = v31;
		VAL v32 = (VVAL(VTUP(r19)->cells[1]));
		int64_t v33 = VI64(VTUP(v32)->cells[2]);
		int64_t v34 = 1LL;
		int64_t v35 = i64_add(v33, v34);
		VTUP(v32)->cells[2] = MKI64(v35);
		VTUP(r19)->cells[1] = v32;
		VAL v36 = (VVAL(VTUP(r19)->cells[1]));
		VAL v37 = (mw_mirth_c99_ZPlusC99_indent(v36));
		VAL v38 = pop_value();
		incref(v38);
		VAL v39 = (mw_mirth_c99_ZPlusC99_putZ_cstrZ_long(v38, v37));
		STR* v40;
		STRLIT(v40, ",", 1);
		VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), v39));
		VAL v42 = (mw_mirth_c99_ZPlusC99_line(v41));
		VTUP(r19)->cells[1] = v42;
		VAL v43 = (VVAL(VTUP(r19)->cells[1]));
		VAL v44 = (mw_mirth_c99_ZPlusC99_indent(v43));
		incref(v38);
		uint64_t v45 = str_size(VSTR(v38));
		int64_t v46 = 0LL;
		bool v47 = (((int64_t)v45) < v46);
		int64_t x48;
		if (v47) {
			x48 = v46;
			lpush(&lbl_ZPlusstr, v26);
			push_resource(v44);
			push_value(v38);
		} else {
			x48 = ((int64_t)v45);
			lpush(&lbl_ZPlusstr, v26);
			push_resource(v44);
			push_value(v38);
		}
		STR* v49 = i64_show(x48);
		VAL r50 = pop_resource();
		VAL v51 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v49), r50));
		VAL v52 = (mw_mirth_c99_ZPlusC99_line(v51));
		VTUP(r19)->cells[1] = v52;
		VAL v53 = (VVAL(VTUP(r19)->cells[1]));
		int64_t v54 = VI64(VTUP(v53)->cells[2]);
		int64_t v55 = 1LL;
		int64_t v56 = i64_sub(v54, v55);
		int64_t v57 = 0LL;
		bool v58 = (v56 < v57);
		int64_t x59;
		if (v58) {
			int64_t v60 = 0LL;
			x59 = v60;
		} else {
			x59 = v56;
		}
		VTUP(v53)->cells[2] = MKI64(x59);
		VTUP(r19)->cells[1] = v53;
		VAL v61 = (VVAL(VTUP(r19)->cells[1]));
		VAL v62 = (mw_mirth_c99_ZPlusC99_indent(v61));
		STR* v63;
		STRLIT(v63, ");", 2);
		VAL v64 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v63), v62));
		VAL v65 = (mw_mirth_c99_ZPlusC99_line(v64));
		VTUP(r19)->cells[1] = v65;
		x18 = r19;
		VAL v66 = pop_value();
		x17 = v66;
		VAL v67 = (lpop(&lbl_ZPlusstr));
		x16 = v67;
	} else {
		VAL r68 = pop_resource();
		VAL v69 = (VVAL(VTUP(r68)->cells[1]));
		VAL v70 = (mw_mirth_c99_ZPlusC99_indent(v69));
		STR* v71;
		STRLIT(v71, "STRLIT(", 7);
		VAL v72 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v71), v70));
		VAL v73 = (lpop(&lbl_ZPlusstr));
		VAL v74;
		VAL v75;
		mw_mirth_c99_ZPlusC99Local_rdup(v73, &v74, &v75);
		VAL v76 = mw_mirth_c99_ZPlusC99Local_consume(v74);
		VAL v77 = (mw_mirth_c99_ZPlusC99_put(v76, v72));
		STR* v78;
		STRLIT(v78, ", ", 2);
		VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
		VAL v80 = pop_value();
		incref(v80);
		VAL v81 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v80, v79));
		STR* v82;
		STRLIT(v82, ", ", 2);
		VAL v83 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v82), v81));
		incref(v80);
		uint64_t v84 = str_size(VSTR(v80));
		int64_t v85 = 0LL;
		bool v86 = (((int64_t)v84) < v85);
		int64_t x87;
		if (v86) {
			x87 = v85;
			lpush(&lbl_ZPlusstr, v75);
			push_resource(v83);
			push_value(v80);
		} else {
			x87 = ((int64_t)v84);
			lpush(&lbl_ZPlusstr, v75);
			push_resource(v83);
			push_value(v80);
		}
		STR* v88 = i64_show(x87);
		VAL r89 = pop_resource();
		VAL v90 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v88), r89));
		STR* v91;
		STRLIT(v91, ");", 2);
		VAL v92 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v91), v90));
		VAL v93 = (mw_mirth_c99_ZPlusC99_line(v92));
		VTUP(r68)->cells[1] = v93;
		x18 = r68;
		VAL v94 = pop_value();
		x17 = v94;
		VAL v95 = (lpop(&lbl_ZPlusstr));
		x16 = v95;
	}
	decref(x17);
	VAL v96 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x18, x16));
	return v96;
}
static VAL mw_mirth_c99_ZPlusC99_putZ_cstrZ_long (VAL x1, VAL x2) {
	int64_t v3 = 0LL /* False */;
	int64_t v4 = 34LL /* BQUOTE */;
	VAL v5 = (mw_mirth_c99_ZPlusC99_putZ_byte(v4, x2));
	int64_t v6 = 0LL /* BNUL */;
	incref(x1);
	incref(x1);
	void* v7 = str_base(VSTR(x1));
	uint64_t v8 = str_size(VSTR(x1));
	int64_t v9 = 0LL;
	bool v10 = (((int64_t)v8) < v9);
	int64_t x11;
	if (v10) {
		x11 = v9;
		lpush(&lbl_avoidZ_hexdigit, MKI64(v3));
		push_resource(v5);
		push_i64(v6);
		push_ptr(v7);
	} else {
		x11 = ((int64_t)v8);
		lpush(&lbl_avoidZ_hexdigit, MKI64(v3));
		push_resource(v5);
		push_i64(v6);
		push_ptr(v7);
	}
	int64_t v12 = 0LL;
	bool v13 = (x11 > v12);
	int64_t v14 = x11;
	bool v15 = v13;
	while (v15) {
		int64_t v16 = v14;
		void* v17 = pop_ptr();
		int64_t v18 = (0LL /* +Unsafe */);
		int64_t v19;
		int64_t v20;
		mw_std_prim_Ptr_ZAtByte(v17, v18, &v19, &v20);
		int64_t v21 = pop_i64();
		int64_t v22 = 10LL /* BLF */;
		bool v23 = (v21 == v22);
		int64_t x24;
		VAL x25;
		int64_t x26;
		if (v23) {
			int64_t v27 = 34LL /* BQUOTE */;
			VAL r28 = pop_resource();
			VAL v29 = (mw_mirth_c99_ZPlusC99_putZ_byte(v27, r28));
			VAL v30 = (mw_mirth_c99_ZPlusC99_line(v29));
			VAL v31 = (mw_mirth_c99_ZPlusC99_indent(v30));
			int64_t v32 = 34LL /* BQUOTE */;
			VAL v33 = (mw_mirth_c99_ZPlusC99_putZ_byte(v32, v31));
			x26 = v19;
			x25 = v33;
			int64_t v34 = VI64(lpop(&lbl_avoidZ_hexdigit));
			x24 = v34;
		} else {
			x26 = v19;
			VAL r35 = pop_resource();
			x25 = r35;
			int64_t v36 = VI64(lpop(&lbl_avoidZ_hexdigit));
			x24 = v36;
		}
		int64_t v37;
		VAL v38;
		mw_mirth_c99_c99Z_stringZ_byteZBang(x26, x24, x25, &v37, &v38);
		int64_t v39 = 1LL;
		int64_t v40 = (0LL /* +Unsafe */);
		void* v41 = (void*)(v39 + (char*)v17);
		int64_t v42 = 1LL;
		int64_t v43 = i64_sub(v16, v42);
		int64_t v44 = 0LL;
		bool v45 = (v43 < v44);
		int64_t x46;
		if (v45) {
			int64_t v47 = 0LL;
			x46 = v47;
			push_i64(x26);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v37));
			push_resource(v38);
			push_ptr(v41);
		} else {
			x46 = v43;
			push_i64(x26);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v37));
			push_resource(v38);
			push_ptr(v41);
		}
		int64_t v48 = 0LL;
		bool v49 = (x46 > v48);
		v15 = v49;
		v14 = x46;
	}
	void* v50 = pop_ptr();
	decref(x1);
	int64_t v51 = 34LL /* BQUOTE */;
	VAL r52 = pop_resource();
	VAL v53 = (mw_mirth_c99_ZPlusC99_putZ_byte(v51, r52));
	int64_t v54 = VI64(lpop(&lbl_avoidZ_hexdigit));
	VAL v55 = pop_value();
	decref(v55);
	return v53;
}
static VAL mw_mirth_c99_ZPlusC99_putZ_cstr (VAL x1, VAL x2) {
	int64_t v3 = 0LL /* False */;
	int64_t v4 = 34LL /* BQUOTE */;
	VAL v5 = (mw_mirth_c99_ZPlusC99_putZ_byte(v4, x2));
	incref(x1);
	incref(x1);
	void* v6 = str_base(VSTR(x1));
	uint64_t v7 = str_size(VSTR(x1));
	int64_t v8 = 0LL;
	bool v9 = (((int64_t)v7) < v8);
	int64_t x10;
	if (v9) {
		x10 = v8;
		lpush(&lbl_avoidZ_hexdigit, MKI64(v3));
		push_resource(v5);
		push_ptr(v6);
	} else {
		x10 = ((int64_t)v7);
		lpush(&lbl_avoidZ_hexdigit, MKI64(v3));
		push_resource(v5);
		push_ptr(v6);
	}
	int64_t v11 = 0LL;
	bool v12 = (x10 > v11);
	int64_t v13 = x10;
	bool v14 = v12;
	while (v14) {
		int64_t v15 = v13;
		void* v16 = pop_ptr();
		int64_t v17 = (0LL /* +Unsafe */);
		int64_t v18;
		int64_t v19;
		mw_std_prim_Ptr_ZAtByte(v16, v17, &v18, &v19);
		VAL r20 = pop_resource();
		int64_t v21 = VI64(lpop(&lbl_avoidZ_hexdigit));
		int64_t v22;
		VAL v23;
		mw_mirth_c99_c99Z_stringZ_byteZBang(v18, v21, r20, &v22, &v23);
		int64_t v24 = 1LL;
		int64_t v25 = (0LL /* +Unsafe */);
		void* v26 = (void*)(v24 + (char*)v16);
		int64_t v27 = 1LL;
		int64_t v28 = i64_sub(v15, v27);
		int64_t v29 = 0LL;
		bool v30 = (v28 < v29);
		int64_t x31;
		if (v30) {
			int64_t v32 = 0LL;
			x31 = v32;
			lpush(&lbl_avoidZ_hexdigit, MKI64(v22));
			push_resource(v23);
			push_ptr(v26);
		} else {
			x31 = v28;
			lpush(&lbl_avoidZ_hexdigit, MKI64(v22));
			push_resource(v23);
			push_ptr(v26);
		}
		int64_t v33 = 0LL;
		bool v34 = (x31 > v33);
		v14 = v34;
		v13 = x31;
	}
	void* v35 = pop_ptr();
	decref(x1);
	int64_t v36 = 34LL /* BQUOTE */;
	VAL r37 = pop_resource();
	VAL v38 = (mw_mirth_c99_ZPlusC99_putZ_byte(v36, r37));
	int64_t v39 = VI64(lpop(&lbl_avoidZ_hexdigit));
	return v38;
}
static void mw_mirth_c99_c99Z_stringZ_byteZBang (int64_t x1, int64_t x2, VAL x3, int64_t *x4, VAL *x5) {
	int64_t x6;
	VAL x7;
	switch (x1) {
		case 92LL: { // B'\'
			STR* v8;
			STRLIT(v8, "\\\\", 2);
			VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), x3));
			int64_t v10 = 0LL /* False */;
			x7 = v9;
			x6 = v10;
		} break;
		case 34LL: { // BQUOTE
			STR* v11;
			STRLIT(v11, "\\\"", 2);
			VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), x3));
			int64_t v13 = 0LL /* False */;
			x7 = v12;
			x6 = v13;
		} break;
		case 9LL: { // BHT
			STR* v14;
			STRLIT(v14, "\\t", 2);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), x3));
			int64_t v16 = 0LL /* False */;
			x7 = v15;
			x6 = v16;
		} break;
		case 10LL: { // BLF
			STR* v17;
			STRLIT(v17, "\\n", 2);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), x3));
			int64_t v19 = 0LL /* False */;
			x7 = v18;
			x6 = v19;
		} break;
		case 13LL: { // BCR
			STR* v20;
			STRLIT(v20, "\\r", 2);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), x3));
			int64_t v22 = 0LL /* False */;
			x7 = v21;
			x6 = v22;
		} break;
		default: {
			int64_t v23 = 32LL /* BSPACE */;
			int64_t v24 = 126LL /* B'~' */;
			bool v25 = (x1 >= v23);
			bool v26 = (x1 <= v24);
			bool v27 = (v25 && v26);
			int64_t x28;
			VAL x29;
			int64_t x30;
			int64_t x31;
			if (v27) {
				int64_t v32 = mw_std_byte_Byte_isZ_hexdigit(x1);
				bool v33 = (((bool)v32) && ((bool)x2));
				bool v34 = !v33;
				x31 = ((int64_t)v34);
				x30 = x1;
				x29 = x3;
				x28 = x2;
			} else {
				int64_t v35 = 0LL /* False */;
				x31 = v35;
				x30 = x1;
				x29 = x3;
				x28 = x2;
			}
			VAL x36;
			int64_t x37;
			if (((bool)x31)) {
				VAL v38 = (mw_mirth_c99_ZPlusC99_putZ_byte(x30, x29));
				int64_t v39 = 0LL /* False */;
				x37 = v39;
				x36 = v38;
			} else {
				STR* v40;
				STRLIT(v40, "\\x", 2);
				VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), x29));
				int64_t v42;
				int64_t v43;
				mw_std_byte_Byte_toZ_hexdigits(x30, &v42, &v43);
				VAL v44 = (mw_mirth_c99_ZPlusC99_putZ_byte(v42, v41));
				VAL v45 = (mw_mirth_c99_ZPlusC99_putZ_byte(v43, v44));
				int64_t v46 = 1LL /* True */;
				x37 = v46;
				x36 = v45;
			}
			x7 = x36;
			x6 = x37;
		} break;
	}
	*x5 = x7;
	*x4 = x6;
}
static int64_t mw_mirth_c99_C99ReprType_ZEqualZEqual (int64_t x1, int64_t x2) {
	bool v3 = (x1 == x2);
	return ((int64_t)v3);
}
static int64_t mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 1LL: { // C99RT_STR
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		default: {
			int64_t v5 = 0LL /* False */;
			x2 = v5;
		} break;
	}
	return x2;
}
static int64_t mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 2LL: { // C99RT_I64
			int64_t v3 = 1LL /* True */;
			x2 = v3;
		} break;
		case 3LL: { // C99RT_I32
			int64_t v4 = 1LL /* True */;
			x2 = v4;
		} break;
		case 4LL: { // C99RT_I16
			int64_t v5 = 1LL /* True */;
			x2 = v5;
		} break;
		case 5LL: { // C99RT_I8
			int64_t v6 = 1LL /* True */;
			x2 = v6;
		} break;
		case 6LL: { // C99RT_U64
			int64_t v7 = 1LL /* True */;
			x2 = v7;
		} break;
		case 7LL: { // C99RT_U32
			int64_t v8 = 1LL /* True */;
			x2 = v8;
		} break;
		case 8LL: { // C99RT_U16
			int64_t v9 = 1LL /* True */;
			x2 = v9;
		} break;
		case 9LL: { // C99RT_U8
			int64_t v10 = 1LL /* True */;
			x2 = v10;
		} break;
		case 12LL: { // C99RT_BOOL
			int64_t v11 = 1LL /* True */;
			x2 = v11;
		} break;
		default: {
			int64_t v12 = 0LL /* False */;
			x2 = v12;
		} break;
	}
	return x2;
}
static VAL mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v3;
			STRLIT(v3, "VAL", 3);
			x2 = MKSTR(v3);
		} break;
		case 1LL: { // C99RT_STR
			STR* v4;
			STRLIT(v4, "STR*", 4);
			x2 = MKSTR(v4);
		} break;
		case 2LL: { // C99RT_I64
			STR* v5;
			STRLIT(v5, "int64_t", 7);
			x2 = MKSTR(v5);
		} break;
		case 3LL: { // C99RT_I32
			STR* v6;
			STRLIT(v6, "int32_t", 7);
			x2 = MKSTR(v6);
		} break;
		case 4LL: { // C99RT_I16
			STR* v7;
			STRLIT(v7, "int16_t", 7);
			x2 = MKSTR(v7);
		} break;
		case 5LL: { // C99RT_I8
			STR* v8;
			STRLIT(v8, "int8_t", 6);
			x2 = MKSTR(v8);
		} break;
		case 6LL: { // C99RT_U64
			STR* v9;
			STRLIT(v9, "uint64_t", 8);
			x2 = MKSTR(v9);
		} break;
		case 7LL: { // C99RT_U32
			STR* v10;
			STRLIT(v10, "uint32_t", 8);
			x2 = MKSTR(v10);
		} break;
		case 8LL: { // C99RT_U16
			STR* v11;
			STRLIT(v11, "uint16_t", 8);
			x2 = MKSTR(v11);
		} break;
		case 9LL: { // C99RT_U8
			STR* v12;
			STRLIT(v12, "uint8_t", 7);
			x2 = MKSTR(v12);
		} break;
		case 10LL: { // C99RT_F64
			STR* v13;
			STRLIT(v13, "double", 6);
			x2 = MKSTR(v13);
		} break;
		case 11LL: { // C99RT_F32
			STR* v14;
			STRLIT(v14, "float", 5);
			x2 = MKSTR(v14);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v15;
			STRLIT(v15, "bool", 4);
			x2 = MKSTR(v15);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v16;
			STRLIT(v16, "void*", 5);
			x2 = MKSTR(v16);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v17;
			STRLIT(v17, "FNPTR", 5);
			x2 = MKSTR(v17);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_c99_C99ReprType_vZ_macro (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v3;
			STRLIT(v3, "VVAL", 4);
			x2 = MKSTR(v3);
		} break;
		case 1LL: { // C99RT_STR
			STR* v4;
			STRLIT(v4, "VSTR", 4);
			x2 = MKSTR(v4);
		} break;
		case 2LL: { // C99RT_I64
			STR* v5;
			STRLIT(v5, "VI64", 4);
			x2 = MKSTR(v5);
		} break;
		case 3LL: { // C99RT_I32
			STR* v6;
			STRLIT(v6, "VI32", 4);
			x2 = MKSTR(v6);
		} break;
		case 4LL: { // C99RT_I16
			STR* v7;
			STRLIT(v7, "VI16", 4);
			x2 = MKSTR(v7);
		} break;
		case 5LL: { // C99RT_I8
			STR* v8;
			STRLIT(v8, "VI8", 3);
			x2 = MKSTR(v8);
		} break;
		case 6LL: { // C99RT_U64
			STR* v9;
			STRLIT(v9, "VU64", 4);
			x2 = MKSTR(v9);
		} break;
		case 7LL: { // C99RT_U32
			STR* v10;
			STRLIT(v10, "VU32", 4);
			x2 = MKSTR(v10);
		} break;
		case 8LL: { // C99RT_U16
			STR* v11;
			STRLIT(v11, "VU16", 4);
			x2 = MKSTR(v11);
		} break;
		case 9LL: { // C99RT_U8
			STR* v12;
			STRLIT(v12, "VU8", 3);
			x2 = MKSTR(v12);
		} break;
		case 10LL: { // C99RT_F64
			STR* v13;
			STRLIT(v13, "VF64", 4);
			x2 = MKSTR(v13);
		} break;
		case 11LL: { // C99RT_F32
			STR* v14;
			STRLIT(v14, "VF32", 4);
			x2 = MKSTR(v14);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v15;
			STRLIT(v15, "VBOOL", 5);
			x2 = MKSTR(v15);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v16;
			STRLIT(v16, "VPTR", 4);
			x2 = MKSTR(v16);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v17;
			STRLIT(v17, "VFNPTR", 6);
			x2 = MKSTR(v17);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_c99_C99ReprType_mkZ_macro (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v3;
			STRLIT(v3, "MKVAL", 5);
			x2 = MKSTR(v3);
		} break;
		case 1LL: { // C99RT_STR
			STR* v4;
			STRLIT(v4, "MKSTR", 5);
			x2 = MKSTR(v4);
		} break;
		case 2LL: { // C99RT_I64
			STR* v5;
			STRLIT(v5, "MKI64", 5);
			x2 = MKSTR(v5);
		} break;
		case 3LL: { // C99RT_I32
			STR* v6;
			STRLIT(v6, "MKI32", 5);
			x2 = MKSTR(v6);
		} break;
		case 4LL: { // C99RT_I16
			STR* v7;
			STRLIT(v7, "MKI16", 5);
			x2 = MKSTR(v7);
		} break;
		case 5LL: { // C99RT_I8
			STR* v8;
			STRLIT(v8, "MKI8", 4);
			x2 = MKSTR(v8);
		} break;
		case 6LL: { // C99RT_U64
			STR* v9;
			STRLIT(v9, "MKU64", 5);
			x2 = MKSTR(v9);
		} break;
		case 7LL: { // C99RT_U32
			STR* v10;
			STRLIT(v10, "MKU32", 5);
			x2 = MKSTR(v10);
		} break;
		case 8LL: { // C99RT_U16
			STR* v11;
			STRLIT(v11, "MKU16", 5);
			x2 = MKSTR(v11);
		} break;
		case 9LL: { // C99RT_U8
			STR* v12;
			STRLIT(v12, "MKU8", 4);
			x2 = MKSTR(v12);
		} break;
		case 11LL: { // C99RT_F32
			STR* v13;
			STRLIT(v13, "MKF32", 5);
			x2 = MKSTR(v13);
		} break;
		case 10LL: { // C99RT_F64
			STR* v14;
			STRLIT(v14, "MKF64", 5);
			x2 = MKSTR(v14);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v15;
			STRLIT(v15, "MKBOOL", 6);
			x2 = MKSTR(v15);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v16;
			STRLIT(v16, "MKPTR", 5);
			x2 = MKSTR(v16);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v17;
			STRLIT(v17, "MKFNPTR", 7);
			x2 = MKSTR(v17);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_c99_C99ReprType_popZ_macro (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v3;
			STRLIT(v3, "pop_value", 9);
			x2 = MKSTR(v3);
		} break;
		case 1LL: { // C99RT_STR
			STR* v4;
			STRLIT(v4, "pop_str", 7);
			x2 = MKSTR(v4);
		} break;
		case 2LL: { // C99RT_I64
			STR* v5;
			STRLIT(v5, "pop_i64", 7);
			x2 = MKSTR(v5);
		} break;
		case 3LL: { // C99RT_I32
			STR* v6;
			STRLIT(v6, "pop_i32", 7);
			x2 = MKSTR(v6);
		} break;
		case 4LL: { // C99RT_I16
			STR* v7;
			STRLIT(v7, "pop_i16", 7);
			x2 = MKSTR(v7);
		} break;
		case 5LL: { // C99RT_I8
			STR* v8;
			STRLIT(v8, "pop_i8", 6);
			x2 = MKSTR(v8);
		} break;
		case 6LL: { // C99RT_U64
			STR* v9;
			STRLIT(v9, "pop_u64", 7);
			x2 = MKSTR(v9);
		} break;
		case 7LL: { // C99RT_U32
			STR* v10;
			STRLIT(v10, "pop_u32", 7);
			x2 = MKSTR(v10);
		} break;
		case 8LL: { // C99RT_U16
			STR* v11;
			STRLIT(v11, "pop_u16", 7);
			x2 = MKSTR(v11);
		} break;
		case 9LL: { // C99RT_U8
			STR* v12;
			STRLIT(v12, "pop_u8", 6);
			x2 = MKSTR(v12);
		} break;
		case 10LL: { // C99RT_F64
			STR* v13;
			STRLIT(v13, "pop_f64", 7);
			x2 = MKSTR(v13);
		} break;
		case 11LL: { // C99RT_F32
			STR* v14;
			STRLIT(v14, "pop_f32", 7);
			x2 = MKSTR(v14);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v15;
			STRLIT(v15, "pop_bool", 8);
			x2 = MKSTR(v15);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v16;
			STRLIT(v16, "pop_ptr", 7);
			x2 = MKSTR(v16);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v17;
			STRLIT(v17, "pop_fnptr", 9);
			x2 = MKSTR(v17);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static VAL mw_mirth_c99_C99ReprType_pushZ_macro (int64_t x1) {
	VAL x2;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v3;
			STRLIT(v3, "push_value", 10);
			x2 = MKSTR(v3);
		} break;
		case 1LL: { // C99RT_STR
			STR* v4;
			STRLIT(v4, "push_str", 8);
			x2 = MKSTR(v4);
		} break;
		case 2LL: { // C99RT_I64
			STR* v5;
			STRLIT(v5, "push_i64", 8);
			x2 = MKSTR(v5);
		} break;
		case 3LL: { // C99RT_I32
			STR* v6;
			STRLIT(v6, "push_i32", 8);
			x2 = MKSTR(v6);
		} break;
		case 4LL: { // C99RT_I16
			STR* v7;
			STRLIT(v7, "push_i16", 8);
			x2 = MKSTR(v7);
		} break;
		case 5LL: { // C99RT_I8
			STR* v8;
			STRLIT(v8, "push_i8", 7);
			x2 = MKSTR(v8);
		} break;
		case 6LL: { // C99RT_U64
			STR* v9;
			STRLIT(v9, "push_u64", 8);
			x2 = MKSTR(v9);
		} break;
		case 7LL: { // C99RT_U32
			STR* v10;
			STRLIT(v10, "push_u32", 8);
			x2 = MKSTR(v10);
		} break;
		case 8LL: { // C99RT_U16
			STR* v11;
			STRLIT(v11, "push_u16", 8);
			x2 = MKSTR(v11);
		} break;
		case 9LL: { // C99RT_U8
			STR* v12;
			STRLIT(v12, "push_u8", 7);
			x2 = MKSTR(v12);
		} break;
		case 10LL: { // C99RT_F64
			STR* v13;
			STRLIT(v13, "push_f64", 8);
			x2 = MKSTR(v13);
		} break;
		case 11LL: { // C99RT_F32
			STR* v14;
			STRLIT(v14, "push_f32", 8);
			x2 = MKSTR(v14);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v15;
			STRLIT(v15, "push_bool", 9);
			x2 = MKSTR(v15);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v16;
			STRLIT(v16, "push_ptr", 8);
			x2 = MKSTR(v16);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v17;
			STRLIT(v17, "push_fnptr", 10);
			x2 = MKSTR(v17);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_type_Resource_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = mw_mirth_type_Resource_ZToType(x1);
	int64_t v6;
	VAL v7;
	mw_mirth_type_Type_c99Z_repr(v5, x2, &v6, &v7);
	*x4 = v7;
	*x3 = v6;
}
static void mw_mirth_type_Type_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4) {
	int64_t x5;
	VAL x6;
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			int64_t v7 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v7;
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v8 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v8;
		} break;
		case 2LL: { // TPrim
			int64_t v9 = mtp_mirth_type_Type_TPrim(x1);
			int64_t v10 = mw_mirth_type_PrimType_c99Z_repr(v9);
			x6 = x2;
			x5 = v10;
		} break;
		case 3LL: { // TMeta
			uint64_t v11 = mtp_mirth_type_Type_TMeta(x1);
			VAL v12 = mw_mirth_type_MetaVar_typeZAsk(v11);
			int64_t x13;
			VAL x14;
			switch (get_data_tag(v12)) {
				case 0LL: { // None
					int64_t v15 = 0LL /* C99RT_VAL */;
					x14 = x2;
					x13 = v15;
				} break;
				case 1LL: { // Some
					VAL v16 = mtp_std_maybe_Maybe_1_Some(v12);
					VAL v17 = mw_mirth_type_Type_expand(v16);
					incref(v17);
					VAL v18 = mtw_std_maybe_Maybe_1_Some(v17);
					void* v19 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v11);
					mut_set(v18, v19);
					int64_t v20;
					VAL v21;
					mw_mirth_type_Type_c99Z_repr(v17, x2, &v20, &v21);
					x14 = v21;
					x13 = v20;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x6 = x14;
			x5 = x13;
		} break;
		case 4LL: { // THole
			uint64_t v22 = mtp_mirth_type_Type_THole(x1);
			int64_t v23 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v23;
		} break;
		case 5LL: { // TVar
			uint64_t v24 = mtp_mirth_type_Type_TVar(x1);
			int64_t v25 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v25;
		} break;
		case 6LL: { // TTable
			uint64_t v26 = mtp_mirth_type_Type_TTable(x1);
			int64_t v27 = 6LL /* C99RT_U64 */;
			x6 = x2;
			x5 = v27;
		} break;
		case 7LL: { // TData
			uint64_t v28 = mtp_mirth_type_Type_TData(x1);
			int64_t v29;
			VAL v30;
			mw_mirth_data_Data_c99Z_repr(v28, x2, &v29, &v30);
			x6 = v30;
			x5 = v29;
		} break;
		case 8LL: { // TDataPartial
			VAL v31 = mtp_mirth_type_Type_TDataPartial(x1);
			uint64_t v32 = VU64(VTUP(v31)->cells[1]);
			decref(v31);
			int64_t v33;
			VAL v34;
			mw_mirth_data_Data_c99Z_repr(v32, x2, &v33, &v34);
			x6 = v34;
			x5 = v33;
		} break;
		case 10LL: { // TMorphism
			VAL v35 = mtp_mirth_type_Type_TMorphism(x1);
			decref(v35);
			int64_t v36 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v36;
		} break;
		case 9LL: { // TTensor
			VAL v37 = mtp_mirth_type_Type_TTensor(x1);
			decref(v37);
			int64_t v38 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v38;
		} break;
		case 11LL: { // TApp
			VAL v39;
			VAL v40;
			mtp_mirth_type_Type_TApp(x1, &v39, &v40);
			decref(v40);
			int64_t v41;
			VAL v42;
			mw_mirth_type_Type_c99Z_repr(v39, x2, &v41, &v42);
			x6 = v42;
			x5 = v41;
		} break;
		case 12LL: { // TMut
			VAL v43 = mtp_mirth_type_Type_TMut(x1);
			decref(v43);
			int64_t v44 = 13LL /* C99RT_PTR */;
			x6 = x2;
			x5 = v44;
		} break;
		case 13LL: { // TValue
			VAL v45 = mtp_mirth_type_Type_TValue(x1);
			decref(v45);
			int64_t v46 = 0LL /* C99RT_VAL */;
			x6 = x2;
			x5 = v46;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x6;
	*x3 = x5;
}
static int64_t mw_mirth_type_PrimType_c99Z_repr (int64_t x1) {
	int64_t x2;
	switch (x1) {
		case 0LL: { // PRIM_TYPE_TYPE
			int64_t v3 = 0LL /* C99RT_VAL */;
			x2 = v3;
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			int64_t v4 = 0LL /* C99RT_VAL */;
			x2 = v4;
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			int64_t v5 = 0LL /* C99RT_VAL */;
			x2 = v5;
		} break;
		case 3LL: { // PRIM_TYPE_INT
			int64_t v6 = 2LL /* C99RT_I64 */;
			x2 = v6;
		} break;
		case 4LL: { // PRIM_TYPE_F32
			int64_t v7 = 11LL /* C99RT_F32 */;
			x2 = v7;
		} break;
		case 5LL: { // PRIM_TYPE_F64
			int64_t v8 = 10LL /* C99RT_F64 */;
			x2 = v8;
		} break;
		case 7LL: { // PRIM_TYPE_STR
			int64_t v9 = 0LL /* C99RT_VAL */;
			x2 = v9;
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			int64_t v10 = 13LL /* C99RT_PTR */;
			x2 = v10;
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			int64_t v11 = 2LL /* C99RT_I64 */;
			x2 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_data_Data_c99Z_repr (uint64_t x1, VAL x2, int64_t *x3, VAL *x4) {
	int64_t v5 = mw_mirth_data_Data_isZ_enumZ_orZ_unitZAsk(x1);
	VAL x6;
	int64_t x7;
	if (((bool)v5)) {
		int64_t v8 = 2LL /* C99RT_I64 */;
		x7 = v8;
		x6 = x2;
	} else {
		VAL v9;
		VAL v10;
		mw_mirth_data_Data_semiZ_transparentZAsk(x2, x1, &v9, &v10);
		int64_t x11;
		VAL x12;
		switch (get_data_tag(v10)) {
			case 1LL: { // Some
				VAL v13 = mtp_std_maybe_Maybe_1_Some(v10);
				VAL v14 = VVAL(VTUP(v13)->cells[2]);
				incref(v14);
				decref(v13);
				VAL v15 = mw_mirth_type_StackTypePart_typeZDivresource(v14);
				int64_t x16;
				VAL x17;
				switch (get_data_tag(v15)) {
					case 0LL: { // Left
						VAL v18 = mtp_std_either_Either_2_Left(v15);
						int64_t v19;
						VAL v20;
						mw_mirth_type_Type_c99Z_repr(v18, v9, &v19, &v20);
						x17 = v20;
						x16 = v19;
					} break;
					case 1LL: { // Right
						VAL v21 = mtp_std_either_Either_2_Right(v15);
						int64_t v22;
						VAL v23;
						mw_mirth_type_Resource_c99Z_repr(v21, v9, &v22, &v23);
						x17 = v23;
						x16 = v22;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x12 = x17;
				x11 = x16;
			} break;
			case 0LL: { // None
				int64_t v24 = 0LL /* C99RT_VAL */;
				x12 = v9;
				x11 = v24;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x7 = x11;
		x6 = x12;
	}
	*x4 = x6;
	*x3 = x7;
}
static void mw_mirth_c99_ZPlusC99Local_rdup (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4 = VI64(VTUP(x1)->cells[1]);
	VAL v5 = VVAL(VTUP(x1)->cells[2]);
	incref(v5);
	VAL v6 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v4, v5));
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_c99_ZPlusC99Local_rdrop (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, &v2, &v3);
	decref(v3);
}
static void mw_mirth_c99_C99ReprType_newZ_localZBang (int64_t x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5 = (VVAL(VTUP(x2)->cells[1]));
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v5, &v6, &v7);
	VTUP(x2)->cells[1] = v7;
	VAL v8 = (VVAL(VTUP(x2)->cells[1]));
	VAL v9 = (mw_mirth_c99_ZPlusC99_indent(v8));
	VAL v10 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(x1);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v9));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	incref(v6);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v6, v13));
	STR* v15;
	STRLIT(v15, ";", 1);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL v17 = (mw_mirth_c99_ZPlusC99_line(v16));
	VTUP(x2)->cells[1] = v17;
	VAL v18 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, v6));
	*x4 = v18;
	*x3 = x2;
}
static void mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang (int64_t x1, VAL x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(x2, &v5, &v6);
	VAL v7 = (mw_mirth_c99_ZPlusC99_indent(v6));
	VAL v8 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(x1);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
	STR* v10;
	STRLIT(v10, " ", 1);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	incref(v5);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v5, v11));
	STR* v13;
	STRLIT(v13, " = ", 3);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = mw_mirth_c99_C99ReprType_popZ_macro(x1);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v14));
	STR* v17;
	STRLIT(v17, "();", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL v19 = (mw_mirth_c99_ZPlusC99_line(v18));
	VAL v20 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, v5));
	*x4 = v20;
	*x3 = v19;
}
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang (VAL x1, VAL x2) {
	int64_t v3;
	VAL v4;
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x2, &v3, &v4);
	VAL v5 = (mw_mirth_c99_ZPlusC99_indent(x1));
	VAL v6 = mw_mirth_c99_C99ReprType_pushZ_macro(v3);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(v6, v5));
	STR* v8;
	STRLIT(v8, "(", 1);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v4, v9));
	STR* v11;
	STRLIT(v11, ");", 2);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	VAL v13 = (mw_mirth_c99_ZPlusC99_line(v12));
	return v13;
}
static VAL mw_mirth_c99_ZPlusC99Local_consume (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, &v2, &v3);
	return v3;
}
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, &v2, &v3);
	VAL x4;
	switch (v2) {
		case 0LL: { // C99RT_VAL
			x4 = v3;
		} break;
		default: {
			STR* v5;
			STRLIT(v5, "", 0);
			VAL v6 = mw_mirth_c99_C99ReprType_mkZ_macro(v2);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, MKSTR(v5)));
			STR* v8;
			STRLIT(v8, "(", 1);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(v3, v9));
			STR* v11;
			STRLIT(v11, ")", 1);
			VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
			x4 = v12;
		} break;
	}
	return x4;
}
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_as (int64_t x1, VAL x2) {
	VAL x3;
	switch (x1) {
		case 0LL: { // C99RT_VAL
			VAL v4 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(x2);
			x3 = v4;
		} break;
		default: {
			int64_t v5;
			VAL v6;
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x2, &v5, &v6);
			int64_t x7;
			VAL x8;
			switch (v5) {
				case 0LL: { // C99RT_VAL
					STR* v9;
					STRLIT(v9, "", 0);
					VAL v10 = mw_mirth_c99_C99ReprType_vZ_macro(x1);
					VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, MKSTR(v9)));
					STR* v12;
					STRLIT(v12, "(", 1);
					VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
					VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, v13));
					STR* v15;
					STRLIT(v15, ")", 1);
					VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v15), v14));
					x8 = v16;
					x7 = v5;
				} break;
				default: {
					int64_t v17 = mw_mirth_c99_C99ReprType_ZEqualZEqual(v5, x1);
					int64_t x18;
					VAL x19;
					if (((bool)v17)) {
						x19 = v6;
						x18 = v5;
					} else {
						int64_t v20 = mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk(x1);
						int64_t v21 = mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk(v5);
						bool v22 = (((bool)v20) && ((bool)v21));
						int64_t x23;
						VAL x24;
						if (v22) {
							STR* v25;
							STRLIT(v25, "", 0);
							STR* v26;
							STRLIT(v26, "((", 2);
							VAL v27 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v26), MKSTR(v25)));
							VAL v28 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(x1);
							VAL v29 = (mw_std_str_ZPlusStr_pushZ_strZBang(v28, v27));
							STR* v30;
							STRLIT(v30, ")", 1);
							VAL v31 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v30), v29));
							VAL v32 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, v31));
							STR* v33;
							STRLIT(v33, ")", 1);
							VAL v34 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v33), v32));
							x24 = v34;
							x23 = v5;
						} else {
							STR* v35;
							STRLIT(v35, "", 0);
							STR* v36;
							STRLIT(v36, "(\n#error \"attempted to cast ", 28);
							VAL v37 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v36), MKSTR(v35)));
							VAL v38 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, v37));
							STR* v39;
							STRLIT(v39, " to incompatible C99 repr type ", 31);
							VAL v40 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v39), v38));
							VAL v41 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(x1);
							VAL v42 = (mw_std_str_ZPlusStr_pushZ_strZBang(v41, v40));
							STR* v43;
							STRLIT(v43, "\"\n", 2);
							VAL v44 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v43), v42));
							x24 = v44;
							x23 = v5;
						}
						x19 = x24;
						x18 = x23;
					}
					x8 = x19;
					x7 = x18;
				} break;
			}
			x3 = x8;
		} break;
	}
	return x3;
}
static VAL mw_mirth_c99_ZPlusC99Local_dropZ_localZBang (VAL x1, VAL x2) {
	int64_t v3 = VI64(VTUP(x2)->cells[1]);
	int64_t v4 = mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk(v3);
	VAL x5;
	if (((bool)v4)) {
		VAL v6 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(x2);
		VAL v7 = (VVAL(VTUP(x1)->cells[1]));
		VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v7));
		STR* v9;
		STRLIT(v9, "decref(", 7);
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
		VAL v11 = (mw_mirth_c99_ZPlusC99_put(v6, v10));
		STR* v12;
		STRLIT(v12, ");", 2);
		VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
		VAL v14 = (mw_mirth_c99_ZPlusC99_line(v13));
		VTUP(x1)->cells[1] = v14;
		x5 = x1;
	} else {
		mw_mirth_c99_ZPlusC99Local_rdrop(x2);
		x5 = x1;
	}
	return x5;
}
static void mw_mirth_c99_ZPlusC99Local_dupZ_localZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	int64_t v6 = VI64(VTUP(x2)->cells[1]);
	int64_t v7 = mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk(v6);
	VAL x8;
	VAL x9;
	if (((bool)v7)) {
		VAL v10;
		VAL v11;
		mw_mirth_c99_ZPlusC99Local_rdup(x2, &v10, &v11);
		VAL v12 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v11);
		VAL v13 = (VVAL(VTUP(x1)->cells[1]));
		VAL v14 = (mw_mirth_c99_ZPlusC99_indent(v13));
		STR* v15;
		STRLIT(v15, "incref(", 7);
		VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
		VAL v17 = (mw_mirth_c99_ZPlusC99_put(v12, v16));
		STR* v18;
		STRLIT(v18, ");", 2);
		VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
		VAL v20 = (mw_mirth_c99_ZPlusC99_line(v19));
		VTUP(x1)->cells[1] = v20;
		x9 = v10;
		x8 = x1;
	} else {
		x9 = x2;
		x8 = x1;
	}
	VAL v21;
	VAL v22;
	mw_mirth_c99_ZPlusC99Local_rdup(x9, &v21, &v22);
	*x5 = v22;
	*x4 = v21;
	*x3 = x8;
}
static void mw_mirth_c99_ZPlusC99Local_peekZ_dataZ_tag (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4 = VI64(VTUP(x1)->cells[1]);
	VAL x5;
	VAL x6;
	switch (v4) {
		case 0LL: { // C99RT_VAL
			VAL v7 = VVAL(VTUP(x1)->cells[2]);
			incref(v7);
			STR* v8;
			STRLIT(v8, "", 0);
			STR* v9;
			STRLIT(v9, "get_data_tag(", 13);
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), MKSTR(v8)));
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v7, v10));
			STR* v12;
			STRLIT(v12, ")", 1);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
			x6 = v13;
			x5 = x1;
		} break;
		default: {
			VAL v14 = VVAL(VTUP(x1)->cells[2]);
			incref(v14);
			x6 = v14;
			x5 = x1;
		} break;
	}
	*x3 = x6;
	*x2 = x5;
}
static void mw_mirth_c99_ZPlusC99LocalResource_rdup (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4 = VI64(VTUP(x1)->cells[1]);
	VAL v5 = VVAL(VTUP(x1)->cells[2]);
	incref(v5);
	VAL v6 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v4, v5));
	*x3 = v6;
	*x2 = x1;
}
static void mw_mirth_c99_ZPlusC99LocalResource_rdrop (VAL x1) {
	VAL v2 = mw_mirth_c99_ZPlusC99LocalResource_consume(x1);
	decref(v2);
}
static VAL mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1, &v2, &v3);
	VAL v4 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v2, v3));
	return v4;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1, &v2, &v3);
	VAL v4 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v2, v3));
	return v4;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_dropZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(x2));
	VAL v4 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(x1, v3));
	return v4;
}
static void mw_mirth_c99_ZPlusC99LocalResource_dupZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99LocalResource_rdup(x2, &v6, &v7);
	VAL v8 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v7));
	VAL v9;
	VAL v10;
	VAL v11;
	mw_mirth_c99_ZPlusC99Local_dupZ_localZBang(x1, v8, &v9, &v10, &v11);
	mw_mirth_c99_ZPlusC99Local_rdrop(v11);
	*x5 = v10;
	*x4 = v6;
	*x3 = v9;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_consume (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1, &v2, &v3);
	return v3;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL (VAL x1) {
	int64_t v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1, &v2, &v3);
	VAL x4;
	switch (v2) {
		case 0LL: { // C99RT_VAL
			x4 = v3;
		} break;
		default: {
			STR* v5;
			STRLIT(v5, "", 0);
			VAL v6 = mw_mirth_c99_C99ReprType_mkZ_macro(v2);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, MKSTR(v5)));
			STR* v8;
			STRLIT(v8, "(", 1);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(v3, v9));
			STR* v11;
			STRLIT(v11, ")", 1);
			VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
			x4 = v12;
		} break;
	}
	return x4;
}
static void mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang (VAL x1, int64_t x2, VAL *x3, VAL *x4) {
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang(x1, &v5, &v6);
	VAL v7 = (mw_mirth_c99_ZPlusC99_indent(v6));
	VAL v8 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(x2);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
	STR* v10;
	STRLIT(v10, " ", 1);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	incref(v5);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v5, v11));
	STR* v13;
	STRLIT(v13, " = ", 3);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL x15;
	int64_t x16;
	VAL x17;
	switch (x2) {
		case 0LL: { // C99RT_VAL
			STR* v18;
			STRLIT(v18, "pop_resource()", 14);
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v14));
			x17 = v19;
			x16 = x2;
			x15 = v5;
		} break;
		default: {
			VAL v20 = mw_mirth_c99_C99ReprType_vZ_macro(x2);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v14));
			STR* v22;
			STRLIT(v22, "(pop_resource())", 16);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			x17 = v23;
			x16 = x2;
			x15 = v5;
		} break;
	}
	STR* v24;
	STRLIT(v24, ";", 1);
	VAL v25 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v24), x17));
	VAL v26 = (mw_mirth_c99_ZPlusC99_line(v25));
	VAL v27 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x16, x15));
	*x4 = v27;
	*x3 = v26;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang (VAL x1, VAL x2) {
	int64_t v3;
	VAL v4;
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x2, &v3, &v4);
	VAL v5 = (mw_mirth_c99_ZPlusC99_indent(x1));
	STR* v6;
	STRLIT(v6, "push_resource(", 14);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL x8;
	switch (v3) {
		case 0LL: { // C99RT_VAL
			VAL v9 = (mw_mirth_c99_ZPlusC99_put(v4, v7));
			x8 = v9;
		} break;
		default: {
			VAL v10 = mw_mirth_c99_C99ReprType_mkZ_macro(v3);
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v7));
			STR* v12;
			STRLIT(v12, "(", 1);
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
			VAL v14 = (mw_mirth_c99_ZPlusC99_put(v4, v13));
			STR* v15;
			STRLIT(v15, ")", 1);
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
			x8 = v16;
		} break;
	}
	STR* v17;
	STRLIT(v17, ");", 2);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), x8));
	VAL v19 = (mw_mirth_c99_ZPlusC99_line(v18));
	return v19;
}
static void mw_mirth_c99_ZPlusC99LocalResource_peekZ_dataZ_tag (VAL x1, VAL *x2, VAL *x3) {
	int64_t v4 = VI64(VTUP(x1)->cells[1]);
	VAL x5;
	VAL x6;
	switch (v4) {
		case 0LL: { // C99RT_VAL
			VAL v7 = VVAL(VTUP(x1)->cells[2]);
			incref(v7);
			STR* v8;
			STRLIT(v8, "", 0);
			STR* v9;
			STRLIT(v9, "get_data_tag(", 13);
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), MKSTR(v8)));
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v7, v10));
			STR* v12;
			STRLIT(v12, ")", 1);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), v11));
			x6 = v13;
			x5 = x1;
		} break;
		default: {
			VAL v14 = VVAL(VTUP(x1)->cells[2]);
			incref(v14);
			x6 = v14;
			x5 = x1;
		} break;
	}
	*x3 = x6;
	*x2 = x5;
}
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // +Left
			VAL v4 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x2));
			VAL v5 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x1, v4));
			x3 = v5;
		} break;
		case 1LL: { // +Right
			VAL v6 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x2));
			VAL v7 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(x1, v6));
			x3 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_peekZ_dataZ_tag (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v6 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			VAL v7;
			VAL v8;
			mw_mirth_c99_ZPlusC99Local_peekZ_dataZ_tag(v6, &v7, &v8);
			VAL v9 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v7));
			x5 = v8;
			x4 = v9;
		} break;
		case 1LL: { // +Right
			VAL v10 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			VAL v11;
			VAL v12;
			mw_mirth_c99_ZPlusC99LocalResource_peekZ_dataZ_tag(v10, &v11, &v12);
			VAL v13 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v11));
			x5 = v12;
			x4 = v13;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v6 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			VAL v7;
			VAL v8;
			mw_mirth_c99_ZPlusC99Local_rdup(v6, &v7, &v8);
			VAL v9 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v8));
			VAL v10 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v7));
			x5 = v9;
			x4 = v10;
		} break;
		case 1LL: { // +Right
			VAL v11 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			VAL v12;
			VAL v13;
			mw_mirth_c99_ZPlusC99LocalResource_rdup(v11, &v12, &v13);
			VAL v14 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v13));
			VAL v15 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v12));
			x5 = v14;
			x4 = v15;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v2 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			mw_mirth_c99_ZPlusC99Local_rdrop(v2);
		} break;
		case 1LL: { // +Right
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			mw_mirth_c99_ZPlusC99LocalResource_rdrop(v3);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL (VAL x1) {
	VAL x2;
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			VAL v4 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v3);
			x2 = v4;
		} break;
		case 1LL: { // +Right
			VAL v5 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			VAL v6 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v5);
			x2 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x2;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	int64_t v5 = mw_mirth_data_Data_isZ_resourceZAsk(x1);
	VAL x6;
	VAL x7;
	if (((bool)v5)) {
		VAL v8 = (VVAL(VTUP(x2)->cells[1]));
		VAL v9 = (VVAL(VTUP(v8)->cells[6]));
		int64_t v10;
		VAL v11;
		mw_mirth_data_Data_c99Z_repr(x1, v9, &v10, &v11);
		VTUP(v8)->cells[6] = v11;
		VTUP(x2)->cells[1] = v8;
		VAL v12;
		VAL v13;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(x2, v10, &v12, &v13);
		VAL v14 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v13));
		x7 = v14;
		x6 = v12;
	} else {
		VAL v15 = (VVAL(VTUP(x2)->cells[1]));
		VAL v16 = (VVAL(VTUP(v15)->cells[6]));
		int64_t v17;
		VAL v18;
		mw_mirth_data_Data_c99Z_repr(x1, v16, &v17, &v18);
		VTUP(v15)->cells[6] = v18;
		VTUP(x2)->cells[1] = v15;
		VAL v19;
		VAL v20;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v17, &v19, &v20);
		VAL v21 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v20));
		x7 = v21;
		x6 = v19;
	}
	*x4 = x7;
	*x3 = x6;
}
static VAL mw_mirth_c99_ZPlusC99Branch_refreshZ_branchZBang (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(x1, &v2, &v3);
	VAL v4 = (mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang(v2, v3));
	return v4;
}
static VAL mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			VAL v4 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(x1));
			x3 = v4;
		} break;
		case 1LL: { // +SCCons
			VAL v5;
			VAL v6;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2, &v5, &v6);
			VAL v7 = (mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang(x1, v5));
			int64_t v8 = VI64(VTUP(v6)->cells[1]);
			VAL v9 = (VVAL(VTUP(v7)->cells[1]));
			VAL v10;
			VAL v11;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v9, &v10, &v11);
			VAL v12 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v8, v10));
			VAL v13 = (mw_mirth_c99_ZPlusC99_indent(v11));
			int64_t v14 = VI64(VTUP(v12)->cells[1]);
			VAL v15 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v14);
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v13));
			STR* v17;
			STRLIT(v17, " ", 1);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
			VAL v19 = VVAL(VTUP(v12)->cells[2]);
			incref(v19);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(v19, v18));
			STR* v21;
			STRLIT(v21, " = ", 3);
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
			VAL v23 = mw_mirth_c99_ZPlusC99Local_consume(v6);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v22));
			STR* v25;
			STRLIT(v25, ";", 1);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
			VTUP(v7)->cells[1] = v27;
			VAL v28 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v7, v12));
			x3 = v28;
		} break;
		case 2LL: { // +SCWith
			VAL v29;
			VAL v30;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2, &v29, &v30);
			VAL v31 = (mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang(x1, v29));
			int64_t v32 = VI64(VTUP(v30)->cells[1]);
			VAL v33 = (VVAL(VTUP(v31)->cells[1]));
			VAL v34;
			VAL v35;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v33, &v34, &v35);
			VAL v36 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v32, v34));
			VAL v37 = (mw_mirth_c99_ZPlusC99_indent(v35));
			int64_t v38 = VI64(VTUP(v36)->cells[1]);
			VAL v39 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v38);
			VAL v40 = (mw_mirth_c99_ZPlusC99_put(v39, v37));
			STR* v41;
			STRLIT(v41, " ", 1);
			VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), v40));
			VAL v43 = VVAL(VTUP(v36)->cells[2]);
			incref(v43);
			VAL v44 = (mw_mirth_c99_ZPlusC99_put(v43, v42));
			STR* v45;
			STRLIT(v45, " = (", 4);
			VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v44));
			VAL v47 = mw_mirth_c99_ZPlusC99LocalResource_consume(v30);
			VAL v48 = (mw_mirth_c99_ZPlusC99_put(v47, v46));
			STR* v49;
			STRLIT(v49, ");", 2);
			VAL v50 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v49), v48));
			VAL v51 = (mw_mirth_c99_ZPlusC99_line(v50));
			VTUP(v31)->cells[1] = v51;
			VAL v52 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v31, v36));
			x3 = v52;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v53;
			VAL v54;
			uint64_t v55;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2, &v53, &v54, &v55);
			VAL v56 = (mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang(x1, v53));
			int64_t v57 = VI64(VTUP(v54)->cells[1]);
			VAL v58 = (VVAL(VTUP(v56)->cells[1]));
			VAL v59;
			VAL v60;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v58, &v59, &v60);
			VAL v61 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v57, v59));
			VAL v62 = (mw_mirth_c99_ZPlusC99_indent(v60));
			int64_t v63 = VI64(VTUP(v61)->cells[1]);
			VAL v64 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v63);
			VAL v65 = (mw_mirth_c99_ZPlusC99_put(v64, v62));
			STR* v66;
			STRLIT(v66, " ", 1);
			VAL v67 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v66), v65));
			VAL v68 = VVAL(VTUP(v61)->cells[2]);
			incref(v68);
			VAL v69 = (mw_mirth_c99_ZPlusC99_put(v68, v67));
			STR* v70;
			STRLIT(v70, " = ", 3);
			VAL v71 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v70), v69));
			VAL v72 = mw_mirth_c99_ZPlusC99Local_consume(v54);
			VAL v73 = (mw_mirth_c99_ZPlusC99_put(v72, v71));
			STR* v74;
			STRLIT(v74, ";", 1);
			VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v73));
			VAL v76 = (mw_mirth_c99_ZPlusC99_line(v75));
			VTUP(v56)->cells[1] = v76;
			int64_t v77 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v55);
			VAL x78;
			if (((bool)v77)) {
				VAL v79 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v61));
				VAL v80 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v55, v56, v79));
				x78 = v80;
			} else {
				VAL v81 = (mw_mirth_c99_pushZ_localZ_labelZBang(v55, v56, v61));
				x78 = v81;
			}
			x3 = x78;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v82;
			VAL v83;
			uint64_t v84;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2, &v82, &v83, &v84);
			VAL v85 = (mw_mirth_c99_ZPlusC99StackCache_refreshZ_allZBang(x1, v82));
			int64_t v86 = VI64(VTUP(v83)->cells[1]);
			VAL v87 = (VVAL(VTUP(v85)->cells[1]));
			VAL v88;
			VAL v89;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v87, &v88, &v89);
			VAL v90 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v86, v88));
			VAL v91 = (mw_mirth_c99_ZPlusC99_indent(v89));
			int64_t v92 = VI64(VTUP(v90)->cells[1]);
			VAL v93 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v92);
			VAL v94 = (mw_mirth_c99_ZPlusC99_put(v93, v91));
			STR* v95;
			STRLIT(v95, " ", 1);
			VAL v96 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v95), v94));
			VAL v97 = VVAL(VTUP(v90)->cells[2]);
			incref(v97);
			VAL v98 = (mw_mirth_c99_ZPlusC99_put(v97, v96));
			STR* v99;
			STRLIT(v99, " = ", 3);
			VAL v100 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v99), v98));
			VAL v101 = mw_mirth_c99_ZPlusC99LocalResource_consume(v83);
			VAL v102 = (mw_mirth_c99_ZPlusC99_put(v101, v100));
			STR* v103;
			STRLIT(v103, ";", 1);
			VAL v104 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v103), v102));
			VAL v105 = (mw_mirth_c99_ZPlusC99_line(v104));
			VTUP(v85)->cells[1] = v105;
			int64_t v106 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v84);
			VAL x107;
			if (((bool)v106)) {
				VAL v108 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v90));
				VAL v109 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v84, v85, v108));
				x107 = v109;
			} else {
				VAL v110 = (mw_mirth_c99_pushZ_localZ_labelZBang(v84, v85, v90));
				x107 = v110;
			}
			x3 = x107;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static VAL mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			VAL v4 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(x1));
			x3 = v4;
		} break;
		case 1LL: { // +SCCons
			VAL v5;
			VAL v6;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2, &v5, &v6);
			int64_t v7 = VI64(VTUP(v6)->cells[1]);
			VAL v8;
			VAL v9;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x1, v7, &v8, &v9);
			VAL v10 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v7, v9);
			VAL v11 = VVAL(VTUP(v6)->cells[2]);
			incref(v11);
			VAL v12 = (VVAL(VTUP(v8)->cells[1]));
			VAL v13 = (mw_mirth_c99_ZPlusC99_indent(v12));
			VAL v14 = (mw_mirth_c99_ZPlusC99_put(v11, v13));
			STR* v15;
			STRLIT(v15, " = ", 3);
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
			VAL v17 = (mw_mirth_c99_ZPlusC99_put(v10, v16));
			STR* v18;
			STRLIT(v18, ";", 1);
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
			VAL v20 = (mw_mirth_c99_ZPlusC99_line(v19));
			VTUP(v8)->cells[1] = v20;
			VAL v21 = (mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang(v8, v5));
			VAL v22 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v21, v6));
			x3 = v22;
		} break;
		case 2LL: { // +SCWith
			VAL v23;
			VAL v24;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2, &v23, &v24);
			int64_t v25 = VI64(VTUP(v24)->cells[1]);
			VAL v26;
			VAL v27;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(x1, v25, &v26, &v27);
			VAL v28 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v27));
			VAL v29 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v25, v28);
			VAL v30 = VVAL(VTUP(v24)->cells[2]);
			incref(v30);
			VAL v31 = (VVAL(VTUP(v26)->cells[1]));
			VAL v32 = (mw_mirth_c99_ZPlusC99_indent(v31));
			VAL v33 = (mw_mirth_c99_ZPlusC99_put(v30, v32));
			STR* v34;
			STRLIT(v34, " = ", 3);
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v34), v33));
			VAL v36 = (mw_mirth_c99_ZPlusC99_put(v29, v35));
			STR* v37;
			STRLIT(v37, ";", 1);
			VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), v36));
			VAL v39 = (mw_mirth_c99_ZPlusC99_line(v38));
			VTUP(v26)->cells[1] = v39;
			VAL v40 = (mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang(v26, v23));
			VAL v41 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v40, v24));
			x3 = v41;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v42;
			VAL v43;
			uint64_t v44;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2, &v42, &v43, &v44);
			int64_t v45 = VI64(VTUP(v43)->cells[1]);
			VAL v46;
			VAL v47;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v45, v44, x1, &v46, &v47);
			VAL v48 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v45, v47);
			VAL v49 = VVAL(VTUP(v43)->cells[2]);
			incref(v49);
			VAL v50 = (VVAL(VTUP(v46)->cells[1]));
			VAL v51 = (mw_mirth_c99_ZPlusC99_indent(v50));
			VAL v52 = (mw_mirth_c99_ZPlusC99_put(v49, v51));
			STR* v53;
			STRLIT(v53, " = ", 3);
			VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v53), v52));
			VAL v55 = (mw_mirth_c99_ZPlusC99_put(v48, v54));
			STR* v56;
			STRLIT(v56, ";", 1);
			VAL v57 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v56), v55));
			VAL v58 = (mw_mirth_c99_ZPlusC99_line(v57));
			VTUP(v46)->cells[1] = v58;
			VAL v59 = (mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang(v46, v42));
			VAL v60 = (mw_mirth_c99_pushZ_localZ_labelZBang(v44, v59, v43));
			x3 = v60;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v61;
			VAL v62;
			uint64_t v63;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2, &v61, &v62, &v63);
			int64_t v64 = VI64(VTUP(v62)->cells[1]);
			VAL v65;
			VAL v66;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v64, v63, x1, &v65, &v66);
			VAL v67 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(v66));
			VAL v68 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v64, v67);
			VAL v69 = VVAL(VTUP(v62)->cells[2]);
			incref(v69);
			VAL v70 = (VVAL(VTUP(v65)->cells[1]));
			VAL v71 = (mw_mirth_c99_ZPlusC99_indent(v70));
			VAL v72 = (mw_mirth_c99_ZPlusC99_put(v69, v71));
			STR* v73;
			STRLIT(v73, " = ", 3);
			VAL v74 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v73), v72));
			VAL v75 = (mw_mirth_c99_ZPlusC99_put(v68, v74));
			STR* v76;
			STRLIT(v76, ";", 1);
			VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v76), v75));
			VAL v78 = (mw_mirth_c99_ZPlusC99_line(v77));
			VTUP(v65)->cells[1] = v78;
			VAL v79 = (mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang(v65, v61));
			VAL v80 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v63, v79, v62));
			x3 = v80;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
			VAL v6 = (MKI64(0LL /* +C99LocalNone */));
			VAL v7 = (MKI64(0LL /* +SCNil */));
			x5 = v7;
			x4 = v6;
		} break;
		case 1LL: { // +SCCons
			VAL v8;
			VAL v9;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1, &v8, &v9);
			VAL v10 = (mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(v9));
			x5 = v8;
			x4 = v10;
		} break;
		case 2LL: { // +SCWith
			VAL v11;
			VAL v12;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1, &v11, &v12);
			VAL v13;
			VAL v14;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(v11, &v13, &v14);
			VAL v15 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v14, v12));
			x5 = v15;
			x4 = v13;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v16;
			VAL v17;
			uint64_t v18;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1, &v16, &v17, &v18);
			VAL v19;
			VAL v20;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(v16, &v19, &v20);
			VAL v21 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v20, v17, v18));
			x5 = v21;
			x4 = v19;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v22;
			VAL v23;
			uint64_t v24;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1, &v22, &v23, &v24);
			VAL v25;
			VAL v26;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(v22, &v25, &v26);
			VAL v27 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v26, v23, v24));
			x5 = v27;
			x4 = v25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
			VAL v6 = (MKI64(0LL /* +C99LocalResourceNone */));
			VAL v7 = (MKI64(0LL /* +SCNil */));
			x5 = v7;
			x4 = v6;
		} break;
		case 2LL: { // +SCWith
			VAL v8;
			VAL v9;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1, &v8, &v9);
			VAL v10 = (mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(v9));
			x5 = v8;
			x4 = v10;
		} break;
		case 1LL: { // +SCCons
			VAL v11;
			VAL v12;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1, &v11, &v12);
			VAL v13;
			VAL v14;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(v11, &v13, &v14);
			VAL v15 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v14, v12));
			x5 = v15;
			x4 = v13;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v16;
			VAL v17;
			uint64_t v18;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1, &v16, &v17, &v18);
			VAL v19;
			VAL v20;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(v16, &v19, &v20);
			VAL v21 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v20, v17, v18));
			x5 = v21;
			x4 = v19;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v22;
			VAL v23;
			uint64_t v24;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1, &v22, &v23, &v24);
			VAL v25;
			VAL v26;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(v22, &v25, &v26);
			VAL v27 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v26, v23, v24));
			x5 = v27;
			x4 = v25;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk (uint64_t x1, VAL x2, uint64_t *x3, VAL *x4, VAL *x5) {
	uint64_t x6;
	VAL x7;
	VAL x8;
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			VAL v9 = (MKI64(0LL /* +C99LocalNone */));
			VAL v10 = (MKI64(0LL /* +SCNil */));
			x8 = v10;
			x7 = v9;
			x6 = x1;
		} break;
		case 1LL: { // +SCCons
			VAL v11;
			VAL v12;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2, &v11, &v12);
			uint64_t v13;
			VAL v14;
			VAL v15;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(x1, v11, &v13, &v14, &v15);
			VAL v16 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v15, v12));
			x8 = v16;
			x7 = v14;
			x6 = v13;
		} break;
		case 2LL: { // +SCWith
			VAL v17;
			VAL v18;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2, &v17, &v18);
			uint64_t v19;
			VAL v20;
			VAL v21;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(x1, v17, &v19, &v20, &v21);
			VAL v22 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v21, v18));
			x8 = v22;
			x7 = v20;
			x6 = v19;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v23;
			VAL v24;
			uint64_t v25;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2, &v23, &v24, &v25);
			uint64_t v26;
			VAL v27;
			VAL v28;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(x1, v23, &v26, &v27, &v28);
			VAL v29 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v28, v24, v25));
			x8 = v29;
			x7 = v27;
			x6 = v26;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v30;
			VAL v31;
			uint64_t v32;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2, &v30, &v31, &v32);
			int64_t v33 = mw_mirth_label_Label_ZEqualZEqual(x1, v32);
			uint64_t x34;
			VAL x35;
			VAL x36;
			if (((bool)v33)) {
				VAL v37 = (mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(v31));
				x36 = v30;
				x35 = v37;
				x34 = x1;
			} else {
				uint64_t v38;
				VAL v39;
				VAL v40;
				mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(x1, v30, &v38, &v39, &v40);
				VAL v41 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v40, v31, v32));
				x36 = v41;
				x35 = v39;
				x34 = v38;
			}
			x8 = x36;
			x7 = x35;
			x6 = x34;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x8;
	*x4 = x7;
	*x3 = x6;
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk (uint64_t x1, VAL x2, uint64_t *x3, VAL *x4, VAL *x5) {
	uint64_t x6;
	VAL x7;
	VAL x8;
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			VAL v9 = (MKI64(0LL /* +C99LocalResourceNone */));
			VAL v10 = (MKI64(0LL /* +SCNil */));
			x8 = v10;
			x7 = v9;
			x6 = x1;
		} break;
		case 1LL: { // +SCCons
			VAL v11;
			VAL v12;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2, &v11, &v12);
			uint64_t v13;
			VAL v14;
			VAL v15;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(x1, v11, &v13, &v14, &v15);
			VAL v16 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v15, v12));
			x8 = v16;
			x7 = v14;
			x6 = v13;
		} break;
		case 2LL: { // +SCWith
			VAL v17;
			VAL v18;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2, &v17, &v18);
			uint64_t v19;
			VAL v20;
			VAL v21;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(x1, v17, &v19, &v20, &v21);
			VAL v22 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v21, v18));
			x8 = v22;
			x7 = v20;
			x6 = v19;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v23;
			VAL v24;
			uint64_t v25;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2, &v23, &v24, &v25);
			uint64_t v26;
			VAL v27;
			VAL v28;
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(x1, v23, &v26, &v27, &v28);
			VAL v29 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v28, v24, v25));
			x8 = v29;
			x7 = v27;
			x6 = v26;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v30;
			VAL v31;
			uint64_t v32;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2, &v30, &v31, &v32);
			int64_t v33 = mw_mirth_label_Label_ZEqualZEqual(x1, v32);
			uint64_t x34;
			VAL x35;
			VAL x36;
			if (((bool)v33)) {
				VAL v37 = (mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(v31));
				x36 = v30;
				x35 = v37;
				x34 = x1;
			} else {
				uint64_t v38;
				VAL v39;
				VAL v40;
				mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(x1, v30, &v38, &v39, &v40);
				VAL v41 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v40, v31, v32));
				x36 = v41;
				x35 = v39;
				x34 = v38;
			}
			x8 = x36;
			x7 = x35;
			x6 = x34;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x8;
	*x4 = x7;
	*x3 = x6;
}
static VAL mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			x3 = x1;
		} break;
		case 1LL: { // +SCCons
			VAL v4;
			VAL v5;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2, &v4, &v5);
			VAL v6 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(x1, v4));
			VAL v7 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang(v6, v5));
			x3 = v7;
		} break;
		case 2LL: { // +SCWith
			VAL v8;
			VAL v9;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2, &v8, &v9);
			VAL v10 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(x1, v8));
			VAL v11 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang(v10, v9));
			x3 = v11;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v12;
			VAL v13;
			uint64_t v14;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2, &v12, &v13, &v14);
			VAL v15 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(x1, v12));
			VAL v16 = (mw_mirth_c99_pushZ_localZ_labelZ_directZBang(v14, v15, v13));
			x3 = v16;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v17;
			VAL v18;
			uint64_t v19;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2, &v17, &v18, &v19);
			VAL v20 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(x1, v17));
			VAL v21 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang(v19, v20, v18));
			x3 = v21;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x3;
}
static void mw_mirth_c99_ZPlusC99StackCache_rdup (VAL x1, VAL *x2, VAL *x3) {
	VAL x4;
	VAL x5;
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
			VAL v6 = (MKI64(0LL /* +SCNil */));
			VAL v7 = (MKI64(0LL /* +SCNil */));
			x5 = v7;
			x4 = v6;
		} break;
		case 1LL: { // +SCCons
			VAL v8;
			VAL v9;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1, &v8, &v9);
			VAL v10;
			VAL v11;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v8, &v10, &v11);
			VAL v12;
			VAL v13;
			mw_mirth_c99_ZPlusC99Local_rdup(v9, &v12, &v13);
			VAL v14 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v11, v13));
			VAL v15 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v10, v12));
			x5 = v14;
			x4 = v15;
		} break;
		case 2LL: { // +SCWith
			VAL v16;
			VAL v17;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1, &v16, &v17);
			VAL v18;
			VAL v19;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v16, &v18, &v19);
			VAL v20;
			VAL v21;
			mw_mirth_c99_ZPlusC99LocalResource_rdup(v17, &v20, &v21);
			VAL v22 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v19, v21));
			VAL v23 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v18, v20));
			x5 = v22;
			x4 = v23;
		} break;
		case 3LL: { // +SCConsLabel
			VAL v24;
			VAL v25;
			uint64_t v26;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1, &v24, &v25, &v26);
			VAL v27;
			VAL v28;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v24, &v27, &v28);
			VAL v29;
			VAL v30;
			mw_mirth_c99_ZPlusC99Local_rdup(v25, &v29, &v30);
			VAL v31 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v28, v30, v26));
			VAL v32 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v27, v29, v26));
			x5 = v31;
			x4 = v32;
		} break;
		case 4LL: { // +SCWithLabel
			VAL v33;
			VAL v34;
			uint64_t v35;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1, &v33, &v34, &v35);
			VAL v36;
			VAL v37;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v33, &v36, &v37);
			VAL v38;
			VAL v39;
			mw_mirth_c99_ZPlusC99LocalResource_rdup(v34, &v38, &v39);
			VAL v40 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v37, v39, v35));
			VAL v41 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v36, v38, v35));
			x5 = v40;
			x4 = v41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x3 = x5;
	*x2 = x4;
}
static void mw_mirth_c99_ZPlusC99StackCache_rdrop (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
		} break;
		case 1LL: { // +SCCons
			VAL v2;
			VAL v3;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1, &v2, &v3);
			mw_mirth_c99_ZPlusC99Local_rdrop(v3);
			mw_mirth_c99_ZPlusC99StackCache_rdrop(v2);
		} break;
		case 2LL: { // +SCWith
			VAL v4;
			VAL v5;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1, &v4, &v5);
			mw_mirth_c99_ZPlusC99LocalResource_rdrop(v5);
			mw_mirth_c99_ZPlusC99StackCache_rdrop(v4);
		} break;
		case 3LL: { // +SCConsLabel
			VAL v6;
			VAL v7;
			uint64_t v8;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1, &v6, &v7, &v8);
			mw_mirth_c99_ZPlusC99Local_rdrop(v7);
			mw_mirth_c99_ZPlusC99StackCache_rdrop(v6);
		} break;
		case 4LL: { // +SCWithLabel
			VAL v9;
			VAL v10;
			uint64_t v11;
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1, &v9, &v10, &v11);
			mw_mirth_c99_ZPlusC99LocalResource_rdrop(v10);
			mw_mirth_c99_ZPlusC99StackCache_rdrop(v9);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang (VAL x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	int64_t v4;
	VAL v5;
	VAL v6;
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params(x1, v3, &v4, &v5, &v6);
	VTUP(x2)->cells[1] = v6;
	incref(v5);
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v5, &v7, &v8);
	VAL x9;
	int64_t x10;
	VAL x11;
	VAL x12;
	int64_t x13;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v15 = (mw_mirth_c99_C99APIArg_reserveZ_asZ_isZBang(v14, x2));
			int64_t v16 = 1LL /* True */;
			x13 = v16;
			x12 = v8;
			x11 = v5;
			x10 = v4;
			x9 = v15;
		} break;
		case 0LL: { // None
			int64_t v17 = 0LL /* False */;
			x13 = v17;
			x12 = v8;
			x11 = v5;
			x10 = v4;
			x9 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18 = (x9);
	int64_t v19 = x10;
	VAL v20 = x11;
	VAL v21 = x12;
	int64_t v22 = x13;
	while (((bool)v22)) {
		VAL v23 = (v18);
		int64_t v24 = v19;
		VAL v25 = v20;
		VAL v26 = v21;
		VAL v27;
		VAL v28;
		mw_std_list_List_1_uncons(v26, &v27, &v28);
		VAL x29;
		int64_t x30;
		VAL x31;
		VAL x32;
		int64_t x33;
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				VAL v34 = mtp_std_maybe_Maybe_1_Some(v27);
				VAL v35 = (mw_mirth_c99_C99APIArg_reserveZ_asZ_isZBang(v34, v23));
				int64_t v36 = 1LL /* True */;
				x33 = v36;
				x32 = v28;
				x31 = v25;
				x30 = v24;
				x29 = v35;
			} break;
			case 0LL: { // None
				int64_t v37 = 0LL /* False */;
				x33 = v37;
				x32 = v28;
				x31 = v25;
				x30 = v24;
				x29 = v23;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v22 = x33;
		v21 = x32;
		v20 = x31;
		v19 = x30;
		v18 = x29;
	}
	decref(v21);
	VAL v38;
	VAL v39;
	mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(v18, &v38, &v39);
	VAL v40 = (mtw_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit(v38, v39, v20, v19));
	return v40;
}
static VAL mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang (VAL x1) {
	VAL v2;
	VAL v3;
	VAL v4;
	int64_t v5;
	mtp_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit(x1, &v2, &v3, &v4, &v5);
	mw_mirth_c99_ZPlusC99StackCache_rdrop(v3);
	VAL v6 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v2));
	VAL v7;
	VAL v8;
	mw_std_list_List_1_uncons(v4, &v7, &v8);
	int64_t x9;
	VAL x10;
	VAL x11;
	int64_t x12;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v14 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v13, v6));
			int64_t v15 = 1LL /* True */;
			x12 = v15;
			x11 = v8;
			x10 = v14;
			x9 = v5;
		} break;
		case 0LL: { // None
			int64_t v16 = 0LL /* False */;
			x12 = v16;
			x11 = v8;
			x10 = v6;
			x9 = v5;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v17 = x9;
	VAL v18 = (x10);
	VAL v19 = x11;
	int64_t v20 = x12;
	while (((bool)v20)) {
		int64_t v21 = v17;
		VAL v22 = (v18);
		VAL v23 = v19;
		VAL v24;
		VAL v25;
		mw_std_list_List_1_uncons(v23, &v24, &v25);
		int64_t x26;
		VAL x27;
		VAL x28;
		int64_t x29;
		switch (get_data_tag(v24)) {
			case 1LL: { // Some
				VAL v30 = mtp_std_maybe_Maybe_1_Some(v24);
				VAL v31 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v30, v22));
				int64_t v32 = 1LL /* True */;
				x29 = v32;
				x28 = v25;
				x27 = v31;
				x26 = v21;
			} break;
			case 0LL: { // None
				int64_t v33 = 0LL /* False */;
				x29 = v33;
				x28 = v25;
				x27 = v22;
				x26 = v21;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v20 = x29;
		v19 = x28;
		v18 = x27;
		v17 = x26;
	}
	decref(v19);
	return v18;
}
static VAL mw_mirth_c99_ZPlusC99_startZ_branchZBang (VAL x1) {
	VAL v2 = (MKI64(0LL /* +SCNil */));
	VAL v3 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(x1, v2));
	return v3;
}
static VAL mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang (VAL x1) {
	VAL v2;
	VAL v3;
	mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(x1, &v2, &v3);
	VAL v4 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(v2, v3));
	return v4;
}
static VAL mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang (VAL x1) {
	VAL v2 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x1));
	VAL v3 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v2));
	return v3;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang (VAL x1, int64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = (VVAL(VTUP(x1)->cells[2]));
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(v5, &v6, &v7);
	VTUP(x1)->cells[2] = v7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // +C99LocalSome
			VAL v10 = (mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(v6));
			x9 = v10;
			x8 = x1;
		} break;
		case 0LL: { // +C99LocalNone
			VAL v11 = (VVAL(VTUP(x1)->cells[1]));
			VAL v12;
			VAL v13;
			mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang(x2, v11, &v12, &v13);
			VTUP(x1)->cells[1] = v12;
			x9 = v13;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x9;
	*x3 = x8;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = (VVAL(VTUP(x3)->cells[2]));
	uint64_t v7;
	VAL v8;
	VAL v9;
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(x2, v6, &v7, &v8, &v9);
	VTUP(x3)->cells[2] = v9;
	VAL x10;
	VAL x11;
	switch (get_data_tag(v8)) {
		case 1LL: { // +C99LocalSome
			VAL v12 = (mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(v8));
			x11 = v12;
			x10 = x3;
		} break;
		case 0LL: { // +C99LocalNone
			VAL v13 = (VVAL(VTUP(x3)->cells[1]));
			VAL v14;
			VAL v15;
			mw_mirth_c99_popZ_localZ_labelZ_directZBang(x1, v7, v13, &v14, &v15);
			VTUP(x3)->cells[1] = v14;
			x11 = v15;
			x10 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x11;
	*x4 = x10;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang (VAL x1, int64_t x2, VAL *x3, VAL *x4) {
	VAL v5 = (VVAL(VTUP(x1)->cells[2]));
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(v5, &v6, &v7);
	VTUP(x1)->cells[2] = v7;
	VAL x8;
	VAL x9;
	switch (get_data_tag(v6)) {
		case 1LL: { // +C99LocalResourceSome
			VAL v10 = (mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(v6));
			x9 = v10;
			x8 = x1;
		} break;
		case 0LL: { // +C99LocalResourceNone
			VAL v11 = (VVAL(VTUP(x1)->cells[1]));
			VAL v12;
			VAL v13;
			mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang(v11, x2, &v12, &v13);
			VTUP(x1)->cells[1] = v12;
			x9 = v13;
			x8 = x1;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x4 = x9;
	*x3 = x8;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang (int64_t x1, uint64_t x2, VAL x3, VAL *x4, VAL *x5) {
	VAL v6 = (VVAL(VTUP(x3)->cells[2]));
	uint64_t v7;
	VAL v8;
	VAL v9;
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(x2, v6, &v7, &v8, &v9);
	VTUP(x3)->cells[2] = v9;
	VAL x10;
	VAL x11;
	switch (get_data_tag(v8)) {
		case 1LL: { // +C99LocalResourceSome
			VAL v12 = (mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(v8));
			x11 = v12;
			x10 = x3;
		} break;
		case 0LL: { // +C99LocalResourceNone
			VAL v13 = (VVAL(VTUP(x3)->cells[1]));
			VAL v14;
			VAL v15;
			mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang(x1, v7, v13, &v14, &v15);
			VTUP(x3)->cells[1] = v14;
			x11 = v15;
			x10 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x11;
	*x4 = x10;
}
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZBang (VAL x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x1)->cells[2]));
	VAL v4 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v3, x2));
	VTUP(x1)->cells[2] = v4;
	return x1;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang (VAL x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x1)->cells[2]));
	VAL v4 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v3, x2));
	VTUP(x1)->cells[2] = v4;
	return x1;
}
static void mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = (VVAL(VTUP(x2)->cells[1]));
	VAL v6 = (VVAL(VTUP(v5)->cells[6]));
	int64_t v7;
	VAL v8;
	mw_mirth_type_Type_c99Z_repr(x1, v6, &v7, &v8);
	VTUP(v5)->cells[6] = v8;
	VTUP(x2)->cells[1] = v5;
	*x4 = x2;
	*x3 = v7;
}
static void mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr (VAL x1, VAL x2, int64_t *x3, VAL *x4) {
	VAL v5 = (VVAL(VTUP(x2)->cells[1]));
	VAL v6 = (VVAL(VTUP(v5)->cells[6]));
	int64_t v7;
	VAL v8;
	mw_mirth_type_Resource_c99Z_repr(x1, v6, &v7, &v8);
	VTUP(v5)->cells[6] = v8;
	VTUP(x2)->cells[1] = v5;
	*x4 = x2;
	*x3 = v7;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6 = mw_mirth_type_StackType_forceZ_consZAskZBang(x1);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			x8 = v9;
			x7 = x2;
		} break;
		case 0LL: { // None
			STR* v10;
			STRLIT(v10, "c99 error: tried to pop from invalid stack type", 47);
			VAL v11 = (VVAL(VTUP(x2)->cells[1]));
			VAL v12 = (VVAL(VTUP(v11)->cells[6]));
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v10), v12);
			VAL r13 = pop_resource();
			VTUP(v11)->cells[6] = r13;
			VTUP(x2)->cells[1] = v11;
			VAL v14 = pop_value();
			x8 = v14;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15;
	VAL v16;
	value_uncons(x8, &v15, &v16);
	VAL v17;
	VAL v18;
	value_uncons(v15, &v17, &v18);
	decref(v17);
	int64_t v19;
	VAL v20;
	mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v16, x7, &v19, &v20);
	VAL v21;
	VAL v22;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v20, v19, &v21, &v22);
	*x5 = v22;
	*x4 = v21;
	*x3 = v18;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6 = mw_mirth_type_StackType_forceZ_withZAskZBang(x1);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			x8 = v9;
			x7 = x2;
		} break;
		case 0LL: { // None
			STR* v10;
			STRLIT(v10, "c99 error: tried to pop from invalid stack type", 47);
			VAL v11 = (VVAL(VTUP(x2)->cells[1]));
			VAL v12 = (VVAL(VTUP(v11)->cells[6]));
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v10), v12);
			VAL r13 = pop_resource();
			VTUP(v11)->cells[6] = r13;
			VTUP(x2)->cells[1] = v11;
			VAL v14 = pop_value();
			x8 = v14;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v15;
	VAL v16;
	value_uncons(x8, &v15, &v16);
	VAL v17;
	VAL v18;
	value_uncons(v15, &v17, &v18);
	decref(v17);
	int64_t v19;
	VAL v20;
	mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v16, x7, &v19, &v20);
	VAL v21;
	VAL v22;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v20, v19, &v21, &v22);
	*x5 = v22;
	*x4 = v21;
	*x3 = v18;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(x1, x2);
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			x10 = v11;
			x9 = x1;
			x8 = x3;
		} break;
		case 0LL: { // None
			STR* v12;
			STRLIT(v12, "c99 error: tried to pop from invalid stack type", 47);
			VAL v13 = (VVAL(VTUP(x3)->cells[1]));
			VAL v14 = (VVAL(VTUP(v13)->cells[6]));
			push_u64(x1);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v12), v14);
			VAL r15 = pop_resource();
			VTUP(v13)->cells[6] = r15;
			VTUP(x3)->cells[1] = v13;
			VAL v16 = pop_value();
			x10 = v16;
			uint64_t v17 = pop_u64();
			x9 = v17;
			x8 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18;
	VAL v19;
	value_uncons(x10, &v18, &v19);
	VAL v20;
	VAL v21;
	value_uncons(v18, &v20, &v21);
	decref(v20);
	int64_t v22;
	VAL v23;
	mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v19, x8, &v22, &v23);
	VAL v24;
	VAL v25;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v22, x9, v23, &v24, &v25);
	*x6 = v25;
	*x5 = v24;
	*x4 = v21;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3, VAL *x4, VAL *x5, VAL *x6) {
	VAL v7 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(x1, x2);
	VAL x8;
	uint64_t x9;
	VAL x10;
	switch (get_data_tag(v7)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
			x10 = v11;
			x9 = x1;
			x8 = x3;
		} break;
		case 0LL: { // None
			STR* v12;
			STRLIT(v12, "c99 error: tried to pop from invalid stack type", 47);
			VAL v13 = (VVAL(VTUP(x3)->cells[1]));
			VAL v14 = (VVAL(VTUP(v13)->cells[6]));
			push_u64(x1);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v12), v14);
			VAL r15 = pop_resource();
			VTUP(v13)->cells[6] = r15;
			VTUP(x3)->cells[1] = v13;
			VAL v16 = pop_value();
			x10 = v16;
			uint64_t v17 = pop_u64();
			x9 = v17;
			x8 = x3;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18;
	VAL v19;
	value_uncons(x10, &v18, &v19);
	VAL v20;
	VAL v21;
	value_uncons(v18, &v20, &v21);
	decref(v20);
	int64_t v22;
	VAL v23;
	mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v19, x8, &v22, &v23);
	VAL v24;
	VAL v25;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v22, x9, v23, &v24, &v25);
	*x6 = v25;
	*x5 = v24;
	*x4 = v21;
}
static VAL mw_mirth_c99_c99Z_primZBang (VAL x1, int64_t x2, VAL x3) {
	VAL x4;
	switch (x2) {
		case 0LL: { // PRIM_CORE_ID
			decref(x1);
			x4 = x3;
		} break;
		case 2LL: { // PRIM_CORE_DROP
			VAL v5 = VVAL(VTUP(x1)->cells[6]);
			incref(v5);
			decref(x1);
			VAL v6;
			VAL v7;
			VAL v8;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v5, x3, &v6, &v7, &v8);
			decref(v6);
			VAL v9 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(v7, v8));
			x4 = v9;
		} break;
		case 1LL: { // PRIM_CORE_DUP
			VAL v10 = VVAL(VTUP(x1)->cells[6]);
			incref(v10);
			decref(x1);
			VAL v11;
			VAL v12;
			VAL v13;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v10, x3, &v11, &v12, &v13);
			decref(v11);
			VAL v14;
			VAL v15;
			VAL v16;
			mw_mirth_c99_ZPlusC99Local_dupZ_localZBang(v12, v13, &v14, &v15, &v16);
			VAL v17 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v14, v15));
			VAL v18 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v17, v16));
			x4 = v18;
		} break;
		case 3LL: { // PRIM_CORE_SWAP
			VAL v19 = VVAL(VTUP(x1)->cells[6]);
			incref(v19);
			decref(x1);
			VAL v20;
			VAL v21;
			VAL v22;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v19, x3, &v20, &v21, &v22);
			VAL v23;
			VAL v24;
			VAL v25;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v20, v21, &v23, &v24, &v25);
			decref(v23);
			VAL v26 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v24, v22));
			VAL v27 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v26, v25));
			x4 = v27;
		} break;
		case 4LL: { // PRIM_CORE_RSWAP
			VAL v28 = VVAL(VTUP(x1)->cells[6]);
			incref(v28);
			decref(x1);
			VAL v29;
			VAL v30;
			VAL v31;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v28, x3, &v29, &v30, &v31);
			VAL v32;
			VAL v33;
			VAL v34;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v29, v30, &v32, &v33, &v34);
			decref(v32);
			VAL v35 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v33, v31));
			VAL v36 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v35, v34));
			x4 = v36;
		} break;
		case 5LL: { // PRIM_CORE_DIP
			incref(x1);
			VAL v37 = VVAL(VTUP(x1)->cells[5]);
			incref(v37);
			decref(x1);
			VAL v38 = mw_std_list_List_1_ZDivL1(v37);
			VAL x39;
			VAL x40;
			uint64_t x41;
			switch (get_data_tag(v38)) {
				case 1LL: { // Some
					VAL v42 = mtp_std_maybe_Maybe_1_Some(v38);
					x41 = VU64(v42);
					x40 = x1;
					x39 = x3;
				} break;
				case 0LL: { // None
					uint64_t v43 = VU64(VTUP(x1)->cells[2]);
					decref(x1);
					STR* v44;
					STRLIT(v44, "unexpected number of arguments to PRIM_CORE_DIP", 47);
					VAL v45 = (VVAL(VTUP(x3)->cells[1]));
					VAL v46 = (VVAL(VTUP(v45)->cells[6]));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v43, MKSTR(v44), v46);
					VAL r47 = pop_resource();
					VTUP(v45)->cells[6] = r47;
					VTUP(x3)->cells[1] = v45;
					uint64_t v48 = pop_u64();
					x41 = v48;
					VAL v49 = pop_value();
					x40 = v49;
					x39 = x3;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v50 = VVAL(VTUP(x40)->cells[6]);
			incref(v50);
			decref(x40);
			VAL v51;
			VAL v52;
			VAL v53;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v50, x39, &v51, &v52, &v53);
			decref(v51);
			VAL v54 = (mw_mirth_c99_c99Z_argZ_runZBang(x41, v52));
			VAL v55 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v54, v53));
			x4 = v55;
		} break;
		case 6LL: { // PRIM_CORE_RDIP
			incref(x1);
			VAL v56 = VVAL(VTUP(x1)->cells[5]);
			incref(v56);
			decref(x1);
			VAL v57 = mw_std_list_List_1_ZDivL1(v56);
			VAL x58;
			VAL x59;
			uint64_t x60;
			switch (get_data_tag(v57)) {
				case 1LL: { // Some
					VAL v61 = mtp_std_maybe_Maybe_1_Some(v57);
					x60 = VU64(v61);
					x59 = x1;
					x58 = x3;
				} break;
				case 0LL: { // None
					uint64_t v62 = VU64(VTUP(x1)->cells[2]);
					decref(x1);
					STR* v63;
					STRLIT(v63, "unexpected number of arguments to PRIM_CORE_RDIP", 48);
					VAL v64 = (VVAL(VTUP(x3)->cells[1]));
					VAL v65 = (VVAL(VTUP(v64)->cells[6]));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v62, MKSTR(v63), v65);
					VAL r66 = pop_resource();
					VTUP(v64)->cells[6] = r66;
					VTUP(x3)->cells[1] = v64;
					uint64_t v67 = pop_u64();
					x60 = v67;
					VAL v68 = pop_value();
					x59 = v68;
					x58 = x3;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v69 = VVAL(VTUP(x59)->cells[6]);
			incref(v69);
			decref(x59);
			VAL v70;
			VAL v71;
			VAL v72;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v69, x58, &v70, &v71, &v72);
			decref(v70);
			VAL v73 = (mw_mirth_c99_c99Z_argZ_runZBang(x60, v71));
			VAL v74 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v73, v72));
			x4 = v74;
		} break;
		case 7LL: { // PRIM_CORE_IF
			incref(x1);
			VAL v75 = VVAL(VTUP(x1)->cells[5]);
			incref(v75);
			decref(x1);
			VAL v76 = mw_std_list_List_1_ZDivL2(v75);
			VAL x77;
			VAL x78;
			VAL x79;
			switch (get_data_tag(v76)) {
				case 1LL: { // Some
					VAL v80 = mtp_std_maybe_Maybe_1_Some(v76);
					x79 = v80;
					x78 = x1;
					x77 = x3;
				} break;
				case 0LL: { // None
					uint64_t v81 = VU64(VTUP(x1)->cells[2]);
					decref(x1);
					STR* v82;
					STRLIT(v82, "unexpected number of arguments to PRIM_CORE_IF", 46);
					VAL v83 = (VVAL(VTUP(x3)->cells[1]));
					VAL v84 = (VVAL(VTUP(v83)->cells[6]));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v81, MKSTR(v82), v84);
					VAL r85 = pop_resource();
					VTUP(v83)->cells[6] = r85;
					VTUP(x3)->cells[1] = v83;
					VAL v86 = pop_value();
					x79 = v86;
					VAL v87 = pop_value();
					x78 = v87;
					x77 = x3;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v88;
			VAL v89;
			value_uncons(x79, &v88, &v89);
			VAL v90;
			VAL v91;
			value_uncons(v88, &v90, &v91);
			decref(v90);
			int64_t v92 = 12LL /* C99RT_BOOL */;
			VAL v93;
			VAL v94;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x77, v92, &v93, &v94);
			VAL v95 = (VVAL(VTUP(v93)->cells[1]));
			VAL v96 = (VVAL(VTUP(v95)->cells[6]));
			VAL v97 = VVAL(VTUP(x78)->cells[7]);
			incref(v97);
			decref(x78);
			VTUP(v95)->cells[6] = v96;
			VTUP(v93)->cells[1] = v95;
			VAL v98 = (mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang(v97, v93));
			VAL v99 = (VVAL(VTUP(v98)->cells[1]));
			VAL v100 = (mw_mirth_c99_ZPlusC99_indent(v99));
			STR* v101;
			STRLIT(v101, "if (", 4);
			VAL v102 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v101), v100));
			int64_t v103 = 12LL /* C99RT_BOOL */;
			VAL v104 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v103, v94);
			VAL v105 = (mw_mirth_c99_ZPlusC99_put(v104, v102));
			STR* v106;
			STRLIT(v106, ") {", 3);
			VAL v107 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v106), v105));
			VAL v108 = (mw_mirth_c99_ZPlusC99_line(v107));
			VTUP(v98)->cells[1] = v108;
			VAL v109 = (VVAL(VTUP(v98)->cells[1]));
			int64_t v110 = VI64(VTUP(v109)->cells[2]);
			int64_t v111 = 1LL;
			int64_t v112 = i64_add(v110, v111);
			VTUP(v109)->cells[2] = MKI64(v112);
			VTUP(v98)->cells[1] = v109;
			VAL v113 = (VVAL(VTUP(v98)->cells[2]));
			VAL v114;
			VAL v115;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v113, &v114, &v115);
			VTUP(v98)->cells[2] = v114;
			VAL v116 = VVAL(VTUP(v98)->cells[3]);
			incref(v116);
			VAL v117 = (VVAL(VTUP(v98)->cells[1]));
			VAL v118 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(v117, v115));
			VAL v119 = (mw_mirth_c99_c99Z_argZ_runZBang(VU64(v91), v118));
			VAL v120 = mw_std_list_List_1_reverse(v116);
			VAL v121;
			VAL v122;
			mw_std_list_List_1_uncons(v120, &v121, &v122);
			VAL x123;
			VAL x124;
			int64_t x125;
			switch (get_data_tag(v121)) {
				case 1LL: { // Some
					VAL v126 = mtp_std_maybe_Maybe_1_Some(v121);
					VAL v127 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v126, v119));
					int64_t v128 = 1LL /* True */;
					x125 = v128;
					x124 = v122;
					x123 = v127;
					push_value(v89);
				} break;
				case 0LL: { // None
					int64_t v129 = 0LL /* False */;
					x125 = v129;
					x124 = v122;
					x123 = v119;
					push_value(v89);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v130 = (x123);
			VAL v131 = x124;
			int64_t v132 = x125;
			while (((bool)v132)) {
				VAL v133 = (v130);
				VAL v134 = v131;
				VAL v135;
				VAL v136;
				mw_std_list_List_1_uncons(v134, &v135, &v136);
				VAL x137;
				VAL x138;
				int64_t x139;
				switch (get_data_tag(v135)) {
					case 1LL: { // Some
						VAL v140 = mtp_std_maybe_Maybe_1_Some(v135);
						VAL v141 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v140, v133));
						int64_t v142 = 1LL /* True */;
						x139 = v142;
						x138 = v136;
						x137 = v141;
					} break;
					case 0LL: { // None
						int64_t v143 = 0LL /* False */;
						x139 = v143;
						x138 = v136;
						x137 = v133;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v132 = x139;
				v131 = x138;
				v130 = x137;
			}
			decref(v131);
			VAL v144 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v130));
			VTUP(v98)->cells[1] = v144;
			VAL v145 = (VVAL(VTUP(v98)->cells[1]));
			int64_t v146 = VI64(VTUP(v145)->cells[2]);
			int64_t v147 = 1LL;
			int64_t v148 = i64_sub(v146, v147);
			int64_t v149 = 0LL;
			bool v150 = (v148 < v149);
			int64_t x151;
			if (v150) {
				int64_t v152 = 0LL;
				x151 = v152;
			} else {
				x151 = v148;
			}
			VTUP(v145)->cells[2] = MKI64(x151);
			VTUP(v98)->cells[1] = v145;
			VAL v153 = (VVAL(VTUP(v98)->cells[1]));
			VAL v154 = (mw_mirth_c99_ZPlusC99_indent(v153));
			STR* v155;
			STRLIT(v155, "} else {", 8);
			VAL v156 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v155), v154));
			VAL v157 = (mw_mirth_c99_ZPlusC99_line(v156));
			VTUP(v98)->cells[1] = v157;
			VAL v158 = (VVAL(VTUP(v98)->cells[1]));
			int64_t v159 = VI64(VTUP(v158)->cells[2]);
			int64_t v160 = 1LL;
			int64_t v161 = i64_add(v159, v160);
			VTUP(v158)->cells[2] = MKI64(v161);
			VTUP(v98)->cells[1] = v158;
			VAL v162 = (VVAL(VTUP(v98)->cells[2]));
			VAL v163;
			VAL v164;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v162, &v163, &v164);
			VTUP(v98)->cells[2] = v163;
			VAL v165 = VVAL(VTUP(v98)->cells[3]);
			incref(v165);
			VAL v166 = (VVAL(VTUP(v98)->cells[1]));
			VAL v167 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(v166, v164));
			uint64_t v168 = pop_u64();
			VAL v169 = (mw_mirth_c99_c99Z_argZ_runZBang(v168, v167));
			VAL v170 = mw_std_list_List_1_reverse(v165);
			VAL v171;
			VAL v172;
			mw_std_list_List_1_uncons(v170, &v171, &v172);
			VAL x173;
			VAL x174;
			int64_t x175;
			switch (get_data_tag(v171)) {
				case 1LL: { // Some
					VAL v176 = mtp_std_maybe_Maybe_1_Some(v171);
					VAL v177 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v176, v169));
					int64_t v178 = 1LL /* True */;
					x175 = v178;
					x174 = v172;
					x173 = v177;
				} break;
				case 0LL: { // None
					int64_t v179 = 0LL /* False */;
					x175 = v179;
					x174 = v172;
					x173 = v169;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v180 = (x173);
			VAL v181 = x174;
			int64_t v182 = x175;
			while (((bool)v182)) {
				VAL v183 = (v180);
				VAL v184 = v181;
				VAL v185;
				VAL v186;
				mw_std_list_List_1_uncons(v184, &v185, &v186);
				VAL x187;
				VAL x188;
				int64_t x189;
				switch (get_data_tag(v185)) {
					case 1LL: { // Some
						VAL v190 = mtp_std_maybe_Maybe_1_Some(v185);
						VAL v191 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v190, v183));
						int64_t v192 = 1LL /* True */;
						x189 = v192;
						x188 = v186;
						x187 = v191;
					} break;
					case 0LL: { // None
						int64_t v193 = 0LL /* False */;
						x189 = v193;
						x188 = v186;
						x187 = v183;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v182 = x189;
				v181 = x188;
				v180 = x187;
			}
			decref(v181);
			VAL v194 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v180));
			VTUP(v98)->cells[1] = v194;
			VAL v195 = (VVAL(VTUP(v98)->cells[1]));
			int64_t v196 = VI64(VTUP(v195)->cells[2]);
			int64_t v197 = 1LL;
			int64_t v198 = i64_sub(v196, v197);
			int64_t v199 = 0LL;
			bool v200 = (v198 < v199);
			int64_t x201;
			if (v200) {
				int64_t v202 = 0LL;
				x201 = v202;
			} else {
				x201 = v198;
			}
			VTUP(v195)->cells[2] = MKI64(x201);
			VTUP(v98)->cells[1] = v195;
			VAL v203 = (VVAL(VTUP(v98)->cells[1]));
			VAL v204 = (mw_mirth_c99_ZPlusC99_indent(v203));
			STR* v205;
			STRLIT(v205, "}", 1);
			VAL v206 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v205), v204));
			VAL v207 = (mw_mirth_c99_ZPlusC99_line(v206));
			VTUP(v98)->cells[1] = v207;
			VAL v208 = (mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang(v98));
			x4 = v208;
		} break;
		case 8LL: { // PRIM_CORE_WHILE
			incref(x1);
			VAL v209 = VVAL(VTUP(x1)->cells[5]);
			incref(v209);
			decref(x1);
			VAL v210 = mw_std_list_List_1_ZDivL2(v209);
			VAL x211;
			VAL x212;
			VAL x213;
			switch (get_data_tag(v210)) {
				case 1LL: { // Some
					VAL v214 = mtp_std_maybe_Maybe_1_Some(v210);
					x213 = v214;
					x212 = x1;
					x211 = x3;
				} break;
				case 0LL: { // None
					uint64_t v215 = VU64(VTUP(x1)->cells[2]);
					decref(x1);
					STR* v216;
					STRLIT(v216, "unexpected number of arguments to PRIM_CORE_WHILE", 49);
					VAL v217 = (VVAL(VTUP(x3)->cells[1]));
					VAL v218 = (VVAL(VTUP(v217)->cells[6]));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v215, MKSTR(v216), v218);
					VAL r219 = pop_resource();
					VTUP(v217)->cells[6] = r219;
					VTUP(x3)->cells[1] = v217;
					VAL v220 = pop_value();
					x213 = v220;
					VAL v221 = pop_value();
					x212 = v221;
					x211 = x3;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x212);
			VAL v222;
			VAL v223;
			value_uncons(x213, &v222, &v223);
			VAL v224;
			VAL v225;
			value_uncons(v222, &v224, &v225);
			decref(v224);
			incref(v225);
			VAL v226 = (mw_mirth_c99_c99Z_argZ_runZBang(VU64(v225), x211));
			int64_t v227 = 12LL /* C99RT_BOOL */;
			VAL v228;
			VAL v229;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v226, v227, &v228, &v229);
			VAL v230 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v228, v229));
			VAL v231 = (mw_mirth_c99_ZPlusC99Branch_refreshZ_branchZBang(v230));
			VAL v232 = (VVAL(VTUP(v231)->cells[2]));
			VAL v233;
			VAL v234;
			mw_mirth_c99_ZPlusC99StackCache_rdup(v232, &v233, &v234);
			VTUP(v231)->cells[2] = v233;
			int64_t v235 = 12LL /* C99RT_BOOL */;
			VAL v236;
			VAL v237;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v231, v235, &v236, &v237);
			VAL v238 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v235, v237);
			VAL v239 = (VVAL(VTUP(v236)->cells[1]));
			VAL v240 = (mw_mirth_c99_ZPlusC99_indent(v239));
			STR* v241;
			STRLIT(v241, "while (", 7);
			VAL v242 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v241), v240));
			VAL v243 = (mw_mirth_c99_ZPlusC99_put(v238, v242));
			STR* v244;
			STRLIT(v244, ") {", 3);
			VAL v245 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v244), v243));
			VAL v246 = (mw_mirth_c99_ZPlusC99_line(v245));
			VTUP(v236)->cells[1] = v246;
			VAL v247 = (VVAL(VTUP(v236)->cells[1]));
			int64_t v248 = VI64(VTUP(v247)->cells[2]);
			int64_t v249 = 1LL;
			int64_t v250 = i64_add(v248, v249);
			VTUP(v247)->cells[2] = MKI64(v250);
			VTUP(v236)->cells[1] = v247;
			VAL v251 = (mw_mirth_c99_ZPlusC99Branch_refreshZ_branchZBang(v236));
			VAL v252 = (mw_mirth_c99_c99Z_argZ_runZBang(VU64(v223), v251));
			VAL v253 = (mw_mirth_c99_c99Z_argZ_runZBang(VU64(v225), v252));
			VAL v254 = (mw_mirth_c99_ZPlusC99StackCache_tieZ_knotZBang(v253, v234));
			VAL v255 = (VVAL(VTUP(v254)->cells[1]));
			int64_t v256 = VI64(VTUP(v255)->cells[2]);
			int64_t v257 = 1LL;
			int64_t v258 = i64_sub(v256, v257);
			int64_t v259 = 0LL;
			bool v260 = (v258 < v259);
			int64_t x261;
			if (v260) {
				int64_t v262 = 0LL;
				x261 = v262;
			} else {
				x261 = v258;
			}
			VTUP(v255)->cells[2] = MKI64(x261);
			VTUP(v254)->cells[1] = v255;
			VAL v263 = (VVAL(VTUP(v254)->cells[1]));
			VAL v264 = (mw_mirth_c99_ZPlusC99_indent(v263));
			STR* v265;
			STRLIT(v265, "}", 1);
			VAL v266 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v265), v264));
			VAL v267 = (mw_mirth_c99_ZPlusC99_line(v266));
			VTUP(v254)->cells[1] = v267;
			int64_t v268 = 12LL /* C99RT_BOOL */;
			VAL v269;
			VAL v270;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v254, v268, &v269, &v270);
			mw_mirth_c99_ZPlusC99Local_rdrop(v270);
			x4 = v269;
		} break;
		case 9LL: { // PRIM_CORE_DEBUG
			decref(x1);
			VAL v271 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(x3));
			VAL v272 = (VVAL(VTUP(v271)->cells[1]));
			VAL v273 = (mw_mirth_c99_ZPlusC99_indent(v272));
			STR* v274;
			STRLIT(v274, "trace_stack();", 14);
			VAL v275 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v274), v273));
			VAL v276 = (mw_mirth_c99_ZPlusC99_line(v275));
			VTUP(v271)->cells[1] = v276;
			x4 = v271;
		} break;
		case 10LL: { // PRIM_CORE_PANIC
			decref(x1);
			int64_t v277 = 1LL /* C99RT_STR */;
			VAL v278;
			VAL v279;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v277, &v278, &v279);
			VAL v280 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v277, v279);
			VAL v281 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(v278));
			VAL v282 = (VVAL(VTUP(v281)->cells[1]));
			VAL v283 = (mw_mirth_c99_ZPlusC99_indent(v282));
			STR* v284;
			STRLIT(v284, "do_panic(", 9);
			VAL v285 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v284), v283));
			VAL v286 = (mw_mirth_c99_ZPlusC99_put(v280, v285));
			STR* v287;
			STRLIT(v287, ");", 2);
			VAL v288 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v287), v286));
			VAL v289 = (mw_mirth_c99_ZPlusC99_line(v288));
			VTUP(v281)->cells[1] = v289;
			x4 = v281;
		} break;
		case 11LL: { // PRIM_CORE_RUN
			incref(x1);
			VAL v290 = VVAL(VTUP(x1)->cells[5]);
			incref(v290);
			decref(x1);
			int64_t v291 = mw_std_list_List_1_emptyZAsk(v290);
			VAL x292;
			VAL x293;
			if (((bool)v291)) {
				x293 = x3;
				x292 = x1;
			} else {
				STR* v294;
				STRLIT(v294, "expected no arguments to prim-core-run", 38);
				STR* v295;
				STRLIT(v295, "assertion failed: ", 18);
				STR* v296 = str_cat(v295, v294);
				push_resource(x3);
				push_value(x1);
				do_panic(v296);
				VAL r297 = pop_resource();
				x293 = r297;
				VAL v298 = pop_value();
				x292 = v298;
			}
			decref(x292);
			int64_t v299 = 0LL /* C99RT_VAL */;
			VAL v300;
			VAL v301;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x293, v299, &v300, &v301);
			VAL v302 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(v300));
			VAL v303 = (VVAL(VTUP(v302)->cells[1]));
			VAL v304 = (mw_mirth_c99_ZPlusC99_indent(v303));
			STR* v305;
			STRLIT(v305, "run_value(", 10);
			VAL v306 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v305), v304));
			VAL v307 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v301);
			VAL v308 = (mw_mirth_c99_ZPlusC99_put(v307, v306));
			STR* v309;
			STRLIT(v309, ");", 2);
			VAL v310 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v309), v308));
			VAL v311 = (mw_mirth_c99_ZPlusC99_line(v310));
			VTUP(v302)->cells[1] = v311;
			x4 = v302;
		} break;
		case 14LL: { // PRIM_INT_EQ
			decref(x1);
			STR* v312;
			STRLIT(v312, "(", 1);
			int64_t v313 = 2LL /* C99RT_I64 */;
			STR* v314;
			STRLIT(v314, " == ", 4);
			int64_t v315 = 2LL /* C99RT_I64 */;
			STR* v316;
			STRLIT(v316, ")", 1);
			int64_t v317 = 0LL /* False */;
			int64_t v318 = 12LL /* C99RT_BOOL */;
			VAL v319 = mtw_std_maybe_Maybe_1_Some(MKI64(v318));
			VAL v320 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v312), v313, MKSTR(v314), v315, MKSTR(v316), v317, v319, x3));
			x4 = v320;
		} break;
		case 15LL: { // PRIM_INT_LT
			decref(x1);
			STR* v321;
			STRLIT(v321, "(", 1);
			int64_t v322 = 2LL /* C99RT_I64 */;
			STR* v323;
			STRLIT(v323, " < ", 3);
			int64_t v324 = 2LL /* C99RT_I64 */;
			STR* v325;
			STRLIT(v325, ")", 1);
			int64_t v326 = 0LL /* False */;
			int64_t v327 = 12LL /* C99RT_BOOL */;
			VAL v328 = mtw_std_maybe_Maybe_1_Some(MKI64(v327));
			VAL v329 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v321), v322, MKSTR(v323), v324, MKSTR(v325), v326, v328, x3));
			x4 = v329;
		} break;
		case 16LL: { // PRIM_INT_LE
			decref(x1);
			STR* v330;
			STRLIT(v330, "(", 1);
			int64_t v331 = 2LL /* C99RT_I64 */;
			STR* v332;
			STRLIT(v332, " <= ", 4);
			int64_t v333 = 2LL /* C99RT_I64 */;
			STR* v334;
			STRLIT(v334, ")", 1);
			int64_t v335 = 0LL /* False */;
			int64_t v336 = 12LL /* C99RT_BOOL */;
			VAL v337 = mtw_std_maybe_Maybe_1_Some(MKI64(v336));
			VAL v338 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v330), v331, MKSTR(v332), v333, MKSTR(v334), v335, v337, x3));
			x4 = v338;
		} break;
		case 17LL: { // PRIM_INT_GT
			decref(x1);
			STR* v339;
			STRLIT(v339, "(", 1);
			int64_t v340 = 2LL /* C99RT_I64 */;
			STR* v341;
			STRLIT(v341, " > ", 3);
			int64_t v342 = 2LL /* C99RT_I64 */;
			STR* v343;
			STRLIT(v343, ")", 1);
			int64_t v344 = 0LL /* False */;
			int64_t v345 = 12LL /* C99RT_BOOL */;
			VAL v346 = mtw_std_maybe_Maybe_1_Some(MKI64(v345));
			VAL v347 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v339), v340, MKSTR(v341), v342, MKSTR(v343), v344, v346, x3));
			x4 = v347;
		} break;
		case 18LL: { // PRIM_INT_GE
			decref(x1);
			STR* v348;
			STRLIT(v348, "(", 1);
			int64_t v349 = 2LL /* C99RT_I64 */;
			STR* v350;
			STRLIT(v350, " >= ", 4);
			int64_t v351 = 2LL /* C99RT_I64 */;
			STR* v352;
			STRLIT(v352, ")", 1);
			int64_t v353 = 0LL /* False */;
			int64_t v354 = 12LL /* C99RT_BOOL */;
			VAL v355 = mtw_std_maybe_Maybe_1_Some(MKI64(v354));
			VAL v356 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v348), v349, MKSTR(v350), v351, MKSTR(v352), v353, v355, x3));
			x4 = v356;
		} break;
		case 19LL: { // PRIM_INT_NE
			decref(x1);
			STR* v357;
			STRLIT(v357, "(", 1);
			int64_t v358 = 2LL /* C99RT_I64 */;
			STR* v359;
			STRLIT(v359, " != ", 4);
			int64_t v360 = 2LL /* C99RT_I64 */;
			STR* v361;
			STRLIT(v361, ")", 1);
			int64_t v362 = 0LL /* False */;
			int64_t v363 = 12LL /* C99RT_BOOL */;
			VAL v364 = mtw_std_maybe_Maybe_1_Some(MKI64(v363));
			VAL v365 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v357), v358, MKSTR(v359), v360, MKSTR(v361), v362, v364, x3));
			x4 = v365;
		} break;
		case 20LL: { // PRIM_INT_ADD
			decref(x1);
			STR* v366;
			STRLIT(v366, "i64_add(", 8);
			int64_t v367 = 2LL /* C99RT_I64 */;
			STR* v368;
			STRLIT(v368, ", ", 2);
			int64_t v369 = 2LL /* C99RT_I64 */;
			STR* v370;
			STRLIT(v370, ")", 1);
			int64_t v371 = 0LL /* False */;
			int64_t v372 = 2LL /* C99RT_I64 */;
			VAL v373 = mtw_std_maybe_Maybe_1_Some(MKI64(v372));
			VAL v374 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v366), v367, MKSTR(v368), v369, MKSTR(v370), v371, v373, x3));
			x4 = v374;
		} break;
		case 21LL: { // PRIM_INT_SUB
			decref(x1);
			STR* v375;
			STRLIT(v375, "i64_sub(", 8);
			int64_t v376 = 2LL /* C99RT_I64 */;
			STR* v377;
			STRLIT(v377, ", ", 2);
			int64_t v378 = 2LL /* C99RT_I64 */;
			STR* v379;
			STRLIT(v379, ")", 1);
			int64_t v380 = 0LL /* False */;
			int64_t v381 = 2LL /* C99RT_I64 */;
			VAL v382 = mtw_std_maybe_Maybe_1_Some(MKI64(v381));
			VAL v383 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v375), v376, MKSTR(v377), v378, MKSTR(v379), v380, v382, x3));
			x4 = v383;
		} break;
		case 22LL: { // PRIM_INT_MUL
			decref(x1);
			STR* v384;
			STRLIT(v384, "i64_mul(", 8);
			int64_t v385 = 2LL /* C99RT_I64 */;
			STR* v386;
			STRLIT(v386, ", ", 2);
			int64_t v387 = 2LL /* C99RT_I64 */;
			STR* v388;
			STRLIT(v388, ")", 1);
			int64_t v389 = 0LL /* False */;
			int64_t v390 = 2LL /* C99RT_I64 */;
			VAL v391 = mtw_std_maybe_Maybe_1_Some(MKI64(v390));
			VAL v392 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v384), v385, MKSTR(v386), v387, MKSTR(v388), v389, v391, x3));
			x4 = v392;
		} break;
		case 23LL: { // PRIM_INT_DIV
			decref(x1);
			STR* v393;
			STRLIT(v393, "i64_div(", 8);
			int64_t v394 = 2LL /* C99RT_I64 */;
			STR* v395;
			STRLIT(v395, ", ", 2);
			int64_t v396 = 2LL /* C99RT_I64 */;
			STR* v397;
			STRLIT(v397, ")", 1);
			int64_t v398 = 0LL /* False */;
			int64_t v399 = 2LL /* C99RT_I64 */;
			VAL v400 = mtw_std_maybe_Maybe_1_Some(MKI64(v399));
			VAL v401 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v393), v394, MKSTR(v395), v396, MKSTR(v397), v398, v400, x3));
			x4 = v401;
		} break;
		case 24LL: { // PRIM_INT_MOD
			decref(x1);
			STR* v402;
			STRLIT(v402, "i64_mod(", 8);
			int64_t v403 = 2LL /* C99RT_I64 */;
			STR* v404;
			STRLIT(v404, ", ", 2);
			int64_t v405 = 2LL /* C99RT_I64 */;
			STR* v406;
			STRLIT(v406, ")", 1);
			int64_t v407 = 0LL /* False */;
			int64_t v408 = 2LL /* C99RT_I64 */;
			VAL v409 = mtw_std_maybe_Maybe_1_Some(MKI64(v408));
			VAL v410 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v402), v403, MKSTR(v404), v405, MKSTR(v406), v407, v409, x3));
			x4 = v410;
		} break;
		case 25LL: { // PRIM_INT_AND
			decref(x1);
			STR* v411;
			STRLIT(v411, "(", 1);
			int64_t v412 = 6LL /* C99RT_U64 */;
			STR* v413;
			STRLIT(v413, " & ", 3);
			int64_t v414 = 6LL /* C99RT_U64 */;
			STR* v415;
			STRLIT(v415, ")", 1);
			int64_t v416 = 0LL /* False */;
			int64_t v417 = 6LL /* C99RT_U64 */;
			VAL v418 = mtw_std_maybe_Maybe_1_Some(MKI64(v417));
			VAL v419 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v411), v412, MKSTR(v413), v414, MKSTR(v415), v416, v418, x3));
			x4 = v419;
		} break;
		case 27LL: { // PRIM_INT_XOR
			decref(x1);
			STR* v420;
			STRLIT(v420, "(", 1);
			int64_t v421 = 6LL /* C99RT_U64 */;
			STR* v422;
			STRLIT(v422, " ^ ", 3);
			int64_t v423 = 6LL /* C99RT_U64 */;
			STR* v424;
			STRLIT(v424, ")", 1);
			int64_t v425 = 0LL /* False */;
			int64_t v426 = 6LL /* C99RT_U64 */;
			VAL v427 = mtw_std_maybe_Maybe_1_Some(MKI64(v426));
			VAL v428 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v420), v421, MKSTR(v422), v423, MKSTR(v424), v425, v427, x3));
			x4 = v428;
		} break;
		case 26LL: { // PRIM_INT_OR
			decref(x1);
			STR* v429;
			STRLIT(v429, "(", 1);
			int64_t v430 = 6LL /* C99RT_U64 */;
			STR* v431;
			STRLIT(v431, " | ", 3);
			int64_t v432 = 6LL /* C99RT_U64 */;
			STR* v433;
			STRLIT(v433, ")", 1);
			int64_t v434 = 0LL /* False */;
			int64_t v435 = 6LL /* C99RT_U64 */;
			VAL v436 = mtw_std_maybe_Maybe_1_Some(MKI64(v435));
			VAL v437 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v429), v430, MKSTR(v431), v432, MKSTR(v433), v434, v436, x3));
			x4 = v437;
		} break;
		case 28LL: { // PRIM_INT_SHL
			decref(x1);
			STR* v438;
			STRLIT(v438, "u64_shl(", 8);
			int64_t v439 = 6LL /* C99RT_U64 */;
			STR* v440;
			STRLIT(v440, ", ", 2);
			int64_t v441 = 6LL /* C99RT_U64 */;
			STR* v442;
			STRLIT(v442, ")", 1);
			int64_t v443 = 0LL /* False */;
			int64_t v444 = 6LL /* C99RT_U64 */;
			VAL v445 = mtw_std_maybe_Maybe_1_Some(MKI64(v444));
			VAL v446 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v438), v439, MKSTR(v440), v441, MKSTR(v442), v443, v445, x3));
			x4 = v446;
		} break;
		case 29LL: { // PRIM_INT_SHR
			decref(x1);
			STR* v447;
			STRLIT(v447, "u64_shr(", 8);
			int64_t v448 = 6LL /* C99RT_U64 */;
			STR* v449;
			STRLIT(v449, ", ", 2);
			int64_t v450 = 6LL /* C99RT_U64 */;
			STR* v451;
			STRLIT(v451, ")", 1);
			int64_t v452 = 0LL /* False */;
			int64_t v453 = 6LL /* C99RT_U64 */;
			VAL v454 = mtw_std_maybe_Maybe_1_Some(MKI64(v453));
			VAL v455 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v447), v448, MKSTR(v449), v450, MKSTR(v451), v452, v454, x3));
			x4 = v455;
		} break;
		case 31LL: { // PRIM_INT_TO_F32
			decref(x1);
			STR* v456;
			STRLIT(v456, "(float)", 7);
			int64_t v457 = 2LL /* C99RT_I64 */;
			STR* v458;
			STRLIT(v458, "", 0);
			int64_t v459 = 11LL /* C99RT_F32 */;
			VAL v460 = mtw_std_maybe_Maybe_1_Some(MKI64(v459));
			VAL v461 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v456), v457, MKSTR(v458), v460, x3));
			x4 = v461;
		} break;
		case 32LL: { // PRIM_INT_TO_F64
			decref(x1);
			STR* v462;
			STRLIT(v462, "(double)", 8);
			int64_t v463 = 2LL /* C99RT_I64 */;
			STR* v464;
			STRLIT(v464, "", 0);
			int64_t v465 = 10LL /* C99RT_F64 */;
			VAL v466 = mtw_std_maybe_Maybe_1_Some(MKI64(v465));
			VAL v467 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v462), v463, MKSTR(v464), v466, x3));
			x4 = v467;
		} break;
		case 30LL: { // PRIM_INT_TO_STR
			decref(x1);
			STR* v468;
			STRLIT(v468, "i64_show(", 9);
			int64_t v469 = 2LL /* C99RT_I64 */;
			STR* v470;
			STRLIT(v470, ")", 1);
			int64_t v471 = 1LL /* C99RT_STR */;
			VAL v472 = mtw_std_maybe_Maybe_1_Some(MKI64(v471));
			VAL v473 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v468), v469, MKSTR(v470), v472, x3));
			x4 = v473;
		} break;
		case 34LL: { // PRIM_F32_LT
			decref(x1);
			STR* v474;
			STRLIT(v474, "(", 1);
			int64_t v475 = 11LL /* C99RT_F32 */;
			STR* v476;
			STRLIT(v476, " < ", 3);
			int64_t v477 = 11LL /* C99RT_F32 */;
			STR* v478;
			STRLIT(v478, ")", 1);
			int64_t v479 = 0LL /* False */;
			int64_t v480 = 12LL /* C99RT_BOOL */;
			VAL v481 = mtw_std_maybe_Maybe_1_Some(MKI64(v480));
			VAL v482 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v474), v475, MKSTR(v476), v477, MKSTR(v478), v479, v481, x3));
			x4 = v482;
		} break;
		case 33LL: { // PRIM_F32_EQ
			decref(x1);
			STR* v483;
			STRLIT(v483, "(", 1);
			int64_t v484 = 11LL /* C99RT_F32 */;
			STR* v485;
			STRLIT(v485, " == ", 4);
			int64_t v486 = 11LL /* C99RT_F32 */;
			STR* v487;
			STRLIT(v487, ")", 1);
			int64_t v488 = 0LL /* False */;
			int64_t v489 = 12LL /* C99RT_BOOL */;
			VAL v490 = mtw_std_maybe_Maybe_1_Some(MKI64(v489));
			VAL v491 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v483), v484, MKSTR(v485), v486, MKSTR(v487), v488, v490, x3));
			x4 = v491;
		} break;
		case 35LL: { // PRIM_F32_ADD
			decref(x1);
			STR* v492;
			STRLIT(v492, "(", 1);
			int64_t v493 = 11LL /* C99RT_F32 */;
			STR* v494;
			STRLIT(v494, " + ", 3);
			int64_t v495 = 11LL /* C99RT_F32 */;
			STR* v496;
			STRLIT(v496, ")", 1);
			int64_t v497 = 0LL /* False */;
			int64_t v498 = 11LL /* C99RT_F32 */;
			VAL v499 = mtw_std_maybe_Maybe_1_Some(MKI64(v498));
			VAL v500 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v492), v493, MKSTR(v494), v495, MKSTR(v496), v497, v499, x3));
			x4 = v500;
		} break;
		case 36LL: { // PRIM_F32_SUB
			decref(x1);
			STR* v501;
			STRLIT(v501, "(", 1);
			int64_t v502 = 11LL /* C99RT_F32 */;
			STR* v503;
			STRLIT(v503, " - ", 3);
			int64_t v504 = 11LL /* C99RT_F32 */;
			STR* v505;
			STRLIT(v505, ")", 1);
			int64_t v506 = 0LL /* False */;
			int64_t v507 = 11LL /* C99RT_F32 */;
			VAL v508 = mtw_std_maybe_Maybe_1_Some(MKI64(v507));
			VAL v509 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v501), v502, MKSTR(v503), v504, MKSTR(v505), v506, v508, x3));
			x4 = v509;
		} break;
		case 37LL: { // PRIM_F32_MUL
			decref(x1);
			STR* v510;
			STRLIT(v510, "(", 1);
			int64_t v511 = 11LL /* C99RT_F32 */;
			STR* v512;
			STRLIT(v512, " * ", 3);
			int64_t v513 = 11LL /* C99RT_F32 */;
			STR* v514;
			STRLIT(v514, ")", 1);
			int64_t v515 = 0LL /* False */;
			int64_t v516 = 11LL /* C99RT_F32 */;
			VAL v517 = mtw_std_maybe_Maybe_1_Some(MKI64(v516));
			VAL v518 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v510), v511, MKSTR(v512), v513, MKSTR(v514), v515, v517, x3));
			x4 = v518;
		} break;
		case 38LL: { // PRIM_F32_DIV
			decref(x1);
			STR* v519;
			STRLIT(v519, "(", 1);
			int64_t v520 = 11LL /* C99RT_F32 */;
			STR* v521;
			STRLIT(v521, " / ", 3);
			int64_t v522 = 11LL /* C99RT_F32 */;
			STR* v523;
			STRLIT(v523, ")", 1);
			int64_t v524 = 0LL /* False */;
			int64_t v525 = 11LL /* C99RT_F32 */;
			VAL v526 = mtw_std_maybe_Maybe_1_Some(MKI64(v525));
			VAL v527 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v519), v520, MKSTR(v521), v522, MKSTR(v523), v524, v526, x3));
			x4 = v527;
		} break;
		case 39LL: { // PRIM_F32_TO_INT
			decref(x1);
			STR* v528;
			STRLIT(v528, "(int64_t)", 9);
			int64_t v529 = 11LL /* C99RT_F32 */;
			STR* v530;
			STRLIT(v530, "", 0);
			int64_t v531 = 2LL /* C99RT_I64 */;
			VAL v532 = mtw_std_maybe_Maybe_1_Some(MKI64(v531));
			VAL v533 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v528), v529, MKSTR(v530), v532, x3));
			x4 = v533;
		} break;
		case 41LL: { // PRIM_F32_TO_F64
			decref(x1);
			STR* v534;
			STRLIT(v534, "(double)", 8);
			int64_t v535 = 11LL /* C99RT_F32 */;
			STR* v536;
			STRLIT(v536, "", 0);
			int64_t v537 = 10LL /* C99RT_F64 */;
			VAL v538 = mtw_std_maybe_Maybe_1_Some(MKI64(v537));
			VAL v539 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v534), v535, MKSTR(v536), v538, x3));
			x4 = v539;
		} break;
		case 40LL: { // PRIM_F32_TO_STR
			decref(x1);
			STR* v540;
			STRLIT(v540, "f32_show(", 9);
			int64_t v541 = 11LL /* C99RT_F32 */;
			STR* v542;
			STRLIT(v542, ")", 1);
			int64_t v543 = 1LL /* C99RT_STR */;
			VAL v544 = mtw_std_maybe_Maybe_1_Some(MKI64(v543));
			VAL v545 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v540), v541, MKSTR(v542), v544, x3));
			x4 = v545;
		} break;
		case 42LL: { // PRIM_F64_EQ
			decref(x1);
			STR* v546;
			STRLIT(v546, "(", 1);
			int64_t v547 = 10LL /* C99RT_F64 */;
			STR* v548;
			STRLIT(v548, " == ", 4);
			int64_t v549 = 10LL /* C99RT_F64 */;
			STR* v550;
			STRLIT(v550, ")", 1);
			int64_t v551 = 0LL /* False */;
			int64_t v552 = 12LL /* C99RT_BOOL */;
			VAL v553 = mtw_std_maybe_Maybe_1_Some(MKI64(v552));
			VAL v554 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v546), v547, MKSTR(v548), v549, MKSTR(v550), v551, v553, x3));
			x4 = v554;
		} break;
		case 43LL: { // PRIM_F64_LT
			decref(x1);
			STR* v555;
			STRLIT(v555, "(", 1);
			int64_t v556 = 10LL /* C99RT_F64 */;
			STR* v557;
			STRLIT(v557, " < ", 3);
			int64_t v558 = 10LL /* C99RT_F64 */;
			STR* v559;
			STRLIT(v559, ")", 1);
			int64_t v560 = 0LL /* False */;
			int64_t v561 = 12LL /* C99RT_BOOL */;
			VAL v562 = mtw_std_maybe_Maybe_1_Some(MKI64(v561));
			VAL v563 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v555), v556, MKSTR(v557), v558, MKSTR(v559), v560, v562, x3));
			x4 = v563;
		} break;
		case 44LL: { // PRIM_F64_ADD
			decref(x1);
			STR* v564;
			STRLIT(v564, "(", 1);
			int64_t v565 = 10LL /* C99RT_F64 */;
			STR* v566;
			STRLIT(v566, " + ", 3);
			int64_t v567 = 10LL /* C99RT_F64 */;
			STR* v568;
			STRLIT(v568, ")", 1);
			int64_t v569 = 0LL /* False */;
			int64_t v570 = 10LL /* C99RT_F64 */;
			VAL v571 = mtw_std_maybe_Maybe_1_Some(MKI64(v570));
			VAL v572 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v564), v565, MKSTR(v566), v567, MKSTR(v568), v569, v571, x3));
			x4 = v572;
		} break;
		case 45LL: { // PRIM_F64_SUB
			decref(x1);
			STR* v573;
			STRLIT(v573, "(", 1);
			int64_t v574 = 10LL /* C99RT_F64 */;
			STR* v575;
			STRLIT(v575, " - ", 3);
			int64_t v576 = 10LL /* C99RT_F64 */;
			STR* v577;
			STRLIT(v577, ")", 1);
			int64_t v578 = 0LL /* False */;
			int64_t v579 = 10LL /* C99RT_F64 */;
			VAL v580 = mtw_std_maybe_Maybe_1_Some(MKI64(v579));
			VAL v581 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v573), v574, MKSTR(v575), v576, MKSTR(v577), v578, v580, x3));
			x4 = v581;
		} break;
		case 46LL: { // PRIM_F64_MUL
			decref(x1);
			STR* v582;
			STRLIT(v582, "(", 1);
			int64_t v583 = 10LL /* C99RT_F64 */;
			STR* v584;
			STRLIT(v584, " * ", 3);
			int64_t v585 = 10LL /* C99RT_F64 */;
			STR* v586;
			STRLIT(v586, ")", 1);
			int64_t v587 = 0LL /* False */;
			int64_t v588 = 10LL /* C99RT_F64 */;
			VAL v589 = mtw_std_maybe_Maybe_1_Some(MKI64(v588));
			VAL v590 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v582), v583, MKSTR(v584), v585, MKSTR(v586), v587, v589, x3));
			x4 = v590;
		} break;
		case 47LL: { // PRIM_F64_DIV
			decref(x1);
			STR* v591;
			STRLIT(v591, "(", 1);
			int64_t v592 = 10LL /* C99RT_F64 */;
			STR* v593;
			STRLIT(v593, " / ", 3);
			int64_t v594 = 10LL /* C99RT_F64 */;
			STR* v595;
			STRLIT(v595, ")", 1);
			int64_t v596 = 0LL /* False */;
			int64_t v597 = 10LL /* C99RT_F64 */;
			VAL v598 = mtw_std_maybe_Maybe_1_Some(MKI64(v597));
			VAL v599 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v591), v592, MKSTR(v593), v594, MKSTR(v595), v596, v598, x3));
			x4 = v599;
		} break;
		case 48LL: { // PRIM_F64_TO_INT
			decref(x1);
			STR* v600;
			STRLIT(v600, "(int64_t)", 9);
			int64_t v601 = 10LL /* C99RT_F64 */;
			STR* v602;
			STRLIT(v602, "", 0);
			int64_t v603 = 2LL /* C99RT_I64 */;
			VAL v604 = mtw_std_maybe_Maybe_1_Some(MKI64(v603));
			VAL v605 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v600), v601, MKSTR(v602), v604, x3));
			x4 = v605;
		} break;
		case 50LL: { // PRIM_F64_TO_F32
			decref(x1);
			STR* v606;
			STRLIT(v606, "(float)", 7);
			int64_t v607 = 10LL /* C99RT_F64 */;
			STR* v608;
			STRLIT(v608, "", 0);
			int64_t v609 = 11LL /* C99RT_F32 */;
			VAL v610 = mtw_std_maybe_Maybe_1_Some(MKI64(v609));
			VAL v611 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v606), v607, MKSTR(v608), v610, x3));
			x4 = v611;
		} break;
		case 49LL: { // PRIM_F64_TO_STR
			decref(x1);
			STR* v612;
			STRLIT(v612, "f64_show(", 9);
			int64_t v613 = 10LL /* C99RT_F64 */;
			STR* v614;
			STRLIT(v614, ")", 1);
			int64_t v615 = 1LL /* C99RT_STR */;
			VAL v616 = mtw_std_maybe_Maybe_1_Some(MKI64(v615));
			VAL v617 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v612), v613, MKSTR(v614), v616, x3));
			x4 = v617;
		} break;
		case 51LL: { // PRIM_BOOL_AND
			decref(x1);
			STR* v618;
			STRLIT(v618, "(", 1);
			int64_t v619 = 12LL /* C99RT_BOOL */;
			STR* v620;
			STRLIT(v620, " && ", 4);
			int64_t v621 = 12LL /* C99RT_BOOL */;
			STR* v622;
			STRLIT(v622, ")", 1);
			int64_t v623 = 0LL /* False */;
			int64_t v624 = 12LL /* C99RT_BOOL */;
			VAL v625 = mtw_std_maybe_Maybe_1_Some(MKI64(v624));
			VAL v626 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v618), v619, MKSTR(v620), v621, MKSTR(v622), v623, v625, x3));
			x4 = v626;
		} break;
		case 52LL: { // PRIM_BOOL_OR
			decref(x1);
			STR* v627;
			STRLIT(v627, "(", 1);
			int64_t v628 = 12LL /* C99RT_BOOL */;
			STR* v629;
			STRLIT(v629, " || ", 4);
			int64_t v630 = 12LL /* C99RT_BOOL */;
			STR* v631;
			STRLIT(v631, ")", 1);
			int64_t v632 = 0LL /* False */;
			int64_t v633 = 12LL /* C99RT_BOOL */;
			VAL v634 = mtw_std_maybe_Maybe_1_Some(MKI64(v633));
			VAL v635 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v627), v628, MKSTR(v629), v630, MKSTR(v631), v632, v634, x3));
			x4 = v635;
		} break;
		case 53LL: { // PRIM_BOOL_NOT
			decref(x1);
			STR* v636;
			STRLIT(v636, "!", 1);
			int64_t v637 = 12LL /* C99RT_BOOL */;
			STR* v638;
			STRLIT(v638, "", 0);
			int64_t v639 = 12LL /* C99RT_BOOL */;
			VAL v640 = mtw_std_maybe_Maybe_1_Some(MKI64(v639));
			VAL v641 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v636), v637, MKSTR(v638), v640, x3));
			x4 = v641;
		} break;
		case 54LL: { // PRIM_PACK_NIL
			decref(x1);
			int64_t v642 = 0LL /* C99RT_VAL */;
			VAL v643 = (VVAL(VTUP(x3)->cells[1]));
			VAL v644;
			VAL v645;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v643, &v644, &v645);
			VAL v646 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v642, v644));
			VAL v647 = (mw_mirth_c99_ZPlusC99_indent(v645));
			int64_t v648 = VI64(VTUP(v646)->cells[1]);
			VAL v649 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v648);
			VAL v650 = (mw_mirth_c99_ZPlusC99_put(v649, v647));
			STR* v651;
			STRLIT(v651, " ", 1);
			VAL v652 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v651), v650));
			VAL v653 = VVAL(VTUP(v646)->cells[2]);
			incref(v653);
			VAL v654 = (mw_mirth_c99_ZPlusC99_put(v653, v652));
			STR* v655;
			STRLIT(v655, " = ", 3);
			VAL v656 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v655), v654));
			STR* v657;
			STRLIT(v657, "MKNIL", 5);
			VAL v658 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v657), v656));
			STR* v659;
			STRLIT(v659, ";", 1);
			VAL v660 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v659), v658));
			VAL v661 = (mw_mirth_c99_ZPlusC99_line(v660));
			VTUP(x3)->cells[1] = v661;
			VAL v662 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v646));
			x4 = v662;
		} break;
		case 55LL: { // PRIM_PACK_CONS
			decref(x1);
			STR* v663;
			STRLIT(v663, "mkcons(", 7);
			int64_t v664 = 0LL /* C99RT_VAL */;
			STR* v665;
			STRLIT(v665, ", ", 2);
			int64_t v666 = 0LL /* C99RT_VAL */;
			STR* v667;
			STRLIT(v667, ")", 1);
			int64_t v668 = 0LL /* False */;
			int64_t v669 = 0LL /* C99RT_VAL */;
			VAL v670 = mtw_std_maybe_Maybe_1_Some(MKI64(v669));
			VAL v671 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v663), v664, MKSTR(v665), v666, MKSTR(v667), v668, v670, x3));
			x4 = v671;
		} break;
		case 56LL: { // PRIM_PACK_UNCONS
			decref(x1);
			int64_t v672 = 0LL /* C99RT_VAL */;
			VAL v673;
			VAL v674;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v672, &v673, &v674);
			int64_t v675 = 0LL /* C99RT_VAL */;
			VAL v676;
			VAL v677;
			mw_mirth_c99_C99ReprType_newZ_localZBang(v675, v673, &v676, &v677);
			int64_t v678 = 0LL /* C99RT_VAL */;
			VAL v679;
			VAL v680;
			mw_mirth_c99_C99ReprType_newZ_localZBang(v678, v676, &v679, &v680);
			VAL v681 = (VVAL(VTUP(v679)->cells[1]));
			VAL v682 = (mw_mirth_c99_ZPlusC99_indent(v681));
			STR* v683;
			STRLIT(v683, "value_uncons(", 13);
			VAL v684 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v683), v682));
			VAL v685 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v674);
			VAL v686 = (mw_mirth_c99_ZPlusC99_put(v685, v684));
			STR* v687;
			STRLIT(v687, ", &", 3);
			VAL v688 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v687), v686));
			VAL v689 = VVAL(VTUP(v677)->cells[2]);
			incref(v689);
			VAL v690 = (mw_mirth_c99_ZPlusC99_put(v689, v688));
			STR* v691;
			STRLIT(v691, ", &", 3);
			VAL v692 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v691), v690));
			VAL v693 = VVAL(VTUP(v680)->cells[2]);
			incref(v693);
			VAL v694 = (mw_mirth_c99_ZPlusC99_put(v693, v692));
			STR* v695;
			STRLIT(v695, ");", 2);
			VAL v696 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v695), v694));
			VAL v697 = (mw_mirth_c99_ZPlusC99_line(v696));
			VTUP(v679)->cells[1] = v697;
			VAL v698 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v679, v677));
			VAL v699 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v698, v680));
			x4 = v699;
		} break;
		case 57LL: { // PRIM_MUT_GET
			decref(x1);
			STR* v700;
			STRLIT(v700, "mut_get(", 8);
			int64_t v701 = 13LL /* C99RT_PTR */;
			STR* v702;
			STRLIT(v702, ")", 1);
			int64_t v703 = 0LL /* C99RT_VAL */;
			VAL v704 = mtw_std_maybe_Maybe_1_Some(MKI64(v703));
			VAL v705 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v700), v701, MKSTR(v702), v704, x3));
			x4 = v705;
		} break;
		case 58LL: { // PRIM_MUT_SET
			decref(x1);
			STR* v706;
			STRLIT(v706, "mut_set(", 8);
			int64_t v707 = 0LL /* C99RT_VAL */;
			STR* v708;
			STRLIT(v708, ", ", 2);
			int64_t v709 = 13LL /* C99RT_PTR */;
			STR* v710;
			STRLIT(v710, ");", 2);
			int64_t v711 = 0LL /* False */;
			VAL v712 = MKI64(0LL /* None */);
			VAL v713 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v706), v707, MKSTR(v708), v709, MKSTR(v710), v711, v712, x3));
			x4 = v713;
		} break;
		case 59LL: { // PRIM_MUT_IS_SET
			decref(x1);
			STR* v714;
			STRLIT(v714, "mut_is_set(", 11);
			int64_t v715 = 13LL /* C99RT_PTR */;
			STR* v716;
			STRLIT(v716, ")", 1);
			int64_t v717 = 12LL /* C99RT_BOOL */;
			VAL v718 = mtw_std_maybe_Maybe_1_Some(MKI64(v717));
			VAL v719 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v714), v715, MKSTR(v716), v718, x3));
			x4 = v719;
		} break;
		case 60LL: { // PRIM_PTR_NIL
			decref(x1);
			int64_t v720 = 13LL /* C99RT_PTR */;
			VAL v721 = (VVAL(VTUP(x3)->cells[1]));
			VAL v722;
			VAL v723;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v721, &v722, &v723);
			VAL v724 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v720, v722));
			VAL v725 = (mw_mirth_c99_ZPlusC99_indent(v723));
			int64_t v726 = VI64(VTUP(v724)->cells[1]);
			VAL v727 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v726);
			VAL v728 = (mw_mirth_c99_ZPlusC99_put(v727, v725));
			STR* v729;
			STRLIT(v729, " ", 1);
			VAL v730 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v729), v728));
			VAL v731 = VVAL(VTUP(v724)->cells[2]);
			incref(v731);
			VAL v732 = (mw_mirth_c99_ZPlusC99_put(v731, v730));
			STR* v733;
			STRLIT(v733, " = ", 3);
			VAL v734 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v733), v732));
			STR* v735;
			STRLIT(v735, "(void*)0", 8);
			VAL v736 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v735), v734));
			STR* v737;
			STRLIT(v737, ";", 1);
			VAL v738 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v737), v736));
			VAL v739 = (mw_mirth_c99_ZPlusC99_line(v738));
			VTUP(x3)->cells[1] = v739;
			VAL v740 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v724));
			x4 = v740;
		} break;
		case 61LL: { // PRIM_PTR_EQ
			decref(x1);
			STR* v741;
			STRLIT(v741, "(", 1);
			int64_t v742 = 13LL /* C99RT_PTR */;
			STR* v743;
			STRLIT(v743, " == ", 4);
			int64_t v744 = 13LL /* C99RT_PTR */;
			STR* v745;
			STRLIT(v745, ")", 1);
			int64_t v746 = 0LL /* False */;
			int64_t v747 = 12LL /* C99RT_BOOL */;
			VAL v748 = mtw_std_maybe_Maybe_1_Some(MKI64(v747));
			VAL v749 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v741), v742, MKSTR(v743), v744, MKSTR(v745), v746, v748, x3));
			x4 = v749;
		} break;
		case 62LL: { // PRIM_PTR_ADD
			decref(x1);
			STR* v750;
			STRLIT(v750, "(void*)(", 8);
			int64_t v751 = 2LL /* C99RT_I64 */;
			STR* v752;
			STRLIT(v752, " + (char*)", 10);
			int64_t v753 = 13LL /* C99RT_PTR */;
			STR* v754;
			STRLIT(v754, ")", 1);
			int64_t v755 = 0LL /* False */;
			int64_t v756 = 13LL /* C99RT_PTR */;
			VAL v757 = mtw_std_maybe_Maybe_1_Some(MKI64(v756));
			VAL v758 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v750), v751, MKSTR(v752), v753, MKSTR(v754), v755, v757, x3));
			x4 = v758;
		} break;
		case 63LL: { // PRIM_PTR_SIZE
			decref(x1);
			int64_t v759 = 6LL /* C99RT_U64 */;
			VAL v760 = (VVAL(VTUP(x3)->cells[1]));
			VAL v761;
			VAL v762;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v760, &v761, &v762);
			VAL v763 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v759, v761));
			VAL v764 = (mw_mirth_c99_ZPlusC99_indent(v762));
			int64_t v765 = VI64(VTUP(v763)->cells[1]);
			VAL v766 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v765);
			VAL v767 = (mw_mirth_c99_ZPlusC99_put(v766, v764));
			STR* v768;
			STRLIT(v768, " ", 1);
			VAL v769 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v768), v767));
			VAL v770 = VVAL(VTUP(v763)->cells[2]);
			incref(v770);
			VAL v771 = (mw_mirth_c99_ZPlusC99_put(v770, v769));
			STR* v772;
			STRLIT(v772, " = ", 3);
			VAL v773 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v772), v771));
			STR* v774;
			STRLIT(v774, "sizeof(void*)", 13);
			VAL v775 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v774), v773));
			STR* v776;
			STRLIT(v776, ";", 1);
			VAL v777 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v776), v775));
			VAL v778 = (mw_mirth_c99_ZPlusC99_line(v777));
			VTUP(x3)->cells[1] = v778;
			VAL v779 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v763));
			x4 = v779;
		} break;
		case 64LL: { // PRIM_PTR_ALLOC
			decref(x1);
			STR* v780;
			STRLIT(v780, "ptr_alloc(", 10);
			int64_t v781 = 6LL /* C99RT_U64 */;
			STR* v782;
			STRLIT(v782, ");", 2);
			int64_t v783 = 13LL /* C99RT_PTR */;
			VAL v784 = mtw_std_maybe_Maybe_1_Some(MKI64(v783));
			VAL v785 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v780), v781, MKSTR(v782), v784, x3));
			x4 = v785;
		} break;
		case 65LL: { // PRIM_PTR_REALLOC
			decref(x1);
			STR* v786;
			STRLIT(v786, "ptr_realloc(", 12);
			int64_t v787 = 13LL /* C99RT_PTR */;
			STR* v788;
			STRLIT(v788, ",", 1);
			int64_t v789 = 6LL /* C99RT_U64 */;
			STR* v790;
			STRLIT(v790, ")", 1);
			int64_t v791 = 0LL /* False */;
			int64_t v792 = 13LL /* C99RT_PTR */;
			VAL v793 = mtw_std_maybe_Maybe_1_Some(MKI64(v792));
			VAL v794 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v786), v787, MKSTR(v788), v789, MKSTR(v790), v791, v793, x3));
			x4 = v794;
		} break;
		case 66LL: { // PRIM_PTR_FREE
			decref(x1);
			STR* v795;
			STRLIT(v795, "free(", 5);
			int64_t v796 = 13LL /* C99RT_PTR */;
			STR* v797;
			STRLIT(v797, ");", 2);
			VAL v798 = MKI64(0LL /* None */);
			VAL v799 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v795), v796, MKSTR(v797), v798, x3));
			x4 = v799;
		} break;
		case 67LL: { // PRIM_PTR_COPY
			decref(x1);
			int64_t v800 = 13LL /* C99RT_PTR */;
			VAL v801;
			VAL v802;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v800, &v801, &v802);
			int64_t v803 = 6LL /* C99RT_U64 */;
			VAL v804;
			VAL v805;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v801, v803, &v804, &v805);
			int64_t v806 = 13LL /* C99RT_PTR */;
			VAL v807;
			VAL v808;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v804, v806, &v807, &v808);
			VAL v809 = (VVAL(VTUP(v807)->cells[1]));
			VAL v810 = (mw_mirth_c99_ZPlusC99_indent(v809));
			STR* v811;
			STRLIT(v811, "ptr_copy(", 9);
			VAL v812 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v811), v810));
			int64_t v813 = 13LL /* C99RT_PTR */;
			VAL v814 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v813, v808);
			VAL v815 = (mw_mirth_c99_ZPlusC99_put(v814, v812));
			STR* v816;
			STRLIT(v816, ", ", 2);
			VAL v817 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v816), v815));
			int64_t v818 = 6LL /* C99RT_U64 */;
			VAL v819 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v818, v805);
			VAL v820 = (mw_mirth_c99_ZPlusC99_put(v819, v817));
			STR* v821;
			STRLIT(v821, ", ", 2);
			VAL v822 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v821), v820));
			int64_t v823 = 13LL /* C99RT_PTR */;
			VAL v824 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v823, v802);
			VAL v825 = (mw_mirth_c99_ZPlusC99_put(v824, v822));
			STR* v826;
			STRLIT(v826, ");", 2);
			VAL v827 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v826), v825));
			VAL v828 = (mw_mirth_c99_ZPlusC99_line(v827));
			VTUP(v807)->cells[1] = v828;
			x4 = v807;
		} break;
		case 68LL: { // PRIM_PTR_FILL
			decref(x1);
			int64_t v829 = 13LL /* C99RT_PTR */;
			VAL v830;
			VAL v831;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v829, &v830, &v831);
			int64_t v832 = 6LL /* C99RT_U64 */;
			VAL v833;
			VAL v834;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v830, v832, &v833, &v834);
			int64_t v835 = 9LL /* C99RT_U8 */;
			VAL v836;
			VAL v837;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v833, v835, &v836, &v837);
			VAL v838 = (VVAL(VTUP(v836)->cells[1]));
			VAL v839 = (mw_mirth_c99_ZPlusC99_indent(v838));
			STR* v840;
			STRLIT(v840, "ptr_fill(", 9);
			VAL v841 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v840), v839));
			int64_t v842 = 9LL /* C99RT_U8 */;
			VAL v843 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v842, v837);
			VAL v844 = (mw_mirth_c99_ZPlusC99_put(v843, v841));
			STR* v845;
			STRLIT(v845, ", ", 2);
			VAL v846 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v845), v844));
			int64_t v847 = 6LL /* C99RT_U64 */;
			VAL v848 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v847, v834);
			VAL v849 = (mw_mirth_c99_ZPlusC99_put(v848, v846));
			STR* v850;
			STRLIT(v850, ", ", 2);
			VAL v851 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v850), v849));
			int64_t v852 = 13LL /* C99RT_PTR */;
			VAL v853 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v852, v831);
			VAL v854 = (mw_mirth_c99_ZPlusC99_put(v853, v851));
			STR* v855;
			STRLIT(v855, ");", 2);
			VAL v856 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v855), v854));
			VAL v857 = (mw_mirth_c99_ZPlusC99_line(v856));
			VTUP(v836)->cells[1] = v857;
			x4 = v836;
		} break;
		case 69LL: { // PRIM_STR_COPY
			decref(x1);
			STR* v858;
			STRLIT(v858, "str_make(", 9);
			int64_t v859 = 13LL /* C99RT_PTR */;
			STR* v860;
			STRLIT(v860, ", ", 2);
			int64_t v861 = 6LL /* C99RT_U64 */;
			STR* v862;
			STRLIT(v862, ")", 1);
			int64_t v863 = 0LL /* False */;
			int64_t v864 = 1LL /* C99RT_STR */;
			VAL v865 = mtw_std_maybe_Maybe_1_Some(MKI64(v864));
			VAL v866 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v858), v859, MKSTR(v860), v861, MKSTR(v862), v863, v865, x3));
			x4 = v866;
		} break;
		case 70LL: { // PRIM_STR_NUM_BYTES
			decref(x1);
			STR* v867;
			STRLIT(v867, "str_size(", 9);
			int64_t v868 = 1LL /* C99RT_STR */;
			STR* v869;
			STRLIT(v869, ")", 1);
			int64_t v870 = 6LL /* C99RT_U64 */;
			VAL v871 = mtw_std_maybe_Maybe_1_Some(MKI64(v870));
			VAL v872 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v867), v868, MKSTR(v869), v871, x3));
			x4 = v872;
		} break;
		case 71LL: { // PRIM_STR_BASE
			decref(x1);
			STR* v873;
			STRLIT(v873, "str_base(", 9);
			int64_t v874 = 1LL /* C99RT_STR */;
			STR* v875;
			STRLIT(v875, ")", 1);
			int64_t v876 = 13LL /* C99RT_PTR */;
			VAL v877 = mtw_std_maybe_Maybe_1_Some(MKI64(v876));
			VAL v878 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v873), v874, MKSTR(v875), v877, x3));
			x4 = v878;
		} break;
		case 72LL: { // PRIM_STR_CAT
			decref(x1);
			STR* v879;
			STRLIT(v879, "str_cat(", 8);
			int64_t v880 = 1LL /* C99RT_STR */;
			STR* v881;
			STRLIT(v881, ", ", 2);
			int64_t v882 = 1LL /* C99RT_STR */;
			STR* v883;
			STRLIT(v883, ")", 1);
			int64_t v884 = 0LL /* False */;
			int64_t v885 = 1LL /* C99RT_STR */;
			VAL v886 = mtw_std_maybe_Maybe_1_Some(MKI64(v885));
			VAL v887 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v879), v880, MKSTR(v881), v882, MKSTR(v883), v884, v886, x3));
			x4 = v887;
		} break;
		case 73LL: { // PRIM_STR_CMP
			decref(x1);
			STR* v888;
			STRLIT(v888, "str_cmp(", 8);
			int64_t v889 = 1LL /* C99RT_STR */;
			STR* v890;
			STRLIT(v890, ", ", 2);
			int64_t v891 = 1LL /* C99RT_STR */;
			STR* v892;
			STRLIT(v892, ")", 1);
			int64_t v893 = 0LL /* False */;
			int64_t v894 = 2LL /* C99RT_I64 */;
			VAL v895 = mtw_std_maybe_Maybe_1_Some(MKI64(v894));
			VAL v896 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v888), v889, MKSTR(v890), v891, MKSTR(v892), v893, v895, x3));
			x4 = v896;
		} break;
		case 74LL: { // PRIM_STR_EQ
			decref(x1);
			STR* v897;
			STRLIT(v897, "(str_cmp(", 9);
			int64_t v898 = 1LL /* C99RT_STR */;
			STR* v899;
			STRLIT(v899, ", ", 2);
			int64_t v900 = 1LL /* C99RT_STR */;
			STR* v901;
			STRLIT(v901, ") == 0)", 7);
			int64_t v902 = 0LL /* False */;
			int64_t v903 = 12LL /* C99RT_BOOL */;
			VAL v904 = mtw_std_maybe_Maybe_1_Some(MKI64(v903));
			VAL v905 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v897), v898, MKSTR(v899), v900, MKSTR(v901), v902, v904, x3));
			x4 = v905;
		} break;
		case 75LL: { // PRIM_STR_LT
			decref(x1);
			STR* v906;
			STRLIT(v906, "(str_cmp(", 9);
			int64_t v907 = 1LL /* C99RT_STR */;
			STR* v908;
			STRLIT(v908, ", ", 2);
			int64_t v909 = 1LL /* C99RT_STR */;
			STR* v910;
			STRLIT(v910, ") < 0)", 6);
			int64_t v911 = 0LL /* False */;
			int64_t v912 = 12LL /* C99RT_BOOL */;
			VAL v913 = mtw_std_maybe_Maybe_1_Some(MKI64(v912));
			VAL v914 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v906), v907, MKSTR(v908), v909, MKSTR(v910), v911, v913, x3));
			x4 = v914;
		} break;
		case 76LL: { // PRIM_STR_LE
			decref(x1);
			STR* v915;
			STRLIT(v915, "(str_cmp(", 9);
			int64_t v916 = 1LL /* C99RT_STR */;
			STR* v917;
			STRLIT(v917, ", ", 2);
			int64_t v918 = 1LL /* C99RT_STR */;
			STR* v919;
			STRLIT(v919, ") <= 0)", 7);
			int64_t v920 = 0LL /* False */;
			int64_t v921 = 12LL /* C99RT_BOOL */;
			VAL v922 = mtw_std_maybe_Maybe_1_Some(MKI64(v921));
			VAL v923 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v915), v916, MKSTR(v917), v918, MKSTR(v919), v920, v922, x3));
			x4 = v923;
		} break;
		case 77LL: { // PRIM_STR_GT
			decref(x1);
			STR* v924;
			STRLIT(v924, "(str_cmp(", 9);
			int64_t v925 = 1LL /* C99RT_STR */;
			STR* v926;
			STRLIT(v926, ", ", 2);
			int64_t v927 = 1LL /* C99RT_STR */;
			STR* v928;
			STRLIT(v928, ") > 0)", 6);
			int64_t v929 = 0LL /* False */;
			int64_t v930 = 12LL /* C99RT_BOOL */;
			VAL v931 = mtw_std_maybe_Maybe_1_Some(MKI64(v930));
			VAL v932 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v924), v925, MKSTR(v926), v927, MKSTR(v928), v929, v931, x3));
			x4 = v932;
		} break;
		case 78LL: { // PRIM_STR_GE
			decref(x1);
			STR* v933;
			STRLIT(v933, "(str_cmp(", 9);
			int64_t v934 = 1LL /* C99RT_STR */;
			STR* v935;
			STRLIT(v935, ", ", 2);
			int64_t v936 = 1LL /* C99RT_STR */;
			STR* v937;
			STRLIT(v937, ") >= 0)", 7);
			int64_t v938 = 0LL /* False */;
			int64_t v939 = 12LL /* C99RT_BOOL */;
			VAL v940 = mtw_std_maybe_Maybe_1_Some(MKI64(v939));
			VAL v941 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v933), v934, MKSTR(v935), v936, MKSTR(v937), v938, v940, x3));
			x4 = v941;
		} break;
		case 79LL: { // PRIM_STR_NE
			decref(x1);
			STR* v942;
			STRLIT(v942, "(str_cmp(", 9);
			int64_t v943 = 1LL /* C99RT_STR */;
			STR* v944;
			STRLIT(v944, ", ", 2);
			int64_t v945 = 1LL /* C99RT_STR */;
			STR* v946;
			STRLIT(v946, ") != 0)", 7);
			int64_t v947 = 0LL /* False */;
			int64_t v948 = 12LL /* C99RT_BOOL */;
			VAL v949 = mtw_std_maybe_Maybe_1_Some(MKI64(v948));
			VAL v950 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v942), v943, MKSTR(v944), v945, MKSTR(v946), v947, v949, x3));
			x4 = v950;
		} break;
		case 80LL: { // PRIM_U8_GET
			decref(x1);
			STR* v951;
			STRLIT(v951, "*(uint8_t*)", 11);
			int64_t v952 = 13LL /* C99RT_PTR */;
			STR* v953;
			STRLIT(v953, "", 0);
			int64_t v954 = 9LL /* C99RT_U8 */;
			VAL v955 = mtw_std_maybe_Maybe_1_Some(MKI64(v954));
			VAL v956 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v951), v952, MKSTR(v953), v955, x3));
			x4 = v956;
		} break;
		case 81LL: { // PRIM_U16_GET
			decref(x1);
			STR* v957;
			STRLIT(v957, "*(uint16_t*)", 12);
			int64_t v958 = 13LL /* C99RT_PTR */;
			STR* v959;
			STRLIT(v959, "", 0);
			int64_t v960 = 8LL /* C99RT_U16 */;
			VAL v961 = mtw_std_maybe_Maybe_1_Some(MKI64(v960));
			VAL v962 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v957), v958, MKSTR(v959), v961, x3));
			x4 = v962;
		} break;
		case 82LL: { // PRIM_U32_GET
			decref(x1);
			STR* v963;
			STRLIT(v963, "*(uint32_t*)", 12);
			int64_t v964 = 13LL /* C99RT_PTR */;
			STR* v965;
			STRLIT(v965, "", 0);
			int64_t v966 = 7LL /* C99RT_U32 */;
			VAL v967 = mtw_std_maybe_Maybe_1_Some(MKI64(v966));
			VAL v968 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v963), v964, MKSTR(v965), v967, x3));
			x4 = v968;
		} break;
		case 83LL: { // PRIM_U64_GET
			decref(x1);
			STR* v969;
			STRLIT(v969, "*(uint64_t*)", 12);
			int64_t v970 = 13LL /* C99RT_PTR */;
			STR* v971;
			STRLIT(v971, "", 0);
			int64_t v972 = 6LL /* C99RT_U64 */;
			VAL v973 = mtw_std_maybe_Maybe_1_Some(MKI64(v972));
			VAL v974 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v969), v970, MKSTR(v971), v973, x3));
			x4 = v974;
		} break;
		case 84LL: { // PRIM_I8_GET
			decref(x1);
			STR* v975;
			STRLIT(v975, "*(int8_t*)", 10);
			int64_t v976 = 13LL /* C99RT_PTR */;
			STR* v977;
			STRLIT(v977, "", 0);
			int64_t v978 = 5LL /* C99RT_I8 */;
			VAL v979 = mtw_std_maybe_Maybe_1_Some(MKI64(v978));
			VAL v980 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v975), v976, MKSTR(v977), v979, x3));
			x4 = v980;
		} break;
		case 85LL: { // PRIM_I16_GET
			decref(x1);
			STR* v981;
			STRLIT(v981, "*(int16_t*)", 11);
			int64_t v982 = 13LL /* C99RT_PTR */;
			STR* v983;
			STRLIT(v983, "", 0);
			int64_t v984 = 4LL /* C99RT_I16 */;
			VAL v985 = mtw_std_maybe_Maybe_1_Some(MKI64(v984));
			VAL v986 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v981), v982, MKSTR(v983), v985, x3));
			x4 = v986;
		} break;
		case 86LL: { // PRIM_I32_GET
			decref(x1);
			STR* v987;
			STRLIT(v987, "*(int32_t*)", 11);
			int64_t v988 = 13LL /* C99RT_PTR */;
			STR* v989;
			STRLIT(v989, "", 0);
			int64_t v990 = 3LL /* C99RT_I32 */;
			VAL v991 = mtw_std_maybe_Maybe_1_Some(MKI64(v990));
			VAL v992 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v987), v988, MKSTR(v989), v991, x3));
			x4 = v992;
		} break;
		case 87LL: { // PRIM_I64_GET
			decref(x1);
			STR* v993;
			STRLIT(v993, "*(int64_t*)", 11);
			int64_t v994 = 13LL /* C99RT_PTR */;
			STR* v995;
			STRLIT(v995, "", 0);
			int64_t v996 = 2LL /* C99RT_I64 */;
			VAL v997 = mtw_std_maybe_Maybe_1_Some(MKI64(v996));
			VAL v998 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v993), v994, MKSTR(v995), v997, x3));
			x4 = v998;
		} break;
		case 88LL: { // PRIM_PTR_GET
			decref(x1);
			STR* v999;
			STRLIT(v999, "*(void**)", 9);
			int64_t v1000 = 13LL /* C99RT_PTR */;
			STR* v1001;
			STRLIT(v1001, "", 0);
			int64_t v1002 = 13LL /* C99RT_PTR */;
			VAL v1003 = mtw_std_maybe_Maybe_1_Some(MKI64(v1002));
			VAL v1004 = (mw_mirth_c99_c99Z_unopZBang(MKSTR(v999), v1000, MKSTR(v1001), v1003, x3));
			x4 = v1004;
		} break;
		case 89LL: { // PRIM_U8_SET
			decref(x1);
			STR* v1005;
			STRLIT(v1005, "*(uint8_t*)", 11);
			int64_t v1006 = 13LL /* C99RT_PTR */;
			STR* v1007;
			STRLIT(v1007, " = ", 3);
			int64_t v1008 = 9LL /* C99RT_U8 */;
			STR* v1009;
			STRLIT(v1009, ";", 1);
			int64_t v1010 = 1LL /* True */;
			VAL v1011 = MKI64(0LL /* None */);
			VAL v1012 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1005), v1006, MKSTR(v1007), v1008, MKSTR(v1009), v1010, v1011, x3));
			x4 = v1012;
		} break;
		case 90LL: { // PRIM_U16_SET
			decref(x1);
			STR* v1013;
			STRLIT(v1013, "*(uint16_t*)", 12);
			int64_t v1014 = 13LL /* C99RT_PTR */;
			STR* v1015;
			STRLIT(v1015, " = ", 3);
			int64_t v1016 = 8LL /* C99RT_U16 */;
			STR* v1017;
			STRLIT(v1017, ";", 1);
			int64_t v1018 = 1LL /* True */;
			VAL v1019 = MKI64(0LL /* None */);
			VAL v1020 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1013), v1014, MKSTR(v1015), v1016, MKSTR(v1017), v1018, v1019, x3));
			x4 = v1020;
		} break;
		case 91LL: { // PRIM_U32_SET
			decref(x1);
			STR* v1021;
			STRLIT(v1021, "*(uint32_t*)", 12);
			int64_t v1022 = 13LL /* C99RT_PTR */;
			STR* v1023;
			STRLIT(v1023, " = ", 3);
			int64_t v1024 = 7LL /* C99RT_U32 */;
			STR* v1025;
			STRLIT(v1025, ";", 1);
			int64_t v1026 = 1LL /* True */;
			VAL v1027 = MKI64(0LL /* None */);
			VAL v1028 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1021), v1022, MKSTR(v1023), v1024, MKSTR(v1025), v1026, v1027, x3));
			x4 = v1028;
		} break;
		case 92LL: { // PRIM_U64_SET
			decref(x1);
			STR* v1029;
			STRLIT(v1029, "*(uint64_t*)", 12);
			int64_t v1030 = 13LL /* C99RT_PTR */;
			STR* v1031;
			STRLIT(v1031, " = ", 3);
			int64_t v1032 = 6LL /* C99RT_U64 */;
			STR* v1033;
			STRLIT(v1033, ";", 1);
			int64_t v1034 = 1LL /* True */;
			VAL v1035 = MKI64(0LL /* None */);
			VAL v1036 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1029), v1030, MKSTR(v1031), v1032, MKSTR(v1033), v1034, v1035, x3));
			x4 = v1036;
		} break;
		case 93LL: { // PRIM_I8_SET
			decref(x1);
			STR* v1037;
			STRLIT(v1037, "*(int8_t*)", 10);
			int64_t v1038 = 13LL /* C99RT_PTR */;
			STR* v1039;
			STRLIT(v1039, " = ", 3);
			int64_t v1040 = 5LL /* C99RT_I8 */;
			STR* v1041;
			STRLIT(v1041, ";", 1);
			int64_t v1042 = 1LL /* True */;
			VAL v1043 = MKI64(0LL /* None */);
			VAL v1044 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1037), v1038, MKSTR(v1039), v1040, MKSTR(v1041), v1042, v1043, x3));
			x4 = v1044;
		} break;
		case 94LL: { // PRIM_I16_SET
			decref(x1);
			STR* v1045;
			STRLIT(v1045, "*(int16_t*)", 11);
			int64_t v1046 = 13LL /* C99RT_PTR */;
			STR* v1047;
			STRLIT(v1047, " = ", 3);
			int64_t v1048 = 4LL /* C99RT_I16 */;
			STR* v1049;
			STRLIT(v1049, ";", 1);
			int64_t v1050 = 1LL /* True */;
			VAL v1051 = MKI64(0LL /* None */);
			VAL v1052 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1045), v1046, MKSTR(v1047), v1048, MKSTR(v1049), v1050, v1051, x3));
			x4 = v1052;
		} break;
		case 95LL: { // PRIM_I32_SET
			decref(x1);
			STR* v1053;
			STRLIT(v1053, "*(int32_t*)", 11);
			int64_t v1054 = 13LL /* C99RT_PTR */;
			STR* v1055;
			STRLIT(v1055, " = ", 3);
			int64_t v1056 = 3LL /* C99RT_I32 */;
			STR* v1057;
			STRLIT(v1057, ";", 1);
			int64_t v1058 = 1LL /* True */;
			VAL v1059 = MKI64(0LL /* None */);
			VAL v1060 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1053), v1054, MKSTR(v1055), v1056, MKSTR(v1057), v1058, v1059, x3));
			x4 = v1060;
		} break;
		case 96LL: { // PRIM_I64_SET
			decref(x1);
			STR* v1061;
			STRLIT(v1061, "*(int64_t*)", 11);
			int64_t v1062 = 13LL /* C99RT_PTR */;
			STR* v1063;
			STRLIT(v1063, " = ", 3);
			int64_t v1064 = 2LL /* C99RT_I64 */;
			STR* v1065;
			STRLIT(v1065, ";", 1);
			int64_t v1066 = 1LL /* True */;
			VAL v1067 = MKI64(0LL /* None */);
			VAL v1068 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1061), v1062, MKSTR(v1063), v1064, MKSTR(v1065), v1066, v1067, x3));
			x4 = v1068;
		} break;
		case 97LL: { // PRIM_PTR_SET
			decref(x1);
			STR* v1069;
			STRLIT(v1069, "*(void**)", 9);
			int64_t v1070 = 13LL /* C99RT_PTR */;
			STR* v1071;
			STRLIT(v1071, " = ", 3);
			int64_t v1072 = 13LL /* C99RT_PTR */;
			STR* v1073;
			STRLIT(v1073, ";", 1);
			int64_t v1074 = 1LL /* True */;
			VAL v1075 = MKI64(0LL /* None */);
			VAL v1076 = (mw_mirth_c99_c99Z_binopZBang(MKSTR(v1069), v1070, MKSTR(v1071), v1072, MKSTR(v1073), v1074, v1075, x3));
			x4 = v1076;
		} break;
		case 98LL: { // PRIM_SYS_OS
			decref(x1);
			int64_t v1077 = 2LL /* C99RT_I64 */;
			VAL v1078 = (VVAL(VTUP(x3)->cells[1]));
			VAL v1079;
			VAL v1080;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1078, &v1079, &v1080);
			VAL v1081 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v1077, v1079));
			VAL v1082 = (mw_mirth_c99_ZPlusC99_indent(v1080));
			int64_t v1083 = VI64(VTUP(v1081)->cells[1]);
			VAL v1084 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v1083);
			VAL v1085 = (mw_mirth_c99_ZPlusC99_put(v1084, v1082));
			STR* v1086;
			STRLIT(v1086, " ", 1);
			VAL v1087 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1086), v1085));
			VAL v1088 = VVAL(VTUP(v1081)->cells[2]);
			incref(v1088);
			VAL v1089 = (mw_mirth_c99_ZPlusC99_put(v1088, v1087));
			STR* v1090;
			STRLIT(v1090, " = ", 3);
			VAL v1091 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1090), v1089));
			STR* v1092;
			STRLIT(v1092, "RUNNING_OS", 10);
			VAL v1093 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1092), v1091));
			STR* v1094;
			STRLIT(v1094, ";", 1);
			VAL v1095 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1094), v1093));
			VAL v1096 = (mw_mirth_c99_ZPlusC99_line(v1095));
			VTUP(x3)->cells[1] = v1096;
			VAL v1097 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v1081));
			x4 = v1097;
		} break;
		case 99LL: { // PRIM_SYS_ARCH
			decref(x1);
			int64_t v1098 = 2LL /* C99RT_I64 */;
			VAL v1099 = (VVAL(VTUP(x3)->cells[1]));
			VAL v1100;
			VAL v1101;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1099, &v1100, &v1101);
			VAL v1102 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v1098, v1100));
			VAL v1103 = (mw_mirth_c99_ZPlusC99_indent(v1101));
			int64_t v1104 = VI64(VTUP(v1102)->cells[1]);
			VAL v1105 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v1104);
			VAL v1106 = (mw_mirth_c99_ZPlusC99_put(v1105, v1103));
			STR* v1107;
			STRLIT(v1107, " ", 1);
			VAL v1108 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1107), v1106));
			VAL v1109 = VVAL(VTUP(v1102)->cells[2]);
			incref(v1109);
			VAL v1110 = (mw_mirth_c99_ZPlusC99_put(v1109, v1108));
			STR* v1111;
			STRLIT(v1111, " = ", 3);
			VAL v1112 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1111), v1110));
			STR* v1113;
			STRLIT(v1113, "RUNNING_ARCH", 12);
			VAL v1114 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1113), v1112));
			STR* v1115;
			STRLIT(v1115, ";", 1);
			VAL v1116 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1115), v1114));
			VAL v1117 = (mw_mirth_c99_ZPlusC99_line(v1116));
			VTUP(x3)->cells[1] = v1117;
			VAL v1118 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v1102));
			x4 = v1118;
		} break;
		case 100LL: { // PRIM_SYS_ARGC
			decref(x1);
			int64_t v1119 = 2LL /* C99RT_I64 */;
			VAL v1120 = (VVAL(VTUP(x3)->cells[1]));
			VAL v1121;
			VAL v1122;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1120, &v1121, &v1122);
			VAL v1123 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v1119, v1121));
			VAL v1124 = (mw_mirth_c99_ZPlusC99_indent(v1122));
			int64_t v1125 = VI64(VTUP(v1123)->cells[1]);
			VAL v1126 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v1125);
			VAL v1127 = (mw_mirth_c99_ZPlusC99_put(v1126, v1124));
			STR* v1128;
			STRLIT(v1128, " ", 1);
			VAL v1129 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1128), v1127));
			VAL v1130 = VVAL(VTUP(v1123)->cells[2]);
			incref(v1130);
			VAL v1131 = (mw_mirth_c99_ZPlusC99_put(v1130, v1129));
			STR* v1132;
			STRLIT(v1132, " = ", 3);
			VAL v1133 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1132), v1131));
			STR* v1134;
			STRLIT(v1134, "global_argc", 11);
			VAL v1135 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1134), v1133));
			STR* v1136;
			STRLIT(v1136, ";", 1);
			VAL v1137 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1136), v1135));
			VAL v1138 = (mw_mirth_c99_ZPlusC99_line(v1137));
			VTUP(x3)->cells[1] = v1138;
			VAL v1139 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v1123));
			x4 = v1139;
		} break;
		case 101LL: { // PRIM_SYS_ARGV
			decref(x1);
			int64_t v1140 = 13LL /* C99RT_PTR */;
			VAL v1141 = (VVAL(VTUP(x3)->cells[1]));
			VAL v1142;
			VAL v1143;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1141, &v1142, &v1143);
			VAL v1144 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v1140, v1142));
			VAL v1145 = (mw_mirth_c99_ZPlusC99_indent(v1143));
			int64_t v1146 = VI64(VTUP(v1144)->cells[1]);
			VAL v1147 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v1146);
			VAL v1148 = (mw_mirth_c99_ZPlusC99_put(v1147, v1145));
			STR* v1149;
			STRLIT(v1149, " ", 1);
			VAL v1150 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1149), v1148));
			VAL v1151 = VVAL(VTUP(v1144)->cells[2]);
			incref(v1151);
			VAL v1152 = (mw_mirth_c99_ZPlusC99_put(v1151, v1150));
			STR* v1153;
			STRLIT(v1153, " = ", 3);
			VAL v1154 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1153), v1152));
			STR* v1155;
			STRLIT(v1155, "global_argv", 11);
			VAL v1156 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1155), v1154));
			STR* v1157;
			STRLIT(v1157, ";", 1);
			VAL v1158 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1157), v1156));
			VAL v1159 = (mw_mirth_c99_ZPlusC99_line(v1158));
			VTUP(x3)->cells[1] = v1159;
			VAL v1160 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, v1144));
			x4 = v1160;
		} break;
		case 12LL: { // PRIM_CORE_MATCH
			VAL v1161 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1161;
		} break;
		case 13LL: { // PRIM_CORE_LAMBDA
			VAL v1162 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1162;
		} break;
		case 102LL: { // PRIM_SYNTAX_MODULE
			VAL v1163 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1163;
		} break;
		case 103LL: { // PRIM_SYNTAX_IMPORT
			VAL v1164 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1164;
		} break;
		case 104LL: { // PRIM_SYNTAX_ALIAS
			VAL v1165 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1165;
		} break;
		case 105LL: { // PRIM_SYNTAX_INLINE
			VAL v1166 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1166;
		} break;
		case 106LL: { // PRIM_SYNTAX_DEF
			VAL v1167 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1167;
		} break;
		case 107LL: { // PRIM_SYNTAX_DEF_MISSING
			VAL v1168 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1168;
		} break;
		case 108LL: { // PRIM_SYNTAX_DEF_TYPE
			VAL v1169 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1169;
		} break;
		case 109LL: { // PRIM_SYNTAX_BUFFER
			VAL v1170 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1170;
		} break;
		case 110LL: { // PRIM_SYNTAX_VARIABLE
			VAL v1171 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1171;
		} break;
		case 111LL: { // PRIM_SYNTAX_EXTERNAL
			VAL v1172 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1172;
		} break;
		case 112LL: { // PRIM_SYNTAX_DEF_EXTERNAL
			VAL v1173 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1173;
		} break;
		case 113LL: { // PRIM_SYNTAX_EMBED_STR
			VAL v1174 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1174;
		} break;
		case 114LL: { // PRIM_SYNTAX_TABLE
			VAL v1175 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1175;
		} break;
		case 115LL: { // PRIM_SYNTAX_FIELD
			VAL v1176 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1176;
		} break;
		case 116LL: { // PRIM_SYNTAX_DATA
			VAL v1177 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1177;
		} break;
		case 117LL: { // PRIM_SYNTAX_STRUCT
			VAL v1178 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1178;
		} break;
		case 118LL: { // PRIM_SYNTAX_DASHES
			VAL v1179 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1179;
		} break;
		case 119LL: { // PRIM_SYNTAX_ARROW
			VAL v1180 = (mw_mirth_c99_c99Z_primZ_syntaxZBang(x1, x3));
			x4 = v1180;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_c99_c99Z_primZ_syntaxZBang (VAL x1, VAL x2) {
	uint64_t v3 = VU64(VTUP(x1)->cells[2]);
	decref(x1);
	STR* v4;
	STRLIT(v4, "unexpected syntax primitive", 27);
	VAL v5 = (VVAL(VTUP(x2)->cells[1]));
	VAL v6 = (VVAL(VTUP(v5)->cells[6]));
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v3, MKSTR(v4), v6);
	VAL r7 = pop_resource();
	VTUP(v5)->cells[6] = r7;
	VTUP(x2)->cells[1] = v5;
	return x2;
}
static VAL mw_mirth_c99_c99Z_binopZBang (VAL x1, int64_t x2, VAL x3, int64_t x4, VAL x5, int64_t x6, VAL x7, VAL x8) {
	VAL x9;
	VAL x10;
	VAL x11;
	VAL x12;
	VAL x13;
	VAL x14;
	VAL x15;
	if (((bool)x6)) {
		VAL v16;
		VAL v17;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x8, x2, &v16, &v17);
		VAL v18 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(x2, v17);
		VAL v19;
		VAL v20;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v16, x4, &v19, &v20);
		VAL v21 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(x4, v20);
		x15 = v21;
		x14 = v19;
		x13 = v18;
		x12 = x1;
		x11 = x3;
		x10 = x5;
		x9 = x7;
	} else {
		VAL v22;
		VAL v23;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x8, x4, &v22, &v23);
		VAL v24 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(x4, v23);
		VAL v25;
		VAL v26;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v22, x2, &v25, &v26);
		VAL v27 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(x2, v26);
		x15 = v24;
		x14 = v25;
		x13 = v27;
		x12 = x1;
		x11 = x3;
		x10 = x5;
		x9 = x7;
	}
	VAL x28;
	switch (get_data_tag(x9)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(x9);
			VAL v30 = (VVAL(VTUP(x14)->cells[1]));
			VAL v31;
			VAL v32;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v30, &v31, &v32);
			VAL v33 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(VI64(v29), v31));
			VAL v34 = (mw_mirth_c99_ZPlusC99_indent(v32));
			int64_t v35 = VI64(VTUP(v33)->cells[1]);
			VAL v36 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v35);
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v36, v34));
			STR* v38;
			STRLIT(v38, " ", 1);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			VAL v40 = VVAL(VTUP(v33)->cells[2]);
			incref(v40);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(v40, v39));
			STR* v42;
			STRLIT(v42, " = ", 3);
			VAL v43 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), v41));
			VAL v44 = (mw_mirth_c99_ZPlusC99_put(x12, v43));
			VAL v45 = (mw_mirth_c99_ZPlusC99_put(x13, v44));
			VAL v46 = (mw_mirth_c99_ZPlusC99_put(x11, v45));
			VAL v47 = (mw_mirth_c99_ZPlusC99_put(x15, v46));
			VAL v48 = (mw_mirth_c99_ZPlusC99_put(x10, v47));
			STR* v49;
			STRLIT(v49, ";", 1);
			VAL v50 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v49), v48));
			VAL v51 = (mw_mirth_c99_ZPlusC99_line(v50));
			VTUP(x14)->cells[1] = v51;
			VAL v52 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x14, v33));
			x28 = v52;
		} break;
		case 0LL: { // None
			VAL v53 = (VVAL(VTUP(x14)->cells[1]));
			VAL v54 = (mw_mirth_c99_ZPlusC99_indent(v53));
			VAL v55 = (mw_mirth_c99_ZPlusC99_put(x12, v54));
			VAL v56 = (mw_mirth_c99_ZPlusC99_put(x13, v55));
			VAL v57 = (mw_mirth_c99_ZPlusC99_put(x11, v56));
			VAL v58 = (mw_mirth_c99_ZPlusC99_put(x15, v57));
			VAL v59 = (mw_mirth_c99_ZPlusC99_put(x10, v58));
			VAL v60 = (mw_mirth_c99_ZPlusC99_line(v59));
			VTUP(x14)->cells[1] = v60;
			x28 = x14;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x28;
}
static VAL mw_mirth_c99_c99Z_unopZBang (VAL x1, int64_t x2, VAL x3, VAL x4, VAL x5) {
	VAL v6;
	VAL v7;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x5, x2, &v6, &v7);
	VAL v8 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(x2, v7);
	VAL x9;
	switch (get_data_tag(x4)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(x4);
			VAL v11 = (VVAL(VTUP(v6)->cells[1]));
			VAL v12;
			VAL v13;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v11, &v12, &v13);
			VAL v14 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(VI64(v10), v12));
			VAL v15 = (mw_mirth_c99_ZPlusC99_indent(v13));
			int64_t v16 = VI64(VTUP(v14)->cells[1]);
			VAL v17 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v16);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(v17, v15));
			STR* v19;
			STRLIT(v19, " ", 1);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
			VAL v21 = VVAL(VTUP(v14)->cells[2]);
			incref(v21);
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(v21, v20));
			STR* v23;
			STRLIT(v23, " = ", 3);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
			VAL v25 = (mw_mirth_c99_ZPlusC99_put(x1, v24));
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(v8, v25));
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(x3, v26));
			STR* v28;
			STRLIT(v28, ";", 1);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
			VAL v30 = (mw_mirth_c99_ZPlusC99_line(v29));
			VTUP(v6)->cells[1] = v30;
			VAL v31 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v6, v14));
			x9 = v31;
		} break;
		case 0LL: { // None
			VAL v32 = (VVAL(VTUP(v6)->cells[1]));
			VAL v33 = (mw_mirth_c99_ZPlusC99_indent(v32));
			VAL v34 = (mw_mirth_c99_ZPlusC99_put(x1, v33));
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(v8, v34));
			VAL v36 = (mw_mirth_c99_ZPlusC99_put(x3, v35));
			VAL v37 = (mw_mirth_c99_ZPlusC99_line(v36));
			VTUP(v6)->cells[1] = v37;
			x9 = v6;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x9;
}
static VAL mw_mirth_c99_c99Z_argsZ_pushZBang (VAL x1, VAL x2) {
	VAL v3;
	VAL v4;
	mw_std_list_List_1_uncons(x1, &v3, &v4);
	VAL x5;
	VAL x6;
	int64_t x7;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v9 = (mw_mirth_c99_c99Z_argZ_pushZBang(VU64(v8), x2));
			int64_t v10 = 1LL /* True */;
			x7 = v10;
			x6 = v4;
			x5 = v9;
		} break;
		case 0LL: { // None
			int64_t v11 = 0LL /* False */;
			x7 = v11;
			x6 = v4;
			x5 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v12 = (x5);
	VAL v13 = x6;
	int64_t v14 = x7;
	while (((bool)v14)) {
		VAL v15 = (v12);
		VAL v16 = v13;
		VAL v17;
		VAL v18;
		mw_std_list_List_1_uncons(v16, &v17, &v18);
		VAL x19;
		VAL x20;
		int64_t x21;
		switch (get_data_tag(v17)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v17);
				VAL v23 = (mw_mirth_c99_c99Z_argZ_pushZBang(VU64(v22), v15));
				int64_t v24 = 1LL /* True */;
				x21 = v24;
				x20 = v18;
				x19 = v23;
			} break;
			case 0LL: { // None
				int64_t v25 = 0LL /* False */;
				x21 = v25;
				x20 = v18;
				x19 = v15;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v14 = x21;
		v13 = x20;
		v12 = x19;
	}
	decref(v13);
	return v12;
}
static VAL mw_mirth_c99_c99Z_argZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_c99Z_blockZ_pushZBang(x1, x2));
	return v3;
}
static VAL mw_mirth_c99_c99Z_argZ_runZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_c99Z_blockZ_runZBang(x1, x2));
	return v3;
}
static VAL mw_mirth_c99_c99Z_blockZ_runZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_arrow(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VTUP(x2)->cells[1] = v3;
	VAL v7 = (mw_mirth_c99_c99Z_arrowZBang(v6, x2));
	return v7;
}
static VAL mw_mirth_c99_ZPlusC99_varZ_put (uint64_t x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "var_", 4);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	uint64_t v5 = mw_mirth_var_Var_name(x1);
	VAL v6 = mw_mirth_name_Name_mangled(v5);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(v6, v4));
	return v7;
}
static VAL mw_mirth_c99_c99Z_packZ_closureZ_varsZBang (VAL x1, VAL x2) {
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(x1, &v5, &v6);
	VAL x7;
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v11);
			int64_t v12 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v11));
			VAL x13;
			VAL x14;
			if (((bool)v12)) {
				VAL v15 = mtw_std_maybe_Maybe_1_Some(v11);
				x14 = v15;
				x13 = x2;
			} else {
				decref(v11);
				VAL v16 = MKI64(0LL /* None */);
				x14 = v16;
				x13 = x2;
			}
			VAL x17;
			switch (get_data_tag(x14)) {
				case 1LL: { // Some
					VAL v18 = mtp_std_maybe_Maybe_1_Some(x14);
					VAL v19 = mtw_std_list_List_1_Cons(v18, v4);
					x17 = v19;
					push_resource(x13);
				} break;
				case 0LL: { // None
					x17 = v4;
					push_resource(x13);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v20 = 1LL /* True */;
			x10 = v20;
			x9 = v6;
			x8 = x17;
			VAL r21 = pop_resource();
			x7 = r21;
		} break;
		case 0LL: { // None
			int64_t v22 = 0LL /* False */;
			x10 = v22;
			x9 = v6;
			x8 = v4;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v23 = (x7);
	VAL v24 = (x8);
	VAL v25 = x9;
	int64_t v26 = x10;
	while (((bool)v26)) {
		VAL v27 = (v23);
		VAL v28 = (v24);
		VAL v29 = v25;
		VAL v30;
		VAL v31;
		mw_std_list_List_1_uncons(v29, &v30, &v31);
		VAL x32;
		VAL x33;
		VAL x34;
		int64_t x35;
		switch (get_data_tag(v30)) {
			case 1LL: { // Some
				VAL v36 = mtp_std_maybe_Maybe_1_Some(v30);
				incref(v36);
				int64_t v37 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v36));
				VAL x38;
				VAL x39;
				if (((bool)v37)) {
					VAL v40 = mtw_std_maybe_Maybe_1_Some(v36);
					x39 = v40;
					x38 = v27;
				} else {
					decref(v36);
					VAL v41 = MKI64(0LL /* None */);
					x39 = v41;
					x38 = v27;
				}
				VAL x42;
				switch (get_data_tag(x39)) {
					case 1LL: { // Some
						VAL v43 = mtp_std_maybe_Maybe_1_Some(x39);
						VAL v44 = mtw_std_list_List_1_Cons(v43, v28);
						x42 = v44;
						push_resource(x38);
					} break;
					case 0LL: { // None
						x42 = v28;
						push_resource(x38);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v45 = 1LL /* True */;
				x35 = v45;
				x34 = v31;
				x33 = x42;
				VAL r46 = pop_resource();
				x32 = r46;
			} break;
			case 0LL: { // None
				int64_t v47 = 0LL /* False */;
				x35 = v47;
				x34 = v31;
				x33 = v28;
				x32 = v27;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v26 = x35;
		v25 = x34;
		v24 = x33;
		v23 = x32;
	}
	decref(v25);
	VAL v48 = mw_std_list_List_1_reverse(v24);
	incref(v48);
	int64_t v49 = mw_std_list_List_1_emptyZAsk(v48);
	VAL x50;
	if (((bool)v49)) {
		decref(v48);
		x50 = v23;
	} else {
		int64_t v51 = 14LL /* C99RT_FNPTR */;
		VAL v52;
		VAL v53;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v23, v51, &v52, &v53);
		int64_t v54 = 0LL /* C99RT_VAL */;
		VAL v55 = (VVAL(VTUP(v52)->cells[1]));
		VAL v56;
		VAL v57;
		mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v55, &v56, &v57);
		VAL v58 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v54, v56));
		VAL v59 = (mw_mirth_c99_ZPlusC99_indent(v57));
		int64_t v60 = VI64(VTUP(v58)->cells[1]);
		VAL v61 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v60);
		VAL v62 = (mw_mirth_c99_ZPlusC99_put(v61, v59));
		STR* v63;
		STRLIT(v63, " ", 1);
		VAL v64 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v63), v62));
		VAL v65 = VVAL(VTUP(v58)->cells[2]);
		incref(v65);
		VAL v66 = (mw_mirth_c99_ZPlusC99_put(v65, v64));
		STR* v67;
		STRLIT(v67, " = ", 3);
		VAL v68 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v67), v66));
		STR* v69;
		STRLIT(v69, "MKTUP(tup_new(", 14);
		VAL v70 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v69), v68));
		incref(v48);
		int64_t v71 = mw_std_list_List_1_len(v48);
		int64_t v72 = 1LL;
		int64_t v73 = i64_add(v71, v72);
		STR* v74 = i64_show(v73);
		incref(MKSTR(v74));
		VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v70));
		STR* v76;
		STRLIT(v76, "), ", 3);
		VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v76), v75));
		VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v77));
		STR* v79;
		STRLIT(v79, ")", 1);
		VAL v80 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v79), v78));
		STR* v81;
		STRLIT(v81, ";", 1);
		VAL v82 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v81), v80));
		VAL v83 = (mw_mirth_c99_ZPlusC99_line(v82));
		VTUP(v52)->cells[1] = v83;
		VAL v84 = (VVAL(VTUP(v52)->cells[1]));
		VAL v85 = (mw_mirth_c99_ZPlusC99_indent(v84));
		STR* v86;
		STRLIT(v86, "VTUP(", 5);
		VAL v87 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v86), v85));
		VAL v88;
		VAL v89;
		mw_mirth_c99_ZPlusC99Local_rdup(v58, &v88, &v89);
		VAL v90 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v88);
		VAL v91 = (mw_mirth_c99_ZPlusC99_put(v90, v87));
		STR* v92;
		STRLIT(v92, ")->cells[0] = ", 14);
		VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
		VAL v94 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v53);
		VAL v95 = (mw_mirth_c99_ZPlusC99_put(v94, v93));
		STR* v96;
		STRLIT(v96, ";", 1);
		VAL v97 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v96), v95));
		VAL v98 = (mw_mirth_c99_ZPlusC99_line(v97));
		VTUP(v52)->cells[1] = v98;
		int64_t v99 = 1LL;
		VAL v100;
		VAL v101;
		mw_std_list_List_1_uncons(v48, &v100, &v101);
		VAL x102;
		VAL x103;
		int64_t x104;
		VAL x105;
		int64_t x106;
		switch (get_data_tag(v100)) {
			case 1LL: { // Some
				VAL v107 = mtp_std_maybe_Maybe_1_Some(v100);
				VAL v108 = (VVAL(VTUP(v52)->cells[1]));
				VAL v109 = (mw_mirth_c99_ZPlusC99_indent(v108));
				STR* v110;
				STRLIT(v110, "VTUP(", 5);
				VAL v111 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v110), v109));
				VAL v112;
				VAL v113;
				mw_mirth_c99_ZPlusC99Local_rdup(v89, &v112, &v113);
				VAL v114 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v112);
				VAL v115 = (mw_mirth_c99_ZPlusC99_put(v114, v111));
				STR* v116;
				STRLIT(v116, ")->cells[", 9);
				VAL v117 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v116), v115));
				STR* v118 = i64_show(v99);
				VAL v119 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v118), v117));
				STR* v120;
				STRLIT(v120, "] = ", 4);
				VAL v121 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v120), v119));
				incref(v107);
				VAL v122 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v107), v121));
				STR* v123;
				STRLIT(v123, "; incref(", 9);
				VAL v124 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v123), v122));
				VAL v125 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v107), v124));
				STR* v126;
				STRLIT(v126, ");", 2);
				VAL v127 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v126), v125));
				VAL v128 = (mw_mirth_c99_ZPlusC99_line(v127));
				VTUP(v52)->cells[1] = v128;
				int64_t v129 = 1LL;
				int64_t v130 = i64_add(v99, v129);
				int64_t v131 = 1LL /* True */;
				x106 = v131;
				x105 = v101;
				x104 = v130;
				x103 = v52;
				x102 = v113;
			} break;
			case 0LL: { // None
				int64_t v132 = 0LL /* False */;
				x106 = v132;
				x105 = v101;
				x104 = v99;
				x103 = v52;
				x102 = v89;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v133 = x102;
		VAL v134 = (x103);
		int64_t v135 = x104;
		VAL v136 = x105;
		int64_t v137 = x106;
		while (((bool)v137)) {
			VAL v138 = v133;
			VAL v139 = (v134);
			int64_t v140 = v135;
			VAL v141 = v136;
			VAL v142;
			VAL v143;
			mw_std_list_List_1_uncons(v141, &v142, &v143);
			VAL x144;
			VAL x145;
			int64_t x146;
			VAL x147;
			int64_t x148;
			switch (get_data_tag(v142)) {
				case 1LL: { // Some
					VAL v149 = mtp_std_maybe_Maybe_1_Some(v142);
					VAL v150 = (VVAL(VTUP(v139)->cells[1]));
					VAL v151 = (mw_mirth_c99_ZPlusC99_indent(v150));
					STR* v152;
					STRLIT(v152, "VTUP(", 5);
					VAL v153 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v152), v151));
					VAL v154;
					VAL v155;
					mw_mirth_c99_ZPlusC99Local_rdup(v138, &v154, &v155);
					VAL v156 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v154);
					VAL v157 = (mw_mirth_c99_ZPlusC99_put(v156, v153));
					STR* v158;
					STRLIT(v158, ")->cells[", 9);
					VAL v159 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v158), v157));
					STR* v160 = i64_show(v140);
					VAL v161 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v160), v159));
					STR* v162;
					STRLIT(v162, "] = ", 4);
					VAL v163 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v162), v161));
					incref(v149);
					VAL v164 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v149), v163));
					STR* v165;
					STRLIT(v165, "; incref(", 9);
					VAL v166 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v165), v164));
					VAL v167 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v149), v166));
					STR* v168;
					STRLIT(v168, ");", 2);
					VAL v169 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v168), v167));
					VAL v170 = (mw_mirth_c99_ZPlusC99_line(v169));
					VTUP(v139)->cells[1] = v170;
					int64_t v171 = 1LL;
					int64_t v172 = i64_add(v140, v171);
					int64_t v173 = 1LL /* True */;
					x148 = v173;
					x147 = v143;
					x146 = v172;
					x145 = v139;
					x144 = v155;
				} break;
				case 0LL: { // None
					int64_t v174 = 0LL /* False */;
					x148 = v174;
					x147 = v143;
					x146 = v140;
					x145 = v139;
					x144 = v138;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v137 = x148;
			v136 = x147;
			v135 = x146;
			v134 = x145;
			v133 = x144;
		}
		decref(v136);
		VAL v175 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v134, v133));
		x50 = v175;
	}
	return x50;
}
static VAL mw_mirth_c99_c99Z_popZ_toZ_varZBang (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_var_Var_type(x1);
	VAL v4 = (VVAL(VTUP(x2)->cells[1]));
	VAL v5 = (VVAL(VTUP(v4)->cells[6]));
	int64_t v6;
	VAL v7;
	mw_mirth_type_Type_c99Z_repr(v3, v5, &v6, &v7);
	VTUP(v4)->cells[6] = v7;
	VTUP(x2)->cells[1] = v4;
	VAL v8;
	VAL v9;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v6, &v8, &v9);
	VAL v10 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v9);
	VAL v11 = (VVAL(VTUP(v8)->cells[1]));
	VAL v12 = (mw_mirth_c99_ZPlusC99_indent(v11));
	STR* v13;
	STRLIT(v13, "VAL ", 4);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = (mw_mirth_c99_ZPlusC99_varZ_put(x1, v14));
	STR* v16;
	STRLIT(v16, " = ", 3);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(v10, v17));
	STR* v19;
	STRLIT(v19, ";", 1);
	VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
	VAL v21 = (mw_mirth_c99_ZPlusC99_line(v20));
	VTUP(v8)->cells[1] = v21;
	return v8;
}
static VAL mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang (VAL x1, VAL x2) {
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(x1, &v5, &v6);
	VAL x7;
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v11);
			int64_t v12 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v11));
			VAL x13;
			VAL x14;
			if (((bool)v12)) {
				VAL v15 = mtw_std_maybe_Maybe_1_Some(v11);
				x14 = v15;
				x13 = x2;
			} else {
				decref(v11);
				VAL v16 = MKI64(0LL /* None */);
				x14 = v16;
				x13 = x2;
			}
			VAL x17;
			switch (get_data_tag(x14)) {
				case 1LL: { // Some
					VAL v18 = mtp_std_maybe_Maybe_1_Some(x14);
					VAL v19 = mtw_std_list_List_1_Cons(v18, v4);
					x17 = v19;
					push_resource(x13);
				} break;
				case 0LL: { // None
					x17 = v4;
					push_resource(x13);
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v20 = 1LL /* True */;
			x10 = v20;
			x9 = v6;
			x8 = x17;
			VAL r21 = pop_resource();
			x7 = r21;
		} break;
		case 0LL: { // None
			int64_t v22 = 0LL /* False */;
			x10 = v22;
			x9 = v6;
			x8 = v4;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v23 = (x7);
	VAL v24 = (x8);
	VAL v25 = x9;
	int64_t v26 = x10;
	while (((bool)v26)) {
		VAL v27 = (v23);
		VAL v28 = (v24);
		VAL v29 = v25;
		VAL v30;
		VAL v31;
		mw_std_list_List_1_uncons(v29, &v30, &v31);
		VAL x32;
		VAL x33;
		VAL x34;
		int64_t x35;
		switch (get_data_tag(v30)) {
			case 1LL: { // Some
				VAL v36 = mtp_std_maybe_Maybe_1_Some(v30);
				incref(v36);
				int64_t v37 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v36));
				VAL x38;
				VAL x39;
				if (((bool)v37)) {
					VAL v40 = mtw_std_maybe_Maybe_1_Some(v36);
					x39 = v40;
					x38 = v27;
				} else {
					decref(v36);
					VAL v41 = MKI64(0LL /* None */);
					x39 = v41;
					x38 = v27;
				}
				VAL x42;
				switch (get_data_tag(x39)) {
					case 1LL: { // Some
						VAL v43 = mtp_std_maybe_Maybe_1_Some(x39);
						VAL v44 = mtw_std_list_List_1_Cons(v43, v28);
						x42 = v44;
						push_resource(x38);
					} break;
					case 0LL: { // None
						x42 = v28;
						push_resource(x38);
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v45 = 1LL /* True */;
				x35 = v45;
				x34 = v31;
				x33 = x42;
				VAL r46 = pop_resource();
				x32 = r46;
			} break;
			case 0LL: { // None
				int64_t v47 = 0LL /* False */;
				x35 = v47;
				x34 = v31;
				x33 = v28;
				x32 = v27;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v26 = x35;
		v25 = x34;
		v24 = x33;
		v23 = x32;
	}
	decref(v25);
	VAL v48 = mw_std_list_List_1_reverse(v24);
	incref(v48);
	int64_t v49 = mw_std_list_List_1_emptyZAsk(v48);
	VAL x50;
	if (((bool)v49)) {
		decref(v48);
		x50 = v23;
	} else {
		int64_t v51 = 0LL /* C99RT_VAL */;
		VAL v52;
		VAL v53;
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v23, v51, &v52, &v53);
		int64_t v54 = 1LL;
		VAL v55;
		VAL v56;
		mw_std_list_List_1_uncons(v48, &v55, &v56);
		VAL x57;
		VAL x58;
		int64_t x59;
		VAL x60;
		int64_t x61;
		switch (get_data_tag(v55)) {
			case 1LL: { // Some
				VAL v62 = mtp_std_maybe_Maybe_1_Some(v55);
				VAL v63 = (VVAL(VTUP(v52)->cells[1]));
				VAL v64 = (mw_mirth_c99_ZPlusC99_indent(v63));
				STR* v65;
				STRLIT(v65, "VAL ", 4);
				VAL v66 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v65), v64));
				incref(v62);
				VAL v67 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v62), v66));
				STR* v68;
				STRLIT(v68, " = VTUP(", 8);
				VAL v69 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v68), v67));
				VAL v70;
				VAL v71;
				mw_mirth_c99_ZPlusC99Local_rdup(v53, &v70, &v71);
				VAL v72 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v70);
				VAL v73 = (mw_mirth_c99_ZPlusC99_put(v72, v69));
				STR* v74;
				STRLIT(v74, ")->cells[", 9);
				VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v73));
				STR* v76 = i64_show(v54);
				VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v76), v75));
				STR* v78;
				STRLIT(v78, "]; incref(", 10);
				VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
				VAL v80 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v62), v79));
				STR* v81;
				STRLIT(v81, ");", 2);
				VAL v82 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v81), v80));
				VAL v83 = (mw_mirth_c99_ZPlusC99_line(v82));
				VTUP(v52)->cells[1] = v83;
				int64_t v84 = 1LL;
				int64_t v85 = i64_add(v54, v84);
				int64_t v86 = 1LL /* True */;
				x61 = v86;
				x60 = v56;
				x59 = v85;
				x58 = v71;
				x57 = v52;
			} break;
			case 0LL: { // None
				int64_t v87 = 0LL /* False */;
				x61 = v87;
				x60 = v56;
				x59 = v54;
				x58 = v53;
				x57 = v52;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v88 = (x57);
		VAL v89 = x58;
		int64_t v90 = x59;
		VAL v91 = x60;
		int64_t v92 = x61;
		while (((bool)v92)) {
			VAL v93 = (v88);
			VAL v94 = v89;
			int64_t v95 = v90;
			VAL v96 = v91;
			VAL v97;
			VAL v98;
			mw_std_list_List_1_uncons(v96, &v97, &v98);
			VAL x99;
			VAL x100;
			int64_t x101;
			VAL x102;
			int64_t x103;
			switch (get_data_tag(v97)) {
				case 1LL: { // Some
					VAL v104 = mtp_std_maybe_Maybe_1_Some(v97);
					VAL v105 = (VVAL(VTUP(v93)->cells[1]));
					VAL v106 = (mw_mirth_c99_ZPlusC99_indent(v105));
					STR* v107;
					STRLIT(v107, "VAL ", 4);
					VAL v108 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v107), v106));
					incref(v104);
					VAL v109 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v104), v108));
					STR* v110;
					STRLIT(v110, " = VTUP(", 8);
					VAL v111 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v110), v109));
					VAL v112;
					VAL v113;
					mw_mirth_c99_ZPlusC99Local_rdup(v94, &v112, &v113);
					VAL v114 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v112);
					VAL v115 = (mw_mirth_c99_ZPlusC99_put(v114, v111));
					STR* v116;
					STRLIT(v116, ")->cells[", 9);
					VAL v117 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v116), v115));
					STR* v118 = i64_show(v95);
					VAL v119 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v118), v117));
					STR* v120;
					STRLIT(v120, "]; incref(", 10);
					VAL v121 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v120), v119));
					VAL v122 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v104), v121));
					STR* v123;
					STRLIT(v123, ");", 2);
					VAL v124 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v123), v122));
					VAL v125 = (mw_mirth_c99_ZPlusC99_line(v124));
					VTUP(v93)->cells[1] = v125;
					int64_t v126 = 1LL;
					int64_t v127 = i64_add(v95, v126);
					int64_t v128 = 1LL /* True */;
					x103 = v128;
					x102 = v98;
					x101 = v127;
					x100 = v113;
					x99 = v93;
				} break;
				case 0LL: { // None
					int64_t v129 = 0LL /* False */;
					x103 = v129;
					x102 = v98;
					x101 = v95;
					x100 = v94;
					x99 = v93;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v92 = x103;
			v91 = x102;
			v90 = x101;
			v89 = x100;
			v88 = x99;
		}
		decref(v91);
		VAL v130 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(v88, v89));
		x50 = v130;
	}
	return x50;
}
static VAL mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang (VAL x1, VAL x2) {
	VAL v3 = MKI64(0LL /* Nil */);
	VAL v4 = mw_std_list_List_1_reverse(v3);
	VAL v5;
	VAL v6;
	mw_std_list_List_1_uncons(x1, &v5, &v6);
	VAL x7;
	VAL x8;
	VAL x9;
	int64_t x10;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v11);
			int64_t v12 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v11));
			VAL x13;
			VAL x14;
			if (((bool)v12)) {
				VAL v15 = mtw_std_maybe_Maybe_1_Some(v11);
				x14 = v15;
				x13 = x2;
			} else {
				decref(v11);
				VAL v16 = MKI64(0LL /* None */);
				x14 = v16;
				x13 = x2;
			}
			VAL x17;
			VAL x18;
			switch (get_data_tag(x14)) {
				case 1LL: { // Some
					VAL v19 = mtp_std_maybe_Maybe_1_Some(x14);
					VAL v20 = mtw_std_list_List_1_Cons(v19, v4);
					x18 = v20;
					x17 = x13;
				} break;
				case 0LL: { // None
					x18 = v4;
					x17 = x13;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v21 = 1LL /* True */;
			x10 = v21;
			x9 = v6;
			x8 = x18;
			x7 = x17;
		} break;
		case 0LL: { // None
			int64_t v22 = 0LL /* False */;
			x10 = v22;
			x9 = v6;
			x8 = v4;
			x7 = x2;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v23 = (x7);
	VAL v24 = (x8);
	VAL v25 = x9;
	int64_t v26 = x10;
	while (((bool)v26)) {
		VAL v27 = (v23);
		VAL v28 = (v24);
		VAL v29 = v25;
		VAL v30;
		VAL v31;
		mw_std_list_List_1_uncons(v29, &v30, &v31);
		VAL x32;
		VAL x33;
		VAL x34;
		int64_t x35;
		switch (get_data_tag(v30)) {
			case 1LL: { // Some
				VAL v36 = mtp_std_maybe_Maybe_1_Some(v30);
				incref(v36);
				int64_t v37 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v36));
				VAL x38;
				VAL x39;
				if (((bool)v37)) {
					VAL v40 = mtw_std_maybe_Maybe_1_Some(v36);
					x39 = v40;
					x38 = v27;
				} else {
					decref(v36);
					VAL v41 = MKI64(0LL /* None */);
					x39 = v41;
					x38 = v27;
				}
				VAL x42;
				VAL x43;
				switch (get_data_tag(x39)) {
					case 1LL: { // Some
						VAL v44 = mtp_std_maybe_Maybe_1_Some(x39);
						VAL v45 = mtw_std_list_List_1_Cons(v44, v28);
						x43 = v45;
						x42 = x38;
					} break;
					case 0LL: { // None
						x43 = v28;
						x42 = x38;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v46 = 1LL /* True */;
				x35 = v46;
				x34 = v31;
				x33 = x43;
				x32 = x42;
			} break;
			case 0LL: { // None
				int64_t v47 = 0LL /* False */;
				x35 = v47;
				x34 = v31;
				x33 = v28;
				x32 = v27;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v26 = x35;
		v25 = x34;
		v24 = x33;
		v23 = x32;
	}
	decref(v25);
	VAL v48 = mw_std_list_List_1_reverse(v24);
	VAL v49 = mw_std_list_List_1_reverse(v48);
	VAL v50;
	VAL v51;
	mw_std_list_List_1_uncons(v49, &v50, &v51);
	VAL x52;
	VAL x53;
	int64_t x54;
	switch (get_data_tag(v50)) {
		case 1LL: { // Some
			VAL v55 = mtp_std_maybe_Maybe_1_Some(v50);
			VAL v56 = (VVAL(VTUP(v23)->cells[1]));
			VAL v57 = (mw_mirth_c99_ZPlusC99_indent(v56));
			STR* v58;
			STRLIT(v58, "decref(", 7);
			VAL v59 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v58), v57));
			VAL v60 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v55), v59));
			STR* v61;
			STRLIT(v61, ");", 2);
			VAL v62 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v61), v60));
			VAL v63 = (mw_mirth_c99_ZPlusC99_line(v62));
			VTUP(v23)->cells[1] = v63;
			int64_t v64 = 1LL /* True */;
			x54 = v64;
			x53 = v51;
			x52 = v23;
		} break;
		case 0LL: { // None
			int64_t v65 = 0LL /* False */;
			x54 = v65;
			x53 = v51;
			x52 = v23;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v66 = (x52);
	VAL v67 = x53;
	int64_t v68 = x54;
	while (((bool)v68)) {
		VAL v69 = (v66);
		VAL v70 = v67;
		VAL v71;
		VAL v72;
		mw_std_list_List_1_uncons(v70, &v71, &v72);
		VAL x73;
		VAL x74;
		int64_t x75;
		switch (get_data_tag(v71)) {
			case 1LL: { // Some
				VAL v76 = mtp_std_maybe_Maybe_1_Some(v71);
				VAL v77 = (VVAL(VTUP(v69)->cells[1]));
				VAL v78 = (mw_mirth_c99_ZPlusC99_indent(v77));
				STR* v79;
				STRLIT(v79, "decref(", 7);
				VAL v80 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v79), v78));
				VAL v81 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v76), v80));
				STR* v82;
				STRLIT(v82, ");", 2);
				VAL v83 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v82), v81));
				VAL v84 = (mw_mirth_c99_ZPlusC99_line(v83));
				VTUP(v69)->cells[1] = v84;
				int64_t v85 = 1LL /* True */;
				x75 = v85;
				x74 = v72;
				x73 = v69;
			} break;
			case 0LL: { // None
				int64_t v86 = 0LL /* False */;
				x75 = v86;
				x74 = v72;
				x73 = v69;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v68 = x75;
		v67 = x74;
		v66 = x73;
	}
	decref(v67);
	return v66;
}
static VAL mw_mirth_c99_c99Z_blockZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_toZ_runZ_var(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VTUP(x2)->cells[1] = v3;
	VAL x7;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v9 = (mw_mirth_c99_c99Z_varZ_pushZBang(VU64(v8), x2));
			x7 = v9;
		} break;
		case 0LL: { // None
			int64_t v10 = 14LL /* C99RT_FNPTR */;
			VAL v11 = (VVAL(VTUP(x2)->cells[1]));
			VAL v12;
			VAL v13;
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v11, &v12, &v13);
			VAL v14 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v10, v12));
			VAL v15 = (mw_mirth_c99_ZPlusC99_indent(v13));
			int64_t v16 = VI64(VTUP(v14)->cells[1]);
			VAL v17 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v16);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(v17, v15));
			STR* v19;
			STRLIT(v19, " ", 1);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
			VAL v21 = VVAL(VTUP(v14)->cells[2]);
			incref(v21);
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(v21, v20));
			STR* v23;
			STRLIT(v23, " = ", 3);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
			STR* v25;
			STRLIT(v25, "&", 1);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			VAL v27 = (VVAL(VTUP(v26)->cells[6]));
			VAL v28;
			VAL v29;
			mw_mirth_arrow_Block_cname(v27, x1, &v28, &v29);
			VTUP(v26)->cells[6] = v28;
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(v29, v26));
			STR* v31;
			STRLIT(v31, ";", 1);
			VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
			VAL v33 = (mw_mirth_c99_ZPlusC99_line(v32));
			VTUP(x2)->cells[1] = v33;
			VAL v34 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v14));
			VAL v35 = (VVAL(VTUP(v34)->cells[1]));
			VAL v36 = (VVAL(VTUP(v35)->cells[6]));
			VAL v37;
			VAL v38;
			mw_mirth_arrow_Block_freeZ_vars(v36, x1, &v37, &v38);
			VTUP(v35)->cells[6] = v37;
			VTUP(v34)->cells[1] = v35;
			VAL v39 = (mw_mirth_c99_c99Z_packZ_closureZ_varsZBang(v38, v34));
			x7 = v39;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x7;
}
static VAL mw_mirth_c99_c99Z_varZBang (uint64_t x1, VAL x2) {
	VAL v3 = mw_mirth_var_Var_autoZ_runZAsk(x1);
	VAL x4;
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v3);
			decref(v5);
			VAL v6 = (mw_mirth_c99_c99Z_varZ_runZBang(x1, x2));
			x4 = v6;
		} break;
		case 0LL: { // None
			VAL v7 = (mw_mirth_c99_c99Z_varZ_pushZBang(x1, x2));
			x4 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x4;
}
static VAL mw_mirth_c99_c99Z_varZ_runZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(x2));
	VAL v4 = (VVAL(VTUP(v3)->cells[1]));
	VAL v5 = (mw_mirth_c99_ZPlusC99_indent(v4));
	STR* v6;
	STRLIT(v6, "incref(", 7);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_varZ_put(x1, v7));
	STR* v9;
	STRLIT(v9, ");", 2);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
	VTUP(v3)->cells[1] = v11;
	VAL v12 = (VVAL(VTUP(v3)->cells[1]));
	VAL v13 = (mw_mirth_c99_ZPlusC99_indent(v12));
	STR* v14;
	STRLIT(v14, "run_value(", 10);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
	VAL v16 = (mw_mirth_c99_ZPlusC99_varZ_put(x1, v15));
	STR* v17;
	STRLIT(v17, ");", 2);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL v19 = (mw_mirth_c99_ZPlusC99_line(v18));
	VTUP(v3)->cells[1] = v19;
	return v3;
}
static VAL mw_mirth_c99_c99Z_varZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = (mw_mirth_c99_ZPlusC99_indent(v3));
	STR* v5;
	STRLIT(v5, "incref(", 7);
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
	VAL v7 = (mw_mirth_c99_ZPlusC99_varZ_put(x1, v6));
	STR* v8;
	STRLIT(v8, ");", 2);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
	VAL v10 = (mw_mirth_c99_ZPlusC99_line(v9));
	VTUP(x2)->cells[1] = v10;
	int64_t v11 = 0LL /* C99RT_VAL */;
	VAL v12 = (VVAL(VTUP(x2)->cells[1]));
	VAL v13;
	VAL v14;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v12, &v13, &v14);
	VAL v15 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v11, v13));
	VAL v16 = (mw_mirth_c99_ZPlusC99_indent(v14));
	int64_t v17 = VI64(VTUP(v15)->cells[1]);
	VAL v18 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v17);
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(v18, v16));
	STR* v20;
	STRLIT(v20, " ", 1);
	VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
	VAL v22 = VVAL(VTUP(v15)->cells[2]);
	incref(v22);
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(v22, v21));
	STR* v24;
	STRLIT(v24, " = ", 3);
	VAL v25 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v24), v23));
	VAL v26 = (mw_mirth_c99_ZPlusC99_varZ_put(x1, v25));
	STR* v27;
	STRLIT(v27, ";", 1);
	VAL v28 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v27), v26));
	VAL v29 = (mw_mirth_c99_ZPlusC99_line(v28));
	VTUP(x2)->cells[1] = v29;
	VAL v30 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, v15));
	return v30;
}
static VAL mw_mirth_c99_c99Z_lambdaZBang (VAL x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x2));
	VAL v4 = (mw_mirth_c99_ZPlusC99_indent(v3));
	STR* v5;
	STRLIT(v5, "{", 1);
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
	VAL v7 = (mw_mirth_c99_ZPlusC99_line(v6));
	int64_t v8 = VI64(VTUP(v7)->cells[2]);
	int64_t v9 = 1LL;
	int64_t v10 = i64_add(v8, v9);
	VTUP(v7)->cells[2] = MKI64(v10);
	VAL v11 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v7));
	incref(x1);
	VAL v12 = VVAL(VTUP(x1)->cells[4]);
	incref(v12);
	decref(x1);
	VAL v13 = mw_std_list_List_1_reverse(v12);
	VAL v14;
	VAL v15;
	mw_std_list_List_1_uncons(v13, &v14, &v15);
	VAL x16;
	VAL x17;
	VAL x18;
	int64_t x19;
	switch (get_data_tag(v14)) {
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(v14);
			VAL v21 = (mw_mirth_c99_c99Z_popZ_toZ_varZBang(VU64(v20), v11));
			int64_t v22 = 1LL /* True */;
			x19 = v22;
			x18 = v15;
			x17 = x1;
			x16 = v21;
		} break;
		case 0LL: { // None
			int64_t v23 = 0LL /* False */;
			x19 = v23;
			x18 = v15;
			x17 = x1;
			x16 = v11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v24 = (x16);
	VAL v25 = x17;
	VAL v26 = x18;
	int64_t v27 = x19;
	while (((bool)v27)) {
		VAL v28 = (v24);
		VAL v29 = v25;
		VAL v30 = v26;
		VAL v31;
		VAL v32;
		mw_std_list_List_1_uncons(v30, &v31, &v32);
		VAL x33;
		VAL x34;
		VAL x35;
		int64_t x36;
		switch (get_data_tag(v31)) {
			case 1LL: { // Some
				VAL v37 = mtp_std_maybe_Maybe_1_Some(v31);
				VAL v38 = (mw_mirth_c99_c99Z_popZ_toZ_varZBang(VU64(v37), v28));
				int64_t v39 = 1LL /* True */;
				x36 = v39;
				x35 = v32;
				x34 = v29;
				x33 = v38;
			} break;
			case 0LL: { // None
				int64_t v40 = 0LL /* False */;
				x36 = v40;
				x35 = v32;
				x34 = v29;
				x33 = v28;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v27 = x36;
		v26 = x35;
		v25 = x34;
		v24 = x33;
	}
	decref(v26);
	incref(v25);
	VAL v41 = VVAL(VTUP(v25)->cells[5]);
	incref(v41);
	decref(v25);
	VAL v42 = (mw_mirth_c99_c99Z_arrowZBang(v41, v24));
	VAL v43 = VVAL(VTUP(v25)->cells[4]);
	incref(v43);
	decref(v25);
	VAL v44 = mw_std_list_List_1_reverse(v43);
	VAL v45;
	VAL v46;
	mw_std_list_List_1_uncons(v44, &v45, &v46);
	VAL x47;
	VAL x48;
	int64_t x49;
	switch (get_data_tag(v45)) {
		case 1LL: { // Some
			VAL v50 = mtp_std_maybe_Maybe_1_Some(v45);
			VAL v51 = (VVAL(VTUP(v42)->cells[1]));
			VAL v52 = (mw_mirth_c99_ZPlusC99_indent(v51));
			STR* v53;
			STRLIT(v53, "decref(", 7);
			VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v53), v52));
			VAL v55 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v50), v54));
			STR* v56;
			STRLIT(v56, ");", 2);
			VAL v57 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v56), v55));
			VAL v58 = (mw_mirth_c99_ZPlusC99_line(v57));
			VTUP(v42)->cells[1] = v58;
			int64_t v59 = 1LL /* True */;
			x49 = v59;
			x48 = v46;
			x47 = v42;
		} break;
		case 0LL: { // None
			int64_t v60 = 0LL /* False */;
			x49 = v60;
			x48 = v46;
			x47 = v42;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v61 = (x47);
	VAL v62 = x48;
	int64_t v63 = x49;
	while (((bool)v63)) {
		VAL v64 = (v61);
		VAL v65 = v62;
		VAL v66;
		VAL v67;
		mw_std_list_List_1_uncons(v65, &v66, &v67);
		VAL x68;
		VAL x69;
		int64_t x70;
		switch (get_data_tag(v66)) {
			case 1LL: { // Some
				VAL v71 = mtp_std_maybe_Maybe_1_Some(v66);
				VAL v72 = (VVAL(VTUP(v64)->cells[1]));
				VAL v73 = (mw_mirth_c99_ZPlusC99_indent(v72));
				STR* v74;
				STRLIT(v74, "decref(", 7);
				VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v73));
				VAL v76 = (mw_mirth_c99_ZPlusC99_varZ_put(VU64(v71), v75));
				STR* v77;
				STRLIT(v77, ");", 2);
				VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v77), v76));
				VAL v79 = (mw_mirth_c99_ZPlusC99_line(v78));
				VTUP(v64)->cells[1] = v79;
				int64_t v80 = 1LL /* True */;
				x70 = v80;
				x69 = v67;
				x68 = v64;
			} break;
			case 0LL: { // None
				int64_t v81 = 0LL /* False */;
				x70 = v81;
				x69 = v67;
				x68 = v64;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v63 = x70;
		v62 = x69;
		v61 = x68;
	}
	decref(v62);
	VAL v82 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v61));
	int64_t v83 = VI64(VTUP(v82)->cells[2]);
	int64_t v84 = 1LL;
	int64_t v85 = i64_sub(v83, v84);
	int64_t v86 = 0LL;
	bool v87 = (v85 < v86);
	int64_t x88;
	if (v87) {
		int64_t v89 = 0LL;
		x88 = v89;
	} else {
		x88 = v85;
	}
	VTUP(v82)->cells[2] = MKI64(x88);
	VAL v90 = (mw_mirth_c99_ZPlusC99_indent(v82));
	STR* v91;
	STRLIT(v91, "}", 1);
	VAL v92 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v91), v90));
	VAL v93 = (mw_mirth_c99_ZPlusC99_line(v92));
	VAL v94 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v93));
	return v94;
}
static VAL mw_mirth_c99_c99Z_matchZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[7]);
	incref(v3);
	decref(x1);
	VAL v4 = mw_std_list_List_1_ZDivL1(v3);
	VAL x5;
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v4);
			decref(x1);
			VAL v7 = (mw_mirth_c99_c99Z_singleZ_caseZBang(v6, x2));
			x5 = v7;
		} break;
		case 0LL: { // None
			incref(x1);
			VAL v8 = mw_mirth_match_Match_scrutineeZ_dataZAsk(x1);
			VAL x9;
			VAL x10;
			uint64_t x11;
			switch (get_data_tag(v8)) {
				case 1LL: { // Some
					VAL v12 = mtp_std_maybe_Maybe_1_Some(v8);
					x11 = VU64(v12);
					x10 = x1;
					x9 = x2;
				} break;
				case 0LL: { // None
					uint64_t v13 = VU64(VTUP(x1)->cells[2]);
					decref(x1);
					STR* v14;
					STRLIT(v14, "non-uniform match, not supported at present", 43);
					VAL v15 = (VVAL(VTUP(x2)->cells[1]));
					VAL v16 = (VVAL(VTUP(v15)->cells[6]));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v13, MKSTR(v14), v16);
					VAL r17 = pop_resource();
					VTUP(v15)->cells[6] = r17;
					VTUP(x2)->cells[1] = v15;
					uint64_t v18 = pop_u64();
					x11 = v18;
					VAL v19 = pop_value();
					x10 = v19;
					x9 = x2;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v20;
			VAL v21;
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(x11, x9, &v20, &v21);
			incref(x10);
			VAL v22 = VVAL(VTUP(x10)->cells[6]);
			incref(v22);
			decref(x10);
			VAL v23 = (mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang(v22, v20));
			VAL v24 = (VVAL(VTUP(v23)->cells[1]));
			VAL v25 = (mw_mirth_c99_ZPlusC99_indent(v24));
			STR* v26;
			STRLIT(v26, "switch (", 8);
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v25));
			VAL v28;
			VAL v29;
			mw_mirth_c99_ZPlusC99LocalValueZDivResource_peekZ_dataZ_tag(v21, &v28, &v29);
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(v29, v27));
			STR* v31;
			STRLIT(v31, ") {", 3);
			VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
			VAL v33 = (mw_mirth_c99_ZPlusC99_line(v32));
			VTUP(v23)->cells[1] = v33;
			VAL v34 = (VVAL(VTUP(v23)->cells[1]));
			int64_t v35 = VI64(VTUP(v34)->cells[2]);
			int64_t v36 = 1LL;
			int64_t v37 = i64_add(v35, v36);
			VTUP(v34)->cells[2] = MKI64(v37);
			VTUP(v23)->cells[1] = v34;
			incref(x10);
			VAL v38 = VVAL(VTUP(x10)->cells[7]);
			incref(v38);
			decref(x10);
			VAL v39;
			VAL v40;
			mw_std_list_List_1_uncons(v38, &v39, &v40);
			VAL x41;
			VAL x42;
			VAL x43;
			VAL x44;
			int64_t x45;
			switch (get_data_tag(v39)) {
				case 1LL: { // Some
					VAL v46 = mtp_std_maybe_Maybe_1_Some(v39);
					VAL v47;
					VAL v48;
					mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v28, &v47, &v48);
					VAL v49 = (mw_mirth_c99_c99Z_caseZBang(v46, v23, v47));
					int64_t v50 = 1LL /* True */;
					x45 = v50;
					x44 = v40;
					x43 = x10;
					x42 = v49;
					x41 = v48;
				} break;
				case 0LL: { // None
					int64_t v51 = 0LL /* False */;
					x45 = v51;
					x44 = v40;
					x43 = x10;
					x42 = v23;
					x41 = v28;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			VAL v52 = x41;
			VAL v53 = (x42);
			VAL v54 = x43;
			VAL v55 = x44;
			int64_t v56 = x45;
			while (((bool)v56)) {
				VAL v57 = v52;
				VAL v58 = (v53);
				VAL v59 = v54;
				VAL v60 = v55;
				VAL v61;
				VAL v62;
				mw_std_list_List_1_uncons(v60, &v61, &v62);
				VAL x63;
				VAL x64;
				VAL x65;
				VAL x66;
				int64_t x67;
				switch (get_data_tag(v61)) {
					case 1LL: { // Some
						VAL v68 = mtp_std_maybe_Maybe_1_Some(v61);
						VAL v69;
						VAL v70;
						mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v57, &v69, &v70);
						VAL v71 = (mw_mirth_c99_c99Z_caseZBang(v68, v58, v69));
						int64_t v72 = 1LL /* True */;
						x67 = v72;
						x66 = v62;
						x65 = v59;
						x64 = v71;
						x63 = v70;
					} break;
					case 0LL: { // None
						int64_t v73 = 0LL /* False */;
						x67 = v73;
						x66 = v62;
						x65 = v59;
						x64 = v58;
						x63 = v57;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				v56 = x67;
				v55 = x66;
				v54 = x65;
				v53 = x64;
				v52 = x63;
			}
			decref(v55);
			int64_t v74 = mw_mirth_match_Match_hasZ_defaultZ_caseZAsk(v54);
			VAL x75;
			VAL x76;
			if (((bool)v74)) {
				x76 = v53;
				x75 = v52;
			} else {
				VAL v77 = (VVAL(VTUP(v53)->cells[1]));
				VAL v78 = (mw_mirth_c99_ZPlusC99_indent(v77));
				STR* v79;
				STRLIT(v79, "default: {", 10);
				VAL v80 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v79), v78));
				VAL v81 = (mw_mirth_c99_ZPlusC99_line(v80));
				VTUP(v53)->cells[1] = v81;
				VAL v82 = (VVAL(VTUP(v53)->cells[1]));
				int64_t v83 = VI64(VTUP(v82)->cells[2]);
				int64_t v84 = 1LL;
				int64_t v85 = i64_add(v83, v84);
				VTUP(v82)->cells[2] = MKI64(v85);
				VTUP(v53)->cells[1] = v82;
				VAL v86 = (VVAL(VTUP(v53)->cells[1]));
				VAL v87 = (mw_mirth_c99_ZPlusC99_indent(v86));
				STR* v88;
				STRLIT(v88, "do_panic(str_make(\"unexpected fallthrough in match\\n\", 32));", 60);
				VAL v89 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v88), v87));
				VAL v90 = (mw_mirth_c99_ZPlusC99_line(v89));
				VTUP(v53)->cells[1] = v90;
				VAL v91 = (VVAL(VTUP(v53)->cells[1]));
				int64_t v92 = VI64(VTUP(v91)->cells[2]);
				int64_t v93 = 1LL;
				int64_t v94 = i64_sub(v92, v93);
				int64_t v95 = 0LL;
				bool v96 = (v94 < v95);
				int64_t x97;
				if (v96) {
					int64_t v98 = 0LL;
					x97 = v98;
					lpush(&lbl_ZPlusscrutinee, v52);
				} else {
					x97 = v94;
					lpush(&lbl_ZPlusscrutinee, v52);
				}
				VTUP(v91)->cells[2] = MKI64(x97);
				VTUP(v53)->cells[1] = v91;
				VAL v99 = (VVAL(VTUP(v53)->cells[1]));
				VAL v100 = (mw_mirth_c99_ZPlusC99_indent(v99));
				STR* v101;
				STRLIT(v101, "}", 1);
				VAL v102 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v101), v100));
				VAL v103 = (mw_mirth_c99_ZPlusC99_line(v102));
				VTUP(v53)->cells[1] = v103;
				x76 = v53;
				VAL v104 = (lpop(&lbl_ZPlusscrutinee));
				x75 = v104;
			}
			mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop(x75);
			VAL v105 = (VVAL(VTUP(x76)->cells[1]));
			int64_t v106 = VI64(VTUP(v105)->cells[2]);
			int64_t v107 = 1LL;
			int64_t v108 = i64_sub(v106, v107);
			int64_t v109 = 0LL;
			bool v110 = (v108 < v109);
			int64_t x111;
			if (v110) {
				int64_t v112 = 0LL;
				x111 = v112;
			} else {
				x111 = v108;
			}
			VTUP(v105)->cells[2] = MKI64(x111);
			VTUP(x76)->cells[1] = v105;
			VAL v113 = (VVAL(VTUP(x76)->cells[1]));
			VAL v114 = (mw_mirth_c99_ZPlusC99_indent(v113));
			STR* v115;
			STRLIT(v115, "}", 1);
			VAL v116 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v115), v114));
			VAL v117 = (mw_mirth_c99_ZPlusC99_line(v116));
			VTUP(x76)->cells[1] = v117;
			VAL v118 = (mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang(x76));
			x5 = v118;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	return x5;
}
static VAL mw_mirth_c99_c99Z_singleZ_caseZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v3 = VVAL(VTUP(x1)->cells[1]);
	incref(v3);
	decref(x1);
	int64_t v4 = mw_mirth_match_Pattern_isZ_defaultZAsk(v3);
	VAL x5;
	if (((bool)v4)) {
		VAL v6 = VVAL(VTUP(x1)->cells[2]);
		incref(v6);
		decref(x1);
		VAL v7 = (mw_mirth_c99_c99Z_arrowZBang(v6, x2));
		x5 = v7;
	} else {
		incref(x1);
		VAL v8 = VVAL(VTUP(x1)->cells[1]);
		incref(v8);
		decref(x1);
		VAL v9 = mw_mirth_match_Pattern_singleZ_tagZAsk(v8);
		VAL x10;
		switch (get_data_tag(v9)) {
			case 1LL: { // Some
				VAL v11 = mtp_std_maybe_Maybe_1_Some(v9);
				VAL v12 = (mw_mirth_c99_c99Z_reverseZ_tagZBang(VU64(v11), x2));
				VAL v13 = VVAL(VTUP(x1)->cells[2]);
				incref(v13);
				decref(x1);
				VAL v14 = (mw_mirth_c99_c99Z_arrowZBang(v13, v12));
				x10 = v14;
			} break;
			case 0LL: { // None
				VAL v15 = VVAL(VTUP(x1)->cells[1]);
				incref(v15);
				decref(x1);
				uint64_t v16 = VU64(VTUP(v15)->cells[2]);
				decref(v15);
				STR* v17;
				STRLIT(v17, "c99 target -- don't know how to compile this pattern", 52);
				VAL v18 = (VVAL(VTUP(x2)->cells[1]));
				VAL v19 = (VVAL(VTUP(v18)->cells[6]));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v16, MKSTR(v17), v19);
				VAL r20 = pop_resource();
				VTUP(v18)->cells[6] = r20;
				VTUP(x2)->cells[1] = v18;
				x10 = x2;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x5 = x10;
	}
	return x5;
}
static VAL mw_mirth_c99_c99Z_caseZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v4 = VVAL(VTUP(x1)->cells[1]);
	incref(v4);
	decref(x1);
	int64_t v5 = mw_mirth_match_Pattern_isZ_defaultZAsk(v4);
	VAL x6;
	if (((bool)v5)) {
		VAL v7 = (VVAL(VTUP(x2)->cells[1]));
		VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v7));
		STR* v9;
		STRLIT(v9, "default: {", 10);
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
		VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
		VTUP(x2)->cells[1] = v11;
		VAL v12 = (VVAL(VTUP(x2)->cells[1]));
		int64_t v13 = VI64(VTUP(v12)->cells[2]);
		int64_t v14 = 1LL;
		int64_t v15 = i64_add(v13, v14);
		VTUP(v12)->cells[2] = MKI64(v15);
		VTUP(x2)->cells[1] = v12;
		VAL v16 = (VVAL(VTUP(x2)->cells[2]));
		VAL v17;
		VAL v18;
		mw_mirth_c99_ZPlusC99StackCache_rdup(v16, &v17, &v18);
		VTUP(x2)->cells[2] = v17;
		VAL v19 = VVAL(VTUP(x2)->cells[3]);
		incref(v19);
		VAL v20 = (VVAL(VTUP(x2)->cells[1]));
		VAL v21 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(v20, v18));
		push_value(x1);
		VAL v22 = (mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang(v21, x3));
		VAL v23 = pop_value();
		VAL v24 = VVAL(VTUP(v23)->cells[2]);
		incref(v24);
		decref(v23);
		VAL v25 = (mw_mirth_c99_c99Z_arrowZBang(v24, v22));
		VAL v26 = mw_std_list_List_1_reverse(v19);
		VAL v27;
		VAL v28;
		mw_std_list_List_1_uncons(v26, &v27, &v28);
		VAL x29;
		VAL x30;
		int64_t x31;
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				VAL v32 = mtp_std_maybe_Maybe_1_Some(v27);
				VAL v33 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v32, v25));
				int64_t v34 = 1LL /* True */;
				x31 = v34;
				x30 = v28;
				x29 = v33;
			} break;
			case 0LL: { // None
				int64_t v35 = 0LL /* False */;
				x31 = v35;
				x30 = v28;
				x29 = v25;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v36 = (x29);
		VAL v37 = x30;
		int64_t v38 = x31;
		while (((bool)v38)) {
			VAL v39 = (v36);
			VAL v40 = v37;
			VAL v41;
			VAL v42;
			mw_std_list_List_1_uncons(v40, &v41, &v42);
			VAL x43;
			VAL x44;
			int64_t x45;
			switch (get_data_tag(v41)) {
				case 1LL: { // Some
					VAL v46 = mtp_std_maybe_Maybe_1_Some(v41);
					VAL v47 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v46, v39));
					int64_t v48 = 1LL /* True */;
					x45 = v48;
					x44 = v42;
					x43 = v47;
				} break;
				case 0LL: { // None
					int64_t v49 = 0LL /* False */;
					x45 = v49;
					x44 = v42;
					x43 = v39;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v38 = x45;
			v37 = x44;
			v36 = x43;
		}
		decref(v37);
		VAL v50 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v36));
		VTUP(x2)->cells[1] = v50;
		VAL v51 = (VVAL(VTUP(x2)->cells[1]));
		int64_t v52 = VI64(VTUP(v51)->cells[2]);
		int64_t v53 = 1LL;
		int64_t v54 = i64_sub(v52, v53);
		int64_t v55 = 0LL;
		bool v56 = (v54 < v55);
		int64_t x57;
		if (v56) {
			int64_t v58 = 0LL;
			x57 = v58;
		} else {
			x57 = v54;
		}
		VTUP(v51)->cells[2] = MKI64(x57);
		VTUP(x2)->cells[1] = v51;
		VAL v59 = (VVAL(VTUP(x2)->cells[1]));
		VAL v60 = (mw_mirth_c99_ZPlusC99_indent(v59));
		STR* v61;
		STRLIT(v61, "} break;", 8);
		VAL v62 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v61), v60));
		VAL v63 = (mw_mirth_c99_ZPlusC99_line(v62));
		VTUP(x2)->cells[1] = v63;
		x6 = x2;
	} else {
		incref(x1);
		VAL v64 = VVAL(VTUP(x1)->cells[1]);
		incref(v64);
		decref(x1);
		VAL v65 = mw_mirth_match_Pattern_singleZ_tagZAsk(v64);
		VAL x66;
		switch (get_data_tag(v65)) {
			case 1LL: { // Some
				VAL v67 = mtp_std_maybe_Maybe_1_Some(v65);
				VAL v68 = (VVAL(VTUP(x2)->cells[1]));
				VAL v69 = (mw_mirth_c99_ZPlusC99_indent(v68));
				STR* v70;
				STRLIT(v70, "case ", 5);
				VAL v71 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v70), v69));
				incref(v67);
				VAL v72 = mw_mirth_data_Tag_valueZ_show(VU64(v67));
				VAL v73 = (mw_mirth_c99_ZPlusC99_put(v72, v71));
				STR* v74;
				STRLIT(v74, "LL: { // ", 9);
				VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v73));
				incref(v67);
				uint64_t v76 = mw_mirth_data_Tag_name(VU64(v67));
				VAL v77 = mw_mirth_name_Name_ZToStr(v76);
				VAL v78 = (mw_mirth_c99_ZPlusC99_put(v77, v75));
				VAL v79 = (mw_mirth_c99_ZPlusC99_line(v78));
				VTUP(x2)->cells[1] = v79;
				VAL v80 = (VVAL(VTUP(x2)->cells[1]));
				int64_t v81 = VI64(VTUP(v80)->cells[2]);
				int64_t v82 = 1LL;
				int64_t v83 = i64_add(v81, v82);
				VTUP(v80)->cells[2] = MKI64(v83);
				VTUP(x2)->cells[1] = v80;
				VAL v84 = (VVAL(VTUP(x2)->cells[2]));
				VAL v85;
				VAL v86;
				mw_mirth_c99_ZPlusC99StackCache_rdup(v84, &v85, &v86);
				VTUP(x2)->cells[2] = v85;
				VAL v87 = VVAL(VTUP(x2)->cells[3]);
				incref(v87);
				VAL v88 = (VVAL(VTUP(x2)->cells[1]));
				VAL v89 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(v88, v86));
				push_value(x1);
				push_value(v67);
				VAL v90 = (mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang(v89, x3));
				uint64_t v91 = pop_u64();
				VAL v92 = (mw_mirth_c99_c99Z_reverseZ_tagZBang(v91, v90));
				VAL v93 = pop_value();
				VAL v94 = VVAL(VTUP(v93)->cells[2]);
				incref(v94);
				decref(v93);
				VAL v95 = (mw_mirth_c99_c99Z_arrowZBang(v94, v92));
				VAL v96 = mw_std_list_List_1_reverse(v87);
				VAL v97;
				VAL v98;
				mw_std_list_List_1_uncons(v96, &v97, &v98);
				VAL x99;
				VAL x100;
				int64_t x101;
				switch (get_data_tag(v97)) {
					case 1LL: { // Some
						VAL v102 = mtp_std_maybe_Maybe_1_Some(v97);
						VAL v103 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v102, v95));
						int64_t v104 = 1LL /* True */;
						x101 = v104;
						x100 = v98;
						x99 = v103;
					} break;
					case 0LL: { // None
						int64_t v105 = 0LL /* False */;
						x101 = v105;
						x100 = v98;
						x99 = v95;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				VAL v106 = (x99);
				VAL v107 = x100;
				int64_t v108 = x101;
				while (((bool)v108)) {
					VAL v109 = (v106);
					VAL v110 = v107;
					VAL v111;
					VAL v112;
					mw_std_list_List_1_uncons(v110, &v111, &v112);
					VAL x113;
					VAL x114;
					int64_t x115;
					switch (get_data_tag(v111)) {
						case 1LL: { // Some
							VAL v116 = mtp_std_maybe_Maybe_1_Some(v111);
							VAL v117 = (mw_mirth_c99_C99APIArg_popZ_toZ_reservedZBang(v116, v109));
							int64_t v118 = 1LL /* True */;
							x115 = v118;
							x114 = v112;
							x113 = v117;
						} break;
						case 0LL: { // None
							int64_t v119 = 0LL /* False */;
							x115 = v119;
							x114 = v112;
							x113 = v109;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					v108 = x115;
					v107 = x114;
					v106 = x113;
				}
				decref(v107);
				VAL v120 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v106));
				VTUP(x2)->cells[1] = v120;
				VAL v121 = (VVAL(VTUP(x2)->cells[1]));
				int64_t v122 = VI64(VTUP(v121)->cells[2]);
				int64_t v123 = 1LL;
				int64_t v124 = i64_sub(v122, v123);
				int64_t v125 = 0LL;
				bool v126 = (v124 < v125);
				int64_t x127;
				if (v126) {
					int64_t v128 = 0LL;
					x127 = v128;
				} else {
					x127 = v124;
				}
				VTUP(v121)->cells[2] = MKI64(x127);
				VTUP(x2)->cells[1] = v121;
				VAL v129 = (VVAL(VTUP(x2)->cells[1]));
				VAL v130 = (mw_mirth_c99_ZPlusC99_indent(v129));
				STR* v131;
				STRLIT(v131, "} break;", 8);
				VAL v132 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v131), v130));
				VAL v133 = (mw_mirth_c99_ZPlusC99_line(v132));
				VTUP(x2)->cells[1] = v133;
				x66 = x2;
			} break;
			case 0LL: { // None
				VAL v134 = VVAL(VTUP(x1)->cells[1]);
				incref(v134);
				decref(x1);
				uint64_t v135 = VU64(VTUP(v134)->cells[2]);
				decref(v134);
				STR* v136;
				STRLIT(v136, "c99 target -- don't know how to compile this pattern", 52);
				VAL v137 = (VVAL(VTUP(x2)->cells[1]));
				VAL v138 = (VVAL(VTUP(v137)->cells[6]));
				lpush(&lbl_ZPlusscrutinee, x3);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v135, MKSTR(v136), v138);
				VAL r139 = pop_resource();
				VTUP(v137)->cells[6] = r139;
				VTUP(x2)->cells[1] = v137;
				x66 = x2;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		x6 = x66;
	}
	return x6;
}
static void mw_mirth_data_Tag_wordZ_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_wordZ_cname(x2, x1, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_data_Tag_type(v6, x1, &v8, &v9);
	*x5 = v8;
	*x4 = v9;
	*x3 = v7;
}
static void mw_mirth_data_Tag_patZ_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_patZ_cname(x2, x1, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_data_Tag_type(v6, x1, &v8, &v9);
	VAL v10 = mw_mirth_type_ArrowType_invert(v9);
	*x5 = v8;
	*x4 = v10;
	*x3 = v7;
}
static void mw_mirth_word_Word_cnameZ_type (uint64_t x1, VAL x2, VAL *x3, VAL *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	mw_mirth_word_Word_cname(x1, x2, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_word_Word_type(x1, v7, &v8, &v9);
	*x5 = v9;
	*x4 = v8;
	*x3 = v6;
}
static void mw_mirth_data_Tag_wordZ_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Tag_ZTildewordZ_c99Z_api(x1);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x1;
		x7 = x2;
	} else {
		VAL v11 = (VVAL(VTUP(x2)->cells[6]));
		VAL v12;
		VAL v13;
		VAL v14;
		mw_mirth_data_Tag_wordZ_cnameZ_type(x1, v11, &v12, &v13, &v14);
		VTUP(x2)->cells[6] = v14;
		VAL v15;
		VAL v16;
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v12, v13, x2, &v15, &v16);
		incref(v15);
		mut_set(v15, v5);
		x9 = v15;
		x8 = x1;
		x7 = v16;
	}
	*x4 = x7;
	*x3 = x9;
}
static void mw_mirth_data_Tag_patZ_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_data_Tag_ZTildepatZ_c99Z_api(x1);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x1;
		x7 = x2;
	} else {
		VAL v11 = (VVAL(VTUP(x2)->cells[6]));
		VAL v12;
		VAL v13;
		VAL v14;
		mw_mirth_data_Tag_patZ_cnameZ_type(x1, v11, &v12, &v13, &v14);
		VTUP(x2)->cells[6] = v14;
		VAL v15;
		VAL v16;
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v12, v13, x2, &v15, &v16);
		incref(v15);
		mut_set(v15, v5);
		x9 = v15;
		x8 = x1;
		x7 = v16;
	}
	*x4 = x7;
	*x3 = x9;
}
static void mw_mirth_word_Word_c99Z_api (uint64_t x1, VAL x2, VAL *x3, VAL *x4) {
	void* v5 = mfld_mirth_word_Word_ZTildec99Z_api(x1);
	bool v6 = mut_is_set(v5);
	VAL x7;
	uint64_t x8;
	VAL x9;
	if (v6) {
		VAL v10 = mut_get(v5);
		x9 = v10;
		x8 = x1;
		x7 = x2;
	} else {
		VAL v11 = (VVAL(VTUP(x2)->cells[6]));
		VAL v12;
		VAL v13;
		VAL v14;
		mw_mirth_word_Word_cnameZ_type(x1, v11, &v12, &v13, &v14);
		VTUP(x2)->cells[6] = v14;
		VAL v15;
		VAL v16;
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v12, v13, x2, &v15, &v16);
		incref(v15);
		mut_set(v15, v5);
		x9 = v15;
		x8 = x1;
		x7 = v16;
	}
	*x4 = x7;
	*x3 = x9;
}
static VAL mw_mirth_c99_c99Z_wordZ_sigsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_word_Word_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (VVAL(VTUP(v9)->cells[4]));
		int64_t v12;
		VAL v13;
		mw_mirth_word_Word_neededZAsk(((uint64_t)v10), v11, &v12, &v13);
		VTUP(v9)->cells[4] = v13;
		VAL x14;
		if (((bool)v12)) {
			VAL v15 = (mw_mirth_c99_c99Z_wordZ_sigZBang(((uint64_t)v10), v9));
			x14 = v15;
		} else {
			x14 = v9;
		}
		int64_t v16 = 1LL;
		int64_t v17 = i64_add(v10, v16);
		void* v18 = mbuf_mirth_word_Word_NUM;
		int64_t v19 = *(int64_t*)v18;
		bool v20 = (v17 <= v19);
		v8 = v20;
		v7 = v17;
		v6 = x14;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_wordZ_sigZBang (uint64_t x1, VAL x2) {
	VAL v3;
	VAL v4;
	mw_mirth_word_Word_c99Z_api(x1, x2, &v3, &v4);
	VAL v5 = (mw_mirth_c99_c99Z_smartZ_sigZBang(v3, v4));
	return v5;
}
static VAL mw_mirth_c99_c99Z_blockZ_sigsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_arrow_Block_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (VVAL(VTUP(v9)->cells[4]));
		int64_t v12;
		VAL v13;
		mw_mirth_arrow_Block_neededZAsk(((uint64_t)v10), v11, &v12, &v13);
		VTUP(v9)->cells[4] = v13;
		VAL x14;
		if (((bool)v12)) {
			VAL v15 = (mw_mirth_c99_c99Z_blockZ_sigZBang(((uint64_t)v10), v9));
			x14 = v15;
		} else {
			x14 = v9;
		}
		int64_t v16 = 1LL;
		int64_t v17 = i64_add(v10, v16);
		void* v18 = mbuf_mirth_arrow_Block_NUM;
		int64_t v19 = *(int64_t*)v18;
		bool v20 = (v17 <= v19);
		v8 = v20;
		v7 = v17;
		v6 = x14;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_blockZ_sigZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(x2));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_cname(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VAL v7 = (mw_mirth_c99_ZPlusC99_sigZ_put(v6, v3));
	STR* v8;
	STRLIT(v8, ";", 1);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
	VAL v10 = (mw_mirth_c99_ZPlusC99_line(v9));
	return v10;
}
static VAL mw_mirth_c99_c99Z_blockZ_enterZBang (uint64_t x1, VAL x2) {
	VAL v3 = VVAL(VTUP(x2)->cells[1]);
	incref(v3);
	int64_t v4 = VI64(VTUP(v3)->cells[2]);
	decref(v3);
	VAL x5;
	if (((bool)v4)) {
		VAL v6 = (mw_mirth_c99_ZPlusC99_indent(x2));
		STR* v7;
		STRLIT(v7, "WORD_ENTER(", 11);
		VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
		VAL v9 = mw_mirth_arrow_Block_home(x1);
		VAL x10;
		uint64_t x11;
		VAL x12;
		switch (get_data_tag(v9)) {
			case 0LL: { // HomeMain
				uint64_t v13 = mtp_mirth_arrow_Home_HomeMain(v9);
				STR* v14;
				STRLIT(v14, "block", 5);
				x12 = MKSTR(v14);
				x11 = x1;
				x10 = v8;
			} break;
			case 1LL: { // HomeWord
				uint64_t v15 = mtp_mirth_arrow_Home_HomeWord(v9);
				uint64_t v16 = mw_mirth_word_Word_name(v15);
				VAL v17 = mw_mirth_name_Name_ZToStr(v16);
				STR* v18;
				STRLIT(v18, " block", 6);
				STR* v19 = str_cat(VSTR(v17), v18);
				x12 = MKSTR(v19);
				x11 = x1;
				x10 = v8;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v20 = (mw_mirth_c99_ZPlusC99_putZ_cstr(x12, x10));
		STR* v21;
		STRLIT(v21, ", ", 2);
		VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
		uint64_t v23 = mw_mirth_arrow_Block_token(x11);
		uint64_t v24 = mw_mirth_token_Token_module(v23);
		VAL v25 = mw_mirth_module_Module_sourceZ_path(v24);
		VAL v26 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v25, v22));
		STR* v27;
		STRLIT(v27, ", ", 2);
		VAL v28 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v27), v26));
		uint64_t v29 = mw_mirth_arrow_Block_token(x11);
		int64_t v30 = mw_mirth_token_Token_row(v29);
		int64_t v31 = mw_mirth_location_Row_ZToInt(v30);
		STR* v32 = i64_show(v31);
		VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v28));
		STR* v34;
		STRLIT(v34, ", ", 2);
		VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v34), v33));
		uint64_t v36 = mw_mirth_arrow_Block_token(x11);
		int64_t v37 = mw_mirth_token_Token_col(v36);
		int64_t v38 = mw_mirth_location_Col_ZToInt(v37);
		STR* v39 = i64_show(v38);
		VAL v40 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v39), v35));
		STR* v41;
		STRLIT(v41, ");", 2);
		VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), v40));
		VAL v43 = (mw_mirth_c99_ZPlusC99_line(v42));
		x5 = v43;
	} else {
		x5 = x2;
	}
	VAL v44 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(x5));
	return v44;
}
static VAL mw_mirth_c99_c99Z_blockZ_exitZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x2));
	VAL v4 = VVAL(VTUP(v3)->cells[1]);
	incref(v4);
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	decref(v4);
	VAL x6;
	if (((bool)v5)) {
		VAL v7 = (mw_mirth_c99_ZPlusC99_indent(v3));
		STR* v8;
		STRLIT(v8, "WORD_EXIT;", 10);
		VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
		VAL v10 = (mw_mirth_c99_ZPlusC99_line(v9));
		x6 = v10;
	} else {
		x6 = v3;
	}
	return x6;
}
static VAL mw_mirth_c99_c99Z_blockZ_defsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_arrow_Block_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (VVAL(VTUP(v9)->cells[4]));
		int64_t v12;
		VAL v13;
		mw_mirth_arrow_Block_neededZAsk(((uint64_t)v10), v11, &v12, &v13);
		VTUP(v9)->cells[4] = v13;
		VAL x14;
		if (((bool)v12)) {
			VAL v15 = (mw_mirth_c99_c99Z_blockZ_defZBang(((uint64_t)v10), v9));
			x14 = v15;
		} else {
			x14 = v9;
		}
		int64_t v16 = 1LL;
		int64_t v17 = i64_add(v10, v16);
		void* v18 = mbuf_mirth_arrow_Block_NUM;
		int64_t v19 = *(int64_t*)v18;
		bool v20 = (v17 <= v19);
		v8 = v20;
		v7 = v17;
		v6 = x14;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_blockZ_defZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(x2));
	VAL v4 = (VVAL(VTUP(v3)->cells[6]));
	VAL v5;
	VAL v6;
	mw_mirth_arrow_Block_cname(v4, x1, &v5, &v6);
	VTUP(v3)->cells[6] = v5;
	VAL v7 = (mw_mirth_c99_ZPlusC99_sigZ_put(v6, v3));
	STR* v8;
	STRLIT(v8, " {", 2);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
	VAL v10 = (mw_mirth_c99_ZPlusC99_line(v9));
	VAL v11 = (mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang(v10));
	int64_t v12 = VI64(VTUP(v11)->cells[2]);
	int64_t v13 = 1LL;
	int64_t v14 = i64_add(v12, v13);
	VTUP(v11)->cells[2] = MKI64(v14);
	VAL v15 = (mw_mirth_c99_c99Z_blockZ_enterZBang(x1, v11));
	VAL v16 = (VVAL(VTUP(v15)->cells[1]));
	VAL v17 = (VVAL(VTUP(v16)->cells[6]));
	VAL v18;
	VAL v19;
	mw_mirth_arrow_Block_arrow(v17, x1, &v18, &v19);
	VTUP(v16)->cells[6] = v18;
	VTUP(v15)->cells[1] = v16;
	incref(v19);
	VAL v20 = (VVAL(VTUP(v15)->cells[1]));
	VAL v21 = (VVAL(VTUP(v20)->cells[6]));
	VAL v22;
	VAL v23;
	mw_mirth_arrow_Arrow_freeZ_vars(v21, v19, &v22, &v23);
	VTUP(v20)->cells[6] = v22;
	VTUP(v15)->cells[1] = v20;
	VAL v24 = (mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang(v23, v15));
	incref(v19);
	VAL v25 = (VVAL(VTUP(v24)->cells[1]));
	VAL v26 = (VVAL(VTUP(v25)->cells[6]));
	VAL v27 = mw_mirth_arrow_Arrow_type(v19);
	VTUP(v25)->cells[6] = v26;
	VTUP(v24)->cells[1] = v25;
	VAL v28 = mw_mirth_type_ArrowType_dom(v27);
	VAL v29 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v28, v24));
	incref(v19);
	VAL v30 = (mw_mirth_c99_c99Z_arrowZBang(v19, v29));
	VAL v31 = (VVAL(VTUP(v30)->cells[1]));
	VAL v32 = (VVAL(VTUP(v31)->cells[6]));
	VAL v33;
	VAL v34;
	mw_mirth_arrow_Arrow_freeZ_vars(v32, v19, &v33, &v34);
	VTUP(v31)->cells[6] = v33;
	VTUP(v30)->cells[1] = v31;
	VAL v35 = (mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang(v34, v30));
	VAL v36 = (mw_mirth_c99_c99Z_blockZ_exitZBang(x1, v35));
	int64_t v37 = VI64(VTUP(v36)->cells[2]);
	int64_t v38 = 1LL;
	int64_t v39 = i64_sub(v37, v38);
	int64_t v40 = 0LL;
	bool v41 = (v39 < v40);
	int64_t x42;
	if (v41) {
		int64_t v43 = 0LL;
		x42 = v43;
	} else {
		x42 = v39;
	}
	VTUP(v36)->cells[2] = MKI64(x42);
	VAL v44 = (mw_mirth_c99_ZPlusC99_indent(v36));
	STR* v45;
	STRLIT(v45, "}", 1);
	VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v44));
	VAL v47 = (mw_mirth_c99_ZPlusC99_line(v46));
	return v47;
}
static VAL mw_mirth_c99_exposeZ_stackZ_typeZBang (VAL x1, VAL x2) {
	VAL x3;
	switch (get_data_tag(x1)) {
		case 4LL: { // STMeta
			uint64_t v4 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v5 = mw_mirth_type_MetaVar_typeZAsk(v4);
			VAL x6;
			switch (get_data_tag(v5)) {
				case 0LL: { // None
					x6 = x2;
				} break;
				case 1LL: { // Some
					VAL v7 = mtp_std_maybe_Maybe_1_Some(v5);
					VAL v8 = mw_mirth_type_Type_expand(v7);
					incref(v8);
					VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
					void* v10 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v4);
					mut_set(v9, v10);
					VAL v11 = mw_mirth_type_Type_ZToStackType(v8);
					VAL v12 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v11, x2));
					x6 = v12;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x3 = x6;
		} break;
		case 5LL: { // STCons
			VAL v13;
			VAL v14;
			mtp_mirth_type_StackType_STCons(x1, &v13, &v14);
			int64_t v15;
			VAL v16;
			mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v14, x2, &v15, &v16);
			VAL v17;
			VAL v18;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v16, v15, &v17, &v18);
			VAL v19 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v13, v17));
			VAL v20 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v19, v18));
			x3 = v20;
		} break;
		case 7LL: { // STWith
			VAL v21;
			VAL v22;
			mtp_mirth_type_StackType_STWith(x1, &v21, &v22);
			int64_t v23;
			VAL v24;
			mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v22, x2, &v23, &v24);
			VAL v25;
			VAL v26;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(v24, v23, &v25, &v26);
			VAL v27 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v21, v25));
			VAL v28 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v27, v26));
			x3 = v28;
		} break;
		case 6LL: { // STConsLabel
			VAL v29;
			VAL v30;
			uint64_t v31;
			mtp_mirth_type_StackType_STConsLabel(x1, &v29, &v30, &v31);
			int64_t v32;
			VAL v33;
			mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v30, x2, &v32, &v33);
			VAL v34;
			VAL v35;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v32, v31, v33, &v34, &v35);
			VAL v36 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v29, v34));
			VAL v37 = (mw_mirth_c99_pushZ_localZ_labelZBang(v31, v36, v35));
			x3 = v37;
		} break;
		case 8LL: { // STWithLabel
			VAL v38;
			VAL v39;
			uint64_t v40;
			mtp_mirth_type_StackType_STWithLabel(x1, &v38, &v39, &v40);
			int64_t v41;
			VAL v42;
			mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v39, x2, &v41, &v42);
			VAL v43;
			VAL v44;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v41, v40, v42, &v43, &v44);
			VAL v45 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v38, v43));
			VAL v46 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v40, v45, v44));
			x3 = v46;
		} break;
		default: {
			decref(x1);
			x3 = x2;
		} break;
	}
	return x3;
}
static VAL mw_mirth_c99_c99Z_wordZ_enterZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = VVAL(VTUP(v3)->cells[1]);
	incref(v4);
	VTUP(x2)->cells[1] = v3;
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	decref(v4);
	uint64_t x6;
	VAL x7;
	if (((bool)v5)) {
		VAL v8 = (VVAL(VTUP(x2)->cells[1]));
		VAL v9 = (mw_mirth_c99_ZPlusC99_indent(v8));
		STR* v10;
		STRLIT(v10, "WORD_ENTER(", 11);
		VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
		uint64_t v12 = mw_mirth_word_Word_name(x1);
		VAL v13 = mw_mirth_name_Name_ZToStr(v12);
		VAL v14 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v13, v11));
		STR* v15;
		STRLIT(v15, ", ", 2);
		VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
		uint64_t v17 = mw_mirth_word_Word_body(x1);
		uint64_t v18 = mw_mirth_token_Token_module(v17);
		VAL v19 = mw_mirth_module_Module_sourceZ_path(v18);
		VAL v20 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v19, v16));
		STR* v21;
		STRLIT(v21, ", ", 2);
		VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
		uint64_t v23 = mw_mirth_word_Word_body(x1);
		int64_t v24 = mw_mirth_token_Token_row(v23);
		int64_t v25 = mw_mirth_location_Row_ZToInt(v24);
		STR* v26 = i64_show(v25);
		VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v22));
		STR* v28;
		STRLIT(v28, ", ", 2);
		VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
		uint64_t v30 = mw_mirth_word_Word_body(x1);
		int64_t v31 = mw_mirth_token_Token_col(v30);
		int64_t v32 = mw_mirth_location_Col_ZToInt(v31);
		STR* v33 = i64_show(v32);
		VAL v34 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), v29));
		STR* v35;
		STRLIT(v35, ");", 2);
		VAL v36 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), v34));
		VAL v37 = (mw_mirth_c99_ZPlusC99_line(v36));
		VTUP(x2)->cells[1] = v37;
		x7 = x2;
		x6 = x1;
	} else {
		x7 = x2;
		x6 = x1;
	}
	return x7;
}
static VAL mw_mirth_c99_c99Z_wordZ_exitZBang (uint64_t x1, VAL x2) {
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	VAL v4 = VVAL(VTUP(v3)->cells[1]);
	incref(v4);
	VTUP(x2)->cells[1] = v3;
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	decref(v4);
	VAL x6;
	if (((bool)v5)) {
		VAL v7 = (VVAL(VTUP(x2)->cells[1]));
		VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v7));
		STR* v9;
		STRLIT(v9, "WORD_EXIT;", 10);
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
		VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
		VTUP(x2)->cells[1] = v11;
		x6 = x2;
	} else {
		x6 = x2;
	}
	return x6;
}
static VAL mw_mirth_c99_c99Z_wordZ_defsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_word_Word_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (VVAL(VTUP(v9)->cells[4]));
		int64_t v12;
		VAL v13;
		mw_mirth_word_Word_neededZAsk(((uint64_t)v10), v11, &v12, &v13);
		VTUP(v9)->cells[4] = v13;
		VAL x14;
		if (((bool)v12)) {
			VAL v15 = (mw_mirth_c99_c99Z_wordZ_defZBang(((uint64_t)v10), v9));
			x14 = v15;
		} else {
			x14 = v9;
		}
		int64_t v16 = 1LL;
		int64_t v17 = i64_add(v10, v16);
		void* v18 = mbuf_mirth_word_Word_NUM;
		int64_t v19 = *(int64_t*)v18;
		bool v20 = (v17 <= v19);
		v8 = v20;
		v7 = v17;
		v6 = x14;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_wordZ_defZBang (uint64_t x1, VAL x2) {
	VAL v3;
	VAL v4;
	mw_mirth_word_Word_c99Z_api(x1, x2, &v3, &v4);
	VAL v5 = (mw_mirth_c99_ZPlusC99_indent(v4));
	incref(v3);
	VAL v6 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v3, v5));
	STR* v7;
	STRLIT(v7, " {", 2);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_line(v8));
	int64_t v10 = VI64(VTUP(v9)->cells[2]);
	int64_t v11 = 1LL;
	int64_t v12 = i64_add(v10, v11);
	VTUP(v9)->cells[2] = MKI64(v12);
	incref(v3);
	VAL v13 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v3, v9));
	VAL v14 = (mw_mirth_c99_c99Z_wordZ_enterZBang(x1, v13));
	VAL v15 = (VVAL(VTUP(v14)->cells[1]));
	VAL v16 = (VVAL(VTUP(v15)->cells[6]));
	VAL v17;
	VAL v18;
	mw_mirth_word_Word_arrow(x1, v16, &v17, &v18);
	VTUP(v15)->cells[6] = v18;
	VTUP(v14)->cells[1] = v15;
	VAL v19 = (mw_mirth_c99_c99Z_arrowZBang(v17, v14));
	VAL v20 = (mw_mirth_c99_c99Z_wordZ_exitZBang(x1, v19));
	VAL v21 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v3, v20));
	int64_t v22 = VI64(VTUP(v21)->cells[2]);
	int64_t v23 = 1LL;
	int64_t v24 = i64_sub(v22, v23);
	int64_t v25 = 0LL;
	bool v26 = (v24 < v25);
	int64_t x27;
	if (v26) {
		int64_t v28 = 0LL;
		x27 = v28;
		push_u64(x1);
	} else {
		x27 = v24;
		push_u64(x1);
	}
	VTUP(v21)->cells[2] = MKI64(x27);
	VAL v29 = (mw_mirth_c99_ZPlusC99_indent(v21));
	STR* v30;
	STRLIT(v30, "}", 1);
	VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
	VAL v32 = (mw_mirth_c99_ZPlusC99_line(v31));
	uint64_t v33 = pop_u64();
	return v32;
}
static VAL mw_mirth_c99_fieldZ_sigZ_put (uint64_t x1, VAL x2) {
	STR* v3;
	STRLIT(v3, "static void* ", 13);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), x2));
	VAL v5 = (VVAL(VTUP(v4)->cells[6]));
	VAL v6;
	VAL v7;
	mw_mirth_table_Field_cname(v5, x1, &v6, &v7);
	VTUP(v4)->cells[6] = v6;
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(v7, v4));
	STR* v9;
	STRLIT(v9, " (uint64_t i)", 13);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	return v10;
}
static VAL mw_mirth_c99_c99Z_fieldZ_sigsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_table_Field_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_fieldZ_sigZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_table_Field_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_fieldZ_sigZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(x2));
	VAL v4 = (mw_mirth_c99_fieldZ_sigZ_put(x1, v3));
	STR* v5;
	STRLIT(v5, ";", 1);
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
	VAL v7 = (mw_mirth_c99_ZPlusC99_line(v6));
	return v7;
}
static VAL mw_mirth_c99_c99Z_fieldZ_defsZBang (VAL x1) {
	int64_t v2 = 1LL;
	void* v3 = mbuf_mirth_table_Field_NUM;
	int64_t v4 = *(int64_t*)v3;
	bool v5 = (v2 <= v4);
	VAL v6 = (x1);
	int64_t v7 = v2;
	bool v8 = v5;
	while (v8) {
		VAL v9 = (v6);
		int64_t v10 = v7;
		VAL v11 = (mw_mirth_c99_c99Z_fieldZ_defZBang(((uint64_t)v10), v9));
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v10, v12);
		void* v14 = mbuf_mirth_table_Field_NUM;
		int64_t v15 = *(int64_t*)v14;
		bool v16 = (v13 <= v15);
		v8 = v16;
		v7 = v13;
		v6 = v11;
	}
	return v6;
}
static VAL mw_mirth_c99_c99Z_fieldZ_defZBang (uint64_t x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_fieldZ_sigZ_put(x1, x2));
	STR* v4;
	STRLIT(v4, " {", 2);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	VAL v6 = (mw_mirth_c99_ZPlusC99_line(v5));
	STR* v7;
	STRLIT(v7, "\tstatic struct VAL * p = 0;", 27);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_line(v8));
	STR* v10;
	STRLIT(v10, "\tsize_t m = ", 12);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	push_u64(x1);
	push_resource(v11);
	int64_t v12 = mw_mirth_elab_TABLEz_MAXz_COUNT();
	STR* v13 = i64_show(v12);
	VAL r14 = pop_resource();
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), r14));
	STR* v16;
	STRLIT(v16, ";", 1);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = (mw_mirth_c99_ZPlusC99_line(v17));
	STR* v19;
	STRLIT(v19, "\tif (! p) { p = calloc(m, sizeof *p); }", 39);
	VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
	VAL v21 = (mw_mirth_c99_ZPlusC99_line(v20));
	STR* v22;
	STRLIT(v22, "\tEXPECT(i<m, \"table grew too big\");", 35);
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
	VAL v24 = (mw_mirth_c99_ZPlusC99_line(v23));
	STR* v25;
	STRLIT(v25, "\treturn (void*)(p+i);", 21);
	VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
	VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
	STR* v28;
	STRLIT(v28, "}", 1);
	VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
	VAL v30 = (mw_mirth_c99_ZPlusC99_line(v29));
	VAL v31 = (mw_mirth_c99_ZPlusC99_line(v30));
	uint64_t v32 = pop_u64();
	return v31;
}
static VAL mw_mirth_c99_c99Z_fieldZ_callZBang (uint64_t x1, VAL x2) {
	int64_t v3 = 6LL /* C99RT_U64 */;
	VAL v4;
	VAL v5;
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v3, &v4, &v5);
	int64_t v6 = 13LL /* C99RT_PTR */;
	VAL v7 = (VVAL(VTUP(v4)->cells[1]));
	VAL v8;
	VAL v9;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v7, &v8, &v9);
	VAL v10 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v6, v8));
	VAL v11 = (mw_mirth_c99_ZPlusC99_indent(v9));
	int64_t v12 = VI64(VTUP(v10)->cells[1]);
	VAL v13 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v12);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v11));
	STR* v15;
	STRLIT(v15, " ", 1);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL v17 = VVAL(VTUP(v10)->cells[2]);
	incref(v17);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(v17, v16));
	STR* v19;
	STRLIT(v19, " = ", 3);
	VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
	VAL v21 = (VVAL(VTUP(v20)->cells[6]));
	VAL v22;
	VAL v23;
	mw_mirth_table_Field_cname(v21, x1, &v22, &v23);
	VTUP(v20)->cells[6] = v22;
	VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v20));
	STR* v25;
	STRLIT(v25, "(", 1);
	VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
	int64_t v27 = 6LL /* C99RT_U64 */;
	VAL v28 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v27, v5);
	VAL v29 = (mw_mirth_c99_ZPlusC99_put(v28, v26));
	STR* v30;
	STRLIT(v30, ")", 1);
	VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
	STR* v32;
	STRLIT(v32, ";", 1);
	VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v31));
	VAL v34 = (mw_mirth_c99_ZPlusC99_line(v33));
	VTUP(v4)->cells[1] = v34;
	VAL v35 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v4, v10));
	return v35;
}
static VAL mw_mirth_c99_c99Z_mainZBang (VAL x1, VAL x2) {
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(x2));
	STR* v4;
	STRLIT(v4, "int main (int argc, char** argv) {", 34);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	VAL v6 = (mw_mirth_c99_ZPlusC99_line(v5));
	VAL v7 = (mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang(v6));
	int64_t v8 = VI64(VTUP(v7)->cells[2]);
	int64_t v9 = 1LL;
	int64_t v10 = i64_add(v8, v9);
	VTUP(v7)->cells[2] = MKI64(v10);
	VAL v11 = (mw_mirth_c99_ZPlusC99_indent(v7));
	STR* v12;
	STRLIT(v12, "global_argc = argc;", 19);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL v14 = (mw_mirth_c99_ZPlusC99_line(v13));
	VAL v15 = (mw_mirth_c99_ZPlusC99_indent(v14));
	STR* v16;
	STRLIT(v16, "global_argv = argv;", 19);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = (mw_mirth_c99_ZPlusC99_line(v17));
	VAL v19 = VVAL(VTUP(v18)->cells[1]);
	incref(v19);
	int64_t v20 = VI64(VTUP(v19)->cells[2]);
	decref(v19);
	VAL x21;
	VAL x22;
	if (((bool)v20)) {
		VAL v23 = (mw_mirth_c99_ZPlusC99_indent(v18));
		STR* v24;
		STRLIT(v24, "WORD_ENTER(", 11);
		VAL v25 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v24), v23));
		STR* v26;
		STRLIT(v26, "\"<main>\", ", 10);
		VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v25));
		incref(x1);
		uint64_t v28 = VU64(VTUP(x1)->cells[2]);
		decref(x1);
		uint64_t v29 = mw_mirth_token_Token_module(v28);
		VAL v30 = mw_mirth_module_Module_sourceZ_path(v29);
		VAL v31 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v30, v27));
		STR* v32;
		STRLIT(v32, ", ", 2);
		VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v31));
		incref(x1);
		uint64_t v34 = VU64(VTUP(x1)->cells[2]);
		decref(x1);
		int64_t v35 = mw_mirth_token_Token_row(v34);
		int64_t v36 = mw_mirth_location_Row_ZToInt(v35);
		STR* v37 = i64_show(v36);
		VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), v33));
		STR* v39;
		STRLIT(v39, ", ", 2);
		VAL v40 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v39), v38));
		incref(x1);
		uint64_t v41 = VU64(VTUP(x1)->cells[2]);
		decref(x1);
		int64_t v42 = mw_mirth_token_Token_col(v41);
		int64_t v43 = mw_mirth_location_Col_ZToInt(v42);
		STR* v44 = i64_show(v43);
		VAL v45 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v44), v40));
		STR* v46;
		STRLIT(v46, ");", 2);
		VAL v47 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v46), v45));
		VAL v48 = (mw_mirth_c99_ZPlusC99_line(v47));
		x22 = v48;
		x21 = x1;
	} else {
		x22 = v18;
		x21 = x1;
	}
	VAL v49 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(x22));
	int64_t v50 = 2LL /* C99RT_I64 */;
	VAL v51 = (VVAL(VTUP(v49)->cells[1]));
	VAL v52;
	VAL v53;
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v51, &v52, &v53);
	VAL v54 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v50, v52));
	VAL v55 = (mw_mirth_c99_ZPlusC99_indent(v53));
	int64_t v56 = VI64(VTUP(v54)->cells[1]);
	VAL v57 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v56);
	VAL v58 = (mw_mirth_c99_ZPlusC99_put(v57, v55));
	STR* v59;
	STRLIT(v59, " ", 1);
	VAL v60 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v59), v58));
	VAL v61 = VVAL(VTUP(v54)->cells[2]);
	incref(v61);
	VAL v62 = (mw_mirth_c99_ZPlusC99_put(v61, v60));
	STR* v63;
	STRLIT(v63, " = (", 4);
	VAL v64 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v63), v62));
	STR* v65;
	STRLIT(v65, "0 /* The World! */", 18);
	VAL v66 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v65), v64));
	STR* v67;
	STRLIT(v67, ");", 2);
	VAL v68 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v67), v66));
	VAL v69 = (mw_mirth_c99_ZPlusC99_line(v68));
	VTUP(v49)->cells[1] = v69;
	VAL v70 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v49, v54));
	VAL v71 = (mw_mirth_c99_c99Z_arrowZBang(x21, v70));
	VAL v72 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v71));
	VAL v73 = VVAL(VTUP(v72)->cells[1]);
	incref(v73);
	int64_t v74 = VI64(VTUP(v73)->cells[2]);
	decref(v73);
	VAL x75;
	if (((bool)v74)) {
		VAL v76 = (mw_mirth_c99_ZPlusC99_indent(v72));
		STR* v77;
		STRLIT(v77, "WORD_EXIT;", 10);
		VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v77), v76));
		VAL v79 = (mw_mirth_c99_ZPlusC99_line(v78));
		x75 = v79;
	} else {
		x75 = v72;
	}
	VAL v80 = (mw_mirth_c99_ZPlusC99_indent(x75));
	STR* v81;
	STRLIT(v81, "return 0;", 9);
	VAL v82 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v81), v80));
	VAL v83 = (mw_mirth_c99_ZPlusC99_line(v82));
	int64_t v84 = VI64(VTUP(v83)->cells[2]);
	int64_t v85 = 1LL;
	int64_t v86 = i64_sub(v84, v85);
	int64_t v87 = 0LL;
	bool v88 = (v86 < v87);
	int64_t x89;
	if (v88) {
		int64_t v90 = 0LL;
		x89 = v90;
	} else {
		x89 = v86;
	}
	VTUP(v83)->cells[2] = MKI64(x89);
	VAL v91 = (mw_mirth_c99_ZPlusC99_indent(v83));
	STR* v92;
	STRLIT(v92, "}", 1);
	VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
	VAL v94 = (mw_mirth_c99_ZPlusC99_line(v93));
	return v94;
}
static VAL mw_mirth_main_Arguments_default (void) {
	int64_t v1 = 0LL /* False */;
	STR* v2;
	STRLIT(v2, "mirth.mth", 9);
	VAL v3 = MKI64(0LL /* None */);
	STR* v4;
	STRLIT(v4, "main", 4);
	VAL v5 = mtw_std_maybe_Maybe_1_Some(MKSTR(v4));
	VAL v6 = MKI64(0LL /* Nil */);
	VAL v7 = MKI64(0LL /* Nil */);
	VAL v8 = mtw_mirth_main_Arguments_Arguments(MKSTR(v2), v3, v5, v6, v7, v1);
	return v8;
}
static void mw_mirth_main_compileZBang (VAL x1, int64_t x2, VAL x3, int64_t *x4, VAL *x5) {
	VAL v6;
	VAL v7;
	VAL v8;
	VAL v9;
	VAL v10;
	int64_t v11;
	mtp_mirth_main_Arguments_Arguments(x1, &v6, &v7, &v8, &v9, &v10, &v11);
	VAL v12 = VVAL(VTUP(x3)->cells[7]);
	incref(v12);
	decref(v12);
	VAL v13 = VTUP(x3)->cells[7];
	decref(v13);
	VTUP(x3)->cells[7] = v10;
	STR* v14;
	STRLIT(v14, "", 0);
	STR* v15;
	STRLIT(v15, "Compiling ", 10);
	VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v15), MKSTR(v14)));
	incref(v6);
	VAL v17 = (mw_std_path_Path_pathZThen(v6, v16));
	STR* v18;
	STRLIT(v18, "\n", 1);
	STR* v19 = str_cat(VSTR(v17), v18);
	int64_t v20 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v19), x2));
	VAL v21;
	VAL v22;
	mw_std_list_List_1_uncons(v9, &v21, &v22);
	VAL x23;
	VAL x24;
	int64_t x25;
	VAL x26;
	int64_t x27;
	VAL x28;
	VAL x29;
	int64_t x30;
	switch (get_data_tag(v21)) {
		case 1LL: { // Some
			VAL v31 = mtp_std_maybe_Maybe_1_Some(v21);
			VAL v32;
			VAL v33;
			value_uncons(v31, &v32, &v33);
			VAL v34;
			VAL v35;
			value_uncons(v32, &v34, &v35);
			decref(v34);
			uint64_t v36 = mw_std_prim_Str_ZToName(v35);
			VAL v37;
			uint64_t v38;
			mw_mirth_package_Package_newZ_orZ_pathZBang(x3, v33, v36, &v37, &v38);
			int64_t v39 = 1LL /* True */;
			x30 = v39;
			x29 = v22;
			x28 = v37;
			x27 = v20;
			x26 = v6;
			x25 = v11;
			x24 = v8;
			x23 = v7;
		} break;
		case 0LL: { // None
			int64_t v40 = 0LL /* False */;
			x30 = v40;
			x29 = v22;
			x28 = x3;
			x27 = v20;
			x26 = v6;
			x25 = v11;
			x24 = v8;
			x23 = v7;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v41 = x23;
	VAL v42 = x24;
	int64_t v43 = x25;
	VAL v44 = x26;
	int64_t v45 = (x27);
	VAL v46 = (x28);
	VAL v47 = x29;
	int64_t v48 = x30;
	while (((bool)v48)) {
		VAL v49 = v41;
		VAL v50 = v42;
		int64_t v51 = v43;
		VAL v52 = v44;
		int64_t v53 = (v45);
		VAL v54 = (v46);
		VAL v55 = v47;
		VAL v56;
		VAL v57;
		mw_std_list_List_1_uncons(v55, &v56, &v57);
		VAL x58;
		VAL x59;
		int64_t x60;
		VAL x61;
		int64_t x62;
		VAL x63;
		VAL x64;
		int64_t x65;
		switch (get_data_tag(v56)) {
			case 1LL: { // Some
				VAL v66 = mtp_std_maybe_Maybe_1_Some(v56);
				VAL v67;
				VAL v68;
				value_uncons(v66, &v67, &v68);
				VAL v69;
				VAL v70;
				value_uncons(v67, &v69, &v70);
				decref(v69);
				uint64_t v71 = mw_std_prim_Str_ZToName(v70);
				VAL v72;
				uint64_t v73;
				mw_mirth_package_Package_newZ_orZ_pathZBang(v54, v68, v71, &v72, &v73);
				int64_t v74 = 1LL /* True */;
				x65 = v74;
				x64 = v57;
				x63 = v72;
				x62 = v53;
				x61 = v52;
				x60 = v51;
				x59 = v50;
				x58 = v49;
			} break;
			case 0LL: { // None
				int64_t v75 = 0LL /* False */;
				x65 = v75;
				x64 = v57;
				x63 = v54;
				x62 = v53;
				x61 = v52;
				x60 = v51;
				x59 = v50;
				x58 = v49;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v48 = x65;
		v47 = x64;
		v46 = x63;
		v45 = x62;
		v44 = x61;
		v43 = x60;
		v42 = x59;
		v41 = x58;
	}
	decref(v47);
	uint64_t v76;
	int64_t v77;
	VAL v78;
	mw_mirth_lexer_runZ_lexerZBang(v44, v45, v46, &v76, &v77, &v78);
	STR* v79;
	STRLIT(v79, "", 0);
	STR* v80;
	STRLIT(v80, "Building.", 9);
	VAL v81 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v80), MKSTR(v79)));
	STR* v82;
	STRLIT(v82, "\n", 1);
	STR* v83 = str_cat(VSTR(v81), v82);
	int64_t v84 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v83), v77));
	uint64_t v85;
	int64_t v86;
	VAL v87;
	mw_mirth_elab_elabZ_moduleZBang(v76, v84, v78, &v85, &v86, &v87);
	VAL v88 = (mw_mirth_elab_typecheckZ_everythingZBang(v87));
	VAL x89;
	int64_t x90;
	uint64_t x91;
	int64_t x92;
	VAL x93;
	VAL x94;
	switch (get_data_tag(v42)) {
		case 1LL: { // Some
			VAL v95 = mtp_std_maybe_Maybe_1_Some(v42);
			VAL v96 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v85);
			uint64_t v97 = mw_std_prim_Str_ZToName(v95);
			VAL v98 = mw_mirth_name_QNAME0(v96, v97);
			VAL v99;
			VAL v100;
			mw_mirth_elab_elabZ_entryZ_point(v98, v88, &v99, &v100);
			VAL v101 = mtw_std_maybe_Maybe_1_Some(v99);
			x94 = v101;
			x93 = v100;
			x92 = v86;
			x91 = v85;
			x90 = v43;
			x89 = v41;
		} break;
		case 0LL: { // None
			VAL v102 = MKI64(0LL /* None */);
			x94 = v102;
			x93 = v88;
			x92 = v86;
			x91 = v85;
			x90 = v43;
			x89 = v41;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v103;
	VAL v104;
	mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang(x92, x93, &v103, &v104);
	int64_t v105 = VI64(VTUP(v104)->cells[1]);
	int64_t v106 = 0LL;
	bool v107 = (v105 > v106);
	VAL x108;
	int64_t x109;
	VAL x110;
	int64_t x111;
	VAL x112;
	if (v107) {
		int64_t v113 = VI64(VTUP(v104)->cells[1]);
		STR* v114;
		STRLIT(v114, "", 0);
		VAL v115 = MKI64(31LL /* FGRed */);
		VAL v116 = (mw_std_terminal_Sgr_emitZThen(v115, MKSTR(v114)));
		STR* v117 = i64_show(v113);
		VAL v118 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v117), v116));
		STR* v119;
		STRLIT(v119, " errors.", 8);
		VAL v120 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v119), v118));
		VAL v121 = MKI64(0LL /* Reset */);
		VAL v122 = (mw_std_terminal_Sgr_emitZThen(v121, v120));
		STR* v123;
		STRLIT(v123, "\n", 1);
		STR* v124 = str_cat(VSTR(v122), v123);
		int64_t v125 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v124), v103));
		int64_t v126 = 1LL;
		lpush(&lbl_outputZ_file, x89);
		lpush(&lbl_emitZ_debugZ_info, MKI64(x90));
		push_value(x94);
		push_resource(MKI64(v125));
		push_resource(v104);
		mext_std_posix_externalZ_posixZ_exit(v126);
		VAL r127 = pop_resource();
		x112 = r127;
		int64_t r128 = VI64(pop_resource());
		x111 = r128;
		VAL v129 = pop_value();
		x110 = v129;
		int64_t v130 = VI64(lpop(&lbl_emitZ_debugZ_info));
		x109 = v130;
		VAL v131 = lpop(&lbl_outputZ_file);
		x108 = v131;
	} else {
		STR* v132;
		STRLIT(v132, "", 0);
		VAL v133 = MKI64(32LL /* FGGreen */);
		VAL v134 = (mw_std_terminal_Sgr_emitZThen(v133, MKSTR(v132)));
		STR* v135;
		STRLIT(v135, "No errors.", 10);
		VAL v136 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v135), v134));
		VAL v137 = MKI64(0LL /* Reset */);
		VAL v138 = (mw_std_terminal_Sgr_emitZThen(v137, v136));
		STR* v139;
		STRLIT(v139, "\n", 1);
		STR* v140 = str_cat(VSTR(v138), v139);
		int64_t v141 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v140), v103));
		x112 = v104;
		x111 = v141;
		x110 = x94;
		x109 = x90;
		x108 = x89;
	}
	int64_t x142;
	VAL x143;
	switch (get_data_tag(x110)) {
		case 1LL: { // Some
			VAL v144 = mtp_std_maybe_Maybe_1_Some(x110);
			STR* v145;
			STRLIT(v145, "Specializer.", 12);
			STR* v146;
			STRLIT(v146, "\n", 1);
			STR* v147 = str_cat(v145, v146);
			int64_t v148 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v147), x111));
			VAL v149;
			VAL v150;
			mw_mirth_specializzer_runZ_specializzerZBang(x112, v144, &v149, &v150);
			STR* v151;
			STRLIT(v151, "Codegen.", 8);
			STR* v152;
			STRLIT(v152, "\n", 1);
			STR* v153 = str_cat(v151, v152);
			int64_t v154 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v153), v148));
			int64_t x155;
			VAL x156;
			switch (get_data_tag(x108)) {
				case 1LL: { // Some
					VAL v157 = mtp_std_maybe_Maybe_1_Some(x108);
					VAL v158 = mtw_mirth_c99_C99z_Options_C99z_Options(v157, x109);
					int64_t v159;
					VAL v160;
					mw_mirth_c99_runZ_outputZ_c99ZBang(v150, v158, v154, v149, &v159, &v160);
					x156 = v160;
					x155 = v159;
				} break;
				case 0LL: { // None
					decref(v150);
					x156 = v149;
					x155 = v154;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x143 = x156;
			x142 = x155;
		} break;
		case 0LL: { // None
			STR* v161;
			STRLIT(v161, "Skipping Codegen.", 17);
			STR* v162;
			STRLIT(v162, "\n", 1);
			STR* v163 = str_cat(v161, v162);
			int64_t v164 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v163), x111));
			decref(x108);
			x143 = x112;
			x142 = v164;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	*x5 = x143;
	*x4 = x142;
}
static VAL mw_mirth_main_parseZ_packageZ_def (VAL x1) {
	int64_t v2 = 58LL /* BCOLON */;
	VAL v3 = mw_std_prim_Str_splitZ_byte(v2, x1);
	VAL v4;
	VAL v5;
	mtp_std_list_ListZPlus_1_ListZPlus(v3, &v4, &v5);
	VAL v6 = mw_std_list_List_1_ZDivL1(v5);
	VAL x7;
	VAL x8;
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
			incref(v4);
			VAL v10 = MKNIL;
			VAL v11 = mkcons(v10, v4);
			VAL v12 = mkcons(v11, v9);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(v12);
			x8 = v13;
			x7 = v4;
		} break;
		case 0LL: { // None
			VAL v14 = MKI64(0LL /* None */);
			x8 = v14;
			x7 = v4;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	decref(x7);
	VAL x15;
	switch (get_data_tag(x8)) {
		case 1LL: { // Some
			VAL v16 = mtp_std_maybe_Maybe_1_Some(x8);
			x15 = v16;
		} break;
		case 0LL: { // None
			STR* v17;
			STRLIT(v17, "Invalid package path definition", 31);
			do_panic(v17);
			VAL v18 = pop_value();
			x15 = v18;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v19;
	VAL v20;
	value_uncons(x15, &v19, &v20);
	VAL v21;
	VAL v22;
	value_uncons(v19, &v21, &v22);
	decref(v21);
	VAL v23 = MKNIL;
	VAL v24 = mkcons(v23, v22);
	VAL v25 = mkcons(v24, v20);
	return v25;
}
static void mw_mirth_main_compilerZ_parseZ_args (VAL x1, VAL x2, VAL x3, VAL x4, VAL *x5, VAL *x6) {
	VAL x7;
	VAL x8;
	switch (get_data_tag(x4)) {
		case 0LL: { // Short
			int64_t v9 = mtp_argZ_parser_types_ArgpOptionType_Short(x4);
			VAL x10;
			VAL x11;
			switch (v9) {
				case 111LL: { // B'o'
					VAL x12;
					VAL x13;
					switch (get_data_tag(x3)) {
						case 1LL: { // Some
							VAL v14 = mtp_std_maybe_Maybe_1_Some(x3);
							VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
							x13 = v15;
							x12 = x1;
						} break;
						case 0LL: { // None
							VAL v16 = MKI64(0LL /* None */);
							x13 = v16;
							x12 = x1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					VAL v17 = tup_replace(x2, 2, x13);
					x11 = v17;
					x10 = x12;
				} break;
				case 101LL: { // B'e'
					VAL v18 = tup_replace(x2, 3, x3);
					x11 = v18;
					x10 = x1;
				} break;
				case 99LL: { // B'c'
					decref(x3);
					VAL v19 = MKI64(0LL /* None */);
					VAL v20 = tup_replace(x2, 3, v19);
					x11 = v20;
					x10 = x1;
				} break;
				case 112LL: { // B'p'
					VAL x21;
					VAL x22;
					switch (get_data_tag(x3)) {
						case 1LL: { // Some
							VAL v23 = mtp_std_maybe_Maybe_1_Some(x3);
							VAL v24 = mw_mirth_main_parseZ_packageZ_def(v23);
							incref(x2);
							VAL v25 = VVAL(VTUP(x2)->cells[4]);
							incref(v25);
							decref(x2);
							VAL v26 = mtw_std_list_List_1_Cons(v24, v25);
							VAL v27 = tup_replace(x2, 4, v26);
							x22 = v27;
							x21 = x1;
						} break;
						case 0LL: { // None
							x22 = x2;
							x21 = x1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x11 = x22;
					x10 = x21;
				} break;
				case 80LL: { // B'P'
					VAL x28;
					VAL x29;
					switch (get_data_tag(x3)) {
						case 1LL: { // Some
							VAL v30 = mtp_std_maybe_Maybe_1_Some(x3);
							incref(x2);
							VAL v31 = VVAL(VTUP(x2)->cells[5]);
							incref(v31);
							decref(x2);
							VAL v32 = mtw_std_list_List_1_Cons(v30, v31);
							VAL v33 = tup_replace(x2, 5, v32);
							x29 = v33;
							x28 = x1;
						} break;
						case 0LL: { // None
							x29 = x2;
							x28 = x1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x11 = x29;
					x10 = x28;
				} break;
				default: {
					decref(x3);
					VAL v34 = MKI64(4LL /* UnknownArg */);
					VAL v35 = mtw_std_maybe_Maybe_1_Some(v34);
					VAL v36 = VVAL(VTUP(x1)->cells[2]);
					incref(v36);
					VAL v37 = tup_replace(v36, 6, v35);
					VAL v38 = VTUP(x1)->cells[2];
					decref(v38);
					VTUP(x1)->cells[2] = v37;
					x11 = x2;
					x10 = x1;
				} break;
			}
			x8 = x11;
			x7 = x10;
		} break;
		case 2LL: { // Positional
			VAL v39 = VVAL(VTUP(x1)->cells[2]);
			incref(v39);
			int64_t v40 = VI64(VTUP(v39)->cells[4]);
			decref(v39);
			int64_t v41 = 0LL;
			bool v42 = (v40 == v41);
			VAL x43;
			VAL x44;
			if (v42) {
				VAL x45;
				VAL x46;
				switch (get_data_tag(x3)) {
					case 1LL: { // Some
						VAL v47 = mtp_std_maybe_Maybe_1_Some(x3);
						VAL v48 = tup_replace(x2, 1, v47);
						x46 = v48;
						x45 = x1;
					} break;
					case 0LL: { // None
						x46 = x2;
						x45 = x1;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				x44 = x46;
				x43 = x45;
			} else {
				decref(x3);
				VAL v49 = MKI64(2LL /* TooManyArgs */);
				VAL v50 = mtw_std_maybe_Maybe_1_Some(v49);
				VAL v51 = VVAL(VTUP(x1)->cells[2]);
				incref(v51);
				VAL v52 = tup_replace(v51, 6, v50);
				VAL v53 = VTUP(x1)->cells[2];
				decref(v53);
				VTUP(x1)->cells[2] = v52;
				x44 = x2;
				x43 = x1;
			}
			x8 = x44;
			x7 = x43;
		} break;
		case 1LL: { // LongOnly
			VAL v54 = mtp_argZ_parser_types_ArgpOptionType_LongOnly(x4);
			incref(v54);
			STR* v55;
			STRLIT(v55, "debug", 5);
			bool v56 = (str_cmp(VSTR(v54), v55) == 0);
			VAL x57;
			VAL x58;
			if (v56) {
				decref(v54);
				decref(x3);
				int64_t v59 = 1LL /* True */;
				VAL v60 = tup_replace(x2, 6, MKI64(v59));
				x58 = v60;
				x57 = x1;
			} else {
				decref(v54);
				decref(x3);
				VAL v61 = MKI64(4LL /* UnknownArg */);
				VAL v62 = mtw_std_maybe_Maybe_1_Some(v61);
				VAL v63 = VVAL(VTUP(x1)->cells[2]);
				incref(v63);
				VAL v64 = tup_replace(v63, 6, v62);
				VAL v65 = VTUP(x1)->cells[2];
				decref(v65);
				VTUP(x1)->cells[2] = v64;
				x58 = x2;
				x57 = x1;
			}
			x8 = x58;
			x7 = x57;
		} break;
		case 3LL: { // End
			VAL v66 = VVAL(VTUP(x1)->cells[2]);
			incref(v66);
			int64_t v67 = VI64(VTUP(v66)->cells[4]);
			decref(v66);
			int64_t v68 = 1LL;
			bool v69 = (v67 < v68);
			VAL x70;
			VAL x71;
			VAL x72;
			if (v69) {
				VAL v73 = MKI64(3LL /* TooFewArgs */);
				VAL v74 = mtw_std_maybe_Maybe_1_Some(v73);
				VAL v75 = VVAL(VTUP(x1)->cells[2]);
				incref(v75);
				VAL v76 = tup_replace(v75, 6, v74);
				VAL v77 = VTUP(x1)->cells[2];
				decref(v77);
				VTUP(x1)->cells[2] = v76;
				x72 = x1;
				x71 = x3;
				x70 = x2;
			} else {
				x72 = x1;
				x71 = x3;
				x70 = x2;
			}
			VAL v78 = VVAL(VTUP(x72)->cells[2]);
			incref(v78);
			VAL v79 = VVAL(VTUP(v78)->cells[1]);
			incref(v79);
			decref(v78);
			VAL v80 = VVAL(VTUP(v79)->cells[2]);
			incref(v80);
			decref(v79);
			VAL x81;
			VAL x82;
			VAL x83;
			switch (get_data_tag(v80)) {
				case 1LL: { // Some
					VAL v84 = mtp_std_maybe_Maybe_1_Some(v80);
					decref(v84);
					x83 = x72;
					x82 = x71;
					x81 = x70;
				} break;
				case 0LL: { // None
					VAL v85 = VVAL(VTUP(x72)->cells[2]);
					incref(v85);
					VAL v86 = VVAL(VTUP(v85)->cells[1]);
					incref(v86);
					decref(v85);
					VAL v87 = VVAL(VTUP(v86)->cells[3]);
					incref(v87);
					decref(v86);
					VAL x88;
					VAL x89;
					VAL x90;
					switch (get_data_tag(v87)) {
						case 1LL: { // Some
							VAL v91 = mtp_std_maybe_Maybe_1_Some(v87);
							decref(v91);
							STR* v92;
							STRLIT(v92, "output-file", 11);
							VAL v93 = mtw_argZ_parser_types_ArgumentParsingError_MissingArg(MKSTR(v92));
							VAL v94 = mtw_std_maybe_Maybe_1_Some(v93);
							VAL v95 = VVAL(VTUP(x72)->cells[2]);
							incref(v95);
							VAL v96 = tup_replace(v95, 6, v94);
							VAL v97 = VTUP(x72)->cells[2];
							decref(v97);
							VTUP(x72)->cells[2] = v96;
							x90 = x72;
							x89 = x71;
							x88 = x70;
						} break;
						case 0LL: { // None
							x90 = x72;
							x89 = x71;
							x88 = x70;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x83 = x90;
					x82 = x89;
					x81 = x88;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			decref(x82);
			x8 = x81;
			x7 = x83;
		} break;
		default: {
			decref(x4);
			decref(x3);
			VAL v98 = MKI64(4LL /* UnknownArg */);
			VAL v99 = mtw_std_maybe_Maybe_1_Some(v98);
			VAL v100 = VVAL(VTUP(x1)->cells[2]);
			incref(v100);
			VAL v101 = tup_replace(v100, 6, v99);
			VAL v102 = VTUP(x1)->cells[2];
			decref(v102);
			VTUP(x1)->cells[2] = v101;
			x8 = x2;
			x7 = x1;
		} break;
	}
	*x6 = x8;
	*x5 = x7;
}
static int64_t mw_mirth_main_main (int64_t x1) {
	push_resource(MKI64(x1));
	VAL v2 = (mw_mirth_mirth_ZPlusMirth_InitZBang());
	VAL v3 = mw_mirth_main_Arguments_default();
	VAL v4 = MKI64(0LL /* Nil */);
	VAL v5 = mw_std_list_List_1_reverse(v4);
	STR* v6;
	STRLIT(v6, "output-file", 11);
	VAL v7 = mtw_std_maybe_Maybe_1_Some(MKSTR(v6));
	int64_t v8 = 111LL /* B'o' */;
	VAL v9 = mtw_argZ_parser_types_ArgpOptionType_Short(v8);
	STR* v10;
	STRLIT(v10, "OUTPUT_FILE", 11);
	VAL v11 = mtw_std_maybe_Maybe_1_Some(MKSTR(v10));
	STR* v12;
	STRLIT(v12, "Test argument", 13);
	VAL v13 = mtw_std_maybe_Maybe_1_Some(MKSTR(v12));
	VAL v14 = MKI64(0LL /* None */);
	VAL v15 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v7, v9, v11, v13, v14);
	VAL v16 = mtw_std_list_List_1_Cons(v15, v5);
	STR* v17;
	STRLIT(v17, "compile-only", 12);
	VAL v18 = mtw_std_maybe_Maybe_1_Some(MKSTR(v17));
	int64_t v19 = 99LL /* B'c' */;
	VAL v20 = mtw_argZ_parser_types_ArgpOptionType_Short(v19);
	VAL v21 = MKI64(0LL /* None */);
	STR* v22;
	STRLIT(v22, "Compile code without running codegen step", 41);
	VAL v23 = mtw_std_maybe_Maybe_1_Some(MKSTR(v22));
	VAL v24 = MKI64(0LL /* None */);
	VAL v25 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v18, v20, v21, v23, v24);
	VAL v26 = mtw_std_list_List_1_Cons(v25, v16);
	STR* v27;
	STRLIT(v27, "entry-point", 11);
	VAL v28 = mtw_std_maybe_Maybe_1_Some(MKSTR(v27));
	int64_t v29 = 101LL /* B'e' */;
	VAL v30 = mtw_argZ_parser_types_ArgpOptionType_Short(v29);
	STR* v31;
	STRLIT(v31, "ENTRY_POINT", 11);
	VAL v32 = mtw_std_maybe_Maybe_1_Some(MKSTR(v31));
	STR* v33;
	STRLIT(v33, "Custom entry point word for compilation", 39);
	VAL v34 = mtw_std_maybe_Maybe_1_Some(MKSTR(v33));
	VAL v35 = MKI64(0LL /* None */);
	VAL v36 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v28, v30, v32, v34, v35);
	VAL v37 = mtw_std_list_List_1_Cons(v36, v26);
	STR* v38;
	STRLIT(v38, "package", 7);
	VAL v39 = mtw_std_maybe_Maybe_1_Some(MKSTR(v38));
	int64_t v40 = 112LL /* B'p' */;
	VAL v41 = mtw_argZ_parser_types_ArgpOptionType_Short(v40);
	STR* v42;
	STRLIT(v42, "(PACKAGE:PATH)*", 15);
	VAL v43 = mtw_std_maybe_Maybe_1_Some(MKSTR(v42));
	STR* v44;
	STRLIT(v44, "Package locations", 17);
	VAL v45 = mtw_std_maybe_Maybe_1_Some(MKSTR(v44));
	VAL v46 = MKI64(0LL /* None */);
	VAL v47 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v39, v41, v43, v45, v46);
	VAL v48 = mtw_std_list_List_1_Cons(v47, v37);
	STR* v49;
	STRLIT(v49, "package-search-path", 19);
	VAL v50 = mtw_std_maybe_Maybe_1_Some(MKSTR(v49));
	int64_t v51 = 80LL /* B'P' */;
	VAL v52 = mtw_argZ_parser_types_ArgpOptionType_Short(v51);
	STR* v53;
	STRLIT(v53, "SEARCH_PATH*", 12);
	VAL v54 = mtw_std_maybe_Maybe_1_Some(MKSTR(v53));
	STR* v55;
	STRLIT(v55, "Package search paths", 20);
	VAL v56 = mtw_std_maybe_Maybe_1_Some(MKSTR(v55));
	VAL v57 = MKI64(0LL /* None */);
	VAL v58 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v50, v52, v54, v56, v57);
	VAL v59 = mtw_std_list_List_1_Cons(v58, v48);
	STR* v60;
	STRLIT(v60, "debug", 5);
	VAL v61 = mtw_std_maybe_Maybe_1_Some(MKSTR(v60));
	STR* v62;
	STRLIT(v62, "debug", 5);
	VAL v63 = mtw_argZ_parser_types_ArgpOptionType_LongOnly(MKSTR(v62));
	VAL v64 = MKI64(0LL /* None */);
	STR* v65;
	STRLIT(v65, "Emit debugging information during codegen", 41);
	VAL v66 = mtw_std_maybe_Maybe_1_Some(MKSTR(v65));
	VAL v67 = MKI64(0LL /* None */);
	VAL v68 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v61, v63, v64, v66, v67);
	VAL v69 = mtw_std_list_List_1_Cons(v68, v59);
	VAL v70 = mw_std_list_List_1_reverse(v69);
	FNPTR v71 = &mb_mirth_main_main_1;
	STR* v72;
	STRLIT(v72, "input-file", 10);
	VAL v73 = mtw_std_maybe_Maybe_1_Some(MKSTR(v72));
	STR* v74;
	STRLIT(v74, "Mirth Compiler", 14);
	VAL v75 = mtw_argZ_parser_types_ArgumentParser_1_ArgumentParser(v70, MKFNPTR(v71), v73, MKSTR(v74));
	VAL v76 = mw_argZ_parser_parse_parseZ_args(v3, v75);
	int64_t x77;
	VAL x78;
	VAL x79;
	switch (get_data_tag(v76)) {
		case 1LL: { // Right
			VAL v80 = mtp_std_either_Either_2_Right(v76);
			x79 = v80;
			x78 = v2;
			int64_t r81 = VI64(pop_resource());
			x77 = r81;
		} break;
		case 0LL: { // Left
			VAL v82 = mtp_std_either_Either_2_Left(v76);
			STR* v83;
			STRLIT(v83, "", 0);
			VAL v84;
			VAL v85;
			value_uncons(v82, &v84, &v85);
			VAL v86;
			VAL v87;
			value_uncons(v84, &v86, &v87);
			decref(v86);
			VAL v88 = (mw_std_str_ZPlusStr_pushZ_strZBang(v85, MKSTR(v83)));
			VAL v89 = (mw_argZ_parser_types_ArgumentParsingError_emitZThen(v87, v88));
			STR* v90;
			STRLIT(v90, "\n", 1);
			STR* v91 = str_cat(VSTR(v89), v90);
			int64_t r92 = VI64(pop_resource());
			int64_t v93 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v91), r92));
			int64_t v94 = 1LL;
			push_resource(MKI64(v93));
			push_resource(v2);
			mext_std_posix_externalZ_posixZ_exit(v94);
			VAL v95 = pop_value();
			x79 = v95;
			VAL r96 = pop_resource();
			x78 = r96;
			int64_t r97 = VI64(pop_resource());
			x77 = r97;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	incref(x79);
	VAL v98 = VVAL(VTUP(x79)->cells[5]);
	incref(v98);
	decref(x79);
	int64_t v99 = mw_std_list_List_1_emptyZAsk(v98);
	int64_t x100;
	VAL x101;
	VAL x102;
	if (((bool)v99)) {
		VAL v103 = MKI64(0LL /* Nil */);
		VAL v104 = mw_std_list_List_1_reverse(v103);
		STR* v105;
		STRLIT(v105, "lib", 3);
		VAL v106 = mtw_std_list_List_1_Cons(MKSTR(v105), v104);
		VAL v107;
		VAL v108;
		mw_mirth_mirth_ZPlusMirth_mirthZ_baseZ_libZ_path(x78, &v107, &v108);
		int64_t x109;
		VAL x110;
		VAL x111;
		VAL x112;
		switch (get_data_tag(v108)) {
			case 1LL: { // Some
				VAL v113 = mtp_std_maybe_Maybe_1_Some(v108);
				VAL v114 = mtw_std_list_List_1_Cons(v113, v106);
				x112 = v114;
				x111 = v107;
				x110 = x79;
				x109 = x77;
			} break;
			case 0LL: { // None
				x112 = v106;
				x111 = v107;
				x110 = x79;
				x109 = x77;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		VAL v115 = mw_std_list_List_1_reverse(x112);
		VAL v116 = tup_replace(x110, 5, v115);
		x102 = v116;
		x101 = x111;
		x100 = x109;
	} else {
		x102 = x79;
		x101 = x78;
		x100 = x77;
	}
	int64_t v117;
	VAL v118;
	mw_mirth_main_compileZBang(x102, x100, x101, &v117, &v118);
	mw_mirth_mirth_ZPlusMirth_rdrop(v118);
	return v117;
}
static void mb_mirth_main_main_1 (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	VAL v4;
	VAL v5;
	mw_mirth_main_compilerZ_parseZ_args(r3, v2, v1, v0, &v4, &v5);
	push_resource(v4);
	push_value(v5);
}
static void mb_mirth_elab_elabZ_blockZ_atZBang_1 (void) {
	uint64_t v0 = pop_u64();
	VAL r1 = pop_resource();
	VAL v2 = mw_mirth_arrow_Block_ctx(v0);
	VAL v3 = mw_mirth_arrow_Block_dom(v0);
	VAL v4 = mw_mirth_arrow_Block_cod(v0);
	uint64_t v5 = mw_mirth_arrow_Block_token(v0);
	VAL v6 = mw_mirth_arrow_Block_home(v0);
	VAL v7;
	VAL v8;
	mw_mirth_elab_elabZ_arrowZ_homZBang(r1, v2, v3, v4, v5, v6, &v7, &v8);
	push_resource(v7);
	push_value(v8);
}
static void mb_mirth_elab_elabZ_defZBang_0 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2 = mw_mirth_word_Word_sigZAsk(v1);
	VAL x3;
	VAL x4;
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v6 = (mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang(VU64(v5)));
			VAL v7;
			VAL v8;
			VAL v9;
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(r0, v6, &v7, &v8, &v9);
			VAL v10 = VVAL(VTUP(v8)->cells[1]);
			incref(v10);
			VAL v11 = MKNIL;
			VAL v12 = mkcons(v11, v10);
			VAL v13 = mkcons(v12, v9);
			mw_mirth_elab_ZPlusTypeElab_rdrop(v8);
			x4 = v13;
			x3 = v7;
		} break;
		case 0LL: { // None
			VAL v14;
			VAL v15;
			mw_mirth_word_Word_arrow(v1, r0, &v14, &v15);
			VAL v16;
			VAL v17;
			mw_mirth_arrow_Arrow_ctxZ_type(v14, &v16, &v17);
			VAL v18 = MKNIL;
			VAL v19 = mkcons(v18, v16);
			VAL v20 = mkcons(v19, v17);
			x4 = v20;
			x3 = v15;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	push_resource(x3);
	push_value(x4);
}
static void mb_mirth_elab_elabZ_defZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_defZ_paramsZBang(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_elab_elabZ_defZBang_3 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	VAL v4;
	uint64_t v5;
	VAL v6;
	uint64_t v7;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r0, v1, &v2, &v3, &v4, &v5, &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_type_ArrowType_unpack(v4, &v8, &v9);
	incref(v8);
	VAL v10 = MKI64(0LL /* Nil */);
	VAL v11 = mtw_mirth_arrow_Arrow_Arrow(v6, v5, v5, v3, v8, v8, v10);
	VAL v12;
	VAL v13;
	mw_mirth_word_Word_params(v1, v2, &v12, &v13);
	incref(v12);
	int64_t v14 = mw_std_list_List_1_emptyZAsk(v12);
	uint64_t x15;
	VAL x16;
	VAL x17;
	VAL x18;
	if (((bool)v14)) {
		decref(v12);
		VAL v19;
		VAL v20;
		VAL v21;
		mw_mirth_elab_elabZ_defZ_bodyZBang(v9, v13, v11, &v19, &v20, &v21);
		x18 = v21;
		x17 = v20;
		x16 = v19;
		x15 = v1;
	} else {
		VAL v22;
		uint64_t v23;
		mw_mirth_elab_abZ_tokenZAt(v11, &v22, &v23);
		incref(v12);
		VAL v24;
		VAL v25;
		mw_mirth_elab_abZ_ctxZAt(v22, &v24, &v25);
		VAL v26;
		VAL v27;
		mw_mirth_elab_abZ_typeZAt(v24, &v26, &v27);
		VAL v28 = mw_std_list_List_1_reverse(v12);
		VAL v29;
		VAL v30;
		mw_std_list_List_1_uncons(v28, &v29, &v30);
		uint64_t x31;
		VAL x32;
		VAL x33;
		VAL x34;
		VAL x35;
		VAL x36;
		int64_t x37;
		switch (get_data_tag(v29)) {
			case 1LL: { // Some
				VAL v38 = mtp_std_maybe_Maybe_1_Some(v29);
				incref(v38);
				VAL v39 = mw_mirth_var_Ctx_new(v25, VU64(v38));
				VAL v40;
				uint64_t v41;
				mw_mirth_elab_abZ_tokenZAt(v26, &v40, &v41);
				VAL v42;
				VAL v43;
				VAL v44;
				uint64_t v45;
				mw_mirth_elab_elabZ_expandZ_tensorZBang(v13, v27, v41, &v42, &v43, &v44, &v45);
				VAL v46 = mw_mirth_var_Var_type(VU64(v38));
				VAL v47;
				VAL v48;
				uint64_t v49;
				mw_mirth_elab_elabZ_typeZ_unifyZBang(v42, v44, v46, v45, &v47, &v48, &v49);
				decref(v48);
				int64_t v50 = 1LL /* True */;
				x37 = v50;
				x36 = v30;
				x35 = v43;
				x34 = v40;
				x33 = v39;
				x32 = v47;
				x31 = v23;
				push_u64(v1);
				push_value(v9);
			} break;
			case 0LL: { // None
				int64_t v51 = 0LL /* False */;
				x37 = v51;
				x36 = v30;
				x35 = v27;
				x34 = v26;
				x33 = v25;
				x32 = v13;
				x31 = v23;
				push_u64(v1);
				push_value(v9);
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		uint64_t v52 = x31;
		VAL v53 = (x32);
		VAL v54 = x33;
		VAL v55 = (x34);
		VAL v56 = x35;
		VAL v57 = x36;
		int64_t v58 = x37;
		while (((bool)v58)) {
			uint64_t v59 = v52;
			VAL v60 = (v53);
			VAL v61 = v54;
			VAL v62 = (v55);
			VAL v63 = v56;
			VAL v64 = v57;
			VAL v65;
			VAL v66;
			mw_std_list_List_1_uncons(v64, &v65, &v66);
			uint64_t x67;
			VAL x68;
			VAL x69;
			VAL x70;
			VAL x71;
			VAL x72;
			int64_t x73;
			switch (get_data_tag(v65)) {
				case 1LL: { // Some
					VAL v74 = mtp_std_maybe_Maybe_1_Some(v65);
					incref(v74);
					VAL v75 = mw_mirth_var_Ctx_new(v61, VU64(v74));
					VAL v76;
					uint64_t v77;
					mw_mirth_elab_abZ_tokenZAt(v62, &v76, &v77);
					VAL v78;
					VAL v79;
					VAL v80;
					uint64_t v81;
					mw_mirth_elab_elabZ_expandZ_tensorZBang(v60, v63, v77, &v78, &v79, &v80, &v81);
					VAL v82 = mw_mirth_var_Var_type(VU64(v74));
					VAL v83;
					VAL v84;
					uint64_t v85;
					mw_mirth_elab_elabZ_typeZ_unifyZBang(v78, v80, v82, v81, &v83, &v84, &v85);
					decref(v84);
					int64_t v86 = 1LL /* True */;
					x73 = v86;
					x72 = v66;
					x71 = v79;
					x70 = v76;
					x69 = v75;
					x68 = v83;
					x67 = v59;
				} break;
				case 0LL: { // None
					int64_t v87 = 0LL /* False */;
					x73 = v87;
					x72 = v66;
					x71 = v63;
					x70 = v62;
					x69 = v61;
					x68 = v60;
					x67 = v59;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			v58 = x73;
			v57 = x72;
			v56 = x71;
			v55 = x70;
			v54 = x69;
			v53 = x68;
			v52 = x67;
		}
		decref(v57);
		VAL v88;
		VAL v89;
		mw_mirth_elab_abZ_homeZAt(v55, &v88, &v89);
		incref(v56);
		VAL v90 = MKI64(0LL /* Nil */);
		VAL v91 = mtw_mirth_arrow_Arrow_Arrow(v89, v52, v52, v54, v56, v56, v90);
		VAL v92 = pop_value();
		VAL v93;
		VAL v94;
		VAL v95;
		mw_mirth_elab_elabZ_defZ_bodyZBang(v92, v53, v91, &v93, &v94, &v95);
		VAL v96;
		VAL v97;
		mw_mirth_elab_abZ_ctxZAt(v88, &v96, &v97);
		VAL v98;
		VAL v99;
		mw_mirth_elab_abZ_typeZAt(v96, &v98, &v99);
		VAL v100;
		uint64_t v101;
		mw_mirth_elab_abZ_tokenZAt(v98, &v100, &v101);
		VAL v102 = mtw_mirth_arrow_Lambda_Lambda(v101, v97, v99, v12, v95);
		VAL v103 = mtw_mirth_arrow_Op_OpLambda(v102);
		VAL v104;
		VAL v105;
		mw_mirth_elab_abZ_opZBang(v103, v94, v100, &v104, &v105);
		x18 = v105;
		x17 = v104;
		x16 = v93;
		uint64_t v106 = pop_u64();
		x15 = v106;
	}
	VAL v107;
	VAL v108;
	mw_mirth_elab_abZ_unifyZ_typeZBang(x16, x17, x18, &v107, &v108);
	VAL v109;
	VAL v110;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v107, v108, v7, &v109, &v110);
	incref(v110);
	VAL v111 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(v109, x15, v110));
	push_value(v110);
	push_resource(v111);
}
static void mb_mirth_elab_elabZ_defZ_typeZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_elab_elabZ_variableZBang_1 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_elab_elabZ_fieldZBang_1 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_elab_elabZ_fieldZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_elab_elabZ_dataZ_headerZBang_2 (void) {
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_dataZ_paramsZBang(v1, r0, &v2, &v3);
	push_value(v2);
	push_resource(v3);
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_5 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	VAL v4;
	mw_mirth_data_Tag_ctxZ_type(r0, v1, &v2, &v3, &v4);
	VAL v5;
	VAL v6;
	mw_mirth_type_ArrowType_unpack(v4, &v5, &v6);
	VAL v7 = mw_mirth_type_TZ_ZTo(v6, v5);
	VAL v8 = MKNIL;
	VAL v9 = mkcons(v8, v3);
	VAL v10 = mkcons(v9, v7);
	push_resource(v2);
	push_value(v10);
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_14 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	int64_t v2 = mw_mirth_data_Data_isZ_unitZAsk(v1);
	VAL x3;
	uint64_t x4;
	VAL x5;
	if (((bool)v2)) {
		VAL v6 = MKI64(5LL /* Phantom */);
		VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
		x5 = v7;
		x4 = v1;
		x3 = r0;
	} else {
		int64_t v8 = mw_mirth_data_Data_isZ_enumZAsk(v1);
		VAL x9;
		uint64_t x10;
		VAL x11;
		if (((bool)v8)) {
			STR* v12;
			STRLIT(v12, "int", 3);
			VAL v13 = mtw_mirth_type_CType_IntLike(MKSTR(v12));
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			x11 = v14;
			x10 = v1;
			x9 = r0;
		} else {
			VAL v15;
			VAL v16;
			mw_mirth_data_Data_semiZ_transparentZAsk(r0, v1, &v15, &v16);
			uint64_t x17;
			VAL x18;
			VAL x19;
			switch (get_data_tag(v16)) {
				case 1LL: { // Some
					VAL v20 = mtp_std_maybe_Maybe_1_Some(v16);
					VAL v21 = VVAL(VTUP(v20)->cells[2]);
					incref(v21);
					decref(v20);
					uint64_t x22;
					VAL x23;
					VAL x24;
					switch (get_data_tag(v21)) {
						case 0LL: { // STPCons
							VAL v25 = mtp_mirth_type_StackTypePart_STPCons(v21);
							VAL v26;
							VAL v27;
							mw_mirth_type_Type_ctypeZAsk(v15, v25, &v26, &v27);
							x24 = v27;
							x23 = v26;
							x22 = v1;
						} break;
						case 1LL: { // STPConsLabel
							VAL v28;
							uint64_t v29;
							mtp_mirth_type_StackTypePart_STPConsLabel(v21, &v28, &v29);
							VAL v30;
							VAL v31;
							mw_mirth_type_Type_ctypeZAsk(v15, v28, &v30, &v31);
							x24 = v31;
							x23 = v30;
							x22 = v1;
						} break;
						case 2LL: { // STPWith
							VAL v32 = mtp_mirth_type_StackTypePart_STPWith(v21);
							VAL v33;
							VAL v34;
							mw_mirth_type_Resource_ctypeZAsk(v15, v32, &v33, &v34);
							x24 = v34;
							x23 = v33;
							x22 = v1;
						} break;
						case 3LL: { // STPWithLabel
							VAL v35;
							uint64_t v36;
							mtp_mirth_type_StackTypePart_STPWithLabel(v21, &v35, &v36);
							VAL v37;
							VAL v38;
							mw_mirth_type_Resource_ctypeZAsk(v15, v35, &v37, &v38);
							x24 = v38;
							x23 = v37;
							x22 = v1;
						} break;
						default: {
							do_panic(str_make("unexpected fallthrough in match\n", 32));
						}
					}
					x19 = x24;
					x18 = x23;
					x17 = x22;
				} break;
				case 0LL: { // None
					VAL v39 = MKI64(0LL /* None */);
					x19 = v39;
					x18 = v15;
					x17 = v1;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x11 = x19;
			x10 = x17;
			x9 = x18;
		}
		x5 = x11;
		x4 = x10;
		x3 = x9;
	}
	push_resource(x3);
	push_value(x5);
}
static void mb_mirth_elab_elabZ_defZ_head_3 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_elab_createZ_projectorsZBang_24 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_word_Word_type(v1, r0, &v2, &v3);
	VAL v4 = mw_mirth_type_ArrowType_dom(v2);
	VAL v5 = mw_mirth_type_StackType_topZ_typeZAsk(v4);
	VAL x6;
	VAL x7;
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v8 = mtp_std_maybe_Maybe_1_Some(v5);
			x7 = v8;
			x6 = v3;
		} break;
		case 0LL: { // None
			STR* v9;
			STRLIT(v9, "logic error: expected parameter", 31);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v9), v3);
			VAL v10 = pop_value();
			x7 = v10;
			VAL r11 = pop_resource();
			x6 = r11;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v12 = mw_mirth_type_Type_morphismZAsk(x7);
	VAL x13;
	VAL x14;
	switch (get_data_tag(v12)) {
		case 1LL: { // Some
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v12);
			x14 = v15;
			x13 = x6;
		} break;
		case 0LL: { // None
			STR* v16;
			STRLIT(v16, "logic error: expected morphism", 30);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v16), x6);
			VAL v17 = pop_value();
			x14 = v17;
			VAL r18 = pop_resource();
			x13 = r18;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	STR* v19;
	STRLIT(v19, "f", 1);
	uint64_t v20 = mw_std_prim_Str_ZToName(MKSTR(v19));
	uint64_t v21 = mw_mirth_var_Var_newZ_autoZ_runZBang(x14, v20);
	VAL v22 = MKI64(0LL /* Nil */);
	VAL v23 = mtw_std_list_List_1_Cons(MKU64(v21), v22);
	push_resource(x13);
	push_value(v23);
}
static void mb_mirth_elab_elabZ_externalZ_defZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	uint64_t v2 = mw_mirth_external_External_sig(v1);
	VAL v3 = (mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang(v2));
	VAL v4;
	VAL v5;
	VAL v6;
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(r0, v3, &v4, &v5, &v6);
	VAL v7 = VVAL(VTUP(v5)->cells[1]);
	incref(v7);
	VAL v8 = MKNIL;
	VAL v9 = mkcons(v8, v7);
	VAL v10 = mkcons(v9, v6);
	mw_mirth_elab_ZPlusTypeElab_rdrop(v5);
	push_resource(v4);
	push_value(v10);
}
static void mb_mirth_elab_elabZ_externalZ_defZBang_4 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2;
	VAL v3;
	mw_mirth_elab_elabZ_defZ_externalZ_ctype(r0, v1, &v2, &v3);
	push_resource(v2);
	push_value(v3);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot81ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	VAL v8;
	VAL v9;
	VAL v10;
	uint64_t v11;
	VAL v12;
	uint64_t v13;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3), &v8, &v9, &v10, &v11, &v12, &v13);
	VAL v14;
	VAL v15;
	mw_mirth_type_ArrowType_unpack(v10, &v14, &v15);
	incref(v14);
	VAL v16 = MKI64(0LL /* Nil */);
	VAL v17 = mtw_mirth_arrow_Arrow_Arrow(v12, v11, v11, v9, v14, v14, v16);
	VAL v18;
	VAL v19;
	mw_mirth_specializzer_synthZ_specializzedZ_wordZBang(v8, v17, v7, VU64(v5), &v18, &v19);
	VAL v20;
	VAL v21;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v15, v18, v19, &v20, &v21);
	VAL v22;
	VAL v23;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v20, v21, v13, &v22, &v23);
	push_resource(v22);
	push_value(v23);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot63ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL v6;
	VAL v7;
	VAL v8;
	mw_mirth_word_Word_ctxZ_type(VU64(v3), r1, &v6, &v7, &v8);
	VAL v9;
	VAL v10;
	VAL v11;
	mw_mirth_specializzer_specializzeZ_ctxZ_type(v8, v5, v6, v7, &v9, &v10, &v11);
	VAL v12 = MKNIL;
	VAL v13 = mkcons(v12, v10);
	VAL v14 = mkcons(v13, v11);
	push_resource(v9);
	push_value(v14);
}
static void mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot267ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	VAL v8;
	VAL v9;
	value_uncons(v6, &v8, &v9);
	decref(v8);
	incref(v3);
	VAL v10;
	VAL v11;
	VAL v12;
	uint64_t v13;
	VAL v14;
	uint64_t v15;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3), &v10, &v11, &v12, &v13, &v14, &v15);
	VAL v16;
	VAL v17;
	mw_mirth_type_ArrowType_unpack(v12, &v16, &v17);
	incref(v16);
	VAL v18 = MKI64(0LL /* Nil */);
	VAL v19 = mtw_mirth_arrow_Arrow_Arrow(v14, v13, v13, v11, v16, v16, v18);
	VAL v20;
	VAL v21;
	mw_mirth_word_Word_params(VU64(v3), v10, &v20, &v21);
	incref(v20);
	VAL v22;
	uint64_t v23;
	mw_mirth_elab_abZ_tokenZAt(v19, &v22, &v23);
	incref(v20);
	VAL v24;
	VAL v25;
	mw_mirth_elab_abZ_ctxZAt(v22, &v24, &v25);
	VAL v26;
	VAL v27;
	mw_mirth_elab_abZ_typeZAt(v24, &v26, &v27);
	VAL v28 = mw_std_list_List_1_reverse(v20);
	VAL v29;
	VAL v30;
	mw_std_list_List_1_uncons(v28, &v29, &v30);
	uint64_t x31;
	VAL x32;
	VAL x33;
	VAL x34;
	VAL x35;
	VAL x36;
	int64_t x37;
	switch (get_data_tag(v29)) {
		case 1LL: { // Some
			VAL v38 = mtp_std_maybe_Maybe_1_Some(v29);
			incref(v38);
			VAL v39 = mw_mirth_var_Ctx_new(v25, VU64(v38));
			VAL v40;
			uint64_t v41;
			mw_mirth_elab_abZ_tokenZAt(v26, &v40, &v41);
			VAL v42;
			VAL v43;
			VAL v44;
			uint64_t v45;
			mw_mirth_elab_elabZ_expandZ_tensorZBang(v21, v27, v41, &v42, &v43, &v44, &v45);
			VAL v46 = mw_mirth_var_Var_type(VU64(v38));
			VAL v47;
			VAL v48;
			uint64_t v49;
			mw_mirth_elab_elabZ_typeZ_unifyZBang(v42, v44, v46, v45, &v47, &v48, &v49);
			decref(v48);
			int64_t v50 = 1LL /* True */;
			x37 = v50;
			x36 = v30;
			x35 = v43;
			x34 = v40;
			x33 = v39;
			x32 = v47;
			x31 = v23;
			lpush(&lbl_lblz_set, v5);
			lpush(&lbl_lblz_get, v7);
			lpush(&lbl_dat, v9);
			push_value(v17);
			push_value(v20);
		} break;
		case 0LL: { // None
			int64_t v51 = 0LL /* False */;
			x37 = v51;
			x36 = v30;
			x35 = v27;
			x34 = v26;
			x33 = v25;
			x32 = v21;
			x31 = v23;
			lpush(&lbl_lblz_set, v5);
			lpush(&lbl_lblz_get, v7);
			lpush(&lbl_dat, v9);
			push_value(v17);
			push_value(v20);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v52 = x31;
	VAL v53 = (x32);
	VAL v54 = x33;
	VAL v55 = (x34);
	VAL v56 = x35;
	VAL v57 = x36;
	int64_t v58 = x37;
	while (((bool)v58)) {
		uint64_t v59 = v52;
		VAL v60 = (v53);
		VAL v61 = v54;
		VAL v62 = (v55);
		VAL v63 = v56;
		VAL v64 = v57;
		VAL v65;
		VAL v66;
		mw_std_list_List_1_uncons(v64, &v65, &v66);
		uint64_t x67;
		VAL x68;
		VAL x69;
		VAL x70;
		VAL x71;
		VAL x72;
		int64_t x73;
		switch (get_data_tag(v65)) {
			case 1LL: { // Some
				VAL v74 = mtp_std_maybe_Maybe_1_Some(v65);
				incref(v74);
				VAL v75 = mw_mirth_var_Ctx_new(v61, VU64(v74));
				VAL v76;
				uint64_t v77;
				mw_mirth_elab_abZ_tokenZAt(v62, &v76, &v77);
				VAL v78;
				VAL v79;
				VAL v80;
				uint64_t v81;
				mw_mirth_elab_elabZ_expandZ_tensorZBang(v60, v63, v77, &v78, &v79, &v80, &v81);
				VAL v82 = mw_mirth_var_Var_type(VU64(v74));
				VAL v83;
				VAL v84;
				uint64_t v85;
				mw_mirth_elab_elabZ_typeZ_unifyZBang(v78, v80, v82, v81, &v83, &v84, &v85);
				decref(v84);
				int64_t v86 = 1LL /* True */;
				x73 = v86;
				x72 = v66;
				x71 = v79;
				x70 = v76;
				x69 = v75;
				x68 = v83;
				x67 = v59;
			} break;
			case 0LL: { // None
				int64_t v87 = 0LL /* False */;
				x73 = v87;
				x72 = v66;
				x71 = v63;
				x70 = v62;
				x69 = v61;
				x68 = v60;
				x67 = v59;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v58 = x73;
		v57 = x72;
		v56 = x71;
		v55 = x70;
		v54 = x69;
		v53 = x68;
		v52 = x67;
	}
	decref(v57);
	VAL v88;
	VAL v89;
	mw_mirth_elab_abZ_homeZAt(v55, &v88, &v89);
	incref(v56);
	VAL v90 = MKI64(0LL /* Nil */);
	VAL v91 = mtw_mirth_arrow_Arrow_Arrow(v89, v52, v52, v54, v56, v56, v90);
	VAL v92 = pop_value();
	VAL v93 = mw_std_list_List_1_ZDivL1(v92);
	uint64_t x94;
	uint64_t x95;
	uint64_t x96;
	VAL x97;
	VAL x98;
	VAL x99;
	uint64_t x100;
	switch (get_data_tag(v93)) {
		case 1LL: { // Some
			VAL v101 = mtp_std_maybe_Maybe_1_Some(v93);
			x100 = VU64(v101);
			x99 = v91;
			x98 = v53;
			VAL v102 = pop_value();
			x97 = v102;
			uint64_t v103 = VU64(lpop(&lbl_dat));
			x96 = v103;
			uint64_t v104 = VU64(lpop(&lbl_lblz_get));
			x95 = v104;
			uint64_t v105 = VU64(lpop(&lbl_lblz_set));
			x94 = v105;
		} break;
		case 0LL: { // None
			STR* v106;
			STRLIT(v106, "Expected one parameter.", 23);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v106), v53);
			uint64_t v107 = pop_u64();
			x100 = v107;
			x99 = v91;
			VAL r108 = pop_resource();
			x98 = r108;
			VAL v109 = pop_value();
			x97 = v109;
			uint64_t v110 = VU64(lpop(&lbl_dat));
			x96 = v110;
			uint64_t v111 = VU64(lpop(&lbl_lblz_get));
			x95 = v111;
			uint64_t v112 = VU64(lpop(&lbl_lblz_set));
			x94 = v112;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	int64_t v113 = mw_mirth_data_Data_isZ_resourceZAsk(x96);
	VAL x114;
	VAL x115;
	VAL x116;
	if (((bool)v113)) {
		VAL v117;
		VAL v118;
		mw_mirth_elab_abZ_wordZBang(x95, x98, x99, &v117, &v118);
		VAL v119;
		uint64_t v120;
		mw_mirth_elab_abZ_tokenZAt(v118, &v119, &v120);
		VAL v121;
		VAL v122;
		mw_mirth_elab_abZ_ctxZAt(v119, &v121, &v122);
		uint64_t v123 = mw_mirth_type_MetaVar_newZBang();
		VAL v124 = mtw_mirth_type_StackType_STMeta(v123);
		VAL v125;
		VAL v126;
		mw_mirth_elab_abZ_homeZAt(v121, &v125, &v126);
		incref(v124);
		VAL v127 = MKI64(0LL /* Nil */);
		VAL v128 = mtw_mirth_arrow_Arrow_Arrow(v126, v120, v120, v122, v124, v124, v127);
		VAL v129;
		VAL v130;
		mw_mirth_elab_abZ_varZBang(x100, v117, v128, &v129, &v130);
		VAL v131;
		uint64_t v132;
		mw_mirth_arrow_Block_newZBang(v129, v130, &v131, &v132);
		VAL v133 = mtw_mirth_arrow_Op_OpBlockPush(v132);
		VAL v134;
		VAL v135;
		mw_mirth_elab_abZ_opZBang(v133, v131, v125, &v134, &v135);
		int64_t v136 = 6LL /* PRIM_CORE_RDIP */;
		VAL v137;
		VAL v138;
		mw_mirth_elab_abZ_primZBang(v136, v134, v135, &v137, &v138);
		VAL v139;
		VAL v140;
		mw_mirth_elab_abZ_wordZBang(x94, v137, v138, &v139, &v140);
		x116 = v140;
		x115 = v139;
		x114 = x97;
	} else {
		int64_t v141 = 1LL /* PRIM_CORE_DUP */;
		VAL v142;
		VAL v143;
		mw_mirth_elab_abZ_primZBang(v141, x98, x99, &v142, &v143);
		VAL v144;
		uint64_t v145;
		mw_mirth_elab_abZ_tokenZAt(v143, &v144, &v145);
		VAL v146;
		VAL v147;
		mw_mirth_elab_abZ_ctxZAt(v144, &v146, &v147);
		uint64_t v148 = mw_mirth_type_MetaVar_newZBang();
		VAL v149 = mtw_mirth_type_StackType_STMeta(v148);
		VAL v150;
		VAL v151;
		mw_mirth_elab_abZ_homeZAt(v146, &v150, &v151);
		incref(v149);
		VAL v152 = MKI64(0LL /* Nil */);
		VAL v153 = mtw_mirth_arrow_Arrow_Arrow(v151, v145, v145, v147, v149, v149, v152);
		VAL v154;
		VAL v155;
		mw_mirth_elab_abZ_wordZBang(x95, v142, v153, &v154, &v155);
		VAL v156;
		VAL v157;
		mw_mirth_elab_abZ_varZBang(x100, v154, v155, &v156, &v157);
		VAL v158;
		uint64_t v159;
		mw_mirth_arrow_Block_newZBang(v156, v157, &v158, &v159);
		VAL v160 = mtw_mirth_arrow_Op_OpBlockPush(v159);
		VAL v161;
		VAL v162;
		mw_mirth_elab_abZ_opZBang(v160, v158, v150, &v161, &v162);
		int64_t v163 = 5LL /* PRIM_CORE_DIP */;
		VAL v164;
		VAL v165;
		mw_mirth_elab_abZ_primZBang(v163, v161, v162, &v164, &v165);
		VAL v166;
		VAL v167;
		mw_mirth_elab_abZ_wordZBang(x94, v164, v165, &v166, &v167);
		x116 = v167;
		x115 = v166;
		x114 = x97;
	}
	VAL v168;
	VAL v169;
	mw_mirth_elab_abZ_ctxZAt(v88, &v168, &v169);
	VAL v170;
	VAL v171;
	mw_mirth_elab_abZ_typeZAt(v168, &v170, &v171);
	VAL v172;
	uint64_t v173;
	mw_mirth_elab_abZ_tokenZAt(v170, &v172, &v173);
	VAL v174 = mtw_mirth_arrow_Lambda_Lambda(v173, v169, v171, v20, x116);
	VAL v175 = mtw_mirth_arrow_Op_OpLambda(v174);
	VAL v176;
	VAL v177;
	mw_mirth_elab_abZ_opZBang(v175, x115, v172, &v176, &v177);
	VAL v178;
	VAL v179;
	mw_mirth_elab_abZ_unifyZ_typeZBang(x114, v176, v177, &v178, &v179);
	VAL v180;
	VAL v181;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v178, v179, v15, &v180, &v181);
	push_resource(v180);
	push_value(v181);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot167ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL v6 = mw_mirth_type_TYPEz_STACK();
	STR* v7;
	STRLIT(v7, "*x", 2);
	uint64_t v8 = mw_std_prim_Str_ZToName(MKSTR(v7));
	uint64_t v9 = mw_mirth_var_Var_newZBang(v6, v8);
	VAL v10 = mw_mirth_type_TYPEz_STACK();
	STR* v11;
	STRLIT(v11, "*y", 2);
	uint64_t v12 = mw_std_prim_Str_ZToName(MKSTR(v11));
	uint64_t v13 = mw_mirth_var_Var_newZBang(v10, v12);
	incref(v5);
	VAL v14;
	VAL v15;
	mw_mirth_data_Tag_projectZ_inputZ_label(r1, VU64(v3), VU64(v5), &v14, &v15);
	uint64_t x16;
	uint64_t x17;
	uint64_t x18;
	VAL x19;
	VAL x20;
	switch (get_data_tag(v15)) {
		case 1LL: { // Some
			VAL v21 = mtp_std_maybe_Maybe_1_Some(v15);
			x20 = v21;
			x19 = v14;
			x18 = VU64(v5);
			x17 = v13;
			x16 = v9;
		} break;
		case 0LL: { // None
			STR* v22;
			STRLIT(v22, "logic error: expeted field in tag.", 34);
			lpush(&lbl_sx, MKU64(v9));
			lpush(&lbl_sy, MKU64(v13));
			lpush(&lbl_tag, v5);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v22), v14);
			VAL v23 = pop_value();
			x20 = v23;
			VAL r24 = pop_resource();
			x19 = r24;
			uint64_t v25 = VU64(lpop(&lbl_tag));
			x18 = v25;
			uint64_t v26 = VU64(lpop(&lbl_sy));
			x17 = v26;
			uint64_t v27 = VU64(lpop(&lbl_sx));
			x16 = v27;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v28;
	VAL v29;
	mw_mirth_data_Tag_outputZ_type(x19, x18, &v28, &v29);
	VAL v30;
	VAL v31;
	mw_mirth_data_Tag_ctx(v28, x18, &v30, &v31);
	VAL v32 = MKI64(0LL /* Nil */);
	VAL v33 = mtw_std_list_List_1_Cons(MKU64(x17), v32);
	VAL v34 = mtw_std_list_List_1_Cons(MKU64(x16), v33);
	VAL v35 = mw_std_list_List_1_cat(v31, v34);
	VAL v36 = mtw_mirth_type_StackType_STVar(x16);
	incref(v29);
	VAL v37 = mw_mirth_type_TZMulZPlus(v36, v29);
	VAL v38 = mtw_mirth_type_StackType_STVar(x16);
	incref(x20);
	VAL v39 = mw_mirth_type_TZMulZPlus(v38, x20);
	VAL v40 = mtw_mirth_type_StackType_STVar(x17);
	incref(x20);
	VAL v41 = mw_mirth_type_TZMulZPlus(v40, x20);
	VAL v42 = mw_mirth_type_TZ_ZTo(v39, v41);
	VAL v43 = mtw_mirth_type_Type_TMorphism(v42);
	VAL v44 = mw_mirth_type_TZMul(v37, v43);
	VAL v45 = mtw_mirth_type_StackType_STVar(x17);
	incref(v29);
	VAL v46 = mw_mirth_type_TZMulZPlus(v45, v29);
	VAL v47 = mw_mirth_type_TZ_ZTo(v44, v46);
	VAL v48 = MKNIL;
	VAL v49 = mkcons(v48, v35);
	VAL v50 = mkcons(v49, v47);
	decref(v29);
	decref(x20);
	push_resource(v30);
	push_value(v50);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot134ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	VAL v8;
	VAL v9;
	VAL v10;
	uint64_t v11;
	VAL v12;
	uint64_t v13;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3), &v8, &v9, &v10, &v11, &v12, &v13);
	VAL v14;
	VAL v15;
	mw_mirth_type_ArrowType_unpack(v10, &v14, &v15);
	incref(v14);
	VAL v16 = MKI64(0LL /* Nil */);
	VAL v17 = mtw_mirth_arrow_Arrow_Arrow(v12, v11, v11, v9, v14, v14, v16);
	VAL v18;
	VAL v19;
	mw_mirth_data_Tag_projectZ_tagZ_field(v8, VU64(v5), VU64(v7), &v18, &v19);
	VAL x20;
	VAL x21;
	VAL x22;
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v23 = mtp_std_maybe_Maybe_1_Some(v19);
			x22 = v23;
			x21 = v17;
			x20 = v18;
		} break;
		case 0LL: { // None
			STR* v24;
			STRLIT(v24, "logic error: expected field in tag.", 35);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v24), v18);
			VAL v25 = pop_value();
			x22 = v25;
			x21 = v17;
			VAL r26 = pop_resource();
			x20 = r26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v27 = mtw_mirth_arrow_Op_OpDataSetLabel(x22);
	VAL v28;
	VAL v29;
	mw_mirth_elab_abZ_opZBang(v27, x20, x21, &v28, &v29);
	VAL v30;
	VAL v31;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v15, v28, v29, &v30, &v31);
	VAL v32;
	VAL v33;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v30, v31, v13, &v32, &v33);
	push_resource(v32);
	push_value(v33);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot106ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	incref(v5);
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_ctx(r1, VU64(v5), &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_data_Tag_projectZ_tagZ_field(v6, VU64(v3), VU64(v5), &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
			x12 = v13;
			x11 = v8;
			x10 = v7;
		} break;
		case 0LL: { // None
			STR* v14;
			STRLIT(v14, "logic error: expected field in tag.", 35);
			push_value(v7);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v14), v8);
			VAL v15 = pop_value();
			x12 = v15;
			VAL r16 = pop_resource();
			x11 = r16;
			VAL v17 = pop_value();
			x10 = v17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18;
	VAL v19;
	mw_mirth_elab_dataZ_setZ_labelZ_type(x11, x12, &v18, &v19);
	VAL v20 = MKNIL;
	VAL v21 = mkcons(v20, x10);
	VAL v22 = mkcons(v21, v19);
	push_resource(v18);
	push_value(v22);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot73ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	VAL v8;
	VAL v9;
	VAL v10;
	uint64_t v11;
	VAL v12;
	uint64_t v13;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3), &v8, &v9, &v10, &v11, &v12, &v13);
	VAL v14;
	VAL v15;
	mw_mirth_type_ArrowType_unpack(v10, &v14, &v15);
	incref(v14);
	VAL v16 = MKI64(0LL /* Nil */);
	VAL v17 = mtw_mirth_arrow_Arrow_Arrow(v12, v11, v11, v9, v14, v14, v16);
	VAL v18;
	VAL v19;
	mw_mirth_data_Tag_projectZ_tagZ_field(v8, VU64(v5), VU64(v7), &v18, &v19);
	VAL x20;
	VAL x21;
	VAL x22;
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v23 = mtp_std_maybe_Maybe_1_Some(v19);
			x22 = v23;
			x21 = v17;
			x20 = v18;
		} break;
		case 0LL: { // None
			STR* v24;
			STRLIT(v24, "logic error: expected field in tag.", 35);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v24), v18);
			VAL v25 = pop_value();
			x22 = v25;
			x21 = v17;
			VAL r26 = pop_resource();
			x20 = r26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v27 = mtw_mirth_arrow_Op_OpDataGetLabel(x22);
	VAL v28;
	VAL v29;
	mw_mirth_elab_abZ_opZBang(v27, x20, x21, &v28, &v29);
	VAL v30;
	VAL v31;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v15, v28, v29, &v30, &v31);
	VAL v32;
	VAL v33;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v30, v31, v13, &v32, &v33);
	push_resource(v32);
	push_value(v33);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	incref(v5);
	VAL v6;
	VAL v7;
	mw_mirth_data_Tag_ctx(r1, VU64(v5), &v6, &v7);
	VAL v8;
	VAL v9;
	mw_mirth_data_Tag_projectZ_tagZ_field(v6, VU64(v3), VU64(v5), &v8, &v9);
	VAL x10;
	VAL x11;
	VAL x12;
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v9);
			x12 = v13;
			x11 = v8;
			x10 = v7;
		} break;
		case 0LL: { // None
			STR* v14;
			STRLIT(v14, "logic error: expected field in tag.", 35);
			push_value(v7);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v14), v8);
			VAL v15 = pop_value();
			x12 = v15;
			VAL r16 = pop_resource();
			x11 = r16;
			VAL v17 = pop_value();
			x10 = v17;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v18;
	VAL v19;
	mw_mirth_elab_dataZ_getZ_labelZ_type(x11, x12, &v18, &v19);
	VAL v20 = MKNIL;
	VAL v21 = mkcons(v20, x10);
	VAL v22 = mkcons(v21, v19);
	push_resource(v18);
	push_value(v22);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot104ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL v6;
	VAL v7;
	VAL v8;
	uint64_t v9;
	VAL v10;
	uint64_t v11;
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3), &v6, &v7, &v8, &v9, &v10, &v11);
	VAL v12;
	VAL v13;
	mw_mirth_type_ArrowType_unpack(v8, &v12, &v13);
	incref(v12);
	VAL v14 = MKI64(0LL /* Nil */);
	VAL v15 = mtw_mirth_arrow_Arrow_Arrow(v10, v9, v9, v7, v12, v12, v14);
	incref(v5);
	VAL v16;
	VAL v17;
	mw_mirth_data_Tag_type(v6, VU64(v5), &v16, &v17);
	VAL v18 = mw_mirth_type_ArrowType_dom(v17);
	incref(v5);
	uint64_t v19 = mw_mirth_data_Tag_data(VU64(v5));
	VAL v20 = mw_mirth_data_Data_headZAsk(v19);
	VAL x21;
	VAL x22;
	VAL x23;
	VAL x24;
	uint64_t x25;
	uint64_t x26;
	switch (get_data_tag(v20)) {
		case 1LL: { // Some
			VAL v27 = mtp_std_maybe_Maybe_1_Some(v20);
			x26 = VU64(v27);
			x25 = VU64(v5);
			x24 = v18;
			x23 = v15;
			x22 = v16;
			x21 = v13;
		} break;
		case 0LL: { // None
			STR* v28;
			STRLIT(v28, "Missing data token info", 23);
			push_value(v13);
			lpush(&lbl_cod, v18);
			lpush(&lbl_tag, v5);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v28), v16);
			uint64_t v29 = pop_u64();
			x26 = v29;
			uint64_t v30 = VU64(lpop(&lbl_tag));
			x25 = v30;
			VAL v31 = lpop(&lbl_cod);
			x24 = v31;
			x23 = v15;
			VAL r32 = pop_resource();
			x22 = r32;
			VAL v33 = pop_value();
			x21 = v33;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v34;
	VAL v35;
	mw_mirth_elab_abZ_ctxZAt(x23, &v34, &v35);
	VAL v36;
	VAL v37;
	mw_mirth_elab_abZ_typeZAt(v34, &v36, &v37);
	VAL v38;
	uint64_t v39;
	mw_mirth_elab_abZ_tokenZAt(v36, &v38, &v39);
	VAL v40;
	VAL v41;
	mw_mirth_elab_abZ_homeZAt(v38, &v40, &v41);
	VAL v42 = MKI64(0LL /* Nil */);
	VAL v43 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v41, v39, x26, v35, v37, x24, v42));
	VAL v44 = VVAL(VTUP(v43)->cells[1]);
	incref(v44);
	VAL v45 = VVAL(VTUP(v43)->cells[4]);
	incref(v45);
	incref(v45);
	VAL v46 = MKI64(0LL /* Nil */);
	VAL v47 = VVAL(VTUP(v43)->cells[5]);
	incref(v47);
	incref(v47);
	VAL v48 = MKI64(0LL /* Nil */);
	VAL v49 = mtw_mirth_match_Pattern_Pattern(v44, x26, x26, v45, v45, v46, v47, v47, v48);
	VAL v50 = (mw_mirth_match_Pattern_thaw(v49));
	VAL v51;
	VAL v52;
	mw_mirth_match_ZPlusPattern_tagZBang(x22, v50, x25, &v51, &v52);
	VAL v53 = mw_mirth_match_ZPlusPattern_freezze(v52);
	incref(v53);
	VAL v54 = VVAL(VTUP(v53)->cells[5]);
	incref(v54);
	decref(v53);
	incref(v53);
	VAL v55 = mw_mirth_match_Pattern_dom(v53);
	VAL v56 = VVAL(VTUP(v43)->cells[6]);
	incref(v56);
	VAL v57 = mw_mirth_type_TZ_ZTo(v55, v56);
	VAL v58 = VVAL(VTUP(v43)->cells[1]);
	incref(v58);
	VAL v59;
	VAL v60;
	mw_mirth_type_ArrowType_unpack(v57, &v59, &v60);
	incref(v59);
	VAL v61 = MKI64(0LL /* Nil */);
	VAL v62 = mtw_mirth_arrow_Arrow_Arrow(v58, x26, x26, v54, v59, v59, v61);
	VAL v63;
	VAL v64;
	mw_mirth_elab_abZ_unifyZ_typeZBang(v60, v51, v62, &v63, &v64);
	VAL v65 = mtw_mirth_match_Case_CASE(v53, v64);
	VAL v66;
	VAL v67;
	mw_mirth_match_ZPlusMatch_addZ_case(v63, v43, v65, &v66, &v67);
	VAL v68 = mw_mirth_match_ZPlusMatch_freezze(v67);
	VAL v69 = mtw_mirth_arrow_Op_OpMatch(v68);
	VAL v70;
	VAL v71;
	mw_mirth_elab_abZ_opZBang(v69, v66, v40, &v70, &v71);
	VAL v72;
	VAL v73;
	mw_mirth_elab_abZ_unifyZ_typeZBang(x21, v70, v71, &v72, &v73);
	VAL v74;
	VAL v75;
	mw_mirth_elab_finalizzeZ_wordZ_arrow(v72, v73, v11, &v74, &v75);
	push_resource(v74);
	push_value(v75);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_dataZ_tagZBangZDot42ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	incref(v3);
	uint64_t v6 = mw_mirth_data_Tag_data(VU64(v3));
	VAL v7;
	VAL v8;
	mw_mirth_data_Data_params(r1, v6, &v7, &v8);
	VAL v9 = mw_std_list_List_1_ZToCtx(v8);
	int64_t v10 = 1LL /* True */;
	int64_t v11 = 0LL /* False */;
	VAL v12 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v9, VU64(v5), v11, v10));
	VAL v13 = mw_mirth_type_T0();
	incref(v3);
	uint64_t v14 = mw_mirth_data_Tag_data(VU64(v3));
	VAL v15;
	VAL v16;
	mw_mirth_data_Data_fullZ_type(v7, v14, &v15, &v16);
	VAL v17 = mw_mirth_type_TZMulZPlus(v13, v16);
	VAL v18 = mw_mirth_data_Tag_sigZAsk(VU64(v3));
	VAL x19;
	VAL x20;
	VAL x21;
	VAL x22;
	switch (get_data_tag(v18)) {
		case 0LL: { // None
			VAL v23 = mw_mirth_type_T0();
			x22 = v23;
			x21 = v17;
			x20 = v12;
			x19 = v15;
		} break;
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v18);
			VTUP(v12)->cells[2] = v24;
			VAL v25 = mw_mirth_type_T0();
			VAL v26;
			VAL v27;
			VAL v28;
			mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang(v15, v12, v25, &v26, &v27, &v28);
			x22 = v28;
			x21 = v17;
			x20 = v27;
			x19 = v26;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	VAL v29 = mw_mirth_type_TZ_ZTo(x22, x21);
	VAL v30 = VVAL(VTUP(x20)->cells[1]);
	incref(v30);
	VAL v31 = MKNIL;
	VAL v32 = mkcons(v31, v30);
	VAL v33 = mkcons(v32, v29);
	mw_mirth_elab_ZPlusTypeElab_rdrop(x20);
	push_resource(x19);
	push_value(v33);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotelabZ_aliasZBangZDot21ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	incref(v5);
	STR* v8;
	STRLIT(v8, "target", 6);
	int64_t v9 = 0LL /* False */;
	int64_t v10 = 0LL /* False */;
	VAL v11;
	VAL v12;
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v8), VU64(v5), v7, v10, v9, r1, &v11, &v12);
	int64_t v13 = mw_mirth_alias_Alias_arity(VU64(v3));
	VAL v14 = VVAL(VTUP(v12)->cells[4]);
	incref(v14);
	VAL v15 = MKI64(0LL /* Nil */);
	VAL v16 = MKI64(0LL /* Nil */);
	VAL v17;
	VAL v18;
	mw_std_list_List_1_uncons(v14, &v17, &v18);
	uint64_t x19;
	VAL x20;
	int64_t x21;
	VAL x22;
	VAL x23;
	VAL x24;
	VAL x25;
	int64_t x26;
	switch (get_data_tag(v17)) {
		case 1LL: { // Some
			VAL v27 = mtp_std_maybe_Maybe_1_Some(v17);
			incref(v27);
			int64_t v28 = mw_mirth_def_Def_arity(v27);
			int64_t v29 = mw_mirth_elab_arityZ_compatibleZAsk(v13, v28);
			uint64_t x30;
			VAL x31;
			int64_t x32;
			VAL x33;
			VAL x34;
			if (((bool)v29)) {
				VAL v35 = mtw_std_either_Either_2_Right(v27);
				x34 = v35;
				x33 = v12;
				x32 = v13;
				x31 = v11;
				x30 = VU64(v5);
			} else {
				VAL v36 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v27);
				VAL v37 = mtw_std_either_Either_2_Left(v36);
				x34 = v37;
				x33 = v12;
				x32 = v13;
				x31 = v11;
				x30 = VU64(v5);
			}
			uint64_t x38;
			VAL x39;
			int64_t x40;
			VAL x41;
			VAL x42;
			VAL x43;
			switch (get_data_tag(x34)) {
				case 0LL: { // Left
					VAL v44 = mtp_std_either_Either_2_Left(x34);
					VAL v45 = mtw_std_list_List_1_Cons(v44, v15);
					x43 = v16;
					x42 = v45;
					x41 = x33;
					x40 = x32;
					x39 = x31;
					x38 = x30;
				} break;
				case 1LL: { // Right
					VAL v46 = mtp_std_either_Either_2_Right(x34);
					VAL v47 = mtw_std_list_List_1_Cons(v46, v16);
					x43 = v47;
					x42 = v15;
					x41 = x33;
					x40 = x32;
					x39 = x31;
					x38 = x30;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			int64_t v48 = 1LL /* True */;
			x26 = v48;
			x25 = v18;
			x24 = x43;
			x23 = x42;
			x22 = x41;
			x21 = x40;
			x20 = x39;
			x19 = x38;
		} break;
		case 0LL: { // None
			int64_t v49 = 0LL /* False */;
			x26 = v49;
			x25 = v18;
			x24 = v16;
			x23 = v15;
			x22 = v12;
			x21 = v13;
			x20 = v11;
			x19 = VU64(v5);
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t v50 = x19;
	VAL v51 = (x20);
	int64_t v52 = x21;
	VAL v53 = (x22);
	VAL v54 = x23;
	VAL v55 = x24;
	VAL v56 = x25;
	int64_t v57 = x26;
	while (((bool)v57)) {
		uint64_t v58 = v50;
		VAL v59 = (v51);
		int64_t v60 = v52;
		VAL v61 = (v53);
		VAL v62 = v54;
		VAL v63 = v55;
		VAL v64 = v56;
		VAL v65;
		VAL v66;
		mw_std_list_List_1_uncons(v64, &v65, &v66);
		uint64_t x67;
		VAL x68;
		int64_t x69;
		VAL x70;
		VAL x71;
		VAL x72;
		VAL x73;
		int64_t x74;
		switch (get_data_tag(v65)) {
			case 1LL: { // Some
				VAL v75 = mtp_std_maybe_Maybe_1_Some(v65);
				incref(v75);
				int64_t v76 = mw_mirth_def_Def_arity(v75);
				int64_t v77 = mw_mirth_elab_arityZ_compatibleZAsk(v60, v76);
				uint64_t x78;
				VAL x79;
				int64_t x80;
				VAL x81;
				VAL x82;
				if (((bool)v77)) {
					VAL v83 = mtw_std_either_Either_2_Right(v75);
					x82 = v83;
					x81 = v61;
					x80 = v60;
					x79 = v59;
					x78 = v58;
				} else {
					VAL v84 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v75);
					VAL v85 = mtw_std_either_Either_2_Left(v84);
					x82 = v85;
					x81 = v61;
					x80 = v60;
					x79 = v59;
					x78 = v58;
				}
				uint64_t x86;
				VAL x87;
				int64_t x88;
				VAL x89;
				VAL x90;
				VAL x91;
				switch (get_data_tag(x82)) {
					case 0LL: { // Left
						VAL v92 = mtp_std_either_Either_2_Left(x82);
						VAL v93 = mtw_std_list_List_1_Cons(v92, v62);
						x91 = v63;
						x90 = v93;
						x89 = x81;
						x88 = x80;
						x87 = x79;
						x86 = x78;
					} break;
					case 1LL: { // Right
						VAL v94 = mtp_std_either_Either_2_Right(x82);
						VAL v95 = mtw_std_list_List_1_Cons(v94, v63);
						x91 = v95;
						x90 = v62;
						x89 = x81;
						x88 = x80;
						x87 = x79;
						x86 = x78;
					} break;
					default: {
						do_panic(str_make("unexpected fallthrough in match\n", 32));
					}
				}
				int64_t v96 = 1LL /* True */;
				x74 = v96;
				x73 = v66;
				x72 = x91;
				x71 = x90;
				x70 = x89;
				x69 = x88;
				x68 = x87;
				x67 = x86;
			} break;
			case 0LL: { // None
				int64_t v97 = 0LL /* False */;
				x74 = v97;
				x73 = v66;
				x72 = v63;
				x71 = v62;
				x70 = v61;
				x69 = v60;
				x68 = v59;
				x67 = v58;
			} break;
			default: {
				do_panic(str_make("unexpected fallthrough in match\n", 32));
			}
		}
		v57 = x74;
		v56 = x73;
		v55 = x72;
		v54 = x71;
		v53 = x70;
		v52 = x69;
		v51 = x68;
		v50 = x67;
	}
	decref(v56);
	VAL v98 = mw_std_list_List_1_reverse(v54);
	VAL v99 = mw_std_list_List_1_reverse(v55);
	VAL v100 = VVAL(VTUP(v53)->cells[5]);
	incref(v100);
	VAL v101 = mw_std_list_List_1_cat(v98, v100);
	VAL v102 = VTUP(v53)->cells[5];
	decref(v102);
	VTUP(v53)->cells[5] = v101;
	VAL v103 = VTUP(v53)->cells[4];
	decref(v103);
	VTUP(v53)->cells[4] = v99;
	VAL v104;
	VAL v105;
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(v51, v53, &v104, &v105);
	VAL v106 = MKI64(0LL /* Nil */);
	VAL v107;
	VAL v108;
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v106, v104, v105, &v107, &v108);
	VAL v109;
	VAL v110;
	mw_mirth_elab_resolveZ_defZ_endZBang(v107, v108, &v109, &v110);
	uint64_t x111;
	VAL x112;
	VAL x113;
	switch (get_data_tag(v110)) {
		case 1LL: { // Some
			VAL v114 = mtp_std_maybe_Maybe_1_Some(v110);
			x113 = v114;
			x112 = v109;
			x111 = v50;
		} break;
		case 0LL: { // None
			lpush(&lbl_target, MKU64(v50));
			mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang(v109);
			VAL v115 = pop_value();
			x113 = v115;
			VAL r116 = pop_resource();
			x112 = r116;
			uint64_t v117 = VU64(lpop(&lbl_target));
			x111 = v117;
		} break;
		default: {
			do_panic(str_make("unexpected fallthrough in match\n", 32));
		}
	}
	uint64_t x118;
	VAL x119;
	VAL x120;
	switch (get_data_tag(x113)) {
		case 0LL: { // DefAlias
			uint64_t v121 = mtp_mirth_def_Def_DefAlias(x113);
			void* v122 = mfld_mirth_alias_Alias_ZTildetarget(v121);
			VAL v123;
			VAL v124;
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(v122, x112, &v123, &v124);
			uint64_t x125;
			VAL x126;
			VAL x127;
			switch (get_data_tag(v123)) {
				case 1LL: { // Some
					VAL v128 = mtp_std_maybe_Maybe_1_Some(v123);
					x127 = v128;
					x126 = v124;
					x125 = x111;
				} break;
				case 0LL: { // None
					STR* v129;
					STRLIT(v129, "Alias points to itself, circular aliases are not allowed.", 57);
					lpush(&lbl_target, MKU64(x111));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(x111, MKSTR(v129), v124);
					VAL v130 = pop_value();
					x127 = v130;
					VAL r131 = pop_resource();
					x126 = r131;
					uint64_t v132 = VU64(lpop(&lbl_target));
					x125 = v132;
				} break;
				default: {
					do_panic(str_make("unexpected fallthrough in match\n", 32));
				}
			}
			x120 = x126;
			x119 = x127;
			x118 = x125;
		} break;
		default: {
			x120 = x112;
			x119 = x113;
			x118 = x111;
		} break;
	}
	push_value(x119);
	push_resource(x120);
}
