#define MIRTH_DEBUG 0
/* MIRTH HEADER */
// #line 3 "src/mirth.h"

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#define MIRTH_WINDOWS 1
#elif defined(__linux__)
#define MIRTH_LINUX 1
#elif defined(__APPLE__)
#define MIRTH_MACOS 1
#else
#error "Platform not supported."
#endif

#if defined(__x86_64__) || defined(_M_X64)
#define MIRTH_AMD64
#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)
#define MIRTH_I386
#elif defined(__aarch64__) || defined(_M_ARM64)
#define MIRTH_ARM64
#else
#error "Architecture not supported."
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <float.h>

extern void* malloc(size_t);
extern void* calloc(size_t, size_t);
extern void* realloc(void*, size_t);
extern void* memset(void*, int, size_t);
extern void* memcpy(void*, const void*, size_t);
extern int memcmp(const void*, const void*, size_t);
extern int strcmp(const char*, const char*);
extern size_t strlen(const char*);
extern void free(void*);
extern int read(int, void*, size_t);
extern int write(int, const char*, size_t);
extern int close(int);
extern int open(const char*, int, ...);
extern void exit(int);
extern int sprintf (char * s, const char * format, ...);

typedef uint16_t TAG;
#define REFS_FLAG 	 0x8000
#define TUP_FLAG 	 0x4000
#define TUP_LEN_MASK 0x3FFF
#define TUP_LEN_MAX  0x3FFF

#define TAG_INT 1
#define TAG_PTR 1
#define TAG_STR (2 | REFS_FLAG)
#define TAG_FNPTR 3
#define TAG_F32 4
#define TAG_F64 5
#define TAG_TUP_NIL TUP_FLAG
#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)
#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (n))

typedef uint32_t REFS;
typedef uint64_t USIZE;
typedef void (*FNPTR)(void);

typedef union DATA {
	USIZE usize;
	uint64_t u64;
	uint32_t u32;
	uint16_t u16;
	uint8_t u8;
	int64_t i64;
	int32_t i32;
	int16_t i16;
	int8_t i8;
	float f32;
	double f64;
	void* ptr;
	FNPTR fnptr;
	REFS* refs;
	struct TUP* tup;
	struct STR* str;
} DATA;

typedef struct VAL {
	DATA data;
	TAG tag;
} VAL;

#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))

#define VREFS(v)  (*(v).data.refs)
#define VVAL(v)   (v)
#define VINT(v)   ((v).data.i64)
#define VI64(v)   ((v).data.i64)
#define VI32(v)   ((v).data.i32)
#define VI16(v)   ((v).data.i16)
#define VI8(v)    ((v).data.i8)
#define VU64(v)   ((v).data.u64)
#define VU32(v)   ((v).data.u32)
#define VU16(v)   ((v).data.u16)
#define VU8(v)    ((v).data.u8)
#define VBOOL(v)  ((_Bool)((v).data.u64))
#define VF32(v)   ((v).data.f32)
#define VF64(v)   ((v).data.f64)
#define VPTR(v)   ((v).data.ptr)
#define VFNPTR(v) ((v).data.fnptr)
#define VSTR(v)   ((v).data.str)
#define VTUP(v)   ((v).data.tup)
#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))

#define HAS_REFS(v) ((v).tag & REFS_FLAG)
#define IS_VAL(v)   (1)
#define IS_INT(v)   ((v).tag == TAG_INT)
#define IS_I64(v)   ((v).tag == TAG_INT)
#define IS_U64(v)   ((v).tag == TAG_INT)
#define IS_BOOL(v)  ((v).tag == TAG_INT)
#define IS_F32(v)   ((v).tag == TAG_F32)
#define IS_F64(v)   ((v).tag == TAG_F64)
#define IS_PTR(v)   ((v).tag == TAG_PTR)
#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)
#define IS_STR(v)   ((v).tag == TAG_STR)
#define IS_TUP(v)   ((v).tag & TUP_FLAG)
#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))

#define MKVAL(x)   (x)
#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI32(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI16(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI8(x)    ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKU32(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKU16(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKU8(x)    ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKBOOL(x)  ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKF32(x)   ((VAL){.tag=TAG_F32, .data={.f32=(x)}})
#define MKF64(x)   ((VAL){.tag=TAG_F64, .data={.f64=(x)}})
#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})
#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})
#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})
#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})
#define MKNIL_C	         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}
#define MKNIL      ((VAL)MKNIL_C)

#define STRLIT(v,x,n) \
	do { \
		static STR* mval = 0; \
		if (!mval) mval = str_make(x,n); \
		incref(MKSTR(mval)); \
		v = mval; \
	} while(0)

typedef uint16_t TUPLEN;
typedef struct TUP {
	REFS refs;
	TUPLEN cap;
	TUPLEN size;
	VAL cells[];
} TUP;

typedef struct STR {
	REFS refs;
	USIZE cap;
	USIZE size;
	char data[];
} STR;

#define STACK_MAX 0x80000
static USIZE stack_counter = STACK_MAX;
static VAL stack [STACK_MAX] = {0};
static USIZE rstack_counter = STACK_MAX;
static VAL rstack [STACK_MAX] = {0};

static int global_argc;
static char** global_argv;

static void push_value(VAL v);
static void trace_stack(void);
static void trace_rstack(void);

#if MIRTH_DEBUG
	typedef struct LOC {
		FNPTR fnptr;
		const char* word;
		const char* path;
		USIZE line, col;
		const char* atom;
	} LOC;
	static USIZE fstack_counter = 0;
	static LOC fstack [STACK_MAX] = {
		{
			.fnptr=(void(*)(void))0,
			.word="<word>",
			.path="<path>",
			.line=0, .col=0,
			.atom="<atom>"
		},
	};

	#define WORD_ENTER(_f,_w,_p,_l,_c) \
		do { \
			fstack[fstack_counter].fnptr = (_f); \
			fstack[fstack_counter].word = (_w); \
			fstack[fstack_counter].path = (_p); \
			fstack[fstack_counter].line = (_l); \
			fstack[fstack_counter].col = (_c); \
			fstack[fstack_counter].atom = ""; \
			fstack_counter++; \
		} while(0)

	#define WORD_ATOM(_l,_c,_n) \
		do { \
			if (fstack_counter > 0) { \
				fstack[fstack_counter-1].line = (_l); \
				fstack[fstack_counter-1].col = (_c); \
				fstack[fstack_counter-1].atom = (_n); \
			} \
		} while(0)

	#define WORD_EXIT(_f) \
		do { \
			if ((fstack_counter == 0) || (fstack[fstack_counter-1].fnptr != (_f))) { \
				TRACE("mismatched WORD_EXIT, expected " #_f "\n"); \
				exit(1); \
			} \
			fstack_counter--; \
		} while(0)
	#define PRIM_ENTER(_f,_w) WORD_ENTER(_f,_w,__FILE__,__LINE__,1)
	#define PRIM_EXIT(_f) WORD_EXIT(_f)
#else
	#define PRIM_ENTER(_f,_w)
	#define PRIM_EXIT(_f)
#endif

#define TRACE(x) write(2,x,strlen(x))
#define _STR(x) #x
#define STR(x) _STR(x)

#define EXPECT(test,msg) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			trace_stack(); \
			trace_rstack(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT1(test,msg,v1) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			trace_stack(); \
			trace_rstack(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT2(test,msg,v1,v2) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			push_value(v2); \
			trace_stack(); \
			trace_rstack(); \
			exit(1); \
		} \
	} while(0)

#define ASSERT(test) \
	EXPECT(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")")
#define ASSERT1(test,v) \
	EXPECT1(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v)
#define ASSERT2(test,v1,v2) \
	EXPECT2(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v1, v2)

#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)
#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)
static void free_value(VAL v) {
	ASSERT(HAS_REFS(v));
	ASSERT(VREFS(v) == 0);
	ASSERT1(IS_TUP(v)||IS_STR(v), v);
	if (IS_TUP(v)) {
		TUP* tup = VTUP(v);
		ASSERT(tup);
		for (TUPLEN i = 0; i < tup->size; i++) {
			decref(tup->cells[i]);
		}
		free(tup);
	} else if (IS_STR(v)) {
		STR* str = VSTR(v);
		ASSERT(str);
		free(str);
	}
}

static void tup_decref_outer(TUP* tup, size_t n) {
	if (tup->refs == 1) {
		for (size_t i = n; i < tup->size; i++) {
			decref(tup->cells[i]);
		}
		free(tup);
	} else {
		for (size_t i = 0; i < n; i++) {
			incref(tup->cells[i]);
		}
		if (!--tup->refs) free_value(MKTUP(tup,n));
	}
}

static void value_uncons(VAL val, VAL* tail, VAL* head) {
	if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		ASSERT1((len > 0) && tup, val);
		VAL tailval = MKTUP(tup, len-1);
		VAL headval = tup->cells[len-1];
		if (len == 1) {
			incref(headval);
			decref(val);
			tailval = MKNIL;
		} else {
			if (tup->refs == 1) {
				for (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }
				memset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));
				tup->size = len-1;
			} else {
				incref(headval);
			}
			if (len == 2) {
				VAL ptval = tup->cells[0];
				if (!IS_TUP(ptval)) {
					incref(ptval);
					decref(tailval);
					tailval = ptval;
				}
			}
		}
		*tail = tailval;
		*head = headval;
	} else {
		*tail = MKNIL;
		*head = val;
	}
}

static uint64_t value_u64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VU64(v);
}

static int64_t value_i64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VI64(v);
}

static float value_f32 (VAL v) {
	ASSERT1(IS_F32(v), v);
	return VF32(v);
}

static double value_f64 (VAL v) {
	ASSERT1(IS_F64(v), v);
	return VF64(v);
}

static void* value_ptr (VAL v) {
	ASSERT1(IS_PTR(v),v);
	return VPTR(v);
}

static FNPTR value_fnptr (VAL v) {
	ASSERT1(IS_FNPTR(v),v);
	return VFNPTR(v);
}

static STR* value_str (VAL v) {
	ASSERT1(IS_STR(v),v);
	return VSTR(v);
}

#define pop_u8() ((uint8_t)pop_u64())
#define pop_u16() ((uint16_t)pop_u64())
#define pop_u32() ((uint32_t)pop_u64())
#define pop_u64() (value_u64(pop_value()))
#define pop_i8() ((int8_t)pop_i64())
#define pop_i16() ((int16_t)pop_i64())
#define pop_i32() ((int32_t)pop_i64())
#define pop_i64() (value_i64(pop_value()))
#define pop_usize() (pop_u64())
#define pop_f32() (value_f32(pop_value()))
#define pop_f64() (value_f64(pop_value()))
#define pop_bool() ((bool)pop_u64())
#define pop_str() (value_str(pop_value()))
#define pop_ptr() (value_ptr(pop_value()))
#define pop_fnptr() (value_fnptr(pop_value()))

#define push_u64(v) push_value(MKU64(v))
#define push_i64(v) push_value(MKI64(v))
#define push_usize(v) push_u64((uint64_t)(v))
#define push_bool(b) push_u64((uint64_t)((bool)(b)))
#define push_u8(b) push_u64((uint64_t)(b))
#define push_u16(b) push_u64((uint64_t)(b))
#define push_u32(b) push_u64((uint64_t)(b))
#define push_i8(b) push_i64((int64_t)(b))
#define push_i16(b) push_i64((int64_t)(b))
#define push_i32(b) push_i64((int64_t)(b))
#define push_f32(f) push_value(MKF32(f))
#define push_f64(f) push_value(MKF64(f))
#define push_str(p) push_value(MKSTR(p))
#define push_ptr(p) push_value(MKPTR(p))
#define push_fnptr(p) push_value(MKFNPTR(p))

static void push_value(VAL x) {
	ASSERT(stack_counter > 0);
	stack[--stack_counter] = x;
}

static VAL top_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter];
}

static VAL pop_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter++];
}

static void push_resource(VAL x) {
	ASSERT(rstack_counter > 0);
	rstack[--rstack_counter] = x;
}

static VAL top_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter];
}

static VAL pop_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter++];
}

// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.
static TUP* tup_new (TUPLEN cap_hint) {
	if (cap_hint < 3) cap_hint = 3;
	if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
	TUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
	ASSERT(new_tup);
	new_tup->refs = 1;
	new_tup->cap = cap_hint;
	return new_tup;
}

// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.
// Consume old_tup and copy its elements over to the new tuple.
static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {
	ASSERT(old_tup);
	if (cap_hint < old_tup->size) cap_hint = old_tup->size;
	if (old_tup->refs == 1) {
		if (cap_hint < 3) cap_hint = 3;
		if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
		TUPLEN old_cap = old_tup->cap;
		TUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
		ASSERT(new_tup);
		if (old_cap < cap_hint) {
			memset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));
		}
		new_tup->cap = cap_hint;
		return new_tup;
	} else {
		TUP* new_tup = tup_new(cap_hint);
		for (TUPLEN i = 0; i < old_tup->size; i++) {
			VAL v = old_tup->cells[i];
			new_tup->cells[i] = v;
			incref(v);
		}
		new_tup->size = old_tup->size;
		old_tup->refs--;
		return new_tup;
	}
}

static VAL tup_replace (VAL tup, TUPLEN i, VAL v) {
	ASSERT(IS_TUP(tup));
	TUPLEN n = VTUPLEN(tup);
	ASSERT(i < n);
	if (VTUP(tup)->refs > 1) {
		TUP* newtup = tup_new(n);
		newtup->size = n;
		memcpy(newtup->cells, VTUP(tup)->cells, n*sizeof(VAL));
		for (TUPLEN j=0; j<n; j++) incref(newtup->cells[j]);
		decref(tup);
		tup = MKTUP(newtup, n);
	}
	VAL u = VTUP(tup)->cells[i];
	VTUP(tup)->cells[i] = v;
	decref(u);
	return tup;
}

static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {
	if (IS_TUP(tail) && HAS_REFS(tail)) {
		TUPLEN tail_len = VTUPLEN(tail);
		TUP *tail_tup = VTUP(tail);
		ASSERT1(tail_tup, tail);
		ASSERT1(tail_len <= tail_tup->size, tail);
		if (tail_len < tail_tup->size) {
			ASSERT1(tail_tup->refs >= 1, tail);
			if (tail_tup->refs == 1) {
				decref(tail_tup->cells[tail_len]);
				tail_tup->cells[tail_len] = head;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				VAL *cmp = &tail_tup->cells[tail_len];
				if (VALEQ(*cmp, head)) {
					decref(head);
					return MKTUP(tail_tup, tail_len+1);
				} else {
					if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
					TUP* new_tup = tup_new(cap_hint);
					for (TUPLEN i = 0; i < tail_len; i++) {
						VAL v = tail_tup->cells[i];
						new_tup->cells[i] = v;
						incref(v);
					}
					new_tup->cells[tail_len] = head;
					new_tup->size = tail_len+1;
					tail_tup->refs--;
					return MKTUP(new_tup, tail_len+1);
				}
			}
		} else {
			ASSERT1(tail_len < TUP_LEN_MAX, tail);
			ASSERT1(tail_len <= tail_tup->cap, tail);
			if (tail_len < tail_tup->cap) {
				tail_tup->cells[tail_len] = head;
				tail_tup->size = tail_len+1;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
				TUP* new_tup = tup_resize(tail_tup, cap_hint);
				ASSERT(tail_len < new_tup->cap);
				new_tup->size = tail_len+1;
				new_tup->cells[tail_len] = head;
				return MKTUP(new_tup, tail_len+1);
			}
		}
	} else if (IS_TUP(tail)) { // cons onto nil
		ASSERT(IS_NIL(tail));
		if (IS_TUP(head)) {
			TUP* tup = tup_new(cap_hint);
			tup->size = 1;
			tup->cells[0] = head;
			return MKTUP(tup,1);
		} else { // non-tup value pretends to be unary tuple
			return head;
		}
	} else { // cons onto non-tup value pretending to be unary tuple
		TUP* tup = tup_new(cap_hint);
		tup->size = 2;
		tup->cells[0] = tail;
		tup->cells[1] = head;
		return MKTUP(tup,2);
	}
}
static VAL mkcons(VAL tail, VAL head) {
	VAL v = mkcons_hint(tail,head,3);
	return v;
}

static VAL lpop(VAL* stk) {
	VAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);
	*stk=lcar; return lcdr;
}
static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }
#define LPOP(v) push_value(lpop(&(v)))
#define LPUSH(v) lpush(&(v),pop_value())
#define LPOPR(v) push_resource(lpop(&(v)))
#define LPUSHR(v) lpush(&(v),pop_resource())

static STR* str_alloc (USIZE cap) {
	ASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));
	EXPECT(str, "failed to allocate string");
	str->refs = 1;
	str->cap = cap;
	return str;
}

static STR* str_make (const char* data, USIZE size) {
	ASSERT(data);
	ASSERT(size <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = str_alloc(size);
	str->size = size;
	memcpy(str->data, data, (size_t)size);
	return str;
}
#define mkstr(x,n) MKSTR(str_make((x), (n)))

static STR* str_cat (STR* s1, STR* s2) {
	EXPECT(s1 && s2, "invalid strings in prim-str-cat");
	USIZE m = s1->cap;
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	if ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {
		ASSERT(n2 <= SIZE_MAX);
		memcpy(s1->data + n1, s2->data, (size_t)n2);
		s1->size += n2;
		ASSERT(s1->size + 4 <= s1->cap);
		decref(MKSTR(s2));
		return s1;
	} else {
		USIZE m2 = n1 + n2 + 4;
		if ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;
		STR* str = str_alloc(m2);
		str->size = n1+n2;
		ASSERT(n1 <= SIZE_MAX);
		ASSERT(n2 <= SIZE_MAX);
		memcpy(str->data, s1->data, (size_t)n1);
		memcpy(str->data+n1, s2->data, (size_t)n2);
		decref(MKSTR(s1));
		decref(MKSTR(s2));
		return str;
	}
}

static USIZE get_data_tag(VAL v) {
	if (IS_TUP(v)) {
		ASSERT(VTUPLEN(v) > 0);
		return VU64(VTUP(v)->cells[0]);
	} else {
		return VU64(v);
	}
}

static USIZE get_top_data_tag(void) {
	return get_data_tag(top_value());
}

static USIZE get_top_resource_data_tag(void) {
	return get_data_tag(top_resource());
}

static int str_cmp(STR* s1, STR* s2) {
	ASSERT(s1 && s2);
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	USIZE n = (n1 < n2 ? n1 : n2);
	ASSERT(n < SIZE_MAX);
	int r = memcmp(s1->data, s2->data, (size_t)n);
	decref(MKSTR(s1));
	decref(MKSTR(s2));
	if (r) return r;
	if (n1 < n2) return -1;
	if (n1 > n2) return 1;
	return 0;
}

static void run_value(VAL v) {
	if (IS_TUP(v)) {
		VAL h = VTUP(v)->cells[0];
		ASSERT(IS_FNPTR(h));
		push_value(v);
		VFNPTR(h)();
	} else {
		ASSERT(IS_FNPTR(v));
		VFNPTR(v)();
	}
}

static int64_t i64_add (int64_t a, int64_t b) {
	EXPECT(((b >= 0) && (a <= INT64_MAX - b))
		|| ((b <  0) && (a >= INT64_MIN - b)),
		"overflow during integer addition");
	return a + b;
}

static int64_t i64_sub (int64_t a, int64_t b) {
	EXPECT(((b >= 0) && (a >= INT64_MIN + b))
		|| ((b <  0) && (a <= INT64_MAX + b)),
		"overflow during integer subtraction");
	return a - b;
}

static int64_t i64_mul (int64_t a, int64_t b) {
	EXPECT((a == 0) || (b == 0) ||
		((a > 0) && (b > 0) && (a <= INT64_MAX/b)) ||
		((a > 0) && (b < 0) && (a <= INT64_MIN/b)) ||
		((a < 0) && (b > 0) && (a >= INT64_MIN/b)) ||
		((a < 0) && (b < 0) && (a >= INT64_MAX/b)),
		"overflow during integer multiplication"
	);
	return a * b;
}

static int64_t i64_div (int64_t a, int64_t b) {
	EXPECT(b != 0, "divide by zero");
	EXPECT(!((b == -1) && (a == INT64_MIN)), "overflow during integer division");
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) q--;
	return q;
}

static int64_t i64_mod (int64_t a, int64_t b) {
	EXPECT(b != 0, "divide by zero");
	EXPECT(!((b == -1) && (a == INT64_MIN)), "overflow during integer division");
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) r += b;
	return r;
}

static uint64_t u64_shl (uint64_t a, uint64_t b) {
	if (b >= 64) return 0;
	return (a << b);
}

static uint64_t u64_shr (uint64_t a, uint64_t b) {
	if (b >= 64) return 0;
	return (a >> b);
}

static STR* f32_show (float d) {
 	char result[DBL_DIG+32] = {0};
	int len = sprintf(result, "%.*g", DBL_DIG, d);
	return str_make(result, len);
}

static STR* f64_show (double d) {
 	char result[DBL_DIG+32] = {0};
	int len = sprintf(result, "%.*g", DBL_DIG, d);
	return str_make(result, len);
}

void int_repr(int64_t y, char** out_ptr, size_t *out_size) {
	static char c[32] = {0};
	memset(c, 0, 32);
	char* p = c+30;
	size_t n = 0;
	uint64_t x;
	if (y < 0) {
		if (y == INT64_MIN) {
			x = 1+(uint64_t)INT64_MAX;
		} else {
			x = (uint64_t)-y;
		}
	} else {
		x = (uint64_t)y;
	}
	do {
		*--p = '0' + (x % 10);
		x /= 10;
		n++;
	} while (x);
	if (y < 0) {
		*--p = '-';
		n++;
	}
	*out_ptr = p;
	*out_size = n;
}

void int_trace_(int64_t y, int fd) {
	char* p; size_t n;
	int_repr(y, &p, &n);
	write(fd, p, n);
}

STR* i64_show (int64_t x) {
	bool cache = (0 <= x) && (x <= 255);
	static STR* scache[256] = {0};
	if (cache && scache[x]) {
		STR* s = scache[x];
		incref(MKSTR(s));
		return s;
	} else {
		char* p; size_t n;
		int_repr(x,&p,&n);
		STR* s = str_make(p,n);
		if (cache) {
			scache[x] = s;
			incref(MKSTR(s));
		}
		return s;
	}
}

void str_trace_(STR* str, int fd) {
	ASSERT(str->size <= SIZE_MAX);
	write(fd, "\"", 1);
	USIZE i0 = 0;
	char xb[4]={'\\','x'};
	USIZE i;
	for (i = 0; i < str->size; i++) {
		const char* c = NULL; size_t n=0;
		uint8_t v=str->data[i];
		switch(v) {
			case '\n': c="\\n"; n=2; break;
			case '\r': c="\\r"; n=2; break;
			case '\t': c="\\t"; n=2; break;
			case '\\': c="\\\\"; n=2; break;
			case '\"': c="\\\""; n=2; break;
			default:
				if (!((' ' <= v) && (v < 0x7F))) {
					xb[2] = '0' + (v&15) + ('A'-'9'-1)*((v&15) > 9);
					xb[3] = '0' + (v/16) + ('A'-'9'-1)*((v/16) > 9);
					c=xb; n=4;
				}
		}
		if ((n > 0) && (i0 < i)) {
			write(fd, str->data+i0, (size_t)(i-i0));
			i0=i+1;
		}
		write(fd, c, n);
	}
	if (i0 < i) write(fd, str->data+i0, (size_t)(i-i0));
	write(fd, "\"", 1);
}

void value_trace_(VAL val, int fd) {
	if (IS_INT(val)) {
		int_trace_(VINT(val), fd);
	} else if (IS_STR(val)) {
		str_trace_(VSTR(val), fd);
	} else if (IS_FNPTR(val)) {
		write(fd, "<fnptr>", 7);
	} else if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		if (VTUPLEN(val) == 0) {
			write(fd, "[]", 2);
		} else {
			write(fd, "[ ", 2);
			for(TUPLEN i = 0; i < len; i++) {
				if (i > 0) write(fd, " ", 1);
				value_trace_(tup->cells[i], fd);
			}
			write(fd, " ]", 2);
		}
	} else {
		TRACE("value cannot be traced");
		exit(1);
	}
}

static void trace_stack (void) {
	TRACE("??");
	for (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {
		TRACE(" ");
		value_trace_(stack[i], 2);
	}
	TRACE("\n");
}

static void trace_rstack (void) {
	#if MIRTH_DEBUG
		TRACE("call stack:\n");
		for (USIZE i = fstack_counter; i --> 1;) {
			TRACE("    ");
			if (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {
				TRACE(fstack[i-1].atom);
				TRACE(" -> ");
			}
			TRACE(fstack[i].word);
			TRACE(" at ");
			TRACE(fstack[i-1].path);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].line, 2);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].col, 2);
			TRACE("\n");
		}
	#endif
}

static void do_panic(void) {
	if ((stack_counter > 0) && IS_STR(top_value())) {
		VAL v = pop_value();
		size_t n = (VSTR(v)->size < 2048) ? (size_t)(VSTR(v)->size) : 2048;
		write(2, VSTR(v)->data, n);
		TRACE("\n");
	} else {
		TRACE("panic!\n");
	}
	trace_stack();
	trace_rstack();
	exit(1);
}

#if defined(MIRTH_WINDOWS)
#define RUNNING_OS 1
#elif defined(MIRTH_LINUX)
#define RUNNING_OS 2
#elif defined(MIRTH_MACOS)
#define RUNNING_OS 3
#else
#define RUNNING_OS 0
#endif

#if defined(MIRTH_I386)
#define RUNNING_ARCH 1
#elif defined(MIRTH_AMD64)
#define RUNNING_ARCH 2
#elif defined(MIRTH_ARM64)
#define RUNNING_ARCH 3
#else
#define RUNNING_ARCH 0
#endif

static void* ptr_alloc (uint64_t n) {
	EXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), "invalid size in prim-ptr-alloc");
	void* p = malloc((size_t)n);
	EXPECT(p, "failed to allocate in prim-ptr-alloc");
	return p;
}

static void* ptr_realloc (void* p, uint64_t n) {
	EXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), "invalid size in prim-ptr-realloc");
	void* p2 = realloc(p, n);
	EXPECT(p2, "failed to reallocate in prim-ptr-realloc");
	return p2;
}

static void ptr_copy (void* src, uint64_t len, void* dst) {
	if (len > 0) {
		EXPECT(len <= SIZE_MAX, "invalid size in prim-ptr-copy");
		EXPECT(src && dst, "invalid pointer in prim-ptr-copy");
		memcpy(dst, src, (size_t)len);
	}
}

static void ptr_fill (uint8_t val, uint64_t len, void* dst) {
	if (len > 0) {
		EXPECT(len <= SIZE_MAX, "invalid size in prim-ptr-fill");
		EXPECT(dst, "invalid pointer in prim-ptr-fill");
		memset(dst, (int)val, (size_t)len);
	}
}

static void* str_base (STR* s) {
	EXPECT(s && (s->refs > 1), "invalid string for prim-str-base");
	s->refs--;
	return s->data;
}

static uint64_t str_size (STR* s) {
	EXPECT(s, "invalid string for prim-str-size");
	uint64_t n = s->size;
	decref(MKSTR(s));
	return n;
}

static VAL mut_get (VAL mut) {
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL v = *(VAL*)VPTR(mut);
	EXPECT(v.tag, "tried to read uninitialized value");
	incref(v);
	return v;
}

static void mut_set (VAL newval, VAL mut) {
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL oldval = *(VAL*)VPTR(mut);
	*(VAL*)VPTR(mut) = newval;
	if (oldval.tag) {
		decref(oldval);
	}
}

static bool mut_is_set (VAL mut) {
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL val = *(VAL*)VPTR(mut);
	return (val.tag != 0);
}

/* GENERATED C99 */

static VAL lbl_emitZ_debugZ_info = MKNIL_C;
static VAL lbl_inputZ_file = MKNIL_C;
static VAL lbl_outputZ_file = MKNIL_C;
static VAL lbl_entryZ_point = MKNIL_C;
static VAL lbl_packages = MKNIL_C;
static VAL lbl_packageZ_searchZ_paths = MKNIL_C;
static VAL lbl_outputZ_path = MKNIL_C;
static VAL lbl_name = MKNIL_C;
static VAL lbl_flagZ_type = MKNIL_C;
static VAL lbl_argZ_doc = MKNIL_C;
static VAL lbl_doc = MKNIL_C;
static VAL lbl_group = MKNIL_C;
static VAL lbl_options = MKNIL_C;
static VAL lbl_parser = MKNIL_C;
static VAL lbl_argsZ_doc = MKNIL_C;
static VAL lbl_x1 = MKNIL_C;
static VAL lbl_x2 = MKNIL_C;
static VAL lbl_x3 = MKNIL_C;
static VAL lbl_x4 = MKNIL_C;
static VAL lbl_escapeZ_hex = MKNIL_C;
static VAL lbl_sizze = MKNIL_C;
static VAL lbl_base = MKNIL_C;
static VAL lbl_oldZ_sizze = MKNIL_C;
static VAL lbl_fileZ_descriptor = MKNIL_C;
static VAL lbl_owned = MKNIL_C;
static VAL lbl_ZPlusfile = MKNIL_C;
static VAL lbl_ZPlusbuffer = MKNIL_C;
static VAL lbl_length = MKNIL_C;
static VAL lbl_offset = MKNIL_C;
static VAL lbl_ZPlusworld = MKNIL_C;
static VAL lbl_numZ_tests = MKNIL_C;
static VAL lbl_numZ_failed = MKNIL_C;
static VAL lbl_testZ_name = MKNIL_C;
static VAL lbl_testZ_failed = MKNIL_C;
static VAL lbl_ZPlustests = MKNIL_C;
static VAL lbl_colZ_offset = MKNIL_C;
static VAL lbl_argumentZ_parser = MKNIL_C;
static VAL lbl_state = MKNIL_C;
static VAL lbl_docZ_length = MKNIL_C;
static VAL lbl_argv = MKNIL_C;
static VAL lbl_programZ_name = MKNIL_C;
static VAL lbl_argvZ_info = MKNIL_C;
static VAL lbl_parsingZAsk = MKNIL_C;
static VAL lbl_option = MKNIL_C;
static VAL lbl_optionZ_option = MKNIL_C;
static VAL lbl_arg = MKNIL_C;
static VAL lbl_arguments = MKNIL_C;
static VAL lbl_positionalZ_index = MKNIL_C;
static VAL lbl_longestZ_argZ_length = MKNIL_C;
static VAL lbl_error = MKNIL_C;
static VAL lbl_namespace = MKNIL_C;
static VAL lbl_arity = MKNIL_C;
static VAL lbl_std = MKNIL_C;
static VAL lbl_prim = MKNIL_C;
static VAL lbl_bool = MKNIL_C;
static VAL lbl_true = MKNIL_C;
static VAL lbl_false = MKNIL_C;
static VAL lbl_u64 = MKNIL_C;
static VAL lbl_mkZ_u64 = MKNIL_C;
static VAL lbl_u32 = MKNIL_C;
static VAL lbl_mkZ_u32 = MKNIL_C;
static VAL lbl_u16 = MKNIL_C;
static VAL lbl_mkZ_u16 = MKNIL_C;
static VAL lbl_u8 = MKNIL_C;
static VAL lbl_mkZ_u8 = MKNIL_C;
static VAL lbl_i64 = MKNIL_C;
static VAL lbl_mkZ_i64 = MKNIL_C;
static VAL lbl_i32 = MKNIL_C;
static VAL lbl_mkZ_i32 = MKNIL_C;
static VAL lbl_i16 = MKNIL_C;
static VAL lbl_mkZ_i16 = MKNIL_C;
static VAL lbl_i8 = MKNIL_C;
static VAL lbl_mkZ_i8 = MKNIL_C;
static VAL lbl_cchar = MKNIL_C;
static VAL lbl_mkZ_cchar = MKNIL_C;
static VAL lbl_cichar = MKNIL_C;
static VAL lbl_mkZ_cichar = MKNIL_C;
static VAL lbl_cshort = MKNIL_C;
static VAL lbl_mkZ_cshort = MKNIL_C;
static VAL lbl_cint = MKNIL_C;
static VAL lbl_mkZ_cint = MKNIL_C;
static VAL lbl_clong = MKNIL_C;
static VAL lbl_mkZ_clong = MKNIL_C;
static VAL lbl_clonglong = MKNIL_C;
static VAL lbl_mkZ_clonglong = MKNIL_C;
static VAL lbl_cisizze = MKNIL_C;
static VAL lbl_mkZ_cisizze = MKNIL_C;
static VAL lbl_cintptr = MKNIL_C;
static VAL lbl_mkZ_cintptr = MKNIL_C;
static VAL lbl_cuchar = MKNIL_C;
static VAL lbl_mkZ_cuchar = MKNIL_C;
static VAL lbl_cushort = MKNIL_C;
static VAL lbl_mkZ_cushort = MKNIL_C;
static VAL lbl_cuint = MKNIL_C;
static VAL lbl_mkZ_cuint = MKNIL_C;
static VAL lbl_culong = MKNIL_C;
static VAL lbl_mkZ_culong = MKNIL_C;
static VAL lbl_culonglong = MKNIL_C;
static VAL lbl_mkZ_culonglong = MKNIL_C;
static VAL lbl_cusizze = MKNIL_C;
static VAL lbl_mkZ_cusizze = MKNIL_C;
static VAL lbl_cuintptr = MKNIL_C;
static VAL lbl_mkZ_cuintptr = MKNIL_C;
static VAL lbl_cptr = MKNIL_C;
static VAL lbl_mkZ_cptr = MKNIL_C;
static VAL lbl_cconst = MKNIL_C;
static VAL lbl_mkZ_cconst = MKNIL_C;
static VAL lbl_crestrict = MKNIL_C;
static VAL lbl_mkZ_crestrict = MKNIL_C;
static VAL lbl_cvolatile = MKNIL_C;
static VAL lbl_mkZ_cvolatile = MKNIL_C;
static VAL lbl_cvoid = MKNIL_C;
static VAL lbl_mkZ_cvoid = MKNIL_C;
static VAL lbl_numZ_errors = MKNIL_C;
static VAL lbl_numZ_warnings = MKNIL_C;
static VAL lbl_preferZ_inlineZ_defs = MKNIL_C;
static VAL lbl_builtin = MKNIL_C;
static VAL lbl_mirthZ_baseZ_path = MKNIL_C;
static VAL lbl_ZPlusdiagnostics = MKNIL_C;
static VAL lbl_ZPluspropstack = MKNIL_C;
static VAL lbl_errorZ_token = MKNIL_C;
static VAL lbl_severity = MKNIL_C;
static VAL lbl_message = MKNIL_C;
static VAL lbl_location = MKNIL_C;
static VAL lbl_old = MKNIL_C;
static VAL lbl_new = MKNIL_C;
static VAL lbl_label = MKNIL_C;
static VAL lbl_module = MKNIL_C;
static VAL lbl_row = MKNIL_C;
static VAL lbl_col = MKNIL_C;
static VAL lbl_a = MKNIL_C;
static VAL lbl_b = MKNIL_C;
static VAL lbl_c = MKNIL_C;
static VAL lbl_rr = MKNIL_C;
static VAL lbl_sr = MKNIL_C;
static VAL lbl_xs = MKNIL_C;
static VAL lbl_ys = MKNIL_C;
static VAL lbl_ta = MKNIL_C;
static VAL lbl_tb = MKNIL_C;
static VAL lbl_tc = MKNIL_C;
static VAL lbl_trr = MKNIL_C;
static VAL lbl_tsr = MKNIL_C;
static VAL lbl_txs = MKNIL_C;
static VAL lbl_tys = MKNIL_C;
static VAL lbl_qname = MKNIL_C;
static VAL lbl_type = MKNIL_C;
static VAL lbl_token = MKNIL_C;
static VAL lbl_data = MKNIL_C;
static VAL lbl_field = MKNIL_C;
static VAL lbl_labels = MKNIL_C;
static VAL lbl_withses = MKNIL_C;
static VAL lbl_conses = MKNIL_C;
static VAL lbl_parts = MKNIL_C;
static VAL lbl_x = MKNIL_C;
static VAL lbl_baseZAsk = MKNIL_C;
static VAL lbl_dom = MKNIL_C;
static VAL lbl_cod = MKNIL_C;
static VAL lbl_ctype = MKNIL_C;
static VAL lbl_tags = MKNIL_C;
static VAL lbl_params = MKNIL_C;
static VAL lbl_tag = MKNIL_C;
static VAL lbl_inputs = MKNIL_C;
static VAL lbl_value = MKNIL_C;
static VAL lbl_underlying = MKNIL_C;
static VAL lbl_tagname = MKNIL_C;
static VAL lbl_dataname = MKNIL_C;
static VAL lbl_head = MKNIL_C;
static VAL lbl_body = MKNIL_C;
static VAL lbl_sigZAsk = MKNIL_C;
static VAL lbl_pattern = MKNIL_C;
static VAL lbl_ctx = MKNIL_C;
static VAL lbl_subst = MKNIL_C;
static VAL lbl_op = MKNIL_C;
static VAL lbl_saved = MKNIL_C;
static VAL lbl_home = MKNIL_C;
static VAL lbl_cases = MKNIL_C;
static VAL lbl_tokenZ_start = MKNIL_C;
static VAL lbl_tokenZ_end = MKNIL_C;
static VAL lbl_outerZ_ctx = MKNIL_C;
static VAL lbl_innerZ_ctx = MKNIL_C;
static VAL lbl_mid = MKNIL_C;
static VAL lbl_atoms = MKNIL_C;
static VAL lbl_args = MKNIL_C;
static VAL lbl_lexerZ_module = MKNIL_C;
static VAL lbl_ZPlusinput = MKNIL_C;
static VAL lbl_lexerZ_row = MKNIL_C;
static VAL lbl_lexerZ_col = MKNIL_C;
static VAL lbl_lexerZ_stack = MKNIL_C;
static VAL lbl_lexerZ_lastZ_token = MKNIL_C;
static VAL lbl_allowZ_typeZ_holes = MKNIL_C;
static VAL lbl_allowZ_implicitZ_typeZ_vars = MKNIL_C;
static VAL lbl_ignoreZ_lastZ_name = MKNIL_C;
static VAL lbl_candidates = MKNIL_C;
static VAL lbl_rejected = MKNIL_C;
static VAL lbl_sort = MKNIL_C;
static VAL lbl_reportZ_ambiguousZ_asZ_warning = MKNIL_C;
static VAL lbl_accum = MKNIL_C;
static VAL lbl_arrow = MKNIL_C;
static VAL lbl_word = MKNIL_C;
static VAL lbl_ZPlusab = MKNIL_C;
static VAL lbl_ZPluspat = MKNIL_C;
static VAL lbl_tok = MKNIL_C;
static VAL lbl_header = MKNIL_C;
static VAL lbl_valueZAsk = MKNIL_C;
static VAL lbl_syn = MKNIL_C;
static VAL lbl_dat = MKNIL_C;
static VAL lbl_ftag = MKNIL_C;
static VAL lbl_untag = MKNIL_C;
static VAL lbl_lbl = MKNIL_C;
static VAL lbl_lblz_get = MKNIL_C;
static VAL lbl_lblz_set = MKNIL_C;
static VAL lbl_lblz_lens = MKNIL_C;
static VAL lbl_sx = MKNIL_C;
static VAL lbl_sy = MKNIL_C;
static VAL lbl_lblty = MKNIL_C;
static VAL lbl_datty = MKNIL_C;
static VAL lbl_f = MKNIL_C;
static VAL lbl_hasZ_paren = MKNIL_C;
static VAL lbl_target = MKNIL_C;
static VAL lbl_alias = MKNIL_C;
static VAL lbl_code = MKNIL_C;
static VAL lbl_symbol = MKNIL_C;
static VAL lbl_sig = MKNIL_C;
static VAL lbl_extblock = MKNIL_C;
static VAL lbl_external = MKNIL_C;
static VAL lbl_contents = MKNIL_C;
static VAL lbl_tbl = MKNIL_C;
static VAL lbl_va = MKNIL_C;
static VAL lbl_vx = MKNIL_C;
static VAL lbl_valueZ_type = MKNIL_C;
static VAL lbl_indexZ_type = MKNIL_C;
static VAL lbl_fld = MKNIL_C;
static VAL lbl_checklist = MKNIL_C;
static VAL lbl_w = MKNIL_C;
static VAL lbl_key = MKNIL_C;
static VAL lbl_wordZTick = MKNIL_C;
static VAL lbl_spword = MKNIL_C;
static VAL lbl_spkey = MKNIL_C;
static VAL lbl_spmap = MKNIL_C;
static VAL lbl_depth = MKNIL_C;
static VAL lbl_freshZ_counter = MKNIL_C;
static VAL lbl_ZPlusneeds = MKNIL_C;
static VAL lbl_ZPlusmirth = MKNIL_C;
static VAL lbl_ZPlusoutput = MKNIL_C;
static VAL lbl_ZPlusfield = MKNIL_C;
static VAL lbl_tup = MKNIL_C;
static VAL lbl_i = MKNIL_C;
static VAL lbl_fieldty = MKNIL_C;
static VAL lbl_ZPlustuplevar = MKNIL_C;
static VAL lbl_fieldrepr = MKNIL_C;
static VAL lbl_fieldval = MKNIL_C;
static VAL lbl_tupleval = MKNIL_C;
static VAL lbl_ext = MKNIL_C;
static VAL lbl_cty = MKNIL_C;
static VAL lbl_outty = MKNIL_C;
static VAL lbl_argZ_index = MKNIL_C;
static VAL lbl_repr = MKNIL_C;
static VAL lbl_source = MKNIL_C;
static VAL lbl_localZ_name = MKNIL_C;
static VAL lbl_localZ_repr = MKNIL_C;
static VAL lbl_cname = MKNIL_C;
static VAL lbl_inZ_params = MKNIL_C;
static VAL lbl_returnZ_param = MKNIL_C;
static VAL lbl_outZ_params = MKNIL_C;
static VAL lbl_mustZ_flushZAsk = MKNIL_C;
static VAL lbl_api = MKNIL_C;
static VAL lbl_poppedZ_inputs = MKNIL_C;
static VAL lbl_sep = MKNIL_C;
static VAL lbl_ZPlusstr = MKNIL_C;
static VAL lbl_avoidZ_hexdigit = MKNIL_C;
static VAL lbl_localZ_resourceZ_repr = MKNIL_C;
static VAL lbl_localZ_resourceZ_name = MKNIL_C;
static VAL lbl_ZPlusstack = MKNIL_C;
static VAL lbl_ZPluscore = MKNIL_C;
static VAL lbl_prefix = MKNIL_C;
static VAL lbl_ZPlusarg1 = MKNIL_C;
static VAL lbl_arg1Z_type = MKNIL_C;
static VAL lbl_operator = MKNIL_C;
static VAL lbl_ZPlusarg2 = MKNIL_C;
static VAL lbl_arg2Z_type = MKNIL_C;
static VAL lbl_suffix = MKNIL_C;
static VAL lbl_argsZ_swapped = MKNIL_C;
static VAL lbl_outZ_type = MKNIL_C;
static VAL lbl_ZPlusarg = MKNIL_C;
static VAL lbl_argZ_type = MKNIL_C;
static VAL lbl_ZPlusb = MKNIL_C;
static VAL lbl_ZPlusa = MKNIL_C;
static VAL lbl_ZPlusdipped = MKNIL_C;
static VAL lbl_ZPluscond = MKNIL_C;
static VAL lbl_ZPlusclosure = MKNIL_C;
static VAL lbl_ZPluscons = MKNIL_C;
static VAL lbl_ZPlustail = MKNIL_C;
static VAL lbl_ZPlushead = MKNIL_C;
static VAL lbl_ZPlusdst = MKNIL_C;
static VAL lbl_ZPluslen = MKNIL_C;
static VAL lbl_ZPlussrc = MKNIL_C;
static VAL lbl_ZPlusval = MKNIL_C;
static VAL lbl_ZPlusfnptr = MKNIL_C;
static VAL lbl_ZPlustup = MKNIL_C;
static VAL lbl_var = MKNIL_C;
static VAL lbl_ZPlusscrutinee = MKNIL_C;
static VAL lbl_ZPlusindex = MKNIL_C;
static VAL lbl_stack = MKNIL_C;
static VAL lbl_ZPlusset = MKNIL_C;
static VAL mtw_std_either_Either_2_Left (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* Left */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_std_either_Either_2_Left (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_either_Either_2_Right (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* Right */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_std_either_Either_2_Right (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_buffer_ZPlusBuffer_ZPlusBuffer (int64_t x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +Buffer */);
	v0->cells[2] = x2;
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_std_buffer_ZPlusBuffer_ZPlusBuffer (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_sizze, v0);
	lpush(&lbl_base, v1);
}
static VAL mtw_std_list_List_1_Cons (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(1LL /* Cons */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_std_list_List_1_Cons (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_std_maybe_Maybe_1_Some (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* Some */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_std_maybe_Maybe_1_Some (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_input_ZPlusInputOpenState_ZPlusInputOpenState (int64_t x1, int64_t x2, VAL x3, VAL x4) {
	TUP* v0 = tup_new(5);
	v0->size = 5;
	v0->cells[0] = MKI64(0LL /* +InputOpenState */);
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 5));
	return v1;
}
static void mtp_std_input_ZPlusInputOpenState_ZPlusInputOpenState (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	lpush(&lbl_length, v0);
	lpush(&lbl_offset, v1);
	lpush(&lbl_ZPlusfile, v2);
	lpush(&lbl_ZPlusbuffer, v3);
}
static VAL mtw_std_input_ZPlusInput_ZPlusInputOpen (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* +InputOpen */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_std_input_ZPlusInput_ZPlusInputOpen (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_input_ZPlusInput_ZPlusInputDone (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* +InputDone */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_std_input_ZPlusInput_ZPlusInputDone (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_output_ZPlusOutput_ZPlusOutput (int64_t x1, VAL x2, VAL x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* +Output */);
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 4));
	return v1;
}
static void mtp_std_output_ZPlusOutput_ZPlusOutput (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_sizze, v0);
	lpush(&lbl_ZPlusfile, v1);
	lpush(&lbl_ZPlusbuffer, v2);
}
static VAL mtw_std_file_ZPlusFile_ZPlusFile (int64_t x1, int64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +File */);
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_std_file_ZPlusFile_ZPlusFile (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_fileZ_descriptor, v0);
	lpush(&lbl_owned, v1);
}
static VAL mtw_std_file_ZPlusFileZAsk_ZPlusFileOk (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* +FileOk */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_std_file_ZPlusFileZAsk_ZPlusFileOk (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_file_ZPlusFileZAsk_ZPlusFileErr (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* +FileErr */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_std_file_ZPlusFileZAsk_ZPlusFileErr (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtp_std_terminal_Sgr_FGColor (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtp_std_terminal_Sgr_BGColor (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static int64_t mtp_std_terminal_SGRColor_Numbered (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static void mtp_std_terminal_SGRColor_RGB (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	push_value(v0);
	push_value(v1);
	push_value(v2);
}
static VAL mtw_argZ_parser_state_ArgvInfo_ArgvInfo (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* ArgvInfo */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_argZ_parser_state_CurrentArg_CurrentArg (int64_t x1, VAL x2, VAL x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* CurrentArg */);
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static VAL mtw_argZ_parser_state_State_1_State (VAL x1, VAL x2, VAL x3, int64_t x4, int64_t x5, VAL x6) {
	TUP* v0 = tup_new(7);
	v0->size = 7;
	v0->cells[0] = MKI64(0LL /* State */);
	v0->cells[6] = x6;
	v0->cells[5] = MKI64(x5);
	v0->cells[4] = MKI64(x4);
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 7);
	return v1;
}
static VAL mtw_argZ_parser_types_ArgumentParser_1_ArgumentParser (VAL x1, VAL x2, VAL x3, VAL x4) {
	TUP* v0 = tup_new(5);
	v0->size = 5;
	v0->cells[0] = MKI64(0LL /* ArgumentParser */);
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 5);
	return v1;
}
static VAL mtw_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +ArgumentParser */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_argumentZ_parser, v0);
	lpush(&lbl_state, v1);
}
static VAL mtw_argZ_parser_types_ArgpOptionType_Short (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* Short */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_argZ_parser_types_ArgpOptionType_Short (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_argZ_parser_types_ArgpOptionType_LongOnly (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* LongOnly */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_argZ_parser_types_ArgpOptionType_LongOnly (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_argZ_parser_types_ArgpOption_ArgpOption (VAL x1, VAL x2, VAL x3, VAL x4, VAL x5) {
	TUP* v0 = tup_new(6);
	v0->size = 6;
	v0->cells[0] = MKI64(0LL /* ArgpOption */);
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 6);
	return v1;
}
static VAL mtw_argZ_parser_types_ArgumentParsingError_MissingArg (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* MissingArg */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_argZ_parser_types_ArgumentParsingError_MissingArg (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_lazzy_Lazzy_1_LazzyReady (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* LazyReady */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_std_lazzy_Lazzy_1_LazzyReady (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_std_lazzy_Lazzy_1_LazzyDelay (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(1LL /* LazyDelay */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_std_lazzy_Lazzy_1_LazzyDelay (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_tycon_Tycon_TYCONz_DATA (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* TYCON_DATA */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_tycon_Tycon_TYCONz_DATA (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_tycon_Tycon_TYCONz_TABLE (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* TYCON_TABLE */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_tycon_Tycon_TYCONz_TABLE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_tycon_Tycon_TYCONz_PRIM (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* TYCON_PRIM */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_tycon_Tycon_TYCONz_PRIM (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_data_DataPartial_DataPartial (uint64_t x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* DataPartial */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_data_DataPartial_DataPartial (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_data, v0);
	lpush(&lbl_field, v1);
}
static VAL mtw_mirth_match_Match_Match (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v0 = tup_new(8);
	v0->size = 8;
	v0->cells[0] = MKI64(0LL /* Match */);
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 8);
	return v1;
}
static void mtp_mirth_match_Match_Match (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	VAL v6 = VTUP(x1)->cells[7];
	tup_decref_outer(VTUP(x1),8);
	lpush(&lbl_home, v0);
	lpush(&lbl_token, v1);
	lpush(&lbl_body, v2);
	lpush(&lbl_ctx, v3);
	lpush(&lbl_dom, v4);
	lpush(&lbl_cod, v5);
	lpush(&lbl_cases, v6);
}
static VAL mtw_mirth_match_ZPlusMatch_ZPlusMatch (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v0 = tup_new(8);
	v0->size = 8;
	v0->cells[0] = MKI64(0LL /* +Match */);
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 8));
	return v1;
}
static void mtp_mirth_match_ZPlusMatch_ZPlusMatch (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	VAL v6 = VTUP(x1)->cells[7];
	tup_decref_outer(VTUP(x1),8);
	lpush(&lbl_home, v0);
	lpush(&lbl_token, v1);
	lpush(&lbl_body, v2);
	lpush(&lbl_ctx, v3);
	lpush(&lbl_dom, v4);
	lpush(&lbl_cod, v5);
	lpush(&lbl_cases, v6);
}
static VAL mtw_mirth_match_Case_CASE (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* CASE */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_mirth_match_Pattern_Pattern (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7, VAL x8, VAL x9) {
	TUP* v0 = tup_new(10);
	v0->size = 10;
	v0->cells[0] = MKI64(0LL /* Pattern */);
	v0->cells[9] = x9;
	v0->cells[8] = x8;
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 10);
	return v1;
}
static VAL mtw_mirth_match_PatternAtom_PATATOM (uint64_t x1, VAL x2, VAL x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v0 = tup_new(8);
	v0->size = 8;
	v0->cells[0] = MKI64(0LL /* PATATOM */);
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 8);
	return v1;
}
static VAL mtw_mirth_match_PatternOp_PatOpTag (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* PatOpTag */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_match_PatternOp_PatOpTag (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_external_ExternalBlockPart_EBPCode (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* EBPCode */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_external_ExternalBlockPart_EBPCode (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_external_ExternalBlockPart_EBPDef (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* EBPDef */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_external_ExternalBlockPart_EBPDef (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpPrim (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* OpPrim */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_arrow_Op_OpPrim (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_arrow_Op_OpWord (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* OpWord */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpWord (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpExternal (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* OpExternal */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpExternal (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpBuffer (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* OpBuffer */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpBuffer (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpVariable (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(5LL /* OpVariable */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpVariable (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpField (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(6LL /* OpField */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpField (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpInt (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(7LL /* OpInt */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_arrow_Op_OpInt (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_arrow_Op_OpF64 (double x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(8LL /* OpF64 */);
	v0->cells[1] = MKF64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static double mtp_mirth_arrow_Op_OpF64 (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VF64(v0);
}
static VAL mtw_mirth_arrow_Op_OpStr (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(9LL /* OpStr */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_arrow_Op_OpStr (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_arrow_Op_OpTag (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(10LL /* OpTag */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpTag (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpMatch (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(11LL /* OpMatch */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_arrow_Op_OpMatch (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_arrow_Op_OpLambda (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(12LL /* OpLambda */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_arrow_Op_OpLambda (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_arrow_Op_OpVar (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(13LL /* OpVar */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpVar (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpBlockPush (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(14LL /* OpBlockPush */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpBlockPush (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpBlockRun (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(15LL /* OpBlockRun */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpBlockRun (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpCoerce (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(16LL /* OpCoerce */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_arrow_Op_OpCoerce (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_arrow_Op_OpLabelPush (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(17LL /* OpLabelPush */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPush (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpLabelPop (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(18LL /* OpLabelPop */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPop (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpLabelPushR (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(19LL /* OpLabelPushR */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPushR (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpLabelPopR (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(20LL /* OpLabelPopR */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpLabelPopR (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpDataGetTag (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(21LL /* OpDataGetTag */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Op_OpDataGetTag (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Op_OpDataGetLabel (uint64_t x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(22LL /* OpDataGetLabel */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_arrow_Op_OpDataGetLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_arrow_Op_OpDataSetLabel (uint64_t x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(23LL /* OpDataSetLabel */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_arrow_Op_OpDataSetLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_arrow_Home_HomeMain (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* HomeMain */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Home_HomeMain (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Home_HomeWord (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* HomeWord */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_arrow_Home_HomeWord (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_arrow_Arrow_Arrow (VAL x1, uint64_t x2, uint64_t x3, VAL x4, VAL x5, VAL x6, VAL x7) {
	TUP* v0 = tup_new(8);
	v0->size = 8;
	v0->cells[0] = MKI64(0LL /* Arrow */);
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 8);
	return v1;
}
static VAL mtw_mirth_arrow_Atom_Atom (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, VAL x6, VAL x7, VAL x8) {
	TUP* v0 = tup_new(9);
	v0->size = 9;
	v0->cells[0] = MKI64(0LL /* Atom */);
	v0->cells[8] = x8;
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 9);
	return v1;
}
static void mtp_mirth_arrow_Atom_Atom (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	VAL v6 = VTUP(x1)->cells[7];
	VAL v7 = VTUP(x1)->cells[8];
	tup_decref_outer(VTUP(x1),9);
	lpush(&lbl_home, v0);
	lpush(&lbl_token, v1);
	lpush(&lbl_ctx, v2);
	lpush(&lbl_op, v3);
	lpush(&lbl_args, v4);
	lpush(&lbl_dom, v5);
	lpush(&lbl_cod, v6);
	lpush(&lbl_subst, v7);
}
static VAL mtw_mirth_arrow_Lambda_Lambda (uint64_t x1, VAL x2, VAL x3, VAL x4, VAL x5) {
	TUP* v0 = tup_new(6);
	v0->size = 6;
	v0->cells[0] = MKI64(0LL /* Lambda */);
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 6);
	return v1;
}
static VAL mtw_mirth_type_Type_TPrim (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* TPrim */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_type_Type_TPrim (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_type_Type_TMeta (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* TMeta */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_Type_TMeta (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_Type_THole (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* THole */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_Type_THole (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_Type_TVar (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(5LL /* TVar */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_Type_TVar (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_Type_TTable (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(6LL /* TTable */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_Type_TTable (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_Type_TData (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(7LL /* TData */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_Type_TData (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_Type_TDataPartial (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(8LL /* TDataPartial */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_Type_TDataPartial (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_Type_TTensor (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(9LL /* TTensor */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_Type_TTensor (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_Type_TMorphism (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(10LL /* TMorphism */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_Type_TMorphism (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_Type_TApp (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(11LL /* TApp */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_Type_TApp (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_Type_TMut (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(12LL /* TMut */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_Type_TMut (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_Type_TValue (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(13LL /* TValue */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_Type_TValue (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_Value_VALUEz_INT (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* VALUE_INT */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_type_Value_VALUEz_INT (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_type_Value_VALUEz_F64 (double x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* VALUE_F64 */);
	v0->cells[1] = MKF64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static double mtp_mirth_type_Value_VALUEz_F64 (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VF64(v0);
}
static VAL mtw_mirth_type_Value_VALUEz_STR (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* VALUE_STR */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_Value_VALUEz_STR (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_Value_VALUEz_BLOCK (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* VALUE_BLOCK */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_Value_VALUEz_BLOCK (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_StackType_STVar (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* STVar */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_StackType_STVar (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_StackType_STMeta (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* STMeta */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_type_StackType_STMeta (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_type_StackType_STCons (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(5LL /* STCons */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_StackType_STCons (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_StackType_STConsLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(6LL /* STConsLabel */);
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_type_StackType_STConsLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	push_value(v0);
	push_value(v1);
	push_value(v2);
}
static VAL mtw_mirth_type_StackType_STWith (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(7LL /* STWith */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_StackType_STWith (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_StackType_STWithLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(8LL /* STWithLabel */);
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_type_StackType_STWithLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	push_value(v0);
	push_value(v1);
	push_value(v2);
}
static VAL mtw_mirth_type_ArrowType_ARROWz_TYPE (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* ARROW_TYPE */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_ArrowType_ARROWz_TYPE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_Subst_SUBSTz_CON (VAL x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(1LL /* SUBST_CON */);
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_type_Subst_SUBSTz_CON (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	push_value(v0);
	push_value(v1);
	push_value(v2);
}
static VAL mtw_mirth_type_StackTypePart_STPCons (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* STPCons */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_StackTypePart_STPCons (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_StackTypePart_STPConsLabel (VAL x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(1LL /* STPConsLabel */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_StackTypePart_STPConsLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_StackTypePart_STPWith (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* STPWith */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_StackTypePart_STPWith (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_StackTypePart_STPWithLabel (VAL x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(3LL /* STPWithLabel */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_StackTypePart_STPWithLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_CType_IntLike (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* IntLike */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CType_IntLike (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CType_F32Like (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* F32Like */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CType_F32Like (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CType_F64Like (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* F64Like */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CType_F64Like (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CType_PtrLike (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* PtrLike */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CType_PtrLike (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CType_FnPtr (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* FnPtr */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CType_FnPtr (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPCons (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* CTSPCons */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CTypeStackPart_CTSPCons (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPConsLabel (VAL x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(1LL /* CTSPConsLabel */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_CTypeStackPart_CTSPConsLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPWith (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* CTSPWith */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_type_CTypeStackPart_CTSPWith (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_type_CTypeStackPart_CTSPWithLabel (VAL x1, uint64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(3LL /* CTSPWithLabel */);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_type_CTypeStackPart_CTSPWithLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_type_CTypeStack_CTypeStack (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* CTypeStack */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_mirth_type_CTypeArrow_CTypeArrow (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* CTypeArrow */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_mirth_token_TokenValue_TokenLParen (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(6LL /* TokenLParen */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLParen (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenRParen (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(7LL /* TokenRParen */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRParen (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLSquare (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(8LL /* TokenLSquare */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLSquare (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenRSquare (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(9LL /* TokenRSquare */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRSquare (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLCurly (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(10LL /* TokenLCurly */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLCurly (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenRCurly (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(11LL /* TokenRCurly */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRCurly (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLColon (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(12LL /* TokenLColon */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLColon (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenRColon (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(13LL /* TokenRColon */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenRColon (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenInt (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(14LL /* TokenInt */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_token_TokenValue_TokenInt (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenF64 (double x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(15LL /* TokenF64 */);
	v0->cells[1] = MKF64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static double mtp_mirth_token_TokenValue_TokenF64 (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VF64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenStr (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(16LL /* TokenStr */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_token_TokenValue_TokenStr (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_token_TokenValue_TokenName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(17LL /* TokenName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenName (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenDName (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(18LL /* TokenDName */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_token_TokenValue_TokenDName (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPop (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(19LL /* TokenLabelPop */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPop (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPush (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(20LL /* TokenLabelPush */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPush (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPopR (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(21LL /* TokenLabelPopR */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPopR (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelPushR (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(22LL /* TokenLabelPushR */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelPushR (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelGet (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(23LL /* TokenLabelGet */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelGet (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_token_TokenValue_TokenLabelSet (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(24LL /* TokenLabelSet */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_token_TokenValue_TokenLabelSet (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_location_Location_Location (uint64_t x1, int64_t x2, int64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* Location */);
	v0->cells[3] = MKI64(x3);
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_location_Location_Location (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_module, v0);
	lpush(&lbl_row, v1);
	lpush(&lbl_col, v2);
}
static VAL mtw_mirth_mirth_Builtin_Builtin (uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t x7, uint64_t x8, uint64_t x9, uint64_t x10, uint64_t x11, uint64_t x12, uint64_t x13, uint64_t x14, uint64_t x15, uint64_t x16, uint64_t x17, uint64_t x18, uint64_t x19, uint64_t x20, uint64_t x21, uint64_t x22, uint64_t x23, uint64_t x24, uint64_t x25, uint64_t x26, uint64_t x27, uint64_t x28, uint64_t x29, uint64_t x30, uint64_t x31, uint64_t x32, uint64_t x33, uint64_t x34, uint64_t x35, uint64_t x36, uint64_t x37, uint64_t x38, uint64_t x39, uint64_t x40, uint64_t x41, uint64_t x42, uint64_t x43, uint64_t x44, uint64_t x45, uint64_t x46, uint64_t x47, uint64_t x48, uint64_t x49, uint64_t x50, uint64_t x51, uint64_t x52, uint64_t x53, uint64_t x54, uint64_t x55, uint64_t x56, uint64_t x57, uint64_t x58, uint64_t x59, uint64_t x60, uint64_t x61) {
	TUP* v0 = tup_new(62);
	v0->size = 62;
	v0->cells[0] = MKI64(0LL /* Builtin */);
	v0->cells[61] = MKU64(x61);
	v0->cells[60] = MKU64(x60);
	v0->cells[59] = MKU64(x59);
	v0->cells[58] = MKU64(x58);
	v0->cells[57] = MKU64(x57);
	v0->cells[56] = MKU64(x56);
	v0->cells[55] = MKU64(x55);
	v0->cells[54] = MKU64(x54);
	v0->cells[53] = MKU64(x53);
	v0->cells[52] = MKU64(x52);
	v0->cells[51] = MKU64(x51);
	v0->cells[50] = MKU64(x50);
	v0->cells[49] = MKU64(x49);
	v0->cells[48] = MKU64(x48);
	v0->cells[47] = MKU64(x47);
	v0->cells[46] = MKU64(x46);
	v0->cells[45] = MKU64(x45);
	v0->cells[44] = MKU64(x44);
	v0->cells[43] = MKU64(x43);
	v0->cells[42] = MKU64(x42);
	v0->cells[41] = MKU64(x41);
	v0->cells[40] = MKU64(x40);
	v0->cells[39] = MKU64(x39);
	v0->cells[38] = MKU64(x38);
	v0->cells[37] = MKU64(x37);
	v0->cells[36] = MKU64(x36);
	v0->cells[35] = MKU64(x35);
	v0->cells[34] = MKU64(x34);
	v0->cells[33] = MKU64(x33);
	v0->cells[32] = MKU64(x32);
	v0->cells[31] = MKU64(x31);
	v0->cells[30] = MKU64(x30);
	v0->cells[29] = MKU64(x29);
	v0->cells[28] = MKU64(x28);
	v0->cells[27] = MKU64(x27);
	v0->cells[26] = MKU64(x26);
	v0->cells[25] = MKU64(x25);
	v0->cells[24] = MKU64(x24);
	v0->cells[23] = MKU64(x23);
	v0->cells[22] = MKU64(x22);
	v0->cells[21] = MKU64(x21);
	v0->cells[20] = MKU64(x20);
	v0->cells[19] = MKU64(x19);
	v0->cells[18] = MKU64(x18);
	v0->cells[17] = MKU64(x17);
	v0->cells[16] = MKU64(x16);
	v0->cells[15] = MKU64(x15);
	v0->cells[14] = MKU64(x14);
	v0->cells[13] = MKU64(x13);
	v0->cells[12] = MKU64(x12);
	v0->cells[11] = MKU64(x11);
	v0->cells[10] = MKU64(x10);
	v0->cells[9] = MKU64(x9);
	v0->cells[8] = MKU64(x8);
	v0->cells[7] = MKU64(x7);
	v0->cells[6] = MKU64(x6);
	v0->cells[5] = MKU64(x5);
	v0->cells[4] = MKU64(x4);
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 62);
	return v1;
}
static VAL mtw_mirth_mirth_ZPlusMirth_ZPlusMirth (int64_t x1, int64_t x2, int64_t x3, VAL x4, VAL x5, VAL x6, VAL x7, VAL x8, VAL x9) {
	TUP* v0 = tup_new(10);
	v0->size = 10;
	v0->cells[0] = MKI64(0LL /* +Mirth */);
	v0->cells[9] = x9;
	v0->cells[8] = x8;
	v0->cells[7] = x7;
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = MKI64(x3);
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 10));
	return v1;
}
static void mtp_mirth_mirth_ZPlusMirth_ZPlusMirth (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	VAL v6 = VTUP(x1)->cells[7];
	VAL v7 = VTUP(x1)->cells[8];
	VAL v8 = VTUP(x1)->cells[9];
	tup_decref_outer(VTUP(x1),10);
	lpush(&lbl_numZ_errors, v0);
	lpush(&lbl_numZ_warnings, v1);
	lpush(&lbl_preferZ_inlineZ_defs, v2);
	lpush(&lbl_builtin, v3);
	lpush(&lbl_errorZ_token, v4);
	lpush(&lbl_mirthZ_baseZ_path, v5);
	lpush(&lbl_packageZ_searchZ_paths, v6);
	lpush(&lbl_ZPlusdiagnostics, v7);
	lpush(&lbl_ZPluspropstack, v8);
}
static VAL mtw_mirth_mirth_Diagnostic_Diagnostic (int64_t x1, VAL x2, VAL x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* Diagnostic */);
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_mirth_Diagnostic_Diagnostic (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_severity, v0);
	lpush(&lbl_location, v1);
	lpush(&lbl_message, v2);
}
static VAL mtw_mirth_mirth_Prop_1_Prop (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* Prop */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_mirth_mirth_PropState_1_PSReady (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* PSReady */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_mirth_PropState_1_PSReady (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_mirth_PropState_1_PSDelay (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(1LL /* PSDelay */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_mirth_PropState_1_PSDelay (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_mirth_PropLabel_DataQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* DataQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_DataParams (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* DataParams */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_DataCType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* DataCType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_TagType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* TagType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_TableQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* TableQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_TypeDefQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(5LL /* TypeDefQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_TypeDefTarget (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(6LL /* TypeDefTarget */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_WordQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(7LL /* WordQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_WordType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(8LL /* WordType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_WordParams (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(9LL /* WordParams */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_WordArrow (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(10LL /* WordArrow */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_BlockArrow (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(11LL /* BlockArrow */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_AliasQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(12LL /* AliasQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_AliasTarget (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(13LL /* AliasTarget */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_ExternalQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(14LL /* ExternalQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_ExternalType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(15LL /* ExternalType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_ExternalCType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(16LL /* ExternalCType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_VariableType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(17LL /* VariableType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_FieldQName (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(18LL /* FieldQName */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_FieldValueType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(19LL /* FieldValueType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_mirth_PropLabel_FieldIndexType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(20LL /* FieldIndexType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtw_mirth_def_Def_DefAlias (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* DefAlias */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefAlias (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefModule (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* DefModule */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefModule (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefPackage (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* DefPackage */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefPackage (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefData (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* DefData */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefData (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefTable (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* DefTable */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefTable (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefType (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(5LL /* DefType */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefType (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefTag (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(6LL /* DefTag */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefTag (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefPrim (int64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(7LL /* DefPrim */);
	v0->cells[1] = MKI64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static int64_t mtp_mirth_def_Def_DefPrim (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VI64(v0);
}
static VAL mtw_mirth_def_Def_DefWord (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(8LL /* DefWord */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefWord (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefBuffer (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(9LL /* DefBuffer */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefBuffer (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefVariable (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(10LL /* DefVariable */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefVariable (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefExternal (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(11LL /* DefExternal */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefExternal (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_def_Def_DefField (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(12LL /* DefField */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_def_Def_DefField (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* NAMESPACE_PACKAGE */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_MODULE (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* NAMESPACE_MODULE */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_name_Namespace_NAMESPACEz_MODULE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_TYCON (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* NAMESPACE_TYCON */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_name_Namespace_NAMESPACEz_TYCON (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_name_Namespace_NAMESPACEz_WORD (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* NAMESPACE_WORD */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_name_Namespace_NAMESPACEz_WORD (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_name_QName_MKQNAME (VAL x1, uint64_t x2, int64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* MKQNAME */);
	v0->cells[3] = MKI64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_name_QName_MKQNAME (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_namespace, v0);
	lpush(&lbl_name, v1);
	lpush(&lbl_arity, v2);
}
static VAL mtw_mirth_name_DName_DName (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* DName */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_name_DName_DName (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	push_value(v0);
	push_value(v1);
}
static VAL mtw_mirth_lexer_ZPlusLexer_ZPlusLexer (uint64_t x1, int64_t x2, int64_t x3, VAL x4, uint64_t x5, VAL x6) {
	TUP* v0 = tup_new(7);
	v0->size = 7;
	v0->cells[0] = MKI64(0LL /* +Lexer */);
	v0->cells[6] = x6;
	v0->cells[5] = MKU64(x5);
	v0->cells[4] = x4;
	v0->cells[3] = MKI64(x3);
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = MKU64(x1);
	VAL v1 = (MKTUP(v0, 7));
	return v1;
}
static void mtp_mirth_lexer_ZPlusLexer_ZPlusLexer (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	lpush(&lbl_lexerZ_module, v0);
	lpush(&lbl_lexerZ_row, v1);
	lpush(&lbl_lexerZ_col, v2);
	lpush(&lbl_lexerZ_stack, v3);
	lpush(&lbl_lexerZ_lastZ_token, v4);
	lpush(&lbl_ZPlusinput, v5);
}
static VAL mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab (VAL x1, uint64_t x2, int64_t x3, int64_t x4) {
	TUP* v0 = tup_new(5);
	v0->size = 5;
	v0->cells[0] = MKI64(0LL /* +TypeElab */);
	v0->cells[4] = MKI64(x4);
	v0->cells[3] = MKI64(x3);
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 5));
	return v1;
}
static void mtp_mirth_elab_ZPlusTypeElab_ZPlusTypeElab (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	lpush(&lbl_ctx, v0);
	lpush(&lbl_token, v1);
	lpush(&lbl_allowZ_typeZ_holes, v2);
	lpush(&lbl_allowZ_implicitZ_typeZ_vars, v3);
}
static VAL mtw_mirth_elab_ZPlusResolveDef_ZPlusResolveDef (VAL x1, uint64_t x2, VAL x3, VAL x4, int64_t x5, int64_t x6) {
	TUP* v0 = tup_new(7);
	v0->size = 7;
	v0->cells[0] = MKI64(0LL /* +ResolveDef */);
	v0->cells[6] = MKI64(x6);
	v0->cells[5] = MKI64(x5);
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 7));
	return v1;
}
static void mtp_mirth_elab_ZPlusResolveDef_ZPlusResolveDef (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	lpush(&lbl_sort, v0);
	lpush(&lbl_token, v1);
	lpush(&lbl_candidates, v2);
	lpush(&lbl_rejected, v3);
	lpush(&lbl_ignoreZ_lastZ_name, v4);
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, v5);
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* RD_WRONG_SORT */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* RD_WRONG_ARITY */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* RD_NOT_IMPORTED */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(4LL /* RD_WRONG_QUALIFIER */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(5LL /* RD_WRONG_CONSTRUCTOR */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(6LL /* RD_METHOD_NOT_AVAILABLE */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(7LL /* RD_METHOD_WRONG_TYPE */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_OpSig_OPSIGz_PUSH (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* OPSIG_PUSH */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_OpSig_OPSIGz_PUSH (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_OpSig_OPSIGz_APPLY (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* OPSIG_APPLY */);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static VAL mtp_mirth_elab_OpSig_OPSIGz_APPLY (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_elab_SyntaxData_SyntaxData (uint64_t x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* SyntaxData */);
	v0->cells[2] = x2;
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_elab_SyntaxData_SyntaxData (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_header, v0);
	lpush(&lbl_tags, v1);
}
static VAL mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag (VAL x1, uint64_t x2, VAL x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* SyntaxDataTag */);
	v0->cells[3] = x3;
	v0->cells[2] = MKU64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static VAL mtw_mirth_elab_SyntaxDef_SyntaxDef (uint64_t x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* SyntaxDef */);
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = x2;
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_elab_SyntaxDef_SyntaxDef (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_head, v0);
	lpush(&lbl_sigZAsk, v1);
	lpush(&lbl_body, v2);
}
static VAL mtw_mirth_elab_ExternalDeclPart_EDPCode (uint64_t x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* EDPCode */);
	v0->cells[2] = x2;
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static void mtp_mirth_elab_ExternalDeclPart_EDPCode (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_token, v0);
	lpush(&lbl_code, v1);
}
static VAL mtw_mirth_elab_ExternalDeclPart_EDPDef (uint64_t x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(1LL /* EDPDef */);
	v0->cells[3] = MKU64(x3);
	v0->cells[2] = x2;
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_elab_ExternalDeclPart_EDPDef (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_head, v0);
	lpush(&lbl_symbol, v1);
	lpush(&lbl_sig, v2);
}
static VAL mtw_std_map_KVPair_2_KVPair (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* KVPair */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_mirth_specializzer_SPCheckItem_SPCHECKz_WORD (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* SPCHECK_WORD */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_specializzer_SPCheckItem_SPCHECKz_WORD (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* SPCHECK_BLOCK */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	TUP* v0 = tup_new(5);
	v0->size = 5;
	v0->cells[0] = MKI64(0LL /* +SPSYNTH */);
	v0->cells[4] = x3;
	v0->cells[3] = MKU64(x2);
	v0->cells[2] = x1;
	v0->cells[1] = x4;
	VAL v1 = (MKTUP(v0, 5));
	return v1;
}
static void mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	push_resource(v0);
	lpush(&lbl_spkey, v1);
	lpush(&lbl_spword, v2);
	lpush(&lbl_spmap, v3);
}
static VAL mtw_mirth_need_Need_NEEDz_WORD (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* NEED_WORD */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_need_Need_NEEDz_WORD (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_need_Need_NEEDz_BLOCK (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* NEED_BLOCK */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_need_Need_NEEDz_BLOCK (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_need_Need_NEEDz_TAGW (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(2LL /* NEED_TAGW */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_need_Need_NEEDz_TAGW (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_need_Need_NEEDz_TAGP (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* NEED_TAGP */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_need_Need_NEEDz_TAGP (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_need_ZPlusNeeds_ZPlusNeeds (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +Needs */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_need_ZPlusNeeds_ZPlusNeeds (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_stack, v0);
	lpush(&lbl_ZPlusset, v1);
}
static VAL mtw_mirth_c99_C99z_Options_C99z_Options (VAL x1, int64_t x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* C99_Options */);
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 3);
	return v1;
}
static VAL mtw_mirth_c99_ZPlusC99_ZPlusC99 (VAL x1, int64_t x2, int64_t x3, VAL x4, VAL x5, VAL x6) {
	TUP* v0 = tup_new(7);
	v0->size = 7;
	v0->cells[0] = MKI64(0LL /* +C99 */);
	v0->cells[6] = x6;
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = MKI64(x3);
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 7));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99_ZPlusC99 (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	lpush(&lbl_options, v0);
	lpush(&lbl_depth, v1);
	lpush(&lbl_freshZ_counter, v2);
	lpush(&lbl_ZPlusneeds, v3);
	lpush(&lbl_ZPlusoutput, v4);
	lpush(&lbl_ZPlusmirth, v5);
}
static VAL mtw_mirth_c99_C99APIArgSource_C99AASz_ValueLabel (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* C99AAS_ValueLabel */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel (uint64_t x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(3LL /* C99AAS_ResourceLabel */);
	v0->cells[1] = MKU64(x1);
	VAL v1 = MKTUP(v0, 2);
	return v1;
}
static uint64_t mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	tup_decref_outer(VTUP(x1),2);
	return VU64(v0);
}
static VAL mtw_mirth_c99_C99APIArg_C99APIArg (VAL x1, int64_t x2, VAL x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(0LL /* C99APIArg */);
	v0->cells[3] = x3;
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 4);
	return v1;
}
static void mtp_mirth_c99_C99APIArg_C99APIArg (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	tup_decref_outer(VTUP(x1),4);
	lpush(&lbl_source, v0);
	lpush(&lbl_repr, v1);
	lpush(&lbl_name, v2);
}
static VAL mtw_mirth_c99_C99API_C99API (VAL x1, VAL x2, VAL x3, VAL x4, VAL x5, int64_t x6) {
	TUP* v0 = tup_new(7);
	v0->size = 7;
	v0->cells[0] = MKI64(0LL /* C99API */);
	v0->cells[6] = MKI64(x6);
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 7);
	return v1;
}
static VAL mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local (int64_t x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +C99Local */);
	v0->cells[2] = x2;
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_localZ_repr, v0);
	lpush(&lbl_localZ_name, v1);
}
static VAL mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource (int64_t x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +C99LocalResource */);
	v0->cells[2] = x2;
	v0->cells[1] = MKI64(x1);
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_localZ_resourceZ_repr, v0);
	lpush(&lbl_localZ_resourceZ_name, v1);
}
static VAL mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(0LL /* +Left */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* +Right */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* +C99LocalSome */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome (VAL x1) {
	TUP* v0 = tup_new(2);
	v0->size = 2;
	v0->cells[0] = MKI64(1LL /* +C99LocalResourceSome */);
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 2));
	return v1;
}
static VAL mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	tup_decref_outer(VTUP(x1),2);
	return v0;
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(1LL /* +SCCons */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	VAL v1 = (VTUP(x1)->cells[2]);
	tup_decref_outer(VTUP(x1),3);
	push_resource(v0);
	push_resource(v1);
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(2LL /* +SCWith */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith (VAL x1) {
	VAL v0 = (VTUP(x1)->cells[1]);
	VAL v1 = (VTUP(x1)->cells[2]);
	tup_decref_outer(VTUP(x1),3);
	push_resource(v0);
	push_resource(v1);
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(3LL /* +SCConsLabel */);
	v0->cells[3] = x2;
	v0->cells[2] = x1;
	v0->cells[1] = MKU64(x3);
	VAL v1 = (MKTUP(v0, 4));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = (VTUP(x1)->cells[2]);
	VAL v2 = (VTUP(x1)->cells[3]);
	tup_decref_outer(VTUP(x1),4);
	push_value(v0);
	push_resource(v1);
	push_resource(v2);
}
static VAL mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel (VAL x1, VAL x2, uint64_t x3) {
	TUP* v0 = tup_new(4);
	v0->size = 4;
	v0->cells[0] = MKI64(4LL /* +SCWithLabel */);
	v0->cells[3] = x2;
	v0->cells[2] = x1;
	v0->cells[1] = MKU64(x3);
	VAL v1 = (MKTUP(v0, 4));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = (VTUP(x1)->cells[2]);
	VAL v2 = (VTUP(x1)->cells[3]);
	tup_decref_outer(VTUP(x1),4);
	push_value(v0);
	push_resource(v1);
	push_resource(v2);
}
static VAL mtw_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +C99BranchSplit */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_ZPluscore, v0);
	lpush(&lbl_ZPlusstack, v1);
}
static VAL mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch (VAL x1, VAL x2) {
	TUP* v0 = tup_new(3);
	v0->size = 3;
	v0->cells[0] = MKI64(0LL /* +C99Branch */);
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = (MKTUP(v0, 3));
	return v1;
}
static void mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	tup_decref_outer(VTUP(x1),3);
	lpush(&lbl_ZPluscore, v0);
	lpush(&lbl_ZPlusstack, v1);
}
static VAL mtw_mirth_c99_C99BinOp_C99BinOp (VAL x1, VAL x2, VAL x3, int64_t x4, int64_t x5, int64_t x6, VAL x7) {
	TUP* v0 = tup_new(8);
	v0->size = 8;
	v0->cells[0] = MKI64(0LL /* C99BinOp */);
	v0->cells[7] = x7;
	v0->cells[6] = MKI64(x6);
	v0->cells[5] = MKI64(x5);
	v0->cells[4] = MKI64(x4);
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 8);
	return v1;
}
static void mtp_mirth_c99_C99BinOp_C99BinOp (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	VAL v6 = VTUP(x1)->cells[7];
	tup_decref_outer(VTUP(x1),8);
	lpush(&lbl_prefix, v0);
	lpush(&lbl_operator, v1);
	lpush(&lbl_suffix, v2);
	lpush(&lbl_arg1Z_type, v3);
	lpush(&lbl_arg2Z_type, v4);
	lpush(&lbl_argsZ_swapped, v5);
	lpush(&lbl_outZ_type, v6);
}
static VAL mtw_mirth_c99_C99UnOp_C99UnOp (VAL x1, int64_t x2, VAL x3, VAL x4) {
	TUP* v0 = tup_new(5);
	v0->size = 5;
	v0->cells[0] = MKI64(0LL /* C99UnOp */);
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = MKI64(x2);
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 5);
	return v1;
}
static void mtp_mirth_c99_C99UnOp_C99UnOp (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	tup_decref_outer(VTUP(x1),5);
	lpush(&lbl_prefix, v0);
	lpush(&lbl_argZ_type, v1);
	lpush(&lbl_suffix, v2);
	lpush(&lbl_outZ_type, v3);
}
static VAL mtw_mirth_main_Arguments_Arguments (VAL x1, VAL x2, VAL x3, VAL x4, VAL x5, int64_t x6) {
	TUP* v0 = tup_new(7);
	v0->size = 7;
	v0->cells[0] = MKI64(0LL /* Arguments */);
	v0->cells[6] = MKI64(x6);
	v0->cells[5] = x5;
	v0->cells[4] = x4;
	v0->cells[3] = x3;
	v0->cells[2] = x2;
	v0->cells[1] = x1;
	VAL v1 = MKTUP(v0, 7);
	return v1;
}
static void mtp_mirth_main_Arguments_Arguments (VAL x1) {
	VAL v0 = VTUP(x1)->cells[1];
	VAL v1 = VTUP(x1)->cells[2];
	VAL v2 = VTUP(x1)->cells[3];
	VAL v3 = VTUP(x1)->cells[4];
	VAL v4 = VTUP(x1)->cells[5];
	VAL v5 = VTUP(x1)->cells[6];
	tup_decref_outer(VTUP(x1),7);
	lpush(&lbl_inputZ_file, v0);
	lpush(&lbl_outputZ_file, v1);
	lpush(&lbl_entryZ_point, v2);
	lpush(&lbl_packages, v3);
	lpush(&lbl_packageZ_searchZ_paths, v4);
	lpush(&lbl_emitZ_debugZ_info, v5);
}
static char mbuf_mirth_label_Label_NUM[8] = {0};
static char mbuf_mirth_var_Var_NUM[8] = {0};
static char mbuf_mirth_buffer_Buffer_NUM[8] = {0};
static char mbuf_mirth_word_Word_NUM[8] = {0};
static char mbuf_mirth_table_Table_NUM[8] = {0};
static char mbuf_mirth_table_Field_NUM[8] = {0};
static char mbuf_mirth_data_Data_NUM[8] = {0};
static char mbuf_mirth_data_Tag_NUM[8] = {0};
static char mbuf_mirth_external_External_NUM[8] = {0};
static char mbuf_mirth_external_ExternalBlock_NUM[8] = {0};
static char mbuf_mirth_variable_Variable_NUM[8] = {0};
static char mbuf_mirth_arrow_Block_NUM[8] = {0};
static char mbuf_mirth_typedef_TypeDef_NUM[8] = {0};
static char mbuf_mirth_type_MetaVar_NUM[8] = {0};
static char mbuf_mirth_token_Token_NUM[8] = {0};
static char mbuf_mirth_module_Module_NUM[8] = {0};
static char mbuf_mirth_alias_Alias_NUM[8] = {0};
static char mbuf_mirth_name_Name_NUM[8] = {0};
static char mbuf_mirth_name_HASHz_BUF[524288] = {0};
static char mbuf_mirth_package_Package_NUM[8] = {0};
size_t strlen (const char *);
static void mext_std_ctypes_CStr_numZ_bytes (void) {
	const char * X2 = (const char *)pop_ptr();
(void)pop_resource();
	size_t Y = strlen(X2);
	push_resource(MKI64(0));
	push_i64((int64_t)(Y));
}
int read (int, void*, size_t);
static void mext_std_posix_externalZ_posixZ_read (void) {
	size_t X3 = (size_t)pop_i64();
	void* X2 = (void*)pop_ptr();
	int X1 = (int)pop_i64();
	int Y = read(X1, X2, X3);
	push_i64((int64_t)(Y));
}
int write (int, const char *, size_t);
static void mext_std_posix_externalZ_posixZ_write (void) {
	size_t X3 = (size_t)pop_i64();
	const char * X2 = (const char *)pop_ptr();
	int X1 = (int)pop_i64();
	int Y = write(X1, X2, X3);
	push_i64((int64_t)(Y));
}
int close (int);
static void mext_std_posix_externalZ_posixZ_close (void) {
	int X1 = (int)pop_i64();
	int Y = close(X1);
	push_i64((int64_t)(Y));
}
void exit (int);
static void mext_std_posix_externalZ_posixZ_exit (void) {
	int X1 = (int)pop_i64();
	exit(X1);
}
int open_internal(const char* path, int flags, int mode) { return open(path, flags, mode); }
int open_internal (const char *, int, int);
static void mext_std_posix_internalZ_posixZ_open (void) {
	int X3 = (int)pop_i64();
	int X2 = (int)pop_i64();
	const char * X1 = (const char *)pop_ptr();
	int Y = open_internal(X1, X2, X3);
	push_i64((int64_t)(Y));
}
int stat (const char *, void*);
static void mext_std_world_posixZ_stat (void) {
	void* X3 = (void*)pop_ptr();
	const char * X2 = (const char *)pop_ptr();
(void)pop_resource();
	int Y = stat(X2, X3);
	push_resource(MKI64(0));
	push_i64((int64_t)(Y));
}
double strtod(const char*, char**);
double string_to_float64(const char* float64_str) {
    return strtod(float64_str, 0);
}
double string_to_float64 (const char *);
static void mext_mirth_lexer_stringz_toz_float64 (void) {
	const char * X1 = (const char *)pop_ptr();
	double Y = string_to_float64(X1);
	push_f64((double)(Y));
}
static VAL mw_std_either_Either_2_leftZAsk (VAL x1);
static int64_t mw_std_prim_Int_ZToByte (int64_t x1);
static int64_t mw_std_prim_U8_ZToByte (int64_t x1);
static void mw_std_prim_Ptr_ZAtByte (VAL x1, VAL x2);
static int64_t mw_std_byte_Byte_isZ_upper (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_lower (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_digit (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_alpha (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_alnum (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_printable (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_hexdigit (int64_t x1);
static VAL mw_std_byte_Byte_emitZ_asciiZThen (VAL x1, int64_t x2);
static VAL mw_std_byte_Byte_toZ_strZ_unsafe (int64_t x1);
static VAL mw_std_byte_Byte_toZ_asciiZ_str (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_stringZ_end (int64_t x1);
static void mw_std_byte_Byte_toZ_hexdigits (int64_t x1);
static int64_t mw_std_byte_oneZ_hexdigitZ_byte (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_nameZ_byte (int64_t x1);
static int64_t mw_std_byte_Byte_isZ_sign (int64_t x1);
static VAL mw_std_byte_Byte_zzencode (int64_t x1);
static VAL mw_std_buffer_ZPlusBuffer_new (int64_t x1);
static VAL mw_std_buffer_ZPlusBuffer_resizzeZBang (int64_t x1, VAL x2);
static VAL mw_std_buffer_ZPlusBuffer_expandZBang (int64_t x1, VAL x2);
static void mw_std_buffer_ZPlusBuffer_rdrop (VAL x1);
static VAL mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang (int64_t x1, int64_t x2, VAL x3);
static VAL mw_std_buffer_ZPlusBuffer_checkZ_spanZBang (int64_t x1, int64_t x2, VAL x3);
static VAL mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang (int64_t x1, int64_t x2, VAL x3);
static void mw_std_buffer_ZPlusBuffer_ZAtU8 (int64_t x1, VAL x2);
static VAL mw_std_buffer_ZPlusBuffer_ZBangU8 (int64_t x1, int64_t x2, VAL x3);
static VAL mw_std_buffer_ZPlusBuffer_ZBangByte (int64_t x1, int64_t x2, VAL x3);
static VAL mw_std_buffer_ZPlusBuffer_ZBangStr (VAL x1, int64_t x2, VAL x3);
static void mw_std_buffer_ZPlusBuffer_ZAtStr (int64_t x1, int64_t x2, VAL x3);
static void mw_std_prim_Ptr_ZBangStrZPlus (VAL x1, VAL x2, VAL x3);
static void mw_std_str_ZPlusStr_dupZBang (VAL x1);
static void mw_std_str_ZPlusStr_numZ_bytesZAsk (VAL x1);
static void mw_std_str_ZPlusStr_lastZ_byte (VAL x1);
static void mw_std_str_ZPlusStr_byteZAt (int64_t x1, VAL x2);
static int64_t mw_std_str_offsetZ_inZ_bounds (int64_t x1, int64_t x2);
static int64_t mw_std_prim_Str_byteZAt (int64_t x1, VAL x2);
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang (int64_t x1, VAL x2);
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang (int64_t x1, VAL x2);
static VAL mw_std_str_ZPlusStr_pushZ_strZBang (VAL x1, VAL x2);
static void mw_std_prim_Str_dropZ_bytes (int64_t x1, VAL x2, VAL x3);
static VAL mw_std_prim_Str_fromZ_bytesZ_unsafe (VAL x1);
static void mw_std_str_clampZ_sliceZ_offsetZ_sizze (int64_t x1, int64_t x2, int64_t x3);
static void mw_std_prim_Str_slice (int64_t x1, int64_t x2, VAL x3, VAL x4);
static void mw_std_prim_Str_dropZ_slice (int64_t x1, VAL x2, VAL x3);
static void mw_std_prim_Str_takeZ_slice (int64_t x1, VAL x2, VAL x3);
static void mw_std_str_ZPlusStr_slice (int64_t x1, int64_t x2, VAL x3, VAL x4);
static void mw_std_str_ZPlusStr_offsetZ_slice (int64_t x1, int64_t x2, VAL x3, VAL x4);
static void mw_std_str_ZPlusStr_takeZ_slice (int64_t x1, VAL x2, VAL x3);
static void mw_std_str_ZPlusStr_dropZ_slice (int64_t x1, VAL x2, VAL x3);
static void mw_std_str_ZPlusStr_splitZ_byte (int64_t x1, VAL x2);
static VAL mw_std_prim_Str_splitZ_byte (int64_t x1, VAL x2);
static void mw_std_str_ZPlusStr_pushZ_showZ_byteZBang (VAL x1, int64_t x2, int64_t x3);
static VAL mw_std_prim_Str_showZThen (VAL x1, VAL x2);
static VAL mw_std_list_List_1_ZDivL1 (VAL x1);
static VAL mw_std_list_List_1_ZDivL2 (VAL x1);
static int64_t mw_std_list_List_1_emptyZAsk (VAL x1);
static VAL mw_std_list_List_1_ZToListZPlus (VAL x1);
static int64_t mw_std_list_List_1_len (VAL x1);
static void mw_std_list_List_1_uncons (VAL x1);
static void mw_std_list_ListZPlus_1_uncons (VAL x1);
static void mw_std_list_List_1_unsnoc (VAL x1);
static void mw_std_list_ListZPlus_1_unsnoc (VAL x1);
static VAL mw_std_list_List_1_cat (VAL x1, VAL x2);
static VAL mw_std_list_List_1_first (VAL x1);
static VAL mw_std_list_List_1_last (VAL x1);
static VAL mw_std_list_ListZPlus_1_first (VAL x1);
static VAL mw_std_list_ListZPlus_1_last (VAL x1);
static VAL mw_std_list_List_1_reverse (VAL x1);
static VAL mw_std_prim_Int_range (int64_t x1, int64_t x2);
static int64_t mw_std_maybe_Maybe_1_noneZAsk (VAL x1);
static int64_t mw_std_maybe_Maybe_1_someZAsk (VAL x1);
static int64_t mw_std_maybe_Maybe_1_ZToBool (VAL x1);
static VAL mw_std_maybe_Maybe_1_ZToList (VAL x1);
static VAL mw_std_maybe_Maybe_1_unwrap (VAL x1);
static VAL mw_std_maybe_Maybe_1_zzip (VAL x1, VAL x2);
static int64_t mw_std_prim_Int_ZToOS (int64_t x1);
static int64_t mw_std_prim_Int_ZToArch (int64_t x1);
static VAL mw_std_prim_Int_ZToU8ZAsk (int64_t x1);
static VAL mw_std_prim_Int_ZToU16ZAsk (int64_t x1);
static int64_t mw_std_prim_Int_ZToU8 (int64_t x1);
static int64_t mw_std_prim_Int_ZToU16 (int64_t x1);
static int64_t mw_std_prim_Int_ZToI64 (int64_t x1);
static int64_t mw_std_prim_Int_ZToNat (int64_t x1);
static int64_t mw_std_prelude_Sizze_max (int64_t x1, int64_t x2);
static int64_t mw_std_prelude_Sizze_min (int64_t x1, int64_t x2);
static int64_t mw_std_prelude_Offset_min (int64_t x1, int64_t x2);
static VAL mw_std_prelude_ZAtZAsk (VAL x1);
static VAL mw_std_path_PATHz_SEPARATOR (void);
static VAL mw_std_path_Path_joinZ_with (VAL x1, VAL x2, VAL x3);
static VAL mw_std_path_Path_join (VAL x1, VAL x2);
static int64_t mw_std_byte_Byte_isZ_pathZ_separatorZAsk (int64_t x1);
static void mw_std_path_Path_splitZ_last (VAL x1);
static VAL mw_std_path_Path_pathZThen (VAL x1, VAL x2);
static int64_t mw_std_input_INPUTz_BUFFERz_SIZZE (void);
static VAL mw_std_input_ZPlusInput_startZBang (VAL x1);
static VAL mw_std_input_ZPlusInput_stopZBang (VAL x1);
static VAL mw_std_input_ZPlusInput_endZBang (VAL x1);
static void mw_std_input_ZPlusInput_doneZAsk (VAL x1);
static VAL mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang (VAL x1);
static void mw_std_input_ZPlusInput_peek (VAL x1);
static VAL mw_std_input_ZPlusInput_moveZBang (VAL x1);
static VAL mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang (VAL x1);
static void mw_std_input_ZPlusInput_readZ_chunkZBang (VAL x1);
static void mw_std_input_ZPlusInput_readZ_fileZBang (VAL x1);
static int64_t mw_std_output_OUTPUTz_BUFFERz_SIZZE (void);
static VAL mw_std_output_ZPlusOutput_startZBang (VAL x1);
static VAL mw_std_output_ZPlusOutput_endZBang (VAL x1);
static void mw_std_output_ZPlusOutput_offset (VAL x1);
static VAL mw_std_output_ZPlusOutput_flushZBang (VAL x1);
static void mw_std_output_ZPlusOutput_capacityZ_total (VAL x1);
static void mw_std_output_ZPlusOutput_capacityZ_remaining (VAL x1);
static void mw_std_output_ZPlusOutput_fullZAsk (VAL x1);
static VAL mw_std_output_ZPlusOutput_put (VAL x1, VAL x2);
static VAL mw_std_output_ZPlusOutput_putZ_byte (int64_t x1, VAL x2);
static VAL mw_std_output_ZPlusOutput_line (VAL x1);
static int64_t mw_std_posix_posixZ_openZBang (VAL x1, int64_t x2, int64_t x3);
static VAL mw_std_file_ZPlusFileZAsk_unwrapZBang (VAL x1);
static void mw_std_prim_ZPlusWorld_openZ_fileZBang (VAL x1, VAL x2);
static void mw_std_prim_ZPlusWorld_createZ_fileZBang (VAL x1, VAL x2);
static void mw_std_prim_ZPlusWorld_stderrZ_file (VAL x1);
static int64_t mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC (void);
static VAL mw_std_file_ZPlusFile_closeZ_fileZBang (VAL x1, VAL x2);
static VAL mw_std_file_ZPlusFile_unsafeZ_writeZBang (VAL x1, int64_t x2, VAL x3);
static void mw_std_file_ZPlusFile_unsafeZ_readZBang (VAL x1, int64_t x2, VAL x3);
static void mw_std_file_ZPlusFile_readZ_fileZBang (VAL x1);
static VAL mw_std_prim_ZPlusWorld_traceZ_ (VAL x1, VAL x2);
static void mw_std_prim_ZPlusWorld_isZ_directoryZAsk (VAL x1, VAL x2);
static int64_t mw_std_world_Sz_IFMT (void);
static int64_t mw_std_world_Sz_IFDIR (void);
static int64_t mw_std_world_Sz_ISDIR (int64_t x1);
static void mw_std_world_stz_modeZAt (VAL x1, VAL x2);
static VAL mw_std_terminal_SGRColor_showZThen (VAL x1, VAL x2);
static VAL mw_std_terminal_Sgr_emitZThen (VAL x1, VAL x2);
static VAL mw_std_terminal_csiZThen (VAL x1);
static VAL mw_argZ_parser_state_State_1_init (VAL x1);
static VAL mw_argZ_parser_state_State_1_argv (VAL x1);
static VAL mw_argZ_parser_state_State_1_programZ_name (VAL x1);
static int64_t mw_argZ_parser_state_State_1_parsingZAsk (VAL x1);
static VAL mw_argZ_parser_state_State_1_parsingZAskZBang (int64_t x1, VAL x2);
static VAL mw_argZ_parser_state_State_1_optionZ_option (VAL x1);
static VAL mw_argZ_parser_state_State_1_optionZ_optionZBang (VAL x1, VAL x2);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop (VAL x1);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_parser (VAL x1);
static int64_t mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk (VAL x1);
static VAL mw_argZ_parser_types_ArgumentParsingError_emitZThen (VAL x1, VAL x2);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_usage (VAL x1);
static void mw_argZ_parser_types_ArgpOption_usageZThen (VAL x1, VAL x2, VAL x3);
static void mw_argZ_parser_parse_checkZ_shortZ_flag (VAL x1, VAL x2, VAL x3);
static void mw_argZ_parser_parse_checkZ_longZ_flag (VAL x1, VAL x2, VAL x3);
static void mw_argZ_parser_parse_parseZ_flags (VAL x1, VAL x2);
static void mw_argZ_parser_parse_doZ_positionalZ_option (VAL x1, VAL x2);
static VAL mw_argZ_parser_parse_parseZ_args (VAL x1, VAL x2);
static void mw_argZ_parser_parse_readZ_fromZ_argv (VAL x1, int64_t x2);
static VAL mw_argZ_parser_parse_argvZ_toZ_str (void);
static VAL mw_std_lazzy_Lazzy_1_forceZBang (VAL x1);
static int64_t mw_mirth_label_Label_index (uint64_t x1);
static uint64_t mw_mirth_label_Label_allocZBang (void);
static uint64_t mw_mirth_label_Label_name (uint64_t x1);
static VAL mw_mirth_label_Label_ZToStr (uint64_t x1);
static int64_t mw_mirth_label_Label_ZEqualZEqual (uint64_t x1, uint64_t x2);
static uint64_t mw_mirth_label_Label_newZBang (uint64_t x1);
static int64_t mw_mirth_label_Label_isZ_resourceZ_labelZAsk (uint64_t x1);
static int64_t mw_mirth_var_Var_index (uint64_t x1);
static uint64_t mw_mirth_var_Var_allocZBang (void);
static uint64_t mw_mirth_var_Var_name (uint64_t x1);
static VAL mw_mirth_var_Var_type (uint64_t x1);
static int64_t mw_mirth_var_Var_autoZ_runZAsk (uint64_t x1);
static int64_t mw_mirth_var_Var_ZEqualZEqual (uint64_t x1, uint64_t x2);
static VAL mw_mirth_var_Var_typeZThen (VAL x1, uint64_t x2);
static int64_t mw_mirth_var_Var_isZ_stackZAsk (uint64_t x1);
static int64_t mw_mirth_var_Var_isZ_physicalZAsk (uint64_t x1);
static uint64_t mw_mirth_var_Var_newZBang (VAL x1, uint64_t x2);
static uint64_t mw_mirth_var_Var_newZ_autoZ_runZBang (VAL x1, uint64_t x2);
static VAL mw_std_list_List_1_ZToCtx (VAL x1);
static VAL mw_mirth_var_Ctx_ZToList (VAL x1);
static VAL mw_mirth_var_Ctx0 (void);
static VAL mw_mirth_var_Ctx1 (uint64_t x1);
static VAL mw_mirth_var_Ctx2 (uint64_t x1, uint64_t x2);
static VAL mw_mirth_var_Ctx3 (uint64_t x1, uint64_t x2, uint64_t x3);
static VAL mw_mirth_var_Ctx_new (VAL x1, uint64_t x2);
static VAL mw_mirth_var_Ctx_lookup (uint64_t x1, VAL x2);
static void mw_mirth_var_Ctx_freshZ_nameZBang (VAL x1);
static void mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang (VAL x1);
static void mw_mirth_var_Ctx_freshZ_typeZ_varZBang (VAL x1);
static void mw_mirth_var_Ctx_freshZ_varZBang (VAL x1, VAL x2);
static void mw_mirth_var_Var_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4);
static void mw_mirth_var_Var_freshen (VAL x1, uint64_t x2);
static int64_t mw_mirth_buffer_Buffer_index (uint64_t x1);
static uint64_t mw_mirth_buffer_Buffer_allocZBang (void);
static int64_t mw_mirth_buffer_Buffer_sizze (uint64_t x1);
static VAL mw_mirth_buffer_Buffer_qname (uint64_t x1);
static uint64_t mw_mirth_buffer_Buffer_name (uint64_t x1);
static int64_t mw_mirth_buffer_Buffer_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_buffer_Buffer_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4);
static int64_t mw_mirth_word_Word_index (uint64_t x1);
static uint64_t mw_mirth_word_Word_allocZBang (void);
static VAL mw_mirth_word_Word_qnameZ_soft (uint64_t x1);
static void mw_mirth_word_Word_qnameZ_hard (uint64_t x1, VAL x2);
static void mw_mirth_word_Word_namespaceZ_hard (uint64_t x1, VAL x2);
static uint64_t mw_mirth_word_Word_name (uint64_t x1);
static uint64_t mw_mirth_word_Word_head (uint64_t x1);
static VAL mw_mirth_word_Word_sigZAsk (uint64_t x1);
static uint64_t mw_mirth_word_Word_body (uint64_t x1);
static int64_t mw_mirth_word_Word_arity (uint64_t x1);
static void mw_mirth_word_Word_params (uint64_t x1, VAL x2);
static void mw_mirth_word_Word_arrow (uint64_t x1, VAL x2);
static int64_t mw_mirth_word_Word_inferringZ_typeZAsk (uint64_t x1);
static void mw_mirth_word_Word_cname (uint64_t x1, VAL x2);
static void mw_mirth_word_Word_ctxZ_type (uint64_t x1, VAL x2);
static void mw_mirth_word_Word_type (uint64_t x1, VAL x2);
static int64_t mw_mirth_word_Word_preferZ_inlineZAsk (uint64_t x1);
static void mw_mirth_word_Word_makeZ_inlineZBang (uint64_t x1);
static void mw_mirth_word_Word_newZBang (uint64_t x1, VAL x2, uint64_t x3, uint64_t x4, int64_t x5, VAL x6);
static int64_t mw_mirth_word_Word_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_word_Word_incZ_numZ_blocksZBang (uint64_t x1);
static int64_t mw_mirth_table_Table_index (uint64_t x1);
static uint64_t mw_mirth_table_Table_allocZBang (void);
static uint64_t mw_mirth_table_Table_head (uint64_t x1);
static VAL mw_mirth_table_Table_qnameZ_soft (uint64_t x1);
static void mw_mirth_table_Table_qnameZ_hard (VAL x1, uint64_t x2);
static uint64_t mw_mirth_table_Table_name (uint64_t x1);
static uint64_t mw_mirth_table_Table_numZ_buffer (uint64_t x1);
static int64_t mw_mirth_table_Table_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_table_Field_index (uint64_t x1);
static uint64_t mw_mirth_table_Field_allocZBang (void);
static uint64_t mw_mirth_table_Field_name (uint64_t x1);
static VAL mw_mirth_table_Field_qnameZ_soft (uint64_t x1);
static void mw_mirth_table_Field_qnameZ_hard (VAL x1, uint64_t x2);
static void mw_mirth_table_Field_indexZ_type (VAL x1, uint64_t x2);
static void mw_mirth_table_Field_valueZ_type (VAL x1, uint64_t x2);
static void mw_mirth_table_Field_dom (VAL x1, uint64_t x2);
static void mw_mirth_table_Field_cod (VAL x1, uint64_t x2);
static void mw_mirth_table_Field_type (VAL x1, uint64_t x2);
static int64_t mw_mirth_table_Field_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_tycon_Tycon_qnameZ_hard (VAL x1, VAL x2);
static int64_t mw_mirth_tycon_Tycon_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_tycon_Tycon_fullZ_typeZ_fresh (VAL x1, VAL x2);
static int64_t mw_mirth_data_Data_index (uint64_t x1);
static uint64_t mw_mirth_data_Data_allocZBang (void);
static VAL mw_mirth_data_Data_headZAsk (uint64_t x1);
static uint64_t mw_mirth_data_Data_name (uint64_t x1);
static VAL mw_mirth_data_Data_qnameZ_soft (uint64_t x1);
static void mw_mirth_data_Data_qnameZ_hard (VAL x1, uint64_t x2);
static int64_t mw_mirth_data_Data_arity (uint64_t x1);
static void mw_mirth_data_Data_params (VAL x1, uint64_t x2);
static VAL mw_mirth_data_Data_tags (uint64_t x1);
static void mw_mirth_data_Data_ctypeZAsk (uint64_t x1, VAL x2);
static void mw_mirth_data_TYPEz_BOOL (VAL x1);
static void mw_mirth_data_TYPEz_U64 (VAL x1);
static void mw_mirth_data_TYPEz_U32 (VAL x1);
static void mw_mirth_data_TYPEz_U16 (VAL x1);
static void mw_mirth_data_TYPEz_U8 (VAL x1);
static void mw_mirth_data_TYPEz_I64 (VAL x1);
static void mw_mirth_data_TYPEz_I32 (VAL x1);
static void mw_mirth_data_TYPEz_I16 (VAL x1);
static void mw_mirth_data_TYPEz_I8 (VAL x1);
static VAL mw_mirth_data_makeZ_primZ_dataZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5, VAL x6);
static VAL mw_mirth_data_makeZ_primZ_tagZBang (VAL x1, VAL x2, int64_t x3, VAL x4, uint64_t x5);
static VAL mw_mirth_data_makeZ_primZ_intlikeZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL x5, VAL x6);
static VAL mw_mirth_data_initZ_dataZBang (VAL x1);
static VAL mw_mirth_data_dataZ_qname (uint64_t x1, uint64_t x2, int64_t x3);
static VAL mw_mirth_data_dataZ_wordZ_qname (uint64_t x1, VAL x2, int64_t x3);
static int64_t mw_mirth_data_Data_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_data_Data_numZ_tags (uint64_t x1);
static VAL mw_mirth_data_Data_addZ_tagZBang (VAL x1, uint64_t x2, uint64_t x3);
static int64_t mw_mirth_data_Data_isZ_unitZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_enumZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_transparentZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_semiZ_transparentZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_resourceZAsk (uint64_t x1);
static int64_t mw_mirth_data_Data_isZ_valueZ_typeZAsk (uint64_t x1);
static void mw_mirth_data_Data_fullZ_type (VAL x1, uint64_t x2);
static int64_t mw_mirth_data_Tag_index (uint64_t x1);
static uint64_t mw_mirth_data_Tag_allocZBang (void);
static uint64_t mw_mirth_data_Tag_data (uint64_t x1);
static VAL mw_mirth_data_Tag_qname (uint64_t x1);
static uint64_t mw_mirth_data_Tag_name (uint64_t x1);
static int64_t mw_mirth_data_Tag_value (uint64_t x1);
static VAL mw_mirth_data_Tag_labelZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputs (uint64_t x1);
static VAL mw_mirth_data_Tag_sigZAsk (uint64_t x1);
static void mw_mirth_data_Tag_ctxZ_type (VAL x1, uint64_t x2);
static void mw_mirth_data_Tag_ctx (VAL x1, uint64_t x2);
static void mw_mirth_data_Tag_type (VAL x1, uint64_t x2);
static VAL mw_mirth_data_Tag_untag (uint64_t x1);
static VAL mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_labelZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_numZ_totalZ_inputs (uint64_t x1);
static int64_t mw_mirth_data_Tag_isZ_transparentZAsk (uint64_t x1);
static int64_t mw_mirth_data_Tag_isZ_semiZ_transparentZAsk (uint64_t x1);
static int64_t mw_mirth_data_Tag_outputsZ_resourceZAsk (uint64_t x1);
static int64_t mw_mirth_data_Tag_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_data_Tag_preferZ_inlineZAsk (uint64_t x1);
static int64_t mw_mirth_data_DataPartial_ZEqualZEqual (VAL x1, VAL x2);
static VAL mw_mirth_match_Match_thaw (VAL x1);
static VAL mw_mirth_match_ZPlusMatch_freezze (VAL x1);
static int64_t mw_mirth_match_Match_isZ_exhaustiveZAsk (VAL x1);
static int64_t mw_mirth_match_Match_hasZ_defaultZ_caseZAsk (VAL x1);
static VAL mw_mirth_match_Match_scrutineeZ_dataZAsk (VAL x1);
static void mw_mirth_match_ZPlusMatch_addZ_case (VAL x1, VAL x2, VAL x3);
static void mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk (VAL x1, VAL x2);
static int64_t mw_mirth_match_Case_coversZAsk (VAL x1, VAL x2);
static int64_t mw_mirth_match_Case_isZ_defaultZ_caseZAsk (VAL x1);
static VAL mw_mirth_match_Pattern_dom (VAL x1);
static VAL mw_mirth_match_Pattern_thaw (VAL x1);
static VAL mw_mirth_match_Pattern_singleZ_tagZAsk (VAL x1);
static int64_t mw_mirth_match_Pattern_isZ_defaultZAsk (VAL x1);
static VAL mw_mirth_match_ZPlusPattern_freezze (VAL x1);
static void mw_mirth_match_ZPlusPattern_opZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_match_ZPlusPattern_underscoreZBang (VAL x1, VAL x2);
static void mw_mirth_match_ZPlusPattern_tagZBang (VAL x1, VAL x2, uint64_t x3);
static int64_t mw_mirth_match_Pattern_coversZAsk (VAL x1, VAL x2);
static VAL mw_mirth_match_PatternOp_ZDivPatOpTag (VAL x1);
static int64_t mw_mirth_match_PatternOp_ZDivPatOpUnderscore (VAL x1);
static int64_t mw_mirth_external_External_index (uint64_t x1);
static uint64_t mw_mirth_external_External_allocZBang (void);
static VAL mw_mirth_external_External_qnameZ_soft (uint64_t x1);
static void mw_mirth_external_External_qnameZ_hard (VAL x1, uint64_t x2);
static uint64_t mw_mirth_external_External_name (uint64_t x1);
static int64_t mw_mirth_external_External_arity (uint64_t x1);
static VAL mw_mirth_external_External_symbol (uint64_t x1);
static uint64_t mw_mirth_external_External_head (uint64_t x1);
static uint64_t mw_mirth_external_External_sig (uint64_t x1);
static void mw_mirth_external_External_ctxZ_type (VAL x1, uint64_t x2);
static void mw_mirth_external_External_type (VAL x1, uint64_t x2);
static void mw_mirth_external_External_ctype (VAL x1, uint64_t x2);
static int64_t mw_mirth_external_External_ZEqualZEqual (uint64_t x1, uint64_t x2);
static uint64_t mw_mirth_external_ExternalBlock_allocZBang (void);
static VAL mw_mirth_external_ExternalBlock_parts (uint64_t x1);
static int64_t mw_mirth_variable_Variable_index (uint64_t x1);
static uint64_t mw_mirth_variable_Variable_allocZBang (void);
static VAL mw_mirth_variable_Variable_qname (uint64_t x1);
static uint64_t mw_mirth_variable_Variable_name (uint64_t x1);
static void mw_mirth_variable_Variable_type (VAL x1, uint64_t x2);
static int64_t mw_mirth_variable_Variable_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_variable_Variable_newZBang (VAL x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_arrow_Block_index (uint64_t x1);
static uint64_t mw_mirth_arrow_Block_allocZBang (void);
static void mw_mirth_arrow_Arrow_ctxZ_type (VAL x1);
static VAL mw_mirth_arrow_Arrow_type (VAL x1);
static VAL mw_mirth_arrow_Lambda_cod (VAL x1);
static VAL mw_mirth_arrow_Block_ctx (uint64_t x1);
static uint64_t mw_mirth_arrow_Block_token (uint64_t x1);
static VAL mw_mirth_arrow_Block_dom (uint64_t x1);
static VAL mw_mirth_arrow_Block_cod (uint64_t x1);
static VAL mw_mirth_arrow_Block_home (uint64_t x1);
static VAL mw_mirth_arrow_Block_type (uint64_t x1);
static void mw_mirth_arrow_Block_arrow (VAL x1, uint64_t x2);
static void mw_mirth_arrow_Block_qname (VAL x1, uint64_t x2);
static int64_t mw_mirth_arrow_Block_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_arrow_Block_registerZ_homeZBang (uint64_t x1);
static void mw_mirth_arrow_Block_cname (VAL x1, uint64_t x2);
static void mw_mirth_arrow_Block_newZBang (VAL x1, VAL x2);
static void mw_mirth_arrow_Block_newZ_deferredZBang_1 (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL x5);
static VAL mw_mirth_arrow_Block_typecheckZBang (VAL x1, uint64_t x2);
static void mw_mirth_arrow_blockZ_unifyZ_typeZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4);
static void mw_mirth_arrow_Block_toZ_runZ_var (VAL x1, uint64_t x2);
static VAL mw_mirth_arrow_Arrow_toZ_runZ_var (VAL x1);
static VAL mw_mirth_arrow_Atom_toZ_runZ_var (VAL x1);
static void mw_mirth_arrow_Arg_ZToStr (VAL x1, uint64_t x2);
static int64_t mw_mirth_arrow_Arg_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_arrow_Block_freeZ_vars (VAL x1, uint64_t x2);
static void mw_mirth_arrow_Arrow_freeZ_vars (VAL x1, VAL x2);
static void mw_mirth_arrow_Atom_freeZ_vars (VAL x1, VAL x2);
static void mw_mirth_arrow_Arg_freeZ_vars (VAL x1, uint64_t x2);
static void mw_mirth_arrow_Op_freeZ_vars (VAL x1, VAL x2);
static void mw_mirth_match_Match_freeZ_vars (VAL x1, VAL x2);
static void mw_mirth_match_Case_freeZ_vars (VAL x1, VAL x2);
static void mw_mirth_arrow_Lambda_freeZ_vars (VAL x1, VAL x2);
static uint64_t mw_mirth_arrow_Arg_token (uint64_t x1);
static int64_t mw_mirth_typedef_TypeDef_index (uint64_t x1);
static uint64_t mw_mirth_typedef_TypeDef_allocZBang (void);
static VAL mw_mirth_typedef_TypeDef_qnameZ_soft (uint64_t x1);
static void mw_mirth_typedef_TypeDef_qnameZ_hard (VAL x1, uint64_t x2);
static void mw_mirth_typedef_TypeDef_namespace (VAL x1, uint64_t x2);
static uint64_t mw_mirth_typedef_TypeDef_name (uint64_t x1);
static void mw_mirth_typedef_TypeDef_target (VAL x1, uint64_t x2);
static int64_t mw_mirth_typedef_TypeDef_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_typedef_TypeDef_newZBang (VAL x1, VAL x2, uint64_t x3, VAL x4);
static VAL mw_mirth_mirth_ZPlusMirth_defZ_typeZBang (VAL x1, VAL x2, VAL x3);
static int64_t mw_mirth_type_PrimType_isZ_resourceZAsk (int64_t x1);
static int64_t mw_mirth_type_PrimType_isZ_physicalZAsk (int64_t x1);
static VAL mw_mirth_type_Type_tyconZAsk (VAL x1);
static void mw_mirth_type_PrimType_tyconZ_qname (VAL x1, int64_t x2);
static VAL mw_mirth_type_Value_tyconZAsk (VAL x1);
static int64_t mw_mirth_type_PrimType_ZToInt (int64_t x1);
static int64_t mw_mirth_type_PrimType_ZEqualZEqual (int64_t x1, int64_t x2);
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang (VAL x1, int64_t x2);
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang (VAL x1, int64_t x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_initZ_typesZBang (VAL x1);
static VAL mw_mirth_type_TZPlus (VAL x1, VAL x2);
static VAL mw_mirth_type_TZMul (VAL x1, VAL x2);
static VAL mw_mirth_type_TZMulZPlus (VAL x1, VAL x2);
static VAL mw_mirth_type_TZ_ZTo (VAL x1, VAL x2);
static VAL mw_mirth_type_TT (VAL x1);
static VAL mw_mirth_type_T0 (void);
static VAL mw_mirth_type_T1 (VAL x1);
static VAL mw_mirth_type_T2 (VAL x1, VAL x2);
static VAL mw_mirth_type_T3 (VAL x1, VAL x2, VAL x3);
static int64_t mw_mirth_type_Type_errorZAsk (VAL x1);
static VAL mw_mirth_type_Type_morphismZAsk (VAL x1);
static VAL mw_mirth_type_Type_primZAsk (VAL x1);
static int64_t mw_mirth_type_Type_metaZEqual (uint64_t x1, VAL x2);
static int64_t mw_mirth_type_Type_isZ_physicalZAsk (VAL x1);
static VAL mw_mirth_type_TYPEz_TYPE (void);
static VAL mw_mirth_type_TYPEz_STACK (void);
static VAL mw_mirth_type_TYPEz_RESOURCE (void);
static VAL mw_mirth_type_TYPEz_INT (void);
static VAL mw_mirth_type_TYPEz_F32 (void);
static VAL mw_mirth_type_TYPEz_F64 (void);
static VAL mw_mirth_type_TYPEz_PTR (void);
static VAL mw_mirth_type_TYPEz_STR (void);
static VAL mw_mirth_type_TYPEz_WORLD (void);
static VAL mw_mirth_type_RESOURCEz_WORLD (void);
static VAL mw_mirth_type_Type_expand (VAL x1);
static void mw_mirth_type_ZPlusGamma_rdrop (uint64_t x1);
static void mw_mirth_type_Type_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Type_unifyZ_simpleZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Type_unifyZ_auxZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Type_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3);
static void mw_mirth_type_Type_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Value_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Value_unifyZ_typeZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Value_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3);
static void mw_mirth_type_Type_unifyZ_blockZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4);
static void mw_mirth_type_Type_unify2ZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, VAL x6);
static void mw_mirth_type_PrimType_unifyZBang (VAL x1, uint64_t x2, int64_t x3, int64_t x4);
static void mw_mirth_data_Data_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4);
static void mw_mirth_data_DataPartial_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_table_Table_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4);
static int64_t mw_mirth_type_Type_hasZ_metaZAsk (uint64_t x1, VAL x2);
static int64_t mw_mirth_type_Type_hasZ_meta2ZAsk (uint64_t x1, VAL x2, VAL x3);
static int64_t mw_mirth_type_Value_hasZ_metaZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_Type_typeZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_Value_type (VAL x1);
static VAL mw_mirth_type_PrimType_typeZThen (VAL x1, int64_t x2);
static void mw_mirth_type_Type_freshen (VAL x1, VAL x2);
static void mw_mirth_type_Type_freshen2 (VAL x1, VAL x2, VAL x3);
static void mw_mirth_type_Type_rigidifyZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_type_Value_rigidifyZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Type_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_type_MetaVar_index (uint64_t x1);
static uint64_t mw_mirth_type_MetaVar_allocZBang (void);
static VAL mw_mirth_type_MetaVar_typeZAsk (uint64_t x1);
static int64_t mw_mirth_type_MetaVar_hasZ_metaZAsk (uint64_t x1, uint64_t x2);
static VAL mw_mirth_type_MetaVar_typeZThen (VAL x1, uint64_t x2);
static uint64_t mw_mirth_type_MetaVar_newZBang (void);
static VAL mw_mirth_type_MetaVar_expand (uint64_t x1);
static void mw_mirth_type_MetaVar_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4);
static void mw_mirth_type_MetaVar_unifyZ_errorZBang (VAL x1, uint64_t x2, uint64_t x3);
static int64_t mw_mirth_type_MetaVar_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_type_MetaVar_freshen (VAL x1, uint64_t x2);
static void mw_mirth_type_typeZ_holeZ_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4);
static VAL mw_mirth_type_Type_appZ_typeZThenZThen (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Type_appZ_typeZ_openZThenZThen (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Resource_ZToType (VAL x1);
static VAL mw_mirth_type_Type_ZToResource (VAL x1);
static int64_t mw_mirth_type_Resource_hasZ_metaZAsk (uint64_t x1, VAL x2);
static void mw_mirth_type_Resource_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_Resource_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_type_Resource_typeZThen (VAL x1, VAL x2);
static void mw_mirth_type_Resource_freshen (VAL x1, VAL x2);
static void mw_mirth_type_Resource_rigidifyZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Resource_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_type_Type_ZToStackType (VAL x1);
static VAL mw_mirth_type_StackType_ZToType (VAL x1);
static VAL mw_mirth_type_StackType_expand (VAL x1);
static int64_t mw_mirth_type_StackType_unitZAsk (VAL x1);
static void mw_mirth_type_StackType_split4 (VAL x1);
static VAL mw_mirth_type_StackType_base (VAL x1);
static VAL mw_mirth_type_StackType_labelZ_topZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackType_topZ_typeZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_tyconZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_resourceZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk (VAL x1);
static VAL mw_mirth_type_StackType_topZ_namespaces (VAL x1);
static int64_t mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk (VAL x1);
static int64_t mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk (VAL x1);
static int64_t mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk (VAL x1);
static int64_t mw_mirth_type_StackType_hasZ_metaZAsk (uint64_t x1, VAL x2);
static void mw_mirth_type_StackType_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_StackType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_StackType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackType_forceZ_consZAskZBang (VAL x1);
static VAL mw_mirth_type_StackType_forceZ_withZAskZBang (VAL x1);
static VAL mw_mirth_type_StackType_domZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_StackType_codZThen (VAL x1, VAL x2);
static void mw_mirth_type_StackType_baseZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_StackType_stackZThen (VAL x1, VAL x2);
static void mw_mirth_type_StackType_semifreshen (VAL x1, VAL x2);
static void mw_mirth_type_StackType_freshen (VAL x1, VAL x2);
static void mw_mirth_type_StackType_freshenZ_aux (VAL x1, VAL x2, VAL x3);
static void mw_mirth_type_StackType_rigidifyZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_ArrowType_ZToType (VAL x1);
static VAL mw_mirth_type_ArrowType_invert (VAL x1);
static void mw_mirth_type_ArrowType_unpack (VAL x1);
static VAL mw_mirth_type_ArrowType_dom (VAL x1);
static VAL mw_mirth_type_ArrowType_cod (VAL x1);
static void mw_mirth_type_ArrowType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_ArrowType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_type_ArrowType_hasZ_metaZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_ArrowType_sigZThen (VAL x1, VAL x2);
static VAL mw_mirth_type_ArrowType_semifreshenZ_sig (VAL x1);
static VAL mw_mirth_type_ArrowType_semifreshenZ_aux (VAL x1);
static int64_t mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk (VAL x1);
static void mw_mirth_type_ArrowType_freshenZ_sig (VAL x1, VAL x2);
static void mw_mirth_type_ArrowType_freshenZ_sigZ_aux (VAL x1, VAL x2);
static void mw_mirth_type_ArrowType_freshen (VAL x1, VAL x2);
static void mw_mirth_type_ArrowType_rigidifyZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_type_ArrowType_rigidifyZ_sigZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_Subst_nil (void);
static VAL mw_mirth_type_Subst_cons (VAL x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_type_Subst_hasZ_varZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_type_Subst_getZ_var (uint64_t x1, VAL x2);
static VAL mw_mirth_type_StackTypePart_cons (VAL x1, VAL x2);
static void mw_mirth_type_StackType_splitZ_parts (VAL x1);
static VAL mw_mirth_type_CType_cname (VAL x1);
static int64_t mw_mirth_type_CType_phantomZAsk (VAL x1);
static void mw_mirth_type_Resource_ctype (VAL x1, VAL x2);
static void mw_mirth_type_Type_ctype (VAL x1, VAL x2);
static void mw_mirth_type_Resource_ctypeZAsk (VAL x1, VAL x2);
static void mw_mirth_type_Type_ctypeZAsk (VAL x1, VAL x2);
static void mw_mirth_type_Type_ctype1ZAsk (VAL x1, VAL x2, VAL x3);
static void mw_mirth_type_PrimType_ctypeZAsk (VAL x1, int64_t x2);
static void mw_mirth_data_Data_ctype1ZAsk (VAL x1, VAL x2, uint64_t x3);
static VAL mw_mirth_type_CTypeStackPart_ctype (VAL x1);
static VAL mw_mirth_type_CTypeStackPart_labelZAsk (VAL x1);
static void mw_mirth_type_StackTypePart_ctype (VAL x1, VAL x2);
static void mw_mirth_type_StackType_baseZ_ctypeZAsk (VAL x1, VAL x2);
static void mw_mirth_type_StackType_ctype (VAL x1, VAL x2);
static void mw_mirth_type_ArrowType_ctype (VAL x1, VAL x2);
static void mw_mirth_prim_Prim_qname (VAL x1, int64_t x2);
static uint64_t mw_mirth_prim_Prim_name (int64_t x1);
static VAL mw_mirth_prim_Prim_type (int64_t x1);
static int64_t mw_mirth_prim_Prim_arity (int64_t x1);
static int64_t mw_mirth_prim_Prim_ZToInt (int64_t x1);
static int64_t mw_mirth_prim_Prim_ZEqualZEqual (int64_t x1, int64_t x2);
static VAL mw_mirth_prim_defZ_primZBang (VAL x1, int64_t x2, VAL x3, int64_t x4);
static void mw_mirth_prim_Prim_ctxZ_typeZBang (VAL x1, VAL x2, int64_t x3);
static VAL mw_mirth_prim_initZ_primsZBang (VAL x1);
static int64_t mw_mirth_token_TokenValue_noneZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_commaZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lparenZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lparenZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_rparenZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lsquareZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lsquareZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_rsquareZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lcurlyZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lcurlyZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_rcurlyZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_lcolonZ_openZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lcolonZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_intZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_strZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_nameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_dnameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_nameZ_orZ_dnameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_lastZ_nameZAsk (VAL x1);
static VAL mw_mirth_token_TokenValue_penultimateZ_nameZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_argZ_endZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_leftZ_enclosureZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_rightZ_enclosureZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_sigZ_dashesZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_arrowZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_patZ_underscoreZAsk (VAL x1);
static int64_t mw_mirth_token_TokenValue_moduleZ_headerZAsk (VAL x1);
static int64_t mw_mirth_token_Token_index (uint64_t x1);
static uint64_t mw_mirth_token_Token_succ (uint64_t x1);
static uint64_t mw_mirth_token_Token_pred (uint64_t x1);
static uint64_t mw_mirth_token_Token_allocZBang (void);
static int64_t mw_mirth_token_Token_ZEqualZEqual (uint64_t x1, uint64_t x2);
static VAL mw_mirth_token_Token_value (uint64_t x1);
static uint64_t mw_mirth_token_Token_module (uint64_t x1);
static int64_t mw_mirth_token_Token_col (uint64_t x1);
static int64_t mw_mirth_token_Token_row (uint64_t x1);
static int64_t mw_mirth_token_Token_noneZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_commaZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lparenZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lparenZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_rparenZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lsquareZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lsquareZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_rsquareZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lcurlyZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lcurlyZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_rcurlyZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_lcolonZ_openZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lcolonZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_intZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_strZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_nameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_dnameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_nameZ_orZ_dnameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_lastZ_nameZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_penultimateZ_nameZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_argZ_endZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_leftZ_enclosureZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_rightZ_enclosureZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_typeZ_conZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_typeZ_holeZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_typeZ_varZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_paramZ_nameZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_stackZ_varZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_resourceZ_varZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_resourceZ_conZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_dashesZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_arrowZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_patZ_underscoreZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_moduleZ_headerZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_canZ_takeZ_argsZAsk (uint64_t x1);
static uint64_t mw_mirth_token_Token_allocZ_noneZBang (void);
static VAL mw_mirth_token_Token_location (uint64_t x1);
static uint64_t mw_mirth_token_Token_next (uint64_t x1);
static uint64_t mw_mirth_token_Token_prev (uint64_t x1);
static uint64_t mw_mirth_token_Token_nextZ_argZ_end (uint64_t x1);
static int64_t mw_mirth_token_Token_hasZ_argsZAsk (uint64_t x1);
static uint64_t mw_mirth_token_Token_argsZ_start (uint64_t x1);
static int64_t mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_patternZ_varZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_argsZ_0 (uint64_t x1, VAL x2);
static void mw_mirth_token_Token_argsZ_1 (uint64_t x1, VAL x2);
static void mw_mirth_token_Token_argsZ_2 (uint64_t x1, VAL x2);
static void mw_mirth_token_Token_argsZ_3 (uint64_t x1, VAL x2);
static int64_t mw_mirth_token_Token_numZ_args (uint64_t x1);
static VAL mw_mirth_token_Token_args (uint64_t x1);
static int64_t mw_mirth_token_Token_argsZ_endZAsk (uint64_t x1);
static void mw_mirth_token_Token_argsZPlus (uint64_t x1, VAL x2);
static int64_t mw_mirth_token_Token_moduleZ_endZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_runZ_endZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_runZ_tokens (uint64_t x1);
static int64_t mw_mirth_token_Token_runZ_length (uint64_t x1);
static VAL mw_mirth_token_Token_runZ_arrowZAsk (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_stackZ_endZAsk (uint64_t x1);
static uint64_t mw_mirth_token_Token_sigZ_nextZ_stackZ_end (uint64_t x1);
static int64_t mw_mirth_token_Token_sigZ_hasZ_dashesZAsk (uint64_t x1);
static VAL mw_mirth_token_Token_patZ_tokens (uint64_t x1);
static int64_t mw_mirth_module_Module_index (uint64_t x1);
static uint64_t mw_mirth_module_Module_allocZBang (void);
static uint64_t mw_mirth_module_Module_package (uint64_t x1);
static uint64_t mw_mirth_module_Module_name (uint64_t x1);
static VAL mw_mirth_module_Module_qname (uint64_t x1);
static VAL mw_mirth_module_Module_path (uint64_t x1);
static uint64_t mw_mirth_module_Module_start (uint64_t x1);
static VAL mw_mirth_module_Module_imports (uint64_t x1);
static int64_t mw_mirth_module_Module_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_module_Module_prim (VAL x1);
static VAL mw_mirth_module_initZ_modulesZBang (VAL x1);
static void mw_mirth_module_Module_newZBang (VAL x1, VAL x2);
static void mw_mirth_module_Module_addZ_importZBang (uint64_t x1, uint64_t x2);
static VAL mw_mirth_module_Module_sourceZ_path (uint64_t x1);
static int64_t mw_mirth_module_Module_visible (uint64_t x1, uint64_t x2);
static int64_t mw_std_prim_Int_ZToRow (int64_t x1);
static int64_t mw_mirth_location_Row_ZToInt (int64_t x1);
static VAL mw_mirth_location_Row_showZThen (VAL x1, int64_t x2);
static int64_t mw_std_prim_Int_ZToCol (int64_t x1);
static int64_t mw_mirth_location_Col_ZToInt (int64_t x1);
static VAL mw_mirth_location_Col_showZThen (VAL x1, int64_t x2);
static VAL mw_mirth_location_Location_emitZThen (VAL x1, VAL x2);
static int64_t mw_mirth_alias_Alias_index (uint64_t x1);
static uint64_t mw_mirth_alias_Alias_allocZBang (void);
static VAL mw_mirth_alias_Alias_qnameZ_soft (uint64_t x1);
static void mw_mirth_alias_Alias_qnameZ_hard (VAL x1, uint64_t x2);
static void mw_mirth_alias_Alias_namespaceZ_hard (VAL x1, uint64_t x2);
static uint64_t mw_mirth_alias_Alias_name (uint64_t x1);
static int64_t mw_mirth_alias_Alias_arity (uint64_t x1);
static void mw_mirth_alias_Alias_target (VAL x1, uint64_t x2);
static int64_t mw_mirth_alias_Alias_ZEqualZEqual (uint64_t x1, uint64_t x2);
static void mw_mirth_alias_Alias_newZBang (VAL x1, uint64_t x2, uint64_t x3, int64_t x4);
static VAL mw_mirth_mirth_Builtin_AllocZBang (void);
static VAL mw_mirth_mirth_ZPlusMirth_InitZBang (void);
static void mw_mirth_mirth_ZPlusMirth_rdrop (VAL x1);
static void mw_mirth_mirth_ZPlusMirth_mirthZ_baseZ_libZ_path (VAL x1);
static VAL mw_mirth_mirth_Severity_ZToStr (int64_t x1);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang (VAL x1, VAL x2, int64_t x3, VAL x4);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang (uint64_t x1, VAL x2, VAL x3, VAL x4);
static VAL mw_mirth_mirth_ZPlusMirth_errorZBang (VAL x1, VAL x2);
static void mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang (VAL x1, VAL x2);
static void mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang (VAL x1);
static void mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang (VAL x1, VAL x2);
static void mw_mirth_mirth_ZPlusMirth_popZ_diagnostics (VAL x1);
static VAL mw_mirth_mirth_Diagnostic_diagnosticZThen (VAL x1, VAL x2);
static void mw_mirth_mirth_PropLabel_prop (VAL x1, VAL x2, VAL x3);
static void mw_mirth_mirth_PropLabel_prop2 (VAL x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_mirth_PropLabel_prop_1 (VAL x1, VAL x2, VAL x3, VAL x4);
static VAL mw_mirth_mirth_Prop_1_readyZAsk (VAL x1);
static void mw_mirth_mirth_Prop_1_tryZ_forceZBang (VAL x1, VAL x2);
static void mw_mirth_mirth_Prop_1_forceZBang (VAL x1, VAL x2);
static VAL mw_mirth_def_Def_packageZAsk (VAL x1);
static VAL mw_mirth_def_Def_moduleZAsk (VAL x1);
static VAL mw_mirth_def_Def_aliasZAsk (VAL x1);
static VAL mw_mirth_def_Def_dataZAsk (VAL x1);
static VAL mw_mirth_def_Def_tableZAsk (VAL x1);
static VAL mw_mirth_def_Def_typedefZAsk (VAL x1);
static VAL mw_mirth_def_Def_tagZAsk (VAL x1);
static VAL mw_mirth_def_Def_primZAsk (VAL x1);
static VAL mw_mirth_def_Def_wordZAsk (VAL x1);
static VAL mw_mirth_def_Def_bufferZAsk (VAL x1);
static VAL mw_mirth_def_Def_variableZAsk (VAL x1);
static VAL mw_mirth_def_Def_externalZAsk (VAL x1);
static VAL mw_mirth_def_Def_fieldZAsk (VAL x1);
static int64_t mw_mirth_def_Def_ZEqualZEqual (VAL x1, VAL x2);
static VAL mw_mirth_def_Def_typecheckZBang (VAL x1, VAL x2);
static void mw_mirth_def_Def_callableZAsk (VAL x1, VAL x2);
static void mw_mirth_def_Def_definesZ_aZ_typeZAsk (VAL x1, VAL x2);
static void mw_mirth_def_Def_exposedZ_tyconZAsk (VAL x1, VAL x2);
static void mw_mirth_def_Def_sameZ_resolvedZAsk (VAL x1, VAL x2, VAL x3);
static void mw_mirth_def_Def_resolve (VAL x1, VAL x2);
static uint64_t mw_mirth_def_Def_name (VAL x1);
static int64_t mw_mirth_def_Def_arity (VAL x1);
static void mw_mirth_def_Def_qnameZ_soft (VAL x1, VAL x2);
static void mw_mirth_def_Def_qnameZ_hard (VAL x1, VAL x2);
static void mw_mirth_def_Def_asZ_namespaceZAsk (VAL x1, VAL x2);
static VAL mw_mirth_def_Def_register (VAL x1, VAL x2);
static int64_t mw_mirth_name_Name_index (uint64_t x1);
static uint64_t mw_mirth_name_Name_fromZ_index (int64_t x1);
static uint64_t mw_mirth_name_Name_allocZBang (void);
static VAL mw_mirth_name_Name_ZToStr (uint64_t x1);
static VAL mw_mirth_name_Name_defs (uint64_t x1);
static VAL mw_mirth_name_Name_mangled (uint64_t x1);
static int64_t mw_mirth_name_Name_ZEqualZEqual (uint64_t x1, uint64_t x2);
static int64_t mw_mirth_name_Hash_ZToInt (int64_t x1);
static int64_t mw_std_prim_Int_ZToHash (int64_t x1);
static int64_t mw_mirth_name_HASHz_MAX (void);
static VAL mw_mirth_name_hashZ_nameZAt (int64_t x1);
static void mw_mirth_name_hashZ_nameZBang (uint64_t x1, int64_t x2);
static int64_t mw_std_prim_Str_hash (VAL x1);
static int64_t mw_mirth_name_Hash_next (int64_t x1);
static void mw_mirth_name_Hash_keepZ_goingZAsk (VAL x1, int64_t x2);
static uint64_t mw_std_prim_Str_ZToName (VAL x1);
static int64_t mw_mirth_name_Name_head (uint64_t x1);
static int64_t mw_mirth_name_Name_tailZ_head (uint64_t x1);
static int64_t mw_mirth_name_Name_canZ_beZ_relativeZAsk (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_var (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_con (uint64_t x1);
static int64_t mw_mirth_name_Name_isZ_typeZ_hole (uint64_t x1);
static int64_t mw_mirth_name_Name_isZ_underscore (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_stackZ_var (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_var (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_con (uint64_t x1);
static int64_t mw_mirth_name_Name_couldZ_beZ_constructor (uint64_t x1);
static VAL mw_mirth_name_Name_mangleZ_computeZBang (uint64_t x1);
static int64_t mw_mirth_name_Namespace_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_name_Namespace_qname (VAL x1, VAL x2);
static void mw_mirth_name_Namespace_moduleZAsk (VAL x1, VAL x2);
static void mw_mirth_name_Namespace_prim (VAL x1);
static void mw_mirth_name_Namespace_ZToStr (VAL x1, VAL x2);
static void mw_mirth_name_Namespace_mangled (VAL x1, VAL x2);
static VAL mw_mirth_name_QNAME0 (VAL x1, uint64_t x2);
static int64_t mw_mirth_name_QName_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_name_QName_defZ_hardZAsk (VAL x1, VAL x2);
static void mw_mirth_name_QName_definedZ_hardZAsk (VAL x1, VAL x2);
static void mw_mirth_name_QName_defZ_softZAsk (VAL x1, VAL x2);
static void mw_mirth_name_QName_definedZ_softZAsk (VAL x1, VAL x2);
static void mw_mirth_name_QName_undefinedZ_softZAsk (VAL x1, VAL x2);
static void mw_mirth_name_QName_prim (VAL x1, VAL x2, int64_t x3);
static void mw_mirth_name_QName_ZToStr (VAL x1, VAL x2);
static void mw_mirth_name_QName_toZ_moduleZ_path (VAL x1, VAL x2, VAL x3);
static void mw_mirth_name_QName_mangled (VAL x1, VAL x2);
static VAL mw_mirth_name_DName_rootZAsk (VAL x1);
static VAL mw_mirth_name_DName_parts (VAL x1);
static uint64_t mw_mirth_name_DName_lastZ_name (VAL x1);
static VAL mw_mirth_name_DName_penultimateZ_nameZAsk (VAL x1);
static int64_t mw_mirth_name_DName_isZ_relativeZAsk (VAL x1);
static int64_t mw_mirth_package_Package_index (uint64_t x1);
static uint64_t mw_mirth_package_Package_allocZBang (void);
static uint64_t mw_mirth_package_Package_name (uint64_t x1);
static VAL mw_mirth_package_Package_qname (uint64_t x1);
static VAL mw_mirth_package_Package_path (uint64_t x1);
static void mw_mirth_package_Package_std (VAL x1);
static VAL mw_mirth_package_initZ_packagesZBang (VAL x1);
static void mw_mirth_package_Package_pathZ_orZ_search (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_package_Package_pathZBang (VAL x1, uint64_t x2);
static void mw_mirth_package_Package_newZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_package_Package_newZ_orZ_pathZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_package_Package_find (VAL x1, uint64_t x2);
static void mw_mirth_package_Package_findZ_orZ_newZBang (VAL x1, uint64_t x2);
static int64_t mw_mirth_package_Package_ZEqualZEqual (uint64_t x1, uint64_t x2);
static VAL mw_mirth_lexer_lexerZ_stackZ_pushZBang (uint64_t x1, VAL x2);
static void mw_mirth_lexer_lexerZ_stackZ_popZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_stackZ_drop (VAL x1);
static void mw_mirth_lexer_lexerZ_stackZ_peek (VAL x1);
static void mw_mirth_lexer_runZ_lexerZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_lexer_ZPlusLexer_doneZAsk (VAL x1);
static void mw_mirth_lexer_lexerZ_makeZBang (VAL x1, VAL x2);
static VAL mw_mirth_lexer_lexerZ_emitZBang (VAL x1, VAL x2);
static void mw_mirth_lexer_lexerZ_nextZBang (VAL x1, VAL x2);
static VAL mw_mirth_lexer_lexerZ_newlineZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_emitZ_lcolonZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_closeZ_colonsZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_emitZ_lparenZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_rparenZBang (VAL x1, VAL x2);
static VAL mw_mirth_lexer_lexerZ_emitZ_lsquareZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_rsquareZBang (VAL x1, VAL x2);
static VAL mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang (VAL x1, VAL x2);
static VAL mw_mirth_lexer_lexerZ_emitZ_nameZBang (VAL x1);
static void mw_std_str_ZPlusStr_nameZAsk (VAL x1);
static void mw_std_str_ZPlusStr_firstZ_byte (VAL x1);
static void mw_std_str_ZPlusStr_secondZ_byte (VAL x1);
static void mw_std_str_ZPlusStr_thirdZ_byte (VAL x1);
static void mw_std_str_ZPlusStr_firstZ_twoZ_bytes (VAL x1, VAL x2);
static void mw_std_str_ZPlusStr_dropZ_firstZ_byte (VAL x1, VAL x2);
static void mw_std_str_ZPlusStr_dropZ_lastZ_byte (VAL x1, VAL x2);
static void mw_std_str_ZPlusStr_labelZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk (VAL x1);
static void mw_std_str_ZPlusStr_dnameZAsk (VAL x1);
static void mw_std_str_ZPlusStr_isZ_docZ_startZAsk (VAL x1);
static void mw_std_str_ZPlusStr_isZ_floatZAsk (VAL x1);
static void mw_std_str_ZPlusStr_floatZ_sign (VAL x1);
static void mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float (int64_t x1);
static void mw_std_str_ZPlusStr_floatZAsk (VAL x1);
static void mw_std_str_ZPlusStr_isZ_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_isZ_decZ_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_isZ_hexZ_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_isZ_octZ_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_intZ_sign (VAL x1);
static void mw_mirth_lexer_byteZ_signZ_valueZ_index (int64_t x1);
static void mw_std_str_ZPlusStr_decZ_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_hexZ_intZAsk (VAL x1);
static void mw_std_str_ZPlusStr_octZ_intZAsk (VAL x1);
static int64_t mw_mirth_lexer_hexdigitZ_value (int64_t x1);
static void mw_mirth_lexer_lexerZ_emitZ_stringZBang (VAL x1, VAL x2);
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4);
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4);
static VAL mw_mirth_lexer_lexerZ_skipZ_commentZBang (VAL x1);
static VAL mw_mirth_lexer_lexerZ_skipZ_docZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_commentZ_endZAsk (VAL x1);
static void mw_mirth_lexer_lexerZ_peek (VAL x1);
static VAL mw_mirth_lexer_lexerZ_moveZBang (VAL x1);
static void mw_mirth_lexer_lexerZ_location (VAL x1);
static void mw_mirth_lexer_lexerZ_emitZ_warningZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang (uint64_t x1);
static void mw_mirth_elab_ZPlusTypeElab_rdrop (VAL x1);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_resolveZ_defZ_beginZBang (VAL x1, uint64_t x2, int64_t x3, int64_t x4, VAL x5);
static void mw_mirth_elab_resolveZ_defZ_endZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusResolveDef_rdrop (VAL x1);
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous (VAL x1, VAL x2);
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_arity (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_roots (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3);
static int64_t mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk (uint64_t x1, VAL x2);
static void mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3);
static void mw_mirth_name_QName_climbZ_upZ_nameZAsk (VAL x1, uint64_t x2, VAL x3);
static void mw_mirth_name_QName_climbZ_upZ_dnameZAsk (VAL x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang (VAL x1, VAL x2);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4);
static void mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4);
static void mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_abZ_tokenZAt (VAL x1);
static VAL mw_mirth_elab_abZ_tokenZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_abZ_typeZAt (VAL x1);
static VAL mw_mirth_elab_abZ_typeZBang (VAL x1, VAL x2);
static void mw_mirth_elab_abZ_ctxZAt (VAL x1);
static void mw_mirth_elab_abZ_homeZAt (VAL x1);
static void mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home (VAL x1, uint64_t x2);
static void mw_mirth_elab_finalizzeZ_wordZ_arrow (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_elab_guessZ_initialZ_ctxZ_type (VAL x1, uint64_t x2);
static void mw_mirth_elab_abZ_unifyZ_typeZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_elab_abZ_atomZBang (VAL x1, VAL x2);
static VAL mw_mirth_elab_abZ_optimizzedZ_snocZBang (VAL x1, VAL x2);
static void mw_mirth_elab_atomZ_acceptsZ_argsZAsk (VAL x1);
static int64_t mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk (VAL x1);
static void mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg (VAL x1, VAL x2);
static void mw_mirth_elab_abZ_opZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_expandZ_opsigZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_intZBang (int64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_f64ZBang (double x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_strZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_bufferZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_variableZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_fieldZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_varZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_tagZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_primZBang (int64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_wordZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_externalZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_coerceZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_labelZ_pushZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_labelZ_popZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_labelZ_pushZ_rZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_abZ_labelZ_popZ_rZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_opZ_freshZ_sigZBang (VAL x1, VAL x2);
static void mw_mirth_elab_dataZ_getZ_tagZ_type (VAL x1, uint64_t x2);
static VAL mw_mirth_elab_elabZ_coerceZ_sigZBang (VAL x1);
static VAL mw_mirth_elab_elabZ_blockZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_matchZ_sigZBang (VAL x1);
static VAL mw_mirth_elab_elabZ_lambdaZ_sigZBang (VAL x1);
static VAL mw_mirth_elab_elabZ_varZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_popZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang (uint64_t x1);
static VAL mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang (uint64_t x1);
static void mw_mirth_elab_elabZ_arrowZ_homZBang (VAL x1, VAL x2, VAL x3, VAL x4, uint64_t x5, VAL x6);
static void mw_mirth_elab_elabZ_arrowZ_fwdZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5);
static void mw_mirth_elab_elabZ_atomsZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_atomZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_labelZ_getZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_labelZ_setZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_atomZ_blockZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_blockZ_atZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_argsZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_noZ_argsZBang (VAL x1, VAL x2);
static int64_t mw_mirth_elab_arityZ_compatibleZAsk (int64_t x1, int64_t x2);
static void mw_mirth_elab_elabZ_atomZ_nameZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_atomZ_dnameZBang (VAL x1, VAL x2, VAL x3);
static int64_t mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk (uint64_t x1);
static void mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_atomZ_failedZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_atomZ_defZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_primZBang (int64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_atomZ_assertZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_atomZ_matchZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_matchZ_atZBang (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_elab_elabZ_matchZ_casesZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_matchZ_caseZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_patternZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_patternZ_atomZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_expandZ_tensorZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_elab_elabZ_lambdaZ_paramZAsk (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_atomZ_lambdaZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_matchZ_exhaustiveZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_moduleZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_elabZ_moduleZ_packageZ_name (uint64_t x1, VAL x2);
static void mw_mirth_elab_elabZ_moduleZ_qname (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_moduleZ_headerZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_elab_checkZ_moduleZ_path (uint64_t x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_elab_elabZ_moduleZ_declZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_loadZ_module (uint64_t x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_elab_elabZ_moduleZ_importZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_parseZ_data (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_dataZ_header (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_dataZ_tags (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_dataZ_tag (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_struct (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_structZ_tag (VAL x1, uint64_t x2, uint64_t x3);
static void mw_mirth_elab_elabZ_dataZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_structZBang (VAL x1, uint64_t x2);
static VAL mw_mirth_elab_elabZ_dataZ_auxZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_dataZ_headerZBang (uint64_t x1, uint64_t x2, VAL x3);
static void mw_mirth_elab_elabZ_dataZ_paramsZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_dataZ_tagZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_dataZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4);
static VAL mw_mirth_elab_elabZ_dataZ_doneZBang (VAL x1, uint64_t x2);
static void mw_mirth_data_Tag_outputZ_type (VAL x1, uint64_t x2);
static void mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field (VAL x1, uint64_t x2, uint64_t x3);
static void mw_mirth_data_Tag_projectZ_inputZ_label (VAL x1, uint64_t x2, uint64_t x3);
static void mw_mirth_elab_dataZ_getZ_labelZ_type (VAL x1, uint64_t x2, uint64_t x3);
static void mw_mirth_elab_dataZ_setZ_labelZ_type (VAL x1, uint64_t x2, uint64_t x3);
static VAL mw_mirth_elab_createZ_projectorsZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_expectZ_tokenZ_arrow (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_alias (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_aliasZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_missingZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_inlineZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_elab_parseZ_def (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZBang (VAL x1, uint64_t x2);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang (VAL x1, uint64_t x2, uint64_t x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_paramsZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_bodyZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_elab_parseZ_externalZ_decl (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_externalZ_declZ_part (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_externalZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_externalZ_blockZ_partZBang (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_externalZ_defZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4);
static void mw_mirth_elab_elabZ_defZ_externalZ_ctype (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_typeZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_bufferZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_variableZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_tableZBang (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_entryZ_point (VAL x1, VAL x2);
static void mw_mirth_elab_elabZ_embedZ_strZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_elab_typecheckZ_everythingZBang (VAL x1);
static int64_t mw_mirth_elab_TABLEz_MAXz_COUNT (void);
static VAL mw_mirth_elab_tableZ_qname (uint64_t x1, VAL x2, int64_t x3);
static void mw_mirth_elab_tableZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4);
static void mw_mirth_elab_tableZ_newZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4);
static void mw_mirth_elab_resolveZ_defZ_namespace (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname (VAL x1, uint64_t x2, VAL x3, int64_t x4);
static int64_t mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk (uint64_t x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_qname (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_qnameZ_undefined (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_defZ_head (VAL x1, uint64_t x2);
static void mw_mirth_elab_parseZ_field (VAL x1, uint64_t x2);
static void mw_mirth_elab_elabZ_fieldZBang (VAL x1, uint64_t x2);
static VAL mw_std_map_Map_2_empty (void);
static VAL mw_std_map_Map_2_insert (VAL x1, VAL x2);
static void mw_mirth_specializzer_runZ_specializzerZBang (VAL x1, VAL x2);
static VAL mw_mirth_specializzer_ZPlusSPCheck_beginZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_endZBang (VAL x1);
static void mw_mirth_specializzer_ZPlusSPCheck_loopZBang (VAL x1, VAL x2);
static void mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang (uint64_t x1, VAL x2);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang (VAL x1, int64_t x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang (VAL x1, VAL x2, VAL x3, uint64_t x4);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang (uint64_t x1, VAL x2);
static int64_t mw_mirth_specializzer_SPKey_ZEqualZEqual (VAL x1, VAL x2);
static void mw_mirth_specializzer_SPKey_ZToStr (VAL x1, VAL x2);
static void mw_mirth_specializzer_SPKey_ZToName (VAL x1, VAL x2);
static VAL mw_mirth_word_Word_spZ_synthed (uint64_t x1);
static void mw_mirth_specializzer_specializzeZ_wordZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_specializzer_specializzeZ_ctxZ_type (VAL x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_specializzer_synthZ_specializzedZ_wordZBang (VAL x1, VAL x2, VAL x3, uint64_t x4);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang (VAL x1, VAL x2, uint64_t x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang (VAL x1, VAL x2, VAL x3);
static int64_t mw_std_set_SETz_INITIALz_SIZZE (void);
static VAL mw_std_set_ZPlusSet_new (void);
static void mw_std_set_ZPlusSet_rdrop (VAL x1);
static void mw_std_set_ZPlusSet_offsetZ_mask (int64_t x1, VAL x2);
static void mw_std_set_ZPlusSet_memberZAsk (int64_t x1, VAL x2);
static VAL mw_std_set_ZPlusSet_insertZBang (int64_t x1, VAL x2);
static int64_t mw_mirth_need_Need_ZToNat (VAL x1);
static VAL mw_mirth_need_ZPlusNeeds_new (void);
static void mw_mirth_need_ZPlusNeeds_rdrop (VAL x1);
static void mw_mirth_need_Need_neededZAsk (VAL x1, VAL x2);
static void mw_mirth_word_Word_neededZAsk (uint64_t x1, VAL x2);
static void mw_mirth_arrow_Block_neededZAsk (uint64_t x1, VAL x2);
static void mw_mirth_data_Tag_wordZ_neededZAsk (uint64_t x1, VAL x2);
static void mw_mirth_data_Tag_patZ_neededZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZBang (VAL x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_wordZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_blockZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang (uint64_t x1, VAL x2);
static void mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang (VAL x1, VAL x2);
static void mw_mirth_need_ZPlusNeeds_runZ_needZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_argsZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_argZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_blockZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_wordZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_arrowZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_atomZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_opZBang (VAL x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_need_ZPlusNeeds_runZ_primZBang (VAL x1, int64_t x2, VAL x3, VAL x4);
static void mw_mirth_need_ZPlusNeeds_runZ_matchZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_caseZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_patternZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_runZ_patatomZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_pushZ_argsZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_pushZ_argZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_need_ZPlusNeeds_pushZ_blockZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_ZPlusC99_put (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_putZ_byte (int64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_line (VAL x1);
static void mw_mirth_c99_c99Z_startZBang (VAL x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_c99_c99Z_endZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99_freshZ_natZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99_freshZ_nameZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang (VAL x1, VAL x2);
static void mw_mirth_c99_runZ_outputZ_c99ZBang (VAL x1, VAL x2, VAL x3, VAL x4);
static void mw_mirth_data_Tag_wordZ_cname (VAL x1, uint64_t x2);
static void mw_mirth_data_Tag_patZ_cname (VAL x1, uint64_t x2);
static void mw_mirth_buffer_Buffer_cname (VAL x1, uint64_t x2);
static void mw_mirth_variable_Variable_cname (VAL x1, uint64_t x2);
static void mw_mirth_table_Field_cname (VAL x1, uint64_t x2);
static void mw_mirth_external_External_cname (VAL x1, uint64_t x2);
static VAL mw_mirth_c99_ZPlusC99_sigZ_put (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_headerZ_str (void);
static VAL mw_mirth_c99_c99Z_headerZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_buffersZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_bufferZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_bufferZ_callZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_variablesZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_variableZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_variableZ_callZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_tagZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_tagZ_bodyZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_tagZ_defZBang (uint64_t x1, VAL x2);
static void mw_mirth_c99_c99Z_tagZ_labelZ_index (uint64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_tagZ_getZ_labelZBang (uint64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_tagZ_setZ_labelZBang (uint64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_externalZ_blocksZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_externalZ_blockZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_externalZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_type_CType_c99Z_popZ_value (VAL x1, VAL x2);
static VAL mw_mirth_type_CType_c99Z_popZ_resource (VAL x1, VAL x2);
static VAL mw_mirth_type_CType_c99Z_popZ_label (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_type_CType_c99Z_pushZ_value (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_CType_c99Z_pushZ_resource (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_type_CType_c99Z_pushZ_label (VAL x1, uint64_t x2, VAL x3, VAL x4);
static void mw_mirth_type_CTypeStackPart_c99Z_argZ_name (int64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_type_CTypeStackPart_c99Z_pop (VAL x1, VAL x2);
static VAL mw_mirth_type_CTypeStackPart_c99Z_push (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_ZPlusC99_indent (VAL x1);
static VAL mw_mirth_c99_c99Z_callZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_c99_C99APIArg_popZ_consumeZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_C99APIArg_pushZ_toZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_c99Z_smartZ_callZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_ZPlusC99_smartZ_sigZ_put (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_smartZ_sigZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_apiZ_enterZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_apiZ_exitZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_arrowZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_atomZBang (VAL x1, VAL x2);
static int64_t mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk (VAL x1);
static VAL mw_mirth_c99_c99Z_atomZ_opZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_c99Z_getZ_dataZ_tagZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_data_Tag_valueZ_show (uint64_t x1);
static VAL mw_mirth_c99_c99Z_tagZ_callZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_reverseZ_tagZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_labelZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_labelZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_pushZ_localZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_pushZ_localZ_labelZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_c99_popZ_localZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3);
static void mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_pushZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_pushZ_rZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_popZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_labelZ_popZ_rZBang (VAL x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_intZBang (int64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_f64ZBang (double x1, VAL x2);
static VAL mw_mirth_c99_c99Z_strZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_putZ_cstrZ_long (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_putZ_cstr (VAL x1, VAL x2);
static void mw_mirth_c99_c99Z_stringZ_byteZBang (int64_t x1, int64_t x2, VAL x3);
static int64_t mw_mirth_c99_C99ReprType_ZEqualZEqual (int64_t x1, int64_t x2);
static int64_t mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk (int64_t x1);
static int64_t mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_vZ_macro (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_mkZ_macro (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_popZ_macro (int64_t x1);
static VAL mw_mirth_c99_C99ReprType_pushZ_macro (int64_t x1);
static void mw_mirth_type_Resource_c99Z_repr (VAL x1, VAL x2);
static void mw_mirth_type_Type_c99Z_repr (VAL x1, VAL x2);
static int64_t mw_mirth_type_PrimType_c99Z_repr (int64_t x1);
static void mw_mirth_data_Data_c99Z_repr (uint64_t x1, VAL x2);
static void mw_mirth_type_StackType_c99Z_reprZ_semiZ_transparent (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Local_rdup (VAL x1);
static void mw_mirth_c99_ZPlusC99Local_rdrop (VAL x1);
static void mw_mirth_c99_C99ReprType_newZ_localZBang (int64_t x1, VAL x2);
static void mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang (int64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99Local_consume (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_as (int64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99Local_dropZ_localZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Local_dupZ_localZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Local_peekZ_dataZ_tag (VAL x1);
static void mw_mirth_c99_ZPlusC99LocalResource_rdup (VAL x1);
static void mw_mirth_c99_ZPlusC99LocalResource_rdrop (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalResource_dropZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99LocalResource_dupZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99LocalResource_consume (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL (VAL x1);
static void mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang (VAL x1, int64_t x2);
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99LocalResource_peekZ_dataZ_tag (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_peekZ_dataZ_tag (VAL x1);
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup (VAL x1);
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop (VAL x1);
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL (VAL x1);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang (uint64_t x1, VAL x2);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk (VAL x1);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk (VAL x1);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk (uint64_t x1, VAL x2);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99StackCache_rdup (VAL x1);
static void mw_mirth_c99_ZPlusC99StackCache_rdrop (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1 (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_startZ_branchZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang (VAL x1);
static VAL mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang (VAL x1);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang (VAL x1, int64_t x2);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang (int64_t x1, uint64_t x2, VAL x3);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang (VAL x1, int64_t x2);
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang (int64_t x1, uint64_t x2, VAL x3);
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_binopZ_exprZBang (VAL x1, VAL x2, VAL x3, VAL x4);
static VAL mw_mirth_c99_c99Z_binopZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_C99BinOp_Mk (VAL x1, int64_t x2, VAL x3, int64_t x4, VAL x5, int64_t x6, VAL x7);
static VAL mw_mirth_c99_c99Z_primZ_binopZAsk (int64_t x1);
static VAL mw_mirth_c99_c99Z_unopZ_exprZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_c99Z_unopZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_C99UnOp_Mk (VAL x1, int64_t x2, VAL x3, VAL x4);
static VAL mw_mirth_c99_c99Z_primZ_unopZAsk (int64_t x1);
static void mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3);
static VAL mw_mirth_c99_c99Z_primZBang (VAL x1, int64_t x2, VAL x3);
static VAL mw_mirth_c99_c99Z_argsZ_pushZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_argZ_pushZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_argZ_runZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_runZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_ZPlusC99_varZ_put (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_packZ_closureZ_varsZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_popZ_toZ_varZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_pushZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_varZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_varZ_runZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_varZ_pushZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_lambdaZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_matchZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_singleZ_caseZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_caseZBang (VAL x1, VAL x2, VAL x3);
static void mw_mirth_data_Tag_wordZ_cnameZ_type (uint64_t x1, VAL x2);
static void mw_mirth_data_Tag_patZ_cnameZ_type (uint64_t x1, VAL x2);
static void mw_mirth_word_Word_cnameZ_type (uint64_t x1, VAL x2);
static void mw_mirth_data_Tag_wordZ_c99Z_api (uint64_t x1, VAL x2);
static void mw_mirth_data_Tag_patZ_c99Z_api (uint64_t x1, VAL x2);
static void mw_mirth_word_Word_c99Z_api (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_sigsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_wordZ_sigZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_sigsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_blockZ_sigZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_enterZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_exitZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_blockZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_blockZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_exposeZ_stackZ_typeZBang (VAL x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_enterZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_exitZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_wordZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_wordZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_fieldZ_sigZ_put (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_fieldZ_sigsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_fieldZ_sigZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_fieldZ_defsZBang (VAL x1);
static VAL mw_mirth_c99_c99Z_fieldZ_defZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_fieldZ_callZBang (uint64_t x1, VAL x2);
static VAL mw_mirth_c99_c99Z_mainZBang (VAL x1, VAL x2);
static VAL mw_mirth_main_Arguments_default (void);
static void mw_mirth_main_compileZBang (VAL x1, VAL x2, VAL x3);
static VAL mw_mirth_main_parseZ_packageZ_def (VAL x1);
static void mw_mirth_main_compilerZ_parseZ_args (VAL x1, VAL x2, VAL x3, VAL x4);
static VAL mw_mirth_main_main (VAL x1);
static void mb_mirth_main_main_1 (void);
static void mb_std_prim_Str_ZToName_2 (void);
static void mb_mirth_elab_elabZ_blockZ_atZBang_1 (void);
static void mb_mirth_elab_elabZ_defZBang_0 (void);
static void mb_mirth_elab_elabZ_defZBang_2 (void);
static void mb_mirth_elab_elabZ_defZBang_3 (void);
static void mb_mirth_elab_elabZ_defZ_typeZBang_2 (void);
static void mb_mirth_elab_elabZ_variableZBang_1 (void);
static void mb_mirth_elab_elabZ_fieldZBang_2 (void);
static void mb_mirth_elab_elabZ_fieldZBang_3 (void);
static void mb_mirth_elab_elabZ_dataZ_headerZBang_2 (void);
static void mb_mirth_elab_elabZ_dataZ_tagZBang_1 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_5 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_6 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_12 (void);
static void mb_mirth_elab_elabZ_defZ_head_3 (void);
static void mb_mirth_elab_createZ_projectorsZBang_15 (void);
static void mb_mirth_elab_elabZ_externalZ_defZBang_2 (void);
static void mb_mirth_elab_elabZ_externalZ_defZBang_4 (void);
static void mb_mirth_c99_c99Z_primZBang_6 (void);
static void mb_mirth_c99_c99Z_primZBang_9 (void);
static void mb_mirth_c99_c99Z_matchZBang_11 (void);
static void mb_mirth_c99_c99Z_caseZBang_4 (void);
static void mb_mirth_c99_c99Z_caseZBang_10 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot81ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot63ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot215ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot127ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot107ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot86ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot66ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_aliasZBangZDot16ZRParen_1 (void);
static void* mfld_mirth_label_Label_ZTildename (uint64_t i);
static void* mfld_mirth_var_Var_ZTildename (uint64_t i);
static void* mfld_mirth_var_Var_ZTildetype (uint64_t i);
static void* mfld_mirth_var_Var_ZTildeautoZ_runZAsk (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildehead (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildesizze (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildeqname (uint64_t i);
static void* mfld_mirth_word_Word_ZTildename (uint64_t i);
static void* mfld_mirth_word_Word_ZTildearity (uint64_t i);
static void* mfld_mirth_word_Word_ZTildeqname (uint64_t i);
static void* mfld_mirth_word_Word_ZTildehead (uint64_t i);
static void* mfld_mirth_word_Word_ZTildesigZAsk (uint64_t i);
static void* mfld_mirth_word_Word_ZTildebody (uint64_t i);
static void* mfld_mirth_word_Word_ZTildectxZ_type (uint64_t i);
static void* mfld_mirth_word_Word_ZTildeparams (uint64_t i);
static void* mfld_mirth_word_Word_ZTildearrow (uint64_t i);
static void* mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk (uint64_t i);
static void* mfld_mirth_word_Word_ZTildecname (uint64_t i);
static void* mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk (uint64_t i);
static void* mfld_mirth_word_Word_ZTildenumZ_blocks (uint64_t i);
static void* mfld_mirth_table_Table_ZTildehead (uint64_t i);
static void* mfld_mirth_table_Table_ZTildename (uint64_t i);
static void* mfld_mirth_table_Table_ZTildeqname (uint64_t i);
static void* mfld_mirth_table_Table_ZTildenumZ_buffer (uint64_t i);
static void* mfld_mirth_table_Table_ZTildemaxZ_count (uint64_t i);
static void* mfld_mirth_table_Field_ZTildehead (uint64_t i);
static void* mfld_mirth_table_Field_ZTildename (uint64_t i);
static void* mfld_mirth_table_Field_ZTildeqname (uint64_t i);
static void* mfld_mirth_table_Field_ZTildeindexZ_type (uint64_t i);
static void* mfld_mirth_table_Field_ZTildevalueZ_type (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeheadZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeqname (uint64_t i);
static void* mfld_mirth_data_Data_ZTildename (uint64_t i);
static void* mfld_mirth_data_Data_ZTildearity (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeparams (uint64_t i);
static void* mfld_mirth_data_Data_ZTildetags (uint64_t i);
static void* mfld_mirth_data_Data_ZTildectypeZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildelastZ_tagZ_value (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_unitZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_enumZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_transparentZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_semiZ_transparentZAsk (uint64_t i);
static void* mfld_mirth_data_Data_ZTildeisZ_resourceZAsk (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildedata (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildeqname (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildevalue (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildelabelZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildesigZAsk (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildectxZ_type (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildeuntag (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs (uint64_t i);
static void* mfld_mirth_external_External_ZTildename (uint64_t i);
static void* mfld_mirth_external_External_ZTildearity (uint64_t i);
static void* mfld_mirth_external_External_ZTildeqname (uint64_t i);
static void* mfld_mirth_external_External_ZTildesymbol (uint64_t i);
static void* mfld_mirth_external_External_ZTildehead (uint64_t i);
static void* mfld_mirth_external_External_ZTildesig (uint64_t i);
static void* mfld_mirth_external_External_ZTildectxZ_type (uint64_t i);
static void* mfld_mirth_external_External_ZTildectype (uint64_t i);
static void* mfld_mirth_external_ExternalBlock_ZTildetoken (uint64_t i);
static void* mfld_mirth_external_ExternalBlock_ZTildeparts (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildehead (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildeqname (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildetype (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildectx (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildetoken (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildehome (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildedom (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildecod (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildearrow (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildeqname (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildehomeZ_index (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildecname (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildefreeZ_vars (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildeheadZAsk (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildename (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildeqname (uint64_t i);
static void* mfld_mirth_typedef_TypeDef_ZTildetarget (uint64_t i);
static void* mfld_mirth_type_MetaVar_ZTildetypeZAsk (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildename (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildectx (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildetype (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildedecl (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildearity (uint64_t i);
static void* mfld_mirth_token_Token_ZTildevalue (uint64_t i);
static void* mfld_mirth_token_Token_ZTildemodule (uint64_t i);
static void* mfld_mirth_token_Token_ZTilderow (uint64_t i);
static void* mfld_mirth_token_Token_ZTildecol (uint64_t i);
static void* mfld_mirth_module_Module_ZTildepackage (uint64_t i);
static void* mfld_mirth_module_Module_ZTildename (uint64_t i);
static void* mfld_mirth_module_Module_ZTildepath (uint64_t i);
static void* mfld_mirth_module_Module_ZTildestart (uint64_t i);
static void* mfld_mirth_module_Module_ZTildeend (uint64_t i);
static void* mfld_mirth_module_Module_ZTildeimports (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildehead (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildename (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildearity (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildeqname (uint64_t i);
static void* mfld_mirth_alias_Alias_ZTildetarget (uint64_t i);
static void* mfld_mirth_name_Name_ZTildeStr (uint64_t i);
static void* mfld_mirth_name_Name_ZTildedefs (uint64_t i);
static void* mfld_mirth_name_Name_ZTildemangled (uint64_t i);
static void* mfld_mirth_name_Name_ZTildelabel (uint64_t i);
static void* mfld_mirth_package_Package_ZTildename (uint64_t i);
static void* mfld_mirth_package_Package_ZTildepath (uint64_t i);
static void* mfld_mirth_word_Word_ZTildespZ_checked (uint64_t i);
static void* mfld_mirth_arrow_Block_ZTildespZ_checked (uint64_t i);
static void* mfld_mirth_word_Word_ZTildespZ_synthed (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildewordZ_cname (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildepatZ_cname (uint64_t i);
static void* mfld_mirth_buffer_Buffer_ZTildecname (uint64_t i);
static void* mfld_mirth_variable_Variable_ZTildecname (uint64_t i);
static void* mfld_mirth_table_Field_ZTildecname (uint64_t i);
static void* mfld_mirth_external_External_ZTildecname (uint64_t i);
static void* mfld_mirth_prim_Prim_ZTildecname (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildevalueZ_show (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildewordZ_c99Z_api (uint64_t i);
static void* mfld_mirth_data_Tag_ZTildepatZ_c99Z_api (uint64_t i);
static void* mfld_mirth_word_Word_ZTildec99Z_api (uint64_t i);
int main (int argc, char** argv) {
	global_argc = argc;
	global_argv = argv;
	int64_t v0 = (0 /* The World! */);
	VAL v1 = (mw_mirth_main_main(MKI64(v0)));
	push_resource(v1);
	return 0;
}
static void* mfld_mirth_label_Label_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_var_Var_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_var_Var_ZTildetype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_var_Var_ZTildeautoZ_runZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildesizze (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildesigZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildebody (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildectxZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildeparams (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildearrow (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildenumZ_blocks (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildenumZ_buffer (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Table_ZTildemaxZ_count (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildeindexZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildevalueZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeheadZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeparams (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildetags (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildectypeZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildelastZ_tagZ_value (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_unitZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_enumZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_transparentZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_semiZ_transparentZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Data_ZTildeisZ_resourceZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildedata (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildevalue (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildelabelZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildesigZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildectxZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildeuntag (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildesymbol (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildesig (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildectxZ_type (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildectype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_ExternalBlock_ZTildetoken (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_ExternalBlock_ZTildeparts (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildetype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildectx (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildetoken (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildehome (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildedom (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildecod (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildearrow (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildehomeZ_index (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildefreeZ_vars (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildeheadZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_typedef_TypeDef_ZTildetarget (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_type_MetaVar_ZTildetypeZAsk (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildectx (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildetype (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildedecl (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTildevalue (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTildemodule (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTilderow (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_token_Token_ZTildecol (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildepackage (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildepath (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildestart (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildeend (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_module_Module_ZTildeimports (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildehead (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildearity (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildeqname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_alias_Alias_ZTildetarget (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildeStr (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildedefs (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildemangled (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_name_Name_ZTildelabel (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_package_Package_ZTildename (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_package_Package_ZTildepath (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildespZ_checked (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_arrow_Block_ZTildespZ_checked (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildespZ_synthed (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildewordZ_cname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildepatZ_cname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_buffer_Buffer_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_variable_Variable_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_table_Field_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_external_External_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_prim_Prim_ZTildecname (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildevalueZ_show (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildewordZ_c99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_data_Tag_ZTildepatZ_c99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static void* mfld_mirth_word_Word_ZTildec99Z_api (uint64_t i) {
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	return (void*)(p+i);
}

static VAL mw_std_either_Either_2_leftZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Left
			VAL v0 = mtp_std_either_Either_2_Left(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 1LL: { // Right
			VAL v2 = mtp_std_either_Either_2_Right(x1);
			decref(v2);
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	return v4;
}
static int64_t mw_std_prim_Int_ZToByte (int64_t x1) {
	int64_t v0 = 0LL;
	int64_t v1 = 255LL;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	if (v4) {
		push_i64(x1);
	} else {
		STR* v5;
		STRLIT(v5, "Int->Byte out of range", 22);
		STR* v6;
		STRLIT(v6, "assertion failed: ", 18);
		STR* v7 = str_cat(v6, v5);
		push_i64(x1);
		push_str(v7);
		do_panic();
	}
	int64_t v8 = pop_i64();
	return v8;
}
static int64_t mw_std_prim_U8_ZToByte (int64_t x1) {
	int64_t v0 = mw_std_prim_Int_ZToByte(x1);
	return v0;
}
static void mw_std_prim_Ptr_ZAtByte (VAL x1, VAL x2) {
	uint8_t v0 = *(uint8_t*)VPTR(x1);
	push_resource(x2);
	int64_t v1 = mw_std_prim_U8_ZToByte(((int64_t)v0));
	push_i64(v1);
}
static int64_t mw_std_byte_Byte_isZ_upper (int64_t x1) {
	int64_t v0 = 65LL /* B'A' */;
	int64_t v1 = 90LL /* B'Z' */;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	return ((int64_t)v4);
}
static int64_t mw_std_byte_Byte_isZ_lower (int64_t x1) {
	int64_t v0 = 97LL /* B'a' */;
	int64_t v1 = 122LL /* B'z' */;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	return ((int64_t)v4);
}
static int64_t mw_std_byte_Byte_isZ_digit (int64_t x1) {
	int64_t v0 = 48LL /* B'0' */;
	int64_t v1 = 57LL /* B'9' */;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	return ((int64_t)v4);
}
static int64_t mw_std_byte_Byte_isZ_alpha (int64_t x1) {
	push_i64(x1);
	int64_t v0 = mw_std_byte_Byte_isZ_upper(x1);
	if (((bool)v0)) {
		int64_t v1 = pop_i64();
		int64_t v2 = 1LL /* True */;
		push_i64(v2);
	} else {
		int64_t v3 = pop_i64();
		int64_t v4 = mw_std_byte_Byte_isZ_lower(v3);
		push_i64(v4);
	}
	int64_t v5 = pop_i64();
	return v5;
}
static int64_t mw_std_byte_Byte_isZ_alnum (int64_t x1) {
	push_i64(x1);
	int64_t v0 = mw_std_byte_Byte_isZ_digit(x1);
	if (((bool)v0)) {
		int64_t v1 = pop_i64();
		int64_t v2 = 1LL /* True */;
		push_i64(v2);
	} else {
		int64_t v3 = pop_i64();
		int64_t v4 = mw_std_byte_Byte_isZ_alpha(v3);
		push_i64(v4);
	}
	int64_t v5 = pop_i64();
	return v5;
}
static int64_t mw_std_byte_Byte_isZ_printable (int64_t x1) {
	int64_t v0 = 33LL /* B'!' */;
	int64_t v1 = 126LL /* B'~' */;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	return ((int64_t)v4);
}
static int64_t mw_std_byte_Byte_isZ_hexdigit (int64_t x1) {
	switch (x1) {
		case 48LL: { // B'0'
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 49LL: { // B'1'
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 50LL: { // B'2'
			int64_t v2 = 1LL /* True */;
			push_i64(v2);
		} break;
		case 51LL: { // B'3'
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 52LL: { // B'4'
			int64_t v4 = 1LL /* True */;
			push_i64(v4);
		} break;
		case 53LL: { // B'5'
			int64_t v5 = 1LL /* True */;
			push_i64(v5);
		} break;
		case 54LL: { // B'6'
			int64_t v6 = 1LL /* True */;
			push_i64(v6);
		} break;
		case 55LL: { // B'7'
			int64_t v7 = 1LL /* True */;
			push_i64(v7);
		} break;
		case 56LL: { // B'8'
			int64_t v8 = 1LL /* True */;
			push_i64(v8);
		} break;
		case 57LL: { // B'9'
			int64_t v9 = 1LL /* True */;
			push_i64(v9);
		} break;
		case 65LL: { // B'A'
			int64_t v10 = 1LL /* True */;
			push_i64(v10);
		} break;
		case 66LL: { // B'B'
			int64_t v11 = 1LL /* True */;
			push_i64(v11);
		} break;
		case 67LL: { // B'C'
			int64_t v12 = 1LL /* True */;
			push_i64(v12);
		} break;
		case 68LL: { // B'D'
			int64_t v13 = 1LL /* True */;
			push_i64(v13);
		} break;
		case 69LL: { // B'E'
			int64_t v14 = 1LL /* True */;
			push_i64(v14);
		} break;
		case 70LL: { // B'F'
			int64_t v15 = 1LL /* True */;
			push_i64(v15);
		} break;
		case 97LL: { // B'a'
			int64_t v16 = 1LL /* True */;
			push_i64(v16);
		} break;
		case 98LL: { // B'b'
			int64_t v17 = 1LL /* True */;
			push_i64(v17);
		} break;
		case 99LL: { // B'c'
			int64_t v18 = 1LL /* True */;
			push_i64(v18);
		} break;
		case 100LL: { // B'd'
			int64_t v19 = 1LL /* True */;
			push_i64(v19);
		} break;
		case 101LL: { // B'e'
			int64_t v20 = 1LL /* True */;
			push_i64(v20);
		} break;
		case 102LL: { // B'f'
			int64_t v21 = 1LL /* True */;
			push_i64(v21);
		} break;
		default: {
			int64_t v22 = 0LL /* False */;
			push_i64(v22);
		} break;
	}
	int64_t v23 = pop_i64();
	return v23;
}
static VAL mw_std_byte_Byte_emitZ_asciiZThen (VAL x1, int64_t x2) {
	VAL v0 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(x2, x1));
	return v0;
}
static VAL mw_std_byte_Byte_toZ_strZ_unsafe (int64_t x1) {
	int64_t v0 = 0LL /* Nil */;
	VAL v1 = mtw_std_list_List_1_Cons(MKI64(x1), MKI64(v0));
	VAL v2 = mw_std_prim_Str_fromZ_bytesZ_unsafe(v1);
	return v2;
}
static VAL mw_std_byte_Byte_toZ_asciiZ_str (int64_t x1) {
	int64_t v0 = 0LL /* BNUL */;
	int64_t v1 = 127LL /* BDEL */;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	if (v4) {
		VAL v5 = mw_std_byte_Byte_toZ_strZ_unsafe(x1);
		VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
		push_value(v6);
	} else {
		int64_t v7 = 0LL /* None */;
		push_i64(v7);
	}
	VAL v8 = pop_value();
	return v8;
}
static int64_t mw_std_byte_Byte_isZ_stringZ_end (int64_t x1) {
	switch (x1) {
		case 34LL: { // BQUOTE
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 10LL: { // BLF
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 0LL: { // BNUL
			int64_t v2 = 1LL /* True */;
			push_i64(v2);
		} break;
		default: {
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
	}
	int64_t v4 = pop_i64();
	return v4;
}
static void mw_std_byte_Byte_toZ_hexdigits (int64_t x1) {
	int64_t v0 = 4LL;
	uint64_t v1 = u64_shr(((uint64_t)x1), ((uint64_t)v0));
	push_i64(x1);
	int64_t v2 = mw_std_byte_oneZ_hexdigitZ_byte(((int64_t)v1));
	int64_t v3 = pop_i64();
	int64_t v4 = 15LL;
	uint64_t v5 = (((uint64_t)v3) & ((uint64_t)v4));
	push_i64(v2);
	int64_t v6 = mw_std_byte_oneZ_hexdigitZ_byte(((int64_t)v5));
	push_i64(v6);
}
static int64_t mw_std_byte_oneZ_hexdigitZ_byte (int64_t x1) {
	int64_t v0 = 9LL;
	bool v1 = (x1 > v0);
	if (v1) {
		int64_t v2 = 55LL;
		push_i64(x1);
		push_i64(v2);
	} else {
		int64_t v3 = 48LL;
		push_i64(x1);
		push_i64(v3);
	}
	int64_t v4 = pop_i64();
	int64_t v5 = pop_i64();
	int64_t v6 = i64_add(v5, v4);
	int64_t v7 = mw_std_prim_Int_ZToByte(v6);
	return v7;
}
static int64_t mw_std_byte_Byte_isZ_nameZ_byte (int64_t x1) {
	switch (x1) {
		case 40LL: { // BLPAREN
			int64_t v0 = 0LL /* False */;
			push_i64(v0);
		} break;
		case 41LL: { // BRPAREN
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
		case 91LL: { // BLSQUARE
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
		case 93LL: { // BRSQUARE
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		case 123LL: { // BLCURLY
			int64_t v4 = 0LL /* False */;
			push_i64(v4);
		} break;
		case 125LL: { // BRCURLY
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
		case 44LL: { // BCOMMA
			int64_t v6 = 0LL /* False */;
			push_i64(v6);
		} break;
		case 34LL: { // BQUOTE
			int64_t v7 = 0LL /* False */;
			push_i64(v7);
		} break;
		case 58LL: { // BCOLON
			int64_t v8 = 0LL /* False */;
			push_i64(v8);
		} break;
		case 127LL: { // BDEL
			int64_t v9 = 0LL /* False */;
			push_i64(v9);
		} break;
		default: {
			int64_t v10 = 32LL /* BSPACE */;
			bool v11 = (x1 > v10);
			push_bool(v11);
		} break;
	}
	int64_t v12 = pop_i64();
	return v12;
}
static int64_t mw_std_byte_Byte_isZ_sign (int64_t x1) {
	switch (x1) {
		case 45LL: { // B'-'
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 43LL: { // B'+'
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		default: {
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
	}
	int64_t v3 = pop_i64();
	return v3;
}
static VAL mw_std_byte_Byte_zzencode (int64_t x1) {
	switch (x1) {
		case 38LL: { // B'&'
			STR* v0;
			STRLIT(v0, "ZAmp", 4);
			push_str(v0);
		} break;
		case 63LL: { // B'?'
			STR* v1;
			STRLIT(v1, "ZAsk", 4);
			push_str(v1);
		} break;
		case 64LL: { // B'@'
			STR* v2;
			STRLIT(v2, "ZAt", 3);
			push_str(v2);
		} break;
		case 92LL: { // B'\'
			STR* v3;
			STRLIT(v3, "ZBSlash", 7);
			push_str(v3);
		} break;
		case 33LL: { // B'!'
			STR* v4;
			STRLIT(v4, "ZBang", 5);
			push_str(v4);
		} break;
		case 94LL: { // B'^'
			STR* v5;
			STRLIT(v5, "ZCaret", 6);
			push_str(v5);
		} break;
		case 58LL: { // BCOLON
			STR* v6;
			STRLIT(v6, "ZColon", 6);
			push_str(v6);
		} break;
		case 44LL: { // BCOMMA
			STR* v7;
			STRLIT(v7, "ZComma", 6);
			push_str(v7);
		} break;
		case 47LL: { // B'/'
			STR* v8;
			STRLIT(v8, "ZDiv", 4);
			push_str(v8);
		} break;
		case 36LL: { // B'$'
			STR* v9;
			STRLIT(v9, "ZDollar", 7);
			push_str(v9);
		} break;
		case 46LL: { // BDOT
			STR* v10;
			STRLIT(v10, "ZDot", 4);
			push_str(v10);
		} break;
		case 61LL: { // B'='
			STR* v11;
			STRLIT(v11, "ZEqual", 6);
			push_str(v11);
		} break;
		case 35LL: { // BHASH
			STR* v12;
			STRLIT(v12, "ZHash", 5);
			push_str(v12);
		} break;
		case 123LL: { // BLCURLY
			STR* v13;
			STRLIT(v13, "ZLCurly", 7);
			push_str(v13);
		} break;
		case 40LL: { // BLPAREN
			STR* v14;
			STRLIT(v14, "ZLParen", 7);
			push_str(v14);
		} break;
		case 91LL: { // BLSQUARE
			STR* v15;
			STRLIT(v15, "ZLSquare", 8);
			push_str(v15);
		} break;
		case 60LL: { // B'<'
			STR* v16;
			STRLIT(v16, "ZLess", 5);
			push_str(v16);
		} break;
		case 37LL: { // B'%'
			STR* v17;
			STRLIT(v17, "ZMod", 4);
			push_str(v17);
		} break;
		case 42LL: { // B'*'
			STR* v18;
			STRLIT(v18, "ZMul", 4);
			push_str(v18);
		} break;
		case 124LL: { // B'|'
			STR* v19;
			STRLIT(v19, "ZPipe", 5);
			push_str(v19);
		} break;
		case 43LL: { // B'+'
			STR* v20;
			STRLIT(v20, "ZPlus", 5);
			push_str(v20);
		} break;
		case 34LL: { // BQUOTE
			STR* v21;
			STRLIT(v21, "ZQuote", 6);
			push_str(v21);
		} break;
		case 125LL: { // BRCURLY
			STR* v22;
			STRLIT(v22, "ZRCurly", 7);
			push_str(v22);
		} break;
		case 41LL: { // BRPAREN
			STR* v23;
			STRLIT(v23, "ZRParen", 7);
			push_str(v23);
		} break;
		case 93LL: { // BRSQUARE
			STR* v24;
			STRLIT(v24, "ZRSquare", 8);
			push_str(v24);
		} break;
		case 59LL: { // B';'
			STR* v25;
			STRLIT(v25, "ZThen", 5);
			push_str(v25);
		} break;
		case 39LL: { // BTICK
			STR* v26;
			STRLIT(v26, "ZTick", 5);
			push_str(v26);
		} break;
		case 126LL: { // B'~'
			STR* v27;
			STRLIT(v27, "ZTilde", 6);
			push_str(v27);
		} break;
		case 62LL: { // B'>'
			STR* v28;
			STRLIT(v28, "ZTo", 3);
			push_str(v28);
		} break;
		case 90LL: { // B'Z'
			STR* v29;
			STRLIT(v29, "ZZ", 2);
			push_str(v29);
		} break;
		case 45LL: { // B'-'
			STR* v30;
			STRLIT(v30, "Z_", 2);
			push_str(v30);
		} break;
		case 122LL: { // B'z'
			STR* v31;
			STRLIT(v31, "zz", 2);
			push_str(v31);
		} break;
		case 95LL: { // B'_'
			STR* v32;
			STRLIT(v32, "z_", 2);
			push_str(v32);
		} break;
		default: {
			push_i64(x1);
			int64_t v33 = mw_std_byte_Byte_isZ_alnum(x1);
			if (((bool)v33)) {
				int64_t v34 = pop_i64();
				VAL v35 = mw_std_byte_Byte_toZ_strZ_unsafe(v34);
				push_value(v35);
			} else {
				STR* v36;
				STRLIT(v36, "", 0);
				STR* v37;
				STRLIT(v37, "Z", 1);
				VAL v38 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v37), MKSTR(v36)));
				int64_t v39 = pop_i64();
				STR* v40 = i64_show(v39);
				VAL v41 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v40), v38));
				STR* v42;
				STRLIT(v42, "U", 1);
				VAL v43 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v42), v41));
				push_value(v43);
			}
		} break;
	}
	VAL v44 = pop_value();
	return v44;
}
static VAL mw_std_buffer_ZPlusBuffer_new (int64_t x1) {
	int64_t v0 = (0LL /* +Unsafe */);
	void* v1 = ptr_alloc(((uint64_t)x1));;
	VAL v2 = (mtw_std_buffer_ZPlusBuffer_ZPlusBuffer(x1, MKPTR(v1)));
	int64_t v3 = 0LL;
	int64_t v4 = VI64(VTUP(v2)->cells[1]);
	VAL v5 = (mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang(v3, v4, v2));
	return v5;
}
static VAL mw_std_buffer_ZPlusBuffer_resizzeZBang (int64_t x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[1]);
	VTUP(x2)->cells[1] = MKI64(x1);
	int64_t v1 = VI64(VTUP(x2)->cells[1]);
	VAL v2 = VVAL(VTUP(x2)->cells[2]);
	incref(v2);
	int64_t v3 = (0LL /* +Unsafe */);
	void* v4 = ptr_realloc(VPTR(v2),((uint64_t)v1));
	VAL v5 = VTUP(x2)->cells[2];
	decref(v5);
	VTUP(x2)->cells[2] = MKPTR(v4);
	int64_t v6 = VI64(VTUP(x2)->cells[1]);
	bool v7 = (v0 < v6);
	if (v7) {
		int64_t v8 = VI64(VTUP(x2)->cells[1]);
		int64_t v9 = i64_sub(v8, v0);
		push_i64(v0);
		push_resource(x2);
		int64_t v10 = mw_std_prim_Int_ZToNat(v9);
		VAL r11 = pop_resource();
		int64_t v12 = pop_i64();
		VAL v13 = (mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang(v12, v10, r11));
		push_resource(v13);
	} else {
		push_resource(x2);
	}
	VAL r14 = pop_resource();
	return r14;
}
static VAL mw_std_buffer_ZPlusBuffer_expandZBang (int64_t x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[1]);
	bool v1 = (x1 > v0);
	if (v1) {
		int64_t v2 = VI64(VTUP(x2)->cells[1]);
		int64_t v3 = 2LL;
		int64_t v4 = i64_mul(v2, v3);
		push_resource(x2);
		int64_t v5 = mw_std_prelude_Sizze_max(x1, v4);
		VAL r6 = pop_resource();
		VAL v7 = (mw_std_buffer_ZPlusBuffer_resizzeZBang(v5, r6));
		push_resource(v7);
	} else {
		push_resource(x2);
	}
	VAL r8 = pop_resource();
	return r8;
}
static void mw_std_buffer_ZPlusBuffer_rdrop (VAL x1) {
	mtp_std_buffer_ZPlusBuffer_ZPlusBuffer(x1);
	VAL v0 = lpop(&lbl_base);
	int64_t v1 = (0LL /* +Unsafe */);
	free(VPTR(v0));
	int64_t v2 = VI64(lpop(&lbl_sizze));
}
static VAL mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang (int64_t x1, int64_t x2, VAL x3) {
	push_i64(x1);
	push_i64(x2);
	VAL v0 = (mw_std_buffer_ZPlusBuffer_checkZ_spanZBang(x1, x2, x3));
	int64_t v1 = pop_i64();
	int64_t v2 = pop_i64();
	VAL v3 = VVAL(VTUP(v0)->cells[2]);
	incref(v3);
	int64_t v4 = (0LL /* +Unsafe */);
	void* v5 = (void*)(v2 + (char*)VPTR(v3));
	int64_t v6 = 0LL;
	push_resource(v0);
	push_resource(MKI64(v4));
	int64_t v7 = mw_std_prim_Int_ZToU8(v6);
	ptr_fill(((uint8_t)v7), ((uint64_t)v1), v5);
	VAL r8 = pop_resource();
	VAL r9 = pop_resource();
	return r9;
}
static VAL mw_std_buffer_ZPlusBuffer_checkZ_spanZBang (int64_t x1, int64_t x2, VAL x3) {
	int64_t v0 = 0LL;
	bool v1 = (x1 < v0);
	if (v1) {
		int64_t v2 = 1LL /* True */;
		push_resource(x3);
		push_i64(x1);
		push_i64(x2);
		push_i64(v2);
	} else {
		int64_t v3 = i64_add(x1, x2);
		int64_t v4 = VI64(VTUP(x3)->cells[1]);
		bool v5 = (v3 > v4);
		push_i64(x1);
		push_i64(x2);
		push_resource(x3);
		push_bool(v5);
	}
	bool v6 = pop_bool();
	if (v6) {
		STR* v7;
		STRLIT(v7, "memory access out of bounds", 27);
		push_str(v7);
		do_panic();
	} else {
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
	VAL r10 = pop_resource();
	return r10;
}
static VAL mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang (int64_t x1, int64_t x2, VAL x3) {
	push_i64(x1);
	push_i64(x2);
	VAL v0 = (mw_std_buffer_ZPlusBuffer_checkZ_spanZBang(x1, x2, x3));
	int64_t v1 = pop_i64();
	int64_t v2 = pop_i64();
	int64_t v3 = i64_mod(v2, v1);
	int64_t v4 = 0LL;
	bool v5 = (v3 == v4);
	if (v5) {
		push_resource(v0);
	} else {
		STR* v6;
		STRLIT(v6, "memory access unaligned", 23);
		push_resource(v0);
		push_str(v6);
		do_panic();
	}
	VAL r7 = pop_resource();
	return r7;
}
static void mw_std_buffer_ZPlusBuffer_ZAtU8 (int64_t x1, VAL x2) {
	int64_t v0 = 1LL;
	push_resource(x2);
	push_i64(x1);
	push_i64(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL r2 = pop_resource();
	int64_t v3 = pop_i64();
	VAL v4 = (mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang(v3, v1, r2));
	VAL v5 = VVAL(VTUP(v4)->cells[2]);
	incref(v5);
	int64_t v6 = (0LL /* +Unsafe */);
	int64_t v7 = pop_i64();
	void* v8 = (void*)(v7 + (char*)VPTR(v5));
	uint8_t v9 = *(uint8_t*)v8;
	push_resource(v4);
	push_u8(v9);
}
static VAL mw_std_buffer_ZPlusBuffer_ZBangU8 (int64_t x1, int64_t x2, VAL x3) {
	int64_t v0 = 1LL;
	push_i64(x1);
	push_resource(x3);
	push_i64(x2);
	push_i64(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL r2 = pop_resource();
	int64_t v3 = pop_i64();
	VAL v4 = (mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang(v3, v1, r2));
	VAL v5 = VVAL(VTUP(v4)->cells[2]);
	incref(v5);
	int64_t v6 = (0LL /* +Unsafe */);
	int64_t v7 = pop_i64();
	void* v8 = (void*)(v7 + (char*)VPTR(v5));
	uint8_t v9 = pop_u8();
	*(uint8_t*)v8 = v9;
	return v4;
}
static VAL mw_std_buffer_ZPlusBuffer_ZBangByte (int64_t x1, int64_t x2, VAL x3) {
	push_resource(x3);
	int64_t v0 = mw_std_prim_Int_ZToU8(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_std_buffer_ZPlusBuffer_ZBangU8(v0, x2, r1));
	return v2;
}
static VAL mw_std_buffer_ZPlusBuffer_ZBangStr (VAL x1, int64_t x2, VAL x3) {
	incref(x1);
	uint64_t v0 = str_size(VSTR(x1));
	push_resource(x3);
	push_value(x1);
	push_i64(x2);
	push_i64(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	VAL r2 = pop_resource();
	int64_t v3 = pop_i64();
	VAL v4 = (mw_std_buffer_ZPlusBuffer_checkZ_spanZBang(v3, v1, r2));
	VAL v5 = VVAL(VTUP(v4)->cells[2]);
	incref(v5);
	int64_t v6 = (0LL /* +Unsafe */);
	int64_t v7 = pop_i64();
	void* v8 = (void*)(v7 + (char*)VPTR(v5));
	VAL v9 = pop_value();
	push_resource(v4);
	mw_std_prim_Ptr_ZBangStrZPlus(v9, MKPTR(v8), MKI64(v6));
	VAL v10 = pop_value();
	decref(v10);
	VAL r11 = pop_resource();
	VAL r12 = pop_resource();
	return r12;
}
static void mw_std_buffer_ZPlusBuffer_ZAtStr (int64_t x1, int64_t x2, VAL x3) {
	push_i64(x1);
	push_i64(x2);
	VAL v0 = (mw_std_buffer_ZPlusBuffer_checkZ_spanZBang(x1, x2, x3));
	VAL v1 = VVAL(VTUP(v0)->cells[2]);
	incref(v1);
	int64_t v2 = (0LL /* +Unsafe */);
	int64_t v3 = pop_i64();
	int64_t v4 = pop_i64();
	void* v5 = (void*)(v4 + (char*)VPTR(v1));
	STR* v6 = str_make(v5, ((uint64_t)v3));
	push_resource(v0);
	push_str(v6);
}
static void mw_std_prim_Ptr_ZBangStrZPlus (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	incref(x1);
	void* v0 = str_base(VSTR(x1));
	uint64_t v1 = str_size(VSTR(x1));
	push_resource(x3);
	push_value(x2);
	push_ptr(v0);
	int64_t v2 = mw_std_prim_Int_ZToNat(((int64_t)v1));
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v4);
	void* v5 = (void*)(v2 + (char*)VPTR(v4));
	ptr_copy(VPTR(v3), ((uint64_t)v2), VPTR(v4));
	decref(x1);
	push_ptr(v5);
}
static void mw_std_str_ZPlusStr_dupZBang (VAL x1) {
	incref(x1);
	push_resource(x1);
	push_value(x1);
}
static void mw_std_str_ZPlusStr_numZ_bytesZAsk (VAL x1) {
	incref(x1);
	uint64_t v0 = str_size(VSTR(x1));
	push_value(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	VAL v2 = pop_value();
	push_resource(v2);
	push_i64(v1);
}
static void mw_std_str_ZPlusStr_lastZ_byte (VAL x1) {
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x1);
	int64_t v0 = 1LL;
	int64_t v1 = pop_i64();
	int64_t v2 = i64_sub(v1, v0);
	VAL r3 = pop_resource();
	mw_std_str_ZPlusStr_byteZAt(v2, r3);
}
static void mw_std_str_ZPlusStr_byteZAt (int64_t x1, VAL x2) {
	push_i64(x1);
	mw_std_str_ZPlusStr_dupZBang(x2);
	VAL v0 = pop_value();
	int64_t v1 = pop_i64();
	int64_t v2 = mw_std_prim_Str_byteZAt(v1, v0);
	push_i64(v2);
}
static int64_t mw_std_str_offsetZ_inZ_bounds (int64_t x1, int64_t x2) {
	int64_t v0 = 0LL;
	bool v1 = (x1 >= v0);
	bool v2 = (x1 <= x2);
	bool v3 = (v1 && v2);
	return ((int64_t)v3);
}
static int64_t mw_std_prim_Str_byteZAt (int64_t x1, VAL x2) {
	incref(x2);
	incref(x2);
	void* v0 = str_base(VSTR(x2));
	uint64_t v1 = str_size(VSTR(x2));
	push_i64(x1);
	push_ptr(v0);
	int64_t v2 = mw_std_prim_Int_ZToNat(((int64_t)v1));
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v3);
	int64_t v5 = mw_std_str_offsetZ_inZ_bounds(VI64(v4), v2);
	if (((bool)v5)) {
		int64_t v6 = (0LL /* +Unsafe */);
		VAL v7 = pop_value();
		int64_t v8 = pop_i64();
		void* v9 = (void*)(v8 + (char*)VPTR(v7));
		mw_std_prim_Ptr_ZAtByte(MKPTR(v9), MKI64(v6));
		VAL r10 = pop_resource();
	} else {
		VAL v11 = pop_value();
		decref(v11);
		VAL v12 = pop_value();
		decref(v12);
		int64_t v13 = 0LL /* BNUL */;
		push_i64(v13);
	}
	decref(x2);
	int64_t v14 = pop_i64();
	return v14;
}
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang (int64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_std_byte_Byte_toZ_strZ_unsafe(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_std_str_ZPlusStr_pushZ_strZBang(v0, r1));
	return v2;
}
static VAL mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang (int64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_std_byte_Byte_toZ_asciiZ_str(x1);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL r2 = pop_resource();
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(v1, r2));
	return v3;
}
static VAL mw_std_str_ZPlusStr_pushZ_strZBang (VAL x1, VAL x2) {
	STR* v0 = str_cat(VSTR(x2), VSTR(x1));
	return MKSTR(v0);
}
static void mw_std_prim_Str_dropZ_bytes (int64_t x1, VAL x2, VAL x3) {
	incref(x2);
	uint64_t v0 = str_size(VSTR(x2));
	push_resource(x3);
	push_i64(x1);
	push_value(x2);
	push_i64(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	int64_t v2 = pop_i64();
	bool v3 = (v2 >= v1);
	if (v3) {
		VAL v4 = pop_value();
		decref(v4);
		VAL v5 = pop_value();
		decref(v5);
		STR* v6;
		STRLIT(v6, "", 0);
		push_str(v6);
	} else {
		VAL v7 = pop_value();
		incref(v7);
		incref(v7);
		void* v8 = str_base(VSTR(v7));
		uint64_t v9 = str_size(VSTR(v7));
		push_ptr(v8);
		int64_t v10 = mw_std_prim_Int_ZToNat(((int64_t)v9));
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		incref(v12);
		int64_t v13 = i64_sub(v10, VI64(v12));
		push_value(v12);
		push_value(v11);
		int64_t v14 = mw_std_prim_Int_ZToNat(v13);
		VAL v15 = pop_value();
		int64_t v16 = pop_i64();
		void* v17 = (void*)(v16 + (char*)VPTR(v15));
		STR* v18 = str_make(v17, ((uint64_t)v14));
		decref(v7);
		push_str(v18);
	}
}
static VAL mw_std_prim_Str_fromZ_bytesZ_unsafe (VAL x1) {
	incref(x1);
	push_value(x1);
	int64_t v0 = mw_std_list_List_1_len(x1);
	VAL v1 = (mw_std_buffer_ZPlusBuffer_new(v0));
	VAL v2 = pop_value();
	int64_t v3 = 0LL;
	push_resource(v1);
	push_i64(v3);
	mw_std_list_List_1_uncons(v2);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		int64_t v11 = mw_std_prim_Int_ZToU8(VI64(v9));
		VAL v12 = pop_value();
		incref(v12);
		VAL r13 = pop_resource();
		push_value(v12);
		VAL v14 = (mw_std_buffer_ZPlusBuffer_ZBangU8(v11, VI64(v12), r13));
		int64_t v15 = 1LL;
		int64_t v16 = pop_i64();
		int64_t v17 = i64_add(v16, v15);
		push_resource(v14);
		push_i64(v17);
		mw_std_list_List_1_uncons(v10);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	int64_t v22 = pop_i64();
	VAL r23 = pop_resource();
	VAL v24 = VVAL(VTUP(r23)->cells[2]);
	incref(v24);
	int64_t v25 = VI64(VTUP(r23)->cells[1]);
	int64_t v26 = (0LL /* +Unsafe */);
	STR* v27 = str_make(VPTR(v24), ((uint64_t)v25));
	push_str(v27);
	mw_std_buffer_ZPlusBuffer_rdrop(r23);
	VAL v28 = pop_value();
	return v28;
}
static void mw_std_str_clampZ_sliceZ_offsetZ_sizze (int64_t x1, int64_t x2, int64_t x3) {
	push_i64(x3);
	int64_t v0 = mw_std_prelude_Offset_min(x1, x3);
	VAL v1 = pop_value();
	push_i64(v0);
	push_value(v1);
	int64_t v2 = mw_std_prim_Int_ZToNat(v0);
	int64_t v3 = pop_i64();
	int64_t v4 = i64_sub(v3, v2);
	int64_t v5 = mw_std_prim_Int_ZToNat(v4);
	int64_t v6 = mw_std_prelude_Sizze_min(v5, x2);
	push_i64(v6);
}
static void mw_std_prim_Str_slice (int64_t x1, int64_t x2, VAL x3, VAL x4) {
	incref(x3);
	incref(x3);
	void* v0 = str_base(VSTR(x3));
	uint64_t v1 = str_size(VSTR(x3));
	push_i64(x1);
	push_i64(x2);
	push_resource(x4);
	push_ptr(v0);
	int64_t v2 = mw_std_prim_Int_ZToNat(((int64_t)v1));
	VAL v3 = pop_value();
	int64_t v4 = pop_i64();
	int64_t v5 = pop_i64();
	mw_std_str_clampZ_sliceZ_offsetZ_sizze(v5, v4, v2);
	int64_t v6 = pop_i64();
	int64_t v7 = pop_i64();
	void* v8 = (void*)(v7 + (char*)VPTR(v3));
	STR* v9 = str_make(v8, ((uint64_t)v6));
	decref(x3);
	push_str(v9);
}
static void mw_std_prim_Str_dropZ_slice (int64_t x1, VAL x2, VAL x3) {
	mw_std_str_ZPlusStr_dropZ_slice(x1, x2, x3);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	decref(r1);
	push_resource(r0);
}
static void mw_std_prim_Str_takeZ_slice (int64_t x1, VAL x2, VAL x3) {
	mw_std_str_ZPlusStr_takeZ_slice(x1, x2, x3);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	decref(r1);
	push_resource(r0);
}
static void mw_std_str_ZPlusStr_slice (int64_t x1, int64_t x2, VAL x3, VAL x4) {
	push_i64(x1);
	push_i64(x2);
	mw_std_str_ZPlusStr_dupZBang(x3);
	VAL v0 = pop_value();
	int64_t v1 = pop_i64();
	int64_t v2 = pop_i64();
	mw_std_prim_Str_slice(v2, v1, v0, x4);
}
static void mw_std_str_ZPlusStr_offsetZ_slice (int64_t x1, int64_t x2, VAL x3, VAL x4) {
	bool v0 = (x1 < x2);
	if (v0) {
		int64_t v1 = i64_sub(x2, x1);
		push_resource(x3);
		push_resource(x4);
		push_i64(x1);
		int64_t v2 = mw_std_prim_Int_ZToNat(v1);
		VAL r3 = pop_resource();
		VAL r4 = pop_resource();
		int64_t v5 = pop_i64();
		mw_std_str_ZPlusStr_slice(v5, v2, r4, r3);
	} else {
		STR* v6;
		STRLIT(v6, "", 0);
		push_resource(x3);
		push_resource(x4);
		push_str(v6);
	}
}
static void mw_std_str_ZPlusStr_takeZ_slice (int64_t x1, VAL x2, VAL x3) {
	int64_t v0 = 0LL;
	mw_std_str_ZPlusStr_slice(v0, x1, x2, x3);
}
static void mw_std_str_ZPlusStr_dropZ_slice (int64_t x1, VAL x2, VAL x3) {
	push_i64(x1);
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x2);
	VAL r0 = pop_resource();
	int64_t v1 = pop_i64();
	int64_t v2 = pop_i64();
	mw_std_str_ZPlusStr_slice(v2, v1, r0, x3);
}
static void mw_std_str_ZPlusStr_splitZ_byte (int64_t x1, VAL x2) {
	int64_t v0 = 0LL /* Nil */;
	push_i64(x1);
	push_resource(x2);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	int64_t v2 = 0LL;
	push_resource(v1);
	push_i64(v2);
	push_i64(v2);
	while(1) {
		int64_t v3 = pop_i64();
		VAL r4 = pop_resource();
		VAL r5 = pop_resource();
		push_i64(v3);
		push_i64(v3);
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r5);
		int64_t v6 = pop_i64();
		int64_t v7 = pop_i64();
		bool v8 = (v7 < v6);
		push_resource(r4);
		if (!v8) break;
		VAL v9 = pop_value();
		incref(v9);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL r12 = pop_resource();
		mw_std_str_ZPlusStr_byteZAt(VI64(v9), r12);
		VAL r13 = pop_resource();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v15);
		bool v16 = (VI64(v14) == VI64(v15));
		if (v16) {
			incref(v9);
			int64_t v17 = (0LL /* +Unsafe */);
			push_value(v15);
			push_value(v9);
			mw_std_str_ZPlusStr_offsetZ_slice(VI64(v10), VI64(v9), r13, MKI64(v17));
			VAL r18 = pop_resource();
			VAL v19 = pop_value();
			VAL v20 = mtw_std_list_List_1_Cons(v19, r11);
			int64_t v21 = 1LL;
			int64_t v22 = pop_i64();
			int64_t v23 = i64_add(v22, v21);
			push_resource(v20);
			push_i64(v23);
			push_i64(v23);
		} else {
			int64_t v24 = 1LL;
			int64_t v25 = i64_add(VI64(v9), v24);
			push_value(v15);
			push_resource(r13);
			push_resource(r11);
			push_value(v10);
			push_i64(v25);
		}
	}
	VAL r26 = pop_resource();
	int64_t v27 = (0LL /* +Unsafe */);
	VAL r28 = pop_resource();
	int64_t v29 = pop_i64();
	int64_t v30 = pop_i64();
	mw_std_str_ZPlusStr_offsetZ_slice(v30, v29, r28, MKI64(v27));
	VAL r31 = pop_resource();
	VAL v32 = pop_value();
	VAL v33 = mtw_std_list_List_1_Cons(v32, r26);
	VAL v34 = mw_std_list_List_1_reverse(v33);
	VAL v35 = pop_value();
	decref(v35);
	push_value(v34);
}
static VAL mw_std_prim_Str_splitZ_byte (int64_t x1, VAL x2) {
	mw_std_str_ZPlusStr_splitZ_byte(x1, x2);
	VAL r0 = pop_resource();
	decref(r0);
	VAL v1 = pop_value();
	return v1;
}
static void mw_std_str_ZPlusStr_pushZ_showZ_byteZBang (VAL x1, int64_t x2, int64_t x3) {
	switch (x3) {
		case 34LL: { // BQUOTE
			STR* v0;
			STRLIT(v0, "\\\"", 2);
			lpush(&lbl_escapeZ_hex, MKI64(x2));
			VAL v1 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v0), x1));
			int64_t v2 = 0LL /* False */;
			int64_t v3 = VI64(lpop(&lbl_escapeZ_hex));
			push_resource(v1);
			lpush(&lbl_escapeZ_hex, MKI64(v2));
		} break;
		case 92LL: { // B'\'
			STR* v4;
			STRLIT(v4, "\\\\", 2);
			lpush(&lbl_escapeZ_hex, MKI64(x2));
			VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), x1));
			int64_t v6 = 0LL /* False */;
			int64_t v7 = VI64(lpop(&lbl_escapeZ_hex));
			push_resource(v5);
			lpush(&lbl_escapeZ_hex, MKI64(v6));
		} break;
		case 10LL: { // BLF
			STR* v8;
			STRLIT(v8, "\n", 1);
			lpush(&lbl_escapeZ_hex, MKI64(x2));
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), x1));
			int64_t v10 = 0LL /* False */;
			int64_t v11 = VI64(lpop(&lbl_escapeZ_hex));
			push_resource(v9);
			lpush(&lbl_escapeZ_hex, MKI64(v10));
		} break;
		case 13LL: { // BCR
			STR* v12;
			STRLIT(v12, "\r", 1);
			lpush(&lbl_escapeZ_hex, MKI64(x2));
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), x1));
			int64_t v14 = 0LL /* False */;
			int64_t v15 = VI64(lpop(&lbl_escapeZ_hex));
			push_resource(v13);
			lpush(&lbl_escapeZ_hex, MKI64(v14));
		} break;
		case 9LL: { // BHT
			STR* v16;
			STRLIT(v16, "\t", 1);
			lpush(&lbl_escapeZ_hex, MKI64(x2));
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), x1));
			int64_t v18 = 0LL /* False */;
			int64_t v19 = VI64(lpop(&lbl_escapeZ_hex));
			push_resource(v17);
			lpush(&lbl_escapeZ_hex, MKI64(v18));
		} break;
		default: {
			int64_t v20 = 32LL /* BSPACE */;
			int64_t v21 = 126LL /* B'~' */;
			bool v22 = (x3 >= v20);
			bool v23 = (x3 <= v21);
			bool v24 = (v22 && v23);
			if (v24) {
				if (((bool)x2)) {
					push_resource(x1);
					lpush(&lbl_escapeZ_hex, MKI64(x2));
					push_i64(x3);
					int64_t v25 = mw_std_byte_Byte_isZ_hexdigit(x3);
					push_i64(v25);
				} else {
					int64_t v26 = 0LL /* False */;
					push_resource(x1);
					push_i64(x3);
					lpush(&lbl_escapeZ_hex, MKI64(x2));
					push_i64(v26);
				}
				bool v27 = pop_bool();
				bool v28 = !v27;
				push_bool(v28);
			} else {
				int64_t v29 = 0LL /* False */;
				push_resource(x1);
				lpush(&lbl_escapeZ_hex, MKI64(x2));
				push_i64(x3);
				push_i64(v29);
			}
			bool v30 = pop_bool();
			if (v30) {
				VAL r31 = pop_resource();
				int64_t v32 = pop_i64();
				VAL v33 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v32, r31));
				int64_t v34 = 0LL /* False */;
				int64_t v35 = VI64(lpop(&lbl_escapeZ_hex));
				push_resource(v33);
				lpush(&lbl_escapeZ_hex, MKI64(v34));
			} else {
				STR* v36;
				STRLIT(v36, "\\x", 2);
				VAL r37 = pop_resource();
				VAL v38 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v36), r37));
				int64_t v39 = pop_i64();
				push_resource(v38);
				mw_std_byte_Byte_toZ_hexdigits(v39);
				int64_t v40 = pop_i64();
				VAL r41 = pop_resource();
				int64_t v42 = pop_i64();
				VAL v43 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v42, r41));
				VAL v44 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v40, v43));
				int64_t v45 = 1LL /* True */;
				int64_t v46 = VI64(lpop(&lbl_escapeZ_hex));
				push_resource(v44);
				lpush(&lbl_escapeZ_hex, MKI64(v45));
			}
		} break;
	}
}
static VAL mw_std_prim_Str_showZThen (VAL x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "\"", 1);
	push_value(x1);
	VAL v1 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v0), x2));
	int64_t v2 = 0LL /* False */;
	VAL v3 = pop_value();
	incref(v3);
	incref(v3);
	void* v4 = str_base(VSTR(v3));
	uint64_t v5 = str_size(VSTR(v3));
	push_resource(v1);
	lpush(&lbl_escapeZ_hex, MKI64(v2));
	push_ptr(v4);
	int64_t v6 = mw_std_prim_Int_ZToNat(((int64_t)v5));
	push_i64(v6);
	while(1) {
		int64_t v7 = pop_i64();
		int64_t v8 = 0LL;
		bool v9 = (v7 > v8);
		push_i64(v7);
		if (!v9) break;
		int64_t v10 = pop_i64();
		VAL v11 = pop_value();
		incref(v11);
		int64_t v12 = (0LL /* +Unsafe */);
		mw_std_prim_Ptr_ZAtByte(v11, MKI64(v12));
		VAL r13 = pop_resource();
		int64_t v14 = pop_i64();
		int64_t v15 = VI64(lpop(&lbl_escapeZ_hex));
		VAL r16 = pop_resource();
		mw_std_str_ZPlusStr_pushZ_showZ_byteZBang(r16, v15, v14);
		int64_t v17 = 1LL;
		int64_t v18 = (0LL /* +Unsafe */);
		void* v19 = (void*)(v17 + (char*)VPTR(v11));
		int64_t v20 = 1LL;
		int64_t v21 = i64_sub(v10, v20);
		push_ptr(v19);
		int64_t v22 = mw_std_prim_Int_ZToNat(v21);
		push_i64(v22);
	}
	int64_t v23 = pop_i64();
	VAL v24 = pop_value();
	decref(v24);
	decref(v3);
	int64_t v25 = VI64(lpop(&lbl_escapeZ_hex));
	STR* v26;
	STRLIT(v26, "\"", 1);
	VAL r27 = pop_resource();
	VAL v28 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v26), r27));
	return v28;
}
static VAL mw_std_list_List_1_ZDivL1 (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
			VAL v0 = pop_value();
			switch (get_data_tag(v0)) {
				case 0LL: { // Nil
					VAL v1 = pop_value();
					VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
					push_value(v2);
				} break;
				default: {
					decref(v0);
					VAL v3 = pop_value();
					decref(v3);
					int64_t v4 = 0LL /* None */;
					push_i64(v4);
				} break;
			}
		} break;
		default: {
			decref(x1);
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
	}
	VAL v6 = pop_value();
	return v6;
}
static VAL mw_std_list_List_1_ZDivL2 (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
			VAL v0 = pop_value();
			VAL v1 = mw_std_list_List_1_ZDivL1(v0);
			switch (get_data_tag(v1)) {
				case 1LL: { // Some
					VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
					VAL v3 = pop_value();
					VAL v4 = MKNIL;
					VAL v5 = mkcons(v4, v3);
					VAL v6 = mkcons(v5, v2);
					VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
					push_value(v7);
				} break;
				case 0LL: { // None
					VAL v8 = pop_value();
					decref(v8);
					int64_t v9 = 0LL /* None */;
					push_i64(v9);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		default: {
			decref(x1);
			int64_t v10 = 0LL /* None */;
			push_i64(v10);
		} break;
	}
	VAL v11 = pop_value();
	return v11;
}
static int64_t mw_std_list_List_1_emptyZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static VAL mw_std_list_List_1_ZToListZPlus (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			int64_t v0 = 0LL /* None */;
			push_i64(v0);
		} break;
		default: {
			VAL v1 = mtw_std_maybe_Maybe_1_Some(x1);
			push_value(v1);
		} break;
	}
	VAL v2 = pop_value();
	return v2;
}
static int64_t mw_std_list_List_1_len (VAL x1) {
	int64_t v0 = 0LL;
	push_value(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL v2 = pop_value();
	push_i64(v1);
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		decref(v8);
		int64_t v10 = 1LL;
		int64_t v11 = pop_i64();
		int64_t v12 = i64_add(v11, v10);
		push_i64(v12);
		mw_std_list_List_1_uncons(v9);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		push_value(v13);
		push_value(v14);
	}
	VAL v15 = pop_value();
	decref(v15);
	VAL v16 = pop_value();
	decref(v16);
	int64_t v17 = pop_i64();
	return v17;
}
static void mw_std_list_List_1_uncons (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			int64_t v0 = 0LL /* None */;
			int64_t v1 = 0LL /* Nil */;
			push_i64(v0);
			push_i64(v1);
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			push_value(v4);
			push_value(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_std_list_ListZPlus_1_uncons (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			STR* v0;
			STRLIT(v0, "Nil in List+.uncons", 19);
			push_str(v0);
			do_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_std_list_List_1_unsnoc (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			int64_t v0 = 0LL /* Nil */;
			int64_t v1 = 0LL /* None */;
			push_i64(v0);
			push_i64(v1);
		} break;
		default: {
			mw_std_list_ListZPlus_1_unsnoc(x1);
			VAL v2 = pop_value();
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
	}
}
static void mw_std_list_ListZPlus_1_unsnoc (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			STR* v0;
			STRLIT(v0, "L0 in List+.unsnoc", 18);
			push_str(v0);
			do_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
			VAL v1 = pop_value();
			switch (get_data_tag(v1)) {
				case 0LL: { // Nil
					int64_t v2 = 0LL /* Nil */;
					VAL v3 = pop_value();
					push_i64(v2);
					push_value(v3);
				} break;
				default: {
					mw_std_list_ListZPlus_1_unsnoc(v1);
					VAL v4 = pop_value();
					VAL v5 = pop_value();
					VAL v6 = pop_value();
					VAL v7 = mtw_std_list_List_1_Cons(v6, v5);
					push_value(v7);
					push_value(v4);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_std_list_List_1_cat (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // Nil
			push_value(x1);
		} break;
		default: {
			push_value(x2);
			VAL v0 = mw_std_list_List_1_reverse(x1);
			mw_std_list_List_1_uncons(v0);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			while(1) {
				VAL v3 = pop_value();
				incref(v3);
				push_value(v3);
				int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
				if (!((bool)v4)) break;
				VAL v5 = pop_value();
				VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				VAL v9 = mtw_std_list_List_1_Cons(v6, v8);
				push_value(v9);
				mw_std_list_List_1_uncons(v7);
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				push_value(v10);
				push_value(v11);
			}
			VAL v12 = pop_value();
			decref(v12);
			VAL v13 = pop_value();
			decref(v13);
		} break;
	}
	VAL v14 = pop_value();
	return v14;
}
static VAL mw_std_list_List_1_first (VAL x1) {
	VAL v0 = mw_std_list_List_1_ZToListZPlus(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_std_list_ListZPlus_1_first(v1);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static VAL mw_std_list_List_1_last (VAL x1) {
	VAL v0 = mw_std_list_List_1_ZToListZPlus(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_std_list_ListZPlus_1_last(v1);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static VAL mw_std_list_ListZPlus_1_first (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			STR* v0;
			STRLIT(v0, "Nil at List+.first", 18);
			push_str(v0);
			do_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
			VAL v1 = pop_value();
			decref(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v2 = pop_value();
	return v2;
}
static VAL mw_std_list_ListZPlus_1_last (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Nil
			STR* v0;
			STRLIT(v0, "Nil at List+.last", 17);
			push_str(v0);
			do_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons(x1);
			VAL v1 = pop_value();
			mw_std_list_List_1_uncons(v1);
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			while(1) {
				VAL v4 = pop_value();
				incref(v4);
				push_value(v4);
				int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
				if (!((bool)v5)) break;
				VAL v6 = pop_value();
				VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				decref(v9);
				push_value(v7);
				mw_std_list_List_1_uncons(v8);
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				push_value(v10);
				push_value(v11);
			}
			VAL v12 = pop_value();
			decref(v12);
			VAL v13 = pop_value();
			decref(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v14 = pop_value();
	return v14;
}
static VAL mw_std_list_List_1_reverse (VAL x1) {
	int64_t v0 = 0LL /* Nil */;
	push_i64(v0);
	mw_std_list_List_1_uncons(x1);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = mtw_std_list_List_1_Cons(v6, v8);
		push_value(v9);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	return v14;
}
static VAL mw_std_prim_Int_range (int64_t x1, int64_t x2) {
	int64_t v0 = 0LL /* Nil */;
	push_i64(x1);
	push_i64(x2);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	push_resource(v1);
	while(1) {
		VAL r2 = pop_resource();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		incref(v3);
		bool v5 = (VI64(v4) <= VI64(v3));
		push_value(v4);
		push_value(v3);
		push_resource(r2);
		if (!v5) break;
		VAL r6 = pop_resource();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v8);
		int64_t v9 = 1LL;
		int64_t v10 = i64_add(VI64(v8), v9);
		push_i64(v10);
		push_value(v7);
		VAL v11 = mtw_std_list_List_1_Cons(v8, r6);
		push_resource(v11);
	}
	VAL r12 = pop_resource();
	VAL v13 = mw_std_list_List_1_reverse(r12);
	VAL v14 = pop_value();
	decref(v14);
	VAL v15 = pop_value();
	decref(v15);
	return v13;
}
static int64_t mw_std_maybe_Maybe_1_noneZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // None
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(x1);
			decref(v1);
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v3 = pop_i64();
	return v3;
}
static int64_t mw_std_maybe_Maybe_1_someZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // None
			int64_t v0 = 0LL /* False */;
			push_i64(v0);
		} break;
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(x1);
			decref(v1);
			int64_t v2 = 1LL /* True */;
			push_i64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v3 = pop_i64();
	return v3;
}
static int64_t mw_std_maybe_Maybe_1_ZToBool (VAL x1) {
	int64_t v0 = mw_std_maybe_Maybe_1_someZAsk(x1);
	return v0;
}
static VAL mw_std_maybe_Maybe_1_ZToList (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // None
			int64_t v0 = 0LL /* Nil */;
			push_i64(v0);
		} break;
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(x1);
			int64_t v2 = 0LL /* Nil */;
			VAL v3 = mtw_std_list_List_1_Cons(v1, MKI64(v2));
			push_value(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	return v4;
}
static VAL mw_std_maybe_Maybe_1_unwrap (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // Some
			VAL v0 = mtp_std_maybe_Maybe_1_Some(x1);
			push_value(v0);
		} break;
		case 0LL: { // None
			STR* v1;
			STRLIT(v1, "tried to unwrap None", 20);
			push_str(v1);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v2 = pop_value();
	return v2;
}
static VAL mw_std_maybe_Maybe_1_zzip (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // None
			decref(x1);
			int64_t v0 = 0LL /* None */;
			push_i64(v0);
		} break;
		case 1LL: { // Some
			push_value(x1);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(x2);
			VAL v2 = pop_value();
			switch (get_data_tag(v2)) {
				case 0LL: { // None
					decref(v1);
					int64_t v3 = 0LL /* None */;
					push_i64(v3);
				} break;
				case 1LL: { // Some
					push_value(v1);
					VAL v4 = mtp_std_maybe_Maybe_1_Some(v2);
					VAL v5 = pop_value();
					VAL v6 = MKNIL;
					VAL v7 = mkcons(v6, v4);
					VAL v8 = mkcons(v7, v5);
					VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
					push_value(v9);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v1);
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	VAL v10 = pop_value();
	return v10;
}
static int64_t mw_std_prim_Int_ZToOS (int64_t x1) {
	int64_t v0 = 1LL;
	int64_t v1 = 3LL;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	if (v4) {
		push_i64(x1);
	} else {
		int64_t v5 = 0LL /* OS_UNKNOWN */;
		push_i64(v5);
	}
	int64_t v6 = pop_i64();
	return v6;
}
static int64_t mw_std_prim_Int_ZToArch (int64_t x1) {
	int64_t v0 = 1LL;
	int64_t v1 = 3LL;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	if (v4) {
		push_i64(x1);
	} else {
		int64_t v5 = 0LL /* ARCH_UNKNOWN */;
		push_i64(v5);
	}
	int64_t v6 = pop_i64();
	return v6;
}
static VAL mw_std_prim_Int_ZToU8ZAsk (int64_t x1) {
	int64_t v0 = 0LL;
	int64_t v1 = 255LL;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	if (v4) {
		VAL v5 = mtw_std_maybe_Maybe_1_Some(MKI64(x1));
		push_value(v5);
	} else {
		int64_t v6 = 0LL /* None */;
		push_i64(v6);
	}
	VAL v7 = pop_value();
	return v7;
}
static VAL mw_std_prim_Int_ZToU16ZAsk (int64_t x1) {
	int64_t v0 = 0LL;
	int64_t v1 = 65535LL;
	bool v2 = (x1 >= v0);
	bool v3 = (x1 <= v1);
	bool v4 = (v2 && v3);
	if (v4) {
		VAL v5 = mtw_std_maybe_Maybe_1_Some(MKI64(x1));
		push_value(v5);
	} else {
		int64_t v6 = 0LL /* None */;
		push_i64(v6);
	}
	VAL v7 = pop_value();
	return v7;
}
static int64_t mw_std_prim_Int_ZToU8 (int64_t x1) {
	VAL v0 = mw_std_prim_Int_ZToU8ZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "U8 out of bounds", 16);
			push_str(v2);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v3 = pop_i64();
	return v3;
}
static int64_t mw_std_prim_Int_ZToU16 (int64_t x1) {
	VAL v0 = mw_std_prim_Int_ZToU16ZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "U16 out of bounds", 17);
			push_str(v2);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v3 = pop_i64();
	return v3;
}
static int64_t mw_std_prim_Int_ZToI64 (int64_t x1) {
	return x1;
}
static int64_t mw_std_prim_Int_ZToNat (int64_t x1) {
	int64_t v0 = 0LL;
	bool v1 = (x1 < v0);
	bool v2 = !v1;
	if (v2) {
		push_i64(x1);
	} else {
		STR* v3;
		STRLIT(v3, "tried to create negative Nat", 28);
		push_i64(x1);
		push_str(v3);
		do_panic();
		do_panic();
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_std_prelude_Sizze_max (int64_t x1, int64_t x2) {
	bool v0 = (x1 >= x2);
	if (v0) {
		push_i64(x1);
	} else {
		push_i64(x2);
	}
	int64_t v1 = pop_i64();
	return v1;
}
static int64_t mw_std_prelude_Sizze_min (int64_t x1, int64_t x2) {
	bool v0 = (x1 <= x2);
	if (v0) {
		push_i64(x1);
	} else {
		push_i64(x2);
	}
	int64_t v1 = pop_i64();
	return v1;
}
static int64_t mw_std_prelude_Offset_min (int64_t x1, int64_t x2) {
	bool v0 = (x1 <= x2);
	if (v0) {
		push_i64(x1);
	} else {
		push_i64(x2);
	}
	int64_t v1 = pop_i64();
	return v1;
}
static VAL mw_std_prelude_ZAtZAsk (VAL x1) {
	incref(x1);
	bool v0 = mut_is_set(x1);
	if (v0) {
		VAL v1 = mut_get(x1);
		VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
		push_value(v2);
	} else {
		decref(x1);
		int64_t v3 = 0LL /* None */;
		push_i64(v3);
	}
	VAL v4 = pop_value();
	return v4;
}
static VAL mw_std_path_PATHz_SEPARATOR (void) {
	int64_t v0 = RUNNING_OS;
	int64_t v1 = mw_std_prim_Int_ZToOS(v0);
	int64_t v2 = 1LL /* OS_WINDOWS */;
	bool v3 = (v1 == v2);
	if (v3) {
		STR* v4;
		STRLIT(v4, "\\", 1);
		push_str(v4);
	} else {
		STR* v5;
		STRLIT(v5, "/", 1);
		push_str(v5);
	}
	VAL v6 = pop_value();
	return v6;
}
static VAL mw_std_path_Path_joinZ_with (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	uint64_t v0 = str_size(VSTR(x1));
	push_value(x1);
	push_value(x2);
	push_value(x3);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	int64_t v2 = 0LL;
	bool v3 = (v1 == v2);
	if (v3) {
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		decref(v5);
		VAL v6 = pop_value();
		decref(v6);
		push_value(v4);
	} else {
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		STR* v9 = pop_str();
		STR* v10 = str_cat(v9, VSTR(v8));
		STR* v11 = str_cat(v10, VSTR(v7));
		push_str(v11);
	}
	VAL v12 = pop_value();
	return v12;
}
static VAL mw_std_path_Path_join (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = mw_std_path_PATHz_SEPARATOR();
	VAL v1 = pop_value();
	VAL v2 = mw_std_path_Path_joinZ_with(v1, v0, x2);
	return v2;
}
static int64_t mw_std_byte_Byte_isZ_pathZ_separatorZAsk (int64_t x1) {
	switch (x1) {
		case 47LL: { // B'/'
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 92LL: { // B'\'
			int64_t v1 = RUNNING_OS;
			int64_t v2 = mw_std_prim_Int_ZToOS(v1);
			int64_t v3 = 1LL /* OS_WINDOWS */;
			bool v4 = (v2 == v3);
			push_bool(v4);
		} break;
		default: {
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
	}
	int64_t v6 = pop_i64();
	return v6;
}
static void mw_std_path_Path_splitZ_last (VAL x1) {
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x1);
	int64_t v0 = 0LL /* None */;
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		int64_t v2 = mw_std_maybe_Maybe_1_noneZAsk(v1);
		if (((bool)v2)) {
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			int64_t v5 = 0LL;
			bool v6 = (VI64(v4) > v5);
			push_value(v4);
			push_value(v3);
			push_bool(v6);
		} else {
			int64_t v7 = 0LL /* False */;
			push_i64(v7);
		}
		bool v8 = pop_bool();
		if (!v8) break;
		VAL v9 = pop_value();
		decref(v9);
		int64_t v10 = 1LL;
		int64_t v11 = pop_i64();
		int64_t v12 = i64_sub(v11, v10);
		VAL r13 = pop_resource();
		mw_std_str_ZPlusStr_byteZAt(v12, r13);
		VAL r14 = pop_resource();
		int64_t v15 = pop_i64();
		int64_t v16 = mw_std_byte_Byte_isZ_pathZ_separatorZAsk(v15);
		if (((bool)v16)) {
			push_resource(r14);
			push_i64(v12);
			VAL v17 = mtw_std_maybe_Maybe_1_Some(MKI64(v12));
			push_value(v17);
		} else {
			int64_t v18 = 0LL /* None */;
			push_resource(r14);
			push_i64(v12);
			push_i64(v18);
		}
	}
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	decref(v20);
	VAL r21 = pop_resource();
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			push_value(r21);
			VAL v22 = mtp_std_maybe_Maybe_1_Some(v19);
			int64_t v23 = (0LL /* +Unsafe */);
			VAL v24 = pop_value();
			incref(v22);
			incref(v24);
			int64_t v25 = 1LL;
			int64_t v26 = i64_add(VI64(v22), v25);
			push_value(v22);
			push_value(v24);
			mw_std_prim_Str_dropZ_slice(v26, v24, MKI64(v23));
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			int64_t v29 = pop_i64();
			int64_t v30 = mw_std_prim_Int_ZToNat(v29);
			VAL r31 = pop_resource();
			mw_std_prim_Str_takeZ_slice(v30, v28, r31);
			VAL r32 = pop_resource();
			VAL v33 = mtw_std_maybe_Maybe_1_Some(v27);
			push_value(v33);
		} break;
		case 0LL: { // None
			int64_t v34 = 0LL /* None */;
			push_value(r21);
			push_i64(v34);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(r21);
		}
	}
	VAL v35 = pop_value();
	push_value(v35);
}
static VAL mw_std_path_Path_pathZThen (VAL x1, VAL x2) {
	VAL v0 = (mw_std_str_ZPlusStr_pushZ_strZBang(x1, x2));
	return v0;
}
static int64_t mw_std_input_INPUTz_BUFFERz_SIZZE (void) {
	int64_t v0 = 8192LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	return v1;
}
static VAL mw_std_input_ZPlusInput_startZBang (VAL x1) {
	lpush(&lbl_ZPlusfile, x1);
	int64_t v0 = mw_std_input_INPUTz_BUFFERz_SIZZE();
	VAL v1 = (mw_std_buffer_ZPlusBuffer_new(v0));
	int64_t v2 = 0LL;
	lpush(&lbl_ZPlusbuffer, v1);
	int64_t v3 = mw_std_prim_Int_ZToNat(v2);
	int64_t v4 = 0LL;
	VAL v5 = (lpop(&lbl_ZPlusbuffer));
	VAL v6 = (lpop(&lbl_ZPlusfile));
	VAL v7 = (mtw_std_input_ZPlusInputOpenState_ZPlusInputOpenState(v3, v4, v6, v5));
	VAL v8 = (mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang(v7));
	return v8;
}
static VAL mw_std_input_ZPlusInput_stopZBang (VAL x1) {
	VAL v0 = (mw_std_input_ZPlusInput_endZBang(x1));
	VAL v1 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v0));
	return v1;
}
static VAL mw_std_input_ZPlusInput_endZBang (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v0 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			mtp_std_input_ZPlusInputOpenState_ZPlusInputOpenState(v0);
			VAL v1 = (lpop(&lbl_ZPlusbuffer));
			mw_std_buffer_ZPlusBuffer_rdrop(v1);
			int64_t v2 = VI64(lpop(&lbl_length));
			int64_t v3 = VI64(lpop(&lbl_offset));
			VAL v4 = (lpop(&lbl_ZPlusfile));
			push_resource(v4);
		} break;
		case 1LL: { // +InputDone
			VAL v5 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			push_resource(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r6 = pop_resource();
	return r6;
}
static void mw_std_input_ZPlusInput_doneZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v0 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
			VAL v2 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(v0));
			push_resource(v2);
		} break;
		case 1LL: { // +InputDone
			VAL v3 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			int64_t v4 = 1LL /* True */;
			push_i64(v4);
			VAL v5 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v3));
			push_resource(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[4]));
	VAL v1 = VVAL(VTUP(v0)->cells[2]);
	incref(v1);
	int64_t v2 = VI64(VTUP(v0)->cells[1]);
	VTUP(x1)->cells[4] = v0;
	VAL v3 = (VVAL(VTUP(x1)->cells[3]));
	mw_std_file_ZPlusFile_unsafeZ_readZBang(v1, v2, v3);
	VAL r4 = pop_resource();
	VTUP(x1)->cells[3] = r4;
	int64_t v5 = pop_i64();
	int64_t v6 = 0LL;
	bool v7 = (v5 > v6);
	if (v7) {
		VTUP(x1)->cells[1] = MKI64(v5);
		int64_t v8 = 0LL;
		VTUP(x1)->cells[2] = MKI64(v8);
		VAL v9 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(x1));
		push_resource(v9);
	} else {
		VAL v10 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(x1));
		VAL v11 = (mw_std_input_ZPlusInput_stopZBang(v10));
		push_resource(v11);
	}
	VAL r12 = pop_resource();
	return r12;
}
static void mw_std_input_ZPlusInput_peek (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v0 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v1 = VI64(VTUP(v0)->cells[2]);
			VAL v2 = (VVAL(VTUP(v0)->cells[4]));
			mw_std_buffer_ZPlusBuffer_ZAtU8(v1, v2);
			VAL r3 = pop_resource();
			VTUP(v0)->cells[4] = r3;
			int64_t v4 = pop_i64();
			push_resource(v0);
			int64_t v5 = mw_std_prim_U8_ZToByte(v4);
			VAL r6 = pop_resource();
			push_i64(v5);
			VAL v7 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(r6));
			push_resource(v7);
		} break;
		case 1LL: { // +InputDone
			VAL v8 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			STR* v9;
			STRLIT(v9, "error: no more input", 20);
			push_resource(v8);
			push_str(v9);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_std_input_ZPlusInput_moveZBang (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v0 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v1 = VI64(VTUP(v0)->cells[2]);
			int64_t v2 = 1LL;
			int64_t v3 = i64_add(v1, v2);
			VTUP(v0)->cells[2] = MKI64(v3);
			VAL v4 = (mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang(v0));
			push_resource(v4);
		} break;
		case 1LL: { // +InputDone
			VAL v5 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			STR* v6;
			STRLIT(v6, "error: no more input", 20);
			push_resource(v5);
			push_str(v6);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r7 = pop_resource();
	return r7;
}
static VAL mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[2]);
	int64_t v1 = VI64(VTUP(x1)->cells[1]);
	bool v2 = (v0 >= v1);
	if (v2) {
		VAL v3 = (mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang(x1));
		push_resource(v3);
	} else {
		VAL v4 = (mtw_std_input_ZPlusInput_ZPlusInputOpen(x1));
		push_resource(v4);
	}
	VAL r5 = pop_resource();
	return r5;
}
static void mw_std_input_ZPlusInput_readZ_chunkZBang (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +InputOpen
			VAL v0 = (mtp_std_input_ZPlusInput_ZPlusInputOpen(x1));
			int64_t v1 = VI64(VTUP(v0)->cells[2]);
			int64_t v2 = VI64(VTUP(v0)->cells[1]);
			int64_t v3 = VI64(VTUP(v0)->cells[2]);
			push_i64(v1);
			push_i64(v2);
			push_resource(v0);
			int64_t v4 = mw_std_prim_Int_ZToNat(v3);
			int64_t v5 = pop_i64();
			int64_t v6 = i64_sub(v5, v4);
			int64_t v7 = mw_std_prim_Int_ZToNat(v6);
			VAL r8 = pop_resource();
			VAL v9 = (VVAL(VTUP(r8)->cells[4]));
			int64_t v10 = pop_i64();
			mw_std_buffer_ZPlusBuffer_ZAtStr(v10, v7, v9);
			VAL r11 = pop_resource();
			VTUP(r8)->cells[4] = r11;
			VAL v12 = (mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang(r8));
			VAL v13 = pop_value();
			push_resource(v12);
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		case 1LL: { // +InputDone
			VAL v15 = (mtp_std_input_ZPlusInput_ZPlusInputDone(x1));
			int64_t v16 = 0LL /* None */;
			push_i64(v16);
			VAL v17 = (mtw_std_input_ZPlusInput_ZPlusInputDone(v15));
			push_resource(v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_std_input_ZPlusInput_readZ_fileZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "", 0);
	push_str(v0);
	mw_std_input_ZPlusInput_readZ_chunkZBang(x1);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		int64_t v2 = mw_std_maybe_Maybe_1_someZAsk(v1);
		if (!((bool)v2)) break;
		VAL v3 = pop_value();
		VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
		STR* v5 = pop_str();
		STR* v6 = str_cat(v5, VSTR(v4));
		VAL r7 = pop_resource();
		push_str(v6);
		mw_std_input_ZPlusInput_readZ_chunkZBang(r7);
	}
	VAL v8 = pop_value();
	decref(v8);
}
static int64_t mw_std_output_OUTPUTz_BUFFERz_SIZZE (void) {
	int64_t v0 = 4096LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	return v1;
}
static VAL mw_std_output_ZPlusOutput_startZBang (VAL x1) {
	int64_t v0 = 0LL;
	lpush(&lbl_ZPlusfile, x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	lpush(&lbl_sizze, MKI64(v1));
	int64_t v2 = mw_std_output_OUTPUTz_BUFFERz_SIZZE();
	VAL v3 = (mw_std_buffer_ZPlusBuffer_new(v2));
	VAL v4 = (lpop(&lbl_ZPlusfile));
	int64_t v5 = VI64(lpop(&lbl_sizze));
	VAL v6 = (mtw_std_output_ZPlusOutput_ZPlusOutput(v5, v4, v3));
	return v6;
}
static VAL mw_std_output_ZPlusOutput_endZBang (VAL x1) {
	VAL v0 = (mw_std_output_ZPlusOutput_flushZBang(x1));
	mtp_std_output_ZPlusOutput_ZPlusOutput(v0);
	int64_t v1 = VI64(lpop(&lbl_sizze));
	VAL v2 = (lpop(&lbl_ZPlusbuffer));
	mw_std_buffer_ZPlusBuffer_rdrop(v2);
	VAL v3 = (lpop(&lbl_ZPlusfile));
	return v3;
}
static void mw_std_output_ZPlusOutput_offset (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[1]);
	push_i64(v0);
	push_resource(x1);
}
static VAL mw_std_output_ZPlusOutput_flushZBang (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[3]));
	VAL v1 = VVAL(VTUP(v0)->cells[2]);
	incref(v1);
	VTUP(x1)->cells[3] = v0;
	int64_t v2 = VI64(VTUP(x1)->cells[1]);
	VAL v3 = (VVAL(VTUP(x1)->cells[2]));
	VAL v4 = (mw_std_file_ZPlusFile_unsafeZ_writeZBang(v1, v2, v3));
	VTUP(x1)->cells[2] = v4;
	int64_t v5 = 0LL;
	push_resource(x1);
	int64_t v6 = mw_std_prim_Int_ZToNat(v5);
	VAL r7 = pop_resource();
	VTUP(r7)->cells[1] = MKI64(v6);
	return r7;
}
static void mw_std_output_ZPlusOutput_capacityZ_total (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[3]));
	int64_t v1 = VI64(VTUP(v0)->cells[1]);
	VTUP(x1)->cells[3] = v0;
	push_i64(v1);
	push_resource(x1);
}
static void mw_std_output_ZPlusOutput_capacityZ_remaining (VAL x1) {
	mw_std_output_ZPlusOutput_capacityZ_total(x1);
	VAL r0 = pop_resource();
	int64_t v1 = VI64(VTUP(r0)->cells[1]);
	int64_t v2 = pop_i64();
	int64_t v3 = i64_sub(v2, v1);
	push_resource(r0);
	int64_t v4 = mw_std_prim_Int_ZToNat(v3);
	push_i64(v4);
}
static void mw_std_output_ZPlusOutput_fullZAsk (VAL x1) {
	mw_std_output_ZPlusOutput_capacityZ_remaining(x1);
	int64_t v0 = 0LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = pop_i64();
	bool v3 = (v2 <= v1);
	push_bool(v3);
}
static VAL mw_std_output_ZPlusOutput_put (VAL x1, VAL x2) {
	incref(x1);
	uint64_t v0 = str_size(VSTR(x1));
	push_resource(x2);
	push_value(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	VAL r2 = pop_resource();
	push_i64(v1);
	mw_std_output_ZPlusOutput_capacityZ_remaining(r2);
	int64_t v3 = pop_i64();
	int64_t v4 = pop_i64();
	bool v5 = (v4 > v3);
	if (v5) {
		VAL r6 = pop_resource();
		VAL v7 = (mw_std_output_ZPlusOutput_flushZBang(r6));
		VAL v8 = pop_value();
		incref(v8);
		uint64_t v9 = str_size(VSTR(v8));
		push_resource(v7);
		push_value(v8);
		int64_t v10 = mw_std_prim_Int_ZToNat(((int64_t)v9));
		VAL r11 = pop_resource();
		push_i64(v10);
		mw_std_output_ZPlusOutput_capacityZ_total(r11);
		int64_t v12 = pop_i64();
		int64_t v13 = pop_i64();
		bool v14 = (v13 >= v12);
		if (v14) {
			VAL v15 = pop_value();
			incref(v15);
			incref(v15);
			void* v16 = str_base(VSTR(v15));
			uint64_t v17 = str_size(VSTR(v15));
			push_ptr(v16);
			int64_t v18 = mw_std_prim_Int_ZToNat(((int64_t)v17));
			VAL r19 = pop_resource();
			VAL v20 = (VVAL(VTUP(r19)->cells[2]));
			VAL v21 = pop_value();
			VAL v22 = (mw_std_file_ZPlusFile_unsafeZ_writeZBang(v21, v18, v20));
			VTUP(r19)->cells[2] = v22;
			decref(v15);
			push_resource(r19);
		} else {
			VAL r23 = pop_resource();
			VAL v24 = pop_value();
			VAL v25 = (mw_std_output_ZPlusOutput_put(v24, r23));
			push_resource(v25);
		}
	} else {
		VAL v26 = pop_value();
		incref(v26);
		VAL r27 = pop_resource();
		push_value(v26);
		push_value(v26);
		mw_std_output_ZPlusOutput_offset(r27);
		VAL r28 = pop_resource();
		VAL v29 = (VVAL(VTUP(r28)->cells[3]));
		int64_t v30 = pop_i64();
		VAL v31 = pop_value();
		VAL v32 = (mw_std_buffer_ZPlusBuffer_ZBangStr(v31, v30, v29));
		VTUP(r28)->cells[3] = v32;
		STR* v33 = pop_str();
		uint64_t v34 = str_size(v33);
		push_resource(r28);
		int64_t v35 = mw_std_prim_Int_ZToNat(((int64_t)v34));
		VAL r36 = pop_resource();
		int64_t v37 = VI64(VTUP(r36)->cells[1]);
		int64_t v38 = i64_add(v35, v37);
		VTUP(r36)->cells[1] = MKI64(v38);
		push_resource(r36);
	}
	VAL r39 = pop_resource();
	return r39;
}
static VAL mw_std_output_ZPlusOutput_putZ_byte (int64_t x1, VAL x2) {
	push_i64(x1);
	mw_std_output_ZPlusOutput_fullZAsk(x2);
	bool v0 = pop_bool();
	if (v0) {
		VAL r1 = pop_resource();
		VAL v2 = (mw_std_output_ZPlusOutput_flushZBang(r1));
		push_resource(v2);
	} else {
	}
	VAL r3 = pop_resource();
	mw_std_output_ZPlusOutput_offset(r3);
	VAL r4 = pop_resource();
	VAL v5 = (VVAL(VTUP(r4)->cells[3]));
	int64_t v6 = pop_i64();
	int64_t v7 = pop_i64();
	VAL v8 = (mw_std_buffer_ZPlusBuffer_ZBangByte(v7, v6, v5));
	VTUP(r4)->cells[3] = v8;
	int64_t v9 = VI64(VTUP(r4)->cells[1]);
	int64_t v10 = 1LL;
	int64_t v11 = i64_add(v9, v10);
	VTUP(r4)->cells[1] = MKI64(v11);
	return r4;
}
static VAL mw_std_output_ZPlusOutput_line (VAL x1) {
	int64_t v0 = 10LL /* BLF */;
	VAL v1 = (mw_std_output_ZPlusOutput_putZ_byte(v0, x1));
	return v1;
}
static int64_t mw_std_posix_posixZ_openZBang (VAL x1, int64_t x2, int64_t x3) {
	incref(x1);
	void* v0 = str_base(VSTR(x1));
	push_ptr(v0);
	push_i64(x2);
	push_i64(x3);
	mext_std_posix_internalZ_posixZ_open();
	decref(x1);
	int64_t v1 = pop_i64();
	return v1;
}
static VAL mw_std_file_ZPlusFileZAsk_unwrapZBang (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +FileOk
			VAL v0 = (mtp_std_file_ZPlusFileZAsk_ZPlusFileOk(x1));
			push_resource(v0);
		} break;
		case 1LL: { // +FileErr
			VAL v1 = mtp_std_file_ZPlusFileZAsk_ZPlusFileErr(x1);
			push_value(v1);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r2 = pop_resource();
	return r2;
}
static void mw_std_prim_ZPlusWorld_openZ_fileZBang (VAL x1, VAL x2) {
	incref(x1);
	int64_t v0 = 0LL;
	int64_t v1 = 0LL;
	push_resource(x2);
	push_value(x1);
	int64_t v2 = mw_std_posix_posixZ_openZBang(x1, v0, v1);
	int64_t v3 = 0LL;
	bool v4 = (v2 > v3);
	if (v4) {
		VAL v5 = pop_value();
		decref(v5);
		int64_t v6 = 1LL /* True */;
		VAL v7 = (mtw_std_file_ZPlusFile_ZPlusFile(v2, v6));
		VAL v8 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileOk(v7));
		push_resource(v8);
	} else {
		STR* v9;
		STRLIT(v9, "", 0);
		STR* v10;
		STRLIT(v10, "failed to open file: ", 21);
		VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), MKSTR(v9)));
		VAL v12 = pop_value();
		VAL v13 = (mw_std_prim_Str_showZThen(v12, v11));
		VAL v14 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileErr(v13));
		push_resource(v14);
	}
}
static void mw_std_prim_ZPlusWorld_createZ_fileZBang (VAL x1, VAL x2) {
	incref(x1);
	push_resource(x2);
	push_value(x1);
	push_value(x1);
	int64_t v0 = mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC();
	int64_t v1 = 438LL;
	VAL v2 = pop_value();
	int64_t v3 = mw_std_posix_posixZ_openZBang(v2, v0, v1);
	int64_t v4 = 0LL;
	bool v5 = (v3 > v4);
	if (v5) {
		VAL v6 = pop_value();
		decref(v6);
		int64_t v7 = 1LL /* True */;
		VAL v8 = (mtw_std_file_ZPlusFile_ZPlusFile(v3, v7));
		VAL v9 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileOk(v8));
		push_resource(v9);
	} else {
		STR* v10;
		STRLIT(v10, "", 0);
		STR* v11;
		STRLIT(v11, "failed to create file: ", 23);
		VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), MKSTR(v10)));
		VAL v13 = pop_value();
		VAL v14 = (mw_std_prim_Str_showZThen(v13, v12));
		VAL v15 = (mtw_std_file_ZPlusFileZAsk_ZPlusFileErr(v14));
		push_resource(v15);
	}
}
static void mw_std_prim_ZPlusWorld_stderrZ_file (VAL x1) {
	int64_t v0 = 2LL;
	int64_t v1 = 0LL /* False */;
	push_resource(x1);
	VAL v2 = (mtw_std_file_ZPlusFile_ZPlusFile(v0, v1));
	push_resource(v2);
}
static int64_t mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC (void) {
	int64_t v0 = RUNNING_OS;
	int64_t v1 = mw_std_prim_Int_ZToOS(v0);
	switch (v1) {
		case 3LL: { // OS_MACOS
			int64_t v2 = 1537LL;
			push_i64(v2);
		} break;
		case 2LL: { // OS_LINUX
			int64_t v3 = 577LL;
			push_i64(v3);
		} break;
		case 1LL: { // OS_WINDOWS
			int64_t v4 = 769LL;
			push_i64(v4);
		} break;
		case 0LL: { // OS_UNKNOWN
			STR* v5;
			STRLIT(v5, "O_WRONLY|O_CREAT|O_TRUNC on unknown os", 38);
			push_str(v5);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v6 = pop_i64();
	return v6;
}
static VAL mw_std_file_ZPlusFile_closeZ_fileZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_std_file_ZPlusFile_ZPlusFile(x2);
	int64_t v0 = VI64(lpop(&lbl_owned));
	if (((bool)v0)) {
		int64_t v1 = VI64(lpop(&lbl_fileZ_descriptor));
		push_i64(v1);
		mext_std_posix_externalZ_posixZ_close();
		int64_t v2 = pop_i64();
		int64_t v3 = 0LL;
		bool v4 = (v2 < v3);
		bool v5 = !v4;
		if (v5) {
			push_i64(v2);
		} else {
			STR* v6;
			STRLIT(v6, "failed to close file", 20);
			push_i64(v2);
			push_str(v6);
			do_panic();
		}
		int64_t v7 = pop_i64();
	} else {
		int64_t v8 = VI64(lpop(&lbl_fileZ_descriptor));
	}
	VAL r9 = pop_resource();
	return r9;
}
static VAL mw_std_file_ZPlusFile_unsafeZ_writeZBang (VAL x1, int64_t x2, VAL x3) {
	int64_t v0 = VI64(VTUP(x3)->cells[1]);
	push_i64(v0);
	push_resource(x3);
	push_value(x1);
	push_i64(x2);
	mext_std_posix_externalZ_posixZ_write();
	int64_t v1 = pop_i64();
	int64_t v2 = 0LL;
	bool v3 = (v1 < v2);
	bool v4 = !v3;
	if (v4) {
		push_i64(v1);
	} else {
		STR* v5;
		STRLIT(v5, "write failed", 12);
		push_i64(v1);
		push_str(v5);
		do_panic();
	}
	int64_t v6 = pop_i64();
	int64_t v7 = mw_std_prim_Int_ZToNat(v6);
	bool v8 = (v7 == x2);
	if (v8) {
		push_i64(v7);
		push_i64(x2);
	} else {
		STR* v9;
		STRLIT(v9, "write output fewer bytes than expected", 38);
		push_i64(v7);
		push_i64(x2);
		push_str(v9);
		do_panic();
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	VAL r12 = pop_resource();
	return r12;
}
static void mw_std_file_ZPlusFile_unsafeZ_readZBang (VAL x1, int64_t x2, VAL x3) {
	int64_t v0 = VI64(VTUP(x3)->cells[1]);
	push_i64(v0);
	push_resource(x3);
	push_value(x1);
	push_i64(x2);
	mext_std_posix_externalZ_posixZ_read();
	int64_t v1 = pop_i64();
	int64_t v2 = 0LL;
	bool v3 = (v1 < v2);
	bool v4 = !v3;
	if (v4) {
		push_i64(v1);
	} else {
		STR* v5;
		STRLIT(v5, "read failed", 11);
		push_i64(v1);
		push_str(v5);
		do_panic();
	}
	int64_t v6 = pop_i64();
	int64_t v7 = mw_std_prim_Int_ZToNat(v6);
	push_i64(v7);
}
static void mw_std_file_ZPlusFile_readZ_fileZBang (VAL x1) {
	VAL v0 = (mw_std_input_ZPlusInput_startZBang(x1));
	mw_std_input_ZPlusInput_readZ_fileZBang(v0);
	VAL r1 = pop_resource();
	VAL v2 = (mw_std_input_ZPlusInput_endZBang(r1));
	push_resource(v2);
}
static VAL mw_std_prim_ZPlusWorld_traceZ_ (VAL x1, VAL x2) {
	push_value(x1);
	mw_std_prim_ZPlusWorld_stderrZ_file(x2);
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	void* v1 = str_base(VSTR(v0));
	uint64_t v2 = str_size(VSTR(v0));
	push_ptr(v1);
	int64_t v3 = mw_std_prim_Int_ZToNat(((int64_t)v2));
	VAL r4 = pop_resource();
	VAL v5 = pop_value();
	VAL v6 = (mw_std_file_ZPlusFile_unsafeZ_writeZBang(v5, v3, r4));
	decref(v0);
	VAL r7 = pop_resource();
	VAL v8 = (mw_std_file_ZPlusFile_closeZ_fileZBang(r7, v6));
	return v8;
}
static void mw_std_prim_ZPlusWorld_isZ_directoryZAsk (VAL x1, VAL x2) {
	int64_t v0 = 256LL;
	push_resource(x1);
	push_value(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL v2 = (mw_std_buffer_ZPlusBuffer_new(v1));
	VAL v3 = pop_value();
	incref(v3);
	incref(v3);
	void* v4 = str_base(VSTR(v3));
	uint64_t v5 = str_size(VSTR(v3));
	push_resource(v2);
	push_ptr(v4);
	int64_t v6 = mw_std_prim_Int_ZToNat(((int64_t)v5));
	VAL v7 = pop_value();
	incref(v7);
	int64_t v8 = (0LL /* +Unsafe */);
	void* v9 = (void*)(v6 + (char*)VPTR(v7));
	uint8_t v10 = *(uint8_t*)v9;
	int64_t v11 = 0LL;
	bool v12 = (((int64_t)v10) == v11);
	if (v12) {
		push_value(v7);
	} else {
		STR* v13;
		STRLIT(v13, "tried to use Str as CStr, but Str is not zero terminated", 56);
		push_value(v7);
		push_str(v13);
		do_panic();
	}
	VAL r14 = pop_resource();
	VAL v15 = VVAL(VTUP(r14)->cells[2]);
	incref(v15);
	int64_t v16 = (0LL /* +Unsafe */);
	push_value(v15);
	push_resource(r14);
	push_resource(MKI64(v16));
	mext_std_world_posixZ_stat();
	VAL r17 = pop_resource();
	int64_t v18 = 0LL;
	int64_t v19 = pop_i64();
	bool v20 = (v19 == v18);
	if (v20) {
		VAL r21 = pop_resource();
		VAL v22 = VVAL(VTUP(r21)->cells[2]);
		incref(v22);
		int64_t v23 = (0LL /* +Unsafe */);
		push_resource(r21);
		mw_std_world_stz_modeZAt(v22, MKI64(v23));
		VAL r24 = pop_resource();
		int64_t v25 = pop_i64();
		int64_t v26 = mw_std_world_Sz_ISDIR(v25);
		push_i64(v26);
	} else {
		int64_t v27 = 0LL /* False */;
		push_i64(v27);
	}
	decref(v3);
	VAL r28 = pop_resource();
	mw_std_buffer_ZPlusBuffer_rdrop(r28);
}
static int64_t mw_std_world_Sz_IFMT (void) {
	int64_t v0 = 61440LL;
	int64_t v1 = mw_std_prim_Int_ZToU16(v0);
	return v1;
}
static int64_t mw_std_world_Sz_IFDIR (void) {
	int64_t v0 = 16384LL;
	int64_t v1 = mw_std_prim_Int_ZToU16(v0);
	return v1;
}
static int64_t mw_std_world_Sz_ISDIR (int64_t x1) {
	push_i64(x1);
	int64_t v0 = mw_std_world_Sz_IFMT();
	uint64_t v1 = pop_u64();
	uint64_t v2 = (v1 & ((uint64_t)v0));
	push_u64(v2);
	int64_t v3 = mw_std_world_Sz_IFDIR();
	int64_t v4 = pop_i64();
	bool v5 = (v4 == v3);
	return ((int64_t)v5);
}
static void mw_std_world_stz_modeZAt (VAL x1, VAL x2) {
	int64_t v0 = RUNNING_OS;
	push_value(x1);
	push_resource(x2);
	int64_t v1 = mw_std_prim_Int_ZToOS(v0);
	switch (v1) {
		case 2LL: { // OS_LINUX
			int64_t v2 = 24LL;
			push_i64(v2);
		} break;
		case 1LL: { // OS_WINDOWS
			int64_t v3 = 6LL;
			push_i64(v3);
		} break;
		case 3LL: { // OS_MACOS
			int64_t v4 = RUNNING_ARCH;
			int64_t v5 = mw_std_prim_Int_ZToArch(v4);
			int64_t v6 = 3LL /* ARCH_ARM64 */;
			bool v7 = (v5 == v6);
			if (v7) {
				int64_t v8 = 4LL;
				push_i64(v8);
			} else {
				int64_t v9 = 8LL;
				push_i64(v9);
			}
		} break;
		default: {
			int64_t v10 = 8LL;
			push_i64(v10);
		} break;
	}
	int64_t v11 = pop_i64();
	VAL v12 = pop_value();
	void* v13 = (void*)(v11 + (char*)VPTR(v12));
	uint16_t v14 = *(uint16_t*)v13;
	push_u16(v14);
}
static VAL mw_std_terminal_SGRColor_showZThen (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Numbered
			push_resource(x2);
			int64_t v0 = mtp_std_terminal_SGRColor_Numbered(x1);
			STR* v1;
			STRLIT(v1, ";5;", 3);
			VAL r2 = pop_resource();
			push_i64(v0);
			VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v1), r2));
			int64_t v4 = pop_i64();
			STR* v5 = i64_show(v4);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), v3));
			push_resource(v6);
		} break;
		case 1LL: { // RGB
			push_resource(x2);
			mtp_std_terminal_SGRColor_RGB(x1);
			STR* v7;
			STRLIT(v7, ";2;", 3);
			VAL r8 = pop_resource();
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), r8));
			int64_t v10 = pop_i64();
			STR* v11 = i64_show(v10);
			VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v9));
			STR* v13;
			STRLIT(v13, ";", 1);
			VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), v12));
			int64_t v15 = pop_i64();
			STR* v16 = i64_show(v15);
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), v14));
			STR* v18;
			STRLIT(v18, ";", 1);
			VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), v17));
			int64_t v20 = pop_i64();
			STR* v21 = i64_show(v20);
			VAL v22 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v21), v19));
			push_resource(v22);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r23 = pop_resource();
	return r23;
}
static VAL mw_std_terminal_Sgr_emitZThen (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = (mw_std_terminal_csiZThen(x2));
	VAL v1 = pop_value();
	incref(v1);
	push_resource(v0);
	push_value(v1);
	push_value(v1);
	{
		VAL val = pop_value();
		USIZE tag = get_data_tag(val);
		push_u64(tag);
		decref(val);
	}
	int64_t v2 = pop_i64();
	STR* v3 = i64_show(v2);
	VAL r4 = pop_resource();
	VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), r4));
	VAL v6 = pop_value();
	switch (get_data_tag(v6)) {
		case 38LL: { // FGColor
			push_resource(v5);
			VAL v7 = mtp_std_terminal_Sgr_FGColor(v6);
			VAL r8 = pop_resource();
			VAL v9 = (mw_std_terminal_SGRColor_showZThen(v7, r8));
			push_resource(v9);
		} break;
		case 48LL: { // BGColor
			push_resource(v5);
			VAL v10 = mtp_std_terminal_Sgr_BGColor(v6);
			VAL r11 = pop_resource();
			VAL v12 = (mw_std_terminal_SGRColor_showZThen(v10, r11));
			push_resource(v12);
		} break;
		default: {
			decref(v6);
			push_resource(v5);
		} break;
	}
	STR* v13;
	STRLIT(v13, "m", 1);
	VAL r14 = pop_resource();
	VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), r14));
	return v15;
}
static VAL mw_std_terminal_csiZThen (VAL x1) {
	int64_t v0 = 27LL /* BESC */;
	VAL v1 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(v0, x1));
	int64_t v2 = 91LL /* BLSQUARE */;
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(v2, v1));
	return v3;
}
static VAL mw_argZ_parser_state_State_1_init (VAL x1) {
	push_value(x1);
	VAL v0 = mw_argZ_parser_parse_argvZ_toZ_str();
	int64_t v1 = 0LL;
	int64_t v2 = (0LL /* +Unsafe */);
	lpush(&lbl_argv, v0);
	mw_argZ_parser_parse_readZ_fromZ_argv(MKI64(v2), v1);
	VAL r3 = pop_resource();
	VAL v4 = pop_value();
	VAL v5 = lpop(&lbl_argv);
	VAL v6 = mtw_argZ_parser_state_ArgvInfo_ArgvInfo(v5, v4);
	int64_t v7 = 0LL /* False */;
	int64_t v8 = 0LL /* None */;
	int64_t v9 = 0LL /* None */;
	lpush(&lbl_argvZ_info, v6);
	VAL v10 = mtw_argZ_parser_state_CurrentArg_CurrentArg(v7, MKI64(v8), MKI64(v9));
	VAL v11 = pop_value();
	int64_t v12 = 0LL;
	int64_t v13 = 0LL;
	int64_t v14 = 0LL /* None */;
	VAL v15 = lpop(&lbl_argvZ_info);
	VAL v16 = mtw_argZ_parser_state_State_1_State(v11, v15, v10, v12, v13, MKI64(v14));
	return v16;
}
static VAL mw_argZ_parser_state_State_1_argv (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[2]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	decref(v0);
	return v1;
}
static VAL mw_argZ_parser_state_State_1_programZ_name (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[2]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(v0)->cells[2]);
	incref(v1);
	decref(v0);
	return v1;
}
static int64_t mw_argZ_parser_state_State_1_parsingZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[3]);
	incref(v0);
	decref(x1);
	int64_t v1 = VI64(VTUP(v0)->cells[1]);
	decref(v0);
	return v1;
}
static VAL mw_argZ_parser_state_State_1_parsingZAskZBang (int64_t x1, VAL x2) {
	incref(x2);
	VAL v0 = VVAL(VTUP(x2)->cells[3]);
	incref(v0);
	decref(x2);
	VAL v1 = tup_replace(v0, 1, MKI64(x1));
	VAL v2 = tup_replace(x2, 3, v1);
	return v2;
}
static VAL mw_argZ_parser_state_State_1_optionZ_option (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[3]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(v0)->cells[3]);
	incref(v1);
	decref(v0);
	return v1;
}
static VAL mw_argZ_parser_state_State_1_optionZ_optionZBang (VAL x1, VAL x2) {
	incref(x2);
	VAL v0 = VVAL(VTUP(x2)->cells[3]);
	incref(v0);
	decref(x2);
	VAL v1 = tup_replace(v0, 3, x1);
	VAL v2 = tup_replace(x2, 3, v1);
	return v2;
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop (VAL x1) {
	mtp_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser(x1);
	VAL v0 = lpop(&lbl_argumentZ_parser);
	decref(v0);
	VAL v1 = lpop(&lbl_state);
	decref(v1);
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_parser (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	VAL v1 = VVAL(VTUP(v0)->cells[2]);
	incref(v1);
	decref(v0);
	push_resource(x1);
	push_value(v1);
}
static int64_t mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // Short
			int64_t v0 = mtp_argZ_parser_types_ArgpOptionType_Short(x1);
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
	}
	int64_t v3 = pop_i64();
	return v3;
}
static VAL mw_argZ_parser_types_ArgumentParsingError_emitZThen (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 1LL: { // MissingArg
			push_resource(x2);
			VAL v0 = mtp_argZ_parser_types_ArgumentParsingError_MissingArg(x1);
			int64_t v1 = 31LL /* FGRed */;
			VAL r2 = pop_resource();
			push_value(v0);
			VAL v3 = (mw_std_terminal_Sgr_emitZThen(MKI64(v1), r2));
			STR* v4;
			STRLIT(v4, "Missing argument: ", 18);
			VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), v3));
			int64_t v6 = 0LL /* Reset */;
			VAL v7 = (mw_std_terminal_Sgr_emitZThen(MKI64(v6), v5));
			VAL v8 = pop_value();
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(v8, v7));
			push_resource(v9);
		} break;
		case 0LL: { // MissingArgValue
			STR* v10;
			STRLIT(v10, "Missing associated value for flag option", 40);
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), x2));
			push_resource(v11);
		} break;
		case 2LL: { // TooManyArgs
			STR* v12;
			STRLIT(v12, "Too many positional arguments passed", 36);
			VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v12), x2));
			push_resource(v13);
		} break;
		case 3LL: { // TooFewArgs
			STR* v14;
			STRLIT(v14, "Too few positional arguments passed", 35);
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), x2));
			push_resource(v15);
		} break;
		case 4LL: { // UnknownArg
			STR* v16;
			STRLIT(v16, "Got an unknown option", 21);
			VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v16), x2));
			push_resource(v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r18 = pop_resource();
	return r18;
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_usage (VAL x1) {
	STR* v0;
	STRLIT(v0, "", 0);
	int64_t v1 = 1LL /* Bold */;
	push_resource(x1);
	VAL v2 = (mw_std_terminal_Sgr_emitZThen(MKI64(v1), MKSTR(v0)));
	STR* v3;
	STRLIT(v3, "Usage: ", 7);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), v2));
	int64_t v5 = 0LL /* Reset */;
	VAL v6 = (mw_std_terminal_Sgr_emitZThen(MKI64(v5), v4));
	STR* v7;
	STRLIT(v7, "  ", 2);
	VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
	VAL r9 = pop_resource();
	VAL v10 = VVAL(VTUP(r9)->cells[2]);
	incref(v10);
	push_resource(r9);
	push_resource(v8);
	VAL v11 = mw_argZ_parser_state_State_1_programZ_name(v10);
	VAL r12 = pop_resource();
	VAL v13 = (mw_std_str_ZPlusStr_pushZ_strZBang(v11, r12));
	STR* v14;
	STRLIT(v14, " [options] ", 11);
	VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), v13));
	VAL r16 = pop_resource();
	VAL v17 = VVAL(VTUP(r16)->cells[1]);
	incref(v17);
	VAL v18 = VVAL(VTUP(v17)->cells[3]);
	incref(v18);
	decref(v17);
	switch (get_data_tag(v18)) {
		case 1LL: { // Some
			push_resource(r16);
			push_resource(v15);
			VAL v19 = mtp_std_maybe_Maybe_1_Some(v18);
			VAL r20 = pop_resource();
			VAL v21 = (mw_std_str_ZPlusStr_pushZ_strZBang(v19, r20));
			push_resource(v21);
		} break;
		case 0LL: { // None
			push_resource(r16);
			push_resource(v15);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(r16);
			push_resource(v15);
		}
	}
	STR* v22;
	STRLIT(v22, "\n\n", 2);
	VAL r23 = pop_resource();
	VAL v24 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v22), r23));
	VAL r25 = pop_resource();
	VAL v26 = VVAL(VTUP(r25)->cells[1]);
	incref(v26);
	VAL v27 = VVAL(VTUP(v26)->cells[1]);
	incref(v27);
	decref(v26);
	push_resource(r25);
	push_resource(v24);
	mw_std_list_List_1_uncons(v27);
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	push_value(v28);
	push_value(v29);
	while(1) {
		VAL v30 = pop_value();
		incref(v30);
		push_value(v30);
		int64_t v31 = mw_std_maybe_Maybe_1_someZAsk(v30);
		if (!((bool)v31)) break;
		VAL v32 = pop_value();
		VAL v33 = mw_std_maybe_Maybe_1_unwrap(v32);
		VAL v34 = pop_value();
		VAL r35 = pop_resource();
		VAL r36 = pop_resource();
		mw_argZ_parser_types_ArgpOption_usageZThen(r36, r35, v33);
		mw_std_list_List_1_uncons(v34);
		VAL v37 = pop_value();
		VAL v38 = pop_value();
		push_value(v37);
		push_value(v38);
	}
	VAL v39 = pop_value();
	decref(v39);
	VAL v40 = pop_value();
	decref(v40);
	STR* v41;
	STRLIT(v41, "\n", 1);
	VAL r42 = pop_resource();
	VAL v43 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v41), r42));
	push_value(v43);
}
static void mw_argZ_parser_types_ArgpOption_usageZThen (VAL x1, VAL x2, VAL x3) {
	STR* v0;
	STRLIT(v0, "  ", 2);
	push_resource(x1);
	push_value(x3);
	VAL v1 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v0), x2));
	int64_t v2 = 0LL;
	VAL v3 = pop_value();
	incref(v3);
	VAL v4 = VVAL(VTUP(v3)->cells[2]);
	incref(v4);
	decref(v3);
	switch (get_data_tag(v4)) {
		case 0LL: { // Short
			push_resource(v1);
			lpush(&lbl_colZ_offset, MKI64(v2));
			push_value(v3);
			int64_t v5 = mtp_argZ_parser_types_ArgpOptionType_Short(v4);
			push_i64(v5);
			int64_t v6 = mw_std_byte_Byte_isZ_printable(v5);
			if (((bool)v6)) {
				int64_t v7 = VI64(lpop(&lbl_colZ_offset));
				int64_t v8 = 2LL;
				int64_t v9 = i64_add(v7, v8);
				STR* v10;
				STRLIT(v10, "-", 1);
				VAL r11 = pop_resource();
				lpush(&lbl_colZ_offset, MKI64(v9));
				VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), r11));
				int64_t v13 = pop_i64();
				push_i64(v13);
				VAL v14 = (mw_std_byte_Byte_emitZ_asciiZThen(v12, v13));
				push_resource(v14);
			} else {
			}
			int64_t v15 = pop_i64();
		} break;
		default: {
			decref(v4);
			push_resource(v1);
			lpush(&lbl_colZ_offset, MKI64(v2));
			push_value(v3);
		} break;
	}
	VAL v16 = pop_value();
	incref(v16);
	VAL v17 = VVAL(VTUP(v16)->cells[2]);
	incref(v17);
	decref(v16);
	push_value(v16);
	int64_t v18 = mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk(v17);
	if (((bool)v18)) {
		VAL v19 = pop_value();
		incref(v19);
		VAL v20 = VVAL(VTUP(v19)->cells[1]);
		incref(v20);
		decref(v19);
		push_value(v19);
		int64_t v21 = mw_std_maybe_Maybe_1_someZAsk(v20);
		push_i64(v21);
	} else {
		int64_t v22 = 0LL /* False */;
		push_i64(v22);
	}
	bool v23 = pop_bool();
	if (v23) {
		STR* v24;
		STRLIT(v24, ", ", 2);
		VAL r25 = pop_resource();
		VAL v26 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), r25));
		int64_t v27 = VI64(lpop(&lbl_colZ_offset));
		int64_t v28 = 2LL;
		int64_t v29 = i64_add(v27, v28);
		push_resource(v26);
		lpush(&lbl_colZ_offset, MKI64(v29));
	} else {
	}
	VAL v30 = pop_value();
	incref(v30);
	VAL v31 = VVAL(VTUP(v30)->cells[1]);
	incref(v31);
	decref(v30);
	switch (get_data_tag(v31)) {
		case 1LL: { // Some
			push_value(v30);
			VAL v32 = mtp_std_maybe_Maybe_1_Some(v31);
			incref(v32);
			uint64_t v33 = str_size(VSTR(v32));
			push_value(v32);
			int64_t v34 = mw_std_prim_Int_ZToNat(((int64_t)v33));
			int64_t v35 = VI64(lpop(&lbl_colZ_offset));
			int64_t v36 = 2LL;
			int64_t v37 = i64_add(v35, v36);
			int64_t v38 = i64_add(v34, v37);
			STR* v39;
			STRLIT(v39, "--", 2);
			VAL r40 = pop_resource();
			lpush(&lbl_colZ_offset, MKI64(v38));
			VAL v41 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v39), r40));
			VAL v42 = pop_value();
			VAL v43 = (mw_std_str_ZPlusStr_pushZ_strZBang(v42, v41));
			VAL v44 = pop_value();
			incref(v44);
			VAL v45 = VVAL(VTUP(v44)->cells[3]);
			incref(v45);
			decref(v44);
			switch (get_data_tag(v45)) {
				case 1LL: { // Some
					push_resource(v43);
					push_value(v44);
					VAL v46 = mtp_std_maybe_Maybe_1_Some(v45);
					incref(v46);
					uint64_t v47 = str_size(VSTR(v46));
					push_value(v46);
					int64_t v48 = mw_std_prim_Int_ZToNat(((int64_t)v47));
					int64_t v49 = VI64(lpop(&lbl_colZ_offset));
					int64_t v50 = 1LL;
					int64_t v51 = i64_add(v49, v50);
					int64_t v52 = i64_add(v48, v51);
					STR* v53;
					STRLIT(v53, " ", 1);
					VAL r54 = pop_resource();
					lpush(&lbl_colZ_offset, MKI64(v52));
					VAL v55 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v53), r54));
					VAL v56 = pop_value();
					VAL v57 = (mw_std_str_ZPlusStr_pushZ_strZBang(v56, v55));
					push_resource(v57);
				} break;
				case 0LL: { // None
					push_resource(v43);
					push_value(v44);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_resource(v43);
					push_value(v44);
				}
			}
		} break;
		case 0LL: { // None
			push_value(v30);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(v30);
		}
	}
	VAL v58 = pop_value();
	incref(v58);
	VAL v59 = VVAL(VTUP(v58)->cells[4]);
	incref(v59);
	decref(v58);
	switch (get_data_tag(v59)) {
		case 1LL: { // Some
			push_value(v58);
			VAL v60 = mtp_std_maybe_Maybe_1_Some(v59);
			int64_t v61 = VI64(lpop(&lbl_colZ_offset));
			VAL r62 = pop_resource();
			VAL r63 = pop_resource();
			VAL v64 = VVAL(VTUP(r63)->cells[2]);
			incref(v64);
			int64_t v65 = VI64(VTUP(v64)->cells[5]);
			decref(v64);
			bool v66 = (v61 < v65);
			if (v66) {
				int64_t v67 = i64_sub(v65, v61);
				int64_t v68 = 0LL;
				push_value(v60);
				lpush(&lbl_colZ_offset, MKI64(v61));
				push_resource(r63);
				push_resource(r62);
				VAL v69 = mw_std_prim_Int_range(v68, v67);
				mw_std_list_List_1_uncons(v69);
				VAL v70 = pop_value();
				VAL v71 = pop_value();
				push_value(v70);
				push_value(v71);
				while(1) {
					VAL v72 = pop_value();
					incref(v72);
					push_value(v72);
					int64_t v73 = mw_std_maybe_Maybe_1_someZAsk(v72);
					if (!((bool)v73)) break;
					VAL v74 = pop_value();
					VAL v75 = mw_std_maybe_Maybe_1_unwrap(v74);
					VAL v76 = pop_value();
					decref(v75);
					STR* v77;
					STRLIT(v77, " ", 1);
					VAL r78 = pop_resource();
					VAL v79 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v77), r78));
					push_resource(v79);
					mw_std_list_List_1_uncons(v76);
					VAL v80 = pop_value();
					VAL v81 = pop_value();
					push_value(v80);
					push_value(v81);
				}
				VAL v82 = pop_value();
				decref(v82);
				VAL v83 = pop_value();
				decref(v83);
			} else {
				push_value(v60);
				lpush(&lbl_colZ_offset, MKI64(v61));
				push_resource(r63);
				push_resource(r62);
			}
			STR* v84;
			STRLIT(v84, "    ", 4);
			VAL r85 = pop_resource();
			VAL v86 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v84), r85));
			VAL v87 = pop_value();
			VAL v88 = (mw_std_str_ZPlusStr_pushZ_strZBang(v87, v86));
			push_resource(v88);
		} break;
		case 0LL: { // None
			push_value(v58);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(v58);
		}
	}
	int64_t v89 = VI64(lpop(&lbl_colZ_offset));
	STR* v90;
	STRLIT(v90, "\n", 1);
	VAL r91 = pop_resource();
	VAL v92 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v90), r91));
	VAL v93 = pop_value();
	decref(v93);
	push_resource(v92);
}
static void mw_argZ_parser_parse_checkZ_shortZ_flag (VAL x1, VAL x2, VAL x3) {
	incref(x2);
	VAL v0 = VVAL(VTUP(x2)->cells[2]);
	incref(v0);
	decref(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // Short
			push_resource(x1);
			push_value(x2);
			push_value(x3);
			int64_t v1 = mtp_argZ_parser_types_ArgpOptionType_Short(v0);
			int64_t v2 = 0LL;
			VAL v3 = pop_value();
			push_i64(v1);
			int64_t v4 = mw_std_prim_Str_byteZAt(v2, v3);
			int64_t v5 = pop_i64();
			bool v6 = (v5 == v4);
			push_bool(v6);
		} break;
		default: {
			decref(v0);
			decref(x3);
			int64_t v7 = 0LL /* False */;
			push_resource(x1);
			push_value(x2);
			push_i64(v7);
		} break;
	}
}
static void mw_argZ_parser_parse_checkZ_longZ_flag (VAL x1, VAL x2, VAL x3) {
	incref(x2);
	VAL v0 = VVAL(VTUP(x2)->cells[1]);
	incref(v0);
	decref(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			push_resource(x1);
			push_value(x2);
			push_value(x3);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			STR* v2 = pop_str();
			bool v3 = (str_cmp(v2, VSTR(v1)) == 0);
			push_bool(v3);
		} break;
		case 0LL: { // None
			decref(x3);
			int64_t v4 = 0LL /* False */;
			push_resource(x1);
			push_value(x2);
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_value(x2);
			push_value(x3);
		}
	}
}
static void mw_argZ_parser_parse_parseZ_flags (VAL x1, VAL x2) {
	incref(x2);
	uint64_t v0 = str_size(VSTR(x2));
	push_resource(x1);
	push_value(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	int64_t v2 = 2LL;
	push_i64(v1);
	int64_t v3 = mw_std_prim_Int_ZToNat(v2);
	int64_t v4 = pop_i64();
	bool v5 = (v4 >= v3);
	if (v5) {
		int64_t v6 = 1LL;
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		int64_t v8 = mw_std_prim_Str_byteZAt(v6, v7);
		int64_t v9 = 45LL /* B'-' */;
		bool v10 = (v8 == v9);
		push_bool(v10);
	} else {
		int64_t v11 = 0LL /* False */;
		push_i64(v11);
	}
	bool v12 = pop_bool();
	if (v12) {
		int64_t v13 = 2LL;
		int64_t v14 = mw_std_prim_Int_ZToNat(v13);
		VAL v15 = pop_value();
		incref(v15);
		int64_t v16 = (0LL /* +Unsafe */);
		push_value(v15);
		mw_std_prim_Str_dropZ_bytes(v14, v15, MKI64(v16));
		VAL r17 = pop_resource();
		VAL r18 = pop_resource();
		VAL v19 = VVAL(VTUP(r18)->cells[1]);
		incref(v19);
		VAL v20 = VVAL(VTUP(v19)->cells[1]);
		incref(v20);
		decref(v19);
		int64_t v21 = 0LL /* None */;
		push_resource(r18);
		push_i64(v21);
		mw_std_list_List_1_uncons(v20);
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		push_value(v22);
		push_value(v23);
		while(1) {
			VAL v24 = pop_value();
			incref(v24);
			push_value(v24);
			int64_t v25 = mw_std_maybe_Maybe_1_someZAsk(v24);
			if (!((bool)v25)) break;
			VAL v26 = pop_value();
			VAL v27 = mw_std_maybe_Maybe_1_unwrap(v26);
			VAL v28 = pop_value();
			VAL v29 = pop_value();
			incref(v27);
			VAL v30 = pop_value();
			incref(v30);
			VAL r31 = pop_resource();
			push_value(v30);
			mw_argZ_parser_parse_checkZ_longZ_flag(r31, v27, v30);
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			decref(v33);
			if (VBOOL(v32)) {
				VAL v34 = mtw_std_maybe_Maybe_1_Some(v27);
				push_value(v34);
			} else {
				decref(v27);
				int64_t v35 = 0LL /* None */;
				push_i64(v35);
			}
			VAL v36 = pop_value();
			switch (get_data_tag(v36)) {
				case 0LL: { // None
					push_value(v29);
					push_value(v28);
				} break;
				default: {
					decref(v28);
					decref(v29);
					int64_t v37 = 0LL /* Nil */;
					push_value(v36);
					push_i64(v37);
				} break;
			}
			VAL v38 = pop_value();
			mw_std_list_List_1_uncons(v38);
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			push_value(v39);
			push_value(v40);
		}
		VAL v41 = pop_value();
		decref(v41);
		VAL v42 = pop_value();
		decref(v42);
		VAL v43 = pop_value();
		VAL v44 = pop_value();
		decref(v44);
		switch (get_data_tag(v43)) {
			case 1LL: { // Some
				VAL v45 = mtp_std_maybe_Maybe_1_Some(v43);
				incref(v45);
				VAL v46 = VVAL(VTUP(v45)->cells[3]);
				incref(v46);
				decref(v45);
				switch (get_data_tag(v46)) {
					case 1LL: { // Some
						push_value(v45);
						VAL v47 = mtp_std_maybe_Maybe_1_Some(v46);
						int64_t v48 = 1LL /* True */;
						VAL r49 = pop_resource();
						VAL v50 = VVAL(VTUP(r49)->cells[2]);
						incref(v50);
						push_value(v47);
						push_resource(r49);
						VAL v51 = mw_argZ_parser_state_State_1_parsingZAskZBang(v48, v50);
						VAL r52 = pop_resource();
						VAL v53 = VTUP(r52)->cells[2];
						decref(v53);
						VTUP(r52)->cells[2] = v51;
						VAL v54 = pop_value();
						decref(v54);
						VAL v55 = pop_value();
						push_resource(r52);
						VAL v56 = mtw_std_maybe_Maybe_1_Some(v55);
						VAL r57 = pop_resource();
						VAL v58 = VVAL(VTUP(r57)->cells[2]);
						incref(v58);
						push_resource(r57);
						VAL v59 = mw_argZ_parser_state_State_1_optionZ_optionZBang(v56, v58);
						VAL r60 = pop_resource();
						VAL v61 = VTUP(r60)->cells[2];
						decref(v61);
						VTUP(r60)->cells[2] = v59;
						push_resource(r60);
					} break;
					case 0LL: { // None
						VAL v62 = VVAL(VTUP(v45)->cells[2]);
						incref(v62);
						decref(v45);
						VAL r63 = pop_resource();
						VAL v64 = VVAL(VTUP(r63)->cells[2]);
						incref(v64);
						VAL v65 = VVAL(VTUP(v64)->cells[1]);
						incref(v65);
						decref(v64);
						int64_t v66 = 0LL /* None */;
						push_value(v65);
						push_i64(v66);
						push_value(v62);
						mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r63);
						VAL v67 = pop_value();
						switch (get_data_tag(v67)) {
							case 1LL: { // Some
								VAL v68 = mtp_std_maybe_Maybe_1_Some(v67);
								run_value(v68);
								VAL r69 = pop_resource();
								VAL v70 = VVAL(VTUP(r69)->cells[2]);
								incref(v70);
								VAL v71 = pop_value();
								VAL v72 = tup_replace(v70, 1, v71);
								VAL v73 = VTUP(r69)->cells[2];
								decref(v73);
								VTUP(r69)->cells[2] = v72;
								push_resource(r69);
							} break;
							case 0LL: { // None
								VAL v74 = pop_value();
								decref(v74);
								VAL v75 = pop_value();
								decref(v75);
								VAL v76 = pop_value();
								decref(v76);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v45);
					}
				}
				int64_t v77 = 0LL /* None */;
				push_i64(v77);
			} break;
			case 0LL: { // None
				int64_t v78 = 4LL /* UnknownArg */;
				VAL v79 = mtw_std_maybe_Maybe_1_Some(MKI64(v78));
				push_value(v79);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	} else {
		int64_t v80 = 1LL;
		int64_t v81 = mw_std_prim_Int_ZToNat(v80);
		VAL v82 = pop_value();
		incref(v82);
		int64_t v83 = (0LL /* +Unsafe */);
		push_value(v82);
		mw_std_prim_Str_dropZ_bytes(v81, v82, MKI64(v83));
		VAL r84 = pop_resource();
		VAL r85 = pop_resource();
		VAL v86 = VVAL(VTUP(r85)->cells[1]);
		incref(v86);
		VAL v87 = VVAL(VTUP(v86)->cells[1]);
		incref(v87);
		decref(v86);
		int64_t v88 = 0LL /* None */;
		push_resource(r85);
		push_i64(v88);
		mw_std_list_List_1_uncons(v87);
		VAL v89 = pop_value();
		VAL v90 = pop_value();
		push_value(v89);
		push_value(v90);
		while(1) {
			VAL v91 = pop_value();
			incref(v91);
			push_value(v91);
			int64_t v92 = mw_std_maybe_Maybe_1_someZAsk(v91);
			if (!((bool)v92)) break;
			VAL v93 = pop_value();
			VAL v94 = mw_std_maybe_Maybe_1_unwrap(v93);
			VAL v95 = pop_value();
			VAL v96 = pop_value();
			incref(v94);
			VAL v97 = pop_value();
			incref(v97);
			VAL r98 = pop_resource();
			push_value(v97);
			mw_argZ_parser_parse_checkZ_shortZ_flag(r98, v94, v97);
			VAL v99 = pop_value();
			VAL v100 = pop_value();
			decref(v100);
			if (VBOOL(v99)) {
				VAL v101 = mtw_std_maybe_Maybe_1_Some(v94);
				push_value(v101);
			} else {
				decref(v94);
				int64_t v102 = 0LL /* None */;
				push_i64(v102);
			}
			VAL v103 = pop_value();
			switch (get_data_tag(v103)) {
				case 0LL: { // None
					push_value(v96);
					push_value(v95);
				} break;
				default: {
					decref(v95);
					decref(v96);
					int64_t v104 = 0LL /* Nil */;
					push_value(v103);
					push_i64(v104);
				} break;
			}
			VAL v105 = pop_value();
			mw_std_list_List_1_uncons(v105);
			VAL v106 = pop_value();
			VAL v107 = pop_value();
			push_value(v106);
			push_value(v107);
		}
		VAL v108 = pop_value();
		decref(v108);
		VAL v109 = pop_value();
		decref(v109);
		VAL v110 = pop_value();
		VAL v111 = pop_value();
		decref(v111);
		switch (get_data_tag(v110)) {
			case 1LL: { // Some
				VAL v112 = mtp_std_maybe_Maybe_1_Some(v110);
				incref(v112);
				VAL v113 = VVAL(VTUP(v112)->cells[3]);
				incref(v113);
				decref(v112);
				switch (get_data_tag(v113)) {
					case 1LL: { // Some
						push_value(v112);
						VAL v114 = mtp_std_maybe_Maybe_1_Some(v113);
						int64_t v115 = 1LL /* True */;
						VAL r116 = pop_resource();
						VAL v117 = VVAL(VTUP(r116)->cells[2]);
						incref(v117);
						push_value(v114);
						push_resource(r116);
						VAL v118 = mw_argZ_parser_state_State_1_parsingZAskZBang(v115, v117);
						VAL r119 = pop_resource();
						VAL v120 = VTUP(r119)->cells[2];
						decref(v120);
						VTUP(r119)->cells[2] = v118;
						VAL v121 = pop_value();
						decref(v121);
						VAL v122 = pop_value();
						push_resource(r119);
						VAL v123 = mtw_std_maybe_Maybe_1_Some(v122);
						VAL r124 = pop_resource();
						VAL v125 = VVAL(VTUP(r124)->cells[2]);
						incref(v125);
						push_resource(r124);
						VAL v126 = mw_argZ_parser_state_State_1_optionZ_optionZBang(v123, v125);
						VAL r127 = pop_resource();
						VAL v128 = VTUP(r127)->cells[2];
						decref(v128);
						VTUP(r127)->cells[2] = v126;
						push_resource(r127);
					} break;
					case 0LL: { // None
						VAL v129 = VVAL(VTUP(v112)->cells[2]);
						incref(v129);
						decref(v112);
						VAL r130 = pop_resource();
						VAL v131 = VVAL(VTUP(r130)->cells[2]);
						incref(v131);
						VAL v132 = VVAL(VTUP(v131)->cells[1]);
						incref(v132);
						decref(v131);
						int64_t v133 = 0LL /* None */;
						push_value(v132);
						push_i64(v133);
						push_value(v129);
						mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r130);
						VAL v134 = pop_value();
						switch (get_data_tag(v134)) {
							case 1LL: { // Some
								VAL v135 = mtp_std_maybe_Maybe_1_Some(v134);
								run_value(v135);
								VAL r136 = pop_resource();
								VAL v137 = VVAL(VTUP(r136)->cells[2]);
								incref(v137);
								VAL v138 = pop_value();
								VAL v139 = tup_replace(v137, 1, v138);
								VAL v140 = VTUP(r136)->cells[2];
								decref(v140);
								VTUP(r136)->cells[2] = v139;
								push_resource(r136);
							} break;
							case 0LL: { // None
								VAL v141 = pop_value();
								decref(v141);
								VAL v142 = pop_value();
								decref(v142);
								VAL v143 = pop_value();
								decref(v143);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v112);
					}
				}
				int64_t v144 = 0LL /* None */;
				push_i64(v144);
			} break;
			case 0LL: { // None
				int64_t v145 = 4LL /* UnknownArg */;
				VAL v146 = mtw_std_maybe_Maybe_1_Some(MKI64(v145));
				push_value(v146);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
	VAL v147 = pop_value();
	VAL v148 = pop_value();
	decref(v148);
	push_value(v147);
}
static void mw_argZ_parser_parse_doZ_positionalZ_option (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x1)->cells[2]);
	incref(v0);
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	decref(v0);
	push_resource(x1);
	push_value(v1);
	VAL v2 = mtw_std_maybe_Maybe_1_Some(x2);
	int64_t v3 = 2LL /* Positional */;
	VAL r4 = pop_resource();
	push_value(v2);
	push_i64(v3);
	mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r4);
	VAL v5 = pop_value();
	VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
	run_value(v6);
	VAL r7 = pop_resource();
	VAL v8 = VVAL(VTUP(r7)->cells[2]);
	incref(v8);
	VAL v9 = pop_value();
	VAL v10 = tup_replace(v8, 1, v9);
	VAL v11 = VTUP(r7)->cells[2];
	decref(v11);
	VTUP(r7)->cells[2] = v10;
	int64_t v12 = 0LL /* None */;
	VAL v13 = VVAL(VTUP(r7)->cells[2]);
	incref(v13);
	int64_t v14 = VI64(VTUP(v13)->cells[4]);
	decref(v13);
	int64_t v15 = 1LL;
	int64_t v16 = i64_add(v14, v15);
	VAL v17 = VVAL(VTUP(r7)->cells[2]);
	incref(v17);
	VAL v18 = tup_replace(v17, 4, MKI64(v16));
	VAL v19 = VTUP(r7)->cells[2];
	decref(v19);
	VTUP(r7)->cells[2] = v18;
	push_i64(v12);
	push_resource(r7);
}
static VAL mw_argZ_parser_parse_parseZ_args (VAL x1, VAL x2) {
	lpush(&lbl_argumentZ_parser, x2);
	VAL v0 = mw_argZ_parser_state_State_1_init(x1);
	VAL v1 = lpop(&lbl_argumentZ_parser);
	VAL v2 = (mtw_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser(v1, v0));
	VAL v3 = VVAL(VTUP(v2)->cells[1]);
	incref(v3);
	VAL v4 = VVAL(VTUP(v3)->cells[1]);
	incref(v4);
	decref(v3);
	push_resource(v2);
	mw_std_list_List_1_uncons(v4);
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		int64_t v8 = mw_std_maybe_Maybe_1_someZAsk(v7);
		if (!((bool)v8)) break;
		VAL v9 = pop_value();
		VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
		VAL v11 = pop_value();
		int64_t v12 = 0LL;
		incref(v10);
		VAL v13 = VVAL(VTUP(v10)->cells[2]);
		incref(v13);
		decref(v10);
		switch (get_data_tag(v13)) {
			case 0LL: { // Short
				lpush(&lbl_docZ_length, MKI64(v12));
				push_value(v10);
				int64_t v14 = mtp_argZ_parser_types_ArgpOptionType_Short(v13);
				int64_t v15 = VI64(lpop(&lbl_docZ_length));
				int64_t v16 = 2LL;
				int64_t v17 = i64_add(v15, v16);
				lpush(&lbl_docZ_length, MKI64(v17));
			} break;
			default: {
				decref(v13);
				lpush(&lbl_docZ_length, MKI64(v12));
				push_value(v10);
			} break;
		}
		VAL v18 = pop_value();
		incref(v18);
		VAL v19 = VVAL(VTUP(v18)->cells[1]);
		incref(v19);
		decref(v18);
		switch (get_data_tag(v19)) {
			case 1LL: { // Some
				push_value(v18);
				VAL v20 = mtp_std_maybe_Maybe_1_Some(v19);
				uint64_t v21 = str_size(VSTR(v20));
				int64_t v22 = mw_std_prim_Int_ZToNat(((int64_t)v21));
				int64_t v23 = VI64(lpop(&lbl_docZ_length));
				int64_t v24 = 3LL;
				int64_t v25 = i64_add(v23, v24);
				int64_t v26 = i64_add(v22, v25);
				lpush(&lbl_docZ_length, MKI64(v26));
			} break;
			case 0LL: { // None
				push_value(v18);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_value(v18);
			}
		}
		VAL v27 = pop_value();
		VAL v28 = VVAL(VTUP(v27)->cells[3]);
		incref(v28);
		decref(v27);
		switch (get_data_tag(v28)) {
			case 1LL: { // Some
				VAL v29 = mtp_std_maybe_Maybe_1_Some(v28);
				uint64_t v30 = str_size(VSTR(v29));
				int64_t v31 = mw_std_prim_Int_ZToNat(((int64_t)v30));
				int64_t v32 = VI64(lpop(&lbl_docZ_length));
				int64_t v33 = 1LL;
				int64_t v34 = i64_add(v32, v33);
				int64_t v35 = i64_add(v31, v34);
				lpush(&lbl_docZ_length, MKI64(v35));
			} break;
			case 0LL: { // None
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		int64_t v36 = VI64(lpop(&lbl_docZ_length));
		VAL r37 = pop_resource();
		VAL v38 = VVAL(VTUP(r37)->cells[2]);
		incref(v38);
		int64_t v39 = VI64(VTUP(v38)->cells[5]);
		decref(v38);
		bool v40 = (v36 > v39);
		if (v40) {
			VAL v41 = VVAL(VTUP(r37)->cells[2]);
			incref(v41);
			VAL v42 = tup_replace(v41, 5, MKI64(v36));
			VAL v43 = VTUP(r37)->cells[2];
			decref(v43);
			VTUP(r37)->cells[2] = v42;
			push_resource(r37);
		} else {
			push_resource(r37);
		}
		mw_std_list_List_1_uncons(v11);
		VAL v44 = pop_value();
		VAL v45 = pop_value();
		push_value(v44);
		push_value(v45);
	}
	VAL v46 = pop_value();
	decref(v46);
	VAL v47 = pop_value();
	decref(v47);
	VAL r48 = pop_resource();
	VAL v49 = VVAL(VTUP(r48)->cells[2]);
	incref(v49);
	push_resource(r48);
	VAL v50 = mw_argZ_parser_state_State_1_argv(v49);
	mw_std_list_List_1_uncons(v50);
	VAL v51 = pop_value();
	VAL v52 = pop_value();
	push_value(v51);
	push_value(v52);
	while(1) {
		VAL v53 = pop_value();
		incref(v53);
		push_value(v53);
		int64_t v54 = mw_std_maybe_Maybe_1_someZAsk(v53);
		if (!((bool)v54)) break;
		VAL v55 = pop_value();
		VAL v56 = mw_std_maybe_Maybe_1_unwrap(v55);
		VAL v57 = pop_value();
		incref(v56);
		uint64_t v58 = str_size(VSTR(v56));
		push_value(v56);
		int64_t v59 = mw_std_prim_Int_ZToNat(((int64_t)v58));
		int64_t v60 = 1LL;
		push_i64(v59);
		int64_t v61 = mw_std_prim_Int_ZToNat(v60);
		int64_t v62 = pop_i64();
		bool v63 = (v62 > v61);
		if (v63) {
			int64_t v64 = 0LL;
			VAL v65 = pop_value();
			incref(v65);
			push_value(v65);
			int64_t v66 = mw_std_prim_Str_byteZAt(v64, v65);
			int64_t v67 = 45LL /* B'-' */;
			bool v68 = (v66 == v67);
			if (v68) {
				VAL r69 = pop_resource();
				VAL v70 = VVAL(VTUP(r69)->cells[2]);
				incref(v70);
				push_resource(r69);
				int64_t v71 = mw_argZ_parser_state_State_1_parsingZAsk(v70);
				if (((bool)v71)) {
					VAL v72 = pop_value();
					decref(v72);
					VAL r73 = pop_resource();
					VAL v74 = VVAL(VTUP(r73)->cells[2]);
					incref(v74);
					push_resource(r73);
					VAL v75 = mw_argZ_parser_state_State_1_optionZ_option(v74);
					switch (get_data_tag(v75)) {
						case 1LL: { // Some
							VAL v76 = mtp_std_maybe_Maybe_1_Some(v75);
							VAL v77 = VVAL(VTUP(v76)->cells[3]);
							incref(v77);
							decref(v76);
							switch (get_data_tag(v77)) {
								case 1LL: { // Some
									VAL v78 = mtp_std_maybe_Maybe_1_Some(v77);
									decref(v78);
									int64_t v79 = 0LL /* MissingArgValue */;
									VAL v80 = mtw_std_maybe_Maybe_1_Some(MKI64(v79));
									push_value(v80);
								} break;
								case 0LL: { // None
									int64_t v81 = 0LL /* False */;
									VAL r82 = pop_resource();
									VAL v83 = VVAL(VTUP(r82)->cells[2]);
									incref(v83);
									push_resource(r82);
									VAL v84 = mw_argZ_parser_state_State_1_parsingZAskZBang(v81, v83);
									VAL r85 = pop_resource();
									VAL v86 = VTUP(r85)->cells[2];
									decref(v86);
									VTUP(r85)->cells[2] = v84;
									int64_t v87 = 0LL /* None */;
									push_resource(r85);
									push_i64(v87);
								} break;
								default: {
									push_value(mkstr("unexpected fallthrough in match\n", 32));
									do_panic();
								}
							}
						} break;
						case 0LL: { // None
							int64_t v88 = 0LL /* MissingArgValue */;
							VAL v89 = mtw_std_maybe_Maybe_1_Some(MKI64(v88));
							push_value(v89);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} else {
					VAL v90 = pop_value();
					VAL r91 = pop_resource();
					mw_argZ_parser_parse_parseZ_flags(r91, v90);
				}
			} else {
				VAL r92 = pop_resource();
				VAL v93 = VVAL(VTUP(r92)->cells[2]);
				incref(v93);
				push_resource(r92);
				int64_t v94 = mw_argZ_parser_state_State_1_parsingZAsk(v93);
				if (((bool)v94)) {
					VAL r95 = pop_resource();
					VAL v96 = VVAL(VTUP(r95)->cells[2]);
					incref(v96);
					push_resource(r95);
					VAL v97 = mw_argZ_parser_state_State_1_optionZ_option(v96);
					switch (get_data_tag(v97)) {
						case 1LL: { // Some
							VAL v98 = mtp_std_maybe_Maybe_1_Some(v97);
							VAL v99 = VVAL(VTUP(v98)->cells[3]);
							incref(v99);
							decref(v98);
							switch (get_data_tag(v99)) {
								case 1LL: { // Some
									VAL v100 = mtp_std_maybe_Maybe_1_Some(v99);
									decref(v100);
									VAL r101 = pop_resource();
									VAL v102 = VVAL(VTUP(r101)->cells[2]);
									incref(v102);
									VAL v103 = VVAL(VTUP(v102)->cells[1]);
									incref(v103);
									decref(v102);
									VAL v104 = pop_value();
									push_resource(r101);
									push_value(v103);
									VAL v105 = mtw_std_maybe_Maybe_1_Some(v104);
									VAL r106 = pop_resource();
									VAL v107 = VVAL(VTUP(r106)->cells[2]);
									incref(v107);
									push_value(v105);
									push_resource(r106);
									VAL v108 = mw_argZ_parser_state_State_1_optionZ_option(v107);
									VAL v109 = mw_std_maybe_Maybe_1_unwrap(v108);
									VAL v110 = VVAL(VTUP(v109)->cells[2]);
									incref(v110);
									decref(v109);
									VAL r111 = pop_resource();
									push_value(v110);
									mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r111);
									VAL v112 = pop_value();
									VAL v113 = mw_std_maybe_Maybe_1_unwrap(v112);
									run_value(v113);
									VAL r114 = pop_resource();
									VAL v115 = VVAL(VTUP(r114)->cells[2]);
									incref(v115);
									VAL v116 = pop_value();
									VAL v117 = tup_replace(v115, 1, v116);
									VAL v118 = VTUP(r114)->cells[2];
									decref(v118);
									VTUP(r114)->cells[2] = v117;
									int64_t v119 = 0LL /* None */;
									push_resource(r114);
									push_i64(v119);
								} break;
								case 0LL: { // None
									VAL v120 = pop_value();
									decref(v120);
									int64_t v121 = 4LL /* UnknownArg */;
									VAL v122 = mtw_std_maybe_Maybe_1_Some(MKI64(v121));
									push_value(v122);
								} break;
								default: {
									push_value(mkstr("unexpected fallthrough in match\n", 32));
									do_panic();
								}
							}
						} break;
						case 0LL: { // None
							VAL v123 = pop_value();
							decref(v123);
							int64_t v124 = 4LL /* UnknownArg */;
							VAL v125 = mtw_std_maybe_Maybe_1_Some(MKI64(v124));
							push_value(v125);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
					int64_t v126 = 0LL /* False */;
					VAL r127 = pop_resource();
					VAL v128 = VVAL(VTUP(r127)->cells[2]);
					incref(v128);
					VAL v129 = mw_argZ_parser_state_State_1_parsingZAskZBang(v126, v128);
					VAL v130 = VTUP(r127)->cells[2];
					decref(v130);
					VTUP(r127)->cells[2] = v129;
					push_resource(r127);
				} else {
					VAL v131 = pop_value();
					VAL r132 = pop_resource();
					mw_argZ_parser_parse_doZ_positionalZ_option(r132, v131);
				}
			}
		} else {
			VAL v133 = pop_value();
			decref(v133);
			int64_t v134 = 0LL /* None */;
			push_i64(v134);
		}
		VAL v135 = pop_value();
		switch (get_data_tag(v135)) {
			case 1LL: { // Some
				VAL v136 = mtp_std_maybe_Maybe_1_Some(v135);
				VAL v137 = mtw_std_maybe_Maybe_1_Some(v136);
				VAL r138 = pop_resource();
				VAL v139 = VVAL(VTUP(r138)->cells[2]);
				incref(v139);
				VAL v140 = tup_replace(v139, 6, v137);
				VAL v141 = VTUP(r138)->cells[2];
				decref(v141);
				VTUP(r138)->cells[2] = v140;
				push_resource(r138);
			} break;
			case 0LL: { // None
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		mw_std_list_List_1_uncons(v57);
		VAL v142 = pop_value();
		VAL v143 = pop_value();
		push_value(v142);
		push_value(v143);
	}
	VAL v144 = pop_value();
	decref(v144);
	VAL v145 = pop_value();
	decref(v145);
	VAL r146 = pop_resource();
	VAL v147 = VVAL(VTUP(r146)->cells[2]);
	incref(v147);
	push_resource(r146);
	int64_t v148 = mw_argZ_parser_state_State_1_parsingZAsk(v147);
	if (((bool)v148)) {
		int64_t v149 = 0LL /* MissingArgValue */;
		VAL v150 = mtw_std_maybe_Maybe_1_Some(MKI64(v149));
		VAL r151 = pop_resource();
		VAL v152 = VVAL(VTUP(r151)->cells[2]);
		incref(v152);
		VAL v153 = tup_replace(v152, 6, v150);
		VAL v154 = VTUP(r151)->cells[2];
		decref(v154);
		VTUP(r151)->cells[2] = v153;
		push_resource(r151);
	} else {
	}
	VAL r155 = pop_resource();
	VAL v156 = VVAL(VTUP(r155)->cells[2]);
	incref(v156);
	VAL v157 = VVAL(VTUP(v156)->cells[1]);
	incref(v157);
	decref(v156);
	int64_t v158 = 0LL /* None */;
	int64_t v159 = 3LL /* End */;
	push_value(v157);
	push_i64(v158);
	push_i64(v159);
	mw_argZ_parser_types_ZPlusArgumentParser_1_parser(r155);
	VAL v160 = pop_value();
	VAL v161 = mw_std_maybe_Maybe_1_unwrap(v160);
	run_value(v161);
	VAL r162 = pop_resource();
	VAL v163 = VVAL(VTUP(r162)->cells[2]);
	incref(v163);
	VAL v164 = pop_value();
	VAL v165 = tup_replace(v163, 1, v164);
	VAL v166 = VTUP(r162)->cells[2];
	decref(v166);
	VTUP(r162)->cells[2] = v165;
	VAL v167 = VVAL(VTUP(r162)->cells[2]);
	incref(v167);
	VAL v168 = VVAL(VTUP(v167)->cells[1]);
	incref(v168);
	decref(v167);
	VAL v169 = VVAL(VTUP(r162)->cells[2]);
	incref(v169);
	VAL v170 = VVAL(VTUP(v169)->cells[6]);
	incref(v170);
	decref(v169);
	switch (get_data_tag(v170)) {
		case 1LL: { // Some
			push_value(v168);
			push_resource(r162);
			VAL v171 = mtp_std_maybe_Maybe_1_Some(v170);
			VAL r172 = pop_resource();
			push_value(v171);
			mw_argZ_parser_types_ZPlusArgumentParser_1_usage(r172);
			VAL v173 = pop_value();
			VAL v174 = pop_value();
			VAL v175 = MKNIL;
			VAL v176 = mkcons(v175, v174);
			VAL v177 = mkcons(v176, v173);
			VAL v178 = mtw_std_either_Either_2_Left(v177);
			VAL v179 = pop_value();
			decref(v179);
			push_value(v178);
		} break;
		case 0LL: { // None
			push_resource(r162);
			VAL v180 = mtw_std_either_Either_2_Right(v168);
			push_value(v180);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(v168);
			push_resource(r162);
		}
	}
	VAL r181 = pop_resource();
	mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop(r181);
	VAL v182 = pop_value();
	return v182;
}
static void mw_argZ_parser_parse_readZ_fromZ_argv (VAL x1, int64_t x2) {
	uint64_t v0 = sizeof(void*);
	push_resource(x1);
	push_i64(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(((int64_t)v0));
	int64_t v2 = pop_i64();
	int64_t v3 = i64_mul(v2, v1);
	int64_t v4 = mw_std_prim_Int_ZToNat(v3);
	void* v5 = global_argv;
	void* v6 = (void*)(v4 + (char*)v5);
	void* v7 = *(void**)v6;
	push_ptr(v7);
	push_ptr(v7);
	mext_std_ctypes_CStr_numZ_bytes();
	int64_t v8 = pop_i64();
	int64_t v9 = mw_std_prim_Int_ZToNat(v8);
	void* v10 = pop_ptr();
	STR* v11 = str_make(v10, ((uint64_t)v9));
	push_str(v11);
}
static VAL mw_argZ_parser_parse_argvZ_toZ_str (void) {
	int64_t v0 = 1LL;
	int64_t v1 = global_argc;
	int64_t v2 = 1LL;
	int64_t v3 = i64_sub(v1, v2);
	VAL v4 = mw_std_prim_Int_range(v0, v3);
	int64_t v5 = 0LL /* Nil */;
	push_value(v4);
	VAL v6 = mw_std_list_List_1_reverse(MKI64(v5));
	VAL v7 = pop_value();
	push_resource(v6);
	mw_std_list_List_1_uncons(v7);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		int64_t v11 = mw_std_maybe_Maybe_1_someZAsk(v10);
		if (!((bool)v11)) break;
		VAL v12 = pop_value();
		VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
		VAL v14 = pop_value();
		VAL r15 = pop_resource();
		int64_t v16 = (0LL /* +Unsafe */);
		mw_argZ_parser_parse_readZ_fromZ_argv(MKI64(v16), VI64(v13));
		VAL r17 = pop_resource();
		VAL v18 = pop_value();
		VAL v19 = mtw_std_list_List_1_Cons(v18, r15);
		push_resource(v19);
		mw_std_list_List_1_uncons(v14);
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
	}
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	VAL r24 = pop_resource();
	VAL v25 = mw_std_list_List_1_reverse(r24);
	return v25;
}
static VAL mw_std_lazzy_Lazzy_1_forceZBang (VAL x1) {
	incref(x1);
	VAL v0 = mut_get(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // LazyReady
			push_value(x1);
			VAL v1 = mtp_std_lazzy_Lazzy_1_LazzyReady(v0);
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
		} break;
		case 1LL: { // LazyDelay
			push_value(x1);
			mtp_std_lazzy_Lazzy_1_LazzyDelay(v0);
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			int64_t v6 = 2LL /* LazyWait */;
			incref(v5);
			mut_set(MKI64(v6), v5);
			push_value(v4);
			run_value(v3);
			VAL v7 = pop_value();
			incref(v7);
			push_value(v7);
			VAL v8 = mtw_std_lazzy_Lazzy_1_LazzyReady(v7);
			mut_set(v8, v5);
		} break;
		case 2LL: { // LazyWait
			STR* v9;
			STRLIT(v9, "recursive thunk dependency", 26);
			push_value(x1);
			push_str(v9);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	VAL v10 = pop_value();
	return v10;
}
static int64_t mw_mirth_label_Label_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_label_Label_allocZBang (void) {
	void* v0 = mbuf_mirth_label_Label_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_label_Label_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_label_Label_name (uint64_t x1) {
	void* v0 = mfld_mirth_label_Label_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_label_Label_ZToStr (uint64_t x1) {
	uint64_t v0 = mw_mirth_label_Label_name(x1);
	VAL v1 = mw_mirth_name_Name_ZToStr(v0);
	return v1;
}
static int64_t mw_mirth_label_Label_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_label_Label_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_label_Label_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static uint64_t mw_mirth_label_Label_newZBang (uint64_t x1) {
	void* v0 = mfld_mirth_name_Name_ZTildelabel(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		uint64_t v3 = mw_mirth_label_Label_allocZBang();
		VAL v4 = pop_value();
		incref(v4);
		void* v5 = mfld_mirth_label_Label_ZTildename(v3);
		mut_set(v4, MKPTR(v5));
		mut_set(MKU64(v3), MKPTR(v0));
		push_value(v4);
		push_u64(v3);
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	return VU64(v6);
}
static int64_t mw_mirth_label_Label_isZ_resourceZ_labelZAsk (uint64_t x1) {
	uint64_t v0 = mw_mirth_label_Label_name(x1);
	int64_t v1 = mw_mirth_name_Name_head(v0);
	int64_t v2 = 43LL /* B'+' */;
	bool v3 = (v1 == v2);
	return ((int64_t)v3);
}
static int64_t mw_mirth_var_Var_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_var_Var_allocZBang (void) {
	void* v0 = mbuf_mirth_var_Var_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_var_Var_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_var_Var_name (uint64_t x1) {
	void* v0 = mfld_mirth_var_Var_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_var_Var_type (uint64_t x1) {
	void* v0 = mfld_mirth_var_Var_ZTildetype(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_var_Var_autoZ_runZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_var_Var_ZTildeautoZ_runZAsk(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static int64_t mw_mirth_var_Var_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_var_Var_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_var_Var_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static VAL mw_mirth_var_Var_typeZThen (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_var_Var_name(x2);
	VAL v1 = mw_mirth_name_Name_ZToStr(v0);
	VAL r2 = pop_resource();
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(v1, r2));
	return v3;
}
static int64_t mw_mirth_var_Var_isZ_stackZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_var_Var_type(x1);
	VAL v1 = mw_mirth_type_Type_primZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			int64_t v3 = 1LL /* PRIM_TYPE_STACK */;
			int64_t v4 = mw_mirth_type_PrimType_ZEqualZEqual(VI64(v2), v3);
			push_i64(v4);
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v6 = pop_i64();
	return v6;
}
static int64_t mw_mirth_var_Var_isZ_physicalZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_var_Var_type(x1);
	int64_t v1 = mw_mirth_type_Type_isZ_physicalZAsk(v0);
	return v1;
}
static uint64_t mw_mirth_var_Var_newZBang (VAL x1, uint64_t x2) {
	push_value(x1);
	push_u64(x2);
	uint64_t v0 = mw_mirth_var_Var_allocZBang();
	VAL v1 = pop_value();
	void* v2 = mfld_mirth_var_Var_ZTildename(v0);
	mut_set(v1, MKPTR(v2));
	VAL v3 = pop_value();
	void* v4 = mfld_mirth_var_Var_ZTildetype(v0);
	mut_set(v3, MKPTR(v4));
	int64_t v5 = 0LL /* False */;
	void* v6 = mfld_mirth_var_Var_ZTildeautoZ_runZAsk(v0);
	mut_set(MKI64(v5), MKPTR(v6));
	return v0;
}
static uint64_t mw_mirth_var_Var_newZ_autoZ_runZBang (VAL x1, uint64_t x2) {
	uint64_t v0 = mw_mirth_var_Var_newZBang(x1, x2);
	int64_t v1 = 1LL /* True */;
	void* v2 = mfld_mirth_var_Var_ZTildeautoZ_runZAsk(v0);
	mut_set(MKI64(v1), MKPTR(v2));
	return v0;
}
static VAL mw_std_list_List_1_ZToCtx (VAL x1) {
	return x1;
}
static VAL mw_mirth_var_Ctx_ZToList (VAL x1) {
	return x1;
}
static VAL mw_mirth_var_Ctx0 (void) {
	int64_t v0 = 0LL /* Nil */;
	return MKI64(v0);
}
static VAL mw_mirth_var_Ctx1 (uint64_t x1) {
	int64_t v0 = 0LL /* Nil */;
	VAL v1 = mtw_std_list_List_1_Cons(MKU64(x1), MKI64(v0));
	return v1;
}
static VAL mw_mirth_var_Ctx2 (uint64_t x1, uint64_t x2) {
	int64_t v0 = 0LL /* Nil */;
	push_u64(x1);
	VAL v1 = mtw_std_list_List_1_Cons(MKU64(x2), MKI64(v0));
	VAL v2 = pop_value();
	VAL v3 = mtw_std_list_List_1_Cons(v2, v1);
	return v3;
}
static VAL mw_mirth_var_Ctx3 (uint64_t x1, uint64_t x2, uint64_t x3) {
	int64_t v0 = 0LL /* Nil */;
	push_u64(x1);
	push_u64(x2);
	VAL v1 = mtw_std_list_List_1_Cons(MKU64(x3), MKI64(v0));
	VAL v2 = pop_value();
	VAL v3 = mtw_std_list_List_1_Cons(v2, v1);
	VAL v4 = pop_value();
	VAL v5 = mtw_std_list_List_1_Cons(v4, v3);
	return v5;
}
static VAL mw_mirth_var_Ctx_new (VAL x1, uint64_t x2) {
	VAL v0 = mw_mirth_var_Ctx_ZToList(x1);
	int64_t v1 = 0LL /* Nil */;
	push_value(v0);
	VAL v2 = mtw_std_list_List_1_Cons(MKU64(x2), MKI64(v1));
	VAL v3 = pop_value();
	VAL v4 = mw_std_list_List_1_cat(v3, v2);
	VAL v5 = mw_std_list_List_1_ZToCtx(v4);
	return v5;
}
static VAL mw_mirth_var_Ctx_lookup (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_var_Ctx_ZToList(x2);
	VAL v1 = mw_std_list_List_1_reverse(v0);
	int64_t v2 = 0LL /* None */;
	push_i64(v2);
	mw_std_list_List_1_uncons(v1);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		incref(v8);
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		uint64_t v12 = mw_mirth_var_Var_name(VU64(v8));
		uint64_t v13 = pop_u64();
		int64_t v14 = mw_mirth_name_Name_ZEqualZEqual(v13, v12);
		if (((bool)v14)) {
			push_value(v11);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v15);
		} else {
			decref(v8);
			int64_t v16 = 0LL /* None */;
			push_value(v11);
			push_i64(v16);
		}
		VAL v17 = pop_value();
		switch (get_data_tag(v17)) {
			case 0LL: { // None
				push_value(v10);
				push_value(v9);
			} break;
			default: {
				decref(v9);
				decref(v10);
				int64_t v18 = 0LL /* Nil */;
				push_value(v17);
				push_i64(v18);
			} break;
		}
		VAL v19 = pop_value();
		mw_std_list_List_1_uncons(v19);
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
	}
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	VAL v25 = pop_value();
	decref(v25);
	return v24;
}
static void mw_mirth_var_Ctx_freshZ_nameZBang (VAL x1) {
	int64_t v0 = 1LL;
	STR* v1;
	STRLIT(v1, "_x1", 3);
	push_value(x1);
	push_i64(v0);
	uint64_t v2 = mw_std_prim_Str_ZToName(MKSTR(v1));
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v3);
	push_u64(v2);
	VAL v5 = mw_mirth_var_Ctx_lookup(v2, v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		decref(v9);
		VAL v10 = pop_value();
		decref(v10);
		int64_t v11 = 1LL;
		int64_t v12 = pop_i64();
		int64_t v13 = i64_add(v12, v11);
		STR* v14;
		STRLIT(v14, "_x", 2);
		STR* v15 = i64_show(v13);
		STR* v16 = str_cat(v14, v15);
		push_i64(v13);
		uint64_t v17 = mw_std_prim_Str_ZToName(MKSTR(v16));
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		incref(v19);
		push_value(v19);
		push_value(v18);
		push_u64(v17);
		VAL v20 = mw_mirth_var_Ctx_lookup(v17, v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	decref(v23);
	push_value(v22);
}
static void mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang (VAL x1) {
	int64_t v0 = 1LL /* PRIM_TYPE_STACK */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	mw_mirth_var_Ctx_freshZ_varZBang(v1, x1);
}
static void mw_mirth_var_Ctx_freshZ_typeZ_varZBang (VAL x1) {
	int64_t v0 = 0LL /* PRIM_TYPE_TYPE */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	mw_mirth_var_Ctx_freshZ_varZBang(v1, x1);
}
static void mw_mirth_var_Ctx_freshZ_varZBang (VAL x1, VAL x2) {
	push_value(x1);
	mw_mirth_var_Ctx_freshZ_nameZBang(x2);
	uint64_t v0 = pop_u64();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	uint64_t v3 = mw_mirth_var_Var_newZBang(v2, v0);
	VAL v4 = pop_value();
	VAL v5 = mw_mirth_var_Ctx_new(v4, v3);
	push_value(v5);
	push_u64(v3);
}
static void mw_mirth_var_Var_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_u64(x3);
	push_u64(x4);
	int64_t v0 = mw_mirth_var_Var_ZEqualZEqual(x3, x4);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		uint64_t v2 = pop_u64();
		VAL v3 = mtw_mirth_type_Type_TVar(v2);
		push_value(v3);
	} else {
		uint64_t v4 = pop_u64();
		uint64_t v5 = pop_u64();
		VAL v6 = mtw_mirth_type_Type_TVar(v5);
		push_value(v6);
		VAL v7 = mtw_mirth_type_Type_TVar(v4);
		VAL v8 = pop_value();
		uint64_t r9 = VU64(pop_resource());
		VAL r10 = pop_resource();
		mw_mirth_type_Type_unifyZ_failedZBang(r10, r9, v8, v7);
	}
}
static void mw_mirth_var_Var_freshen (VAL x1, uint64_t x2) {
	incref(x1);
	push_u64(x2);
	push_value(x1);
	int64_t v0 = mw_mirth_type_Subst_hasZ_varZAsk(x2, x1);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		incref(v1);
		VAL v2 = pop_value();
		push_value(v1);
		VAL v3 = mw_mirth_type_Subst_getZ_var(VU64(v2), v1);
		push_value(v3);
	} else {
		uint64_t v4 = mw_mirth_type_MetaVar_newZBang();
		VAL v5 = mtw_mirth_type_Type_TMeta(v4);
		incref(v5);
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = mw_mirth_type_Subst_cons(v5, VU64(v7), v6);
		push_value(v8);
		push_value(v5);
	}
}
static int64_t mw_mirth_buffer_Buffer_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_buffer_Buffer_allocZBang (void) {
	void* v0 = mbuf_mirth_buffer_Buffer_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_buffer_Buffer_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static int64_t mw_mirth_buffer_Buffer_sizze (uint64_t x1) {
	void* v0 = mfld_mirth_buffer_Buffer_ZTildesizze(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static VAL mw_mirth_buffer_Buffer_qname (uint64_t x1) {
	void* v0 = mfld_mirth_buffer_Buffer_ZTildeqname(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_buffer_Buffer_name (uint64_t x1) {
	VAL v0 = mw_mirth_buffer_Buffer_qname(x1);
	uint64_t v1 = VU64(VTUP(v0)->cells[2]);
	decref(v0);
	return v1;
}
static int64_t mw_mirth_buffer_Buffer_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_buffer_Buffer_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_buffer_Buffer_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_buffer_Buffer_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4) {
	push_resource(x1);
	push_u64(x2);
	push_value(x3);
	push_i64(x4);
	uint64_t v0 = mw_mirth_buffer_Buffer_allocZBang();
	VAL v1 = pop_value();
	void* v2 = mfld_mirth_buffer_Buffer_ZTildesizze(v0);
	mut_set(v1, MKPTR(v2));
	VAL v3 = pop_value();
	void* v4 = mfld_mirth_buffer_Buffer_ZTildeqname(v0);
	mut_set(v3, MKPTR(v4));
	VAL v5 = pop_value();
	void* v6 = mfld_mirth_buffer_Buffer_ZTildehead(v0);
	mut_set(v5, MKPTR(v6));
	push_u64(v0);
	VAL v7 = mtw_mirth_def_Def_DefBuffer(v0);
	VAL r8 = pop_resource();
	VAL v9 = (mw_mirth_def_Def_register(r8, v7));
	push_resource(v9);
}
static int64_t mw_mirth_word_Word_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_word_Word_allocZBang (void) {
	void* v0 = mbuf_mirth_word_Word_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_word_Word_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_word_Word_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_word_Word_qnameZ_hard (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildeqname(x1);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x2);
}
static void mw_mirth_word_Word_namespaceZ_hard (uint64_t x1, VAL x2) {
	mw_mirth_word_Word_qnameZ_hard(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	decref(v0);
	push_value(v1);
}
static uint64_t mw_mirth_word_Word_name (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static uint64_t mw_mirth_word_Word_head (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildehead(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_word_Word_sigZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildesigZAsk(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_word_Word_body (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildebody(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static int64_t mw_mirth_word_Word_arity (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildearity(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static void mw_mirth_word_Word_params (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildeparams(x1);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x2);
}
static void mw_mirth_word_Word_arrow (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildearrow(x1);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x2);
}
static int64_t mw_mirth_word_Word_inferringZ_typeZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static void mw_mirth_word_Word_cname (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildecname(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x2);
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		mw_mirth_word_Word_qnameZ_hard(x1, x2);
		VAL v3 = pop_value();
		VAL r4 = pop_resource();
		mw_mirth_name_QName_mangled(r4, v3);
		STR* v5;
		STRLIT(v5, "", 0);
		STR* v6;
		STRLIT(v6, "mw_", 3);
		VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), MKSTR(v5)));
		VAL v8 = pop_value();
		VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(v8, v7));
		incref(v9);
		mut_set(v9, MKPTR(v0));
		push_value(v9);
	}
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	decref(v11);
	push_value(v10);
}
static void mw_mirth_word_Word_ctxZ_type (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildectxZ_type(x1);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x2);
	VAL v1 = pop_value();
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	push_value(v5);
	push_value(v3);
}
static void mw_mirth_word_Word_type (uint64_t x1, VAL x2) {
	mw_mirth_word_Word_ctxZ_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static int64_t mw_mirth_word_Word_preferZ_inlineZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static void mw_mirth_word_Word_makeZ_inlineZBang (uint64_t x1) {
	int64_t v0 = 1LL /* True */;
	void* v1 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(x1);
	mut_set(MKI64(v0), MKPTR(v1));
}
static void mw_mirth_word_Word_newZBang (uint64_t x1, VAL x2, uint64_t x3, uint64_t x4, int64_t x5, VAL x6) {
	lpush(&lbl_head, MKU64(x1));
	lpush(&lbl_sigZAsk, x2);
	lpush(&lbl_body, MKU64(x3));
	lpush(&lbl_name, MKU64(x4));
	lpush(&lbl_arity, MKI64(x5));
	push_resource(x6);
	uint64_t v0 = mw_mirth_word_Word_allocZBang();
	uint64_t v1 = VU64(lpop(&lbl_name));
	void* v2 = mfld_mirth_word_Word_ZTildename(v0);
	mut_set(MKU64(v1), MKPTR(v2));
	uint64_t v3 = VU64(lpop(&lbl_head));
	void* v4 = mfld_mirth_word_Word_ZTildehead(v0);
	mut_set(MKU64(v3), MKPTR(v4));
	uint64_t v5 = VU64(lpop(&lbl_body));
	void* v6 = mfld_mirth_word_Word_ZTildebody(v0);
	mut_set(MKU64(v5), MKPTR(v6));
	int64_t v7 = VI64(lpop(&lbl_arity));
	void* v8 = mfld_mirth_word_Word_ZTildearity(v0);
	mut_set(MKI64(v7), MKPTR(v8));
	VAL v9 = lpop(&lbl_sigZAsk);
	void* v10 = mfld_mirth_word_Word_ZTildesigZAsk(v0);
	mut_set(v9, MKPTR(v10));
	push_u64(v0);
	VAL v11 = mtw_mirth_def_Def_DefWord(v0);
	VAL r12 = pop_resource();
	VAL v13 = (mw_mirth_def_Def_register(r12, v11));
	push_resource(v13);
}
static int64_t mw_mirth_word_Word_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_word_Word_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_word_Word_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static int64_t mw_mirth_word_Word_incZ_numZ_blocksZBang (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildenumZ_blocks(x1);
	push_u64(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			incref(v2);
			VAL v3 = pop_value();
			int64_t v4 = 1LL;
			int64_t v5 = i64_add(VI64(v2), v4);
			void* v6 = mfld_mirth_word_Word_ZTildenumZ_blocks(VU64(v3));
			mut_set(MKI64(v5), MKPTR(v6));
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v7 = 1LL;
			uint64_t v8 = pop_u64();
			void* v9 = mfld_mirth_word_Word_ZTildenumZ_blocks(v8);
			mut_set(MKI64(v7), MKPTR(v9));
			int64_t v10 = 0LL;
			push_i64(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v11 = pop_i64();
	return v11;
}
static int64_t mw_mirth_table_Table_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_table_Table_allocZBang (void) {
	void* v0 = mbuf_mirth_table_Table_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_table_Table_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_table_Table_head (uint64_t x1) {
	void* v0 = mfld_mirth_table_Table_ZTildehead(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_table_Table_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_table_Table_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_table_Table_qnameZ_hard (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_table_Table_ZTildeqname(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static uint64_t mw_mirth_table_Table_name (uint64_t x1) {
	void* v0 = mfld_mirth_table_Table_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static uint64_t mw_mirth_table_Table_numZ_buffer (uint64_t x1) {
	void* v0 = mfld_mirth_table_Table_ZTildenumZ_buffer(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static int64_t mw_mirth_table_Table_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_table_Table_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_table_Table_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static int64_t mw_mirth_table_Field_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_table_Field_allocZBang (void) {
	void* v0 = mbuf_mirth_table_Field_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_table_Field_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_table_Field_name (uint64_t x1) {
	void* v0 = mfld_mirth_table_Field_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_table_Field_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_table_Field_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_table_Field_qnameZ_hard (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_table_Field_ZTildeqname(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static void mw_mirth_table_Field_indexZ_type (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_table_Field_ZTildeindexZ_type(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static void mw_mirth_table_Field_valueZ_type (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_table_Field_ZTildevalueZ_type(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static void mw_mirth_table_Field_dom (VAL x1, uint64_t x2) {
	mw_mirth_table_Field_indexZ_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_mirth_type_T1(v0);
	push_value(v1);
}
static void mw_mirth_table_Field_cod (VAL x1, uint64_t x2) {
	mw_mirth_table_Field_valueZ_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = mtw_mirth_type_Type_TMut(v0);
	VAL v2 = mw_mirth_type_T1(v1);
	push_value(v2);
}
static void mw_mirth_table_Field_type (VAL x1, uint64_t x2) {
	mw_mirth_table_Field_dom(x1, x2);
	VAL r0 = pop_resource();
	mw_mirth_table_Field_cod(r0, x2);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = mw_mirth_type_TZ_ZTo(v2, v1);
	push_value(v3);
}
static int64_t mw_mirth_table_Field_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_table_Field_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_table_Field_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_tycon_Tycon_qnameZ_hard (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			push_resource(x1);
			uint64_t v0 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			VAL r1 = pop_resource();
			mw_mirth_data_Data_qnameZ_hard(r1, v0);
		} break;
		case 1LL: { // TYCON_TABLE
			push_resource(x1);
			uint64_t v2 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			VAL r3 = pop_resource();
			mw_mirth_table_Table_qnameZ_hard(r3, v2);
		} break;
		case 2LL: { // TYCON_PRIM
			push_resource(x1);
			int64_t v4 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			VAL r5 = pop_resource();
			mw_mirth_type_PrimType_tyconZ_qname(r5, v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static int64_t mw_mirth_tycon_Tycon_ZEqualZEqual (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			push_value(x1);
			uint64_t v0 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			VAL v1 = pop_value();
			switch (get_data_tag(v1)) {
				case 0LL: { // TYCON_DATA
					push_u64(v0);
					uint64_t v2 = mtp_mirth_tycon_Tycon_TYCONz_DATA(v1);
					uint64_t v3 = pop_u64();
					int64_t v4 = mw_mirth_data_Data_ZEqualZEqual(v3, v2);
					push_i64(v4);
				} break;
				default: {
					decref(v1);
					int64_t v5 = 0LL /* False */;
					push_i64(v5);
				} break;
			}
		} break;
		case 1LL: { // TYCON_TABLE
			push_value(x1);
			uint64_t v6 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			VAL v7 = pop_value();
			switch (get_data_tag(v7)) {
				case 1LL: { // TYCON_TABLE
					push_u64(v6);
					uint64_t v8 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(v7);
					uint64_t v9 = pop_u64();
					int64_t v10 = mw_mirth_table_Table_ZEqualZEqual(v9, v8);
					push_i64(v10);
				} break;
				default: {
					decref(v7);
					int64_t v11 = 0LL /* False */;
					push_i64(v11);
				} break;
			}
		} break;
		case 2LL: { // TYCON_PRIM
			push_value(x1);
			int64_t v12 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			VAL v13 = pop_value();
			switch (get_data_tag(v13)) {
				case 2LL: { // TYCON_PRIM
					push_i64(v12);
					int64_t v14 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(v13);
					int64_t v15 = pop_i64();
					int64_t v16 = mw_mirth_type_PrimType_ZEqualZEqual(v15, v14);
					push_i64(v16);
				} break;
				default: {
					decref(v13);
					int64_t v17 = 0LL /* False */;
					push_i64(v17);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	int64_t v18 = pop_i64();
	return v18;
}
static void mw_mirth_tycon_Tycon_fullZ_typeZ_fresh (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			push_resource(x1);
			uint64_t v0 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			int64_t v1 = 0LL /* SUBST_NIL */;
			VAL r2 = pop_resource();
			push_i64(v1);
			mw_mirth_data_Data_fullZ_type(r2, v0);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 0LL: { // Left
					VAL v4 = mtp_std_either_Either_2_Left(v3);
					VAL v5 = pop_value();
					mw_mirth_type_Type_freshen(v5, v4);
					VAL v6 = pop_value();
					VAL v7 = mtw_std_either_Either_2_Left(v6);
					push_value(v7);
				} break;
				case 1LL: { // Right
					VAL v8 = mtp_std_either_Either_2_Right(v3);
					VAL v9 = pop_value();
					mw_mirth_type_Resource_freshen(v9, v8);
					VAL v10 = pop_value();
					VAL v11 = mtw_std_either_Either_2_Right(v10);
					push_value(v11);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			decref(v13);
			push_value(v12);
		} break;
		case 2LL: { // TYCON_PRIM
			push_resource(x1);
			int64_t v14 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			push_i64(v14);
			int64_t v15 = mw_mirth_type_PrimType_isZ_resourceZAsk(v14);
			if (((bool)v15)) {
				int64_t v16 = pop_i64();
				VAL v17 = mtw_mirth_type_Type_TPrim(v16);
				VAL v18 = mtw_std_either_Either_2_Right(v17);
				push_value(v18);
			} else {
				int64_t v19 = pop_i64();
				VAL v20 = mtw_mirth_type_Type_TPrim(v19);
				VAL v21 = mtw_std_either_Either_2_Left(v20);
				push_value(v21);
			}
		} break;
		case 1LL: { // TYCON_TABLE
			push_resource(x1);
			uint64_t v22 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			VAL v23 = mtw_mirth_type_Type_TTable(v22);
			VAL v24 = mtw_std_either_Either_2_Left(v23);
			push_value(v24);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static int64_t mw_mirth_data_Data_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_data_Data_allocZBang (void) {
	void* v0 = mbuf_mirth_data_Data_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_data_Data_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_data_Data_headZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeheadZAsk(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_data_Data_name (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_data_Data_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_data_Data_qnameZ_hard (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_data_Data_ZTildeqname(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static int64_t mw_mirth_data_Data_arity (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildearity(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static void mw_mirth_data_Data_params (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_data_Data_ZTildeparams(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static VAL mw_mirth_data_Data_tags (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildetags(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static void mw_mirth_data_Data_ctypeZAsk (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_data_Data_ZTildectypeZAsk(x1);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x2);
}
static void mw_mirth_data_TYPEz_BOOL (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[3]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_U64 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[6]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_U32 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[8]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_U16 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[10]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_U8 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[12]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_I64 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[14]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_I32 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[16]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_I16 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[18]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static void mw_mirth_data_TYPEz_I8 (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[20]);
	decref(v0);
	push_resource(x1);
	VAL v2 = mtw_mirth_type_Type_TData(v1);
	push_value(v2);
}
static VAL mw_mirth_data_makeZ_primZ_dataZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5, VAL x6) {
	incref(x3);
	push_resource(x1);
	lpush(&lbl_ctype, x6);
	lpush(&lbl_tags, x5);
	lpush(&lbl_data, MKU64(x4));
	lpush(&lbl_name, x2);
	lpush(&lbl_params, x3);
	int64_t v0 = mw_std_list_List_1_len(x3);
	uint64_t v1 = VU64(lpop(&lbl_data));
	void* v2 = mfld_mirth_data_Data_ZTildearity(v1);
	mut_set(MKI64(v0), MKPTR(v2));
	VAL v3 = lpop(&lbl_name);
	incref(v3);
	push_i64(v0);
	lpush(&lbl_data, MKU64(v1));
	lpush(&lbl_name, v3);
	uint64_t v4 = mw_std_prim_Str_ZToName(v3);
	uint64_t v5 = VU64(lpop(&lbl_data));
	void* v6 = mfld_mirth_data_Data_ZTildename(v5);
	mut_set(MKU64(v4), MKPTR(v6));
	VAL v7 = lpop(&lbl_name);
	int64_t v8 = pop_i64();
	VAL r9 = pop_resource();
	lpush(&lbl_data, MKU64(v5));
	mw_mirth_name_QName_prim(r9, v7, v8);
	uint64_t v10 = VU64(lpop(&lbl_data));
	lpush(&lbl_data, MKU64(v10));
	VAL v11 = mtw_mirth_mirth_PropLabel_DataQName(v10);
	VAL r12 = pop_resource();
	VAL v13 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v13, v11, r12);
	uint64_t v14 = VU64(lpop(&lbl_data));
	void* v15 = mfld_mirth_data_Data_ZTildeqname(v14);
	VAL v16 = pop_value();
	mut_set(v16, MKPTR(v15));
	VAL v17 = lpop(&lbl_ctype);
	push_value(v17);
	lpush(&lbl_data, MKU64(v14));
	VAL v18 = mtw_mirth_mirth_PropLabel_DataCType(v14);
	VAL r19 = pop_resource();
	VAL v20 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v20, v18, r19);
	uint64_t v21 = VU64(lpop(&lbl_data));
	void* v22 = mfld_mirth_data_Data_ZTildectypeZAsk(v21);
	VAL v23 = pop_value();
	mut_set(v23, MKPTR(v22));
	VAL v24 = lpop(&lbl_tags);
	incref(v24);
	lpush(&lbl_data, MKU64(v21));
	lpush(&lbl_tags, v24);
	mw_std_list_List_1_uncons(v24);
	VAL v25 = pop_value();
	VAL v26 = pop_value();
	push_value(v25);
	push_value(v26);
	while(1) {
		VAL v27 = pop_value();
		incref(v27);
		push_value(v27);
		int64_t v28 = mw_std_maybe_Maybe_1_someZAsk(v27);
		if (!((bool)v28)) break;
		VAL v29 = pop_value();
		VAL v30 = mw_std_maybe_Maybe_1_unwrap(v29);
		VAL v31 = pop_value();
		uint64_t v32 = VU64(lpop(&lbl_data));
		void* v33 = mfld_mirth_data_Tag_ZTildedata(VU64(v30));
		mut_set(MKU64(v32), MKPTR(v33));
		lpush(&lbl_data, MKU64(v32));
		mw_std_list_List_1_uncons(v31);
		VAL v34 = pop_value();
		VAL v35 = pop_value();
		push_value(v34);
		push_value(v35);
	}
	VAL v36 = pop_value();
	decref(v36);
	VAL v37 = pop_value();
	decref(v37);
	VAL v38 = lpop(&lbl_tags);
	uint64_t v39 = VU64(lpop(&lbl_data));
	void* v40 = mfld_mirth_data_Data_ZTildetags(v39);
	mut_set(v38, MKPTR(v40));
	VAL v41 = lpop(&lbl_params);
	push_value(v41);
	lpush(&lbl_data, MKU64(v39));
	VAL v42 = mtw_mirth_mirth_PropLabel_DataParams(v39);
	VAL r43 = pop_resource();
	VAL v44 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v44, v42, r43);
	uint64_t v45 = VU64(lpop(&lbl_data));
	void* v46 = mfld_mirth_data_Data_ZTildeparams(v45);
	VAL v47 = pop_value();
	mut_set(v47, MKPTR(v46));
	int64_t v48 = 0LL /* None */;
	void* v49 = mfld_mirth_data_Data_ZTildeheadZAsk(v45);
	mut_set(MKI64(v48), MKPTR(v49));
	VAL v50 = mtw_mirth_def_Def_DefData(v45);
	VAL r51 = pop_resource();
	VAL v52 = (mw_mirth_def_Def_register(r51, v50));
	return v52;
}
static VAL mw_mirth_data_makeZ_primZ_tagZBang (VAL x1, VAL x2, int64_t x3, VAL x4, uint64_t x5) {
	push_resource(x1);
	lpush(&lbl_inputs, x4);
	lpush(&lbl_value, MKI64(x3));
	lpush(&lbl_name, x2);
	lpush(&lbl_tag, MKU64(x5));
	uint64_t v0 = mw_mirth_data_Tag_data(x5);
	VAL v1 = lpop(&lbl_name);
	int64_t v2 = 0LL;
	VAL v3 = mw_mirth_data_dataZ_wordZ_qname(v0, v1, v2);
	uint64_t v4 = VU64(lpop(&lbl_tag));
	void* v5 = mfld_mirth_data_Tag_ZTildeqname(v4);
	mut_set(v3, MKPTR(v5));
	int64_t v6 = VI64(lpop(&lbl_value));
	void* v7 = mfld_mirth_data_Tag_ZTildevalue(v4);
	mut_set(MKI64(v6), MKPTR(v7));
	VAL v8 = lpop(&lbl_inputs);
	incref(v8);
	lpush(&lbl_tag, MKU64(v4));
	lpush(&lbl_inputs, v8);
	int64_t v9 = mw_std_list_List_1_len(v8);
	uint64_t v10 = VU64(lpop(&lbl_tag));
	void* v11 = mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs(v10);
	mut_set(MKI64(v9), MKPTR(v11));
	int64_t v12 = 0LL;
	lpush(&lbl_tag, MKU64(v10));
	int64_t v13 = mw_std_prim_Int_ZToNat(v12);
	uint64_t v14 = VU64(lpop(&lbl_tag));
	void* v15 = mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs(v14);
	mut_set(MKI64(v13), MKPTR(v15));
	int64_t v16 = 0LL /* Nil */;
	void* v17 = mfld_mirth_data_Tag_ZTildelabelZ_inputs(v14);
	mut_set(MKI64(v16), MKPTR(v17));
	lpush(&lbl_tag, MKU64(v14));
	uint64_t v18 = mw_mirth_data_Tag_data(v14);
	VAL r19 = pop_resource();
	mw_mirth_data_Data_params(r19, v18);
	VAL v20 = pop_value();
	VAL v21 = mw_std_list_List_1_ZToCtx(v20);
	VAL v22 = lpop(&lbl_inputs);
	push_value(v21);
	VAL v23 = mw_mirth_type_TT(v22);
	push_value(v23);
	VAL v24 = mw_mirth_type_T0();
	uint64_t v25 = VU64(lpop(&lbl_tag));
	push_value(v24);
	lpush(&lbl_tag, MKU64(v25));
	uint64_t v26 = mw_mirth_data_Tag_data(v25);
	VAL r27 = pop_resource();
	mw_mirth_data_Data_fullZ_type(r27, v26);
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	VAL v30 = mw_mirth_type_TZMulZPlus(v29, v28);
	VAL v31 = pop_value();
	VAL v32 = mw_mirth_type_TZ_ZTo(v31, v30);
	uint64_t v33 = VU64(lpop(&lbl_tag));
	push_value(v32);
	lpush(&lbl_tag, MKU64(v33));
	VAL v34 = mtw_mirth_mirth_PropLabel_TagType(v33);
	VAL r35 = pop_resource();
	VAL v36 = pop_value();
	VAL v37 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v37, v36, v34, r35);
	uint64_t v38 = VU64(lpop(&lbl_tag));
	void* v39 = mfld_mirth_data_Tag_ZTildectxZ_type(v38);
	VAL v40 = pop_value();
	mut_set(v40, MKPTR(v39));
	VAL v41 = mtw_mirth_def_Def_DefTag(v38);
	VAL r42 = pop_resource();
	VAL v43 = (mw_mirth_def_Def_register(r42, v41));
	return v43;
}
static VAL mw_mirth_data_makeZ_primZ_intlikeZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4, VAL x5, VAL x6) {
	int64_t v0 = 0LL /* Nil */;
	int64_t v1 = 0LL /* Nil */;
	push_resource(x6);
	lpush(&lbl_underlying, x5);
	lpush(&lbl_tagname, x3);
	push_value(x1);
	push_i64(v0);
	push_u64(x2);
	lpush(&lbl_tag, MKU64(x4));
	VAL v2 = mtw_std_list_List_1_Cons(MKU64(x4), MKI64(v1));
	VAL v3 = lpop(&lbl_underlying);
	push_value(v2);
	VAL v4 = mtw_mirth_type_CType_IntLike(v3);
	VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
	VAL v6 = pop_value();
	uint64_t v7 = pop_u64();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	VAL r10 = pop_resource();
	VAL v11 = (mw_mirth_data_makeZ_primZ_dataZBang(r10, v9, v8, v7, v6, v5));
	VAL v12 = lpop(&lbl_tagname);
	int64_t v13 = 0LL;
	push_resource(v11);
	push_value(v12);
	push_i64(v13);
	VAL v14 = mw_mirth_type_TYPEz_INT();
	int64_t v15 = 0LL /* Nil */;
	VAL v16 = mtw_std_list_List_1_Cons(v14, MKI64(v15));
	uint64_t v17 = VU64(lpop(&lbl_tag));
	int64_t v18 = pop_i64();
	VAL v19 = pop_value();
	VAL r20 = pop_resource();
	VAL v21 = (mw_mirth_data_makeZ_primZ_tagZBang(r20, v19, v18, v16, v17));
	return v21;
}
static VAL mw_mirth_data_initZ_dataZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "Bool", 4);
	int64_t v1 = 0LL /* Nil */;
	VAL v2 = VVAL(VTUP(x1)->cells[4]);
	incref(v2);
	uint64_t v3 = VU64(VTUP(v2)->cells[3]);
	decref(v2);
	VAL v4 = VVAL(VTUP(x1)->cells[4]);
	incref(v4);
	uint64_t v5 = VU64(VTUP(v4)->cells[4]);
	decref(v4);
	VAL v6 = VVAL(VTUP(x1)->cells[4]);
	incref(v6);
	uint64_t v7 = VU64(VTUP(v6)->cells[5]);
	decref(v6);
	int64_t v8 = 0LL /* Nil */;
	push_str(v0);
	push_i64(v1);
	push_u64(v3);
	push_u64(v5);
	push_resource(x1);
	VAL v9 = mtw_std_list_List_1_Cons(MKU64(v7), MKI64(v8));
	VAL v10 = pop_value();
	VAL v11 = mtw_std_list_List_1_Cons(v10, v9);
	STR* v12;
	STRLIT(v12, "_Bool", 5);
	push_value(v11);
	VAL v13 = mtw_mirth_type_CType_IntLike(MKSTR(v12));
	VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
	VAL v15 = pop_value();
	uint64_t v16 = pop_u64();
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	VAL r19 = pop_resource();
	VAL v20 = (mw_mirth_data_makeZ_primZ_dataZBang(r19, v18, v17, v16, v15, v14));
	STR* v21;
	STRLIT(v21, "False", 5);
	int64_t v22 = 0LL;
	int64_t v23 = 0LL /* Nil */;
	VAL v24 = VVAL(VTUP(v20)->cells[4]);
	incref(v24);
	uint64_t v25 = VU64(VTUP(v24)->cells[5]);
	decref(v24);
	VAL v26 = (mw_mirth_data_makeZ_primZ_tagZBang(v20, MKSTR(v21), v22, MKI64(v23), v25));
	STR* v27;
	STRLIT(v27, "True", 4);
	int64_t v28 = 1LL;
	int64_t v29 = 0LL /* Nil */;
	VAL v30 = VVAL(VTUP(v26)->cells[4]);
	incref(v30);
	uint64_t v31 = VU64(VTUP(v30)->cells[4]);
	decref(v30);
	VAL v32 = (mw_mirth_data_makeZ_primZ_tagZBang(v26, MKSTR(v27), v28, MKI64(v29), v31));
	push_resource(v32);
	VAL v33 = mw_mirth_type_TYPEz_TYPE();
	STR* v34;
	STRLIT(v34, "a", 1);
	push_value(v33);
	uint64_t v35 = mw_std_prim_Str_ZToName(MKSTR(v34));
	VAL v36 = pop_value();
	uint64_t v37 = mw_mirth_var_Var_newZBang(v36, v35);
	STR* v38;
	STRLIT(v38, "CPtr", 4);
	int64_t v39 = 0LL /* Nil */;
	push_str(v38);
	lpush(&lbl_a, MKU64(v37));
	VAL v40 = mtw_std_list_List_1_Cons(MKU64(v37), MKI64(v39));
	VAL r41 = pop_resource();
	VAL v42 = VVAL(VTUP(r41)->cells[4]);
	incref(v42);
	uint64_t v43 = VU64(VTUP(v42)->cells[52]);
	decref(v42);
	VAL v44 = VVAL(VTUP(r41)->cells[4]);
	incref(v44);
	uint64_t v45 = VU64(VTUP(v44)->cells[53]);
	decref(v44);
	int64_t v46 = 0LL /* Nil */;
	push_value(v40);
	push_u64(v43);
	push_resource(r41);
	VAL v47 = mtw_std_list_List_1_Cons(MKU64(v45), MKI64(v46));
	int64_t v48 = 0LL /* None */;
	uint64_t v49 = pop_u64();
	VAL v50 = pop_value();
	VAL v51 = pop_value();
	VAL r52 = pop_resource();
	VAL v53 = (mw_mirth_data_makeZ_primZ_dataZBang(r52, v51, v50, v49, v47, MKI64(v48)));
	STR* v54;
	STRLIT(v54, "CPtr", 4);
	int64_t v55 = 0LL;
	push_resource(v53);
	push_str(v54);
	push_i64(v55);
	VAL v56 = mw_mirth_type_TYPEz_PTR();
	int64_t v57 = 0LL /* Nil */;
	VAL v58 = mtw_std_list_List_1_Cons(v56, MKI64(v57));
	VAL r59 = pop_resource();
	VAL v60 = VVAL(VTUP(r59)->cells[4]);
	incref(v60);
	uint64_t v61 = VU64(VTUP(v60)->cells[53]);
	decref(v60);
	int64_t v62 = pop_i64();
	VAL v63 = pop_value();
	VAL v64 = (mw_mirth_data_makeZ_primZ_tagZBang(r59, v63, v62, v58, v61));
	STR* v65;
	STRLIT(v65, "CConst", 6);
	uint64_t v66 = VU64(lpop(&lbl_a));
	int64_t v67 = 0LL /* Nil */;
	push_resource(v64);
	push_str(v65);
	lpush(&lbl_a, MKU64(v66));
	VAL v68 = mtw_std_list_List_1_Cons(MKU64(v66), MKI64(v67));
	VAL r69 = pop_resource();
	VAL v70 = VVAL(VTUP(r69)->cells[4]);
	incref(v70);
	uint64_t v71 = VU64(VTUP(v70)->cells[54]);
	decref(v70);
	VAL v72 = VVAL(VTUP(r69)->cells[4]);
	incref(v72);
	uint64_t v73 = VU64(VTUP(v72)->cells[55]);
	decref(v72);
	int64_t v74 = 0LL /* Nil */;
	push_value(v68);
	push_u64(v71);
	push_resource(r69);
	VAL v75 = mtw_std_list_List_1_Cons(MKU64(v73), MKI64(v74));
	int64_t v76 = 0LL /* None */;
	uint64_t v77 = pop_u64();
	VAL v78 = pop_value();
	VAL v79 = pop_value();
	VAL r80 = pop_resource();
	VAL v81 = (mw_mirth_data_makeZ_primZ_dataZBang(r80, v79, v78, v77, v75, MKI64(v76)));
	STR* v82;
	STRLIT(v82, "CConst", 6);
	int64_t v83 = 0LL;
	uint64_t v84 = VU64(lpop(&lbl_a));
	push_resource(v81);
	push_str(v82);
	push_i64(v83);
	lpush(&lbl_a, MKU64(v84));
	VAL v85 = mtw_mirth_type_Type_TVar(v84);
	int64_t v86 = 0LL /* Nil */;
	VAL v87 = mtw_std_list_List_1_Cons(v85, MKI64(v86));
	VAL r88 = pop_resource();
	VAL v89 = VVAL(VTUP(r88)->cells[4]);
	incref(v89);
	uint64_t v90 = VU64(VTUP(v89)->cells[55]);
	decref(v89);
	int64_t v91 = pop_i64();
	VAL v92 = pop_value();
	VAL v93 = (mw_mirth_data_makeZ_primZ_tagZBang(r88, v92, v91, v87, v90));
	STR* v94;
	STRLIT(v94, "CRestrict", 9);
	uint64_t v95 = VU64(lpop(&lbl_a));
	int64_t v96 = 0LL /* Nil */;
	push_resource(v93);
	push_str(v94);
	lpush(&lbl_a, MKU64(v95));
	VAL v97 = mtw_std_list_List_1_Cons(MKU64(v95), MKI64(v96));
	VAL r98 = pop_resource();
	VAL v99 = VVAL(VTUP(r98)->cells[4]);
	incref(v99);
	uint64_t v100 = VU64(VTUP(v99)->cells[56]);
	decref(v99);
	VAL v101 = VVAL(VTUP(r98)->cells[4]);
	incref(v101);
	uint64_t v102 = VU64(VTUP(v101)->cells[57]);
	decref(v101);
	int64_t v103 = 0LL /* Nil */;
	push_value(v97);
	push_u64(v100);
	push_resource(r98);
	VAL v104 = mtw_std_list_List_1_Cons(MKU64(v102), MKI64(v103));
	int64_t v105 = 0LL /* None */;
	uint64_t v106 = pop_u64();
	VAL v107 = pop_value();
	VAL v108 = pop_value();
	VAL r109 = pop_resource();
	VAL v110 = (mw_mirth_data_makeZ_primZ_dataZBang(r109, v108, v107, v106, v104, MKI64(v105)));
	STR* v111;
	STRLIT(v111, "CRestrict", 9);
	int64_t v112 = 0LL;
	uint64_t v113 = VU64(lpop(&lbl_a));
	push_resource(v110);
	push_str(v111);
	push_i64(v112);
	lpush(&lbl_a, MKU64(v113));
	VAL v114 = mtw_mirth_type_Type_TVar(v113);
	int64_t v115 = 0LL /* Nil */;
	VAL v116 = mtw_std_list_List_1_Cons(v114, MKI64(v115));
	VAL r117 = pop_resource();
	VAL v118 = VVAL(VTUP(r117)->cells[4]);
	incref(v118);
	uint64_t v119 = VU64(VTUP(v118)->cells[57]);
	decref(v118);
	int64_t v120 = pop_i64();
	VAL v121 = pop_value();
	VAL v122 = (mw_mirth_data_makeZ_primZ_tagZBang(r117, v121, v120, v116, v119));
	STR* v123;
	STRLIT(v123, "CVolatile", 9);
	uint64_t v124 = VU64(lpop(&lbl_a));
	int64_t v125 = 0LL /* Nil */;
	push_resource(v122);
	push_str(v123);
	lpush(&lbl_a, MKU64(v124));
	VAL v126 = mtw_std_list_List_1_Cons(MKU64(v124), MKI64(v125));
	VAL r127 = pop_resource();
	VAL v128 = VVAL(VTUP(r127)->cells[4]);
	incref(v128);
	uint64_t v129 = VU64(VTUP(v128)->cells[58]);
	decref(v128);
	VAL v130 = VVAL(VTUP(r127)->cells[4]);
	incref(v130);
	uint64_t v131 = VU64(VTUP(v130)->cells[59]);
	decref(v130);
	int64_t v132 = 0LL /* Nil */;
	push_value(v126);
	push_u64(v129);
	push_resource(r127);
	VAL v133 = mtw_std_list_List_1_Cons(MKU64(v131), MKI64(v132));
	int64_t v134 = 0LL /* None */;
	uint64_t v135 = pop_u64();
	VAL v136 = pop_value();
	VAL v137 = pop_value();
	VAL r138 = pop_resource();
	VAL v139 = (mw_mirth_data_makeZ_primZ_dataZBang(r138, v137, v136, v135, v133, MKI64(v134)));
	STR* v140;
	STRLIT(v140, "CVolatile", 9);
	int64_t v141 = 0LL;
	uint64_t v142 = VU64(lpop(&lbl_a));
	push_resource(v139);
	push_str(v140);
	push_i64(v141);
	lpush(&lbl_a, MKU64(v142));
	VAL v143 = mtw_mirth_type_Type_TVar(v142);
	int64_t v144 = 0LL /* Nil */;
	VAL v145 = mtw_std_list_List_1_Cons(v143, MKI64(v144));
	VAL r146 = pop_resource();
	VAL v147 = VVAL(VTUP(r146)->cells[4]);
	incref(v147);
	uint64_t v148 = VU64(VTUP(v147)->cells[59]);
	decref(v147);
	int64_t v149 = pop_i64();
	VAL v150 = pop_value();
	VAL v151 = (mw_mirth_data_makeZ_primZ_tagZBang(r146, v150, v149, v145, v148));
	uint64_t v152 = VU64(lpop(&lbl_a));
	STR* v153;
	STRLIT(v153, "CVoid", 5);
	int64_t v154 = 0LL /* Nil */;
	VAL v155 = VVAL(VTUP(v151)->cells[4]);
	incref(v155);
	uint64_t v156 = VU64(VTUP(v155)->cells[60]);
	decref(v155);
	VAL v157 = VVAL(VTUP(v151)->cells[4]);
	incref(v157);
	uint64_t v158 = VU64(VTUP(v157)->cells[61]);
	decref(v157);
	int64_t v159 = 0LL /* Nil */;
	push_str(v153);
	push_i64(v154);
	push_u64(v156);
	push_resource(v151);
	VAL v160 = mtw_std_list_List_1_Cons(MKU64(v158), MKI64(v159));
	int64_t v161 = 5LL /* Phantom */;
	push_value(v160);
	VAL v162 = mtw_std_maybe_Maybe_1_Some(MKI64(v161));
	VAL v163 = pop_value();
	uint64_t v164 = pop_u64();
	VAL v165 = pop_value();
	VAL v166 = pop_value();
	VAL r167 = pop_resource();
	VAL v168 = (mw_mirth_data_makeZ_primZ_dataZBang(r167, v166, v165, v164, v163, v162));
	STR* v169;
	STRLIT(v169, "CVoid", 5);
	int64_t v170 = 0LL;
	int64_t v171 = 0LL /* Nil */;
	VAL v172 = VVAL(VTUP(v168)->cells[4]);
	incref(v172);
	uint64_t v173 = VU64(VTUP(v172)->cells[61]);
	decref(v172);
	VAL v174 = (mw_mirth_data_makeZ_primZ_tagZBang(v168, MKSTR(v169), v170, MKI64(v171), v173));
	STR* v175;
	STRLIT(v175, "U64", 3);
	VAL v176 = VVAL(VTUP(v174)->cells[4]);
	incref(v176);
	uint64_t v177 = VU64(VTUP(v176)->cells[6]);
	decref(v176);
	STR* v178;
	STRLIT(v178, "Int>U64-unsafe", 14);
	VAL v179 = VVAL(VTUP(v174)->cells[4]);
	incref(v179);
	uint64_t v180 = VU64(VTUP(v179)->cells[7]);
	decref(v179);
	STR* v181;
	STRLIT(v181, "uint64_t", 8);
	VAL v182 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v175), v177, MKSTR(v178), v180, MKSTR(v181), v174));
	STR* v183;
	STRLIT(v183, "U32", 3);
	VAL v184 = VVAL(VTUP(v182)->cells[4]);
	incref(v184);
	uint64_t v185 = VU64(VTUP(v184)->cells[8]);
	decref(v184);
	STR* v186;
	STRLIT(v186, "Int>U32-unsafe", 14);
	VAL v187 = VVAL(VTUP(v182)->cells[4]);
	incref(v187);
	uint64_t v188 = VU64(VTUP(v187)->cells[9]);
	decref(v187);
	STR* v189;
	STRLIT(v189, "uint32_t", 8);
	VAL v190 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v183), v185, MKSTR(v186), v188, MKSTR(v189), v182));
	STR* v191;
	STRLIT(v191, "U16", 3);
	VAL v192 = VVAL(VTUP(v190)->cells[4]);
	incref(v192);
	uint64_t v193 = VU64(VTUP(v192)->cells[10]);
	decref(v192);
	STR* v194;
	STRLIT(v194, "Int>U16-unsafe", 14);
	VAL v195 = VVAL(VTUP(v190)->cells[4]);
	incref(v195);
	uint64_t v196 = VU64(VTUP(v195)->cells[11]);
	decref(v195);
	STR* v197;
	STRLIT(v197, "uint16_t", 8);
	VAL v198 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v191), v193, MKSTR(v194), v196, MKSTR(v197), v190));
	STR* v199;
	STRLIT(v199, "U8", 2);
	VAL v200 = VVAL(VTUP(v198)->cells[4]);
	incref(v200);
	uint64_t v201 = VU64(VTUP(v200)->cells[12]);
	decref(v200);
	STR* v202;
	STRLIT(v202, "Int>U8-unsafe", 13);
	VAL v203 = VVAL(VTUP(v198)->cells[4]);
	incref(v203);
	uint64_t v204 = VU64(VTUP(v203)->cells[13]);
	decref(v203);
	STR* v205;
	STRLIT(v205, "uint8_t", 7);
	VAL v206 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v199), v201, MKSTR(v202), v204, MKSTR(v205), v198));
	STR* v207;
	STRLIT(v207, "I64", 3);
	VAL v208 = VVAL(VTUP(v206)->cells[4]);
	incref(v208);
	uint64_t v209 = VU64(VTUP(v208)->cells[14]);
	decref(v208);
	STR* v210;
	STRLIT(v210, "Int>I64-unsafe", 14);
	VAL v211 = VVAL(VTUP(v206)->cells[4]);
	incref(v211);
	uint64_t v212 = VU64(VTUP(v211)->cells[15]);
	decref(v211);
	STR* v213;
	STRLIT(v213, "int64_t", 7);
	VAL v214 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v207), v209, MKSTR(v210), v212, MKSTR(v213), v206));
	STR* v215;
	STRLIT(v215, "I32", 3);
	VAL v216 = VVAL(VTUP(v214)->cells[4]);
	incref(v216);
	uint64_t v217 = VU64(VTUP(v216)->cells[16]);
	decref(v216);
	STR* v218;
	STRLIT(v218, "Int>I32-unsafe", 14);
	VAL v219 = VVAL(VTUP(v214)->cells[4]);
	incref(v219);
	uint64_t v220 = VU64(VTUP(v219)->cells[17]);
	decref(v219);
	STR* v221;
	STRLIT(v221, "int32_t", 7);
	VAL v222 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v215), v217, MKSTR(v218), v220, MKSTR(v221), v214));
	STR* v223;
	STRLIT(v223, "I16", 3);
	VAL v224 = VVAL(VTUP(v222)->cells[4]);
	incref(v224);
	uint64_t v225 = VU64(VTUP(v224)->cells[18]);
	decref(v224);
	STR* v226;
	STRLIT(v226, "Int>I16-unsafe", 14);
	VAL v227 = VVAL(VTUP(v222)->cells[4]);
	incref(v227);
	uint64_t v228 = VU64(VTUP(v227)->cells[19]);
	decref(v227);
	STR* v229;
	STRLIT(v229, "int16_t", 7);
	VAL v230 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v223), v225, MKSTR(v226), v228, MKSTR(v229), v222));
	STR* v231;
	STRLIT(v231, "I8", 2);
	VAL v232 = VVAL(VTUP(v230)->cells[4]);
	incref(v232);
	uint64_t v233 = VU64(VTUP(v232)->cells[20]);
	decref(v232);
	STR* v234;
	STRLIT(v234, "Int>I8-unsafe", 13);
	VAL v235 = VVAL(VTUP(v230)->cells[4]);
	incref(v235);
	uint64_t v236 = VU64(VTUP(v235)->cells[21]);
	decref(v235);
	STR* v237;
	STRLIT(v237, "int8_t", 6);
	VAL v238 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v231), v233, MKSTR(v234), v236, MKSTR(v237), v230));
	STR* v239;
	STRLIT(v239, "CChar", 5);
	VAL v240 = VVAL(VTUP(v238)->cells[4]);
	incref(v240);
	uint64_t v241 = VU64(VTUP(v240)->cells[22]);
	decref(v240);
	STR* v242;
	STRLIT(v242, "CChar", 5);
	VAL v243 = VVAL(VTUP(v238)->cells[4]);
	incref(v243);
	uint64_t v244 = VU64(VTUP(v243)->cells[23]);
	decref(v243);
	STR* v245;
	STRLIT(v245, "char", 4);
	VAL v246 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v239), v241, MKSTR(v242), v244, MKSTR(v245), v238));
	STR* v247;
	STRLIT(v247, "CIChar", 6);
	VAL v248 = VVAL(VTUP(v246)->cells[4]);
	incref(v248);
	uint64_t v249 = VU64(VTUP(v248)->cells[24]);
	decref(v248);
	STR* v250;
	STRLIT(v250, "CIChar", 6);
	VAL v251 = VVAL(VTUP(v246)->cells[4]);
	incref(v251);
	uint64_t v252 = VU64(VTUP(v251)->cells[25]);
	decref(v251);
	STR* v253;
	STRLIT(v253, "signed char", 11);
	VAL v254 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v247), v249, MKSTR(v250), v252, MKSTR(v253), v246));
	STR* v255;
	STRLIT(v255, "CShort", 6);
	VAL v256 = VVAL(VTUP(v254)->cells[4]);
	incref(v256);
	uint64_t v257 = VU64(VTUP(v256)->cells[26]);
	decref(v256);
	STR* v258;
	STRLIT(v258, "CShort", 6);
	VAL v259 = VVAL(VTUP(v254)->cells[4]);
	incref(v259);
	uint64_t v260 = VU64(VTUP(v259)->cells[27]);
	decref(v259);
	STR* v261;
	STRLIT(v261, "short", 5);
	VAL v262 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v255), v257, MKSTR(v258), v260, MKSTR(v261), v254));
	STR* v263;
	STRLIT(v263, "CInt", 4);
	VAL v264 = VVAL(VTUP(v262)->cells[4]);
	incref(v264);
	uint64_t v265 = VU64(VTUP(v264)->cells[28]);
	decref(v264);
	STR* v266;
	STRLIT(v266, "CInt", 4);
	VAL v267 = VVAL(VTUP(v262)->cells[4]);
	incref(v267);
	uint64_t v268 = VU64(VTUP(v267)->cells[29]);
	decref(v267);
	STR* v269;
	STRLIT(v269, "int", 3);
	VAL v270 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v263), v265, MKSTR(v266), v268, MKSTR(v269), v262));
	STR* v271;
	STRLIT(v271, "CLong", 5);
	VAL v272 = VVAL(VTUP(v270)->cells[4]);
	incref(v272);
	uint64_t v273 = VU64(VTUP(v272)->cells[30]);
	decref(v272);
	STR* v274;
	STRLIT(v274, "CLong", 5);
	VAL v275 = VVAL(VTUP(v270)->cells[4]);
	incref(v275);
	uint64_t v276 = VU64(VTUP(v275)->cells[31]);
	decref(v275);
	STR* v277;
	STRLIT(v277, "long", 4);
	VAL v278 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v271), v273, MKSTR(v274), v276, MKSTR(v277), v270));
	STR* v279;
	STRLIT(v279, "CLongLong", 9);
	VAL v280 = VVAL(VTUP(v278)->cells[4]);
	incref(v280);
	uint64_t v281 = VU64(VTUP(v280)->cells[32]);
	decref(v280);
	STR* v282;
	STRLIT(v282, "CLongLong", 9);
	VAL v283 = VVAL(VTUP(v278)->cells[4]);
	incref(v283);
	uint64_t v284 = VU64(VTUP(v283)->cells[33]);
	decref(v283);
	STR* v285;
	STRLIT(v285, "long long", 9);
	VAL v286 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v279), v281, MKSTR(v282), v284, MKSTR(v285), v278));
	STR* v287;
	STRLIT(v287, "CISize", 6);
	VAL v288 = VVAL(VTUP(v286)->cells[4]);
	incref(v288);
	uint64_t v289 = VU64(VTUP(v288)->cells[34]);
	decref(v288);
	STR* v290;
	STRLIT(v290, "CISize", 6);
	VAL v291 = VVAL(VTUP(v286)->cells[4]);
	incref(v291);
	uint64_t v292 = VU64(VTUP(v291)->cells[35]);
	decref(v291);
	STR* v293;
	STRLIT(v293, "ssize_t", 7);
	VAL v294 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v287), v289, MKSTR(v290), v292, MKSTR(v293), v286));
	STR* v295;
	STRLIT(v295, "CIntPtr", 7);
	VAL v296 = VVAL(VTUP(v294)->cells[4]);
	incref(v296);
	uint64_t v297 = VU64(VTUP(v296)->cells[36]);
	decref(v296);
	STR* v298;
	STRLIT(v298, "CIntPtr", 7);
	VAL v299 = VVAL(VTUP(v294)->cells[4]);
	incref(v299);
	uint64_t v300 = VU64(VTUP(v299)->cells[37]);
	decref(v299);
	STR* v301;
	STRLIT(v301, "intptr_t", 8);
	VAL v302 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v295), v297, MKSTR(v298), v300, MKSTR(v301), v294));
	STR* v303;
	STRLIT(v303, "CUChar", 6);
	VAL v304 = VVAL(VTUP(v302)->cells[4]);
	incref(v304);
	uint64_t v305 = VU64(VTUP(v304)->cells[38]);
	decref(v304);
	STR* v306;
	STRLIT(v306, "CUChar", 6);
	VAL v307 = VVAL(VTUP(v302)->cells[4]);
	incref(v307);
	uint64_t v308 = VU64(VTUP(v307)->cells[39]);
	decref(v307);
	STR* v309;
	STRLIT(v309, "unsigned char", 13);
	VAL v310 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v303), v305, MKSTR(v306), v308, MKSTR(v309), v302));
	STR* v311;
	STRLIT(v311, "CUShort", 7);
	VAL v312 = VVAL(VTUP(v310)->cells[4]);
	incref(v312);
	uint64_t v313 = VU64(VTUP(v312)->cells[40]);
	decref(v312);
	STR* v314;
	STRLIT(v314, "CUShort", 7);
	VAL v315 = VVAL(VTUP(v310)->cells[4]);
	incref(v315);
	uint64_t v316 = VU64(VTUP(v315)->cells[41]);
	decref(v315);
	STR* v317;
	STRLIT(v317, "unsigned short", 14);
	VAL v318 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v311), v313, MKSTR(v314), v316, MKSTR(v317), v310));
	STR* v319;
	STRLIT(v319, "CUInt", 5);
	VAL v320 = VVAL(VTUP(v318)->cells[4]);
	incref(v320);
	uint64_t v321 = VU64(VTUP(v320)->cells[42]);
	decref(v320);
	STR* v322;
	STRLIT(v322, "CUInt", 5);
	VAL v323 = VVAL(VTUP(v318)->cells[4]);
	incref(v323);
	uint64_t v324 = VU64(VTUP(v323)->cells[43]);
	decref(v323);
	STR* v325;
	STRLIT(v325, "unsigned int", 12);
	VAL v326 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v319), v321, MKSTR(v322), v324, MKSTR(v325), v318));
	STR* v327;
	STRLIT(v327, "CULong", 6);
	VAL v328 = VVAL(VTUP(v326)->cells[4]);
	incref(v328);
	uint64_t v329 = VU64(VTUP(v328)->cells[44]);
	decref(v328);
	STR* v330;
	STRLIT(v330, "CULong", 6);
	VAL v331 = VVAL(VTUP(v326)->cells[4]);
	incref(v331);
	uint64_t v332 = VU64(VTUP(v331)->cells[45]);
	decref(v331);
	STR* v333;
	STRLIT(v333, "unsigned long", 13);
	VAL v334 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v327), v329, MKSTR(v330), v332, MKSTR(v333), v326));
	STR* v335;
	STRLIT(v335, "CULongLong", 10);
	VAL v336 = VVAL(VTUP(v334)->cells[4]);
	incref(v336);
	uint64_t v337 = VU64(VTUP(v336)->cells[46]);
	decref(v336);
	STR* v338;
	STRLIT(v338, "CULongLong", 10);
	VAL v339 = VVAL(VTUP(v334)->cells[4]);
	incref(v339);
	uint64_t v340 = VU64(VTUP(v339)->cells[47]);
	decref(v339);
	STR* v341;
	STRLIT(v341, "unsigned long long", 18);
	VAL v342 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v335), v337, MKSTR(v338), v340, MKSTR(v341), v334));
	STR* v343;
	STRLIT(v343, "CUSize", 6);
	VAL v344 = VVAL(VTUP(v342)->cells[4]);
	incref(v344);
	uint64_t v345 = VU64(VTUP(v344)->cells[48]);
	decref(v344);
	STR* v346;
	STRLIT(v346, "CUSize", 6);
	VAL v347 = VVAL(VTUP(v342)->cells[4]);
	incref(v347);
	uint64_t v348 = VU64(VTUP(v347)->cells[49]);
	decref(v347);
	STR* v349;
	STRLIT(v349, "size_t", 6);
	VAL v350 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v343), v345, MKSTR(v346), v348, MKSTR(v349), v342));
	STR* v351;
	STRLIT(v351, "CUIntPtr", 8);
	VAL v352 = VVAL(VTUP(v350)->cells[4]);
	incref(v352);
	uint64_t v353 = VU64(VTUP(v352)->cells[50]);
	decref(v352);
	STR* v354;
	STRLIT(v354, "CUIntPtr", 8);
	VAL v355 = VVAL(VTUP(v350)->cells[4]);
	incref(v355);
	uint64_t v356 = VU64(VTUP(v355)->cells[51]);
	decref(v355);
	STR* v357;
	STRLIT(v357, "uintptr_t", 9);
	VAL v358 = (mw_mirth_data_makeZ_primZ_intlikeZBang(MKSTR(v351), v353, MKSTR(v354), v356, MKSTR(v357), v350));
	return v358;
}
static VAL mw_mirth_data_dataZ_qname (uint64_t x1, uint64_t x2, int64_t x3) {
	lpush(&lbl_arity, MKI64(x3));
	lpush(&lbl_name, MKU64(x2));
	VAL v0 = mtw_mirth_tycon_Tycon_TYCONz_DATA(x1);
	VAL v1 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v0);
	int64_t v2 = VI64(lpop(&lbl_arity));
	uint64_t v3 = VU64(lpop(&lbl_name));
	VAL v4 = mtw_mirth_name_QName_MKQNAME(v1, v3, v2);
	return v4;
}
static VAL mw_mirth_data_dataZ_wordZ_qname (uint64_t x1, VAL x2, int64_t x3) {
	push_u64(x1);
	uint64_t v0 = mw_std_prim_Str_ZToName(x2);
	uint64_t v1 = pop_u64();
	VAL v2 = mw_mirth_data_dataZ_qname(v1, v0, x3);
	return v2;
}
static int64_t mw_mirth_data_Data_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_data_Data_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_data_Data_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static int64_t mw_mirth_data_Data_numZ_tags (uint64_t x1) {
	VAL v0 = mw_mirth_data_Data_tags(x1);
	int64_t v1 = mw_std_list_List_1_len(v0);
	return v1;
}
static VAL mw_mirth_data_Data_addZ_tagZBang (VAL x1, uint64_t x2, uint64_t x3) {
	void* v0 = mfld_mirth_data_Tag_ZTildevalue(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_u64(x3);
		push_value(v2);
	} else {
		void* v3 = mfld_mirth_data_Data_ZTildelastZ_tagZ_value(x3);
		push_resource(x1);
		push_u64(x2);
		push_u64(x3);
		VAL v4 = mw_std_prelude_ZAtZAsk(MKPTR(v3));
		switch (get_data_tag(v4)) {
			case 1LL: { // Some
				VAL v5 = mtp_std_maybe_Maybe_1_Some(v4);
				int64_t v6 = 1LL;
				int64_t v7 = i64_add(VI64(v5), v6);
				push_i64(v7);
			} break;
			case 0LL: { // None
				int64_t v8 = 0LL;
				push_i64(v8);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		int64_t v9 = pop_i64();
		mut_set(MKI64(v9), MKPTR(v0));
		push_i64(v9);
	}
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	incref(v11);
	push_value(v11);
	push_value(v10);
	VAL v12 = mw_mirth_data_Data_tags(VU64(v11));
	int64_t v13 = 0LL /* None */;
	push_i64(v13);
	mw_std_list_List_1_uncons(v12);
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	push_value(v14);
	push_value(v15);
	while(1) {
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		int64_t v17 = mw_std_maybe_Maybe_1_someZAsk(v16);
		if (!((bool)v17)) break;
		VAL v18 = pop_value();
		VAL v19 = mw_std_maybe_Maybe_1_unwrap(v18);
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		incref(v19);
		int64_t v22 = mw_mirth_data_Tag_value(VU64(v19));
		VAL v23 = pop_value();
		incref(v23);
		bool v24 = (v22 == VI64(v23));
		if (v24) {
			push_value(v23);
			VAL v25 = mtw_std_maybe_Maybe_1_Some(v19);
			push_value(v25);
		} else {
			decref(v19);
			int64_t v26 = 0LL /* None */;
			push_value(v23);
			push_i64(v26);
		}
		VAL v27 = pop_value();
		switch (get_data_tag(v27)) {
			case 0LL: { // None
				push_value(v21);
				push_value(v20);
			} break;
			default: {
				decref(v20);
				decref(v21);
				int64_t v28 = 0LL /* Nil */;
				push_value(v27);
				push_i64(v28);
			} break;
		}
		VAL v29 = pop_value();
		mw_std_list_List_1_uncons(v29);
		VAL v30 = pop_value();
		VAL v31 = pop_value();
		push_value(v30);
		push_value(v31);
	}
	VAL v32 = pop_value();
	decref(v32);
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	switch (get_data_tag(v34)) {
		case 1LL: { // Some
			VAL v35 = mtp_std_maybe_Maybe_1_Some(v34);
			STR* v36;
			STRLIT(v36, "", 0);
			STR* v37;
			STRLIT(v37, "Constructors ", 13);
			push_value(v35);
			VAL v38 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v37), MKSTR(v36)));
			uint64_t v39 = pop_u64();
			push_resource(v38);
			uint64_t v40 = mw_mirth_data_Tag_name(v39);
			VAL r41 = pop_resource();
			VAL v42 = mw_mirth_name_Name_ZToStr(v40);
			VAL v43 = (mw_std_str_ZPlusStr_pushZ_strZBang(v42, r41));
			STR* v44;
			STRLIT(v44, " and ", 5);
			VAL v45 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v44), v43));
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			VAL v48 = pop_value();
			incref(v48);
			push_resource(v45);
			push_value(v48);
			push_value(v47);
			push_value(v46);
			uint64_t v49 = mw_mirth_data_Tag_name(VU64(v48));
			VAL r50 = pop_resource();
			VAL v51 = mw_mirth_name_Name_ZToStr(v49);
			VAL v52 = (mw_std_str_ZPlusStr_pushZ_strZBang(v51, r50));
			STR* v53;
			STRLIT(v53, " have the same tag value.", 25);
			VAL v54 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v53), v52));
			VAL v55 = pop_value();
			VAL v56 = pop_value();
			incref(v56);
			push_value(v56);
			push_value(v55);
			push_value(v54);
			VAL v57 = mw_mirth_data_Data_headZAsk(VU64(v56));
			switch (get_data_tag(v57)) {
				case 1LL: { // Some
					VAL v58 = mtp_std_maybe_Maybe_1_Some(v57);
					push_value(v58);
				} break;
				case 0LL: { // None
					VAL r59 = pop_resource();
					VAL v60 = VVAL(VTUP(r59)->cells[5]);
					incref(v60);
					switch (get_data_tag(v60)) {
						case 1LL: { // Some
							push_resource(r59);
							VAL v61 = mtp_std_maybe_Maybe_1_Some(v60);
							push_value(v61);
						} break;
						case 0LL: { // None
							push_resource(r59);
							do_panic();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_resource(r59);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			uint64_t v62 = pop_u64();
			VAL v63 = pop_value();
			VAL r64 = pop_resource();
			VAL v65 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v62, v63, r64));
			push_resource(v65);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v66 = pop_value();
	VAL v67 = pop_value();
	incref(v67);
	void* v68 = mfld_mirth_data_Data_ZTildelastZ_tagZ_value(VU64(v67));
	mut_set(v66, MKPTR(v68));
	incref(v67);
	VAL v69 = mw_mirth_data_Data_tags(VU64(v67));
	uint64_t v70 = pop_u64();
	int64_t v71 = 0LL /* Nil */;
	push_value(v69);
	VAL v72 = mtw_std_list_List_1_Cons(MKU64(v70), MKI64(v71));
	VAL v73 = pop_value();
	VAL v74 = mw_std_list_List_1_cat(v73, v72);
	void* v75 = mfld_mirth_data_Data_ZTildetags(VU64(v67));
	mut_set(v74, MKPTR(v75));
	VAL r76 = pop_resource();
	return r76;
}
static int64_t mw_mirth_data_Data_isZ_unitZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeisZ_unitZAsk(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		VAL v3 = mw_mirth_data_Data_tags(x1);
		VAL v4 = mw_std_list_List_1_ZDivL1(v3);
		switch (get_data_tag(v4)) {
			case 1LL: { // Some
				VAL v5 = mtp_std_maybe_Maybe_1_Some(v4);
				int64_t v6 = mw_mirth_data_Tag_numZ_totalZ_inputs(VU64(v5));
				int64_t v7 = 0LL;
				bool v8 = (v6 == v7);
				push_bool(v8);
			} break;
			case 0LL: { // None
				int64_t v9 = 0LL /* False */;
				push_i64(v9);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		int64_t v10 = pop_i64();
		mut_set(MKI64(v10), MKPTR(v0));
		push_i64(v10);
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	decref(v12);
	return VI64(v11);
}
static int64_t mw_mirth_data_Data_isZ_enumZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeisZ_enumZAsk(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		int64_t v3 = mw_mirth_data_Data_isZ_unitZAsk(x1);
		bool v4 = !((bool)v3);
		if (v4) {
			uint64_t v5 = pop_u64();
			push_u64(v5);
			VAL v6 = mw_mirth_data_Data_tags(v5);
			int64_t v7 = 0LL /* None */;
			push_i64(v7);
			mw_std_list_List_1_uncons(v6);
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			push_value(v8);
			push_value(v9);
			while(1) {
				VAL v10 = pop_value();
				incref(v10);
				push_value(v10);
				int64_t v11 = mw_std_maybe_Maybe_1_someZAsk(v10);
				if (!((bool)v11)) break;
				VAL v12 = pop_value();
				VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				incref(v13);
				int64_t v16 = mw_mirth_data_Tag_numZ_totalZ_inputs(VU64(v13));
				int64_t v17 = 0LL;
				bool v18 = (v16 == v17);
				bool v19 = !v18;
				if (v19) {
					VAL v20 = mtw_std_maybe_Maybe_1_Some(v13);
					push_value(v20);
				} else {
					decref(v13);
					int64_t v21 = 0LL /* None */;
					push_i64(v21);
				}
				VAL v22 = pop_value();
				switch (get_data_tag(v22)) {
					case 0LL: { // None
						push_value(v15);
						push_value(v14);
					} break;
					default: {
						decref(v14);
						decref(v15);
						int64_t v23 = 0LL /* Nil */;
						push_value(v22);
						push_i64(v23);
					} break;
				}
				VAL v24 = pop_value();
				mw_std_list_List_1_uncons(v24);
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				push_value(v25);
				push_value(v26);
			}
			VAL v27 = pop_value();
			decref(v27);
			VAL v28 = pop_value();
			decref(v28);
			VAL v29 = pop_value();
			int64_t v30 = mw_std_maybe_Maybe_1_noneZAsk(v29);
			push_i64(v30);
		} else {
			int64_t v31 = 0LL /* False */;
			push_i64(v31);
		}
		int64_t v32 = pop_i64();
		mut_set(MKI64(v32), MKPTR(v0));
		push_i64(v32);
	}
	VAL v33 = pop_value();
	VAL v34 = pop_value();
	decref(v34);
	return VI64(v33);
}
static int64_t mw_mirth_data_Data_isZ_transparentZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeisZ_transparentZAsk(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		int64_t v3 = mw_mirth_data_Data_isZ_resourceZAsk(x1);
		if (((bool)v3)) {
			uint64_t v4 = pop_u64();
			push_u64(v4);
			VAL v5 = mw_mirth_data_Data_tags(v4);
			VAL v6 = mw_std_list_List_1_ZDivL1(v5);
			switch (get_data_tag(v6)) {
				case 1LL: { // Some
					VAL v7 = mtp_std_maybe_Maybe_1_Some(v6);
					incref(v7);
					push_value(v7);
					int64_t v8 = mw_mirth_data_Tag_numZ_resourceZ_inputs(VU64(v7));
					int64_t v9 = 1LL;
					push_i64(v8);
					int64_t v10 = mw_std_prim_Int_ZToNat(v9);
					int64_t v11 = pop_i64();
					bool v12 = (v11 == v10);
					uint64_t v13 = pop_u64();
					push_bool(v12);
					int64_t v14 = mw_mirth_data_Tag_numZ_totalZ_inputs(v13);
					int64_t v15 = 1LL;
					push_i64(v14);
					int64_t v16 = mw_std_prim_Int_ZToNat(v15);
					int64_t v17 = pop_i64();
					bool v18 = (v17 == v16);
					bool v19 = pop_bool();
					bool v20 = (v19 && v18);
					push_bool(v20);
				} break;
				case 0LL: { // None
					int64_t v21 = 0LL /* False */;
					push_i64(v21);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} else {
			uint64_t v22 = pop_u64();
			push_u64(v22);
			VAL v23 = mw_mirth_data_Data_tags(v22);
			VAL v24 = mw_std_list_List_1_ZDivL1(v23);
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v24);
					incref(v25);
					push_value(v25);
					int64_t v26 = mw_mirth_data_Tag_numZ_typeZ_inputs(VU64(v25));
					int64_t v27 = 1LL;
					push_i64(v26);
					int64_t v28 = mw_std_prim_Int_ZToNat(v27);
					int64_t v29 = pop_i64();
					bool v30 = (v29 == v28);
					uint64_t v31 = pop_u64();
					push_bool(v30);
					int64_t v32 = mw_mirth_data_Tag_numZ_totalZ_inputs(v31);
					int64_t v33 = 1LL;
					push_i64(v32);
					int64_t v34 = mw_std_prim_Int_ZToNat(v33);
					int64_t v35 = pop_i64();
					bool v36 = (v35 == v34);
					bool v37 = pop_bool();
					bool v38 = (v37 && v36);
					push_bool(v38);
				} break;
				case 0LL: { // None
					int64_t v39 = 0LL /* False */;
					push_i64(v39);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		}
		int64_t v40 = pop_i64();
		mut_set(MKI64(v40), MKPTR(v0));
		push_i64(v40);
	}
	VAL v41 = pop_value();
	VAL v42 = pop_value();
	decref(v42);
	return VI64(v41);
}
static int64_t mw_mirth_data_Data_isZ_semiZ_transparentZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeisZ_semiZ_transparentZAsk(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		VAL v3 = mw_mirth_data_Data_tags(x1);
		VAL v4 = mw_std_list_List_1_ZDivL1(v3);
		switch (get_data_tag(v4)) {
			case 1LL: { // Some
				VAL v5 = mtp_std_maybe_Maybe_1_Some(v4);
				int64_t v6 = mw_mirth_data_Tag_numZ_totalZ_inputs(VU64(v5));
				int64_t v7 = 1LL;
				push_i64(v6);
				int64_t v8 = mw_std_prim_Int_ZToNat(v7);
				int64_t v9 = pop_i64();
				bool v10 = (v9 == v8);
				push_bool(v10);
			} break;
			case 0LL: { // None
				int64_t v11 = 0LL /* False */;
				push_i64(v11);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		int64_t v12 = pop_i64();
		mut_set(MKI64(v12), MKPTR(v0));
		push_i64(v12);
	}
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	decref(v14);
	return VI64(v13);
}
static int64_t mw_mirth_data_Data_isZ_resourceZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Data_ZTildeisZ_resourceZAsk(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		uint64_t v3 = mw_mirth_data_Data_name(x1);
		int64_t v4 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(v3);
		mut_set(MKI64(v4), MKPTR(v0));
		push_i64(v4);
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	decref(v6);
	return VI64(v5);
}
static int64_t mw_mirth_data_Data_isZ_valueZ_typeZAsk (uint64_t x1) {
	int64_t v0 = mw_mirth_data_Data_isZ_resourceZAsk(x1);
	bool v1 = !((bool)v0);
	return ((int64_t)v1);
}
static void mw_mirth_data_Data_fullZ_type (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mtw_mirth_type_Type_TData(x2);
	VAL r1 = pop_resource();
	push_value(v0);
	mw_mirth_data_Data_params(r1, x2);
	VAL v2 = pop_value();
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL v10 = mtw_mirth_type_Type_TVar(VU64(v8));
		VAL v11 = pop_value();
		VAL v12 = mtw_mirth_type_Type_TApp(v11, v10);
		push_value(v12);
		mw_std_list_List_1_uncons(v9);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		push_value(v13);
		push_value(v14);
	}
	VAL v15 = pop_value();
	decref(v15);
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = pop_value();
	uint64_t v18 = pop_u64();
	push_value(v17);
	int64_t v19 = mw_mirth_data_Data_isZ_valueZ_typeZAsk(v18);
	if (((bool)v19)) {
		VAL v20 = pop_value();
		VAL v21 = mtw_std_either_Either_2_Left(v20);
		push_value(v21);
	} else {
		VAL v22 = pop_value();
		VAL v23 = mtw_std_either_Either_2_Right(v22);
		push_value(v23);
	}
}
static int64_t mw_mirth_data_Tag_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_data_Tag_allocZBang (void) {
	void* v0 = mbuf_mirth_data_Tag_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_data_Tag_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_data_Tag_data (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildedata(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_data_Tag_qname (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildeqname(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_data_Tag_name (uint64_t x1) {
	VAL v0 = mw_mirth_data_Tag_qname(x1);
	uint64_t v1 = VU64(VTUP(v0)->cells[2]);
	decref(v0);
	return v1;
}
static int64_t mw_mirth_data_Tag_value (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildevalue(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static VAL mw_mirth_data_Tag_labelZ_inputs (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildelabelZ_inputs(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputs (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputs (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static VAL mw_mirth_data_Tag_sigZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildesigZAsk(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static void mw_mirth_data_Tag_ctxZ_type (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_data_Tag_ZTildectxZ_type(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
	VAL v1 = pop_value();
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	push_value(v5);
	push_value(v3);
}
static void mw_mirth_data_Tag_ctx (VAL x1, uint64_t x2) {
	mw_mirth_data_Tag_ctxZ_type(x1, x2);
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_mirth_data_Tag_type (VAL x1, uint64_t x2) {
	mw_mirth_data_Tag_ctxZ_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static VAL mw_mirth_data_Tag_untag (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildeuntag(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static VAL mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig (uint64_t x1) {
	VAL v0 = mw_mirth_data_Tag_sigZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_token_Token_runZ_tokens(VU64(v1));
			int64_t v3 = 0LL /* Nil */;
			push_value(v2);
			VAL v4 = mw_std_list_List_1_reverse(MKI64(v3));
			VAL v5 = pop_value();
			push_resource(v4);
			mw_std_list_List_1_uncons(v5);
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			push_value(v6);
			push_value(v7);
			while(1) {
				VAL v8 = pop_value();
				incref(v8);
				push_value(v8);
				int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
				if (!((bool)v9)) break;
				VAL v10 = pop_value();
				VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
				VAL v12 = pop_value();
				VAL r13 = pop_resource();
				incref(v11);
				int64_t v14 = mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk(VU64(v11));
				if (((bool)v14)) {
					VAL v15 = mtw_std_maybe_Maybe_1_Some(v11);
					push_value(v15);
				} else {
					decref(v11);
					int64_t v16 = 0LL /* None */;
					push_i64(v16);
				}
				VAL v17 = pop_value();
				switch (get_data_tag(v17)) {
					case 1LL: { // Some
						push_resource(r13);
						VAL v18 = mtp_std_maybe_Maybe_1_Some(v17);
						VAL r19 = pop_resource();
						VAL v20 = mtw_std_list_List_1_Cons(v18, r19);
						push_resource(v20);
					} break;
					case 0LL: { // None
						push_resource(r13);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_resource(r13);
					}
				}
				mw_std_list_List_1_uncons(v12);
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				push_value(v21);
				push_value(v22);
			}
			VAL v23 = pop_value();
			decref(v23);
			VAL v24 = pop_value();
			decref(v24);
			VAL r25 = pop_resource();
			VAL v26 = mw_std_list_List_1_reverse(r25);
			int64_t v27 = 0LL /* Nil */;
			push_value(v26);
			VAL v28 = mw_std_list_List_1_reverse(MKI64(v27));
			VAL v29 = pop_value();
			push_resource(v28);
			mw_std_list_List_1_uncons(v29);
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			push_value(v30);
			push_value(v31);
			while(1) {
				VAL v32 = pop_value();
				incref(v32);
				push_value(v32);
				int64_t v33 = mw_std_maybe_Maybe_1_someZAsk(v32);
				if (!((bool)v33)) break;
				VAL v34 = pop_value();
				VAL v35 = mw_std_maybe_Maybe_1_unwrap(v34);
				VAL v36 = pop_value();
				VAL r37 = pop_resource();
				VAL v38 = mw_mirth_token_Token_nameZAsk(VU64(v35));
				VAL v39 = mw_std_maybe_Maybe_1_unwrap(v38);
				uint64_t v40 = mw_mirth_label_Label_newZBang(VU64(v39));
				VAL v41 = mtw_std_list_List_1_Cons(MKU64(v40), r37);
				push_resource(v41);
				mw_std_list_List_1_uncons(v36);
				VAL v42 = pop_value();
				VAL v43 = pop_value();
				push_value(v42);
				push_value(v43);
			}
			VAL v44 = pop_value();
			decref(v44);
			VAL v45 = pop_value();
			decref(v45);
			VAL r46 = pop_resource();
			VAL v47 = mw_std_list_List_1_reverse(r46);
			push_value(v47);
		} break;
		case 0LL: { // None
			int64_t v48 = 0LL /* Nil */;
			push_i64(v48);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v49 = pop_value();
	return v49;
}
static int64_t mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig (uint64_t x1) {
	push_u64(x1);
	VAL v0 = mw_mirth_data_Tag_sigZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_token_Token_runZ_length(VU64(v1));
			VAL v3 = pop_value();
			incref(v3);
			push_value(v3);
			push_i64(v2);
			int64_t v4 = mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig(VU64(v3));
			int64_t v5 = pop_i64();
			int64_t v6 = i64_sub(v5, v4);
			int64_t v7 = mw_std_prim_Int_ZToNat(v6);
			uint64_t v8 = pop_u64();
			push_i64(v7);
			VAL v9 = mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig(v8);
			int64_t v10 = mw_std_list_List_1_len(v9);
			int64_t v11 = pop_i64();
			int64_t v12 = i64_sub(v11, v10);
			int64_t v13 = mw_std_prim_Int_ZToNat(v12);
			push_i64(v13);
		} break;
		case 0LL: { // None
			uint64_t v14 = pop_u64();
			int64_t v15 = 0LL;
			int64_t v16 = mw_std_prim_Int_ZToNat(v15);
			push_i64(v16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v17 = pop_i64();
	return v17;
}
static int64_t mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig (uint64_t x1) {
	VAL v0 = mw_mirth_data_Tag_sigZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_token_Token_runZ_tokens(VU64(v1));
			int64_t v3 = 0LL /* Nil */;
			push_value(v2);
			VAL v4 = mw_std_list_List_1_reverse(MKI64(v3));
			VAL v5 = pop_value();
			push_resource(v4);
			mw_std_list_List_1_uncons(v5);
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			push_value(v6);
			push_value(v7);
			while(1) {
				VAL v8 = pop_value();
				incref(v8);
				push_value(v8);
				int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
				if (!((bool)v9)) break;
				VAL v10 = pop_value();
				VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
				VAL v12 = pop_value();
				VAL r13 = pop_resource();
				incref(v11);
				int64_t v14 = mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk(VU64(v11));
				bool v15 = !((bool)v14);
				if (v15) {
					VAL v16 = mtw_std_maybe_Maybe_1_Some(v11);
					push_value(v16);
				} else {
					decref(v11);
					int64_t v17 = 0LL /* None */;
					push_i64(v17);
				}
				VAL v18 = pop_value();
				switch (get_data_tag(v18)) {
					case 1LL: { // Some
						push_resource(r13);
						VAL v19 = mtp_std_maybe_Maybe_1_Some(v18);
						VAL r20 = pop_resource();
						VAL v21 = mtw_std_list_List_1_Cons(v19, r20);
						push_resource(v21);
					} break;
					case 0LL: { // None
						push_resource(r13);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_resource(r13);
					}
				}
				mw_std_list_List_1_uncons(v12);
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				push_value(v22);
				push_value(v23);
			}
			VAL v24 = pop_value();
			decref(v24);
			VAL v25 = pop_value();
			decref(v25);
			VAL r26 = pop_resource();
			VAL v27 = mw_std_list_List_1_reverse(r26);
			int64_t v28 = 0LL /* Nil */;
			push_value(v27);
			VAL v29 = mw_std_list_List_1_reverse(MKI64(v28));
			VAL v30 = pop_value();
			push_resource(v29);
			mw_std_list_List_1_uncons(v30);
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			push_value(v31);
			push_value(v32);
			while(1) {
				VAL v33 = pop_value();
				incref(v33);
				push_value(v33);
				int64_t v34 = mw_std_maybe_Maybe_1_someZAsk(v33);
				if (!((bool)v34)) break;
				VAL v35 = pop_value();
				VAL v36 = mw_std_maybe_Maybe_1_unwrap(v35);
				VAL v37 = pop_value();
				VAL r38 = pop_resource();
				VAL v39 = mw_mirth_token_Token_nameZAsk(VU64(v36));
				switch (get_data_tag(v39)) {
					case 1LL: { // Some
						push_resource(r38);
						VAL v40 = mtp_std_maybe_Maybe_1_Some(v39);
						VAL r41 = pop_resource();
						VAL v42 = mtw_std_list_List_1_Cons(v40, r41);
						push_resource(v42);
					} break;
					case 0LL: { // None
						push_resource(r38);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_resource(r38);
					}
				}
				mw_std_list_List_1_uncons(v37);
				VAL v43 = pop_value();
				VAL v44 = pop_value();
				push_value(v43);
				push_value(v44);
			}
			VAL v45 = pop_value();
			decref(v45);
			VAL v46 = pop_value();
			decref(v46);
			VAL r47 = pop_resource();
			VAL v48 = mw_std_list_List_1_reverse(r47);
			int64_t v49 = 0LL /* Nil */;
			push_value(v48);
			VAL v50 = mw_std_list_List_1_reverse(MKI64(v49));
			VAL v51 = pop_value();
			push_resource(v50);
			mw_std_list_List_1_uncons(v51);
			VAL v52 = pop_value();
			VAL v53 = pop_value();
			push_value(v52);
			push_value(v53);
			while(1) {
				VAL v54 = pop_value();
				incref(v54);
				push_value(v54);
				int64_t v55 = mw_std_maybe_Maybe_1_someZAsk(v54);
				if (!((bool)v55)) break;
				VAL v56 = pop_value();
				VAL v57 = mw_std_maybe_Maybe_1_unwrap(v56);
				VAL v58 = pop_value();
				VAL r59 = pop_resource();
				incref(v57);
				incref(v57);
				int64_t v60 = mw_mirth_name_Name_couldZ_beZ_resourceZ_var(VU64(v57));
				if (((bool)v60)) {
					decref(v57);
					int64_t v61 = 1LL /* True */;
					push_i64(v61);
				} else {
					int64_t v62 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(VU64(v57));
					push_i64(v62);
				}
				int64_t v63 = pop_i64();
				if (((bool)v63)) {
					VAL v64 = mtw_std_maybe_Maybe_1_Some(v57);
					push_value(v64);
				} else {
					decref(v57);
					int64_t v65 = 0LL /* None */;
					push_i64(v65);
				}
				VAL v66 = pop_value();
				switch (get_data_tag(v66)) {
					case 1LL: { // Some
						push_resource(r59);
						VAL v67 = mtp_std_maybe_Maybe_1_Some(v66);
						VAL r68 = pop_resource();
						VAL v69 = mtw_std_list_List_1_Cons(v67, r68);
						push_resource(v69);
					} break;
					case 0LL: { // None
						push_resource(r59);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_resource(r59);
					}
				}
				mw_std_list_List_1_uncons(v58);
				VAL v70 = pop_value();
				VAL v71 = pop_value();
				push_value(v70);
				push_value(v71);
			}
			VAL v72 = pop_value();
			decref(v72);
			VAL v73 = pop_value();
			decref(v73);
			VAL r74 = pop_resource();
			VAL v75 = mw_std_list_List_1_reverse(r74);
			int64_t v76 = mw_std_list_List_1_len(v75);
			push_i64(v76);
		} break;
		case 0LL: { // None
			int64_t v77 = 0LL;
			int64_t v78 = mw_std_prim_Int_ZToNat(v77);
			push_i64(v78);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v79 = pop_i64();
	return v79;
}
static int64_t mw_mirth_data_Tag_numZ_labelZ_inputs (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		VAL v3 = mw_mirth_data_Tag_labelZ_inputs(x1);
		int64_t v4 = mw_std_list_List_1_len(v3);
		mut_set(MKI64(v4), MKPTR(v0));
		push_i64(v4);
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	decref(v6);
	return VI64(v5);
}
static int64_t mw_mirth_data_Tag_numZ_totalZ_inputs (uint64_t x1) {
	lpush(&lbl_tag, MKU64(x1));
	int64_t v0 = mw_mirth_data_Tag_numZ_labelZ_inputs(x1);
	uint64_t v1 = VU64(lpop(&lbl_tag));
	push_i64(v0);
	lpush(&lbl_tag, MKU64(v1));
	int64_t v2 = mw_mirth_data_Tag_numZ_typeZ_inputs(v1);
	int64_t v3 = pop_i64();
	int64_t v4 = i64_add(v3, v2);
	uint64_t v5 = VU64(lpop(&lbl_tag));
	push_i64(v4);
	int64_t v6 = mw_mirth_data_Tag_numZ_resourceZ_inputs(v5);
	int64_t v7 = pop_i64();
	int64_t v8 = i64_add(v7, v6);
	return v8;
}
static int64_t mw_mirth_data_Tag_isZ_transparentZAsk (uint64_t x1) {
	uint64_t v0 = mw_mirth_data_Tag_data(x1);
	int64_t v1 = mw_mirth_data_Data_isZ_transparentZAsk(v0);
	return v1;
}
static int64_t mw_mirth_data_Tag_isZ_semiZ_transparentZAsk (uint64_t x1) {
	uint64_t v0 = mw_mirth_data_Tag_data(x1);
	int64_t v1 = mw_mirth_data_Data_isZ_semiZ_transparentZAsk(v0);
	return v1;
}
static int64_t mw_mirth_data_Tag_outputsZ_resourceZAsk (uint64_t x1) {
	uint64_t v0 = mw_mirth_data_Tag_data(x1);
	int64_t v1 = mw_mirth_data_Data_isZ_resourceZAsk(v0);
	return v1;
}
static int64_t mw_mirth_data_Tag_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_data_Tag_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_data_Tag_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static int64_t mw_mirth_data_Tag_preferZ_inlineZAsk (uint64_t x1) {
	push_u64(x1);
	uint64_t v0 = mw_mirth_data_Tag_data(x1);
	int64_t v1 = mw_mirth_data_Data_isZ_semiZ_transparentZAsk(v0);
	if (((bool)v1)) {
		int64_t v2 = 1LL /* True */;
		push_i64(v2);
	} else {
		uint64_t v3 = pop_u64();
		push_u64(v3);
		int64_t v4 = mw_mirth_data_Tag_numZ_totalZ_inputs(v3);
		int64_t v5 = 0LL;
		bool v6 = (v4 == v5);
		push_bool(v6);
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	return VI64(v7);
}
static int64_t mw_mirth_data_DataPartial_ZEqualZEqual (VAL x1, VAL x2) {
	push_value(x1);
	mtp_mirth_data_DataPartial_DataPartial(x2);
	VAL v0 = pop_value();
	mtp_mirth_data_DataPartial_DataPartial(v0);
	uint64_t v1 = VU64(lpop(&lbl_data));
	uint64_t v2 = VU64(lpop(&lbl_data));
	int64_t v3 = mw_mirth_data_Data_ZEqualZEqual(v1, v2);
	uint64_t v4 = VU64(lpop(&lbl_field));
	uint64_t v5 = VU64(lpop(&lbl_field));
	push_i64(v3);
	int64_t v6 = mw_mirth_label_Label_ZEqualZEqual(v4, v5);
	bool v7 = pop_bool();
	bool v8 = (v7 && ((bool)v6));
	return ((int64_t)v8);
}
static VAL mw_mirth_match_Match_thaw (VAL x1) {
	mtp_mirth_match_Match_Match(x1);
	VAL v0 = lpop(&lbl_cases);
	VAL v1 = lpop(&lbl_cod);
	VAL v2 = lpop(&lbl_dom);
	VAL v3 = lpop(&lbl_ctx);
	uint64_t v4 = VU64(lpop(&lbl_body));
	uint64_t v5 = VU64(lpop(&lbl_token));
	VAL v6 = lpop(&lbl_home);
	VAL v7 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v6, v5, v4, v3, v2, v1, v0));
	return v7;
}
static VAL mw_mirth_match_ZPlusMatch_freezze (VAL x1) {
	mtp_mirth_match_ZPlusMatch_ZPlusMatch(x1);
	VAL v0 = lpop(&lbl_cases);
	VAL v1 = lpop(&lbl_cod);
	VAL v2 = lpop(&lbl_dom);
	VAL v3 = lpop(&lbl_ctx);
	uint64_t v4 = VU64(lpop(&lbl_body));
	uint64_t v5 = VU64(lpop(&lbl_token));
	VAL v6 = lpop(&lbl_home);
	VAL v7 = mtw_mirth_match_Match_Match(v6, v5, v4, v3, v2, v1, v0);
	return v7;
}
static int64_t mw_mirth_match_Match_isZ_exhaustiveZAsk (VAL x1) {
	incref(x1);
	push_value(x1);
	int64_t v0 = mw_mirth_match_Match_hasZ_defaultZ_caseZAsk(x1);
	if (((bool)v0)) {
		int64_t v1 = 1LL /* True */;
		push_i64(v1);
	} else {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		VAL v3 = mw_mirth_match_Match_scrutineeZ_dataZAsk(v2);
		switch (get_data_tag(v3)) {
			case 1LL: { // Some
				VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
				int64_t v5 = mw_mirth_data_Data_numZ_tags(VU64(v4));
				VAL v6 = pop_value();
				incref(v6);
				VAL v7 = VVAL(VTUP(v6)->cells[7]);
				incref(v7);
				decref(v6);
				push_value(v6);
				push_i64(v5);
				int64_t v8 = mw_std_list_List_1_len(v7);
				int64_t v9 = pop_i64();
				bool v10 = (v9 == v8);
				push_bool(v10);
			} break;
			case 0LL: { // None
				VAL v11 = pop_value();
				incref(v11);
				VAL v12 = VVAL(VTUP(v11)->cells[7]);
				incref(v12);
				decref(v11);
				push_value(v11);
				int64_t v13 = mw_std_list_List_1_len(v12);
				int64_t v14 = 0LL;
				bool v15 = (v13 > v14);
				push_bool(v15);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
	VAL v16 = pop_value();
	VAL v17 = pop_value();
	decref(v17);
	return VI64(v16);
}
static int64_t mw_mirth_match_Match_hasZ_defaultZ_caseZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	int64_t v1 = 0LL /* None */;
	push_i64(v1);
	mw_std_list_List_1_uncons(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		int64_t v10 = mw_mirth_match_Case_isZ_defaultZ_caseZAsk(v7);
		if (((bool)v10)) {
			VAL v11 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v11);
		} else {
			decref(v7);
			int64_t v12 = 0LL /* None */;
			push_i64(v12);
		}
		VAL v13 = pop_value();
		switch (get_data_tag(v13)) {
			case 0LL: { // None
				push_value(v9);
				push_value(v8);
			} break;
			default: {
				decref(v8);
				decref(v9);
				int64_t v14 = 0LL /* Nil */;
				push_value(v13);
				push_i64(v14);
			} break;
		}
		VAL v15 = pop_value();
		mw_std_list_List_1_uncons(v15);
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
	}
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = pop_value();
	decref(v19);
	VAL v20 = pop_value();
	int64_t v21 = mw_std_maybe_Maybe_1_someZAsk(v20);
	return v21;
}
static VAL mw_mirth_match_Match_scrutineeZ_dataZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	int64_t v1 = 0LL /* Nil */;
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	push_resource(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		incref(v9);
		int64_t v12 = mw_mirth_match_Case_isZ_defaultZ_caseZAsk(v9);
		bool v13 = !((bool)v12);
		if (v13) {
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v9);
			push_value(v14);
		} else {
			decref(v9);
			int64_t v15 = 0LL /* None */;
			push_i64(v15);
		}
		VAL v16 = pop_value();
		switch (get_data_tag(v16)) {
			case 1LL: { // Some
				push_resource(r11);
				VAL v17 = mtp_std_maybe_Maybe_1_Some(v16);
				VAL r18 = pop_resource();
				VAL v19 = mtw_std_list_List_1_Cons(v17, r18);
				push_resource(v19);
			} break;
			case 0LL: { // None
				push_resource(r11);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r11);
			}
		}
		mw_std_list_List_1_uncons(v10);
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
	}
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	VAL r24 = pop_resource();
	VAL v25 = mw_std_list_List_1_reverse(r24);
	incref(v25);
	push_value(v25);
	VAL v26 = mw_std_list_List_1_first(v25);
	switch (get_data_tag(v26)) {
		case 1LL: { // Some
			VAL v27 = mtp_std_maybe_Maybe_1_Some(v26);
			VAL v28 = VVAL(VTUP(v27)->cells[1]);
			incref(v28);
			decref(v27);
			VAL v29 = mw_mirth_match_Pattern_singleZ_tagZAsk(v28);
			push_value(v29);
		} break;
		case 0LL: { // None
			int64_t v30 = 0LL /* None */;
			push_i64(v30);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v31 = pop_value();
	switch (get_data_tag(v31)) {
		case 1LL: { // Some
			VAL v32 = mtp_std_maybe_Maybe_1_Some(v31);
			uint64_t v33 = mw_mirth_data_Tag_data(VU64(v32));
			VAL v34 = mtw_std_maybe_Maybe_1_Some(MKU64(v33));
			push_value(v34);
		} break;
		case 0LL: { // None
			int64_t v35 = 0LL /* None */;
			push_i64(v35);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v36 = pop_value();
	switch (get_data_tag(v36)) {
		case 1LL: { // Some
			VAL v37 = mtp_std_maybe_Maybe_1_Some(v36);
			VAL v38 = pop_value();
			int64_t v39 = 0LL /* None */;
			push_value(v37);
			push_i64(v39);
			mw_std_list_List_1_uncons(v38);
			VAL v40 = pop_value();
			VAL v41 = pop_value();
			push_value(v40);
			push_value(v41);
			while(1) {
				VAL v42 = pop_value();
				incref(v42);
				push_value(v42);
				int64_t v43 = mw_std_maybe_Maybe_1_someZAsk(v42);
				if (!((bool)v43)) break;
				VAL v44 = pop_value();
				VAL v45 = mw_std_maybe_Maybe_1_unwrap(v44);
				VAL v46 = pop_value();
				VAL v47 = pop_value();
				incref(v45);
				VAL v48 = VVAL(VTUP(v45)->cells[1]);
				incref(v48);
				decref(v45);
				VAL v49 = mw_mirth_match_Pattern_singleZ_tagZAsk(v48);
				switch (get_data_tag(v49)) {
					case 1LL: { // Some
						VAL v50 = mtp_std_maybe_Maybe_1_Some(v49);
						uint64_t v51 = pop_u64();
						push_u64(v51);
						push_u64(v51);
						uint64_t v52 = mw_mirth_data_Tag_data(VU64(v50));
						uint64_t v53 = pop_u64();
						int64_t v54 = mw_mirth_data_Data_ZEqualZEqual(v53, v52);
						push_i64(v54);
					} break;
					case 0LL: { // None
						int64_t v55 = 0LL /* False */;
						push_i64(v55);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
				bool v56 = pop_bool();
				bool v57 = !v56;
				if (v57) {
					VAL v58 = mtw_std_maybe_Maybe_1_Some(v45);
					push_value(v58);
				} else {
					decref(v45);
					int64_t v59 = 0LL /* None */;
					push_i64(v59);
				}
				VAL v60 = pop_value();
				switch (get_data_tag(v60)) {
					case 0LL: { // None
						push_value(v47);
						push_value(v46);
					} break;
					default: {
						decref(v46);
						decref(v47);
						int64_t v61 = 0LL /* Nil */;
						push_value(v60);
						push_i64(v61);
					} break;
				}
				VAL v62 = pop_value();
				mw_std_list_List_1_uncons(v62);
				VAL v63 = pop_value();
				VAL v64 = pop_value();
				push_value(v63);
				push_value(v64);
			}
			VAL v65 = pop_value();
			decref(v65);
			VAL v66 = pop_value();
			decref(v66);
			VAL v67 = pop_value();
			int64_t v68 = mw_std_maybe_Maybe_1_noneZAsk(v67);
			if (((bool)v68)) {
				VAL v69 = pop_value();
				VAL v70 = mtw_std_maybe_Maybe_1_Some(v69);
				push_value(v70);
			} else {
				uint64_t v71 = pop_u64();
				int64_t v72 = 0LL /* None */;
				push_i64(v72);
			}
		} break;
		case 0LL: { // None
			VAL v73 = pop_value();
			decref(v73);
			int64_t v74 = 0LL /* None */;
			push_i64(v74);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v75 = pop_value();
	return v75;
}
static void mw_mirth_match_ZPlusMatch_addZ_case (VAL x1, VAL x2, VAL x3) {
	incref(x3);
	push_resource(x1);
	push_value(x3);
	mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk(x3, x2);
	bool v0 = pop_bool();
	if (v0) {
		VAL v1 = pop_value();
		VAL v2 = VVAL(VTUP(v1)->cells[1]);
		incref(v2);
		decref(v1);
		uint64_t v3 = VU64(VTUP(v2)->cells[2]);
		decref(v2);
		STR* v4;
		STRLIT(v4, "Case is unreachable.", 20);
		VAL r5 = pop_resource();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v3, MKSTR(v4), r6));
		push_resource(v7);
		push_resource(r5);
	} else {
		VAL r8 = pop_resource();
		VAL v9 = VVAL(VTUP(r8)->cells[7]);
		incref(v9);
		VAL v10 = pop_value();
		int64_t v11 = 0LL /* Nil */;
		push_value(v9);
		VAL v12 = mtw_std_list_List_1_Cons(v10, MKI64(v11));
		VAL v13 = pop_value();
		VAL v14 = mw_std_list_List_1_cat(v13, v12);
		VAL v15 = VTUP(r8)->cells[7];
		decref(v15);
		VTUP(r8)->cells[7] = v14;
		push_resource(r8);
	}
}
static void mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[7]);
	incref(v0);
	int64_t v1 = 0LL /* None */;
	push_value(x1);
	push_resource(x2);
	push_i64(v1);
	mw_std_list_List_1_uncons(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = pop_value();
		incref(v10);
		int64_t v11 = mw_mirth_match_Case_coversZAsk(v10, v7);
		if (((bool)v11)) {
			push_value(v10);
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v12);
		} else {
			decref(v7);
			int64_t v13 = 0LL /* None */;
			push_value(v10);
			push_i64(v13);
		}
		VAL v14 = pop_value();
		switch (get_data_tag(v14)) {
			case 0LL: { // None
				push_value(v9);
				push_value(v8);
			} break;
			default: {
				decref(v8);
				decref(v9);
				int64_t v15 = 0LL /* Nil */;
				push_value(v14);
				push_i64(v15);
			} break;
		}
		VAL v16 = pop_value();
		mw_std_list_List_1_uncons(v16);
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		push_value(v17);
		push_value(v18);
	}
	VAL v19 = pop_value();
	decref(v19);
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	VAL v22 = pop_value();
	decref(v22);
	int64_t v23 = mw_std_maybe_Maybe_1_someZAsk(v21);
	push_i64(v23);
}
static int64_t mw_mirth_match_Case_coversZAsk (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(x2)->cells[1]);
	incref(v1);
	decref(x2);
	int64_t v2 = mw_mirth_match_Pattern_coversZAsk(v0, v1);
	return v2;
}
static int64_t mw_mirth_match_Case_isZ_defaultZ_caseZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	int64_t v1 = mw_mirth_match_Pattern_isZ_defaultZAsk(v0);
	return v1;
}
static VAL mw_mirth_match_Pattern_dom (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(x1)->cells[6]);
	incref(v1);
	decref(x1);
	push_value(v0);
	mw_std_list_List_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		VAL v10 = mtw_mirth_type_StackType_STCons(v9, v7);
		push_value(v10);
		mw_std_list_List_1_uncons(v8);
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	VAL v15 = pop_value();
	return v15;
}
static VAL mw_mirth_match_Pattern_thaw (VAL x1) {
	return x1;
}
static VAL mw_mirth_match_Pattern_singleZ_tagZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[9]);
	incref(v0);
	decref(x1);
	VAL v1 = mw_std_list_List_1_ZDivL1(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = VVAL(VTUP(v2)->cells[7]);
			incref(v3);
			decref(v2);
			VAL v4 = mw_mirth_match_PatternOp_ZDivPatOpTag(v3);
			push_value(v4);
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v6 = pop_value();
	return v6;
}
static int64_t mw_mirth_match_Pattern_isZ_defaultZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[9]);
	incref(v0);
	decref(x1);
	int64_t v1 = 0LL /* None */;
	push_i64(v1);
	mw_std_list_List_1_uncons(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = VVAL(VTUP(v7)->cells[7]);
		incref(v10);
		decref(v7);
		int64_t v11 = mw_mirth_match_PatternOp_ZDivPatOpUnderscore(v10);
		bool v12 = !((bool)v11);
		if (v12) {
			VAL v13 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v13);
		} else {
			decref(v7);
			int64_t v14 = 0LL /* None */;
			push_i64(v14);
		}
		VAL v15 = pop_value();
		switch (get_data_tag(v15)) {
			case 0LL: { // None
				push_value(v9);
				push_value(v8);
			} break;
			default: {
				decref(v8);
				decref(v9);
				int64_t v16 = 0LL /* Nil */;
				push_value(v15);
				push_i64(v16);
			} break;
		}
		VAL v17 = pop_value();
		mw_std_list_List_1_uncons(v17);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	int64_t v23 = mw_std_maybe_Maybe_1_noneZAsk(v22);
	return v23;
}
static VAL mw_mirth_match_ZPlusPattern_freezze (VAL x1) {
	return x1;
}
static void mw_mirth_match_ZPlusPattern_opZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x1)) {
		case 0LL: { // PatOpUnderscore
			mw_mirth_match_ZPlusPattern_underscoreZBang(x2, x3);
		} break;
		case 1LL: { // PatOpTag
			push_resource(x2);
			push_resource(x3);
			uint64_t v0 = mtp_mirth_match_PatternOp_PatOpTag(x1);
			VAL r1 = pop_resource();
			VAL r2 = pop_resource();
			mw_mirth_match_ZPlusPattern_tagZBang(r2, r1, v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_resource(x3);
		}
	}
}
static void mw_mirth_match_ZPlusPattern_underscoreZBang (VAL x1, VAL x2) {
	incref(x2);
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	incref(x2);
	VAL v1 = VVAL(VTUP(x2)->cells[5]);
	incref(v1);
	decref(x2);
	incref(x2);
	VAL v2 = VVAL(VTUP(x2)->cells[7]);
	incref(v2);
	decref(x2);
	int64_t v3 = 0LL /* SUBST_NIL */;
	int64_t v4 = 0LL /* PatOpUnderscore */;
	incref(x2);
	VAL v5 = VVAL(VTUP(x2)->cells[7]);
	incref(v5);
	decref(x2);
	push_resource(x1);
	lpush(&lbl_token, MKU64(v0));
	lpush(&lbl_ctx, v1);
	lpush(&lbl_cod, v2);
	lpush(&lbl_subst, MKI64(v3));
	lpush(&lbl_op, MKI64(v4));
	push_resource(x2);
	VAL v6 = mw_mirth_type_StackType_forceZ_consZAskZBang(v5);
	switch (get_data_tag(v6)) {
		case 0LL: { // None
			VAL r7 = pop_resource();
			incref(r7);
			uint64_t v8 = VU64(VTUP(r7)->cells[2]);
			decref(r7);
			STR* v9;
			STRLIT(v9, "pattern expects something on stack", 34);
			VAL r10 = pop_resource();
			VAL v11 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v8, MKSTR(v9), r10));
			int64_t v12 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v13 = 0LL /* TYPE_ERROR */;
			push_resource(v11);
			push_resource(r7);
			push_i64(v12);
			push_i64(v13);
		} break;
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v6);
			VAL v15;
			VAL v16;
			value_uncons(v14, &v15, &v16);
			VAL v17;
			VAL v18;
			value_uncons(v15, &v17, &v18);
			decref(v17);
			push_value(v18);
			push_value(v16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v19 = pop_value();
	incref(v19);
	VAL r20 = pop_resource();
	incref(r20);
	incref(r20);
	VAL v21 = VVAL(VTUP(r20)->cells[6]);
	incref(v21);
	decref(r20);
	push_value(v19);
	VAL v22 = mtw_std_list_List_1_Cons(v19, v21);
	VAL v23 = tup_replace(r20, 6, v22);
	decref(r20);
	int64_t v24 = 0LL /* Nil */;
	VAL v25 = pop_value();
	push_resource(v23);
	VAL v26 = mtw_std_list_List_1_Cons(v25, MKI64(v24));
	VAL v27 = pop_value();
	incref(v27);
	VAL r28 = pop_resource();
	incref(r28);
	VAL v29 = tup_replace(r28, 7, v27);
	decref(r28);
	VAL v30 = lpop(&lbl_op);
	VAL v31 = lpop(&lbl_subst);
	VAL v32 = lpop(&lbl_cod);
	VAL v33 = lpop(&lbl_ctx);
	uint64_t v34 = VU64(lpop(&lbl_token));
	push_resource(v29);
	VAL v35 = mtw_mirth_match_PatternAtom_PATATOM(v34, v33, v26, v27, v32, v31, v30);
	VAL r36 = pop_resource();
	incref(r36);
	incref(r36);
	VAL v37 = VVAL(VTUP(r36)->cells[9]);
	incref(v37);
	decref(r36);
	VAL v38 = mtw_std_list_List_1_Cons(v35, v37);
	VAL v39 = tup_replace(r36, 9, v38);
	decref(r36);
	push_resource(v39);
}
static void mw_mirth_match_ZPlusPattern_tagZBang (VAL x1, VAL x2, uint64_t x3) {
	push_resource(x1);
	push_resource(x2);
	push_u64(x3);
	VAL v0 = mtw_mirth_match_PatternOp_PatOpTag(x3);
	int64_t v1 = 0LL /* Nil */;
	VAL r2 = pop_resource();
	incref(r2);
	uint64_t v3 = VU64(VTUP(r2)->cells[2]);
	decref(r2);
	incref(r2);
	VAL v4 = VVAL(VTUP(r2)->cells[5]);
	incref(v4);
	decref(r2);
	uint64_t v5 = pop_u64();
	int64_t v6 = 0LL /* SUBST_NIL */;
	VAL r7 = pop_resource();
	lpush(&lbl_op, v0);
	lpush(&lbl_saved, MKI64(v1));
	lpush(&lbl_token, MKU64(v3));
	lpush(&lbl_ctx, v4);
	push_i64(v6);
	mw_mirth_data_Tag_type(r7, v5);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_resource(r2);
	mw_mirth_type_ArrowType_freshenZ_sig(v9, v8);
	VAL v10 = pop_value();
	mw_mirth_type_ArrowType_unpack(v10);
	VAL v11 = pop_value();
	VAL r12 = pop_resource();
	incref(r12);
	VAL v13 = VVAL(VTUP(r12)->cells[7]);
	incref(v13);
	decref(r12);
	incref(r12);
	uint64_t v14 = VU64(VTUP(r12)->cells[2]);
	decref(r12);
	VAL r15 = pop_resource();
	mw_mirth_type_StackType_unifyZBang(r15, v14, v13, v11);
	uint64_t r16 = VU64(pop_resource());
	push_resource(r12);
	mw_mirth_type_ZPlusGamma_rdrop(r16);
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	incref(v18);
	VAL r19 = pop_resource();
	incref(r19);
	VAL v20 = tup_replace(r19, 7, v18);
	decref(r19);
	VAL v21 = pop_value();
	VAL v22 = lpop(&lbl_op);
	VAL v23 = lpop(&lbl_saved);
	VAL v24 = lpop(&lbl_ctx);
	uint64_t v25 = VU64(lpop(&lbl_token));
	push_resource(v20);
	VAL v26 = mtw_mirth_match_PatternAtom_PATATOM(v25, v24, v23, v18, v17, v21, v22);
	VAL r27 = pop_resource();
	incref(r27);
	incref(r27);
	VAL v28 = VVAL(VTUP(r27)->cells[9]);
	incref(v28);
	decref(r27);
	VAL v29 = mtw_std_list_List_1_Cons(v26, v28);
	VAL v30 = tup_replace(r27, 9, v29);
	decref(r27);
	push_resource(v30);
}
static int64_t mw_mirth_match_Pattern_coversZAsk (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x1)->cells[9]);
	incref(v0);
	decref(x1);
	VAL v1 = mw_std_list_List_1_ZDivL1(v0);
	VAL v2 = VVAL(VTUP(x2)->cells[9]);
	incref(v2);
	decref(x2);
	push_value(v1);
	VAL v3 = mw_std_list_List_1_ZDivL1(v2);
	VAL v4 = pop_value();
	VAL v5 = mw_std_maybe_Maybe_1_zzip(v4, v3);
	switch (get_data_tag(v5)) {
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			push_i64(v6);
		} break;
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v5);
			VAL v8;
			VAL v9;
			value_uncons(v7, &v8, &v9);
			VAL v10;
			VAL v11;
			value_uncons(v8, &v10, &v11);
			decref(v10);
			VAL v12 = VVAL(VTUP(v9)->cells[7]);
			incref(v12);
			decref(v9);
			switch (get_data_tag(v12)) {
				case 0LL: { // PatOpUnderscore
					decref(v11);
					int64_t v13 = 1LL /* True */;
					push_i64(v13);
				} break;
				case 1LL: { // PatOpTag
					push_value(v11);
					uint64_t v14 = mtp_mirth_match_PatternOp_PatOpTag(v12);
					VAL v15 = pop_value();
					VAL v16 = VVAL(VTUP(v15)->cells[7]);
					incref(v16);
					decref(v15);
					switch (get_data_tag(v16)) {
						case 0LL: { // PatOpUnderscore
							int64_t v17 = 0LL /* False */;
							push_i64(v17);
						} break;
						case 1LL: { // PatOpTag
							push_u64(v14);
							uint64_t v18 = mtp_mirth_match_PatternOp_PatOpTag(v16);
							uint64_t v19 = pop_u64();
							int64_t v20 = mw_mirth_data_Tag_ZEqualZEqual(v19, v18);
							push_i64(v20);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_u64(v14);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v11);
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v21 = pop_i64();
	return v21;
}
static VAL mw_mirth_match_PatternOp_ZDivPatOpTag (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // PatOpTag
			uint64_t v0 = mtp_mirth_match_PatternOp_PatOpTag(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_match_PatternOp_ZDivPatOpUnderscore (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // PatOpUnderscore
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static int64_t mw_mirth_external_External_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_external_External_allocZBang (void) {
	void* v0 = mbuf_mirth_external_External_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_external_External_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_external_External_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_external_External_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_external_External_qnameZ_hard (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_external_External_ZTildeqname(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static uint64_t mw_mirth_external_External_name (uint64_t x1) {
	void* v0 = mfld_mirth_external_External_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static int64_t mw_mirth_external_External_arity (uint64_t x1) {
	void* v0 = mfld_mirth_external_External_ZTildearity(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static VAL mw_mirth_external_External_symbol (uint64_t x1) {
	void* v0 = mfld_mirth_external_External_ZTildesymbol(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_external_External_head (uint64_t x1) {
	void* v0 = mfld_mirth_external_External_ZTildehead(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static uint64_t mw_mirth_external_External_sig (uint64_t x1) {
	void* v0 = mfld_mirth_external_External_ZTildesig(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static void mw_mirth_external_External_ctxZ_type (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_external_External_ZTildectxZ_type(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
	VAL v1 = pop_value();
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	push_value(v5);
	push_value(v3);
}
static void mw_mirth_external_External_type (VAL x1, uint64_t x2) {
	mw_mirth_external_External_ctxZ_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static void mw_mirth_external_External_ctype (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_external_External_ZTildectype(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static int64_t mw_mirth_external_External_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_external_External_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_external_External_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static uint64_t mw_mirth_external_ExternalBlock_allocZBang (void) {
	void* v0 = mbuf_mirth_external_ExternalBlock_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_external_ExternalBlock_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_external_ExternalBlock_parts (uint64_t x1) {
	void* v0 = mfld_mirth_external_ExternalBlock_ZTildeparts(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_variable_Variable_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_variable_Variable_allocZBang (void) {
	void* v0 = mbuf_mirth_variable_Variable_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_variable_Variable_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_variable_Variable_qname (uint64_t x1) {
	void* v0 = mfld_mirth_variable_Variable_ZTildeqname(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_variable_Variable_name (uint64_t x1) {
	VAL v0 = mw_mirth_variable_Variable_qname(x1);
	uint64_t v1 = VU64(VTUP(v0)->cells[2]);
	decref(v0);
	return v1;
}
static void mw_mirth_variable_Variable_type (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_variable_Variable_ZTildetype(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static int64_t mw_mirth_variable_Variable_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_variable_Variable_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_variable_Variable_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_variable_Variable_newZBang (VAL x1, uint64_t x2, VAL x3) {
	push_resource(x1);
	push_u64(x2);
	push_value(x3);
	uint64_t v0 = mw_mirth_variable_Variable_allocZBang();
	VAL v1 = pop_value();
	void* v2 = mfld_mirth_variable_Variable_ZTildeqname(v0);
	mut_set(v1, MKPTR(v2));
	VAL v3 = pop_value();
	void* v4 = mfld_mirth_variable_Variable_ZTildehead(v0);
	mut_set(v3, MKPTR(v4));
	push_u64(v0);
	VAL v5 = mtw_mirth_def_Def_DefVariable(v0);
	VAL r6 = pop_resource();
	VAL v7 = (mw_mirth_def_Def_register(r6, v5));
	push_resource(v7);
}
static int64_t mw_mirth_arrow_Block_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_arrow_Block_allocZBang (void) {
	void* v0 = mbuf_mirth_arrow_Block_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_arrow_Block_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static void mw_mirth_arrow_Arrow_ctxZ_type (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	decref(x1);
	push_value(v0);
	VAL v1 = mw_mirth_arrow_Arrow_type(x1);
	push_value(v1);
}
static VAL mw_mirth_arrow_Arrow_type (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(x1)->cells[6]);
	incref(v1);
	decref(x1);
	VAL v2 = mw_mirth_type_TZ_ZTo(v0, v1);
	return v2;
}
static VAL mw_mirth_arrow_Lambda_cod (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(v0)->cells[6]);
	incref(v1);
	decref(v0);
	return v1;
}
static VAL mw_mirth_arrow_Block_ctx (uint64_t x1) {
	void* v0 = mfld_mirth_arrow_Block_ZTildectx(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_arrow_Block_token (uint64_t x1) {
	void* v0 = mfld_mirth_arrow_Block_ZTildetoken(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_arrow_Block_dom (uint64_t x1) {
	void* v0 = mfld_mirth_arrow_Block_ZTildedom(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static VAL mw_mirth_arrow_Block_cod (uint64_t x1) {
	void* v0 = mfld_mirth_arrow_Block_ZTildecod(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static VAL mw_mirth_arrow_Block_home (uint64_t x1) {
	void* v0 = mfld_mirth_arrow_Block_ZTildehome(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static VAL mw_mirth_arrow_Block_type (uint64_t x1) {
	VAL v0 = mw_mirth_arrow_Block_dom(x1);
	push_value(v0);
	VAL v1 = mw_mirth_arrow_Block_cod(x1);
	VAL v2 = pop_value();
	VAL v3 = mw_mirth_type_TZ_ZTo(v2, v1);
	return v3;
}
static void mw_mirth_arrow_Block_arrow (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_arrow_Block_ZTildearrow(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static void mw_mirth_arrow_Block_qname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_arrow_Block_ZTildeqname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		push_resource(x1);
		push_u64(x2);
		push_u64(x2);
		VAL v3 = mw_mirth_arrow_Block_home(x2);
		switch (get_data_tag(v3)) {
			case 0LL: { // HomeMain
				uint64_t v4 = mtp_mirth_arrow_Home_HomeMain(v3);
				uint64_t v5 = mw_mirth_token_Token_module(v4);
				VAL v6 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v5);
				uint64_t v7 = pop_u64();
				VAL r8 = pop_resource();
				push_value(v6);
				mw_mirth_arrow_Block_arrow(r8, v7);
				VAL v9 = pop_value();
				uint64_t v10 = VU64(VTUP(v9)->cells[2]);
				decref(v9);
				int64_t v11 = mw_mirth_token_Token_index(v10);
				STR* v12 = i64_show(v11);
				STR* v13;
				STRLIT(v13, "entry@", 6);
				STR* v14 = str_cat(v13, v12);
				uint64_t v15 = mw_std_prim_Str_ZToName(MKSTR(v14));
				VAL v16 = pop_value();
				VAL v17 = mw_mirth_name_QNAME0(v16, v15);
				push_value(v17);
			} break;
			case 1LL: { // HomeWord
				uint64_t v18 = mtp_mirth_arrow_Home_HomeWord(v3);
				push_u64(v18);
				VAL v19 = mtw_mirth_name_Namespace_NAMESPACEz_WORD(v18);
				uint64_t v20 = pop_u64();
				uint64_t v21 = pop_u64();
				VAL r22 = pop_resource();
				mw_mirth_arrow_Block_arrow(r22, v21);
				VAL r23 = pop_resource();
				mw_mirth_word_Word_arrow(v20, r23);
				VAL v24 = pop_value();
				VAL v25 = pop_value();
				uint64_t v26 = VU64(VTUP(v25)->cells[2]);
				decref(v25);
				int64_t v27 = mw_mirth_token_Token_index(v26);
				uint64_t v28 = VU64(VTUP(v24)->cells[2]);
				decref(v24);
				push_i64(v27);
				int64_t v29 = mw_mirth_token_Token_index(v28);
				int64_t v30 = pop_i64();
				int64_t v31 = i64_sub(v30, v29);
				STR* v32 = i64_show(v31);
				uint64_t v33 = mw_std_prim_Str_ZToName(MKSTR(v32));
				VAL v34 = mw_mirth_name_QNAME0(v19, v33);
				push_value(v34);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL v35 = pop_value();
		incref(v35);
		mut_set(v35, MKPTR(v0));
		push_value(v35);
	}
	VAL v36 = pop_value();
	VAL v37 = pop_value();
	decref(v37);
	push_value(v36);
}
static int64_t mw_mirth_arrow_Block_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_arrow_Block_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_arrow_Block_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_arrow_Block_registerZ_homeZBang (uint64_t x1) {
	push_u64(x1);
	VAL v0 = mw_mirth_arrow_Block_home(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // HomeWord
			uint64_t v1 = mtp_mirth_arrow_Home_HomeWord(v0);
			int64_t v2 = mw_mirth_word_Word_incZ_numZ_blocksZBang(v1);
			uint64_t v3 = pop_u64();
			void* v4 = mfld_mirth_arrow_Block_ZTildehomeZ_index(v3);
			mut_set(MKI64(v2), MKPTR(v4));
		} break;
		case 0LL: { // HomeMain
			uint64_t v5 = mtp_mirth_arrow_Home_HomeMain(v0);
			VAL v6 = pop_value();
			decref(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_arrow_Block_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_arrow_Block_ZTildecname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		push_resource(x1);
		push_u64(x2);
		VAL v3 = mw_mirth_arrow_Block_home(x2);
		switch (get_data_tag(v3)) {
			case 1LL: { // HomeWord
				uint64_t v4 = mtp_mirth_arrow_Home_HomeWord(v3);
				VAL r5 = pop_resource();
				mw_mirth_word_Word_qnameZ_hard(v4, r5);
				VAL v6 = pop_value();
				VAL r7 = pop_resource();
				mw_mirth_name_QName_mangled(r7, v6);
				STR* v8;
				STRLIT(v8, "", 0);
				STR* v9;
				STRLIT(v9, "mb_", 3);
				VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), MKSTR(v8)));
				VAL v11 = pop_value();
				VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(v11, v10));
				STR* v13;
				STRLIT(v13, "_", 1);
				VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), v12));
				uint64_t v15 = pop_u64();
				void* v16 = mfld_mirth_arrow_Block_ZTildehomeZ_index(v15);
				VAL v17 = mut_get(MKPTR(v16));
				STR* v18 = i64_show(VI64(v17));
				push_u64(v15);
				VAL v19 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), v14));
				push_value(v19);
			} break;
			case 0LL: { // HomeMain
				uint64_t v20 = mtp_mirth_arrow_Home_HomeMain(v3);
				STR* v21;
				STRLIT(v21, "", 0);
				STR* v22;
				STRLIT(v22, "mb_", 3);
				VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v22), MKSTR(v21)));
				uint64_t v24 = pop_u64();
				push_resource(v23);
				push_u64(v24);
				int64_t v25 = mw_mirth_arrow_Block_index(v24);
				STR* v26 = i64_show(v25);
				VAL r27 = pop_resource();
				VAL v28 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v26), r27));
				push_value(v28);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL v29 = pop_value();
		incref(v29);
		mut_set(v29, MKPTR(v0));
		push_value(v29);
	}
	VAL v30 = pop_value();
	VAL v31 = pop_value();
	decref(v31);
	push_value(v30);
}
static void mw_mirth_arrow_Block_newZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_value(x2);
	uint64_t v0 = mw_mirth_arrow_Block_allocZBang();
	VAL v1 = pop_value();
	incref(v1);
	VAL v2 = VVAL(VTUP(v1)->cells[1]);
	incref(v2);
	decref(v1);
	void* v3 = mfld_mirth_arrow_Block_ZTildehome(v0);
	mut_set(v2, MKPTR(v3));
	push_value(v1);
	push_u64(v0);
	mw_mirth_arrow_Block_registerZ_homeZBang(v0);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	VAL v6 = VVAL(VTUP(v5)->cells[4]);
	incref(v6);
	decref(v5);
	incref(v4);
	void* v7 = mfld_mirth_arrow_Block_ZTildectx(VU64(v4));
	mut_set(v6, MKPTR(v7));
	incref(v5);
	uint64_t v8 = VU64(VTUP(v5)->cells[2]);
	decref(v5);
	incref(v4);
	void* v9 = mfld_mirth_arrow_Block_ZTildetoken(VU64(v4));
	mut_set(MKU64(v8), MKPTR(v9));
	incref(v5);
	VAL v10 = VVAL(VTUP(v5)->cells[5]);
	incref(v10);
	decref(v5);
	incref(v4);
	void* v11 = mfld_mirth_arrow_Block_ZTildedom(VU64(v4));
	mut_set(v10, MKPTR(v11));
	incref(v5);
	VAL v12 = VVAL(VTUP(v5)->cells[6]);
	incref(v12);
	decref(v5);
	incref(v4);
	void* v13 = mfld_mirth_arrow_Block_ZTildecod(VU64(v4));
	mut_set(v12, MKPTR(v13));
	incref(v4);
	incref(v4);
	push_value(v4);
	push_value(v5);
	VAL v14 = mtw_mirth_mirth_PropLabel_BlockArrow(VU64(v4));
	VAL r15 = pop_resource();
	VAL v16 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v16, v14, r15);
	void* v17 = mfld_mirth_arrow_Block_ZTildearrow(VU64(v4));
	VAL v18 = pop_value();
	mut_set(v18, MKPTR(v17));
}
static void mw_mirth_arrow_Block_newZ_deferredZBang_1 (VAL x1, VAL x2, uint64_t x3, VAL x4, VAL x5) {
	push_resource(x1);
	push_value(x2);
	push_u64(x3);
	push_value(x4);
	push_value(x5);
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		uint64_t v1 = mw_mirth_arrow_Block_allocZBang();
		VAL v2 = pop_value();
		void* v3 = mfld_mirth_arrow_Block_ZTildehome(v1);
		mut_set(v2, MKPTR(v3));
		push_u64(v1);
		mw_mirth_arrow_Block_registerZ_homeZBang(v1);
		VAL v4 = pop_value();
		incref(v4);
		VAL v5 = pop_value();
		void* v6 = mfld_mirth_arrow_Block_ZTildetoken(VU64(v4));
		mut_set(v5, MKPTR(v6));
		incref(v4);
		VAL v7 = pop_value();
		void* v8 = mfld_mirth_arrow_Block_ZTildectx(VU64(v4));
		mut_set(v7, MKPTR(v8));
		push_value(v4);
		uint64_t v9 = mw_mirth_type_MetaVar_newZBang();
		VAL v10 = mtw_mirth_type_StackType_STMeta(v9);
		VAL v11 = pop_value();
		incref(v11);
		void* v12 = mfld_mirth_arrow_Block_ZTildedom(VU64(v11));
		mut_set(v10, MKPTR(v12));
		push_value(v11);
		uint64_t v13 = mw_mirth_type_MetaVar_newZBang();
		VAL v14 = mtw_mirth_type_StackType_STMeta(v13);
		VAL v15 = pop_value();
		incref(v15);
		void* v16 = mfld_mirth_arrow_Block_ZTildecod(VU64(v15));
		mut_set(v14, MKPTR(v16));
		incref(v15);
		incref(v15);
		push_value(v15);
		push_value(v15);
		VAL v17 = mtw_mirth_mirth_PropLabel_BlockArrow(VU64(v15));
		incref(var_f);
		VAL v18 = var_f;
		VAL r19 = pop_resource();
		VAL v20 = pop_value();
		mw_mirth_mirth_PropLabel_prop_1(v20, v17, r19, v18);
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		incref(v22);
		void* v23 = mfld_mirth_arrow_Block_ZTildearrow(VU64(v22));
		mut_set(v21, MKPTR(v23));
		decref(var_f);
		push_value(v22);
	}
}
static VAL mw_mirth_arrow_Block_typecheckZBang (VAL x1, uint64_t x2) {
	mw_mirth_arrow_Block_arrow(x1, x2);
	VAL v0 = pop_value();
	decref(v0);
	VAL r1 = pop_resource();
	return r1;
}
static void mw_mirth_arrow_blockZ_unifyZ_typeZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_u64(x3);
	VAL v0 = mw_mirth_arrow_Block_type(x3);
	VAL v1 = pop_value();
	uint64_t r2 = VU64(pop_resource());
	VAL r3 = pop_resource();
	mw_mirth_type_ArrowType_unifyZBang(r3, r2, v0, x4);
	VAL v4 = pop_value();
	decref(v4);
	uint64_t r5 = VU64(pop_resource());
	VAL r6 = pop_resource();
	mw_mirth_arrow_Block_arrow(r6, VU64(v1));
	VAL v7 = pop_value();
	push_resource(MKU64(r5));
	VAL v8 = mw_mirth_arrow_Arrow_type(v7);
	push_value(v8);
}
static void mw_mirth_arrow_Block_toZ_runZ_var (VAL x1, uint64_t x2) {
	mw_mirth_arrow_Block_arrow(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_mirth_arrow_Arrow_toZ_runZ_var(v0);
	push_value(v1);
}
static VAL mw_mirth_arrow_Arrow_toZ_runZ_var (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	VAL v1 = mw_std_list_List_1_ZDivL1(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_arrow_Atom_toZ_runZ_var(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static VAL mw_mirth_arrow_Atom_toZ_runZ_var (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 13LL: { // OpVar
			uint64_t v1 = mtp_mirth_arrow_Op_OpVar(v0);
			push_u64(v1);
			int64_t v2 = mw_mirth_var_Var_autoZ_runZAsk(v1);
			if (((bool)v2)) {
				VAL v3 = pop_value();
				VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
				push_value(v4);
			} else {
				uint64_t v5 = pop_u64();
				int64_t v6 = 0LL /* None */;
				push_i64(v6);
			}
		} break;
		default: {
			decref(v0);
			int64_t v7 = 0LL /* None */;
			push_i64(v7);
		} break;
	}
	VAL v8 = pop_value();
	return v8;
}
static void mw_mirth_arrow_Arg_ZToStr (VAL x1, uint64_t x2) {
	mw_mirth_arrow_Block_qname(x1, x2);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	mw_mirth_name_QName_ZToStr(r1, v0);
}
static int64_t mw_mirth_arrow_Arg_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_arrow_Block_ZEqualZEqual(x1, x2);
	return v0;
}
static void mw_mirth_arrow_Block_freeZ_vars (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_arrow_Block_ZTildefreeZ_vars(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		push_u64(x2);
		mw_mirth_arrow_Block_arrow(x1, x2);
		VAL v3 = pop_value();
		VAL r4 = pop_resource();
		mw_mirth_arrow_Arrow_freeZ_vars(r4, v3);
		VAL v5 = pop_value();
		incref(v5);
		mut_set(v5, MKPTR(v0));
		push_value(v5);
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_arrow_Arrow_freeZ_vars (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[7]);
	incref(v0);
	decref(x2);
	int64_t v1 = 0LL /* Nil */;
	push_resource(x1);
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	push_resource(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL r12 = pop_resource();
		mw_mirth_arrow_Atom_freeZ_vars(r12, v9);
		VAL v13 = pop_value();
		VAL v14 = mtw_std_list_List_1_Cons(v13, r11);
		push_resource(v14);
		mw_std_list_List_1_uncons(v10);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
	VAL r19 = pop_resource();
	VAL v20 = mw_std_list_List_1_reverse(r19);
	VAL v21 = mw_std_list_List_1_ZToListZPlus(v20);
	switch (get_data_tag(v21)) {
		case 1LL: { // Some
			VAL v22 = mtp_std_maybe_Maybe_1_Some(v21);
			mw_std_list_ListZPlus_1_uncons(v22);
			VAL v23 = pop_value();
			mw_std_list_List_1_uncons(v23);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
			while(1) {
				VAL v26 = pop_value();
				incref(v26);
				push_value(v26);
				int64_t v27 = mw_std_maybe_Maybe_1_someZAsk(v26);
				if (!((bool)v27)) break;
				VAL v28 = pop_value();
				VAL v29 = mw_std_maybe_Maybe_1_unwrap(v28);
				VAL v30 = pop_value();
				VAL v31 = pop_value();
				incref(v31);
				int64_t v32 = 0LL /* Nil */;
				push_value(v31);
				push_value(v29);
				VAL v33 = mw_std_list_List_1_reverse(MKI64(v32));
				VAL v34 = pop_value();
				push_resource(v33);
				mw_std_list_List_1_uncons(v34);
				VAL v35 = pop_value();
				VAL v36 = pop_value();
				push_value(v35);
				push_value(v36);
				while(1) {
					VAL v37 = pop_value();
					incref(v37);
					push_value(v37);
					int64_t v38 = mw_std_maybe_Maybe_1_someZAsk(v37);
					if (!((bool)v38)) break;
					VAL v39 = pop_value();
					VAL v40 = mw_std_maybe_Maybe_1_unwrap(v39);
					VAL v41 = pop_value();
					VAL r42 = pop_resource();
					incref(v40);
					VAL v43 = pop_value();
					incref(v43);
					int64_t v44 = 0LL /* None */;
					push_value(v40);
					push_i64(v44);
					mw_std_list_List_1_uncons(v43);
					VAL v45 = pop_value();
					VAL v46 = pop_value();
					push_value(v45);
					push_value(v46);
					while(1) {
						VAL v47 = pop_value();
						incref(v47);
						push_value(v47);
						int64_t v48 = mw_std_maybe_Maybe_1_someZAsk(v47);
						if (!((bool)v48)) break;
						VAL v49 = pop_value();
						VAL v50 = mw_std_maybe_Maybe_1_unwrap(v49);
						VAL v51 = pop_value();
						VAL v52 = pop_value();
						incref(v50);
						VAL v53 = pop_value();
						incref(v53);
						int64_t v54 = mw_mirth_var_Var_ZEqualZEqual(VU64(v53), VU64(v50));
						if (((bool)v54)) {
							push_value(v53);
							VAL v55 = mtw_std_maybe_Maybe_1_Some(v50);
							push_value(v55);
						} else {
							decref(v50);
							int64_t v56 = 0LL /* None */;
							push_value(v53);
							push_i64(v56);
						}
						VAL v57 = pop_value();
						switch (get_data_tag(v57)) {
							case 0LL: { // None
								push_value(v52);
								push_value(v51);
							} break;
							default: {
								decref(v51);
								decref(v52);
								int64_t v58 = 0LL /* Nil */;
								push_value(v57);
								push_i64(v58);
							} break;
						}
						VAL v59 = pop_value();
						mw_std_list_List_1_uncons(v59);
						VAL v60 = pop_value();
						VAL v61 = pop_value();
						push_value(v60);
						push_value(v61);
					}
					VAL v62 = pop_value();
					decref(v62);
					VAL v63 = pop_value();
					decref(v63);
					VAL v64 = pop_value();
					VAL v65 = pop_value();
					decref(v65);
					int64_t v66 = mw_std_maybe_Maybe_1_someZAsk(v64);
					bool v67 = !((bool)v66);
					if (v67) {
						push_value(v43);
						VAL v68 = mtw_std_maybe_Maybe_1_Some(v40);
						push_value(v68);
					} else {
						decref(v40);
						int64_t v69 = 0LL /* None */;
						push_value(v43);
						push_i64(v69);
					}
					VAL v70 = pop_value();
					switch (get_data_tag(v70)) {
						case 1LL: { // Some
							push_resource(r42);
							VAL v71 = mtp_std_maybe_Maybe_1_Some(v70);
							VAL r72 = pop_resource();
							VAL v73 = mtw_std_list_List_1_Cons(v71, r72);
							push_resource(v73);
						} break;
						case 0LL: { // None
							push_resource(r42);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_resource(r42);
						}
					}
					mw_std_list_List_1_uncons(v41);
					VAL v74 = pop_value();
					VAL v75 = pop_value();
					push_value(v74);
					push_value(v75);
				}
				VAL v76 = pop_value();
				decref(v76);
				VAL v77 = pop_value();
				decref(v77);
				VAL r78 = pop_resource();
				VAL v79 = mw_std_list_List_1_reverse(r78);
				VAL v80 = pop_value();
				decref(v80);
				VAL v81 = mw_std_list_List_1_cat(v31, v79);
				push_value(v81);
				mw_std_list_List_1_uncons(v30);
				VAL v82 = pop_value();
				VAL v83 = pop_value();
				push_value(v82);
				push_value(v83);
			}
			VAL v84 = pop_value();
			decref(v84);
			VAL v85 = pop_value();
			decref(v85);
			VAL v86 = pop_value();
			VAL v87 = mtw_std_maybe_Maybe_1_Some(v86);
			push_value(v87);
		} break;
		case 0LL: { // None
			int64_t v88 = 0LL /* None */;
			push_i64(v88);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v89 = pop_value();
	switch (get_data_tag(v89)) {
		case 1LL: { // Some
			VAL v90 = mtp_std_maybe_Maybe_1_Some(v89);
			push_value(v90);
		} break;
		case 0LL: { // None
			int64_t v91 = 0LL /* Nil */;
			push_i64(v91);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_arrow_Atom_freeZ_vars (VAL x1, VAL x2) {
	incref(x2);
	VAL v0 = VVAL(VTUP(x2)->cells[5]);
	incref(v0);
	decref(x2);
	int64_t v1 = 0LL /* Nil */;
	push_resource(x1);
	push_value(x2);
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	push_resource(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL r12 = pop_resource();
		mw_mirth_arrow_Arg_freeZ_vars(r12, VU64(v9));
		VAL v13 = pop_value();
		VAL v14 = mtw_std_list_List_1_Cons(v13, r11);
		push_resource(v14);
		mw_std_list_List_1_uncons(v10);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
	VAL r19 = pop_resource();
	VAL v20 = mw_std_list_List_1_reverse(r19);
	VAL v21 = mw_std_list_List_1_ZToListZPlus(v20);
	switch (get_data_tag(v21)) {
		case 1LL: { // Some
			VAL v22 = mtp_std_maybe_Maybe_1_Some(v21);
			mw_std_list_ListZPlus_1_uncons(v22);
			VAL v23 = pop_value();
			mw_std_list_List_1_uncons(v23);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
			while(1) {
				VAL v26 = pop_value();
				incref(v26);
				push_value(v26);
				int64_t v27 = mw_std_maybe_Maybe_1_someZAsk(v26);
				if (!((bool)v27)) break;
				VAL v28 = pop_value();
				VAL v29 = mw_std_maybe_Maybe_1_unwrap(v28);
				VAL v30 = pop_value();
				VAL v31 = pop_value();
				incref(v31);
				int64_t v32 = 0LL /* Nil */;
				push_value(v31);
				push_value(v29);
				VAL v33 = mw_std_list_List_1_reverse(MKI64(v32));
				VAL v34 = pop_value();
				push_resource(v33);
				mw_std_list_List_1_uncons(v34);
				VAL v35 = pop_value();
				VAL v36 = pop_value();
				push_value(v35);
				push_value(v36);
				while(1) {
					VAL v37 = pop_value();
					incref(v37);
					push_value(v37);
					int64_t v38 = mw_std_maybe_Maybe_1_someZAsk(v37);
					if (!((bool)v38)) break;
					VAL v39 = pop_value();
					VAL v40 = mw_std_maybe_Maybe_1_unwrap(v39);
					VAL v41 = pop_value();
					VAL r42 = pop_resource();
					incref(v40);
					VAL v43 = pop_value();
					incref(v43);
					int64_t v44 = 0LL /* None */;
					push_value(v40);
					push_i64(v44);
					mw_std_list_List_1_uncons(v43);
					VAL v45 = pop_value();
					VAL v46 = pop_value();
					push_value(v45);
					push_value(v46);
					while(1) {
						VAL v47 = pop_value();
						incref(v47);
						push_value(v47);
						int64_t v48 = mw_std_maybe_Maybe_1_someZAsk(v47);
						if (!((bool)v48)) break;
						VAL v49 = pop_value();
						VAL v50 = mw_std_maybe_Maybe_1_unwrap(v49);
						VAL v51 = pop_value();
						VAL v52 = pop_value();
						incref(v50);
						VAL v53 = pop_value();
						incref(v53);
						int64_t v54 = mw_mirth_var_Var_ZEqualZEqual(VU64(v53), VU64(v50));
						if (((bool)v54)) {
							push_value(v53);
							VAL v55 = mtw_std_maybe_Maybe_1_Some(v50);
							push_value(v55);
						} else {
							decref(v50);
							int64_t v56 = 0LL /* None */;
							push_value(v53);
							push_i64(v56);
						}
						VAL v57 = pop_value();
						switch (get_data_tag(v57)) {
							case 0LL: { // None
								push_value(v52);
								push_value(v51);
							} break;
							default: {
								decref(v51);
								decref(v52);
								int64_t v58 = 0LL /* Nil */;
								push_value(v57);
								push_i64(v58);
							} break;
						}
						VAL v59 = pop_value();
						mw_std_list_List_1_uncons(v59);
						VAL v60 = pop_value();
						VAL v61 = pop_value();
						push_value(v60);
						push_value(v61);
					}
					VAL v62 = pop_value();
					decref(v62);
					VAL v63 = pop_value();
					decref(v63);
					VAL v64 = pop_value();
					VAL v65 = pop_value();
					decref(v65);
					int64_t v66 = mw_std_maybe_Maybe_1_someZAsk(v64);
					bool v67 = !((bool)v66);
					if (v67) {
						push_value(v43);
						VAL v68 = mtw_std_maybe_Maybe_1_Some(v40);
						push_value(v68);
					} else {
						decref(v40);
						int64_t v69 = 0LL /* None */;
						push_value(v43);
						push_i64(v69);
					}
					VAL v70 = pop_value();
					switch (get_data_tag(v70)) {
						case 1LL: { // Some
							push_resource(r42);
							VAL v71 = mtp_std_maybe_Maybe_1_Some(v70);
							VAL r72 = pop_resource();
							VAL v73 = mtw_std_list_List_1_Cons(v71, r72);
							push_resource(v73);
						} break;
						case 0LL: { // None
							push_resource(r42);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_resource(r42);
						}
					}
					mw_std_list_List_1_uncons(v41);
					VAL v74 = pop_value();
					VAL v75 = pop_value();
					push_value(v74);
					push_value(v75);
				}
				VAL v76 = pop_value();
				decref(v76);
				VAL v77 = pop_value();
				decref(v77);
				VAL r78 = pop_resource();
				VAL v79 = mw_std_list_List_1_reverse(r78);
				VAL v80 = pop_value();
				decref(v80);
				VAL v81 = mw_std_list_List_1_cat(v31, v79);
				push_value(v81);
				mw_std_list_List_1_uncons(v30);
				VAL v82 = pop_value();
				VAL v83 = pop_value();
				push_value(v82);
				push_value(v83);
			}
			VAL v84 = pop_value();
			decref(v84);
			VAL v85 = pop_value();
			decref(v85);
			VAL v86 = pop_value();
			VAL v87 = mtw_std_maybe_Maybe_1_Some(v86);
			push_value(v87);
		} break;
		case 0LL: { // None
			int64_t v88 = 0LL /* None */;
			push_i64(v88);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v89 = pop_value();
	switch (get_data_tag(v89)) {
		case 1LL: { // Some
			VAL v90 = mtp_std_maybe_Maybe_1_Some(v89);
			push_value(v90);
		} break;
		case 0LL: { // None
			int64_t v91 = 0LL /* Nil */;
			push_i64(v91);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v92 = pop_value();
	VAL v93 = pop_value();
	VAL v94 = VVAL(VTUP(v93)->cells[4]);
	incref(v94);
	decref(v93);
	VAL r95 = pop_resource();
	push_value(v92);
	mw_mirth_arrow_Op_freeZ_vars(r95, v94);
	VAL v96 = pop_value();
	VAL v97 = pop_value();
	incref(v97);
	int64_t v98 = 0LL /* Nil */;
	push_value(v97);
	push_value(v96);
	VAL v99 = mw_std_list_List_1_reverse(MKI64(v98));
	VAL v100 = pop_value();
	push_resource(v99);
	mw_std_list_List_1_uncons(v100);
	VAL v101 = pop_value();
	VAL v102 = pop_value();
	push_value(v101);
	push_value(v102);
	while(1) {
		VAL v103 = pop_value();
		incref(v103);
		push_value(v103);
		int64_t v104 = mw_std_maybe_Maybe_1_someZAsk(v103);
		if (!((bool)v104)) break;
		VAL v105 = pop_value();
		VAL v106 = mw_std_maybe_Maybe_1_unwrap(v105);
		VAL v107 = pop_value();
		VAL r108 = pop_resource();
		incref(v106);
		VAL v109 = pop_value();
		incref(v109);
		int64_t v110 = 0LL /* None */;
		push_value(v106);
		push_i64(v110);
		mw_std_list_List_1_uncons(v109);
		VAL v111 = pop_value();
		VAL v112 = pop_value();
		push_value(v111);
		push_value(v112);
		while(1) {
			VAL v113 = pop_value();
			incref(v113);
			push_value(v113);
			int64_t v114 = mw_std_maybe_Maybe_1_someZAsk(v113);
			if (!((bool)v114)) break;
			VAL v115 = pop_value();
			VAL v116 = mw_std_maybe_Maybe_1_unwrap(v115);
			VAL v117 = pop_value();
			VAL v118 = pop_value();
			incref(v116);
			VAL v119 = pop_value();
			incref(v119);
			int64_t v120 = mw_mirth_var_Var_ZEqualZEqual(VU64(v119), VU64(v116));
			if (((bool)v120)) {
				push_value(v119);
				VAL v121 = mtw_std_maybe_Maybe_1_Some(v116);
				push_value(v121);
			} else {
				decref(v116);
				int64_t v122 = 0LL /* None */;
				push_value(v119);
				push_i64(v122);
			}
			VAL v123 = pop_value();
			switch (get_data_tag(v123)) {
				case 0LL: { // None
					push_value(v118);
					push_value(v117);
				} break;
				default: {
					decref(v117);
					decref(v118);
					int64_t v124 = 0LL /* Nil */;
					push_value(v123);
					push_i64(v124);
				} break;
			}
			VAL v125 = pop_value();
			mw_std_list_List_1_uncons(v125);
			VAL v126 = pop_value();
			VAL v127 = pop_value();
			push_value(v126);
			push_value(v127);
		}
		VAL v128 = pop_value();
		decref(v128);
		VAL v129 = pop_value();
		decref(v129);
		VAL v130 = pop_value();
		VAL v131 = pop_value();
		decref(v131);
		int64_t v132 = mw_std_maybe_Maybe_1_someZAsk(v130);
		bool v133 = !((bool)v132);
		if (v133) {
			push_value(v109);
			VAL v134 = mtw_std_maybe_Maybe_1_Some(v106);
			push_value(v134);
		} else {
			decref(v106);
			int64_t v135 = 0LL /* None */;
			push_value(v109);
			push_i64(v135);
		}
		VAL v136 = pop_value();
		switch (get_data_tag(v136)) {
			case 1LL: { // Some
				push_resource(r108);
				VAL v137 = mtp_std_maybe_Maybe_1_Some(v136);
				VAL r138 = pop_resource();
				VAL v139 = mtw_std_list_List_1_Cons(v137, r138);
				push_resource(v139);
			} break;
			case 0LL: { // None
				push_resource(r108);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r108);
			}
		}
		mw_std_list_List_1_uncons(v107);
		VAL v140 = pop_value();
		VAL v141 = pop_value();
		push_value(v140);
		push_value(v141);
	}
	VAL v142 = pop_value();
	decref(v142);
	VAL v143 = pop_value();
	decref(v143);
	VAL r144 = pop_resource();
	VAL v145 = mw_std_list_List_1_reverse(r144);
	VAL v146 = pop_value();
	decref(v146);
	VAL v147 = mw_std_list_List_1_cat(v97, v145);
	push_value(v147);
}
static void mw_mirth_arrow_Arg_freeZ_vars (VAL x1, uint64_t x2) {
	mw_mirth_arrow_Block_freeZ_vars(x1, x2);
}
static void mw_mirth_arrow_Op_freeZ_vars (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			int64_t v0 = 0LL /* Nil */;
			push_resource(x1);
			push_i64(v0);
		} break;
		case 1LL: { // OpPrim
			push_resource(x1);
			int64_t v1 = mtp_mirth_arrow_Op_OpPrim(x2);
			int64_t v2 = 0LL /* Nil */;
			push_i64(v2);
		} break;
		case 2LL: { // OpWord
			push_resource(x1);
			uint64_t v3 = mtp_mirth_arrow_Op_OpWord(x2);
			int64_t v4 = 0LL /* Nil */;
			push_i64(v4);
		} break;
		case 3LL: { // OpExternal
			push_resource(x1);
			uint64_t v5 = mtp_mirth_arrow_Op_OpExternal(x2);
			int64_t v6 = 0LL /* Nil */;
			push_i64(v6);
		} break;
		case 4LL: { // OpBuffer
			push_resource(x1);
			uint64_t v7 = mtp_mirth_arrow_Op_OpBuffer(x2);
			int64_t v8 = 0LL /* Nil */;
			push_i64(v8);
		} break;
		case 5LL: { // OpVariable
			push_resource(x1);
			uint64_t v9 = mtp_mirth_arrow_Op_OpVariable(x2);
			int64_t v10 = 0LL /* Nil */;
			push_i64(v10);
		} break;
		case 6LL: { // OpField
			push_resource(x1);
			uint64_t v11 = mtp_mirth_arrow_Op_OpField(x2);
			int64_t v12 = 0LL /* Nil */;
			push_i64(v12);
		} break;
		case 7LL: { // OpInt
			push_resource(x1);
			int64_t v13 = mtp_mirth_arrow_Op_OpInt(x2);
			int64_t v14 = 0LL /* Nil */;
			push_i64(v14);
		} break;
		case 8LL: { // OpF64
			push_resource(x1);
			double v15 = mtp_mirth_arrow_Op_OpF64(x2);
			int64_t v16 = 0LL /* Nil */;
			push_i64(v16);
		} break;
		case 9LL: { // OpStr
			push_resource(x1);
			VAL v17 = mtp_mirth_arrow_Op_OpStr(x2);
			decref(v17);
			int64_t v18 = 0LL /* Nil */;
			push_i64(v18);
		} break;
		case 10LL: { // OpTag
			push_resource(x1);
			uint64_t v19 = mtp_mirth_arrow_Op_OpTag(x2);
			int64_t v20 = 0LL /* Nil */;
			push_i64(v20);
		} break;
		case 11LL: { // OpMatch
			push_resource(x1);
			VAL v21 = mtp_mirth_arrow_Op_OpMatch(x2);
			VAL r22 = pop_resource();
			mw_mirth_match_Match_freeZ_vars(r22, v21);
		} break;
		case 12LL: { // OpLambda
			push_resource(x1);
			VAL v23 = mtp_mirth_arrow_Op_OpLambda(x2);
			VAL r24 = pop_resource();
			mw_mirth_arrow_Lambda_freeZ_vars(r24, v23);
		} break;
		case 13LL: { // OpVar
			push_resource(x1);
			uint64_t v25 = mtp_mirth_arrow_Op_OpVar(x2);
			int64_t v26 = 0LL /* Nil */;
			VAL v27 = mtw_std_list_List_1_Cons(MKU64(v25), MKI64(v26));
			push_value(v27);
		} break;
		case 14LL: { // OpBlockPush
			push_resource(x1);
			uint64_t v28 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			VAL r29 = pop_resource();
			mw_mirth_arrow_Block_freeZ_vars(r29, v28);
		} break;
		case 15LL: { // OpBlockRun
			push_resource(x1);
			uint64_t v30 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			VAL r31 = pop_resource();
			mw_mirth_arrow_Block_freeZ_vars(r31, v30);
		} break;
		case 16LL: { // OpCoerce
			push_resource(x1);
			VAL v32 = mtp_mirth_arrow_Op_OpCoerce(x2);
			decref(v32);
			int64_t v33 = 0LL /* Nil */;
			push_i64(v33);
		} break;
		case 17LL: { // OpLabelPush
			push_resource(x1);
			uint64_t v34 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			int64_t v35 = 0LL /* Nil */;
			push_i64(v35);
		} break;
		case 18LL: { // OpLabelPop
			push_resource(x1);
			uint64_t v36 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			int64_t v37 = 0LL /* Nil */;
			push_i64(v37);
		} break;
		case 19LL: { // OpLabelPushR
			push_resource(x1);
			uint64_t v38 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			int64_t v39 = 0LL /* Nil */;
			push_i64(v39);
		} break;
		case 20LL: { // OpLabelPopR
			push_resource(x1);
			uint64_t v40 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			int64_t v41 = 0LL /* Nil */;
			push_i64(v41);
		} break;
		case 21LL: { // OpDataGetTag
			push_resource(x1);
			uint64_t v42 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			int64_t v43 = 0LL /* Nil */;
			push_i64(v43);
		} break;
		case 22LL: { // OpDataGetLabel
			push_resource(x1);
			mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			VAL v44 = pop_value();
			decref(v44);
			VAL v45 = pop_value();
			decref(v45);
			int64_t v46 = 0LL /* Nil */;
			push_i64(v46);
		} break;
		case 23LL: { // OpDataSetLabel
			push_resource(x1);
			mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			VAL v47 = pop_value();
			decref(v47);
			VAL v48 = pop_value();
			decref(v48);
			int64_t v49 = 0LL /* Nil */;
			push_i64(v49);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_match_Match_freeZ_vars (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[7]);
	incref(v0);
	decref(x2);
	int64_t v1 = 0LL /* Nil */;
	push_resource(x1);
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	push_resource(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL r12 = pop_resource();
		mw_mirth_match_Case_freeZ_vars(r12, v9);
		VAL v13 = pop_value();
		VAL v14 = mtw_std_list_List_1_Cons(v13, r11);
		push_resource(v14);
		mw_std_list_List_1_uncons(v10);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
	VAL r19 = pop_resource();
	VAL v20 = mw_std_list_List_1_reverse(r19);
	VAL v21 = mw_std_list_List_1_ZToListZPlus(v20);
	switch (get_data_tag(v21)) {
		case 1LL: { // Some
			VAL v22 = mtp_std_maybe_Maybe_1_Some(v21);
			mw_std_list_ListZPlus_1_uncons(v22);
			VAL v23 = pop_value();
			mw_std_list_List_1_uncons(v23);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
			while(1) {
				VAL v26 = pop_value();
				incref(v26);
				push_value(v26);
				int64_t v27 = mw_std_maybe_Maybe_1_someZAsk(v26);
				if (!((bool)v27)) break;
				VAL v28 = pop_value();
				VAL v29 = mw_std_maybe_Maybe_1_unwrap(v28);
				VAL v30 = pop_value();
				VAL v31 = pop_value();
				incref(v31);
				int64_t v32 = 0LL /* Nil */;
				push_value(v31);
				push_value(v29);
				VAL v33 = mw_std_list_List_1_reverse(MKI64(v32));
				VAL v34 = pop_value();
				push_resource(v33);
				mw_std_list_List_1_uncons(v34);
				VAL v35 = pop_value();
				VAL v36 = pop_value();
				push_value(v35);
				push_value(v36);
				while(1) {
					VAL v37 = pop_value();
					incref(v37);
					push_value(v37);
					int64_t v38 = mw_std_maybe_Maybe_1_someZAsk(v37);
					if (!((bool)v38)) break;
					VAL v39 = pop_value();
					VAL v40 = mw_std_maybe_Maybe_1_unwrap(v39);
					VAL v41 = pop_value();
					VAL r42 = pop_resource();
					incref(v40);
					VAL v43 = pop_value();
					incref(v43);
					int64_t v44 = 0LL /* None */;
					push_value(v40);
					push_i64(v44);
					mw_std_list_List_1_uncons(v43);
					VAL v45 = pop_value();
					VAL v46 = pop_value();
					push_value(v45);
					push_value(v46);
					while(1) {
						VAL v47 = pop_value();
						incref(v47);
						push_value(v47);
						int64_t v48 = mw_std_maybe_Maybe_1_someZAsk(v47);
						if (!((bool)v48)) break;
						VAL v49 = pop_value();
						VAL v50 = mw_std_maybe_Maybe_1_unwrap(v49);
						VAL v51 = pop_value();
						VAL v52 = pop_value();
						incref(v50);
						VAL v53 = pop_value();
						incref(v53);
						int64_t v54 = mw_mirth_var_Var_ZEqualZEqual(VU64(v53), VU64(v50));
						if (((bool)v54)) {
							push_value(v53);
							VAL v55 = mtw_std_maybe_Maybe_1_Some(v50);
							push_value(v55);
						} else {
							decref(v50);
							int64_t v56 = 0LL /* None */;
							push_value(v53);
							push_i64(v56);
						}
						VAL v57 = pop_value();
						switch (get_data_tag(v57)) {
							case 0LL: { // None
								push_value(v52);
								push_value(v51);
							} break;
							default: {
								decref(v51);
								decref(v52);
								int64_t v58 = 0LL /* Nil */;
								push_value(v57);
								push_i64(v58);
							} break;
						}
						VAL v59 = pop_value();
						mw_std_list_List_1_uncons(v59);
						VAL v60 = pop_value();
						VAL v61 = pop_value();
						push_value(v60);
						push_value(v61);
					}
					VAL v62 = pop_value();
					decref(v62);
					VAL v63 = pop_value();
					decref(v63);
					VAL v64 = pop_value();
					VAL v65 = pop_value();
					decref(v65);
					int64_t v66 = mw_std_maybe_Maybe_1_someZAsk(v64);
					bool v67 = !((bool)v66);
					if (v67) {
						push_value(v43);
						VAL v68 = mtw_std_maybe_Maybe_1_Some(v40);
						push_value(v68);
					} else {
						decref(v40);
						int64_t v69 = 0LL /* None */;
						push_value(v43);
						push_i64(v69);
					}
					VAL v70 = pop_value();
					switch (get_data_tag(v70)) {
						case 1LL: { // Some
							push_resource(r42);
							VAL v71 = mtp_std_maybe_Maybe_1_Some(v70);
							VAL r72 = pop_resource();
							VAL v73 = mtw_std_list_List_1_Cons(v71, r72);
							push_resource(v73);
						} break;
						case 0LL: { // None
							push_resource(r42);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_resource(r42);
						}
					}
					mw_std_list_List_1_uncons(v41);
					VAL v74 = pop_value();
					VAL v75 = pop_value();
					push_value(v74);
					push_value(v75);
				}
				VAL v76 = pop_value();
				decref(v76);
				VAL v77 = pop_value();
				decref(v77);
				VAL r78 = pop_resource();
				VAL v79 = mw_std_list_List_1_reverse(r78);
				VAL v80 = pop_value();
				decref(v80);
				VAL v81 = mw_std_list_List_1_cat(v31, v79);
				push_value(v81);
				mw_std_list_List_1_uncons(v30);
				VAL v82 = pop_value();
				VAL v83 = pop_value();
				push_value(v82);
				push_value(v83);
			}
			VAL v84 = pop_value();
			decref(v84);
			VAL v85 = pop_value();
			decref(v85);
			VAL v86 = pop_value();
			VAL v87 = mtw_std_maybe_Maybe_1_Some(v86);
			push_value(v87);
		} break;
		case 0LL: { // None
			int64_t v88 = 0LL /* None */;
			push_i64(v88);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v89 = pop_value();
	switch (get_data_tag(v89)) {
		case 1LL: { // Some
			VAL v90 = mtp_std_maybe_Maybe_1_Some(v89);
			push_value(v90);
		} break;
		case 0LL: { // None
			int64_t v91 = 0LL /* Nil */;
			push_i64(v91);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_match_Case_freeZ_vars (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[2]);
	incref(v0);
	decref(x2);
	mw_mirth_arrow_Arrow_freeZ_vars(x1, v0);
}
static void mw_mirth_arrow_Lambda_freeZ_vars (VAL x1, VAL x2) {
	incref(x2);
	VAL v0 = VVAL(VTUP(x2)->cells[5]);
	incref(v0);
	decref(x2);
	push_value(x2);
	mw_mirth_arrow_Arrow_freeZ_vars(x1, v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = VVAL(VTUP(v2)->cells[4]);
	incref(v3);
	decref(v2);
	int64_t v4 = 0LL /* Nil */;
	push_value(v3);
	push_value(v1);
	VAL v5 = mw_std_list_List_1_reverse(MKI64(v4));
	VAL v6 = pop_value();
	push_resource(v5);
	mw_std_list_List_1_uncons(v6);
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	while(1) {
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
		if (!((bool)v10)) break;
		VAL v11 = pop_value();
		VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
		VAL v13 = pop_value();
		VAL r14 = pop_resource();
		incref(v12);
		VAL v15 = pop_value();
		incref(v15);
		int64_t v16 = 0LL /* None */;
		push_value(v12);
		push_i64(v16);
		mw_std_list_List_1_uncons(v15);
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		push_value(v17);
		push_value(v18);
		while(1) {
			VAL v19 = pop_value();
			incref(v19);
			push_value(v19);
			int64_t v20 = mw_std_maybe_Maybe_1_someZAsk(v19);
			if (!((bool)v20)) break;
			VAL v21 = pop_value();
			VAL v22 = mw_std_maybe_Maybe_1_unwrap(v21);
			VAL v23 = pop_value();
			VAL v24 = pop_value();
			incref(v22);
			VAL v25 = pop_value();
			incref(v25);
			int64_t v26 = mw_mirth_var_Var_ZEqualZEqual(VU64(v25), VU64(v22));
			if (((bool)v26)) {
				push_value(v25);
				VAL v27 = mtw_std_maybe_Maybe_1_Some(v22);
				push_value(v27);
			} else {
				decref(v22);
				int64_t v28 = 0LL /* None */;
				push_value(v25);
				push_i64(v28);
			}
			VAL v29 = pop_value();
			switch (get_data_tag(v29)) {
				case 0LL: { // None
					push_value(v24);
					push_value(v23);
				} break;
				default: {
					decref(v23);
					decref(v24);
					int64_t v30 = 0LL /* Nil */;
					push_value(v29);
					push_i64(v30);
				} break;
			}
			VAL v31 = pop_value();
			mw_std_list_List_1_uncons(v31);
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			push_value(v32);
			push_value(v33);
		}
		VAL v34 = pop_value();
		decref(v34);
		VAL v35 = pop_value();
		decref(v35);
		VAL v36 = pop_value();
		VAL v37 = pop_value();
		decref(v37);
		int64_t v38 = mw_std_maybe_Maybe_1_someZAsk(v36);
		bool v39 = !((bool)v38);
		if (v39) {
			push_value(v15);
			VAL v40 = mtw_std_maybe_Maybe_1_Some(v12);
			push_value(v40);
		} else {
			decref(v12);
			int64_t v41 = 0LL /* None */;
			push_value(v15);
			push_i64(v41);
		}
		VAL v42 = pop_value();
		switch (get_data_tag(v42)) {
			case 1LL: { // Some
				push_resource(r14);
				VAL v43 = mtp_std_maybe_Maybe_1_Some(v42);
				VAL r44 = pop_resource();
				VAL v45 = mtw_std_list_List_1_Cons(v43, r44);
				push_resource(v45);
			} break;
			case 0LL: { // None
				push_resource(r14);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r14);
			}
		}
		mw_std_list_List_1_uncons(v13);
		VAL v46 = pop_value();
		VAL v47 = pop_value();
		push_value(v46);
		push_value(v47);
	}
	VAL v48 = pop_value();
	decref(v48);
	VAL v49 = pop_value();
	decref(v49);
	VAL r50 = pop_resource();
	VAL v51 = mw_std_list_List_1_reverse(r50);
	VAL v52 = pop_value();
	decref(v52);
	push_value(v51);
}
static uint64_t mw_mirth_arrow_Arg_token (uint64_t x1) {
	uint64_t v0 = mw_mirth_arrow_Block_token(x1);
	return v0;
}
static int64_t mw_mirth_typedef_TypeDef_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_typedef_TypeDef_allocZBang (void) {
	void* v0 = mbuf_mirth_typedef_TypeDef_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_typedef_TypeDef_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_typedef_TypeDef_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_typedef_TypeDef_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_typedef_TypeDef_qnameZ_hard (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_typedef_TypeDef_ZTildeqname(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static void mw_mirth_typedef_TypeDef_namespace (VAL x1, uint64_t x2) {
	mw_mirth_typedef_TypeDef_qnameZ_hard(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	decref(v0);
	push_value(v1);
}
static uint64_t mw_mirth_typedef_TypeDef_name (uint64_t x1) {
	void* v0 = mfld_mirth_typedef_TypeDef_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static void mw_mirth_typedef_TypeDef_target (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_typedef_TypeDef_ZTildetarget(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static int64_t mw_mirth_typedef_TypeDef_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_typedef_TypeDef_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_typedef_TypeDef_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_typedef_TypeDef_newZBang (VAL x1, VAL x2, uint64_t x3, VAL x4) {
	push_resource(x1);
	lpush(&lbl_head, x2);
	lpush(&lbl_name, MKU64(x3));
	lpush(&lbl_state, x4);
	uint64_t v0 = mw_mirth_typedef_TypeDef_allocZBang();
	VAL v1 = lpop(&lbl_head);
	void* v2 = mfld_mirth_typedef_TypeDef_ZTildeheadZAsk(v0);
	mut_set(v1, MKPTR(v2));
	uint64_t v3 = VU64(lpop(&lbl_name));
	void* v4 = mfld_mirth_typedef_TypeDef_ZTildename(v0);
	mut_set(MKU64(v3), MKPTR(v4));
	push_u64(v0);
	VAL v5 = mtw_mirth_mirth_PropLabel_TypeDefQName(v0);
	VAL v6 = lpop(&lbl_state);
	VAL v7 = mtw_mirth_mirth_Prop_1_Prop(v5, v6);
	VAL v8 = pop_value();
	incref(v8);
	void* v9 = mfld_mirth_typedef_TypeDef_ZTildeqname(VU64(v8));
	mut_set(v7, MKPTR(v9));
	incref(v8);
	push_value(v8);
	VAL v10 = mtw_mirth_def_Def_DefType(VU64(v8));
	VAL r11 = pop_resource();
	VAL v12 = (mw_mirth_def_Def_register(r11, v10));
	push_resource(v12);
}
static VAL mw_mirth_mirth_ZPlusMirth_defZ_typeZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v0 = 0LL /* None */;
	incref(x2);
	uint64_t v1 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	push_resource(x1);
	lpush(&lbl_type, x3);
	lpush(&lbl_head, MKI64(v0));
	lpush(&lbl_name, MKU64(v1));
	VAL v2 = mtw_mirth_mirth_PropState_1_PSReady(x2);
	uint64_t v3 = VU64(lpop(&lbl_name));
	VAL v4 = lpop(&lbl_head);
	VAL r5 = pop_resource();
	mw_mirth_typedef_TypeDef_newZBang(r5, v4, v3, v2);
	VAL v6 = lpop(&lbl_type);
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	VAL v8 = mtw_mirth_mirth_PropLabel_TypeDefTarget(VU64(v7));
	VAL r9 = pop_resource();
	VAL v10 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v10, v8, r9);
	VAL v11 = pop_value();
	uint64_t v12 = pop_u64();
	void* v13 = mfld_mirth_typedef_TypeDef_ZTildetarget(v12);
	mut_set(v11, MKPTR(v13));
	VAL r14 = pop_resource();
	return r14;
}
static int64_t mw_mirth_type_PrimType_isZ_resourceZAsk (int64_t x1) {
	switch (x1) {
		case 8LL: { // PRIM_TYPE_WORLD
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static int64_t mw_mirth_type_PrimType_isZ_physicalZAsk (int64_t x1) {
	switch (x1) {
		case 0LL: { // PRIM_TYPE_TYPE
			int64_t v0 = 0LL /* False */;
			push_i64(v0);
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
		default: {
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
	}
	int64_t v4 = pop_i64();
	return v4;
}
static VAL mw_mirth_type_Type_tyconZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			int64_t v0 = 0LL /* None */;
			push_i64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v1 = 0LL /* None */;
			push_i64(v1);
		} break;
		case 2LL: { // TPrim
			int64_t v2 = mtp_mirth_type_Type_TPrim(x1);
			VAL v3 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v2);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			push_value(v4);
		} break;
		case 3LL: { // TMeta
			uint64_t v5 = mtp_mirth_type_Type_TMeta(x1);
			push_u64(v5);
			VAL v6 = mw_mirth_type_MetaVar_typeZAsk(v5);
			switch (get_data_tag(v6)) {
				case 0LL: { // None
					uint64_t v7 = pop_u64();
					int64_t v8 = 0LL /* None */;
					push_i64(v8);
				} break;
				case 1LL: { // Some
					VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
					VAL v10 = mw_mirth_type_Type_expand(v9);
					incref(v10);
					VAL v11 = pop_value();
					push_value(v10);
					push_value(v11);
					VAL v12 = mtw_std_maybe_Maybe_1_Some(v10);
					uint64_t v13 = pop_u64();
					void* v14 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v13);
					mut_set(v12, MKPTR(v14));
					VAL v15 = pop_value();
					VAL v16 = mw_mirth_type_Type_tyconZAsk(v15);
					push_value(v16);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 4LL: { // THole
			uint64_t v17 = mtp_mirth_type_Type_THole(x1);
			int64_t v18 = 0LL /* None */;
			push_i64(v18);
		} break;
		case 5LL: { // TVar
			uint64_t v19 = mtp_mirth_type_Type_TVar(x1);
			int64_t v20 = 0LL /* None */;
			push_i64(v20);
		} break;
		case 6LL: { // TTable
			uint64_t v21 = mtp_mirth_type_Type_TTable(x1);
			VAL v22 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v21);
			VAL v23 = mtw_std_maybe_Maybe_1_Some(v22);
			push_value(v23);
		} break;
		case 7LL: { // TData
			uint64_t v24 = mtp_mirth_type_Type_TData(x1);
			VAL v25 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v24);
			VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
			push_value(v26);
		} break;
		case 8LL: { // TDataPartial
			VAL v27 = mtp_mirth_type_Type_TDataPartial(x1);
			uint64_t v28 = VU64(VTUP(v27)->cells[1]);
			decref(v27);
			VAL v29 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v28);
			VAL v30 = mtw_std_maybe_Maybe_1_Some(v29);
			push_value(v30);
		} break;
		case 10LL: { // TMorphism
			VAL v31 = mtp_mirth_type_Type_TMorphism(x1);
			decref(v31);
			int64_t v32 = 0LL /* None */;
			push_i64(v32);
		} break;
		case 9LL: { // TTensor
			VAL v33 = mtp_mirth_type_Type_TTensor(x1);
			decref(v33);
			int64_t v34 = 0LL /* None */;
			push_i64(v34);
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp(x1);
			VAL v35 = pop_value();
			decref(v35);
			VAL v36 = pop_value();
			VAL v37 = mw_mirth_type_Type_tyconZAsk(v36);
			push_value(v37);
		} break;
		case 12LL: { // TMut
			VAL v38 = mtp_mirth_type_Type_TMut(x1);
			VAL v39 = mw_mirth_type_Type_tyconZAsk(v38);
			push_value(v39);
		} break;
		case 13LL: { // TValue
			VAL v40 = mtp_mirth_type_Type_TValue(x1);
			VAL v41 = mw_mirth_type_Value_tyconZAsk(v40);
			push_value(v41);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v42 = pop_value();
	return v42;
}
static void mw_mirth_type_PrimType_tyconZ_qname (VAL x1, int64_t x2) {
	switch (x2) {
		case 0LL: { // PRIM_TYPE_TYPE
			STR* v0;
			STRLIT(v0, "TYPE", 4);
			int64_t v1 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v0), v1);
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			STR* v2;
			STRLIT(v2, "STACK", 5);
			int64_t v3 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v2), v3);
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			STR* v4;
			STRLIT(v4, "Resource", 8);
			int64_t v5 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v4), v5);
		} break;
		case 3LL: { // PRIM_TYPE_INT
			STR* v6;
			STRLIT(v6, "Int", 3);
			int64_t v7 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v6), v7);
		} break;
		case 4LL: { // PRIM_TYPE_F32
			STR* v8;
			STRLIT(v8, "F32", 3);
			int64_t v9 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v8), v9);
		} break;
		case 5LL: { // PRIM_TYPE_F64
			STR* v10;
			STRLIT(v10, "F64", 3);
			int64_t v11 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v10), v11);
		} break;
		case 7LL: { // PRIM_TYPE_STR
			STR* v12;
			STRLIT(v12, "Str", 3);
			int64_t v13 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v12), v13);
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			STR* v14;
			STRLIT(v14, "Ptr", 3);
			int64_t v15 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v14), v15);
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			STR* v16;
			STRLIT(v16, "+World", 6);
			int64_t v17 = 0LL;
			mw_mirth_name_QName_prim(x1, MKSTR(v16), v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static VAL mw_mirth_type_Value_tyconZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // VALUE_INT
			int64_t v0 = mtp_mirth_type_Value_VALUEz_INT(x1);
			int64_t v1 = 3LL /* PRIM_TYPE_INT */;
			VAL v2 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v1);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 1LL: { // VALUE_F64
			double v4 = mtp_mirth_type_Value_VALUEz_F64(x1);
			int64_t v5 = 5LL /* PRIM_TYPE_F64 */;
			VAL v6 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 2LL: { // VALUE_STR
			VAL v8 = mtp_mirth_type_Value_VALUEz_STR(x1);
			decref(v8);
			int64_t v9 = 7LL /* PRIM_TYPE_STR */;
			VAL v10 = mtw_mirth_tycon_Tycon_TYCONz_PRIM(v9);
			VAL v11 = mtw_std_maybe_Maybe_1_Some(v10);
			push_value(v11);
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v12 = mtp_mirth_type_Value_VALUEz_BLOCK(x1);
			int64_t v13 = 0LL /* None */;
			push_i64(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v14 = pop_value();
	return v14;
}
static int64_t mw_mirth_type_PrimType_ZToInt (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_type_PrimType_ZEqualZEqual (int64_t x1, int64_t x2) {
	int64_t v0 = mw_mirth_type_PrimType_ZToInt(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_type_PrimType_ZToInt(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang (VAL x1, int64_t x2) {
	push_i64(x2);
	mw_mirth_type_PrimType_tyconZ_qname(x1, x2);
	VAL v0 = pop_value();
	int64_t v1 = pop_i64();
	lpush(&lbl_qname, v0);
	VAL v2 = mtw_mirth_type_Type_TPrim(v1);
	VAL v3 = lpop(&lbl_qname);
	VAL r4 = pop_resource();
	VAL v5 = (mw_mirth_mirth_ZPlusMirth_defZ_typeZBang(r4, v3, v2));
	return v5;
}
static VAL mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang (VAL x1, int64_t x2, VAL x3) {
	push_resource(x1);
	push_i64(x2);
	uint64_t v0 = mw_std_prim_Str_ZToName(x3);
	VAL v1 = pop_value();
	incref(v1);
	VAL r2 = pop_resource();
	push_value(v1);
	push_u64(v0);
	mw_mirth_type_PrimType_tyconZ_qname(r2, VI64(v1));
	VAL v3 = pop_value();
	uint64_t v4 = pop_u64();
	VAL v5 = tup_replace(v3, 2, MKU64(v4));
	int64_t v6 = pop_i64();
	lpush(&lbl_qname, v5);
	VAL v7 = mtw_mirth_type_Type_TPrim(v6);
	VAL v8 = lpop(&lbl_qname);
	VAL r9 = pop_resource();
	VAL v10 = (mw_mirth_mirth_ZPlusMirth_defZ_typeZBang(r9, v8, v7));
	return v10;
}
static VAL mw_mirth_mirth_ZPlusMirth_initZ_typesZBang (VAL x1) {
	int64_t v0 = 3LL /* PRIM_TYPE_INT */;
	VAL v1 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(x1, v0));
	int64_t v2 = 4LL /* PRIM_TYPE_F32 */;
	VAL v3 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v1, v2));
	int64_t v4 = 4LL /* PRIM_TYPE_F32 */;
	STR* v5;
	STRLIT(v5, "Float32", 7);
	VAL v6 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang(v3, v4, MKSTR(v5)));
	int64_t v7 = 5LL /* PRIM_TYPE_F64 */;
	VAL v8 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v6, v7));
	int64_t v9 = 5LL /* PRIM_TYPE_F64 */;
	STR* v10;
	STRLIT(v10, "Float64", 7);
	VAL v11 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang(v8, v9, MKSTR(v10)));
	int64_t v12 = 6LL /* PRIM_TYPE_PTR */;
	VAL v13 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v11, v12));
	int64_t v14 = 7LL /* PRIM_TYPE_STR */;
	VAL v15 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v13, v14));
	int64_t v16 = 8LL /* PRIM_TYPE_WORLD */;
	VAL v17 = (mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang(v15, v16));
	VAL v18 = (mw_mirth_data_initZ_dataZBang(v17));
	return v18;
}
static VAL mw_mirth_type_TZPlus (VAL x1, VAL x2) {
	VAL v0 = mtw_mirth_type_StackType_STWith(x1, x2);
	return v0;
}
static VAL mw_mirth_type_TZMul (VAL x1, VAL x2) {
	VAL v0 = mtw_mirth_type_StackType_STCons(x1, x2);
	return v0;
}
static VAL mw_mirth_type_TZMulZPlus (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // Left
			push_value(x1);
			VAL v0 = mtp_std_either_Either_2_Left(x2);
			VAL v1 = pop_value();
			VAL v2 = mw_mirth_type_TZMul(v1, v0);
			push_value(v2);
		} break;
		case 1LL: { // Right
			push_value(x1);
			VAL v3 = mtp_std_either_Either_2_Right(x2);
			VAL v4 = pop_value();
			VAL v5 = mw_mirth_type_TZPlus(v4, v3);
			push_value(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	VAL v6 = pop_value();
	return v6;
}
static VAL mw_mirth_type_TZ_ZTo (VAL x1, VAL x2) {
	VAL v0 = mtw_mirth_type_ArrowType_ARROWz_TYPE(x1, x2);
	return v0;
}
static VAL mw_mirth_type_TT (VAL x1) {
	push_value(x1);
	VAL v0 = mw_mirth_type_T0();
	VAL v1 = pop_value();
	push_value(v0);
	mw_std_list_List_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		VAL v10 = mw_mirth_type_TZMul(v9, v7);
		push_value(v10);
		mw_std_list_List_1_uncons(v8);
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	VAL v15 = pop_value();
	return v15;
}
static VAL mw_mirth_type_T0 (void) {
	int64_t v0 = 2LL /* STACK_TYPE_UNIT */;
	return MKI64(v0);
}
static VAL mw_mirth_type_T1 (VAL x1) {
	VAL v0 = mw_mirth_type_T0();
	VAL v1 = mw_mirth_type_TZMul(v0, x1);
	return v1;
}
static VAL mw_mirth_type_T2 (VAL x1, VAL x2) {
	VAL v0 = mw_mirth_type_T1(x1);
	VAL v1 = mw_mirth_type_TZMul(v0, x2);
	return v1;
}
static VAL mw_mirth_type_T3 (VAL x1, VAL x2, VAL x3) {
	VAL v0 = mw_mirth_type_T2(x1, x2);
	VAL v1 = mw_mirth_type_TZMul(v0, x3);
	return v1;
}
static int64_t mw_mirth_type_Type_errorZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_Type_expand(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // TYPE_ERROR
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		default: {
			decref(v0);
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
	}
	int64_t v3 = pop_i64();
	return v3;
}
static VAL mw_mirth_type_Type_morphismZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_Type_expand(x1);
	switch (get_data_tag(v0)) {
		case 10LL: { // TMorphism
			VAL v1 = mtp_mirth_type_Type_TMorphism(v0);
			VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		default: {
			decref(v0);
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
	}
	VAL v4 = pop_value();
	return v4;
}
static VAL mw_mirth_type_Type_primZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_Type_expand(x1);
	switch (get_data_tag(v0)) {
		case 2LL: { // TPrim
			int64_t v1 = mtp_mirth_type_Type_TPrim(v0);
			VAL v2 = mtw_std_maybe_Maybe_1_Some(MKI64(v1));
			push_value(v2);
		} break;
		default: {
			decref(v0);
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
	}
	VAL v4 = pop_value();
	return v4;
}
static int64_t mw_mirth_type_Type_metaZEqual (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 3LL: { // TMeta
			push_u64(x1);
			uint64_t v0 = mtp_mirth_type_Type_TMeta(x2);
			uint64_t v1 = pop_u64();
			int64_t v2 = mw_mirth_type_MetaVar_ZEqualZEqual(v1, v0);
			push_i64(v2);
		} break;
		default: {
			decref(x2);
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_type_Type_isZ_physicalZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 3LL: { // TMeta
			uint64_t v0 = mtp_mirth_type_Type_TMeta(x1);
			push_u64(v0);
			VAL v1 = mw_mirth_type_MetaVar_typeZAsk(v0);
			switch (get_data_tag(v1)) {
				case 0LL: { // None
					STR* v2;
					STRLIT(v2, "unbound meta at Type.is-physical?", 33);
					push_str(v2);
					do_panic();
				} break;
				case 1LL: { // Some
					VAL v3 = mtp_std_maybe_Maybe_1_Some(v1);
					VAL v4 = mw_mirth_type_Type_expand(v3);
					incref(v4);
					VAL v5 = pop_value();
					push_value(v4);
					push_value(v5);
					VAL v6 = mtw_std_maybe_Maybe_1_Some(v4);
					uint64_t v7 = pop_u64();
					void* v8 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v7);
					mut_set(v6, MKPTR(v8));
					VAL v9 = pop_value();
					int64_t v10 = mw_mirth_type_Type_isZ_physicalZAsk(v9);
					push_i64(v10);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 2LL: { // TPrim
			int64_t v11 = mtp_mirth_type_Type_TPrim(x1);
			int64_t v12 = mw_mirth_type_PrimType_isZ_physicalZAsk(v11);
			push_i64(v12);
		} break;
		default: {
			decref(x1);
			int64_t v13 = 1LL /* True */;
			push_i64(v13);
		} break;
	}
	int64_t v14 = pop_i64();
	return v14;
}
static VAL mw_mirth_type_TYPEz_TYPE (void) {
	int64_t v0 = 0LL /* PRIM_TYPE_TYPE */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_STACK (void) {
	int64_t v0 = 1LL /* PRIM_TYPE_STACK */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_RESOURCE (void) {
	int64_t v0 = 2LL /* PRIM_TYPE_RESOURCE */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_INT (void) {
	int64_t v0 = 3LL /* PRIM_TYPE_INT */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_F32 (void) {
	int64_t v0 = 4LL /* PRIM_TYPE_F32 */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_F64 (void) {
	int64_t v0 = 5LL /* PRIM_TYPE_F64 */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_PTR (void) {
	int64_t v0 = 6LL /* PRIM_TYPE_PTR */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_STR (void) {
	int64_t v0 = 7LL /* PRIM_TYPE_STR */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_TYPEz_WORLD (void) {
	int64_t v0 = 8LL /* PRIM_TYPE_WORLD */;
	VAL v1 = mtw_mirth_type_Type_TPrim(v0);
	return v1;
}
static VAL mw_mirth_type_RESOURCEz_WORLD (void) {
	VAL v0 = mw_mirth_type_TYPEz_WORLD();
	return v0;
}
static VAL mw_mirth_type_Type_expand (VAL x1) {
	switch (get_data_tag(x1)) {
		case 3LL: { // TMeta
			uint64_t v0 = mtp_mirth_type_Type_TMeta(x1);
			VAL v1 = mw_mirth_type_MetaVar_expand(v0);
			push_value(v1);
		} break;
		default: {
			push_value(x1);
		} break;
	}
	VAL v2 = pop_value();
	return v2;
}
static void mw_mirth_type_ZPlusGamma_rdrop (uint64_t x1) {
}
static void mw_mirth_type_Type_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	STR* v0;
	STRLIT(v0, "", 0);
	STR* v1;
	STRLIT(v1, "Failed to unify ", 16);
	push_resource(x1);
	push_resource(MKU64(x2));
	push_value(x3);
	push_value(x4);
	VAL v2 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v1), MKSTR(v0)));
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = (mw_mirth_type_Type_typeZThen(v4, v2));
	STR* v6;
	STRLIT(v6, " with ", 6);
	push_value(v3);
	VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), v5));
	VAL v8 = pop_value();
	VAL v9 = (mw_mirth_type_Type_typeZThen(v8, v7));
	uint64_t r10 = VU64(pop_resource());
	VAL r11 = pop_resource();
	VAL v12 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r10, v9, r11));
	int64_t v13 = 0LL /* TYPE_ERROR */;
	push_resource(v12);
	push_resource(MKU64(r10));
	push_i64(v13);
}
static void mw_mirth_type_Type_unifyZ_simpleZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	switch (get_data_tag(x4)) {
		case 5LL: { // TVar
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			uint64_t v0 = mtp_mirth_type_Type_TVar(x4);
			VAL v1 = pop_value();
			switch (get_data_tag(v1)) {
				case 5LL: { // TVar
					push_u64(v0);
					uint64_t v2 = mtp_mirth_type_Type_TVar(v1);
					uint64_t v3 = pop_u64();
					uint64_t r4 = VU64(pop_resource());
					VAL r5 = pop_resource();
					mw_mirth_var_Var_unifyZBang(r5, r4, v3, v2);
				} break;
				default: {
					VAL v6 = mtw_mirth_type_Type_TVar(v0);
					uint64_t r7 = VU64(pop_resource());
					VAL r8 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r8, r7, v6, v1);
				} break;
			}
		} break;
		case 2LL: { // TPrim
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			int64_t v9 = mtp_mirth_type_Type_TPrim(x4);
			VAL v10 = pop_value();
			switch (get_data_tag(v10)) {
				case 2LL: { // TPrim
					push_i64(v9);
					int64_t v11 = mtp_mirth_type_Type_TPrim(v10);
					int64_t v12 = pop_i64();
					uint64_t r13 = VU64(pop_resource());
					VAL r14 = pop_resource();
					mw_mirth_type_PrimType_unifyZBang(r14, r13, v12, v11);
				} break;
				default: {
					VAL v15 = mtw_mirth_type_Type_TPrim(v9);
					uint64_t r16 = VU64(pop_resource());
					VAL r17 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r17, r16, v15, v10);
				} break;
			}
		} break;
		case 7LL: { // TData
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			uint64_t v18 = mtp_mirth_type_Type_TData(x4);
			VAL v19 = pop_value();
			switch (get_data_tag(v19)) {
				case 7LL: { // TData
					push_u64(v18);
					uint64_t v20 = mtp_mirth_type_Type_TData(v19);
					uint64_t v21 = pop_u64();
					uint64_t r22 = VU64(pop_resource());
					VAL r23 = pop_resource();
					mw_mirth_data_Data_unifyZBang(r23, r22, v21, v20);
				} break;
				default: {
					VAL v24 = mtw_mirth_type_Type_TData(v18);
					uint64_t r25 = VU64(pop_resource());
					VAL r26 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r26, r25, v24, v19);
				} break;
			}
		} break;
		case 8LL: { // TDataPartial
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			VAL v27 = mtp_mirth_type_Type_TDataPartial(x4);
			VAL v28 = pop_value();
			switch (get_data_tag(v28)) {
				case 8LL: { // TDataPartial
					push_value(v27);
					VAL v29 = mtp_mirth_type_Type_TDataPartial(v28);
					VAL v30 = pop_value();
					uint64_t r31 = VU64(pop_resource());
					VAL r32 = pop_resource();
					mw_mirth_data_DataPartial_unifyZBang(r32, r31, v30, v29);
				} break;
				default: {
					VAL v33 = mtw_mirth_type_Type_TDataPartial(v27);
					uint64_t r34 = VU64(pop_resource());
					VAL r35 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r35, r34, v33, v28);
				} break;
			}
		} break;
		case 6LL: { // TTable
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			uint64_t v36 = mtp_mirth_type_Type_TTable(x4);
			VAL v37 = pop_value();
			switch (get_data_tag(v37)) {
				case 6LL: { // TTable
					push_u64(v36);
					uint64_t v38 = mtp_mirth_type_Type_TTable(v37);
					uint64_t v39 = pop_u64();
					uint64_t r40 = VU64(pop_resource());
					VAL r41 = pop_resource();
					mw_mirth_table_Table_unifyZBang(r41, r40, v39, v38);
				} break;
				default: {
					VAL v42 = mtw_mirth_type_Type_TTable(v36);
					uint64_t r43 = VU64(pop_resource());
					VAL r44 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r44, r43, v42, v37);
				} break;
			}
		} break;
		case 9LL: { // TTensor
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			VAL v45 = mtp_mirth_type_Type_TTensor(x4);
			VAL v46 = pop_value();
			switch (get_data_tag(v46)) {
				case 9LL: { // TTensor
					push_value(v45);
					VAL v47 = mtp_mirth_type_Type_TTensor(v46);
					VAL v48 = pop_value();
					uint64_t r49 = VU64(pop_resource());
					VAL r50 = pop_resource();
					mw_mirth_type_StackType_unifyZBang(r50, r49, v48, v47);
					VAL v51 = pop_value();
					VAL v52 = mw_mirth_type_StackType_ZToType(v51);
					push_value(v52);
				} break;
				default: {
					VAL v53 = mtw_mirth_type_Type_TTensor(v45);
					uint64_t r54 = VU64(pop_resource());
					VAL r55 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r55, r54, v53, v46);
				} break;
			}
		} break;
		case 10LL: { // TMorphism
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			VAL v56 = mtp_mirth_type_Type_TMorphism(x4);
			VAL v57 = pop_value();
			switch (get_data_tag(v57)) {
				case 10LL: { // TMorphism
					push_value(v56);
					VAL v58 = mtp_mirth_type_Type_TMorphism(v57);
					VAL v59 = pop_value();
					uint64_t r60 = VU64(pop_resource());
					VAL r61 = pop_resource();
					mw_mirth_type_ArrowType_unifyZBang(r61, r60, v59, v58);
					VAL v62 = pop_value();
					VAL v63 = mtw_mirth_type_Type_TMorphism(v62);
					push_value(v63);
				} break;
				default: {
					VAL v64 = mtw_mirth_type_Type_TMorphism(v56);
					uint64_t r65 = VU64(pop_resource());
					VAL r66 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r66, r65, v64, v57);
				} break;
			}
		} break;
		case 11LL: { // TApp
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			mtp_mirth_type_Type_TApp(x4);
			VAL v67 = pop_value();
			VAL v68 = pop_value();
			VAL v69 = pop_value();
			switch (get_data_tag(v69)) {
				case 11LL: { // TApp
					push_value(v68);
					push_value(v67);
					mtp_mirth_type_Type_TApp(v69);
					VAL v70 = pop_value();
					VAL v71 = pop_value();
					VAL v72 = pop_value();
					VAL v73 = pop_value();
					uint64_t r74 = VU64(pop_resource());
					VAL r75 = pop_resource();
					mw_mirth_type_Type_unify2ZBang(r75, r74, v73, v72, v71, v70);
					VAL v76 = pop_value();
					VAL v77 = pop_value();
					VAL v78 = mtw_mirth_type_Type_TApp(v77, v76);
					push_value(v78);
				} break;
				default: {
					VAL v79 = mtw_mirth_type_Type_TApp(v68, v67);
					uint64_t r80 = VU64(pop_resource());
					VAL r81 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r81, r80, v79, v69);
				} break;
			}
		} break;
		case 12LL: { // TMut
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			VAL v82 = mtp_mirth_type_Type_TMut(x4);
			VAL v83 = pop_value();
			switch (get_data_tag(v83)) {
				case 12LL: { // TMut
					push_value(v82);
					VAL v84 = mtp_mirth_type_Type_TMut(v83);
					VAL v85 = pop_value();
					uint64_t r86 = VU64(pop_resource());
					VAL r87 = pop_resource();
					mw_mirth_type_Type_unifyZBang(r87, r86, v85, v84);
					VAL v88 = pop_value();
					VAL v89 = mtw_mirth_type_Type_TMut(v88);
					push_value(v89);
				} break;
				default: {
					VAL v90 = mtw_mirth_type_Type_TMut(v82);
					uint64_t r91 = VU64(pop_resource());
					VAL r92 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r92, r91, v90, v83);
				} break;
			}
		} break;
		default: {
			mw_mirth_type_Type_unifyZ_failedZBang(x1, x2, x3, x4);
		} break;
	}
}
static void mw_mirth_type_Type_unifyZ_auxZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	switch (get_data_tag(x4)) {
		case 0LL: { // TYPE_ERROR
			mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, x3);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
		} break;
		case 4LL: { // THole
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			uint64_t v0 = mtp_mirth_type_Type_THole(x4);
			VAL v1 = pop_value();
			uint64_t r2 = VU64(pop_resource());
			VAL r3 = pop_resource();
			mw_mirth_type_typeZ_holeZ_unifyZBang(r3, r2, v1, v0);
		} break;
		case 3LL: { // TMeta
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			uint64_t v4 = mtp_mirth_type_Type_TMeta(x4);
			VAL v5 = pop_value();
			switch (get_data_tag(v5)) {
				case 0LL: { // TYPE_ERROR
					uint64_t r6 = VU64(pop_resource());
					VAL r7 = pop_resource();
					mw_mirth_type_MetaVar_unifyZ_errorZBang(r7, r6, v4);
				} break;
				case 1LL: { // TYPE_DONT_CARE
					VAL v8 = mtw_mirth_type_Type_TMeta(v4);
					push_value(v8);
				} break;
				case 4LL: { // THole
					push_u64(v4);
					uint64_t v9 = mtp_mirth_type_Type_THole(v5);
					uint64_t v10 = pop_u64();
					VAL v11 = mtw_mirth_type_Type_TMeta(v10);
					uint64_t r12 = VU64(pop_resource());
					VAL r13 = pop_resource();
					mw_mirth_type_typeZ_holeZ_unifyZBang(r13, r12, v11, v9);
				} break;
				case 3LL: { // TMeta
					push_u64(v4);
					uint64_t v14 = mtp_mirth_type_Type_TMeta(v5);
					uint64_t v15 = pop_u64();
					VAL v16 = mtw_mirth_type_Type_TMeta(v15);
					uint64_t r17 = VU64(pop_resource());
					VAL r18 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r18, r17, v16, v14);
				} break;
				case 13LL: { // TValue
					push_u64(v4);
					VAL v19 = mtp_mirth_type_Type_TValue(v5);
					uint64_t v20 = pop_u64();
					VAL v21 = mtw_mirth_type_Type_TMeta(v20);
					uint64_t r22 = VU64(pop_resource());
					VAL r23 = pop_resource();
					mw_mirth_type_Value_unifyZ_typeZBang(r23, r22, v21, v19);
				} break;
				default: {
					uint64_t r24 = VU64(pop_resource());
					VAL r25 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r25, r24, v5, v4);
				} break;
			}
		} break;
		case 13LL: { // TValue
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			VAL v26 = mtp_mirth_type_Type_TValue(x4);
			VAL v27 = pop_value();
			switch (get_data_tag(v27)) {
				case 0LL: { // TYPE_ERROR
					uint64_t r28 = VU64(pop_resource());
					VAL r29 = pop_resource();
					mw_mirth_type_Value_unifyZ_errorZBang(r29, r28, v26);
				} break;
				case 1LL: { // TYPE_DONT_CARE
					VAL v30 = mtw_mirth_type_Type_TValue(v26);
					push_value(v30);
				} break;
				case 4LL: { // THole
					push_value(v26);
					uint64_t v31 = mtp_mirth_type_Type_THole(v27);
					VAL v32 = pop_value();
					VAL v33 = mtw_mirth_type_Type_TValue(v32);
					uint64_t r34 = VU64(pop_resource());
					VAL r35 = pop_resource();
					mw_mirth_type_typeZ_holeZ_unifyZBang(r35, r34, v33, v31);
				} break;
				case 3LL: { // TMeta
					push_value(v26);
					uint64_t v36 = mtp_mirth_type_Type_TMeta(v27);
					VAL v37 = pop_value();
					VAL v38 = mtw_mirth_type_Type_TValue(v37);
					uint64_t r39 = VU64(pop_resource());
					VAL r40 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r40, r39, v38, v36);
				} break;
				case 13LL: { // TValue
					push_value(v26);
					VAL v41 = mtp_mirth_type_Type_TValue(v27);
					VAL v42 = pop_value();
					uint64_t r43 = VU64(pop_resource());
					VAL r44 = pop_resource();
					mw_mirth_type_Value_unifyZBang(r44, r43, v42, v41);
				} break;
				default: {
					uint64_t r45 = VU64(pop_resource());
					VAL r46 = pop_resource();
					mw_mirth_type_Value_unifyZ_typeZBang(r46, r45, v27, v26);
				} break;
			}
		} break;
		default: {
			switch (get_data_tag(x3)) {
				case 0LL: { // TYPE_ERROR
					mw_mirth_type_Type_unifyZ_errorZBang(x1, x2, x4);
				} break;
				case 1LL: { // TYPE_DONT_CARE
					push_resource(x1);
					push_resource(MKU64(x2));
					push_value(x4);
				} break;
				case 4LL: { // THole
					push_resource(x1);
					push_resource(MKU64(x2));
					push_value(x4);
					uint64_t v47 = mtp_mirth_type_Type_THole(x3);
					VAL v48 = pop_value();
					uint64_t r49 = VU64(pop_resource());
					VAL r50 = pop_resource();
					mw_mirth_type_typeZ_holeZ_unifyZBang(r50, r49, v48, v47);
				} break;
				case 3LL: { // TMeta
					push_resource(x1);
					push_resource(MKU64(x2));
					push_value(x4);
					uint64_t v51 = mtp_mirth_type_Type_TMeta(x3);
					VAL v52 = pop_value();
					uint64_t r53 = VU64(pop_resource());
					VAL r54 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r54, r53, v52, v51);
				} break;
				case 13LL: { // TValue
					push_resource(x1);
					push_resource(MKU64(x2));
					push_value(x4);
					VAL v55 = mtp_mirth_type_Type_TValue(x3);
					VAL v56 = pop_value();
					uint64_t r57 = VU64(pop_resource());
					VAL r58 = pop_resource();
					mw_mirth_type_Value_unifyZ_typeZBang(r58, r57, v56, v55);
				} break;
				default: {
					mw_mirth_type_Type_unifyZ_simpleZBang(x1, x2, x4, x3);
				} break;
			}
		} break;
	}
}
static void mw_mirth_type_Type_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3) {
	push_resource(x1);
	push_resource(MKU64(x2));
	VAL v0 = mw_mirth_type_Type_expand(x3);
	switch (get_data_tag(v0)) {
		case 0LL: { // TYPE_ERROR
			int64_t v1 = 0LL /* TYPE_ERROR */;
			push_i64(v1);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v2 = 0LL /* TYPE_ERROR */;
			push_i64(v2);
		} break;
		case 4LL: { // THole
			uint64_t v3 = mtp_mirth_type_Type_THole(v0);
			int64_t v4 = 0LL /* TYPE_ERROR */;
			uint64_t r5 = VU64(pop_resource());
			VAL r6 = pop_resource();
			mw_mirth_type_typeZ_holeZ_unifyZBang(r6, r5, MKI64(v4), v3);
		} break;
		case 3LL: { // TMeta
			uint64_t v7 = mtp_mirth_type_Type_TMeta(v0);
			uint64_t r8 = VU64(pop_resource());
			VAL r9 = pop_resource();
			mw_mirth_type_MetaVar_unifyZ_errorZBang(r9, r8, v7);
		} break;
		case 13LL: { // TValue
			VAL v10 = mtp_mirth_type_Type_TValue(v0);
			uint64_t r11 = VU64(pop_resource());
			VAL r12 = pop_resource();
			mw_mirth_type_Value_unifyZ_errorZBang(r12, r11, v10);
		} break;
		case 5LL: { // TVar
			uint64_t v13 = mtp_mirth_type_Type_TVar(v0);
			int64_t v14 = 0LL /* TYPE_ERROR */;
			push_i64(v14);
		} break;
		case 2LL: { // TPrim
			int64_t v15 = mtp_mirth_type_Type_TPrim(v0);
			int64_t v16 = 0LL /* TYPE_ERROR */;
			push_i64(v16);
		} break;
		case 7LL: { // TData
			uint64_t v17 = mtp_mirth_type_Type_TData(v0);
			int64_t v18 = 0LL /* TYPE_ERROR */;
			push_i64(v18);
		} break;
		case 8LL: { // TDataPartial
			VAL v19 = mtp_mirth_type_Type_TDataPartial(v0);
			decref(v19);
			int64_t v20 = 0LL /* TYPE_ERROR */;
			push_i64(v20);
		} break;
		case 6LL: { // TTable
			uint64_t v21 = mtp_mirth_type_Type_TTable(v0);
			int64_t v22 = 0LL /* TYPE_ERROR */;
			push_i64(v22);
		} break;
		case 9LL: { // TTensor
			VAL v23 = mtp_mirth_type_Type_TTensor(v0);
			uint64_t r24 = VU64(pop_resource());
			VAL r25 = pop_resource();
			mw_mirth_type_StackType_unifyZ_errorZBang(r25, r24, v23);
			VAL v26 = pop_value();
			decref(v26);
			int64_t v27 = 0LL /* TYPE_ERROR */;
			push_i64(v27);
		} break;
		case 10LL: { // TMorphism
			VAL v28 = mtp_mirth_type_Type_TMorphism(v0);
			uint64_t r29 = VU64(pop_resource());
			VAL r30 = pop_resource();
			mw_mirth_type_ArrowType_unifyZ_errorZBang(r30, r29, v28);
			VAL v31 = pop_value();
			decref(v31);
			int64_t v32 = 0LL /* TYPE_ERROR */;
			push_i64(v32);
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp(v0);
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			uint64_t r35 = VU64(pop_resource());
			VAL r36 = pop_resource();
			mw_mirth_type_Type_unifyZ_errorZBang(r36, r35, v34);
			VAL v37 = pop_value();
			decref(v37);
			uint64_t r38 = VU64(pop_resource());
			VAL r39 = pop_resource();
			mw_mirth_type_Type_unifyZ_errorZBang(r39, r38, v33);
			VAL v40 = pop_value();
			decref(v40);
			int64_t v41 = 0LL /* TYPE_ERROR */;
			push_i64(v41);
		} break;
		case 12LL: { // TMut
			VAL v42 = mtp_mirth_type_Type_TMut(v0);
			uint64_t r43 = VU64(pop_resource());
			VAL r44 = pop_resource();
			mw_mirth_type_Type_unifyZ_errorZBang(r44, r43, v42);
			VAL v45 = pop_value();
			decref(v45);
			int64_t v46 = 0LL /* TYPE_ERROR */;
			push_i64(v46);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_type_Type_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	VAL v0 = mw_mirth_type_Type_expand(x3);
	push_value(v0);
	VAL v1 = mw_mirth_type_Type_expand(x4);
	VAL v2 = pop_value();
	uint64_t r3 = VU64(pop_resource());
	VAL r4 = pop_resource();
	mw_mirth_type_Type_unifyZ_auxZBang(r4, r3, v2, v1);
}
static void mw_mirth_type_Value_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	switch (get_data_tag(x3)) {
		case 0LL: { // VALUE_INT
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x4);
			int64_t v0 = mtp_mirth_type_Value_VALUEz_INT(x3);
			VAL v1 = pop_value();
			switch (get_data_tag(v1)) {
				case 0LL: { // VALUE_INT
					push_i64(v0);
					int64_t v2 = mtp_mirth_type_Value_VALUEz_INT(v1);
					VAL v3 = pop_value();
					incref(v3);
					bool v4 = (VI64(v3) == v2);
					if (v4) {
						VAL v5 = mtw_mirth_type_Value_VALUEz_INT(VI64(v3));
						VAL v6 = mtw_mirth_type_Type_TValue(v5);
						push_value(v6);
					} else {
						decref(v3);
						VAL v7 = mw_mirth_type_TYPEz_INT();
						push_value(v7);
					}
				} break;
				case 2LL: { // VALUE_STR
					push_i64(v0);
					VAL v8 = mtp_mirth_type_Value_VALUEz_STR(v1);
					decref(v8);
					VAL v9 = pop_value();
					decref(v9);
					uint64_t r10 = VU64(pop_resource());
					STR* v11;
					STRLIT(v11, "Can't unify int value with string value.", 40);
					VAL r12 = pop_resource();
					VAL v13 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r10, MKSTR(v11), r12));
					int64_t v14 = 0LL /* TYPE_ERROR */;
					push_resource(v13);
					push_resource(MKU64(r10));
					push_i64(v14);
				} break;
				case 1LL: { // VALUE_F64
					push_i64(v0);
					double v15 = mtp_mirth_type_Value_VALUEz_F64(v1);
					VAL v16 = pop_value();
					decref(v16);
					uint64_t r17 = VU64(pop_resource());
					STR* v18;
					STRLIT(v18, "Can't unify int value with float value.", 39);
					VAL r19 = pop_resource();
					VAL v20 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r17, MKSTR(v18), r19));
					int64_t v21 = 0LL /* TYPE_ERROR */;
					push_resource(v20);
					push_resource(MKU64(r17));
					push_i64(v21);
				} break;
				case 3LL: { // VALUE_BLOCK
					push_i64(v0);
					uint64_t v22 = mtp_mirth_type_Value_VALUEz_BLOCK(v1);
					VAL v23 = pop_value();
					decref(v23);
					uint64_t r24 = VU64(pop_resource());
					STR* v25;
					STRLIT(v25, "Can't unify int value with block.", 33);
					VAL r26 = pop_resource();
					VAL v27 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r24, MKSTR(v25), r26));
					int64_t v28 = 0LL /* TYPE_ERROR */;
					push_resource(v27);
					push_resource(MKU64(r24));
					push_i64(v28);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_i64(v0);
				}
			}
		} break;
		case 2LL: { // VALUE_STR
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x4);
			VAL v29 = mtp_mirth_type_Value_VALUEz_STR(x3);
			VAL v30 = pop_value();
			switch (get_data_tag(v30)) {
				case 2LL: { // VALUE_STR
					push_value(v29);
					VAL v31 = mtp_mirth_type_Value_VALUEz_STR(v30);
					VAL v32 = pop_value();
					incref(v32);
					incref(v31);
					bool v33 = (str_cmp(VSTR(v32), VSTR(v31)) == 0);
					if (v33) {
						decref(v31);
						VAL v34 = mtw_mirth_type_Value_VALUEz_STR(v32);
						VAL v35 = mtw_mirth_type_Type_TValue(v34);
						push_value(v35);
					} else {
						decref(v31);
						decref(v32);
						VAL v36 = mw_mirth_type_TYPEz_STR();
						push_value(v36);
					}
				} break;
				case 0LL: { // VALUE_INT
					push_value(v29);
					int64_t v37 = mtp_mirth_type_Value_VALUEz_INT(v30);
					VAL v38 = pop_value();
					decref(v38);
					uint64_t r39 = VU64(pop_resource());
					STR* v40;
					STRLIT(v40, "Can't unify string value with int value.", 40);
					VAL r41 = pop_resource();
					VAL v42 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r39, MKSTR(v40), r41));
					int64_t v43 = 0LL /* TYPE_ERROR */;
					push_resource(v42);
					push_resource(MKU64(r39));
					push_i64(v43);
				} break;
				case 1LL: { // VALUE_F64
					push_value(v29);
					double v44 = mtp_mirth_type_Value_VALUEz_F64(v30);
					VAL v45 = pop_value();
					decref(v45);
					uint64_t r46 = VU64(pop_resource());
					STR* v47;
					STRLIT(v47, "Can't unify string value with float value.", 42);
					VAL r48 = pop_resource();
					VAL v49 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r46, MKSTR(v47), r48));
					int64_t v50 = 0LL /* TYPE_ERROR */;
					push_resource(v49);
					push_resource(MKU64(r46));
					push_i64(v50);
				} break;
				case 3LL: { // VALUE_BLOCK
					push_value(v29);
					uint64_t v51 = mtp_mirth_type_Value_VALUEz_BLOCK(v30);
					VAL v52 = pop_value();
					decref(v52);
					uint64_t r53 = VU64(pop_resource());
					STR* v54;
					STRLIT(v54, "Can't unify string value with block.", 36);
					VAL r55 = pop_resource();
					VAL v56 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r53, MKSTR(v54), r55));
					int64_t v57 = 0LL /* TYPE_ERROR */;
					push_resource(v56);
					push_resource(MKU64(r53));
					push_i64(v57);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v29);
				}
			}
		} break;
		case 3LL: { // VALUE_BLOCK
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x4);
			uint64_t v58 = mtp_mirth_type_Value_VALUEz_BLOCK(x3);
			VAL v59 = pop_value();
			switch (get_data_tag(v59)) {
				case 3LL: { // VALUE_BLOCK
					push_u64(v58);
					uint64_t v60 = mtp_mirth_type_Value_VALUEz_BLOCK(v59);
					VAL v61 = pop_value();
					incref(v61);
					push_value(v61);
					push_u64(v60);
					int64_t v62 = mw_mirth_arrow_Block_ZEqualZEqual(VU64(v61), v60);
					if (((bool)v62)) {
						uint64_t v63 = pop_u64();
						uint64_t v64 = pop_u64();
						VAL v65 = mtw_mirth_type_Value_VALUEz_BLOCK(v64);
						VAL v66 = mtw_mirth_type_Type_TValue(v65);
						push_value(v66);
					} else {
						uint64_t r67 = VU64(pop_resource());
						uint64_t v68 = pop_u64();
						VAL r69 = pop_resource();
						mw_mirth_arrow_Block_arrow(r69, v68);
						VAL v70 = pop_value();
						push_resource(MKU64(r67));
						VAL v71 = mw_mirth_arrow_Arrow_type(v70);
						uint64_t v72 = pop_u64();
						uint64_t r73 = VU64(pop_resource());
						VAL r74 = pop_resource();
						mw_mirth_arrow_blockZ_unifyZ_typeZBang(r74, r73, v72, v71);
						VAL v75 = pop_value();
						VAL v76 = mw_mirth_type_ArrowType_ZToType(v75);
						push_value(v76);
					}
				} break;
				case 0LL: { // VALUE_INT
					push_u64(v58);
					int64_t v77 = mtp_mirth_type_Value_VALUEz_INT(v59);
					VAL v78 = pop_value();
					decref(v78);
					uint64_t r79 = VU64(pop_resource());
					STR* v80;
					STRLIT(v80, "Can't unify block with int value.", 33);
					VAL r81 = pop_resource();
					VAL v82 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r79, MKSTR(v80), r81));
					int64_t v83 = 0LL /* TYPE_ERROR */;
					push_resource(v82);
					push_resource(MKU64(r79));
					push_i64(v83);
				} break;
				case 1LL: { // VALUE_F64
					push_u64(v58);
					double v84 = mtp_mirth_type_Value_VALUEz_F64(v59);
					VAL v85 = pop_value();
					decref(v85);
					uint64_t r86 = VU64(pop_resource());
					STR* v87;
					STRLIT(v87, "Can't unify block with float value.", 35);
					VAL r88 = pop_resource();
					VAL v89 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r86, MKSTR(v87), r88));
					int64_t v90 = 0LL /* TYPE_ERROR */;
					push_resource(v89);
					push_resource(MKU64(r86));
					push_i64(v90);
				} break;
				case 2LL: { // VALUE_STR
					push_u64(v58);
					VAL v91 = mtp_mirth_type_Value_VALUEz_STR(v59);
					decref(v91);
					VAL v92 = pop_value();
					decref(v92);
					uint64_t r93 = VU64(pop_resource());
					STR* v94;
					STRLIT(v94, "Can't unify block with string value.", 36);
					VAL r95 = pop_resource();
					VAL v96 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r93, MKSTR(v94), r95));
					int64_t v97 = 0LL /* TYPE_ERROR */;
					push_resource(v96);
					push_resource(MKU64(r93));
					push_i64(v97);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_u64(v58);
				}
			}
		} break;
		case 1LL: { // VALUE_F64
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x4);
			double v98 = mtp_mirth_type_Value_VALUEz_F64(x3);
			VAL v99 = pop_value();
			switch (get_data_tag(v99)) {
				case 1LL: { // VALUE_F64
					push_f64(v98);
					double v100 = mtp_mirth_type_Value_VALUEz_F64(v99);
					VAL v101 = pop_value();
					incref(v101);
					bool v102 = (VF64(v101) == v100);
					if (v102) {
						VAL v103 = mtw_mirth_type_Value_VALUEz_F64(VF64(v101));
						VAL v104 = mtw_mirth_type_Type_TValue(v103);
						push_value(v104);
					} else {
						decref(v101);
						VAL v105 = mw_mirth_type_TYPEz_F64();
						push_value(v105);
					}
				} break;
				case 0LL: { // VALUE_INT
					push_f64(v98);
					int64_t v106 = mtp_mirth_type_Value_VALUEz_INT(v99);
					VAL v107 = pop_value();
					decref(v107);
					uint64_t r108 = VU64(pop_resource());
					STR* v109;
					STRLIT(v109, "Can't unify float value with int value.", 39);
					VAL r110 = pop_resource();
					VAL v111 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r108, MKSTR(v109), r110));
					int64_t v112 = 0LL /* TYPE_ERROR */;
					push_resource(v111);
					push_resource(MKU64(r108));
					push_i64(v112);
				} break;
				case 3LL: { // VALUE_BLOCK
					push_f64(v98);
					uint64_t v113 = mtp_mirth_type_Value_VALUEz_BLOCK(v99);
					VAL v114 = pop_value();
					decref(v114);
					uint64_t r115 = VU64(pop_resource());
					STR* v116;
					STRLIT(v116, "Can't unify float value with block.", 35);
					VAL r117 = pop_resource();
					VAL v118 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r115, MKSTR(v116), r117));
					int64_t v119 = 0LL /* TYPE_ERROR */;
					push_resource(v118);
					push_resource(MKU64(r115));
					push_i64(v119);
				} break;
				case 2LL: { // VALUE_STR
					push_f64(v98);
					VAL v120 = mtp_mirth_type_Value_VALUEz_STR(v99);
					decref(v120);
					VAL v121 = pop_value();
					decref(v121);
					uint64_t r122 = VU64(pop_resource());
					STR* v123;
					STRLIT(v123, "Can't unify float value with string value.", 42);
					VAL r124 = pop_resource();
					VAL v125 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(r122, MKSTR(v123), r124));
					int64_t v126 = 0LL /* TYPE_ERROR */;
					push_resource(v125);
					push_resource(MKU64(r122));
					push_i64(v126);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_f64(v98);
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x4);
		}
	}
}
static void mw_mirth_type_Value_unifyZ_typeZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	switch (get_data_tag(x4)) {
		case 0LL: { // VALUE_INT
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			int64_t v0 = mtp_mirth_type_Value_VALUEz_INT(x4);
			VAL v1 = mw_mirth_type_TYPEz_INT();
			VAL v2 = pop_value();
			uint64_t r3 = VU64(pop_resource());
			VAL r4 = pop_resource();
			mw_mirth_type_Type_unifyZBang(r4, r3, v2, v1);
		} break;
		case 2LL: { // VALUE_STR
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			VAL v5 = mtp_mirth_type_Value_VALUEz_STR(x4);
			decref(v5);
			VAL v6 = mw_mirth_type_TYPEz_STR();
			VAL v7 = pop_value();
			uint64_t r8 = VU64(pop_resource());
			VAL r9 = pop_resource();
			mw_mirth_type_Type_unifyZBang(r9, r8, v7, v6);
		} break;
		case 1LL: { // VALUE_F64
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			double v10 = mtp_mirth_type_Value_VALUEz_F64(x4);
			VAL v11 = mw_mirth_type_TYPEz_F64();
			VAL v12 = pop_value();
			uint64_t r13 = VU64(pop_resource());
			VAL r14 = pop_resource();
			mw_mirth_type_Type_unifyZBang(r14, r13, v12, v11);
		} break;
		case 3LL: { // VALUE_BLOCK
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
			uint64_t v15 = mtp_mirth_type_Value_VALUEz_BLOCK(x4);
			VAL v16 = pop_value();
			uint64_t r17 = VU64(pop_resource());
			VAL r18 = pop_resource();
			mw_mirth_type_Type_unifyZ_blockZBang(r18, r17, v15, v16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_resource(MKU64(x2));
			push_value(x3);
		}
	}
}
static void mw_mirth_type_Value_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 0LL: { // VALUE_INT
			push_resource(x1);
			push_resource(MKU64(x2));
			int64_t v0 = mtp_mirth_type_Value_VALUEz_INT(x3);
			int64_t v1 = 0LL /* TYPE_ERROR */;
			push_i64(v1);
		} break;
		case 2LL: { // VALUE_STR
			push_resource(x1);
			push_resource(MKU64(x2));
			VAL v2 = mtp_mirth_type_Value_VALUEz_STR(x3);
			decref(v2);
			int64_t v3 = 0LL /* TYPE_ERROR */;
			push_i64(v3);
		} break;
		case 1LL: { // VALUE_F64
			push_resource(x1);
			push_resource(MKU64(x2));
			double v4 = mtp_mirth_type_Value_VALUEz_F64(x3);
			int64_t v5 = 0LL /* TYPE_ERROR */;
			push_i64(v5);
		} break;
		case 3LL: { // VALUE_BLOCK
			push_resource(x1);
			push_resource(MKU64(x2));
			uint64_t v6 = mtp_mirth_type_Value_VALUEz_BLOCK(x3);
			int64_t v7 = 0LL /* TYPE_ERROR */;
			uint64_t r8 = VU64(pop_resource());
			VAL r9 = pop_resource();
			mw_mirth_type_Type_unifyZ_blockZBang(r9, r8, v6, MKI64(v7));
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_resource(MKU64(x2));
		}
	}
}
static void mw_mirth_type_Type_unifyZ_blockZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_u64(x3);
	VAL v0 = mw_mirth_type_Type_expand(x4);
	switch (get_data_tag(v0)) {
		case 0LL: { // TYPE_ERROR
			int64_t v1 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v2 = 0LL /* STACK_TYPE_ERROR */;
			VAL v3 = mw_mirth_type_TZ_ZTo(MKI64(v1), MKI64(v2));
			uint64_t v4 = pop_u64();
			uint64_t r5 = VU64(pop_resource());
			VAL r6 = pop_resource();
			mw_mirth_arrow_blockZ_unifyZ_typeZBang(r6, r5, v4, v3);
			VAL v7 = pop_value();
			decref(v7);
			int64_t v8 = 0LL /* TYPE_ERROR */;
			push_i64(v8);
		} break;
		case 3LL: { // TMeta
			uint64_t v9 = mtp_mirth_type_Type_TMeta(v0);
			VAL v10 = pop_value();
			incref(v10);
			VAL v11 = mw_mirth_arrow_Block_type(VU64(v10));
			VAL v12 = mw_mirth_type_ArrowType_ZToType(v11);
			uint64_t r13 = VU64(pop_resource());
			VAL r14 = pop_resource();
			mw_mirth_type_MetaVar_unifyZBang(r14, r13, v12, v9);
			VAL v15 = pop_value();
			decref(v15);
			uint64_t r16 = VU64(pop_resource());
			VAL r17 = pop_resource();
			mw_mirth_arrow_Block_arrow(r17, VU64(v10));
			VAL v18 = pop_value();
			push_resource(MKU64(r16));
			VAL v19 = mw_mirth_arrow_Arrow_type(v18);
			VAL v20 = mw_mirth_type_ArrowType_ZToType(v19);
			push_value(v20);
		} break;
		case 10LL: { // TMorphism
			VAL v21 = mtp_mirth_type_Type_TMorphism(v0);
			uint64_t v22 = pop_u64();
			uint64_t r23 = VU64(pop_resource());
			VAL r24 = pop_resource();
			mw_mirth_arrow_blockZ_unifyZ_typeZBang(r24, r23, v22, v21);
			VAL v25 = pop_value();
			VAL v26 = mw_mirth_type_ArrowType_ZToType(v25);
			push_value(v26);
		} break;
		default: {
			uint64_t v27 = pop_u64();
			VAL v28 = mw_mirth_arrow_Block_type(v27);
			VAL v29 = mw_mirth_type_ArrowType_ZToType(v28);
			uint64_t r30 = VU64(pop_resource());
			VAL r31 = pop_resource();
			mw_mirth_type_Type_unifyZBang(r31, r30, v29, v0);
		} break;
	}
}
static void mw_mirth_type_Type_unify2ZBang (VAL x1, uint64_t x2, VAL x3, VAL x4, VAL x5, VAL x6) {
	mw_mirth_type_Type_unifyZBang(x1, x2, x3, x5);
	uint64_t r0 = VU64(pop_resource());
	VAL r1 = pop_resource();
	mw_mirth_type_Type_unifyZBang(r1, r0, x4, x6);
}
static void mw_mirth_type_PrimType_unifyZBang (VAL x1, uint64_t x2, int64_t x3, int64_t x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_i64(x3);
	push_i64(x4);
	int64_t v0 = mw_mirth_type_PrimType_ZEqualZEqual(x3, x4);
	if (((bool)v0)) {
		int64_t v1 = pop_i64();
		int64_t v2 = pop_i64();
		VAL v3 = mtw_mirth_type_Type_TPrim(v2);
		push_value(v3);
	} else {
		int64_t v4 = pop_i64();
		int64_t v5 = pop_i64();
		VAL v6 = mtw_mirth_type_Type_TPrim(v5);
		push_value(v6);
		VAL v7 = mtw_mirth_type_Type_TPrim(v4);
		VAL v8 = pop_value();
		uint64_t r9 = VU64(pop_resource());
		VAL r10 = pop_resource();
		mw_mirth_type_Type_unifyZ_failedZBang(r10, r9, v8, v7);
	}
}
static void mw_mirth_data_Data_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_u64(x3);
	push_u64(x4);
	int64_t v0 = mw_mirth_data_Data_ZEqualZEqual(x3, x4);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		uint64_t v2 = pop_u64();
		VAL v3 = mtw_mirth_type_Type_TData(v2);
		push_value(v3);
	} else {
		uint64_t v4 = pop_u64();
		uint64_t v5 = pop_u64();
		VAL v6 = mtw_mirth_type_Type_TData(v5);
		push_value(v6);
		VAL v7 = mtw_mirth_type_Type_TData(v4);
		VAL v8 = pop_value();
		uint64_t r9 = VU64(pop_resource());
		VAL r10 = pop_resource();
		mw_mirth_type_Type_unifyZ_failedZBang(r10, r9, v8, v7);
	}
}
static void mw_mirth_data_DataPartial_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	incref(x3);
	incref(x4);
	push_resource(x1);
	push_resource(MKU64(x2));
	push_value(x3);
	push_value(x4);
	int64_t v0 = mw_mirth_data_DataPartial_ZEqualZEqual(x3, x4);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		decref(v1);
		VAL v2 = pop_value();
		VAL v3 = mtw_mirth_type_Type_TDataPartial(v2);
		push_value(v3);
	} else {
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		VAL v6 = mtw_mirth_type_Type_TDataPartial(v5);
		push_value(v6);
		VAL v7 = mtw_mirth_type_Type_TDataPartial(v4);
		VAL v8 = pop_value();
		uint64_t r9 = VU64(pop_resource());
		VAL r10 = pop_resource();
		mw_mirth_type_Type_unifyZ_failedZBang(r10, r9, v8, v7);
	}
}
static void mw_mirth_table_Table_unifyZBang (VAL x1, uint64_t x2, uint64_t x3, uint64_t x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_u64(x3);
	push_u64(x4);
	int64_t v0 = mw_mirth_table_Table_ZEqualZEqual(x3, x4);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		uint64_t v2 = pop_u64();
		VAL v3 = mtw_mirth_type_Type_TTable(v2);
		push_value(v3);
	} else {
		uint64_t v4 = pop_u64();
		uint64_t v5 = pop_u64();
		VAL v6 = mtw_mirth_type_Type_TTable(v5);
		push_value(v6);
		VAL v7 = mtw_mirth_type_Type_TTable(v4);
		VAL v8 = pop_value();
		uint64_t r9 = VU64(pop_resource());
		VAL r10 = pop_resource();
		mw_mirth_type_Type_unifyZ_failedZBang(r10, r9, v8, v7);
	}
}
static int64_t mw_mirth_type_Type_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 3LL: { // TMeta
			push_u64(x1);
			uint64_t v0 = mtp_mirth_type_Type_TMeta(x2);
			uint64_t v1 = pop_u64();
			int64_t v2 = mw_mirth_type_MetaVar_hasZ_metaZAsk(v1, v0);
			push_i64(v2);
		} break;
		case 0LL: { // TYPE_ERROR
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v4 = 0LL /* False */;
			push_i64(v4);
		} break;
		case 2LL: { // TPrim
			push_u64(x1);
			int64_t v5 = mtp_mirth_type_Type_TPrim(x2);
			VAL v6 = pop_value();
			decref(v6);
			int64_t v7 = 0LL /* False */;
			push_i64(v7);
		} break;
		case 5LL: { // TVar
			push_u64(x1);
			uint64_t v8 = mtp_mirth_type_Type_TVar(x2);
			VAL v9 = pop_value();
			decref(v9);
			int64_t v10 = 0LL /* False */;
			push_i64(v10);
		} break;
		case 4LL: { // THole
			push_u64(x1);
			uint64_t v11 = mtp_mirth_type_Type_THole(x2);
			VAL v12 = pop_value();
			decref(v12);
			int64_t v13 = 0LL /* False */;
			push_i64(v13);
		} break;
		case 9LL: { // TTensor
			push_u64(x1);
			VAL v14 = mtp_mirth_type_Type_TTensor(x2);
			uint64_t v15 = pop_u64();
			int64_t v16 = mw_mirth_type_StackType_hasZ_metaZAsk(v15, v14);
			push_i64(v16);
		} break;
		case 10LL: { // TMorphism
			push_u64(x1);
			VAL v17 = mtp_mirth_type_Type_TMorphism(x2);
			uint64_t v18 = pop_u64();
			int64_t v19 = mw_mirth_type_ArrowType_hasZ_metaZAsk(v18, v17);
			push_i64(v19);
		} break;
		case 11LL: { // TApp
			push_u64(x1);
			mtp_mirth_type_Type_TApp(x2);
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			uint64_t v22 = pop_u64();
			int64_t v23 = mw_mirth_type_Type_hasZ_meta2ZAsk(v22, v21, v20);
			push_i64(v23);
		} break;
		case 7LL: { // TData
			push_u64(x1);
			uint64_t v24 = mtp_mirth_type_Type_TData(x2);
			VAL v25 = pop_value();
			decref(v25);
			int64_t v26 = 0LL /* False */;
			push_i64(v26);
		} break;
		case 8LL: { // TDataPartial
			push_u64(x1);
			VAL v27 = mtp_mirth_type_Type_TDataPartial(x2);
			decref(v27);
			VAL v28 = pop_value();
			decref(v28);
			int64_t v29 = 0LL /* False */;
			push_i64(v29);
		} break;
		case 6LL: { // TTable
			push_u64(x1);
			uint64_t v30 = mtp_mirth_type_Type_TTable(x2);
			VAL v31 = pop_value();
			decref(v31);
			int64_t v32 = 0LL /* False */;
			push_i64(v32);
		} break;
		case 13LL: { // TValue
			push_u64(x1);
			VAL v33 = mtp_mirth_type_Type_TValue(x2);
			uint64_t v34 = pop_u64();
			int64_t v35 = mw_mirth_type_Value_hasZ_metaZAsk(v34, v33);
			push_i64(v35);
		} break;
		case 12LL: { // TMut
			push_u64(x1);
			VAL v36 = mtp_mirth_type_Type_TMut(x2);
			uint64_t v37 = pop_u64();
			int64_t v38 = mw_mirth_type_Type_hasZ_metaZAsk(v37, v36);
			push_i64(v38);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
		}
	}
	int64_t v39 = pop_i64();
	return v39;
}
static int64_t mw_mirth_type_Type_hasZ_meta2ZAsk (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	push_value(x2);
	int64_t v0 = mw_mirth_type_Type_hasZ_metaZAsk(x1, x3);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		decref(v1);
		VAL v2 = pop_value();
		decref(v2);
		int64_t v3 = 1LL /* True */;
		push_i64(v3);
	} else {
		VAL v4 = pop_value();
		uint64_t v5 = pop_u64();
		int64_t v6 = mw_mirth_type_Type_hasZ_metaZAsk(v5, v4);
		push_i64(v6);
	}
	int64_t v7 = pop_i64();
	return v7;
}
static int64_t mw_mirth_type_Value_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_Value_type(x2);
	uint64_t v1 = pop_u64();
	int64_t v2 = mw_mirth_type_Type_hasZ_metaZAsk(v1, v0);
	return v2;
}
static VAL mw_mirth_type_Type_typeZThen (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			STR* v0;
			STRLIT(v0, "<ERROR>", 7);
			VAL v1 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v0), x2));
			push_resource(v1);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			STR* v2;
			STRLIT(v2, "_", 1);
			VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v2), x2));
			push_resource(v3);
		} break;
		case 2LL: { // TPrim
			push_resource(x2);
			int64_t v4 = mtp_mirth_type_Type_TPrim(x1);
			VAL r5 = pop_resource();
			VAL v6 = (mw_mirth_type_PrimType_typeZThen(r5, v4));
			push_resource(v6);
		} break;
		case 5LL: { // TVar
			push_resource(x2);
			uint64_t v7 = mtp_mirth_type_Type_TVar(x1);
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_var_Var_typeZThen(r8, v7));
			push_resource(v9);
		} break;
		case 3LL: { // TMeta
			push_resource(x2);
			uint64_t v10 = mtp_mirth_type_Type_TMeta(x1);
			VAL r11 = pop_resource();
			VAL v12 = (mw_mirth_type_MetaVar_typeZThen(r11, v10));
			push_resource(v12);
		} break;
		case 9LL: { // TTensor
			push_resource(x2);
			VAL v13 = mtp_mirth_type_Type_TTensor(x1);
			STR* v14;
			STRLIT(v14, "[", 1);
			VAL r15 = pop_resource();
			push_value(v13);
			VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v14), r15));
			VAL v17 = pop_value();
			VAL v18 = (mw_mirth_type_StackType_stackZThen(v16, v17));
			STR* v19;
			STRLIT(v19, "]", 1);
			VAL v20 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v19), v18));
			push_resource(v20);
		} break;
		case 10LL: { // TMorphism
			push_resource(x2);
			VAL v21 = mtp_mirth_type_Type_TMorphism(x1);
			STR* v22;
			STRLIT(v22, "[", 1);
			VAL r23 = pop_resource();
			push_value(v21);
			VAL v24 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v22), r23));
			VAL v25 = pop_value();
			VAL v26 = (mw_mirth_type_ArrowType_sigZThen(v24, v25));
			STR* v27;
			STRLIT(v27, "]", 1);
			VAL v28 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v27), v26));
			push_resource(v28);
		} break;
		case 7LL: { // TData
			push_resource(x2);
			uint64_t v29 = mtp_mirth_type_Type_TData(x1);
			uint64_t v30 = mw_mirth_data_Data_name(v29);
			VAL v31 = mw_mirth_name_Name_ZToStr(v30);
			VAL r32 = pop_resource();
			VAL v33 = (mw_std_str_ZPlusStr_pushZ_strZBang(v31, r32));
			push_resource(v33);
		} break;
		case 8LL: { // TDataPartial
			push_resource(x2);
			VAL v34 = mtp_mirth_type_Type_TDataPartial(x1);
			incref(v34);
			uint64_t v35 = VU64(VTUP(v34)->cells[1]);
			decref(v34);
			push_value(v34);
			uint64_t v36 = mw_mirth_data_Data_name(v35);
			VAL v37 = mw_mirth_name_Name_ZToStr(v36);
			VAL r38 = pop_resource();
			VAL v39 = (mw_std_str_ZPlusStr_pushZ_strZBang(v37, r38));
			STR* v40;
			STRLIT(v40, "/", 1);
			VAL v41 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v40), v39));
			VAL v42 = pop_value();
			uint64_t v43 = VU64(VTUP(v42)->cells[2]);
			decref(v42);
			push_resource(v41);
			uint64_t v44 = mw_mirth_label_Label_name(v43);
			VAL v45 = mw_mirth_name_Name_ZToStr(v44);
			VAL r46 = pop_resource();
			VAL v47 = (mw_std_str_ZPlusStr_pushZ_strZBang(v45, r46));
			push_resource(v47);
		} break;
		case 6LL: { // TTable
			push_resource(x2);
			uint64_t v48 = mtp_mirth_type_Type_TTable(x1);
			uint64_t v49 = mw_mirth_table_Table_name(v48);
			VAL v50 = mw_mirth_name_Name_ZToStr(v49);
			VAL r51 = pop_resource();
			VAL v52 = (mw_std_str_ZPlusStr_pushZ_strZBang(v50, r51));
			push_resource(v52);
		} break;
		case 4LL: { // THole
			push_resource(x2);
			uint64_t v53 = mtp_mirth_type_Type_THole(x1);
			VAL v54 = mw_mirth_name_Name_ZToStr(v53);
			VAL r55 = pop_resource();
			VAL v56 = (mw_std_str_ZPlusStr_pushZ_strZBang(v54, r55));
			push_resource(v56);
		} break;
		case 11LL: { // TApp
			push_resource(x2);
			mtp_mirth_type_Type_TApp(x1);
			VAL v57 = pop_value();
			VAL v58 = pop_value();
			VAL r59 = pop_resource();
			VAL v60 = (mw_mirth_type_Type_appZ_typeZThenZThen(r59, v58, v57));
			push_resource(v60);
		} break;
		case 13LL: { // TValue
			push_resource(x2);
			VAL v61 = mtp_mirth_type_Type_TValue(x1);
			VAL v62 = mw_mirth_type_Value_type(v61);
			VAL r63 = pop_resource();
			VAL v64 = (mw_mirth_type_Type_typeZThen(v62, r63));
			push_resource(v64);
		} break;
		case 12LL: { // TMut
			push_resource(x2);
			VAL v65 = mtp_mirth_type_Type_TMut(x1);
			STR* v66;
			STRLIT(v66, "Mut(", 4);
			VAL r67 = pop_resource();
			push_value(v65);
			VAL v68 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v66), r67));
			VAL v69 = pop_value();
			VAL v70 = (mw_mirth_type_Type_typeZThen(v69, v68));
			STR* v71;
			STRLIT(v71, ")", 1);
			VAL v72 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v71), v70));
			push_resource(v72);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r73 = pop_resource();
	return r73;
}
static VAL mw_mirth_type_Value_type (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // VALUE_INT
			int64_t v0 = mtp_mirth_type_Value_VALUEz_INT(x1);
			int64_t v1 = 3LL /* PRIM_TYPE_INT */;
			VAL v2 = mtw_mirth_type_Type_TPrim(v1);
			push_value(v2);
		} break;
		case 1LL: { // VALUE_F64
			double v3 = mtp_mirth_type_Value_VALUEz_F64(x1);
			int64_t v4 = 5LL /* PRIM_TYPE_F64 */;
			VAL v5 = mtw_mirth_type_Type_TPrim(v4);
			push_value(v5);
		} break;
		case 2LL: { // VALUE_STR
			VAL v6 = mtp_mirth_type_Value_VALUEz_STR(x1);
			decref(v6);
			int64_t v7 = 7LL /* PRIM_TYPE_STR */;
			VAL v8 = mtw_mirth_type_Type_TPrim(v7);
			push_value(v8);
		} break;
		case 3LL: { // VALUE_BLOCK
			uint64_t v9 = mtp_mirth_type_Value_VALUEz_BLOCK(x1);
			VAL v10 = mw_mirth_arrow_Block_type(v9);
			VAL v11 = mw_mirth_type_ArrowType_ZToType(v10);
			push_value(v11);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v12 = pop_value();
	return v12;
}
static VAL mw_mirth_type_PrimType_typeZThen (VAL x1, int64_t x2) {
	switch (x2) {
		case 0LL: { // PRIM_TYPE_TYPE
			STR* v0;
			STRLIT(v0, "<TYPE>", 6);
			push_resource(x1);
			push_str(v0);
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			STR* v1;
			STRLIT(v1, "<STACK>", 7);
			push_resource(x1);
			push_str(v1);
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			STR* v2;
			STRLIT(v2, "<Resource>", 10);
			push_resource(x1);
			push_str(v2);
		} break;
		case 3LL: { // PRIM_TYPE_INT
			STR* v3;
			STRLIT(v3, "Int", 3);
			push_resource(x1);
			push_str(v3);
		} break;
		case 4LL: { // PRIM_TYPE_F32
			STR* v4;
			STRLIT(v4, "F32", 3);
			push_resource(x1);
			push_str(v4);
		} break;
		case 5LL: { // PRIM_TYPE_F64
			STR* v5;
			STRLIT(v5, "F64", 3);
			push_resource(x1);
			push_str(v5);
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			STR* v6;
			STRLIT(v6, "Ptr", 3);
			push_resource(x1);
			push_str(v6);
		} break;
		case 7LL: { // PRIM_TYPE_STR
			STR* v7;
			STRLIT(v7, "Str", 3);
			push_resource(x1);
			push_str(v7);
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			STR* v8;
			STRLIT(v8, "+World", 6);
			push_resource(x1);
			push_str(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
	VAL r9 = pop_resource();
	VAL v10 = pop_value();
	VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, r9));
	return v11;
}
static void mw_mirth_type_Type_freshen (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // TYPE_ERROR
			int64_t v0 = 0LL /* TYPE_ERROR */;
			push_value(x1);
			push_i64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v1 = 1LL /* TYPE_DONT_CARE */;
			push_value(x1);
			push_i64(v1);
		} break;
		case 2LL: { // TPrim
			push_value(x1);
			int64_t v2 = mtp_mirth_type_Type_TPrim(x2);
			VAL v3 = mtw_mirth_type_Type_TPrim(v2);
			push_value(v3);
		} break;
		case 4LL: { // THole
			push_value(x1);
			uint64_t v4 = mtp_mirth_type_Type_THole(x2);
			VAL v5 = mtw_mirth_type_Type_THole(v4);
			push_value(v5);
		} break;
		case 7LL: { // TData
			push_value(x1);
			uint64_t v6 = mtp_mirth_type_Type_TData(x2);
			VAL v7 = mtw_mirth_type_Type_TData(v6);
			push_value(v7);
		} break;
		case 8LL: { // TDataPartial
			push_value(x1);
			VAL v8 = mtp_mirth_type_Type_TDataPartial(x2);
			VAL v9 = mtw_mirth_type_Type_TDataPartial(v8);
			push_value(v9);
		} break;
		case 6LL: { // TTable
			push_value(x1);
			uint64_t v10 = mtp_mirth_type_Type_TTable(x2);
			VAL v11 = mtw_mirth_type_Type_TTable(v10);
			push_value(v11);
		} break;
		case 13LL: { // TValue
			push_value(x1);
			VAL v12 = mtp_mirth_type_Type_TValue(x2);
			VAL v13 = mtw_mirth_type_Type_TValue(v12);
			push_value(v13);
		} break;
		case 5LL: { // TVar
			push_value(x1);
			uint64_t v14 = mtp_mirth_type_Type_TVar(x2);
			VAL v15 = pop_value();
			mw_mirth_var_Var_freshen(v15, v14);
		} break;
		case 3LL: { // TMeta
			push_value(x1);
			uint64_t v16 = mtp_mirth_type_Type_TMeta(x2);
			VAL v17 = pop_value();
			mw_mirth_type_MetaVar_freshen(v17, v16);
		} break;
		case 9LL: { // TTensor
			push_value(x1);
			VAL v18 = mtp_mirth_type_Type_TTensor(x2);
			VAL v19 = pop_value();
			mw_mirth_type_StackType_freshen(v19, v18);
			VAL v20 = pop_value();
			VAL v21 = mtw_mirth_type_Type_TTensor(v20);
			push_value(v21);
		} break;
		case 10LL: { // TMorphism
			push_value(x1);
			VAL v22 = mtp_mirth_type_Type_TMorphism(x2);
			VAL v23 = pop_value();
			mw_mirth_type_ArrowType_freshen(v23, v22);
			VAL v24 = pop_value();
			VAL v25 = mtw_mirth_type_Type_TMorphism(v24);
			push_value(v25);
		} break;
		case 11LL: { // TApp
			push_value(x1);
			mtp_mirth_type_Type_TApp(x2);
			VAL v26 = pop_value();
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			mw_mirth_type_Type_freshen2(v28, v27, v26);
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			VAL v31 = mtw_mirth_type_Type_TApp(v30, v29);
			push_value(v31);
		} break;
		case 12LL: { // TMut
			push_value(x1);
			VAL v32 = mtp_mirth_type_Type_TMut(x2);
			VAL v33 = pop_value();
			mw_mirth_type_Type_freshen(v33, v32);
			VAL v34 = pop_value();
			VAL v35 = mtw_mirth_type_Type_TMut(v34);
			push_value(v35);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
}
static void mw_mirth_type_Type_freshen2 (VAL x1, VAL x2, VAL x3) {
	mw_mirth_type_Type_freshen(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	mw_mirth_type_Type_freshen(v1, x3);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	push_value(v2);
}
static void mw_mirth_type_Type_rigidifyZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 3LL: { // TMeta
			push_resource(x1);
			push_value(x2);
			uint64_t v0 = mtp_mirth_type_Type_TMeta(x3);
			push_u64(v0);
			VAL v1 = mw_mirth_type_MetaVar_typeZAsk(v0);
			switch (get_data_tag(v1)) {
				case 0LL: { // None
					uint64_t v2 = pop_u64();
					VAL v3 = pop_value();
					mw_mirth_var_Ctx_freshZ_typeZ_varZBang(v3);
					uint64_t v4 = pop_u64();
					VAL v5 = mtw_mirth_type_Type_TVar(v4);
					incref(v5);
					push_value(v5);
					VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
					void* v7 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v2);
					mut_set(v6, MKPTR(v7));
				} break;
				case 1LL: { // Some
					VAL v8 = mtp_std_maybe_Maybe_1_Some(v1);
					VAL v9 = pop_value();
					decref(v9);
					push_value(v8);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			VAL r12 = pop_resource();
			mw_mirth_type_Type_rigidifyZBang(r12, v11, v10);
		} break;
		case 0LL: { // TYPE_ERROR
			int64_t v13 = 0LL /* TYPE_ERROR */;
			push_resource(x1);
			push_value(x2);
			push_i64(v13);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v14 = 1LL /* TYPE_DONT_CARE */;
			push_resource(x1);
			push_value(x2);
			push_i64(v14);
		} break;
		case 2LL: { // TPrim
			push_resource(x1);
			push_value(x2);
			int64_t v15 = mtp_mirth_type_Type_TPrim(x3);
			VAL v16 = mtw_mirth_type_Type_TPrim(v15);
			push_value(v16);
		} break;
		case 4LL: { // THole
			push_resource(x1);
			push_value(x2);
			uint64_t v17 = mtp_mirth_type_Type_THole(x3);
			VAL v18 = mtw_mirth_type_Type_THole(v17);
			push_value(v18);
		} break;
		case 5LL: { // TVar
			push_resource(x1);
			push_value(x2);
			uint64_t v19 = mtp_mirth_type_Type_TVar(x3);
			VAL v20 = mtw_mirth_type_Type_TVar(v19);
			push_value(v20);
		} break;
		case 6LL: { // TTable
			push_resource(x1);
			push_value(x2);
			uint64_t v21 = mtp_mirth_type_Type_TTable(x3);
			VAL v22 = mtw_mirth_type_Type_TTable(v21);
			push_value(v22);
		} break;
		case 7LL: { // TData
			push_resource(x1);
			push_value(x2);
			uint64_t v23 = mtp_mirth_type_Type_TData(x3);
			VAL v24 = mtw_mirth_type_Type_TData(v23);
			push_value(v24);
		} break;
		case 8LL: { // TDataPartial
			push_resource(x1);
			push_value(x2);
			VAL v25 = mtp_mirth_type_Type_TDataPartial(x3);
			VAL v26 = mtw_mirth_type_Type_TDataPartial(v25);
			push_value(v26);
		} break;
		case 11LL: { // TApp
			push_resource(x1);
			push_value(x2);
			mtp_mirth_type_Type_TApp(x3);
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			VAL v29 = pop_value();
			VAL r30 = pop_resource();
			mw_mirth_type_Type_rigidifyZBang(r30, v29, v28);
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			VAL r33 = pop_resource();
			mw_mirth_type_Type_rigidifyZBang(r33, v32, v27);
			VAL v34 = pop_value();
			VAL v35 = mtw_mirth_type_Type_TApp(v31, v34);
			push_value(v35);
		} break;
		case 9LL: { // TTensor
			push_resource(x1);
			push_value(x2);
			VAL v36 = mtp_mirth_type_Type_TTensor(x3);
			VAL v37 = pop_value();
			VAL r38 = pop_resource();
			mw_mirth_type_StackType_rigidifyZBang(r38, v37, v36);
			VAL v39 = pop_value();
			VAL v40 = mtw_mirth_type_Type_TTensor(v39);
			push_value(v40);
		} break;
		case 10LL: { // TMorphism
			push_resource(x1);
			push_value(x2);
			VAL v41 = mtp_mirth_type_Type_TMorphism(x3);
			VAL v42 = pop_value();
			VAL r43 = pop_resource();
			mw_mirth_type_ArrowType_rigidifyZBang(r43, v42, v41);
			VAL v44 = pop_value();
			VAL v45 = mtw_mirth_type_Type_TMorphism(v44);
			push_value(v45);
		} break;
		case 13LL: { // TValue
			push_resource(x1);
			push_value(x2);
			VAL v46 = mtp_mirth_type_Type_TValue(x3);
			VAL v47 = pop_value();
			VAL r48 = pop_resource();
			mw_mirth_type_Value_rigidifyZBang(r48, v47, v46);
		} break;
		case 12LL: { // TMut
			push_resource(x1);
			push_value(x2);
			VAL v49 = mtp_mirth_type_Type_TMut(x3);
			VAL v50 = pop_value();
			VAL r51 = pop_resource();
			mw_mirth_type_Type_rigidifyZBang(r51, v50, v49);
			VAL v52 = pop_value();
			VAL v53 = mtw_mirth_type_Type_TMut(v52);
			push_value(v53);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_value(x2);
		}
	}
}
static void mw_mirth_type_Value_rigidifyZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 0LL: { // VALUE_INT
			push_resource(x1);
			push_value(x2);
			int64_t v0 = mtp_mirth_type_Value_VALUEz_INT(x3);
			VAL v1 = mtw_mirth_type_Value_VALUEz_INT(v0);
			VAL v2 = mtw_mirth_type_Type_TValue(v1);
			push_value(v2);
		} break;
		case 2LL: { // VALUE_STR
			push_resource(x1);
			push_value(x2);
			VAL v3 = mtp_mirth_type_Value_VALUEz_STR(x3);
			VAL v4 = mtw_mirth_type_Value_VALUEz_STR(v3);
			VAL v5 = mtw_mirth_type_Type_TValue(v4);
			push_value(v5);
		} break;
		case 1LL: { // VALUE_F64
			push_resource(x1);
			push_value(x2);
			double v6 = mtp_mirth_type_Value_VALUEz_F64(x3);
			VAL v7 = mtw_mirth_type_Value_VALUEz_F64(v6);
			VAL v8 = mtw_mirth_type_Type_TValue(v7);
			push_value(v8);
		} break;
		case 3LL: { // VALUE_BLOCK
			push_resource(x1);
			push_value(x2);
			uint64_t v9 = mtp_mirth_type_Value_VALUEz_BLOCK(x3);
			VAL r10 = pop_resource();
			mw_mirth_arrow_Block_arrow(r10, v9);
			VAL v11 = pop_value();
			VAL v12 = mw_mirth_arrow_Arrow_type(v11);
			VAL v13 = pop_value();
			VAL r14 = pop_resource();
			mw_mirth_type_ArrowType_rigidifyZBang(r14, v13, v12);
			VAL v15 = pop_value();
			VAL v16 = mw_mirth_type_ArrowType_ZToType(v15);
			push_value(v16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_value(x2);
		}
	}
}
static VAL mw_mirth_type_Type_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 3LL: { // TMeta
			push_u64(x1);
			push_u64(x2);
			uint64_t v0 = mtp_mirth_type_Type_TMeta(x3);
			push_u64(v0);
			VAL v1 = mw_mirth_type_MetaVar_typeZAsk(v0);
			switch (get_data_tag(v1)) {
				case 0LL: { // None
					STR* v2;
					STRLIT(v2, "Type.except-field on metavar", 28);
					push_str(v2);
					do_panic();
				} break;
				case 1LL: { // Some
					VAL v3 = mtp_std_maybe_Maybe_1_Some(v1);
					VAL v4 = mw_mirth_type_Type_expand(v3);
					incref(v4);
					VAL v5 = pop_value();
					push_value(v4);
					push_value(v5);
					VAL v6 = mtw_std_maybe_Maybe_1_Some(v4);
					uint64_t v7 = pop_u64();
					void* v8 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v7);
					mut_set(v6, MKPTR(v8));
					VAL v9 = pop_value();
					uint64_t v10 = pop_u64();
					uint64_t v11 = pop_u64();
					VAL v12 = mw_mirth_type_Type_exceptZ_field(v11, v10, v9);
					push_value(v12);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 7LL: { // TData
			push_u64(x1);
			push_u64(x2);
			uint64_t v13 = mtp_mirth_type_Type_TData(x3);
			uint64_t v14 = pop_u64();
			uint64_t v15 = pop_u64();
			VAL v16 = mtw_mirth_data_DataPartial_DataPartial(v13, v15);
			VAL v17 = mtw_mirth_type_Type_TDataPartial(v16);
			push_value(v17);
		} break;
		case 11LL: { // TApp
			push_u64(x1);
			push_u64(x2);
			mtp_mirth_type_Type_TApp(x3);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			uint64_t v20 = pop_u64();
			uint64_t v21 = pop_u64();
			VAL v22 = mw_mirth_type_Type_exceptZ_field(v21, v20, v19);
			VAL v23 = mtw_mirth_type_Type_TApp(v22, v18);
			push_value(v23);
		} break;
		default: {
			STR* v24;
			STRLIT(v24, "Type.except-field on unexpected type", 36);
			push_u64(x1);
			push_u64(x2);
			push_value(x3);
			push_str(v24);
			do_panic();
		} break;
	}
	VAL v25 = pop_value();
	return v25;
}
static int64_t mw_mirth_type_MetaVar_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_type_MetaVar_allocZBang (void) {
	void* v0 = mbuf_mirth_type_MetaVar_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_type_MetaVar_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_type_MetaVar_typeZAsk (uint64_t x1) {
	void* v0 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_type_MetaVar_hasZ_metaZAsk (uint64_t x1, uint64_t x2) {
	push_u64(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_type_MetaVar_typeZAsk(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			uint64_t v1 = pop_u64();
			uint64_t v2 = pop_u64();
			int64_t v3 = mw_mirth_type_MetaVar_ZEqualZEqual(v2, v1);
			push_i64(v3);
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = pop_u64();
			int64_t v7 = mw_mirth_type_Type_hasZ_metaZAsk(v6, v4);
			push_i64(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v8 = pop_i64();
	return v8;
}
static VAL mw_mirth_type_MetaVar_typeZThen (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_type_MetaVar_typeZAsk(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			STR* v1;
			STRLIT(v1, "?", 1);
			VAL r2 = pop_resource();
			VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v1), r2));
			uint64_t v4 = pop_u64();
			push_resource(v3);
			int64_t v5 = mw_mirth_type_MetaVar_index(v4);
			STR* v6 = i64_show(v5);
			VAL r7 = pop_resource();
			VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), r7));
			push_resource(v8);
		} break;
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v10 = pop_value();
			decref(v10);
			VAL r11 = pop_resource();
			VAL v12 = (mw_mirth_type_Type_typeZThen(v9, r11));
			push_resource(v12);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r13 = pop_resource();
	return r13;
}
static uint64_t mw_mirth_type_MetaVar_newZBang (void) {
	uint64_t v0 = mw_mirth_type_MetaVar_allocZBang();
	int64_t v1 = 0LL /* None */;
	void* v2 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v0);
	mut_set(MKI64(v1), MKPTR(v2));
	return v0;
}
static VAL mw_mirth_type_MetaVar_expand (uint64_t x1) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_MetaVar_typeZAsk(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			uint64_t v1 = pop_u64();
			VAL v2 = mtw_mirth_type_Type_TMeta(v1);
			push_value(v2);
		} break;
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v4 = mw_mirth_type_Type_expand(v3);
			incref(v4);
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v4);
			uint64_t v7 = pop_u64();
			void* v8 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v7);
			mut_set(v6, MKPTR(v8));
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v9 = pop_value();
	return v9;
}
static void mw_mirth_type_MetaVar_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_value(x3);
	push_u64(x4);
	VAL v0 = mw_mirth_type_MetaVar_typeZAsk(x4);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			uint64_t r4 = VU64(pop_resource());
			VAL r5 = pop_resource();
			mw_mirth_type_Type_unifyZBang(r5, r4, v3, v1);
		} break;
		case 0LL: { // None
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			incref(v7);
			incref(v6);
			push_value(v7);
			push_value(v6);
			int64_t v8 = mw_mirth_type_Type_metaZEqual(VU64(v6), v7);
			if (((bool)v8)) {
				uint64_t v9 = pop_u64();
			} else {
				uint64_t v10 = pop_u64();
				VAL v11 = pop_value();
				incref(v11);
				push_u64(v10);
				push_value(v11);
				int64_t v12 = mw_mirth_type_Type_hasZ_metaZAsk(v10, v11);
				if (((bool)v12)) {
					VAL v13 = pop_value();
					uint64_t v14 = pop_u64();
					push_value(v13);
					VAL v15 = mtw_mirth_type_Type_TMeta(v14);
					VAL v16 = pop_value();
					uint64_t r17 = VU64(pop_resource());
					VAL r18 = pop_resource();
					mw_mirth_type_Type_unifyZ_failedZBang(r18, r17, v16, v15);
				} else {
					VAL v19 = pop_value();
					incref(v19);
					VAL v20 = pop_value();
					push_value(v19);
					push_value(v20);
					VAL v21 = mtw_std_maybe_Maybe_1_Some(v19);
					uint64_t v22 = pop_u64();
					void* v23 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v22);
					mut_set(v21, MKPTR(v23));
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_type_MetaVar_unifyZ_errorZBang (VAL x1, uint64_t x2, uint64_t x3) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_u64(x3);
	VAL v0 = mw_mirth_type_MetaVar_typeZAsk(x3);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = pop_value();
			decref(v2);
			uint64_t r3 = VU64(pop_resource());
			VAL r4 = pop_resource();
			mw_mirth_type_Type_unifyZ_errorZBang(r4, r3, v1);
		} break;
		case 0LL: { // None
			uint64_t v5 = pop_u64();
			int64_t v6 = 0LL /* TYPE_ERROR */;
			VAL v7 = mtw_std_maybe_Maybe_1_Some(MKI64(v6));
			void* v8 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v5);
			mut_set(v7, MKPTR(v8));
			int64_t v9 = 0LL /* TYPE_ERROR */;
			push_i64(v9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static int64_t mw_mirth_type_MetaVar_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_type_MetaVar_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_type_MetaVar_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_type_MetaVar_freshen (VAL x1, uint64_t x2) {
	push_value(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_type_MetaVar_typeZAsk(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			uint64_t v1 = pop_u64();
			uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
			VAL v3 = mtw_mirth_type_Type_TMeta(v2);
			push_value(v3);
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v5 = mw_mirth_type_Type_expand(v4);
			incref(v5);
			VAL v6 = pop_value();
			push_value(v5);
			push_value(v6);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v5);
			uint64_t v8 = pop_u64();
			void* v9 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v8);
			mut_set(v7, MKPTR(v9));
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			mw_mirth_type_Type_freshen(v11, v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_type_typeZ_holeZ_unifyZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4) {
	STR* v0;
	STRLIT(v0, "", 0);
	push_resource(x1);
	push_resource(MKU64(x2));
	push_value(x3);
	push_resource(MKSTR(v0));
	VAL v1 = mtw_mirth_type_Type_THole(x4);
	VAL r2 = pop_resource();
	VAL v3 = (mw_mirth_type_Type_typeZThen(v1, r2));
	STR* v4;
	STRLIT(v4, " ~ ", 3);
	VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), v3));
	VAL v6 = pop_value();
	incref(v6);
	push_value(v6);
	VAL v7 = (mw_mirth_type_Type_typeZThen(v6, v5));
	STR* v8;
	STRLIT(v8, "\n", 1);
	VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
	uint64_t r10 = VU64(pop_resource());
	VAL r11 = pop_resource();
	VAL v12 = (mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang(r10, v9, r11));
	push_resource(v12);
	push_resource(MKU64(r10));
}
static VAL mw_mirth_type_Type_appZ_typeZThenZThen (VAL x1, VAL x2, VAL x3) {
	VAL v0 = (mw_mirth_type_Type_appZ_typeZ_openZThenZThen(x1, x2, x3));
	STR* v1;
	STRLIT(v1, ")", 1);
	VAL v2 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v1), v0));
	return v2;
}
static VAL mw_mirth_type_Type_appZ_typeZ_openZThenZThen (VAL x1, VAL x2, VAL x3) {
	push_resource(x1);
	push_value(x3);
	VAL v0 = mw_mirth_type_Type_expand(x2);
	switch (get_data_tag(v0)) {
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp(v0);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			VAL r3 = pop_resource();
			VAL v4 = (mw_mirth_type_Type_appZ_typeZ_openZThenZThen(r3, v2, v1));
			STR* v5;
			STRLIT(v5, ", ", 2);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), v4));
			VAL v7 = pop_value();
			VAL v8 = (mw_mirth_type_Type_typeZThen(v7, v6));
			push_resource(v8);
		} break;
		default: {
			VAL r9 = pop_resource();
			VAL v10 = (mw_mirth_type_Type_typeZThen(v0, r9));
			STR* v11;
			STRLIT(v11, "(", 1);
			VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
			VAL v13 = pop_value();
			VAL v14 = (mw_mirth_type_Type_typeZThen(v13, v12));
			push_resource(v14);
		} break;
	}
	VAL r15 = pop_resource();
	return r15;
}
static VAL mw_mirth_type_Resource_ZToType (VAL x1) {
	return x1;
}
static VAL mw_mirth_type_Type_ZToResource (VAL x1) {
	return x1;
}
static int64_t mw_mirth_type_Resource_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_Resource_ZToType(x2);
	uint64_t v1 = pop_u64();
	int64_t v2 = mw_mirth_type_Type_hasZ_metaZAsk(v1, v0);
	return v2;
}
static void mw_mirth_type_Resource_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	VAL v0 = mw_mirth_type_Resource_ZToType(x3);
	push_value(v0);
	VAL v1 = mw_mirth_type_Resource_ZToType(x4);
	VAL v2 = pop_value();
	uint64_t r3 = VU64(pop_resource());
	VAL r4 = pop_resource();
	mw_mirth_type_Type_unifyZBang(r4, r3, v2, v1);
	VAL v5 = pop_value();
	VAL v6 = mw_mirth_type_Type_ZToResource(v5);
	push_value(v6);
}
static void mw_mirth_type_Resource_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3) {
	push_resource(x1);
	push_resource(MKU64(x2));
	VAL v0 = mw_mirth_type_Resource_ZToType(x3);
	uint64_t r1 = VU64(pop_resource());
	VAL r2 = pop_resource();
	mw_mirth_type_Type_unifyZ_errorZBang(r2, r1, v0);
	VAL v3 = pop_value();
	VAL v4 = mw_mirth_type_Type_ZToResource(v3);
	push_value(v4);
}
static VAL mw_mirth_type_Resource_typeZThen (VAL x1, VAL x2) {
	push_resource(x1);
	VAL v0 = mw_mirth_type_Resource_ZToType(x2);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_type_Type_typeZThen(v0, r1));
	return v2;
}
static void mw_mirth_type_Resource_freshen (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = mw_mirth_type_Resource_ZToType(x2);
	VAL v1 = pop_value();
	mw_mirth_type_Type_freshen(v1, v0);
	VAL v2 = pop_value();
	VAL v3 = mw_mirth_type_Type_ZToResource(v2);
	push_value(v3);
}
static void mw_mirth_type_Resource_rigidifyZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x1);
	push_value(x2);
	VAL v0 = mw_mirth_type_Resource_ZToType(x3);
	VAL v1 = pop_value();
	VAL r2 = pop_resource();
	mw_mirth_type_Type_rigidifyZBang(r2, v1, v0);
	VAL v3 = pop_value();
	VAL v4 = mw_mirth_type_Type_ZToResource(v3);
	push_value(v4);
}
static VAL mw_mirth_type_Resource_exceptZ_field (uint64_t x1, uint64_t x2, VAL x3) {
	VAL v0 = mw_mirth_type_Type_exceptZ_field(x1, x2, x3);
	return v0;
}
static VAL mw_mirth_type_Type_ZToStackType (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			int64_t v0 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v1 = 1LL /* STACK_TYPE_DONT_CARE */;
			push_i64(v1);
		} break;
		case 5LL: { // TVar
			uint64_t v2 = mtp_mirth_type_Type_TVar(x1);
			VAL v3 = mtw_mirth_type_StackType_STVar(v2);
			push_value(v3);
		} break;
		case 3LL: { // TMeta
			uint64_t v4 = mtp_mirth_type_Type_TMeta(x1);
			VAL v5 = mtw_mirth_type_StackType_STMeta(v4);
			push_value(v5);
		} break;
		case 9LL: { // TTensor
			VAL v6 = mtp_mirth_type_Type_TTensor(x1);
			push_value(v6);
		} break;
		default: {
			STR* v7;
			STRLIT(v7, "kind error! expected stack type, got regular type.", 50);
			push_value(x1);
			push_str(v7);
			do_panic();
		} break;
	}
	VAL v8 = pop_value();
	return v8;
}
static VAL mw_mirth_type_StackType_ZToType (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v0 = 0LL /* TYPE_ERROR */;
			push_i64(v0);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v1 = 1LL /* TYPE_DONT_CARE */;
			push_i64(v1);
		} break;
		case 3LL: { // STVar
			uint64_t v2 = mtp_mirth_type_StackType_STVar(x1);
			VAL v3 = mtw_mirth_type_Type_TVar(v2);
			push_value(v3);
		} break;
		case 4LL: { // STMeta
			uint64_t v4 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v5 = mtw_mirth_type_Type_TMeta(v4);
			push_value(v5);
		} break;
		default: {
			VAL v6 = mtw_mirth_type_Type_TTensor(x1);
			push_value(v6);
		} break;
	}
	VAL v7 = pop_value();
	return v7;
}
static VAL mw_mirth_type_StackType_expand (VAL x1) {
	switch (get_data_tag(x1)) {
		case 4LL: { // STMeta
			uint64_t v0 = mtp_mirth_type_StackType_STMeta(x1);
			VAL v1 = mw_mirth_type_MetaVar_expand(v0);
			VAL v2 = mw_mirth_type_Type_ZToStackType(v1);
			push_value(v2);
		} break;
		default: {
			push_value(x1);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_type_StackType_unitZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		default: {
			decref(v0);
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
	}
	int64_t v3 = pop_i64();
	return v3;
}
static void mw_mirth_type_StackType_split4 (VAL x1) {
	int64_t v0 = 0LL /* Nil */;
	int64_t v1 = 0LL /* Nil */;
	int64_t v2 = 0LL /* Nil */;
	push_value(x1);
	lpush(&lbl_labels, MKI64(v2));
	lpush(&lbl_withses, MKI64(v1));
	lpush(&lbl_conses, MKI64(v0));
	while(1) {
		VAL v3 = pop_value();
		VAL v4 = mw_mirth_type_StackType_expand(v3);
		switch (get_data_tag(v4)) {
			case 5LL: { // STCons
				mtp_mirth_type_StackType_STCons(v4);
				VAL v5 = lpop(&lbl_conses);
				VAL v6 = pop_value();
				VAL v7 = mtw_std_list_List_1_Cons(v6, v5);
				int64_t v8 = 1LL /* True */;
				lpush(&lbl_conses, v7);
				push_i64(v8);
			} break;
			case 7LL: { // STWith
				mtp_mirth_type_StackType_STWith(v4);
				VAL v9 = lpop(&lbl_withses);
				VAL v10 = pop_value();
				VAL v11 = mtw_std_list_List_1_Cons(v10, v9);
				int64_t v12 = 1LL /* True */;
				lpush(&lbl_withses, v11);
				push_i64(v12);
			} break;
			case 6LL: { // STConsLabel
				mtp_mirth_type_StackType_STConsLabel(v4);
				uint64_t v13 = pop_u64();
				VAL v14 = pop_value();
				VAL v15 = mtw_std_either_Either_2_Left(v14);
				VAL v16 = MKNIL;
				VAL v17 = mkcons(v16, v15);
				VAL v18 = mkcons(v17, MKU64(v13));
				VAL v19 = lpop(&lbl_labels);
				VAL v20 = mtw_std_list_List_1_Cons(v18, v19);
				int64_t v21 = 1LL /* True */;
				lpush(&lbl_labels, v20);
				push_i64(v21);
			} break;
			case 8LL: { // STWithLabel
				mtp_mirth_type_StackType_STWithLabel(v4);
				uint64_t v22 = pop_u64();
				VAL v23 = pop_value();
				VAL v24 = mtw_std_either_Either_2_Right(v23);
				VAL v25 = MKNIL;
				VAL v26 = mkcons(v25, v24);
				VAL v27 = mkcons(v26, MKU64(v22));
				VAL v28 = lpop(&lbl_labels);
				VAL v29 = mtw_std_list_List_1_Cons(v27, v28);
				int64_t v30 = 1LL /* True */;
				lpush(&lbl_labels, v29);
				push_i64(v30);
			} break;
			default: {
				int64_t v31 = 0LL /* False */;
				push_value(v4);
				push_i64(v31);
			} break;
		}
		bool v32 = pop_bool();
		if (!v32) break;
	}
	VAL v33 = lpop(&lbl_labels);
	VAL v34 = lpop(&lbl_conses);
	VAL v35 = lpop(&lbl_withses);
	push_value(v33);
	push_value(v34);
	push_value(v35);
}
static VAL mw_mirth_type_StackType_base (VAL x1) {
	mw_mirth_type_StackType_split4(x1);
	VAL v0 = pop_value();
	decref(v0);
	VAL v1 = pop_value();
	decref(v1);
	VAL v2 = pop_value();
	decref(v2);
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_type_StackType_labelZ_topZAsk (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	switch (get_data_tag(v0)) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v1 = pop_value();
			decref(v1);
			VAL v2 = pop_value();
			uint64_t v3 = pop_u64();
			VAL v4 = mw_mirth_type_StackType_labelZ_topZAsk(v3, v2);
			push_value(v4);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			uint64_t v7 = pop_u64();
			VAL v8 = mw_mirth_type_StackType_labelZ_topZAsk(v7, v6);
			push_value(v8);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			incref(v12);
			incref(v9);
			push_value(v12);
			push_value(v11);
			push_value(v10);
			push_value(v9);
			int64_t v13 = mw_mirth_label_Label_ZEqualZEqual(VU64(v12), VU64(v9));
			if (((bool)v13)) {
				uint64_t v14 = pop_u64();
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				decref(v16);
				VAL v17 = pop_value();
				decref(v17);
				VAL v18 = mtw_std_either_Either_2_Left(v15);
				VAL v19 = mtw_std_maybe_Maybe_1_Some(v18);
				push_value(v19);
			} else {
				VAL v20 = pop_value();
				decref(v20);
				VAL v21 = pop_value();
				decref(v21);
				VAL v22 = pop_value();
				uint64_t v23 = pop_u64();
				VAL v24 = mw_mirth_type_StackType_labelZ_topZAsk(v23, v22);
				push_value(v24);
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			incref(v28);
			incref(v25);
			push_value(v28);
			push_value(v27);
			push_value(v26);
			push_value(v25);
			int64_t v29 = mw_mirth_label_Label_ZEqualZEqual(VU64(v28), VU64(v25));
			if (((bool)v29)) {
				uint64_t v30 = pop_u64();
				VAL v31 = pop_value();
				VAL v32 = pop_value();
				decref(v32);
				VAL v33 = pop_value();
				decref(v33);
				VAL v34 = mtw_std_either_Either_2_Right(v31);
				VAL v35 = mtw_std_maybe_Maybe_1_Some(v34);
				push_value(v35);
			} else {
				VAL v36 = pop_value();
				decref(v36);
				VAL v37 = pop_value();
				decref(v37);
				VAL v38 = pop_value();
				uint64_t v39 = pop_u64();
				VAL v40 = mw_mirth_type_StackType_labelZ_topZAsk(v39, v38);
				push_value(v40);
			}
		} break;
		default: {
			decref(v0);
			VAL v41 = pop_value();
			decref(v41);
			int64_t v42 = 0LL /* None */;
			push_i64(v42);
		} break;
	}
	VAL v43 = pop_value();
	return v43;
}
static VAL mw_mirth_type_StackType_topZ_typeZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v1 = pop_value();
			decref(v1);
			VAL v2 = pop_value();
			VAL v3 = mw_mirth_type_StackType_topZ_typeZAsk(v2);
			push_value(v3);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v4);
			push_value(v6);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v7 = pop_value();
			decref(v7);
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = pop_value();
			VAL v10 = mw_mirth_type_StackType_topZ_typeZAsk(v9);
			push_value(v10);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v11 = pop_value();
			decref(v11);
			VAL v12 = pop_value();
			decref(v12);
			VAL v13 = pop_value();
			VAL v14 = mw_mirth_type_StackType_topZ_typeZAsk(v13);
			push_value(v14);
		} break;
		default: {
			decref(v0);
			int64_t v15 = 0LL /* None */;
			push_i64(v15);
		} break;
	}
	VAL v16 = pop_value();
	return v16;
}
static VAL mw_mirth_type_StackType_topZ_tyconZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_topZ_typeZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_type_Type_tyconZAsk(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	return v4;
}
static VAL mw_mirth_type_StackType_topZ_resourceZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v3);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			VAL v6 = mw_mirth_type_StackType_topZ_resourceZAsk(v5);
			push_value(v6);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v7 = pop_value();
			decref(v7);
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = pop_value();
			VAL v10 = mw_mirth_type_StackType_topZ_resourceZAsk(v9);
			push_value(v10);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v11 = pop_value();
			decref(v11);
			VAL v12 = pop_value();
			decref(v12);
			VAL v13 = pop_value();
			VAL v14 = mw_mirth_type_StackType_topZ_resourceZAsk(v13);
			push_value(v14);
		} break;
		default: {
			decref(v0);
			int64_t v15 = 0LL /* None */;
			push_i64(v15);
		} break;
	}
	VAL v16 = pop_value();
	return v16;
}
static VAL mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_topZ_resourceZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_type_Resource_ZToType(v1);
			VAL v3 = mw_mirth_type_Type_tyconZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static VAL mw_mirth_type_StackType_topZ_namespaces (VAL x1) {
	int64_t v0 = 0LL /* Nil */;
	push_value(x1);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	VAL v2 = pop_value();
	incref(v2);
	push_resource(v1);
	push_value(v2);
	VAL v3 = mw_mirth_type_StackType_topZ_tyconZAsk(v2);
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v4);
			VAL r6 = pop_resource();
			VAL v7 = mtw_std_list_List_1_Cons(v5, r6);
			push_resource(v7);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v8 = pop_value();
	VAL v9 = mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk(v8);
	switch (get_data_tag(v9)) {
		case 1LL: { // Some
			VAL v10 = mtp_std_maybe_Maybe_1_Some(v9);
			VAL v11 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v10);
			VAL r12 = pop_resource();
			VAL v13 = mtw_std_list_List_1_Cons(v11, r12);
			push_resource(v13);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r14 = pop_resource();
	VAL v15 = mw_std_list_List_1_reverse(r14);
	return v15;
}
static int64_t mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk (VAL x1) {
	incref(x1);
	push_value(x1);
	int64_t v0 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(x1);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		int64_t v2 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v1);
		push_i64(v2);
	} else {
		int64_t v3 = 0LL /* False */;
		push_i64(v3);
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	decref(v5);
	return VI64(v4);
}
static int64_t mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			int64_t v3 = mw_mirth_type_Type_errorZAsk(v1);
			bool v4 = !((bool)v3);
			push_bool(v4);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			VAL v7 = pop_value();
			int64_t v8 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(v7);
			push_i64(v8);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v9 = pop_value();
			decref(v9);
			VAL v10 = pop_value();
			int64_t v11 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(v10);
			push_i64(v11);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v12 = pop_value();
			decref(v12);
			VAL v13 = pop_value();
			decref(v13);
			VAL v14 = pop_value();
			int64_t v15 = mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk(v14);
			push_i64(v15);
		} break;
		case 4LL: { // STMeta
			uint64_t v16 = mtp_mirth_type_StackType_STMeta(v0);
			int64_t v17 = 1LL /* True */;
			push_i64(v17);
		} break;
		case 3LL: { // STVar
			uint64_t v18 = mtp_mirth_type_StackType_STVar(v0);
			int64_t v19 = 1LL /* True */;
			push_i64(v19);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v20 = 1LL /* True */;
			push_i64(v20);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v21 = 0LL /* False */;
			push_i64(v21);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v22 = 0LL /* False */;
			push_i64(v22);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v23 = pop_i64();
	return v23;
}
static int64_t mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v1 = pop_value();
			decref(v1);
			VAL v2 = pop_value();
			int64_t v3 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v2);
			push_i64(v3);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			int64_t v7 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v6);
			push_i64(v7);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			decref(v9);
			int64_t v10 = mw_mirth_type_Type_errorZAsk(v8);
			bool v11 = !((bool)v10);
			push_bool(v11);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v12 = pop_value();
			decref(v12);
			VAL v13 = pop_value();
			decref(v13);
			VAL v14 = pop_value();
			int64_t v15 = mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk(v14);
			push_i64(v15);
		} break;
		case 4LL: { // STMeta
			uint64_t v16 = mtp_mirth_type_StackType_STMeta(v0);
			int64_t v17 = 1LL /* True */;
			push_i64(v17);
		} break;
		case 3LL: { // STVar
			uint64_t v18 = mtp_mirth_type_StackType_STVar(v0);
			int64_t v19 = 1LL /* True */;
			push_i64(v19);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v20 = 1LL /* True */;
			push_i64(v20);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v21 = 0LL /* False */;
			push_i64(v21);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v22 = 0LL /* False */;
			push_i64(v22);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v23 = pop_i64();
	return v23;
}
static int64_t mw_mirth_type_StackType_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	switch (get_data_tag(v0)) {
		case 4LL: { // STMeta
			uint64_t v1 = mtp_mirth_type_StackType_STMeta(v0);
			uint64_t v2 = pop_u64();
			int64_t v3 = mw_mirth_type_MetaVar_ZEqualZEqual(v2, v1);
			push_i64(v3);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			uint64_t v4 = pop_u64();
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			uint64_t v6 = pop_u64();
			int64_t v7 = 0LL /* False */;
			push_i64(v7);
		} break;
		case 3LL: { // STVar
			uint64_t v8 = mtp_mirth_type_StackType_STVar(v0);
			VAL v9 = pop_value();
			decref(v9);
			int64_t v10 = 0LL /* False */;
			push_i64(v10);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			uint64_t v11 = pop_u64();
			int64_t v12 = 0LL /* False */;
			push_i64(v12);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			VAL v15 = pop_value();
			incref(v15);
			push_value(v15);
			push_value(v14);
			int64_t v16 = mw_mirth_type_Type_hasZ_metaZAsk(VU64(v15), v13);
			if (((bool)v16)) {
				VAL v17 = pop_value();
				decref(v17);
				VAL v18 = pop_value();
				decref(v18);
				int64_t v19 = 1LL /* True */;
				push_i64(v19);
			} else {
				VAL v20 = pop_value();
				uint64_t v21 = pop_u64();
				int64_t v22 = mw_mirth_type_StackType_hasZ_metaZAsk(v21, v20);
				push_i64(v22);
			}
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			uint64_t v23 = pop_u64();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			incref(v26);
			push_value(v26);
			push_value(v25);
			int64_t v27 = mw_mirth_type_Type_hasZ_metaZAsk(VU64(v26), v24);
			if (((bool)v27)) {
				VAL v28 = pop_value();
				decref(v28);
				VAL v29 = pop_value();
				decref(v29);
				int64_t v30 = 1LL /* True */;
				push_i64(v30);
			} else {
				VAL v31 = pop_value();
				uint64_t v32 = pop_u64();
				int64_t v33 = mw_mirth_type_StackType_hasZ_metaZAsk(v32, v31);
				push_i64(v33);
			}
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v34 = pop_value();
			VAL v35 = pop_value();
			VAL v36 = pop_value();
			incref(v36);
			push_value(v36);
			push_value(v35);
			int64_t v37 = mw_mirth_type_Resource_hasZ_metaZAsk(VU64(v36), v34);
			if (((bool)v37)) {
				VAL v38 = pop_value();
				decref(v38);
				VAL v39 = pop_value();
				decref(v39);
				int64_t v40 = 1LL /* True */;
				push_i64(v40);
			} else {
				VAL v41 = pop_value();
				uint64_t v42 = pop_u64();
				int64_t v43 = mw_mirth_type_StackType_hasZ_metaZAsk(v42, v41);
				push_i64(v43);
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			uint64_t v44 = pop_u64();
			VAL v45 = pop_value();
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			incref(v47);
			push_value(v47);
			push_value(v46);
			int64_t v48 = mw_mirth_type_Resource_hasZ_metaZAsk(VU64(v47), v45);
			if (((bool)v48)) {
				VAL v49 = pop_value();
				decref(v49);
				VAL v50 = pop_value();
				decref(v50);
				int64_t v51 = 1LL /* True */;
				push_i64(v51);
			} else {
				VAL v52 = pop_value();
				uint64_t v53 = pop_u64();
				int64_t v54 = mw_mirth_type_StackType_hasZ_metaZAsk(v53, v52);
				push_i64(v54);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v55 = pop_i64();
	return v55;
}
static void mw_mirth_type_StackType_unifyZ_failedZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	VAL v0 = mw_mirth_type_StackType_ZToType(x3);
	push_value(v0);
	VAL v1 = mw_mirth_type_StackType_ZToType(x4);
	VAL v2 = pop_value();
	uint64_t r3 = VU64(pop_resource());
	VAL r4 = pop_resource();
	mw_mirth_type_Type_unifyZ_failedZBang(r4, r3, v2, v1);
	VAL v5 = pop_value();
	VAL v6 = mw_mirth_type_Type_ZToStackType(v5);
	push_value(v6);
}
static void mw_mirth_type_StackType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	push_value(x4);
	VAL v0 = mw_mirth_type_StackType_expand(x3);
	switch (get_data_tag(v0)) {
		case 0LL: { // STACK_TYPE_ERROR
			VAL v1 = pop_value();
			uint64_t r2 = VU64(pop_resource());
			VAL r3 = pop_resource();
			mw_mirth_type_StackType_unifyZ_errorZBang(r3, r2, v1);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
		} break;
		case 4LL: { // STMeta
			uint64_t v4 = mtp_mirth_type_StackType_STMeta(v0);
			VAL v5 = pop_value();
			push_u64(v4);
			VAL v6 = mw_mirth_type_StackType_expand(v5);
			switch (get_data_tag(v6)) {
				case 0LL: { // STACK_TYPE_ERROR
					uint64_t v7 = pop_u64();
					VAL v8 = mtw_mirth_type_StackType_STMeta(v7);
					uint64_t r9 = VU64(pop_resource());
					VAL r10 = pop_resource();
					mw_mirth_type_StackType_unifyZ_errorZBang(r10, r9, v8);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					uint64_t v11 = pop_u64();
					VAL v12 = mtw_mirth_type_StackType_STMeta(v11);
					push_value(v12);
				} break;
				case 4LL: { // STMeta
					uint64_t v13 = mtp_mirth_type_StackType_STMeta(v6);
					uint64_t v14 = pop_u64();
					VAL v15 = mtw_mirth_type_Type_TMeta(v14);
					uint64_t r16 = VU64(pop_resource());
					VAL r17 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r17, r16, v15, v13);
					VAL v18 = pop_value();
					VAL v19 = mw_mirth_type_Type_ZToStackType(v18);
					push_value(v19);
				} break;
				default: {
					VAL v20 = mw_mirth_type_StackType_ZToType(v6);
					uint64_t v21 = pop_u64();
					uint64_t r22 = VU64(pop_resource());
					VAL r23 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r23, r22, v20, v21);
					VAL v24 = pop_value();
					VAL v25 = mw_mirth_type_Type_ZToStackType(v24);
					push_value(v25);
				} break;
			}
		} break;
		case 3LL: { // STVar
			uint64_t v26 = mtp_mirth_type_StackType_STVar(v0);
			VAL v27 = pop_value();
			push_u64(v26);
			VAL v28 = mw_mirth_type_StackType_expand(v27);
			switch (get_data_tag(v28)) {
				case 0LL: { // STACK_TYPE_ERROR
					uint64_t v29 = pop_u64();
					int64_t v30 = 0LL /* STACK_TYPE_ERROR */;
					push_i64(v30);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					uint64_t v31 = pop_u64();
					VAL v32 = mtw_mirth_type_StackType_STVar(v31);
					push_value(v32);
				} break;
				case 4LL: { // STMeta
					uint64_t v33 = mtp_mirth_type_StackType_STMeta(v28);
					uint64_t v34 = pop_u64();
					VAL v35 = mtw_mirth_type_Type_TVar(v34);
					uint64_t r36 = VU64(pop_resource());
					VAL r37 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r37, r36, v35, v33);
					VAL v38 = pop_value();
					VAL v39 = mw_mirth_type_Type_ZToStackType(v38);
					push_value(v39);
				} break;
				case 3LL: { // STVar
					uint64_t v40 = mtp_mirth_type_StackType_STVar(v28);
					uint64_t v41 = pop_u64();
					uint64_t r42 = VU64(pop_resource());
					VAL r43 = pop_resource();
					mw_mirth_var_Var_unifyZBang(r43, r42, v41, v40);
					VAL v44 = pop_value();
					VAL v45 = mw_mirth_type_Type_ZToStackType(v44);
					push_value(v45);
				} break;
				default: {
					uint64_t v46 = pop_u64();
					VAL v47 = mtw_mirth_type_StackType_STVar(v46);
					uint64_t r48 = VU64(pop_resource());
					VAL r49 = pop_resource();
					mw_mirth_type_StackType_unifyZ_failedZBang(r49, r48, v47, v28);
				} break;
			}
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			VAL v50 = pop_value();
			VAL v51 = mw_mirth_type_StackType_expand(v50);
			switch (get_data_tag(v51)) {
				case 0LL: { // STACK_TYPE_ERROR
					int64_t v52 = 0LL /* STACK_TYPE_ERROR */;
					push_i64(v52);
				} break;
				case 4LL: { // STMeta
					uint64_t v53 = mtp_mirth_type_StackType_STMeta(v51);
					int64_t v54 = 2LL /* STACK_TYPE_UNIT */;
					VAL v55 = mw_mirth_type_StackType_ZToType(MKI64(v54));
					uint64_t r56 = VU64(pop_resource());
					VAL r57 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r57, r56, v55, v53);
					VAL v58 = pop_value();
					VAL v59 = mw_mirth_type_Type_ZToStackType(v58);
					push_value(v59);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					int64_t v60 = 2LL /* STACK_TYPE_UNIT */;
					push_i64(v60);
				} break;
				case 2LL: { // STACK_TYPE_UNIT
					int64_t v61 = 2LL /* STACK_TYPE_UNIT */;
					push_i64(v61);
				} break;
				default: {
					int64_t v62 = 2LL /* STACK_TYPE_UNIT */;
					uint64_t r63 = VU64(pop_resource());
					VAL r64 = pop_resource();
					mw_mirth_type_StackType_unifyZ_failedZBang(r64, r63, v51, MKI64(v62));
				} break;
			}
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v65 = pop_value();
			VAL v66 = pop_value();
			VAL v67 = pop_value();
			push_value(v66);
			push_value(v65);
			VAL v68 = mw_mirth_type_StackType_expand(v67);
			switch (get_data_tag(v68)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v69 = pop_value();
					VAL v70 = pop_value();
					VAL v71 = mtw_mirth_type_StackType_STCons(v70, v69);
					uint64_t r72 = VU64(pop_resource());
					VAL r73 = pop_resource();
					mw_mirth_type_StackType_unifyZ_errorZBang(r73, r72, v71);
				} break;
				case 4LL: { // STMeta
					uint64_t v74 = mtp_mirth_type_StackType_STMeta(v68);
					VAL v75 = pop_value();
					VAL v76 = pop_value();
					VAL v77 = mtw_mirth_type_StackType_STCons(v76, v75);
					VAL v78 = mw_mirth_type_StackType_ZToType(v77);
					uint64_t r79 = VU64(pop_resource());
					VAL r80 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r80, r79, v78, v74);
					VAL v81 = pop_value();
					VAL v82 = mw_mirth_type_Type_ZToStackType(v81);
					push_value(v82);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v83 = pop_value();
					VAL v84 = pop_value();
					VAL v85 = mtw_mirth_type_StackType_STCons(v84, v83);
					push_value(v85);
				} break;
				default: {
					incref(v68);
					push_value(v68);
					VAL v86 = mw_mirth_type_StackType_forceZ_consZAskZBang(v68);
					switch (get_data_tag(v86)) {
						case 1LL: { // Some
							VAL v87 = mtp_std_maybe_Maybe_1_Some(v86);
							VAL v88 = pop_value();
							decref(v88);
							VAL v89;
							VAL v90;
							value_uncons(v87, &v89, &v90);
							VAL v91;
							VAL v92;
							value_uncons(v89, &v91, &v92);
							decref(v91);
							VAL v93 = pop_value();
							VAL v94 = pop_value();
							uint64_t r95 = VU64(pop_resource());
							VAL r96 = pop_resource();
							mw_mirth_type_StackType_unifyZBang(r96, r95, v94, v92);
							uint64_t r97 = VU64(pop_resource());
							VAL r98 = pop_resource();
							mw_mirth_type_Type_unifyZBang(r98, r97, v93, v90);
							VAL v99 = pop_value();
							VAL v100 = pop_value();
							VAL v101 = mtw_mirth_type_StackType_STCons(v100, v99);
							push_value(v101);
						} break;
						case 0LL: { // None
							VAL v102 = pop_value();
							VAL v103 = pop_value();
							VAL v104 = pop_value();
							VAL v105 = mtw_mirth_type_StackType_STCons(v104, v103);
							uint64_t r106 = VU64(pop_resource());
							VAL r107 = pop_resource();
							mw_mirth_type_StackType_unifyZ_failedZBang(r107, r106, v105, v102);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} break;
			}
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v108 = pop_value();
			VAL v109 = pop_value();
			VAL v110 = pop_value();
			push_value(v109);
			push_value(v108);
			VAL v111 = mw_mirth_type_StackType_expand(v110);
			switch (get_data_tag(v111)) {
				case 0LL: { // STACK_TYPE_ERROR
					VAL v112 = pop_value();
					VAL v113 = pop_value();
					VAL v114 = mtw_mirth_type_StackType_STWith(v113, v112);
					uint64_t r115 = VU64(pop_resource());
					VAL r116 = pop_resource();
					mw_mirth_type_StackType_unifyZ_errorZBang(r116, r115, v114);
				} break;
				case 4LL: { // STMeta
					uint64_t v117 = mtp_mirth_type_StackType_STMeta(v111);
					VAL v118 = pop_value();
					VAL v119 = pop_value();
					VAL v120 = mtw_mirth_type_StackType_STWith(v119, v118);
					VAL v121 = mw_mirth_type_StackType_ZToType(v120);
					uint64_t r122 = VU64(pop_resource());
					VAL r123 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r123, r122, v121, v117);
					VAL v124 = pop_value();
					VAL v125 = mw_mirth_type_Type_ZToStackType(v124);
					push_value(v125);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					VAL v126 = pop_value();
					VAL v127 = pop_value();
					VAL v128 = mtw_mirth_type_StackType_STWith(v127, v126);
					push_value(v128);
				} break;
				default: {
					incref(v111);
					push_value(v111);
					VAL v129 = mw_mirth_type_StackType_forceZ_withZAskZBang(v111);
					switch (get_data_tag(v129)) {
						case 1LL: { // Some
							VAL v130 = mtp_std_maybe_Maybe_1_Some(v129);
							VAL v131 = pop_value();
							decref(v131);
							VAL v132;
							VAL v133;
							value_uncons(v130, &v132, &v133);
							VAL v134;
							VAL v135;
							value_uncons(v132, &v134, &v135);
							decref(v134);
							VAL v136 = pop_value();
							VAL v137 = pop_value();
							uint64_t r138 = VU64(pop_resource());
							VAL r139 = pop_resource();
							mw_mirth_type_StackType_unifyZBang(r139, r138, v137, v135);
							uint64_t r140 = VU64(pop_resource());
							VAL r141 = pop_resource();
							mw_mirth_type_Resource_unifyZBang(r141, r140, v136, v133);
							VAL v142 = pop_value();
							VAL v143 = pop_value();
							VAL v144 = mtw_mirth_type_StackType_STWith(v143, v142);
							push_value(v144);
						} break;
						case 0LL: { // None
							VAL v145 = pop_value();
							VAL v146 = pop_value();
							VAL v147 = pop_value();
							VAL v148 = mtw_mirth_type_StackType_STWith(v147, v146);
							uint64_t r149 = VU64(pop_resource());
							VAL r150 = pop_resource();
							mw_mirth_type_StackType_unifyZ_failedZBang(r150, r149, v148, v145);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} break;
			}
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v151 = pop_value();
			VAL v152 = pop_value();
			VAL v153 = pop_value();
			VAL v154 = pop_value();
			push_value(v153);
			push_value(v152);
			push_value(v151);
			VAL v155 = mw_mirth_type_StackType_expand(v154);
			switch (get_data_tag(v155)) {
				case 0LL: { // STACK_TYPE_ERROR
					uint64_t v156 = pop_u64();
					VAL v157 = pop_value();
					VAL v158 = pop_value();
					VAL v159 = mtw_mirth_type_StackType_STConsLabel(v158, v157, v156);
					uint64_t r160 = VU64(pop_resource());
					VAL r161 = pop_resource();
					mw_mirth_type_StackType_unifyZ_errorZBang(r161, r160, v159);
				} break;
				case 4LL: { // STMeta
					uint64_t v162 = mtp_mirth_type_StackType_STMeta(v155);
					uint64_t v163 = pop_u64();
					VAL v164 = pop_value();
					VAL v165 = pop_value();
					VAL v166 = mtw_mirth_type_StackType_STConsLabel(v165, v164, v163);
					VAL v167 = mw_mirth_type_StackType_ZToType(v166);
					uint64_t r168 = VU64(pop_resource());
					VAL r169 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r169, r168, v167, v162);
					VAL v170 = pop_value();
					VAL v171 = mw_mirth_type_Type_ZToStackType(v170);
					push_value(v171);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					uint64_t v172 = pop_u64();
					VAL v173 = pop_value();
					VAL v174 = pop_value();
					VAL v175 = mtw_mirth_type_StackType_STConsLabel(v174, v173, v172);
					push_value(v175);
				} break;
				default: {
					VAL v176 = pop_value();
					incref(v176);
					incref(v155);
					push_value(v176);
					push_value(v155);
					VAL v177 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(VU64(v176), v155);
					switch (get_data_tag(v177)) {
						case 1LL: { // Some
							VAL v178 = mtp_std_maybe_Maybe_1_Some(v177);
							VAL v179 = pop_value();
							decref(v179);
							uint64_t v180 = pop_u64();
							VAL v181;
							VAL v182;
							value_uncons(v178, &v181, &v182);
							VAL v183;
							VAL v184;
							value_uncons(v181, &v183, &v184);
							decref(v183);
							VAL v185 = pop_value();
							VAL v186 = pop_value();
							uint64_t r187 = VU64(pop_resource());
							VAL r188 = pop_resource();
							mw_mirth_type_StackType_unifyZBang(r188, r187, v186, v184);
							uint64_t r189 = VU64(pop_resource());
							VAL r190 = pop_resource();
							mw_mirth_type_Type_unifyZBang(r190, r189, v185, v182);
							VAL v191 = pop_value();
							VAL v192 = pop_value();
							VAL v193 = mtw_mirth_type_StackType_STConsLabel(v192, v191, v180);
							push_value(v193);
						} break;
						case 0LL: { // None
							VAL v194 = pop_value();
							uint64_t v195 = pop_u64();
							VAL v196 = pop_value();
							VAL v197 = pop_value();
							VAL v198 = mtw_mirth_type_StackType_STConsLabel(v197, v196, v195);
							uint64_t r199 = VU64(pop_resource());
							VAL r200 = pop_resource();
							mw_mirth_type_StackType_unifyZ_failedZBang(r200, r199, v198, v194);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} break;
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v201 = pop_value();
			VAL v202 = pop_value();
			VAL v203 = pop_value();
			VAL v204 = pop_value();
			push_value(v203);
			push_value(v202);
			push_value(v201);
			VAL v205 = mw_mirth_type_StackType_expand(v204);
			switch (get_data_tag(v205)) {
				case 0LL: { // STACK_TYPE_ERROR
					uint64_t v206 = pop_u64();
					VAL v207 = pop_value();
					VAL v208 = pop_value();
					VAL v209 = mtw_mirth_type_StackType_STWithLabel(v208, v207, v206);
					uint64_t r210 = VU64(pop_resource());
					VAL r211 = pop_resource();
					mw_mirth_type_StackType_unifyZ_errorZBang(r211, r210, v209);
				} break;
				case 4LL: { // STMeta
					uint64_t v212 = mtp_mirth_type_StackType_STMeta(v205);
					uint64_t v213 = pop_u64();
					VAL v214 = pop_value();
					VAL v215 = pop_value();
					VAL v216 = mtw_mirth_type_StackType_STWithLabel(v215, v214, v213);
					VAL v217 = mw_mirth_type_StackType_ZToType(v216);
					uint64_t r218 = VU64(pop_resource());
					VAL r219 = pop_resource();
					mw_mirth_type_MetaVar_unifyZBang(r219, r218, v217, v212);
					VAL v220 = pop_value();
					VAL v221 = mw_mirth_type_Type_ZToStackType(v220);
					push_value(v221);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					uint64_t v222 = pop_u64();
					VAL v223 = pop_value();
					VAL v224 = pop_value();
					VAL v225 = mtw_mirth_type_StackType_STWithLabel(v224, v223, v222);
					push_value(v225);
				} break;
				default: {
					VAL v226 = pop_value();
					incref(v226);
					incref(v205);
					push_value(v226);
					push_value(v205);
					VAL v227 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(VU64(v226), v205);
					switch (get_data_tag(v227)) {
						case 1LL: { // Some
							VAL v228 = mtp_std_maybe_Maybe_1_Some(v227);
							VAL v229 = pop_value();
							decref(v229);
							uint64_t v230 = pop_u64();
							VAL v231;
							VAL v232;
							value_uncons(v228, &v231, &v232);
							VAL v233;
							VAL v234;
							value_uncons(v231, &v233, &v234);
							decref(v233);
							VAL v235 = pop_value();
							VAL v236 = pop_value();
							uint64_t r237 = VU64(pop_resource());
							VAL r238 = pop_resource();
							mw_mirth_type_StackType_unifyZBang(r238, r237, v236, v234);
							uint64_t r239 = VU64(pop_resource());
							VAL r240 = pop_resource();
							mw_mirth_type_Resource_unifyZBang(r240, r239, v235, v232);
							VAL v241 = pop_value();
							VAL v242 = pop_value();
							VAL v243 = mtw_mirth_type_StackType_STWithLabel(v242, v241, v230);
							push_value(v243);
						} break;
						case 0LL: { // None
							VAL v244 = pop_value();
							uint64_t v245 = pop_u64();
							VAL v246 = pop_value();
							VAL v247 = pop_value();
							VAL v248 = mtw_mirth_type_StackType_STWithLabel(v247, v246, v245);
							uint64_t r249 = VU64(pop_resource());
							VAL r250 = pop_resource();
							mw_mirth_type_StackType_unifyZ_failedZBang(r250, r249, v248, v244);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_type_StackType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3) {
	push_resource(x1);
	push_resource(MKU64(x2));
	VAL v0 = mw_mirth_type_StackType_expand(x3);
	switch (get_data_tag(v0)) {
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v1 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v1);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v2 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v2);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v3 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v3);
		} break;
		case 4LL: { // STMeta
			uint64_t v4 = mtp_mirth_type_StackType_STMeta(v0);
			uint64_t r5 = VU64(pop_resource());
			VAL r6 = pop_resource();
			mw_mirth_type_MetaVar_unifyZ_errorZBang(r6, r5, v4);
			VAL v7 = pop_value();
			VAL v8 = mw_mirth_type_Type_ZToStackType(v7);
			push_value(v8);
		} break;
		case 3LL: { // STVar
			uint64_t v9 = mtp_mirth_type_StackType_STVar(v0);
			int64_t v10 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v10);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			uint64_t r13 = VU64(pop_resource());
			VAL r14 = pop_resource();
			mw_mirth_type_StackType_unifyZ_errorZBang(r14, r13, v12);
			VAL v15 = pop_value();
			decref(v15);
			uint64_t r16 = VU64(pop_resource());
			VAL r17 = pop_resource();
			mw_mirth_type_Type_unifyZ_errorZBang(r17, r16, v11);
			VAL v18 = pop_value();
			decref(v18);
			int64_t v19 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v19);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			uint64_t r22 = VU64(pop_resource());
			VAL r23 = pop_resource();
			mw_mirth_type_StackType_unifyZ_errorZBang(r23, r22, v21);
			VAL v24 = pop_value();
			decref(v24);
			uint64_t r25 = VU64(pop_resource());
			VAL r26 = pop_resource();
			mw_mirth_type_Resource_unifyZ_errorZBang(r26, r25, v20);
			VAL v27 = pop_value();
			decref(v27);
			int64_t v28 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v28);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			uint64_t v29 = pop_u64();
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			uint64_t r32 = VU64(pop_resource());
			VAL r33 = pop_resource();
			mw_mirth_type_StackType_unifyZ_errorZBang(r33, r32, v31);
			VAL v34 = pop_value();
			decref(v34);
			uint64_t r35 = VU64(pop_resource());
			VAL r36 = pop_resource();
			mw_mirth_type_Type_unifyZ_errorZBang(r36, r35, v30);
			VAL v37 = pop_value();
			decref(v37);
			int64_t v38 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v38);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			uint64_t v39 = pop_u64();
			VAL v40 = pop_value();
			VAL v41 = pop_value();
			uint64_t r42 = VU64(pop_resource());
			VAL r43 = pop_resource();
			mw_mirth_type_StackType_unifyZ_errorZBang(r43, r42, v41);
			VAL v44 = pop_value();
			decref(v44);
			uint64_t r45 = VU64(pop_resource());
			VAL r46 = pop_resource();
			mw_mirth_type_Resource_unifyZ_errorZBang(r46, r45, v40);
			VAL v47 = pop_value();
			decref(v47);
			int64_t v48 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v48);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // STACK_TYPE_ERROR
			uint64_t v1 = pop_u64();
			int64_t v2 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v3 = 0LL /* TYPE_ERROR */;
			VAL v4 = MKNIL;
			VAL v5 = mkcons(v4, MKI64(v2));
			VAL v6 = mkcons(v5, MKI64(v3));
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			uint64_t v8 = pop_u64();
			int64_t v9 = 1LL /* STACK_TYPE_DONT_CARE */;
			int64_t v10 = 1LL /* TYPE_DONT_CARE */;
			VAL v11 = MKNIL;
			VAL v12 = mkcons(v11, MKI64(v9));
			VAL v13 = mkcons(v12, MKI64(v10));
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			uint64_t v15 = pop_u64();
			int64_t v16 = 0LL /* None */;
			push_i64(v16);
		} break;
		case 3LL: { // STVar
			uint64_t v17 = mtp_mirth_type_StackType_STVar(v0);
			VAL v18 = pop_value();
			decref(v18);
			int64_t v19 = 0LL /* None */;
			push_i64(v19);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			uint64_t v22 = pop_u64();
			VAL v23 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(v22, v21);
			switch (get_data_tag(v23)) {
				case 1LL: { // Some
					push_value(v20);
					VAL v24 = mtp_std_maybe_Maybe_1_Some(v23);
					VAL v25;
					VAL v26;
					value_uncons(v24, &v25, &v26);
					VAL v27;
					VAL v28;
					value_uncons(v25, &v27, &v28);
					decref(v27);
					VAL v29 = pop_value();
					incref(v29);
					push_value(v29);
					VAL v30 = mtw_mirth_type_StackType_STWith(v28, v29);
					VAL v31 = MKNIL;
					VAL v32 = mkcons(v31, v30);
					VAL v33 = mkcons(v32, v26);
					VAL v34 = mtw_std_maybe_Maybe_1_Some(v33);
					push_value(v34);
				} break;
				case 0LL: { // None
					int64_t v35 = 0LL /* None */;
					push_value(v20);
					push_i64(v35);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v20);
				}
			}
			VAL v36 = pop_value();
			VAL v37 = pop_value();
			decref(v37);
			push_value(v36);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v38 = pop_value();
			VAL v39 = pop_value();
			uint64_t v40 = pop_u64();
			VAL v41 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(v40, v39);
			switch (get_data_tag(v41)) {
				case 1LL: { // Some
					push_value(v38);
					VAL v42 = mtp_std_maybe_Maybe_1_Some(v41);
					VAL v43;
					VAL v44;
					value_uncons(v42, &v43, &v44);
					VAL v45;
					VAL v46;
					value_uncons(v43, &v45, &v46);
					decref(v45);
					VAL v47 = pop_value();
					incref(v47);
					push_value(v47);
					VAL v48 = mtw_mirth_type_StackType_STCons(v46, v47);
					VAL v49 = MKNIL;
					VAL v50 = mkcons(v49, v48);
					VAL v51 = mkcons(v50, v44);
					VAL v52 = mtw_std_maybe_Maybe_1_Some(v51);
					push_value(v52);
				} break;
				case 0LL: { // None
					int64_t v53 = 0LL /* None */;
					push_value(v38);
					push_i64(v53);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v38);
				}
			}
			VAL v54 = pop_value();
			VAL v55 = pop_value();
			decref(v55);
			push_value(v54);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v56 = pop_value();
			VAL v57 = pop_value();
			VAL v58 = pop_value();
			VAL v59 = pop_value();
			incref(v59);
			incref(v56);
			push_value(v59);
			push_value(v58);
			push_value(v57);
			push_value(v56);
			int64_t v60 = mw_mirth_label_Label_ZEqualZEqual(VU64(v59), VU64(v56));
			if (((bool)v60)) {
				uint64_t v61 = pop_u64();
				VAL v62 = pop_value();
				VAL v63 = pop_value();
				VAL v64 = pop_value();
				decref(v64);
				VAL v65 = MKNIL;
				VAL v66 = mkcons(v65, v63);
				VAL v67 = mkcons(v66, v62);
				VAL v68 = mtw_std_maybe_Maybe_1_Some(v67);
				push_value(v68);
			} else {
				uint64_t v69 = pop_u64();
				VAL v70 = pop_value();
				VAL v71 = pop_value();
				uint64_t v72 = pop_u64();
				VAL v73 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(v72, v71);
				switch (get_data_tag(v73)) {
					case 1LL: { // Some
						push_value(v70);
						push_u64(v69);
						VAL v74 = mtp_std_maybe_Maybe_1_Some(v73);
						VAL v75;
						VAL v76;
						value_uncons(v74, &v75, &v76);
						VAL v77;
						VAL v78;
						value_uncons(v75, &v77, &v78);
						decref(v77);
						VAL v79 = pop_value();
						VAL v80 = pop_value();
						VAL v81 = mtw_mirth_type_StackType_STConsLabel(v78, v80, VU64(v79));
						VAL v82 = MKNIL;
						VAL v83 = mkcons(v82, v81);
						VAL v84 = mkcons(v83, v76);
						VAL v85 = mtw_std_maybe_Maybe_1_Some(v84);
						push_value(v85);
					} break;
					case 0LL: { // None
						decref(v70);
						int64_t v86 = 0LL /* None */;
						push_i64(v86);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v70);
						push_u64(v69);
					}
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v87 = pop_value();
			VAL v88 = pop_value();
			VAL v89 = pop_value();
			VAL v90 = pop_value();
			incref(v90);
			incref(v87);
			push_value(v90);
			push_value(v89);
			push_value(v88);
			push_value(v87);
			int64_t v91 = mw_mirth_label_Label_ZEqualZEqual(VU64(v90), VU64(v87));
			if (((bool)v91)) {
				VAL v92 = pop_value();
				decref(v92);
				VAL v93 = pop_value();
				decref(v93);
				VAL v94 = pop_value();
				decref(v94);
				VAL v95 = pop_value();
				decref(v95);
				int64_t v96 = 0LL /* None */;
				push_i64(v96);
			} else {
				uint64_t v97 = pop_u64();
				VAL v98 = pop_value();
				VAL v99 = pop_value();
				uint64_t v100 = pop_u64();
				VAL v101 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(v100, v99);
				switch (get_data_tag(v101)) {
					case 1LL: { // Some
						push_value(v98);
						push_u64(v97);
						VAL v102 = mtp_std_maybe_Maybe_1_Some(v101);
						VAL v103;
						VAL v104;
						value_uncons(v102, &v103, &v104);
						VAL v105;
						VAL v106;
						value_uncons(v103, &v105, &v106);
						decref(v105);
						VAL v107 = pop_value();
						VAL v108 = pop_value();
						VAL v109 = mtw_mirth_type_StackType_STWithLabel(v106, v108, VU64(v107));
						VAL v110 = MKNIL;
						VAL v111 = mkcons(v110, v109);
						VAL v112 = mkcons(v111, v104);
						VAL v113 = mtw_std_maybe_Maybe_1_Some(v112);
						push_value(v113);
					} break;
					case 0LL: { // None
						decref(v98);
						int64_t v114 = 0LL /* None */;
						push_i64(v114);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v98);
						push_u64(v97);
					}
				}
			}
		} break;
		case 4LL: { // STMeta
			uint64_t v115 = mtp_mirth_type_StackType_STMeta(v0);
			uint64_t v116 = pop_u64();
			uint64_t v117 = mw_mirth_type_MetaVar_newZBang();
			VAL v118 = mtw_mirth_type_StackType_STMeta(v117);
			push_value(v118);
			uint64_t v119 = mw_mirth_type_MetaVar_newZBang();
			VAL v120 = mtw_mirth_type_Type_TMeta(v119);
			VAL v121 = pop_value();
			incref(v121);
			incref(v120);
			push_value(v121);
			push_value(v120);
			VAL v122 = mtw_mirth_type_StackType_STConsLabel(v121, v120, v116);
			VAL v123 = mw_mirth_type_StackType_ZToType(v122);
			VAL v124 = mtw_std_maybe_Maybe_1_Some(v123);
			void* v125 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v115);
			mut_set(v124, MKPTR(v125));
			VAL v126 = pop_value();
			VAL v127 = pop_value();
			VAL v128 = MKNIL;
			VAL v129 = mkcons(v128, v127);
			VAL v130 = mkcons(v129, v126);
			VAL v131 = mtw_std_maybe_Maybe_1_Some(v130);
			push_value(v131);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v132 = pop_value();
	return v132;
}
static VAL mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // STACK_TYPE_ERROR
			uint64_t v1 = pop_u64();
			int64_t v2 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v3 = 0LL /* TYPE_ERROR */;
			VAL v4 = MKNIL;
			VAL v5 = mkcons(v4, MKI64(v2));
			VAL v6 = mkcons(v5, MKI64(v3));
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			uint64_t v8 = pop_u64();
			int64_t v9 = 1LL /* STACK_TYPE_DONT_CARE */;
			int64_t v10 = 1LL /* TYPE_DONT_CARE */;
			VAL v11 = MKNIL;
			VAL v12 = mkcons(v11, MKI64(v9));
			VAL v13 = mkcons(v12, MKI64(v10));
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			uint64_t v15 = pop_u64();
			int64_t v16 = 0LL /* None */;
			push_i64(v16);
		} break;
		case 3LL: { // STVar
			uint64_t v17 = mtp_mirth_type_StackType_STVar(v0);
			VAL v18 = pop_value();
			decref(v18);
			int64_t v19 = 0LL /* None */;
			push_i64(v19);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			uint64_t v22 = pop_u64();
			VAL v23 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(v22, v21);
			switch (get_data_tag(v23)) {
				case 1LL: { // Some
					push_value(v20);
					VAL v24 = mtp_std_maybe_Maybe_1_Some(v23);
					VAL v25;
					VAL v26;
					value_uncons(v24, &v25, &v26);
					VAL v27;
					VAL v28;
					value_uncons(v25, &v27, &v28);
					decref(v27);
					VAL v29 = pop_value();
					incref(v29);
					push_value(v29);
					VAL v30 = mtw_mirth_type_StackType_STWith(v28, v29);
					VAL v31 = MKNIL;
					VAL v32 = mkcons(v31, v30);
					VAL v33 = mkcons(v32, v26);
					VAL v34 = mtw_std_maybe_Maybe_1_Some(v33);
					push_value(v34);
				} break;
				case 0LL: { // None
					int64_t v35 = 0LL /* None */;
					push_value(v20);
					push_i64(v35);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v20);
				}
			}
			VAL v36 = pop_value();
			VAL v37 = pop_value();
			decref(v37);
			push_value(v36);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v38 = pop_value();
			VAL v39 = pop_value();
			uint64_t v40 = pop_u64();
			VAL v41 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(v40, v39);
			switch (get_data_tag(v41)) {
				case 1LL: { // Some
					push_value(v38);
					VAL v42 = mtp_std_maybe_Maybe_1_Some(v41);
					VAL v43;
					VAL v44;
					value_uncons(v42, &v43, &v44);
					VAL v45;
					VAL v46;
					value_uncons(v43, &v45, &v46);
					decref(v45);
					VAL v47 = pop_value();
					incref(v47);
					push_value(v47);
					VAL v48 = mtw_mirth_type_StackType_STCons(v46, v47);
					VAL v49 = MKNIL;
					VAL v50 = mkcons(v49, v48);
					VAL v51 = mkcons(v50, v44);
					VAL v52 = mtw_std_maybe_Maybe_1_Some(v51);
					push_value(v52);
				} break;
				case 0LL: { // None
					int64_t v53 = 0LL /* None */;
					push_value(v38);
					push_i64(v53);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(v38);
				}
			}
			VAL v54 = pop_value();
			VAL v55 = pop_value();
			decref(v55);
			push_value(v54);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v56 = pop_value();
			VAL v57 = pop_value();
			VAL v58 = pop_value();
			VAL v59 = pop_value();
			incref(v59);
			incref(v56);
			push_value(v59);
			push_value(v58);
			push_value(v57);
			push_value(v56);
			int64_t v60 = mw_mirth_label_Label_ZEqualZEqual(VU64(v59), VU64(v56));
			if (((bool)v60)) {
				VAL v61 = pop_value();
				decref(v61);
				VAL v62 = pop_value();
				decref(v62);
				VAL v63 = pop_value();
				decref(v63);
				VAL v64 = pop_value();
				decref(v64);
				int64_t v65 = 0LL /* None */;
				push_i64(v65);
			} else {
				uint64_t v66 = pop_u64();
				VAL v67 = pop_value();
				VAL v68 = pop_value();
				uint64_t v69 = pop_u64();
				VAL v70 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(v69, v68);
				switch (get_data_tag(v70)) {
					case 1LL: { // Some
						push_value(v67);
						push_u64(v66);
						VAL v71 = mtp_std_maybe_Maybe_1_Some(v70);
						VAL v72;
						VAL v73;
						value_uncons(v71, &v72, &v73);
						VAL v74;
						VAL v75;
						value_uncons(v72, &v74, &v75);
						decref(v74);
						VAL v76 = pop_value();
						VAL v77 = pop_value();
						VAL v78 = mtw_mirth_type_StackType_STConsLabel(v75, v77, VU64(v76));
						VAL v79 = MKNIL;
						VAL v80 = mkcons(v79, v78);
						VAL v81 = mkcons(v80, v73);
						VAL v82 = mtw_std_maybe_Maybe_1_Some(v81);
						push_value(v82);
					} break;
					case 0LL: { // None
						decref(v67);
						int64_t v83 = 0LL /* None */;
						push_i64(v83);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v67);
						push_u64(v66);
					}
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v84 = pop_value();
			VAL v85 = pop_value();
			VAL v86 = pop_value();
			VAL v87 = pop_value();
			incref(v87);
			incref(v84);
			push_value(v87);
			push_value(v86);
			push_value(v85);
			push_value(v84);
			int64_t v88 = mw_mirth_label_Label_ZEqualZEqual(VU64(v87), VU64(v84));
			if (((bool)v88)) {
				uint64_t v89 = pop_u64();
				VAL v90 = pop_value();
				VAL v91 = pop_value();
				VAL v92 = pop_value();
				decref(v92);
				VAL v93 = MKNIL;
				VAL v94 = mkcons(v93, v91);
				VAL v95 = mkcons(v94, v90);
				VAL v96 = mtw_std_maybe_Maybe_1_Some(v95);
				push_value(v96);
			} else {
				uint64_t v97 = pop_u64();
				VAL v98 = pop_value();
				VAL v99 = pop_value();
				uint64_t v100 = pop_u64();
				VAL v101 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(v100, v99);
				switch (get_data_tag(v101)) {
					case 1LL: { // Some
						push_value(v98);
						push_u64(v97);
						VAL v102 = mtp_std_maybe_Maybe_1_Some(v101);
						VAL v103;
						VAL v104;
						value_uncons(v102, &v103, &v104);
						VAL v105;
						VAL v106;
						value_uncons(v103, &v105, &v106);
						decref(v105);
						VAL v107 = pop_value();
						VAL v108 = pop_value();
						VAL v109 = mtw_mirth_type_StackType_STWithLabel(v106, v108, VU64(v107));
						VAL v110 = MKNIL;
						VAL v111 = mkcons(v110, v109);
						VAL v112 = mkcons(v111, v104);
						VAL v113 = mtw_std_maybe_Maybe_1_Some(v112);
						push_value(v113);
					} break;
					case 0LL: { // None
						decref(v98);
						int64_t v114 = 0LL /* None */;
						push_i64(v114);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v98);
						push_u64(v97);
					}
				}
			}
		} break;
		case 4LL: { // STMeta
			uint64_t v115 = mtp_mirth_type_StackType_STMeta(v0);
			uint64_t v116 = pop_u64();
			uint64_t v117 = mw_mirth_type_MetaVar_newZBang();
			VAL v118 = mtw_mirth_type_StackType_STMeta(v117);
			push_value(v118);
			uint64_t v119 = mw_mirth_type_MetaVar_newZBang();
			VAL v120 = mtw_mirth_type_Type_TMeta(v119);
			VAL v121 = pop_value();
			incref(v121);
			incref(v120);
			push_value(v121);
			push_value(v120);
			VAL v122 = mtw_mirth_type_StackType_STWithLabel(v121, v120, v116);
			VAL v123 = mw_mirth_type_StackType_ZToType(v122);
			VAL v124 = mtw_std_maybe_Maybe_1_Some(v123);
			void* v125 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v115);
			mut_set(v124, MKPTR(v125));
			VAL v126 = pop_value();
			VAL v127 = pop_value();
			VAL v128 = MKNIL;
			VAL v129 = mkcons(v128, v127);
			VAL v130 = mkcons(v129, v126);
			VAL v131 = mtw_std_maybe_Maybe_1_Some(v130);
			push_value(v131);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v132 = pop_value();
	return v132;
}
static VAL mw_mirth_type_StackType_forceZ_consZAskZBang (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v1 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v2 = 0LL /* TYPE_ERROR */;
			VAL v3 = MKNIL;
			VAL v4 = mkcons(v3, MKI64(v1));
			VAL v5 = mkcons(v4, MKI64(v2));
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			push_value(v6);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v7 = 1LL /* STACK_TYPE_DONT_CARE */;
			int64_t v8 = 1LL /* TYPE_DONT_CARE */;
			VAL v9 = MKNIL;
			VAL v10 = mkcons(v9, MKI64(v7));
			VAL v11 = mkcons(v10, MKI64(v8));
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
			push_value(v12);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v13 = 0LL /* None */;
			push_i64(v13);
		} break;
		case 3LL: { // STVar
			uint64_t v14 = mtp_mirth_type_StackType_STVar(v0);
			int64_t v15 = 0LL /* None */;
			push_i64(v15);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			VAL v18 = MKNIL;
			VAL v19 = mkcons(v18, v17);
			VAL v20 = mkcons(v19, v16);
			VAL v21 = mtw_std_maybe_Maybe_1_Some(v20);
			push_value(v21);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			VAL v24 = mw_mirth_type_StackType_forceZ_consZAskZBang(v23);
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v24);
					VAL v26;
					VAL v27;
					value_uncons(v25, &v26, &v27);
					VAL v28;
					VAL v29;
					value_uncons(v26, &v28, &v29);
					decref(v28);
					VAL v30 = pop_value();
					incref(v30);
					push_value(v30);
					VAL v31 = mtw_mirth_type_StackType_STWith(v29, v30);
					VAL v32 = MKNIL;
					VAL v33 = mkcons(v32, v31);
					VAL v34 = mkcons(v33, v27);
					VAL v35 = mtw_std_maybe_Maybe_1_Some(v34);
					push_value(v35);
				} break;
				case 0LL: { // None
					int64_t v36 = 0LL /* None */;
					push_i64(v36);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v37 = pop_value();
			VAL v38 = pop_value();
			decref(v38);
			push_value(v37);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			VAL v41 = pop_value();
			push_value(v40);
			push_value(v39);
			VAL v42 = mw_mirth_type_StackType_forceZ_consZAskZBang(v41);
			switch (get_data_tag(v42)) {
				case 1LL: { // Some
					VAL v43 = mtp_std_maybe_Maybe_1_Some(v42);
					VAL v44;
					VAL v45;
					value_uncons(v43, &v44, &v45);
					VAL v46;
					VAL v47;
					value_uncons(v44, &v46, &v47);
					decref(v46);
					VAL v48 = pop_value();
					VAL v49 = pop_value();
					VAL v50 = mtw_mirth_type_StackType_STConsLabel(v47, v49, VU64(v48));
					VAL v51 = MKNIL;
					VAL v52 = mkcons(v51, v50);
					VAL v53 = mkcons(v52, v45);
					VAL v54 = mtw_std_maybe_Maybe_1_Some(v53);
					push_value(v54);
				} break;
				case 0LL: { // None
					VAL v55 = pop_value();
					decref(v55);
					VAL v56 = pop_value();
					decref(v56);
					int64_t v57 = 0LL /* None */;
					push_i64(v57);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v58 = pop_value();
			VAL v59 = pop_value();
			VAL v60 = pop_value();
			push_value(v59);
			push_value(v58);
			VAL v61 = mw_mirth_type_StackType_forceZ_consZAskZBang(v60);
			switch (get_data_tag(v61)) {
				case 1LL: { // Some
					VAL v62 = mtp_std_maybe_Maybe_1_Some(v61);
					VAL v63;
					VAL v64;
					value_uncons(v62, &v63, &v64);
					VAL v65;
					VAL v66;
					value_uncons(v63, &v65, &v66);
					decref(v65);
					VAL v67 = pop_value();
					VAL v68 = pop_value();
					VAL v69 = mtw_mirth_type_StackType_STWithLabel(v66, v68, VU64(v67));
					VAL v70 = MKNIL;
					VAL v71 = mkcons(v70, v69);
					VAL v72 = mkcons(v71, v64);
					VAL v73 = mtw_std_maybe_Maybe_1_Some(v72);
					push_value(v73);
				} break;
				case 0LL: { // None
					VAL v74 = pop_value();
					decref(v74);
					VAL v75 = pop_value();
					decref(v75);
					int64_t v76 = 0LL /* None */;
					push_i64(v76);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 4LL: { // STMeta
			uint64_t v77 = mtp_mirth_type_StackType_STMeta(v0);
			uint64_t v78 = mw_mirth_type_MetaVar_newZBang();
			VAL v79 = mtw_mirth_type_StackType_STMeta(v78);
			push_value(v79);
			uint64_t v80 = mw_mirth_type_MetaVar_newZBang();
			VAL v81 = mtw_mirth_type_Type_TMeta(v80);
			VAL v82 = pop_value();
			incref(v82);
			incref(v81);
			push_value(v82);
			push_value(v81);
			VAL v83 = mtw_mirth_type_StackType_STCons(v82, v81);
			VAL v84 = mw_mirth_type_StackType_ZToType(v83);
			VAL v85 = mtw_std_maybe_Maybe_1_Some(v84);
			void* v86 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v77);
			mut_set(v85, MKPTR(v86));
			VAL v87 = pop_value();
			VAL v88 = pop_value();
			VAL v89 = MKNIL;
			VAL v90 = mkcons(v89, v88);
			VAL v91 = mkcons(v90, v87);
			VAL v92 = mtw_std_maybe_Maybe_1_Some(v91);
			push_value(v92);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v93 = pop_value();
	return v93;
}
static VAL mw_mirth_type_StackType_forceZ_withZAskZBang (VAL x1) {
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v1 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v2 = 0LL /* TYPE_ERROR */;
			VAL v3 = MKNIL;
			VAL v4 = mkcons(v3, MKI64(v1));
			VAL v5 = mkcons(v4, MKI64(v2));
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			push_value(v6);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v7 = 1LL /* STACK_TYPE_DONT_CARE */;
			int64_t v8 = 1LL /* TYPE_DONT_CARE */;
			VAL v9 = MKNIL;
			VAL v10 = mkcons(v9, MKI64(v7));
			VAL v11 = mkcons(v10, MKI64(v8));
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
			push_value(v12);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v13 = 0LL /* None */;
			push_i64(v13);
		} break;
		case 3LL: { // STVar
			uint64_t v14 = mtp_mirth_type_StackType_STVar(v0);
			int64_t v15 = 0LL /* None */;
			push_i64(v15);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			VAL v18 = MKNIL;
			VAL v19 = mkcons(v18, v17);
			VAL v20 = mkcons(v19, v16);
			VAL v21 = mtw_std_maybe_Maybe_1_Some(v20);
			push_value(v21);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			VAL v24 = mw_mirth_type_StackType_forceZ_withZAskZBang(v23);
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v24);
					VAL v26;
					VAL v27;
					value_uncons(v25, &v26, &v27);
					VAL v28;
					VAL v29;
					value_uncons(v26, &v28, &v29);
					decref(v28);
					VAL v30 = pop_value();
					incref(v30);
					push_value(v30);
					VAL v31 = mtw_mirth_type_StackType_STCons(v29, v30);
					VAL v32 = MKNIL;
					VAL v33 = mkcons(v32, v31);
					VAL v34 = mkcons(v33, v27);
					VAL v35 = mtw_std_maybe_Maybe_1_Some(v34);
					push_value(v35);
				} break;
				case 0LL: { // None
					int64_t v36 = 0LL /* None */;
					push_i64(v36);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v37 = pop_value();
			VAL v38 = pop_value();
			decref(v38);
			push_value(v37);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			VAL v41 = pop_value();
			push_value(v40);
			push_value(v39);
			VAL v42 = mw_mirth_type_StackType_forceZ_withZAskZBang(v41);
			switch (get_data_tag(v42)) {
				case 1LL: { // Some
					VAL v43 = mtp_std_maybe_Maybe_1_Some(v42);
					VAL v44;
					VAL v45;
					value_uncons(v43, &v44, &v45);
					VAL v46;
					VAL v47;
					value_uncons(v44, &v46, &v47);
					decref(v46);
					VAL v48 = pop_value();
					VAL v49 = pop_value();
					VAL v50 = mtw_mirth_type_StackType_STConsLabel(v47, v49, VU64(v48));
					VAL v51 = MKNIL;
					VAL v52 = mkcons(v51, v50);
					VAL v53 = mkcons(v52, v45);
					VAL v54 = mtw_std_maybe_Maybe_1_Some(v53);
					push_value(v54);
				} break;
				case 0LL: { // None
					VAL v55 = pop_value();
					decref(v55);
					VAL v56 = pop_value();
					decref(v56);
					int64_t v57 = 0LL /* None */;
					push_i64(v57);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v58 = pop_value();
			VAL v59 = pop_value();
			VAL v60 = pop_value();
			push_value(v59);
			push_value(v58);
			VAL v61 = mw_mirth_type_StackType_forceZ_withZAskZBang(v60);
			switch (get_data_tag(v61)) {
				case 1LL: { // Some
					VAL v62 = mtp_std_maybe_Maybe_1_Some(v61);
					VAL v63;
					VAL v64;
					value_uncons(v62, &v63, &v64);
					VAL v65;
					VAL v66;
					value_uncons(v63, &v65, &v66);
					decref(v65);
					VAL v67 = pop_value();
					VAL v68 = pop_value();
					VAL v69 = mtw_mirth_type_StackType_STWithLabel(v66, v68, VU64(v67));
					VAL v70 = MKNIL;
					VAL v71 = mkcons(v70, v69);
					VAL v72 = mkcons(v71, v64);
					VAL v73 = mtw_std_maybe_Maybe_1_Some(v72);
					push_value(v73);
				} break;
				case 0LL: { // None
					VAL v74 = pop_value();
					decref(v74);
					VAL v75 = pop_value();
					decref(v75);
					int64_t v76 = 0LL /* None */;
					push_i64(v76);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 4LL: { // STMeta
			uint64_t v77 = mtp_mirth_type_StackType_STMeta(v0);
			uint64_t v78 = mw_mirth_type_MetaVar_newZBang();
			VAL v79 = mtw_mirth_type_StackType_STMeta(v78);
			push_value(v79);
			uint64_t v80 = mw_mirth_type_MetaVar_newZBang();
			VAL v81 = mtw_mirth_type_Type_TMeta(v80);
			VAL v82 = pop_value();
			incref(v82);
			incref(v81);
			push_value(v82);
			push_value(v81);
			VAL v83 = mtw_mirth_type_StackType_STWith(v82, v81);
			VAL v84 = mw_mirth_type_StackType_ZToType(v83);
			VAL v85 = mtw_std_maybe_Maybe_1_Some(v84);
			void* v86 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v77);
			mut_set(v85, MKPTR(v86));
			VAL v87 = pop_value();
			VAL v88 = pop_value();
			VAL v89 = MKNIL;
			VAL v90 = mkcons(v89, v88);
			VAL v91 = mkcons(v90, v87);
			VAL v92 = mtw_std_maybe_Maybe_1_Some(v91);
			push_value(v92);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v93 = pop_value();
	return v93;
}
static VAL mw_mirth_type_StackType_domZThen (VAL x1, VAL x2) {
	push_resource(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	incref(v0);
	push_value(v0);
	int64_t v1 = mw_mirth_type_StackType_unitZAsk(v0);
	if (((bool)v1)) {
		VAL v2 = pop_value();
		decref(v2);
	} else {
		VAL v3 = pop_value();
		VAL r4 = pop_resource();
		VAL v5 = (mw_mirth_type_StackType_stackZThen(r4, v3));
		STR* v6;
		STRLIT(v6, " ", 1);
		VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), v5));
		push_resource(v7);
	}
	VAL r8 = pop_resource();
	return r8;
}
static VAL mw_mirth_type_StackType_codZThen (VAL x1, VAL x2) {
	push_resource(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	incref(v0);
	push_value(v0);
	int64_t v1 = mw_mirth_type_StackType_unitZAsk(v0);
	if (((bool)v1)) {
		VAL v2 = pop_value();
		decref(v2);
	} else {
		STR* v3;
		STRLIT(v3, " ", 1);
		VAL r4 = pop_resource();
		VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), r4));
		VAL v6 = pop_value();
		VAL v7 = (mw_mirth_type_StackType_stackZThen(v5, v6));
		push_resource(v7);
	}
	VAL r8 = pop_resource();
	return r8;
}
static void mw_mirth_type_StackType_baseZThen (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v0 = 0LL /* False */;
			push_resource(x1);
			push_i64(v0);
		} break;
		case 4LL: { // STMeta
			push_resource(x1);
			uint64_t v1 = mtp_mirth_type_StackType_STMeta(x2);
			STR* v2;
			STRLIT(v2, "*", 1);
			VAL r3 = pop_resource();
			push_u64(v1);
			VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v2), r3));
			uint64_t v5 = pop_u64();
			VAL v6 = (mw_mirth_type_MetaVar_typeZThen(v4, v5));
			int64_t v7 = 1LL /* True */;
			push_resource(v6);
			push_i64(v7);
		} break;
		case 3LL: { // STVar
			push_resource(x1);
			uint64_t v8 = mtp_mirth_type_StackType_STVar(x2);
			push_u64(v8);
			int64_t v9 = mw_mirth_var_Var_isZ_stackZAsk(v8);
			if (((bool)v9)) {
			} else {
				STR* v10;
				STRLIT(v10, "* ", 2);
				VAL r11 = pop_resource();
				VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), r11));
				push_resource(v12);
			}
			uint64_t v13 = pop_u64();
			VAL r14 = pop_resource();
			VAL v15 = (mw_mirth_var_Var_typeZThen(r14, v13));
			int64_t v16 = 1LL /* True */;
			push_resource(v15);
			push_i64(v16);
		} break;
		default: {
			push_resource(x1);
			VAL v17 = mw_mirth_type_StackType_ZToType(x2);
			STR* v18;
			STRLIT(v18, "* ", 2);
			VAL r19 = pop_resource();
			push_value(v17);
			VAL v20 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v18), r19));
			VAL v21 = pop_value();
			VAL v22 = (mw_mirth_type_Type_typeZThen(v21, v20));
			int64_t v23 = 1LL /* True */;
			push_resource(v22);
			push_i64(v23);
		} break;
	}
}
static VAL mw_mirth_type_StackType_stackZThen (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_type_StackType_split4(x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL r4 = pop_resource();
	mw_mirth_type_StackType_baseZThen(r4, v3);
	mw_std_list_List_1_uncons(v2);
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		int64_t v8 = mw_std_maybe_Maybe_1_someZAsk(v7);
		if (!((bool)v8)) break;
		VAL v9 = pop_value();
		VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
		VAL v11 = pop_value();
		int64_t v12 = pop_i64();
		if (((bool)v12)) {
			STR* v13;
			STRLIT(v13, " ", 1);
			VAL r14 = pop_resource();
			push_value(v10);
			VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), r14));
			push_resource(v15);
		} else {
			push_value(v10);
		}
		VAL v16 = pop_value();
		VAL v17;
		VAL v18;
		value_uncons(v16, &v17, &v18);
		VAL v19;
		VAL v20;
		value_uncons(v17, &v19, &v20);
		decref(v19);
		push_value(v20);
		VAL v21 = mw_mirth_label_Label_ZToStr(VU64(v18));
		VAL r22 = pop_resource();
		VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(v21, r22));
		STR* v24;
		STRLIT(v24, ":", 1);
		VAL v25 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), v23));
		VAL v26 = pop_value();
		switch (get_data_tag(v26)) {
			case 0LL: { // Left
				push_resource(v25);
				VAL v27 = mtp_std_either_Either_2_Left(v26);
				VAL r28 = pop_resource();
				VAL v29 = (mw_mirth_type_Type_typeZThen(v27, r28));
				push_resource(v29);
			} break;
			case 1LL: { // Right
				push_resource(v25);
				VAL v30 = mtp_std_either_Either_2_Right(v26);
				VAL r31 = pop_resource();
				VAL v32 = (mw_mirth_type_Resource_typeZThen(r31, v30));
				push_resource(v32);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(v25);
			}
		}
		int64_t v33 = 1LL /* True */;
		push_i64(v33);
		mw_std_list_List_1_uncons(v11);
		VAL v34 = pop_value();
		VAL v35 = pop_value();
		push_value(v34);
		push_value(v35);
	}
	VAL v36 = pop_value();
	decref(v36);
	VAL v37 = pop_value();
	decref(v37);
	mw_std_list_List_1_uncons(v1);
	VAL v38 = pop_value();
	VAL v39 = pop_value();
	push_value(v38);
	push_value(v39);
	while(1) {
		VAL v40 = pop_value();
		incref(v40);
		push_value(v40);
		int64_t v41 = mw_std_maybe_Maybe_1_someZAsk(v40);
		if (!((bool)v41)) break;
		VAL v42 = pop_value();
		VAL v43 = mw_std_maybe_Maybe_1_unwrap(v42);
		VAL v44 = pop_value();
		int64_t v45 = pop_i64();
		if (((bool)v45)) {
			STR* v46;
			STRLIT(v46, " ", 1);
			VAL r47 = pop_resource();
			push_value(v43);
			VAL v48 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v46), r47));
			push_resource(v48);
		} else {
			push_value(v43);
		}
		VAL r49 = pop_resource();
		VAL v50 = pop_value();
		VAL v51 = (mw_mirth_type_Type_typeZThen(v50, r49));
		int64_t v52 = 1LL /* True */;
		push_resource(v51);
		push_i64(v52);
		mw_std_list_List_1_uncons(v44);
		VAL v53 = pop_value();
		VAL v54 = pop_value();
		push_value(v53);
		push_value(v54);
	}
	VAL v55 = pop_value();
	decref(v55);
	VAL v56 = pop_value();
	decref(v56);
	mw_std_list_List_1_uncons(v0);
	VAL v57 = pop_value();
	VAL v58 = pop_value();
	push_value(v57);
	push_value(v58);
	while(1) {
		VAL v59 = pop_value();
		incref(v59);
		push_value(v59);
		int64_t v60 = mw_std_maybe_Maybe_1_someZAsk(v59);
		if (!((bool)v60)) break;
		VAL v61 = pop_value();
		VAL v62 = mw_std_maybe_Maybe_1_unwrap(v61);
		VAL v63 = pop_value();
		int64_t v64 = pop_i64();
		if (((bool)v64)) {
			STR* v65;
			STRLIT(v65, " ", 1);
			VAL r66 = pop_resource();
			push_value(v62);
			VAL v67 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v65), r66));
			push_resource(v67);
		} else {
			push_value(v62);
		}
		VAL v68 = pop_value();
		VAL r69 = pop_resource();
		VAL v70 = (mw_mirth_type_Resource_typeZThen(r69, v68));
		int64_t v71 = 1LL /* True */;
		push_resource(v70);
		push_i64(v71);
		mw_std_list_List_1_uncons(v63);
		VAL v72 = pop_value();
		VAL v73 = pop_value();
		push_value(v72);
		push_value(v73);
	}
	VAL v74 = pop_value();
	decref(v74);
	VAL v75 = pop_value();
	decref(v75);
	int64_t v76 = pop_i64();
	VAL r77 = pop_resource();
	return r77;
}
static void mw_mirth_type_StackType_semifreshen (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	switch (get_data_tag(v0)) {
		case 2LL: { // STACK_TYPE_UNIT
			VAL v1 = pop_value();
			incref(v1);
			push_value(v1);
			push_value(v1);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			mw_mirth_type_StackType_semifreshen(v4, v3);
			VAL v5 = pop_value();
			VAL v6 = mtw_mirth_type_StackType_STCons(v5, v2);
			push_value(v6);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			mw_mirth_type_StackType_semifreshen(v9, v8);
			VAL v10 = pop_value();
			VAL v11 = mtw_mirth_type_StackType_STWith(v10, v7);
			push_value(v11);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			VAL v15 = pop_value();
			mw_mirth_type_StackType_semifreshen(v15, v14);
			VAL v16 = pop_value();
			VAL v17 = mtw_mirth_type_StackType_STConsLabel(v16, v13, VU64(v12));
			push_value(v17);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			mw_mirth_type_StackType_semifreshen(v21, v20);
			VAL v22 = pop_value();
			VAL v23 = mtw_mirth_type_StackType_STWithLabel(v22, v19, VU64(v18));
			push_value(v23);
		} break;
		default: {
			STR* v24;
			STRLIT(v24, "expected unit-based stack in semifreshen!", 41);
			push_value(v0);
			push_str(v24);
			do_panic();
		} break;
	}
}
static void mw_mirth_type_StackType_freshen (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = mw_mirth_type_StackType_expand(x2);
	switch (get_data_tag(v0)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v1 = 2LL /* STACK_TYPE_UNIT */;
			push_i64(v1);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			mw_mirth_type_StackType_freshen(v4, v3);
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			mw_mirth_type_Type_freshen(v6, v2);
			VAL v7 = pop_value();
			VAL v8 = mtw_mirth_type_StackType_STCons(v5, v7);
			push_value(v8);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			mw_mirth_type_StackType_freshen(v11, v10);
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			mw_mirth_type_Resource_freshen(v13, v9);
			VAL v14 = pop_value();
			VAL v15 = mtw_mirth_type_StackType_STWith(v12, v14);
			push_value(v15);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			uint64_t v16 = pop_u64();
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			mw_mirth_type_StackType_freshen(v19, v18);
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			mw_mirth_type_Type_freshen(v21, v17);
			VAL v22 = pop_value();
			VAL v23 = mtw_mirth_type_StackType_STConsLabel(v20, v22, v16);
			push_value(v23);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			uint64_t v24 = pop_u64();
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			VAL v27 = pop_value();
			mw_mirth_type_StackType_freshen(v27, v26);
			VAL v28 = pop_value();
			VAL v29 = pop_value();
			mw_mirth_type_Resource_freshen(v29, v25);
			VAL v30 = pop_value();
			VAL v31 = mtw_mirth_type_StackType_STWithLabel(v28, v30, v24);
			push_value(v31);
		} break;
		default: {
			VAL v32 = mw_mirth_type_StackType_ZToType(v0);
			VAL v33 = pop_value();
			mw_mirth_type_Type_freshen(v33, v32);
			VAL v34 = pop_value();
			VAL v35 = mw_mirth_type_Type_ZToStackType(v34);
			push_value(v35);
		} break;
	}
}
static void mw_mirth_type_StackType_freshenZ_aux (VAL x1, VAL x2, VAL x3) {
	push_value(x1);
	push_value(x2);
	VAL v0 = mw_mirth_type_StackType_expand(x3);
	switch (get_data_tag(v0)) {
		case 2LL: { // STACK_TYPE_UNIT
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v1);
			push_value(v2);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v0);
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux(v6, v5, v4);
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			mw_mirth_type_Type_freshen(v8, v3);
			VAL v9 = pop_value();
			VAL v10 = mtw_mirth_type_StackType_STCons(v7, v9);
			push_value(v10);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v0);
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux(v14, v13, v12);
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			mw_mirth_type_Resource_freshen(v16, v11);
			VAL v17 = pop_value();
			VAL v18 = mtw_mirth_type_StackType_STWith(v15, v17);
			push_value(v18);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel(v0);
			uint64_t v19 = pop_u64();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux(v23, v22, v21);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			mw_mirth_type_Type_freshen(v25, v20);
			VAL v26 = pop_value();
			VAL v27 = mtw_mirth_type_StackType_STConsLabel(v24, v26, v19);
			push_value(v27);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel(v0);
			uint64_t v28 = pop_u64();
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux(v32, v31, v30);
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			mw_mirth_type_Resource_freshen(v34, v29);
			VAL v35 = pop_value();
			VAL v36 = mtw_mirth_type_StackType_STWithLabel(v33, v35, v28);
			push_value(v36);
		} break;
		default: {
			VAL v37 = mw_mirth_type_StackType_ZToType(v0);
			VAL v38 = pop_value();
			mw_mirth_type_Type_freshen(v38, v37);
			VAL v39 = pop_value();
			VAL v40 = mw_mirth_type_Type_ZToStackType(v39);
			push_value(v40);
		} break;
	}
}
static void mw_mirth_type_StackType_rigidifyZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v0 = 0LL /* STACK_TYPE_ERROR */;
			push_resource(x1);
			push_value(x2);
			push_i64(v0);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v1 = 1LL /* STACK_TYPE_DONT_CARE */;
			push_resource(x1);
			push_value(x2);
			push_i64(v1);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v2 = 2LL /* STACK_TYPE_UNIT */;
			push_resource(x1);
			push_value(x2);
			push_i64(v2);
		} break;
		case 4LL: { // STMeta
			push_resource(x1);
			push_value(x2);
			uint64_t v3 = mtp_mirth_type_StackType_STMeta(x3);
			push_u64(v3);
			VAL v4 = mw_mirth_type_MetaVar_typeZAsk(v3);
			switch (get_data_tag(v4)) {
				case 0LL: { // None
					uint64_t v5 = pop_u64();
					VAL v6 = pop_value();
					mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang(v6);
					uint64_t v7 = pop_u64();
					VAL v8 = mtw_mirth_type_Type_TVar(v7);
					incref(v8);
					push_value(v8);
					VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
					void* v10 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v5);
					mut_set(v9, MKPTR(v10));
				} break;
				case 1LL: { // Some
					VAL v11 = mtp_std_maybe_Maybe_1_Some(v4);
					VAL v12 = pop_value();
					decref(v12);
					push_value(v11);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v13 = pop_value();
			VAL v14 = mw_mirth_type_Type_ZToStackType(v13);
			VAL v15 = pop_value();
			VAL r16 = pop_resource();
			mw_mirth_type_StackType_rigidifyZBang(r16, v15, v14);
		} break;
		case 3LL: { // STVar
			push_resource(x1);
			push_value(x2);
			uint64_t v17 = mtp_mirth_type_StackType_STVar(x3);
			VAL v18 = mtw_mirth_type_StackType_STVar(v17);
			push_value(v18);
		} break;
		case 5LL: { // STCons
			push_resource(x1);
			push_value(x2);
			mtp_mirth_type_StackType_STCons(x3);
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			VAL r22 = pop_resource();
			mw_mirth_type_StackType_rigidifyZBang(r22, v21, v20);
			VAL v23 = pop_value();
			VAL v24 = pop_value();
			VAL r25 = pop_resource();
			mw_mirth_type_Type_rigidifyZBang(r25, v24, v19);
			VAL v26 = pop_value();
			VAL v27 = mtw_mirth_type_StackType_STCons(v23, v26);
			push_value(v27);
		} break;
		case 6LL: { // STConsLabel
			push_resource(x1);
			push_value(x2);
			mtp_mirth_type_StackType_STConsLabel(x3);
			uint64_t v28 = pop_u64();
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			VAL r32 = pop_resource();
			mw_mirth_type_StackType_rigidifyZBang(r32, v31, v30);
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			VAL r35 = pop_resource();
			mw_mirth_type_Type_rigidifyZBang(r35, v34, v29);
			VAL v36 = pop_value();
			VAL v37 = mtw_mirth_type_StackType_STConsLabel(v33, v36, v28);
			push_value(v37);
		} break;
		case 7LL: { // STWith
			push_resource(x1);
			push_value(x2);
			mtp_mirth_type_StackType_STWith(x3);
			VAL v38 = pop_value();
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			VAL r41 = pop_resource();
			mw_mirth_type_StackType_rigidifyZBang(r41, v40, v39);
			VAL v42 = pop_value();
			VAL v43 = pop_value();
			VAL r44 = pop_resource();
			mw_mirth_type_Resource_rigidifyZBang(r44, v43, v38);
			VAL v45 = pop_value();
			VAL v46 = mtw_mirth_type_StackType_STWith(v42, v45);
			push_value(v46);
		} break;
		case 8LL: { // STWithLabel
			push_resource(x1);
			push_value(x2);
			mtp_mirth_type_StackType_STWithLabel(x3);
			uint64_t v47 = pop_u64();
			VAL v48 = pop_value();
			VAL v49 = pop_value();
			VAL v50 = pop_value();
			VAL r51 = pop_resource();
			mw_mirth_type_StackType_rigidifyZBang(r51, v50, v49);
			VAL v52 = pop_value();
			VAL v53 = pop_value();
			VAL r54 = pop_resource();
			mw_mirth_type_Resource_rigidifyZBang(r54, v53, v48);
			VAL v55 = pop_value();
			VAL v56 = mtw_mirth_type_StackType_STWithLabel(v52, v55, v47);
			push_value(v56);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_value(x2);
		}
	}
}
static VAL mw_mirth_type_ArrowType_ZToType (VAL x1) {
	VAL v0 = mtw_mirth_type_Type_TMorphism(x1);
	return v0;
}
static VAL mw_mirth_type_ArrowType_invert (VAL x1) {
	mtp_mirth_type_ArrowType_ARROWz_TYPE(x1);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v0, v1);
	return v2;
}
static void mw_mirth_type_ArrowType_unpack (VAL x1) {
	mtp_mirth_type_ArrowType_ARROWz_TYPE(x1);
}
static VAL mw_mirth_type_ArrowType_dom (VAL x1) {
	mw_mirth_type_ArrowType_unpack(x1);
	VAL v0 = pop_value();
	decref(v0);
	VAL v1 = pop_value();
	return v1;
}
static VAL mw_mirth_type_ArrowType_cod (VAL x1) {
	mw_mirth_type_ArrowType_unpack(x1);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	return v0;
}
static void mw_mirth_type_ArrowType_unifyZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	push_resource(x1);
	push_resource(MKU64(x2));
	mw_mirth_type_ArrowType_unpack(x3);
	mw_mirth_type_ArrowType_unpack(x4);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	uint64_t r4 = VU64(pop_resource());
	VAL r5 = pop_resource();
	mw_mirth_type_StackType_unifyZBang(r5, r4, v3, v1);
	VAL v6 = pop_value();
	uint64_t r7 = VU64(pop_resource());
	VAL r8 = pop_resource();
	mw_mirth_type_StackType_unifyZBang(r8, r7, v2, v0);
	VAL v9 = pop_value();
	VAL v10 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v6, v9);
	push_value(v10);
}
static void mw_mirth_type_ArrowType_unifyZ_errorZBang (VAL x1, uint64_t x2, VAL x3) {
	push_resource(x1);
	push_resource(MKU64(x2));
	mw_mirth_type_ArrowType_unpack(x3);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	uint64_t r2 = VU64(pop_resource());
	VAL r3 = pop_resource();
	mw_mirth_type_StackType_unifyZ_errorZBang(r3, r2, v1);
	VAL v4 = pop_value();
	uint64_t r5 = VU64(pop_resource());
	VAL r6 = pop_resource();
	mw_mirth_type_StackType_unifyZ_errorZBang(r6, r5, v0);
	VAL v7 = pop_value();
	VAL v8 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v4, v7);
	push_value(v8);
}
static int64_t mw_mirth_type_ArrowType_hasZ_metaZAsk (uint64_t x1, VAL x2) {
	push_u64(x1);
	mw_mirth_type_ArrowType_unpack(x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	int64_t v3 = mw_mirth_type_StackType_hasZ_metaZAsk(VU64(v2), v0);
	if (((bool)v3)) {
		VAL v4 = pop_value();
		decref(v4);
		VAL v5 = pop_value();
		decref(v5);
		int64_t v6 = 1LL /* True */;
		push_i64(v6);
	} else {
		VAL v7 = pop_value();
		uint64_t v8 = pop_u64();
		int64_t v9 = mw_mirth_type_StackType_hasZ_metaZAsk(v8, v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	return v10;
}
static VAL mw_mirth_type_ArrowType_sigZThen (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_type_ArrowType_unpack(x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL r2 = pop_resource();
	push_value(v0);
	VAL v3 = (mw_mirth_type_StackType_domZThen(r2, v1));
	STR* v4;
	STRLIT(v4, "--", 2);
	VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), v3));
	VAL v6 = pop_value();
	VAL v7 = (mw_mirth_type_StackType_codZThen(v5, v6));
	return v7;
}
static VAL mw_mirth_type_ArrowType_semifreshenZ_sig (VAL x1) {
	incref(x1);
	push_value(x1);
	int64_t v0 = mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk(x1);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		VAL v2 = mw_mirth_type_ArrowType_semifreshenZ_aux(v1);
		push_value(v2);
	} else {
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_type_ArrowType_semifreshenZ_aux (VAL x1) {
	push_value(x1);
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	VAL v2 = pop_value();
	push_value(v1);
	mw_mirth_type_ArrowType_unpack(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	mw_mirth_type_StackType_semifreshen(v5, v4);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	mw_mirth_type_StackType_semifreshen(v7, v3);
	VAL v8 = pop_value();
	VAL v9 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v6, v8);
	VAL v10 = pop_value();
	decref(v10);
	return v9;
}
static int64_t mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk (VAL x1) {
	mw_mirth_type_ArrowType_unpack(x1);
	VAL v0 = pop_value();
	VAL v1 = mw_mirth_type_StackType_base(v0);
	int64_t v2 = mw_mirth_type_StackType_unitZAsk(v1);
	if (((bool)v2)) {
		VAL v3 = pop_value();
		VAL v4 = mw_mirth_type_StackType_base(v3);
		int64_t v5 = mw_mirth_type_StackType_unitZAsk(v4);
		push_i64(v5);
	} else {
		VAL v6 = pop_value();
		decref(v6);
		int64_t v7 = 0LL /* False */;
		push_i64(v7);
	}
	int64_t v8 = pop_i64();
	return v8;
}
static void mw_mirth_type_ArrowType_freshenZ_sig (VAL x1, VAL x2) {
	incref(x2);
	push_value(x1);
	push_value(x2);
	int64_t v0 = mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk(x2);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		VAL v2 = pop_value();
		mw_mirth_type_ArrowType_freshenZ_sigZ_aux(v2, v1);
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		mw_mirth_type_ArrowType_freshen(v4, v3);
	}
}
static void mw_mirth_type_ArrowType_freshenZ_sigZ_aux (VAL x1, VAL x2) {
	push_value(x1);
	push_value(x2);
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v1);
	push_value(v3);
	mw_mirth_type_ArrowType_unpack(v2);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	mw_mirth_type_StackType_freshenZ_aux(v7, v6, v5);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	mw_mirth_type_StackType_freshenZ_aux(v10, v9, v4);
	VAL v11 = pop_value();
	VAL v12 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v8, v11);
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	decref(v14);
	push_value(v13);
	push_value(v12);
}
static void mw_mirth_type_ArrowType_freshen (VAL x1, VAL x2) {
	push_value(x1);
	mw_mirth_type_ArrowType_unpack(x2);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	mw_mirth_type_StackType_freshen(v2, v1);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	mw_mirth_type_StackType_freshen(v4, v0);
	VAL v5 = pop_value();
	VAL v6 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v3, v5);
	push_value(v6);
}
static void mw_mirth_type_ArrowType_rigidifyZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x1);
	push_value(x2);
	mw_mirth_type_ArrowType_unpack(x3);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	mw_mirth_type_StackType_rigidifyZBang(r3, v2, v1);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	VAL r6 = pop_resource();
	mw_mirth_type_StackType_rigidifyZBang(r6, v5, v0);
	VAL v7 = pop_value();
	VAL v8 = mtw_mirth_type_ArrowType_ARROWz_TYPE(v4, v7);
	push_value(v8);
}
static void mw_mirth_type_ArrowType_rigidifyZ_sigZBang (VAL x1, VAL x2, VAL x3) {
	mw_mirth_type_ArrowType_rigidifyZBang(x1, x2, x3);
}
static VAL mw_mirth_type_Subst_nil (void) {
	int64_t v0 = 0LL /* SUBST_NIL */;
	return MKI64(v0);
}
static VAL mw_mirth_type_Subst_cons (VAL x1, uint64_t x2, VAL x3) {
	VAL v0 = mtw_mirth_type_Subst_SUBSTz_CON(x3, x1, x2);
	return v0;
}
static int64_t mw_mirth_type_Subst_hasZ_varZAsk (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // SUBST_NIL
			int64_t v0 = 0LL /* False */;
			push_i64(v0);
		} break;
		case 1LL: { // SUBST_CON
			push_u64(x1);
			mtp_mirth_type_Subst_SUBSTz_CON(x2);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v3);
			int64_t v5 = mw_mirth_var_Var_ZEqualZEqual(VU64(v1), VU64(v4));
			if (((bool)v5)) {
				VAL v6 = pop_value();
				decref(v6);
				VAL v7 = pop_value();
				decref(v7);
				int64_t v8 = 1LL /* True */;
				push_i64(v8);
			} else {
				VAL v9 = pop_value();
				uint64_t v10 = pop_u64();
				int64_t v11 = mw_mirth_type_Subst_hasZ_varZAsk(v10, v9);
				push_i64(v11);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
		}
	}
	int64_t v12 = pop_i64();
	return v12;
}
static VAL mw_mirth_type_Subst_getZ_var (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // SUBST_NIL
			int64_t v0 = 0LL /* TYPE_ERROR */;
			push_i64(v0);
		} break;
		case 1LL: { // SUBST_CON
			push_u64(x1);
			mtp_mirth_type_Subst_SUBSTz_CON(x2);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v3);
			push_value(v2);
			int64_t v5 = mw_mirth_var_Var_ZEqualZEqual(VU64(v1), VU64(v4));
			if (((bool)v5)) {
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				decref(v7);
				VAL v8 = pop_value();
				decref(v8);
				push_value(v6);
			} else {
				VAL v9 = pop_value();
				decref(v9);
				VAL v10 = pop_value();
				uint64_t v11 = pop_u64();
				VAL v12 = mw_mirth_type_Subst_getZ_var(v11, v10);
				push_value(v12);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
		}
	}
	VAL v13 = pop_value();
	return v13;
}
static VAL mw_mirth_type_StackTypePart_cons (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // STPCons
			push_value(x1);
			VAL v0 = mtp_mirth_type_StackTypePart_STPCons(x2);
			VAL v1 = pop_value();
			VAL v2 = mtw_mirth_type_StackType_STCons(v1, v0);
			push_value(v2);
		} break;
		case 1LL: { // STPConsLabel
			push_value(x1);
			mtp_mirth_type_StackTypePart_STPConsLabel(x2);
			uint64_t v3 = pop_u64();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			VAL v6 = mtw_mirth_type_StackType_STConsLabel(v5, v4, v3);
			push_value(v6);
		} break;
		case 2LL: { // STPWith
			push_value(x1);
			VAL v7 = mtp_mirth_type_StackTypePart_STPWith(x2);
			VAL v8 = pop_value();
			VAL v9 = mtw_mirth_type_StackType_STWith(v8, v7);
			push_value(v9);
		} break;
		case 3LL: { // STPWithLabel
			push_value(x1);
			mtp_mirth_type_StackTypePart_STPWithLabel(x2);
			uint64_t v10 = pop_u64();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			VAL v13 = mtw_mirth_type_StackType_STWithLabel(v12, v11, v10);
			push_value(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	VAL v14 = pop_value();
	return v14;
}
static void mw_mirth_type_StackType_splitZ_parts (VAL x1) {
	int64_t v0 = 0LL /* Nil */;
	switch (get_data_tag(x1)) {
		case 5LL: { // STCons
			lpush(&lbl_parts, MKI64(v0));
			mtp_mirth_type_StackType_STCons(x1);
			VAL v1 = pop_value();
			VAL v2 = mtw_mirth_type_StackTypePart_STPCons(v1);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 6LL: { // STConsLabel
			lpush(&lbl_parts, MKI64(v0));
			mtp_mirth_type_StackType_STConsLabel(x1);
			uint64_t v4 = pop_u64();
			VAL v5 = pop_value();
			VAL v6 = mtw_mirth_type_StackTypePart_STPConsLabel(v5, v4);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 7LL: { // STWith
			lpush(&lbl_parts, MKI64(v0));
			mtp_mirth_type_StackType_STWith(x1);
			VAL v8 = pop_value();
			VAL v9 = mtw_mirth_type_StackTypePart_STPWith(v8);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			push_value(v10);
		} break;
		case 8LL: { // STWithLabel
			lpush(&lbl_parts, MKI64(v0));
			mtp_mirth_type_StackType_STWithLabel(x1);
			uint64_t v11 = pop_u64();
			VAL v12 = pop_value();
			VAL v13 = mtw_mirth_type_StackTypePart_STPWithLabel(v12, v11);
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		default: {
			int64_t v15 = 0LL /* None */;
			lpush(&lbl_parts, MKI64(v0));
			push_value(x1);
			push_i64(v15);
		} break;
	}
	while(1) {
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		int64_t v17 = mw_std_maybe_Maybe_1_someZAsk(v16);
		if (!((bool)v17)) break;
		VAL v18 = pop_value();
		VAL v19 = mw_std_maybe_Maybe_1_unwrap(v18);
		VAL v20 = lpop(&lbl_parts);
		VAL v21 = mtw_std_list_List_1_Cons(v19, v20);
		VAL v22 = pop_value();
		switch (get_data_tag(v22)) {
			case 5LL: { // STCons
				lpush(&lbl_parts, v21);
				mtp_mirth_type_StackType_STCons(v22);
				VAL v23 = pop_value();
				VAL v24 = mtw_mirth_type_StackTypePart_STPCons(v23);
				VAL v25 = mtw_std_maybe_Maybe_1_Some(v24);
				push_value(v25);
			} break;
			case 6LL: { // STConsLabel
				lpush(&lbl_parts, v21);
				mtp_mirth_type_StackType_STConsLabel(v22);
				uint64_t v26 = pop_u64();
				VAL v27 = pop_value();
				VAL v28 = mtw_mirth_type_StackTypePart_STPConsLabel(v27, v26);
				VAL v29 = mtw_std_maybe_Maybe_1_Some(v28);
				push_value(v29);
			} break;
			case 7LL: { // STWith
				lpush(&lbl_parts, v21);
				mtp_mirth_type_StackType_STWith(v22);
				VAL v30 = pop_value();
				VAL v31 = mtw_mirth_type_StackTypePart_STPWith(v30);
				VAL v32 = mtw_std_maybe_Maybe_1_Some(v31);
				push_value(v32);
			} break;
			case 8LL: { // STWithLabel
				lpush(&lbl_parts, v21);
				mtp_mirth_type_StackType_STWithLabel(v22);
				uint64_t v33 = pop_u64();
				VAL v34 = pop_value();
				VAL v35 = mtw_mirth_type_StackTypePart_STPWithLabel(v34, v33);
				VAL v36 = mtw_std_maybe_Maybe_1_Some(v35);
				push_value(v36);
			} break;
			default: {
				int64_t v37 = 0LL /* None */;
				lpush(&lbl_parts, v21);
				push_value(v22);
				push_i64(v37);
			} break;
		}
	}
	VAL v38 = pop_value();
	decref(v38);
	VAL v39 = lpop(&lbl_parts);
	push_value(v39);
}
static VAL mw_mirth_type_CType_cname (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // IntLike
			VAL v0 = mtp_mirth_type_CType_IntLike(x1);
			push_value(v0);
		} break;
		case 1LL: { // F32Like
			VAL v1 = mtp_mirth_type_CType_F32Like(x1);
			push_value(v1);
		} break;
		case 2LL: { // F64Like
			VAL v2 = mtp_mirth_type_CType_F64Like(x1);
			push_value(v2);
		} break;
		case 3LL: { // PtrLike
			VAL v3 = mtp_mirth_type_CType_PtrLike(x1);
			push_value(v3);
		} break;
		case 4LL: { // FnPtr
			VAL v4 = mtp_mirth_type_CType_FnPtr(x1);
			push_value(v4);
		} break;
		case 5LL: { // Phantom
			STR* v5;
			STRLIT(v5, "void", 4);
			push_str(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v6 = pop_value();
	return v6;
}
static int64_t mw_mirth_type_CType_phantomZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 5LL: { // Phantom
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static void mw_mirth_type_Resource_ctype (VAL x1, VAL x2) {
	mw_mirth_type_Type_ctype(x1, x2);
}
static void mw_mirth_type_Type_ctype (VAL x1, VAL x2) {
	incref(x2);
	push_value(x2);
	mw_mirth_type_Type_ctypeZAsk(x1, x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v3;
			STRLIT(v3, "", 0);
			VAL v4 = pop_value();
			VAL v5 = (mw_mirth_type_Type_typeZThen(v4, MKSTR(v3)));
			STR* v6;
			STRLIT(v6, " doesn't have a C representation.", 33);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), v5));
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_mirth_ZPlusMirth_errorZBang(v7, r8));
			int64_t v10 = 5LL /* Phantom */;
			push_resource(v9);
			push_i64(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_type_Resource_ctypeZAsk (VAL x1, VAL x2) {
	mw_mirth_type_Type_ctypeZAsk(x1, x2);
}
static void mw_mirth_type_Type_ctypeZAsk (VAL x1, VAL x2) {
	push_resource(x1);
	VAL v0 = mw_mirth_type_Type_expand(x2);
	switch (get_data_tag(v0)) {
		case 2LL: { // TPrim
			int64_t v1 = mtp_mirth_type_Type_TPrim(v0);
			VAL r2 = pop_resource();
			mw_mirth_type_PrimType_ctypeZAsk(r2, v1);
		} break;
		case 7LL: { // TData
			uint64_t v3 = mtp_mirth_type_Type_TData(v0);
			VAL r4 = pop_resource();
			mw_mirth_data_Data_ctypeZAsk(v3, r4);
		} break;
		case 10LL: { // TMorphism
			VAL v5 = mtp_mirth_type_Type_TMorphism(v0);
			decref(v5);
			STR* v6;
			STRLIT(v6, "FNPTR", 5);
			VAL v7 = mtw_mirth_type_CType_FnPtr(MKSTR(v6));
			VAL v8 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v8);
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp(v0);
			VAL v9 = pop_value();
			VAL r10 = pop_resource();
			mw_mirth_type_Type_ctypeZAsk(r10, v9);
			VAL v11 = pop_value();
			switch (get_data_tag(v11)) {
				case 1LL: { // Some
					VAL v12 = mtp_std_maybe_Maybe_1_Some(v11);
					VAL v13 = pop_value();
					incref(v13);
					VAL r14 = pop_resource();
					push_value(v13);
					mw_mirth_type_Type_ctype1ZAsk(r14, v12, v13);
				} break;
				case 0LL: { // None
					int64_t v15 = 0LL /* None */;
					push_i64(v15);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			decref(v17);
			push_value(v16);
		} break;
		default: {
			decref(v0);
			int64_t v18 = 0LL /* None */;
			push_i64(v18);
		} break;
	}
}
static void mw_mirth_type_Type_ctype1ZAsk (VAL x1, VAL x2, VAL x3) {
	push_resource(x1);
	push_value(x2);
	VAL v0 = mw_mirth_type_Type_expand(x3);
	switch (get_data_tag(v0)) {
		case 7LL: { // TData
			uint64_t v1 = mtp_mirth_type_Type_TData(v0);
			VAL v2 = pop_value();
			VAL r3 = pop_resource();
			mw_mirth_data_Data_ctype1ZAsk(r3, v2, v1);
		} break;
		default: {
			decref(v0);
			VAL v4 = pop_value();
			decref(v4);
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
	}
}
static void mw_mirth_type_PrimType_ctypeZAsk (VAL x1, int64_t x2) {
	switch (x2) {
		case 6LL: { // PRIM_TYPE_PTR
			STR* v0;
			STRLIT(v0, "void*", 5);
			push_resource(x1);
			VAL v1 = mtw_mirth_type_CType_PtrLike(MKSTR(v0));
			VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			int64_t v3 = 5LL /* Phantom */;
			push_resource(x1);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKI64(v3));
			push_value(v4);
		} break;
		case 4LL: { // PRIM_TYPE_F32
			STR* v5;
			STRLIT(v5, "float", 5);
			push_resource(x1);
			VAL v6 = mtw_mirth_type_CType_F32Like(MKSTR(v5));
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 5LL: { // PRIM_TYPE_F64
			STR* v8;
			STRLIT(v8, "double", 6);
			push_resource(x1);
			VAL v9 = mtw_mirth_type_CType_F64Like(MKSTR(v8));
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			push_value(v10);
		} break;
		default: {
			int64_t v11 = 0LL /* None */;
			push_resource(x1);
			push_i64(v11);
		} break;
	}
}
static void mw_mirth_data_Data_ctype1ZAsk (VAL x1, VAL x2, uint64_t x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[52]);
	decref(v0);
	push_value(x2);
	push_u64(x3);
	push_resource(x1);
	int64_t v2 = mw_mirth_data_Data_ZEqualZEqual(x3, v1);
	if (((bool)v2)) {
		uint64_t v3 = pop_u64();
		VAL v4 = pop_value();
		VAL v5 = mw_mirth_type_CType_cname(v4);
		STR* v6;
		STRLIT(v6, " *", 2);
		STR* v7 = str_cat(VSTR(v5), v6);
		VAL v8 = mtw_mirth_type_CType_PtrLike(MKSTR(v7));
		VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
		push_value(v9);
	} else {
		uint64_t v10 = pop_u64();
		VAL r11 = pop_resource();
		VAL v12 = VVAL(VTUP(r11)->cells[4]);
		incref(v12);
		uint64_t v13 = VU64(VTUP(v12)->cells[54]);
		decref(v12);
		push_u64(v10);
		push_resource(r11);
		int64_t v14 = mw_mirth_data_Data_ZEqualZEqual(v10, v13);
		if (((bool)v14)) {
			uint64_t v15 = pop_u64();
			VAL v16 = pop_value();
			switch (get_data_tag(v16)) {
				case 0LL: { // IntLike
					VAL v17 = mtp_mirth_type_CType_IntLike(v16);
					STR* v18;
					STRLIT(v18, "const ", 6);
					STR* v19 = str_cat(v18, VSTR(v17));
					VAL v20 = mtw_mirth_type_CType_IntLike(MKSTR(v19));
					VAL v21 = mtw_std_maybe_Maybe_1_Some(v20);
					push_value(v21);
				} break;
				case 1LL: { // F32Like
					VAL v22 = mtp_mirth_type_CType_F32Like(v16);
					STR* v23;
					STRLIT(v23, "const ", 6);
					STR* v24 = str_cat(v23, VSTR(v22));
					VAL v25 = mtw_mirth_type_CType_F32Like(MKSTR(v24));
					VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
					push_value(v26);
				} break;
				case 2LL: { // F64Like
					VAL v27 = mtp_mirth_type_CType_F64Like(v16);
					STR* v28;
					STRLIT(v28, "const ", 6);
					STR* v29 = str_cat(v28, VSTR(v27));
					VAL v30 = mtw_mirth_type_CType_F64Like(MKSTR(v29));
					VAL v31 = mtw_std_maybe_Maybe_1_Some(v30);
					push_value(v31);
				} break;
				case 4LL: { // FnPtr
					VAL v32 = mtp_mirth_type_CType_FnPtr(v16);
					STR* v33;
					STRLIT(v33, "const ", 6);
					STR* v34 = str_cat(v33, VSTR(v32));
					VAL v35 = mtw_mirth_type_CType_FnPtr(MKSTR(v34));
					VAL v36 = mtw_std_maybe_Maybe_1_Some(v35);
					push_value(v36);
				} break;
				case 3LL: { // PtrLike
					VAL v37 = mtp_mirth_type_CType_PtrLike(v16);
					STR* v38;
					STRLIT(v38, " const", 6);
					STR* v39 = str_cat(VSTR(v37), v38);
					VAL v40 = mtw_mirth_type_CType_PtrLike(MKSTR(v39));
					VAL v41 = mtw_std_maybe_Maybe_1_Some(v40);
					push_value(v41);
				} break;
				case 5LL: { // Phantom
					int64_t v42 = 5LL /* Phantom */;
					VAL v43 = mtw_std_maybe_Maybe_1_Some(MKI64(v42));
					push_value(v43);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} else {
			uint64_t v44 = pop_u64();
			VAL r45 = pop_resource();
			VAL v46 = VVAL(VTUP(r45)->cells[4]);
			incref(v46);
			uint64_t v47 = VU64(VTUP(v46)->cells[56]);
			decref(v46);
			push_u64(v44);
			push_resource(r45);
			int64_t v48 = mw_mirth_data_Data_ZEqualZEqual(v44, v47);
			if (((bool)v48)) {
				uint64_t v49 = pop_u64();
				VAL v50 = pop_value();
				switch (get_data_tag(v50)) {
					case 0LL: { // IntLike
						VAL v51 = mtp_mirth_type_CType_IntLike(v50);
						STR* v52;
						STRLIT(v52, "restrict ", 9);
						STR* v53 = str_cat(v52, VSTR(v51));
						VAL v54 = mtw_mirth_type_CType_IntLike(MKSTR(v53));
						VAL v55 = mtw_std_maybe_Maybe_1_Some(v54);
						push_value(v55);
					} break;
					case 1LL: { // F32Like
						VAL v56 = mtp_mirth_type_CType_F32Like(v50);
						STR* v57;
						STRLIT(v57, "restrict ", 9);
						STR* v58 = str_cat(v57, VSTR(v56));
						VAL v59 = mtw_mirth_type_CType_F32Like(MKSTR(v58));
						VAL v60 = mtw_std_maybe_Maybe_1_Some(v59);
						push_value(v60);
					} break;
					case 2LL: { // F64Like
						VAL v61 = mtp_mirth_type_CType_F64Like(v50);
						STR* v62;
						STRLIT(v62, "restrict ", 9);
						STR* v63 = str_cat(v62, VSTR(v61));
						VAL v64 = mtw_mirth_type_CType_F64Like(MKSTR(v63));
						VAL v65 = mtw_std_maybe_Maybe_1_Some(v64);
						push_value(v65);
					} break;
					case 4LL: { // FnPtr
						VAL v66 = mtp_mirth_type_CType_FnPtr(v50);
						STR* v67;
						STRLIT(v67, "restrict ", 9);
						STR* v68 = str_cat(v67, VSTR(v66));
						VAL v69 = mtw_mirth_type_CType_FnPtr(MKSTR(v68));
						VAL v70 = mtw_std_maybe_Maybe_1_Some(v69);
						push_value(v70);
					} break;
					case 3LL: { // PtrLike
						VAL v71 = mtp_mirth_type_CType_PtrLike(v50);
						STR* v72;
						STRLIT(v72, " restrict", 9);
						STR* v73 = str_cat(VSTR(v71), v72);
						VAL v74 = mtw_mirth_type_CType_PtrLike(MKSTR(v73));
						VAL v75 = mtw_std_maybe_Maybe_1_Some(v74);
						push_value(v75);
					} break;
					case 5LL: { // Phantom
						int64_t v76 = 5LL /* Phantom */;
						VAL v77 = mtw_std_maybe_Maybe_1_Some(MKI64(v76));
						push_value(v77);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
			} else {
				uint64_t v78 = pop_u64();
				VAL r79 = pop_resource();
				VAL v80 = VVAL(VTUP(r79)->cells[4]);
				incref(v80);
				uint64_t v81 = VU64(VTUP(v80)->cells[58]);
				decref(v80);
				push_u64(v78);
				push_resource(r79);
				int64_t v82 = mw_mirth_data_Data_ZEqualZEqual(v78, v81);
				if (((bool)v82)) {
					uint64_t v83 = pop_u64();
					VAL v84 = pop_value();
					switch (get_data_tag(v84)) {
						case 0LL: { // IntLike
							VAL v85 = mtp_mirth_type_CType_IntLike(v84);
							STR* v86;
							STRLIT(v86, "volatile ", 9);
							STR* v87 = str_cat(v86, VSTR(v85));
							VAL v88 = mtw_mirth_type_CType_IntLike(MKSTR(v87));
							VAL v89 = mtw_std_maybe_Maybe_1_Some(v88);
							push_value(v89);
						} break;
						case 1LL: { // F32Like
							VAL v90 = mtp_mirth_type_CType_F32Like(v84);
							STR* v91;
							STRLIT(v91, "volatile ", 9);
							STR* v92 = str_cat(v91, VSTR(v90));
							VAL v93 = mtw_mirth_type_CType_F32Like(MKSTR(v92));
							VAL v94 = mtw_std_maybe_Maybe_1_Some(v93);
							push_value(v94);
						} break;
						case 2LL: { // F64Like
							VAL v95 = mtp_mirth_type_CType_F64Like(v84);
							STR* v96;
							STRLIT(v96, "volatile ", 9);
							STR* v97 = str_cat(v96, VSTR(v95));
							VAL v98 = mtw_mirth_type_CType_F64Like(MKSTR(v97));
							VAL v99 = mtw_std_maybe_Maybe_1_Some(v98);
							push_value(v99);
						} break;
						case 4LL: { // FnPtr
							VAL v100 = mtp_mirth_type_CType_FnPtr(v84);
							STR* v101;
							STRLIT(v101, "volatile ", 9);
							STR* v102 = str_cat(v101, VSTR(v100));
							VAL v103 = mtw_mirth_type_CType_FnPtr(MKSTR(v102));
							VAL v104 = mtw_std_maybe_Maybe_1_Some(v103);
							push_value(v104);
						} break;
						case 3LL: { // PtrLike
							VAL v105 = mtp_mirth_type_CType_PtrLike(v84);
							STR* v106;
							STRLIT(v106, " volatile", 9);
							STR* v107 = str_cat(VSTR(v105), v106);
							VAL v108 = mtw_mirth_type_CType_PtrLike(MKSTR(v107));
							VAL v109 = mtw_std_maybe_Maybe_1_Some(v108);
							push_value(v109);
						} break;
						case 5LL: { // Phantom
							int64_t v110 = 5LL /* Phantom */;
							VAL v111 = mtw_std_maybe_Maybe_1_Some(MKI64(v110));
							push_value(v111);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} else {
					VAL v112 = pop_value();
					decref(v112);
					VAL v113 = pop_value();
					decref(v113);
					int64_t v114 = 0LL /* None */;
					push_i64(v114);
				}
			}
		}
	}
}
static VAL mw_mirth_type_CTypeStackPart_ctype (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // CTSPCons
			VAL v0 = mtp_mirth_type_CTypeStackPart_CTSPCons(x1);
			push_value(v0);
		} break;
		case 1LL: { // CTSPConsLabel
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x1);
			uint64_t v1 = pop_u64();
		} break;
		case 2LL: { // CTSPWith
			VAL v2 = mtp_mirth_type_CTypeStackPart_CTSPWith(x1);
			push_value(v2);
		} break;
		case 3LL: { // CTSPWithLabel
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x1);
			uint64_t v3 = pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	return v4;
}
static VAL mw_mirth_type_CTypeStackPart_labelZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // CTSPCons
			VAL v0 = mtp_mirth_type_CTypeStackPart_CTSPCons(x1);
			decref(v0);
			int64_t v1 = 0LL /* None */;
			push_i64(v1);
		} break;
		case 1LL: { // CTSPConsLabel
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x1);
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v4);
		} break;
		case 2LL: { // CTSPWith
			VAL v5 = mtp_mirth_type_CTypeStackPart_CTSPWith(x1);
			decref(v5);
			int64_t v6 = 0LL /* None */;
			push_i64(v6);
		} break;
		case 3LL: { // CTSPWithLabel
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x1);
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v10 = pop_value();
	return v10;
}
static void mw_mirth_type_StackTypePart_ctype (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // STPCons
			push_resource(x2);
			VAL v0 = mtp_mirth_type_StackTypePart_STPCons(x1);
			VAL r1 = pop_resource();
			mw_mirth_type_Type_ctype(r1, v0);
			VAL v2 = pop_value();
			VAL v3 = mtw_mirth_type_CTypeStackPart_CTSPCons(v2);
			push_value(v3);
		} break;
		case 1LL: { // STPConsLabel
			push_resource(x2);
			mtp_mirth_type_StackTypePart_STPConsLabel(x1);
			uint64_t v4 = pop_u64();
			VAL v5 = pop_value();
			VAL r6 = pop_resource();
			mw_mirth_type_Type_ctype(r6, v5);
			VAL v7 = pop_value();
			VAL v8 = mtw_mirth_type_CTypeStackPart_CTSPConsLabel(v7, v4);
			push_value(v8);
		} break;
		case 2LL: { // STPWith
			push_resource(x2);
			VAL v9 = mtp_mirth_type_StackTypePart_STPWith(x1);
			VAL r10 = pop_resource();
			mw_mirth_type_Resource_ctype(r10, v9);
			VAL v11 = pop_value();
			VAL v12 = mtw_mirth_type_CTypeStackPart_CTSPWith(v11);
			push_value(v12);
		} break;
		case 3LL: { // STPWithLabel
			push_resource(x2);
			mtp_mirth_type_StackTypePart_STPWithLabel(x1);
			uint64_t v13 = pop_u64();
			VAL v14 = pop_value();
			VAL r15 = pop_resource();
			mw_mirth_type_Resource_ctype(r15, v14);
			VAL v16 = pop_value();
			VAL v17 = mtw_mirth_type_CTypeStackPart_CTSPWithLabel(v16, v13);
			push_value(v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
}
static void mw_mirth_type_StackType_baseZ_ctypeZAsk (VAL x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_mirth_type_StackType_expand(x1);
	switch (get_data_tag(v0)) {
		case 3LL: { // STVar
			uint64_t v1 = mtp_mirth_type_StackType_STVar(v0);
			VAL v2 = mtw_std_maybe_Maybe_1_Some(MKU64(v1));
			push_value(v2);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			STR* v5;
			STRLIT(v5, "unexpected stack base in StackType.base-ctype", 45);
			push_value(v0);
			push_str(v5);
			do_panic();
		} break;
	}
}
static void mw_mirth_type_StackType_ctype (VAL x1, VAL x2) {
	push_resource(x2);
	mw_mirth_type_StackType_splitZ_parts(x1);
	int64_t v0 = 0LL /* Nil */;
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	VAL v2 = pop_value();
	push_resource(v1);
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		VAL r11 = pop_resource();
		mw_mirth_type_StackTypePart_ctype(v8, r11);
		VAL v12 = pop_value();
		VAL v13 = mtw_std_list_List_1_Cons(v12, r10);
		push_resource(v13);
		mw_std_list_List_1_uncons(v9);
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		push_value(v15);
	}
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = pop_value();
	decref(v17);
	VAL r18 = pop_resource();
	VAL v19 = mw_std_list_List_1_reverse(r18);
	VAL r20 = pop_resource();
	VAL v21 = pop_value();
	lpush(&lbl_parts, v19);
	mw_mirth_type_StackType_baseZ_ctypeZAsk(v21, r20);
	VAL v22 = pop_value();
	VAL v23 = lpop(&lbl_parts);
	VAL v24 = mtw_mirth_type_CTypeStack_CTypeStack(v22, v23);
	push_value(v24);
}
static void mw_mirth_type_ArrowType_ctype (VAL x1, VAL x2) {
	push_resource(x2);
	mw_mirth_type_ArrowType_unpack(x1);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	mw_mirth_type_StackType_ctype(v2, r1);
	VAL v3 = pop_value();
	VAL r4 = pop_resource();
	lpush(&lbl_dom, v3);
	mw_mirth_type_StackType_ctype(v0, r4);
	VAL v5 = pop_value();
	VAL v6 = lpop(&lbl_dom);
	VAL v7 = mtw_mirth_type_CTypeArrow_CTypeArrow(v6, v5);
	push_value(v7);
}
static void mw_mirth_prim_Prim_qname (VAL x1, int64_t x2) {
	push_i64(x2);
	mw_mirth_name_Namespace_prim(x1);
	VAL v0 = pop_value();
	int64_t v1 = pop_i64();
	lpush(&lbl_namespace, v0);
	push_i64(v1);
	uint64_t v2 = mw_mirth_prim_Prim_name(v1);
	int64_t v3 = pop_i64();
	lpush(&lbl_name, MKU64(v2));
	int64_t v4 = mw_mirth_prim_Prim_arity(v3);
	uint64_t v5 = VU64(lpop(&lbl_name));
	VAL v6 = lpop(&lbl_namespace);
	VAL v7 = mtw_mirth_name_QName_MKQNAME(v6, v5, v4);
	push_value(v7);
}
static uint64_t mw_mirth_prim_Prim_name (int64_t x1) {
	void* v0 = mfld_mirth_prim_Prim_ZTildename(((uint64_t)x1));
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_prim_Prim_type (int64_t x1) {
	void* v0 = mfld_mirth_prim_Prim_ZTildetype(((uint64_t)x1));
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_prim_Prim_arity (int64_t x1) {
	void* v0 = mfld_mirth_prim_Prim_ZTildearity(((uint64_t)x1));
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static int64_t mw_mirth_prim_Prim_ZToInt (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_prim_Prim_ZEqualZEqual (int64_t x1, int64_t x2) {
	int64_t v0 = mw_mirth_prim_Prim_ZToInt(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_prim_Prim_ZToInt(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static VAL mw_mirth_prim_defZ_primZBang (VAL x1, int64_t x2, VAL x3, int64_t x4) {
	push_resource(x1);
	push_i64(x2);
	uint64_t v0 = mw_std_prim_Str_ZToName(x3);
	VAL v1 = pop_value();
	incref(v1);
	void* v2 = mfld_mirth_prim_Prim_ZTildename(VU64(v1));
	mut_set(MKU64(v0), MKPTR(v2));
	incref(v1);
	void* v3 = mfld_mirth_prim_Prim_ZTildearity(VU64(v1));
	mut_set(MKI64(x4), MKPTR(v3));
	VAL v4 = mtw_mirth_def_Def_DefPrim(VI64(v1));
	VAL r5 = pop_resource();
	VAL v6 = (mw_mirth_def_Def_register(r5, v4));
	return v6;
}
static void mw_mirth_prim_Prim_ctxZ_typeZBang (VAL x1, VAL x2, int64_t x3) {
	void* v0 = mfld_mirth_prim_Prim_ZTildetype(((uint64_t)x3));
	mut_set(x2, MKPTR(v0));
	void* v1 = mfld_mirth_prim_Prim_ZTildectx(((uint64_t)x3));
	mut_set(x1, MKPTR(v1));
}
static VAL mw_mirth_prim_initZ_primsZBang (VAL x1) {
	int64_t v0 = 103LL /* PRIM_SYNTAX_MODULE */;
	STR* v1;
	STRLIT(v1, "module", 6);
	int64_t v2 = -1LL;
	VAL v3 = (mw_mirth_prim_defZ_primZBang(x1, v0, MKSTR(v1), v2));
	int64_t v4 = 104LL /* PRIM_SYNTAX_IMPORT */;
	STR* v5;
	STRLIT(v5, "import", 6);
	int64_t v6 = -1LL;
	VAL v7 = (mw_mirth_prim_defZ_primZBang(v3, v4, MKSTR(v5), v6));
	int64_t v8 = 106LL /* PRIM_SYNTAX_INLINE */;
	STR* v9;
	STRLIT(v9, "inline", 6);
	int64_t v10 = -1LL;
	VAL v11 = (mw_mirth_prim_defZ_primZBang(v7, v8, MKSTR(v9), v10));
	int64_t v12 = 105LL /* PRIM_SYNTAX_ALIAS */;
	STR* v13;
	STRLIT(v13, "alias", 5);
	int64_t v14 = -1LL;
	VAL v15 = (mw_mirth_prim_defZ_primZBang(v11, v12, MKSTR(v13), v14));
	int64_t v16 = 107LL /* PRIM_SYNTAX_DEF */;
	STR* v17;
	STRLIT(v17, "def", 3);
	int64_t v18 = -1LL;
	VAL v19 = (mw_mirth_prim_defZ_primZBang(v15, v16, MKSTR(v17), v18));
	int64_t v20 = 109LL /* PRIM_SYNTAX_DEF_TYPE */;
	STR* v21;
	STRLIT(v21, "def-type", 8);
	int64_t v22 = -1LL;
	VAL v23 = (mw_mirth_prim_defZ_primZBang(v19, v20, MKSTR(v21), v22));
	int64_t v24 = 108LL /* PRIM_SYNTAX_DEF_MISSING */;
	STR* v25;
	STRLIT(v25, "def-missing", 11);
	int64_t v26 = -1LL;
	VAL v27 = (mw_mirth_prim_defZ_primZBang(v23, v24, MKSTR(v25), v26));
	int64_t v28 = 110LL /* PRIM_SYNTAX_BUFFER */;
	STR* v29;
	STRLIT(v29, "buffer", 6);
	int64_t v30 = -1LL;
	VAL v31 = (mw_mirth_prim_defZ_primZBang(v27, v28, MKSTR(v29), v30));
	int64_t v32 = 113LL /* PRIM_SYNTAX_DEF_EXTERNAL */;
	STR* v33;
	STRLIT(v33, "def-external", 12);
	int64_t v34 = -1LL;
	VAL v35 = (mw_mirth_prim_defZ_primZBang(v31, v32, MKSTR(v33), v34));
	int64_t v36 = 112LL /* PRIM_SYNTAX_EXTERNAL */;
	STR* v37;
	STRLIT(v37, "external", 8);
	int64_t v38 = -1LL;
	VAL v39 = (mw_mirth_prim_defZ_primZBang(v35, v36, MKSTR(v37), v38));
	int64_t v40 = 115LL /* PRIM_SYNTAX_TABLE */;
	STR* v41;
	STRLIT(v41, "table", 5);
	int64_t v42 = -1LL;
	VAL v43 = (mw_mirth_prim_defZ_primZBang(v39, v40, MKSTR(v41), v42));
	int64_t v44 = 116LL /* PRIM_SYNTAX_FIELD */;
	STR* v45;
	STRLIT(v45, "field", 5);
	int64_t v46 = -1LL;
	VAL v47 = (mw_mirth_prim_defZ_primZBang(v43, v44, MKSTR(v45), v46));
	int64_t v48 = 114LL /* PRIM_SYNTAX_EMBED_STR */;
	STR* v49;
	STRLIT(v49, "embed-str", 9);
	int64_t v50 = -1LL;
	VAL v51 = (mw_mirth_prim_defZ_primZBang(v47, v48, MKSTR(v49), v50));
	int64_t v52 = 117LL /* PRIM_SYNTAX_DATA */;
	STR* v53;
	STRLIT(v53, "data", 4);
	int64_t v54 = -1LL;
	VAL v55 = (mw_mirth_prim_defZ_primZBang(v51, v52, MKSTR(v53), v54));
	int64_t v56 = 118LL /* PRIM_SYNTAX_STRUCT */;
	STR* v57;
	STRLIT(v57, "struct", 6);
	int64_t v58 = -1LL;
	VAL v59 = (mw_mirth_prim_defZ_primZBang(v55, v56, MKSTR(v57), v58));
	int64_t v60 = 111LL /* PRIM_SYNTAX_VARIABLE */;
	STR* v61;
	STRLIT(v61, "var", 3);
	int64_t v62 = -1LL;
	VAL v63 = (mw_mirth_prim_defZ_primZBang(v59, v60, MKSTR(v61), v62));
	int64_t v64 = 120LL /* PRIM_SYNTAX_ARROW */;
	STR* v65;
	STRLIT(v65, "->", 2);
	int64_t v66 = -1LL;
	VAL v67 = (mw_mirth_prim_defZ_primZBang(v63, v64, MKSTR(v65), v66));
	int64_t v68 = 119LL /* PRIM_SYNTAX_DASHES */;
	STR* v69;
	STRLIT(v69, "--", 2);
	int64_t v70 = -1LL;
	VAL v71 = (mw_mirth_prim_defZ_primZBang(v67, v68, MKSTR(v69), v70));
	int64_t v72 = 4LL /* PRIM_CORE_DIP */;
	STR* v73;
	STRLIT(v73, "dip", 3);
	int64_t v74 = 1LL;
	VAL v75 = (mw_mirth_prim_defZ_primZBang(v71, v72, MKSTR(v73), v74));
	int64_t v76 = 6LL /* PRIM_CORE_WHILE */;
	STR* v77;
	STRLIT(v77, "while", 5);
	int64_t v78 = 2LL;
	VAL v79 = (mw_mirth_prim_defZ_primZBang(v75, v76, MKSTR(v77), v78));
	int64_t v80 = 10LL /* PRIM_CORE_MATCH */;
	STR* v81;
	STRLIT(v81, "match", 5);
	int64_t v82 = -1LL;
	VAL v83 = (mw_mirth_prim_defZ_primZBang(v79, v80, MKSTR(v81), v82));
	int64_t v84 = 11LL /* PRIM_CORE_LAMBDA */;
	STR* v85;
	STRLIT(v85, "\\", 1);
	int64_t v86 = -1LL;
	VAL v87 = (mw_mirth_prim_defZ_primZBang(v83, v84, MKSTR(v85), v86));
	int64_t v88 = 0LL /* PRIM_CORE_ID */;
	STR* v89;
	STRLIT(v89, "prim-id", 7);
	int64_t v90 = 0LL;
	VAL v91 = (mw_mirth_prim_defZ_primZBang(v87, v88, MKSTR(v89), v90));
	int64_t v92 = 1LL /* PRIM_CORE_DUP */;
	STR* v93;
	STRLIT(v93, "prim-dup", 8);
	int64_t v94 = 0LL;
	VAL v95 = (mw_mirth_prim_defZ_primZBang(v91, v92, MKSTR(v93), v94));
	int64_t v96 = 2LL /* PRIM_CORE_DROP */;
	STR* v97;
	STRLIT(v97, "prim-drop", 9);
	int64_t v98 = 0LL;
	VAL v99 = (mw_mirth_prim_defZ_primZBang(v95, v96, MKSTR(v97), v98));
	int64_t v100 = 3LL /* PRIM_CORE_SWAP */;
	STR* v101;
	STRLIT(v101, "prim-swap", 9);
	int64_t v102 = 0LL;
	VAL v103 = (mw_mirth_prim_defZ_primZBang(v99, v100, MKSTR(v101), v102));
	int64_t v104 = 4LL /* PRIM_CORE_DIP */;
	STR* v105;
	STRLIT(v105, "prim-dip", 8);
	int64_t v106 = 1LL;
	VAL v107 = (mw_mirth_prim_defZ_primZBang(v103, v104, MKSTR(v105), v106));
	int64_t v108 = 5LL /* PRIM_CORE_IF */;
	STR* v109;
	STRLIT(v109, "prim-if", 7);
	int64_t v110 = 2LL;
	VAL v111 = (mw_mirth_prim_defZ_primZBang(v107, v108, MKSTR(v109), v110));
	int64_t v112 = 6LL /* PRIM_CORE_WHILE */;
	STR* v113;
	STRLIT(v113, "prim-while", 10);
	int64_t v114 = 2LL;
	VAL v115 = (mw_mirth_prim_defZ_primZBang(v111, v112, MKSTR(v113), v114));
	int64_t v116 = 7LL /* PRIM_CORE_DEBUG */;
	STR* v117;
	STRLIT(v117, "prim-debug", 10);
	int64_t v118 = 0LL;
	VAL v119 = (mw_mirth_prim_defZ_primZBang(v115, v116, MKSTR(v117), v118));
	int64_t v120 = 8LL /* PRIM_CORE_PANIC */;
	STR* v121;
	STRLIT(v121, "prim-panic", 10);
	int64_t v122 = 0LL;
	VAL v123 = (mw_mirth_prim_defZ_primZBang(v119, v120, MKSTR(v121), v122));
	int64_t v124 = 9LL /* PRIM_CORE_RUN */;
	STR* v125;
	STRLIT(v125, "prim-run", 8);
	int64_t v126 = 0LL;
	VAL v127 = (mw_mirth_prim_defZ_primZBang(v123, v124, MKSTR(v125), v126));
	int64_t v128 = 10LL /* PRIM_CORE_MATCH */;
	STR* v129;
	STRLIT(v129, "prim-match", 10);
	int64_t v130 = -1LL;
	VAL v131 = (mw_mirth_prim_defZ_primZBang(v127, v128, MKSTR(v129), v130));
	int64_t v132 = 11LL /* PRIM_CORE_LAMBDA */;
	STR* v133;
	STRLIT(v133, "prim-lambda", 11);
	int64_t v134 = -1LL;
	VAL v135 = (mw_mirth_prim_defZ_primZBang(v131, v132, MKSTR(v133), v134));
	int64_t v136 = 12LL /* PRIM_CORE_RSWAP */;
	STR* v137;
	STRLIT(v137, "prim-rswap", 10);
	int64_t v138 = 0LL;
	VAL v139 = (mw_mirth_prim_defZ_primZBang(v135, v136, MKSTR(v137), v138));
	int64_t v140 = 13LL /* PRIM_CORE_RDIP */;
	STR* v141;
	STRLIT(v141, "prim-rdip", 9);
	int64_t v142 = 1LL;
	VAL v143 = (mw_mirth_prim_defZ_primZBang(v139, v140, MKSTR(v141), v142));
	int64_t v144 = 20LL /* PRIM_INT_ADD */;
	STR* v145;
	STRLIT(v145, "prim-int-add", 12);
	int64_t v146 = 0LL;
	VAL v147 = (mw_mirth_prim_defZ_primZBang(v143, v144, MKSTR(v145), v146));
	int64_t v148 = 21LL /* PRIM_INT_SUB */;
	STR* v149;
	STRLIT(v149, "prim-int-sub", 12);
	int64_t v150 = 0LL;
	VAL v151 = (mw_mirth_prim_defZ_primZBang(v147, v148, MKSTR(v149), v150));
	int64_t v152 = 22LL /* PRIM_INT_MUL */;
	STR* v153;
	STRLIT(v153, "prim-int-mul", 12);
	int64_t v154 = 0LL;
	VAL v155 = (mw_mirth_prim_defZ_primZBang(v151, v152, MKSTR(v153), v154));
	int64_t v156 = 23LL /* PRIM_INT_DIV */;
	STR* v157;
	STRLIT(v157, "prim-int-div", 12);
	int64_t v158 = 0LL;
	VAL v159 = (mw_mirth_prim_defZ_primZBang(v155, v156, MKSTR(v157), v158));
	int64_t v160 = 24LL /* PRIM_INT_MOD */;
	STR* v161;
	STRLIT(v161, "prim-int-mod", 12);
	int64_t v162 = 0LL;
	VAL v163 = (mw_mirth_prim_defZ_primZBang(v159, v160, MKSTR(v161), v162));
	int64_t v164 = 25LL /* PRIM_INT_AND */;
	STR* v165;
	STRLIT(v165, "prim-int-and", 12);
	int64_t v166 = 0LL;
	VAL v167 = (mw_mirth_prim_defZ_primZBang(v163, v164, MKSTR(v165), v166));
	int64_t v168 = 26LL /* PRIM_INT_OR */;
	STR* v169;
	STRLIT(v169, "prim-int-or", 11);
	int64_t v170 = 0LL;
	VAL v171 = (mw_mirth_prim_defZ_primZBang(v167, v168, MKSTR(v169), v170));
	int64_t v172 = 27LL /* PRIM_INT_XOR */;
	STR* v173;
	STRLIT(v173, "prim-int-xor", 12);
	int64_t v174 = 0LL;
	VAL v175 = (mw_mirth_prim_defZ_primZBang(v171, v172, MKSTR(v173), v174));
	int64_t v176 = 28LL /* PRIM_INT_SHL */;
	STR* v177;
	STRLIT(v177, "prim-int-shl", 12);
	int64_t v178 = 0LL;
	VAL v179 = (mw_mirth_prim_defZ_primZBang(v175, v176, MKSTR(v177), v178));
	int64_t v180 = 29LL /* PRIM_INT_SHR */;
	STR* v181;
	STRLIT(v181, "prim-int-shr", 12);
	int64_t v182 = 0LL;
	VAL v183 = (mw_mirth_prim_defZ_primZBang(v179, v180, MKSTR(v181), v182));
	int64_t v184 = 14LL /* PRIM_INT_EQ */;
	STR* v185;
	STRLIT(v185, "prim-int-eq", 11);
	int64_t v186 = 0LL;
	VAL v187 = (mw_mirth_prim_defZ_primZBang(v183, v184, MKSTR(v185), v186));
	int64_t v188 = 15LL /* PRIM_INT_LT */;
	STR* v189;
	STRLIT(v189, "prim-int-lt", 11);
	int64_t v190 = 0LL;
	VAL v191 = (mw_mirth_prim_defZ_primZBang(v187, v188, MKSTR(v189), v190));
	int64_t v192 = 16LL /* PRIM_INT_LE */;
	STR* v193;
	STRLIT(v193, "prim-int-le", 11);
	int64_t v194 = 0LL;
	VAL v195 = (mw_mirth_prim_defZ_primZBang(v191, v192, MKSTR(v193), v194));
	int64_t v196 = 17LL /* PRIM_INT_GT */;
	STR* v197;
	STRLIT(v197, "prim-int-gt", 11);
	int64_t v198 = 0LL;
	VAL v199 = (mw_mirth_prim_defZ_primZBang(v195, v196, MKSTR(v197), v198));
	int64_t v200 = 18LL /* PRIM_INT_GE */;
	STR* v201;
	STRLIT(v201, "prim-int-ge", 11);
	int64_t v202 = 0LL;
	VAL v203 = (mw_mirth_prim_defZ_primZBang(v199, v200, MKSTR(v201), v202));
	int64_t v204 = 19LL /* PRIM_INT_NE */;
	STR* v205;
	STRLIT(v205, "prim-int-ne", 11);
	int64_t v206 = 0LL;
	VAL v207 = (mw_mirth_prim_defZ_primZBang(v203, v204, MKSTR(v205), v206));
	int64_t v208 = 30LL /* PRIM_INT_TO_STR */;
	STR* v209;
	STRLIT(v209, "prim-int-to-str", 15);
	int64_t v210 = 0LL;
	VAL v211 = (mw_mirth_prim_defZ_primZBang(v207, v208, MKSTR(v209), v210));
	int64_t v212 = 31LL /* PRIM_INT_TO_F32 */;
	STR* v213;
	STRLIT(v213, "prim-int-to-float32", 19);
	int64_t v214 = 0LL;
	VAL v215 = (mw_mirth_prim_defZ_primZBang(v211, v212, MKSTR(v213), v214));
	int64_t v216 = 32LL /* PRIM_INT_TO_F64 */;
	STR* v217;
	STRLIT(v217, "prim-int-to-float64", 19);
	int64_t v218 = 0LL;
	VAL v219 = (mw_mirth_prim_defZ_primZBang(v215, v216, MKSTR(v217), v218));
	int64_t v220 = 31LL /* PRIM_INT_TO_F32 */;
	STR* v221;
	STRLIT(v221, "prim-int-to-f32", 15);
	int64_t v222 = 0LL;
	VAL v223 = (mw_mirth_prim_defZ_primZBang(v219, v220, MKSTR(v221), v222));
	int64_t v224 = 32LL /* PRIM_INT_TO_F64 */;
	STR* v225;
	STRLIT(v225, "prim-int-to-f64", 15);
	int64_t v226 = 0LL;
	VAL v227 = (mw_mirth_prim_defZ_primZBang(v223, v224, MKSTR(v225), v226));
	int64_t v228 = 33LL /* PRIM_F32_EQ */;
	STR* v229;
	STRLIT(v229, "prim-f32-eq", 11);
	int64_t v230 = 0LL;
	VAL v231 = (mw_mirth_prim_defZ_primZBang(v227, v228, MKSTR(v229), v230));
	int64_t v232 = 34LL /* PRIM_F32_LT */;
	STR* v233;
	STRLIT(v233, "prim-f32-lt", 11);
	int64_t v234 = 0LL;
	VAL v235 = (mw_mirth_prim_defZ_primZBang(v231, v232, MKSTR(v233), v234));
	int64_t v236 = 35LL /* PRIM_F32_ADD */;
	STR* v237;
	STRLIT(v237, "prim-f32-add", 12);
	int64_t v238 = 0LL;
	VAL v239 = (mw_mirth_prim_defZ_primZBang(v235, v236, MKSTR(v237), v238));
	int64_t v240 = 36LL /* PRIM_F32_SUB */;
	STR* v241;
	STRLIT(v241, "prim-f32-sub", 12);
	int64_t v242 = 0LL;
	VAL v243 = (mw_mirth_prim_defZ_primZBang(v239, v240, MKSTR(v241), v242));
	int64_t v244 = 37LL /* PRIM_F32_MUL */;
	STR* v245;
	STRLIT(v245, "prim-f32-mul", 12);
	int64_t v246 = 0LL;
	VAL v247 = (mw_mirth_prim_defZ_primZBang(v243, v244, MKSTR(v245), v246));
	int64_t v248 = 38LL /* PRIM_F32_DIV */;
	STR* v249;
	STRLIT(v249, "prim-f32-div", 12);
	int64_t v250 = 0LL;
	VAL v251 = (mw_mirth_prim_defZ_primZBang(v247, v248, MKSTR(v249), v250));
	int64_t v252 = 39LL /* PRIM_F32_TO_INT */;
	STR* v253;
	STRLIT(v253, "prim-f32-to-int", 15);
	int64_t v254 = 0LL;
	VAL v255 = (mw_mirth_prim_defZ_primZBang(v251, v252, MKSTR(v253), v254));
	int64_t v256 = 40LL /* PRIM_F32_TO_STR */;
	STR* v257;
	STRLIT(v257, "prim-f32-to-str", 15);
	int64_t v258 = 0LL;
	VAL v259 = (mw_mirth_prim_defZ_primZBang(v255, v256, MKSTR(v257), v258));
	int64_t v260 = 41LL /* PRIM_F32_TO_F64 */;
	STR* v261;
	STRLIT(v261, "prim-f32-to-f64", 15);
	int64_t v262 = 0LL;
	VAL v263 = (mw_mirth_prim_defZ_primZBang(v259, v260, MKSTR(v261), v262));
	int64_t v264 = 42LL /* PRIM_F64_EQ */;
	STR* v265;
	STRLIT(v265, "prim-f64-eq", 11);
	int64_t v266 = 0LL;
	VAL v267 = (mw_mirth_prim_defZ_primZBang(v263, v264, MKSTR(v265), v266));
	int64_t v268 = 43LL /* PRIM_F64_LT */;
	STR* v269;
	STRLIT(v269, "prim-f64-lt", 11);
	int64_t v270 = 0LL;
	VAL v271 = (mw_mirth_prim_defZ_primZBang(v267, v268, MKSTR(v269), v270));
	int64_t v272 = 44LL /* PRIM_F64_ADD */;
	STR* v273;
	STRLIT(v273, "prim-f64-add", 12);
	int64_t v274 = 0LL;
	VAL v275 = (mw_mirth_prim_defZ_primZBang(v271, v272, MKSTR(v273), v274));
	int64_t v276 = 45LL /* PRIM_F64_SUB */;
	STR* v277;
	STRLIT(v277, "prim-f64-sub", 12);
	int64_t v278 = 0LL;
	VAL v279 = (mw_mirth_prim_defZ_primZBang(v275, v276, MKSTR(v277), v278));
	int64_t v280 = 46LL /* PRIM_F64_MUL */;
	STR* v281;
	STRLIT(v281, "prim-f64-mul", 12);
	int64_t v282 = 0LL;
	VAL v283 = (mw_mirth_prim_defZ_primZBang(v279, v280, MKSTR(v281), v282));
	int64_t v284 = 47LL /* PRIM_F64_DIV */;
	STR* v285;
	STRLIT(v285, "prim-f64-div", 12);
	int64_t v286 = 0LL;
	VAL v287 = (mw_mirth_prim_defZ_primZBang(v283, v284, MKSTR(v285), v286));
	int64_t v288 = 48LL /* PRIM_F64_TO_INT */;
	STR* v289;
	STRLIT(v289, "prim-f64-to-int", 15);
	int64_t v290 = 0LL;
	VAL v291 = (mw_mirth_prim_defZ_primZBang(v287, v288, MKSTR(v289), v290));
	int64_t v292 = 49LL /* PRIM_F64_TO_STR */;
	STR* v293;
	STRLIT(v293, "prim-f64-to-str", 15);
	int64_t v294 = 0LL;
	VAL v295 = (mw_mirth_prim_defZ_primZBang(v291, v292, MKSTR(v293), v294));
	int64_t v296 = 50LL /* PRIM_F64_TO_F32 */;
	STR* v297;
	STRLIT(v297, "prim-f64-to-f32", 15);
	int64_t v298 = 0LL;
	VAL v299 = (mw_mirth_prim_defZ_primZBang(v295, v296, MKSTR(v297), v298));
	int64_t v300 = 51LL /* PRIM_BOOL_AND */;
	STR* v301;
	STRLIT(v301, "prim-bool-and", 13);
	int64_t v302 = 0LL;
	VAL v303 = (mw_mirth_prim_defZ_primZBang(v299, v300, MKSTR(v301), v302));
	int64_t v304 = 52LL /* PRIM_BOOL_OR */;
	STR* v305;
	STRLIT(v305, "prim-bool-or", 12);
	int64_t v306 = 0LL;
	VAL v307 = (mw_mirth_prim_defZ_primZBang(v303, v304, MKSTR(v305), v306));
	int64_t v308 = 53LL /* PRIM_BOOL_NOT */;
	STR* v309;
	STRLIT(v309, "prim-bool-not", 13);
	int64_t v310 = 0LL;
	VAL v311 = (mw_mirth_prim_defZ_primZBang(v307, v308, MKSTR(v309), v310));
	int64_t v312 = 54LL /* PRIM_PACK_NIL */;
	STR* v313;
	STRLIT(v313, "prim-pack-nil", 13);
	int64_t v314 = 0LL;
	VAL v315 = (mw_mirth_prim_defZ_primZBang(v311, v312, MKSTR(v313), v314));
	int64_t v316 = 55LL /* PRIM_PACK_CONS */;
	STR* v317;
	STRLIT(v317, "prim-pack-cons", 14);
	int64_t v318 = 0LL;
	VAL v319 = (mw_mirth_prim_defZ_primZBang(v315, v316, MKSTR(v317), v318));
	int64_t v320 = 56LL /* PRIM_PACK_UNCONS */;
	STR* v321;
	STRLIT(v321, "prim-pack-uncons", 16);
	int64_t v322 = 0LL;
	VAL v323 = (mw_mirth_prim_defZ_primZBang(v319, v320, MKSTR(v321), v322));
	int64_t v324 = 58LL /* PRIM_MUT_GET */;
	STR* v325;
	STRLIT(v325, "prim-mut-get", 12);
	int64_t v326 = 0LL;
	VAL v327 = (mw_mirth_prim_defZ_primZBang(v323, v324, MKSTR(v325), v326));
	int64_t v328 = 59LL /* PRIM_MUT_SET */;
	STR* v329;
	STRLIT(v329, "prim-mut-set", 12);
	int64_t v330 = 0LL;
	VAL v331 = (mw_mirth_prim_defZ_primZBang(v327, v328, MKSTR(v329), v330));
	int64_t v332 = 60LL /* PRIM_MUT_IS_SET */;
	STR* v333;
	STRLIT(v333, "prim-mut-is-set", 15);
	int64_t v334 = 0LL;
	VAL v335 = (mw_mirth_prim_defZ_primZBang(v331, v332, MKSTR(v333), v334));
	int64_t v336 = 61LL /* PRIM_PTR_NIL */;
	STR* v337;
	STRLIT(v337, "prim-ptr-nil", 12);
	int64_t v338 = 0LL;
	VAL v339 = (mw_mirth_prim_defZ_primZBang(v335, v336, MKSTR(v337), v338));
	int64_t v340 = 62LL /* PRIM_PTR_EQ */;
	STR* v341;
	STRLIT(v341, "prim-ptr-eq", 11);
	int64_t v342 = 0LL;
	VAL v343 = (mw_mirth_prim_defZ_primZBang(v339, v340, MKSTR(v341), v342));
	int64_t v344 = 63LL /* PRIM_PTR_ADD */;
	STR* v345;
	STRLIT(v345, "prim-ptr-add", 12);
	int64_t v346 = 0LL;
	VAL v347 = (mw_mirth_prim_defZ_primZBang(v343, v344, MKSTR(v345), v346));
	int64_t v348 = 64LL /* PRIM_PTR_SIZE */;
	STR* v349;
	STRLIT(v349, "prim-ptr-size", 13);
	int64_t v350 = 0LL;
	VAL v351 = (mw_mirth_prim_defZ_primZBang(v347, v348, MKSTR(v349), v350));
	int64_t v352 = 65LL /* PRIM_PTR_GET */;
	STR* v353;
	STRLIT(v353, "prim-ptr-get", 12);
	int64_t v354 = 0LL;
	VAL v355 = (mw_mirth_prim_defZ_primZBang(v351, v352, MKSTR(v353), v354));
	int64_t v356 = 66LL /* PRIM_PTR_SET */;
	STR* v357;
	STRLIT(v357, "prim-ptr-set", 12);
	int64_t v358 = 0LL;
	VAL v359 = (mw_mirth_prim_defZ_primZBang(v355, v356, MKSTR(v357), v358));
	int64_t v360 = 67LL /* PRIM_PTR_ALLOC */;
	STR* v361;
	STRLIT(v361, "prim-ptr-alloc", 14);
	int64_t v362 = 0LL;
	VAL v363 = (mw_mirth_prim_defZ_primZBang(v359, v360, MKSTR(v361), v362));
	int64_t v364 = 68LL /* PRIM_PTR_REALLOC */;
	STR* v365;
	STRLIT(v365, "prim-ptr-realloc", 16);
	int64_t v366 = 0LL;
	VAL v367 = (mw_mirth_prim_defZ_primZBang(v363, v364, MKSTR(v365), v366));
	int64_t v368 = 69LL /* PRIM_PTR_FREE */;
	STR* v369;
	STRLIT(v369, "prim-ptr-free", 13);
	int64_t v370 = 0LL;
	VAL v371 = (mw_mirth_prim_defZ_primZBang(v367, v368, MKSTR(v369), v370));
	int64_t v372 = 71LL /* PRIM_PTR_FILL */;
	STR* v373;
	STRLIT(v373, "prim-ptr-fill", 13);
	int64_t v374 = 0LL;
	VAL v375 = (mw_mirth_prim_defZ_primZBang(v371, v372, MKSTR(v373), v374));
	int64_t v376 = 70LL /* PRIM_PTR_COPY */;
	STR* v377;
	STRLIT(v377, "prim-ptr-copy", 13);
	int64_t v378 = 0LL;
	VAL v379 = (mw_mirth_prim_defZ_primZBang(v375, v376, MKSTR(v377), v378));
	int64_t v380 = 72LL /* PRIM_STR_COPY */;
	STR* v381;
	STRLIT(v381, "prim-str-copy", 13);
	int64_t v382 = 0LL;
	VAL v383 = (mw_mirth_prim_defZ_primZBang(v379, v380, MKSTR(v381), v382));
	int64_t v384 = 73LL /* PRIM_STR_NUM_BYTES */;
	STR* v385;
	STRLIT(v385, "prim-str-num-bytes", 18);
	int64_t v386 = 0LL;
	VAL v387 = (mw_mirth_prim_defZ_primZBang(v383, v384, MKSTR(v385), v386));
	int64_t v388 = 74LL /* PRIM_STR_BASE */;
	STR* v389;
	STRLIT(v389, "prim-str-base", 13);
	int64_t v390 = 0LL;
	VAL v391 = (mw_mirth_prim_defZ_primZBang(v387, v388, MKSTR(v389), v390));
	int64_t v392 = 75LL /* PRIM_STR_CAT */;
	STR* v393;
	STRLIT(v393, "prim-str-cat", 12);
	int64_t v394 = 0LL;
	VAL v395 = (mw_mirth_prim_defZ_primZBang(v391, v392, MKSTR(v393), v394));
	int64_t v396 = 76LL /* PRIM_STR_CMP */;
	STR* v397;
	STRLIT(v397, "prim-str-cmp", 12);
	int64_t v398 = 0LL;
	VAL v399 = (mw_mirth_prim_defZ_primZBang(v395, v396, MKSTR(v397), v398));
	int64_t v400 = 77LL /* PRIM_STR_EQ */;
	STR* v401;
	STRLIT(v401, "prim-str-eq", 11);
	int64_t v402 = 0LL;
	VAL v403 = (mw_mirth_prim_defZ_primZBang(v399, v400, MKSTR(v401), v402));
	int64_t v404 = 78LL /* PRIM_STR_LT */;
	STR* v405;
	STRLIT(v405, "prim-str-lt", 11);
	int64_t v406 = 0LL;
	VAL v407 = (mw_mirth_prim_defZ_primZBang(v403, v404, MKSTR(v405), v406));
	int64_t v408 = 79LL /* PRIM_STR_LE */;
	STR* v409;
	STRLIT(v409, "prim-str-le", 11);
	int64_t v410 = 0LL;
	VAL v411 = (mw_mirth_prim_defZ_primZBang(v407, v408, MKSTR(v409), v410));
	int64_t v412 = 80LL /* PRIM_STR_GT */;
	STR* v413;
	STRLIT(v413, "prim-str-gt", 11);
	int64_t v414 = 0LL;
	VAL v415 = (mw_mirth_prim_defZ_primZBang(v411, v412, MKSTR(v413), v414));
	int64_t v416 = 81LL /* PRIM_STR_GE */;
	STR* v417;
	STRLIT(v417, "prim-str-ge", 11);
	int64_t v418 = 0LL;
	VAL v419 = (mw_mirth_prim_defZ_primZBang(v415, v416, MKSTR(v417), v418));
	int64_t v420 = 82LL /* PRIM_STR_NE */;
	STR* v421;
	STRLIT(v421, "prim-str-ne", 11);
	int64_t v422 = 0LL;
	VAL v423 = (mw_mirth_prim_defZ_primZBang(v419, v420, MKSTR(v421), v422));
	int64_t v424 = 83LL /* PRIM_U8_GET */;
	STR* v425;
	STRLIT(v425, "prim-u8-get", 11);
	int64_t v426 = 0LL;
	VAL v427 = (mw_mirth_prim_defZ_primZBang(v423, v424, MKSTR(v425), v426));
	int64_t v428 = 84LL /* PRIM_U8_SET */;
	STR* v429;
	STRLIT(v429, "prim-u8-set", 11);
	int64_t v430 = 0LL;
	VAL v431 = (mw_mirth_prim_defZ_primZBang(v427, v428, MKSTR(v429), v430));
	int64_t v432 = 85LL /* PRIM_U16_GET */;
	STR* v433;
	STRLIT(v433, "prim-u16-get", 12);
	int64_t v434 = 0LL;
	VAL v435 = (mw_mirth_prim_defZ_primZBang(v431, v432, MKSTR(v433), v434));
	int64_t v436 = 86LL /* PRIM_U16_SET */;
	STR* v437;
	STRLIT(v437, "prim-u16-set", 12);
	int64_t v438 = 0LL;
	VAL v439 = (mw_mirth_prim_defZ_primZBang(v435, v436, MKSTR(v437), v438));
	int64_t v440 = 87LL /* PRIM_U32_GET */;
	STR* v441;
	STRLIT(v441, "prim-u32-get", 12);
	int64_t v442 = 0LL;
	VAL v443 = (mw_mirth_prim_defZ_primZBang(v439, v440, MKSTR(v441), v442));
	int64_t v444 = 88LL /* PRIM_U32_SET */;
	STR* v445;
	STRLIT(v445, "prim-u32-set", 12);
	int64_t v446 = 0LL;
	VAL v447 = (mw_mirth_prim_defZ_primZBang(v443, v444, MKSTR(v445), v446));
	int64_t v448 = 89LL /* PRIM_U64_GET */;
	STR* v449;
	STRLIT(v449, "prim-u64-get", 12);
	int64_t v450 = 0LL;
	VAL v451 = (mw_mirth_prim_defZ_primZBang(v447, v448, MKSTR(v449), v450));
	int64_t v452 = 90LL /* PRIM_U64_SET */;
	STR* v453;
	STRLIT(v453, "prim-u64-set", 12);
	int64_t v454 = 0LL;
	VAL v455 = (mw_mirth_prim_defZ_primZBang(v451, v452, MKSTR(v453), v454));
	int64_t v456 = 91LL /* PRIM_I8_GET */;
	STR* v457;
	STRLIT(v457, "prim-i8-get", 11);
	int64_t v458 = 0LL;
	VAL v459 = (mw_mirth_prim_defZ_primZBang(v455, v456, MKSTR(v457), v458));
	int64_t v460 = 92LL /* PRIM_I8_SET */;
	STR* v461;
	STRLIT(v461, "prim-i8-set", 11);
	int64_t v462 = 0LL;
	VAL v463 = (mw_mirth_prim_defZ_primZBang(v459, v460, MKSTR(v461), v462));
	int64_t v464 = 93LL /* PRIM_I16_GET */;
	STR* v465;
	STRLIT(v465, "prim-i16-get", 12);
	int64_t v466 = 0LL;
	VAL v467 = (mw_mirth_prim_defZ_primZBang(v463, v464, MKSTR(v465), v466));
	int64_t v468 = 94LL /* PRIM_I16_SET */;
	STR* v469;
	STRLIT(v469, "prim-i16-set", 12);
	int64_t v470 = 0LL;
	VAL v471 = (mw_mirth_prim_defZ_primZBang(v467, v468, MKSTR(v469), v470));
	int64_t v472 = 95LL /* PRIM_I32_GET */;
	STR* v473;
	STRLIT(v473, "prim-i32-get", 12);
	int64_t v474 = 0LL;
	VAL v475 = (mw_mirth_prim_defZ_primZBang(v471, v472, MKSTR(v473), v474));
	int64_t v476 = 96LL /* PRIM_I32_SET */;
	STR* v477;
	STRLIT(v477, "prim-i32-set", 12);
	int64_t v478 = 0LL;
	VAL v479 = (mw_mirth_prim_defZ_primZBang(v475, v476, MKSTR(v477), v478));
	int64_t v480 = 97LL /* PRIM_I64_GET */;
	STR* v481;
	STRLIT(v481, "prim-i64-get", 12);
	int64_t v482 = 0LL;
	VAL v483 = (mw_mirth_prim_defZ_primZBang(v479, v480, MKSTR(v481), v482));
	int64_t v484 = 98LL /* PRIM_I64_SET */;
	STR* v485;
	STRLIT(v485, "prim-i64-set", 12);
	int64_t v486 = 0LL;
	VAL v487 = (mw_mirth_prim_defZ_primZBang(v483, v484, MKSTR(v485), v486));
	int64_t v488 = 99LL /* PRIM_SYS_OS */;
	STR* v489;
	STRLIT(v489, "prim-sys-os", 11);
	int64_t v490 = 0LL;
	VAL v491 = (mw_mirth_prim_defZ_primZBang(v487, v488, MKSTR(v489), v490));
	int64_t v492 = 100LL /* PRIM_SYS_ARCH */;
	STR* v493;
	STRLIT(v493, "prim-sys-arch", 13);
	int64_t v494 = 0LL;
	VAL v495 = (mw_mirth_prim_defZ_primZBang(v491, v492, MKSTR(v493), v494));
	int64_t v496 = 101LL /* PRIM_SYS_ARGC */;
	STR* v497;
	STRLIT(v497, "prim-sys-argc", 13);
	int64_t v498 = 0LL;
	VAL v499 = (mw_mirth_prim_defZ_primZBang(v495, v496, MKSTR(v497), v498));
	int64_t v500 = 102LL /* PRIM_SYS_ARGV */;
	STR* v501;
	STRLIT(v501, "prim-sys-argv", 13);
	int64_t v502 = 0LL;
	VAL v503 = (mw_mirth_prim_defZ_primZBang(v499, v500, MKSTR(v501), v502));
	push_resource(v503);
	VAL v504 = mw_mirth_var_Ctx0();
	push_value(v504);
	VAL v505 = mw_mirth_type_T0();
	push_value(v505);
	VAL v506 = mw_mirth_type_T0();
	VAL v507 = pop_value();
	VAL v508 = mw_mirth_type_TZ_ZTo(v507, v506);
	VAL v509 = pop_value();
	incref(v509);
	incref(v508);
	int64_t v510 = 0LL /* PRIM_CORE_ID */;
	push_value(v509);
	push_value(v508);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v509, v508, v510);
	VAL v511 = pop_value();
	VAL v512 = pop_value();
	incref(v512);
	incref(v511);
	int64_t v513 = 7LL /* PRIM_CORE_DEBUG */;
	push_value(v512);
	push_value(v511);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v512, v511, v513);
	VAL v514 = pop_value();
	decref(v514);
	VAL v515 = pop_value();
	decref(v515);
	VAL v516 = mw_mirth_var_Ctx0();
	push_value(v516);
	VAL v517 = mw_mirth_type_TYPEz_INT();
	push_value(v517);
	VAL v518 = mw_mirth_type_TYPEz_INT();
	VAL v519 = pop_value();
	VAL v520 = mw_mirth_type_T2(v519, v518);
	push_value(v520);
	VAL v521 = mw_mirth_type_TYPEz_INT();
	VAL v522 = mw_mirth_type_T1(v521);
	VAL v523 = pop_value();
	VAL v524 = mw_mirth_type_TZ_ZTo(v523, v522);
	VAL v525 = pop_value();
	incref(v525);
	incref(v524);
	int64_t v526 = 20LL /* PRIM_INT_ADD */;
	push_value(v525);
	push_value(v524);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v525, v524, v526);
	VAL v527 = pop_value();
	VAL v528 = pop_value();
	incref(v528);
	incref(v527);
	int64_t v529 = 21LL /* PRIM_INT_SUB */;
	push_value(v528);
	push_value(v527);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v528, v527, v529);
	VAL v530 = pop_value();
	VAL v531 = pop_value();
	incref(v531);
	incref(v530);
	int64_t v532 = 22LL /* PRIM_INT_MUL */;
	push_value(v531);
	push_value(v530);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v531, v530, v532);
	VAL v533 = pop_value();
	VAL v534 = pop_value();
	incref(v534);
	incref(v533);
	int64_t v535 = 23LL /* PRIM_INT_DIV */;
	push_value(v534);
	push_value(v533);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v534, v533, v535);
	VAL v536 = pop_value();
	VAL v537 = pop_value();
	incref(v537);
	incref(v536);
	int64_t v538 = 24LL /* PRIM_INT_MOD */;
	push_value(v537);
	push_value(v536);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v537, v536, v538);
	VAL v539 = pop_value();
	VAL v540 = pop_value();
	incref(v540);
	incref(v539);
	int64_t v541 = 25LL /* PRIM_INT_AND */;
	push_value(v540);
	push_value(v539);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v540, v539, v541);
	VAL v542 = pop_value();
	VAL v543 = pop_value();
	incref(v543);
	incref(v542);
	int64_t v544 = 26LL /* PRIM_INT_OR */;
	push_value(v543);
	push_value(v542);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v543, v542, v544);
	VAL v545 = pop_value();
	VAL v546 = pop_value();
	incref(v546);
	incref(v545);
	int64_t v547 = 27LL /* PRIM_INT_XOR */;
	push_value(v546);
	push_value(v545);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v546, v545, v547);
	VAL v548 = pop_value();
	VAL v549 = pop_value();
	incref(v549);
	incref(v548);
	int64_t v550 = 28LL /* PRIM_INT_SHL */;
	push_value(v549);
	push_value(v548);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v549, v548, v550);
	VAL v551 = pop_value();
	VAL v552 = pop_value();
	incref(v552);
	incref(v551);
	int64_t v553 = 29LL /* PRIM_INT_SHR */;
	push_value(v552);
	push_value(v551);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v552, v551, v553);
	VAL v554 = pop_value();
	decref(v554);
	VAL v555 = pop_value();
	decref(v555);
	VAL v556 = mw_mirth_var_Ctx0();
	push_value(v556);
	VAL v557 = mw_mirth_type_TYPEz_INT();
	push_value(v557);
	VAL v558 = mw_mirth_type_TYPEz_INT();
	VAL v559 = pop_value();
	VAL v560 = mw_mirth_type_T2(v559, v558);
	VAL r561 = pop_resource();
	push_value(v560);
	mw_mirth_data_TYPEz_BOOL(r561);
	VAL v562 = pop_value();
	VAL v563 = mw_mirth_type_T1(v562);
	VAL v564 = pop_value();
	VAL v565 = mw_mirth_type_TZ_ZTo(v564, v563);
	VAL v566 = pop_value();
	incref(v566);
	incref(v565);
	int64_t v567 = 14LL /* PRIM_INT_EQ */;
	push_value(v566);
	push_value(v565);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v566, v565, v567);
	VAL v568 = pop_value();
	VAL v569 = pop_value();
	incref(v569);
	incref(v568);
	int64_t v570 = 15LL /* PRIM_INT_LT */;
	push_value(v569);
	push_value(v568);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v569, v568, v570);
	VAL v571 = pop_value();
	VAL v572 = pop_value();
	incref(v572);
	incref(v571);
	int64_t v573 = 16LL /* PRIM_INT_LE */;
	push_value(v572);
	push_value(v571);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v572, v571, v573);
	VAL v574 = pop_value();
	VAL v575 = pop_value();
	incref(v575);
	incref(v574);
	int64_t v576 = 17LL /* PRIM_INT_GT */;
	push_value(v575);
	push_value(v574);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v575, v574, v576);
	VAL v577 = pop_value();
	VAL v578 = pop_value();
	incref(v578);
	incref(v577);
	int64_t v579 = 18LL /* PRIM_INT_GE */;
	push_value(v578);
	push_value(v577);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v578, v577, v579);
	VAL v580 = pop_value();
	VAL v581 = pop_value();
	incref(v581);
	incref(v580);
	int64_t v582 = 19LL /* PRIM_INT_NE */;
	push_value(v581);
	push_value(v580);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v581, v580, v582);
	VAL v583 = pop_value();
	decref(v583);
	VAL v584 = pop_value();
	decref(v584);
	VAL v585 = mw_mirth_var_Ctx0();
	push_value(v585);
	VAL v586 = mw_mirth_type_TYPEz_F32();
	push_value(v586);
	VAL v587 = mw_mirth_type_TYPEz_F32();
	VAL v588 = pop_value();
	VAL v589 = mw_mirth_type_T2(v588, v587);
	VAL r590 = pop_resource();
	push_value(v589);
	mw_mirth_data_TYPEz_BOOL(r590);
	VAL v591 = pop_value();
	VAL v592 = mw_mirth_type_T1(v591);
	VAL v593 = pop_value();
	VAL v594 = mw_mirth_type_TZ_ZTo(v593, v592);
	VAL v595 = pop_value();
	incref(v595);
	incref(v594);
	int64_t v596 = 33LL /* PRIM_F32_EQ */;
	push_value(v595);
	push_value(v594);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v595, v594, v596);
	VAL v597 = pop_value();
	VAL v598 = pop_value();
	incref(v598);
	incref(v597);
	int64_t v599 = 34LL /* PRIM_F32_LT */;
	push_value(v598);
	push_value(v597);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v598, v597, v599);
	VAL v600 = pop_value();
	decref(v600);
	VAL v601 = pop_value();
	decref(v601);
	VAL v602 = mw_mirth_var_Ctx0();
	push_value(v602);
	VAL v603 = mw_mirth_type_TYPEz_F64();
	push_value(v603);
	VAL v604 = mw_mirth_type_TYPEz_F64();
	VAL v605 = pop_value();
	VAL v606 = mw_mirth_type_T2(v605, v604);
	VAL r607 = pop_resource();
	push_value(v606);
	mw_mirth_data_TYPEz_BOOL(r607);
	VAL v608 = pop_value();
	VAL v609 = mw_mirth_type_T1(v608);
	VAL v610 = pop_value();
	VAL v611 = mw_mirth_type_TZ_ZTo(v610, v609);
	VAL v612 = pop_value();
	incref(v612);
	incref(v611);
	int64_t v613 = 42LL /* PRIM_F64_EQ */;
	push_value(v612);
	push_value(v611);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v612, v611, v613);
	VAL v614 = pop_value();
	VAL v615 = pop_value();
	incref(v615);
	incref(v614);
	int64_t v616 = 43LL /* PRIM_F64_LT */;
	push_value(v615);
	push_value(v614);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v615, v614, v616);
	VAL v617 = pop_value();
	decref(v617);
	VAL v618 = pop_value();
	decref(v618);
	VAL v619 = mw_mirth_var_Ctx0();
	push_value(v619);
	VAL v620 = mw_mirth_type_TYPEz_F32();
	push_value(v620);
	VAL v621 = mw_mirth_type_TYPEz_F32();
	VAL v622 = pop_value();
	VAL v623 = mw_mirth_type_T2(v622, v621);
	push_value(v623);
	VAL v624 = mw_mirth_type_TYPEz_F32();
	VAL v625 = mw_mirth_type_T1(v624);
	VAL v626 = pop_value();
	VAL v627 = mw_mirth_type_TZ_ZTo(v626, v625);
	VAL v628 = pop_value();
	incref(v628);
	incref(v627);
	int64_t v629 = 35LL /* PRIM_F32_ADD */;
	push_value(v628);
	push_value(v627);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v628, v627, v629);
	VAL v630 = pop_value();
	VAL v631 = pop_value();
	incref(v631);
	incref(v630);
	int64_t v632 = 36LL /* PRIM_F32_SUB */;
	push_value(v631);
	push_value(v630);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v631, v630, v632);
	VAL v633 = pop_value();
	VAL v634 = pop_value();
	incref(v634);
	incref(v633);
	int64_t v635 = 37LL /* PRIM_F32_MUL */;
	push_value(v634);
	push_value(v633);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v634, v633, v635);
	VAL v636 = pop_value();
	VAL v637 = pop_value();
	incref(v637);
	incref(v636);
	int64_t v638 = 38LL /* PRIM_F32_DIV */;
	push_value(v637);
	push_value(v636);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v637, v636, v638);
	VAL v639 = pop_value();
	decref(v639);
	VAL v640 = pop_value();
	decref(v640);
	VAL v641 = mw_mirth_var_Ctx0();
	push_value(v641);
	VAL v642 = mw_mirth_type_TYPEz_F64();
	push_value(v642);
	VAL v643 = mw_mirth_type_TYPEz_F64();
	VAL v644 = pop_value();
	VAL v645 = mw_mirth_type_T2(v644, v643);
	push_value(v645);
	VAL v646 = mw_mirth_type_TYPEz_F64();
	VAL v647 = mw_mirth_type_T1(v646);
	VAL v648 = pop_value();
	VAL v649 = mw_mirth_type_TZ_ZTo(v648, v647);
	VAL v650 = pop_value();
	incref(v650);
	incref(v649);
	int64_t v651 = 44LL /* PRIM_F64_ADD */;
	push_value(v650);
	push_value(v649);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v650, v649, v651);
	VAL v652 = pop_value();
	VAL v653 = pop_value();
	incref(v653);
	incref(v652);
	int64_t v654 = 45LL /* PRIM_F64_SUB */;
	push_value(v653);
	push_value(v652);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v653, v652, v654);
	VAL v655 = pop_value();
	VAL v656 = pop_value();
	incref(v656);
	incref(v655);
	int64_t v657 = 46LL /* PRIM_F64_MUL */;
	push_value(v656);
	push_value(v655);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v656, v655, v657);
	VAL v658 = pop_value();
	VAL v659 = pop_value();
	incref(v659);
	incref(v658);
	int64_t v660 = 47LL /* PRIM_F64_DIV */;
	push_value(v659);
	push_value(v658);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v659, v658, v660);
	VAL v661 = pop_value();
	decref(v661);
	VAL v662 = pop_value();
	decref(v662);
	VAL v663 = mw_mirth_var_Ctx0();
	VAL r664 = pop_resource();
	push_value(v663);
	mw_mirth_data_TYPEz_BOOL(r664);
	VAL r665 = pop_resource();
	mw_mirth_data_TYPEz_BOOL(r665);
	VAL v666 = pop_value();
	VAL v667 = pop_value();
	VAL v668 = mw_mirth_type_T2(v667, v666);
	VAL r669 = pop_resource();
	push_value(v668);
	mw_mirth_data_TYPEz_BOOL(r669);
	VAL v670 = pop_value();
	VAL v671 = mw_mirth_type_T1(v670);
	VAL v672 = pop_value();
	VAL v673 = mw_mirth_type_TZ_ZTo(v672, v671);
	VAL v674 = pop_value();
	incref(v674);
	incref(v673);
	int64_t v675 = 51LL /* PRIM_BOOL_AND */;
	push_value(v674);
	push_value(v673);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v674, v673, v675);
	VAL v676 = pop_value();
	VAL v677 = pop_value();
	incref(v677);
	incref(v676);
	int64_t v678 = 52LL /* PRIM_BOOL_OR */;
	push_value(v677);
	push_value(v676);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v677, v676, v678);
	VAL v679 = pop_value();
	decref(v679);
	VAL v680 = pop_value();
	decref(v680);
	VAL v681 = mw_mirth_var_Ctx0();
	VAL r682 = pop_resource();
	push_value(v681);
	mw_mirth_data_TYPEz_BOOL(r682);
	VAL v683 = pop_value();
	VAL v684 = mw_mirth_type_T1(v683);
	VAL r685 = pop_resource();
	push_value(v684);
	mw_mirth_data_TYPEz_BOOL(r685);
	VAL v686 = pop_value();
	VAL v687 = mw_mirth_type_T1(v686);
	VAL v688 = pop_value();
	VAL v689 = mw_mirth_type_TZ_ZTo(v688, v687);
	int64_t v690 = 53LL /* PRIM_BOOL_NOT */;
	VAL v691 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v691, v689, v690);
	VAL v692 = mw_mirth_var_Ctx0();
	push_value(v692);
	VAL v693 = mw_mirth_type_TYPEz_INT();
	VAL v694 = mw_mirth_type_T1(v693);
	push_value(v694);
	VAL v695 = mw_mirth_type_TYPEz_STR();
	VAL v696 = mw_mirth_type_T1(v695);
	VAL v697 = pop_value();
	VAL v698 = mw_mirth_type_TZ_ZTo(v697, v696);
	int64_t v699 = 30LL /* PRIM_INT_TO_STR */;
	VAL v700 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v700, v698, v699);
	VAL v701 = mw_mirth_var_Ctx0();
	push_value(v701);
	VAL v702 = mw_mirth_type_TYPEz_INT();
	VAL v703 = mw_mirth_type_T1(v702);
	push_value(v703);
	VAL v704 = mw_mirth_type_TYPEz_F32();
	VAL v705 = mw_mirth_type_T1(v704);
	VAL v706 = pop_value();
	VAL v707 = mw_mirth_type_TZ_ZTo(v706, v705);
	int64_t v708 = 31LL /* PRIM_INT_TO_F32 */;
	VAL v709 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v709, v707, v708);
	VAL v710 = mw_mirth_var_Ctx0();
	push_value(v710);
	VAL v711 = mw_mirth_type_TYPEz_INT();
	VAL v712 = mw_mirth_type_T1(v711);
	push_value(v712);
	VAL v713 = mw_mirth_type_TYPEz_F64();
	VAL v714 = mw_mirth_type_T1(v713);
	VAL v715 = pop_value();
	VAL v716 = mw_mirth_type_TZ_ZTo(v715, v714);
	int64_t v717 = 32LL /* PRIM_INT_TO_F64 */;
	VAL v718 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v718, v716, v717);
	VAL v719 = mw_mirth_var_Ctx0();
	push_value(v719);
	VAL v720 = mw_mirth_type_TYPEz_F32();
	VAL v721 = mw_mirth_type_T1(v720);
	push_value(v721);
	VAL v722 = mw_mirth_type_TYPEz_STR();
	VAL v723 = mw_mirth_type_T1(v722);
	VAL v724 = pop_value();
	VAL v725 = mw_mirth_type_TZ_ZTo(v724, v723);
	int64_t v726 = 40LL /* PRIM_F32_TO_STR */;
	VAL v727 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v727, v725, v726);
	VAL v728 = mw_mirth_var_Ctx0();
	push_value(v728);
	VAL v729 = mw_mirth_type_TYPEz_F64();
	VAL v730 = mw_mirth_type_T1(v729);
	push_value(v730);
	VAL v731 = mw_mirth_type_TYPEz_STR();
	VAL v732 = mw_mirth_type_T1(v731);
	VAL v733 = pop_value();
	VAL v734 = mw_mirth_type_TZ_ZTo(v733, v732);
	int64_t v735 = 49LL /* PRIM_F64_TO_STR */;
	VAL v736 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v736, v734, v735);
	VAL v737 = mw_mirth_var_Ctx0();
	push_value(v737);
	VAL v738 = mw_mirth_type_TYPEz_F32();
	VAL v739 = mw_mirth_type_T1(v738);
	push_value(v739);
	VAL v740 = mw_mirth_type_TYPEz_INT();
	VAL v741 = mw_mirth_type_T1(v740);
	VAL v742 = pop_value();
	VAL v743 = mw_mirth_type_TZ_ZTo(v742, v741);
	int64_t v744 = 39LL /* PRIM_F32_TO_INT */;
	VAL v745 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v745, v743, v744);
	VAL v746 = mw_mirth_var_Ctx0();
	push_value(v746);
	VAL v747 = mw_mirth_type_TYPEz_F64();
	VAL v748 = mw_mirth_type_T1(v747);
	push_value(v748);
	VAL v749 = mw_mirth_type_TYPEz_INT();
	VAL v750 = mw_mirth_type_T1(v749);
	VAL v751 = pop_value();
	VAL v752 = mw_mirth_type_TZ_ZTo(v751, v750);
	int64_t v753 = 48LL /* PRIM_F64_TO_INT */;
	VAL v754 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v754, v752, v753);
	VAL v755 = mw_mirth_var_Ctx0();
	push_value(v755);
	VAL v756 = mw_mirth_type_TYPEz_PTR();
	VAL v757 = mw_mirth_type_T1(v756);
	push_value(v757);
	VAL v758 = mw_mirth_type_TYPEz_PTR();
	VAL v759 = mw_mirth_type_T1(v758);
	VAL v760 = pop_value();
	VAL v761 = mw_mirth_type_TZ_ZTo(v760, v759);
	int64_t v762 = 65LL /* PRIM_PTR_GET */;
	VAL v763 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v763, v761, v762);
	VAL v764 = mw_mirth_var_Ctx0();
	push_value(v764);
	VAL v765 = mw_mirth_type_TYPEz_PTR();
	VAL v766 = mw_mirth_type_T1(v765);
	VAL r767 = pop_resource();
	push_value(v766);
	mw_mirth_data_TYPEz_U8(r767);
	VAL v768 = pop_value();
	VAL v769 = mw_mirth_type_T1(v768);
	VAL v770 = pop_value();
	VAL v771 = mw_mirth_type_TZ_ZTo(v770, v769);
	int64_t v772 = 83LL /* PRIM_U8_GET */;
	VAL v773 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v773, v771, v772);
	VAL v774 = mw_mirth_var_Ctx0();
	push_value(v774);
	VAL v775 = mw_mirth_type_TYPEz_PTR();
	VAL v776 = mw_mirth_type_T1(v775);
	VAL r777 = pop_resource();
	push_value(v776);
	mw_mirth_data_TYPEz_U16(r777);
	VAL v778 = pop_value();
	VAL v779 = mw_mirth_type_T1(v778);
	VAL v780 = pop_value();
	VAL v781 = mw_mirth_type_TZ_ZTo(v780, v779);
	int64_t v782 = 85LL /* PRIM_U16_GET */;
	VAL v783 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v783, v781, v782);
	VAL v784 = mw_mirth_var_Ctx0();
	push_value(v784);
	VAL v785 = mw_mirth_type_TYPEz_PTR();
	VAL v786 = mw_mirth_type_T1(v785);
	VAL r787 = pop_resource();
	push_value(v786);
	mw_mirth_data_TYPEz_U32(r787);
	VAL v788 = pop_value();
	VAL v789 = mw_mirth_type_T1(v788);
	VAL v790 = pop_value();
	VAL v791 = mw_mirth_type_TZ_ZTo(v790, v789);
	int64_t v792 = 87LL /* PRIM_U32_GET */;
	VAL v793 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v793, v791, v792);
	VAL v794 = mw_mirth_var_Ctx0();
	push_value(v794);
	VAL v795 = mw_mirth_type_TYPEz_PTR();
	VAL v796 = mw_mirth_type_T1(v795);
	VAL r797 = pop_resource();
	push_value(v796);
	mw_mirth_data_TYPEz_U64(r797);
	VAL v798 = pop_value();
	VAL v799 = mw_mirth_type_T1(v798);
	VAL v800 = pop_value();
	VAL v801 = mw_mirth_type_TZ_ZTo(v800, v799);
	int64_t v802 = 89LL /* PRIM_U64_GET */;
	VAL v803 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v803, v801, v802);
	VAL v804 = mw_mirth_var_Ctx0();
	push_value(v804);
	VAL v805 = mw_mirth_type_TYPEz_PTR();
	VAL v806 = mw_mirth_type_T1(v805);
	VAL r807 = pop_resource();
	push_value(v806);
	mw_mirth_data_TYPEz_I8(r807);
	VAL v808 = pop_value();
	VAL v809 = mw_mirth_type_T1(v808);
	VAL v810 = pop_value();
	VAL v811 = mw_mirth_type_TZ_ZTo(v810, v809);
	int64_t v812 = 91LL /* PRIM_I8_GET */;
	VAL v813 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v813, v811, v812);
	VAL v814 = mw_mirth_var_Ctx0();
	push_value(v814);
	VAL v815 = mw_mirth_type_TYPEz_PTR();
	VAL v816 = mw_mirth_type_T1(v815);
	VAL r817 = pop_resource();
	push_value(v816);
	mw_mirth_data_TYPEz_I16(r817);
	VAL v818 = pop_value();
	VAL v819 = mw_mirth_type_T1(v818);
	VAL v820 = pop_value();
	VAL v821 = mw_mirth_type_TZ_ZTo(v820, v819);
	int64_t v822 = 93LL /* PRIM_I16_GET */;
	VAL v823 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v823, v821, v822);
	VAL v824 = mw_mirth_var_Ctx0();
	push_value(v824);
	VAL v825 = mw_mirth_type_TYPEz_PTR();
	VAL v826 = mw_mirth_type_T1(v825);
	VAL r827 = pop_resource();
	push_value(v826);
	mw_mirth_data_TYPEz_I32(r827);
	VAL v828 = pop_value();
	VAL v829 = mw_mirth_type_T1(v828);
	VAL v830 = pop_value();
	VAL v831 = mw_mirth_type_TZ_ZTo(v830, v829);
	int64_t v832 = 95LL /* PRIM_I32_GET */;
	VAL v833 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v833, v831, v832);
	VAL v834 = mw_mirth_var_Ctx0();
	push_value(v834);
	VAL v835 = mw_mirth_type_TYPEz_PTR();
	VAL v836 = mw_mirth_type_T1(v835);
	VAL r837 = pop_resource();
	push_value(v836);
	mw_mirth_data_TYPEz_I64(r837);
	VAL v838 = pop_value();
	VAL v839 = mw_mirth_type_T1(v838);
	VAL v840 = pop_value();
	VAL v841 = mw_mirth_type_TZ_ZTo(v840, v839);
	int64_t v842 = 97LL /* PRIM_I64_GET */;
	VAL v843 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v843, v841, v842);
	VAL v844 = mw_mirth_var_Ctx0();
	push_value(v844);
	VAL v845 = mw_mirth_type_TYPEz_PTR();
	push_value(v845);
	VAL v846 = mw_mirth_type_TYPEz_PTR();
	VAL v847 = pop_value();
	VAL v848 = mw_mirth_type_T2(v847, v846);
	push_value(v848);
	VAL v849 = mw_mirth_type_T0();
	VAL v850 = pop_value();
	VAL v851 = mw_mirth_type_TZ_ZTo(v850, v849);
	int64_t v852 = 66LL /* PRIM_PTR_SET */;
	VAL v853 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v853, v851, v852);
	VAL v854 = mw_mirth_var_Ctx0();
	VAL r855 = pop_resource();
	push_value(v854);
	mw_mirth_data_TYPEz_U8(r855);
	VAL v856 = mw_mirth_type_TYPEz_PTR();
	VAL v857 = pop_value();
	VAL v858 = mw_mirth_type_T2(v857, v856);
	push_value(v858);
	VAL v859 = mw_mirth_type_T0();
	VAL v860 = pop_value();
	VAL v861 = mw_mirth_type_TZ_ZTo(v860, v859);
	int64_t v862 = 84LL /* PRIM_U8_SET */;
	VAL v863 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v863, v861, v862);
	VAL v864 = mw_mirth_var_Ctx0();
	VAL r865 = pop_resource();
	push_value(v864);
	mw_mirth_data_TYPEz_U16(r865);
	VAL v866 = mw_mirth_type_TYPEz_PTR();
	VAL v867 = pop_value();
	VAL v868 = mw_mirth_type_T2(v867, v866);
	push_value(v868);
	VAL v869 = mw_mirth_type_T0();
	VAL v870 = pop_value();
	VAL v871 = mw_mirth_type_TZ_ZTo(v870, v869);
	int64_t v872 = 86LL /* PRIM_U16_SET */;
	VAL v873 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v873, v871, v872);
	VAL v874 = mw_mirth_var_Ctx0();
	VAL r875 = pop_resource();
	push_value(v874);
	mw_mirth_data_TYPEz_U32(r875);
	VAL v876 = mw_mirth_type_TYPEz_PTR();
	VAL v877 = pop_value();
	VAL v878 = mw_mirth_type_T2(v877, v876);
	push_value(v878);
	VAL v879 = mw_mirth_type_T0();
	VAL v880 = pop_value();
	VAL v881 = mw_mirth_type_TZ_ZTo(v880, v879);
	int64_t v882 = 88LL /* PRIM_U32_SET */;
	VAL v883 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v883, v881, v882);
	VAL v884 = mw_mirth_var_Ctx0();
	VAL r885 = pop_resource();
	push_value(v884);
	mw_mirth_data_TYPEz_U64(r885);
	VAL v886 = mw_mirth_type_TYPEz_PTR();
	VAL v887 = pop_value();
	VAL v888 = mw_mirth_type_T2(v887, v886);
	push_value(v888);
	VAL v889 = mw_mirth_type_T0();
	VAL v890 = pop_value();
	VAL v891 = mw_mirth_type_TZ_ZTo(v890, v889);
	int64_t v892 = 90LL /* PRIM_U64_SET */;
	VAL v893 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v893, v891, v892);
	VAL v894 = mw_mirth_var_Ctx0();
	VAL r895 = pop_resource();
	push_value(v894);
	mw_mirth_data_TYPEz_I8(r895);
	VAL v896 = mw_mirth_type_TYPEz_PTR();
	VAL v897 = pop_value();
	VAL v898 = mw_mirth_type_T2(v897, v896);
	push_value(v898);
	VAL v899 = mw_mirth_type_T0();
	VAL v900 = pop_value();
	VAL v901 = mw_mirth_type_TZ_ZTo(v900, v899);
	int64_t v902 = 92LL /* PRIM_I8_SET */;
	VAL v903 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v903, v901, v902);
	VAL v904 = mw_mirth_var_Ctx0();
	VAL r905 = pop_resource();
	push_value(v904);
	mw_mirth_data_TYPEz_I16(r905);
	VAL v906 = mw_mirth_type_TYPEz_PTR();
	VAL v907 = pop_value();
	VAL v908 = mw_mirth_type_T2(v907, v906);
	push_value(v908);
	VAL v909 = mw_mirth_type_T0();
	VAL v910 = pop_value();
	VAL v911 = mw_mirth_type_TZ_ZTo(v910, v909);
	int64_t v912 = 94LL /* PRIM_I16_SET */;
	VAL v913 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v913, v911, v912);
	VAL v914 = mw_mirth_var_Ctx0();
	VAL r915 = pop_resource();
	push_value(v914);
	mw_mirth_data_TYPEz_I32(r915);
	VAL v916 = mw_mirth_type_TYPEz_PTR();
	VAL v917 = pop_value();
	VAL v918 = mw_mirth_type_T2(v917, v916);
	push_value(v918);
	VAL v919 = mw_mirth_type_T0();
	VAL v920 = pop_value();
	VAL v921 = mw_mirth_type_TZ_ZTo(v920, v919);
	int64_t v922 = 96LL /* PRIM_I32_SET */;
	VAL v923 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v923, v921, v922);
	VAL v924 = mw_mirth_var_Ctx0();
	VAL r925 = pop_resource();
	push_value(v924);
	mw_mirth_data_TYPEz_I64(r925);
	VAL v926 = mw_mirth_type_TYPEz_PTR();
	VAL v927 = pop_value();
	VAL v928 = mw_mirth_type_T2(v927, v926);
	push_value(v928);
	VAL v929 = mw_mirth_type_T0();
	VAL v930 = pop_value();
	VAL v931 = mw_mirth_type_TZ_ZTo(v930, v929);
	int64_t v932 = 98LL /* PRIM_I64_SET */;
	VAL v933 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v933, v931, v932);
	VAL v934 = mw_mirth_var_Ctx0();
	push_value(v934);
	VAL v935 = mw_mirth_type_T0();
	push_value(v935);
	VAL v936 = mw_mirth_type_TYPEz_PTR();
	VAL v937 = mw_mirth_type_T1(v936);
	VAL v938 = pop_value();
	VAL v939 = mw_mirth_type_TZ_ZTo(v938, v937);
	int64_t v940 = 61LL /* PRIM_PTR_NIL */;
	VAL v941 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v941, v939, v940);
	VAL v942 = mw_mirth_var_Ctx0();
	push_value(v942);
	VAL v943 = mw_mirth_type_TYPEz_PTR();
	push_value(v943);
	VAL v944 = mw_mirth_type_TYPEz_PTR();
	VAL v945 = pop_value();
	VAL v946 = mw_mirth_type_T2(v945, v944);
	VAL r947 = pop_resource();
	push_value(v946);
	mw_mirth_data_TYPEz_BOOL(r947);
	VAL v948 = pop_value();
	VAL v949 = mw_mirth_type_T1(v948);
	VAL v950 = pop_value();
	VAL v951 = mw_mirth_type_TZ_ZTo(v950, v949);
	int64_t v952 = 62LL /* PRIM_PTR_EQ */;
	VAL v953 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v953, v951, v952);
	VAL v954 = mw_mirth_var_Ctx0();
	push_value(v954);
	VAL v955 = mw_mirth_type_TYPEz_INT();
	push_value(v955);
	VAL v956 = mw_mirth_type_TYPEz_PTR();
	VAL v957 = pop_value();
	VAL v958 = mw_mirth_type_T2(v957, v956);
	push_value(v958);
	VAL v959 = mw_mirth_type_TYPEz_PTR();
	VAL v960 = mw_mirth_type_T1(v959);
	VAL v961 = pop_value();
	VAL v962 = mw_mirth_type_TZ_ZTo(v961, v960);
	int64_t v963 = 63LL /* PRIM_PTR_ADD */;
	VAL v964 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v964, v962, v963);
	VAL v965 = mw_mirth_var_Ctx0();
	push_value(v965);
	VAL v966 = mw_mirth_type_T0();
	push_value(v966);
	VAL v967 = mw_mirth_type_TYPEz_INT();
	VAL v968 = mw_mirth_type_T1(v967);
	VAL v969 = pop_value();
	VAL v970 = mw_mirth_type_TZ_ZTo(v969, v968);
	int64_t v971 = 64LL /* PRIM_PTR_SIZE */;
	VAL v972 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v972, v970, v971);
	VAL v973 = mw_mirth_var_Ctx0();
	push_value(v973);
	VAL v974 = mw_mirth_type_TYPEz_INT();
	VAL v975 = mw_mirth_type_T1(v974);
	push_value(v975);
	VAL v976 = mw_mirth_type_TYPEz_PTR();
	VAL v977 = mw_mirth_type_T1(v976);
	VAL v978 = pop_value();
	VAL v979 = mw_mirth_type_TZ_ZTo(v978, v977);
	int64_t v980 = 67LL /* PRIM_PTR_ALLOC */;
	VAL v981 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v981, v979, v980);
	VAL v982 = mw_mirth_var_Ctx0();
	push_value(v982);
	VAL v983 = mw_mirth_type_TYPEz_PTR();
	push_value(v983);
	VAL v984 = mw_mirth_type_TYPEz_INT();
	VAL v985 = pop_value();
	VAL v986 = mw_mirth_type_T2(v985, v984);
	push_value(v986);
	VAL v987 = mw_mirth_type_TYPEz_PTR();
	VAL v988 = mw_mirth_type_T1(v987);
	VAL v989 = pop_value();
	VAL v990 = mw_mirth_type_TZ_ZTo(v989, v988);
	int64_t v991 = 68LL /* PRIM_PTR_REALLOC */;
	VAL v992 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v992, v990, v991);
	VAL v993 = mw_mirth_var_Ctx0();
	push_value(v993);
	VAL v994 = mw_mirth_type_TYPEz_PTR();
	VAL v995 = mw_mirth_type_T1(v994);
	push_value(v995);
	VAL v996 = mw_mirth_type_T0();
	VAL v997 = pop_value();
	VAL v998 = mw_mirth_type_TZ_ZTo(v997, v996);
	int64_t v999 = 69LL /* PRIM_PTR_FREE */;
	VAL v1000 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1000, v998, v999);
	VAL v1001 = mw_mirth_var_Ctx0();
	push_value(v1001);
	VAL v1002 = mw_mirth_type_TYPEz_PTR();
	push_value(v1002);
	VAL v1003 = mw_mirth_type_TYPEz_INT();
	push_value(v1003);
	VAL v1004 = mw_mirth_type_TYPEz_PTR();
	VAL v1005 = pop_value();
	VAL v1006 = pop_value();
	VAL v1007 = mw_mirth_type_T3(v1006, v1005, v1004);
	push_value(v1007);
	VAL v1008 = mw_mirth_type_T0();
	VAL v1009 = pop_value();
	VAL v1010 = mw_mirth_type_TZ_ZTo(v1009, v1008);
	int64_t v1011 = 70LL /* PRIM_PTR_COPY */;
	VAL v1012 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1012, v1010, v1011);
	VAL v1013 = mw_mirth_var_Ctx0();
	push_value(v1013);
	VAL v1014 = mw_mirth_type_TYPEz_INT();
	push_value(v1014);
	VAL v1015 = mw_mirth_type_TYPEz_INT();
	push_value(v1015);
	VAL v1016 = mw_mirth_type_TYPEz_PTR();
	VAL v1017 = pop_value();
	VAL v1018 = pop_value();
	VAL v1019 = mw_mirth_type_T3(v1018, v1017, v1016);
	push_value(v1019);
	VAL v1020 = mw_mirth_type_T0();
	VAL v1021 = pop_value();
	VAL v1022 = mw_mirth_type_TZ_ZTo(v1021, v1020);
	int64_t v1023 = 71LL /* PRIM_PTR_FILL */;
	VAL v1024 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1024, v1022, v1023);
	VAL v1025 = mw_mirth_var_Ctx0();
	push_value(v1025);
	VAL v1026 = mw_mirth_type_TYPEz_PTR();
	push_value(v1026);
	VAL v1027 = mw_mirth_type_TYPEz_INT();
	VAL v1028 = pop_value();
	VAL v1029 = mw_mirth_type_T2(v1028, v1027);
	push_value(v1029);
	VAL v1030 = mw_mirth_type_TYPEz_STR();
	VAL v1031 = mw_mirth_type_T1(v1030);
	VAL v1032 = pop_value();
	VAL v1033 = mw_mirth_type_TZ_ZTo(v1032, v1031);
	int64_t v1034 = 72LL /* PRIM_STR_COPY */;
	VAL v1035 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1035, v1033, v1034);
	VAL v1036 = mw_mirth_var_Ctx0();
	push_value(v1036);
	VAL v1037 = mw_mirth_type_TYPEz_STR();
	VAL v1038 = mw_mirth_type_T1(v1037);
	push_value(v1038);
	VAL v1039 = mw_mirth_type_TYPEz_INT();
	VAL v1040 = mw_mirth_type_T1(v1039);
	VAL v1041 = pop_value();
	VAL v1042 = mw_mirth_type_TZ_ZTo(v1041, v1040);
	int64_t v1043 = 73LL /* PRIM_STR_NUM_BYTES */;
	VAL v1044 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1044, v1042, v1043);
	VAL v1045 = mw_mirth_var_Ctx0();
	push_value(v1045);
	VAL v1046 = mw_mirth_type_TYPEz_STR();
	VAL v1047 = mw_mirth_type_T1(v1046);
	push_value(v1047);
	VAL v1048 = mw_mirth_type_TYPEz_PTR();
	VAL v1049 = mw_mirth_type_T1(v1048);
	VAL v1050 = pop_value();
	VAL v1051 = mw_mirth_type_TZ_ZTo(v1050, v1049);
	int64_t v1052 = 74LL /* PRIM_STR_BASE */;
	VAL v1053 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1053, v1051, v1052);
	VAL v1054 = mw_mirth_var_Ctx0();
	push_value(v1054);
	VAL v1055 = mw_mirth_type_TYPEz_STR();
	push_value(v1055);
	VAL v1056 = mw_mirth_type_TYPEz_STR();
	VAL v1057 = pop_value();
	VAL v1058 = mw_mirth_type_T2(v1057, v1056);
	push_value(v1058);
	VAL v1059 = mw_mirth_type_TYPEz_STR();
	VAL v1060 = mw_mirth_type_T1(v1059);
	VAL v1061 = pop_value();
	VAL v1062 = mw_mirth_type_TZ_ZTo(v1061, v1060);
	int64_t v1063 = 75LL /* PRIM_STR_CAT */;
	VAL v1064 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1064, v1062, v1063);
	VAL v1065 = mw_mirth_var_Ctx0();
	push_value(v1065);
	VAL v1066 = mw_mirth_type_TYPEz_STR();
	push_value(v1066);
	VAL v1067 = mw_mirth_type_TYPEz_STR();
	VAL v1068 = pop_value();
	VAL v1069 = mw_mirth_type_T2(v1068, v1067);
	push_value(v1069);
	VAL v1070 = mw_mirth_type_TYPEz_INT();
	VAL v1071 = mw_mirth_type_T1(v1070);
	VAL v1072 = pop_value();
	VAL v1073 = mw_mirth_type_TZ_ZTo(v1072, v1071);
	int64_t v1074 = 76LL /* PRIM_STR_CMP */;
	VAL v1075 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1075, v1073, v1074);
	VAL v1076 = mw_mirth_var_Ctx0();
	push_value(v1076);
	VAL v1077 = mw_mirth_type_TYPEz_STR();
	push_value(v1077);
	VAL v1078 = mw_mirth_type_TYPEz_STR();
	VAL v1079 = pop_value();
	VAL v1080 = mw_mirth_type_T2(v1079, v1078);
	VAL r1081 = pop_resource();
	push_value(v1080);
	mw_mirth_data_TYPEz_BOOL(r1081);
	VAL v1082 = pop_value();
	VAL v1083 = mw_mirth_type_T1(v1082);
	VAL v1084 = pop_value();
	VAL v1085 = mw_mirth_type_TZ_ZTo(v1084, v1083);
	VAL v1086 = pop_value();
	incref(v1086);
	incref(v1085);
	int64_t v1087 = 77LL /* PRIM_STR_EQ */;
	push_value(v1086);
	push_value(v1085);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1086, v1085, v1087);
	VAL v1088 = pop_value();
	VAL v1089 = pop_value();
	incref(v1089);
	incref(v1088);
	int64_t v1090 = 78LL /* PRIM_STR_LT */;
	push_value(v1089);
	push_value(v1088);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1089, v1088, v1090);
	VAL v1091 = pop_value();
	VAL v1092 = pop_value();
	incref(v1092);
	incref(v1091);
	int64_t v1093 = 79LL /* PRIM_STR_LE */;
	push_value(v1092);
	push_value(v1091);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1092, v1091, v1093);
	VAL v1094 = pop_value();
	VAL v1095 = pop_value();
	incref(v1095);
	incref(v1094);
	int64_t v1096 = 80LL /* PRIM_STR_GT */;
	push_value(v1095);
	push_value(v1094);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1095, v1094, v1096);
	VAL v1097 = pop_value();
	VAL v1098 = pop_value();
	incref(v1098);
	incref(v1097);
	int64_t v1099 = 81LL /* PRIM_STR_GE */;
	push_value(v1098);
	push_value(v1097);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1098, v1097, v1099);
	VAL v1100 = pop_value();
	VAL v1101 = pop_value();
	incref(v1101);
	incref(v1100);
	int64_t v1102 = 82LL /* PRIM_STR_NE */;
	push_value(v1101);
	push_value(v1100);
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1101, v1100, v1102);
	VAL v1103 = pop_value();
	decref(v1103);
	VAL v1104 = pop_value();
	decref(v1104);
	VAL v1105 = mw_mirth_var_Ctx0();
	push_value(v1105);
	VAL v1106 = mw_mirth_type_T0();
	push_value(v1106);
	VAL v1107 = mw_mirth_type_TYPEz_INT();
	VAL v1108 = mw_mirth_type_T1(v1107);
	VAL v1109 = pop_value();
	VAL v1110 = mw_mirth_type_TZ_ZTo(v1109, v1108);
	int64_t v1111 = 99LL /* PRIM_SYS_OS */;
	VAL v1112 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1112, v1110, v1111);
	VAL v1113 = mw_mirth_var_Ctx0();
	push_value(v1113);
	VAL v1114 = mw_mirth_type_T0();
	push_value(v1114);
	VAL v1115 = mw_mirth_type_TYPEz_INT();
	VAL v1116 = mw_mirth_type_T1(v1115);
	VAL v1117 = pop_value();
	VAL v1118 = mw_mirth_type_TZ_ZTo(v1117, v1116);
	int64_t v1119 = 100LL /* PRIM_SYS_ARCH */;
	VAL v1120 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1120, v1118, v1119);
	VAL v1121 = mw_mirth_var_Ctx0();
	push_value(v1121);
	VAL v1122 = mw_mirth_type_T0();
	push_value(v1122);
	VAL v1123 = mw_mirth_type_TYPEz_INT();
	VAL v1124 = mw_mirth_type_T1(v1123);
	VAL v1125 = pop_value();
	VAL v1126 = mw_mirth_type_TZ_ZTo(v1125, v1124);
	int64_t v1127 = 101LL /* PRIM_SYS_ARGC */;
	VAL v1128 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1128, v1126, v1127);
	VAL v1129 = mw_mirth_var_Ctx0();
	push_value(v1129);
	VAL v1130 = mw_mirth_type_T0();
	push_value(v1130);
	VAL v1131 = mw_mirth_type_TYPEz_PTR();
	VAL v1132 = mw_mirth_type_T1(v1131);
	VAL v1133 = pop_value();
	VAL v1134 = mw_mirth_type_TZ_ZTo(v1133, v1132);
	int64_t v1135 = 102LL /* PRIM_SYS_ARGV */;
	VAL v1136 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1136, v1134, v1135);
	VAL v1137 = mw_mirth_var_Ctx0();
	push_value(v1137);
	VAL v1138 = mw_mirth_type_T0();
	push_value(v1138);
	VAL v1139 = mw_mirth_type_T0();
	VAL v1140 = mw_mirth_type_StackType_ZToType(v1139);
	VAL v1141 = mw_mirth_type_T1(v1140);
	VAL v1142 = pop_value();
	VAL v1143 = mw_mirth_type_TZ_ZTo(v1142, v1141);
	int64_t v1144 = 54LL /* PRIM_PACK_NIL */;
	VAL v1145 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1145, v1143, v1144);
	VAL v1146 = mw_mirth_type_TYPEz_TYPE();
	STR* v1147;
	STRLIT(v1147, "a", 1);
	push_value(v1146);
	uint64_t v1148 = mw_std_prim_Str_ZToName(MKSTR(v1147));
	VAL v1149 = pop_value();
	uint64_t v1150 = mw_mirth_var_Var_newZBang(v1149, v1148);
	lpush(&lbl_a, MKU64(v1150));
	VAL v1151 = mw_mirth_type_TYPEz_TYPE();
	STR* v1152;
	STRLIT(v1152, "b", 1);
	push_value(v1151);
	uint64_t v1153 = mw_std_prim_Str_ZToName(MKSTR(v1152));
	VAL v1154 = pop_value();
	uint64_t v1155 = mw_mirth_var_Var_newZBang(v1154, v1153);
	lpush(&lbl_b, MKU64(v1155));
	VAL v1156 = mw_mirth_type_TYPEz_TYPE();
	STR* v1157;
	STRLIT(v1157, "c", 1);
	push_value(v1156);
	uint64_t v1158 = mw_std_prim_Str_ZToName(MKSTR(v1157));
	VAL v1159 = pop_value();
	uint64_t v1160 = mw_mirth_var_Var_newZBang(v1159, v1158);
	lpush(&lbl_c, MKU64(v1160));
	VAL v1161 = mw_mirth_type_TYPEz_RESOURCE();
	STR* v1162;
	STRLIT(v1162, "+r", 2);
	push_value(v1161);
	uint64_t v1163 = mw_std_prim_Str_ZToName(MKSTR(v1162));
	VAL v1164 = pop_value();
	uint64_t v1165 = mw_mirth_var_Var_newZBang(v1164, v1163);
	lpush(&lbl_rr, MKU64(v1165));
	VAL v1166 = mw_mirth_type_TYPEz_RESOURCE();
	STR* v1167;
	STRLIT(v1167, "+s", 2);
	push_value(v1166);
	uint64_t v1168 = mw_std_prim_Str_ZToName(MKSTR(v1167));
	VAL v1169 = pop_value();
	uint64_t v1170 = mw_mirth_var_Var_newZBang(v1169, v1168);
	lpush(&lbl_sr, MKU64(v1170));
	VAL v1171 = mw_mirth_type_TYPEz_STACK();
	STR* v1172;
	STRLIT(v1172, "*x", 2);
	push_value(v1171);
	uint64_t v1173 = mw_std_prim_Str_ZToName(MKSTR(v1172));
	VAL v1174 = pop_value();
	uint64_t v1175 = mw_mirth_var_Var_newZBang(v1174, v1173);
	lpush(&lbl_xs, MKU64(v1175));
	VAL v1176 = mw_mirth_type_TYPEz_STACK();
	STR* v1177;
	STRLIT(v1177, "*y", 2);
	push_value(v1176);
	uint64_t v1178 = mw_std_prim_Str_ZToName(MKSTR(v1177));
	VAL v1179 = pop_value();
	uint64_t v1180 = mw_mirth_var_Var_newZBang(v1179, v1178);
	uint64_t v1181 = VU64(lpop(&lbl_a));
	lpush(&lbl_ys, MKU64(v1180));
	lpush(&lbl_a, MKU64(v1181));
	VAL v1182 = mtw_mirth_type_Type_TVar(v1181);
	uint64_t v1183 = VU64(lpop(&lbl_b));
	lpush(&lbl_ta, v1182);
	lpush(&lbl_b, MKU64(v1183));
	VAL v1184 = mtw_mirth_type_Type_TVar(v1183);
	uint64_t v1185 = VU64(lpop(&lbl_c));
	lpush(&lbl_tb, v1184);
	lpush(&lbl_c, MKU64(v1185));
	VAL v1186 = mtw_mirth_type_Type_TVar(v1185);
	uint64_t v1187 = VU64(lpop(&lbl_rr));
	lpush(&lbl_tc, v1186);
	lpush(&lbl_rr, MKU64(v1187));
	VAL v1188 = mtw_mirth_type_Type_TVar(v1187);
	uint64_t v1189 = VU64(lpop(&lbl_sr));
	lpush(&lbl_trr, v1188);
	lpush(&lbl_sr, MKU64(v1189));
	VAL v1190 = mtw_mirth_type_Type_TVar(v1189);
	uint64_t v1191 = VU64(lpop(&lbl_xs));
	lpush(&lbl_tsr, v1190);
	lpush(&lbl_xs, MKU64(v1191));
	VAL v1192 = mtw_mirth_type_StackType_STVar(v1191);
	uint64_t v1193 = VU64(lpop(&lbl_ys));
	lpush(&lbl_txs, v1192);
	lpush(&lbl_ys, MKU64(v1193));
	VAL v1194 = mtw_mirth_type_StackType_STVar(v1193);
	uint64_t v1195 = VU64(lpop(&lbl_a));
	lpush(&lbl_tys, v1194);
	lpush(&lbl_a, MKU64(v1195));
	VAL v1196 = mw_mirth_var_Ctx1(v1195);
	VAL v1197 = lpop(&lbl_ta);
	incref(v1197);
	push_value(v1196);
	lpush(&lbl_ta, v1197);
	VAL v1198 = mw_mirth_type_T1(v1197);
	push_value(v1198);
	VAL v1199 = mw_mirth_type_T0();
	VAL v1200 = pop_value();
	VAL v1201 = mw_mirth_type_TZ_ZTo(v1200, v1199);
	int64_t v1202 = 2LL /* PRIM_CORE_DROP */;
	VAL v1203 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1203, v1201, v1202);
	uint64_t v1204 = VU64(lpop(&lbl_a));
	lpush(&lbl_a, MKU64(v1204));
	VAL v1205 = mw_mirth_var_Ctx1(v1204);
	VAL v1206 = lpop(&lbl_ta);
	incref(v1206);
	push_value(v1205);
	lpush(&lbl_ta, v1206);
	VAL v1207 = mw_mirth_type_T1(v1206);
	VAL v1208 = lpop(&lbl_ta);
	incref(v1208);
	incref(v1208);
	push_value(v1207);
	lpush(&lbl_ta, v1208);
	VAL v1209 = mw_mirth_type_T2(v1208, v1208);
	VAL v1210 = pop_value();
	VAL v1211 = mw_mirth_type_TZ_ZTo(v1210, v1209);
	int64_t v1212 = 1LL /* PRIM_CORE_DUP */;
	VAL v1213 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1213, v1211, v1212);
	uint64_t v1214 = VU64(lpop(&lbl_a));
	uint64_t v1215 = VU64(lpop(&lbl_b));
	lpush(&lbl_a, MKU64(v1214));
	lpush(&lbl_b, MKU64(v1215));
	VAL v1216 = mw_mirth_var_Ctx2(v1214, v1215);
	VAL v1217 = lpop(&lbl_ta);
	incref(v1217);
	VAL v1218 = lpop(&lbl_tb);
	incref(v1218);
	push_value(v1216);
	lpush(&lbl_ta, v1217);
	lpush(&lbl_tb, v1218);
	VAL v1219 = mw_mirth_type_T2(v1217, v1218);
	VAL v1220 = lpop(&lbl_tb);
	incref(v1220);
	VAL v1221 = lpop(&lbl_ta);
	incref(v1221);
	push_value(v1219);
	lpush(&lbl_tb, v1220);
	lpush(&lbl_ta, v1221);
	VAL v1222 = mw_mirth_type_T2(v1220, v1221);
	VAL v1223 = pop_value();
	VAL v1224 = mw_mirth_type_TZ_ZTo(v1223, v1222);
	int64_t v1225 = 3LL /* PRIM_CORE_SWAP */;
	VAL v1226 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1226, v1224, v1225);
	uint64_t v1227 = VU64(lpop(&lbl_xs));
	uint64_t v1228 = VU64(lpop(&lbl_ys));
	lpush(&lbl_xs, MKU64(v1227));
	lpush(&lbl_ys, MKU64(v1228));
	VAL v1229 = mw_mirth_var_Ctx2(v1227, v1228);
	VAL v1230 = lpop(&lbl_txs);
	incref(v1230);
	incref(v1230);
	VAL v1231 = lpop(&lbl_tys);
	incref(v1231);
	push_value(v1229);
	push_value(v1230);
	lpush(&lbl_txs, v1230);
	lpush(&lbl_tys, v1231);
	VAL v1232 = mw_mirth_type_TZ_ZTo(v1230, v1231);
	VAL v1233 = mtw_mirth_type_Type_TMorphism(v1232);
	VAL v1234 = pop_value();
	VAL v1235 = mw_mirth_type_TZMul(v1234, v1233);
	VAL v1236 = lpop(&lbl_tys);
	incref(v1236);
	lpush(&lbl_tys, v1236);
	VAL v1237 = mw_mirth_type_TZ_ZTo(v1235, v1236);
	int64_t v1238 = 9LL /* PRIM_CORE_RUN */;
	VAL v1239 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1239, v1237, v1238);
	uint64_t v1240 = VU64(lpop(&lbl_xs));
	uint64_t v1241 = VU64(lpop(&lbl_ys));
	lpush(&lbl_xs, MKU64(v1240));
	lpush(&lbl_ys, MKU64(v1241));
	VAL v1242 = mw_mirth_var_Ctx2(v1240, v1241);
	VAL v1243 = lpop(&lbl_txs);
	incref(v1243);
	push_value(v1242);
	push_value(v1243);
	lpush(&lbl_txs, v1243);
	VAL v1244 = mw_mirth_type_TYPEz_STR();
	VAL v1245 = pop_value();
	VAL v1246 = mw_mirth_type_TZMul(v1245, v1244);
	VAL v1247 = lpop(&lbl_tys);
	incref(v1247);
	lpush(&lbl_tys, v1247);
	VAL v1248 = mw_mirth_type_TZ_ZTo(v1246, v1247);
	int64_t v1249 = 8LL /* PRIM_CORE_PANIC */;
	VAL v1250 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1250, v1248, v1249);
	uint64_t v1251 = VU64(lpop(&lbl_xs));
	uint64_t v1252 = VU64(lpop(&lbl_ys));
	uint64_t v1253 = VU64(lpop(&lbl_c));
	lpush(&lbl_xs, MKU64(v1251));
	lpush(&lbl_ys, MKU64(v1252));
	lpush(&lbl_c, MKU64(v1253));
	VAL v1254 = mw_mirth_var_Ctx3(v1251, v1252, v1253);
	VAL v1255 = lpop(&lbl_txs);
	incref(v1255);
	VAL v1256 = lpop(&lbl_tc);
	incref(v1256);
	push_value(v1254);
	lpush(&lbl_txs, v1255);
	lpush(&lbl_tc, v1256);
	VAL v1257 = mw_mirth_type_TZMul(v1255, v1256);
	VAL v1258 = lpop(&lbl_txs);
	incref(v1258);
	VAL v1259 = lpop(&lbl_tys);
	incref(v1259);
	push_value(v1257);
	lpush(&lbl_txs, v1258);
	lpush(&lbl_tys, v1259);
	VAL v1260 = mw_mirth_type_TZ_ZTo(v1258, v1259);
	VAL v1261 = mtw_mirth_type_Type_TMorphism(v1260);
	VAL v1262 = pop_value();
	VAL v1263 = mw_mirth_type_TZMul(v1262, v1261);
	VAL v1264 = lpop(&lbl_tys);
	incref(v1264);
	VAL v1265 = lpop(&lbl_tc);
	incref(v1265);
	push_value(v1263);
	lpush(&lbl_tys, v1264);
	lpush(&lbl_tc, v1265);
	VAL v1266 = mw_mirth_type_TZMul(v1264, v1265);
	VAL v1267 = pop_value();
	VAL v1268 = mw_mirth_type_TZ_ZTo(v1267, v1266);
	int64_t v1269 = 4LL /* PRIM_CORE_DIP */;
	VAL v1270 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1270, v1268, v1269);
	uint64_t v1271 = VU64(lpop(&lbl_xs));
	uint64_t v1272 = VU64(lpop(&lbl_ys));
	lpush(&lbl_xs, MKU64(v1271));
	lpush(&lbl_ys, MKU64(v1272));
	VAL v1273 = mw_mirth_var_Ctx2(v1271, v1272);
	VAL v1274 = lpop(&lbl_txs);
	incref(v1274);
	VAL r1275 = pop_resource();
	push_value(v1273);
	push_value(v1274);
	lpush(&lbl_txs, v1274);
	mw_mirth_data_TYPEz_BOOL(r1275);
	VAL v1276 = pop_value();
	VAL v1277 = pop_value();
	VAL v1278 = mw_mirth_type_TZMul(v1277, v1276);
	VAL v1279 = lpop(&lbl_txs);
	incref(v1279);
	VAL v1280 = lpop(&lbl_tys);
	incref(v1280);
	push_value(v1278);
	lpush(&lbl_txs, v1279);
	lpush(&lbl_tys, v1280);
	VAL v1281 = mw_mirth_type_TZ_ZTo(v1279, v1280);
	VAL v1282 = mtw_mirth_type_Type_TMorphism(v1281);
	incref(v1282);
	VAL v1283 = pop_value();
	VAL v1284 = mw_mirth_type_TZMul(v1283, v1282);
	VAL v1285 = mw_mirth_type_TZMul(v1284, v1282);
	VAL v1286 = lpop(&lbl_tys);
	incref(v1286);
	lpush(&lbl_tys, v1286);
	VAL v1287 = mw_mirth_type_TZ_ZTo(v1285, v1286);
	int64_t v1288 = 5LL /* PRIM_CORE_IF */;
	VAL v1289 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1289, v1287, v1288);
	uint64_t v1290 = VU64(lpop(&lbl_xs));
	lpush(&lbl_xs, MKU64(v1290));
	VAL v1291 = mw_mirth_var_Ctx1(v1290);
	VAL v1292 = lpop(&lbl_txs);
	incref(v1292);
	incref(v1292);
	incref(v1292);
	VAL r1293 = pop_resource();
	push_value(v1291);
	push_value(v1292);
	push_value(v1292);
	push_value(v1292);
	lpush(&lbl_txs, v1292);
	mw_mirth_data_TYPEz_BOOL(r1293);
	VAL v1294 = pop_value();
	VAL v1295 = pop_value();
	VAL v1296 = mw_mirth_type_TZMul(v1295, v1294);
	VAL v1297 = pop_value();
	VAL v1298 = mw_mirth_type_TZ_ZTo(v1297, v1296);
	VAL v1299 = mtw_mirth_type_Type_TMorphism(v1298);
	VAL v1300 = pop_value();
	VAL v1301 = mw_mirth_type_TZMul(v1300, v1299);
	VAL v1302 = lpop(&lbl_txs);
	incref(v1302);
	incref(v1302);
	push_value(v1301);
	lpush(&lbl_txs, v1302);
	VAL v1303 = mw_mirth_type_TZ_ZTo(v1302, v1302);
	VAL v1304 = mtw_mirth_type_Type_TMorphism(v1303);
	VAL v1305 = pop_value();
	VAL v1306 = mw_mirth_type_TZMul(v1305, v1304);
	VAL v1307 = lpop(&lbl_txs);
	incref(v1307);
	lpush(&lbl_txs, v1307);
	VAL v1308 = mw_mirth_type_TZ_ZTo(v1306, v1307);
	int64_t v1309 = 6LL /* PRIM_CORE_WHILE */;
	VAL v1310 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1310, v1308, v1309);
	uint64_t v1311 = VU64(lpop(&lbl_rr));
	uint64_t v1312 = VU64(lpop(&lbl_sr));
	lpush(&lbl_rr, MKU64(v1311));
	lpush(&lbl_sr, MKU64(v1312));
	VAL v1313 = mw_mirth_var_Ctx2(v1311, v1312);
	push_value(v1313);
	VAL v1314 = mw_mirth_type_T0();
	VAL v1315 = lpop(&lbl_trr);
	incref(v1315);
	lpush(&lbl_trr, v1315);
	VAL v1316 = mw_mirth_type_TZPlus(v1314, v1315);
	VAL v1317 = lpop(&lbl_tsr);
	incref(v1317);
	lpush(&lbl_tsr, v1317);
	VAL v1318 = mw_mirth_type_TZPlus(v1316, v1317);
	push_value(v1318);
	VAL v1319 = mw_mirth_type_T0();
	VAL v1320 = lpop(&lbl_tsr);
	incref(v1320);
	lpush(&lbl_tsr, v1320);
	VAL v1321 = mw_mirth_type_TZPlus(v1319, v1320);
	VAL v1322 = lpop(&lbl_trr);
	incref(v1322);
	lpush(&lbl_trr, v1322);
	VAL v1323 = mw_mirth_type_TZPlus(v1321, v1322);
	VAL v1324 = pop_value();
	VAL v1325 = mw_mirth_type_TZ_ZTo(v1324, v1323);
	int64_t v1326 = 12LL /* PRIM_CORE_RSWAP */;
	VAL v1327 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1327, v1325, v1326);
	uint64_t v1328 = VU64(lpop(&lbl_xs));
	uint64_t v1329 = VU64(lpop(&lbl_ys));
	uint64_t v1330 = VU64(lpop(&lbl_rr));
	lpush(&lbl_xs, MKU64(v1328));
	lpush(&lbl_ys, MKU64(v1329));
	lpush(&lbl_rr, MKU64(v1330));
	VAL v1331 = mw_mirth_var_Ctx3(v1328, v1329, v1330);
	VAL v1332 = lpop(&lbl_txs);
	incref(v1332);
	VAL v1333 = lpop(&lbl_trr);
	incref(v1333);
	push_value(v1331);
	lpush(&lbl_txs, v1332);
	lpush(&lbl_trr, v1333);
	VAL v1334 = mw_mirth_type_TZPlus(v1332, v1333);
	VAL v1335 = lpop(&lbl_txs);
	incref(v1335);
	VAL v1336 = lpop(&lbl_tys);
	incref(v1336);
	push_value(v1334);
	lpush(&lbl_txs, v1335);
	lpush(&lbl_tys, v1336);
	VAL v1337 = mw_mirth_type_TZ_ZTo(v1335, v1336);
	VAL v1338 = mtw_mirth_type_Type_TMorphism(v1337);
	VAL v1339 = pop_value();
	VAL v1340 = mw_mirth_type_TZMul(v1339, v1338);
	VAL v1341 = lpop(&lbl_tys);
	incref(v1341);
	VAL v1342 = lpop(&lbl_trr);
	incref(v1342);
	push_value(v1340);
	lpush(&lbl_tys, v1341);
	lpush(&lbl_trr, v1342);
	VAL v1343 = mw_mirth_type_TZPlus(v1341, v1342);
	VAL v1344 = pop_value();
	VAL v1345 = mw_mirth_type_TZ_ZTo(v1344, v1343);
	int64_t v1346 = 13LL /* PRIM_CORE_RDIP */;
	VAL v1347 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1347, v1345, v1346);
	uint64_t v1348 = VU64(lpop(&lbl_xs));
	uint64_t v1349 = VU64(lpop(&lbl_b));
	lpush(&lbl_xs, MKU64(v1348));
	lpush(&lbl_b, MKU64(v1349));
	VAL v1350 = mw_mirth_var_Ctx2(v1348, v1349);
	VAL v1351 = lpop(&lbl_txs);
	incref(v1351);
	push_value(v1350);
	lpush(&lbl_txs, v1351);
	VAL v1352 = mw_mirth_type_StackType_ZToType(v1351);
	VAL v1353 = lpop(&lbl_tb);
	incref(v1353);
	lpush(&lbl_tb, v1353);
	VAL v1354 = mw_mirth_type_T2(v1352, v1353);
	VAL v1355 = lpop(&lbl_txs);
	incref(v1355);
	VAL v1356 = lpop(&lbl_tb);
	incref(v1356);
	push_value(v1354);
	lpush(&lbl_txs, v1355);
	lpush(&lbl_tb, v1356);
	VAL v1357 = mw_mirth_type_TZMul(v1355, v1356);
	VAL v1358 = mw_mirth_type_StackType_ZToType(v1357);
	VAL v1359 = mw_mirth_type_T1(v1358);
	VAL v1360 = pop_value();
	VAL v1361 = mw_mirth_type_TZ_ZTo(v1360, v1359);
	int64_t v1362 = 55LL /* PRIM_PACK_CONS */;
	VAL v1363 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1363, v1361, v1362);
	uint64_t v1364 = VU64(lpop(&lbl_xs));
	uint64_t v1365 = VU64(lpop(&lbl_b));
	lpush(&lbl_xs, MKU64(v1364));
	lpush(&lbl_b, MKU64(v1365));
	VAL v1366 = mw_mirth_var_Ctx2(v1364, v1365);
	VAL v1367 = lpop(&lbl_txs);
	incref(v1367);
	VAL v1368 = lpop(&lbl_tb);
	incref(v1368);
	push_value(v1366);
	lpush(&lbl_txs, v1367);
	lpush(&lbl_tb, v1368);
	VAL v1369 = mw_mirth_type_TZMul(v1367, v1368);
	VAL v1370 = mw_mirth_type_StackType_ZToType(v1369);
	VAL v1371 = mw_mirth_type_T1(v1370);
	VAL v1372 = lpop(&lbl_txs);
	incref(v1372);
	push_value(v1371);
	lpush(&lbl_txs, v1372);
	VAL v1373 = mw_mirth_type_StackType_ZToType(v1372);
	VAL v1374 = lpop(&lbl_tb);
	incref(v1374);
	lpush(&lbl_tb, v1374);
	VAL v1375 = mw_mirth_type_T2(v1373, v1374);
	VAL v1376 = pop_value();
	VAL v1377 = mw_mirth_type_TZ_ZTo(v1376, v1375);
	int64_t v1378 = 56LL /* PRIM_PACK_UNCONS */;
	VAL v1379 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1379, v1377, v1378);
	uint64_t v1380 = VU64(lpop(&lbl_a));
	lpush(&lbl_a, MKU64(v1380));
	VAL v1381 = mw_mirth_var_Ctx1(v1380);
	VAL v1382 = lpop(&lbl_ta);
	incref(v1382);
	push_value(v1381);
	lpush(&lbl_ta, v1382);
	VAL v1383 = mw_mirth_type_T1(v1382);
	VAL v1384 = lpop(&lbl_ta);
	incref(v1384);
	push_value(v1383);
	lpush(&lbl_ta, v1384);
	VAL v1385 = mtw_mirth_type_Type_TMut(v1384);
	VAL v1386 = mw_mirth_type_T1(v1385);
	VAL v1387 = pop_value();
	VAL v1388 = mw_mirth_type_TZ_ZTo(v1387, v1386);
	int64_t v1389 = 57LL /* PRIM_MUT_NEW */;
	VAL v1390 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1390, v1388, v1389);
	uint64_t v1391 = VU64(lpop(&lbl_a));
	lpush(&lbl_a, MKU64(v1391));
	VAL v1392 = mw_mirth_var_Ctx1(v1391);
	VAL v1393 = lpop(&lbl_ta);
	incref(v1393);
	push_value(v1392);
	lpush(&lbl_ta, v1393);
	VAL v1394 = mtw_mirth_type_Type_TMut(v1393);
	VAL v1395 = mw_mirth_type_T1(v1394);
	VAL v1396 = lpop(&lbl_ta);
	incref(v1396);
	push_value(v1395);
	lpush(&lbl_ta, v1396);
	VAL v1397 = mw_mirth_type_T1(v1396);
	VAL v1398 = pop_value();
	VAL v1399 = mw_mirth_type_TZ_ZTo(v1398, v1397);
	int64_t v1400 = 58LL /* PRIM_MUT_GET */;
	VAL v1401 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1401, v1399, v1400);
	uint64_t v1402 = VU64(lpop(&lbl_a));
	lpush(&lbl_a, MKU64(v1402));
	VAL v1403 = mw_mirth_var_Ctx1(v1402);
	VAL v1404 = lpop(&lbl_ta);
	incref(v1404);
	incref(v1404);
	push_value(v1403);
	push_value(v1404);
	lpush(&lbl_ta, v1404);
	VAL v1405 = mtw_mirth_type_Type_TMut(v1404);
	VAL v1406 = pop_value();
	VAL v1407 = mw_mirth_type_T2(v1406, v1405);
	push_value(v1407);
	VAL v1408 = mw_mirth_type_T0();
	VAL v1409 = pop_value();
	VAL v1410 = mw_mirth_type_TZ_ZTo(v1409, v1408);
	int64_t v1411 = 59LL /* PRIM_MUT_SET */;
	VAL v1412 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1412, v1410, v1411);
	uint64_t v1413 = VU64(lpop(&lbl_a));
	lpush(&lbl_a, MKU64(v1413));
	VAL v1414 = mw_mirth_var_Ctx1(v1413);
	VAL v1415 = lpop(&lbl_ta);
	incref(v1415);
	push_value(v1414);
	lpush(&lbl_ta, v1415);
	VAL v1416 = mtw_mirth_type_Type_TMut(v1415);
	VAL v1417 = mw_mirth_type_T1(v1416);
	VAL r1418 = pop_resource();
	push_value(v1417);
	mw_mirth_data_TYPEz_BOOL(r1418);
	VAL v1419 = pop_value();
	VAL v1420 = mw_mirth_type_T1(v1419);
	VAL v1421 = pop_value();
	VAL v1422 = mw_mirth_type_TZ_ZTo(v1421, v1420);
	int64_t v1423 = 60LL /* PRIM_MUT_IS_SET */;
	VAL v1424 = pop_value();
	mw_mirth_prim_Prim_ctxZ_typeZBang(v1424, v1422, v1423);
	uint64_t v1425 = VU64(lpop(&lbl_a));
	uint64_t v1426 = VU64(lpop(&lbl_b));
	uint64_t v1427 = VU64(lpop(&lbl_c));
	uint64_t v1428 = VU64(lpop(&lbl_rr));
	uint64_t v1429 = VU64(lpop(&lbl_sr));
	uint64_t v1430 = VU64(lpop(&lbl_xs));
	uint64_t v1431 = VU64(lpop(&lbl_ys));
	VAL v1432 = lpop(&lbl_ta);
	VAL v1433 = lpop(&lbl_tb);
	VAL v1434 = lpop(&lbl_tc);
	decref(v1434);
	decref(v1433);
	decref(v1432);
	VAL v1435 = lpop(&lbl_trr);
	VAL v1436 = lpop(&lbl_tsr);
	decref(v1436);
	decref(v1435);
	VAL v1437 = lpop(&lbl_txs);
	VAL v1438 = lpop(&lbl_tys);
	decref(v1438);
	decref(v1437);
	VAL r1439 = pop_resource();
	return r1439;
}
static int64_t mw_mirth_token_TokenValue_noneZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // TokenNone
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static int64_t mw_mirth_token_TokenValue_commaZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // TokenComma
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static int64_t mw_mirth_token_TokenValue_lparenZ_openZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 2LL: { // TokenLParenOpen
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static VAL mw_mirth_token_TokenValue_lparenZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 6LL: { // TokenLParen
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenLParen(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_rparenZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 7LL: { // TokenRParen
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenRParen(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_token_TokenValue_lsquareZ_openZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 3LL: { // TokenLSquareOpen
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static VAL mw_mirth_token_TokenValue_lsquareZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 8LL: { // TokenLSquare
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenLSquare(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_rsquareZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 9LL: { // TokenRSquare
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenRSquare(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_token_TokenValue_lcurlyZ_openZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 4LL: { // TokenLCurlyOpen
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static VAL mw_mirth_token_TokenValue_lcurlyZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 10LL: { // TokenLCurly
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenLCurly(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_rcurlyZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 11LL: { // TokenRCurly
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenRCurly(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_token_TokenValue_lcolonZ_openZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 5LL: { // TokenLColonOpen
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		default: {
			decref(x1);
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
	}
	int64_t v2 = pop_i64();
	return v2;
}
static VAL mw_mirth_token_TokenValue_lcolonZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 12LL: { // TokenLColon
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenLColon(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 6LL: { // TokenLParen
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenLParen(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		case 12LL: { // TokenLColon
			uint64_t v2 = mtp_mirth_token_TokenValue_TokenLColon(x1);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(MKU64(v2));
			push_value(v3);
		} break;
		default: {
			decref(x1);
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
	}
	VAL v5 = pop_value();
	return v5;
}
static int64_t mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenName(x1);
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 18LL: { // TokenDName
			VAL v2 = mtp_mirth_token_TokenValue_TokenDName(x1);
			decref(v2);
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 23LL: { // TokenLabelGet
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenLabelGet(x1);
			int64_t v5 = 1LL /* True */;
			push_i64(v5);
		} break;
		default: {
			decref(x1);
			int64_t v6 = 0LL /* False */;
			push_i64(v6);
		} break;
	}
	int64_t v7 = pop_i64();
	return v7;
}
static VAL mw_mirth_token_TokenValue_intZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 14LL: { // TokenInt
			int64_t v0 = mtp_mirth_token_TokenValue_TokenInt(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKI64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_strZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 16LL: { // TokenStr
			VAL v0 = mtp_mirth_token_TokenValue_TokenStr(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_nameZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenName(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_dnameZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 18LL: { // TokenDName
			VAL v0 = mtp_mirth_token_TokenValue_TokenDName(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_token_TokenValue_nameZ_orZ_dnameZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenName(x1);
			VAL v1 = mtw_std_either_Either_2_Left(MKU64(v0));
			VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 18LL: { // TokenDName
			VAL v3 = mtp_mirth_token_TokenValue_TokenDName(x1);
			VAL v4 = mtw_std_either_Either_2_Right(v3);
			VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
			push_value(v5);
		} break;
		default: {
			decref(x1);
			int64_t v6 = 0LL /* None */;
			push_i64(v6);
		} break;
	}
	VAL v7 = pop_value();
	return v7;
}
static VAL mw_mirth_token_TokenValue_lastZ_nameZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 17LL: { // TokenName
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenName(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		case 18LL: { // TokenDName
			VAL v2 = mtp_mirth_token_TokenValue_TokenDName(x1);
			uint64_t v3 = mw_mirth_name_DName_lastZ_name(v2);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			push_value(v4);
		} break;
		default: {
			decref(x1);
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
	}
	VAL v6 = pop_value();
	return v6;
}
static VAL mw_mirth_token_TokenValue_penultimateZ_nameZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 18LL: { // TokenDName
			VAL v0 = mtp_mirth_token_TokenValue_TokenDName(x1);
			VAL v1 = mw_mirth_name_DName_penultimateZ_nameZAsk(v0);
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_token_TokenValue_argZ_endZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // TokenComma
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 7LL: { // TokenRParen
			uint64_t v1 = mtp_mirth_token_TokenValue_TokenRParen(x1);
			int64_t v2 = 1LL /* True */;
			push_i64(v2);
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenRCurly(x1);
			int64_t v4 = 1LL /* True */;
			push_i64(v4);
		} break;
		case 9LL: { // TokenRSquare
			uint64_t v5 = mtp_mirth_token_TokenValue_TokenRSquare(x1);
			int64_t v6 = 1LL /* True */;
			push_i64(v6);
		} break;
		case 13LL: { // TokenRColon
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenRColon(x1);
			int64_t v8 = 1LL /* True */;
			push_i64(v8);
		} break;
		default: {
			decref(x1);
			int64_t v9 = 0LL /* False */;
			push_i64(v9);
		} break;
	}
	int64_t v10 = pop_i64();
	return v10;
}
static int64_t mw_mirth_token_TokenValue_leftZ_enclosureZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 6LL: { // TokenLParen
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenLParen(x1);
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 8LL: { // TokenLSquare
			uint64_t v2 = mtp_mirth_token_TokenValue_TokenLSquare(x1);
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 10LL: { // TokenLCurly
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenLCurly(x1);
			int64_t v5 = 1LL /* True */;
			push_i64(v5);
		} break;
		case 12LL: { // TokenLColon
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenLColon(x1);
			int64_t v7 = 1LL /* True */;
			push_i64(v7);
		} break;
		default: {
			decref(x1);
			int64_t v8 = 0LL /* False */;
			push_i64(v8);
		} break;
	}
	int64_t v9 = pop_i64();
	return v9;
}
static int64_t mw_mirth_token_TokenValue_rightZ_enclosureZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 7LL: { // TokenRParen
			uint64_t v0 = mtp_mirth_token_TokenValue_TokenRParen(x1);
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 9LL: { // TokenRSquare
			uint64_t v2 = mtp_mirth_token_TokenValue_TokenRSquare(x1);
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenRCurly(x1);
			int64_t v5 = 1LL /* True */;
			push_i64(v5);
		} break;
		case 13LL: { // TokenRColon
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenRColon(x1);
			int64_t v7 = 1LL /* True */;
			push_i64(v7);
		} break;
		default: {
			decref(x1);
			int64_t v8 = 0LL /* False */;
			push_i64(v8);
		} break;
	}
	int64_t v9 = pop_i64();
	return v9;
}
static int64_t mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_lastZ_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_typeZ_con(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_isZ_typeZ_hole(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_typeZ_var(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk (VAL x1) {
	int64_t v0 = mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk(x1);
	return v0;
}
static int64_t mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_stackZ_var(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_resourceZ_var(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_lastZ_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_resourceZ_con(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_sigZ_dashesZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = 119LL /* PRIM_SYNTAX_DASHES */;
			push_value(v1);
			uint64_t v3 = mw_mirth_prim_Prim_name(v2);
			uint64_t v4 = pop_u64();
			int64_t v5 = mw_mirth_name_Name_ZEqualZEqual(v4, v3);
			push_i64(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v7 = pop_i64();
	return v7;
}
static int64_t mw_mirth_token_TokenValue_arrowZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = 120LL /* PRIM_SYNTAX_ARROW */;
			push_value(v1);
			uint64_t v3 = mw_mirth_prim_Prim_name(v2);
			uint64_t v4 = pop_u64();
			int64_t v5 = mw_mirth_name_Name_ZEqualZEqual(v4, v3);
			push_i64(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v7 = pop_i64();
	return v7;
}
static int64_t mw_mirth_token_TokenValue_patZ_underscoreZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_isZ_underscore(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static int64_t mw_mirth_token_TokenValue_moduleZ_headerZAsk (VAL x1) {
	VAL v0 = mw_mirth_token_TokenValue_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_name_Name_ZToStr(VU64(v1));
			STR* v3;
			STRLIT(v3, "module", 6);
			bool v4 = (str_cmp(VSTR(v2), v3) == 0);
			push_bool(v4);
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v6 = pop_i64();
	return v6;
}
static int64_t mw_mirth_token_Token_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_token_Token_succ (uint64_t x1) {
	int64_t v0 = 1LL;
	int64_t v1 = i64_add(((int64_t)x1), v0);
	void* v2 = mbuf_mirth_token_Token_NUM;
	uint64_t v3 = *(uint64_t*)v2;
	int64_t v4 = 1LL;
	int64_t v5 = i64_add(((int64_t)v3), v4);
	int64_t v6 = i64_mod(v1, v5);
	return ((uint64_t)v6);
}
static uint64_t mw_mirth_token_Token_pred (uint64_t x1) {
	int64_t v0 = 0LL;
	bool v1 = (((int64_t)x1) == v0);
	if (v1) {
		push_u64(x1);
	} else {
		int64_t v2 = 1LL;
		int64_t v3 = i64_sub(((int64_t)x1), v2);
		push_i64(v3);
	}
	uint64_t v4 = pop_u64();
	return v4;
}
static uint64_t mw_mirth_token_Token_allocZBang (void) {
	void* v0 = mbuf_mirth_token_Token_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_token_Token_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static int64_t mw_mirth_token_Token_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_token_Token_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_token_Token_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static VAL mw_mirth_token_Token_value (uint64_t x1) {
	void* v0 = mfld_mirth_token_Token_ZTildevalue(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_token_Token_module (uint64_t x1) {
	void* v0 = mfld_mirth_token_Token_ZTildemodule(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static int64_t mw_mirth_token_Token_col (uint64_t x1) {
	void* v0 = mfld_mirth_token_Token_ZTildecol(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static int64_t mw_mirth_token_Token_row (uint64_t x1) {
	void* v0 = mfld_mirth_token_Token_ZTilderow(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static int64_t mw_mirth_token_Token_noneZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_noneZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_commaZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_commaZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_lparenZ_openZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_lparenZ_openZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_lparenZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_lparenZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_rparenZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_rparenZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_lsquareZ_openZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_lsquareZ_openZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_lsquareZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_lsquareZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_rsquareZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_rsquareZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_lcurlyZ_openZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_lcurlyZ_openZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_lcurlyZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_lcurlyZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_rcurlyZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_rcurlyZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_lcolonZ_openZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_lcolonZ_openZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_lcolonZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_lcolonZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_intZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_intZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_strZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_strZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_nameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_nameZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_dnameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_dnameZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_nameZ_orZ_dnameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_nameZ_orZ_dnameZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_lastZ_nameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_lastZ_nameZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_penultimateZ_nameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	VAL v1 = mw_mirth_token_TokenValue_penultimateZ_nameZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_argZ_endZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_argZ_endZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_leftZ_enclosureZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_leftZ_enclosureZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_rightZ_enclosureZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_rightZ_enclosureZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_typeZ_conZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_typeZ_holeZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_typeZ_varZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_paramZ_nameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_stackZ_varZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_resourceZ_varZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_resourceZ_conZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_sigZ_dashesZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_sigZ_dashesZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_arrowZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_arrowZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_patZ_underscoreZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_patZ_underscoreZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_moduleZ_headerZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_moduleZ_headerZAsk(v0);
	return v1;
}
static int64_t mw_mirth_token_Token_canZ_takeZ_argsZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	int64_t v1 = mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk(v0);
	return v1;
}
static uint64_t mw_mirth_token_Token_allocZ_noneZBang (void) {
	uint64_t v0 = mw_mirth_token_Token_allocZBang();
	int64_t v1 = 0LL /* TokenNone */;
	void* v2 = mfld_mirth_token_Token_ZTildevalue(v0);
	mut_set(MKI64(v1), MKPTR(v2));
	return v0;
}
static VAL mw_mirth_token_Token_location (uint64_t x1) {
	push_u64(x1);
	uint64_t v0 = mw_mirth_token_Token_module(x1);
	uint64_t v1 = pop_u64();
	lpush(&lbl_module, MKU64(v0));
	push_u64(v1);
	int64_t v2 = mw_mirth_token_Token_row(v1);
	uint64_t v3 = pop_u64();
	lpush(&lbl_row, MKI64(v2));
	int64_t v4 = mw_mirth_token_Token_col(v3);
	int64_t v5 = VI64(lpop(&lbl_row));
	uint64_t v6 = VU64(lpop(&lbl_module));
	VAL v7 = mtw_mirth_location_Location_Location(v6, v5, v4);
	return v7;
}
static uint64_t mw_mirth_token_Token_next (uint64_t x1) {
	push_u64(x1);
	VAL v0 = mw_mirth_token_Token_value(x1);
	switch (get_data_tag(v0)) {
		case 6LL: { // TokenLParen
			uint64_t v1 = mtp_mirth_token_TokenValue_TokenLParen(v0);
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = mw_mirth_token_Token_succ(v1);
			push_u64(v3);
		} break;
		case 8LL: { // TokenLSquare
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenLSquare(v0);
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = mw_mirth_token_Token_succ(v4);
			push_u64(v6);
		} break;
		case 10LL: { // TokenLCurly
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenLCurly(v0);
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = mw_mirth_token_Token_succ(v7);
			push_u64(v9);
		} break;
		case 12LL: { // TokenLColon
			uint64_t v10 = mtp_mirth_token_TokenValue_TokenLColon(v0);
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = mw_mirth_token_Token_succ(v10);
			push_u64(v12);
		} break;
		default: {
			int64_t v13 = mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk(v0);
			if (((bool)v13)) {
				uint64_t v14 = pop_u64();
				uint64_t v15 = mw_mirth_token_Token_succ(v14);
				push_u64(v15);
				VAL v16 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v15);
				switch (get_data_tag(v16)) {
					case 1LL: { // Some
						VAL v17 = mtp_std_maybe_Maybe_1_Some(v16);
						VAL v18 = pop_value();
						decref(v18);
						uint64_t v19 = mw_mirth_token_Token_succ(VU64(v17));
						push_u64(v19);
					} break;
					case 0LL: { // None
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
			} else {
				uint64_t v20 = pop_u64();
				uint64_t v21 = mw_mirth_token_Token_succ(v20);
				push_u64(v21);
			}
		} break;
	}
	uint64_t v22 = pop_u64();
	return v22;
}
static uint64_t mw_mirth_token_Token_prev (uint64_t x1) {
	uint64_t v0 = mw_mirth_token_Token_pred(x1);
	push_u64(v0);
	VAL v1 = mw_mirth_token_Token_value(v0);
	switch (get_data_tag(v1)) {
		case 9LL: { // TokenRSquare
			uint64_t v2 = mtp_mirth_token_TokenValue_TokenRSquare(v1);
			VAL v3 = pop_value();
			decref(v3);
			push_u64(v2);
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v4 = mtp_mirth_token_TokenValue_TokenRCurly(v1);
			VAL v5 = pop_value();
			decref(v5);
			push_u64(v4);
		} break;
		case 7LL: { // TokenRParen
			uint64_t v6 = mtp_mirth_token_TokenValue_TokenRParen(v1);
			VAL v7 = pop_value();
			decref(v7);
			push_u64(v6);
			uint64_t v8 = mw_mirth_token_Token_pred(v6);
			int64_t v9 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(v8);
			if (((bool)v9)) {
				uint64_t v10 = pop_u64();
				uint64_t v11 = mw_mirth_token_Token_pred(v10);
				push_u64(v11);
			} else {
			}
		} break;
		case 13LL: { // TokenRColon
			uint64_t v12 = mtp_mirth_token_TokenValue_TokenRColon(v1);
			VAL v13 = pop_value();
			decref(v13);
			push_u64(v12);
			uint64_t v14 = mw_mirth_token_Token_pred(v12);
			int64_t v15 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(v14);
			if (((bool)v15)) {
				uint64_t v16 = pop_u64();
				uint64_t v17 = mw_mirth_token_Token_pred(v16);
				push_u64(v17);
			} else {
			}
		} break;
		default: {
			decref(v1);
		} break;
	}
	uint64_t v18 = pop_u64();
	return v18;
}
static uint64_t mw_mirth_token_Token_nextZ_argZ_end (uint64_t x1) {
	push_u64(x1);
	while(1) {
		uint64_t v0 = pop_u64();
		push_u64(v0);
		int64_t v1 = mw_mirth_token_Token_argZ_endZAsk(v0);
		bool v2 = !((bool)v1);
		if (!v2) break;
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_next(v3);
		push_u64(v4);
	}
	uint64_t v5 = pop_u64();
	return v5;
}
static int64_t mw_mirth_token_Token_hasZ_argsZAsk (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(x1);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		uint64_t v2 = mw_mirth_token_Token_succ(v1);
		push_u64(v2);
	} else {
	}
	uint64_t v3 = pop_u64();
	VAL v4 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v3);
	int64_t v5 = mw_std_maybe_Maybe_1_ZToBool(v4);
	return v5;
}
static uint64_t mw_mirth_token_Token_argsZ_start (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_canZ_takeZ_argsZAsk(x1);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		push_u64(v1);
		uint64_t v2 = mw_mirth_token_Token_succ(v1);
		VAL v3 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v2);
		int64_t v4 = mw_std_maybe_Maybe_1_ZToBool(v3);
		push_i64(v4);
	} else {
		int64_t v5 = 0LL /* False */;
		push_i64(v5);
	}
	bool v6 = pop_bool();
	if (v6) {
		uint64_t v7 = pop_u64();
		uint64_t v8 = mw_mirth_token_Token_succ(v7);
		push_u64(v8);
	} else {
	}
	uint64_t v9 = pop_u64();
	return v9;
}
static int64_t mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk (uint64_t x1) {
	push_u64(x1);
	VAL v0 = mw_mirth_token_Token_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v4 = pop_bool();
	if (v4) {
		uint64_t v5 = pop_u64();
		push_u64(v5);
		uint64_t v6 = mw_mirth_token_Token_succ(v5);
		VAL v7 = mw_mirth_token_Token_lcolonZAsk(v6);
		int64_t v8 = mw_std_maybe_Maybe_1_ZToBool(v7);
		push_i64(v8);
	} else {
		int64_t v9 = 0LL /* False */;
		push_i64(v9);
	}
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	decref(v11);
	return VI64(v10);
}
static int64_t mw_mirth_token_Token_patternZ_varZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v4 = pop_i64();
	return v4;
}
static VAL mw_mirth_token_Token_argsZ_0 (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v1 = 0LL;
	bool v2 = (v0 == v1);
	if (v2) {
		uint64_t v3 = pop_u64();
	} else {
		STR* v4;
		STRLIT(v4, "expected no args", 16);
		VAL r5 = pop_resource();
		uint64_t v6 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v6, MKSTR(v4), r5);
	}
	VAL r7 = pop_resource();
	return r7;
}
static void mw_mirth_token_Token_argsZ_1 (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v1 = 1LL;
	bool v2 = (v0 == v1);
	if (v2) {
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_argsZ_start(v3);
		uint64_t v5 = mw_mirth_token_Token_succ(v4);
		push_u64(v5);
	} else {
		uint64_t v6 = pop_u64();
		push_u64(v6);
		int64_t v7 = mw_mirth_token_Token_numZ_args(v6);
		int64_t v8 = 1LL;
		bool v9 = (v7 < v8);
		if (v9) {
			STR* v10;
			STRLIT(v10, "expected 1 arg, got none", 24);
			VAL r11 = pop_resource();
			uint64_t v12 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v12, MKSTR(v10), r11);
		} else {
			STR* v13;
			STRLIT(v13, "expected 1 arg, got too many", 28);
			VAL r14 = pop_resource();
			uint64_t v15 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v15, MKSTR(v13), r14);
		}
	}
}
static void mw_mirth_token_Token_argsZ_2 (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v1 = 2LL;
	bool v2 = (v0 == v1);
	if (v2) {
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_argsZ_start(v3);
		uint64_t v5 = mw_mirth_token_Token_succ(v4);
		push_u64(v5);
		uint64_t v6 = mw_mirth_token_Token_nextZ_argZ_end(v5);
		uint64_t v7 = mw_mirth_token_Token_succ(v6);
		push_u64(v7);
	} else {
		uint64_t v8 = pop_u64();
		push_u64(v8);
		int64_t v9 = mw_mirth_token_Token_numZ_args(v8);
		int64_t v10 = 2LL;
		bool v11 = (v9 < v10);
		if (v11) {
			STR* v12;
			STRLIT(v12, "expected 2 args, got too few", 28);
			VAL r13 = pop_resource();
			uint64_t v14 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v14, MKSTR(v12), r13);
		} else {
			STR* v15;
			STRLIT(v15, "expected 2 args, got too many", 29);
			VAL r16 = pop_resource();
			uint64_t v17 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v17, MKSTR(v15), r16);
		}
	}
}
static void mw_mirth_token_Token_argsZ_3 (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_numZ_args(x1);
	int64_t v1 = 3LL;
	bool v2 = (v0 == v1);
	if (v2) {
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_argsZ_start(v3);
		uint64_t v5 = mw_mirth_token_Token_succ(v4);
		push_u64(v5);
		uint64_t v6 = mw_mirth_token_Token_nextZ_argZ_end(v5);
		uint64_t v7 = mw_mirth_token_Token_succ(v6);
		push_u64(v7);
		uint64_t v8 = mw_mirth_token_Token_nextZ_argZ_end(v7);
		uint64_t v9 = mw_mirth_token_Token_succ(v8);
		push_u64(v9);
	} else {
		uint64_t v10 = pop_u64();
		push_u64(v10);
		int64_t v11 = mw_mirth_token_Token_numZ_args(v10);
		int64_t v12 = 3LL;
		bool v13 = (v11 < v12);
		if (v13) {
			STR* v14;
			STRLIT(v14, "expected 3 args, got too few", 28);
			VAL r15 = pop_resource();
			uint64_t v16 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v16, MKSTR(v14), r15);
		} else {
			STR* v17;
			STRLIT(v17, "expected 3 args, got too many", 29);
			VAL r18 = pop_resource();
			uint64_t v19 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v19, MKSTR(v17), r18);
		}
	}
}
static int64_t mw_mirth_token_Token_numZ_args (uint64_t x1) {
	uint64_t v0 = mw_mirth_token_Token_argsZ_start(x1);
	push_u64(v0);
	int64_t v1 = mw_mirth_token_Token_leftZ_enclosureZAsk(v0);
	if (((bool)v1)) {
		uint64_t v2 = pop_u64();
		int64_t v3 = 0LL;
		push_i64(v3);
		push_u64(v2);
		while(1) {
			uint64_t v4 = pop_u64();
			push_u64(v4);
			int64_t v5 = mw_mirth_token_Token_argsZ_endZAsk(v4);
			bool v6 = !((bool)v5);
			if (!v6) break;
			uint64_t v7 = pop_u64();
			int64_t v8 = 1LL;
			int64_t v9 = pop_i64();
			int64_t v10 = i64_add(v9, v8);
			push_i64(v10);
			uint64_t v11 = mw_mirth_token_Token_succ(v7);
			uint64_t v12 = mw_mirth_token_Token_nextZ_argZ_end(v11);
			push_u64(v12);
		}
		uint64_t v13 = pop_u64();
	} else {
		uint64_t v14 = pop_u64();
		int64_t v15 = 0LL;
		push_i64(v15);
	}
	int64_t v16 = pop_i64();
	return v16;
}
static VAL mw_mirth_token_Token_args (uint64_t x1) {
	uint64_t v0 = mw_mirth_token_Token_argsZ_start(x1);
	push_u64(v0);
	int64_t v1 = mw_mirth_token_Token_leftZ_enclosureZAsk(v0);
	if (((bool)v1)) {
		int64_t v2 = 0LL /* Nil */;
		VAL v3 = mw_std_list_List_1_reverse(MKI64(v2));
		push_resource(v3);
		while(1) {
			VAL r4 = pop_resource();
			uint64_t v5 = pop_u64();
			push_u64(v5);
			int64_t v6 = mw_mirth_token_Token_argsZ_endZAsk(v5);
			bool v7 = !((bool)v6);
			push_resource(r4);
			if (!v7) break;
			VAL r8 = pop_resource();
			uint64_t v9 = pop_u64();
			uint64_t v10 = mw_mirth_token_Token_succ(v9);
			uint64_t v11 = mw_mirth_token_Token_nextZ_argZ_end(v10);
			push_u64(v11);
			VAL v12 = mtw_std_list_List_1_Cons(MKU64(v10), r8);
			push_resource(v12);
		}
		VAL r13 = pop_resource();
		VAL v14 = mw_std_list_List_1_reverse(r13);
		VAL v15 = pop_value();
		decref(v15);
		push_value(v14);
	} else {
		uint64_t v16 = pop_u64();
		int64_t v17 = 0LL /* Nil */;
		push_i64(v17);
	}
	VAL v18 = pop_value();
	return v18;
}
static int64_t mw_mirth_token_Token_argsZ_endZAsk (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_commaZAsk(x1);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		uint64_t v2 = mw_mirth_token_Token_succ(v1);
		push_u64(v2);
	} else {
	}
	uint64_t v3 = pop_u64();
	int64_t v4 = mw_mirth_token_Token_rightZ_enclosureZAsk(v3);
	return v4;
}
static void mw_mirth_token_Token_argsZPlus (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	VAL v0 = mw_mirth_token_Token_args(x1);
	VAL v1 = mw_std_list_List_1_ZToListZPlus(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			STR* v3;
			STRLIT(v3, "expected 1 or more args, got none", 33);
			VAL r4 = pop_resource();
			uint64_t v5 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v5, MKSTR(v3), r4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static int64_t mw_mirth_token_Token_moduleZ_endZAsk (uint64_t x1) {
	int64_t v0 = mw_mirth_token_Token_noneZAsk(x1);
	return v0;
}
static int64_t mw_mirth_token_Token_runZ_endZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // TokenNone
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 1LL: { // TokenComma
			int64_t v2 = 1LL /* True */;
			push_i64(v2);
		} break;
		case 7LL: { // TokenRParen
			uint64_t v3 = mtp_mirth_token_TokenValue_TokenRParen(v0);
			int64_t v4 = 1LL /* True */;
			push_i64(v4);
		} break;
		case 9LL: { // TokenRSquare
			uint64_t v5 = mtp_mirth_token_TokenValue_TokenRSquare(v0);
			int64_t v6 = 1LL /* True */;
			push_i64(v6);
		} break;
		case 11LL: { // TokenRCurly
			uint64_t v7 = mtp_mirth_token_TokenValue_TokenRCurly(v0);
			int64_t v8 = 1LL /* True */;
			push_i64(v8);
		} break;
		case 13LL: { // TokenRColon
			uint64_t v9 = mtp_mirth_token_TokenValue_TokenRColon(v0);
			int64_t v10 = 1LL /* True */;
			push_i64(v10);
		} break;
		default: {
			decref(v0);
			int64_t v11 = 0LL /* False */;
			push_i64(v11);
		} break;
	}
	int64_t v12 = pop_i64();
	return v12;
}
static VAL mw_mirth_token_Token_runZ_tokens (uint64_t x1) {
	int64_t v0 = 0LL /* Nil */;
	push_u64(x1);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	push_resource(v1);
	while(1) {
		VAL r2 = pop_resource();
		uint64_t v3 = pop_u64();
		push_u64(v3);
		int64_t v4 = mw_mirth_token_Token_runZ_endZAsk(v3);
		bool v5 = !((bool)v4);
		push_resource(r2);
		if (!v5) break;
		VAL r6 = pop_resource();
		uint64_t v7 = pop_u64();
		uint64_t v8 = mw_mirth_token_Token_next(v7);
		push_u64(v8);
		VAL v9 = mtw_std_list_List_1_Cons(MKU64(v7), r6);
		push_resource(v9);
	}
	VAL r10 = pop_resource();
	VAL v11 = mw_std_list_List_1_reverse(r10);
	VAL v12 = pop_value();
	decref(v12);
	return v11;
}
static int64_t mw_mirth_token_Token_runZ_length (uint64_t x1) {
	int64_t v0 = 0LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	push_i64(v1);
	push_u64(x1);
	while(1) {
		uint64_t v2 = pop_u64();
		push_u64(v2);
		int64_t v3 = mw_mirth_token_Token_runZ_endZAsk(v2);
		bool v4 = !((bool)v3);
		if (!v4) break;
		uint64_t v5 = pop_u64();
		uint64_t v6 = mw_mirth_token_Token_next(v5);
		int64_t v7 = 1LL;
		int64_t v8 = pop_i64();
		int64_t v9 = i64_add(v8, v7);
		push_i64(v9);
		push_u64(v6);
	}
	uint64_t v10 = pop_u64();
	int64_t v11 = pop_i64();
	return v11;
}
static VAL mw_mirth_token_Token_runZ_arrowZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_runZ_tokens(x1);
	int64_t v1 = 0LL /* None */;
	push_i64(v1);
	mw_std_list_List_1_uncons(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		int64_t v10 = mw_mirth_token_Token_arrowZAsk(VU64(v7));
		if (((bool)v10)) {
			VAL v11 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v11);
		} else {
			decref(v7);
			int64_t v12 = 0LL /* None */;
			push_i64(v12);
		}
		VAL v13 = pop_value();
		switch (get_data_tag(v13)) {
			case 0LL: { // None
				push_value(v9);
				push_value(v8);
			} break;
			default: {
				decref(v8);
				decref(v9);
				int64_t v14 = 0LL /* Nil */;
				push_value(v13);
				push_i64(v14);
			} break;
		}
		VAL v15 = pop_value();
		mw_std_list_List_1_uncons(v15);
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
	}
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = pop_value();
	decref(v19);
	VAL v20 = pop_value();
	return v20;
}
static int64_t mw_mirth_token_Token_sigZ_stackZ_endZAsk (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_token_Token_sigZ_dashesZAsk(x1);
	if (((bool)v0)) {
		int64_t v1 = 1LL /* True */;
		push_i64(v1);
	} else {
		uint64_t v2 = pop_u64();
		push_u64(v2);
		int64_t v3 = mw_mirth_token_Token_runZ_endZAsk(v2);
		push_i64(v3);
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	decref(v5);
	return VI64(v4);
}
static uint64_t mw_mirth_token_Token_sigZ_nextZ_stackZ_end (uint64_t x1) {
	push_u64(x1);
	while(1) {
		uint64_t v0 = pop_u64();
		push_u64(v0);
		int64_t v1 = mw_mirth_token_Token_sigZ_stackZ_endZAsk(v0);
		bool v2 = !((bool)v1);
		if (!v2) break;
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_next(v3);
		push_u64(v4);
	}
	uint64_t v5 = pop_u64();
	return v5;
}
static int64_t mw_mirth_token_Token_sigZ_hasZ_dashesZAsk (uint64_t x1) {
	uint64_t v0 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(x1);
	int64_t v1 = mw_mirth_token_Token_sigZ_dashesZAsk(v0);
	return v1;
}
static VAL mw_mirth_token_Token_patZ_tokens (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_runZ_tokens(x1);
	int64_t v1 = 0LL /* Nil */;
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v6);
			int64_t v7 = mw_mirth_token_Token_arrowZAsk(VU64(v6));
			bool v8 = !((bool)v7);
			if (v8) {
				VAL v9 = mtw_std_maybe_Maybe_1_Some(v6);
				push_value(v9);
			} else {
				decref(v6);
				int64_t v10 = 0LL /* None */;
				push_i64(v10);
			}
		} break;
		case 0LL: { // None
			int64_t v11 = 0LL /* None */;
			push_i64(v11);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v12 = pop_value();
	push_value(v4);
	push_value(v12);
	push_resource(v2);
	while(1) {
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		int64_t v14 = mw_std_maybe_Maybe_1_someZAsk(v13);
		if (!((bool)v14)) break;
		VAL v15 = pop_value();
		VAL v16 = mw_std_maybe_Maybe_1_unwrap(v15);
		VAL r17 = pop_resource();
		VAL v18 = mtw_std_list_List_1_Cons(v16, r17);
		VAL v19 = pop_value();
		mw_std_list_List_1_uncons(v19);
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		switch (get_data_tag(v21)) {
			case 1LL: { // Some
				VAL v22 = mtp_std_maybe_Maybe_1_Some(v21);
				incref(v22);
				int64_t v23 = mw_mirth_token_Token_arrowZAsk(VU64(v22));
				bool v24 = !((bool)v23);
				if (v24) {
					VAL v25 = mtw_std_maybe_Maybe_1_Some(v22);
					push_value(v25);
				} else {
					decref(v22);
					int64_t v26 = 0LL /* None */;
					push_i64(v26);
				}
			} break;
			case 0LL: { // None
				int64_t v27 = 0LL /* None */;
				push_i64(v27);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL v28 = pop_value();
		push_value(v20);
		push_value(v28);
		push_resource(v18);
	}
	VAL v29 = pop_value();
	decref(v29);
	VAL r30 = pop_resource();
	VAL v31 = mw_std_list_List_1_reverse(r30);
	VAL v32 = pop_value();
	decref(v32);
	return v31;
}
static int64_t mw_mirth_module_Module_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_module_Module_allocZBang (void) {
	void* v0 = mbuf_mirth_module_Module_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_module_Module_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_module_Module_package (uint64_t x1) {
	void* v0 = mfld_mirth_module_Module_ZTildepackage(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static uint64_t mw_mirth_module_Module_name (uint64_t x1) {
	void* v0 = mfld_mirth_module_Module_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_module_Module_qname (uint64_t x1) {
	uint64_t v0 = mw_mirth_module_Module_package(x1);
	VAL v1 = mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE(v0);
	push_value(v1);
	uint64_t v2 = mw_mirth_module_Module_name(x1);
	VAL v3 = pop_value();
	VAL v4 = mw_mirth_name_QNAME0(v3, v2);
	return v4;
}
static VAL mw_mirth_module_Module_path (uint64_t x1) {
	void* v0 = mfld_mirth_module_Module_ZTildepath(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static uint64_t mw_mirth_module_Module_start (uint64_t x1) {
	void* v0 = mfld_mirth_module_Module_ZTildestart(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_module_Module_imports (uint64_t x1) {
	void* v0 = mfld_mirth_module_Module_ZTildeimports(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_module_Module_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_module_Module_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_module_Module_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_module_Module_prim (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[2]);
	decref(v0);
	push_resource(x1);
	push_u64(v1);
}
static VAL mw_mirth_module_initZ_modulesZBang (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[2]);
	decref(v0);
	int64_t v2 = 0LL /* Nil */;
	void* v3 = mfld_mirth_module_Module_ZTildeimports(v1);
	mut_set(MKI64(v2), MKPTR(v3));
	STR* v4;
	STRLIT(v4, "<prim>", 6);
	void* v5 = mfld_mirth_module_Module_ZTildepath(v1);
	mut_set(MKSTR(v4), MKPTR(v5));
	push_u64(v1);
	mw_mirth_package_Package_std(x1);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	void* v8 = mfld_mirth_module_Module_ZTildepackage(VU64(v7));
	mut_set(v6, MKPTR(v8));
	STR* v9;
	STRLIT(v9, "prim", 4);
	push_value(v7);
	uint64_t v10 = mw_std_prim_Str_ZToName(MKSTR(v9));
	VAL v11 = pop_value();
	incref(v11);
	void* v12 = mfld_mirth_module_Module_ZTildename(VU64(v11));
	mut_set(MKU64(v10), MKPTR(v12));
	decref(v11);
	VAL r13 = pop_resource();
	return r13;
}
static void mw_mirth_module_Module_newZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_value(x2);
	uint64_t v0 = mw_mirth_module_Module_allocZBang();
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_module_Module_prim(r1);
	int64_t v2 = 0LL /* Nil */;
	VAL v3 = pop_value();
	VAL v4 = mtw_std_list_List_1_Cons(v3, MKI64(v2));
	VAL v5 = pop_value();
	incref(v5);
	void* v6 = mfld_mirth_module_Module_ZTildeimports(VU64(v5));
	mut_set(v4, MKPTR(v6));
	incref(v5);
	VAL v7 = pop_value();
	void* v8 = mfld_mirth_module_Module_ZTildepath(VU64(v5));
	mut_set(v7, MKPTR(v8));
	push_value(v5);
}
static void mw_mirth_module_Module_addZ_importZBang (uint64_t x1, uint64_t x2) {
	void* v0 = mfld_mirth_module_Module_ZTildeimports(x1);
	VAL v1 = mut_get(MKPTR(v0));
	VAL v2 = mtw_std_list_List_1_Cons(MKU64(x2), v1);
	mut_set(v2, MKPTR(v0));
}
static VAL mw_mirth_module_Module_sourceZ_path (uint64_t x1) {
	VAL v0 = mw_mirth_module_Module_path(x1);
	return v0;
}
static int64_t mw_mirth_module_Module_visible (uint64_t x1, uint64_t x2) {
	push_u64(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_module_Module_ZEqualZEqual(x1, x2);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		decref(v1);
		VAL v2 = pop_value();
		decref(v2);
		int64_t v3 = 1LL /* True */;
		push_i64(v3);
	} else {
		uint64_t v4 = pop_u64();
		VAL v5 = mw_mirth_module_Module_imports(v4);
		int64_t v6 = 0LL /* None */;
		push_i64(v6);
		mw_std_list_List_1_uncons(v5);
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
		while(1) {
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
			if (!((bool)v10)) break;
			VAL v11 = pop_value();
			VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			incref(v12);
			VAL v15 = pop_value();
			incref(v15);
			int64_t v16 = mw_mirth_module_Module_ZEqualZEqual(VU64(v15), VU64(v12));
			if (((bool)v16)) {
				push_value(v15);
				VAL v17 = mtw_std_maybe_Maybe_1_Some(v12);
				push_value(v17);
			} else {
				decref(v12);
				int64_t v18 = 0LL /* None */;
				push_value(v15);
				push_i64(v18);
			}
			VAL v19 = pop_value();
			switch (get_data_tag(v19)) {
				case 0LL: { // None
					push_value(v14);
					push_value(v13);
				} break;
				default: {
					decref(v13);
					decref(v14);
					int64_t v20 = 0LL /* Nil */;
					push_value(v19);
					push_i64(v20);
				} break;
			}
			VAL v21 = pop_value();
			mw_std_list_List_1_uncons(v21);
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v23);
		}
		VAL v24 = pop_value();
		decref(v24);
		VAL v25 = pop_value();
		decref(v25);
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		decref(v27);
		int64_t v28 = mw_std_maybe_Maybe_1_someZAsk(v26);
		push_i64(v28);
	}
	int64_t v29 = pop_i64();
	return v29;
}
static int64_t mw_std_prim_Int_ZToRow (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_location_Row_ZToInt (int64_t x1) {
	return x1;
}
static VAL mw_mirth_location_Row_showZThen (VAL x1, int64_t x2) {
	STR* v0 = i64_show(x2);
	VAL v1 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v0), x1));
	return v1;
}
static int64_t mw_std_prim_Int_ZToCol (int64_t x1) {
	return x1;
}
static int64_t mw_mirth_location_Col_ZToInt (int64_t x1) {
	return x1;
}
static VAL mw_mirth_location_Col_showZThen (VAL x1, int64_t x2) {
	STR* v0 = i64_show(x2);
	VAL v1 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v0), x1));
	return v1;
}
static VAL mw_mirth_location_Location_emitZThen (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_location_Location_Location(x2);
	uint64_t v0 = VU64(lpop(&lbl_module));
	VAL v1 = mw_mirth_module_Module_sourceZ_path(v0);
	VAL r2 = pop_resource();
	VAL v3 = (mw_std_str_ZPlusStr_pushZ_strZBang(v1, r2));
	STR* v4;
	STRLIT(v4, ":", 1);
	VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), v3));
	int64_t v6 = VI64(lpop(&lbl_row));
	VAL v7 = (mw_mirth_location_Row_showZThen(v5, v6));
	STR* v8;
	STRLIT(v8, ":", 1);
	VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
	int64_t v10 = VI64(lpop(&lbl_col));
	VAL v11 = (mw_mirth_location_Col_showZThen(v9, v10));
	return v11;
}
static int64_t mw_mirth_alias_Alias_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_alias_Alias_allocZBang (void) {
	void* v0 = mbuf_mirth_alias_Alias_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_alias_Alias_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_alias_Alias_qnameZ_soft (uint64_t x1) {
	void* v0 = mfld_mirth_alias_Alias_ZTildeqname(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_mirth_Prop_1_readyZAsk(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			int64_t v4 = 0LL /* None */;
			push_i64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	return v5;
}
static void mw_mirth_alias_Alias_qnameZ_hard (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_alias_Alias_ZTildeqname(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static void mw_mirth_alias_Alias_namespaceZ_hard (VAL x1, uint64_t x2) {
	mw_mirth_alias_Alias_qnameZ_hard(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	decref(v0);
	push_value(v1);
}
static uint64_t mw_mirth_alias_Alias_name (uint64_t x1) {
	void* v0 = mfld_mirth_alias_Alias_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static int64_t mw_mirth_alias_Alias_arity (uint64_t x1) {
	void* v0 = mfld_mirth_alias_Alias_ZTildearity(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VI64(v1);
}
static void mw_mirth_alias_Alias_target (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_alias_Alias_ZTildetarget(x2);
	mw_mirth_mirth_Prop_1_forceZBang(MKPTR(v0), x1);
}
static int64_t mw_mirth_alias_Alias_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_alias_Alias_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_alias_Alias_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static void mw_mirth_alias_Alias_newZBang (VAL x1, uint64_t x2, uint64_t x3, int64_t x4) {
	push_resource(x1);
	lpush(&lbl_head, MKU64(x2));
	lpush(&lbl_name, MKU64(x3));
	lpush(&lbl_arity, MKI64(x4));
	uint64_t v0 = mw_mirth_alias_Alias_allocZBang();
	uint64_t v1 = VU64(lpop(&lbl_name));
	void* v2 = mfld_mirth_alias_Alias_ZTildename(v0);
	mut_set(MKU64(v1), MKPTR(v2));
	uint64_t v3 = VU64(lpop(&lbl_head));
	void* v4 = mfld_mirth_alias_Alias_ZTildehead(v0);
	mut_set(MKU64(v3), MKPTR(v4));
	int64_t v5 = VI64(lpop(&lbl_arity));
	void* v6 = mfld_mirth_alias_Alias_ZTildearity(v0);
	mut_set(MKI64(v5), MKPTR(v6));
	push_u64(v0);
	VAL v7 = mtw_mirth_def_Def_DefAlias(v0);
	VAL r8 = pop_resource();
	VAL v9 = (mw_mirth_def_Def_register(r8, v7));
	push_resource(v9);
}
static VAL mw_mirth_mirth_Builtin_AllocZBang (void) {
	uint64_t v0 = mw_mirth_package_Package_allocZBang();
	lpush(&lbl_std, MKU64(v0));
	uint64_t v1 = mw_mirth_module_Module_allocZBang();
	lpush(&lbl_prim, MKU64(v1));
	uint64_t v2 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_bool, MKU64(v2));
	uint64_t v3 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_true, MKU64(v3));
	uint64_t v4 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_false, MKU64(v4));
	uint64_t v5 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_u64, MKU64(v5));
	uint64_t v6 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_u64, MKU64(v6));
	uint64_t v7 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_u32, MKU64(v7));
	uint64_t v8 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_u32, MKU64(v8));
	uint64_t v9 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_u16, MKU64(v9));
	uint64_t v10 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_u16, MKU64(v10));
	uint64_t v11 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_u8, MKU64(v11));
	uint64_t v12 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_u8, MKU64(v12));
	uint64_t v13 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_i64, MKU64(v13));
	uint64_t v14 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_i64, MKU64(v14));
	uint64_t v15 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_i32, MKU64(v15));
	uint64_t v16 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_i32, MKU64(v16));
	uint64_t v17 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_i16, MKU64(v17));
	uint64_t v18 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_i16, MKU64(v18));
	uint64_t v19 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_i8, MKU64(v19));
	uint64_t v20 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_i8, MKU64(v20));
	uint64_t v21 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cchar, MKU64(v21));
	uint64_t v22 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cchar, MKU64(v22));
	uint64_t v23 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cichar, MKU64(v23));
	uint64_t v24 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cichar, MKU64(v24));
	uint64_t v25 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cshort, MKU64(v25));
	uint64_t v26 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cshort, MKU64(v26));
	uint64_t v27 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cint, MKU64(v27));
	uint64_t v28 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cint, MKU64(v28));
	uint64_t v29 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_clong, MKU64(v29));
	uint64_t v30 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_clong, MKU64(v30));
	uint64_t v31 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_clonglong, MKU64(v31));
	uint64_t v32 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_clonglong, MKU64(v32));
	uint64_t v33 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cisizze, MKU64(v33));
	uint64_t v34 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cisizze, MKU64(v34));
	uint64_t v35 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cintptr, MKU64(v35));
	uint64_t v36 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cintptr, MKU64(v36));
	uint64_t v37 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cuchar, MKU64(v37));
	uint64_t v38 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cuchar, MKU64(v38));
	uint64_t v39 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cushort, MKU64(v39));
	uint64_t v40 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cushort, MKU64(v40));
	uint64_t v41 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cuint, MKU64(v41));
	uint64_t v42 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cuint, MKU64(v42));
	uint64_t v43 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_culong, MKU64(v43));
	uint64_t v44 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_culong, MKU64(v44));
	uint64_t v45 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_culonglong, MKU64(v45));
	uint64_t v46 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_culonglong, MKU64(v46));
	uint64_t v47 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cusizze, MKU64(v47));
	uint64_t v48 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cusizze, MKU64(v48));
	uint64_t v49 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cuintptr, MKU64(v49));
	uint64_t v50 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cuintptr, MKU64(v50));
	uint64_t v51 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cptr, MKU64(v51));
	uint64_t v52 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cptr, MKU64(v52));
	uint64_t v53 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cconst, MKU64(v53));
	uint64_t v54 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cconst, MKU64(v54));
	uint64_t v55 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_crestrict, MKU64(v55));
	uint64_t v56 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_crestrict, MKU64(v56));
	uint64_t v57 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cvolatile, MKU64(v57));
	uint64_t v58 = mw_mirth_data_Tag_allocZBang();
	lpush(&lbl_mkZ_cvolatile, MKU64(v58));
	uint64_t v59 = mw_mirth_data_Data_allocZBang();
	lpush(&lbl_cvoid, MKU64(v59));
	uint64_t v60 = mw_mirth_data_Tag_allocZBang();
	uint64_t v61 = VU64(lpop(&lbl_cvoid));
	uint64_t v62 = VU64(lpop(&lbl_mkZ_cvolatile));
	uint64_t v63 = VU64(lpop(&lbl_cvolatile));
	uint64_t v64 = VU64(lpop(&lbl_mkZ_crestrict));
	uint64_t v65 = VU64(lpop(&lbl_crestrict));
	uint64_t v66 = VU64(lpop(&lbl_mkZ_cconst));
	uint64_t v67 = VU64(lpop(&lbl_cconst));
	uint64_t v68 = VU64(lpop(&lbl_mkZ_cptr));
	uint64_t v69 = VU64(lpop(&lbl_cptr));
	uint64_t v70 = VU64(lpop(&lbl_mkZ_cuintptr));
	uint64_t v71 = VU64(lpop(&lbl_cuintptr));
	uint64_t v72 = VU64(lpop(&lbl_mkZ_cusizze));
	uint64_t v73 = VU64(lpop(&lbl_cusizze));
	uint64_t v74 = VU64(lpop(&lbl_mkZ_culonglong));
	uint64_t v75 = VU64(lpop(&lbl_culonglong));
	uint64_t v76 = VU64(lpop(&lbl_mkZ_culong));
	uint64_t v77 = VU64(lpop(&lbl_culong));
	uint64_t v78 = VU64(lpop(&lbl_mkZ_cuint));
	uint64_t v79 = VU64(lpop(&lbl_cuint));
	uint64_t v80 = VU64(lpop(&lbl_mkZ_cushort));
	uint64_t v81 = VU64(lpop(&lbl_cushort));
	uint64_t v82 = VU64(lpop(&lbl_mkZ_cuchar));
	uint64_t v83 = VU64(lpop(&lbl_cuchar));
	uint64_t v84 = VU64(lpop(&lbl_mkZ_cintptr));
	uint64_t v85 = VU64(lpop(&lbl_cintptr));
	uint64_t v86 = VU64(lpop(&lbl_mkZ_cisizze));
	uint64_t v87 = VU64(lpop(&lbl_cisizze));
	uint64_t v88 = VU64(lpop(&lbl_mkZ_clonglong));
	uint64_t v89 = VU64(lpop(&lbl_clonglong));
	uint64_t v90 = VU64(lpop(&lbl_mkZ_clong));
	uint64_t v91 = VU64(lpop(&lbl_clong));
	uint64_t v92 = VU64(lpop(&lbl_mkZ_cint));
	uint64_t v93 = VU64(lpop(&lbl_cint));
	uint64_t v94 = VU64(lpop(&lbl_mkZ_cshort));
	uint64_t v95 = VU64(lpop(&lbl_cshort));
	uint64_t v96 = VU64(lpop(&lbl_mkZ_cichar));
	uint64_t v97 = VU64(lpop(&lbl_cichar));
	uint64_t v98 = VU64(lpop(&lbl_mkZ_cchar));
	uint64_t v99 = VU64(lpop(&lbl_cchar));
	uint64_t v100 = VU64(lpop(&lbl_mkZ_i8));
	uint64_t v101 = VU64(lpop(&lbl_i8));
	uint64_t v102 = VU64(lpop(&lbl_mkZ_i16));
	uint64_t v103 = VU64(lpop(&lbl_i16));
	uint64_t v104 = VU64(lpop(&lbl_mkZ_i32));
	uint64_t v105 = VU64(lpop(&lbl_i32));
	uint64_t v106 = VU64(lpop(&lbl_mkZ_i64));
	uint64_t v107 = VU64(lpop(&lbl_i64));
	uint64_t v108 = VU64(lpop(&lbl_mkZ_u8));
	uint64_t v109 = VU64(lpop(&lbl_u8));
	uint64_t v110 = VU64(lpop(&lbl_mkZ_u16));
	uint64_t v111 = VU64(lpop(&lbl_u16));
	uint64_t v112 = VU64(lpop(&lbl_mkZ_u32));
	uint64_t v113 = VU64(lpop(&lbl_u32));
	uint64_t v114 = VU64(lpop(&lbl_mkZ_u64));
	uint64_t v115 = VU64(lpop(&lbl_u64));
	uint64_t v116 = VU64(lpop(&lbl_false));
	uint64_t v117 = VU64(lpop(&lbl_true));
	uint64_t v118 = VU64(lpop(&lbl_bool));
	uint64_t v119 = VU64(lpop(&lbl_prim));
	uint64_t v120 = VU64(lpop(&lbl_std));
	VAL v121 = mtw_mirth_mirth_Builtin_Builtin(v120, v119, v118, v117, v116, v115, v114, v113, v112, v111, v110, v109, v108, v107, v106, v105, v104, v103, v102, v101, v100, v99, v98, v97, v96, v95, v94, v93, v92, v91, v90, v89, v88, v87, v86, v85, v84, v83, v82, v81, v80, v79, v78, v77, v76, v75, v74, v73, v72, v71, v70, v69, v68, v67, v66, v65, v64, v63, v62, v61, v60);
	return v121;
}
static VAL mw_mirth_mirth_ZPlusMirth_InitZBang (void) {
	int64_t v0 = 0LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = 0LL;
	lpush(&lbl_numZ_errors, MKI64(v1));
	int64_t v3 = mw_std_prim_Int_ZToNat(v2);
	int64_t v4 = 0LL /* False */;
	lpush(&lbl_numZ_warnings, MKI64(v3));
	lpush(&lbl_preferZ_inlineZ_defs, MKI64(v4));
	VAL v5 = mw_mirth_mirth_Builtin_AllocZBang();
	int64_t v6 = 0LL /* None */;
	int64_t v7 = 0LL /* Nil */;
	int64_t v8 = 0LL /* Nil */;
	int64_t v9 = 0LL /* Nil */;
	int64_t v10 = 0LL /* None */;
	int64_t v11 = VI64(lpop(&lbl_preferZ_inlineZ_defs));
	int64_t v12 = VI64(lpop(&lbl_numZ_warnings));
	int64_t v13 = VI64(lpop(&lbl_numZ_errors));
	VAL v14 = (mtw_mirth_mirth_ZPlusMirth_ZPlusMirth(v13, v12, v11, v5, MKI64(v10), MKI64(v6), MKI64(v7), MKI64(v8), MKI64(v9)));
	VAL v15 = (mw_mirth_package_initZ_packagesZBang(v14));
	VAL v16 = (mw_mirth_module_initZ_modulesZBang(v15));
	VAL v17 = (mw_mirth_mirth_ZPlusMirth_initZ_typesZBang(v16));
	VAL v18 = (mw_mirth_prim_initZ_primsZBang(v17));
	return v18;
}
static void mw_mirth_mirth_ZPlusMirth_rdrop (VAL x1) {
	mtp_mirth_mirth_ZPlusMirth_ZPlusMirth(x1);
	int64_t v0 = VI64(lpop(&lbl_numZ_errors));
	int64_t v1 = VI64(lpop(&lbl_numZ_warnings));
	int64_t v2 = VI64(lpop(&lbl_preferZ_inlineZ_defs));
	VAL v3 = lpop(&lbl_builtin);
	decref(v3);
	VAL v4 = lpop(&lbl_errorZ_token);
	decref(v4);
	VAL v5 = lpop(&lbl_mirthZ_baseZ_path);
	decref(v5);
	VAL v6 = lpop(&lbl_packageZ_searchZ_paths);
	decref(v6);
	VAL v7 = (lpop(&lbl_ZPlusdiagnostics));
	VAL v8 = mw_std_list_List_1_reverse(v7);
	decref(v8);
	VAL v9 = (lpop(&lbl_ZPluspropstack));
	VAL v10 = mw_std_list_List_1_reverse(v9);
	decref(v10);
}
static void mw_mirth_mirth_ZPlusMirth_mirthZ_baseZ_libZ_path (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[6]);
	incref(v0);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			push_resource(x1);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			STR* v2;
			STRLIT(v2, "lib", 3);
			VAL v3 = mw_std_path_Path_join(v1, MKSTR(v2));
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			push_value(v4);
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* None */;
			push_resource(x1);
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static VAL mw_mirth_mirth_Severity_ZToStr (int64_t x1) {
	switch (x1) {
		case 0LL: { // Info
			STR* v0;
			STRLIT(v0, "info", 4);
			push_str(v0);
		} break;
		case 1LL: { // Warning
			STR* v1;
			STRLIT(v1, "warning", 7);
			push_str(v1);
		} break;
		case 2LL: { // Error
			STR* v2;
			STRLIT(v2, "error", 5);
			push_str(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang (VAL x1, VAL x2, int64_t x3, VAL x4) {
	switch (x3) {
		case 0LL: { // Info
			push_resource(x4);
			lpush(&lbl_message, x2);
			lpush(&lbl_location, x1);
			lpush(&lbl_severity, MKI64(x3));
		} break;
		case 1LL: { // Warning
			int64_t v0 = VI64(VTUP(x4)->cells[2]);
			int64_t v1 = 1LL;
			int64_t v2 = i64_add(v0, v1);
			VTUP(x4)->cells[2] = MKI64(v2);
			lpush(&lbl_message, x2);
			lpush(&lbl_location, x1);
			lpush(&lbl_severity, MKI64(x3));
			push_resource(x4);
		} break;
		case 2LL: { // Error
			int64_t v3 = VI64(VTUP(x4)->cells[1]);
			int64_t v4 = 1LL;
			int64_t v5 = i64_add(v3, v4);
			VTUP(x4)->cells[1] = MKI64(v5);
			lpush(&lbl_message, x2);
			lpush(&lbl_location, x1);
			lpush(&lbl_severity, MKI64(x3));
			push_resource(x4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x4);
			lpush(&lbl_message, x2);
			lpush(&lbl_location, x1);
			lpush(&lbl_severity, MKI64(x3));
		}
	}
	VAL v6 = lpop(&lbl_message);
	VAL v7 = lpop(&lbl_location);
	int64_t v8 = VI64(lpop(&lbl_severity));
	VAL v9 = mtw_mirth_mirth_Diagnostic_Diagnostic(v8, v7, v6);
	VAL r10 = pop_resource();
	VAL v11 = (VVAL(VTUP(r10)->cells[8]));
	VAL v12 = mtw_std_list_List_1_Cons(v9, v11);
	VTUP(r10)->cells[8] = v12;
	return r10;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v0 = 0LL /* Info */;
	VAL v1 = (mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang(x1, x2, v0, x3));
	return v1;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v0 = 1LL /* Warning */;
	VAL v1 = (mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang(x1, x2, v0, x3));
	return v1;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3) {
	int64_t v0 = 2LL /* Error */;
	VAL v1 = (mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang(x1, x2, v0, x3));
	return v1;
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang(x1, x2, x3));
	mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang(v0);
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	VAL v0 = mw_mirth_token_Token_location(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang(v0, x2, r1));
	return v2;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	VAL v0 = mw_mirth_token_Token_location(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang(v0, x2, r1));
	return v2;
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	VAL v0 = mw_mirth_token_Token_location(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang(v0, x2, r1));
	return v2;
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	VAL v0 = mw_mirth_token_Token_location(x1);
	VAL r1 = pop_resource();
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang(v0, x2, r1);
}
static VAL mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang (uint64_t x1, VAL x2, VAL x3, VAL x4) {
	STR* v0;
	STRLIT(v0, "", 0);
	int64_t v1 = 36LL /* FGCyan */;
	push_u64(x1);
	lpush(&lbl_old, x2);
	lpush(&lbl_new, x3);
	push_resource(x4);
	VAL v2 = (mw_std_terminal_Sgr_emitZThen(MKI64(v1), MKSTR(v0)));
	VAL v3 = lpop(&lbl_old);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(v3, v2));
	int64_t v5 = 0LL /* Reset */;
	VAL v6 = (mw_std_terminal_Sgr_emitZThen(MKI64(v5), v4));
	STR* v7;
	STRLIT(v7, " is deprecated, please use ", 27);
	VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
	int64_t v9 = 36LL /* FGCyan */;
	VAL v10 = (mw_std_terminal_Sgr_emitZThen(MKI64(v9), v8));
	VAL v11 = lpop(&lbl_new);
	VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(v11, v10));
	int64_t v13 = 0LL /* Reset */;
	VAL v14 = (mw_std_terminal_Sgr_emitZThen(MKI64(v13), v12));
	STR* v15;
	STRLIT(v15, " instead.", 9);
	VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v15), v14));
	VAL r17 = pop_resource();
	uint64_t v18 = pop_u64();
	VAL v19 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(v18, v16, r17));
	return v19;
}
static VAL mw_mirth_mirth_ZPlusMirth_errorZBang (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[5]);
	incref(v0);
	push_value(x1);
	push_resource(x2);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	VAL v4 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(VU64(v1), v2, r3));
	return v4;
}
static void mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[5]);
	incref(v0);
	push_value(x1);
	push_resource(x2);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v1), v2, r3);
}
static void mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang (VAL x1) {
	mw_mirth_mirth_ZPlusMirth_popZ_diagnostics(x1);
	STR* v0;
	STRLIT(v0, "", 0);
	VAL v1 = pop_value();
	push_resource(MKSTR(v0));
	mw_std_list_List_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL r9 = pop_resource();
		VAL v10 = (mw_mirth_mirth_Diagnostic_diagnosticZThen(r9, v7));
		STR* v11;
		STRLIT(v11, "\n", 1);
		VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
		push_resource(v12);
		mw_std_list_List_1_uncons(v8);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		push_value(v13);
		push_value(v14);
	}
	VAL v15 = pop_value();
	decref(v15);
	VAL v16 = pop_value();
	decref(v16);
	int64_t v17 = 31LL /* FGRed */;
	VAL r18 = pop_resource();
	VAL v19 = (mw_std_terminal_Sgr_emitZThen(MKI64(v17), r18));
	STR* v20;
	STRLIT(v20, "Fatal error. Stopping early.", 28);
	VAL v21 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v20), v19));
	int64_t v22 = 0LL /* Reset */;
	VAL v23 = (mw_std_terminal_Sgr_emitZThen(MKI64(v22), v21));
	push_value(v23);
	do_panic();
}
static void mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_mirth_ZPlusMirth_popZ_diagnostics(x2);
	VAL v0 = pop_value();
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		STR* v9;
		STRLIT(v9, "", 0);
		VAL v10 = (mw_mirth_mirth_Diagnostic_diagnosticZThen(MKSTR(v9), v6));
		STR* v11;
		STRLIT(v11, "\n", 1);
		STR* v12 = str_cat(VSTR(v10), v11);
		VAL r13 = pop_resource();
		VAL v14 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v12), r13));
		push_resource(v14);
		push_resource(r8);
		mw_std_list_List_1_uncons(v7);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
}
static void mw_mirth_mirth_ZPlusMirth_popZ_diagnostics (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[8]));
	VAL v1 = mw_std_list_List_1_reverse(v0);
	int64_t v2 = 0LL /* Nil */;
	push_value(v1);
	VAL v3 = mw_std_list_List_1_reverse(MKI64(v2));
	VTUP(x1)->cells[8] = v3;
	push_resource(x1);
}
static VAL mw_mirth_mirth_Diagnostic_diagnosticZThen (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_mirth_Diagnostic_Diagnostic(x2);
	VAL v0 = lpop(&lbl_location);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_location_Location_emitZThen(r1, v0));
	STR* v3;
	STRLIT(v3, ": ", 2);
	VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), v2));
	int64_t v5 = VI64(lpop(&lbl_severity));
	push_resource(v4);
	VAL v6 = mw_mirth_mirth_Severity_ZToStr(v5);
	VAL r7 = pop_resource();
	VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, r7));
	STR* v9;
	STRLIT(v9, ": ", 2);
	VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), v8));
	VAL v11 = lpop(&lbl_message);
	VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(v11, v10));
	return v12;
}
static void mw_mirth_mirth_PropLabel_prop (VAL x1, VAL x2, VAL x3) {
	push_resource(x3);
	lpush(&lbl_label, x2);
	VAL v0 = mtw_mirth_mirth_PropState_1_PSReady(x1);
	VAL v1 = lpop(&lbl_label);
	VAL v2 = mtw_mirth_mirth_Prop_1_Prop(v1, v0);
	push_value(v2);
}
static void mw_mirth_mirth_PropLabel_prop2 (VAL x1, VAL x2, VAL x3, VAL x4) {
	VAL v0 = MKNIL;
	VAL v1 = mkcons(v0, x1);
	VAL v2 = mkcons(v1, x2);
	mw_mirth_mirth_PropLabel_prop(v2, x3, x4);
}
static void mw_mirth_mirth_PropLabel_prop_1 (VAL x1, VAL x2, VAL x3, VAL x4) {
	push_value(x1);
	push_value(x2);
	push_resource(x3);
	push_value(x4);
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL v1 = pop_value();
		incref(var_f);
		VAL v2 = var_f;
		VAL v3 = pop_value();
		lpush(&lbl_label, v1);
		VAL v4 = mtw_mirth_mirth_PropState_1_PSDelay(v3, v2);
		VAL v5 = lpop(&lbl_label);
		VAL v6 = mtw_mirth_mirth_Prop_1_Prop(v5, v4);
		decref(var_f);
		push_value(v6);
	}
}
static VAL mw_mirth_mirth_Prop_1_readyZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[2]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // PSReady
			VAL v1 = mtp_mirth_mirth_PropState_1_PSReady(v0);
			VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		default: {
			decref(v0);
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
	}
	VAL v4 = pop_value();
	return v4;
}
static void mw_mirth_mirth_Prop_1_tryZ_forceZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v0 = mut_get(x1);
	VAL v1 = VVAL(VTUP(v0)->cells[2]);
	incref(v1);
	decref(v0);
	switch (get_data_tag(v1)) {
		case 0LL: { // PSReady
			push_resource(x2);
			push_value(x1);
			VAL v2 = mtp_mirth_mirth_PropState_1_PSReady(v1);
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v4);
		} break;
		case 1LL: { // PSDelay
			push_resource(x2);
			push_value(x1);
			mtp_mirth_mirth_PropState_1_PSDelay(v1);
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			int64_t v8 = 2LL /* PSComputing */;
			incref(v7);
			incref(v7);
			VAL v9 = mut_get(v7);
			VAL v10 = tup_replace(v9, 2, MKI64(v8));
			mut_set(v10, v7);
			push_value(v6);
			run_value(v5);
			VAL v11 = pop_value();
			incref(v11);
			push_value(v11);
			VAL v12 = mtw_mirth_mirth_PropState_1_PSReady(v11);
			incref(v7);
			VAL v13 = mut_get(v7);
			VAL v14 = tup_replace(v13, 2, v12);
			mut_set(v14, v7);
			VAL v15 = pop_value();
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v15);
			push_value(v16);
		} break;
		case 2LL: { // PSComputing
			decref(x1);
			int64_t v17 = 0LL /* None */;
			push_resource(x2);
			push_i64(v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_value(x1);
		}
	}
}
static void mw_mirth_mirth_Prop_1_forceZBang (VAL x1, VAL x2) {
	mw_mirth_mirth_Prop_1_tryZ_forceZBang(x1, x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "Recursive prop detected!", 24);
			VAL r3 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang(MKSTR(v2), r3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_def_Def_packageZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 2LL: { // DefPackage
			uint64_t v0 = mtp_mirth_def_Def_DefPackage(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_moduleZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 1LL: { // DefModule
			uint64_t v0 = mtp_mirth_def_Def_DefModule(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_aliasZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_dataZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 3LL: { // DefData
			uint64_t v0 = mtp_mirth_def_Def_DefData(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_tableZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 4LL: { // DefTable
			uint64_t v0 = mtp_mirth_def_Def_DefTable(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_typedefZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 5LL: { // DefType
			uint64_t v0 = mtp_mirth_def_Def_DefType(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_tagZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 6LL: { // DefTag
			uint64_t v0 = mtp_mirth_def_Def_DefTag(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_primZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 7LL: { // DefPrim
			int64_t v0 = mtp_mirth_def_Def_DefPrim(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKI64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_wordZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 8LL: { // DefWord
			uint64_t v0 = mtp_mirth_def_Def_DefWord(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_bufferZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 9LL: { // DefBuffer
			uint64_t v0 = mtp_mirth_def_Def_DefBuffer(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_variableZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 10LL: { // DefVariable
			uint64_t v0 = mtp_mirth_def_Def_DefVariable(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_externalZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 11LL: { // DefExternal
			uint64_t v0 = mtp_mirth_def_Def_DefExternal(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static VAL mw_mirth_def_Def_fieldZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 12LL: { // DefField
			uint64_t v0 = mtp_mirth_def_Def_DefField(x1);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			push_value(v1);
		} break;
		default: {
			decref(x1);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
	}
	VAL v3 = pop_value();
	return v3;
}
static int64_t mw_mirth_def_Def_ZEqualZEqual (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_value(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			VAL v1 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
			VAL v2 = pop_value();
			push_value(v1);
			VAL v3 = mw_mirth_def_Def_aliasZAsk(v2);
			switch (get_data_tag(v3)) {
				case 0LL: { // None
					VAL v4 = pop_value();
					int64_t v5 = mw_std_maybe_Maybe_1_noneZAsk(v4);
					push_i64(v5);
				} break;
				case 1LL: { // Some
					VAL v6 = mtp_std_maybe_Maybe_1_Some(v3);
					VAL v7 = pop_value();
					switch (get_data_tag(v7)) {
						case 1LL: { // Some
							push_value(v6);
							VAL v8 = mtp_std_maybe_Maybe_1_Some(v7);
							uint64_t v9 = pop_u64();
							int64_t v10 = mw_mirth_alias_Alias_ZEqualZEqual(VU64(v8), v9);
							push_i64(v10);
						} break;
						case 0LL: { // None
							decref(v6);
							int64_t v11 = 0LL /* False */;
							push_i64(v11);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v6);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			push_value(x1);
			uint64_t v12 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(MKU64(v12));
			VAL v14 = pop_value();
			push_value(v13);
			VAL v15 = mw_mirth_def_Def_packageZAsk(v14);
			switch (get_data_tag(v15)) {
				case 0LL: { // None
					VAL v16 = pop_value();
					int64_t v17 = mw_std_maybe_Maybe_1_noneZAsk(v16);
					push_i64(v17);
				} break;
				case 1LL: { // Some
					VAL v18 = mtp_std_maybe_Maybe_1_Some(v15);
					VAL v19 = pop_value();
					switch (get_data_tag(v19)) {
						case 1LL: { // Some
							push_value(v18);
							VAL v20 = mtp_std_maybe_Maybe_1_Some(v19);
							uint64_t v21 = pop_u64();
							int64_t v22 = mw_mirth_package_Package_ZEqualZEqual(VU64(v20), v21);
							push_i64(v22);
						} break;
						case 0LL: { // None
							decref(v18);
							int64_t v23 = 0LL /* False */;
							push_i64(v23);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v18);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 1LL: { // DefModule
			push_value(x1);
			uint64_t v24 = mtp_mirth_def_Def_DefModule(x2);
			VAL v25 = mtw_std_maybe_Maybe_1_Some(MKU64(v24));
			VAL v26 = pop_value();
			push_value(v25);
			VAL v27 = mw_mirth_def_Def_moduleZAsk(v26);
			switch (get_data_tag(v27)) {
				case 0LL: { // None
					VAL v28 = pop_value();
					int64_t v29 = mw_std_maybe_Maybe_1_noneZAsk(v28);
					push_i64(v29);
				} break;
				case 1LL: { // Some
					VAL v30 = mtp_std_maybe_Maybe_1_Some(v27);
					VAL v31 = pop_value();
					switch (get_data_tag(v31)) {
						case 1LL: { // Some
							push_value(v30);
							VAL v32 = mtp_std_maybe_Maybe_1_Some(v31);
							uint64_t v33 = pop_u64();
							int64_t v34 = mw_mirth_module_Module_ZEqualZEqual(VU64(v32), v33);
							push_i64(v34);
						} break;
						case 0LL: { // None
							decref(v30);
							int64_t v35 = 0LL /* False */;
							push_i64(v35);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v30);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 9LL: { // DefBuffer
			push_value(x1);
			uint64_t v36 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v37 = mtw_std_maybe_Maybe_1_Some(MKU64(v36));
			VAL v38 = pop_value();
			push_value(v37);
			VAL v39 = mw_mirth_def_Def_bufferZAsk(v38);
			switch (get_data_tag(v39)) {
				case 0LL: { // None
					VAL v40 = pop_value();
					int64_t v41 = mw_std_maybe_Maybe_1_noneZAsk(v40);
					push_i64(v41);
				} break;
				case 1LL: { // Some
					VAL v42 = mtp_std_maybe_Maybe_1_Some(v39);
					VAL v43 = pop_value();
					switch (get_data_tag(v43)) {
						case 1LL: { // Some
							push_value(v42);
							VAL v44 = mtp_std_maybe_Maybe_1_Some(v43);
							uint64_t v45 = pop_u64();
							int64_t v46 = mw_mirth_buffer_Buffer_ZEqualZEqual(VU64(v44), v45);
							push_i64(v46);
						} break;
						case 0LL: { // None
							decref(v42);
							int64_t v47 = 0LL /* False */;
							push_i64(v47);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v42);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 7LL: { // DefPrim
			push_value(x1);
			int64_t v48 = mtp_mirth_def_Def_DefPrim(x2);
			VAL v49 = mtw_std_maybe_Maybe_1_Some(MKI64(v48));
			VAL v50 = pop_value();
			push_value(v49);
			VAL v51 = mw_mirth_def_Def_primZAsk(v50);
			switch (get_data_tag(v51)) {
				case 0LL: { // None
					VAL v52 = pop_value();
					int64_t v53 = mw_std_maybe_Maybe_1_noneZAsk(v52);
					push_i64(v53);
				} break;
				case 1LL: { // Some
					VAL v54 = mtp_std_maybe_Maybe_1_Some(v51);
					VAL v55 = pop_value();
					switch (get_data_tag(v55)) {
						case 1LL: { // Some
							push_value(v54);
							VAL v56 = mtp_std_maybe_Maybe_1_Some(v55);
							int64_t v57 = pop_i64();
							int64_t v58 = mw_mirth_prim_Prim_ZEqualZEqual(VI64(v56), v57);
							push_i64(v58);
						} break;
						case 0LL: { // None
							decref(v54);
							int64_t v59 = 0LL /* False */;
							push_i64(v59);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v54);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 3LL: { // DefData
			push_value(x1);
			uint64_t v60 = mtp_mirth_def_Def_DefData(x2);
			VAL v61 = mtw_std_maybe_Maybe_1_Some(MKU64(v60));
			VAL v62 = pop_value();
			push_value(v61);
			VAL v63 = mw_mirth_def_Def_dataZAsk(v62);
			switch (get_data_tag(v63)) {
				case 0LL: { // None
					VAL v64 = pop_value();
					int64_t v65 = mw_std_maybe_Maybe_1_noneZAsk(v64);
					push_i64(v65);
				} break;
				case 1LL: { // Some
					VAL v66 = mtp_std_maybe_Maybe_1_Some(v63);
					VAL v67 = pop_value();
					switch (get_data_tag(v67)) {
						case 1LL: { // Some
							push_value(v66);
							VAL v68 = mtp_std_maybe_Maybe_1_Some(v67);
							uint64_t v69 = pop_u64();
							int64_t v70 = mw_mirth_data_Data_ZEqualZEqual(VU64(v68), v69);
							push_i64(v70);
						} break;
						case 0LL: { // None
							decref(v66);
							int64_t v71 = 0LL /* False */;
							push_i64(v71);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v66);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 4LL: { // DefTable
			push_value(x1);
			uint64_t v72 = mtp_mirth_def_Def_DefTable(x2);
			VAL v73 = mtw_std_maybe_Maybe_1_Some(MKU64(v72));
			VAL v74 = pop_value();
			push_value(v73);
			VAL v75 = mw_mirth_def_Def_tableZAsk(v74);
			switch (get_data_tag(v75)) {
				case 0LL: { // None
					VAL v76 = pop_value();
					int64_t v77 = mw_std_maybe_Maybe_1_noneZAsk(v76);
					push_i64(v77);
				} break;
				case 1LL: { // Some
					VAL v78 = mtp_std_maybe_Maybe_1_Some(v75);
					VAL v79 = pop_value();
					switch (get_data_tag(v79)) {
						case 1LL: { // Some
							push_value(v78);
							VAL v80 = mtp_std_maybe_Maybe_1_Some(v79);
							uint64_t v81 = pop_u64();
							int64_t v82 = mw_mirth_table_Table_ZEqualZEqual(VU64(v80), v81);
							push_i64(v82);
						} break;
						case 0LL: { // None
							decref(v78);
							int64_t v83 = 0LL /* False */;
							push_i64(v83);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v78);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 5LL: { // DefType
			push_value(x1);
			uint64_t v84 = mtp_mirth_def_Def_DefType(x2);
			VAL v85 = mtw_std_maybe_Maybe_1_Some(MKU64(v84));
			VAL v86 = pop_value();
			push_value(v85);
			VAL v87 = mw_mirth_def_Def_typedefZAsk(v86);
			switch (get_data_tag(v87)) {
				case 0LL: { // None
					VAL v88 = pop_value();
					int64_t v89 = mw_std_maybe_Maybe_1_noneZAsk(v88);
					push_i64(v89);
				} break;
				case 1LL: { // Some
					VAL v90 = mtp_std_maybe_Maybe_1_Some(v87);
					VAL v91 = pop_value();
					switch (get_data_tag(v91)) {
						case 1LL: { // Some
							push_value(v90);
							VAL v92 = mtp_std_maybe_Maybe_1_Some(v91);
							uint64_t v93 = pop_u64();
							int64_t v94 = mw_mirth_typedef_TypeDef_ZEqualZEqual(VU64(v92), v93);
							push_i64(v94);
						} break;
						case 0LL: { // None
							decref(v90);
							int64_t v95 = 0LL /* False */;
							push_i64(v95);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v90);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 11LL: { // DefExternal
			push_value(x1);
			uint64_t v96 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v97 = mtw_std_maybe_Maybe_1_Some(MKU64(v96));
			VAL v98 = pop_value();
			push_value(v97);
			VAL v99 = mw_mirth_def_Def_externalZAsk(v98);
			switch (get_data_tag(v99)) {
				case 0LL: { // None
					VAL v100 = pop_value();
					int64_t v101 = mw_std_maybe_Maybe_1_noneZAsk(v100);
					push_i64(v101);
				} break;
				case 1LL: { // Some
					VAL v102 = mtp_std_maybe_Maybe_1_Some(v99);
					VAL v103 = pop_value();
					switch (get_data_tag(v103)) {
						case 1LL: { // Some
							push_value(v102);
							VAL v104 = mtp_std_maybe_Maybe_1_Some(v103);
							uint64_t v105 = pop_u64();
							int64_t v106 = mw_mirth_external_External_ZEqualZEqual(VU64(v104), v105);
							push_i64(v106);
						} break;
						case 0LL: { // None
							decref(v102);
							int64_t v107 = 0LL /* False */;
							push_i64(v107);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v102);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 8LL: { // DefWord
			push_value(x1);
			uint64_t v108 = mtp_mirth_def_Def_DefWord(x2);
			VAL v109 = mtw_std_maybe_Maybe_1_Some(MKU64(v108));
			VAL v110 = pop_value();
			push_value(v109);
			VAL v111 = mw_mirth_def_Def_wordZAsk(v110);
			switch (get_data_tag(v111)) {
				case 0LL: { // None
					VAL v112 = pop_value();
					int64_t v113 = mw_std_maybe_Maybe_1_noneZAsk(v112);
					push_i64(v113);
				} break;
				case 1LL: { // Some
					VAL v114 = mtp_std_maybe_Maybe_1_Some(v111);
					VAL v115 = pop_value();
					switch (get_data_tag(v115)) {
						case 1LL: { // Some
							push_value(v114);
							VAL v116 = mtp_std_maybe_Maybe_1_Some(v115);
							uint64_t v117 = pop_u64();
							int64_t v118 = mw_mirth_word_Word_ZEqualZEqual(VU64(v116), v117);
							push_i64(v118);
						} break;
						case 0LL: { // None
							decref(v114);
							int64_t v119 = 0LL /* False */;
							push_i64(v119);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v114);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 12LL: { // DefField
			push_value(x1);
			uint64_t v120 = mtp_mirth_def_Def_DefField(x2);
			VAL v121 = mtw_std_maybe_Maybe_1_Some(MKU64(v120));
			VAL v122 = pop_value();
			push_value(v121);
			VAL v123 = mw_mirth_def_Def_fieldZAsk(v122);
			switch (get_data_tag(v123)) {
				case 0LL: { // None
					VAL v124 = pop_value();
					int64_t v125 = mw_std_maybe_Maybe_1_noneZAsk(v124);
					push_i64(v125);
				} break;
				case 1LL: { // Some
					VAL v126 = mtp_std_maybe_Maybe_1_Some(v123);
					VAL v127 = pop_value();
					switch (get_data_tag(v127)) {
						case 1LL: { // Some
							push_value(v126);
							VAL v128 = mtp_std_maybe_Maybe_1_Some(v127);
							uint64_t v129 = pop_u64();
							int64_t v130 = mw_mirth_table_Field_ZEqualZEqual(VU64(v128), v129);
							push_i64(v130);
						} break;
						case 0LL: { // None
							decref(v126);
							int64_t v131 = 0LL /* False */;
							push_i64(v131);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v126);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 6LL: { // DefTag
			push_value(x1);
			uint64_t v132 = mtp_mirth_def_Def_DefTag(x2);
			VAL v133 = mtw_std_maybe_Maybe_1_Some(MKU64(v132));
			VAL v134 = pop_value();
			push_value(v133);
			VAL v135 = mw_mirth_def_Def_tagZAsk(v134);
			switch (get_data_tag(v135)) {
				case 0LL: { // None
					VAL v136 = pop_value();
					int64_t v137 = mw_std_maybe_Maybe_1_noneZAsk(v136);
					push_i64(v137);
				} break;
				case 1LL: { // Some
					VAL v138 = mtp_std_maybe_Maybe_1_Some(v135);
					VAL v139 = pop_value();
					switch (get_data_tag(v139)) {
						case 1LL: { // Some
							push_value(v138);
							VAL v140 = mtp_std_maybe_Maybe_1_Some(v139);
							uint64_t v141 = pop_u64();
							int64_t v142 = mw_mirth_data_Tag_ZEqualZEqual(VU64(v140), v141);
							push_i64(v142);
						} break;
						case 0LL: { // None
							decref(v138);
							int64_t v143 = 0LL /* False */;
							push_i64(v143);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v138);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 10LL: { // DefVariable
			push_value(x1);
			uint64_t v144 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v145 = mtw_std_maybe_Maybe_1_Some(MKU64(v144));
			VAL v146 = pop_value();
			push_value(v145);
			VAL v147 = mw_mirth_def_Def_variableZAsk(v146);
			switch (get_data_tag(v147)) {
				case 0LL: { // None
					VAL v148 = pop_value();
					int64_t v149 = mw_std_maybe_Maybe_1_noneZAsk(v148);
					push_i64(v149);
				} break;
				case 1LL: { // Some
					VAL v150 = mtp_std_maybe_Maybe_1_Some(v147);
					VAL v151 = pop_value();
					switch (get_data_tag(v151)) {
						case 1LL: { // Some
							push_value(v150);
							VAL v152 = mtp_std_maybe_Maybe_1_Some(v151);
							uint64_t v153 = pop_u64();
							int64_t v154 = mw_mirth_variable_Variable_ZEqualZEqual(VU64(v152), v153);
							push_i64(v154);
						} break;
						case 0LL: { // None
							decref(v150);
							int64_t v155 = 0LL /* False */;
							push_i64(v155);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v150);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	int64_t v156 = pop_i64();
	return v156;
}
static VAL mw_mirth_def_Def_typecheckZBang (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			VAL r1 = pop_resource();
			mw_mirth_alias_Alias_target(r1, v0);
			VAL v2 = pop_value();
			VAL r3 = pop_resource();
			VAL v4 = (mw_mirth_def_Def_typecheckZBang(r3, v2));
			push_resource(v4);
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v5 = mtp_mirth_def_Def_DefPackage(x2);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v6 = mtp_mirth_def_Def_DefModule(x2);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x1);
			uint64_t v7 = mtp_mirth_def_Def_DefBuffer(x2);
		} break;
		case 7LL: { // DefPrim
			push_resource(x1);
			int64_t v8 = mtp_mirth_def_Def_DefPrim(x2);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v9 = mtp_mirth_def_Def_DefData(x2);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v10 = mtp_mirth_def_Def_DefTable(x2);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v11 = mtp_mirth_def_Def_DefType(x2);
			VAL r12 = pop_resource();
			mw_mirth_typedef_TypeDef_target(r12, v11);
			VAL v13 = pop_value();
			decref(v13);
		} break;
		case 11LL: { // DefExternal
			push_resource(x1);
			uint64_t v14 = mtp_mirth_def_Def_DefExternal(x2);
			VAL r15 = pop_resource();
			mw_mirth_external_External_type(r15, v14);
			VAL v16 = pop_value();
			decref(v16);
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v17 = mtp_mirth_def_Def_DefWord(x2);
			VAL r18 = pop_resource();
			push_u64(v17);
			mw_mirth_word_Word_type(v17, r18);
			VAL v19 = pop_value();
			decref(v19);
			VAL r20 = pop_resource();
			uint64_t v21 = pop_u64();
			mw_mirth_word_Word_arrow(v21, r20);
			VAL v22 = pop_value();
			decref(v22);
		} break;
		case 12LL: { // DefField
			push_resource(x1);
			uint64_t v23 = mtp_mirth_def_Def_DefField(x2);
			VAL r24 = pop_resource();
			mw_mirth_table_Field_type(r24, v23);
			VAL v25 = pop_value();
			decref(v25);
		} break;
		case 6LL: { // DefTag
			push_resource(x1);
			uint64_t v26 = mtp_mirth_def_Def_DefTag(x2);
			VAL r27 = pop_resource();
			mw_mirth_data_Tag_type(r27, v26);
			VAL v28 = pop_value();
			decref(v28);
		} break;
		case 10LL: { // DefVariable
			push_resource(x1);
			uint64_t v29 = mtp_mirth_def_Def_DefVariable(x2);
			VAL r30 = pop_resource();
			mw_mirth_variable_Variable_type(r30, v29);
			VAL v31 = pop_value();
			decref(v31);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
	VAL r32 = pop_resource();
	return r32;
}
static void mw_mirth_def_Def_callableZAsk (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			void* v1 = mfld_mirth_alias_Alias_ZTildetarget(v0);
			VAL r2 = pop_resource();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v1), r2);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 1LL: { // Some
					VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
					VAL r5 = pop_resource();
					mw_mirth_def_Def_callableZAsk(r5, v4);
				} break;
				case 0LL: { // None
					int64_t v6 = 0LL /* False */;
					push_i64(v6);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v7 = mtp_mirth_def_Def_DefPackage(x2);
			int64_t v8 = 0LL /* False */;
			push_i64(v8);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v9 = mtp_mirth_def_Def_DefModule(x2);
			int64_t v10 = 0LL /* False */;
			push_i64(v10);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x1);
			uint64_t v11 = mtp_mirth_def_Def_DefBuffer(x2);
			int64_t v12 = 1LL /* True */;
			push_i64(v12);
		} break;
		case 7LL: { // DefPrim
			push_resource(x1);
			int64_t v13 = mtp_mirth_def_Def_DefPrim(x2);
			int64_t v14 = 1LL /* True */;
			push_i64(v14);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v15 = mtp_mirth_def_Def_DefData(x2);
			int64_t v16 = 0LL /* False */;
			push_i64(v16);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v17 = mtp_mirth_def_Def_DefTable(x2);
			int64_t v18 = 0LL /* False */;
			push_i64(v18);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v19 = mtp_mirth_def_Def_DefType(x2);
			int64_t v20 = 0LL /* False */;
			push_i64(v20);
		} break;
		case 11LL: { // DefExternal
			push_resource(x1);
			uint64_t v21 = mtp_mirth_def_Def_DefExternal(x2);
			int64_t v22 = 1LL /* True */;
			push_i64(v22);
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v23 = mtp_mirth_def_Def_DefWord(x2);
			int64_t v24 = 1LL /* True */;
			push_i64(v24);
		} break;
		case 12LL: { // DefField
			push_resource(x1);
			uint64_t v25 = mtp_mirth_def_Def_DefField(x2);
			int64_t v26 = 1LL /* True */;
			push_i64(v26);
		} break;
		case 6LL: { // DefTag
			push_resource(x1);
			uint64_t v27 = mtp_mirth_def_Def_DefTag(x2);
			int64_t v28 = 1LL /* True */;
			push_i64(v28);
		} break;
		case 10LL: { // DefVariable
			push_resource(x1);
			uint64_t v29 = mtp_mirth_def_Def_DefVariable(x2);
			int64_t v30 = 1LL /* True */;
			push_i64(v30);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_def_Def_definesZ_aZ_typeZAsk (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			void* v1 = mfld_mirth_alias_Alias_ZTildetarget(v0);
			VAL r2 = pop_resource();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v1), r2);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 1LL: { // Some
					VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
					VAL r5 = pop_resource();
					mw_mirth_def_Def_definesZ_aZ_typeZAsk(r5, v4);
				} break;
				case 0LL: { // None
					int64_t v6 = 0LL /* False */;
					push_i64(v6);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v7 = mtp_mirth_def_Def_DefPackage(x2);
			int64_t v8 = 0LL /* False */;
			push_i64(v8);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v9 = mtp_mirth_def_Def_DefModule(x2);
			int64_t v10 = 0LL /* False */;
			push_i64(v10);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x1);
			uint64_t v11 = mtp_mirth_def_Def_DefBuffer(x2);
			int64_t v12 = 0LL /* False */;
			push_i64(v12);
		} break;
		case 7LL: { // DefPrim
			push_resource(x1);
			int64_t v13 = mtp_mirth_def_Def_DefPrim(x2);
			int64_t v14 = 0LL /* False */;
			push_i64(v14);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v15 = mtp_mirth_def_Def_DefData(x2);
			int64_t v16 = 1LL /* True */;
			push_i64(v16);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v17 = mtp_mirth_def_Def_DefTable(x2);
			int64_t v18 = 1LL /* True */;
			push_i64(v18);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v19 = mtp_mirth_def_Def_DefType(x2);
			int64_t v20 = 1LL /* True */;
			push_i64(v20);
		} break;
		case 11LL: { // DefExternal
			push_resource(x1);
			uint64_t v21 = mtp_mirth_def_Def_DefExternal(x2);
			int64_t v22 = 0LL /* False */;
			push_i64(v22);
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v23 = mtp_mirth_def_Def_DefWord(x2);
			int64_t v24 = 0LL /* False */;
			push_i64(v24);
		} break;
		case 12LL: { // DefField
			push_resource(x1);
			uint64_t v25 = mtp_mirth_def_Def_DefField(x2);
			int64_t v26 = 0LL /* False */;
			push_i64(v26);
		} break;
		case 6LL: { // DefTag
			push_resource(x1);
			uint64_t v27 = mtp_mirth_def_Def_DefTag(x2);
			int64_t v28 = 0LL /* False */;
			push_i64(v28);
		} break;
		case 10LL: { // DefVariable
			push_resource(x1);
			uint64_t v29 = mtp_mirth_def_Def_DefVariable(x2);
			int64_t v30 = 0LL /* False */;
			push_i64(v30);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_def_Def_exposedZ_tyconZAsk (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			void* v1 = mfld_mirth_alias_Alias_ZTildetarget(v0);
			VAL r2 = pop_resource();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v1), r2);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 1LL: { // Some
					VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
					VAL r5 = pop_resource();
					mw_mirth_def_Def_exposedZ_tyconZAsk(r5, v4);
				} break;
				case 0LL: { // None
					int64_t v6 = 0LL /* None */;
					push_i64(v6);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v7 = mtp_mirth_def_Def_DefPackage(x2);
			int64_t v8 = 0LL /* None */;
			push_i64(v8);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v9 = mtp_mirth_def_Def_DefModule(x2);
			int64_t v10 = 0LL /* None */;
			push_i64(v10);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v11 = mtp_mirth_def_Def_DefData(x2);
			VAL v12 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v11);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(v12);
			push_value(v13);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v14 = mtp_mirth_def_Def_DefTable(x2);
			VAL v15 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v14);
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v15);
			push_value(v16);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v17 = mtp_mirth_def_Def_DefType(x2);
			VAL r18 = pop_resource();
			mw_mirth_typedef_TypeDef_target(r18, v17);
			VAL v19 = pop_value();
			VAL v20 = mw_mirth_type_Type_tyconZAsk(v19);
			push_value(v20);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x1);
			uint64_t v21 = mtp_mirth_def_Def_DefBuffer(x2);
			int64_t v22 = 0LL /* None */;
			push_i64(v22);
		} break;
		case 7LL: { // DefPrim
			push_resource(x1);
			int64_t v23 = mtp_mirth_def_Def_DefPrim(x2);
			int64_t v24 = 0LL /* None */;
			push_i64(v24);
		} break;
		case 11LL: { // DefExternal
			push_resource(x1);
			uint64_t v25 = mtp_mirth_def_Def_DefExternal(x2);
			int64_t v26 = 0LL /* None */;
			push_i64(v26);
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v27 = mtp_mirth_def_Def_DefWord(x2);
			int64_t v28 = 0LL /* None */;
			push_i64(v28);
		} break;
		case 12LL: { // DefField
			push_resource(x1);
			uint64_t v29 = mtp_mirth_def_Def_DefField(x2);
			int64_t v30 = 0LL /* None */;
			push_i64(v30);
		} break;
		case 6LL: { // DefTag
			push_resource(x1);
			uint64_t v31 = mtp_mirth_def_Def_DefTag(x2);
			int64_t v32 = 0LL /* None */;
			push_i64(v32);
		} break;
		case 10LL: { // DefVariable
			push_resource(x1);
			uint64_t v33 = mtp_mirth_def_Def_DefVariable(x2);
			int64_t v34 = 0LL /* None */;
			push_i64(v34);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_def_Def_sameZ_resolvedZAsk (VAL x1, VAL x2, VAL x3) {
	mw_mirth_def_Def_resolve(x1, x2);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	mw_mirth_def_Def_resolve(r1, x3);
	VAL v2 = pop_value();
	int64_t v3 = mw_mirth_def_Def_ZEqualZEqual(v0, v2);
	push_i64(v3);
}
static void mw_mirth_def_Def_resolve (VAL x1, VAL x2) {
	incref(x2);
	push_resource(x1);
	push_value(x2);
	VAL v0 = mw_mirth_def_Def_aliasZAsk(x2);
	push_value(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		int64_t v2 = mw_std_maybe_Maybe_1_someZAsk(v1);
		if (!((bool)v2)) break;
		VAL v3 = pop_value();
		VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
		VAL v5 = pop_value();
		decref(v5);
		VAL r6 = pop_resource();
		mw_mirth_alias_Alias_target(r6, VU64(v4));
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		VAL v8 = mw_mirth_def_Def_aliasZAsk(v7);
		push_value(v8);
	}
	VAL v9 = pop_value();
	decref(v9);
}
static uint64_t mw_mirth_def_Def_name (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x1);
			uint64_t v1 = mw_mirth_alias_Alias_name(v0);
			push_u64(v1);
		} break;
		case 2LL: { // DefPackage
			uint64_t v2 = mtp_mirth_def_Def_DefPackage(x1);
			uint64_t v3 = mw_mirth_package_Package_name(v2);
			push_u64(v3);
		} break;
		case 1LL: { // DefModule
			uint64_t v4 = mtp_mirth_def_Def_DefModule(x1);
			uint64_t v5 = mw_mirth_module_Module_name(v4);
			push_u64(v5);
		} break;
		case 9LL: { // DefBuffer
			uint64_t v6 = mtp_mirth_def_Def_DefBuffer(x1);
			uint64_t v7 = mw_mirth_buffer_Buffer_name(v6);
			push_u64(v7);
		} break;
		case 7LL: { // DefPrim
			int64_t v8 = mtp_mirth_def_Def_DefPrim(x1);
			uint64_t v9 = mw_mirth_prim_Prim_name(v8);
			push_u64(v9);
		} break;
		case 3LL: { // DefData
			uint64_t v10 = mtp_mirth_def_Def_DefData(x1);
			uint64_t v11 = mw_mirth_data_Data_name(v10);
			push_u64(v11);
		} break;
		case 4LL: { // DefTable
			uint64_t v12 = mtp_mirth_def_Def_DefTable(x1);
			uint64_t v13 = mw_mirth_table_Table_name(v12);
			push_u64(v13);
		} break;
		case 5LL: { // DefType
			uint64_t v14 = mtp_mirth_def_Def_DefType(x1);
			uint64_t v15 = mw_mirth_typedef_TypeDef_name(v14);
			push_u64(v15);
		} break;
		case 11LL: { // DefExternal
			uint64_t v16 = mtp_mirth_def_Def_DefExternal(x1);
			uint64_t v17 = mw_mirth_external_External_name(v16);
			push_u64(v17);
		} break;
		case 8LL: { // DefWord
			uint64_t v18 = mtp_mirth_def_Def_DefWord(x1);
			uint64_t v19 = mw_mirth_word_Word_name(v18);
			push_u64(v19);
		} break;
		case 12LL: { // DefField
			uint64_t v20 = mtp_mirth_def_Def_DefField(x1);
			uint64_t v21 = mw_mirth_table_Field_name(v20);
			push_u64(v21);
		} break;
		case 6LL: { // DefTag
			uint64_t v22 = mtp_mirth_def_Def_DefTag(x1);
			uint64_t v23 = mw_mirth_data_Tag_name(v22);
			push_u64(v23);
		} break;
		case 10LL: { // DefVariable
			uint64_t v24 = mtp_mirth_def_Def_DefVariable(x1);
			uint64_t v25 = mw_mirth_variable_Variable_name(v24);
			push_u64(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v26 = pop_u64();
	return v26;
}
static int64_t mw_mirth_def_Def_arity (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x1);
			int64_t v1 = mw_mirth_alias_Alias_arity(v0);
			push_i64(v1);
		} break;
		case 2LL: { // DefPackage
			uint64_t v2 = mtp_mirth_def_Def_DefPackage(x1);
			int64_t v3 = 0LL;
			push_i64(v3);
		} break;
		case 1LL: { // DefModule
			uint64_t v4 = mtp_mirth_def_Def_DefModule(x1);
			int64_t v5 = 0LL;
			push_i64(v5);
		} break;
		case 9LL: { // DefBuffer
			uint64_t v6 = mtp_mirth_def_Def_DefBuffer(x1);
			int64_t v7 = 0LL;
			push_i64(v7);
		} break;
		case 7LL: { // DefPrim
			int64_t v8 = mtp_mirth_def_Def_DefPrim(x1);
			int64_t v9 = mw_mirth_prim_Prim_arity(v8);
			push_i64(v9);
		} break;
		case 3LL: { // DefData
			uint64_t v10 = mtp_mirth_def_Def_DefData(x1);
			int64_t v11 = mw_mirth_data_Data_arity(v10);
			push_i64(v11);
		} break;
		case 4LL: { // DefTable
			uint64_t v12 = mtp_mirth_def_Def_DefTable(x1);
			int64_t v13 = 0LL;
			push_i64(v13);
		} break;
		case 5LL: { // DefType
			uint64_t v14 = mtp_mirth_def_Def_DefType(x1);
			int64_t v15 = 0LL;
			push_i64(v15);
		} break;
		case 11LL: { // DefExternal
			uint64_t v16 = mtp_mirth_def_Def_DefExternal(x1);
			int64_t v17 = mw_mirth_external_External_arity(v16);
			push_i64(v17);
		} break;
		case 8LL: { // DefWord
			uint64_t v18 = mtp_mirth_def_Def_DefWord(x1);
			int64_t v19 = mw_mirth_word_Word_arity(v18);
			push_i64(v19);
		} break;
		case 12LL: { // DefField
			uint64_t v20 = mtp_mirth_def_Def_DefField(x1);
			int64_t v21 = 0LL;
			push_i64(v21);
		} break;
		case 6LL: { // DefTag
			uint64_t v22 = mtp_mirth_def_Def_DefTag(x1);
			int64_t v23 = 0LL;
			push_i64(v23);
		} break;
		case 10LL: { // DefVariable
			uint64_t v24 = mtp_mirth_def_Def_DefVariable(x1);
			int64_t v25 = 0LL;
			push_i64(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v26 = pop_i64();
	return v26;
}
static void mw_mirth_def_Def_qnameZ_soft (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			VAL v1 = mw_mirth_alias_Alias_qnameZ_soft(v0);
			push_value(v1);
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v2 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v3 = mw_mirth_package_Package_qname(v2);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(v3);
			push_value(v4);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v5 = mtp_mirth_def_Def_DefModule(x2);
			VAL v6 = mw_mirth_module_Module_qname(v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x1);
			uint64_t v8 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v9 = mw_mirth_buffer_Buffer_qname(v8);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			push_value(v10);
		} break;
		case 7LL: { // DefPrim
			push_resource(x1);
			int64_t v11 = mtp_mirth_def_Def_DefPrim(x2);
			VAL r12 = pop_resource();
			mw_mirth_prim_Prim_qname(r12, v11);
			VAL v13 = pop_value();
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v15 = mtp_mirth_def_Def_DefData(x2);
			VAL v16 = mw_mirth_data_Data_qnameZ_soft(v15);
			push_value(v16);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v17 = mtp_mirth_def_Def_DefTable(x2);
			VAL v18 = mw_mirth_table_Table_qnameZ_soft(v17);
			push_value(v18);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v19 = mtp_mirth_def_Def_DefType(x2);
			VAL v20 = mw_mirth_typedef_TypeDef_qnameZ_soft(v19);
			push_value(v20);
		} break;
		case 11LL: { // DefExternal
			push_resource(x1);
			uint64_t v21 = mtp_mirth_def_Def_DefExternal(x2);
			VAL v22 = mw_mirth_external_External_qnameZ_soft(v21);
			push_value(v22);
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v23 = mtp_mirth_def_Def_DefWord(x2);
			VAL v24 = mw_mirth_word_Word_qnameZ_soft(v23);
			push_value(v24);
		} break;
		case 12LL: { // DefField
			push_resource(x1);
			uint64_t v25 = mtp_mirth_def_Def_DefField(x2);
			VAL v26 = mw_mirth_table_Field_qnameZ_soft(v25);
			push_value(v26);
		} break;
		case 6LL: { // DefTag
			push_resource(x1);
			uint64_t v27 = mtp_mirth_def_Def_DefTag(x2);
			VAL v28 = mw_mirth_data_Tag_qname(v27);
			VAL v29 = mtw_std_maybe_Maybe_1_Some(v28);
			push_value(v29);
		} break;
		case 10LL: { // DefVariable
			push_resource(x1);
			uint64_t v30 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v31 = mw_mirth_variable_Variable_qname(v30);
			VAL v32 = mtw_std_maybe_Maybe_1_Some(v31);
			push_value(v32);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_def_Def_qnameZ_hard (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			VAL r1 = pop_resource();
			mw_mirth_alias_Alias_qnameZ_hard(r1, v0);
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v2 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v3 = mw_mirth_package_Package_qname(v2);
			push_value(v3);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v4 = mtp_mirth_def_Def_DefModule(x2);
			VAL v5 = mw_mirth_module_Module_qname(v4);
			push_value(v5);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x1);
			uint64_t v6 = mtp_mirth_def_Def_DefBuffer(x2);
			VAL v7 = mw_mirth_buffer_Buffer_qname(v6);
			push_value(v7);
		} break;
		case 7LL: { // DefPrim
			push_resource(x1);
			int64_t v8 = mtp_mirth_def_Def_DefPrim(x2);
			VAL r9 = pop_resource();
			mw_mirth_prim_Prim_qname(r9, v8);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v10 = mtp_mirth_def_Def_DefData(x2);
			VAL r11 = pop_resource();
			mw_mirth_data_Data_qnameZ_hard(r11, v10);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v12 = mtp_mirth_def_Def_DefTable(x2);
			VAL r13 = pop_resource();
			mw_mirth_table_Table_qnameZ_hard(r13, v12);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v14 = mtp_mirth_def_Def_DefType(x2);
			VAL r15 = pop_resource();
			mw_mirth_typedef_TypeDef_qnameZ_hard(r15, v14);
		} break;
		case 11LL: { // DefExternal
			push_resource(x1);
			uint64_t v16 = mtp_mirth_def_Def_DefExternal(x2);
			VAL r17 = pop_resource();
			mw_mirth_external_External_qnameZ_hard(r17, v16);
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v18 = mtp_mirth_def_Def_DefWord(x2);
			VAL r19 = pop_resource();
			mw_mirth_word_Word_qnameZ_hard(v18, r19);
		} break;
		case 12LL: { // DefField
			push_resource(x1);
			uint64_t v20 = mtp_mirth_def_Def_DefField(x2);
			VAL r21 = pop_resource();
			mw_mirth_table_Field_qnameZ_hard(r21, v20);
		} break;
		case 6LL: { // DefTag
			push_resource(x1);
			uint64_t v22 = mtp_mirth_def_Def_DefTag(x2);
			VAL v23 = mw_mirth_data_Tag_qname(v22);
			push_value(v23);
		} break;
		case 10LL: { // DefVariable
			push_resource(x1);
			uint64_t v24 = mtp_mirth_def_Def_DefVariable(x2);
			VAL v25 = mw_mirth_variable_Variable_qname(v24);
			push_value(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_def_Def_asZ_namespaceZAsk (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // DefAlias
			push_resource(x1);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x2);
			void* v1 = mfld_mirth_alias_Alias_ZTildetarget(v0);
			VAL r2 = pop_resource();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v1), r2);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 1LL: { // Some
					VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
					VAL r5 = pop_resource();
					mw_mirth_def_Def_asZ_namespaceZAsk(r5, v4);
				} break;
				case 0LL: { // None
					int64_t v6 = 0LL /* None */;
					push_i64(v6);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			push_resource(x1);
			uint64_t v7 = mtp_mirth_def_Def_DefPackage(x2);
			VAL v8 = mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE(v7);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v9);
		} break;
		case 1LL: { // DefModule
			push_resource(x1);
			uint64_t v10 = mtp_mirth_def_Def_DefModule(x2);
			VAL v11 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v10);
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v11);
			push_value(v12);
		} break;
		case 3LL: { // DefData
			push_resource(x1);
			uint64_t v13 = mtp_mirth_def_Def_DefData(x2);
			VAL v14 = mtw_mirth_tycon_Tycon_TYCONz_DATA(v13);
			VAL v15 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v14);
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v15);
			push_value(v16);
		} break;
		case 4LL: { // DefTable
			push_resource(x1);
			uint64_t v17 = mtp_mirth_def_Def_DefTable(x2);
			VAL v18 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v17);
			VAL v19 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v18);
			VAL v20 = mtw_std_maybe_Maybe_1_Some(v19);
			push_value(v20);
		} break;
		case 5LL: { // DefType
			push_resource(x1);
			uint64_t v21 = mtp_mirth_def_Def_DefType(x2);
			VAL r22 = pop_resource();
			mw_mirth_typedef_TypeDef_target(r22, v21);
			VAL v23 = pop_value();
			VAL v24 = mw_mirth_type_Type_tyconZAsk(v23);
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v24);
					VAL v26 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v25);
					VAL v27 = mtw_std_maybe_Maybe_1_Some(v26);
					push_value(v27);
				} break;
				case 0LL: { // None
					int64_t v28 = 0LL /* None */;
					push_i64(v28);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 8LL: { // DefWord
			push_resource(x1);
			uint64_t v29 = mtp_mirth_def_Def_DefWord(x2);
			VAL v30 = mtw_mirth_name_Namespace_NAMESPACEz_WORD(v29);
			VAL v31 = mtw_std_maybe_Maybe_1_Some(v30);
			push_value(v31);
		} break;
		default: {
			decref(x2);
			int64_t v32 = 0LL /* None */;
			push_resource(x1);
			push_i64(v32);
		} break;
	}
}
static VAL mw_mirth_def_Def_register (VAL x1, VAL x2) {
	incref(x2);
	push_value(x2);
	mw_mirth_def_Def_qnameZ_soft(x1, x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			incref(v1);
			VAL r2 = pop_resource();
			push_value(v1);
			mw_mirth_name_QName_undefinedZ_softZAsk(r2, v1);
			bool v3 = pop_bool();
			if (v3) {
			} else {
				VAL v4 = pop_value();
				VAL r5 = pop_resource();
				mw_mirth_name_QName_ZToStr(r5, v4);
				STR* v6;
				STRLIT(v6, "qualified name already has definition: ", 39);
				VAL v7 = pop_value();
				STR* v8 = str_cat(v6, VSTR(v7));
				push_str(v8);
				do_panic();
			}
			VAL v9 = pop_value();
			decref(v9);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	uint64_t v11 = mw_mirth_def_Def_name(v10);
	void* v12 = mfld_mirth_name_Name_ZTildedefs(v11);
	VAL v13 = mut_get(MKPTR(v12));
	VAL v14 = pop_value();
	VAL v15 = mtw_std_list_List_1_Cons(v14, v13);
	mut_set(v15, MKPTR(v12));
	VAL r16 = pop_resource();
	return r16;
}
static int64_t mw_mirth_name_Name_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_name_Name_fromZ_index (int64_t x1) {
	return ((uint64_t)x1);
}
static uint64_t mw_mirth_name_Name_allocZBang (void) {
	void* v0 = mbuf_mirth_name_Name_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_name_Name_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static VAL mw_mirth_name_Name_ZToStr (uint64_t x1) {
	void* v0 = mfld_mirth_name_Name_ZTildeStr(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static VAL mw_mirth_name_Name_defs (uint64_t x1) {
	void* v0 = mfld_mirth_name_Name_ZTildedefs(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static VAL mw_mirth_name_Name_mangled (uint64_t x1) {
	void* v0 = mfld_mirth_name_Name_ZTildemangled(x1);
	VAL v1 = mw_std_lazzy_Lazzy_1_forceZBang(MKPTR(v0));
	return v1;
}
static int64_t mw_mirth_name_Name_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_name_Name_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_name_Name_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static int64_t mw_mirth_name_Hash_ZToInt (int64_t x1) {
	return x1;
}
static int64_t mw_std_prim_Int_ZToHash (int64_t x1) {
	push_i64(x1);
	int64_t v0 = mw_mirth_name_HASHz_MAX();
	int64_t v1 = pop_i64();
	int64_t v2 = i64_mod(v1, v0);
	return v2;
}
static int64_t mw_mirth_name_HASHz_MAX (void) {
	int64_t v0 = 65536LL;
	return v0;
}
static VAL mw_mirth_name_hashZ_nameZAt (int64_t x1) {
	int64_t v0 = mw_mirth_name_Hash_ZToInt(x1);
	int64_t v1 = 8LL;
	int64_t v2 = i64_mul(v0, v1);
	void* v3 = mbuf_mirth_name_HASHz_BUF;
	int64_t v4 = (0LL /* +Unsafe */);
	void* v5 = (void*)(v2 + (char*)v3);
	int64_t v6 = *(int64_t*)v5;
	int64_t v7 = 0LL;
	bool v8 = (v6 == v7);
	if (v8) {
		int64_t v9 = 0LL /* None */;
		push_i64(v9);
	} else {
		uint64_t v10 = mw_mirth_name_Name_fromZ_index(v6);
		VAL v11 = mtw_std_maybe_Maybe_1_Some(MKU64(v10));
		push_value(v11);
	}
	VAL v12 = pop_value();
	return v12;
}
static void mw_mirth_name_hashZ_nameZBang (uint64_t x1, int64_t x2) {
	int64_t v0 = mw_mirth_name_Name_index(x1);
	int64_t v1 = mw_std_prim_Int_ZToI64(v0);
	push_i64(v1);
	int64_t v2 = mw_mirth_name_Hash_ZToInt(x2);
	int64_t v3 = 8LL;
	int64_t v4 = i64_mul(v2, v3);
	void* v5 = mbuf_mirth_name_HASHz_BUF;
	int64_t v6 = (0LL /* +Unsafe */);
	void* v7 = (void*)(v4 + (char*)v5);
	int64_t v8 = pop_i64();
	*(int64_t*)v7 = v8;
}
static int64_t mw_std_prim_Str_hash (VAL x1) {
	int64_t v0 = 0LL;
	incref(x1);
	incref(x1);
	void* v1 = str_base(VSTR(x1));
	uint64_t v2 = str_size(VSTR(x1));
	push_i64(v0);
	push_ptr(v1);
	int64_t v3 = mw_std_prim_Int_ZToNat(((int64_t)v2));
	push_i64(v3);
	while(1) {
		int64_t v4 = pop_i64();
		int64_t v5 = 0LL;
		bool v6 = (v4 > v5);
		push_i64(v4);
		if (!v6) break;
		int64_t v7 = pop_i64();
		VAL v8 = pop_value();
		incref(v8);
		int64_t v9 = (0LL /* +Unsafe */);
		mw_std_prim_Ptr_ZAtByte(v8, MKI64(v9));
		VAL r10 = pop_resource();
		int64_t v11 = 17LL;
		int64_t v12 = pop_i64();
		int64_t v13 = i64_mul(v12, v11);
		VAL v14 = pop_value();
		incref(v14);
		int64_t v15 = 7LL;
		uint64_t v16 = u64_shl(VU64(v14), ((uint64_t)v15));
		uint64_t v17 = (((uint64_t)v13) ^ v16);
		int64_t v18 = 27LL;
		uint64_t v19 = u64_shr(VU64(v14), ((uint64_t)v18));
		uint64_t v20 = (v17 ^ v19);
		int64_t v21 = 1LL;
		int64_t v22 = (0LL /* +Unsafe */);
		void* v23 = (void*)(v21 + (char*)VPTR(v8));
		int64_t v24 = 1LL;
		int64_t v25 = i64_sub(v7, v24);
		push_u64(v20);
		push_ptr(v23);
		int64_t v26 = mw_std_prim_Int_ZToNat(v25);
		push_i64(v26);
	}
	int64_t v27 = pop_i64();
	VAL v28 = pop_value();
	decref(v28);
	decref(x1);
	int64_t v29 = pop_i64();
	int64_t v30 = mw_std_prim_Int_ZToHash(v29);
	return v30;
}
static int64_t mw_mirth_name_Hash_next (int64_t x1) {
	int64_t v0 = mw_mirth_name_Hash_ZToInt(x1);
	int64_t v1 = 1LL;
	int64_t v2 = i64_add(v0, v1);
	int64_t v3 = mw_std_prim_Int_ZToHash(v2);
	return v3;
}
static void mw_mirth_name_Hash_keepZ_goingZAsk (VAL x1, int64_t x2) {
	push_value(x1);
	push_i64(x2);
	VAL v0 = mw_mirth_name_hashZ_nameZAt(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v3 = mw_mirth_name_Name_ZToStr(VU64(v2));
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			incref(v5);
			bool v6 = (str_cmp(VSTR(v3), VSTR(v5)) != 0);
			push_value(v5);
			push_value(v4);
			push_bool(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static uint64_t mw_std_prim_Str_ZToName (VAL x1) {
	incref(x1);
	push_value(x1);
	int64_t v0 = mw_std_prim_Str_hash(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		VAL v2 = pop_value();
		mw_mirth_name_Hash_keepZ_goingZAsk(v2, v1);
		bool v3 = pop_bool();
		if (!v3) break;
		int64_t v4 = pop_i64();
		int64_t v5 = mw_mirth_name_Hash_next(v4);
		push_i64(v5);
	}
	int64_t v6 = pop_i64();
	push_i64(v6);
	VAL v7 = mw_mirth_name_hashZ_nameZAt(v6);
	switch (get_data_tag(v7)) {
		case 0LL: { // None
			uint64_t v8 = mw_mirth_name_Name_allocZBang();
			VAL v9 = pop_value();
			push_u64(v8);
			mw_mirth_name_hashZ_nameZBang(v8, VI64(v9));
			VAL v10 = pop_value();
			incref(v10);
			VAL v11 = pop_value();
			void* v12 = mfld_mirth_name_Name_ZTildeStr(VU64(v10));
			mut_set(v11, MKPTR(v12));
			int64_t v13 = 0LL /* Nil */;
			incref(v10);
			void* v14 = mfld_mirth_name_Name_ZTildedefs(VU64(v10));
			mut_set(MKI64(v13), MKPTR(v14));
			incref(v10);
			FNPTR v15 = &mb_std_prim_Str_ZToName_2;
			push_value(v10);
			VAL v16 = mtw_std_lazzy_Lazzy_1_LazzyDelay(v10, MKFNPTR(v15));
			VAL v17 = pop_value();
			incref(v17);
			void* v18 = mfld_mirth_name_Name_ZTildemangled(VU64(v17));
			mut_set(v16, MKPTR(v18));
			push_value(v17);
		} break;
		case 1LL: { // Some
			VAL v19 = mtp_std_maybe_Maybe_1_Some(v7);
			VAL v20 = pop_value();
			decref(v20);
			VAL v21 = pop_value();
			decref(v21);
			push_value(v19);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v22 = pop_u64();
	return v22;
}
static int64_t mw_mirth_name_Name_head (uint64_t x1) {
	VAL v0 = mw_mirth_name_Name_ZToStr(x1);
	int64_t v1 = 0LL;
	int64_t v2 = mw_std_prim_Str_byteZAt(v1, v0);
	return v2;
}
static int64_t mw_mirth_name_Name_tailZ_head (uint64_t x1) {
	VAL v0 = mw_mirth_name_Name_ZToStr(x1);
	int64_t v1 = 1LL;
	int64_t v2 = mw_std_prim_Str_byteZAt(v1, v0);
	return v2;
}
static int64_t mw_mirth_name_Name_canZ_beZ_relativeZAsk (uint64_t x1) {
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = mw_std_byte_Byte_isZ_upper(v0);
	bool v2 = !((bool)v1);
	return ((int64_t)v2);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = mw_std_byte_Byte_isZ_lower(v0);
	if (((bool)v1)) {
		int64_t v2 = 1LL /* True */;
		push_i64(v2);
	} else {
		uint64_t v3 = pop_u64();
		push_u64(v3);
		int64_t v4 = mw_mirth_name_Name_head(v3);
		int64_t v5 = 43LL /* B'+' */;
		bool v6 = (v4 == v5);
		if (v6) {
			uint64_t v7 = pop_u64();
			push_u64(v7);
			int64_t v8 = mw_mirth_name_Name_tailZ_head(v7);
			int64_t v9 = mw_std_byte_Byte_isZ_lower(v8);
			push_i64(v9);
		} else {
			int64_t v10 = 0LL /* False */;
			push_i64(v10);
		}
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	decref(v12);
	return VI64(v11);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk (uint64_t x1) {
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = mw_std_byte_Byte_isZ_lower(v0);
	return v1;
}
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_var (uint64_t x1) {
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = mw_std_byte_Byte_isZ_lower(v0);
	return v1;
}
static int64_t mw_mirth_name_Name_couldZ_beZ_typeZ_con (uint64_t x1) {
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = mw_std_byte_Byte_isZ_upper(v0);
	return v1;
}
static int64_t mw_mirth_name_Name_isZ_typeZ_hole (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = 63LL /* B'?' */;
	bool v2 = (v0 == v1);
	uint64_t v3 = pop_u64();
	push_bool(v2);
	int64_t v4 = mw_mirth_name_Name_tailZ_head(v3);
	int64_t v5 = 0LL /* BNUL */;
	bool v6 = (v4 == v5);
	push_bool(v6);
	int64_t v7 = mw_std_byte_Byte_isZ_lower(v4);
	bool v8 = pop_bool();
	bool v9 = (v8 || ((bool)v7));
	bool v10 = pop_bool();
	bool v11 = (v10 && v9);
	return ((int64_t)v11);
}
static int64_t mw_mirth_name_Name_isZ_underscore (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = 95LL /* B'_' */;
	bool v2 = (v0 == v1);
	uint64_t v3 = pop_u64();
	push_bool(v2);
	int64_t v4 = mw_mirth_name_Name_tailZ_head(v3);
	int64_t v5 = 0LL /* BNUL */;
	bool v6 = (v4 == v5);
	bool v7 = pop_bool();
	bool v8 = (v7 && v6);
	return ((int64_t)v8);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_stackZ_var (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = 42LL /* B'*' */;
	bool v2 = (v0 == v1);
	uint64_t v3 = pop_u64();
	push_bool(v2);
	int64_t v4 = mw_mirth_name_Name_tailZ_head(v3);
	int64_t v5 = mw_std_byte_Byte_isZ_lower(v4);
	bool v6 = pop_bool();
	bool v7 = (v6 && ((bool)v5));
	return ((int64_t)v7);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_var (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = 43LL /* B'+' */;
	bool v2 = (v0 == v1);
	uint64_t v3 = pop_u64();
	push_bool(v2);
	int64_t v4 = mw_mirth_name_Name_tailZ_head(v3);
	int64_t v5 = mw_std_byte_Byte_isZ_lower(v4);
	bool v6 = pop_bool();
	bool v7 = (v6 && ((bool)v5));
	return ((int64_t)v7);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_resourceZ_con (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	int64_t v1 = 43LL /* B'+' */;
	bool v2 = (v0 == v1);
	uint64_t v3 = pop_u64();
	push_bool(v2);
	int64_t v4 = mw_mirth_name_Name_tailZ_head(v3);
	int64_t v5 = mw_std_byte_Byte_isZ_upper(v4);
	bool v6 = pop_bool();
	bool v7 = (v6 && ((bool)v5));
	return ((int64_t)v7);
}
static int64_t mw_mirth_name_Name_couldZ_beZ_constructor (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_name_Name_head(x1);
	switch (v0) {
		case 43LL: { // B'+'
			uint64_t v1 = pop_u64();
			int64_t v2 = mw_mirth_name_Name_tailZ_head(v1);
			int64_t v3 = mw_std_byte_Byte_isZ_upper(v2);
			push_i64(v3);
		} break;
		default: {
			VAL v4 = pop_value();
			decref(v4);
			int64_t v5 = mw_std_byte_Byte_isZ_upper(v0);
			push_i64(v5);
		} break;
	}
	int64_t v6 = pop_i64();
	return v6;
}
static VAL mw_mirth_name_Name_mangleZ_computeZBang (uint64_t x1) {
	STR* v0;
	STRLIT(v0, "", 0);
	push_resource(MKSTR(v0));
	VAL v1 = mw_mirth_name_Name_ZToStr(x1);
	incref(v1);
	incref(v1);
	void* v2 = str_base(VSTR(v1));
	uint64_t v3 = str_size(VSTR(v1));
	push_ptr(v2);
	int64_t v4 = mw_std_prim_Int_ZToNat(((int64_t)v3));
	push_i64(v4);
	while(1) {
		int64_t v5 = pop_i64();
		int64_t v6 = 0LL;
		bool v7 = (v5 > v6);
		push_i64(v5);
		if (!v7) break;
		int64_t v8 = pop_i64();
		VAL v9 = pop_value();
		incref(v9);
		int64_t v10 = (0LL /* +Unsafe */);
		mw_std_prim_Ptr_ZAtByte(v9, MKI64(v10));
		VAL r11 = pop_resource();
		int64_t v12 = pop_i64();
		VAL v13 = mw_std_byte_Byte_zzencode(v12);
		VAL r14 = pop_resource();
		VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(v13, r14));
		int64_t v16 = 1LL;
		int64_t v17 = (0LL /* +Unsafe */);
		void* v18 = (void*)(v16 + (char*)VPTR(v9));
		int64_t v19 = 1LL;
		int64_t v20 = i64_sub(v8, v19);
		push_resource(v15);
		push_ptr(v18);
		int64_t v21 = mw_std_prim_Int_ZToNat(v20);
		push_i64(v21);
	}
	int64_t v22 = pop_i64();
	VAL v23 = pop_value();
	decref(v23);
	decref(v1);
	VAL r24 = pop_resource();
	return r24;
}
static int64_t mw_mirth_name_Namespace_ZEqualZEqual (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			switch (get_data_tag(x1)) {
				case 0LL: { // NAMESPACE_ROOT
					int64_t v0 = 1LL /* True */;
					push_i64(v0);
				} break;
				default: {
					decref(x1);
					int64_t v1 = 0LL /* False */;
					push_i64(v1);
				} break;
			}
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			push_value(x1);
			uint64_t v2 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 1LL: { // NAMESPACE_PACKAGE
					push_u64(v2);
					uint64_t v4 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(v3);
					uint64_t v5 = pop_u64();
					int64_t v6 = mw_mirth_package_Package_ZEqualZEqual(v4, v5);
					push_i64(v6);
				} break;
				default: {
					decref(v3);
					int64_t v7 = 0LL /* False */;
					push_i64(v7);
				} break;
			}
		} break;
		case 2LL: { // NAMESPACE_MODULE
			push_value(x1);
			uint64_t v8 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v9 = pop_value();
			switch (get_data_tag(v9)) {
				case 2LL: { // NAMESPACE_MODULE
					push_u64(v8);
					uint64_t v10 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(v9);
					uint64_t v11 = pop_u64();
					int64_t v12 = mw_mirth_module_Module_ZEqualZEqual(v10, v11);
					push_i64(v12);
				} break;
				default: {
					decref(v9);
					int64_t v13 = 0LL /* False */;
					push_i64(v13);
				} break;
			}
		} break;
		case 3LL: { // NAMESPACE_TYCON
			push_value(x1);
			VAL v14 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL v15 = pop_value();
			switch (get_data_tag(v15)) {
				case 3LL: { // NAMESPACE_TYCON
					push_value(v14);
					VAL v16 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v15);
					VAL v17 = pop_value();
					int64_t v18 = mw_mirth_tycon_Tycon_ZEqualZEqual(v16, v17);
					push_i64(v18);
				} break;
				default: {
					decref(v15);
					decref(v14);
					int64_t v19 = 0LL /* False */;
					push_i64(v19);
				} break;
			}
		} break;
		case 4LL: { // NAMESPACE_WORD
			push_value(x1);
			uint64_t v20 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL v21 = pop_value();
			switch (get_data_tag(v21)) {
				case 4LL: { // NAMESPACE_WORD
					push_u64(v20);
					uint64_t v22 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(v21);
					uint64_t v23 = pop_u64();
					int64_t v24 = mw_mirth_word_Word_ZEqualZEqual(v22, v23);
					push_i64(v24);
				} break;
				default: {
					decref(v21);
					int64_t v25 = 0LL /* False */;
					push_i64(v25);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
		}
	}
	int64_t v26 = pop_i64();
	return v26;
}
static void mw_mirth_name_Namespace_qname (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			int64_t v0 = 0LL /* None */;
			push_resource(x1);
			push_i64(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			push_resource(x1);
			uint64_t v1 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			VAL v2 = mw_mirth_package_Package_qname(v1);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			push_resource(x1);
			uint64_t v4 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v5 = mw_mirth_module_Module_qname(v4);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			push_value(v6);
		} break;
		case 3LL: { // NAMESPACE_TYCON
			push_resource(x1);
			VAL v7 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL r8 = pop_resource();
			mw_mirth_tycon_Tycon_qnameZ_hard(r8, v7);
			VAL v9 = pop_value();
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			push_value(v10);
		} break;
		case 4LL: { // NAMESPACE_WORD
			push_resource(x1);
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL r12 = pop_resource();
			mw_mirth_word_Word_qnameZ_hard(v11, r12);
			VAL v13 = pop_value();
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_name_Namespace_moduleZAsk (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			int64_t v0 = 0LL /* None */;
			push_resource(x1);
			push_i64(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			push_resource(x1);
			uint64_t v1 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			int64_t v2 = 0LL /* None */;
			push_i64(v2);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			push_resource(x1);
			uint64_t v3 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKU64(v3));
			push_value(v4);
		} break;
		case 3LL: { // NAMESPACE_TYCON
			push_resource(x1);
			VAL v5 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL r6 = pop_resource();
			mw_mirth_tycon_Tycon_qnameZ_hard(r6, v5);
			VAL v7 = pop_value();
			VAL v8 = VVAL(VTUP(v7)->cells[1]);
			incref(v8);
			decref(v7);
			VAL r9 = pop_resource();
			mw_mirth_name_Namespace_moduleZAsk(r9, v8);
		} break;
		case 4LL: { // NAMESPACE_WORD
			push_resource(x1);
			uint64_t v10 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			int64_t v11 = 0LL /* None */;
			push_i64(v11);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_name_Namespace_prim (VAL x1) {
	mw_mirth_module_Module_prim(x1);
	uint64_t v0 = pop_u64();
	VAL v1 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v0);
	push_value(v1);
}
static void mw_mirth_name_Namespace_ZToStr (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			STR* v0;
			STRLIT(v0, "<root>", 6);
			push_resource(x1);
			push_str(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			push_resource(x1);
			uint64_t v1 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			uint64_t v2 = mw_mirth_package_Package_name(v1);
			VAL v3 = mw_mirth_name_Name_ZToStr(v2);
			push_value(v3);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			push_resource(x1);
			uint64_t v4 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v5 = mw_mirth_module_Module_qname(v4);
			VAL r6 = pop_resource();
			mw_mirth_name_QName_ZToStr(r6, v5);
		} break;
		case 3LL: { // NAMESPACE_TYCON
			push_resource(x1);
			VAL v7 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL r8 = pop_resource();
			mw_mirth_tycon_Tycon_qnameZ_hard(r8, v7);
			VAL v9 = pop_value();
			VAL r10 = pop_resource();
			mw_mirth_name_QName_ZToStr(r10, v9);
		} break;
		case 4LL: { // NAMESPACE_WORD
			push_resource(x1);
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL r12 = pop_resource();
			mw_mirth_word_Word_qnameZ_hard(v11, r12);
			VAL v13 = pop_value();
			VAL r14 = pop_resource();
			mw_mirth_name_QName_ZToStr(r14, v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_name_Namespace_mangled (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // NAMESPACE_ROOT
			STR* v0;
			STRLIT(v0, "__root__", 8);
			push_resource(x1);
			push_str(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			push_resource(x1);
			uint64_t v1 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x2);
			uint64_t v2 = mw_mirth_package_Package_name(v1);
			VAL v3 = mw_mirth_name_Name_mangled(v2);
			push_value(v3);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			push_resource(x1);
			uint64_t v4 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x2);
			VAL v5 = mw_mirth_module_Module_qname(v4);
			VAL r6 = pop_resource();
			mw_mirth_name_QName_mangled(r6, v5);
		} break;
		case 3LL: { // NAMESPACE_TYCON
			push_resource(x1);
			VAL v7 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x2);
			VAL r8 = pop_resource();
			mw_mirth_tycon_Tycon_qnameZ_hard(r8, v7);
			VAL v9 = pop_value();
			VAL r10 = pop_resource();
			mw_mirth_name_QName_mangled(r10, v9);
		} break;
		case 4LL: { // NAMESPACE_WORD
			push_resource(x1);
			uint64_t v11 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x2);
			VAL r12 = pop_resource();
			mw_mirth_word_Word_qnameZ_hard(v11, r12);
			VAL v13 = pop_value();
			VAL r14 = pop_resource();
			mw_mirth_name_QName_mangled(r14, v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static VAL mw_mirth_name_QNAME0 (VAL x1, uint64_t x2) {
	int64_t v0 = 0LL;
	VAL v1 = mtw_mirth_name_QName_MKQNAME(x1, x2, v0);
	return v1;
}
static int64_t mw_mirth_name_QName_ZEqualZEqual (VAL x1, VAL x2) {
	push_value(x1);
	mtp_mirth_name_QName_MKQNAME(x2);
	VAL v0 = pop_value();
	mtp_mirth_name_QName_MKQNAME(v0);
	uint64_t v1 = VU64(lpop(&lbl_name));
	uint64_t v2 = VU64(lpop(&lbl_name));
	int64_t v3 = mw_mirth_name_Name_ZEqualZEqual(v1, v2);
	int64_t v4 = VI64(lpop(&lbl_arity));
	int64_t v5 = VI64(lpop(&lbl_arity));
	bool v6 = (v4 == v5);
	bool v7 = (((bool)v3) && v6);
	VAL v8 = lpop(&lbl_namespace);
	VAL v9 = lpop(&lbl_namespace);
	push_bool(v7);
	int64_t v10 = mw_mirth_name_Namespace_ZEqualZEqual(v8, v9);
	bool v11 = pop_bool();
	bool v12 = (v11 && ((bool)v10));
	return ((int64_t)v12);
}
static void mw_mirth_name_QName_defZ_hardZAsk (VAL x1, VAL x2) {
	incref(x2);
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	push_resource(x1);
	push_value(x2);
	VAL v1 = mw_mirth_name_Name_defs(v0);
	int64_t v2 = 0LL /* None */;
	push_i64(v2);
	mw_std_list_List_1_uncons(v1);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		incref(v8);
		VAL v11 = pop_value();
		incref(v11);
		VAL r12 = pop_resource();
		push_value(v11);
		mw_mirth_def_Def_qnameZ_hard(r12, v8);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		int64_t v15 = mw_mirth_name_QName_ZEqualZEqual(v14, v13);
		if (((bool)v15)) {
			push_value(v11);
			VAL v16 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v16);
		} else {
			decref(v8);
			int64_t v17 = 0LL /* None */;
			push_value(v11);
			push_i64(v17);
		}
		VAL v18 = pop_value();
		switch (get_data_tag(v18)) {
			case 0LL: { // None
				push_value(v10);
				push_value(v9);
			} break;
			default: {
				decref(v9);
				decref(v10);
				int64_t v19 = 0LL /* Nil */;
				push_value(v18);
				push_i64(v19);
			} break;
		}
		VAL v20 = pop_value();
		mw_std_list_List_1_uncons(v20);
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		push_value(v21);
		push_value(v22);
	}
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	decref(v24);
	VAL v25 = pop_value();
	VAL v26 = pop_value();
	decref(v26);
	push_value(v25);
}
static void mw_mirth_name_QName_definedZ_hardZAsk (VAL x1, VAL x2) {
	mw_mirth_name_QName_defZ_hardZAsk(x1, x2);
	VAL v0 = pop_value();
	int64_t v1 = mw_std_maybe_Maybe_1_someZAsk(v0);
	push_i64(v1);
}
static void mw_mirth_name_QName_defZ_softZAsk (VAL x1, VAL x2) {
	incref(x2);
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	decref(x2);
	push_resource(x1);
	push_value(x2);
	VAL v1 = mw_mirth_name_Name_defs(v0);
	VAL v2 = pop_value();
	VAL v3 = mtw_std_maybe_Maybe_1_Some(v2);
	int64_t v4 = 0LL /* None */;
	push_value(v3);
	push_i64(v4);
	mw_std_list_List_1_uncons(v1);
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		int64_t v8 = mw_std_maybe_Maybe_1_someZAsk(v7);
		if (!((bool)v8)) break;
		VAL v9 = pop_value();
		VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		incref(v10);
		VAL v13 = pop_value();
		incref(v13);
		VAL r14 = pop_resource();
		push_value(v13);
		mw_mirth_def_Def_qnameZ_soft(r14, v10);
		VAL v15 = pop_value();
		switch (get_data_tag(v15)) {
			case 0LL: { // None
				VAL v16 = pop_value();
				int64_t v17 = mw_std_maybe_Maybe_1_noneZAsk(v16);
				push_i64(v17);
			} break;
			case 1LL: { // Some
				VAL v18 = mtp_std_maybe_Maybe_1_Some(v15);
				VAL v19 = pop_value();
				switch (get_data_tag(v19)) {
					case 1LL: { // Some
						push_value(v18);
						VAL v20 = mtp_std_maybe_Maybe_1_Some(v19);
						VAL v21 = pop_value();
						int64_t v22 = mw_mirth_name_QName_ZEqualZEqual(v20, v21);
						push_i64(v22);
					} break;
					case 0LL: { // None
						decref(v18);
						int64_t v23 = 0LL /* False */;
						push_i64(v23);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v18);
					}
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		int64_t v24 = pop_i64();
		if (((bool)v24)) {
			push_value(v13);
			VAL v25 = mtw_std_maybe_Maybe_1_Some(v10);
			push_value(v25);
		} else {
			decref(v10);
			int64_t v26 = 0LL /* None */;
			push_value(v13);
			push_i64(v26);
		}
		VAL v27 = pop_value();
		switch (get_data_tag(v27)) {
			case 0LL: { // None
				push_value(v12);
				push_value(v11);
			} break;
			default: {
				decref(v11);
				decref(v12);
				int64_t v28 = 0LL /* Nil */;
				push_value(v27);
				push_i64(v28);
			} break;
		}
		VAL v29 = pop_value();
		mw_std_list_List_1_uncons(v29);
		VAL v30 = pop_value();
		VAL v31 = pop_value();
		push_value(v30);
		push_value(v31);
	}
	VAL v32 = pop_value();
	decref(v32);
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	VAL v35 = pop_value();
	decref(v35);
	push_value(v34);
}
static void mw_mirth_name_QName_definedZ_softZAsk (VAL x1, VAL x2) {
	mw_mirth_name_QName_defZ_softZAsk(x1, x2);
	VAL v0 = pop_value();
	int64_t v1 = mw_std_maybe_Maybe_1_someZAsk(v0);
	push_i64(v1);
}
static void mw_mirth_name_QName_undefinedZ_softZAsk (VAL x1, VAL x2) {
	mw_mirth_name_QName_defZ_softZAsk(x1, x2);
	VAL v0 = pop_value();
	int64_t v1 = mw_std_maybe_Maybe_1_noneZAsk(v0);
	push_i64(v1);
}
static void mw_mirth_name_QName_prim (VAL x1, VAL x2, int64_t x3) {
	push_resource(x1);
	lpush(&lbl_arity, MKI64(x3));
	uint64_t v0 = mw_std_prim_Str_ZToName(x2);
	VAL r1 = pop_resource();
	lpush(&lbl_name, MKU64(v0));
	mw_mirth_name_Namespace_prim(r1);
	VAL v2 = pop_value();
	int64_t v3 = VI64(lpop(&lbl_arity));
	uint64_t v4 = VU64(lpop(&lbl_name));
	VAL v5 = mtw_mirth_name_QName_MKQNAME(v2, v4, v3);
	push_value(v5);
}
static void mw_mirth_name_QName_ZToStr (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_name_QName_MKQNAME(x2);
	VAL v0 = lpop(&lbl_namespace);
	VAL r1 = pop_resource();
	mw_mirth_name_Namespace_ZToStr(r1, v0);
	STR* v2;
	STRLIT(v2, ".", 1);
	STR* v3 = pop_str();
	STR* v4 = str_cat(v3, v2);
	uint64_t v5 = VU64(lpop(&lbl_name));
	push_str(v4);
	VAL v6 = mw_mirth_name_Name_ZToStr(v5);
	STR* v7 = pop_str();
	STR* v8 = str_cat(v7, VSTR(v6));
	int64_t v9 = VI64(lpop(&lbl_arity));
	int64_t v10 = 0LL;
	bool v11 = (v9 == v10);
	if (v11) {
		push_str(v8);
	} else {
		STR* v12;
		STRLIT(v12, "/", 1);
		STR* v13 = i64_show(v9);
		STR* v14 = str_cat(v12, v13);
		STR* v15 = str_cat(v8, v14);
		push_str(v15);
	}
}
static void mw_mirth_name_QName_toZ_moduleZ_path (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // NAMESPACE_PACKAGE
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v1 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(v0);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			mw_mirth_package_Package_pathZ_orZ_search(r3, r2, v1);
			VAL v4 = pop_value();
			switch (get_data_tag(v4)) {
				case 1LL: { // Some
					VAL v5 = mtp_std_maybe_Maybe_1_Some(v4);
					push_value(v5);
				} break;
				case 0LL: { // None
					STR* v6;
					STRLIT(v6, "No path defined for package", 27);
					push_str(v6);
					do_panic();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			uint64_t v9 = VU64(VTUP(v8)->cells[2]);
			decref(v8);
			push_value(v7);
			VAL v10 = mw_mirth_name_Name_ZToStr(v9);
			STR* v11;
			STRLIT(v11, ".mth", 4);
			STR* v12 = str_cat(VSTR(v10), v11);
			VAL v13 = pop_value();
			VAL v14 = mw_std_path_Path_join(v13, MKSTR(v12));
			push_value(v14);
		} break;
		default: {
			decref(v0);
			STR* v15;
			STRLIT(v15, "expected module name", 20);
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			push_str(v15);
			do_panic();
		} break;
	}
}
static void mw_mirth_name_QName_mangled (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_name_QName_MKQNAME(x2);
	VAL v0 = lpop(&lbl_namespace);
	VAL r1 = pop_resource();
	mw_mirth_name_Namespace_mangled(r1, v0);
	STR* v2;
	STRLIT(v2, "_", 1);
	STR* v3 = pop_str();
	STR* v4 = str_cat(v3, v2);
	uint64_t v5 = VU64(lpop(&lbl_name));
	push_str(v4);
	VAL v6 = mw_mirth_name_Name_mangled(v5);
	STR* v7 = pop_str();
	STR* v8 = str_cat(v7, VSTR(v6));
	int64_t v9 = VI64(lpop(&lbl_arity));
	int64_t v10 = 0LL;
	bool v11 = (v9 > v10);
	if (v11) {
		STR* v12;
		STRLIT(v12, "_", 1);
		STR* v13 = i64_show(v9);
		STR* v14 = str_cat(v12, v13);
		STR* v15 = str_cat(v8, v14);
		push_str(v15);
	} else {
		push_str(v8);
	}
}
static VAL mw_mirth_name_DName_rootZAsk (VAL x1) {
	mtp_mirth_name_DName_DName(x1);
	VAL v0 = pop_value();
	decref(v0);
	VAL v1 = pop_value();
	return v1;
}
static VAL mw_mirth_name_DName_parts (VAL x1) {
	mtp_mirth_name_DName_DName(x1);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	return v0;
}
static uint64_t mw_mirth_name_DName_lastZ_name (VAL x1) {
	VAL v0 = mw_mirth_name_DName_parts(x1);
	VAL v1 = mw_std_list_ListZPlus_1_last(v0);
	return VU64(v1);
}
static VAL mw_mirth_name_DName_penultimateZ_nameZAsk (VAL x1) {
	mtp_mirth_name_DName_DName(x1);
	VAL v0 = pop_value();
	mw_std_list_ListZPlus_1_unsnoc(v0);
	uint64_t v1 = pop_u64();
	VAL v2 = pop_value();
	VAL v3 = mw_std_list_List_1_last(v2);
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v4);
			push_value(v6);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v7 = pop_value();
	return v7;
}
static int64_t mw_mirth_name_DName_isZ_relativeZAsk (VAL x1) {
	VAL v0 = mw_mirth_name_DName_rootZAsk(x1);
	int64_t v1 = mw_std_maybe_Maybe_1_noneZAsk(v0);
	return v1;
}
static int64_t mw_mirth_package_Package_index (uint64_t x1) {
	return ((int64_t)x1);
}
static uint64_t mw_mirth_package_Package_allocZBang (void) {
	void* v0 = mbuf_mirth_package_Package_NUM;
	uint64_t v1 = *(uint64_t*)v0;
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(((int64_t)v1), v2);
	void* v4 = mbuf_mirth_package_Package_NUM;
	*(uint64_t*)v4 = ((uint64_t)v3);
	return ((uint64_t)v3);
}
static uint64_t mw_mirth_package_Package_name (uint64_t x1) {
	void* v0 = mfld_mirth_package_Package_ZTildename(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return VU64(v1);
}
static VAL mw_mirth_package_Package_qname (uint64_t x1) {
	int64_t v0 = 0LL /* NAMESPACE_ROOT */;
	push_i64(v0);
	uint64_t v1 = mw_mirth_package_Package_name(x1);
	VAL v2 = pop_value();
	VAL v3 = mw_mirth_name_QNAME0(v2, v1);
	return v3;
}
static VAL mw_mirth_package_Package_path (uint64_t x1) {
	void* v0 = mfld_mirth_package_Package_ZTildepath(x1);
	VAL v1 = mut_get(MKPTR(v0));
	return v1;
}
static void mw_mirth_package_Package_std (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[1]);
	decref(v0);
	push_resource(x1);
	push_u64(v1);
}
static VAL mw_mirth_package_initZ_packagesZBang (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[1]);
	decref(v0);
	STR* v2;
	STRLIT(v2, "std", 3);
	push_resource(x1);
	push_u64(v1);
	uint64_t v3 = mw_std_prim_Str_ZToName(MKSTR(v2));
	VAL v4 = pop_value();
	incref(v4);
	void* v5 = mfld_mirth_package_Package_ZTildename(VU64(v4));
	mut_set(MKU64(v3), MKPTR(v5));
	int64_t v6 = 0LL /* None */;
	void* v7 = mfld_mirth_package_Package_ZTildepath(VU64(v4));
	mut_set(MKI64(v6), MKPTR(v7));
	VAL r8 = pop_resource();
	return r8;
}
static void mw_mirth_package_Package_pathZ_orZ_search (VAL x1, VAL x2, uint64_t x3) {
	push_resource(x1);
	push_resource(x2);
	push_u64(x3);
	VAL v0 = mw_mirth_package_Package_path(x3);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v3);
		} break;
		case 0LL: { // None
			VAL r4 = pop_resource();
			VAL v5 = VVAL(VTUP(r4)->cells[7]);
			incref(v5);
			int64_t v6 = 0LL /* Nil */;
			push_value(v5);
			push_resource(r4);
			VAL v7 = mw_std_list_List_1_reverse(MKI64(v6));
			VAL v8 = pop_value();
			push_resource(v7);
			mw_std_list_List_1_uncons(v8);
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			while(1) {
				VAL v11 = pop_value();
				incref(v11);
				push_value(v11);
				int64_t v12 = mw_std_maybe_Maybe_1_someZAsk(v11);
				if (!((bool)v12)) break;
				VAL v13 = pop_value();
				VAL v14 = mw_std_maybe_Maybe_1_unwrap(v13);
				VAL v15 = pop_value();
				VAL r16 = pop_resource();
				VAL v17 = pop_value();
				incref(v17);
				push_value(v17);
				push_value(v14);
				uint64_t v18 = mw_mirth_package_Package_name(VU64(v17));
				VAL v19 = mw_mirth_name_Name_ZToStr(v18);
				VAL v20 = pop_value();
				VAL v21 = mw_std_path_Path_join(v20, v19);
				VAL v22 = mtw_std_list_List_1_Cons(v21, r16);
				push_resource(v22);
				mw_std_list_List_1_uncons(v15);
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v23);
				push_value(v24);
			}
			VAL v25 = pop_value();
			decref(v25);
			VAL v26 = pop_value();
			decref(v26);
			VAL r27 = pop_resource();
			VAL v28 = mw_std_list_List_1_reverse(r27);
			int64_t v29 = 0LL /* None */;
			push_i64(v29);
			mw_std_list_List_1_uncons(v28);
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			push_value(v30);
			push_value(v31);
			while(1) {
				VAL v32 = pop_value();
				incref(v32);
				push_value(v32);
				int64_t v33 = mw_std_maybe_Maybe_1_someZAsk(v32);
				if (!((bool)v33)) break;
				VAL v34 = pop_value();
				VAL v35 = mw_std_maybe_Maybe_1_unwrap(v34);
				VAL v36 = pop_value();
				VAL v37 = pop_value();
				incref(v35);
				VAL r38 = pop_resource();
				VAL r39 = pop_resource();
				mw_std_prim_ZPlusWorld_isZ_directoryZAsk(r39, v35);
				int64_t v40 = pop_i64();
				if (((bool)v40)) {
					push_resource(r38);
					VAL v41 = mtw_std_maybe_Maybe_1_Some(v35);
					push_value(v41);
				} else {
					decref(v35);
					int64_t v42 = 0LL /* None */;
					push_resource(r38);
					push_i64(v42);
				}
				VAL v43 = pop_value();
				switch (get_data_tag(v43)) {
					case 0LL: { // None
						push_value(v37);
						push_value(v36);
					} break;
					default: {
						decref(v36);
						decref(v37);
						int64_t v44 = 0LL /* Nil */;
						push_value(v43);
						push_i64(v44);
					} break;
				}
				VAL v45 = pop_value();
				mw_std_list_List_1_uncons(v45);
				VAL v46 = pop_value();
				VAL v47 = pop_value();
				push_value(v46);
				push_value(v47);
			}
			VAL v48 = pop_value();
			decref(v48);
			VAL v49 = pop_value();
			decref(v49);
			VAL v50 = pop_value();
			incref(v50);
			VAL v51 = pop_value();
			void* v52 = mfld_mirth_package_Package_ZTildepath(VU64(v51));
			mut_set(v50, MKPTR(v52));
			push_value(v50);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_package_Package_pathZBang (VAL x1, uint64_t x2) {
	push_u64(x2);
	push_value(x1);
	VAL v0 = mw_mirth_package_Package_path(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = pop_value();
			incref(v2);
			incref(v1);
			bool v3 = (str_cmp(VSTR(v2), VSTR(v1)) == 0);
			if (v3) {
				decref(v1);
				decref(v2);
				VAL v4 = pop_value();
				decref(v4);
			} else {
				STR* v5;
				STRLIT(v5, "", 0);
				STR* v6;
				STRLIT(v6, "Tried to set different path for the same package.", 49);
				push_value(v2);
				push_value(v1);
				VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), MKSTR(v5)));
				STR* v8;
				STRLIT(v8, "\n\tPackage: ", 11);
				VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				push_resource(v9);
				push_value(v11);
				push_value(v10);
				uint64_t v13 = mw_mirth_package_Package_name(VU64(v12));
				VAL v14 = mw_mirth_name_Name_ZToStr(v13);
				VAL r15 = pop_resource();
				VAL v16 = (mw_std_str_ZPlusStr_pushZ_strZBang(v14, r15));
				STR* v17;
				STRLIT(v17, "\n\tPath 1: ", 10);
				VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v17), v16));
				VAL v19 = pop_value();
				VAL v20 = pop_value();
				push_value(v19);
				VAL v21 = (mw_std_prim_Str_showZThen(v20, v18));
				STR* v22;
				STRLIT(v22, "\n\tPath 2: ", 10);
				VAL v23 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v22), v21));
				VAL v24 = pop_value();
				VAL v25 = (mw_std_prim_Str_showZThen(v24, v23));
				push_value(v25);
				do_panic();
			}
		} break;
		case 0LL: { // None
			VAL v26 = pop_value();
			VAL v27 = mtw_std_maybe_Maybe_1_Some(v26);
			uint64_t v28 = pop_u64();
			void* v29 = mfld_mirth_package_Package_ZTildepath(v28);
			mut_set(v27, MKPTR(v29));
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_package_Package_newZBang (VAL x1, VAL x2, uint64_t x3) {
	push_resource(x1);
	push_value(x2);
	push_u64(x3);
	uint64_t v0 = mw_mirth_package_Package_allocZBang();
	VAL v1 = pop_value();
	void* v2 = mfld_mirth_package_Package_ZTildename(v0);
	mut_set(v1, MKPTR(v2));
	VAL v3 = pop_value();
	void* v4 = mfld_mirth_package_Package_ZTildepath(v0);
	mut_set(v3, MKPTR(v4));
	push_u64(v0);
	VAL v5 = mtw_mirth_def_Def_DefPackage(v0);
	VAL r6 = pop_resource();
	VAL v7 = (mw_mirth_def_Def_register(r6, v5));
	push_resource(v7);
}
static void mw_mirth_package_Package_newZ_orZ_pathZBang (VAL x1, VAL x2, uint64_t x3) {
	push_value(x2);
	push_u64(x3);
	mw_mirth_package_Package_find(x1, x3);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = pop_value();
			decref(v2);
			incref(v1);
			VAL v3 = pop_value();
			push_value(v1);
			mw_mirth_package_Package_pathZBang(v3, VU64(v1));
		} break;
		case 0LL: { // None
			uint64_t v4 = pop_u64();
			VAL v5 = pop_value();
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			VAL r7 = pop_resource();
			mw_mirth_package_Package_newZBang(r7, v6, v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_package_Package_find (VAL x1, uint64_t x2) {
	int64_t v0 = 0LL /* NAMESPACE_ROOT */;
	push_resource(x1);
	VAL v1 = mw_mirth_name_QNAME0(MKI64(v0), x2);
	VAL r2 = pop_resource();
	mw_mirth_name_QName_defZ_softZAsk(r2, v1);
	VAL v3 = pop_value();
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = mw_mirth_def_Def_packageZAsk(v4);
			push_value(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* None */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_package_Package_findZ_orZ_newZBang (VAL x1, uint64_t x2) {
	push_u64(x2);
	mw_mirth_package_Package_find(x1, x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			uint64_t v2 = pop_u64();
			int64_t v3 = 0LL /* None */;
			VAL r4 = pop_resource();
			push_u64(v2);
			mw_mirth_package_Package_newZBang(r4, MKI64(v3), v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	decref(v6);
	push_value(v5);
}
static int64_t mw_mirth_package_Package_ZEqualZEqual (uint64_t x1, uint64_t x2) {
	int64_t v0 = mw_mirth_package_Package_index(x1);
	push_i64(v0);
	int64_t v1 = mw_mirth_package_Package_index(x2);
	int64_t v2 = pop_i64();
	bool v3 = (v2 == v1);
	return ((int64_t)v3);
}
static VAL mw_mirth_lexer_lexerZ_stackZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[4]);
	incref(v0);
	push_resource(x2);
	VAL v1 = mtw_std_list_List_1_Cons(MKU64(x1), v0);
	VAL r2 = pop_resource();
	VAL v3 = VTUP(r2)->cells[4];
	decref(v3);
	VTUP(r2)->cells[4] = v1;
	return r2;
}
static void mw_mirth_lexer_lexerZ_stackZ_popZBang (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	push_resource(x1);
	mw_std_list_List_1_uncons(v0);
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	VAL v3 = VTUP(r1)->cells[4];
	decref(v3);
	VTUP(r1)->cells[4] = v2;
	push_resource(r1);
}
static VAL mw_mirth_lexer_lexerZ_stackZ_drop (VAL x1) {
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x1);
	VAL v0 = pop_value();
	decref(v0);
	VAL r1 = pop_resource();
	return r1;
}
static void mw_mirth_lexer_lexerZ_stackZ_peek (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	push_resource(x1);
	VAL v1 = mw_std_list_List_1_first(v0);
	push_value(v1);
}
static void mw_mirth_lexer_runZ_lexerZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	mw_mirth_module_Module_newZBang(x3, x1);
	uint64_t v0 = pop_u64();
	lpush(&lbl_lexerZ_module, MKU64(v0));
	VAL v1 = mw_mirth_module_Module_sourceZ_path(v0);
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	mw_std_prim_ZPlusWorld_openZ_fileZBang(v1, r3);
	VAL r4 = pop_resource();
	VAL v5 = (mw_std_file_ZPlusFileZAsk_unwrapZBang(r4));
	VAL v6 = (mw_std_input_ZPlusInput_startZBang(v5));
	int64_t v7 = 1LL;
	lpush(&lbl_ZPlusinput, v6);
	push_resource(r2);
	int64_t v8 = mw_std_prim_Int_ZToRow(v7);
	int64_t v9 = 1LL;
	lpush(&lbl_lexerZ_row, MKI64(v8));
	int64_t v10 = mw_std_prim_Int_ZToCol(v9);
	int64_t v11 = 0LL /* Nil */;
	lpush(&lbl_lexerZ_col, MKI64(v10));
	lpush(&lbl_lexerZ_stack, MKI64(v11));
	uint64_t v12 = mw_mirth_token_Token_allocZ_noneZBang();
	VAL v13 = (lpop(&lbl_ZPlusinput));
	VAL v14 = lpop(&lbl_lexerZ_stack);
	int64_t v15 = VI64(lpop(&lbl_lexerZ_col));
	int64_t v16 = VI64(lpop(&lbl_lexerZ_row));
	uint64_t v17 = VU64(lpop(&lbl_lexerZ_module));
	push_u64(v12);
	VAL v18 = (mtw_mirth_lexer_ZPlusLexer_ZPlusLexer(v17, v16, v15, v14, v12, v13));
	push_resource(v18);
	while(1) {
		VAL r19 = pop_resource();
		mw_mirth_lexer_ZPlusLexer_doneZAsk(r19);
		bool v20 = pop_bool();
		bool v21 = !v20;
		if (!v21) break;
		VAL r22 = pop_resource();
		VAL r23 = pop_resource();
		mw_mirth_lexer_lexerZ_nextZBang(r23, r22);
	}
	int64_t v24 = 0LL /* TokenNone */;
	VAL r25 = pop_resource();
	VAL v26 = (mw_mirth_lexer_lexerZ_emitZBang(MKI64(v24), r25));
	mtp_mirth_lexer_ZPlusLexer_ZPlusLexer(v26);
	VAL r27 = pop_resource();
	VAL v28 = (lpop(&lbl_ZPlusinput));
	VAL v29 = (mw_std_input_ZPlusInput_endZBang(v28));
	VAL r30 = pop_resource();
	VAL v31 = (mw_std_file_ZPlusFile_closeZ_fileZBang(r30, v29));
	VAL v32 = lpop(&lbl_lexerZ_stack);
	push_resource(v31);
	push_resource(r27);
	mw_std_list_List_1_uncons(v32);
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	switch (get_data_tag(v34)) {
		case 1LL: { // Some
			VAL v35 = mtp_std_maybe_Maybe_1_Some(v34);
			STR* v36;
			STRLIT(v36, "Mismatched left parenthesis.", 28);
			VAL r37 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v35), MKSTR(v36), r37);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v38 = VI64(lpop(&lbl_lexerZ_row));
	int64_t v39 = VI64(lpop(&lbl_lexerZ_col));
	uint64_t v40 = VU64(lpop(&lbl_lexerZ_lastZ_token));
	uint64_t v41 = VU64(lpop(&lbl_lexerZ_module));
	push_u64(v41);
	uint64_t v42 = mw_mirth_token_Token_allocZ_noneZBang();
	VAL v43 = pop_value();
	incref(v43);
	void* v44 = mfld_mirth_module_Module_ZTildeend(VU64(v43));
	mut_set(MKU64(v42), MKPTR(v44));
	uint64_t v45 = pop_u64();
	push_value(v43);
	uint64_t v46 = mw_mirth_token_Token_succ(v45);
	VAL v47 = pop_value();
	incref(v47);
	void* v48 = mfld_mirth_module_Module_ZTildestart(VU64(v47));
	mut_set(MKU64(v46), MKPTR(v48));
	push_value(v47);
}
static void mw_mirth_lexer_ZPlusLexer_doneZAsk (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[6]));
	mw_std_input_ZPlusInput_doneZAsk(v0);
	VAL r1 = pop_resource();
	VTUP(x1)->cells[6] = r1;
	push_resource(x1);
}
static void mw_mirth_lexer_lexerZ_makeZBang (VAL x1, VAL x2) {
	push_value(x1);
	push_resource(x2);
	uint64_t v0 = mw_mirth_token_Token_allocZBang();
	VAL v1 = pop_value();
	void* v2 = mfld_mirth_token_Token_ZTildevalue(v0);
	mut_set(v1, MKPTR(v2));
	VAL r3 = pop_resource();
	uint64_t v4 = VU64(VTUP(r3)->cells[1]);
	void* v5 = mfld_mirth_token_Token_ZTildemodule(v0);
	mut_set(MKU64(v4), MKPTR(v5));
	int64_t v6 = VI64(VTUP(r3)->cells[2]);
	void* v7 = mfld_mirth_token_Token_ZTilderow(v0);
	mut_set(MKI64(v6), MKPTR(v7));
	int64_t v8 = VI64(VTUP(r3)->cells[3]);
	void* v9 = mfld_mirth_token_Token_ZTildecol(v0);
	mut_set(MKI64(v8), MKPTR(v9));
	VTUP(r3)->cells[5] = MKU64(v0);
	push_u64(v0);
	push_resource(r3);
}
static VAL mw_mirth_lexer_lexerZ_emitZBang (VAL x1, VAL x2) {
	mw_mirth_lexer_lexerZ_makeZBang(x1, x2);
	uint64_t v0 = pop_u64();
	VAL r1 = pop_resource();
	return r1;
}
static void mw_mirth_lexer_lexerZ_nextZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_lexer_lexerZ_peek(x2);
	int64_t v0 = pop_i64();
	switch (v0) {
		case 10LL: { // BLF
			VAL r1 = pop_resource();
			VAL v2 = (mw_mirth_lexer_lexerZ_newlineZBang(r1));
			VAL v3 = (mw_mirth_lexer_lexerZ_moveZBang(v2));
			push_resource(v3);
		} break;
		case 32LL: { // BSPACE
			VAL r4 = pop_resource();
			VAL v5 = (mw_mirth_lexer_lexerZ_moveZBang(r4));
			push_resource(v5);
		} break;
		case 9LL: { // BHT
			VAL r6 = pop_resource();
			VAL v7 = (mw_mirth_lexer_lexerZ_moveZBang(r6));
			push_resource(v7);
		} break;
		case 11LL: { // BVT
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_lexer_lexerZ_moveZBang(r8));
			push_resource(v9);
		} break;
		case 13LL: { // BCR
			VAL r10 = pop_resource();
			VAL v11 = (mw_mirth_lexer_lexerZ_moveZBang(r10));
			push_resource(v11);
		} break;
		case 35LL: { // BHASH
			VAL r12 = pop_resource();
			VAL v13 = (mw_mirth_lexer_lexerZ_skipZ_commentZBang(r12));
			VAL v14 = (mw_mirth_lexer_lexerZ_moveZBang(v13));
			push_resource(v14);
		} break;
		case 44LL: { // BCOMMA
			VAL r15 = pop_resource();
			VAL v16 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(r15));
			int64_t v17 = 1LL /* TokenComma */;
			VAL v18 = (mw_mirth_lexer_lexerZ_emitZBang(MKI64(v17), v16));
			VAL v19 = (mw_mirth_lexer_lexerZ_moveZBang(v18));
			push_resource(v19);
		} break;
		case 41LL: { // BRPAREN
			VAL r20 = pop_resource();
			VAL v21 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(r20));
			VAL r22 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_rparenZBang(r22, v21);
			VAL r23 = pop_resource();
			VAL v24 = (mw_mirth_lexer_lexerZ_moveZBang(r23));
			push_resource(v24);
		} break;
		case 93LL: { // BRSQUARE
			VAL r25 = pop_resource();
			VAL v26 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(r25));
			VAL r27 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_rsquareZBang(r27, v26);
			VAL r28 = pop_resource();
			VAL v29 = (mw_mirth_lexer_lexerZ_moveZBang(r28));
			push_resource(v29);
		} break;
		case 125LL: { // BRCURLY
			VAL r30 = pop_resource();
			VAL v31 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(r30));
			VAL r32 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang(r32, v31);
			VAL r33 = pop_resource();
			VAL v34 = (mw_mirth_lexer_lexerZ_moveZBang(r33));
			push_resource(v34);
		} break;
		case 58LL: { // BCOLON
			VAL r35 = pop_resource();
			VAL v36 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang(r35));
			VAL v37 = (mw_mirth_lexer_lexerZ_emitZ_lcolonZBang(v36));
			VAL v38 = (mw_mirth_lexer_lexerZ_moveZBang(v37));
			push_resource(v38);
		} break;
		case 40LL: { // BLPAREN
			VAL r39 = pop_resource();
			VAL v40 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang(r39));
			VAL v41 = (mw_mirth_lexer_lexerZ_emitZ_lparenZBang(v40));
			VAL v42 = (mw_mirth_lexer_lexerZ_moveZBang(v41));
			push_resource(v42);
		} break;
		case 91LL: { // BLSQUARE
			VAL r43 = pop_resource();
			VAL v44 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(r43));
			VAL v45 = (mw_mirth_lexer_lexerZ_emitZ_lsquareZBang(v44));
			VAL v46 = (mw_mirth_lexer_lexerZ_moveZBang(v45));
			push_resource(v46);
		} break;
		case 123LL: { // BLCURLY
			VAL r47 = pop_resource();
			VAL v48 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(r47));
			VAL v49 = (mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang(v48));
			VAL v50 = (mw_mirth_lexer_lexerZ_moveZBang(v49));
			push_resource(v50);
		} break;
		case 34LL: { // BQUOTE
			VAL r51 = pop_resource();
			VAL v52 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(r51));
			VAL r53 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_stringZBang(r53, v52);
			VAL r54 = pop_resource();
			VAL v55 = (mw_mirth_lexer_lexerZ_moveZBang(r54));
			push_resource(v55);
		} break;
		default: {
			int64_t v56 = mw_std_byte_Byte_isZ_nameZ_byte(v0);
			if (((bool)v56)) {
				VAL r57 = pop_resource();
				VAL v58 = (mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang(r57));
				VAL v59 = (mw_mirth_lexer_lexerZ_emitZ_nameZBang(v58));
				push_resource(v59);
			} else {
				STR* v60;
				STRLIT(v60, "Unrecognized byte.", 18);
				VAL r61 = pop_resource();
				VAL r62 = pop_resource();
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v60), r62, r61);
			}
		} break;
	}
}
static VAL mw_mirth_lexer_lexerZ_newlineZBang (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[2]);
	push_resource(x1);
	int64_t v1 = mw_mirth_location_Row_ZToInt(v0);
	int64_t v2 = 1LL;
	int64_t v3 = i64_add(v1, v2);
	int64_t v4 = mw_std_prim_Int_ZToRow(v3);
	VAL r5 = pop_resource();
	VTUP(r5)->cells[2] = MKI64(v4);
	int64_t v6 = 0LL;
	push_resource(r5);
	int64_t v7 = mw_std_prim_Int_ZToCol(v6);
	VAL r8 = pop_resource();
	VTUP(r8)->cells[3] = MKI64(v7);
	return r8;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lcolonZBang (VAL x1) {
	int64_t v0 = 5LL /* TokenLColonOpen */;
	mw_mirth_lexer_lexerZ_makeZBang(MKI64(v0), x1);
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v2, r1));
	return v3;
}
static VAL mw_mirth_lexer_lexerZ_closeZ_colonsZBang (VAL x1) {
	mw_mirth_lexer_lexerZ_stackZ_peek(x1);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			incref(v1);
			int64_t v2 = mw_mirth_token_Token_lcolonZ_openZAsk(VU64(v1));
			if (((bool)v2)) {
				VAL v3 = mtw_std_maybe_Maybe_1_Some(v1);
				push_value(v3);
			} else {
				decref(v1);
				int64_t v4 = 0LL /* None */;
				push_i64(v4);
			}
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL r10 = pop_resource();
		push_value(v9);
		VAL v11 = (mw_mirth_lexer_lexerZ_stackZ_drop(r10));
		uint64_t v12 = pop_u64();
		push_resource(v11);
		push_u64(v12);
		VAL v13 = mtw_mirth_token_TokenValue_TokenRColon(v12);
		VAL r14 = pop_resource();
		mw_mirth_lexer_lexerZ_makeZBang(v13, r14);
		uint64_t v15 = pop_u64();
		VAL v16 = mtw_mirth_token_TokenValue_TokenLColon(v15);
		uint64_t v17 = pop_u64();
		void* v18 = mfld_mirth_token_Token_ZTildevalue(v17);
		mut_set(v16, MKPTR(v18));
		VAL r19 = pop_resource();
		mw_mirth_lexer_lexerZ_stackZ_peek(r19);
		VAL v20 = pop_value();
		switch (get_data_tag(v20)) {
			case 1LL: { // Some
				VAL v21 = mtp_std_maybe_Maybe_1_Some(v20);
				incref(v21);
				int64_t v22 = mw_mirth_token_Token_lcolonZ_openZAsk(VU64(v21));
				if (((bool)v22)) {
					VAL v23 = mtw_std_maybe_Maybe_1_Some(v21);
					push_value(v23);
				} else {
					decref(v21);
					int64_t v24 = 0LL /* None */;
					push_i64(v24);
				}
			} break;
			case 0LL: { // None
				int64_t v25 = 0LL /* None */;
				push_i64(v25);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
	VAL v26 = pop_value();
	decref(v26);
	VAL r27 = pop_resource();
	return r27;
}
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang (VAL x1) {
	uint64_t v0 = VU64(VTUP(x1)->cells[5]);
	push_resource(x1);
	int64_t v1 = mw_mirth_token_Token_lcolonZ_openZAsk(v0);
	if (((bool)v1)) {
	} else {
		VAL r2 = pop_resource();
		VAL v3 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(r2));
		push_resource(v3);
	}
	VAL r4 = pop_resource();
	return r4;
}
static VAL mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang (VAL x1) {
	uint64_t v0 = VU64(VTUP(x1)->cells[5]);
	push_resource(x1);
	VAL v1 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			decref(v2);
		} break;
		case 0LL: { // None
			VAL r3 = pop_resource();
			VAL v4 = (mw_mirth_lexer_lexerZ_closeZ_colonsZBang(r3));
			push_resource(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r5 = pop_resource();
	return r5;
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lparenZBang (VAL x1) {
	int64_t v0 = 2LL /* TokenLParenOpen */;
	mw_mirth_lexer_lexerZ_makeZBang(MKI64(v0), x1);
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v2, r1));
	return v3;
}
static void mw_mirth_lexer_lexerZ_emitZ_rparenZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			STR* v1;
			STRLIT(v1, "Mismatched right parenthesis.", 29);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v1), r3, r2);
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v0);
			incref(v4);
			push_value(v4);
			int64_t v5 = mw_mirth_token_Token_lparenZ_openZAsk(VU64(v4));
			if (((bool)v5)) {
				uint64_t v6 = pop_u64();
				push_u64(v6);
				VAL v7 = mtw_mirth_token_TokenValue_TokenRParen(v6);
				VAL r8 = pop_resource();
				mw_mirth_lexer_lexerZ_makeZBang(v7, r8);
				uint64_t v9 = pop_u64();
				VAL v10 = mtw_mirth_token_TokenValue_TokenLParen(v9);
				uint64_t v11 = pop_u64();
				void* v12 = mfld_mirth_token_Token_ZTildevalue(v11);
				mut_set(v10, MKPTR(v12));
			} else {
				STR* v13;
				STRLIT(v13, "Mismatched right parenthesis.", 29);
				VAL r14 = pop_resource();
				VAL r15 = pop_resource();
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v13), r15, r14);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lsquareZBang (VAL x1) {
	int64_t v0 = 3LL /* TokenLSquareOpen */;
	mw_mirth_lexer_lexerZ_makeZBang(MKI64(v0), x1);
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v2, r1));
	return v3;
}
static void mw_mirth_lexer_lexerZ_emitZ_rsquareZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			STR* v1;
			STRLIT(v1, "Mismatched right square bracket.", 32);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v1), r3, r2);
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v0);
			incref(v4);
			push_value(v4);
			int64_t v5 = mw_mirth_token_Token_lsquareZ_openZAsk(VU64(v4));
			if (((bool)v5)) {
				uint64_t v6 = pop_u64();
				push_u64(v6);
				VAL v7 = mtw_mirth_token_TokenValue_TokenRSquare(v6);
				VAL r8 = pop_resource();
				mw_mirth_lexer_lexerZ_makeZBang(v7, r8);
				uint64_t v9 = pop_u64();
				VAL v10 = mtw_mirth_token_TokenValue_TokenLSquare(v9);
				uint64_t v11 = pop_u64();
				void* v12 = mfld_mirth_token_Token_ZTildevalue(v11);
				mut_set(v10, MKPTR(v12));
			} else {
				STR* v13;
				STRLIT(v13, "Mismatched right square bracket.", 32);
				VAL r14 = pop_resource();
				VAL r15 = pop_resource();
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v13), r15, r14);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang (VAL x1) {
	int64_t v0 = 4LL /* TokenLCurlyOpen */;
	mw_mirth_lexer_lexerZ_makeZBang(MKI64(v0), x1);
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = (mw_mirth_lexer_lexerZ_stackZ_pushZBang(v2, r1));
	return v3;
}
static void mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_lexer_lexerZ_stackZ_popZBang(x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			STR* v1;
			STRLIT(v1, "Mismatched right curly brace.", 29);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v1), r3, r2);
		} break;
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v0);
			incref(v4);
			push_value(v4);
			int64_t v5 = mw_mirth_token_Token_lcurlyZ_openZAsk(VU64(v4));
			if (((bool)v5)) {
				uint64_t v6 = pop_u64();
				push_u64(v6);
				VAL v7 = mtw_mirth_token_TokenValue_TokenRCurly(v6);
				VAL r8 = pop_resource();
				mw_mirth_lexer_lexerZ_makeZBang(v7, r8);
				uint64_t v9 = pop_u64();
				VAL v10 = mtw_mirth_token_TokenValue_TokenLCurly(v9);
				uint64_t v11 = pop_u64();
				void* v12 = mfld_mirth_token_Token_ZTildevalue(v11);
				mut_set(v10, MKPTR(v12));
			} else {
				STR* v13;
				STRLIT(v13, "Mismatched right curly brace.", 29);
				VAL r14 = pop_resource();
				VAL r15 = pop_resource();
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v13), r15, r14);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_lexer_lexerZ_emitZ_nameZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "", 0);
	uint64_t v1 = VU64(VTUP(x1)->cells[1]);
	int64_t v2 = VI64(VTUP(x1)->cells[2]);
	int64_t v3 = VI64(VTUP(x1)->cells[3]);
	push_resource(MKSTR(v0));
	push_u64(v1);
	push_i64(v2);
	push_i64(v3);
	mw_mirth_lexer_lexerZ_peek(x1);
	while(1) {
		int64_t v4 = pop_i64();
		push_i64(v4);
		int64_t v5 = mw_std_byte_Byte_isZ_nameZ_byte(v4);
		if (!((bool)v5)) break;
		VAL r6 = pop_resource();
		VAL r7 = pop_resource();
		int64_t v8 = pop_i64();
		VAL v9 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(v8, r7));
		push_resource(v9);
		VAL v10 = (mw_mirth_lexer_lexerZ_moveZBang(r6));
		mw_mirth_lexer_lexerZ_peek(v10);
	}
	int64_t v11 = pop_i64();
	VAL r12 = pop_resource();
	VAL r13 = pop_resource();
	mw_std_str_ZPlusStr_isZ_docZ_startZAsk(r13);
	bool v14 = pop_bool();
	if (v14) {
		VAL v15 = pop_value();
		decref(v15);
		VAL v16 = pop_value();
		decref(v16);
		VAL v17 = pop_value();
		decref(v17);
		VAL v18 = (mw_mirth_lexer_lexerZ_skipZ_docZBang(r12));
		push_resource(v18);
	} else {
		VAL r19 = pop_resource();
		mw_std_str_ZPlusStr_isZ_floatZAsk(r19);
		bool v20 = pop_bool();
		if (v20) {
			VAL r21 = pop_resource();
			mw_std_str_ZPlusStr_floatZAsk(r21);
			double v22 = pop_f64();
			VAL v23 = mtw_mirth_token_TokenValue_TokenF64(v22);
			push_value(v23);
		} else {
			VAL r24 = pop_resource();
			mw_std_str_ZPlusStr_isZ_intZAsk(r24);
			bool v25 = pop_bool();
			if (v25) {
				VAL r26 = pop_resource();
				mw_std_str_ZPlusStr_intZAsk(r26);
				int64_t v27 = pop_i64();
				VAL v28 = mtw_mirth_token_TokenValue_TokenInt(v27);
				push_value(v28);
			} else {
				VAL r29 = pop_resource();
				mw_std_str_ZPlusStr_dnameZAsk(r29);
				VAL v30 = pop_value();
				switch (get_data_tag(v30)) {
					case 1LL: { // Some
						VAL v31 = mtp_std_maybe_Maybe_1_Some(v30);
						VAL v32 = mtw_mirth_token_TokenValue_TokenDName(v31);
						push_value(v32);
					} break;
					case 0LL: { // None
						VAL r33 = pop_resource();
						mw_std_str_ZPlusStr_labelZ_tokenZAsk(r33);
						VAL v34 = pop_value();
						switch (get_data_tag(v34)) {
							case 1LL: { // Some
								VAL v35 = mtp_std_maybe_Maybe_1_Some(v34);
								push_value(v35);
							} break;
							case 0LL: { // None
								VAL r36 = pop_resource();
								mw_std_str_ZPlusStr_nameZAsk(r36);
								uint64_t v37 = pop_u64();
								VAL v38 = mtw_mirth_token_TokenValue_TokenName(v37);
								push_value(v38);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
			}
		}
		push_resource(r12);
		uint64_t v39 = mw_mirth_token_Token_allocZBang();
		VAL v40 = pop_value();
		void* v41 = mfld_mirth_token_Token_ZTildevalue(v39);
		mut_set(v40, MKPTR(v41));
		VAL v42 = pop_value();
		void* v43 = mfld_mirth_token_Token_ZTildecol(v39);
		mut_set(v42, MKPTR(v43));
		VAL v44 = pop_value();
		void* v45 = mfld_mirth_token_Token_ZTilderow(v39);
		mut_set(v44, MKPTR(v45));
		VAL v46 = pop_value();
		void* v47 = mfld_mirth_token_Token_ZTildemodule(v39);
		mut_set(v46, MKPTR(v47));
		VAL r48 = pop_resource();
		VTUP(r48)->cells[5] = MKU64(v39);
		push_resource(r48);
	}
	VAL r49 = pop_resource();
	VAL r50 = pop_resource();
	decref(r50);
	return r49;
}
static void mw_std_str_ZPlusStr_nameZAsk (VAL x1) {
	mw_std_str_ZPlusStr_dupZBang(x1);
	VAL v0 = pop_value();
	uint64_t v1 = mw_std_prim_Str_ZToName(v0);
	push_u64(v1);
}
static void mw_std_str_ZPlusStr_firstZ_byte (VAL x1) {
	int64_t v0 = 0LL;
	mw_std_str_ZPlusStr_byteZAt(v0, x1);
}
static void mw_std_str_ZPlusStr_secondZ_byte (VAL x1) {
	int64_t v0 = 1LL;
	mw_std_str_ZPlusStr_byteZAt(v0, x1);
}
static void mw_std_str_ZPlusStr_thirdZ_byte (VAL x1) {
	int64_t v0 = 2LL;
	mw_std_str_ZPlusStr_byteZAt(v0, x1);
}
static void mw_std_str_ZPlusStr_firstZ_twoZ_bytes (VAL x1, VAL x2) {
	int64_t v0 = 2LL;
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	mw_std_str_ZPlusStr_takeZ_slice(v1, r3, r2);
}
static void mw_std_str_ZPlusStr_dropZ_firstZ_byte (VAL x1, VAL x2) {
	int64_t v0 = 1LL;
	mw_std_str_ZPlusStr_dropZ_slice(v0, x1, x2);
}
static void mw_std_str_ZPlusStr_dropZ_lastZ_byte (VAL x1, VAL x2) {
	mw_std_str_ZPlusStr_numZ_bytesZAsk(x1);
	int64_t v0 = 1LL;
	int64_t v1 = pop_i64();
	bool v2 = (v1 > v0);
	if (v2) {
		VAL r3 = pop_resource();
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r3);
		int64_t v4 = 1LL;
		int64_t v5 = pop_i64();
		int64_t v6 = i64_sub(v5, v4);
		push_resource(x2);
		int64_t v7 = mw_std_prim_Int_ZToNat(v6);
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_std_str_ZPlusStr_takeZ_slice(v7, r9, r8);
	} else {
		STR* v10;
		STRLIT(v10, "", 0);
		push_resource(x2);
		push_str(v10);
	}
}
static void mw_std_str_ZPlusStr_labelZ_tokenZAsk (VAL x1) {
	mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk(x1);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mtw_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			VAL r3 = pop_resource();
			mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk(r3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v4);
			VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
			push_value(v6);
		} break;
		case 0LL: { // None
			VAL r7 = pop_resource();
			mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk(r7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v8 = pop_value();
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v8);
			VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
			push_value(v10);
		} break;
		case 0LL: { // None
			VAL r11 = pop_resource();
			mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk(r11);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v12 = pop_value();
	switch (get_data_tag(v12)) {
		case 1LL: { // Some
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v12);
			VAL v14 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		case 0LL: { // None
			VAL r15 = pop_resource();
			mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk(r15);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v16 = pop_value();
	switch (get_data_tag(v16)) {
		case 1LL: { // Some
			VAL v17 = mtp_std_maybe_Maybe_1_Some(v16);
			VAL v18 = mtw_std_maybe_Maybe_1_Some(v17);
			push_value(v18);
		} break;
		case 0LL: { // None
			VAL r19 = pop_resource();
			mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk(r19);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk (VAL x1) {
	mw_std_str_ZPlusStr_firstZ_byte(x1);
	int64_t v0 = pop_i64();
	int64_t v1 = mw_std_byte_Byte_isZ_lower(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		mw_std_str_ZPlusStr_lastZ_byte(r2);
		int64_t v3 = 62LL /* B'>' */;
		int64_t v4 = pop_i64();
		bool v5 = (v4 == v3);
		push_bool(v5);
	} else {
		int64_t v6 = 0LL /* False */;
		push_i64(v6);
	}
	bool v7 = pop_bool();
	if (v7) {
		int64_t v8 = (0LL /* +Unsafe */);
		VAL r9 = pop_resource();
		mw_std_str_ZPlusStr_dropZ_lastZ_byte(r9, MKI64(v8));
		VAL r10 = pop_resource();
		VAL v11 = pop_value();
		uint64_t v12 = mw_std_prim_Str_ZToName(v11);
		uint64_t v13 = mw_mirth_label_Label_newZBang(v12);
		VAL v14 = mtw_mirth_token_TokenValue_TokenLabelPop(v13);
		VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
		push_value(v15);
	} else {
		int64_t v16 = 0LL /* None */;
		push_i64(v16);
	}
}
static void mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk (VAL x1) {
	mw_std_str_ZPlusStr_firstZ_byte(x1);
	int64_t v0 = 43LL /* B'+' */;
	int64_t v1 = pop_i64();
	bool v2 = (v1 == v0);
	if (v2) {
		VAL r3 = pop_resource();
		mw_std_str_ZPlusStr_secondZ_byte(r3);
		int64_t v4 = pop_i64();
		int64_t v5 = mw_std_byte_Byte_isZ_lower(v4);
		if (((bool)v5)) {
			VAL r6 = pop_resource();
			mw_std_str_ZPlusStr_lastZ_byte(r6);
			int64_t v7 = 62LL /* B'>' */;
			int64_t v8 = pop_i64();
			bool v9 = (v8 == v7);
			push_bool(v9);
		} else {
			int64_t v10 = 0LL /* False */;
			push_i64(v10);
		}
	} else {
		int64_t v11 = 0LL /* False */;
		push_i64(v11);
	}
	bool v12 = pop_bool();
	if (v12) {
		int64_t v13 = (0LL /* +Unsafe */);
		VAL r14 = pop_resource();
		mw_std_str_ZPlusStr_dropZ_lastZ_byte(r14, MKI64(v13));
		VAL r15 = pop_resource();
		VAL v16 = pop_value();
		uint64_t v17 = mw_std_prim_Str_ZToName(v16);
		uint64_t v18 = mw_mirth_label_Label_newZBang(v17);
		VAL v19 = mtw_mirth_token_TokenValue_TokenLabelPopR(v18);
		VAL v20 = mtw_std_maybe_Maybe_1_Some(v19);
		push_value(v20);
	} else {
		int64_t v21 = 0LL /* None */;
		push_i64(v21);
	}
}
static void mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk (VAL x1) {
	mw_std_str_ZPlusStr_firstZ_byte(x1);
	int64_t v0 = 62LL /* B'>' */;
	int64_t v1 = pop_i64();
	bool v2 = (v1 == v0);
	if (v2) {
		VAL r3 = pop_resource();
		mw_std_str_ZPlusStr_secondZ_byte(r3);
		int64_t v4 = pop_i64();
		int64_t v5 = mw_std_byte_Byte_isZ_lower(v4);
		push_i64(v5);
	} else {
		int64_t v6 = 0LL /* False */;
		push_i64(v6);
	}
	bool v7 = pop_bool();
	if (v7) {
		int64_t v8 = (0LL /* +Unsafe */);
		VAL r9 = pop_resource();
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(r9, MKI64(v8));
		VAL r10 = pop_resource();
		VAL v11 = pop_value();
		uint64_t v12 = mw_std_prim_Str_ZToName(v11);
		uint64_t v13 = mw_mirth_label_Label_newZBang(v12);
		VAL v14 = mtw_mirth_token_TokenValue_TokenLabelPush(v13);
		VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
		push_value(v15);
	} else {
		int64_t v16 = 0LL /* None */;
		push_i64(v16);
	}
}
static void mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk (VAL x1) {
	int64_t v0 = (0LL /* +Unsafe */);
	mw_std_str_ZPlusStr_firstZ_twoZ_bytes(x1, MKI64(v0));
	VAL r1 = pop_resource();
	STR* v2;
	STRLIT(v2, ">+", 2);
	STR* v3 = pop_str();
	bool v4 = (str_cmp(v3, v2) == 0);
	if (v4) {
		VAL r5 = pop_resource();
		mw_std_str_ZPlusStr_thirdZ_byte(r5);
		int64_t v6 = pop_i64();
		int64_t v7 = mw_std_byte_Byte_isZ_lower(v6);
		push_i64(v7);
	} else {
		int64_t v8 = 0LL /* False */;
		push_i64(v8);
	}
	bool v9 = pop_bool();
	if (v9) {
		int64_t v10 = (0LL /* +Unsafe */);
		VAL r11 = pop_resource();
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(r11, MKI64(v10));
		VAL r12 = pop_resource();
		VAL v13 = pop_value();
		uint64_t v14 = mw_std_prim_Str_ZToName(v13);
		uint64_t v15 = mw_mirth_label_Label_newZBang(v14);
		VAL v16 = mtw_mirth_token_TokenValue_TokenLabelPushR(v15);
		VAL v17 = mtw_std_maybe_Maybe_1_Some(v16);
		push_value(v17);
	} else {
		int64_t v18 = 0LL /* None */;
		push_i64(v18);
	}
}
static void mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk (VAL x1) {
	mw_std_str_ZPlusStr_firstZ_byte(x1);
	int64_t v0 = 64LL /* B'@' */;
	int64_t v1 = pop_i64();
	bool v2 = (v1 == v0);
	if (v2) {
		VAL r3 = pop_resource();
		mw_std_str_ZPlusStr_secondZ_byte(r3);
		int64_t v4 = pop_i64();
		int64_t v5 = mw_std_byte_Byte_isZ_lower(v4);
		if (((bool)v5)) {
			int64_t v6 = 1LL /* True */;
			push_i64(v6);
		} else {
			VAL r7 = pop_resource();
			mw_std_str_ZPlusStr_secondZ_byte(r7);
			int64_t v8 = 43LL /* B'+' */;
			int64_t v9 = pop_i64();
			bool v10 = (v9 == v8);
			if (v10) {
				VAL r11 = pop_resource();
				mw_std_str_ZPlusStr_thirdZ_byte(r11);
				int64_t v12 = pop_i64();
				int64_t v13 = mw_std_byte_Byte_isZ_lower(v12);
				push_i64(v13);
			} else {
				int64_t v14 = 0LL /* False */;
				push_i64(v14);
			}
		}
	} else {
		int64_t v15 = 0LL /* False */;
		push_i64(v15);
	}
	bool v16 = pop_bool();
	if (v16) {
		int64_t v17 = (0LL /* +Unsafe */);
		VAL r18 = pop_resource();
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(r18, MKI64(v17));
		VAL r19 = pop_resource();
		VAL v20 = pop_value();
		uint64_t v21 = mw_std_prim_Str_ZToName(v20);
		uint64_t v22 = mw_mirth_label_Label_newZBang(v21);
		VAL v23 = mtw_mirth_token_TokenValue_TokenLabelGet(v22);
		VAL v24 = mtw_std_maybe_Maybe_1_Some(v23);
		push_value(v24);
	} else {
		int64_t v25 = 0LL /* None */;
		push_i64(v25);
	}
}
static void mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk (VAL x1) {
	mw_std_str_ZPlusStr_firstZ_byte(x1);
	int64_t v0 = 33LL /* B'!' */;
	int64_t v1 = pop_i64();
	bool v2 = (v1 == v0);
	if (v2) {
		VAL r3 = pop_resource();
		mw_std_str_ZPlusStr_secondZ_byte(r3);
		int64_t v4 = pop_i64();
		int64_t v5 = mw_std_byte_Byte_isZ_lower(v4);
		push_i64(v5);
	} else {
		int64_t v6 = 0LL /* False */;
		push_i64(v6);
	}
	bool v7 = pop_bool();
	if (v7) {
		int64_t v8 = (0LL /* +Unsafe */);
		VAL r9 = pop_resource();
		mw_std_str_ZPlusStr_dropZ_firstZ_byte(r9, MKI64(v8));
		VAL r10 = pop_resource();
		VAL v11 = pop_value();
		uint64_t v12 = mw_std_prim_Str_ZToName(v11);
		uint64_t v13 = mw_mirth_label_Label_newZBang(v12);
		VAL v14 = mtw_mirth_token_TokenValue_TokenLabelSet(v13);
		VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
		push_value(v15);
	} else {
		int64_t v16 = 0LL /* None */;
		push_i64(v16);
	}
}
static void mw_std_str_ZPlusStr_dnameZAsk (VAL x1) {
	int64_t v0 = 46LL /* BDOT */;
	mw_std_str_ZPlusStr_splitZ_byte(v0, x1);
	VAL v1 = pop_value();
	mw_std_list_ListZPlus_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = mw_std_list_List_1_ZToListZPlus(v2);
	switch (get_data_tag(v3)) {
		case 0LL: { // None
			VAL v4 = pop_value();
			decref(v4);
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v7 = pop_value();
			incref(v7);
			uint64_t v8 = str_size(VSTR(v7));
			push_value(v7);
			int64_t v9 = mw_std_prim_Int_ZToNat(((int64_t)v8));
			int64_t v10 = 0LL;
			bool v11 = (v9 == v10);
			if (v11) {
				VAL v12 = pop_value();
				decref(v12);
				int64_t v13 = 0LL /* None */;
				push_i64(v13);
			} else {
				VAL v14 = pop_value();
				uint64_t v15 = mw_std_prim_Str_ZToName(v14);
				VAL v16 = mtw_std_maybe_Maybe_1_Some(MKU64(v15));
				push_value(v16);
			}
			int64_t v17 = 0LL /* Nil */;
			push_value(v6);
			VAL v18 = mw_std_list_List_1_reverse(MKI64(v17));
			VAL v19 = pop_value();
			push_resource(v18);
			mw_std_list_List_1_uncons(v19);
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			push_value(v20);
			push_value(v21);
			while(1) {
				VAL v22 = pop_value();
				incref(v22);
				push_value(v22);
				int64_t v23 = mw_std_maybe_Maybe_1_someZAsk(v22);
				if (!((bool)v23)) break;
				VAL v24 = pop_value();
				VAL v25 = mw_std_maybe_Maybe_1_unwrap(v24);
				VAL v26 = pop_value();
				VAL r27 = pop_resource();
				uint64_t v28 = mw_std_prim_Str_ZToName(v25);
				VAL v29 = mtw_std_list_List_1_Cons(MKU64(v28), r27);
				push_resource(v29);
				mw_std_list_List_1_uncons(v26);
				VAL v30 = pop_value();
				VAL v31 = pop_value();
				push_value(v30);
				push_value(v31);
			}
			VAL v32 = pop_value();
			decref(v32);
			VAL v33 = pop_value();
			decref(v33);
			VAL r34 = pop_resource();
			VAL v35 = mw_std_list_List_1_reverse(r34);
			VAL v36 = pop_value();
			VAL v37 = mtw_mirth_name_DName_DName(v36, v35);
			VAL v38 = mtw_std_maybe_Maybe_1_Some(v37);
			push_value(v38);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_std_str_ZPlusStr_isZ_docZ_startZAsk (VAL x1) {
	mw_std_str_ZPlusStr_dupZBang(x1);
	STR* v0;
	STRLIT(v0, "|||", 3);
	STR* v1 = pop_str();
	bool v2 = (str_cmp(v1, v0) == 0);
	push_bool(v2);
}
static void mw_std_str_ZPlusStr_isZ_floatZAsk (VAL x1) {
	int64_t v0 = 0LL;
	push_resource(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = 0LL;
	VAL r3 = pop_resource();
	push_i64(v1);
	push_i64(v2);
	mw_std_str_ZPlusStr_byteZAt(v2, r3);
	int64_t v4 = pop_i64();
	int64_t v5 = mw_std_byte_Byte_isZ_sign(v4);
	if (((bool)v5)) {
		int64_t v6 = 1LL;
		int64_t v7 = pop_i64();
		int64_t v8 = i64_add(v7, v6);
		push_i64(v8);
	} else {
	}
	while(1) {
		int64_t v9 = pop_i64();
		VAL r10 = pop_resource();
		push_i64(v9);
		mw_std_str_ZPlusStr_byteZAt(v9, r10);
		int64_t v11 = pop_i64();
		int64_t v12 = mw_std_byte_Byte_isZ_digit(v11);
		if (!((bool)v12)) break;
		int64_t v13 = pop_i64();
		int64_t v14 = 1LL;
		int64_t v15 = pop_i64();
		int64_t v16 = i64_add(v15, v14);
		int64_t v17 = 1LL;
		int64_t v18 = i64_add(v13, v17);
		push_i64(v16);
		push_i64(v18);
	}
	int64_t v19 = pop_i64();
	VAL r20 = pop_resource();
	push_i64(v19);
	mw_std_str_ZPlusStr_byteZAt(v19, r20);
	int64_t v21 = 46LL /* BDOT */;
	int64_t v22 = pop_i64();
	bool v23 = (v22 == v21);
	if (v23) {
		int64_t v24 = pop_i64();
		int64_t v25 = 1LL;
		int64_t v26 = pop_i64();
		int64_t v27 = i64_add(v26, v25);
		int64_t v28 = 1LL;
		int64_t v29 = i64_add(v24, v28);
		push_i64(v27);
		push_i64(v29);
		while(1) {
			int64_t v30 = pop_i64();
			VAL r31 = pop_resource();
			push_i64(v30);
			mw_std_str_ZPlusStr_byteZAt(v30, r31);
			int64_t v32 = pop_i64();
			int64_t v33 = mw_std_byte_Byte_isZ_digit(v32);
			if (!((bool)v33)) break;
			int64_t v34 = pop_i64();
			int64_t v35 = 1LL;
			int64_t v36 = pop_i64();
			int64_t v37 = i64_add(v36, v35);
			int64_t v38 = 1LL;
			int64_t v39 = i64_add(v34, v38);
			push_i64(v37);
			push_i64(v39);
		}
		int64_t v40 = pop_i64();
		int64_t v41 = pop_i64();
		int64_t v42 = 3LL;
		bool v43 = (v41 >= v42);
		if (v43) {
			VAL r44 = pop_resource();
			push_i64(v40);
			mw_std_str_ZPlusStr_numZ_bytesZAsk(r44);
			int64_t v45 = pop_i64();
			int64_t v46 = pop_i64();
			bool v47 = (v46 == v45);
			push_bool(v47);
		} else {
			int64_t v48 = 0LL /* False */;
			push_i64(v48);
		}
	} else {
		VAL v49 = pop_value();
		decref(v49);
		VAL v50 = pop_value();
		decref(v50);
		int64_t v51 = 0LL /* False */;
		push_i64(v51);
	}
}
static void mw_std_str_ZPlusStr_floatZ_sign (VAL x1) {
	int64_t v0 = 0LL;
	mw_std_str_ZPlusStr_byteZAt(v0, x1);
	int64_t v1 = pop_i64();
	mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float(v1);
}
static void mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float (int64_t x1) {
	switch (x1) {
		case 45LL: { // B'-'
			int64_t v0 = 45LL /* B'-' */;
			int64_t v1 = 1LL;
			push_i64(v0);
			push_i64(v1);
		} break;
		case 43LL: { // B'+'
			int64_t v2 = 43LL /* B'+' */;
			int64_t v3 = 1LL;
			push_i64(v2);
			push_i64(v3);
		} break;
		default: {
			int64_t v4 = 43LL /* B'+' */;
			int64_t v5 = 0LL;
			push_i64(v4);
			push_i64(v5);
		} break;
	}
}
static void mw_std_str_ZPlusStr_floatZAsk (VAL x1) {
	STR* v0;
	STRLIT(v0, "", 0);
	int64_t v1 = 0LL;
	push_resource(MKSTR(v0));
	push_i64(v1);
	mw_std_str_ZPlusStr_floatZ_sign(x1);
	VAL r2 = pop_resource();
	int64_t v3 = pop_i64();
	VAL r4 = pop_resource();
	int64_t v5 = pop_i64();
	VAL v6 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v5, r4));
	int64_t v7 = pop_i64();
	int64_t v8 = i64_add(v7, v3);
	push_resource(v6);
	push_resource(r2);
	push_i64(v8);
	while(1) {
		int64_t v9 = pop_i64();
		VAL r10 = pop_resource();
		push_i64(v9);
		push_i64(v9);
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r10);
		int64_t v11 = pop_i64();
		int64_t v12 = pop_i64();
		bool v13 = (v12 < v11);
		if (!v13) break;
		int64_t v14 = pop_i64();
		VAL r15 = pop_resource();
		mw_std_str_ZPlusStr_byteZAt(v14, r15);
		VAL r16 = pop_resource();
		VAL r17 = pop_resource();
		int64_t v18 = pop_i64();
		VAL v19 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v18, r17));
		int64_t v20 = 1LL;
		int64_t v21 = i64_add(v14, v20);
		push_resource(v19);
		push_resource(r16);
		push_i64(v21);
	}
	int64_t v22 = pop_i64();
	VAL r23 = pop_resource();
	VAL r24 = pop_resource();
	incref(r24);
	incref(r24);
	void* v25 = str_base(VSTR(r24));
	uint64_t v26 = str_size(VSTR(r24));
	push_resource(r23);
	push_ptr(v25);
	int64_t v27 = mw_std_prim_Int_ZToNat(((int64_t)v26));
	VAL v28 = pop_value();
	incref(v28);
	int64_t v29 = (0LL /* +Unsafe */);
	void* v30 = (void*)(v27 + (char*)VPTR(v28));
	uint8_t v31 = *(uint8_t*)v30;
	int64_t v32 = 0LL;
	bool v33 = (((int64_t)v31) == v32);
	if (v33) {
		push_value(v28);
	} else {
		STR* v34;
		STRLIT(v34, "tried to use Str as CStr, but Str is not zero terminated", 56);
		push_value(v28);
		push_str(v34);
		do_panic();
	}
	mext_mirth_lexer_stringz_toz_float64();
	decref(r24);
}
static void mw_std_str_ZPlusStr_isZ_intZAsk (VAL x1) {
	mw_std_str_ZPlusStr_isZ_decZ_intZAsk(x1);
	bool v0 = pop_bool();
	if (v0) {
		int64_t v1 = 1LL /* True */;
		push_i64(v1);
	} else {
		VAL r2 = pop_resource();
		mw_std_str_ZPlusStr_isZ_hexZ_intZAsk(r2);
	}
	bool v3 = pop_bool();
	if (v3) {
		int64_t v4 = 1LL /* True */;
		push_i64(v4);
	} else {
		VAL r5 = pop_resource();
		mw_std_str_ZPlusStr_isZ_octZ_intZAsk(r5);
	}
}
static void mw_std_str_ZPlusStr_isZ_decZ_intZAsk (VAL x1) {
	int64_t v0 = 0LL;
	push_resource(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = 0LL;
	VAL r3 = pop_resource();
	push_i64(v1);
	push_i64(v2);
	mw_std_str_ZPlusStr_byteZAt(v2, r3);
	int64_t v4 = pop_i64();
	int64_t v5 = mw_std_byte_Byte_isZ_sign(v4);
	if (((bool)v5)) {
		int64_t v6 = 1LL;
		int64_t v7 = pop_i64();
		int64_t v8 = i64_add(v7, v6);
		push_i64(v8);
	} else {
	}
	while(1) {
		int64_t v9 = pop_i64();
		VAL r10 = pop_resource();
		push_i64(v9);
		mw_std_str_ZPlusStr_byteZAt(v9, r10);
		int64_t v11 = pop_i64();
		int64_t v12 = mw_std_byte_Byte_isZ_digit(v11);
		if (!((bool)v12)) break;
		int64_t v13 = pop_i64();
		int64_t v14 = 1LL;
		int64_t v15 = pop_i64();
		int64_t v16 = i64_add(v15, v14);
		int64_t v17 = 1LL;
		int64_t v18 = i64_add(v13, v17);
		push_i64(v16);
		push_i64(v18);
	}
	int64_t v19 = pop_i64();
	int64_t v20 = pop_i64();
	int64_t v21 = 0LL;
	bool v22 = (v20 > v21);
	if (v22) {
		VAL r23 = pop_resource();
		push_i64(v19);
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r23);
		int64_t v24 = pop_i64();
		int64_t v25 = pop_i64();
		bool v26 = (v25 == v24);
		push_bool(v26);
	} else {
		int64_t v27 = 0LL /* False */;
		push_i64(v27);
	}
}
static void mw_std_str_ZPlusStr_isZ_hexZ_intZAsk (VAL x1) {
	int64_t v0 = 0LL;
	push_resource(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = 0LL;
	VAL r3 = pop_resource();
	push_i64(v1);
	push_i64(v2);
	mw_std_str_ZPlusStr_byteZAt(v2, r3);
	int64_t v4 = pop_i64();
	int64_t v5 = mw_std_byte_Byte_isZ_sign(v4);
	if (((bool)v5)) {
		int64_t v6 = 1LL;
		int64_t v7 = pop_i64();
		int64_t v8 = i64_add(v7, v6);
		push_i64(v8);
	} else {
	}
	int64_t v9 = pop_i64();
	VAL r10 = pop_resource();
	push_i64(v9);
	mw_std_str_ZPlusStr_byteZAt(v9, r10);
	int64_t v11 = 48LL /* B'0' */;
	int64_t v12 = pop_i64();
	bool v13 = (v12 == v11);
	if (v13) {
		int64_t v14 = 1LL;
		int64_t v15 = pop_i64();
		int64_t v16 = i64_add(v15, v14);
		VAL r17 = pop_resource();
		push_i64(v16);
		mw_std_str_ZPlusStr_byteZAt(v16, r17);
		int64_t v18 = 120LL /* B'x' */;
		int64_t v19 = pop_i64();
		bool v20 = (v19 == v18);
		if (v20) {
			int64_t v21 = 1LL;
			int64_t v22 = pop_i64();
			int64_t v23 = i64_add(v22, v21);
			push_i64(v23);
			while(1) {
				int64_t v24 = pop_i64();
				VAL r25 = pop_resource();
				push_i64(v24);
				mw_std_str_ZPlusStr_byteZAt(v24, r25);
				int64_t v26 = pop_i64();
				int64_t v27 = mw_std_byte_Byte_isZ_hexdigit(v26);
				if (!((bool)v27)) break;
				int64_t v28 = pop_i64();
				int64_t v29 = 1LL;
				int64_t v30 = pop_i64();
				int64_t v31 = i64_add(v30, v29);
				int64_t v32 = 1LL;
				int64_t v33 = i64_add(v28, v32);
				push_i64(v31);
				push_i64(v33);
			}
			int64_t v34 = pop_i64();
			int64_t v35 = pop_i64();
			int64_t v36 = 0LL;
			bool v37 = (v35 > v36);
			if (v37) {
				VAL r38 = pop_resource();
				push_i64(v34);
				mw_std_str_ZPlusStr_numZ_bytesZAsk(r38);
				int64_t v39 = pop_i64();
				int64_t v40 = pop_i64();
				bool v41 = (v40 == v39);
				push_bool(v41);
			} else {
				int64_t v42 = 0LL /* False */;
				push_i64(v42);
			}
		} else {
			VAL v43 = pop_value();
			decref(v43);
			VAL v44 = pop_value();
			decref(v44);
			int64_t v45 = 0LL /* False */;
			push_i64(v45);
		}
	} else {
		VAL v46 = pop_value();
		decref(v46);
		VAL v47 = pop_value();
		decref(v47);
		int64_t v48 = 0LL /* False */;
		push_i64(v48);
	}
}
static void mw_std_str_ZPlusStr_isZ_octZ_intZAsk (VAL x1) {
	int64_t v0 = 0LL;
	push_resource(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = 0LL;
	VAL r3 = pop_resource();
	push_i64(v1);
	push_i64(v2);
	mw_std_str_ZPlusStr_byteZAt(v2, r3);
	int64_t v4 = pop_i64();
	int64_t v5 = mw_std_byte_Byte_isZ_sign(v4);
	if (((bool)v5)) {
		int64_t v6 = 1LL;
		int64_t v7 = pop_i64();
		int64_t v8 = i64_add(v7, v6);
		push_i64(v8);
	} else {
	}
	int64_t v9 = pop_i64();
	VAL r10 = pop_resource();
	push_i64(v9);
	mw_std_str_ZPlusStr_byteZAt(v9, r10);
	int64_t v11 = 48LL /* B'0' */;
	int64_t v12 = pop_i64();
	bool v13 = (v12 == v11);
	if (v13) {
		int64_t v14 = 1LL;
		int64_t v15 = pop_i64();
		int64_t v16 = i64_add(v15, v14);
		VAL r17 = pop_resource();
		push_i64(v16);
		mw_std_str_ZPlusStr_byteZAt(v16, r17);
		int64_t v18 = 111LL /* B'o' */;
		int64_t v19 = pop_i64();
		bool v20 = (v19 == v18);
		if (v20) {
			int64_t v21 = 1LL;
			int64_t v22 = pop_i64();
			int64_t v23 = i64_add(v22, v21);
			push_i64(v23);
			while(1) {
				int64_t v24 = pop_i64();
				VAL r25 = pop_resource();
				push_i64(v24);
				mw_std_str_ZPlusStr_byteZAt(v24, r25);
				int64_t v26 = 48LL /* B'0' */;
				int64_t v27 = 55LL /* B'7' */;
				VAL v28 = pop_value();
				incref(v28);
				bool v29 = (VI64(v28) >= v26);
				bool v30 = (VI64(v28) <= v27);
				bool v31 = (v29 && v30);
				if (!v31) break;
				int64_t v32 = pop_i64();
				int64_t v33 = 1LL;
				int64_t v34 = pop_i64();
				int64_t v35 = i64_add(v34, v33);
				int64_t v36 = 1LL;
				int64_t v37 = i64_add(v32, v36);
				push_i64(v35);
				push_i64(v37);
			}
			int64_t v38 = pop_i64();
			int64_t v39 = pop_i64();
			int64_t v40 = 0LL;
			bool v41 = (v39 > v40);
			if (v41) {
				VAL r42 = pop_resource();
				push_i64(v38);
				mw_std_str_ZPlusStr_numZ_bytesZAsk(r42);
				int64_t v43 = pop_i64();
				int64_t v44 = pop_i64();
				bool v45 = (v44 == v43);
				push_bool(v45);
			} else {
				int64_t v46 = 0LL /* False */;
				push_i64(v46);
			}
		} else {
			VAL v47 = pop_value();
			decref(v47);
			VAL v48 = pop_value();
			decref(v48);
			int64_t v49 = 0LL /* False */;
			push_i64(v49);
		}
	} else {
		VAL v50 = pop_value();
		decref(v50);
		VAL v51 = pop_value();
		decref(v51);
		int64_t v52 = 0LL /* False */;
		push_i64(v52);
	}
}
static void mw_std_str_ZPlusStr_intZAsk (VAL x1) {
	mw_std_str_ZPlusStr_isZ_decZ_intZAsk(x1);
	bool v0 = pop_bool();
	if (v0) {
		VAL r1 = pop_resource();
		mw_std_str_ZPlusStr_decZ_intZAsk(r1);
	} else {
		VAL r2 = pop_resource();
		mw_std_str_ZPlusStr_isZ_hexZ_intZAsk(r2);
		bool v3 = pop_bool();
		if (v3) {
			VAL r4 = pop_resource();
			mw_std_str_ZPlusStr_hexZ_intZAsk(r4);
		} else {
			VAL r5 = pop_resource();
			mw_std_str_ZPlusStr_octZ_intZAsk(r5);
		}
	}
}
static void mw_std_str_ZPlusStr_intZ_sign (VAL x1) {
	int64_t v0 = 0LL;
	mw_std_str_ZPlusStr_byteZAt(v0, x1);
	int64_t v1 = pop_i64();
	mw_mirth_lexer_byteZ_signZ_valueZ_index(v1);
}
static void mw_mirth_lexer_byteZ_signZ_valueZ_index (int64_t x1) {
	switch (x1) {
		case 45LL: { // B'-'
			int64_t v0 = -1LL;
			int64_t v1 = 0LL;
			int64_t v2 = 1LL;
			push_i64(v0);
			push_i64(v1);
			push_i64(v2);
		} break;
		case 43LL: { // B'+'
			int64_t v3 = 1LL;
			int64_t v4 = 0LL;
			int64_t v5 = 1LL;
			push_i64(v3);
			push_i64(v4);
			push_i64(v5);
		} break;
		default: {
			int64_t v6 = 1LL;
			int64_t v7 = 0LL;
			int64_t v8 = 0LL;
			push_i64(v6);
			push_i64(v7);
			push_i64(v8);
		} break;
	}
}
static void mw_std_str_ZPlusStr_decZ_intZAsk (VAL x1) {
	mw_std_str_ZPlusStr_intZ_sign(x1);
	while(1) {
		int64_t v0 = pop_i64();
		VAL r1 = pop_resource();
		push_i64(v0);
		push_i64(v0);
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r1);
		int64_t v2 = pop_i64();
		int64_t v3 = pop_i64();
		bool v4 = (v3 < v2);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		mw_std_str_ZPlusStr_byteZAt(v5, r6);
		int64_t v7 = pop_i64();
		int64_t v8 = 10LL;
		int64_t v9 = pop_i64();
		int64_t v10 = i64_mul(v9, v8);
		int64_t v11 = 48LL;
		int64_t v12 = i64_sub(v7, v11);
		int64_t v13 = i64_add(v10, v12);
		int64_t v14 = 1LL;
		int64_t v15 = i64_add(v5, v14);
		push_i64(v13);
		push_i64(v15);
	}
	int64_t v16 = pop_i64();
	int64_t v17 = pop_i64();
	int64_t v18 = pop_i64();
	int64_t v19 = i64_mul(v18, v17);
	push_i64(v19);
}
static void mw_std_str_ZPlusStr_hexZ_intZAsk (VAL x1) {
	mw_std_str_ZPlusStr_intZ_sign(x1);
	int64_t v0 = 1LL;
	int64_t v1 = pop_i64();
	int64_t v2 = i64_add(v1, v0);
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(v2, v3);
	push_i64(v4);
	while(1) {
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		push_i64(v5);
		push_i64(v5);
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r6);
		int64_t v7 = pop_i64();
		int64_t v8 = pop_i64();
		bool v9 = (v8 < v7);
		if (!v9) break;
		int64_t v10 = pop_i64();
		VAL r11 = pop_resource();
		mw_std_str_ZPlusStr_byteZAt(v10, r11);
		int64_t v12 = pop_i64();
		int64_t v13 = 16LL;
		int64_t v14 = pop_i64();
		int64_t v15 = i64_mul(v14, v13);
		push_i64(v15);
		int64_t v16 = mw_mirth_lexer_hexdigitZ_value(v12);
		int64_t v17 = pop_i64();
		int64_t v18 = i64_add(v17, v16);
		int64_t v19 = 1LL;
		int64_t v20 = i64_add(v10, v19);
		push_i64(v18);
		push_i64(v20);
	}
	int64_t v21 = pop_i64();
	int64_t v22 = pop_i64();
	int64_t v23 = pop_i64();
	int64_t v24 = i64_mul(v23, v22);
	push_i64(v24);
}
static void mw_std_str_ZPlusStr_octZ_intZAsk (VAL x1) {
	mw_std_str_ZPlusStr_intZ_sign(x1);
	int64_t v0 = 1LL;
	int64_t v1 = pop_i64();
	int64_t v2 = i64_add(v1, v0);
	int64_t v3 = 1LL;
	int64_t v4 = i64_add(v2, v3);
	push_i64(v4);
	while(1) {
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		push_i64(v5);
		push_i64(v5);
		mw_std_str_ZPlusStr_numZ_bytesZAsk(r6);
		int64_t v7 = pop_i64();
		int64_t v8 = pop_i64();
		bool v9 = (v8 < v7);
		if (!v9) break;
		int64_t v10 = pop_i64();
		VAL r11 = pop_resource();
		mw_std_str_ZPlusStr_byteZAt(v10, r11);
		int64_t v12 = pop_i64();
		int64_t v13 = 8LL;
		int64_t v14 = pop_i64();
		int64_t v15 = i64_mul(v14, v13);
		int64_t v16 = 48LL;
		int64_t v17 = i64_sub(v12, v16);
		int64_t v18 = i64_add(v15, v17);
		int64_t v19 = 1LL;
		int64_t v20 = i64_add(v10, v19);
		push_i64(v18);
		push_i64(v20);
	}
	int64_t v21 = pop_i64();
	int64_t v22 = pop_i64();
	int64_t v23 = pop_i64();
	int64_t v24 = i64_mul(v23, v22);
	push_i64(v24);
}
static int64_t mw_mirth_lexer_hexdigitZ_value (int64_t x1) {
	push_i64(x1);
	int64_t v0 = mw_std_byte_Byte_isZ_digit(x1);
	if (((bool)v0)) {
		int64_t v1 = 48LL;
		int64_t v2 = pop_i64();
		int64_t v3 = i64_sub(v2, v1);
		push_i64(v3);
	} else {
		int64_t v4 = 55LL;
		int64_t v5 = pop_i64();
		int64_t v6 = i64_sub(v5, v4);
		push_i64(v6);
	}
	int64_t v7 = pop_i64();
	return v7;
}
static void mw_mirth_lexer_lexerZ_emitZ_stringZBang (VAL x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "", 0);
	int64_t v1 = 0LL /* TokenNone */;
	push_resource(x1);
	push_resource(MKSTR(v0));
	mw_mirth_lexer_lexerZ_makeZBang(MKI64(v1), x2);
	VAL r2 = pop_resource();
	VAL v3 = (mw_mirth_lexer_lexerZ_moveZBang(r2));
	mw_mirth_lexer_lexerZ_peek(v3);
	while(1) {
		int64_t v4 = pop_i64();
		push_i64(v4);
		int64_t v5 = mw_std_byte_Byte_isZ_stringZ_end(v4);
		bool v6 = !((bool)v5);
		if (!v6) break;
		int64_t v7 = pop_i64();
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		VAL r10 = pop_resource();
		mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang(r10, r9, r8, v7);
		VAL r11 = pop_resource();
		VAL v12 = (mw_mirth_lexer_lexerZ_moveZBang(r11));
		mw_mirth_lexer_lexerZ_peek(v12);
	}
	int64_t v13 = 34LL /* BQUOTE */;
	int64_t v14 = pop_i64();
	bool v15 = (v14 == v13);
	if (v15) {
	} else {
		STR* v16;
		STRLIT(v16, "String literal is missing end quote (\").", 40);
		VAL r17 = pop_resource();
		VAL r18 = pop_resource();
		VAL r19 = pop_resource();
		mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang(MKSTR(v16), r19, r17);
		VAL r20 = pop_resource();
		push_resource(r18);
		push_resource(r20);
	}
	VAL r21 = pop_resource();
	VAL r22 = pop_resource();
	VAL v23 = mtw_mirth_token_TokenValue_TokenStr(r22);
	uint64_t v24 = pop_u64();
	void* v25 = mfld_mirth_token_Token_ZTildevalue(v24);
	mut_set(v23, MKPTR(v25));
	push_resource(r21);
}
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4) {
	switch (x4) {
		case 92LL: { // B'\'
			push_resource(x1);
			push_resource(x2);
			VAL v0 = (mw_mirth_lexer_lexerZ_moveZBang(x3));
			mw_mirth_lexer_lexerZ_peek(v0);
			int64_t v1 = pop_i64();
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			VAL r4 = pop_resource();
			mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang(r4, r3, r2, v1);
		} break;
		default: {
			push_resource(x1);
			VAL v5 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(x4, x2));
			push_resource(v5);
			push_resource(x3);
		} break;
	}
}
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang (VAL x1, VAL x2, VAL x3, int64_t x4) {
	switch (x4) {
		case 10LL: { // BLF
			push_resource(x1);
			push_resource(x2);
			VAL v0 = (mw_mirth_lexer_lexerZ_newlineZBang(x3));
			push_resource(v0);
		} break;
		case 110LL: { // B'n'
			int64_t v1 = 10LL /* BLF */;
			push_resource(x1);
			VAL v2 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v1, x2));
			push_resource(v2);
			push_resource(x3);
		} break;
		case 114LL: { // B'r'
			int64_t v3 = 13LL /* BCR */;
			push_resource(x1);
			VAL v4 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v3, x2));
			push_resource(v4);
			push_resource(x3);
		} break;
		case 116LL: { // B't'
			int64_t v5 = 9LL /* BHT */;
			push_resource(x1);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v5, x2));
			push_resource(v6);
			push_resource(x3);
		} break;
		case 92LL: { // B'\'
			int64_t v7 = 92LL /* B'\' */;
			push_resource(x1);
			VAL v8 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v7, x2));
			push_resource(v8);
			push_resource(x3);
		} break;
		case 34LL: { // BQUOTE
			int64_t v9 = 34LL /* BQUOTE */;
			push_resource(x1);
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang(v9, x2));
			push_resource(v10);
			push_resource(x3);
		} break;
		default: {
			push_resource(x1);
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang(x4, x2));
			STR* v12;
			STRLIT(v12, "Unknown character escape sequence.", 34);
			VAL r13 = pop_resource();
			mw_mirth_lexer_lexerZ_emitZ_warningZBang(MKSTR(v12), r13, x3);
			VAL r14 = pop_resource();
			push_resource(v11);
			push_resource(r14);
		} break;
	}
}
static VAL mw_mirth_lexer_lexerZ_skipZ_commentZBang (VAL x1) {
	push_resource(x1);
	while(1) {
		VAL r0 = pop_resource();
		mw_mirth_lexer_lexerZ_commentZ_endZAsk(r0);
		bool v1 = pop_bool();
		bool v2 = !v1;
		if (!v2) break;
		VAL r3 = pop_resource();
		VAL v4 = (mw_mirth_lexer_lexerZ_moveZBang(r3));
		push_resource(v4);
	}
	VAL r5 = pop_resource();
	mw_mirth_lexer_lexerZ_peek(r5);
	int64_t v6 = 10LL /* BLF */;
	int64_t v7 = pop_i64();
	bool v8 = (v7 == v6);
	if (v8) {
		VAL r9 = pop_resource();
		VAL v10 = (mw_mirth_lexer_lexerZ_newlineZBang(r9));
		push_resource(v10);
	} else {
	}
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_lexer_lexerZ_skipZ_docZBang (VAL x1) {
	push_resource(x1);
	while(1) {
		VAL r0 = pop_resource();
		mw_mirth_lexer_lexerZ_commentZ_endZAsk(r0);
		bool v1 = pop_bool();
		bool v2 = !v1;
		if (!v2) break;
		VAL r3 = pop_resource();
		VAL v4 = (mw_mirth_lexer_lexerZ_moveZBang(r3));
		push_resource(v4);
	}
	VAL r5 = pop_resource();
	return r5;
}
static void mw_mirth_lexer_lexerZ_commentZ_endZAsk (VAL x1) {
	mw_mirth_lexer_ZPlusLexer_doneZAsk(x1);
	bool v0 = pop_bool();
	if (v0) {
		int64_t v1 = 1LL /* True */;
		push_i64(v1);
	} else {
		VAL r2 = pop_resource();
		mw_mirth_lexer_lexerZ_peek(r2);
		int64_t v3 = pop_i64();
		int64_t v4 = 10LL /* BLF */;
		bool v5 = (v3 == v4);
		push_bool(v5);
	}
}
static void mw_mirth_lexer_lexerZ_peek (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[6]));
	mw_std_input_ZPlusInput_peek(v0);
	VAL r1 = pop_resource();
	VTUP(x1)->cells[6] = r1;
	push_resource(x1);
}
static VAL mw_mirth_lexer_lexerZ_moveZBang (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[6]));
	VAL v1 = (mw_std_input_ZPlusInput_moveZBang(v0));
	VTUP(x1)->cells[6] = v1;
	int64_t v2 = VI64(VTUP(x1)->cells[3]);
	push_resource(x1);
	int64_t v3 = mw_mirth_location_Col_ZToInt(v2);
	int64_t v4 = 1LL;
	int64_t v5 = i64_add(v3, v4);
	int64_t v6 = mw_std_prim_Int_ZToCol(v5);
	VAL r7 = pop_resource();
	VTUP(r7)->cells[3] = MKI64(v6);
	return r7;
}
static void mw_mirth_lexer_lexerZ_location (VAL x1) {
	uint64_t v0 = VU64(VTUP(x1)->cells[1]);
	int64_t v1 = VI64(VTUP(x1)->cells[2]);
	int64_t v2 = VI64(VTUP(x1)->cells[3]);
	push_resource(x1);
	VAL v3 = mtw_mirth_location_Location_Location(v0, v1, v2);
	push_value(v3);
}
static void mw_mirth_lexer_lexerZ_emitZ_warningZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	mw_mirth_lexer_lexerZ_location(x3);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	VAL v3 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang(v2, x1, r1));
	push_resource(v3);
	push_resource(r0);
}
static void mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	mw_mirth_lexer_lexerZ_location(x3);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	push_resource(r0);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang(v2, x1, r1);
}
static VAL mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang (uint64_t x1) {
	lpush(&lbl_token, MKU64(x1));
	VAL v0 = mw_mirth_var_Ctx0();
	int64_t v1 = 0LL /* False */;
	int64_t v2 = 1LL /* True */;
	uint64_t v3 = VU64(lpop(&lbl_token));
	VAL v4 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v0, v3, v1, v2));
	return v4;
}
static void mw_mirth_elab_ZPlusTypeElab_rdrop (VAL x1) {
	mtp_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(x1);
	VAL v0 = lpop(&lbl_ctx);
	uint64_t v1 = VU64(lpop(&lbl_token));
	decref(v0);
	int64_t v2 = VI64(lpop(&lbl_allowZ_typeZ_holes));
	int64_t v3 = VI64(lpop(&lbl_allowZ_implicitZ_typeZ_vars));
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_mirth_token_Token_runZ_endZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		uint64_t v3 = VU64(VTUP(r2)->cells[2]);
		STR* v4;
		STRLIT(v4, "expected type signature", 23);
		VAL r5 = pop_resource();
		VAL v6 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v3, MKSTR(v4), r5));
		push_resource(v6);
		push_resource(r2);
	} else {
	}
	VAL r7 = pop_resource();
	VAL r8 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang(r8, r7);
	VAL r9 = pop_resource();
	VAL r10 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(r10, r9);
	VAL r11 = pop_resource();
	uint64_t v12 = VU64(VTUP(r11)->cells[2]);
	push_resource(r11);
	int64_t v13 = mw_mirth_token_Token_sigZ_dashesZAsk(v12);
	if (((bool)v13)) {
		VAL r14 = pop_resource();
		uint64_t v15 = VU64(VTUP(r14)->cells[2]);
		uint64_t v16 = mw_mirth_token_Token_succ(v15);
		VTUP(r14)->cells[2] = MKU64(v16);
		VAL r17 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(r17, r14);
	} else {
		VAL v18 = pop_value();
		VAL v19 = mw_mirth_type_T0();
		push_value(v19);
		push_value(v18);
	}
	VAL r20 = pop_resource();
	uint64_t v21 = VU64(VTUP(r20)->cells[2]);
	push_resource(r20);
	int64_t v22 = mw_mirth_token_Token_runZ_endZAsk(v21);
	if (((bool)v22)) {
	} else {
		VAL r23 = pop_resource();
		uint64_t v24 = VU64(VTUP(r23)->cells[2]);
		STR* v25;
		STRLIT(v25, "expected right paren or comma", 29);
		VAL r26 = pop_resource();
		VAL v27 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v24, MKSTR(v25), r26));
		push_resource(v27);
		push_resource(r23);
	}
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	VAL v30 = pop_value();
	push_value(v29);
	mw_std_list_List_1_uncons(v30);
	VAL v31 = pop_value();
	VAL v32 = pop_value();
	push_value(v31);
	push_value(v32);
	while(1) {
		VAL v33 = pop_value();
		incref(v33);
		push_value(v33);
		int64_t v34 = mw_std_maybe_Maybe_1_someZAsk(v33);
		if (!((bool)v34)) break;
		VAL v35 = pop_value();
		VAL v36 = mw_std_maybe_Maybe_1_unwrap(v35);
		VAL v37 = pop_value();
		VAL v38 = pop_value();
		VAL v39 = mw_mirth_type_TZMul(v38, v36);
		push_value(v39);
		mw_std_list_List_1_uncons(v37);
		VAL v40 = pop_value();
		VAL v41 = pop_value();
		push_value(v40);
		push_value(v41);
	}
	VAL v42 = pop_value();
	decref(v42);
	VAL v43 = pop_value();
	decref(v43);
	VAL v44 = pop_value();
	VAL v45 = mw_mirth_type_TZ_ZTo(v44, v28);
	push_value(v45);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	VAL v1 = mw_mirth_token_Token_lparenZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			decref(v2);
			VAL r3 = pop_resource();
			uint64_t v4 = VU64(VTUP(r3)->cells[2]);
			push_resource(r3);
			uint64_t v5 = mw_mirth_token_Token_next(v4);
			VAL r6 = pop_resource();
			uint64_t v7 = VU64(VTUP(r6)->cells[2]);
			push_u64(v5);
			push_resource(r6);
			VAL v8 = mw_mirth_token_Token_args(v7);
			int64_t v9 = 0LL /* Nil */;
			push_value(v8);
			VAL v10 = mw_std_list_List_1_reverse(MKI64(v9));
			VAL v11 = pop_value();
			push_resource(v10);
			mw_std_list_List_1_uncons(v11);
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
			while(1) {
				VAL v14 = pop_value();
				incref(v14);
				push_value(v14);
				int64_t v15 = mw_std_maybe_Maybe_1_someZAsk(v14);
				if (!((bool)v15)) break;
				VAL v16 = pop_value();
				VAL v17 = mw_std_maybe_Maybe_1_unwrap(v16);
				VAL v18 = pop_value();
				VAL r19 = pop_resource();
				VAL r20 = pop_resource();
				VTUP(r20)->cells[2] = v17;
				VAL r21 = pop_resource();
				mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(r21, r20);
				VAL v22 = pop_value();
				VAL v23 = mtw_mirth_type_Type_TMorphism(v22);
				VAL v24 = mtw_std_list_List_1_Cons(v23, r19);
				push_resource(v24);
				mw_std_list_List_1_uncons(v18);
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				push_value(v25);
				push_value(v26);
			}
			VAL v27 = pop_value();
			decref(v27);
			VAL v28 = pop_value();
			decref(v28);
			VAL r29 = pop_resource();
			VAL v30 = mw_std_list_List_1_reverse(r29);
			VAL r31 = pop_resource();
			uint64_t v32 = pop_u64();
			VTUP(r31)->cells[2] = MKU64(v32);
			push_resource(r31);
			push_value(v30);
		} break;
		case 0LL: { // None
			int64_t v33 = 0LL /* Nil */;
			push_i64(v33);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_mirth_token_Token_sigZ_stackZ_varZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		VAL r3 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang(r3, r2);
	} else {
		VAL v4 = mw_mirth_type_T0();
		push_value(v4);
	}
	VAL v5 = pop_value();
	VAL r6 = pop_resource();
	VAL r7 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang(r7, r6, v5);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x1);
	push_resource(x2);
	push_value(x3);
	while(1) {
		VAL r0 = pop_resource();
		uint64_t v1 = VU64(VTUP(r0)->cells[2]);
		push_resource(r0);
		int64_t v2 = mw_mirth_token_Token_sigZ_stackZ_endZAsk(v1);
		bool v3 = !((bool)v2);
		if (!v3) break;
		VAL r4 = pop_resource();
		VAL r5 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang(r5, r4);
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = mw_mirth_type_StackTypePart_cons(v7, v6);
		push_value(v8);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_u64(v0);
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang(x1, x2);
	VAL v1 = pop_value();
	switch (get_data_tag(v1)) {
		case 0LL: { // STPCons
			VAL v2 = mtp_mirth_type_StackTypePart_STPCons(v1);
			VAL v3 = pop_value();
			decref(v3);
			push_value(v2);
		} break;
		case 1LL: { // STPConsLabel
			mtp_mirth_type_StackTypePart_STPConsLabel(v1);
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			STR* v6;
			STRLIT(v6, "Expected type, not label.", 25);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			uint64_t v9 = pop_u64();
			VAL v10 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v9, MKSTR(v6), r8));
			int64_t v11 = 0LL /* TYPE_ERROR */;
			push_resource(v10);
			push_resource(r7);
			push_i64(v11);
		} break;
		case 2LL: { // STPWith
			VAL v12 = mtp_mirth_type_StackTypePart_STPWith(v1);
			decref(v12);
			STR* v13;
			STRLIT(v13, "Expected type, not resource.", 28);
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			uint64_t v16 = pop_u64();
			VAL v17 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v16, MKSTR(v13), r15));
			int64_t v18 = 0LL /* TYPE_ERROR */;
			push_resource(v17);
			push_resource(r14);
			push_i64(v18);
		} break;
		case 3LL: { // STPWithLabel
			mtp_mirth_type_StackTypePart_STPWithLabel(v1);
			VAL v19 = pop_value();
			decref(v19);
			VAL v20 = pop_value();
			decref(v20);
			STR* v21;
			STRLIT(v21, "Expected type, not labelled resource.", 37);
			VAL r22 = pop_resource();
			VAL r23 = pop_resource();
			uint64_t v24 = pop_u64();
			VAL v25 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v24, MKSTR(v21), r23));
			int64_t v26 = 0LL /* TYPE_ERROR */;
			push_resource(v25);
			push_resource(r22);
			push_i64(v26);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r27 = pop_resource();
	uint64_t v28 = VU64(VTUP(r27)->cells[2]);
	push_resource(r27);
	int64_t v29 = mw_mirth_token_Token_argZ_endZAsk(v28);
	if (((bool)v29)) {
	} else {
		VAL r30 = pop_resource();
		uint64_t v31 = VU64(VTUP(r30)->cells[2]);
		STR* v32;
		STRLIT(v32, "Unexpected token after type.", 28);
		VAL r33 = pop_resource();
		VAL v34 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v31, MKSTR(v32), r33));
		push_resource(v34);
		push_resource(r30);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_u64(v0);
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang(x1, x2);
	VAL v1 = pop_value();
	switch (get_data_tag(v1)) {
		case 0LL: { // STPCons
			VAL v2 = mtp_mirth_type_StackTypePart_STPCons(v1);
			decref(v2);
			STR* v3;
			STRLIT(v3, "Expected resource, not type.", 28);
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			uint64_t v6 = pop_u64();
			VAL v7 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v6, MKSTR(v3), r5));
			int64_t v8 = 0LL /* TYPE_ERROR */;
			push_resource(v7);
			push_resource(r4);
			push_i64(v8);
		} break;
		case 1LL: { // STPConsLabel
			mtp_mirth_type_StackTypePart_STPConsLabel(v1);
			VAL v9 = pop_value();
			decref(v9);
			VAL v10 = pop_value();
			decref(v10);
			STR* v11;
			STRLIT(v11, "Expected resource, not label.", 29);
			VAL r12 = pop_resource();
			VAL r13 = pop_resource();
			uint64_t v14 = pop_u64();
			VAL v15 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v14, MKSTR(v11), r13));
			int64_t v16 = 0LL /* TYPE_ERROR */;
			push_resource(v15);
			push_resource(r12);
			push_i64(v16);
		} break;
		case 2LL: { // STPWith
			VAL v17 = mtp_mirth_type_StackTypePart_STPWith(v1);
			VAL v18 = pop_value();
			decref(v18);
			push_value(v17);
		} break;
		case 3LL: { // STPWithLabel
			mtp_mirth_type_StackTypePart_STPWithLabel(v1);
			VAL v19 = pop_value();
			decref(v19);
			VAL v20 = pop_value();
			decref(v20);
			STR* v21;
			STRLIT(v21, "Expected resource, not label.", 29);
			VAL r22 = pop_resource();
			VAL r23 = pop_resource();
			uint64_t v24 = pop_u64();
			VAL v25 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v24, MKSTR(v21), r23));
			int64_t v26 = 0LL /* TYPE_ERROR */;
			push_resource(v25);
			push_resource(r22);
			push_i64(v26);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r27 = pop_resource();
	uint64_t v28 = VU64(VTUP(r27)->cells[2]);
	push_resource(r27);
	int64_t v29 = mw_mirth_token_Token_argZ_endZAsk(v28);
	if (((bool)v29)) {
	} else {
		VAL r30 = pop_resource();
		uint64_t v31 = VU64(VTUP(r30)->cells[2]);
		STR* v32;
		STRLIT(v32, "Unexpected token after resource.", 32);
		VAL r33 = pop_resource();
		VAL v34 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v31, MKSTR(v32), r33));
		push_resource(v34);
		push_resource(r30);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		VAL r3 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang(r3, r2);
	} else {
		VAL r4 = pop_resource();
		uint64_t v5 = VU64(VTUP(r4)->cells[2]);
		push_resource(r4);
		int64_t v6 = mw_mirth_token_Token_sigZ_typeZ_varZAsk(v5);
		if (((bool)v6)) {
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang(r8, r7);
			VAL v9 = pop_value();
			VAL v10 = mtw_mirth_type_StackTypePart_STPCons(v9);
			push_value(v10);
		} else {
			VAL r11 = pop_resource();
			uint64_t v12 = VU64(VTUP(r11)->cells[2]);
			push_resource(r11);
			int64_t v13 = mw_mirth_token_Token_sigZ_typeZ_conZAsk(v12);
			if (((bool)v13)) {
				VAL r14 = pop_resource();
				VAL r15 = pop_resource();
				mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang(r15, r14);
				VAL v16 = pop_value();
				VAL v17 = mtw_mirth_type_StackTypePart_STPCons(v16);
				push_value(v17);
			} else {
				VAL r18 = pop_resource();
				uint64_t v19 = VU64(VTUP(r18)->cells[2]);
				push_resource(r18);
				int64_t v20 = mw_mirth_token_Token_sigZ_resourceZ_varZAsk(v19);
				if (((bool)v20)) {
					VAL r21 = pop_resource();
					VAL r22 = pop_resource();
					mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang(r22, r21);
					VAL v23 = pop_value();
					VAL v24 = mtw_mirth_type_StackTypePart_STPWith(v23);
					push_value(v24);
				} else {
					VAL r25 = pop_resource();
					uint64_t v26 = VU64(VTUP(r25)->cells[2]);
					push_resource(r25);
					int64_t v27 = mw_mirth_token_Token_sigZ_resourceZ_conZAsk(v26);
					if (((bool)v27)) {
						VAL r28 = pop_resource();
						VAL r29 = pop_resource();
						mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang(r29, r28);
						VAL v30 = pop_value();
						VAL v31 = mtw_mirth_type_StackTypePart_STPWith(v30);
						push_value(v31);
					} else {
						VAL r32 = pop_resource();
						uint64_t v33 = VU64(VTUP(r32)->cells[2]);
						push_resource(r32);
						int64_t v34 = mw_mirth_token_Token_patZ_underscoreZAsk(v33);
						if (((bool)v34)) {
							VAL r35 = pop_resource();
							VAL r36 = pop_resource();
							mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang(r36, r35);
							VAL v37 = pop_value();
							VAL v38 = mtw_mirth_type_StackTypePart_STPCons(v37);
							push_value(v38);
						} else {
							VAL r39 = pop_resource();
							uint64_t v40 = VU64(VTUP(r39)->cells[2]);
							push_resource(r39);
							int64_t v41 = mw_mirth_token_Token_sigZ_typeZ_holeZAsk(v40);
							if (((bool)v41)) {
								VAL r42 = pop_resource();
								VAL r43 = pop_resource();
								mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang(r43, r42);
								VAL v44 = pop_value();
								VAL v45 = mtw_mirth_type_StackTypePart_STPCons(v44);
								push_value(v45);
							} else {
								VAL r46 = pop_resource();
								uint64_t v47 = VU64(VTUP(r46)->cells[2]);
								push_resource(r46);
								VAL v48 = mw_mirth_token_Token_lsquareZAsk(v47);
								switch (get_data_tag(v48)) {
									case 1LL: { // Some
										VAL v49 = mtp_std_maybe_Maybe_1_Some(v48);
										decref(v49);
										VAL r50 = pop_resource();
										VAL r51 = pop_resource();
										mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang(r51, r50);
										VAL v52 = pop_value();
										VAL v53 = mtw_mirth_type_StackTypePart_STPCons(v52);
										push_value(v53);
									} break;
									case 0LL: { // None
										VAL r54 = pop_resource();
										uint64_t v55 = VU64(VTUP(r54)->cells[2]);
										STR* v56;
										STRLIT(v56, "Expected type, got unknown token.", 33);
										VAL r57 = pop_resource();
										VAL v58 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v55, MKSTR(v56), r57));
										uint64_t v59 = VU64(VTUP(r54)->cells[2]);
										push_resource(v58);
										uint64_t v60 = mw_mirth_token_Token_next(v59);
										VTUP(r54)->cells[2] = MKU64(v60);
										int64_t v61 = 0LL /* TYPE_ERROR */;
										push_resource(r54);
										VAL v62 = mtw_mirth_type_StackTypePart_STPCons(MKI64(v61));
										push_value(v62);
									} break;
									default: {
										push_value(mkstr("unexpected fallthrough in match\n", 32));
										do_panic();
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	uint64_t v1 = mw_mirth_token_Token_next(v0);
	VAL r2 = pop_resource();
	uint64_t v3 = VU64(VTUP(r2)->cells[2]);
	push_resource(r2);
	VAL v4 = mw_mirth_token_Token_nameZAsk(v3);
	VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
	uint64_t v6 = mw_mirth_label_Label_newZBang(VU64(v5));
	VAL r7 = pop_resource();
	uint64_t v8 = VU64(VTUP(r7)->cells[2]);
	VAL r9 = pop_resource();
	push_u64(v6);
	mw_mirth_token_Token_argsZ_1(v8, r9);
	uint64_t v10 = pop_u64();
	VTUP(r7)->cells[2] = MKU64(v10);
	uint64_t v11 = pop_u64();
	push_resource(r7);
	push_u64(v11);
	int64_t v12 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v11);
	if (((bool)v12)) {
		VAL r13 = pop_resource();
		VAL r14 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang(r14, r13);
		VAL v15 = pop_value();
		uint64_t v16 = pop_u64();
		VAL v17 = mtw_mirth_type_StackTypePart_STPWithLabel(v15, v16);
		push_value(v17);
	} else {
		VAL r18 = pop_resource();
		VAL r19 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(r19, r18);
		VAL v20 = pop_value();
		uint64_t v21 = pop_u64();
		VAL v22 = mtw_mirth_type_StackTypePart_STPConsLabel(v20, v21);
		push_value(v22);
	}
	VAL r23 = pop_resource();
	VTUP(r23)->cells[2] = MKU64(v1);
	push_resource(r23);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_type_TYPEz_STACK();
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang(r2, r1, v0);
	VAL v3 = pop_value();
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = mtw_mirth_type_StackType_STVar(VU64(v4));
			push_value(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* STACK_TYPE_ERROR */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_type_TYPEz_TYPE();
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang(r2, r1, v0);
	VAL v3 = pop_value();
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = mtw_mirth_type_Type_TVar(VU64(v4));
			push_value(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* TYPE_ERROR */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_type_TYPEz_RESOURCE();
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang(r2, r1, v0);
	VAL v3 = pop_value();
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = mtw_mirth_type_Type_TVar(VU64(v4));
			push_value(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* TYPE_ERROR */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang (VAL x1, VAL x2, VAL x3) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_value(x3);
	push_resource(x2);
	VAL v1 = mw_mirth_token_Token_nameZAsk(v0);
	VAL v2 = mw_std_maybe_Maybe_1_unwrap(v1);
	incref(v2);
	VAL r3 = pop_resource();
	VAL v4 = VVAL(VTUP(r3)->cells[1]);
	incref(v4);
	push_value(v2);
	push_resource(r3);
	VAL v5 = mw_mirth_var_Ctx_lookup(VU64(v2), v4);
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v6);
			VAL v7 = pop_value();
			decref(v7);
			VAL v8 = mw_mirth_var_Var_type(VU64(v6));
			VAL r9 = pop_resource();
			uint64_t v10 = VU64(VTUP(r9)->cells[2]);
			VAL v11 = pop_value();
			VAL r12 = pop_resource();
			mw_mirth_type_Type_unifyZBang(r12, v10, v11, v8);
			uint64_t r13 = VU64(pop_resource());
			mw_mirth_type_ZPlusGamma_rdrop(r13);
			VAL v14 = pop_value();
			decref(v14);
			push_resource(r9);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(v6);
			push_value(v15);
		} break;
		case 0LL: { // None
			VAL r16 = pop_resource();
			int64_t v17 = VI64(VTUP(r16)->cells[4]);
			if (((bool)v17)) {
				uint64_t v18 = pop_u64();
				VAL v19 = pop_value();
				push_resource(r16);
				uint64_t v20 = mw_mirth_var_Var_newZBang(v19, v18);
				VAL r21 = pop_resource();
				VAL v22 = VVAL(VTUP(r21)->cells[1]);
				incref(v22);
				push_u64(v20);
				VAL v23 = mw_mirth_var_Ctx_new(v22, v20);
				VAL v24 = VTUP(r21)->cells[1];
				decref(v24);
				VTUP(r21)->cells[1] = v23;
				VAL v25 = pop_value();
				push_resource(r21);
				VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
				push_value(v26);
			} else {
				uint64_t v27 = VU64(VTUP(r16)->cells[2]);
				STR* v28;
				STRLIT(v28, "Implicit type variable not allowed here.", 40);
				VAL r29 = pop_resource();
				VAL v30 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v27, MKSTR(v28), r29));
				VAL v31 = pop_value();
				decref(v31);
				VAL v32 = pop_value();
				decref(v32);
				int64_t v33 = 0LL /* None */;
				push_resource(v30);
				push_resource(r16);
				push_i64(v33);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r34 = pop_resource();
	uint64_t v35 = VU64(VTUP(r34)->cells[2]);
	VAL r36 = pop_resource();
	VAL v37 = (mw_mirth_token_Token_argsZ_0(v35, r36));
	uint64_t v38 = VU64(VTUP(r34)->cells[2]);
	push_resource(v37);
	uint64_t v39 = mw_mirth_token_Token_succ(v38);
	VTUP(r34)->cells[2] = MKU64(v39);
	push_resource(r34);
}
static void mw_mirth_elab_resolveZ_defZ_beginZBang (VAL x1, uint64_t x2, int64_t x3, int64_t x4, VAL x5) {
	if (((bool)x4)) {
		lpush(&lbl_sort, x1);
		lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKI64(x3));
		push_resource(x5);
		lpush(&lbl_ignoreZ_lastZ_name, MKI64(x4));
		lpush(&lbl_token, MKU64(x2));
		VAL v0 = mw_mirth_token_Token_penultimateZ_nameZAsk(x2);
		push_value(v0);
	} else {
		lpush(&lbl_sort, x1);
		lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKI64(x3));
		push_resource(x5);
		lpush(&lbl_ignoreZ_lastZ_name, MKI64(x4));
		lpush(&lbl_token, MKU64(x2));
		VAL v1 = mw_mirth_token_Token_lastZ_nameZAsk(x2);
		push_value(v1);
	}
	VAL v2 = pop_value();
	VAL v3 = mw_std_maybe_Maybe_1_unwrap(v2);
	VAL v4 = mw_mirth_name_Name_defs(VU64(v3));
	int64_t v5 = 0LL /* Nil */;
	int64_t v6 = VI64(lpop(&lbl_reportZ_ambiguousZ_asZ_warning));
	int64_t v7 = VI64(lpop(&lbl_ignoreZ_lastZ_name));
	uint64_t v8 = VU64(lpop(&lbl_token));
	VAL v9 = lpop(&lbl_sort);
	VAL v10 = (mtw_mirth_elab_ZPlusResolveDef_ZPlusResolveDef(v9, v8, v4, MKI64(v5), v7, v6));
	push_resource(v10);
}
static void mw_mirth_elab_resolveZ_defZ_endZBang (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[3]);
	incref(v0);
	switch (get_data_tag(v0)) {
		case 0LL: { // Nil
			VAL v1 = (mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown(x1, x2));
			int64_t v2 = 0LL /* None */;
			push_resource(v1);
			push_i64(v2);
		} break;
		case 1LL: { // Cons
			push_resource(x1);
			push_resource(x2);
			mtp_std_list_List_1_Cons(v0);
			VAL v3 = pop_value();
			switch (get_data_tag(v3)) {
				case 0LL: { // Nil
					VAL r4 = pop_resource();
					mw_mirth_elab_ZPlusResolveDef_rdrop(r4);
					VAL v5 = pop_value();
					VAL v6 = mtw_std_maybe_Maybe_1_Some(v5);
					push_value(v6);
				} break;
				default: {
					int64_t v7 = 0LL /* Nil */;
					push_value(v3);
					VAL v8 = mw_std_list_List_1_reverse(MKI64(v7));
					VAL v9 = pop_value();
					push_resource(v8);
					mw_std_list_List_1_uncons(v9);
					VAL v10 = pop_value();
					VAL v11 = pop_value();
					push_value(v10);
					push_value(v11);
					while(1) {
						VAL v12 = pop_value();
						incref(v12);
						push_value(v12);
						int64_t v13 = mw_std_maybe_Maybe_1_someZAsk(v12);
						if (!((bool)v13)) break;
						VAL v14 = pop_value();
						VAL v15 = mw_std_maybe_Maybe_1_unwrap(v14);
						VAL v16 = pop_value();
						VAL r17 = pop_resource();
						incref(v15);
						VAL v18 = pop_value();
						incref(v18);
						VAL r19 = pop_resource();
						VAL r20 = pop_resource();
						push_value(v18);
						mw_mirth_def_Def_sameZ_resolvedZAsk(r20, v15, v18);
						bool v21 = pop_bool();
						bool v22 = !v21;
						if (v22) {
							push_resource(r19);
							VAL v23 = mtw_std_maybe_Maybe_1_Some(v15);
							push_value(v23);
						} else {
							decref(v15);
							int64_t v24 = 0LL /* None */;
							push_resource(r19);
							push_i64(v24);
						}
						VAL v25 = pop_value();
						switch (get_data_tag(v25)) {
							case 1LL: { // Some
								push_resource(r17);
								VAL v26 = mtp_std_maybe_Maybe_1_Some(v25);
								VAL r27 = pop_resource();
								VAL v28 = mtw_std_list_List_1_Cons(v26, r27);
								push_resource(v28);
							} break;
							case 0LL: { // None
								push_resource(r17);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
								push_resource(r17);
							}
						}
						mw_std_list_List_1_uncons(v16);
						VAL v29 = pop_value();
						VAL v30 = pop_value();
						push_value(v29);
						push_value(v30);
					}
					VAL v31 = pop_value();
					decref(v31);
					VAL v32 = pop_value();
					decref(v32);
					VAL r33 = pop_resource();
					VAL v34 = mw_std_list_List_1_reverse(r33);
					switch (get_data_tag(v34)) {
						case 0LL: { // Nil
							VAL r35 = pop_resource();
							mw_mirth_elab_ZPlusResolveDef_rdrop(r35);
							VAL v36 = pop_value();
							VAL v37 = mtw_std_maybe_Maybe_1_Some(v36);
							push_value(v37);
						} break;
						default: {
							decref(v34);
							VAL v38 = pop_value();
							decref(v38);
							VAL r39 = pop_resource();
							VAL r40 = pop_resource();
							VAL v41 = (mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous(r40, r39));
							int64_t v42 = 0LL /* None */;
							push_resource(v41);
							push_i64(v42);
						} break;
					}
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_resource(x2);
		}
	}
}
static void mw_mirth_elab_ZPlusResolveDef_rdrop (VAL x1) {
	mtp_mirth_elab_ZPlusResolveDef_ZPlusResolveDef(x1);
	VAL v0 = lpop(&lbl_sort);
	uint64_t v1 = VU64(lpop(&lbl_token));
	decref(v0);
	VAL v2 = lpop(&lbl_candidates);
	VAL v3 = lpop(&lbl_rejected);
	decref(v3);
	decref(v2);
	int64_t v4 = VI64(lpop(&lbl_reportZ_ambiguousZ_asZ_warning));
	int64_t v5 = VI64(lpop(&lbl_ignoreZ_lastZ_name));
}
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous (VAL x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[6]);
	if (((bool)v0)) {
		uint64_t v1 = VU64(VTUP(x2)->cells[2]);
		STR* v2;
		STRLIT(v2, "", 0);
		STR* v3;
		STRLIT(v3, "Can't resolve ", 14);
		push_resource(x1);
		push_u64(v1);
		push_resource(x2);
		VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), MKSTR(v2)));
		VAL r5 = pop_resource();
		VAL v6 = VVAL(VTUP(r5)->cells[1]);
		incref(v6);
		push_resource(r5);
		VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, v4));
		STR* v8;
		STRLIT(v8, " due to previous errors. Candidates are:", 40);
		VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
		STR* v10;
		STRLIT(v10, " ", 1);
		VAL r11 = pop_resource();
		VAL v12 = VVAL(VTUP(r11)->cells[3]);
		incref(v12);
		push_str(v10);
		push_resource(r11);
		push_resource(v9);
		mw_std_list_List_1_uncons(v12);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		push_value(v13);
		push_value(v14);
		while(1) {
			VAL v15 = pop_value();
			incref(v15);
			push_value(v15);
			int64_t v16 = mw_std_maybe_Maybe_1_someZAsk(v15);
			if (!((bool)v16)) break;
			VAL v17 = pop_value();
			VAL v18 = mw_std_maybe_Maybe_1_unwrap(v17);
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL r21 = pop_resource();
			push_value(v18);
			VAL v22 = (mw_std_str_ZPlusStr_pushZ_strZBang(v20, r21));
			VAL r23 = pop_resource();
			VAL v24 = pop_value();
			VAL r25 = pop_resource();
			mw_mirth_def_Def_qnameZ_hard(r25, v24);
			VAL v26 = pop_value();
			VAL r27 = pop_resource();
			mw_mirth_name_QName_ZToStr(r27, v26);
			VAL v28 = pop_value();
			push_resource(r23);
			VAL v29 = (mw_std_str_ZPlusStr_pushZ_strZBang(v28, v22));
			STR* v30;
			STRLIT(v30, ", ", 2);
			push_resource(v29);
			push_str(v30);
			mw_std_list_List_1_uncons(v19);
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			push_value(v31);
			push_value(v32);
		}
		VAL v33 = pop_value();
		decref(v33);
		VAL v34 = pop_value();
		decref(v34);
		VAL v35 = pop_value();
		decref(v35);
		VAL r36 = pop_resource();
		VAL r37 = pop_resource();
		VAL r38 = pop_resource();
		uint64_t v39 = pop_u64();
		VAL v40 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(v39, r36, r38));
		push_resource(v40);
		push_resource(r37);
	} else {
		uint64_t v41 = VU64(VTUP(x2)->cells[2]);
		STR* v42;
		STRLIT(v42, "", 0);
		STR* v43;
		STRLIT(v43, "Ambiguous ", 10);
		push_resource(x1);
		push_u64(v41);
		push_resource(x2);
		VAL v44 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v43), MKSTR(v42)));
		VAL r45 = pop_resource();
		VAL v46 = VVAL(VTUP(r45)->cells[1]);
		incref(v46);
		push_resource(r45);
		VAL v47 = (mw_std_str_ZPlusStr_pushZ_strZBang(v46, v44));
		STR* v48;
		STRLIT(v48, ". Can't decide between:", 23);
		VAL v49 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v48), v47));
		STR* v50;
		STRLIT(v50, " ", 1);
		VAL r51 = pop_resource();
		VAL v52 = VVAL(VTUP(r51)->cells[3]);
		incref(v52);
		push_str(v50);
		push_resource(r51);
		push_resource(v49);
		mw_std_list_List_1_uncons(v52);
		VAL v53 = pop_value();
		VAL v54 = pop_value();
		push_value(v53);
		push_value(v54);
		while(1) {
			VAL v55 = pop_value();
			incref(v55);
			push_value(v55);
			int64_t v56 = mw_std_maybe_Maybe_1_someZAsk(v55);
			if (!((bool)v56)) break;
			VAL v57 = pop_value();
			VAL v58 = mw_std_maybe_Maybe_1_unwrap(v57);
			VAL v59 = pop_value();
			VAL v60 = pop_value();
			VAL r61 = pop_resource();
			push_value(v58);
			VAL v62 = (mw_std_str_ZPlusStr_pushZ_strZBang(v60, r61));
			VAL r63 = pop_resource();
			VAL v64 = pop_value();
			VAL r65 = pop_resource();
			mw_mirth_def_Def_qnameZ_hard(r65, v64);
			VAL v66 = pop_value();
			VAL r67 = pop_resource();
			mw_mirth_name_QName_ZToStr(r67, v66);
			VAL v68 = pop_value();
			push_resource(r63);
			VAL v69 = (mw_std_str_ZPlusStr_pushZ_strZBang(v68, v62));
			STR* v70;
			STRLIT(v70, ", ", 2);
			push_resource(v69);
			push_str(v70);
			mw_std_list_List_1_uncons(v59);
			VAL v71 = pop_value();
			VAL v72 = pop_value();
			push_value(v71);
			push_value(v72);
		}
		VAL v73 = pop_value();
		decref(v73);
		VAL v74 = pop_value();
		decref(v74);
		VAL v75 = pop_value();
		decref(v75);
		VAL r76 = pop_resource();
		VAL r77 = pop_resource();
		VAL r78 = pop_resource();
		uint64_t v79 = pop_u64();
		VAL v80 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v79, r76, r78));
		push_resource(v80);
		push_resource(r77);
	}
	VAL r81 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_rdrop(r81);
	VAL r82 = pop_resource();
	return r82;
}
static VAL mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	STR* v1;
	STRLIT(v1, "", 0);
	VAL v2 = VVAL(VTUP(x2)->cells[4]);
	incref(v2);
	switch (get_data_tag(v2)) {
		case 0LL: { // Nil
			STR* v3;
			STRLIT(v3, "Unknown ", 8);
			push_resource(x1);
			push_u64(v0);
			push_resource(x2);
			VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), MKSTR(v1)));
			VAL r5 = pop_resource();
			VAL v6 = VVAL(VTUP(r5)->cells[1]);
			incref(v6);
			push_resource(r5);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(v6, v4));
			STR* v8;
			STRLIT(v8, " name, possibly a misspelling.", 30);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v7));
			push_resource(v9);
		} break;
		case 1LL: { // Cons
			push_resource(x1);
			push_u64(v0);
			push_resource(x2);
			push_resource(MKSTR(v1));
			mtp_std_list_List_1_Cons(v2);
			VAL v10 = pop_value();
			switch (get_data_tag(v10)) {
				case 0LL: { // Nil
					VAL v11 = pop_value();
					switch (get_data_tag(v11)) {
						case 0LL: { // RD_WRONG_SORT
							VAL v12 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v11);
							STR* v13;
							STRLIT(v13, "Expected a ", 11);
							VAL r14 = pop_resource();
							push_value(v12);
							VAL v15 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), r14));
							VAL r16 = pop_resource();
							VAL v17 = VVAL(VTUP(r16)->cells[1]);
							incref(v17);
							push_resource(r16);
							VAL v18 = (mw_std_str_ZPlusStr_pushZ_strZBang(v17, v15));
							STR* v19;
							STRLIT(v19, ", but ", 6);
							VAL v20 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v19), v18));
							VAL r21 = pop_resource();
							VAL v22 = pop_value();
							VAL r23 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r23, v22);
							VAL v24 = pop_value();
							VAL r25 = pop_resource();
							mw_mirth_name_QName_ZToStr(r25, v24);
							VAL v26 = pop_value();
							push_resource(r21);
							VAL v27 = (mw_std_str_ZPlusStr_pushZ_strZBang(v26, v20));
							STR* v28;
							STRLIT(v28, " is not a ", 10);
							VAL v29 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v28), v27));
							VAL r30 = pop_resource();
							VAL v31 = VVAL(VTUP(r30)->cells[1]);
							incref(v31);
							push_resource(r30);
							VAL v32 = (mw_std_str_ZPlusStr_pushZ_strZBang(v31, v29));
							STR* v33;
							STRLIT(v33, ".", 1);
							VAL v34 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v33), v32));
							push_resource(v34);
						} break;
						case 2LL: { // RD_NOT_VISIBLE
							VAL v35 = mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE(v11);
							STR* v36;
							STRLIT(v36, "Not visible in current scope: ", 30);
							VAL r37 = pop_resource();
							push_value(v35);
							VAL v38 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v36), r37));
							VAL r39 = pop_resource();
							VAL v40 = pop_value();
							VAL r41 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r41, v40);
							VAL v42 = pop_value();
							VAL r43 = pop_resource();
							mw_mirth_name_QName_ZToStr(r43, v42);
							VAL v44 = pop_value();
							push_resource(r39);
							VAL v45 = (mw_std_str_ZPlusStr_pushZ_strZBang(v44, v38));
							push_resource(v45);
						} break;
						case 3LL: { // RD_NOT_IMPORTED
							VAL v46 = mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v11);
							STR* v47;
							STRLIT(v47, "Not imported in current scope: ", 31);
							VAL r48 = pop_resource();
							push_value(v46);
							VAL v49 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v47), r48));
							VAL r50 = pop_resource();
							VAL v51 = pop_value();
							VAL r52 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r52, v51);
							VAL v53 = pop_value();
							VAL r54 = pop_resource();
							mw_mirth_name_QName_ZToStr(r54, v53);
							VAL v55 = pop_value();
							push_resource(r50);
							VAL v56 = (mw_std_str_ZPlusStr_pushZ_strZBang(v55, v49));
							push_resource(v56);
						} break;
						case 1LL: { // RD_WRONG_ARITY
							VAL v57 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v11);
							VAL r58 = pop_resource();
							VAL r59 = pop_resource();
							VAL r60 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r60, v57);
							VAL v61 = pop_value();
							incref(v61);
							VAL r62 = pop_resource();
							push_value(v61);
							mw_mirth_name_QName_ZToStr(r62, v61);
							VAL v63 = pop_value();
							push_resource(r59);
							VAL v64 = (mw_std_str_ZPlusStr_pushZ_strZBang(v63, r58));
							STR* v65;
							STRLIT(v65, " expects ", 9);
							VAL v66 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v65), v64));
							VAL v67 = pop_value();
							int64_t v68 = VI64(VTUP(v67)->cells[3]);
							decref(v67);
							STR* v69 = i64_show(v68);
							VAL v70 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v69), v66));
							STR* v71;
							STRLIT(v71, " arguments, but got ", 20);
							VAL v72 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v71), v70));
							VAL r73 = pop_resource();
							uint64_t v74 = VU64(VTUP(r73)->cells[2]);
							push_resource(r73);
							push_resource(v72);
							int64_t v75 = mw_mirth_token_Token_numZ_args(v74);
							STR* v76 = i64_show(v75);
							VAL r77 = pop_resource();
							VAL v78 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v76), r77));
							STR* v79;
							STRLIT(v79, ".", 1);
							VAL v80 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v79), v78));
							push_resource(v80);
						} break;
						case 4LL: { // RD_WRONG_QUALIFIER
							VAL v81 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v11);
							STR* v82;
							STRLIT(v82, "Qualified name not found. Perhaps you meant: ", 45);
							VAL r83 = pop_resource();
							push_value(v81);
							VAL v84 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v82), r83));
							VAL r85 = pop_resource();
							VAL v86 = pop_value();
							VAL r87 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r87, v86);
							VAL v88 = pop_value();
							VAL r89 = pop_resource();
							mw_mirth_name_QName_ZToStr(r89, v88);
							VAL v90 = pop_value();
							push_resource(r85);
							VAL v91 = (mw_std_str_ZPlusStr_pushZ_strZBang(v90, v84));
							push_resource(v91);
						} break;
						case 5LL: { // RD_WRONG_CONSTRUCTOR
							VAL v92 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v11);
							STR* v93;
							STRLIT(v93, "Constructor is for a different type: ", 37);
							VAL r94 = pop_resource();
							push_value(v92);
							VAL v95 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v93), r94));
							VAL r96 = pop_resource();
							VAL v97 = pop_value();
							VAL r98 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r98, v97);
							VAL v99 = pop_value();
							VAL r100 = pop_resource();
							mw_mirth_name_QName_ZToStr(r100, v99);
							VAL v101 = pop_value();
							push_resource(r96);
							VAL v102 = (mw_std_str_ZPlusStr_pushZ_strZBang(v101, v95));
							push_resource(v102);
						} break;
						case 7LL: { // RD_METHOD_WRONG_TYPE
							VAL v103 = mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v11);
							STR* v104;
							STRLIT(v104, "Method is for a different type: ", 32);
							VAL r105 = pop_resource();
							push_value(v103);
							VAL v106 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v104), r105));
							VAL r107 = pop_resource();
							VAL v108 = pop_value();
							VAL r109 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r109, v108);
							VAL v110 = pop_value();
							VAL r111 = pop_resource();
							mw_mirth_name_QName_ZToStr(r111, v110);
							VAL v112 = pop_value();
							push_resource(r107);
							VAL v113 = (mw_std_str_ZPlusStr_pushZ_strZBang(v112, v106));
							push_resource(v113);
						} break;
						case 6LL: { // RD_METHOD_NOT_AVAILABLE
							VAL v114 = mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v11);
							STR* v115;
							STRLIT(v115, "Method is not available for current stack: ", 43);
							VAL r116 = pop_resource();
							push_value(v114);
							VAL v117 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v115), r116));
							VAL r118 = pop_resource();
							VAL v119 = pop_value();
							VAL r120 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard(r120, v119);
							VAL v121 = pop_value();
							VAL r122 = pop_resource();
							mw_mirth_name_QName_ZToStr(r122, v121);
							VAL v123 = pop_value();
							push_resource(r118);
							VAL v124 = (mw_std_str_ZPlusStr_pushZ_strZBang(v123, v117));
							push_resource(v124);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} break;
				default: {
					VAL v125 = pop_value();
					VAL v126 = mtw_std_list_List_1_Cons(v125, v10);
					STR* v127;
					STRLIT(v127, "Multiple definitions for name, but none are suitable:", 53);
					VAL r128 = pop_resource();
					push_value(v126);
					VAL v129 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v127), r128));
					VAL v130 = pop_value();
					STR* v131;
					STRLIT(v131, " ", 1);
					push_resource(v129);
					push_str(v131);
					mw_std_list_List_1_uncons(v130);
					VAL v132 = pop_value();
					VAL v133 = pop_value();
					push_value(v132);
					push_value(v133);
					while(1) {
						VAL v134 = pop_value();
						incref(v134);
						push_value(v134);
						int64_t v135 = mw_std_maybe_Maybe_1_someZAsk(v134);
						if (!((bool)v135)) break;
						VAL v136 = pop_value();
						VAL v137 = mw_std_maybe_Maybe_1_unwrap(v136);
						VAL v138 = pop_value();
						VAL v139 = pop_value();
						VAL r140 = pop_resource();
						push_value(v137);
						VAL v141 = (mw_std_str_ZPlusStr_pushZ_strZBang(v139, r140));
						VAL v142 = pop_value();
						switch (get_data_tag(v142)) {
							case 0LL: { // RD_WRONG_SORT
								push_resource(v141);
								VAL v143 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v142);
								VAL r144 = pop_resource();
								VAL r145 = pop_resource();
								VAL r146 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r146, v143);
								VAL v147 = pop_value();
								VAL r148 = pop_resource();
								mw_mirth_name_QName_ZToStr(r148, v147);
								VAL v149 = pop_value();
								push_resource(r145);
								VAL v150 = (mw_std_str_ZPlusStr_pushZ_strZBang(v149, r144));
								STR* v151;
								STRLIT(v151, " is not a ", 10);
								VAL v152 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v151), v150));
								VAL r153 = pop_resource();
								VAL v154 = VVAL(VTUP(r153)->cells[1]);
								incref(v154);
								push_resource(r153);
								VAL v155 = (mw_std_str_ZPlusStr_pushZ_strZBang(v154, v152));
								push_resource(v155);
							} break;
							case 2LL: { // RD_NOT_VISIBLE
								push_resource(v141);
								VAL v156 = mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE(v142);
								VAL r157 = pop_resource();
								VAL r158 = pop_resource();
								VAL r159 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r159, v156);
								VAL v160 = pop_value();
								VAL r161 = pop_resource();
								mw_mirth_name_QName_ZToStr(r161, v160);
								VAL v162 = pop_value();
								push_resource(r158);
								VAL v163 = (mw_std_str_ZPlusStr_pushZ_strZBang(v162, r157));
								STR* v164;
								STRLIT(v164, " is not visible in current scope", 32);
								VAL v165 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v164), v163));
								push_resource(v165);
							} break;
							case 3LL: { // RD_NOT_IMPORTED
								push_resource(v141);
								VAL v166 = mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v142);
								VAL r167 = pop_resource();
								VAL r168 = pop_resource();
								VAL r169 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r169, v166);
								VAL v170 = pop_value();
								VAL r171 = pop_resource();
								mw_mirth_name_QName_ZToStr(r171, v170);
								VAL v172 = pop_value();
								push_resource(r168);
								VAL v173 = (mw_std_str_ZPlusStr_pushZ_strZBang(v172, r167));
								STR* v174;
								STRLIT(v174, " is not imported in current scope", 33);
								VAL v175 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v174), v173));
								push_resource(v175);
							} break;
							case 1LL: { // RD_WRONG_ARITY
								push_resource(v141);
								VAL v176 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v142);
								VAL r177 = pop_resource();
								VAL r178 = pop_resource();
								VAL r179 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r179, v176);
								VAL v180 = pop_value();
								incref(v180);
								VAL r181 = pop_resource();
								push_value(v180);
								mw_mirth_name_QName_ZToStr(r181, v180);
								VAL v182 = pop_value();
								push_resource(r178);
								VAL v183 = (mw_std_str_ZPlusStr_pushZ_strZBang(v182, r177));
								STR* v184;
								STRLIT(v184, " expects ", 9);
								VAL v185 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v184), v183));
								VAL v186 = pop_value();
								int64_t v187 = VI64(VTUP(v186)->cells[3]);
								decref(v186);
								STR* v188 = i64_show(v187);
								VAL v189 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v188), v185));
								STR* v190;
								STRLIT(v190, " arguments", 10);
								VAL v191 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v190), v189));
								push_resource(v191);
							} break;
							case 4LL: { // RD_WRONG_QUALIFIER
								push_resource(v141);
								VAL v192 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v142);
								VAL r193 = pop_resource();
								VAL r194 = pop_resource();
								VAL r195 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r195, v192);
								VAL v196 = pop_value();
								VAL r197 = pop_resource();
								mw_mirth_name_QName_ZToStr(r197, v196);
								VAL v198 = pop_value();
								push_resource(r194);
								VAL v199 = (mw_std_str_ZPlusStr_pushZ_strZBang(v198, r193));
								STR* v200;
								STRLIT(v200, " doesn't match the given qualified name", 39);
								VAL v201 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v200), v199));
								push_resource(v201);
							} break;
							case 5LL: { // RD_WRONG_CONSTRUCTOR
								push_resource(v141);
								VAL v202 = mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v142);
								VAL r203 = pop_resource();
								VAL r204 = pop_resource();
								VAL r205 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r205, v202);
								VAL v206 = pop_value();
								VAL r207 = pop_resource();
								mw_mirth_name_QName_ZToStr(r207, v206);
								VAL v208 = pop_value();
								push_resource(r204);
								VAL v209 = (mw_std_str_ZPlusStr_pushZ_strZBang(v208, r203));
								STR* v210;
								STRLIT(v210, " is constructor for a different type", 36);
								VAL v211 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v210), v209));
								push_resource(v211);
							} break;
							case 7LL: { // RD_METHOD_WRONG_TYPE
								push_resource(v141);
								VAL v212 = mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v142);
								VAL r213 = pop_resource();
								VAL r214 = pop_resource();
								VAL r215 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r215, v212);
								VAL v216 = pop_value();
								VAL r217 = pop_resource();
								mw_mirth_name_QName_ZToStr(r217, v216);
								VAL v218 = pop_value();
								push_resource(r214);
								VAL v219 = (mw_std_str_ZPlusStr_pushZ_strZBang(v218, r213));
								STR* v220;
								STRLIT(v220, " is method for a different type", 31);
								VAL v221 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v220), v219));
								push_resource(v221);
							} break;
							case 6LL: { // RD_METHOD_NOT_AVAILABLE
								push_resource(v141);
								VAL v222 = mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v142);
								VAL r223 = pop_resource();
								VAL r224 = pop_resource();
								VAL r225 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard(r225, v222);
								VAL v226 = pop_value();
								VAL r227 = pop_resource();
								mw_mirth_name_QName_ZToStr(r227, v226);
								VAL v228 = pop_value();
								push_resource(r224);
								VAL v229 = (mw_std_str_ZPlusStr_pushZ_strZBang(v228, r223));
								STR* v230;
								STRLIT(v230, " is not avaliable for current stack", 35);
								VAL v231 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v230), v229));
								push_resource(v231);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
								push_resource(v141);
							}
						}
						STR* v232;
						STRLIT(v232, ", ", 2);
						push_str(v232);
						mw_std_list_List_1_uncons(v138);
						VAL v233 = pop_value();
						VAL v234 = pop_value();
						push_value(v233);
						push_value(v234);
					}
					VAL v235 = pop_value();
					decref(v235);
					VAL v236 = pop_value();
					decref(v236);
					VAL v237 = pop_value();
					decref(v237);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_u64(v0);
			push_resource(x2);
			push_resource(MKSTR(v1));
		}
	}
	VAL r238 = pop_resource();
	VAL r239 = pop_resource();
	VAL r240 = pop_resource();
	uint64_t v241 = pop_u64();
	VAL v242 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v241, r238, r240));
	push_resource(v242);
	mw_mirth_elab_ZPlusResolveDef_rdrop(r239);
	VAL r243 = pop_resource();
	return r243;
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_arity (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_mirth_token_Token_numZ_args(v0);
	VAL r2 = pop_resource();
	VAL v3 = VVAL(VTUP(r2)->cells[3]);
	incref(v3);
	int64_t v4 = 0LL /* Nil */;
	int64_t v5 = 0LL /* Nil */;
	push_i64(v1);
	push_resource(r2);
	push_i64(v4);
	push_i64(v5);
	mw_std_list_List_1_uncons(v3);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
		if (!((bool)v9)) break;
		VAL v10 = pop_value();
		VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v15);
		incref(v11);
		VAL r16 = pop_resource();
		push_value(v15);
		push_value(v11);
		push_value(v15);
		int64_t v17 = mw_mirth_def_Def_arity(v11);
		int64_t v18 = pop_i64();
		push_resource(r16);
		int64_t v19 = mw_mirth_elab_arityZ_compatibleZAsk(v18, v17);
		if (((bool)v19)) {
			VAL v20 = pop_value();
			VAL v21 = mtw_std_either_Either_2_Right(v20);
			push_value(v21);
		} else {
			VAL v22 = pop_value();
			VAL v23 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v22);
			VAL v24 = mtw_std_either_Either_2_Left(v23);
			push_value(v24);
		}
		VAL v25 = pop_value();
		switch (get_data_tag(v25)) {
			case 0LL: { // Left
				push_value(v14);
				push_value(v13);
				VAL v26 = mtp_std_either_Either_2_Left(v25);
				VAL v27 = pop_value();
				VAL v28 = pop_value();
				VAL v29 = mtw_std_list_List_1_Cons(v26, v28);
				push_value(v29);
				push_value(v27);
			} break;
			case 1LL: { // Right
				push_value(v14);
				push_value(v13);
				VAL v30 = mtp_std_either_Either_2_Right(v25);
				VAL v31 = pop_value();
				VAL v32 = mtw_std_list_List_1_Cons(v30, v31);
				push_value(v32);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_value(v14);
				push_value(v13);
			}
		}
		mw_std_list_List_1_uncons(v12);
		VAL v33 = pop_value();
		VAL v34 = pop_value();
		push_value(v33);
		push_value(v34);
	}
	VAL v35 = pop_value();
	decref(v35);
	VAL v36 = pop_value();
	decref(v36);
	VAL v37 = pop_value();
	VAL v38 = pop_value();
	VAL v39 = mw_std_list_List_1_reverse(v38);
	push_value(v39);
	VAL v40 = mw_std_list_List_1_reverse(v37);
	VAL r41 = pop_resource();
	VAL v42 = VVAL(VTUP(r41)->cells[4]);
	incref(v42);
	VAL v43 = pop_value();
	VAL v44 = mw_std_list_List_1_cat(v43, v42);
	VAL v45 = VTUP(r41)->cells[4];
	decref(v45);
	VTUP(r41)->cells[4] = v44;
	VAL v46 = VTUP(r41)->cells[3];
	decref(v46);
	VTUP(r41)->cells[3] = v40;
	int64_t v47 = pop_i64();
	push_resource(r41);
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	VAL v1 = mw_mirth_token_Token_dnameZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL r3 = pop_resource();
			VAL v4 = VVAL(VTUP(r3)->cells[3]);
			incref(v4);
			int64_t v5 = 0LL /* Nil */;
			int64_t v6 = 0LL /* Nil */;
			push_value(v2);
			push_resource(r3);
			push_i64(v5);
			push_i64(v6);
			mw_std_list_List_1_uncons(v4);
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			push_value(v7);
			push_value(v8);
			while(1) {
				VAL v9 = pop_value();
				incref(v9);
				push_value(v9);
				int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
				if (!((bool)v10)) break;
				VAL v11 = pop_value();
				VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				incref(v16);
				incref(v12);
				VAL r17 = pop_resource();
				VAL r18 = pop_resource();
				push_value(v16);
				push_value(v12);
				push_value(v16);
				mw_mirth_def_Def_qnameZ_hard(r18, v12);
				VAL v19 = pop_value();
				VAL v20 = pop_value();
				VAL r21 = pop_resource();
				mw_mirth_name_QName_climbZ_upZ_dnameZAsk(r21, r17, v20, v19);
				VAL v22 = pop_value();
				int64_t v23 = mw_std_list_List_1_emptyZAsk(v22);
				bool v24 = !((bool)v23);
				if (v24) {
					VAL v25 = pop_value();
					VAL v26 = mtw_std_either_Either_2_Right(v25);
					push_value(v26);
				} else {
					VAL v27 = pop_value();
					VAL v28 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER(v27);
					VAL v29 = mtw_std_either_Either_2_Left(v28);
					push_value(v29);
				}
				VAL v30 = pop_value();
				switch (get_data_tag(v30)) {
					case 0LL: { // Left
						push_value(v15);
						push_value(v14);
						VAL v31 = mtp_std_either_Either_2_Left(v30);
						VAL v32 = pop_value();
						VAL v33 = pop_value();
						VAL v34 = mtw_std_list_List_1_Cons(v31, v33);
						push_value(v34);
						push_value(v32);
					} break;
					case 1LL: { // Right
						push_value(v15);
						push_value(v14);
						VAL v35 = mtp_std_either_Either_2_Right(v30);
						VAL v36 = pop_value();
						VAL v37 = mtw_std_list_List_1_Cons(v35, v36);
						push_value(v37);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v15);
						push_value(v14);
					}
				}
				mw_std_list_List_1_uncons(v13);
				VAL v38 = pop_value();
				VAL v39 = pop_value();
				push_value(v38);
				push_value(v39);
			}
			VAL v40 = pop_value();
			decref(v40);
			VAL v41 = pop_value();
			decref(v41);
			VAL v42 = pop_value();
			VAL v43 = pop_value();
			VAL v44 = mw_std_list_List_1_reverse(v43);
			push_value(v44);
			VAL v45 = mw_std_list_List_1_reverse(v42);
			VAL r46 = pop_resource();
			VAL v47 = VVAL(VTUP(r46)->cells[4]);
			incref(v47);
			VAL v48 = pop_value();
			VAL v49 = mw_std_list_List_1_cat(v48, v47);
			VAL v50 = VTUP(r46)->cells[4];
			decref(v50);
			VTUP(r46)->cells[4] = v49;
			VAL v51 = VTUP(r46)->cells[3];
			decref(v51);
			VTUP(r46)->cells[3] = v45;
			VAL v52 = pop_value();
			decref(v52);
			push_resource(r46);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_roots (VAL x1, VAL x2, VAL x3) {
	uint64_t v0 = VU64(VTUP(x3)->cells[2]);
	push_value(x1);
	push_resource(x2);
	push_resource(x3);
	VAL v1 = mw_mirth_token_Token_nameZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			decref(v2);
			VAL r3 = pop_resource();
			VAL v4 = VVAL(VTUP(r3)->cells[3]);
			incref(v4);
			int64_t v5 = 0LL /* Nil */;
			int64_t v6 = 0LL /* Nil */;
			push_resource(r3);
			push_i64(v5);
			push_i64(v6);
			mw_std_list_List_1_uncons(v4);
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			push_value(v7);
			push_value(v8);
			while(1) {
				VAL v9 = pop_value();
				incref(v9);
				push_value(v9);
				int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
				if (!((bool)v10)) break;
				VAL v11 = pop_value();
				VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				incref(v16);
				incref(v12);
				VAL r17 = pop_resource();
				VAL r18 = pop_resource();
				push_value(v16);
				push_value(v12);
				push_value(v16);
				mw_mirth_def_Def_qnameZ_hard(r18, v12);
				VAL v19 = pop_value();
				VAL v20 = VVAL(VTUP(v19)->cells[1]);
				incref(v20);
				decref(v19);
				VAL v21 = pop_value();
				int64_t v22 = 0LL /* None */;
				push_resource(r17);
				push_value(v20);
				push_i64(v22);
				mw_std_list_List_1_uncons(v21);
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v23);
				push_value(v24);
				while(1) {
					VAL v25 = pop_value();
					incref(v25);
					push_value(v25);
					int64_t v26 = mw_std_maybe_Maybe_1_someZAsk(v25);
					if (!((bool)v26)) break;
					VAL v27 = pop_value();
					VAL v28 = mw_std_maybe_Maybe_1_unwrap(v27);
					VAL v29 = pop_value();
					VAL v30 = pop_value();
					incref(v28);
					VAL v31 = pop_value();
					incref(v31);
					int64_t v32 = mw_mirth_name_Namespace_ZEqualZEqual(v31, v28);
					if (((bool)v32)) {
						push_value(v31);
						VAL v33 = mtw_std_maybe_Maybe_1_Some(v28);
						push_value(v33);
					} else {
						decref(v28);
						int64_t v34 = 0LL /* None */;
						push_value(v31);
						push_i64(v34);
					}
					VAL v35 = pop_value();
					switch (get_data_tag(v35)) {
						case 0LL: { // None
							push_value(v30);
							push_value(v29);
						} break;
						default: {
							decref(v29);
							decref(v30);
							int64_t v36 = 0LL /* Nil */;
							push_value(v35);
							push_i64(v36);
						} break;
					}
					VAL v37 = pop_value();
					mw_std_list_List_1_uncons(v37);
					VAL v38 = pop_value();
					VAL v39 = pop_value();
					push_value(v38);
					push_value(v39);
				}
				VAL v40 = pop_value();
				decref(v40);
				VAL v41 = pop_value();
				decref(v41);
				VAL v42 = pop_value();
				VAL v43 = pop_value();
				decref(v43);
				int64_t v44 = mw_std_maybe_Maybe_1_someZAsk(v42);
				if (((bool)v44)) {
					int64_t v45 = 1LL /* True */;
					push_i64(v45);
				} else {
					VAL r46 = pop_resource();
					uint64_t v47 = VU64(VTUP(r46)->cells[2]);
					VAL v48 = pop_value();
					incref(v48);
					VAL r49 = pop_resource();
					push_value(v48);
					mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk(r49, v47, v48);
					push_resource(r46);
				}
				bool v50 = pop_bool();
				if (v50) {
					VAL v51 = pop_value();
					VAL v52 = mtw_std_either_Either_2_Right(v51);
					push_value(v52);
				} else {
					VAL v53 = pop_value();
					incref(v53);
					VAL r54 = pop_resource();
					VAL r55 = pop_resource();
					push_value(v53);
					mw_mirth_def_Def_qnameZ_hard(r55, v53);
					VAL v56 = pop_value();
					VAL v57 = VVAL(VTUP(v56)->cells[1]);
					incref(v57);
					decref(v56);
					switch (get_data_tag(v57)) {
						case 3LL: { // NAMESPACE_TYCON
							push_resource(r54);
							VAL v58 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v57);
							decref(v58);
							VAL r59 = pop_resource();
							uint64_t v60 = VU64(VTUP(r59)->cells[2]);
							push_resource(r59);
							VAL v61 = mw_mirth_token_Token_nameZAsk(v60);
							VAL v62 = mw_std_maybe_Maybe_1_unwrap(v61);
							int64_t v63 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(VU64(v62));
							if (((bool)v63)) {
								VAL v64 = pop_value();
								VAL v65 = pop_value();
								incref(v65);
								push_value(v65);
								push_value(v64);
								int64_t v66 = mw_std_list_List_1_emptyZAsk(v65);
								if (((bool)v66)) {
									VAL v67 = pop_value();
									VAL v68 = mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v67);
									push_value(v68);
								} else {
									VAL v69 = pop_value();
									VAL v70 = mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v69);
									push_value(v70);
								}
							} else {
								VAL v71 = pop_value();
								VAL v72 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v71);
								push_value(v72);
							}
						} break;
						default: {
							decref(v57);
							VAL v73 = pop_value();
							push_resource(r54);
							VAL v74 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v73);
							push_value(v74);
						} break;
					}
					VAL v75 = pop_value();
					VAL v76 = mtw_std_either_Either_2_Left(v75);
					push_value(v76);
				}
				VAL v77 = pop_value();
				switch (get_data_tag(v77)) {
					case 0LL: { // Left
						push_value(v15);
						push_value(v14);
						VAL v78 = mtp_std_either_Either_2_Left(v77);
						VAL v79 = pop_value();
						VAL v80 = pop_value();
						VAL v81 = mtw_std_list_List_1_Cons(v78, v80);
						push_value(v81);
						push_value(v79);
					} break;
					case 1LL: { // Right
						push_value(v15);
						push_value(v14);
						VAL v82 = mtp_std_either_Either_2_Right(v77);
						VAL v83 = pop_value();
						VAL v84 = mtw_std_list_List_1_Cons(v82, v83);
						push_value(v84);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v15);
						push_value(v14);
					}
				}
				mw_std_list_List_1_uncons(v13);
				VAL v85 = pop_value();
				VAL v86 = pop_value();
				push_value(v85);
				push_value(v86);
			}
			VAL v87 = pop_value();
			decref(v87);
			VAL v88 = pop_value();
			decref(v88);
			VAL v89 = pop_value();
			VAL v90 = pop_value();
			VAL v91 = mw_std_list_List_1_reverse(v90);
			push_value(v91);
			VAL v92 = mw_std_list_List_1_reverse(v89);
			VAL r93 = pop_resource();
			VAL v94 = VVAL(VTUP(r93)->cells[4]);
			incref(v94);
			VAL v95 = pop_value();
			VAL v96 = mw_std_list_List_1_cat(v95, v94);
			VAL v97 = VTUP(r93)->cells[4];
			decref(v97);
			VTUP(r93)->cells[4] = v96;
			VAL v98 = VTUP(r93)->cells[3];
			decref(v98);
			VTUP(r93)->cells[3] = v92;
			push_resource(r93);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r99 = pop_resource();
	uint64_t v100 = VU64(VTUP(r99)->cells[2]);
	push_resource(r99);
	VAL v101 = mw_mirth_token_Token_dnameZAsk(v100);
	switch (get_data_tag(v101)) {
		case 1LL: { // Some
			VAL v102 = mtp_std_maybe_Maybe_1_Some(v101);
			incref(v102);
			push_value(v102);
			int64_t v103 = mw_mirth_name_DName_isZ_relativeZAsk(v102);
			if (((bool)v103)) {
				VAL r104 = pop_resource();
				int64_t v105 = VI64(VTUP(r104)->cells[5]);
				bool v106 = !((bool)v105);
				push_resource(r104);
				push_bool(v106);
			} else {
				int64_t v107 = 0LL /* False */;
				push_i64(v107);
			}
			bool v108 = pop_bool();
			if (v108) {
				VAL r109 = pop_resource();
				VAL v110 = VVAL(VTUP(r109)->cells[3]);
				incref(v110);
				int64_t v111 = 0LL /* Nil */;
				int64_t v112 = 0LL /* Nil */;
				push_resource(r109);
				push_i64(v111);
				push_i64(v112);
				mw_std_list_List_1_uncons(v110);
				VAL v113 = pop_value();
				VAL v114 = pop_value();
				push_value(v113);
				push_value(v114);
				while(1) {
					VAL v115 = pop_value();
					incref(v115);
					push_value(v115);
					int64_t v116 = mw_std_maybe_Maybe_1_someZAsk(v115);
					if (!((bool)v116)) break;
					VAL v117 = pop_value();
					VAL v118 = mw_std_maybe_Maybe_1_unwrap(v117);
					VAL v119 = pop_value();
					VAL v120 = pop_value();
					VAL v121 = pop_value();
					VAL v122 = pop_value();
					incref(v122);
					incref(v118);
					VAL r123 = pop_resource();
					VAL r124 = pop_resource();
					push_value(v122);
					push_value(v118);
					push_value(v122);
					mw_mirth_def_Def_qnameZ_hard(r124, v118);
					VAL v125 = pop_value();
					VAL v126 = pop_value();
					VAL r127 = pop_resource();
					mw_mirth_name_QName_climbZ_upZ_dnameZAsk(r127, r123, v126, v125);
					int64_t v128 = 0LL /* None */;
					VAL v129 = pop_value();
					push_i64(v128);
					mw_std_list_List_1_uncons(v129);
					VAL v130 = pop_value();
					VAL v131 = pop_value();
					push_value(v130);
					push_value(v131);
					while(1) {
						VAL v132 = pop_value();
						incref(v132);
						push_value(v132);
						int64_t v133 = mw_std_maybe_Maybe_1_someZAsk(v132);
						if (!((bool)v133)) break;
						VAL v134 = pop_value();
						VAL v135 = mw_std_maybe_Maybe_1_unwrap(v134);
						VAL v136 = pop_value();
						VAL v137 = pop_value();
						incref(v135);
						VAL v138 = pop_value();
						VAL v139 = pop_value();
						VAL v140 = pop_value();
						incref(v140);
						int64_t v141 = 0LL /* None */;
						push_value(v140);
						push_value(v139);
						push_value(v138);
						push_value(v135);
						push_i64(v141);
						mw_std_list_List_1_uncons(v140);
						VAL v142 = pop_value();
						VAL v143 = pop_value();
						push_value(v142);
						push_value(v143);
						while(1) {
							VAL v144 = pop_value();
							incref(v144);
							push_value(v144);
							int64_t v145 = mw_std_maybe_Maybe_1_someZAsk(v144);
							if (!((bool)v145)) break;
							VAL v146 = pop_value();
							VAL v147 = mw_std_maybe_Maybe_1_unwrap(v146);
							VAL v148 = pop_value();
							VAL v149 = pop_value();
							incref(v147);
							VAL v150 = pop_value();
							incref(v150);
							int64_t v151 = mw_mirth_name_Namespace_ZEqualZEqual(v150, v147);
							if (((bool)v151)) {
								push_value(v150);
								VAL v152 = mtw_std_maybe_Maybe_1_Some(v147);
								push_value(v152);
							} else {
								decref(v147);
								int64_t v153 = 0LL /* None */;
								push_value(v150);
								push_i64(v153);
							}
							VAL v154 = pop_value();
							switch (get_data_tag(v154)) {
								case 0LL: { // None
									push_value(v149);
									push_value(v148);
								} break;
								default: {
									decref(v148);
									decref(v149);
									int64_t v155 = 0LL /* Nil */;
									push_value(v154);
									push_i64(v155);
								} break;
							}
							VAL v156 = pop_value();
							mw_std_list_List_1_uncons(v156);
							VAL v157 = pop_value();
							VAL v158 = pop_value();
							push_value(v157);
							push_value(v158);
						}
						VAL v159 = pop_value();
						decref(v159);
						VAL v160 = pop_value();
						decref(v160);
						VAL v161 = pop_value();
						VAL v162 = pop_value();
						decref(v162);
						int64_t v163 = mw_std_maybe_Maybe_1_someZAsk(v161);
						if (((bool)v163)) {
							VAL v164 = mtw_std_maybe_Maybe_1_Some(v135);
							push_value(v164);
						} else {
							decref(v135);
							int64_t v165 = 0LL /* None */;
							push_i64(v165);
						}
						VAL v166 = pop_value();
						switch (get_data_tag(v166)) {
							case 0LL: { // None
								push_value(v137);
								push_value(v136);
							} break;
							default: {
								decref(v136);
								decref(v137);
								int64_t v167 = 0LL /* Nil */;
								push_value(v166);
								push_i64(v167);
							} break;
						}
						VAL v168 = pop_value();
						mw_std_list_List_1_uncons(v168);
						VAL v169 = pop_value();
						VAL v170 = pop_value();
						push_value(v169);
						push_value(v170);
					}
					VAL v171 = pop_value();
					decref(v171);
					VAL v172 = pop_value();
					decref(v172);
					VAL v173 = pop_value();
					int64_t v174 = mw_std_maybe_Maybe_1_someZAsk(v173);
					if (((bool)v174)) {
						VAL v175 = pop_value();
						VAL v176 = mtw_std_either_Either_2_Right(v175);
						push_value(v176);
					} else {
						VAL v177 = pop_value();
						VAL v178 = pop_value();
						VAL v179 = pop_value();
						incref(v179);
						push_value(v179);
						push_value(v178);
						push_value(v177);
						int64_t v180 = mw_std_list_List_1_emptyZAsk(v179);
						if (((bool)v180)) {
							VAL v181 = pop_value();
							VAL v182 = mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE(v181);
							push_value(v182);
						} else {
							VAL v183 = pop_value();
							VAL v184 = mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE(v183);
							push_value(v184);
						}
						VAL v185 = pop_value();
						VAL v186 = mtw_std_either_Either_2_Left(v185);
						push_value(v186);
					}
					VAL v187 = pop_value();
					switch (get_data_tag(v187)) {
						case 0LL: { // Left
							push_value(v121);
							push_value(v120);
							VAL v188 = mtp_std_either_Either_2_Left(v187);
							VAL v189 = pop_value();
							VAL v190 = pop_value();
							VAL v191 = mtw_std_list_List_1_Cons(v188, v190);
							push_value(v191);
							push_value(v189);
						} break;
						case 1LL: { // Right
							push_value(v121);
							push_value(v120);
							VAL v192 = mtp_std_either_Either_2_Right(v187);
							VAL v193 = pop_value();
							VAL v194 = mtw_std_list_List_1_Cons(v192, v193);
							push_value(v194);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v121);
							push_value(v120);
						}
					}
					mw_std_list_List_1_uncons(v119);
					VAL v195 = pop_value();
					VAL v196 = pop_value();
					push_value(v195);
					push_value(v196);
				}
				VAL v197 = pop_value();
				decref(v197);
				VAL v198 = pop_value();
				decref(v198);
				VAL v199 = pop_value();
				VAL v200 = pop_value();
				VAL v201 = mw_std_list_List_1_reverse(v200);
				push_value(v201);
				VAL v202 = mw_std_list_List_1_reverse(v199);
				VAL r203 = pop_resource();
				VAL v204 = VVAL(VTUP(r203)->cells[4]);
				incref(v204);
				VAL v205 = pop_value();
				VAL v206 = mw_std_list_List_1_cat(v205, v204);
				VAL v207 = VTUP(r203)->cells[4];
				decref(v207);
				VTUP(r203)->cells[4] = v206;
				VAL v208 = VTUP(r203)->cells[3];
				decref(v208);
				VTUP(r203)->cells[3] = v202;
				push_resource(r203);
			} else {
				VAL r209 = pop_resource();
				VAL v210 = VVAL(VTUP(r209)->cells[3]);
				incref(v210);
				int64_t v211 = 0LL /* Nil */;
				int64_t v212 = 0LL /* Nil */;
				push_resource(r209);
				push_i64(v211);
				push_i64(v212);
				mw_std_list_List_1_uncons(v210);
				VAL v213 = pop_value();
				VAL v214 = pop_value();
				push_value(v213);
				push_value(v214);
				while(1) {
					VAL v215 = pop_value();
					incref(v215);
					push_value(v215);
					int64_t v216 = mw_std_maybe_Maybe_1_someZAsk(v215);
					if (!((bool)v216)) break;
					VAL v217 = pop_value();
					VAL v218 = mw_std_maybe_Maybe_1_unwrap(v217);
					VAL v219 = pop_value();
					VAL v220 = pop_value();
					VAL v221 = pop_value();
					VAL v222 = pop_value();
					incref(v222);
					incref(v218);
					VAL r223 = pop_resource();
					VAL r224 = pop_resource();
					push_value(v222);
					push_value(v218);
					push_value(v222);
					mw_mirth_def_Def_qnameZ_hard(r224, v218);
					VAL v225 = pop_value();
					VAL v226 = pop_value();
					VAL r227 = pop_resource();
					mw_mirth_name_QName_climbZ_upZ_dnameZAsk(r227, r223, v226, v225);
					int64_t v228 = 0LL /* None */;
					VAL v229 = pop_value();
					push_i64(v228);
					mw_std_list_List_1_uncons(v229);
					VAL v230 = pop_value();
					VAL v231 = pop_value();
					push_value(v230);
					push_value(v231);
					while(1) {
						VAL v232 = pop_value();
						incref(v232);
						push_value(v232);
						int64_t v233 = mw_std_maybe_Maybe_1_someZAsk(v232);
						if (!((bool)v233)) break;
						VAL v234 = pop_value();
						VAL v235 = mw_std_maybe_Maybe_1_unwrap(v234);
						VAL v236 = pop_value();
						VAL v237 = pop_value();
						incref(v235);
						VAL r238 = pop_resource();
						uint64_t v239 = VU64(VTUP(r238)->cells[2]);
						VAL r240 = pop_resource();
						mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(r240, v239, v235);
						int64_t v241 = pop_i64();
						if (((bool)v241)) {
							push_resource(r238);
							VAL v242 = mtw_std_maybe_Maybe_1_Some(v235);
							push_value(v242);
						} else {
							decref(v235);
							int64_t v243 = 0LL /* None */;
							push_resource(r238);
							push_i64(v243);
						}
						VAL v244 = pop_value();
						switch (get_data_tag(v244)) {
							case 0LL: { // None
								push_value(v237);
								push_value(v236);
							} break;
							default: {
								decref(v236);
								decref(v237);
								int64_t v245 = 0LL /* Nil */;
								push_value(v244);
								push_i64(v245);
							} break;
						}
						VAL v246 = pop_value();
						mw_std_list_List_1_uncons(v246);
						VAL v247 = pop_value();
						VAL v248 = pop_value();
						push_value(v247);
						push_value(v248);
					}
					VAL v249 = pop_value();
					decref(v249);
					VAL v250 = pop_value();
					decref(v250);
					VAL v251 = pop_value();
					int64_t v252 = mw_std_maybe_Maybe_1_someZAsk(v251);
					if (((bool)v252)) {
						VAL v253 = pop_value();
						VAL v254 = mtw_std_either_Either_2_Right(v253);
						push_value(v254);
					} else {
						VAL v255 = pop_value();
						VAL v256 = mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED(v255);
						VAL v257 = mtw_std_either_Either_2_Left(v256);
						push_value(v257);
					}
					VAL v258 = pop_value();
					switch (get_data_tag(v258)) {
						case 0LL: { // Left
							push_value(v221);
							push_value(v220);
							VAL v259 = mtp_std_either_Either_2_Left(v258);
							VAL v260 = pop_value();
							VAL v261 = pop_value();
							VAL v262 = mtw_std_list_List_1_Cons(v259, v261);
							push_value(v262);
							push_value(v260);
						} break;
						case 1LL: { // Right
							push_value(v221);
							push_value(v220);
							VAL v263 = mtp_std_either_Either_2_Right(v258);
							VAL v264 = pop_value();
							VAL v265 = mtw_std_list_List_1_Cons(v263, v264);
							push_value(v265);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v221);
							push_value(v220);
						}
					}
					mw_std_list_List_1_uncons(v219);
					VAL v266 = pop_value();
					VAL v267 = pop_value();
					push_value(v266);
					push_value(v267);
				}
				VAL v268 = pop_value();
				decref(v268);
				VAL v269 = pop_value();
				decref(v269);
				VAL v270 = pop_value();
				VAL v271 = pop_value();
				VAL v272 = mw_std_list_List_1_reverse(v271);
				push_value(v272);
				VAL v273 = mw_std_list_List_1_reverse(v270);
				VAL r274 = pop_resource();
				VAL v275 = VVAL(VTUP(r274)->cells[4]);
				incref(v275);
				VAL v276 = pop_value();
				VAL v277 = mw_std_list_List_1_cat(v276, v275);
				VAL v278 = VTUP(r274)->cells[4];
				decref(v278);
				VTUP(r274)->cells[4] = v277;
				VAL v279 = VTUP(r274)->cells[3];
				decref(v279);
				VTUP(r274)->cells[3] = v273;
				push_resource(r274);
			}
			VAL v280 = pop_value();
			decref(v280);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v281 = pop_value();
	decref(v281);
}
static void mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3) {
	incref(x3);
	push_u64(x2);
	push_value(x3);
	mw_mirth_def_Def_qnameZ_hard(x1, x3);
	VAL v0 = pop_value();
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	decref(v0);
	switch (get_data_tag(v1)) {
		case 0LL: { // NAMESPACE_ROOT
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			decref(v3);
			int64_t v4 = 1LL /* True */;
			push_i64(v4);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			uint64_t v5 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(v1);
			VAL v6 = pop_value();
			decref(v6);
			VAL v7 = pop_value();
			decref(v7);
			int64_t v8 = 1LL /* True */;
			push_i64(v8);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v9 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(v1);
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = pop_u64();
			int64_t v12 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(v11, v9);
			push_i64(v12);
		} break;
		case 3LL: { // NAMESPACE_TYCON
			VAL v13 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v1);
			VAL v14 = pop_value();
			uint64_t v15 = pop_u64();
			push_value(v14);
			int64_t v16 = mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk(v15, v13);
			if (((bool)v16)) {
				VAL v17 = pop_value();
				VAL v18 = mw_mirth_def_Def_tagZAsk(v17);
				int64_t v19 = mw_std_maybe_Maybe_1_ZToBool(v18);
				push_i64(v19);
			} else {
				VAL v20 = pop_value();
				decref(v20);
				int64_t v21 = 0LL /* False */;
				push_i64(v21);
			}
		} break;
		case 4LL: { // NAMESPACE_WORD
			uint64_t v22 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(v1);
			VAL v23 = pop_value();
			decref(v23);
			VAL v24 = pop_value();
			decref(v24);
			int64_t v25 = 0LL /* False */;
			push_i64(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static int64_t mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // TYCON_DATA
			push_u64(x1);
			uint64_t v0 = mtp_mirth_tycon_Tycon_TYCONz_DATA(x2);
			VAL v1 = mw_mirth_data_Data_headZAsk(v0);
			switch (get_data_tag(v1)) {
				case 1LL: { // Some
					VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
					uint64_t v3 = mw_mirth_token_Token_module(VU64(v2));
					uint64_t v4 = pop_u64();
					int64_t v5 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(v4, v3);
					push_i64(v5);
				} break;
				case 0LL: { // None
					uint64_t v6 = pop_u64();
					int64_t v7 = 1LL /* True */;
					push_i64(v7);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 1LL: { // TYCON_TABLE
			push_u64(x1);
			uint64_t v8 = mtp_mirth_tycon_Tycon_TYCONz_TABLE(x2);
			uint64_t v9 = mw_mirth_table_Table_head(v8);
			uint64_t v10 = mw_mirth_token_Token_module(v9);
			uint64_t v11 = pop_u64();
			int64_t v12 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(v11, v10);
			push_i64(v12);
		} break;
		case 2LL: { // TYCON_PRIM
			push_u64(x1);
			int64_t v13 = mtp_mirth_tycon_Tycon_TYCONz_PRIM(x2);
			VAL v14 = pop_value();
			decref(v14);
			int64_t v15 = 1LL /* True */;
			push_i64(v15);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
		}
	}
	int64_t v16 = pop_i64();
	return v16;
}
static void mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk (VAL x1, uint64_t x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 0LL: { // NAMESPACE_ROOT
			int64_t v0 = 1LL /* True */;
			push_resource(x1);
			push_i64(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			push_resource(x1);
			push_u64(x2);
			uint64_t v1 = mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE(x3);
			VAL v2 = pop_value();
			decref(v2);
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			push_resource(x1);
			push_u64(x2);
			uint64_t v4 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(x3);
			uint64_t v5 = pop_u64();
			int64_t v6 = mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk(v5, v4);
			push_i64(v6);
		} break;
		case 3LL: { // NAMESPACE_TYCON
			push_resource(x1);
			push_u64(x2);
			VAL v7 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(x3);
			VAL r8 = pop_resource();
			mw_mirth_tycon_Tycon_qnameZ_hard(r8, v7);
			VAL v9 = pop_value();
			VAL v10 = VVAL(VTUP(v9)->cells[1]);
			incref(v10);
			decref(v9);
			uint64_t v11 = pop_u64();
			VAL r12 = pop_resource();
			mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk(r12, v11, v10);
		} break;
		case 4LL: { // NAMESPACE_WORD
			push_resource(x1);
			push_u64(x2);
			uint64_t v13 = mtp_mirth_name_Namespace_NAMESPACEz_WORD(x3);
			VAL v14 = pop_value();
			decref(v14);
			int64_t v15 = 0LL /* False */;
			push_i64(v15);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
			push_u64(x2);
		}
	}
}
static void mw_mirth_name_QName_climbZ_upZ_nameZAsk (VAL x1, uint64_t x2, VAL x3) {
	incref(x3);
	uint64_t v0 = VU64(VTUP(x3)->cells[2]);
	decref(x3);
	push_resource(x1);
	lpush(&lbl_qname, x3);
	lpush(&lbl_name, MKU64(x2));
	int64_t v1 = mw_mirth_name_Name_ZEqualZEqual(v0, x2);
	if (((bool)v1)) {
		VAL v2 = lpop(&lbl_qname);
		incref(v2);
		VAL v3 = VVAL(VTUP(v2)->cells[1]);
		incref(v3);
		decref(v2);
		int64_t v4 = 0LL /* Nil */;
		lpush(&lbl_qname, v2);
		VAL v5 = mtw_std_list_List_1_Cons(v3, MKI64(v4));
		push_value(v5);
	} else {
		int64_t v6 = 0LL /* Nil */;
		push_i64(v6);
	}
	VAL v7 = pop_value();
	uint64_t v8 = VU64(lpop(&lbl_name));
	lpush(&lbl_accum, v7);
	VAL v9 = mw_mirth_name_Name_defs(v8);
	mw_std_list_List_1_uncons(v9);
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	push_value(v10);
	push_value(v11);
	while(1) {
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		int64_t v13 = mw_std_maybe_Maybe_1_someZAsk(v12);
		if (!((bool)v13)) break;
		VAL v14 = pop_value();
		VAL v15 = mw_std_maybe_Maybe_1_unwrap(v14);
		VAL v16 = pop_value();
		switch (get_data_tag(v15)) {
			case 0LL: { // DefAlias
				uint64_t v17 = mtp_mirth_def_Def_DefAlias(v15);
				VAL r18 = pop_resource();
				push_u64(v17);
				mw_mirth_alias_Alias_target(r18, v17);
				VAL v19 = pop_value();
				VAL r20 = pop_resource();
				mw_mirth_def_Def_qnameZ_hard(r20, v19);
				VAL v21 = lpop(&lbl_qname);
				incref(v21);
				VAL v22 = pop_value();
				lpush(&lbl_qname, v21);
				int64_t v23 = mw_mirth_name_QName_ZEqualZEqual(v22, v21);
				if (((bool)v23)) {
					uint64_t v24 = pop_u64();
					VAL r25 = pop_resource();
					mw_mirth_alias_Alias_namespaceZ_hard(r25, v24);
					VAL v26 = lpop(&lbl_accum);
					VAL v27 = pop_value();
					VAL v28 = mtw_std_list_List_1_Cons(v27, v26);
					lpush(&lbl_accum, v28);
				} else {
					uint64_t v29 = pop_u64();
				}
			} break;
			case 5LL: { // DefType
				uint64_t v30 = mtp_mirth_def_Def_DefType(v15);
				VAL r31 = pop_resource();
				push_u64(v30);
				mw_mirth_typedef_TypeDef_target(r31, v30);
				VAL v32 = pop_value();
				VAL v33 = mw_mirth_type_Type_tyconZAsk(v32);
				switch (get_data_tag(v33)) {
					case 1LL: { // Some
						VAL v34 = mtp_std_maybe_Maybe_1_Some(v33);
						VAL r35 = pop_resource();
						mw_mirth_tycon_Tycon_qnameZ_hard(r35, v34);
						VAL v36 = lpop(&lbl_qname);
						incref(v36);
						VAL v37 = pop_value();
						lpush(&lbl_qname, v36);
						int64_t v38 = mw_mirth_name_QName_ZEqualZEqual(v37, v36);
						push_i64(v38);
					} break;
					case 0LL: { // None
						int64_t v39 = 0LL /* False */;
						push_i64(v39);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
				bool v40 = pop_bool();
				if (v40) {
					uint64_t v41 = pop_u64();
					VAL r42 = pop_resource();
					mw_mirth_typedef_TypeDef_namespace(r42, v41);
					VAL v43 = lpop(&lbl_accum);
					VAL v44 = pop_value();
					VAL v45 = mtw_std_list_List_1_Cons(v44, v43);
					lpush(&lbl_accum, v45);
				} else {
					uint64_t v46 = pop_u64();
				}
			} break;
			default: {
				decref(v15);
			} break;
		}
		mw_std_list_List_1_uncons(v16);
		VAL v47 = pop_value();
		VAL v48 = pop_value();
		push_value(v47);
		push_value(v48);
	}
	VAL v49 = pop_value();
	decref(v49);
	VAL v50 = pop_value();
	decref(v50);
	VAL v51 = lpop(&lbl_qname);
	decref(v51);
	VAL v52 = lpop(&lbl_accum);
	push_value(v52);
}
static void mw_mirth_name_QName_climbZ_upZ_dnameZAsk (VAL x1, VAL x2, VAL x3, VAL x4) {
	incref(x3);
	push_resource(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_name_DName_rootZAsk(x3);
	VAL v1 = mw_std_maybe_Maybe_1_ZToList(v0);
	push_value(v1);
	VAL v2 = mw_mirth_name_DName_parts(x3);
	mw_std_list_ListZPlus_1_unsnoc(v2);
	uint64_t v3 = pop_u64();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	VAL v6 = mw_std_list_List_1_cat(v5, v4);
	VAL r7 = pop_resource();
	int64_t v8 = VI64(VTUP(r7)->cells[5]);
	if (((bool)v8)) {
		push_resource(r7);
		mw_std_list_List_1_unsnoc(v6);
		VAL v9 = pop_value();
		VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
		push_value(v10);
	} else {
		push_value(v6);
		push_u64(v3);
		push_resource(r7);
	}
	VAL r11 = pop_resource();
	uint64_t v12 = pop_u64();
	VAL r13 = pop_resource();
	mw_mirth_name_QName_climbZ_upZ_nameZAsk(r13, v12, x4);
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	push_resource(r11);
	push_value(v14);
	VAL v16 = mw_std_list_List_1_reverse(v15);
	mw_std_list_List_1_uncons(v16);
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	push_value(v17);
	push_value(v18);
	while(1) {
		VAL v19 = pop_value();
		incref(v19);
		push_value(v19);
		int64_t v20 = mw_std_maybe_Maybe_1_someZAsk(v19);
		if (!((bool)v20)) break;
		VAL v21 = pop_value();
		VAL v22 = mw_std_maybe_Maybe_1_unwrap(v21);
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		int64_t v25 = 0LL /* Nil */;
		push_value(v22);
		push_value(v24);
		VAL v26 = mw_std_list_List_1_reverse(MKI64(v25));
		VAL v27 = pop_value();
		push_resource(v26);
		mw_std_list_List_1_uncons(v27);
		VAL v28 = pop_value();
		VAL v29 = pop_value();
		push_value(v28);
		push_value(v29);
		while(1) {
			VAL v30 = pop_value();
			incref(v30);
			push_value(v30);
			int64_t v31 = mw_std_maybe_Maybe_1_someZAsk(v30);
			if (!((bool)v31)) break;
			VAL v32 = pop_value();
			VAL v33 = mw_std_maybe_Maybe_1_unwrap(v32);
			VAL v34 = pop_value();
			VAL r35 = pop_resource();
			VAL r36 = pop_resource();
			VAL r37 = pop_resource();
			mw_mirth_name_Namespace_qname(r37, v33);
			VAL v38 = pop_value();
			switch (get_data_tag(v38)) {
				case 1LL: { // Some
					push_resource(r36);
					VAL v39 = mtp_std_maybe_Maybe_1_Some(v38);
					uint64_t v40 = pop_u64();
					VAL r41 = pop_resource();
					VAL r42 = pop_resource();
					push_u64(v40);
					mw_mirth_name_QName_climbZ_upZ_nameZAsk(r42, v40, v39);
					push_resource(r41);
				} break;
				case 0LL: { // None
					int64_t v43 = 0LL /* Nil */;
					push_resource(r36);
					push_i64(v43);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_resource(r36);
				}
			}
			VAL v44 = pop_value();
			push_resource(r35);
			mw_std_list_List_1_uncons(v44);
			VAL v45 = pop_value();
			VAL v46 = pop_value();
			push_value(v45);
			push_value(v46);
			while(1) {
				VAL v47 = pop_value();
				incref(v47);
				push_value(v47);
				int64_t v48 = mw_std_maybe_Maybe_1_someZAsk(v47);
				if (!((bool)v48)) break;
				VAL v49 = pop_value();
				VAL v50 = mw_std_maybe_Maybe_1_unwrap(v49);
				VAL v51 = pop_value();
				VAL r52 = pop_resource();
				VAL v53 = mtw_std_list_List_1_Cons(v50, r52);
				push_resource(v53);
				mw_std_list_List_1_uncons(v51);
				VAL v54 = pop_value();
				VAL v55 = pop_value();
				push_value(v54);
				push_value(v55);
			}
			VAL v56 = pop_value();
			decref(v56);
			VAL v57 = pop_value();
			decref(v57);
			mw_std_list_List_1_uncons(v34);
			VAL v58 = pop_value();
			VAL v59 = pop_value();
			push_value(v58);
			push_value(v59);
		}
		VAL v60 = pop_value();
		decref(v60);
		VAL v61 = pop_value();
		decref(v61);
		VAL r62 = pop_resource();
		VAL v63 = mw_std_list_List_1_reverse(r62);
		VAL v64 = pop_value();
		decref(v64);
		push_value(v63);
		mw_std_list_List_1_uncons(v23);
		VAL v65 = pop_value();
		VAL v66 = pop_value();
		push_value(v65);
		push_value(v66);
	}
	VAL v67 = pop_value();
	decref(v67);
	VAL v68 = pop_value();
	decref(v68);
}
static void mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* False */;
	int64_t v1 = 0LL /* False */;
	uint64_t v2 = VU64(VTUP(x2)->cells[2]);
	STR* v3;
	STRLIT(v3, "type", 4);
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v3), v2, v0, v1, x1);
	VAL r4 = pop_resource();
	VAL v5 = VVAL(VTUP(r4)->cells[3]);
	incref(v5);
	int64_t v6 = 0LL /* Nil */;
	int64_t v7 = 0LL /* Nil */;
	push_resource(r4);
	push_i64(v6);
	push_i64(v7);
	mw_std_list_List_1_uncons(v5);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		int64_t v11 = mw_std_maybe_Maybe_1_someZAsk(v10);
		if (!((bool)v11)) break;
		VAL v12 = pop_value();
		VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		incref(v13);
		VAL r17 = pop_resource();
		VAL r18 = pop_resource();
		push_value(v13);
		mw_mirth_def_Def_definesZ_aZ_typeZAsk(r18, v13);
		bool v19 = pop_bool();
		if (v19) {
			VAL v20 = pop_value();
			push_resource(r17);
			VAL v21 = mtw_std_either_Either_2_Right(v20);
			push_value(v21);
		} else {
			VAL v22 = pop_value();
			push_resource(r17);
			VAL v23 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v22);
			VAL v24 = mtw_std_either_Either_2_Left(v23);
			push_value(v24);
		}
		VAL v25 = pop_value();
		switch (get_data_tag(v25)) {
			case 0LL: { // Left
				push_value(v16);
				push_value(v15);
				VAL v26 = mtp_std_either_Either_2_Left(v25);
				VAL v27 = pop_value();
				VAL v28 = pop_value();
				VAL v29 = mtw_std_list_List_1_Cons(v26, v28);
				push_value(v29);
				push_value(v27);
			} break;
			case 1LL: { // Right
				push_value(v16);
				push_value(v15);
				VAL v30 = mtp_std_either_Either_2_Right(v25);
				VAL v31 = pop_value();
				VAL v32 = mtw_std_list_List_1_Cons(v30, v31);
				push_value(v32);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_value(v16);
				push_value(v15);
			}
		}
		mw_std_list_List_1_uncons(v14);
		VAL v33 = pop_value();
		VAL v34 = pop_value();
		push_value(v33);
		push_value(v34);
	}
	VAL v35 = pop_value();
	decref(v35);
	VAL v36 = pop_value();
	decref(v36);
	VAL v37 = pop_value();
	VAL v38 = pop_value();
	VAL v39 = mw_std_list_List_1_reverse(v38);
	push_value(v39);
	VAL v40 = mw_std_list_List_1_reverse(v37);
	VAL r41 = pop_resource();
	VAL v42 = VVAL(VTUP(r41)->cells[4]);
	incref(v42);
	VAL v43 = pop_value();
	VAL v44 = mw_std_list_List_1_cat(v43, v42);
	VAL v45 = VTUP(r41)->cells[4];
	decref(v45);
	VTUP(r41)->cells[4] = v44;
	VAL v46 = VTUP(r41)->cells[3];
	decref(v46);
	VTUP(r41)->cells[3] = v40;
	VAL r47 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_arity(r47, r41);
	VAL r48 = pop_resource();
	VAL r49 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(r49, r48);
	int64_t v50 = 0LL /* Nil */;
	VAL r51 = pop_resource();
	VAL r52 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots(MKI64(v50), r52, r51);
	VAL r53 = pop_resource();
	VAL r54 = pop_resource();
	mw_mirth_elab_resolveZ_defZ_endZBang(r54, r53);
	VAL v55 = pop_value();
	switch (get_data_tag(v55)) {
		case 1LL: { // Some
			push_resource(x2);
			VAL v56 = mtp_std_maybe_Maybe_1_Some(v55);
			switch (get_data_tag(v56)) {
				case 3LL: { // DefData
					uint64_t v57 = mtp_mirth_def_Def_DefData(v56);
					VAL v58 = mtw_mirth_type_Type_TData(v57);
					push_value(v58);
				} break;
				case 4LL: { // DefTable
					uint64_t v59 = mtp_mirth_def_Def_DefTable(v56);
					VAL v60 = mtw_mirth_type_Type_TTable(v59);
					push_value(v60);
				} break;
				case 5LL: { // DefType
					uint64_t v61 = mtp_mirth_def_Def_DefType(v56);
					VAL r62 = pop_resource();
					VAL r63 = pop_resource();
					mw_mirth_typedef_TypeDef_target(r63, v61);
					push_resource(r62);
				} break;
				default: {
					decref(v56);
					VAL r64 = pop_resource();
					uint64_t v65 = VU64(VTUP(r64)->cells[2]);
					STR* v66;
					STRLIT(v66, "compiler bug: resolve-type-con-name! doesn't understand type", 60);
					VAL r67 = pop_resource();
					VAL v68 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v65, MKSTR(v66), r67));
					int64_t v69 = 0LL /* TYPE_ERROR */;
					push_resource(v68);
					push_resource(r64);
					push_i64(v69);
				} break;
			}
			VAL v70 = pop_value();
			VAL v71 = mtw_std_maybe_Maybe_1_Some(v70);
			push_value(v71);
		} break;
		case 0LL: { // None
			int64_t v72 = 0LL /* None */;
			push_resource(x2);
			push_i64(v72);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL v73 = pop_value();
	switch (get_data_tag(v73)) {
		case 1LL: { // Some
			VAL v74 = mtp_std_maybe_Maybe_1_Some(v73);
			push_value(v74);
		} break;
		case 0LL: { // None
			int64_t v75 = 0LL /* TYPE_ERROR */;
			push_i64(v75);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	VAL v1 = mw_mirth_token_Token_nameZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = mw_mirth_name_Name_ZToStr(VU64(v2));
			STR* v4;
			STRLIT(v4, "Mut", 3);
			bool v5 = (str_cmp(VSTR(v3), v4) == 0);
			push_bool(v5);
		} break;
		case 0LL: { // None
			int64_t v6 = 0LL /* False */;
			push_i64(v6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v7 = pop_bool();
	if (v7) {
		VAL r8 = pop_resource();
		uint64_t v9 = VU64(VTUP(r8)->cells[2]);
		push_resource(r8);
		uint64_t v10 = mw_mirth_token_Token_next(v9);
		VAL r11 = pop_resource();
		uint64_t v12 = VU64(VTUP(r11)->cells[2]);
		VAL r13 = pop_resource();
		mw_mirth_token_Token_argsZ_1(v12, r13);
		uint64_t v14 = pop_u64();
		VTUP(r11)->cells[2] = MKU64(v14);
		VAL r15 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(r15, r11);
		VAL v16 = pop_value();
		VAL v17 = mtw_mirth_type_Type_TMut(v16);
		VAL r18 = pop_resource();
		VTUP(r18)->cells[2] = MKU64(v10);
		push_value(v17);
		push_resource(r18);
	} else {
		VAL r19 = pop_resource();
		VAL r20 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang(r20, r19);
		VAL v21 = pop_value();
		VAL r22 = pop_resource();
		VAL r23 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang(r23, r22, v21);
		VAL r24 = pop_resource();
		uint64_t v25 = VU64(VTUP(r24)->cells[2]);
		uint64_t v26 = mw_mirth_token_Token_next(v25);
		VTUP(r24)->cells[2] = MKU64(v26);
		push_resource(r24);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang (VAL x1, VAL x2) {
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang(x1, x2);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang (VAL x1, VAL x2, VAL x3) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_value(x3);
	push_resource(x2);
	int64_t v1 = mw_mirth_token_Token_hasZ_argsZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		uint64_t v3 = VU64(VTUP(r2)->cells[2]);
		uint64_t v4 = VU64(VTUP(r2)->cells[2]);
		push_resource(r2);
		VAL v5 = mw_mirth_token_Token_args(v4);
		mw_std_list_List_1_uncons(v5);
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
		while(1) {
			VAL v8 = pop_value();
			incref(v8);
			push_value(v8);
			int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
			if (!((bool)v9)) break;
			VAL v10 = pop_value();
			VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
			VAL v12 = pop_value();
			VAL r13 = pop_resource();
			VTUP(r13)->cells[2] = v11;
			VAL r14 = pop_resource();
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(r14, r13);
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			VAL v17 = mtw_mirth_type_Type_TApp(v16, v15);
			push_value(v17);
			mw_std_list_List_1_uncons(v12);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			push_value(v18);
			push_value(v19);
		}
		VAL v20 = pop_value();
		decref(v20);
		VAL v21 = pop_value();
		decref(v21);
		VAL r22 = pop_resource();
		VTUP(r22)->cells[2] = MKU64(v3);
		push_resource(r22);
	} else {
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang (VAL x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[3]);
	if (((bool)v0)) {
		uint64_t v1 = VU64(VTUP(x2)->cells[2]);
		VAL v2 = (mw_mirth_token_Token_argsZ_0(v1, x1));
		uint64_t v3 = VU64(VTUP(x2)->cells[2]);
		push_resource(v2);
		push_resource(x2);
		VAL v4 = mw_mirth_token_Token_nameZAsk(v3);
		VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
		VAL v6 = mtw_mirth_type_Type_THole(VU64(v5));
		push_value(v6);
	} else {
		uint64_t v7 = VU64(VTUP(x2)->cells[2]);
		STR* v8;
		STRLIT(v8, "type holes are not allowed here", 31);
		VAL v9 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v7, MKSTR(v8), x1));
		int64_t v10 = 0LL /* TYPE_ERROR */;
		push_resource(v9);
		push_resource(x2);
		push_i64(v10);
	}
	VAL r11 = pop_resource();
	uint64_t v12 = VU64(VTUP(r11)->cells[2]);
	uint64_t v13 = mw_mirth_token_Token_next(v12);
	VTUP(r11)->cells[2] = MKU64(v13);
	push_resource(r11);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang (VAL x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[3]);
	if (((bool)v0)) {
		uint64_t v1 = VU64(VTUP(x2)->cells[2]);
		VAL v2 = (mw_mirth_token_Token_argsZ_0(v1, x1));
		int64_t v3 = 1LL /* TYPE_DONT_CARE */;
		push_resource(v2);
		push_resource(x2);
		push_i64(v3);
	} else {
		uint64_t v4 = VU64(VTUP(x2)->cells[2]);
		STR* v5;
		STRLIT(v5, "underscore is not allowed here", 30);
		VAL v6 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v4, MKSTR(v5), x1));
		int64_t v7 = 0LL /* TYPE_ERROR */;
		push_resource(v6);
		push_resource(x2);
		push_i64(v7);
	}
	VAL r8 = pop_resource();
	uint64_t v9 = VU64(VTUP(r8)->cells[2]);
	uint64_t v10 = mw_mirth_token_Token_next(v9);
	VTUP(r8)->cells[2] = MKU64(v10);
	push_resource(r8);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[2]);
	push_resource(x1);
	push_resource(x2);
	uint64_t v1 = mw_mirth_token_Token_next(v0);
	VAL r2 = pop_resource();
	uint64_t v3 = VU64(VTUP(r2)->cells[2]);
	VAL r4 = pop_resource();
	mw_mirth_token_Token_argsZ_1(v3, r4);
	uint64_t v5 = pop_u64();
	VTUP(r2)->cells[2] = MKU64(v5);
	uint64_t v6 = VU64(VTUP(r2)->cells[2]);
	push_resource(r2);
	int64_t v7 = mw_mirth_token_Token_sigZ_hasZ_dashesZAsk(v6);
	if (((bool)v7)) {
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(r9, r8);
		VAL v10 = pop_value();
		VAL v11 = mw_mirth_type_ArrowType_ZToType(v10);
		push_value(v11);
	} else {
		VAL r12 = pop_resource();
		VAL r13 = pop_resource();
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(r13, r12);
		VAL v14 = pop_value();
		VAL v15 = mw_mirth_type_StackType_ZToType(v14);
		push_value(v15);
	}
	VAL r16 = pop_resource();
	VTUP(r16)->cells[2] = MKU64(v1);
	push_resource(r16);
}
static void mw_mirth_elab_elabZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4) {
	mw_mirth_type_Type_unifyZBang(x1, x4, x2, x3);
	uint64_t r0 = VU64(pop_resource());
	push_u64(r0);
}
static void mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang (VAL x1, VAL x2, VAL x3, uint64_t x4) {
	mw_mirth_type_StackType_unifyZBang(x1, x4, x2, x3);
	uint64_t r0 = VU64(pop_resource());
	push_u64(r0);
}
static void mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	lpush(&lbl_token, MKU64(x2));
	VAL v0 = mw_mirth_var_Ctx0();
	int64_t v1 = 0LL /* False */;
	int64_t v2 = 0LL /* False */;
	uint64_t v3 = VU64(lpop(&lbl_token));
	VAL v4 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v0, v3, v1, v2));
	VAL r5 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang(r5, v4);
	VAL r6 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_rdrop(r6);
}
static void mw_mirth_elab_abZ_tokenZAt (VAL x1) {
	incref(x1);
	uint64_t v0 = VU64(VTUP(x1)->cells[3]);
	decref(x1);
	push_resource(x1);
	push_u64(v0);
}
static VAL mw_mirth_elab_abZ_tokenZBang (VAL x1, uint64_t x2) {
	incref(x1);
	VAL v0 = tup_replace(x1, 3, MKU64(x2));
	decref(x1);
	return v0;
}
static void mw_mirth_elab_abZ_typeZAt (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[6]);
	incref(v0);
	decref(x1);
	push_resource(x1);
	push_value(v0);
}
static VAL mw_mirth_elab_abZ_typeZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v0 = tup_replace(x1, 6, x2);
	decref(x1);
	return v0;
}
static void mw_mirth_elab_abZ_ctxZAt (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	decref(x1);
	push_resource(x1);
	push_value(v0);
}
static void mw_mirth_elab_abZ_homeZAt (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	push_resource(x1);
	push_value(v0);
}
static void mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_word_Word_ZTildectxZ_type(x2);
	lpush(&lbl_word, MKU64(x2));
	mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v0), x1);
	VAL v1 = pop_value();
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3;
			VAL v4;
			value_uncons(v2, &v3, &v4);
			VAL v5;
			VAL v6;
			value_uncons(v3, &v5, &v6);
			decref(v5);
			push_value(v6);
			push_value(v4);
		} break;
		case 0LL: { // None
			uint64_t v7 = VU64(lpop(&lbl_word));
			VAL r8 = pop_resource();
			mw_mirth_elab_guessZ_initialZ_ctxZ_type(r8, v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v9 = VU64(lpop(&lbl_word));
	lpush(&lbl_word, MKU64(v9));
	uint64_t v10 = mw_mirth_word_Word_body(v9);
	uint64_t v11 = VU64(lpop(&lbl_word));
	push_u64(v10);
	lpush(&lbl_word, MKU64(v11));
	VAL v12 = mtw_mirth_arrow_Home_HomeWord(v11);
	uint64_t v13 = VU64(lpop(&lbl_word));
	push_value(v12);
	push_u64(v13);
}
static void mw_mirth_elab_finalizzeZ_wordZ_arrow (VAL x1, VAL x2, uint64_t x3) {
	push_resource(x1);
	lpush(&lbl_arrow, x2);
	lpush(&lbl_word, MKU64(x3));
	int64_t v0 = mw_mirth_word_Word_inferringZ_typeZAsk(x3);
	if (((bool)v0)) {
		VAL v1 = lpop(&lbl_arrow);
		incref(v1);
		lpush(&lbl_arrow, v1);
		mw_mirth_arrow_Arrow_ctxZ_type(v1);
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		VAL r4 = pop_resource();
		mw_mirth_type_ArrowType_rigidifyZ_sigZBang(r4, v3, v2);
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		incref(v5);
		VAL v7 = MKNIL;
		VAL v8 = mkcons(v7, v6);
		VAL v9 = mkcons(v8, v5);
		uint64_t v10 = VU64(lpop(&lbl_word));
		push_value(v6);
		push_value(v5);
		push_value(v9);
		lpush(&lbl_word, MKU64(v10));
		VAL v11 = mtw_mirth_mirth_PropLabel_WordType(v10);
		VAL r12 = pop_resource();
		VAL v13 = pop_value();
		mw_mirth_mirth_PropLabel_prop(v13, v11, r12);
		uint64_t v14 = VU64(lpop(&lbl_word));
		void* v15 = mfld_mirth_word_Word_ZTildectxZ_type(v14);
		VAL v16 = pop_value();
		mut_set(v16, MKPTR(v15));
		int64_t v17 = 0LL /* False */;
		void* v18 = mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk(v14);
		mut_set(MKI64(v17), MKPTR(v18));
		VAL v19 = pop_value();
		lpush(&lbl_word, MKU64(v14));
		mw_mirth_type_ArrowType_unpack(v19);
		VAL v20 = lpop(&lbl_arrow);
		VAL v21 = pop_value();
		VAL v22 = tup_replace(v20, 6, v21);
		VAL v23 = pop_value();
		VAL v24 = tup_replace(v22, 5, v23);
		VAL v25 = pop_value();
		VAL v26 = tup_replace(v24, 4, v25);
		push_value(v26);
	} else {
		VAL v27 = lpop(&lbl_arrow);
		push_value(v27);
	}
	uint64_t v28 = VU64(lpop(&lbl_word));
}
static void mw_mirth_elab_guessZ_initialZ_ctxZ_type (VAL x1, uint64_t x2) {
	push_resource(x1);
	lpush(&lbl_word, MKU64(x2));
	VAL v0 = mw_mirth_var_Ctx0();
	lpush(&lbl_ctx, v0);
	uint64_t v1 = mw_mirth_type_MetaVar_newZBang();
	VAL v2 = mtw_mirth_type_StackType_STMeta(v1);
	lpush(&lbl_dom, v2);
	uint64_t v3 = mw_mirth_type_MetaVar_newZBang();
	VAL v4 = mtw_mirth_type_StackType_STMeta(v3);
	uint64_t v5 = VU64(lpop(&lbl_word));
	VAL r6 = pop_resource();
	lpush(&lbl_cod, v4);
	lpush(&lbl_word, MKU64(v5));
	mw_mirth_word_Word_namespaceZ_hard(v5, r6);
	VAL v7 = pop_value();
	switch (get_data_tag(v7)) {
		case 3LL: { // NAMESPACE_TYCON
			VAL v8 = mtp_mirth_name_Namespace_NAMESPACEz_TYCON(v7);
			VAL r9 = pop_resource();
			mw_mirth_tycon_Tycon_fullZ_typeZ_fresh(r9, v8);
			uint64_t v10 = VU64(lpop(&lbl_word));
			lpush(&lbl_word, MKU64(v10));
			uint64_t v11 = mw_mirth_word_Word_name(v10);
			int64_t v12 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(v11);
			if (((bool)v12)) {
				VAL v13 = lpop(&lbl_dom);
				VAL v14 = pop_value();
				VAL v15 = mw_mirth_type_TZMulZPlus(v13, v14);
				lpush(&lbl_dom, v15);
			} else {
				VAL v16 = lpop(&lbl_cod);
				VAL v17 = pop_value();
				VAL v18 = mw_mirth_type_TZMulZPlus(v16, v17);
				lpush(&lbl_cod, v18);
			}
		} break;
		case 2LL: { // NAMESPACE_MODULE
			uint64_t v19 = mtp_mirth_name_Namespace_NAMESPACEz_MODULE(v7);
			uint64_t v20 = VU64(lpop(&lbl_word));
			lpush(&lbl_word, MKU64(v20));
			uint64_t v21 = mw_mirth_word_Word_name(v20);
			VAL v22 = mw_mirth_name_Name_ZToStr(v21);
			STR* v23;
			STRLIT(v23, "main", 4);
			bool v24 = (str_cmp(VSTR(v22), v23) == 0);
			if (v24) {
				VAL v25 = mw_mirth_type_T0();
				push_value(v25);
				VAL v26 = mw_mirth_type_RESOURCEz_WORLD();
				VAL v27 = pop_value();
				VAL v28 = mw_mirth_type_TZPlus(v27, v26);
				VAL v29 = lpop(&lbl_dom);
				decref(v29);
				lpush(&lbl_dom, v28);
				VAL v30 = mw_mirth_type_T0();
				push_value(v30);
				VAL v31 = mw_mirth_type_RESOURCEz_WORLD();
				VAL v32 = pop_value();
				VAL v33 = mw_mirth_type_TZPlus(v32, v31);
				VAL v34 = lpop(&lbl_cod);
				decref(v34);
				lpush(&lbl_cod, v33);
			} else {
			}
		} break;
		default: {
			decref(v7);
		} break;
	}
	uint64_t v35 = VU64(lpop(&lbl_word));
	lpush(&lbl_word, MKU64(v35));
	int64_t v36 = mw_mirth_word_Word_arity(v35);
	int64_t v37 = mw_std_prim_Int_ZToNat(v36);
	push_i64(v37);
	while(1) {
		int64_t v38 = pop_i64();
		int64_t v39 = 0LL;
		bool v40 = (v38 > v39);
		push_i64(v38);
		if (!v40) break;
		int64_t v41 = pop_i64();
		VAL v42 = lpop(&lbl_dom);
		push_value(v42);
		uint64_t v43 = mw_mirth_type_MetaVar_newZBang();
		VAL v44 = mtw_mirth_type_StackType_STMeta(v43);
		push_value(v44);
		uint64_t v45 = mw_mirth_type_MetaVar_newZBang();
		VAL v46 = mtw_mirth_type_StackType_STMeta(v45);
		VAL v47 = pop_value();
		VAL v48 = mw_mirth_type_TZ_ZTo(v47, v46);
		VAL v49 = mw_mirth_type_ArrowType_ZToType(v48);
		VAL v50 = pop_value();
		VAL v51 = mw_mirth_type_TZMul(v50, v49);
		int64_t v52 = 1LL;
		int64_t v53 = i64_sub(v41, v52);
		lpush(&lbl_dom, v51);
		int64_t v54 = mw_std_prim_Int_ZToNat(v53);
		push_i64(v54);
	}
	int64_t v55 = pop_i64();
	VAL v56 = lpop(&lbl_ctx);
	VAL v57 = lpop(&lbl_dom);
	VAL v58 = lpop(&lbl_cod);
	push_value(v56);
	VAL v59 = mw_mirth_type_TZ_ZTo(v57, v58);
	VAL v60 = pop_value();
	incref(v60);
	incref(v59);
	VAL v61 = MKNIL;
	VAL v62 = mkcons(v61, v60);
	VAL v63 = mkcons(v62, v59);
	uint64_t v64 = VU64(lpop(&lbl_word));
	push_value(v60);
	push_value(v59);
	push_value(v63);
	lpush(&lbl_word, MKU64(v64));
	VAL v65 = mtw_mirth_mirth_PropLabel_WordType(v64);
	VAL r66 = pop_resource();
	VAL v67 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v67, v65, r66);
	uint64_t v68 = VU64(lpop(&lbl_word));
	void* v69 = mfld_mirth_word_Word_ZTildectxZ_type(v68);
	VAL v70 = pop_value();
	mut_set(v70, MKPTR(v69));
	int64_t v71 = 1LL /* True */;
	void* v72 = mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk(v68);
	mut_set(MKI64(v71), MKPTR(v72));
	lpush(&lbl_word, MKU64(v68));
}
static void mw_mirth_elab_abZ_unifyZ_typeZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	mw_mirth_elab_abZ_typeZAt(x3);
	VAL r0 = pop_resource();
	push_value(x1);
	mw_mirth_elab_abZ_tokenZAt(r0);
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL r5 = pop_resource();
	mw_mirth_type_StackType_unifyZBang(r5, v2, v4, v3);
	uint64_t r6 = VU64(pop_resource());
	mw_mirth_type_ZPlusGamma_rdrop(r6);
	VAL v7 = pop_value();
	VAL v8 = (mw_mirth_elab_abZ_typeZBang(r1, v7));
	push_resource(v8);
}
static VAL mw_mirth_elab_abZ_atomZBang (VAL x1, VAL x2) {
	incref(x1);
	uint64_t v0 = VU64(VTUP(x1)->cells[2]);
	decref(x1);
	push_value(x1);
	VAL v1 = (mw_mirth_elab_abZ_tokenZBang(x2, v0));
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = VVAL(VTUP(v2)->cells[7]);
	incref(v3);
	decref(v2);
	push_value(v2);
	VAL v4 = (mw_mirth_elab_abZ_typeZBang(v1, v3));
	incref(v4);
	incref(v4);
	VAL v5 = VVAL(VTUP(v4)->cells[7]);
	incref(v5);
	decref(v4);
	VAL v6 = pop_value();
	VAL v7 = mw_mirth_elab_abZ_optimizzedZ_snocZBang(v5, v6);
	VAL v8 = tup_replace(v4, 7, v7);
	decref(v4);
	return v8;
}
static VAL mw_mirth_elab_abZ_optimizzedZ_snocZBang (VAL x1, VAL x2) {
	push_value(x1);
	push_value(x2);
	while(1) {
		VAL v0 = pop_value();
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v0);
		int64_t v2 = mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk(v1);
		if (((bool)v2)) {
			VAL v3 = pop_value();
			mw_mirth_elab_atomZ_acceptsZ_argsZAsk(v3);
		} else {
			int64_t v4 = 0LL /* False */;
			push_i64(v4);
		}
		bool v5 = pop_bool();
		if (!v5) break;
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg(v6, v7);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	int64_t v10 = 0LL /* Nil */;
	VAL v11 = pop_value();
	VAL v12 = mtw_std_list_List_1_Cons(v11, MKI64(v10));
	VAL v13 = pop_value();
	VAL v14 = mw_std_list_List_1_cat(v13, v12);
	return v14;
}
static void mw_mirth_elab_atomZ_acceptsZ_argsZAsk (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 2LL: { // OpWord
			push_value(x1);
			uint64_t v1 = mtp_mirth_arrow_Op_OpWord(v0);
			VAL v2 = pop_value();
			incref(v2);
			VAL v3 = VVAL(VTUP(v2)->cells[5]);
			incref(v3);
			decref(v2);
			push_value(v2);
			int64_t v4 = mw_std_list_List_1_len(v3);
			push_i64(v4);
			int64_t v5 = mw_mirth_word_Word_arity(v1);
			int64_t v6 = pop_i64();
			bool v7 = (v6 < v5);
			push_bool(v7);
		} break;
		case 1LL: { // OpPrim
			push_value(x1);
			int64_t v8 = mtp_mirth_arrow_Op_OpPrim(v0);
			switch (v8) {
				case 4LL: { // PRIM_CORE_DIP
					VAL v9 = pop_value();
					incref(v9);
					VAL v10 = VVAL(VTUP(v9)->cells[5]);
					incref(v10);
					decref(v9);
					push_value(v9);
					int64_t v11 = mw_std_list_List_1_len(v10);
					int64_t v12 = 1LL;
					push_i64(v11);
					int64_t v13 = mw_std_prim_Int_ZToNat(v12);
					int64_t v14 = pop_i64();
					bool v15 = (v14 < v13);
					push_bool(v15);
				} break;
				case 13LL: { // PRIM_CORE_RDIP
					VAL v16 = pop_value();
					incref(v16);
					VAL v17 = VVAL(VTUP(v16)->cells[5]);
					incref(v17);
					decref(v16);
					push_value(v16);
					int64_t v18 = mw_std_list_List_1_len(v17);
					int64_t v19 = 1LL;
					push_i64(v18);
					int64_t v20 = mw_std_prim_Int_ZToNat(v19);
					int64_t v21 = pop_i64();
					bool v22 = (v21 < v20);
					push_bool(v22);
				} break;
				case 5LL: { // PRIM_CORE_IF
					VAL v23 = pop_value();
					incref(v23);
					VAL v24 = VVAL(VTUP(v23)->cells[5]);
					incref(v24);
					decref(v23);
					push_value(v23);
					int64_t v25 = mw_std_list_List_1_len(v24);
					int64_t v26 = 2LL;
					push_i64(v25);
					int64_t v27 = mw_std_prim_Int_ZToNat(v26);
					int64_t v28 = pop_i64();
					bool v29 = (v28 < v27);
					push_bool(v29);
				} break;
				case 6LL: { // PRIM_CORE_WHILE
					VAL v30 = pop_value();
					incref(v30);
					VAL v31 = VVAL(VTUP(v30)->cells[5]);
					incref(v31);
					decref(v30);
					push_value(v30);
					int64_t v32 = mw_std_list_List_1_len(v31);
					int64_t v33 = 2LL;
					push_i64(v32);
					int64_t v34 = mw_std_prim_Int_ZToNat(v33);
					int64_t v35 = pop_i64();
					bool v36 = (v35 < v34);
					push_bool(v36);
				} break;
				default: {
					int64_t v37 = 0LL /* False */;
					push_i64(v37);
				} break;
			}
		} break;
		default: {
			decref(v0);
			int64_t v38 = 0LL /* False */;
			push_value(x1);
			push_i64(v38);
		} break;
	}
}
static int64_t mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk (VAL x1) {
	VAL v0 = mw_std_list_List_1_last(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v3 = VVAL(VTUP(v2)->cells[4]);
			incref(v3);
			decref(v2);
			switch (get_data_tag(v3)) {
				case 14LL: { // OpBlockPush
					uint64_t v4 = mtp_mirth_arrow_Op_OpBlockPush(v3);
					int64_t v5 = 1LL /* True */;
					push_i64(v5);
				} break;
				default: {
					decref(v3);
					int64_t v6 = 0LL /* False */;
					push_i64(v6);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v7 = pop_i64();
	return v7;
}
static void mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = mw_std_list_List_1_ZToListZPlus(x2);
	switch (get_data_tag(v0)) {
		case 0LL: { // None
			int64_t v1 = 0LL /* Nil */;
			push_i64(v1);
		} break;
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v0);
			mw_std_list_ListZPlus_1_unsnoc(v2);
			VAL v3 = pop_value();
			incref(v3);
			VAL v4 = VVAL(VTUP(v3)->cells[4]);
			incref(v4);
			decref(v3);
			switch (get_data_tag(v4)) {
				case 14LL: { // OpBlockPush
					push_value(v3);
					uint64_t v5 = mtp_mirth_arrow_Op_OpBlockPush(v4);
					VAL v6 = pop_value();
					VAL v7 = VVAL(VTUP(v6)->cells[6]);
					incref(v7);
					decref(v6);
					VAL v8 = pop_value();
					VAL v9 = pop_value();
					VAL v10 = tup_replace(v9, 6, v7);
					incref(v10);
					VAL v11 = VVAL(VTUP(v10)->cells[5]);
					incref(v11);
					decref(v10);
					push_value(v8);
					VAL v12 = mtw_std_list_List_1_Cons(MKU64(v5), v11);
					VAL v13 = tup_replace(v10, 5, v12);
					VAL v14 = pop_value();
					push_value(v13);
					push_value(v14);
				} break;
				default: {
					decref(v4);
					int64_t v15 = 0LL /* Nil */;
					VAL v16 = mtw_std_list_List_1_Cons(v3, MKI64(v15));
					VAL v17 = pop_value();
					VAL v18 = mw_std_list_List_1_cat(v17, v16);
					push_value(v18);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_abZ_opZBang (VAL x1, VAL x2, VAL x3) {
	push_value(x1);
	push_resource(x2);
	mw_mirth_elab_abZ_ctxZAt(x3);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	lpush(&lbl_ctx, v0);
	mw_mirth_elab_abZ_tokenZAt(r1);
	uint64_t v2 = pop_u64();
	VAL r3 = pop_resource();
	lpush(&lbl_token, MKU64(v2));
	mw_mirth_elab_abZ_homeZAt(r3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	VAL r6 = pop_resource();
	VAL r7 = pop_resource();
	lpush(&lbl_home, v4);
	lpush(&lbl_op, v5);
	mw_mirth_elab_elabZ_opZ_freshZ_sigZBang(r7, v5);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	VAL r10 = pop_resource();
	lpush(&lbl_subst, v9);
	mw_mirth_elab_abZ_expandZ_opsigZBang(v8, r10, r6);
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	int64_t v13 = 0LL /* Nil */;
	VAL v14 = lpop(&lbl_subst);
	VAL v15 = lpop(&lbl_op);
	VAL v16 = lpop(&lbl_ctx);
	uint64_t v17 = VU64(lpop(&lbl_token));
	VAL v18 = lpop(&lbl_home);
	VAL v19 = mtw_mirth_arrow_Atom_Atom(v18, v17, v16, v15, MKI64(v13), v12, v11, v14);
	VAL r20 = pop_resource();
	VAL v21 = (mw_mirth_elab_abZ_atomZBang(v19, r20));
	push_resource(v21);
}
static void mw_mirth_elab_abZ_expandZ_opsigZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x1)) {
		case 0LL: { // OPSIG_ID
			push_resource(x2);
			mw_mirth_elab_abZ_typeZAt(x3);
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
		} break;
		case 1LL: { // OPSIG_PUSH
			push_resource(x2);
			push_resource(x3);
			VAL v1 = mtp_mirth_elab_OpSig_OPSIGz_PUSH(x1);
			VAL r2 = pop_resource();
			mw_mirth_elab_abZ_typeZAt(r2);
			VAL v3 = pop_value();
			incref(v3);
			push_value(v3);
			VAL v4 = mtw_mirth_type_StackType_STCons(v3, v1);
			push_value(v4);
		} break;
		case 2LL: { // OPSIG_APPLY
			push_resource(x2);
			push_resource(x3);
			VAL v5 = mtp_mirth_elab_OpSig_OPSIGz_APPLY(x1);
			VAL r6 = pop_resource();
			mw_mirth_elab_abZ_typeZAt(r6);
			mw_mirth_type_ArrowType_unpack(v5);
			VAL v7 = pop_value();
			VAL r8 = pop_resource();
			mw_mirth_elab_abZ_tokenZAt(r8);
			VAL r9 = pop_resource();
			uint64_t v10 = pop_u64();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			VAL r13 = pop_resource();
			mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang(r13, v12, v11, v10);
			uint64_t v14 = pop_u64();
			push_resource(r9);
			push_value(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_resource(x3);
		}
	}
}
static void mw_mirth_elab_abZ_intZBang (int64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpInt(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_f64ZBang (double x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpF64(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_strZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpStr(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_bufferZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpBuffer(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_variableZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpVariable(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_fieldZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpField(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_varZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpVar(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_tagZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpTag(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_primZBang (int64_t x1, VAL x2, VAL x3) {
	void* v0 = mfld_mirth_prim_Prim_ZTildetype(((uint64_t)x1));
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		push_resource(x2);
		push_resource(x3);
		VAL v2 = mtw_mirth_arrow_Op_OpPrim(x1);
		VAL r3 = pop_resource();
		VAL r4 = pop_resource();
		mw_mirth_elab_abZ_opZBang(v2, r4, r3);
	} else {
		push_resource(x2);
		push_i64(x1);
		mw_mirth_elab_abZ_tokenZAt(x3);
		STR* v5;
		STRLIT(v5, "prim does not have type", 23);
		VAL r6 = pop_resource();
		VAL r7 = pop_resource();
		uint64_t v8 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v8, MKSTR(v5), r7);
		push_resource(r6);
	}
}
static void mw_mirth_elab_abZ_wordZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpWord(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_externalZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpExternal(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_coerceZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpCoerce(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_labelZ_pushZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpLabelPush(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_labelZ_popZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpLabelPop(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_labelZ_pushZ_rZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpLabelPushR(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_abZ_labelZ_popZ_rZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mtw_mirth_arrow_Op_OpLabelPopR(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v0, r2, r1);
}
static void mw_mirth_elab_elabZ_opZ_freshZ_sigZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_value(x2);
	VAL v0 = mw_mirth_type_Subst_nil();
	VAL v1 = pop_value();
	switch (get_data_tag(v1)) {
		case 0LL: { // OpNone
			int64_t v2 = 0LL /* OPSIG_ID */;
			push_value(v0);
			push_i64(v2);
		} break;
		case 7LL: { // OpInt
			push_value(v0);
			int64_t v3 = mtp_mirth_arrow_Op_OpInt(v1);
			VAL v4 = mtw_mirth_type_Value_VALUEz_INT(v3);
			VAL v5 = mtw_mirth_type_Type_TValue(v4);
			VAL v6 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v5);
			push_value(v6);
		} break;
		case 8LL: { // OpF64
			push_value(v0);
			double v7 = mtp_mirth_arrow_Op_OpF64(v1);
			VAL v8 = mtw_mirth_type_Value_VALUEz_F64(v7);
			VAL v9 = mtw_mirth_type_Type_TValue(v8);
			VAL v10 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v9);
			push_value(v10);
		} break;
		case 9LL: { // OpStr
			push_value(v0);
			VAL v11 = mtp_mirth_arrow_Op_OpStr(v1);
			VAL v12 = mtw_mirth_type_Value_VALUEz_STR(v11);
			VAL v13 = mtw_mirth_type_Type_TValue(v12);
			VAL v14 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v13);
			push_value(v14);
		} break;
		case 4LL: { // OpBuffer
			push_value(v0);
			uint64_t v15 = mtp_mirth_arrow_Op_OpBuffer(v1);
			VAL v16 = mw_mirth_type_TYPEz_PTR();
			VAL v17 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v16);
			push_value(v17);
		} break;
		case 5LL: { // OpVariable
			push_value(v0);
			uint64_t v18 = mtp_mirth_arrow_Op_OpVariable(v1);
			VAL r19 = pop_resource();
			mw_mirth_variable_Variable_type(r19, v18);
			VAL v20 = pop_value();
			VAL v21 = mtw_mirth_type_Type_TMut(v20);
			VAL v22 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v21);
			push_value(v22);
		} break;
		case 10LL: { // OpTag
			push_value(v0);
			uint64_t v23 = mtp_mirth_arrow_Op_OpTag(v1);
			VAL r24 = pop_resource();
			mw_mirth_data_Tag_type(r24, v23);
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v26, v25);
			VAL v27 = pop_value();
			VAL v28 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v27);
			push_value(v28);
		} break;
		case 2LL: { // OpWord
			push_value(v0);
			uint64_t v29 = mtp_mirth_arrow_Op_OpWord(v1);
			push_u64(v29);
			int64_t v30 = mw_mirth_word_Word_inferringZ_typeZAsk(v29);
			if (((bool)v30)) {
				VAL r31 = pop_resource();
				uint64_t v32 = pop_u64();
				mw_mirth_word_Word_type(v32, r31);
			} else {
				VAL r33 = pop_resource();
				uint64_t v34 = pop_u64();
				mw_mirth_word_Word_type(v34, r33);
				VAL v35 = pop_value();
				VAL v36 = pop_value();
				mw_mirth_type_ArrowType_freshenZ_sig(v36, v35);
			}
			VAL v37 = pop_value();
			VAL v38 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v37);
			push_value(v38);
		} break;
		case 1LL: { // OpPrim
			push_value(v0);
			int64_t v39 = mtp_mirth_arrow_Op_OpPrim(v1);
			VAL v40 = mw_mirth_prim_Prim_type(v39);
			VAL v41 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v41, v40);
			VAL v42 = pop_value();
			VAL v43 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v42);
			push_value(v43);
		} break;
		case 3LL: { // OpExternal
			push_value(v0);
			uint64_t v44 = mtp_mirth_arrow_Op_OpExternal(v1);
			VAL r45 = pop_resource();
			mw_mirth_external_External_type(r45, v44);
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v47, v46);
			VAL v48 = pop_value();
			VAL v49 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v48);
			push_value(v49);
		} break;
		case 6LL: { // OpField
			push_value(v0);
			uint64_t v50 = mtp_mirth_arrow_Op_OpField(v1);
			VAL r51 = pop_resource();
			mw_mirth_table_Field_type(r51, v50);
			VAL v52 = pop_value();
			VAL v53 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v53, v52);
			VAL v54 = pop_value();
			VAL v55 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v54);
			push_value(v55);
		} break;
		case 14LL: { // OpBlockPush
			push_value(v0);
			uint64_t v56 = mtp_mirth_arrow_Op_OpBlockPush(v1);
			VAL v57 = mw_mirth_elab_elabZ_blockZ_sigZBang(v56);
			push_value(v57);
		} break;
		case 15LL: { // OpBlockRun
			push_value(v0);
			uint64_t v58 = mtp_mirth_arrow_Op_OpBlockRun(v1);
			VAL v59 = mw_mirth_arrow_Block_type(v58);
			VAL v60 = mw_mirth_type_ArrowType_semifreshenZ_sig(v59);
			VAL v61 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v60);
			push_value(v61);
		} break;
		case 13LL: { // OpVar
			push_value(v0);
			uint64_t v62 = mtp_mirth_arrow_Op_OpVar(v1);
			VAL v63 = mw_mirth_elab_elabZ_varZ_sigZBang(v62);
			push_value(v63);
		} break;
		case 11LL: { // OpMatch
			push_value(v0);
			VAL v64 = mtp_mirth_arrow_Op_OpMatch(v1);
			VAL v65 = mw_mirth_elab_elabZ_matchZ_sigZBang(v64);
			push_value(v65);
		} break;
		case 12LL: { // OpLambda
			push_value(v0);
			VAL v66 = mtp_mirth_arrow_Op_OpLambda(v1);
			VAL v67 = mw_mirth_elab_elabZ_lambdaZ_sigZBang(v66);
			push_value(v67);
		} break;
		case 16LL: { // OpCoerce
			push_value(v0);
			VAL v68 = mtp_mirth_arrow_Op_OpCoerce(v1);
			VAL v69 = mw_mirth_elab_elabZ_coerceZ_sigZBang(v68);
			push_value(v69);
		} break;
		case 17LL: { // OpLabelPush
			push_value(v0);
			uint64_t v70 = mtp_mirth_arrow_Op_OpLabelPush(v1);
			VAL v71 = mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang(v70);
			push_value(v71);
		} break;
		case 18LL: { // OpLabelPop
			push_value(v0);
			uint64_t v72 = mtp_mirth_arrow_Op_OpLabelPop(v1);
			VAL v73 = mw_mirth_elab_elabZ_labelZ_popZ_sigZBang(v72);
			push_value(v73);
		} break;
		case 19LL: { // OpLabelPushR
			push_value(v0);
			uint64_t v74 = mtp_mirth_arrow_Op_OpLabelPushR(v1);
			VAL v75 = mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang(v74);
			push_value(v75);
		} break;
		case 20LL: { // OpLabelPopR
			push_value(v0);
			uint64_t v76 = mtp_mirth_arrow_Op_OpLabelPopR(v1);
			VAL v77 = mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang(v76);
			push_value(v77);
		} break;
		case 21LL: { // OpDataGetTag
			push_value(v0);
			uint64_t v78 = mtp_mirth_arrow_Op_OpDataGetTag(v1);
			VAL r79 = pop_resource();
			mw_mirth_elab_dataZ_getZ_tagZ_type(r79, v78);
			VAL v80 = pop_value();
			VAL v81 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v81, v80);
			VAL v82 = pop_value();
			VAL v83 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v82);
			push_value(v83);
		} break;
		case 22LL: { // OpDataGetLabel
			push_value(v0);
			mtp_mirth_arrow_Op_OpDataGetLabel(v1);
			uint64_t v84 = pop_u64();
			uint64_t v85 = pop_u64();
			VAL r86 = pop_resource();
			mw_mirth_elab_dataZ_getZ_labelZ_type(r86, v85, v84);
			VAL v87 = pop_value();
			VAL v88 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v88, v87);
			VAL v89 = pop_value();
			VAL v90 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v89);
			push_value(v90);
		} break;
		case 23LL: { // OpDataSetLabel
			push_value(v0);
			mtp_mirth_arrow_Op_OpDataSetLabel(v1);
			uint64_t v91 = pop_u64();
			uint64_t v92 = pop_u64();
			VAL r93 = pop_resource();
			mw_mirth_elab_dataZ_setZ_labelZ_type(r93, v92, v91);
			VAL v94 = pop_value();
			VAL v95 = pop_value();
			mw_mirth_type_ArrowType_freshenZ_sig(v95, v94);
			VAL v96 = pop_value();
			VAL v97 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v96);
			push_value(v97);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(v0);
		}
	}
}
static void mw_mirth_elab_dataZ_getZ_tagZ_type (VAL x1, uint64_t x2) {
	mw_mirth_data_Data_fullZ_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_std_either_Either_2_leftZAsk(v0);
	VAL v2 = mw_std_maybe_Maybe_1_unwrap(v1);
	VAL v3 = mw_mirth_type_T1(v2);
	push_value(v3);
	VAL v4 = mw_mirth_type_TYPEz_INT();
	VAL v5 = mw_mirth_type_T1(v4);
	VAL v6 = pop_value();
	VAL v7 = mw_mirth_type_TZ_ZTo(v6, v5);
	push_value(v7);
}
static VAL mw_mirth_elab_elabZ_coerceZ_sigZBang (VAL x1) {
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	incref(v1);
	push_value(v1);
	push_value(v1);
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_Type_TMeta(v2);
	VAL v4 = pop_value();
	VAL v5 = mw_mirth_type_TZMul(v4, v3);
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	uint64_t v7 = mw_mirth_type_MetaVar_newZBang();
	VAL v8 = mtw_mirth_type_Type_TMeta(v7);
	VAL v9 = pop_value();
	VAL v10 = mw_mirth_type_TZMul(v9, v8);
	VAL v11 = pop_value();
	VAL v12 = mw_mirth_type_TZ_ZTo(v11, v10);
	VAL v13 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v12);
	return v13;
}
static VAL mw_mirth_elab_elabZ_blockZ_sigZBang (uint64_t x1) {
	VAL v0 = mtw_mirth_type_Value_VALUEz_BLOCK(x1);
	VAL v1 = mtw_mirth_type_Type_TValue(v0);
	VAL v2 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v1);
	return v2;
}
static VAL mw_mirth_elab_elabZ_matchZ_sigZBang (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(x1)->cells[6]);
	incref(v1);
	decref(x1);
	VAL v2 = mw_mirth_type_TZ_ZTo(v0, v1);
	VAL v3 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v2);
	return v3;
}
static VAL mw_mirth_elab_elabZ_lambdaZ_sigZBang (VAL x1) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[3]);
	incref(v0);
	decref(x1);
	push_value(v0);
	VAL v1 = mw_mirth_arrow_Lambda_cod(x1);
	VAL v2 = pop_value();
	VAL v3 = mw_mirth_type_TZ_ZTo(v2, v1);
	VAL v4 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v3);
	return v4;
}
static VAL mw_mirth_elab_elabZ_varZ_sigZBang (uint64_t x1) {
	push_u64(x1);
	int64_t v0 = mw_mirth_var_Var_autoZ_runZAsk(x1);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		VAL v2 = mw_mirth_var_Var_type(v1);
		VAL v3 = mw_mirth_type_Type_morphismZAsk(v2);
		VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
		VAL v5 = mw_mirth_type_ArrowType_semifreshenZ_sig(v4);
		VAL v6 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v5);
		push_value(v6);
	} else {
		uint64_t v7 = pop_u64();
		VAL v8 = mw_mirth_var_Var_type(v7);
		VAL v9 = mtw_mirth_elab_OpSig_OPSIGz_PUSH(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	return v10;
}
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang (uint64_t x1) {
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	push_value(v1);
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_Type_TMeta(v2);
	VAL v4 = pop_value();
	incref(v4);
	incref(v3);
	push_value(v4);
	push_value(v3);
	VAL v5 = mtw_mirth_type_StackType_STConsLabel(v4, v3, x1);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = mtw_mirth_type_StackType_STCons(v7, v6);
	VAL v9 = mw_mirth_type_TZ_ZTo(v8, v5);
	VAL v10 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v9);
	return v10;
}
static VAL mw_mirth_elab_elabZ_labelZ_popZ_sigZBang (uint64_t x1) {
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	push_value(v1);
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_Type_TMeta(v2);
	VAL v4 = pop_value();
	incref(v4);
	incref(v3);
	push_value(v4);
	push_value(v3);
	VAL v5 = mtw_mirth_type_StackType_STConsLabel(v4, v3, x1);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = mtw_mirth_type_StackType_STCons(v7, v6);
	VAL v9 = mw_mirth_type_TZ_ZTo(v5, v8);
	VAL v10 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v9);
	return v10;
}
static VAL mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang (uint64_t x1) {
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	push_value(v1);
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_Type_TMeta(v2);
	VAL v4 = pop_value();
	incref(v4);
	incref(v3);
	push_value(v4);
	push_value(v3);
	VAL v5 = mtw_mirth_type_StackType_STWithLabel(v4, v3, x1);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = mtw_mirth_type_StackType_STWith(v7, v6);
	VAL v9 = mw_mirth_type_TZ_ZTo(v8, v5);
	VAL v10 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v9);
	return v10;
}
static VAL mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang (uint64_t x1) {
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	push_value(v1);
	uint64_t v2 = mw_mirth_type_MetaVar_newZBang();
	VAL v3 = mtw_mirth_type_Type_TMeta(v2);
	VAL v4 = pop_value();
	incref(v4);
	incref(v3);
	push_value(v4);
	push_value(v3);
	VAL v5 = mtw_mirth_type_StackType_STWithLabel(v4, v3, x1);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = mtw_mirth_type_StackType_STWith(v7, v6);
	VAL v9 = mw_mirth_type_TZ_ZTo(v5, v8);
	VAL v10 = mtw_mirth_elab_OpSig_OPSIGz_APPLY(v9);
	return v10;
}
static void mw_mirth_elab_elabZ_arrowZ_homZBang (VAL x1, VAL x2, VAL x3, VAL x4, uint64_t x5, VAL x6) {
	mw_mirth_elab_elabZ_arrowZ_fwdZBang(x1, x2, x3, x5, x6);
	VAL v0 = pop_value();
	incref(v0);
	uint64_t v1 = VU64(VTUP(v0)->cells[3]);
	decref(v0);
	incref(v0);
	VAL v2 = VVAL(VTUP(v0)->cells[6]);
	incref(v2);
	decref(v0);
	VAL r3 = pop_resource();
	push_value(v0);
	mw_mirth_type_StackType_unifyZBang(r3, v1, v2, x4);
	uint64_t r4 = VU64(pop_resource());
	mw_mirth_type_ZPlusGamma_rdrop(r4);
	VAL v5 = pop_value();
	decref(v5);
}
static void mw_mirth_elab_elabZ_arrowZ_fwdZBang (VAL x1, VAL x2, VAL x3, uint64_t x4, VAL x5) {
	incref(x3);
	int64_t v0 = 0LL /* Nil */;
	push_resource(x1);
	VAL v1 = mtw_mirth_arrow_Arrow_Arrow(x5, x4, x4, x2, x3, x3, MKI64(v0));
	VAL r2 = pop_resource();
	mw_mirth_elab_elabZ_atomsZBang(r2, v1);
	VAL r3 = pop_resource();
	push_value(r3);
}
static void mw_mirth_elab_elabZ_atomsZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_resource(x2);
	while(1) {
		VAL r0 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r0);
		uint64_t v1 = pop_u64();
		int64_t v2 = mw_mirth_token_Token_runZ_endZAsk(v1);
		bool v3 = !((bool)v2);
		if (!v3) break;
		VAL r4 = pop_resource();
		VAL r5 = pop_resource();
		mw_mirth_elab_elabZ_atomZBang(r5, r4);
		VAL r6 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r6);
		uint64_t v7 = pop_u64();
		uint64_t v8 = mw_mirth_token_Token_next(v7);
		VAL r9 = pop_resource();
		VAL v10 = (mw_mirth_elab_abZ_tokenZBang(r9, v8));
		push_resource(v10);
	}
}
static void mw_mirth_elab_elabZ_atomZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_tokenZAt(x2);
	uint64_t v0 = pop_u64();
	VAL v1 = mw_mirth_token_Token_value(v0);
	switch (get_data_tag(v1)) {
		case 17LL: { // TokenName
			uint64_t v2 = mtp_mirth_token_TokenValue_TokenName(v1);
			VAL r3 = pop_resource();
			VAL r4 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_nameZBang(v2, r4, r3);
		} break;
		case 18LL: { // TokenDName
			VAL v5 = mtp_mirth_token_TokenValue_TokenDName(v1);
			VAL r6 = pop_resource();
			VAL r7 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_dnameZBang(v5, r7, r6);
		} break;
		case 14LL: { // TokenInt
			int64_t v8 = mtp_mirth_token_TokenValue_TokenInt(v1);
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			mw_mirth_elab_abZ_intZBang(v8, r10, r9);
		} break;
		case 16LL: { // TokenStr
			VAL v11 = mtp_mirth_token_TokenValue_TokenStr(v1);
			VAL r12 = pop_resource();
			VAL r13 = pop_resource();
			mw_mirth_elab_abZ_strZBang(v11, r13, r12);
		} break;
		case 15LL: { // TokenF64
			double v14 = mtp_mirth_token_TokenValue_TokenF64(v1);
			VAL r15 = pop_resource();
			VAL r16 = pop_resource();
			mw_mirth_elab_abZ_f64ZBang(v14, r16, r15);
		} break;
		case 8LL: { // TokenLSquare
			uint64_t v17 = mtp_mirth_token_TokenValue_TokenLSquare(v1);
			VAL r18 = pop_resource();
			VAL r19 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_blockZBang(r19, r18);
		} break;
		case 10LL: { // TokenLCurly
			uint64_t v20 = mtp_mirth_token_TokenValue_TokenLCurly(v1);
			VAL r21 = pop_resource();
			VAL r22 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_assertZBang(r22, r21);
		} break;
		case 20LL: { // TokenLabelPush
			uint64_t v23 = mtp_mirth_token_TokenValue_TokenLabelPush(v1);
			VAL r24 = pop_resource();
			push_u64(v23);
			mw_mirth_elab_abZ_tokenZAt(r24);
			VAL r25 = pop_resource();
			VAL r26 = pop_resource();
			uint64_t v27 = pop_u64();
			VAL v28 = (mw_mirth_token_Token_argsZ_0(v27, r26));
			uint64_t v29 = pop_u64();
			mw_mirth_elab_abZ_labelZ_pushZBang(v29, v28, r25);
		} break;
		case 19LL: { // TokenLabelPop
			uint64_t v30 = mtp_mirth_token_TokenValue_TokenLabelPop(v1);
			VAL r31 = pop_resource();
			push_u64(v30);
			mw_mirth_elab_abZ_tokenZAt(r31);
			VAL r32 = pop_resource();
			VAL r33 = pop_resource();
			uint64_t v34 = pop_u64();
			VAL v35 = (mw_mirth_token_Token_argsZ_0(v34, r33));
			uint64_t v36 = pop_u64();
			mw_mirth_elab_abZ_labelZ_popZBang(v36, v35, r32);
		} break;
		case 22LL: { // TokenLabelPushR
			uint64_t v37 = mtp_mirth_token_TokenValue_TokenLabelPushR(v1);
			VAL r38 = pop_resource();
			push_u64(v37);
			mw_mirth_elab_abZ_tokenZAt(r38);
			VAL r39 = pop_resource();
			VAL r40 = pop_resource();
			uint64_t v41 = pop_u64();
			VAL v42 = (mw_mirth_token_Token_argsZ_0(v41, r40));
			uint64_t v43 = pop_u64();
			mw_mirth_elab_abZ_labelZ_pushZ_rZBang(v43, v42, r39);
		} break;
		case 21LL: { // TokenLabelPopR
			uint64_t v44 = mtp_mirth_token_TokenValue_TokenLabelPopR(v1);
			VAL r45 = pop_resource();
			push_u64(v44);
			mw_mirth_elab_abZ_tokenZAt(r45);
			VAL r46 = pop_resource();
			VAL r47 = pop_resource();
			uint64_t v48 = pop_u64();
			VAL v49 = (mw_mirth_token_Token_argsZ_0(v48, r47));
			uint64_t v50 = pop_u64();
			mw_mirth_elab_abZ_labelZ_popZ_rZBang(v50, v49, r46);
		} break;
		case 23LL: { // TokenLabelGet
			uint64_t v51 = mtp_mirth_token_TokenValue_TokenLabelGet(v1);
			VAL r52 = pop_resource();
			VAL r53 = pop_resource();
			mw_mirth_elab_elabZ_labelZ_getZBang(v51, r53, r52);
		} break;
		case 24LL: { // TokenLabelSet
			uint64_t v54 = mtp_mirth_token_TokenValue_TokenLabelSet(v1);
			VAL r55 = pop_resource();
			VAL r56 = pop_resource();
			mw_mirth_elab_elabZ_labelZ_setZBang(v54, r56, r55);
		} break;
		default: {
			VAL r57 = pop_resource();
			push_value(v1);
			mw_mirth_elab_abZ_tokenZAt(r57);
			STR* v58;
			STRLIT(v58, "Unexpected token in elab-atom!", 30);
			VAL r59 = pop_resource();
			VAL r60 = pop_resource();
			uint64_t v61 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v61, MKSTR(v58), r60);
			push_resource(r59);
		} break;
	}
}
static void mw_mirth_elab_elabZ_labelZ_getZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	push_u64(x1);
	int64_t v0 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(x1);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		VAL r2 = pop_resource();
		VAL r3 = pop_resource();
		push_u64(v1);
		mw_mirth_elab_abZ_labelZ_popZ_rZBang(v1, r3, r2);
		VAL r4 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r4);
		uint64_t v5 = pop_u64();
		VAL r6 = pop_resource();
		VAL r7 = pop_resource();
		push_u64(v5);
		mw_mirth_token_Token_argsZ_1(v5, r7);
		uint64_t v8 = pop_u64();
		VAL v9 = (mw_mirth_elab_abZ_tokenZBang(r6, v8));
		VAL r10 = pop_resource();
		mw_mirth_elab_elabZ_atomsZBang(r10, v9);
		uint64_t v11 = pop_u64();
		VAL r12 = pop_resource();
		VAL v13 = (mw_mirth_elab_abZ_tokenZBang(r12, v11));
		VAL r14 = pop_resource();
		uint64_t v15 = pop_u64();
		mw_mirth_elab_abZ_labelZ_pushZ_rZBang(v15, r14, v13);
	} else {
		uint64_t v16 = pop_u64();
		VAL r17 = pop_resource();
		VAL r18 = pop_resource();
		push_u64(v16);
		mw_mirth_elab_abZ_labelZ_popZBang(v16, r18, r17);
		VAL r19 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r19);
		uint64_t v20 = pop_u64();
		int64_t v21 = mw_mirth_token_Token_numZ_args(v20);
		int64_t v22 = 0LL;
		bool v23 = (v21 == v22);
		if (v23) {
			int64_t v24 = 1LL /* PRIM_CORE_DUP */;
			VAL r25 = pop_resource();
			VAL r26 = pop_resource();
			mw_mirth_elab_abZ_primZBang(v24, r26, r25);
		} else {
			VAL r27 = pop_resource();
			mw_mirth_elab_abZ_tokenZAt(r27);
			uint64_t v28 = pop_u64();
			VAL r29 = pop_resource();
			VAL r30 = pop_resource();
			push_u64(v28);
			mw_mirth_token_Token_argsZ_1(v28, r30);
			uint64_t v31 = pop_u64();
			VAL v32 = (mw_mirth_elab_abZ_tokenZBang(r29, v31));
			VAL r33 = pop_resource();
			mw_mirth_elab_elabZ_atomsZBang(r33, v32);
			uint64_t v34 = pop_u64();
			VAL r35 = pop_resource();
			VAL v36 = (mw_mirth_elab_abZ_tokenZBang(r35, v34));
			push_resource(v36);
		}
		VAL r37 = pop_resource();
		VAL r38 = pop_resource();
		uint64_t v39 = pop_u64();
		mw_mirth_elab_abZ_labelZ_pushZBang(v39, r38, r37);
	}
}
static void mw_mirth_elab_elabZ_labelZ_setZBang (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	push_resource(x2);
	mw_mirth_elab_abZ_tokenZAt(x3);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = (mw_mirth_token_Token_argsZ_0(v2, r1));
	uint64_t v4 = pop_u64();
	push_u64(v4);
	mw_mirth_elab_abZ_labelZ_popZBang(v4, v3, r0);
	int64_t v5 = 2LL /* PRIM_CORE_DROP */;
	VAL r6 = pop_resource();
	VAL r7 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v5, r7, r6);
	VAL r8 = pop_resource();
	VAL r9 = pop_resource();
	uint64_t v10 = pop_u64();
	mw_mirth_elab_abZ_labelZ_pushZBang(v10, r9, r8);
}
static void mw_mirth_elab_elabZ_atomZ_blockZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_tokenZAt(x2);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	mw_mirth_token_Token_argsZ_1(v2, r1);
	VAL r3 = pop_resource();
	uint64_t v4 = pop_u64();
	mw_mirth_elab_elabZ_blockZ_atZBang(v4, r3, r0);
}
static void mw_mirth_elab_elabZ_blockZ_atZBang (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	push_resource(x2);
	mw_mirth_elab_abZ_ctxZAt(x3);
	VAL v0 = pop_value();
	uint64_t v1 = pop_u64();
	VAL r2 = pop_resource();
	push_value(v0);
	push_u64(v1);
	mw_mirth_elab_abZ_homeZAt(r2);
	VAL r3 = pop_resource();
	FNPTR v4 = &mb_mirth_elab_elabZ_blockZ_atZBang_1;
	VAL v5 = pop_value();
	uint64_t v6 = pop_u64();
	VAL v7 = pop_value();
	VAL r8 = pop_resource();
	mw_mirth_arrow_Block_newZ_deferredZBang_1(r8, v7, v6, v5, MKFNPTR(v4));
	uint64_t v9 = pop_u64();
	push_resource(r3);
	VAL v10 = mtw_mirth_arrow_Op_OpBlockPush(v9);
	VAL r11 = pop_resource();
	VAL r12 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v10, r12, r11);
}
static void mw_mirth_elab_elabZ_argsZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_tokenZAt(x2);
	uint64_t v0 = pop_u64();
	VAL v1 = mw_mirth_token_Token_args(v0);
	mw_std_list_List_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL r9 = pop_resource();
		VAL r10 = pop_resource();
		mw_mirth_elab_elabZ_blockZ_atZBang(VU64(v7), r10, r9);
		mw_std_list_List_1_uncons(v8);
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
}
static void mw_mirth_elab_elabZ_noZ_argsZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_tokenZAt(x2);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	VAL v3 = (mw_mirth_token_Token_argsZ_0(v2, r1));
	push_resource(v3);
	push_resource(r0);
}
static int64_t mw_mirth_elab_arityZ_compatibleZAsk (int64_t x1, int64_t x2) {
	int64_t v0 = -1LL;
	bool v1 = (x2 == v0);
	bool v2 = (x1 == x2);
	bool v3 = (v2 || v1);
	return ((int64_t)v3);
}
static void mw_mirth_elab_elabZ_atomZ_nameZBang (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	push_resource(x2);
	mw_mirth_elab_abZ_ctxZAt(x3);
	VAL v0 = pop_value();
	uint64_t v1 = pop_u64();
	VAL v2 = mw_mirth_var_Ctx_lookup(v1, v0);
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			push_value(v3);
			mw_mirth_elab_elabZ_argsZBang(r5, r4);
			VAL r6 = pop_resource();
			VAL r7 = pop_resource();
			uint64_t v8 = pop_u64();
			mw_mirth_elab_abZ_varZBang(v8, r7, r6);
		} break;
		case 0LL: { // None
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang(r10, r9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_atomZ_dnameZBang (VAL x1, VAL x2, VAL x3) {
	decref(x1);
	mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang(x2, x3);
}
static int64_t mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk (uint64_t x1) {
	VAL v0 = mw_mirth_token_Token_value(x1);
	switch (get_data_tag(v0)) {
		case 17LL: { // TokenName
			uint64_t v1 = mtp_mirth_token_TokenValue_TokenName(v0);
			int64_t v2 = mw_mirth_name_Name_canZ_beZ_relativeZAsk(v1);
			push_i64(v2);
		} break;
		case 18LL: { // TokenDName
			VAL v3 = mtp_mirth_token_TokenValue_TokenDName(v0);
			int64_t v4 = mw_mirth_name_DName_isZ_relativeZAsk(v3);
			push_i64(v4);
		} break;
		default: {
			decref(v0);
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
	}
	int64_t v6 = pop_i64();
	return v6;
}
static void mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_typeZAt(x2);
	VAL v0 = pop_value();
	int64_t v1 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v0);
	bool v2 = !((bool)v1);
	VAL r3 = pop_resource();
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKBOOL(v2));
	mw_mirth_elab_abZ_tokenZAt(r3);
	uint64_t v4 = pop_u64();
	STR* v5;
	STRLIT(v5, "word", 4);
	int64_t v6 = 0LL /* False */;
	VAL r7 = pop_resource();
	VAL r8 = pop_resource();
	int64_t v9 = VI64(lpop(&lbl_reportZ_ambiguousZ_asZ_warning));
	lpush(&lbl_ZPlusab, r7);
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v5), v4, v9, v6, r8);
	VAL r10 = pop_resource();
	VAL v11 = VVAL(VTUP(r10)->cells[3]);
	incref(v11);
	int64_t v12 = 0LL /* Nil */;
	int64_t v13 = 0LL /* Nil */;
	push_resource(r10);
	push_i64(v12);
	push_i64(v13);
	mw_std_list_List_1_uncons(v11);
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	push_value(v14);
	push_value(v15);
	while(1) {
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		int64_t v17 = mw_std_maybe_Maybe_1_someZAsk(v16);
		if (!((bool)v17)) break;
		VAL v18 = pop_value();
		VAL v19 = mw_std_maybe_Maybe_1_unwrap(v18);
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		incref(v19);
		VAL r23 = pop_resource();
		VAL r24 = pop_resource();
		push_value(v19);
		mw_mirth_def_Def_callableZAsk(r24, v19);
		bool v25 = pop_bool();
		if (v25) {
			VAL v26 = pop_value();
			push_resource(r23);
			VAL v27 = mtw_std_either_Either_2_Right(v26);
			push_value(v27);
		} else {
			VAL v28 = pop_value();
			push_resource(r23);
			VAL v29 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v28);
			VAL v30 = mtw_std_either_Either_2_Left(v29);
			push_value(v30);
		}
		VAL v31 = pop_value();
		switch (get_data_tag(v31)) {
			case 0LL: { // Left
				push_value(v22);
				push_value(v21);
				VAL v32 = mtp_std_either_Either_2_Left(v31);
				VAL v33 = pop_value();
				VAL v34 = pop_value();
				VAL v35 = mtw_std_list_List_1_Cons(v32, v34);
				push_value(v35);
				push_value(v33);
			} break;
			case 1LL: { // Right
				push_value(v22);
				push_value(v21);
				VAL v36 = mtp_std_either_Either_2_Right(v31);
				VAL v37 = pop_value();
				VAL v38 = mtw_std_list_List_1_Cons(v36, v37);
				push_value(v38);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_value(v22);
				push_value(v21);
			}
		}
		mw_std_list_List_1_uncons(v20);
		VAL v39 = pop_value();
		VAL v40 = pop_value();
		push_value(v39);
		push_value(v40);
	}
	VAL v41 = pop_value();
	decref(v41);
	VAL v42 = pop_value();
	decref(v42);
	VAL v43 = pop_value();
	VAL v44 = pop_value();
	VAL v45 = mw_std_list_List_1_reverse(v44);
	push_value(v45);
	VAL v46 = mw_std_list_List_1_reverse(v43);
	VAL r47 = pop_resource();
	VAL v48 = VVAL(VTUP(r47)->cells[4]);
	incref(v48);
	VAL v49 = pop_value();
	VAL v50 = mw_std_list_List_1_cat(v49, v48);
	VAL v51 = VTUP(r47)->cells[4];
	decref(v51);
	VTUP(r47)->cells[4] = v50;
	VAL v52 = VTUP(r47)->cells[3];
	decref(v52);
	VTUP(r47)->cells[3] = v46;
	VAL r53 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_arity(r53, r47);
	VAL r54 = pop_resource();
	VAL r55 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(r55, r54);
	VAL r56 = pop_resource();
	uint64_t v57 = VU64(VTUP(r56)->cells[2]);
	push_resource(r56);
	int64_t v58 = mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk(v57);
	if (((bool)v58)) {
		VAL v59 = (lpop(&lbl_ZPlusab));
		mw_mirth_elab_abZ_typeZAt(v59);
		VAL r60 = pop_resource();
		VAL v61 = pop_value();
		lpush(&lbl_ZPlusab, r60);
		int64_t v62 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v61);
		if (((bool)v62)) {
			VAL v63 = (lpop(&lbl_ZPlusab));
			mw_mirth_elab_abZ_typeZAt(v63);
			VAL r64 = pop_resource();
			VAL v65 = pop_value();
			lpush(&lbl_ZPlusab, r64);
			VAL v66 = mw_mirth_type_StackType_topZ_namespaces(v65);
			VAL r67 = pop_resource();
			VAL r68 = pop_resource();
			mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v66, r68, r67);
		} else {
		}
	} else {
		int64_t v69 = 0LL /* Nil */;
		VAL r70 = pop_resource();
		VAL r71 = pop_resource();
		mw_mirth_elab_ZPlusResolveDef_filterZ_roots(MKI64(v69), r71, r70);
	}
	VAL r72 = pop_resource();
	VAL r73 = pop_resource();
	mw_mirth_elab_resolveZ_defZ_endZBang(r73, r72);
	VAL v74 = (lpop(&lbl_ZPlusab));
	VAL v75 = pop_value();
	switch (get_data_tag(v75)) {
		case 0LL: { // None
			VAL r76 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_failedZBang(r76, v74);
		} break;
		case 1LL: { // Some
			push_resource(v74);
			VAL v77 = mtp_std_maybe_Maybe_1_Some(v75);
			VAL r78 = pop_resource();
			VAL r79 = pop_resource();
			mw_mirth_elab_elabZ_atomZ_defZBang(v77, r79, r78);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(v74);
		}
	}
}
static void mw_mirth_elab_elabZ_atomZ_failedZBang (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* STACK_TYPE_ERROR */;
	push_resource(x1);
	VAL v1 = (mw_mirth_elab_abZ_typeZBang(x2, MKI64(v0)));
	push_resource(v1);
}
static void mw_mirth_elab_elabZ_atomZ_defZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x1)) {
		case 0LL: { // DefAlias
			push_resource(x2);
			push_resource(x3);
			uint64_t v0 = mtp_mirth_def_Def_DefAlias(x1);
			VAL r1 = pop_resource();
			VAL r2 = pop_resource();
			mw_mirth_alias_Alias_target(r2, v0);
			VAL r3 = pop_resource();
			VAL v4 = pop_value();
			mw_mirth_elab_elabZ_atomZ_defZBang(v4, r3, r1);
		} break;
		case 9LL: { // DefBuffer
			push_resource(x2);
			push_resource(x3);
			uint64_t v5 = mtp_mirth_def_Def_DefBuffer(x1);
			VAL r6 = pop_resource();
			VAL r7 = pop_resource();
			push_u64(v5);
			mw_mirth_elab_elabZ_noZ_argsZBang(r7, r6);
			VAL r8 = pop_resource();
			VAL r9 = pop_resource();
			uint64_t v10 = pop_u64();
			mw_mirth_elab_abZ_bufferZBang(v10, r9, r8);
		} break;
		case 10LL: { // DefVariable
			push_resource(x2);
			push_resource(x3);
			uint64_t v11 = mtp_mirth_def_Def_DefVariable(x1);
			VAL r12 = pop_resource();
			VAL r13 = pop_resource();
			push_u64(v11);
			mw_mirth_elab_elabZ_noZ_argsZBang(r13, r12);
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			uint64_t v16 = pop_u64();
			mw_mirth_elab_abZ_variableZBang(v16, r15, r14);
		} break;
		case 11LL: { // DefExternal
			push_resource(x2);
			push_resource(x3);
			uint64_t v17 = mtp_mirth_def_Def_DefExternal(x1);
			VAL r18 = pop_resource();
			VAL r19 = pop_resource();
			push_u64(v17);
			mw_mirth_elab_elabZ_noZ_argsZBang(r19, r18);
			VAL r20 = pop_resource();
			VAL r21 = pop_resource();
			uint64_t v22 = pop_u64();
			mw_mirth_elab_abZ_externalZBang(v22, r21, r20);
		} break;
		case 12LL: { // DefField
			push_resource(x2);
			push_resource(x3);
			uint64_t v23 = mtp_mirth_def_Def_DefField(x1);
			VAL r24 = pop_resource();
			VAL r25 = pop_resource();
			push_u64(v23);
			mw_mirth_elab_elabZ_noZ_argsZBang(r25, r24);
			VAL r26 = pop_resource();
			VAL r27 = pop_resource();
			uint64_t v28 = pop_u64();
			mw_mirth_elab_abZ_fieldZBang(v28, r27, r26);
		} break;
		case 8LL: { // DefWord
			push_resource(x2);
			push_resource(x3);
			uint64_t v29 = mtp_mirth_def_Def_DefWord(x1);
			VAL r30 = pop_resource();
			VAL r31 = pop_resource();
			push_u64(v29);
			mw_mirth_elab_elabZ_argsZBang(r31, r30);
			VAL r32 = pop_resource();
			VAL r33 = pop_resource();
			uint64_t v34 = pop_u64();
			mw_mirth_elab_abZ_wordZBang(v34, r33, r32);
		} break;
		case 6LL: { // DefTag
			push_resource(x2);
			push_resource(x3);
			uint64_t v35 = mtp_mirth_def_Def_DefTag(x1);
			VAL r36 = pop_resource();
			VAL r37 = pop_resource();
			push_u64(v35);
			mw_mirth_elab_elabZ_argsZBang(r37, r36);
			VAL r38 = pop_resource();
			VAL r39 = pop_resource();
			uint64_t v40 = pop_u64();
			mw_mirth_elab_abZ_tagZBang(v40, r39, r38);
		} break;
		case 7LL: { // DefPrim
			push_resource(x2);
			push_resource(x3);
			int64_t v41 = mtp_mirth_def_Def_DefPrim(x1);
			VAL r42 = pop_resource();
			VAL r43 = pop_resource();
			mw_mirth_elab_elabZ_primZBang(v41, r43, r42);
		} break;
		default: {
			mw_mirth_def_Def_qnameZ_hard(x2, x1);
			VAL r44 = pop_resource();
			VAL v45 = pop_value();
			mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang(v45, r44, x3);
		} break;
	}
}
static void mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang (VAL x1, VAL x2, VAL x3) {
	push_value(x1);
	push_resource(x2);
	mw_mirth_elab_abZ_typeZAt(x3);
	VAL v0 = pop_value();
	int64_t v1 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v0);
	if (((bool)v1)) {
		VAL v2 = pop_value();
		VAL r3 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r3);
		STR* v4;
		STRLIT(v4, "Not a word: ", 12);
		VAL r5 = pop_resource();
		VAL r6 = pop_resource();
		push_str(v4);
		mw_mirth_name_QName_ZToStr(r6, v2);
		STR* v7 = pop_str();
		STR* v8 = pop_str();
		STR* v9 = str_cat(v8, v7);
		VAL r10 = pop_resource();
		uint64_t v11 = pop_u64();
		VAL v12 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v11, MKSTR(v9), r10));
		push_resource(v12);
		push_resource(r5);
	} else {
		VAL v13 = pop_value();
		decref(v13);
	}
	VAL r14 = pop_resource();
	VAL r15 = pop_resource();
	mw_mirth_elab_elabZ_atomZ_failedZBang(r15, r14);
}
static void mw_mirth_elab_elabZ_primZBang (int64_t x1, VAL x2, VAL x3) {
	switch (x1) {
		case 10LL: { // PRIM_CORE_MATCH
			mw_mirth_elab_elabZ_atomZ_matchZBang(x2, x3);
		} break;
		case 11LL: { // PRIM_CORE_LAMBDA
			mw_mirth_elab_elabZ_atomZ_lambdaZBang(x2, x3);
		} break;
		default: {
			push_i64(x1);
			mw_mirth_elab_elabZ_argsZBang(x2, x3);
			VAL r0 = pop_resource();
			VAL r1 = pop_resource();
			int64_t v2 = pop_i64();
			mw_mirth_elab_abZ_primZBang(v2, r1, r0);
		} break;
	}
}
static void mw_mirth_elab_elabZ_atomZ_assertZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_tokenZAt(x2);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	mw_mirth_token_Token_argsZ_1(v2, r1);
	uint64_t v3 = pop_u64();
	lpush(&lbl_token, MKU64(v3));
	mw_mirth_elab_abZ_ctxZAt(r0);
	VAL v4 = pop_value();
	int64_t v5 = 1LL /* True */;
	int64_t v6 = 0LL /* False */;
	uint64_t v7 = VU64(lpop(&lbl_token));
	VAL v8 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v4, v7, v5, v6));
	VAL r9 = pop_resource();
	VAL r10 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang(r10, v8);
	VAL r11 = pop_resource();
	push_resource(r9);
	mw_mirth_elab_ZPlusTypeElab_rdrop(r11);
	VAL v12 = pop_value();
	VAL r13 = pop_resource();
	mw_mirth_elab_abZ_typeZAt(r13);
	VAL r14 = pop_resource();
	push_value(v12);
	mw_mirth_elab_abZ_tokenZAt(r14);
	VAL r15 = pop_resource();
	uint64_t v16 = pop_u64();
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	VAL r19 = pop_resource();
	mw_mirth_type_StackType_unifyZBang(r19, v16, v18, v17);
	uint64_t r20 = VU64(pop_resource());
	mw_mirth_type_ZPlusGamma_rdrop(r20);
	VAL v21 = pop_value();
	decref(v21);
	push_resource(r15);
}
static void mw_mirth_elab_elabZ_atomZ_matchZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_resource(x2);
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	VAL r2 = pop_resource();
	lpush(&lbl_cod, v1);
	mw_mirth_elab_abZ_tokenZAt(r2);
	uint64_t v3 = pop_u64();
	uint64_t v4 = mw_mirth_token_Token_succ(v3);
	VAL v5 = mw_mirth_token_Token_lcurlyZAsk(v4);
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
			decref(v6);
			VAL r7 = pop_resource();
			mw_mirth_elab_abZ_tokenZAt(r7);
			uint64_t v8 = pop_u64();
			uint64_t v9 = mw_mirth_token_Token_succ(v8);
			uint64_t v10 = mw_mirth_token_Token_succ(v9);
			VAL r11 = pop_resource();
			lpush(&lbl_body, MKU64(v10));
			mw_mirth_elab_abZ_tokenZAt(r11);
			uint64_t v12 = pop_u64();
			uint64_t v13 = mw_mirth_token_Token_succ(v12);
			VAL r14 = pop_resource();
			VAL v15 = (mw_mirth_elab_abZ_tokenZBang(r14, v13));
			push_resource(v15);
		} break;
		case 0LL: { // None
			VAL r16 = pop_resource();
			mw_mirth_elab_abZ_tokenZAt(r16);
			VAL r17 = pop_resource();
			VAL r18 = pop_resource();
			uint64_t v19 = pop_u64();
			mw_mirth_token_Token_argsZPlus(v19, r18);
			VAL v20 = pop_value();
			push_resource(r17);
			VAL v21 = mw_std_list_ListZPlus_1_first(v20);
			lpush(&lbl_body, v21);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r22 = pop_resource();
	VAL r23 = pop_resource();
	uint64_t v24 = VU64(lpop(&lbl_body));
	VAL v25 = lpop(&lbl_cod);
	mw_mirth_elab_elabZ_matchZ_atZBang(v25, v24, r23, r22);
}
static void mw_mirth_elab_elabZ_matchZ_atZBang (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	lpush(&lbl_cod, x1);
	lpush(&lbl_body, MKU64(x2));
	push_resource(x3);
	mw_mirth_elab_abZ_ctxZAt(x4);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	lpush(&lbl_ctx, v0);
	mw_mirth_elab_abZ_typeZAt(r1);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	lpush(&lbl_dom, v2);
	mw_mirth_elab_abZ_tokenZAt(r3);
	uint64_t v4 = pop_u64();
	VAL r5 = pop_resource();
	lpush(&lbl_token, MKU64(v4));
	mw_mirth_elab_abZ_homeZAt(r5);
	VAL v6 = pop_value();
	int64_t v7 = 0LL /* Nil */;
	VAL r8 = pop_resource();
	VAL v9 = lpop(&lbl_cod);
	VAL v10 = lpop(&lbl_dom);
	VAL v11 = lpop(&lbl_ctx);
	uint64_t v12 = VU64(lpop(&lbl_body));
	uint64_t v13 = VU64(lpop(&lbl_token));
	VAL v14 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v6, v13, v12, v11, v10, v9, MKI64(v7)));
	VAL r15 = pop_resource();
	mw_mirth_elab_elabZ_matchZ_casesZBang(r15, v14);
	VAL r16 = pop_resource();
	VAL r17 = pop_resource();
	mw_mirth_elab_elabZ_matchZ_exhaustiveZBang(r17, r16);
	VAL r18 = pop_resource();
	VAL v19 = mw_mirth_match_ZPlusMatch_freezze(r18);
	push_resource(r8);
	VAL v20 = mtw_mirth_arrow_Op_OpMatch(v19);
	VAL r21 = pop_resource();
	VAL r22 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v20, r22, r21);
}
static void mw_mirth_elab_elabZ_matchZ_casesZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[3]);
	push_resource(x1);
	push_resource(x2);
	VAL v1 = mw_mirth_token_Token_lcurlyZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			decref(v2);
			VAL r3 = pop_resource();
			VAL r4 = pop_resource();
			mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang(r4, r3);
		} break;
		case 0LL: { // None
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang(r6, r5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[3]);
	push_resource(x1);
	push_resource(x2);
	VAL v1 = mw_mirth_token_Token_runZ_tokens(v0);
	mw_std_list_List_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		incref(v7);
		push_value(v7);
		VAL v9 = mw_mirth_token_Token_lcurlyZAsk(VU64(v7));
		switch (get_data_tag(v9)) {
			case 1LL: { // Some
				VAL v10 = mtp_std_maybe_Maybe_1_Some(v9);
				decref(v10);
			} break;
			case 0LL: { // None
				STR* v11;
				STRLIT(v11, "Expected a pattern match case of the form { ... -> ... }", 56);
				VAL r12 = pop_resource();
				VAL r13 = pop_resource();
				uint64_t v14 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v14, MKSTR(v11), r13);
				push_resource(r12);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL r15 = pop_resource();
		VAL r16 = pop_resource();
		uint64_t v17 = pop_u64();
		mw_mirth_token_Token_argsZ_1(v17, r16);
		VAL r18 = pop_resource();
		uint64_t v19 = pop_u64();
		mw_mirth_elab_elabZ_matchZ_caseZBang(v19, r18, r15);
		uint64_t v20 = pop_u64();
		mw_std_list_List_1_uncons(v8);
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		push_value(v21);
		push_value(v22);
	}
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	decref(v24);
}
static void mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang (VAL x1, VAL x2) {
	uint64_t v0 = VU64(VTUP(x2)->cells[3]);
	push_resource(x1);
	push_u64(v0);
	push_resource(x2);
	while(1) {
		uint64_t v1 = pop_u64();
		push_u64(v1);
		int64_t v2 = mw_mirth_token_Token_argsZ_endZAsk(v1);
		bool v3 = !((bool)v2);
		if (!v3) break;
		VAL r4 = pop_resource();
		VAL r5 = pop_resource();
		uint64_t v6 = pop_u64();
		mw_mirth_elab_elabZ_matchZ_caseZBang(v6, r5, r4);
	}
	uint64_t v7 = pop_u64();
}
static void mw_mirth_elab_elabZ_matchZ_caseZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	push_u64(x1);
	VAL v0 = mw_mirth_token_Token_runZ_arrowZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "Expected pattern match case ... -> ...", 38);
			VAL r3 = pop_resource();
			VAL r4 = pop_resource();
			uint64_t v5 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v5, MKSTR(v2), r4);
			push_resource(r3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	incref(v6);
	push_value(v7);
	push_value(v6);
	int64_t v8 = mw_mirth_token_Token_ZEqualZEqual(VU64(v7), VU64(v6));
	if (((bool)v8)) {
		STR* v9;
		STRLIT(v9, "expected pattern", 16);
		VAL r10 = pop_resource();
		VAL r11 = pop_resource();
		uint64_t v12 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v12, MKSTR(v9), r11);
		push_resource(r10);
	} else {
	}
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v14);
	incref(v13);
	push_value(v14);
	push_value(v13);
	push_value(v14);
	uint64_t v15 = mw_mirth_token_Token_prev(VU64(v13));
	uint64_t v16 = pop_u64();
	int64_t v17 = mw_mirth_token_Token_ZEqualZEqual(v16, v15);
	if (((bool)v17)) {
	} else {
		STR* v18;
		STRLIT(v18, "multi-part pattern not supported", 32);
		VAL r19 = pop_resource();
		VAL r20 = pop_resource();
		uint64_t v21 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v21, MKSTR(v18), r20);
		push_resource(r19);
	}
	uint64_t v22 = pop_u64();
	uint64_t v23 = pop_u64();
	VAL v24 = mw_mirth_token_Token_patZ_tokens(v23);
	push_value(v24);
	uint64_t v25 = mw_mirth_token_Token_prev(v22);
	push_u64(v25);
	uint64_t v26 = mw_mirth_token_Token_succ(v22);
	VAL r27 = pop_resource();
	VAL v28 = VVAL(VTUP(r27)->cells[1]);
	incref(v28);
	uint64_t v29 = pop_u64();
	VAL v30 = VVAL(VTUP(r27)->cells[4]);
	incref(v30);
	incref(v30);
	int64_t v31 = 0LL /* Nil */;
	VAL v32 = VVAL(VTUP(r27)->cells[5]);
	incref(v32);
	incref(v32);
	int64_t v33 = 0LL /* Nil */;
	push_resource(r27);
	VAL v34 = mtw_mirth_match_Pattern_Pattern(v28, v29, v29, v30, v30, MKI64(v31), v32, v32, MKI64(v33));
	VAL r35 = pop_resource();
	VAL v36 = (mw_mirth_match_Pattern_thaw(v34));
	VAL r37 = pop_resource();
	VAL v38 = pop_value();
	mw_mirth_elab_elabZ_patternZBang(v38, r37, v36);
	VAL r39 = pop_resource();
	VAL v40 = mw_mirth_match_ZPlusPattern_freezze(r39);
	incref(v40);
	VAL v41 = VVAL(VTUP(v40)->cells[5]);
	incref(v41);
	decref(v40);
	incref(v40);
	push_resource(r35);
	push_u64(v26);
	push_value(v41);
	lpush(&lbl_pattern, v40);
	VAL v42 = mw_mirth_match_Pattern_dom(v40);
	VAL r43 = pop_resource();
	VAL v44 = VVAL(VTUP(r43)->cells[6]);
	incref(v44);
	push_resource(r43);
	VAL v45 = mw_mirth_type_TZ_ZTo(v42, v44);
	VAL v46 = pop_value();
	VAL v47 = pop_value();
	VAL r48 = pop_resource();
	VAL v49 = VVAL(VTUP(r48)->cells[1]);
	incref(v49);
	VAL v50 = lpop(&lbl_pattern);
	push_value(v46);
	mw_mirth_type_ArrowType_unpack(v45);
	VAL v51 = pop_value();
	VAL v52 = pop_value();
	VAL v53 = pop_value();
	incref(v47);
	incref(v52);
	int64_t v54 = 0LL /* Nil */;
	push_value(v51);
	VAL v55 = mtw_mirth_arrow_Arrow_Arrow(v49, VU64(v47), VU64(v47), v53, v52, v52, MKI64(v54));
	VAL v56 = pop_value();
	VAL r57 = pop_resource();
	mw_mirth_elab_elabZ_atomsZBang(r57, v55);
	VAL r58 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r58);
	uint64_t v59 = pop_u64();
	push_u64(v59);
	int64_t v60 = mw_mirth_token_Token_commaZAsk(v59);
	if (((bool)v60)) {
		uint64_t v61 = pop_u64();
		uint64_t v62 = mw_mirth_token_Token_succ(v61);
		push_u64(v62);
	} else {
	}
	VAL r63 = pop_resource();
	VAL r64 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v56, r64, r63);
	VAL r65 = pop_resource();
	push_resource(r48);
	VAL v66 = mtw_mirth_match_Case_CASE(v50, r65);
	VAL r67 = pop_resource();
	VAL r68 = pop_resource();
	mw_mirth_match_ZPlusMatch_addZ_case(r68, r67, v66);
}
static void mw_mirth_elab_elabZ_patternZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	VAL v0 = mw_std_list_List_1_reverse(x1);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_elab_elabZ_patternZ_atomZBang(VU64(v6), r9, r8);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_elab_elabZ_patternZ_atomZBang (uint64_t x1, VAL x2, VAL x3) {
	incref(x3);
	VAL v0 = tup_replace(x3, 2, MKU64(x1));
	decref(x3);
	push_resource(x2);
	push_resource(v0);
	push_u64(x1);
	int64_t v1 = mw_mirth_token_Token_patZ_underscoreZAsk(x1);
	if (((bool)v1)) {
		uint64_t v2 = pop_u64();
		VAL r3 = pop_resource();
		VAL r4 = pop_resource();
		mw_mirth_match_ZPlusPattern_underscoreZBang(r4, r3);
	} else {
		uint64_t v5 = pop_u64();
		push_u64(v5);
		VAL v6 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(v5);
		switch (get_data_tag(v6)) {
			case 1LL: { // Some
				VAL v7 = mtp_std_maybe_Maybe_1_Some(v6);
				decref(v7);
				uint64_t v8 = pop_u64();
				STR* v9;
				STRLIT(v9, "constructor", 11);
				VAL r10 = pop_resource();
				incref(r10);
				VAL v11 = VVAL(VTUP(r10)->cells[7]);
				incref(v11);
				decref(r10);
				lpush(&lbl_token, MKU64(v8));
				lpush(&lbl_sort, MKSTR(v9));
				push_resource(r10);
				int64_t v12 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v11);
				bool v13 = !((bool)v12);
				int64_t v14 = 0LL /* False */;
				VAL r15 = pop_resource();
				VAL r16 = pop_resource();
				uint64_t v17 = VU64(lpop(&lbl_token));
				VAL v18 = lpop(&lbl_sort);
				lpush(&lbl_ZPluspat, r15);
				mw_mirth_elab_resolveZ_defZ_beginZBang(v18, v17, ((int64_t)v13), v14, r16);
				VAL r19 = pop_resource();
				VAL v20 = VVAL(VTUP(r19)->cells[3]);
				incref(v20);
				int64_t v21 = 0LL /* Nil */;
				int64_t v22 = 0LL /* Nil */;
				push_resource(r19);
				push_i64(v21);
				push_i64(v22);
				mw_std_list_List_1_uncons(v20);
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v23);
				push_value(v24);
				while(1) {
					VAL v25 = pop_value();
					incref(v25);
					push_value(v25);
					int64_t v26 = mw_std_maybe_Maybe_1_someZAsk(v25);
					if (!((bool)v26)) break;
					VAL v27 = pop_value();
					VAL v28 = mw_std_maybe_Maybe_1_unwrap(v27);
					VAL v29 = pop_value();
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					incref(v28);
					push_value(v28);
					VAL v32 = mw_mirth_def_Def_tagZAsk(v28);
					int64_t v33 = mw_std_maybe_Maybe_1_someZAsk(v32);
					if (((bool)v33)) {
						VAL v34 = pop_value();
						VAL v35 = mtw_std_either_Either_2_Right(v34);
						push_value(v35);
					} else {
						VAL v36 = pop_value();
						VAL v37 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v36);
						VAL v38 = mtw_std_either_Either_2_Left(v37);
						push_value(v38);
					}
					VAL v39 = pop_value();
					switch (get_data_tag(v39)) {
						case 0LL: { // Left
							push_value(v31);
							push_value(v30);
							VAL v40 = mtp_std_either_Either_2_Left(v39);
							VAL v41 = pop_value();
							VAL v42 = pop_value();
							VAL v43 = mtw_std_list_List_1_Cons(v40, v42);
							push_value(v43);
							push_value(v41);
						} break;
						case 1LL: { // Right
							push_value(v31);
							push_value(v30);
							VAL v44 = mtp_std_either_Either_2_Right(v39);
							VAL v45 = pop_value();
							VAL v46 = mtw_std_list_List_1_Cons(v44, v45);
							push_value(v46);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v31);
							push_value(v30);
						}
					}
					mw_std_list_List_1_uncons(v29);
					VAL v47 = pop_value();
					VAL v48 = pop_value();
					push_value(v47);
					push_value(v48);
				}
				VAL v49 = pop_value();
				decref(v49);
				VAL v50 = pop_value();
				decref(v50);
				VAL v51 = pop_value();
				VAL v52 = pop_value();
				VAL v53 = mw_std_list_List_1_reverse(v52);
				push_value(v53);
				VAL v54 = mw_std_list_List_1_reverse(v51);
				VAL r55 = pop_resource();
				VAL v56 = VVAL(VTUP(r55)->cells[4]);
				incref(v56);
				VAL v57 = pop_value();
				VAL v58 = mw_std_list_List_1_cat(v57, v56);
				VAL v59 = VTUP(r55)->cells[4];
				decref(v59);
				VTUP(r55)->cells[4] = v58;
				VAL v60 = VTUP(r55)->cells[3];
				decref(v60);
				VTUP(r55)->cells[3] = v54;
				VAL r61 = pop_resource();
				mw_mirth_elab_ZPlusResolveDef_filterZ_arity(r61, r55);
				VAL r62 = pop_resource();
				VAL r63 = pop_resource();
				mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(r63, r62);
				VAL v64 = (lpop(&lbl_ZPluspat));
				incref(v64);
				VAL v65 = VVAL(VTUP(v64)->cells[7]);
				incref(v65);
				decref(v64);
				lpush(&lbl_ZPluspat, v64);
				int64_t v66 = mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk(v65);
				if (((bool)v66)) {
					VAL v67 = (lpop(&lbl_ZPluspat));
					incref(v67);
					VAL v68 = VVAL(VTUP(v67)->cells[7]);
					incref(v68);
					decref(v67);
					lpush(&lbl_ZPluspat, v67);
					VAL v69 = mw_mirth_type_StackType_topZ_namespaces(v68);
					VAL r70 = pop_resource();
					uint64_t v71 = VU64(VTUP(r70)->cells[2]);
					push_value(v69);
					push_resource(r70);
					VAL v72 = mw_mirth_token_Token_nameZAsk(v71);
					switch (get_data_tag(v72)) {
						case 1LL: { // Some
							VAL v73 = mtp_std_maybe_Maybe_1_Some(v72);
							decref(v73);
							VAL r74 = pop_resource();
							VAL v75 = VVAL(VTUP(r74)->cells[3]);
							incref(v75);
							int64_t v76 = 0LL /* Nil */;
							int64_t v77 = 0LL /* Nil */;
							push_resource(r74);
							push_i64(v76);
							push_i64(v77);
							mw_std_list_List_1_uncons(v75);
							VAL v78 = pop_value();
							VAL v79 = pop_value();
							push_value(v78);
							push_value(v79);
							while(1) {
								VAL v80 = pop_value();
								incref(v80);
								push_value(v80);
								int64_t v81 = mw_std_maybe_Maybe_1_someZAsk(v80);
								if (!((bool)v81)) break;
								VAL v82 = pop_value();
								VAL v83 = mw_std_maybe_Maybe_1_unwrap(v82);
								VAL v84 = pop_value();
								VAL v85 = pop_value();
								VAL v86 = pop_value();
								VAL v87 = pop_value();
								incref(v87);
								incref(v83);
								VAL r88 = pop_resource();
								VAL r89 = pop_resource();
								push_value(v87);
								push_value(v83);
								push_value(v87);
								mw_mirth_def_Def_qnameZ_hard(r89, v83);
								VAL v90 = pop_value();
								VAL v91 = VVAL(VTUP(v90)->cells[1]);
								incref(v91);
								decref(v90);
								VAL v92 = pop_value();
								int64_t v93 = 0LL /* None */;
								push_resource(r88);
								push_value(v91);
								push_i64(v93);
								mw_std_list_List_1_uncons(v92);
								VAL v94 = pop_value();
								VAL v95 = pop_value();
								push_value(v94);
								push_value(v95);
								while(1) {
									VAL v96 = pop_value();
									incref(v96);
									push_value(v96);
									int64_t v97 = mw_std_maybe_Maybe_1_someZAsk(v96);
									if (!((bool)v97)) break;
									VAL v98 = pop_value();
									VAL v99 = mw_std_maybe_Maybe_1_unwrap(v98);
									VAL v100 = pop_value();
									VAL v101 = pop_value();
									incref(v99);
									VAL v102 = pop_value();
									incref(v102);
									int64_t v103 = mw_mirth_name_Namespace_ZEqualZEqual(v102, v99);
									if (((bool)v103)) {
										push_value(v102);
										VAL v104 = mtw_std_maybe_Maybe_1_Some(v99);
										push_value(v104);
									} else {
										decref(v99);
										int64_t v105 = 0LL /* None */;
										push_value(v102);
										push_i64(v105);
									}
									VAL v106 = pop_value();
									switch (get_data_tag(v106)) {
										case 0LL: { // None
											push_value(v101);
											push_value(v100);
										} break;
										default: {
											decref(v100);
											decref(v101);
											int64_t v107 = 0LL /* Nil */;
											push_value(v106);
											push_i64(v107);
										} break;
									}
									VAL v108 = pop_value();
									mw_std_list_List_1_uncons(v108);
									VAL v109 = pop_value();
									VAL v110 = pop_value();
									push_value(v109);
									push_value(v110);
								}
								VAL v111 = pop_value();
								decref(v111);
								VAL v112 = pop_value();
								decref(v112);
								VAL v113 = pop_value();
								VAL v114 = pop_value();
								decref(v114);
								int64_t v115 = mw_std_maybe_Maybe_1_someZAsk(v113);
								if (((bool)v115)) {
									VAL v116 = pop_value();
									VAL v117 = mtw_std_either_Either_2_Right(v116);
									push_value(v117);
								} else {
									VAL v118 = pop_value();
									VAL v119 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR(v118);
									VAL v120 = mtw_std_either_Either_2_Left(v119);
									push_value(v120);
								}
								VAL v121 = pop_value();
								switch (get_data_tag(v121)) {
									case 0LL: { // Left
										push_value(v86);
										push_value(v85);
										VAL v122 = mtp_std_either_Either_2_Left(v121);
										VAL v123 = pop_value();
										VAL v124 = pop_value();
										VAL v125 = mtw_std_list_List_1_Cons(v122, v124);
										push_value(v125);
										push_value(v123);
									} break;
									case 1LL: { // Right
										push_value(v86);
										push_value(v85);
										VAL v126 = mtp_std_either_Either_2_Right(v121);
										VAL v127 = pop_value();
										VAL v128 = mtw_std_list_List_1_Cons(v126, v127);
										push_value(v128);
									} break;
									default: {
										push_value(mkstr("unexpected fallthrough in match\n", 32));
										do_panic();
										push_value(v86);
										push_value(v85);
									}
								}
								mw_std_list_List_1_uncons(v84);
								VAL v129 = pop_value();
								VAL v130 = pop_value();
								push_value(v129);
								push_value(v130);
							}
							VAL v131 = pop_value();
							decref(v131);
							VAL v132 = pop_value();
							decref(v132);
							VAL v133 = pop_value();
							VAL v134 = pop_value();
							VAL v135 = mw_std_list_List_1_reverse(v134);
							push_value(v135);
							VAL v136 = mw_std_list_List_1_reverse(v133);
							VAL r137 = pop_resource();
							VAL v138 = VVAL(VTUP(r137)->cells[4]);
							incref(v138);
							VAL v139 = pop_value();
							VAL v140 = mw_std_list_List_1_cat(v139, v138);
							VAL v141 = VTUP(r137)->cells[4];
							decref(v141);
							VTUP(r137)->cells[4] = v140;
							VAL v142 = VTUP(r137)->cells[3];
							decref(v142);
							VTUP(r137)->cells[3] = v136;
							VAL v143 = pop_value();
							decref(v143);
							push_resource(r137);
						} break;
						case 0LL: { // None
							VAL r144 = pop_resource();
							VAL r145 = pop_resource();
							VAL v146 = pop_value();
							mw_mirth_elab_ZPlusResolveDef_filterZ_roots(v146, r145, r144);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} else {
				}
				VAL r147 = pop_resource();
				VAL r148 = pop_resource();
				mw_mirth_elab_resolveZ_defZ_endZBang(r148, r147);
				VAL v149 = (lpop(&lbl_ZPluspat));
				VAL v150 = pop_value();
				switch (get_data_tag(v150)) {
					case 1LL: { // Some
						push_resource(v149);
						VAL v151 = mtp_std_maybe_Maybe_1_Some(v150);
						VAL v152 = mw_mirth_def_Def_tagZAsk(v151);
						push_value(v152);
					} break;
					case 0LL: { // None
						int64_t v153 = 0LL /* None */;
						push_resource(v149);
						push_i64(v153);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_resource(v149);
					}
				}
				VAL v154 = pop_value();
				switch (get_data_tag(v154)) {
					case 1LL: { // Some
						VAL v155 = mtp_std_maybe_Maybe_1_Some(v154);
						VAL r156 = pop_resource();
						VAL r157 = pop_resource();
						mw_mirth_match_ZPlusPattern_tagZBang(r157, r156, VU64(v155));
					} break;
					case 0LL: { // None
						int64_t v158 = 0LL /* STACK_TYPE_ERROR */;
						VAL r159 = pop_resource();
						incref(r159);
						VAL v160 = tup_replace(r159, 7, MKI64(v158));
						decref(r159);
						push_resource(v160);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
			} break;
			case 0LL: { // None
				STR* v161;
				STRLIT(v161, "Expected constructor name.", 26);
				VAL r162 = pop_resource();
				VAL r163 = pop_resource();
				uint64_t v164 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v164, MKSTR(v161), r163);
				push_resource(r162);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
}
static void mw_mirth_elab_elabZ_expandZ_tensorZBang (VAL x1, VAL x2, uint64_t x3) {
	push_resource(x1);
	lpush(&lbl_tok, MKU64(x3));
	VAL v0 = mw_mirth_type_StackType_forceZ_consZAskZBang(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2;
			VAL v3;
			value_uncons(v1, &v2, &v3);
			VAL v4;
			VAL v5;
			value_uncons(v2, &v4, &v5);
			decref(v4);
			uint64_t v6 = VU64(lpop(&lbl_tok));
			push_value(v5);
			push_value(v3);
			push_u64(v6);
		} break;
		case 0LL: { // None
			int64_t v7 = 0LL /* STACK_TYPE_ERROR */;
			int64_t v8 = 0LL /* TYPE_ERROR */;
			uint64_t v9 = VU64(lpop(&lbl_tok));
			STR* v10;
			STRLIT(v10, "expected tuple type", 19);
			VAL r11 = pop_resource();
			push_i64(v7);
			push_i64(v8);
			push_u64(v9);
			VAL v12 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v9, MKSTR(v10), r11));
			push_resource(v12);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_lambdaZ_paramZAsk (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_token_Token_patternZ_varZAsk(x2);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		VAL r2 = pop_resource();
		push_u64(v1);
		VAL v3 = (mw_mirth_token_Token_argsZ_0(v1, r2));
		uint64_t v4 = pop_u64();
		push_resource(v3);
		uint64_t v5 = mw_mirth_token_Token_next(v4);
		push_u64(v5);
		uint64_t v6 = mw_mirth_type_MetaVar_newZBang();
		VAL v7 = mtw_mirth_type_Type_TMeta(v6);
		push_value(v7);
		VAL v8 = mw_mirth_token_Token_nameZAsk(v4);
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		uint64_t v11 = mw_mirth_var_Var_newZBang(v10, VU64(v9));
		VAL v12 = mtw_std_maybe_Maybe_1_Some(MKU64(v11));
		push_value(v12);
	} else {
		uint64_t v13 = pop_u64();
		push_u64(v13);
		VAL v14 = mw_mirth_token_Token_lsquareZAsk(v13);
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				VAL v15 = mtp_std_maybe_Maybe_1_Some(v14);
				decref(v15);
				uint64_t v16 = pop_u64();
				push_u64(v16);
				uint64_t v17 = mw_mirth_token_Token_succ(v16);
				int64_t v18 = mw_mirth_token_Token_patternZ_varZAsk(v17);
				push_i64(v18);
			} break;
			case 0LL: { // None
				int64_t v19 = 0LL /* False */;
				push_i64(v19);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		bool v20 = pop_bool();
		if (v20) {
			uint64_t v21 = pop_u64();
			push_u64(v21);
			uint64_t v22 = mw_mirth_token_Token_succ(v21);
			uint64_t v23 = mw_mirth_token_Token_succ(v22);
			VAL v24 = mw_mirth_token_Token_rsquareZAsk(v23);
			int64_t v25 = mw_std_maybe_Maybe_1_ZToBool(v24);
			push_i64(v25);
		} else {
			int64_t v26 = 0LL /* False */;
			push_i64(v26);
		}
		bool v27 = pop_bool();
		if (v27) {
			uint64_t v28 = pop_u64();
			push_u64(v28);
			uint64_t v29 = mw_mirth_token_Token_succ(v28);
			VAL r30 = pop_resource();
			VAL v31 = (mw_mirth_token_Token_argsZ_0(v29, r30));
			uint64_t v32 = pop_u64();
			push_resource(v31);
			uint64_t v33 = mw_mirth_token_Token_next(v32);
			push_u64(v33);
			uint64_t v34 = mw_mirth_type_MetaVar_newZBang();
			VAL v35 = mtw_mirth_type_StackType_STMeta(v34);
			push_value(v35);
			uint64_t v36 = mw_mirth_type_MetaVar_newZBang();
			VAL v37 = mtw_mirth_type_StackType_STMeta(v36);
			VAL v38 = pop_value();
			VAL v39 = mw_mirth_type_TZ_ZTo(v38, v37);
			VAL v40 = mtw_mirth_type_Type_TMorphism(v39);
			push_value(v40);
			uint64_t v41 = mw_mirth_token_Token_succ(v32);
			VAL v42 = mw_mirth_token_Token_nameZAsk(v41);
			VAL v43 = mw_std_maybe_Maybe_1_unwrap(v42);
			VAL v44 = pop_value();
			uint64_t v45 = mw_mirth_var_Var_newZ_autoZ_runZBang(v44, VU64(v43));
			VAL v46 = mtw_std_maybe_Maybe_1_Some(MKU64(v45));
			push_value(v46);
		} else {
			int64_t v47 = 0LL /* None */;
			push_i64(v47);
		}
	}
}
static void mw_mirth_elab_elabZ_atomZ_lambdaZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_elab_abZ_tokenZAt(x2);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	uint64_t v2 = pop_u64();
	mw_mirth_token_Token_argsZ_1(v2, r1);
	int64_t v3 = 0LL /* Nil */;
	push_resource(r0);
	VAL v4 = mw_std_list_List_1_reverse(MKI64(v3));
	VAL r5 = pop_resource();
	uint64_t v6 = pop_u64();
	VAL r7 = pop_resource();
	mw_mirth_elab_elabZ_lambdaZ_paramZAsk(r7, v6);
	push_resource(r5);
	push_resource(v4);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
		if (!((bool)v9)) break;
		VAL v10 = pop_value();
		VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
		VAL r12 = pop_resource();
		VAL v13 = mtw_std_list_List_1_Cons(v11, r12);
		VAL r14 = pop_resource();
		uint64_t v15 = pop_u64();
		VAL r16 = pop_resource();
		mw_mirth_elab_elabZ_lambdaZ_paramZAsk(r16, v15);
		push_resource(r14);
		push_resource(v13);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL r18 = pop_resource();
	VAL v19 = mw_std_list_List_1_reverse(r18);
	VAL r20 = pop_resource();
	uint64_t v21 = pop_u64();
	VAL r22 = pop_resource();
	mw_mirth_elab_expectZ_tokenZ_arrow(r22, v21);
	uint64_t v23 = pop_u64();
	push_resource(r20);
	uint64_t v24 = mw_mirth_token_Token_succ(v23);
	incref(v19);
	VAL r25 = pop_resource();
	push_u64(v24);
	mw_mirth_elab_abZ_ctxZAt(r25);
	VAL r26 = pop_resource();
	mw_mirth_elab_abZ_typeZAt(r26);
	VAL v27 = mw_std_list_List_1_reverse(v19);
	mw_std_list_List_1_uncons(v27);
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	push_value(v28);
	push_value(v29);
	while(1) {
		VAL v30 = pop_value();
		incref(v30);
		push_value(v30);
		int64_t v31 = mw_std_maybe_Maybe_1_someZAsk(v30);
		if (!((bool)v31)) break;
		VAL v32 = pop_value();
		VAL v33 = mw_std_maybe_Maybe_1_unwrap(v32);
		VAL v34 = pop_value();
		VAL v35 = pop_value();
		incref(v33);
		VAL v36 = pop_value();
		VAL v37 = mw_mirth_var_Ctx_new(v36, VU64(v33));
		VAL r38 = pop_resource();
		push_value(v37);
		push_value(v33);
		push_value(v35);
		mw_mirth_elab_abZ_tokenZAt(r38);
		VAL r39 = pop_resource();
		uint64_t v40 = pop_u64();
		VAL v41 = pop_value();
		VAL r42 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang(r42, v41, v40);
		uint64_t v43 = pop_u64();
		VAL v44 = pop_value();
		VAL v45 = pop_value();
		VAL v46 = pop_value();
		push_resource(r39);
		push_value(v45);
		push_value(v44);
		VAL v47 = mw_mirth_var_Var_type(VU64(v46));
		VAL r48 = pop_resource();
		VAL v49 = pop_value();
		VAL r50 = pop_resource();
		mw_mirth_elab_elabZ_typeZ_unifyZBang(r50, v49, v47, v43);
		VAL v51 = pop_value();
		decref(v51);
		VAL v52 = pop_value();
		decref(v52);
		push_resource(r48);
		mw_std_list_List_1_uncons(v34);
		VAL v53 = pop_value();
		VAL v54 = pop_value();
		push_value(v53);
		push_value(v54);
	}
	VAL v55 = pop_value();
	decref(v55);
	VAL v56 = pop_value();
	decref(v56);
	VAL v57 = pop_value();
	VAL v58 = pop_value();
	VAL v59 = pop_value();
	VAL r60 = pop_resource();
	push_value(v58);
	push_value(v57);
	push_value(v59);
	mw_mirth_elab_abZ_homeZAt(r60);
	VAL r61 = pop_resource();
	VAL v62 = pop_value();
	uint64_t v63 = pop_u64();
	VAL v64 = pop_value();
	incref(v64);
	VAL v65 = pop_value();
	int64_t v66 = 0LL /* Nil */;
	VAL v67 = mtw_mirth_arrow_Arrow_Arrow(v62, v63, v63, v65, v64, v64, MKI64(v66));
	VAL r68 = pop_resource();
	mw_mirth_elab_elabZ_atomsZBang(r68, v67);
	VAL r69 = pop_resource();
	lpush(&lbl_params, v19);
	lpush(&lbl_body, r69);
	mw_mirth_elab_abZ_ctxZAt(r61);
	VAL v70 = pop_value();
	VAL r71 = pop_resource();
	lpush(&lbl_outerZ_ctx, v70);
	mw_mirth_elab_abZ_typeZAt(r71);
	VAL v72 = pop_value();
	VAL r73 = pop_resource();
	lpush(&lbl_dom, v72);
	mw_mirth_elab_abZ_tokenZAt(r73);
	uint64_t v74 = pop_u64();
	VAL v75 = lpop(&lbl_body);
	VAL v76 = lpop(&lbl_params);
	VAL v77 = lpop(&lbl_dom);
	VAL v78 = lpop(&lbl_outerZ_ctx);
	VAL v79 = mtw_mirth_arrow_Lambda_Lambda(v74, v78, v77, v76, v75);
	VAL v80 = mtw_mirth_arrow_Op_OpLambda(v79);
	VAL r81 = pop_resource();
	VAL r82 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v80, r82, r81);
}
static void mw_mirth_elab_elabZ_matchZ_exhaustiveZBang (VAL x1, VAL x2) {
	push_resource(x1);
	VAL v0 = mw_mirth_match_ZPlusMatch_freezze(x2);
	incref(v0);
	push_value(v0);
	int64_t v1 = mw_mirth_match_Match_isZ_exhaustiveZAsk(v0);
	if (((bool)v1)) {
	} else {
		VAL v2 = pop_value();
		incref(v2);
		uint64_t v3 = VU64(VTUP(v2)->cells[2]);
		decref(v2);
		STR* v4;
		STRLIT(v4, "Pattern match not exhaustive.", 29);
		VAL r5 = pop_resource();
		push_value(v2);
		VAL v6 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(v3, MKSTR(v4), r5));
		push_resource(v6);
	}
	VAL v7 = pop_value();
	VAL v8 = (mw_mirth_match_Match_thaw(v7));
	push_resource(v8);
}
static void mw_mirth_elab_elabZ_moduleZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	push_u64(x1);
	uint64_t v0 = mw_mirth_module_Module_start(x1);
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	mw_mirth_elab_elabZ_moduleZ_headerZBang(r2, r1, v0);
	while(1) {
		uint64_t v3 = pop_u64();
		push_u64(v3);
		int64_t v4 = mw_mirth_token_Token_moduleZ_endZAsk(v3);
		bool v5 = !((bool)v4);
		if (!v5) break;
		VAL r6 = pop_resource();
		VAL r7 = pop_resource();
		uint64_t v8 = pop_u64();
		mw_mirth_elab_elabZ_moduleZ_declZBang(v8, r7, r6);
	}
	uint64_t v9 = pop_u64();
}
static void mw_mirth_elab_elabZ_moduleZ_packageZ_name (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	VAL v0 = mw_mirth_token_Token_dnameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "Expected module name. (1)", 25);
			VAL r3 = pop_resource();
			uint64_t v4 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v4, MKSTR(v2), r3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	incref(v6);
	VAL r7 = pop_resource();
	push_value(v6);
	push_value(v5);
	VAL v8 = (mw_mirth_token_Token_argsZ_0(VU64(v6), r7));
	VAL v9 = pop_value();
	incref(v9);
	push_resource(v8);
	push_value(v9);
	VAL v10 = mw_mirth_name_DName_rootZAsk(v9);
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v10);
			push_value(v11);
		} break;
		case 0LL: { // None
			VAL v12 = pop_value();
			decref(v12);
			STR* v13;
			STRLIT(v13, "Expected module name. (2)", 25);
			VAL r14 = pop_resource();
			uint64_t v15 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v15, MKSTR(v13), r14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v16 = pop_u64();
	VAL v17 = pop_value();
	push_u64(v16);
	VAL v18 = mw_mirth_name_DName_parts(v17);
	VAL v19 = mw_std_list_List_1_ZDivL1(v18);
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(v19);
			push_value(v20);
		} break;
		case 0LL: { // None
			uint64_t v21 = pop_u64();
			STR* v22;
			STRLIT(v22, "Expected module name. (3)", 25);
			VAL r23 = pop_resource();
			uint64_t v24 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v24, MKSTR(v22), r23);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v25 = pop_u64();
	uint64_t v26 = pop_u64();
	VAL r27 = pop_resource();
	mw_mirth_package_Package_findZ_orZ_newZBang(r27, v26);
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	decref(v29);
	push_value(v28);
	push_u64(v25);
}
static void mw_mirth_elab_elabZ_moduleZ_qname (VAL x1, uint64_t x2) {
	mw_mirth_elab_elabZ_moduleZ_packageZ_name(x2, x1);
	uint64_t v0 = pop_u64();
	uint64_t v1 = pop_u64();
	VAL v2 = mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE(v1);
	VAL v3 = mw_mirth_name_QNAME0(v2, v0);
	push_value(v3);
}
static void mw_mirth_elab_elabZ_moduleZ_headerZBang (VAL x1, VAL x2, uint64_t x3) {
	push_resource(x1);
	push_resource(x2);
	push_u64(x3);
	int64_t v0 = mw_mirth_token_Token_moduleZ_headerZAsk(x3);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		uint64_t v2 = mw_mirth_token_Token_next(v1);
		VAL r3 = pop_resource();
		push_u64(v2);
		mw_mirth_token_Token_argsZ_1(v1, r3);
		uint64_t v4 = pop_u64();
		VAL r5 = pop_resource();
		push_u64(v4);
		mw_mirth_elab_elabZ_moduleZ_packageZ_name(v4, r5);
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v7);
		push_value(v6);
		uint64_t v9 = mw_mirth_token_Token_module(VU64(v8));
		VAL v10 = pop_value();
		void* v11 = mfld_mirth_module_Module_ZTildename(v9);
		mut_set(v10, MKPTR(v11));
		VAL v12 = pop_value();
		void* v13 = mfld_mirth_module_Module_ZTildepackage(v9);
		mut_set(v12, MKPTR(v13));
		push_u64(v9);
		VAL v14 = mw_mirth_module_Module_qname(v9);
		VAL r15 = pop_resource();
		mw_mirth_name_QName_definedZ_softZAsk(r15, v14);
		bool v16 = pop_bool();
		if (v16) {
			uint64_t v17 = pop_u64();
			STR* v18;
			STRLIT(v18, "Module name already taken.", 26);
			VAL r19 = pop_resource();
			uint64_t v20 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v20, MKSTR(v18), r19);
		} else {
		}
		uint64_t v21 = pop_u64();
		push_u64(v21);
		VAL v22 = mtw_mirth_def_Def_DefModule(v21);
		VAL r23 = pop_resource();
		VAL v24 = (mw_mirth_def_Def_register(r23, v22));
		VAL r25 = pop_resource();
		uint64_t v26 = pop_u64();
		uint64_t v27 = pop_u64();
		mw_mirth_elab_checkZ_moduleZ_path(v27, v26, r25, v24);
	} else {
		uint64_t v28 = pop_u64();
		STR* v29;
		STRLIT(v29, "Expected module header.", 23);
		VAL r30 = pop_resource();
		push_u64(v28);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v28, MKSTR(v29), r30);
	}
}
static void mw_mirth_elab_checkZ_moduleZ_path (uint64_t x1, uint64_t x2, VAL x3, VAL x4) {
	push_u64(x1);
	push_resource(x3);
	push_resource(x4);
	push_u64(x2);
	VAL v0 = mw_mirth_module_Module_path(x2);
	mw_std_path_Path_splitZ_last(v0);
	VAL v1 = pop_value();
	switch (get_data_tag(v1)) {
		case 0LL: { // None
			VAL v2 = pop_value();
			uint64_t v3 = pop_u64();
			push_value(v2);
			VAL v4 = mw_mirth_module_Module_qname(v3);
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			mw_mirth_name_QName_toZ_moduleZ_path(v4, r6, r5);
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			incref(v8);
			incref(v7);
			bool v9 = (str_cmp(VSTR(v8), VSTR(v7)) == 0);
			if (v9) {
				push_value(v8);
				push_value(v7);
			} else {
				STR* v10;
				STRLIT(v10, "expected module name to match path\n", 35);
				STR* v11 = str_cat(v10, VSTR(v7));
				STR* v12;
				STRLIT(v12, "\n", 1);
				STR* v13 = str_cat(v11, v12);
				STR* v14 = str_cat(v13, VSTR(v8));
				VAL r15 = pop_resource();
				uint64_t v16 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v16, MKSTR(v14), r15);
			}
			VAL v17 = pop_value();
			decref(v17);
			VAL v18 = pop_value();
			decref(v18);
			VAL v19 = pop_value();
			decref(v19);
		} break;
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(v1);
			mw_std_str_ZPlusStr_numZ_bytesZAsk(v20);
			int64_t v21 = 0LL /* None */;
			push_i64(v21);
			while(1) {
				VAL v22 = pop_value();
				incref(v22);
				push_value(v22);
				int64_t v23 = mw_std_maybe_Maybe_1_noneZAsk(v22);
				if (((bool)v23)) {
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					incref(v25);
					int64_t v26 = 0LL;
					bool v27 = (VI64(v25) > v26);
					push_value(v25);
					push_value(v24);
					push_bool(v27);
				} else {
					int64_t v28 = 0LL /* False */;
					push_i64(v28);
				}
				bool v29 = pop_bool();
				if (!v29) break;
				VAL v30 = pop_value();
				decref(v30);
				int64_t v31 = 1LL;
				int64_t v32 = pop_i64();
				int64_t v33 = i64_sub(v32, v31);
				VAL r34 = pop_resource();
				mw_std_str_ZPlusStr_byteZAt(v33, r34);
				VAL r35 = pop_resource();
				int64_t v36 = 46LL /* BDOT */;
				int64_t v37 = pop_i64();
				bool v38 = (v37 == v36);
				if (v38) {
					push_resource(r35);
					push_i64(v33);
					VAL v39 = mtw_std_maybe_Maybe_1_Some(MKI64(v33));
					push_value(v39);
				} else {
					int64_t v40 = 0LL /* None */;
					push_resource(r35);
					push_i64(v33);
					push_i64(v40);
				}
			}
			VAL v41 = pop_value();
			VAL v42 = pop_value();
			decref(v42);
			VAL r43 = pop_resource();
			switch (get_data_tag(v41)) {
				case 1LL: { // Some
					push_value(r43);
					VAL v44 = mtp_std_maybe_Maybe_1_Some(v41);
					int64_t v45 = (0LL /* +Unsafe */);
					VAL v46 = pop_value();
					incref(v44);
					incref(v46);
					int64_t v47 = 1LL;
					int64_t v48 = i64_add(VI64(v44), v47);
					push_value(v44);
					push_value(v46);
					mw_std_prim_Str_dropZ_slice(v48, v46, MKI64(v45));
					VAL v49 = pop_value();
					VAL v50 = pop_value();
					int64_t v51 = pop_i64();
					int64_t v52 = mw_std_prim_Int_ZToNat(v51);
					VAL r53 = pop_resource();
					mw_std_prim_Str_takeZ_slice(v52, v50, r53);
					VAL r54 = pop_resource();
					VAL v55 = mtw_std_maybe_Maybe_1_Some(v49);
					push_value(v55);
				} break;
				case 0LL: { // None
					int64_t v56 = 0LL /* None */;
					push_value(r43);
					push_i64(v56);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_value(r43);
				}
			}
			STR* v57;
			STRLIT(v57, "mth", 3);
			VAL v58 = mtw_std_maybe_Maybe_1_Some(MKSTR(v57));
			switch (get_data_tag(v58)) {
				case 0LL: { // None
					VAL v59 = pop_value();
					int64_t v60 = mw_std_maybe_Maybe_1_noneZAsk(v59);
					push_i64(v60);
				} break;
				case 1LL: { // Some
					VAL v61 = mtp_std_maybe_Maybe_1_Some(v58);
					VAL v62 = pop_value();
					switch (get_data_tag(v62)) {
						case 1LL: { // Some
							push_value(v61);
							VAL v63 = mtp_std_maybe_Maybe_1_Some(v62);
							VAL v64 = pop_value();
							bool v65 = (str_cmp(VSTR(v63), VSTR(v64)) == 0);
							push_bool(v65);
						} break;
						case 0LL: { // None
							decref(v61);
							int64_t v66 = 0LL /* False */;
							push_i64(v66);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v61);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			bool v67 = pop_bool();
			if (v67) {
			} else {
				VAL v68 = pop_value();
				VAL v69 = pop_value();
				VAL v70 = pop_value();
				VAL v71 = pop_value();
				incref(v71);
				STR* v72;
				STRLIT(v72, "expected .mth extension for mirth file", 38);
				VAL r73 = pop_resource();
				push_value(v71);
				push_value(v70);
				push_value(v69);
				push_value(v68);
				VAL v74 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(VU64(v71), MKSTR(v72), r73));
				push_resource(v74);
			}
			VAL v75 = pop_value();
			VAL v76 = pop_value();
			VAL v77 = pop_value();
			incref(v77);
			push_value(v77);
			push_value(v76);
			push_value(v75);
			uint64_t v78 = mw_mirth_module_Module_name(VU64(v77));
			VAL v79 = mw_mirth_name_Name_ZToStr(v78);
			STR* v80 = pop_str();
			bool v81 = (str_cmp(v80, VSTR(v79)) == 0);
			if (v81) {
			} else {
				VAL v82 = pop_value();
				VAL v83 = pop_value();
				VAL v84 = pop_value();
				incref(v84);
				STR* v85;
				STRLIT(v85, "expected module name to match file name", 39);
				VAL r86 = pop_resource();
				push_value(v84);
				push_value(v83);
				push_value(v82);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(VU64(v84), MKSTR(v85), r86);
			}
			VAL v87 = pop_value();
			VAL v88 = pop_value();
			incref(v88);
			push_value(v88);
			push_value(v87);
			uint64_t v89 = mw_mirth_module_Module_package(VU64(v88));
			VAL v90 = pop_value();
			mw_mirth_package_Package_pathZBang(v90, v89);
			VAL v91 = pop_value();
			decref(v91);
			VAL v92 = pop_value();
			decref(v92);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_moduleZ_declZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	push_u64(x1);
	VAL v0 = mw_mirth_token_Token_nameZAsk(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "unknown declaration", 19);
			VAL r3 = pop_resource();
			uint64_t v4 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v4, MKSTR(v2), r3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v5 = pop_u64();
	VAL v6 = mw_mirth_name_Name_defs(v5);
	int64_t v7 = 0LL /* None */;
	push_i64(v7);
	mw_std_list_List_1_uncons(v6);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		int64_t v11 = mw_std_maybe_Maybe_1_someZAsk(v10);
		if (!((bool)v11)) break;
		VAL v12 = pop_value();
		VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		VAL v16 = mw_mirth_def_Def_primZAsk(v13);
		switch (get_data_tag(v16)) {
			case 0LL: { // None
				push_value(v15);
				push_value(v14);
			} break;
			default: {
				decref(v14);
				decref(v15);
				int64_t v17 = 0LL /* Nil */;
				push_value(v16);
				push_i64(v17);
			} break;
		}
		VAL v18 = pop_value();
		mw_std_list_List_1_uncons(v18);
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	switch (get_data_tag(v23)) {
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v23);
			push_value(v24);
		} break;
		case 0LL: { // None
			STR* v25;
			STRLIT(v25, "unknown declaration", 19);
			VAL r26 = pop_resource();
			uint64_t v27 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v27, MKSTR(v25), r26);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v28 = pop_i64();
	switch (v28) {
		case 104LL: { // PRIM_SYNTAX_IMPORT
			VAL r29 = pop_resource();
			VAL r30 = pop_resource();
			uint64_t v31 = pop_u64();
			mw_mirth_elab_elabZ_moduleZ_importZBang(v31, r30, r29);
		} break;
		case 105LL: { // PRIM_SYNTAX_ALIAS
			uint64_t v32 = pop_u64();
			VAL r33 = pop_resource();
			mw_mirth_elab_elabZ_aliasZBang(r33, v32);
		} break;
		case 106LL: { // PRIM_SYNTAX_INLINE
			VAL r34 = pop_resource();
			VAL r35 = pop_resource();
			uint64_t v36 = pop_u64();
			mw_mirth_elab_elabZ_inlineZBang(v36, r35, r34);
		} break;
		case 107LL: { // PRIM_SYNTAX_DEF
			uint64_t v37 = pop_u64();
			VAL r38 = pop_resource();
			mw_mirth_elab_elabZ_defZBang(r38, v37);
		} break;
		case 108LL: { // PRIM_SYNTAX_DEF_MISSING
			uint64_t v39 = pop_u64();
			VAL r40 = pop_resource();
			mw_mirth_elab_elabZ_defZ_missingZBang(r40, v39);
		} break;
		case 109LL: { // PRIM_SYNTAX_DEF_TYPE
			uint64_t v41 = pop_u64();
			VAL r42 = pop_resource();
			mw_mirth_elab_elabZ_defZ_typeZBang(r42, v41);
		} break;
		case 113LL: { // PRIM_SYNTAX_DEF_EXTERNAL
			uint64_t v43 = pop_u64();
			STR* v44;
			STRLIT(v44, "def-external", 12);
			STR* v45;
			STRLIT(v45, "external", 8);
			VAL r46 = pop_resource();
			push_u64(v43);
			VAL v47 = (mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang(v43, MKSTR(v44), MKSTR(v45), r46));
			uint64_t v48 = pop_u64();
			mw_mirth_elab_elabZ_externalZBang(v47, v48);
		} break;
		case 112LL: { // PRIM_SYNTAX_EXTERNAL
			uint64_t v49 = pop_u64();
			VAL r50 = pop_resource();
			mw_mirth_elab_elabZ_externalZBang(r50, v49);
		} break;
		case 110LL: { // PRIM_SYNTAX_BUFFER
			uint64_t v51 = pop_u64();
			VAL r52 = pop_resource();
			mw_mirth_elab_elabZ_bufferZBang(r52, v51);
		} break;
		case 111LL: { // PRIM_SYNTAX_VARIABLE
			uint64_t v53 = pop_u64();
			VAL r54 = pop_resource();
			mw_mirth_elab_elabZ_variableZBang(r54, v53);
		} break;
		case 115LL: { // PRIM_SYNTAX_TABLE
			uint64_t v55 = pop_u64();
			VAL r56 = pop_resource();
			mw_mirth_elab_elabZ_tableZBang(r56, v55);
		} break;
		case 116LL: { // PRIM_SYNTAX_FIELD
			uint64_t v57 = pop_u64();
			VAL r58 = pop_resource();
			mw_mirth_elab_elabZ_fieldZBang(r58, v57);
		} break;
		case 117LL: { // PRIM_SYNTAX_DATA
			uint64_t v59 = pop_u64();
			VAL r60 = pop_resource();
			mw_mirth_elab_elabZ_dataZBang(r60, v59);
		} break;
		case 118LL: { // PRIM_SYNTAX_STRUCT
			uint64_t v61 = pop_u64();
			VAL r62 = pop_resource();
			mw_mirth_elab_elabZ_structZBang(r62, v61);
		} break;
		case 114LL: { // PRIM_SYNTAX_EMBED_STR
			VAL r63 = pop_resource();
			VAL r64 = pop_resource();
			uint64_t v65 = pop_u64();
			mw_mirth_elab_elabZ_embedZ_strZBang(v65, r64, r63);
		} break;
		default: {
			STR* v66;
			STRLIT(v66, "unknown declaration", 19);
			VAL r67 = pop_resource();
			uint64_t v68 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v68, MKSTR(v66), r67);
		} break;
	}
}
static void mw_mirth_elab_loadZ_module (uint64_t x1, VAL x2, VAL x3, VAL x4) {
	incref(x2);
	push_u64(x1);
	push_resource(x3);
	push_value(x2);
	mw_mirth_name_QName_defZ_softZAsk(x4, x2);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_def_Def_moduleZAsk(v1);
			switch (get_data_tag(v2)) {
				case 1LL: { // Some
					VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
					push_value(v3);
				} break;
				case 0LL: { // None
					VAL v4 = pop_value();
					decref(v4);
					STR* v5;
					STRLIT(v5, "module name already taken", 25);
					VAL r6 = pop_resource();
					uint64_t v7 = pop_u64();
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v7, MKSTR(v5), r6);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			decref(v9);
			push_value(v8);
		} break;
		case 0LL: { // None
			VAL r10 = pop_resource();
			VAL r11 = pop_resource();
			VAL v12 = pop_value();
			mw_mirth_name_QName_toZ_moduleZ_path(v12, r11, r10);
			VAL r13 = pop_resource();
			VAL r14 = pop_resource();
			VAL v15 = pop_value();
			mw_mirth_lexer_runZ_lexerZBang(v15, r14, r13);
			VAL r16 = pop_resource();
			VAL r17 = pop_resource();
			uint64_t v18 = pop_u64();
			mw_mirth_elab_elabZ_moduleZBang(v18, r17, r16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_moduleZ_importZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	uint64_t v0 = mw_mirth_token_Token_next(x1);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_1(x1, r1);
	uint64_t v2 = pop_u64();
	VAL r3 = pop_resource();
	push_u64(v2);
	mw_mirth_elab_elabZ_moduleZ_qname(r3, v2);
	VAL r4 = pop_resource();
	VAL r5 = pop_resource();
	VAL v6 = pop_value();
	uint64_t v7 = pop_u64();
	mw_mirth_elab_loadZ_module(v7, v6, r5, r4);
	uint64_t v8 = pop_u64();
	uint64_t v9 = pop_u64();
	uint64_t v10 = mw_mirth_token_Token_module(v9);
	mw_mirth_module_Module_addZ_importZBang(v10, v8);
}
static void mw_mirth_elab_parseZ_data (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_token_Token_numZ_args(x2);
	int64_t v1 = 0LL;
	bool v2 = (v0 > v1);
	if (v2) {
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_succ(v3);
		push_u64(v4);
		VAL v5 = mw_mirth_token_Token_lparenZAsk(v4);
		switch (get_data_tag(v5)) {
			case 1LL: { // Some
				VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
				decref(v6);
			} break;
			case 0LL: { // None
				STR* v7;
				STRLIT(v7, "expected left parenthesis '('", 29);
				VAL r8 = pop_resource();
				uint64_t v9 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v9, MKSTR(v7), r8);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v10 = pop_u64();
		uint64_t v11 = mw_mirth_token_Token_succ(v10);
		VAL r12 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_header(r12, v11);
		uint64_t v13 = pop_u64();
		uint64_t v14 = pop_u64();
		lpush(&lbl_header, MKU64(v13));
		push_u64(v14);
		int64_t v15 = mw_mirth_token_Token_commaZAsk(v14);
		if (((bool)v15)) {
			uint64_t v16 = pop_u64();
			uint64_t v17 = mw_mirth_token_Token_succ(v16);
			push_u64(v17);
		} else {
		}
		uint64_t v18 = pop_u64();
		VAL r19 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_tags(r19, v18);
		VAL v20 = pop_value();
		uint64_t v21 = pop_u64();
		lpush(&lbl_tags, v20);
		push_u64(v21);
		VAL v22 = mw_mirth_token_Token_rparenZAsk(v21);
		switch (get_data_tag(v22)) {
			case 1LL: { // Some
				VAL v23 = mtp_std_maybe_Maybe_1_Some(v22);
				decref(v23);
			} break;
			case 0LL: { // None
				STR* v24;
				STRLIT(v24, "expected right parenthesis ')'", 30);
				VAL r25 = pop_resource();
				uint64_t v26 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v26, MKSTR(v24), r25);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v27 = pop_u64();
		uint64_t v28 = mw_mirth_token_Token_succ(v27);
		push_u64(v28);
	} else {
		uint64_t v29 = pop_u64();
		uint64_t v30 = mw_mirth_token_Token_succ(v29);
		VAL r31 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_header(r31, v30);
		uint64_t v32 = pop_u64();
		uint64_t v33 = pop_u64();
		lpush(&lbl_header, MKU64(v32));
		push_u64(v33);
		VAL v34 = mw_mirth_token_Token_lcurlyZAsk(v33);
		switch (get_data_tag(v34)) {
			case 1LL: { // Some
				VAL v35 = mtp_std_maybe_Maybe_1_Some(v34);
				decref(v35);
			} break;
			case 0LL: { // None
				STR* v36;
				STRLIT(v36, "expected left curly brace '{'", 29);
				VAL r37 = pop_resource();
				uint64_t v38 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v38, MKSTR(v36), r37);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v39 = pop_u64();
		uint64_t v40 = mw_mirth_token_Token_succ(v39);
		VAL r41 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_tags(r41, v40);
		VAL v42 = pop_value();
		uint64_t v43 = pop_u64();
		lpush(&lbl_tags, v42);
		push_u64(v43);
		VAL v44 = mw_mirth_token_Token_rcurlyZAsk(v43);
		switch (get_data_tag(v44)) {
			case 1LL: { // Some
				VAL v45 = mtp_std_maybe_Maybe_1_Some(v44);
				decref(v45);
			} break;
			case 0LL: { // None
				STR* v46;
				STRLIT(v46, "expected right curly brace '}'", 30);
				VAL r47 = pop_resource();
				uint64_t v48 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v48, MKSTR(v46), r47);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v49 = pop_u64();
		uint64_t v50 = mw_mirth_token_Token_succ(v49);
		push_u64(v50);
	}
	VAL v51 = lpop(&lbl_tags);
	uint64_t v52 = VU64(lpop(&lbl_header));
	VAL v53 = mtw_mirth_elab_SyntaxData_SyntaxData(v52, v51);
	push_value(v53);
}
static void mw_mirth_elab_parseZ_dataZ_header (VAL x1, uint64_t x2) {
	push_resource(x1);
	lpush(&lbl_head, MKU64(x2));
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	uint64_t v1 = VU64(lpop(&lbl_head));
	push_u64(v0);
	lpush(&lbl_head, MKU64(v1));
	VAL v2 = mw_mirth_token_Token_lastZ_nameZAsk(v1);
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
			int64_t v4 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v3));
			push_i64(v4);
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v6 = pop_bool();
	if (v6) {
	} else {
		uint64_t v7 = VU64(lpop(&lbl_head));
		STR* v8;
		STRLIT(v8, "Expected type name.", 19);
		VAL r9 = pop_resource();
		lpush(&lbl_head, MKU64(v7));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v7, MKSTR(v8), r9);
	}
	uint64_t v10 = VU64(lpop(&lbl_head));
	push_u64(v10);
}
static void mw_mirth_elab_parseZ_dataZ_tags (VAL x1, uint64_t x2) {
	int64_t v0 = 0LL /* Nil */;
	push_resource(x1);
	push_u64(x2);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	push_resource(v1);
	while(1) {
		VAL r2 = pop_resource();
		uint64_t v3 = pop_u64();
		push_u64(v3);
		int64_t v4 = mw_mirth_token_Token_argZ_endZAsk(v3);
		bool v5 = !((bool)v4);
		push_resource(r2);
		if (!v5) break;
		VAL r6 = pop_resource();
		uint64_t v7 = pop_u64();
		VAL r8 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_tag(r8, v7);
		VAL v9 = pop_value();
		VAL v10 = mtw_std_list_List_1_Cons(v9, r6);
		push_resource(v10);
	}
	VAL r11 = pop_resource();
	VAL v12 = mw_std_list_List_1_reverse(r11);
	push_value(v12);
}
static void mw_mirth_elab_parseZ_dataZ_tag (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_token_Token_intZAsk(x2);
	incref(v0);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			lpush(&lbl_valueZAsk, v0);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			decref(v1);
			uint64_t v2 = pop_u64();
			uint64_t v3 = mw_mirth_token_Token_succ(v2);
			push_u64(v3);
		} break;
		case 0LL: { // None
			lpush(&lbl_valueZAsk, v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			lpush(&lbl_valueZAsk, v0);
		}
	}
	uint64_t v4 = pop_u64();
	push_u64(v4);
	VAL v5 = mw_mirth_token_Token_nameZAsk(v4);
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
			incref(v6);
			int64_t v7 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v6));
			if (((bool)v7)) {
				VAL v8 = mtw_std_maybe_Maybe_1_Some(v6);
				push_value(v8);
			} else {
				decref(v6);
				int64_t v9 = 0LL /* None */;
				push_i64(v9);
			}
		} break;
		case 0LL: { // None
			int64_t v10 = 0LL /* None */;
			push_i64(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v11 = pop_value();
	switch (get_data_tag(v11)) {
		case 1LL: { // Some
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v11);
			push_value(v12);
		} break;
		case 0LL: { // None
			STR* v13;
			STRLIT(v13, "Expected constructor name.", 26);
			VAL r14 = pop_resource();
			uint64_t v15 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v15, MKSTR(v13), r14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v16 = pop_u64();
	uint64_t v17 = pop_u64();
	lpush(&lbl_name, MKU64(v16));
	uint64_t v18 = mw_mirth_token_Token_succ(v17);
	push_u64(v18);
	int64_t v19 = mw_mirth_token_Token_arrowZAsk(v18);
	if (((bool)v19)) {
		uint64_t v20 = pop_u64();
		uint64_t v21 = mw_mirth_token_Token_succ(v20);
		push_u64(v21);
		VAL v22 = mtw_std_maybe_Maybe_1_Some(MKU64(v21));
		uint64_t v23 = pop_u64();
		lpush(&lbl_sigZAsk, v22);
		uint64_t v24 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(v23);
		push_u64(v24);
		int64_t v25 = mw_mirth_token_Token_argZ_endZAsk(v24);
		if (((bool)v25)) {
		} else {
			STR* v26;
			STRLIT(v26, "Expected comma.", 15);
			VAL r27 = pop_resource();
			uint64_t v28 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v28, MKSTR(v26), r27);
		}
	} else {
		uint64_t v29 = pop_u64();
		push_u64(v29);
		VAL v30 = mw_mirth_token_Token_lsquareZAsk(v29);
		switch (get_data_tag(v30)) {
			case 1LL: { // Some
				VAL v31 = mtp_std_maybe_Maybe_1_Some(v30);
				decref(v31);
				uint64_t v32 = pop_u64();
				uint64_t v33 = mw_mirth_token_Token_succ(v32);
				push_u64(v33);
				VAL v34 = mtw_std_maybe_Maybe_1_Some(MKU64(v33));
				uint64_t v35 = pop_u64();
				lpush(&lbl_sigZAsk, v34);
				uint64_t v36 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(v35);
				push_u64(v36);
				VAL v37 = mw_mirth_token_Token_rsquareZAsk(v36);
				switch (get_data_tag(v37)) {
					case 1LL: { // Some
						VAL v38 = mtp_std_maybe_Maybe_1_Some(v37);
						decref(v38);
					} break;
					case 0LL: { // None
						STR* v39;
						STRLIT(v39, "Expected right square bracket ']'", 33);
						VAL r40 = pop_resource();
						uint64_t v41 = pop_u64();
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v41, MKSTR(v39), r40);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
				uint64_t v42 = pop_u64();
				uint64_t v43 = mw_mirth_token_Token_succ(v42);
				push_u64(v43);
			} break;
			case 0LL: { // None
				int64_t v44 = 0LL /* None */;
				lpush(&lbl_sigZAsk, MKI64(v44));
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
	uint64_t v45 = pop_u64();
	push_u64(v45);
	int64_t v46 = mw_mirth_token_Token_commaZAsk(v45);
	if (((bool)v46)) {
		uint64_t v47 = pop_u64();
		uint64_t v48 = mw_mirth_token_Token_succ(v47);
		push_u64(v48);
	} else {
	}
	VAL v49 = lpop(&lbl_sigZAsk);
	uint64_t v50 = VU64(lpop(&lbl_name));
	VAL v51 = lpop(&lbl_valueZAsk);
	VAL v52 = mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag(v51, v50, v49);
	push_value(v52);
}
static void mw_mirth_elab_parseZ_struct (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_token_Token_numZ_args(x2);
	int64_t v1 = 0LL;
	bool v2 = (v0 > v1);
	if (v2) {
		uint64_t v3 = pop_u64();
		uint64_t v4 = mw_mirth_token_Token_succ(v3);
		push_u64(v4);
		VAL v5 = mw_mirth_token_Token_lparenZAsk(v4);
		switch (get_data_tag(v5)) {
			case 1LL: { // Some
				VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
				decref(v6);
				STR* v7;
				STRLIT(v7, "Expected left parenthesis '('", 29);
				VAL r8 = pop_resource();
				uint64_t v9 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v9, MKSTR(v7), r8);
			} break;
			case 0LL: { // None
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v10 = pop_u64();
		uint64_t v11 = mw_mirth_token_Token_succ(v10);
		VAL r12 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_header(r12, v11);
		uint64_t v13 = pop_u64();
		uint64_t v14 = pop_u64();
		lpush(&lbl_header, MKU64(v13));
		push_u64(v14);
		int64_t v15 = mw_mirth_token_Token_commaZAsk(v14);
		if (((bool)v15)) {
			uint64_t v16 = pop_u64();
			uint64_t v17 = mw_mirth_token_Token_succ(v16);
			push_u64(v17);
		} else {
		}
		uint64_t v18 = VU64(lpop(&lbl_header));
		uint64_t v19 = pop_u64();
		VAL r20 = pop_resource();
		mw_mirth_elab_parseZ_structZ_tag(r20, v19, v18);
		int64_t v21 = 0LL /* Nil */;
		VAL v22 = pop_value();
		VAL v23 = mtw_std_list_List_1_Cons(v22, MKI64(v21));
		uint64_t v24 = pop_u64();
		lpush(&lbl_tags, v23);
		push_u64(v24);
		VAL v25 = mw_mirth_token_Token_rparenZAsk(v24);
		switch (get_data_tag(v25)) {
			case 1LL: { // Some
				VAL v26 = mtp_std_maybe_Maybe_1_Some(v25);
				decref(v26);
				STR* v27;
				STRLIT(v27, "Expected right parenthesis ')'", 30);
				VAL r28 = pop_resource();
				uint64_t v29 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v29, MKSTR(v27), r28);
			} break;
			case 0LL: { // None
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v30 = pop_u64();
		uint64_t v31 = mw_mirth_token_Token_succ(v30);
		push_u64(v31);
	} else {
		uint64_t v32 = pop_u64();
		uint64_t v33 = mw_mirth_token_Token_succ(v32);
		VAL r34 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_header(r34, v33);
		uint64_t v35 = pop_u64();
		uint64_t v36 = pop_u64();
		lpush(&lbl_header, MKU64(v35));
		push_u64(v36);
		VAL v37 = mw_mirth_token_Token_lcurlyZAsk(v36);
		switch (get_data_tag(v37)) {
			case 1LL: { // Some
				VAL v38 = mtp_std_maybe_Maybe_1_Some(v37);
				decref(v38);
			} break;
			case 0LL: { // None
				STR* v39;
				STRLIT(v39, "expected left curly brace '{'", 29);
				VAL r40 = pop_resource();
				uint64_t v41 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v41, MKSTR(v39), r40);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v42 = pop_u64();
		uint64_t v43 = mw_mirth_token_Token_succ(v42);
		uint64_t v44 = VU64(lpop(&lbl_header));
		VAL r45 = pop_resource();
		mw_mirth_elab_parseZ_structZ_tag(r45, v43, v44);
		int64_t v46 = 0LL /* Nil */;
		VAL v47 = pop_value();
		VAL v48 = mtw_std_list_List_1_Cons(v47, MKI64(v46));
		uint64_t v49 = pop_u64();
		lpush(&lbl_tags, v48);
		push_u64(v49);
		VAL v50 = mw_mirth_token_Token_rcurlyZAsk(v49);
		switch (get_data_tag(v50)) {
			case 1LL: { // Some
				VAL v51 = mtp_std_maybe_Maybe_1_Some(v50);
				decref(v51);
			} break;
			case 0LL: { // None
				STR* v52;
				STRLIT(v52, "expected right curly brace '}'", 30);
				VAL r53 = pop_resource();
				uint64_t v54 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v54, MKSTR(v52), r53);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v55 = pop_u64();
		uint64_t v56 = mw_mirth_token_Token_succ(v55);
		push_u64(v56);
	}
	VAL v57 = lpop(&lbl_tags);
	uint64_t v58 = VU64(lpop(&lbl_header));
	VAL v59 = mtw_mirth_elab_SyntaxData_SyntaxData(v58, v57);
	push_value(v59);
}
static void mw_mirth_elab_parseZ_structZ_tag (VAL x1, uint64_t x2, uint64_t x3) {
	push_resource(x1);
	push_u64(x2);
	lpush(&lbl_header, MKU64(x3));
	VAL v0 = mw_mirth_token_Token_lastZ_nameZAsk(x3);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			incref(v1);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v1));
			if (((bool)v2)) {
				VAL v3 = mtw_std_maybe_Maybe_1_Some(v1);
				push_value(v3);
			} else {
				decref(v1);
				int64_t v4 = 0LL /* None */;
				push_i64(v4);
			}
		} break;
		case 0LL: { // None
			int64_t v5 = 0LL /* None */;
			push_i64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v6 = pop_value();
	switch (get_data_tag(v6)) {
		case 1LL: { // Some
			VAL v7 = mtp_std_maybe_Maybe_1_Some(v6);
			push_value(v7);
		} break;
		case 0LL: { // None
			uint64_t v8 = VU64(lpop(&lbl_header));
			STR* v9;
			STRLIT(v9, "expected constructor name", 25);
			VAL r10 = pop_resource();
			lpush(&lbl_header, MKU64(v8));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v8, MKSTR(v9), r10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v11 = pop_u64();
	int64_t v12 = 0LL /* None */;
	uint64_t v13 = pop_u64();
	lpush(&lbl_name, MKU64(v11));
	lpush(&lbl_valueZAsk, MKI64(v12));
	push_u64(v13);
	VAL v14 = mtw_std_maybe_Maybe_1_Some(MKU64(v13));
	uint64_t v15 = pop_u64();
	lpush(&lbl_sigZAsk, v14);
	uint64_t v16 = mw_mirth_token_Token_sigZ_nextZ_stackZ_end(v15);
	VAL v17 = lpop(&lbl_sigZAsk);
	uint64_t v18 = VU64(lpop(&lbl_name));
	VAL v19 = lpop(&lbl_valueZAsk);
	push_u64(v16);
	VAL v20 = mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag(v19, v18, v17);
	push_value(v20);
}
static void mw_mirth_elab_elabZ_dataZBang (VAL x1, uint64_t x2) {
	mw_mirth_elab_parseZ_data(x1, x2);
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2 = (mw_mirth_elab_elabZ_dataZ_auxZBang(v1, r0));
	push_resource(v2);
}
static void mw_mirth_elab_elabZ_structZBang (VAL x1, uint64_t x2) {
	mw_mirth_elab_parseZ_struct(x1, x2);
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2 = (mw_mirth_elab_elabZ_dataZ_auxZBang(v1, r0));
	push_resource(v2);
}
static VAL mw_mirth_elab_elabZ_dataZ_auxZBang (VAL x1, VAL x2) {
	push_resource(x2);
	mtp_mirth_elab_SyntaxData_SyntaxData(x1);
	uint64_t v0 = mw_mirth_data_Data_allocZBang();
	int64_t v1 = 0LL /* Nil */;
	void* v2 = mfld_mirth_data_Data_ZTildetags(v0);
	mut_set(MKI64(v1), MKPTR(v2));
	uint64_t v3 = VU64(lpop(&lbl_header));
	VAL r4 = pop_resource();
	mw_mirth_elab_elabZ_dataZ_headerZBang(v0, v3, r4);
	VAL v5 = lpop(&lbl_tags);
	mw_std_list_List_1_uncons(v5);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
		if (!((bool)v9)) break;
		VAL v10 = pop_value();
		VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
		VAL v12 = pop_value();
		VAL r13 = pop_resource();
		uint64_t v14 = pop_u64();
		mw_mirth_elab_elabZ_dataZ_tagZBang(v14, v11, r13);
		mw_std_list_List_1_uncons(v12);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
	uint64_t v19 = pop_u64();
	VAL r20 = pop_resource();
	VAL v21 = (mw_mirth_elab_elabZ_dataZ_doneZBang(r20, v19));
	return v21;
}
static void mw_mirth_elab_elabZ_dataZ_headerZBang (uint64_t x1, uint64_t x2, VAL x3) {
	push_resource(x3);
	lpush(&lbl_data, MKU64(x1));
	lpush(&lbl_head, MKU64(x2));
	VAL v0 = mw_mirth_token_Token_lastZ_nameZAsk(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			int64_t v2 = mw_mirth_name_Name_couldZ_beZ_constructor(VU64(v1));
			push_i64(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v4 = pop_bool();
	if (v4) {
	} else {
		uint64_t v5 = VU64(lpop(&lbl_head));
		STR* v6;
		STRLIT(v6, "Expected type name.", 19);
		VAL r7 = pop_resource();
		lpush(&lbl_head, MKU64(v5));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v5, MKSTR(v6), r7);
	}
	uint64_t v8 = VU64(lpop(&lbl_head));
	VAL r9 = pop_resource();
	mw_mirth_elab_elabZ_defZ_head(r9, v8);
	uint64_t v10 = VU64(lpop(&lbl_head));
	lpush(&lbl_head, MKU64(v10));
	VAL v11 = mtw_std_maybe_Maybe_1_Some(MKU64(v10));
	uint64_t v12 = VU64(lpop(&lbl_data));
	void* v13 = mfld_mirth_data_Data_ZTildeheadZAsk(v12);
	mut_set(v11, MKPTR(v13));
	int64_t v14 = VI64(lpop(&lbl_arity));
	void* v15 = mfld_mirth_data_Data_ZTildearity(v12);
	mut_set(MKI64(v14), MKPTR(v15));
	uint64_t v16 = VU64(lpop(&lbl_name));
	void* v17 = mfld_mirth_data_Data_ZTildename(v12);
	mut_set(MKU64(v16), MKPTR(v17));
	lpush(&lbl_data, MKU64(v12));
	VAL v18 = mtw_mirth_mirth_PropLabel_DataQName(v12);
	VAL v19 = lpop(&lbl_state);
	VAL v20 = mtw_mirth_mirth_Prop_1_Prop(v18, v19);
	uint64_t v21 = VU64(lpop(&lbl_data));
	void* v22 = mfld_mirth_data_Data_ZTildeqname(v21);
	mut_set(v20, MKPTR(v22));
	uint64_t v23 = VU64(lpop(&lbl_head));
	lpush(&lbl_data, MKU64(v21));
	lpush(&lbl_head, MKU64(v23));
	VAL v24 = mw_mirth_token_Token_args(v23);
	uint64_t v25 = VU64(lpop(&lbl_data));
	push_value(v24);
	lpush(&lbl_data, MKU64(v25));
	VAL v26 = mtw_mirth_mirth_PropLabel_DataParams(v25);
	FNPTR v27 = &mb_mirth_elab_elabZ_dataZ_headerZBang_2;
	VAL r28 = pop_resource();
	VAL v29 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v29, v26, r28, MKFNPTR(v27));
	uint64_t v30 = VU64(lpop(&lbl_data));
	void* v31 = mfld_mirth_data_Data_ZTildeparams(v30);
	VAL v32 = pop_value();
	mut_set(v32, MKPTR(v31));
	lpush(&lbl_data, MKU64(v30));
	VAL v33 = mtw_mirth_def_Def_DefData(v30);
	VAL r34 = pop_resource();
	VAL v35 = (mw_mirth_def_Def_register(r34, v33));
	uint64_t v36 = VU64(lpop(&lbl_head));
	uint64_t v37 = VU64(lpop(&lbl_data));
	push_resource(v35);
	push_u64(v37);
}
static void mw_mirth_elab_elabZ_dataZ_paramsZBang (VAL x1, VAL x2) {
	push_value(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_var_Ctx0();
	VAL v1 = pop_value();
	push_value(v0);
	mw_std_list_List_1_uncons(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		incref(v7);
		push_value(v7);
		int64_t v9 = mw_mirth_token_Token_sigZ_typeZ_varZAsk(VU64(v7));
		if (((bool)v9)) {
		} else {
			STR* v10;
			STRLIT(v10, "expected type variable", 22);
			VAL r11 = pop_resource();
			uint64_t v12 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v12, MKSTR(v10), r11);
		}
		uint64_t v13 = pop_u64();
		push_u64(v13);
		VAL v14 = mw_mirth_token_Token_nameZAsk(v13);
		VAL v15 = mw_std_maybe_Maybe_1_unwrap(v14);
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		push_value(v16);
		VAL v18 = mw_mirth_var_Ctx_lookup(VU64(v15), v17);
		switch (get_data_tag(v18)) {
			case 1LL: { // Some
				VAL v19 = mtp_std_maybe_Maybe_1_Some(v18);
				decref(v19);
				STR* v20;
				STRLIT(v20, "duplicate parameter name", 24);
				VAL r21 = pop_resource();
				uint64_t v22 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v22, MKSTR(v20), r21);
			} break;
			case 0LL: { // None
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v23 = pop_u64();
		VAL v24 = mw_mirth_token_Token_nameZAsk(v23);
		VAL v25 = mw_std_maybe_Maybe_1_unwrap(v24);
		push_value(v25);
		VAL v26 = mw_mirth_type_TYPEz_TYPE();
		uint64_t v27 = pop_u64();
		uint64_t v28 = mw_mirth_var_Var_newZBang(v26, v27);
		VAL v29 = pop_value();
		VAL v30 = mw_mirth_var_Ctx_new(v29, v28);
		push_value(v30);
		mw_std_list_List_1_uncons(v8);
		VAL v31 = pop_value();
		VAL v32 = pop_value();
		push_value(v31);
		push_value(v32);
	}
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	decref(v34);
	VAL v35 = pop_value();
	VAL v36 = mw_mirth_var_Ctx_ZToList(v35);
	push_value(v36);
}
static void mw_mirth_elab_elabZ_dataZ_tagZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	lpush(&lbl_syn, x2);
	lpush(&lbl_dat, MKU64(x1));
	uint64_t v0 = mw_mirth_data_Tag_allocZBang();
	uint64_t v1 = VU64(lpop(&lbl_dat));
	VAL v2 = lpop(&lbl_syn);
	incref(v2);
	uint64_t v3 = VU64(VTUP(v2)->cells[2]);
	decref(v2);
	int64_t v4 = 0LL;
	lpush(&lbl_tag, MKU64(v0));
	lpush(&lbl_dat, MKU64(v1));
	lpush(&lbl_syn, v2);
	VAL v5 = mw_mirth_data_dataZ_qname(v1, v3, v4);
	uint64_t v6 = VU64(lpop(&lbl_tag));
	void* v7 = mfld_mirth_data_Tag_ZTildeqname(v6);
	mut_set(v5, MKPTR(v7));
	VAL v8 = lpop(&lbl_syn);
	incref(v8);
	VAL v9 = VVAL(VTUP(v8)->cells[3]);
	incref(v9);
	decref(v8);
	void* v10 = mfld_mirth_data_Tag_ZTildesigZAsk(v6);
	mut_set(v9, MKPTR(v10));
	incref(v8);
	VAL v11 = VVAL(VTUP(v8)->cells[1]);
	incref(v11);
	decref(v8);
	switch (get_data_tag(v11)) {
		case 1LL: { // Some
			lpush(&lbl_tag, MKU64(v6));
			lpush(&lbl_syn, v8);
			VAL v12 = mtp_std_maybe_Maybe_1_Some(v11);
			uint64_t v13 = VU64(lpop(&lbl_tag));
			void* v14 = mfld_mirth_data_Tag_ZTildevalue(v13);
			mut_set(v12, MKPTR(v14));
			lpush(&lbl_tag, MKU64(v13));
		} break;
		case 0LL: { // None
			lpush(&lbl_tag, MKU64(v6));
			lpush(&lbl_syn, v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			lpush(&lbl_tag, MKU64(v6));
			lpush(&lbl_syn, v8);
		}
	}
	uint64_t v15 = VU64(lpop(&lbl_dat));
	uint64_t v16 = VU64(lpop(&lbl_tag));
	void* v17 = mfld_mirth_data_Tag_ZTildedata(v16);
	mut_set(MKU64(v15), MKPTR(v17));
	VAL r18 = pop_resource();
	lpush(&lbl_tag, MKU64(v16));
	lpush(&lbl_dat, MKU64(v15));
	VAL v19 = (mw_mirth_data_Data_addZ_tagZBang(r18, v16, v15));
	uint64_t v20 = VU64(lpop(&lbl_tag));
	push_resource(v19);
	lpush(&lbl_tag, MKU64(v20));
	VAL v21 = mtw_mirth_def_Def_DefTag(v20);
	VAL r22 = pop_resource();
	VAL v23 = (mw_mirth_def_Def_register(r22, v21));
	uint64_t v24 = VU64(lpop(&lbl_tag));
	push_resource(v23);
	push_u64(v24);
	lpush(&lbl_tag, MKU64(v24));
	VAL v25 = mtw_mirth_mirth_PropLabel_TagType(v24);
	FNPTR v26 = &mb_mirth_elab_elabZ_dataZ_tagZBang_1;
	VAL r27 = pop_resource();
	VAL v28 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v28, v25, r27, MKFNPTR(v26));
	uint64_t v29 = VU64(lpop(&lbl_tag));
	void* v30 = mfld_mirth_data_Tag_ZTildectxZ_type(v29);
	VAL v31 = pop_value();
	mut_set(v31, MKPTR(v30));
	lpush(&lbl_tag, MKU64(v29));
	int64_t v32 = mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig(v29);
	uint64_t v33 = VU64(lpop(&lbl_tag));
	void* v34 = mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs(v33);
	mut_set(MKI64(v32), MKPTR(v34));
	lpush(&lbl_tag, MKU64(v33));
	int64_t v35 = mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig(v33);
	uint64_t v36 = VU64(lpop(&lbl_tag));
	void* v37 = mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs(v36);
	mut_set(MKI64(v35), MKPTR(v37));
	lpush(&lbl_tag, MKU64(v36));
	VAL v38 = mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig(v36);
	uint64_t v39 = VU64(lpop(&lbl_tag));
	void* v40 = mfld_mirth_data_Tag_ZTildelabelZ_inputs(v39);
	mut_set(v38, MKPTR(v40));
	lpush(&lbl_tag, MKU64(v39));
	int64_t v41 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v39);
	bool v42 = !((bool)v41);
	uint64_t v43 = VU64(lpop(&lbl_tag));
	push_bool(v42);
	lpush(&lbl_tag, MKU64(v43));
	int64_t v44 = mw_mirth_data_Tag_numZ_resourceZ_inputs(v43);
	int64_t v45 = 0LL;
	bool v46 = (v44 > v45);
	bool v47 = pop_bool();
	bool v48 = (v47 && v46);
	if (v48) {
		uint64_t v49 = VU64(lpop(&lbl_tag));
		lpush(&lbl_tag, MKU64(v49));
		VAL v50 = mw_mirth_data_Tag_sigZAsk(v49);
		VAL v51 = mw_std_maybe_Maybe_1_unwrap(v50);
		VAL v52 = mw_mirth_token_Token_runZ_tokens(VU64(v51));
		int64_t v53 = 0LL /* None */;
		push_i64(v53);
		mw_std_list_List_1_uncons(v52);
		VAL v54 = pop_value();
		VAL v55 = pop_value();
		push_value(v54);
		push_value(v55);
		while(1) {
			VAL v56 = pop_value();
			incref(v56);
			push_value(v56);
			int64_t v57 = mw_std_maybe_Maybe_1_someZAsk(v56);
			if (!((bool)v57)) break;
			VAL v58 = pop_value();
			VAL v59 = mw_std_maybe_Maybe_1_unwrap(v58);
			VAL v60 = pop_value();
			VAL v61 = pop_value();
			incref(v59);
			incref(v59);
			int64_t v62 = mw_mirth_token_Token_sigZ_resourceZ_conZAsk(VU64(v59));
			if (((bool)v62)) {
				decref(v59);
				int64_t v63 = 1LL /* True */;
				push_i64(v63);
			} else {
				int64_t v64 = mw_mirth_token_Token_sigZ_resourceZ_varZAsk(VU64(v59));
				push_i64(v64);
			}
			int64_t v65 = pop_i64();
			if (((bool)v65)) {
				VAL v66 = mtw_std_maybe_Maybe_1_Some(v59);
				push_value(v66);
			} else {
				decref(v59);
				int64_t v67 = 0LL /* None */;
				push_i64(v67);
			}
			VAL v68 = pop_value();
			switch (get_data_tag(v68)) {
				case 0LL: { // None
					push_value(v61);
					push_value(v60);
				} break;
				default: {
					decref(v60);
					decref(v61);
					int64_t v69 = 0LL /* Nil */;
					push_value(v68);
					push_i64(v69);
				} break;
			}
			VAL v70 = pop_value();
			mw_std_list_List_1_uncons(v70);
			VAL v71 = pop_value();
			VAL v72 = pop_value();
			push_value(v71);
			push_value(v72);
		}
		VAL v73 = pop_value();
		decref(v73);
		VAL v74 = pop_value();
		decref(v74);
		VAL v75 = pop_value();
		VAL v76 = mw_std_maybe_Maybe_1_unwrap(v75);
		STR* v77;
		STRLIT(v77, "Value type cannot contain resource.", 35);
		VAL r78 = pop_resource();
		VAL v79 = (mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang(VU64(v76), MKSTR(v77), r78));
		push_resource(v79);
	} else {
	}
	uint64_t v80 = VU64(lpop(&lbl_tag));
	VAL v81 = lpop(&lbl_syn);
	decref(v81);
	uint64_t v82 = VU64(lpop(&lbl_dat));
	push_u64(v82);
}
static void mw_mirth_elab_dataZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4) {
	incref(x3);
	push_resource(x1);
	push_u64(x2);
	lpush(&lbl_arity, MKI64(x4));
	push_value(x3);
	push_i64(x4);
	uint64_t v0 = mw_std_prim_Str_ZToName(x3);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	uint64_t v3 = pop_u64();
	lpush(&lbl_name, MKU64(v0));
	push_u64(v3);
	VAL v4 = mw_mirth_data_Data_headZAsk(v3);
	VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
	incref(v5);
	uint64_t v6 = pop_u64();
	lpush(&lbl_body, v5);
	lpush(&lbl_head, v5);
	VAL v7 = mw_mirth_data_dataZ_wordZ_qname(v6, v2, VI64(v1));
	int64_t v8 = 0LL /* None */;
	VAL r9 = pop_resource();
	int64_t v10 = VI64(lpop(&lbl_arity));
	uint64_t v11 = VU64(lpop(&lbl_name));
	uint64_t v12 = VU64(lpop(&lbl_body));
	uint64_t v13 = VU64(lpop(&lbl_head));
	lpush(&lbl_qname, v7);
	mw_mirth_word_Word_newZBang(v13, MKI64(v8), v12, v11, v10, r9);
	VAL v14 = lpop(&lbl_qname);
	VAL v15 = pop_value();
	incref(v15);
	push_value(v15);
	push_value(v14);
	VAL v16 = mtw_mirth_mirth_PropLabel_WordQName(VU64(v15));
	VAL r17 = pop_resource();
	VAL v18 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v18, v16, r17);
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	incref(v20);
	void* v21 = mfld_mirth_word_Word_ZTildeqname(VU64(v20));
	mut_set(v19, MKPTR(v21));
	push_value(v20);
}
static VAL mw_mirth_elab_elabZ_dataZ_doneZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	lpush(&lbl_dat, MKU64(x2));
	int64_t v0 = mw_mirth_data_Data_isZ_valueZ_typeZAsk(x2);
	if (((bool)v0)) {
		uint64_t v1 = VU64(lpop(&lbl_dat));
		STR* v2;
		STRLIT(v2, "tag", 3);
		int64_t v3 = 0LL;
		VAL r4 = pop_resource();
		lpush(&lbl_dat, MKU64(v1));
		mw_mirth_elab_dataZ_wordZ_newZBang(r4, v1, MKSTR(v2), v3);
		uint64_t v5 = pop_u64();
		uint64_t v6 = VU64(lpop(&lbl_dat));
		VAL r7 = pop_resource();
		lpush(&lbl_tag, MKU64(v5));
		lpush(&lbl_dat, MKU64(v6));
		mw_mirth_data_Data_params(r7, v6);
		VAL v8 = pop_value();
		VAL v9 = mw_std_list_List_1_ZToCtx(v8);
		uint64_t v10 = VU64(lpop(&lbl_dat));
		VAL r11 = pop_resource();
		push_value(v9);
		lpush(&lbl_dat, MKU64(v10));
		mw_mirth_elab_dataZ_getZ_tagZ_type(r11, v10);
		uint64_t v12 = VU64(lpop(&lbl_tag));
		lpush(&lbl_tag, MKU64(v12));
		VAL v13 = mtw_mirth_mirth_PropLabel_WordType(v12);
		VAL r14 = pop_resource();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		mw_mirth_mirth_PropLabel_prop2(v16, v15, v13, r14);
		uint64_t v17 = VU64(lpop(&lbl_tag));
		void* v18 = mfld_mirth_word_Word_ZTildectxZ_type(v17);
		VAL v19 = pop_value();
		mut_set(v19, MKPTR(v18));
		VAL r20 = pop_resource();
		lpush(&lbl_tag, MKU64(v17));
		mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r20, v17);
		uint64_t v21 = pop_u64();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		mw_mirth_type_ArrowType_unpack(v24);
		VAL v25 = pop_value();
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		incref(v23);
		incref(v26);
		int64_t v28 = 0LL /* Nil */;
		push_value(v25);
		VAL v29 = mtw_mirth_arrow_Arrow_Arrow(v22, VU64(v23), VU64(v23), v27, v26, v26, MKI64(v28));
		VAL v30 = pop_value();
		uint64_t v31 = VU64(lpop(&lbl_dat));
		push_resource(v29);
		lpush(&lbl_dat, MKU64(v31));
		VAL v32 = mtw_mirth_arrow_Op_OpDataGetTag(v31);
		VAL r33 = pop_resource();
		VAL r34 = pop_resource();
		mw_mirth_elab_abZ_opZBang(v32, r34, r33);
		VAL r35 = pop_resource();
		VAL r36 = pop_resource();
		mw_mirth_elab_abZ_unifyZ_typeZBang(v30, r36, r35);
		VAL r37 = pop_resource();
		VAL r38 = pop_resource();
		mw_mirth_elab_finalizzeZ_wordZ_arrow(r38, r37, v21);
		VAL v39 = mtw_mirth_mirth_PropLabel_WordArrow(v17);
		VAL r40 = pop_resource();
		VAL v41 = pop_value();
		mw_mirth_mirth_PropLabel_prop(v41, v39, r40);
		VAL v42 = pop_value();
		void* v43 = mfld_mirth_word_Word_ZTildearrow(v17);
		mut_set(v42, MKPTR(v43));
		mw_mirth_word_Word_makeZ_inlineZBang(v17);
		uint64_t v44 = VU64(lpop(&lbl_tag));
	} else {
	}
	uint64_t v45 = VU64(lpop(&lbl_dat));
	lpush(&lbl_dat, MKU64(v45));
	int64_t v46 = mw_mirth_data_Data_isZ_enumZAsk(v45);
	if (((bool)v46)) {
		uint64_t v47 = VU64(lpop(&lbl_dat));
		STR* v48;
		STRLIT(v48, "from-tag-unsafe", 15);
		int64_t v49 = 0LL;
		VAL r50 = pop_resource();
		lpush(&lbl_dat, MKU64(v47));
		mw_mirth_elab_dataZ_wordZ_newZBang(r50, v47, MKSTR(v48), v49);
		uint64_t v51 = pop_u64();
		lpush(&lbl_ftag, MKU64(v51));
		VAL v52 = mw_mirth_var_Ctx0();
		push_value(v52);
		VAL v53 = mw_mirth_type_TYPEz_INT();
		VAL v54 = mw_mirth_type_T1(v53);
		uint64_t v55 = VU64(lpop(&lbl_dat));
		push_value(v54);
		lpush(&lbl_dat, MKU64(v55));
		VAL v56 = mtw_mirth_type_Type_TData(v55);
		VAL v57 = mw_mirth_type_T1(v56);
		VAL v58 = pop_value();
		VAL v59 = mw_mirth_type_TZ_ZTo(v58, v57);
		uint64_t v60 = VU64(lpop(&lbl_ftag));
		push_value(v59);
		lpush(&lbl_ftag, MKU64(v60));
		VAL v61 = mtw_mirth_mirth_PropLabel_WordType(v60);
		VAL r62 = pop_resource();
		VAL v63 = pop_value();
		VAL v64 = pop_value();
		mw_mirth_mirth_PropLabel_prop2(v64, v63, v61, r62);
		uint64_t v65 = VU64(lpop(&lbl_ftag));
		void* v66 = mfld_mirth_word_Word_ZTildectxZ_type(v65);
		VAL v67 = pop_value();
		mut_set(v67, MKPTR(v66));
		VAL r68 = pop_resource();
		lpush(&lbl_ftag, MKU64(v65));
		mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r68, v65);
		uint64_t v69 = pop_u64();
		VAL v70 = pop_value();
		VAL v71 = pop_value();
		VAL v72 = pop_value();
		mw_mirth_type_ArrowType_unpack(v72);
		VAL v73 = pop_value();
		VAL v74 = pop_value();
		VAL v75 = pop_value();
		incref(v71);
		incref(v74);
		int64_t v76 = 0LL /* Nil */;
		push_value(v73);
		VAL v77 = mtw_mirth_arrow_Arrow_Arrow(v70, VU64(v71), VU64(v71), v75, v74, v74, MKI64(v76));
		VAL v78 = pop_value();
		int64_t v79 = 0LL /* CoerceUnsafe */;
		VAL r80 = pop_resource();
		mw_mirth_elab_abZ_coerceZBang(MKI64(v79), r80, v77);
		VAL r81 = pop_resource();
		VAL r82 = pop_resource();
		mw_mirth_elab_abZ_unifyZ_typeZBang(v78, r82, r81);
		VAL r83 = pop_resource();
		VAL r84 = pop_resource();
		mw_mirth_elab_finalizzeZ_wordZ_arrow(r84, r83, v69);
		VAL v85 = mtw_mirth_mirth_PropLabel_WordArrow(v65);
		VAL r86 = pop_resource();
		VAL v87 = pop_value();
		mw_mirth_mirth_PropLabel_prop(v87, v85, r86);
		VAL v88 = pop_value();
		void* v89 = mfld_mirth_word_Word_ZTildearrow(v65);
		mut_set(v88, MKPTR(v89));
		mw_mirth_word_Word_makeZ_inlineZBang(v65);
		uint64_t v90 = VU64(lpop(&lbl_ftag));
	} else {
	}
	uint64_t v91 = VU64(lpop(&lbl_dat));
	lpush(&lbl_dat, MKU64(v91));
	VAL v92 = mw_mirth_data_Data_tags(v91);
	VAL v93 = mw_std_list_List_1_ZDivL1(v92);
	switch (get_data_tag(v93)) {
		case 1LL: { // Some
			VAL v94 = mtp_std_maybe_Maybe_1_Some(v93);
			uint64_t v95 = VU64(lpop(&lbl_dat));
			STR* v96;
			STRLIT(v96, "/", 1);
			incref(v94);
			push_u64(v95);
			lpush(&lbl_dat, MKU64(v95));
			push_str(v96);
			lpush(&lbl_tag, v94);
			uint64_t v97 = mw_mirth_data_Tag_name(VU64(v94));
			VAL v98 = mw_mirth_name_Name_ZToStr(v97);
			STR* v99 = pop_str();
			STR* v100 = str_cat(v99, VSTR(v98));
			int64_t v101 = 0LL;
			uint64_t v102 = pop_u64();
			VAL r103 = pop_resource();
			mw_mirth_elab_dataZ_wordZ_newZBang(r103, v102, MKSTR(v100), v101);
			uint64_t v104 = pop_u64();
			lpush(&lbl_untag, MKU64(v104));
			VAL v105 = mtw_std_maybe_Maybe_1_Some(MKU64(v104));
			uint64_t v106 = VU64(lpop(&lbl_tag));
			void* v107 = mfld_mirth_data_Tag_ZTildeuntag(v106);
			mut_set(v105, MKPTR(v107));
			uint64_t v108 = VU64(lpop(&lbl_untag));
			push_u64(v106);
			lpush(&lbl_tag, MKU64(v106));
			lpush(&lbl_untag, MKU64(v108));
			VAL v109 = mtw_mirth_mirth_PropLabel_WordType(v108);
			FNPTR v110 = &mb_mirth_elab_elabZ_dataZ_doneZBang_5;
			VAL r111 = pop_resource();
			VAL v112 = pop_value();
			mw_mirth_mirth_PropLabel_prop_1(v112, v109, r111, MKFNPTR(v110));
			uint64_t v113 = VU64(lpop(&lbl_untag));
			void* v114 = mfld_mirth_word_Word_ZTildectxZ_type(v113);
			VAL v115 = pop_value();
			mut_set(v115, MKPTR(v114));
			uint64_t v116 = VU64(lpop(&lbl_tag));
			push_u64(v116);
			lpush(&lbl_tag, MKU64(v116));
			lpush(&lbl_untag, MKU64(v113));
			VAL v117 = mtw_mirth_mirth_PropLabel_WordArrow(v113);
			FNPTR v118 = &mb_mirth_elab_elabZ_dataZ_doneZBang_6;
			VAL r119 = pop_resource();
			VAL v120 = pop_value();
			mw_mirth_mirth_PropLabel_prop_1(v120, v117, r119, MKFNPTR(v118));
			uint64_t v121 = VU64(lpop(&lbl_untag));
			void* v122 = mfld_mirth_word_Word_ZTildearrow(v121);
			VAL v123 = pop_value();
			mut_set(v123, MKPTR(v122));
			lpush(&lbl_untag, MKU64(v121));
			mw_mirth_word_Word_makeZ_inlineZBang(v121);
			uint64_t v124 = VU64(lpop(&lbl_tag));
			VAL r125 = pop_resource();
			lpush(&lbl_tag, MKU64(v124));
			VAL v126 = (mw_mirth_elab_createZ_projectorsZBang(r125, v124));
			uint64_t v127 = VU64(lpop(&lbl_tag));
			uint64_t v128 = VU64(lpop(&lbl_untag));
			push_resource(v126);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v129 = VU64(lpop(&lbl_dat));
	push_u64(v129);
	lpush(&lbl_dat, MKU64(v129));
	VAL v130 = mtw_mirth_mirth_PropLabel_DataCType(v129);
	FNPTR v131 = &mb_mirth_elab_elabZ_dataZ_doneZBang_12;
	VAL r132 = pop_resource();
	VAL v133 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v133, v130, r132, MKFNPTR(v131));
	uint64_t v134 = VU64(lpop(&lbl_dat));
	void* v135 = mfld_mirth_data_Data_ZTildectypeZAsk(v134);
	VAL v136 = pop_value();
	mut_set(v136, MKPTR(v135));
	VAL r137 = pop_resource();
	return r137;
}
static void mw_mirth_data_Tag_outputZ_type (VAL x1, uint64_t x2) {
	push_u64(x2);
	mw_mirth_data_Tag_type(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_mirth_type_ArrowType_cod(v0);
	VAL v2 = mw_mirth_type_StackType_expand(v1);
	switch (get_data_tag(v2)) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons(v2);
			VAL v3 = pop_value();
			VAL v4 = mtw_std_either_Either_2_Left(v3);
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			push_value(v4);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith(v2);
			VAL v7 = pop_value();
			VAL v8 = mtw_std_either_Either_2_Right(v7);
			VAL v9 = pop_value();
			decref(v9);
			VAL v10 = pop_value();
			decref(v10);
			push_value(v8);
		} break;
		default: {
			decref(v2);
			uint64_t v11 = pop_u64();
			STR* v12;
			STRLIT(v12, "Unexpected output type for constructor ", 39);
			push_str(v12);
			VAL v13 = mw_mirth_data_Tag_qname(v11);
			VAL r14 = pop_resource();
			mw_mirth_name_QName_ZToStr(r14, v13);
			STR* v15 = pop_str();
			STR* v16 = pop_str();
			STR* v17 = str_cat(v16, v15);
			push_str(v17);
			do_panic();
		} break;
	}
}
static void mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field (VAL x1, uint64_t x2, uint64_t x3) {
	push_u64(x2);
	push_u64(x3);
	mw_mirth_data_Tag_outputZ_type(x1, x3);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 0LL: { // Left
			VAL v1 = mtp_std_either_Either_2_Left(v0);
			uint64_t v2 = pop_u64();
			uint64_t v3 = pop_u64();
			VAL v4 = mw_mirth_type_Type_exceptZ_field(v3, v2, v1);
			VAL v5 = mtw_std_either_Either_2_Left(v4);
			push_value(v5);
		} break;
		case 1LL: { // Right
			VAL v6 = mtp_std_either_Either_2_Right(v0);
			uint64_t v7 = pop_u64();
			uint64_t v8 = pop_u64();
			VAL v9 = mw_mirth_type_Resource_exceptZ_field(v8, v7, v6);
			VAL v10 = mtw_std_either_Either_2_Right(v9);
			push_value(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_data_Tag_projectZ_inputZ_label (VAL x1, uint64_t x2, uint64_t x3) {
	push_u64(x2);
	mw_mirth_data_Tag_type(x1, x3);
	VAL v0 = pop_value();
	VAL v1 = mw_mirth_type_ArrowType_dom(v0);
	uint64_t v2 = pop_u64();
	VAL v3 = mw_mirth_type_StackType_labelZ_topZAsk(v2, v1);
	push_value(v3);
}
static void mw_mirth_elab_dataZ_getZ_labelZ_type (VAL x1, uint64_t x2, uint64_t x3) {
	lpush(&lbl_lbl, MKU64(x3));
	lpush(&lbl_tag, MKU64(x2));
	mw_mirth_data_Tag_projectZ_inputZ_label(x1, x3, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	switch (get_data_tag(v1)) {
		case 0LL: { // Left
			VAL v2 = mtp_std_either_Either_2_Left(v1);
			push_value(v2);
			VAL v3 = mw_mirth_type_T0();
			uint64_t v4 = VU64(lpop(&lbl_tag));
			VAL r5 = pop_resource();
			push_value(v3);
			lpush(&lbl_tag, MKU64(v4));
			mw_mirth_data_Tag_outputZ_type(r5, v4);
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			VAL v8 = mw_mirth_type_TZMulZPlus(v7, v6);
			VAL v9 = pop_value();
			push_value(v8);
			VAL v10 = mw_mirth_type_T1(v9);
			uint64_t v11 = VU64(lpop(&lbl_tag));
			push_value(v10);
			lpush(&lbl_tag, MKU64(v11));
			uint64_t v12 = mw_mirth_data_Tag_data(v11);
			int64_t v13 = mw_mirth_data_Data_isZ_resourceZAsk(v12);
			if (((bool)v13)) {
				uint64_t v14 = VU64(lpop(&lbl_tag));
				VAL r15 = pop_resource();
				lpush(&lbl_tag, MKU64(v14));
				mw_mirth_data_Tag_outputZ_type(r15, v14);
				VAL v16 = pop_value();
				VAL v17 = pop_value();
				VAL v18 = mw_mirth_type_TZMulZPlus(v17, v16);
				push_value(v18);
			} else {
			}
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = mw_mirth_type_TZ_ZTo(v20, v19);
			push_value(v21);
		} break;
		case 1LL: { // Right
			VAL v22 = mtp_std_either_Either_2_Right(v1);
			push_value(v22);
			VAL v23 = mw_mirth_type_T0();
			uint64_t v24 = VU64(lpop(&lbl_tag));
			VAL r25 = pop_resource();
			push_value(v23);
			lpush(&lbl_tag, MKU64(v24));
			mw_mirth_data_Tag_outputZ_type(r25, v24);
			VAL v26 = pop_value();
			VAL v27 = pop_value();
			VAL v28 = mw_mirth_type_TZMulZPlus(v27, v26);
			push_value(v28);
			VAL v29 = mw_mirth_type_T0();
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			push_value(v30);
			VAL v32 = mw_mirth_type_TZPlus(v29, v31);
			uint64_t v33 = VU64(lpop(&lbl_lbl));
			uint64_t v34 = VU64(lpop(&lbl_tag));
			VAL r35 = pop_resource();
			push_value(v32);
			lpush(&lbl_lbl, MKU64(v33));
			lpush(&lbl_tag, MKU64(v34));
			mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field(r35, v33, v34);
			VAL v36 = pop_value();
			VAL v37 = pop_value();
			VAL v38 = mw_mirth_type_TZMulZPlus(v37, v36);
			VAL v39 = pop_value();
			VAL v40 = mw_mirth_type_TZ_ZTo(v39, v38);
			push_value(v40);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v41 = VU64(lpop(&lbl_lbl));
	uint64_t v42 = VU64(lpop(&lbl_tag));
}
static void mw_mirth_elab_dataZ_setZ_labelZ_type (VAL x1, uint64_t x2, uint64_t x3) {
	lpush(&lbl_lbl, MKU64(x3));
	lpush(&lbl_tag, MKU64(x2));
	mw_mirth_data_Tag_projectZ_inputZ_label(x1, x3, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	switch (get_data_tag(v1)) {
		case 0LL: { // Left
			VAL v2 = mtp_std_either_Either_2_Left(v1);
			VAL v3 = mw_mirth_type_T1(v2);
			uint64_t v4 = VU64(lpop(&lbl_tag));
			VAL r5 = pop_resource();
			push_value(v3);
			lpush(&lbl_tag, MKU64(v4));
			mw_mirth_data_Tag_outputZ_type(r5, v4);
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			VAL v8 = mw_mirth_type_TZMulZPlus(v7, v6);
			push_value(v8);
			VAL v9 = mw_mirth_type_T0();
			uint64_t v10 = VU64(lpop(&lbl_tag));
			VAL r11 = pop_resource();
			push_value(v9);
			lpush(&lbl_tag, MKU64(v10));
			mw_mirth_data_Tag_outputZ_type(r11, v10);
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			VAL v14 = mw_mirth_type_TZMulZPlus(v13, v12);
			VAL v15 = pop_value();
			VAL v16 = mw_mirth_type_TZ_ZTo(v15, v14);
			push_value(v16);
		} break;
		case 1LL: { // Right
			VAL v17 = mtp_std_either_Either_2_Right(v1);
			push_value(v17);
			VAL v18 = mw_mirth_type_T0();
			VAL v19 = pop_value();
			VAL v20 = mw_mirth_type_TZPlus(v18, v19);
			uint64_t v21 = VU64(lpop(&lbl_lbl));
			uint64_t v22 = VU64(lpop(&lbl_tag));
			VAL r23 = pop_resource();
			push_value(v20);
			lpush(&lbl_lbl, MKU64(v21));
			lpush(&lbl_tag, MKU64(v22));
			mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field(r23, v21, v22);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			VAL v26 = mw_mirth_type_TZMulZPlus(v25, v24);
			push_value(v26);
			VAL v27 = mw_mirth_type_T0();
			uint64_t v28 = VU64(lpop(&lbl_tag));
			VAL r29 = pop_resource();
			push_value(v27);
			lpush(&lbl_tag, MKU64(v28));
			mw_mirth_data_Tag_outputZ_type(r29, v28);
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			VAL v32 = mw_mirth_type_TZMulZPlus(v31, v30);
			VAL v33 = pop_value();
			VAL v34 = mw_mirth_type_TZ_ZTo(v33, v32);
			push_value(v34);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v35 = VU64(lpop(&lbl_lbl));
	uint64_t v36 = VU64(lpop(&lbl_tag));
}
static VAL mw_mirth_elab_createZ_projectorsZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	lpush(&lbl_tag, MKU64(x2));
	uint64_t v0 = mw_mirth_data_Tag_data(x2);
	uint64_t v1 = VU64(lpop(&lbl_tag));
	lpush(&lbl_dat, MKU64(v0));
	lpush(&lbl_tag, MKU64(v1));
	VAL v2 = mw_mirth_data_Tag_labelZ_inputs(v1);
	VAL v3 = mw_std_list_List_1_reverse(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		uint64_t v11 = VU64(lpop(&lbl_dat));
		incref(v9);
		push_u64(v11);
		lpush(&lbl_dat, MKU64(v11));
		lpush(&lbl_lbl, v9);
		uint64_t v12 = mw_mirth_label_Label_name(VU64(v9));
		int64_t v13 = 0LL;
		uint64_t v14 = pop_u64();
		VAL v15 = mw_mirth_data_dataZ_qname(v14, v12, v13);
		VAL r16 = pop_resource();
		mw_mirth_name_QName_undefinedZ_softZAsk(r16, v15);
		bool v17 = pop_bool();
		if (v17) {
			uint64_t v18 = VU64(lpop(&lbl_dat));
			uint64_t v19 = VU64(lpop(&lbl_lbl));
			push_u64(v18);
			lpush(&lbl_dat, MKU64(v18));
			lpush(&lbl_lbl, MKU64(v19));
			VAL v20 = mw_mirth_label_Label_ZToStr(v19);
			int64_t v21 = 0LL;
			uint64_t v22 = pop_u64();
			VAL r23 = pop_resource();
			mw_mirth_elab_dataZ_wordZ_newZBang(r23, v22, v20, v21);
			uint64_t v24 = pop_u64();
			uint64_t v25 = VU64(lpop(&lbl_dat));
			uint64_t v26 = VU64(lpop(&lbl_lbl));
			lpush(&lbl_lblz_get, MKU64(v24));
			push_u64(v25);
			lpush(&lbl_dat, MKU64(v25));
			lpush(&lbl_lbl, MKU64(v26));
			VAL v27 = mw_mirth_label_Label_ZToStr(v26);
			STR* v28;
			STRLIT(v28, "!", 1);
			STR* v29 = str_cat(VSTR(v27), v28);
			int64_t v30 = 0LL;
			uint64_t v31 = pop_u64();
			VAL r32 = pop_resource();
			mw_mirth_elab_dataZ_wordZ_newZBang(r32, v31, MKSTR(v29), v30);
			uint64_t v33 = pop_u64();
			uint64_t v34 = VU64(lpop(&lbl_dat));
			uint64_t v35 = VU64(lpop(&lbl_lbl));
			lpush(&lbl_lblz_set, MKU64(v33));
			push_u64(v34);
			lpush(&lbl_dat, MKU64(v34));
			lpush(&lbl_lbl, MKU64(v35));
			VAL v36 = mw_mirth_label_Label_ZToStr(v35);
			int64_t v37 = 1LL;
			uint64_t v38 = pop_u64();
			VAL r39 = pop_resource();
			mw_mirth_elab_dataZ_wordZ_newZBang(r39, v38, v36, v37);
			uint64_t v40 = pop_u64();
			uint64_t v41 = VU64(lpop(&lbl_lblz_get));
			lpush(&lbl_lblz_lens, MKU64(v40));
			lpush(&lbl_lblz_get, MKU64(v41));
			mw_mirth_word_Word_makeZ_inlineZBang(v41);
			uint64_t v42 = VU64(lpop(&lbl_tag));
			uint64_t v43 = VU64(lpop(&lbl_lbl));
			uint64_t v44 = VU64(lpop(&lbl_lblz_get));
			push_u64(v42);
			lpush(&lbl_tag, MKU64(v42));
			push_u64(v43);
			lpush(&lbl_lbl, MKU64(v43));
			lpush(&lbl_lblz_get, MKU64(v44));
			VAL v45 = mtw_mirth_mirth_PropLabel_WordType(v44);
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			VAL v48 = MKNIL;
			VAL v49 = mkcons(v48, v47);
			VAL v50 = mkcons(v49, v46);
			FNPTR v51 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1;
			VAL r52 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v50, v45, r52, MKFNPTR(v51));
			uint64_t v53 = VU64(lpop(&lbl_lblz_get));
			void* v54 = mfld_mirth_word_Word_ZTildectxZ_type(v53);
			VAL v55 = pop_value();
			mut_set(v55, MKPTR(v54));
			uint64_t v56 = VU64(lpop(&lbl_tag));
			uint64_t v57 = VU64(lpop(&lbl_lbl));
			push_u64(v56);
			lpush(&lbl_tag, MKU64(v56));
			push_u64(v57);
			lpush(&lbl_lbl, MKU64(v57));
			lpush(&lbl_lblz_get, MKU64(v53));
			push_u64(v53);
			VAL v58 = mtw_mirth_mirth_PropLabel_WordArrow(v53);
			VAL v59 = pop_value();
			VAL v60 = pop_value();
			VAL v61 = pop_value();
			VAL v62 = MKNIL;
			VAL v63 = mkcons(v62, v61);
			VAL v64 = mkcons(v63, v60);
			VAL v65 = mkcons(v64, v59);
			FNPTR v66 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot66ZRParen_1;
			VAL r67 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v65, v58, r67, MKFNPTR(v66));
			uint64_t v68 = VU64(lpop(&lbl_lblz_get));
			void* v69 = mfld_mirth_word_Word_ZTildearrow(v68);
			VAL v70 = pop_value();
			mut_set(v70, MKPTR(v69));
			uint64_t v71 = VU64(lpop(&lbl_lblz_set));
			lpush(&lbl_lblz_get, MKU64(v68));
			lpush(&lbl_lblz_set, MKU64(v71));
			mw_mirth_word_Word_makeZ_inlineZBang(v71);
			uint64_t v72 = VU64(lpop(&lbl_tag));
			uint64_t v73 = VU64(lpop(&lbl_lbl));
			uint64_t v74 = VU64(lpop(&lbl_lblz_set));
			push_u64(v72);
			lpush(&lbl_tag, MKU64(v72));
			push_u64(v73);
			lpush(&lbl_lbl, MKU64(v73));
			lpush(&lbl_lblz_set, MKU64(v74));
			VAL v75 = mtw_mirth_mirth_PropLabel_WordType(v74);
			VAL v76 = pop_value();
			VAL v77 = pop_value();
			VAL v78 = MKNIL;
			VAL v79 = mkcons(v78, v77);
			VAL v80 = mkcons(v79, v76);
			FNPTR v81 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot86ZRParen_1;
			VAL r82 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v80, v75, r82, MKFNPTR(v81));
			uint64_t v83 = VU64(lpop(&lbl_lblz_set));
			void* v84 = mfld_mirth_word_Word_ZTildectxZ_type(v83);
			VAL v85 = pop_value();
			mut_set(v85, MKPTR(v84));
			uint64_t v86 = VU64(lpop(&lbl_tag));
			uint64_t v87 = VU64(lpop(&lbl_lbl));
			push_u64(v86);
			lpush(&lbl_tag, MKU64(v86));
			push_u64(v87);
			lpush(&lbl_lbl, MKU64(v87));
			lpush(&lbl_lblz_set, MKU64(v83));
			push_u64(v83);
			VAL v88 = mtw_mirth_mirth_PropLabel_WordArrow(v83);
			VAL v89 = pop_value();
			VAL v90 = pop_value();
			VAL v91 = pop_value();
			VAL v92 = MKNIL;
			VAL v93 = mkcons(v92, v91);
			VAL v94 = mkcons(v93, v90);
			VAL v95 = mkcons(v94, v89);
			FNPTR v96 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot107ZRParen_1;
			VAL r97 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v95, v88, r97, MKFNPTR(v96));
			uint64_t v98 = VU64(lpop(&lbl_lblz_set));
			void* v99 = mfld_mirth_word_Word_ZTildearrow(v98);
			VAL v100 = pop_value();
			mut_set(v100, MKPTR(v99));
			uint64_t v101 = VU64(lpop(&lbl_lblz_lens));
			lpush(&lbl_lblz_set, MKU64(v98));
			lpush(&lbl_lblz_lens, MKU64(v101));
			mw_mirth_word_Word_makeZ_inlineZBang(v101);
			uint64_t v102 = VU64(lpop(&lbl_tag));
			uint64_t v103 = VU64(lpop(&lbl_lbl));
			uint64_t v104 = VU64(lpop(&lbl_lblz_lens));
			push_u64(v102);
			lpush(&lbl_tag, MKU64(v102));
			push_u64(v103);
			lpush(&lbl_lbl, MKU64(v103));
			lpush(&lbl_lblz_lens, MKU64(v104));
			VAL v105 = mtw_mirth_mirth_PropLabel_WordType(v104);
			VAL v106 = pop_value();
			VAL v107 = pop_value();
			VAL v108 = MKNIL;
			VAL v109 = mkcons(v108, v107);
			VAL v110 = mkcons(v109, v106);
			FNPTR v111 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot127ZRParen_1;
			VAL r112 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v110, v105, r112, MKFNPTR(v111));
			uint64_t v113 = VU64(lpop(&lbl_lblz_lens));
			void* v114 = mfld_mirth_word_Word_ZTildectxZ_type(v113);
			VAL v115 = pop_value();
			mut_set(v115, MKPTR(v114));
			lpush(&lbl_lblz_lens, MKU64(v113));
			push_u64(v113);
			VAL v116 = mtw_mirth_mirth_PropLabel_WordParams(v113);
			FNPTR v117 = &mb_mirth_elab_createZ_projectorsZBang_15;
			VAL r118 = pop_resource();
			VAL v119 = pop_value();
			mw_mirth_mirth_PropLabel_prop_1(v119, v116, r118, MKFNPTR(v117));
			uint64_t v120 = VU64(lpop(&lbl_lblz_lens));
			void* v121 = mfld_mirth_word_Word_ZTildeparams(v120);
			VAL v122 = pop_value();
			mut_set(v122, MKPTR(v121));
			uint64_t v123 = VU64(lpop(&lbl_dat));
			uint64_t v124 = VU64(lpop(&lbl_lblz_get));
			uint64_t v125 = VU64(lpop(&lbl_lblz_set));
			push_u64(v123);
			lpush(&lbl_dat, MKU64(v123));
			push_u64(v124);
			lpush(&lbl_lblz_get, MKU64(v124));
			push_u64(v125);
			lpush(&lbl_lblz_set, MKU64(v125));
			lpush(&lbl_lblz_lens, MKU64(v120));
			push_u64(v120);
			VAL v126 = mtw_mirth_mirth_PropLabel_WordArrow(v120);
			VAL v127 = pop_value();
			VAL v128 = pop_value();
			VAL v129 = pop_value();
			VAL v130 = pop_value();
			VAL v131 = MKNIL;
			VAL v132 = mkcons(v131, v130);
			VAL v133 = mkcons(v132, v129);
			VAL v134 = mkcons(v133, v128);
			VAL v135 = mkcons(v134, v127);
			FNPTR v136 = &mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot215ZRParen_1;
			VAL r137 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v135, v126, r137, MKFNPTR(v136));
			uint64_t v138 = VU64(lpop(&lbl_lblz_lens));
			void* v139 = mfld_mirth_word_Word_ZTildearrow(v138);
			VAL v140 = pop_value();
			mut_set(v140, MKPTR(v139));
			uint64_t v141 = VU64(lpop(&lbl_lblz_get));
			uint64_t v142 = VU64(lpop(&lbl_lblz_set));
		} else {
		}
		uint64_t v143 = VU64(lpop(&lbl_lbl));
		mw_std_list_List_1_uncons(v10);
		VAL v144 = pop_value();
		VAL v145 = pop_value();
		push_value(v144);
		push_value(v145);
	}
	VAL v146 = pop_value();
	decref(v146);
	VAL v147 = pop_value();
	decref(v147);
	uint64_t v148 = VU64(lpop(&lbl_dat));
	uint64_t v149 = VU64(lpop(&lbl_tag));
	VAL r150 = pop_resource();
	return r150;
}
static void mw_mirth_elab_expectZ_tokenZ_arrow (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_token_Token_arrowZAsk(x2);
	if (((bool)v0)) {
	} else {
		STR* v1;
		STRLIT(v1, "Expected arrow.", 15);
		VAL r2 = pop_resource();
		uint64_t v3 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v3, MKSTR(v1), r2);
	}
}
static void mw_mirth_elab_parseZ_alias (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	uint64_t v0 = mw_mirth_token_Token_succ(x2);
	VAL v1 = mw_mirth_token_Token_lparenZAsk(v0);
	int64_t v2 = mw_std_maybe_Maybe_1_ZToBool(v1);
	if (((bool)v2)) {
		uint64_t v3 = pop_u64();
		lpush(&lbl_hasZ_paren, MKI64(v2));
		uint64_t v4 = mw_mirth_token_Token_next(v3);
		VAL r5 = pop_resource();
		push_u64(v4);
		mw_mirth_token_Token_argsZ_2(v3, r5);
		uint64_t v6 = pop_u64();
		uint64_t v7 = pop_u64();
		lpush(&lbl_target, MKU64(v6));
		lpush(&lbl_head, MKU64(v7));
	} else {
		uint64_t v8 = pop_u64();
		lpush(&lbl_hasZ_paren, MKI64(v2));
		uint64_t v9 = mw_mirth_token_Token_next(v8);
		lpush(&lbl_head, MKU64(v9));
		uint64_t v10 = mw_mirth_token_Token_next(v9);
		lpush(&lbl_target, MKU64(v10));
		uint64_t v11 = mw_mirth_token_Token_next(v10);
		push_u64(v11);
	}
	uint64_t v12 = VU64(lpop(&lbl_head));
	lpush(&lbl_head, MKU64(v12));
	VAL v13 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(v12);
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v13);
			decref(v14);
		} break;
		case 0LL: { // None
			uint64_t v15 = VU64(lpop(&lbl_head));
			STR* v16;
			STRLIT(v16, "expected alias name", 19);
			VAL r17 = pop_resource();
			lpush(&lbl_head, MKU64(v15));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v15, MKSTR(v16), r17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v18 = VU64(lpop(&lbl_target));
	lpush(&lbl_target, MKU64(v18));
	VAL v19 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(v18);
	switch (get_data_tag(v19)) {
		case 1LL: { // Some
			VAL v20 = mtp_std_maybe_Maybe_1_Some(v19);
			decref(v20);
		} break;
		case 0LL: { // None
			uint64_t v21 = VU64(lpop(&lbl_target));
			STR* v22;
			STRLIT(v22, "expected alias target, which must be a name", 43);
			VAL r23 = pop_resource();
			lpush(&lbl_target, MKU64(v21));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v21, MKSTR(v22), r23);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v24 = VU64(lpop(&lbl_target));
	VAL r25 = pop_resource();
	lpush(&lbl_target, MKU64(v24));
	VAL v26 = (mw_mirth_token_Token_argsZ_0(v24, r25));
	int64_t v27 = VI64(lpop(&lbl_hasZ_paren));
	if (((bool)v27)) {
		uint64_t v28 = VU64(lpop(&lbl_head));
		push_resource(v26);
		lpush(&lbl_hasZ_paren, MKI64(v27));
		lpush(&lbl_head, MKU64(v28));
		uint64_t v29 = mw_mirth_token_Token_next(v28);
		int64_t v30 = mw_mirth_token_Token_argZ_endZAsk(v29);
		if (((bool)v30)) {
		} else {
			uint64_t v31 = VU64(lpop(&lbl_head));
			STR* v32;
			STRLIT(v32, "expected comma after alias name", 31);
			VAL r33 = pop_resource();
			lpush(&lbl_head, MKU64(v31));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v31, MKSTR(v32), r33);
		}
		uint64_t v34 = VU64(lpop(&lbl_target));
		lpush(&lbl_target, MKU64(v34));
		uint64_t v35 = mw_mirth_token_Token_succ(v34);
		int64_t v36 = mw_mirth_token_Token_argZ_endZAsk(v35);
		if (((bool)v36)) {
		} else {
			uint64_t v37 = VU64(lpop(&lbl_head));
			STR* v38;
			STRLIT(v38, "expected end of arguments after alias target", 44);
			VAL r39 = pop_resource();
			lpush(&lbl_head, MKU64(v37));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v37, MKSTR(v38), r39);
		}
	} else {
		push_resource(v26);
		lpush(&lbl_hasZ_paren, MKI64(v27));
	}
	int64_t v40 = VI64(lpop(&lbl_hasZ_paren));
}
static void mw_mirth_elab_elabZ_aliasZBang (VAL x1, uint64_t x2) {
	mw_mirth_elab_parseZ_alias(x1, x2);
	uint64_t v0 = VU64(lpop(&lbl_head));
	VAL r1 = pop_resource();
	mw_mirth_elab_elabZ_defZ_head(r1, v0);
	int64_t v2 = VI64(lpop(&lbl_arity));
	uint64_t v3 = VU64(lpop(&lbl_name));
	uint64_t v4 = VU64(lpop(&lbl_head));
	VAL r5 = pop_resource();
	mw_mirth_alias_Alias_newZBang(r5, v4, v3, v2);
	uint64_t v6 = pop_u64();
	push_u64(v6);
	VAL v7 = mtw_mirth_mirth_PropLabel_AliasQName(v6);
	VAL v8 = lpop(&lbl_state);
	VAL v9 = mtw_mirth_mirth_Prop_1_Prop(v7, v8);
	VAL v10 = pop_value();
	incref(v10);
	void* v11 = mfld_mirth_alias_Alias_ZTildeqname(VU64(v10));
	mut_set(v9, MKPTR(v11));
	uint64_t v12 = VU64(lpop(&lbl_target));
	incref(v10);
	incref(v10);
	push_value(v10);
	push_u64(v12);
	push_value(v10);
	VAL v13 = mtw_mirth_mirth_PropLabel_AliasTarget(VU64(v10));
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	VAL v16 = MKNIL;
	VAL v17 = mkcons(v16, v15);
	VAL v18 = mkcons(v17, v14);
	FNPTR v19 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_aliasZBangZDot16ZRParen_1;
	VAL r20 = pop_resource();
	mw_mirth_mirth_PropLabel_prop_1(v18, v13, r20, MKFNPTR(v19));
	VAL v21 = pop_value();
	uint64_t v22 = pop_u64();
	void* v23 = mfld_mirth_alias_Alias_ZTildetarget(v22);
	mut_set(v21, MKPTR(v23));
}
static void mw_mirth_elab_elabZ_defZ_missingZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_token_Token_args(x2);
	int64_t v1 = mw_std_list_List_1_len(v0);
	int64_t v2 = 3LL;
	push_i64(v1);
	int64_t v3 = mw_std_prim_Int_ZToNat(v2);
	int64_t v4 = pop_i64();
	bool v5 = (v4 < v3);
	if (v5) {
		STR* v6;
		STRLIT(v6, "def-missing expects at least three arguments", 44);
		VAL r7 = pop_resource();
		uint64_t v8 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v8, MKSTR(v6), r7);
	} else {
	}
	uint64_t v9 = pop_u64();
	push_u64(v9);
	uint64_t v10 = mw_mirth_token_Token_succ(v9);
	uint64_t v11 = mw_mirth_token_Token_succ(v10);
	VAL r12 = pop_resource();
	mw_mirth_elab_elabZ_defZ_qname(r12, v11);
	VAL v13 = pop_value();
	VAL r14 = pop_resource();
	mw_mirth_name_QName_definedZ_hardZAsk(r14, v13);
	bool v15 = pop_bool();
	if (v15) {
		uint64_t v16 = pop_u64();
		uint64_t v17 = mw_mirth_token_Token_next(v16);
		push_u64(v17);
	} else {
		uint64_t v18 = pop_u64();
		VAL r19 = pop_resource();
		mw_mirth_elab_elabZ_defZBang(r19, v18);
	}
}
static void mw_mirth_elab_elabZ_inlineZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	uint64_t v0 = mw_mirth_token_Token_next(x1);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_1(x1, r1);
	uint64_t v2 = pop_u64();
	VAL r3 = pop_resource();
	int64_t v4 = VI64(VTUP(r3)->cells[3]);
	int64_t v5 = 1LL /* True */;
	VTUP(r3)->cells[3] = MKI64(v5);
	push_i64(v4);
	push_u64(v2);
	push_resource(r3);
	while(1) {
		uint64_t v6 = pop_u64();
		push_u64(v6);
		int64_t v7 = mw_mirth_token_Token_argZ_endZAsk(v6);
		bool v8 = !((bool)v7);
		if (!v8) break;
		VAL r9 = pop_resource();
		VAL r10 = pop_resource();
		uint64_t v11 = pop_u64();
		mw_mirth_elab_elabZ_moduleZ_declZBang(v11, r10, r9);
	}
	uint64_t v12 = pop_u64();
	VAL r13 = pop_resource();
	int64_t v14 = pop_i64();
	VTUP(r13)->cells[3] = MKI64(v14);
	push_resource(r13);
}
static void mw_mirth_elab_parseZ_def (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_token_Token_args(x2);
	int64_t v1 = mw_std_list_List_1_emptyZAsk(v0);
	if (((bool)v1)) {
		uint64_t v2 = pop_u64();
		uint64_t v3 = mw_mirth_token_Token_next(v2);
		lpush(&lbl_head, MKU64(v3));
		uint64_t v4 = mw_mirth_token_Token_next(v3);
		push_u64(v4);
		VAL v5 = mw_mirth_token_Token_lsquareZAsk(v4);
		switch (get_data_tag(v5)) {
			case 1LL: { // Some
				VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
				decref(v6);
				uint64_t v7 = pop_u64();
				VAL r8 = pop_resource();
				push_u64(v7);
				mw_mirth_token_Token_argsZ_1(v7, r8);
				VAL v9 = pop_value();
				VAL v10 = mtw_std_maybe_Maybe_1_Some(v9);
				uint64_t v11 = pop_u64();
				lpush(&lbl_sigZAsk, v10);
				uint64_t v12 = mw_mirth_token_Token_next(v11);
				push_u64(v12);
			} break;
			case 0LL: { // None
				int64_t v13 = 0LL /* None */;
				lpush(&lbl_sigZAsk, MKI64(v13));
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v14 = pop_u64();
		push_u64(v14);
		VAL v15 = mw_mirth_token_Token_lcurlyZAsk(v14);
		switch (get_data_tag(v15)) {
			case 1LL: { // Some
				VAL v16 = mtp_std_maybe_Maybe_1_Some(v15);
				decref(v16);
			} break;
			case 0LL: { // None
				STR* v17;
				STRLIT(v17, "expected { ... }", 16);
				VAL r18 = pop_resource();
				uint64_t v19 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v19, MKSTR(v17), r18);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v20 = pop_u64();
		VAL r21 = pop_resource();
		push_u64(v20);
		mw_mirth_token_Token_argsZPlus(v20, r21);
		VAL v22 = pop_value();
		uint64_t v23 = pop_u64();
		lpush(&lbl_body, v22);
		uint64_t v24 = mw_mirth_token_Token_next(v23);
		push_u64(v24);
	} else {
		uint64_t v25 = pop_u64();
		uint64_t v26 = mw_mirth_token_Token_next(v25);
		push_u64(v26);
		push_u64(v25);
		VAL v27 = mw_mirth_token_Token_args(v25);
		incref(v27);
		push_value(v27);
		int64_t v28 = mw_std_list_List_1_len(v27);
		int64_t v29 = 3LL;
		push_i64(v28);
		int64_t v30 = mw_std_prim_Int_ZToNat(v29);
		int64_t v31 = pop_i64();
		bool v32 = (v31 < v30);
		if (v32) {
			VAL v33 = pop_value();
			decref(v33);
			STR* v34;
			STRLIT(v34, "def(...) expects at least three arguments", 41);
			VAL r35 = pop_resource();
			uint64_t v36 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v36, MKSTR(v34), r35);
		} else {
		}
		VAL v37 = pop_value();
		VAL v38 = pop_value();
		decref(v38);
		VAL v39 = mw_std_list_List_1_ZToListZPlus(v37);
		VAL v40 = mw_std_maybe_Maybe_1_unwrap(v39);
		mw_std_list_ListZPlus_1_uncons(v40);
		VAL v41 = pop_value();
		uint64_t v42 = pop_u64();
		lpush(&lbl_head, MKU64(v42));
		VAL v43 = mw_std_list_List_1_ZToListZPlus(v41);
		VAL v44 = mw_std_maybe_Maybe_1_unwrap(v43);
		mw_std_list_ListZPlus_1_uncons(v44);
		VAL v45 = pop_value();
		VAL v46 = pop_value();
		VAL v47 = mtw_std_maybe_Maybe_1_Some(v46);
		lpush(&lbl_sigZAsk, v47);
		VAL v48 = mw_std_list_List_1_ZToListZPlus(v45);
		VAL v49 = mw_std_maybe_Maybe_1_unwrap(v48);
		uint64_t v50 = VU64(lpop(&lbl_head));
		lpush(&lbl_body, v49);
		lpush(&lbl_head, MKU64(v50));
		uint64_t v51 = mw_mirth_token_Token_next(v50);
		int64_t v52 = mw_mirth_token_Token_argZ_endZAsk(v51);
		if (((bool)v52)) {
		} else {
			uint64_t v53 = VU64(lpop(&lbl_head));
			lpush(&lbl_head, MKU64(v53));
			uint64_t v54 = mw_mirth_token_Token_next(v53);
			STR* v55;
			STRLIT(v55, "expected comma after word name", 30);
			VAL r56 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v54, MKSTR(v55), r56);
		}
	}
	VAL v57 = lpop(&lbl_body);
	mw_std_list_ListZPlus_1_uncons(v57);
	VAL v58 = pop_value();
	int64_t v59 = mw_std_list_List_1_emptyZAsk(v58);
	if (((bool)v59)) {
		int64_t v60 = 1LL /* True */;
		push_i64(v60);
	} else {
		uint64_t v61 = pop_u64();
		push_u64(v61);
		VAL v62 = mw_mirth_token_Token_runZ_arrowZAsk(v61);
		int64_t v63 = mw_std_maybe_Maybe_1_ZToBool(v62);
		push_i64(v63);
	}
	bool v64 = pop_bool();
	if (v64) {
	} else {
		STR* v65;
		STRLIT(v65, "expected match case", 19);
		VAL r66 = pop_resource();
		uint64_t v67 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v67, MKSTR(v65), r66);
	}
	uint64_t v68 = pop_u64();
	VAL v69 = lpop(&lbl_sigZAsk);
	uint64_t v70 = VU64(lpop(&lbl_head));
	VAL v71 = mtw_mirth_elab_SyntaxDef_SyntaxDef(v70, v69, v68);
	push_value(v71);
}
static void mw_mirth_elab_elabZ_defZBang (VAL x1, uint64_t x2) {
	mw_mirth_elab_parseZ_def(x1, x2);
	VAL v0 = pop_value();
	mtp_mirth_elab_SyntaxDef_SyntaxDef(v0);
	uint64_t v1 = VU64(lpop(&lbl_head));
	VAL r2 = pop_resource();
	mw_mirth_elab_elabZ_defZ_head(r2, v1);
	VAL r3 = pop_resource();
	int64_t v4 = VI64(lpop(&lbl_arity));
	uint64_t v5 = VU64(lpop(&lbl_name));
	uint64_t v6 = VU64(lpop(&lbl_body));
	VAL v7 = lpop(&lbl_sigZAsk);
	uint64_t v8 = VU64(lpop(&lbl_head));
	mw_mirth_word_Word_newZBang(v8, v7, v6, v5, v4, r3);
	uint64_t v9 = pop_u64();
	lpush(&lbl_word, MKU64(v9));
	VAL v10 = mtw_mirth_mirth_PropLabel_WordQName(v9);
	VAL v11 = lpop(&lbl_state);
	VAL v12 = mtw_mirth_mirth_Prop_1_Prop(v10, v11);
	uint64_t v13 = VU64(lpop(&lbl_word));
	void* v14 = mfld_mirth_word_Word_ZTildeqname(v13);
	mut_set(v12, MKPTR(v14));
	VAL r15 = pop_resource();
	int64_t v16 = VI64(VTUP(r15)->cells[3]);
	void* v17 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(v13);
	mut_set(MKI64(v16), MKPTR(v17));
	push_resource(r15);
	push_u64(v13);
	lpush(&lbl_word, MKU64(v13));
	VAL v18 = mtw_mirth_mirth_PropLabel_WordType(v13);
	FNPTR v19 = &mb_mirth_elab_elabZ_defZBang_0;
	VAL r20 = pop_resource();
	VAL v21 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v21, v18, r20, MKFNPTR(v19));
	uint64_t v22 = VU64(lpop(&lbl_word));
	void* v23 = mfld_mirth_word_Word_ZTildectxZ_type(v22);
	VAL v24 = pop_value();
	mut_set(v24, MKPTR(v23));
	push_u64(v22);
	lpush(&lbl_word, MKU64(v22));
	VAL v25 = mtw_mirth_mirth_PropLabel_WordParams(v22);
	FNPTR v26 = &mb_mirth_elab_elabZ_defZBang_2;
	VAL r27 = pop_resource();
	VAL v28 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v28, v25, r27, MKFNPTR(v26));
	uint64_t v29 = VU64(lpop(&lbl_word));
	void* v30 = mfld_mirth_word_Word_ZTildeparams(v29);
	VAL v31 = pop_value();
	mut_set(v31, MKPTR(v30));
	push_u64(v29);
	lpush(&lbl_word, MKU64(v29));
	VAL v32 = mtw_mirth_mirth_PropLabel_WordArrow(v29);
	FNPTR v33 = &mb_mirth_elab_elabZ_defZBang_3;
	VAL r34 = pop_resource();
	VAL v35 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v35, v32, r34, MKFNPTR(v33));
	uint64_t v36 = VU64(lpop(&lbl_word));
	void* v37 = mfld_mirth_word_Word_ZTildearrow(v36);
	VAL v38 = pop_value();
	mut_set(v38, MKPTR(v37));
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x3)->cells[7]);
	incref(v0);
	decref(x3);
	push_resource(x1);
	push_u64(x2);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		uint64_t v8 = pop_u64();
		VAL r9 = pop_resource();
		push_u64(v8);
		VAL v10 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang(r9, v8, v6));
		push_resource(v10);
		mw_std_list_List_1_uncons(v7);
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	uint64_t v15 = pop_u64();
	VAL r16 = pop_resource();
	return r16;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang (VAL x1, uint64_t x2, VAL x3) {
	push_resource(x1);
	push_u64(x2);
	push_value(x3);
	int64_t v0 = mw_mirth_word_Word_preferZ_inlineZAsk(x2);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		VAL v2 = pop_value();
		incref(v2);
		incref(v1);
		VAL v3 = VVAL(VTUP(v1)->cells[4]);
		incref(v3);
		decref(v1);
		VAL r4 = pop_resource();
		push_value(v2);
		push_value(v1);
		VAL v5 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang(r4, VU64(v2), v3));
		VAL v6 = pop_value();
		VAL v7 = VVAL(VTUP(v6)->cells[5]);
		incref(v7);
		decref(v6);
		push_resource(v5);
		mw_std_list_List_1_uncons(v7);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
		while(1) {
			VAL v10 = pop_value();
			incref(v10);
			push_value(v10);
			int64_t v11 = mw_std_maybe_Maybe_1_someZAsk(v10);
			if (!((bool)v11)) break;
			VAL v12 = pop_value();
			VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
			VAL v14 = pop_value();
			uint64_t v15 = pop_u64();
			VAL r16 = pop_resource();
			push_u64(v15);
			VAL v17 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang(r16, v15, VU64(v13)));
			push_resource(v17);
			mw_std_list_List_1_uncons(v14);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			push_value(v18);
			push_value(v19);
		}
		VAL v20 = pop_value();
		decref(v20);
		VAL v21 = pop_value();
		decref(v21);
		uint64_t v22 = pop_u64();
	} else {
		VAL v23 = pop_value();
		decref(v23);
		VAL v24 = pop_value();
		decref(v24);
	}
	VAL r25 = pop_resource();
	return r25;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang (VAL x1, uint64_t x2, uint64_t x3) {
	push_u64(x2);
	mw_mirth_arrow_Block_arrow(x1, x3);
	VAL v0 = pop_value();
	uint64_t v1 = pop_u64();
	VAL r2 = pop_resource();
	VAL v3 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(r2, v1, v0));
	return v3;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang (VAL x1, uint64_t x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 15LL: { // OpBlockRun
			push_resource(x1);
			push_u64(x2);
			uint64_t v0 = mtp_mirth_arrow_Op_OpBlockRun(x3);
			VAL r1 = pop_resource();
			mw_mirth_arrow_Block_arrow(r1, v0);
			VAL v2 = pop_value();
			uint64_t v3 = pop_u64();
			VAL r4 = pop_resource();
			VAL v5 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(r4, v3, v2));
			push_resource(v5);
		} break;
		case 2LL: { // OpWord
			push_resource(x1);
			push_u64(x2);
			uint64_t v6 = mtp_mirth_arrow_Op_OpWord(x3);
			VAL v7 = pop_value();
			incref(v7);
			push_value(v7);
			push_u64(v6);
			int64_t v8 = mw_mirth_word_Word_ZEqualZEqual(VU64(v7), v6);
			if (((bool)v8)) {
				uint64_t v9 = pop_u64();
				uint64_t v10 = pop_u64();
				VAL r11 = pop_resource();
				VAL v12 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang(r11, v10));
				push_resource(v12);
			} else {
				uint64_t v13 = pop_u64();
				push_u64(v13);
				int64_t v14 = mw_mirth_word_Word_preferZ_inlineZAsk(v13);
				if (((bool)v14)) {
					uint64_t v15 = pop_u64();
					void* v16 = mfld_mirth_word_Word_ZTildearrow(v15);
					VAL r17 = pop_resource();
					mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v16), r17);
					VAL v18 = pop_value();
					switch (get_data_tag(v18)) {
						case 1LL: { // Some
							VAL v19 = mtp_std_maybe_Maybe_1_Some(v18);
							uint64_t v20 = pop_u64();
							VAL r21 = pop_resource();
							VAL v22 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(r21, v20, v19));
							push_resource(v22);
						} break;
						case 0LL: { // None
							uint64_t v23 = pop_u64();
							VAL r24 = pop_resource();
							VAL v25 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang(r24, v23));
							push_resource(v25);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} else {
					VAL v26 = pop_value();
					decref(v26);
					VAL v27 = pop_value();
					decref(v27);
				}
			}
		} break;
		case 11LL: { // OpMatch
			push_resource(x1);
			push_u64(x2);
			VAL v28 = mtp_mirth_arrow_Op_OpMatch(x3);
			VAL v29 = VVAL(VTUP(v28)->cells[7]);
			incref(v29);
			decref(v28);
			mw_std_list_List_1_uncons(v29);
			VAL v30 = pop_value();
			VAL v31 = pop_value();
			push_value(v30);
			push_value(v31);
			while(1) {
				VAL v32 = pop_value();
				incref(v32);
				push_value(v32);
				int64_t v33 = mw_std_maybe_Maybe_1_someZAsk(v32);
				if (!((bool)v33)) break;
				VAL v34 = pop_value();
				VAL v35 = mw_std_maybe_Maybe_1_unwrap(v34);
				VAL v36 = pop_value();
				uint64_t v37 = pop_u64();
				VAL v38 = VVAL(VTUP(v35)->cells[2]);
				incref(v38);
				decref(v35);
				VAL r39 = pop_resource();
				push_u64(v37);
				VAL v40 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(r39, v37, v38));
				push_resource(v40);
				mw_std_list_List_1_uncons(v36);
				VAL v41 = pop_value();
				VAL v42 = pop_value();
				push_value(v41);
				push_value(v42);
			}
			VAL v43 = pop_value();
			decref(v43);
			VAL v44 = pop_value();
			decref(v44);
			uint64_t v45 = pop_u64();
		} break;
		case 12LL: { // OpLambda
			push_resource(x1);
			push_u64(x2);
			VAL v46 = mtp_mirth_arrow_Op_OpLambda(x3);
			VAL v47 = VVAL(VTUP(v46)->cells[5]);
			incref(v47);
			decref(v46);
			uint64_t v48 = pop_u64();
			VAL r49 = pop_resource();
			VAL v50 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(r49, v48, v47));
			push_resource(v50);
		} break;
		default: {
			decref(x3);
			push_resource(x1);
		} break;
	}
	VAL r51 = pop_resource();
	return r51;
}
static VAL mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_word_Word_preferZ_inlineZAsk(x2);
	if (((bool)v0)) {
		int64_t v1 = 0LL /* False */;
		VAL v2 = pop_value();
		incref(v2);
		void* v3 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(VU64(v2));
		mut_set(MKI64(v1), MKPTR(v3));
		uint64_t v4 = mw_mirth_word_Word_head(VU64(v2));
		STR* v5;
		STRLIT(v5, "recursive word cannot be inlined", 32);
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang(v4, MKSTR(v5), r6));
		push_resource(v7);
	} else {
		uint64_t v8 = pop_u64();
	}
	VAL r9 = pop_resource();
	return r9;
}
static void mw_mirth_elab_elabZ_defZ_paramsZBang (VAL x1, uint64_t x2) {
	int64_t v0 = 0LL /* Nil */;
	push_u64(x2);
	push_i64(v0);
	mw_mirth_word_Word_type(x2, x1);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v1);
	uint64_t v4 = mw_mirth_word_Word_head(VU64(v3));
	VAL v5 = pop_value();
	mw_mirth_type_ArrowType_unpack(v5);
	VAL v6 = pop_value();
	decref(v6);
	VAL v7 = mw_mirth_token_Token_args(v4);
	VAL v8 = mw_std_list_List_1_reverse(v7);
	mw_std_list_List_1_uncons(v8);
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	while(1) {
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		int64_t v12 = mw_std_maybe_Maybe_1_someZAsk(v11);
		if (!((bool)v12)) break;
		VAL v13 = pop_value();
		VAL v14 = mw_std_maybe_Maybe_1_unwrap(v13);
		VAL v15 = pop_value();
		incref(v14);
		push_value(v14);
		int64_t v16 = mw_mirth_token_Token_sigZ_paramZ_nameZAsk(VU64(v14));
		if (((bool)v16)) {
		} else {
			STR* v17;
			STRLIT(v17, "expected parameter name", 23);
			VAL r18 = pop_resource();
			uint64_t v19 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v19, MKSTR(v17), r18);
		}
		uint64_t v20 = pop_u64();
		push_u64(v20);
		uint64_t v21 = mw_mirth_token_Token_succ(v20);
		push_u64(v21);
		int64_t v22 = mw_mirth_token_Token_runZ_endZAsk(v21);
		if (((bool)v22)) {
			uint64_t v23 = pop_u64();
		} else {
			STR* v24;
			STRLIT(v24, "expected right paren or comma", 29);
			VAL r25 = pop_resource();
			uint64_t v26 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v26, MKSTR(v24), r25);
		}
		uint64_t v27 = pop_u64();
		VAL v28 = pop_value();
		VAL r29 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang(r29, v28, v27);
		VAL v30 = pop_value();
		VAL v31 = pop_value();
		incref(v31);
		push_value(v31);
		push_value(v30);
		VAL v32 = mw_mirth_type_Type_morphismZAsk(v31);
		switch (get_data_tag(v32)) {
			case 1LL: { // Some
				VAL v33 = mtp_std_maybe_Maybe_1_Some(v32);
				decref(v33);
			} break;
			case 0LL: { // None
				STR* v34;
				STRLIT(v34, "need function type for param", 28);
				VAL r35 = pop_resource();
				uint64_t v36 = pop_u64();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v36, MKSTR(v34), r35);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		uint64_t v37 = pop_u64();
		VAL v38 = mw_mirth_token_Token_nameZAsk(v37);
		VAL v39 = mw_std_maybe_Maybe_1_unwrap(v38);
		VAL v40 = pop_value();
		uint64_t v41 = mw_mirth_var_Var_newZ_autoZ_runZBang(v40, VU64(v39));
		VAL v42 = pop_value();
		VAL v43 = pop_value();
		VAL v44 = mtw_std_list_List_1_Cons(MKU64(v41), v43);
		push_value(v44);
		push_value(v42);
		mw_std_list_List_1_uncons(v15);
		VAL v45 = pop_value();
		VAL v46 = pop_value();
		push_value(v45);
		push_value(v46);
	}
	VAL v47 = pop_value();
	decref(v47);
	VAL v48 = pop_value();
	decref(v48);
	VAL v49 = pop_value();
	decref(v49);
}
static void mw_mirth_elab_elabZ_defZ_bodyZBang (VAL x1, VAL x2, VAL x3) {
	push_value(x1);
	push_resource(x2);
	mw_mirth_elab_abZ_tokenZAt(x3);
	uint64_t v0 = pop_u64();
	VAL v1 = mw_mirth_token_Token_runZ_arrowZAsk(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			decref(v2);
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 0LL: { // None
			VAL r4 = pop_resource();
			mw_mirth_elab_abZ_tokenZAt(r4);
			uint64_t v5 = pop_u64();
			VAL v6 = mw_mirth_token_Token_lcurlyZAsk(v5);
			int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
			push_i64(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v8 = pop_bool();
	if (v8) {
		VAL v9 = pop_value();
		incref(v9);
		VAL r10 = pop_resource();
		push_value(v9);
		lpush(&lbl_cod, v9);
		mw_mirth_elab_abZ_tokenZAt(r10);
		uint64_t v11 = pop_u64();
		VAL r12 = pop_resource();
		VAL r13 = pop_resource();
		VAL v14 = lpop(&lbl_cod);
		mw_mirth_elab_elabZ_matchZ_atZBang(v14, v11, r13, r12);
	} else {
		VAL r15 = pop_resource();
		VAL r16 = pop_resource();
		mw_mirth_elab_elabZ_atomsZBang(r16, r15);
	}
}
static void mw_mirth_elab_parseZ_externalZ_decl (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	push_u64(v0);
	uint64_t v1 = mw_mirth_token_Token_succ(x2);
	push_u64(v1);
	VAL v2 = mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk(v1);
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
			decref(v3);
		} break;
		case 0LL: { // None
			uint64_t v4 = pop_u64();
			uint64_t v5 = mw_mirth_token_Token_pred(v4);
			STR* v6;
			STRLIT(v6, "", 0);
			int64_t v7 = 36LL /* FGCyan */;
			push_u64(v5);
			VAL v8 = (mw_std_terminal_Sgr_emitZThen(MKI64(v7), MKSTR(v6)));
			STR* v9;
			STRLIT(v9, "external", 8);
			VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v9), v8));
			int64_t v11 = 0LL /* Reset */;
			VAL v12 = (mw_std_terminal_Sgr_emitZThen(MKI64(v11), v10));
			STR* v13;
			STRLIT(v13, " requires arguments", 19);
			VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v13), v12));
			VAL r15 = pop_resource();
			uint64_t v16 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v16, v14, r15);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v17 = 0LL /* Nil */;
	VAL v18 = mw_std_list_List_1_reverse(MKI64(v17));
	uint64_t v19 = pop_u64();
	push_resource(v18);
	uint64_t v20 = mw_mirth_token_Token_succ(v19);
	push_u64(v20);
	while(1) {
		uint64_t v21 = pop_u64();
		push_u64(v21);
		int64_t v22 = mw_mirth_token_Token_argsZ_endZAsk(v21);
		bool v23 = !((bool)v22);
		if (!v23) break;
		VAL r24 = pop_resource();
		uint64_t v25 = pop_u64();
		VAL r26 = pop_resource();
		mw_mirth_elab_parseZ_externalZ_declZ_part(r26, v25);
		VAL v27 = pop_value();
		VAL v28 = mtw_std_list_List_1_Cons(v27, r24);
		push_resource(v28);
	}
	uint64_t v29 = pop_u64();
	VAL r30 = pop_resource();
	VAL v31 = mw_std_list_List_1_reverse(r30);
	push_value(v31);
}
static void mw_mirth_elab_parseZ_externalZ_declZ_part (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_token_Token_strZAsk(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			uint64_t v2 = pop_u64();
			lpush(&lbl_code, v1);
			lpush(&lbl_token, MKU64(v2));
			uint64_t v3 = mw_mirth_token_Token_succ(v2);
			VAL v4 = lpop(&lbl_code);
			uint64_t v5 = VU64(lpop(&lbl_token));
			push_u64(v3);
			VAL v6 = mtw_mirth_elab_ExternalDeclPart_EDPCode(v5, v4);
			push_value(v6);
		} break;
		case 0LL: { // None
			uint64_t v7 = pop_u64();
			lpush(&lbl_head, MKU64(v7));
			push_u64(v7);
			VAL v8 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(v7);
			switch (get_data_tag(v8)) {
				case 1LL: { // Some
					VAL v9 = mtp_std_maybe_Maybe_1_Some(v8);
					decref(v9);
				} break;
				case 0LL: { // None
					STR* v10;
					STRLIT(v10, "expected external word name", 27);
					VAL r11 = pop_resource();
					uint64_t v12 = pop_u64();
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v12, MKSTR(v10), r11);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			uint64_t v13 = pop_u64();
			uint64_t v14 = mw_mirth_token_Token_succ(v13);
			push_u64(v14);
			int64_t v15 = mw_mirth_token_Token_arrowZAsk(v14);
			if (((bool)v15)) {
				uint64_t v16 = pop_u64();
				uint64_t v17 = mw_mirth_token_Token_succ(v16);
				push_u64(v17);
				VAL v18 = mw_mirth_token_Token_nameZAsk(v17);
				switch (get_data_tag(v18)) {
					case 1LL: { // Some
						VAL v19 = mtp_std_maybe_Maybe_1_Some(v18);
						decref(v19);
					} break;
					case 0LL: { // None
						STR* v20;
						STRLIT(v20, "expected external symbol name", 29);
						VAL r21 = pop_resource();
						uint64_t v22 = pop_u64();
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v22, MKSTR(v20), r21);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
				uint64_t v23 = pop_u64();
				push_u64(v23);
				VAL v24 = mtw_std_maybe_Maybe_1_Some(MKU64(v23));
				uint64_t v25 = pop_u64();
				lpush(&lbl_symbol, v24);
				uint64_t v26 = mw_mirth_token_Token_succ(v25);
				push_u64(v26);
			} else {
				int64_t v27 = 0LL /* None */;
				lpush(&lbl_symbol, MKI64(v27));
			}
			uint64_t v28 = pop_u64();
			push_u64(v28);
			VAL v29 = mw_mirth_token_Token_lsquareZAsk(v28);
			switch (get_data_tag(v29)) {
				case 1LL: { // Some
					VAL v30 = mtp_std_maybe_Maybe_1_Some(v29);
					decref(v30);
					uint64_t v31 = pop_u64();
					VAL r32 = pop_resource();
					push_u64(v31);
					mw_mirth_token_Token_argsZ_1(v31, r32);
					uint64_t v33 = pop_u64();
					uint64_t v34 = pop_u64();
					lpush(&lbl_sig, MKU64(v33));
					uint64_t v35 = mw_mirth_token_Token_next(v34);
					push_u64(v35);
				} break;
				case 0LL: { // None
					uint64_t v36 = pop_u64();
					push_u64(v36);
					int64_t v37 = mw_mirth_token_Token_commaZAsk(v36);
					if (((bool)v37)) {
					} else {
						STR* v38;
						STRLIT(v38, "expected type signature", 23);
						VAL r39 = pop_resource();
						uint64_t v40 = pop_u64();
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v40, MKSTR(v38), r39);
					}
					uint64_t v41 = pop_u64();
					uint64_t v42 = mw_mirth_token_Token_succ(v41);
					push_u64(v42);
					int64_t v43 = mw_mirth_token_Token_argZ_endZAsk(v42);
					if (((bool)v43)) {
						STR* v44;
						STRLIT(v44, "expected type signature", 23);
						VAL r45 = pop_resource();
						uint64_t v46 = pop_u64();
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v46, MKSTR(v44), r45);
					} else {
					}
					uint64_t v47 = pop_u64();
					lpush(&lbl_sig, MKU64(v47));
					uint64_t v48 = mw_mirth_token_Token_nextZ_argZ_end(v47);
					push_u64(v48);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			uint64_t v49 = VU64(lpop(&lbl_sig));
			VAL v50 = lpop(&lbl_symbol);
			uint64_t v51 = VU64(lpop(&lbl_head));
			VAL v52 = mtw_mirth_elab_ExternalDeclPart_EDPDef(v51, v50, v49);
			push_value(v52);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v53 = pop_value();
	uint64_t v54 = pop_u64();
	push_u64(v54);
	int64_t v55 = mw_mirth_token_Token_commaZAsk(v54);
	if (((bool)v55)) {
		uint64_t v56 = pop_u64();
		uint64_t v57 = mw_mirth_token_Token_succ(v56);
		push_u64(v57);
	} else {
	}
	push_value(v53);
}
static void mw_mirth_elab_elabZ_externalZBang (VAL x1, uint64_t x2) {
	lpush(&lbl_token, MKU64(x2));
	mw_mirth_elab_parseZ_externalZ_decl(x1, x2);
	int64_t v0 = 0LL /* Nil */;
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	VAL v2 = pop_value();
	push_resource(v1);
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		VAL r11 = pop_resource();
		mw_mirth_elab_elabZ_externalZ_blockZ_partZBang(r11, v8);
		VAL v12 = pop_value();
		VAL v13 = mtw_std_list_List_1_Cons(v12, r10);
		push_resource(v13);
		mw_std_list_List_1_uncons(v9);
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		push_value(v15);
	}
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = pop_value();
	decref(v17);
	VAL r18 = pop_resource();
	VAL v19 = mw_std_list_List_1_reverse(r18);
	lpush(&lbl_parts, v19);
	uint64_t v20 = mw_mirth_external_ExternalBlock_allocZBang();
	uint64_t v21 = VU64(lpop(&lbl_token));
	void* v22 = mfld_mirth_external_ExternalBlock_ZTildetoken(v20);
	mut_set(MKU64(v21), MKPTR(v22));
	VAL v23 = lpop(&lbl_parts);
	void* v24 = mfld_mirth_external_ExternalBlock_ZTildeparts(v20);
	mut_set(v23, MKPTR(v24));
}
static void mw_mirth_elab_elabZ_externalZ_blockZ_partZBang (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // EDPCode
			push_resource(x1);
			mtp_mirth_elab_ExternalDeclPart_EDPCode(x2);
			uint64_t v0 = VU64(lpop(&lbl_token));
			VAL v1 = lpop(&lbl_code);
			VAL v2 = mtw_mirth_external_ExternalBlockPart_EBPCode(v1);
			push_value(v2);
		} break;
		case 1LL: { // EDPDef
			push_resource(x1);
			mtp_mirth_elab_ExternalDeclPart_EDPDef(x2);
			uint64_t v3 = VU64(lpop(&lbl_sig));
			VAL v4 = lpop(&lbl_symbol);
			uint64_t v5 = VU64(lpop(&lbl_head));
			VAL r6 = pop_resource();
			mw_mirth_elab_elabZ_externalZ_defZBang(r6, v5, v4, v3);
			uint64_t v7 = pop_u64();
			VAL v8 = mtw_mirth_external_ExternalBlockPart_EBPDef(v7);
			push_value(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_elab_elabZ_externalZ_defZBang (VAL x1, uint64_t x2, VAL x3, uint64_t x4) {
	lpush(&lbl_symbol, x3);
	lpush(&lbl_sig, MKU64(x4));
	mw_mirth_elab_elabZ_defZ_head(x1, x2);
	VAL v0 = lpop(&lbl_symbol);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_token_Token_nameZAsk(VU64(v1));
			VAL v3 = mw_std_maybe_Maybe_1_unwrap(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			uint64_t v4 = VU64(lpop(&lbl_name));
			push_u64(v4);
			lpush(&lbl_name, MKU64(v4));
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v5 = pop_u64();
	VAL v6 = mw_mirth_name_Name_ZToStr(v5);
	lpush(&lbl_symbol, v6);
	uint64_t v7 = mw_mirth_external_External_allocZBang();
	uint64_t v8 = VU64(lpop(&lbl_name));
	void* v9 = mfld_mirth_external_External_ZTildename(v7);
	mut_set(MKU64(v8), MKPTR(v9));
	int64_t v10 = VI64(lpop(&lbl_arity));
	void* v11 = mfld_mirth_external_External_ZTildearity(v7);
	mut_set(MKI64(v10), MKPTR(v11));
	lpush(&lbl_external, MKU64(v7));
	VAL v12 = mtw_mirth_mirth_PropLabel_ExternalQName(v7);
	VAL v13 = lpop(&lbl_state);
	VAL v14 = mtw_mirth_mirth_Prop_1_Prop(v12, v13);
	uint64_t v15 = VU64(lpop(&lbl_external));
	void* v16 = mfld_mirth_external_External_ZTildeqname(v15);
	mut_set(v14, MKPTR(v16));
	VAL v17 = lpop(&lbl_symbol);
	void* v18 = mfld_mirth_external_External_ZTildesymbol(v15);
	mut_set(v17, MKPTR(v18));
	uint64_t v19 = VU64(lpop(&lbl_sig));
	void* v20 = mfld_mirth_external_External_ZTildesig(v15);
	mut_set(MKU64(v19), MKPTR(v20));
	uint64_t v21 = VU64(lpop(&lbl_head));
	void* v22 = mfld_mirth_external_External_ZTildehead(v15);
	mut_set(MKU64(v21), MKPTR(v22));
	lpush(&lbl_external, MKU64(v15));
	push_u64(v15);
	VAL v23 = mtw_mirth_mirth_PropLabel_ExternalType(v15);
	FNPTR v24 = &mb_mirth_elab_elabZ_externalZ_defZBang_2;
	VAL r25 = pop_resource();
	VAL v26 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v26, v23, r25, MKFNPTR(v24));
	uint64_t v27 = VU64(lpop(&lbl_external));
	void* v28 = mfld_mirth_external_External_ZTildectxZ_type(v27);
	VAL v29 = pop_value();
	mut_set(v29, MKPTR(v28));
	lpush(&lbl_external, MKU64(v27));
	push_u64(v27);
	VAL v30 = mtw_mirth_mirth_PropLabel_ExternalCType(v27);
	FNPTR v31 = &mb_mirth_elab_elabZ_externalZ_defZBang_4;
	VAL r32 = pop_resource();
	VAL v33 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v33, v30, r32, MKFNPTR(v31));
	uint64_t v34 = VU64(lpop(&lbl_external));
	void* v35 = mfld_mirth_external_External_ZTildectype(v34);
	VAL v36 = pop_value();
	mut_set(v36, MKPTR(v35));
	lpush(&lbl_external, MKU64(v34));
	VAL v37 = mtw_mirth_def_Def_DefExternal(v34);
	VAL r38 = pop_resource();
	VAL v39 = (mw_mirth_def_Def_register(r38, v37));
	uint64_t v40 = VU64(lpop(&lbl_external));
	push_resource(v39);
	push_u64(v40);
}
static void mw_mirth_elab_elabZ_defZ_externalZ_ctype (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	uint64_t v0 = mw_mirth_external_External_head(x2);
	VAL r1 = pop_resource();
	VAL v2 = VVAL(VTUP(r1)->cells[5]);
	incref(v2);
	push_resource(r1);
	VAL v3 = mtw_std_maybe_Maybe_1_Some(MKU64(v0));
	VAL r4 = pop_resource();
	VAL v5 = VTUP(r4)->cells[5];
	decref(v5);
	VTUP(r4)->cells[5] = v3;
	uint64_t v6 = pop_u64();
	mw_mirth_external_External_type(r4, v6);
	VAL r7 = pop_resource();
	VAL v8 = pop_value();
	mw_mirth_type_ArrowType_ctype(v8, r7);
	VAL v9 = pop_value();
	incref(v9);
	VAL v10 = VVAL(VTUP(v9)->cells[2]);
	incref(v10);
	decref(v9);
	VAL v11 = VVAL(VTUP(v10)->cells[2]);
	incref(v11);
	decref(v10);
	int64_t v12 = 0LL /* Nil */;
	push_value(v9);
	push_value(v11);
	VAL v13 = mw_std_list_List_1_reverse(MKI64(v12));
	VAL v14 = pop_value();
	push_resource(v13);
	mw_std_list_List_1_uncons(v14);
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	push_value(v15);
	push_value(v16);
	while(1) {
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		int64_t v18 = mw_std_maybe_Maybe_1_someZAsk(v17);
		if (!((bool)v18)) break;
		VAL v19 = pop_value();
		VAL v20 = mw_std_maybe_Maybe_1_unwrap(v19);
		VAL v21 = pop_value();
		VAL r22 = pop_resource();
		incref(v20);
		VAL v23 = mw_mirth_type_CTypeStackPart_labelZAsk(v20);
		int64_t v24 = mw_std_maybe_Maybe_1_noneZAsk(v23);
		if (((bool)v24)) {
			VAL v25 = mtw_std_maybe_Maybe_1_Some(v20);
			push_value(v25);
		} else {
			decref(v20);
			int64_t v26 = 0LL /* None */;
			push_i64(v26);
		}
		VAL v27 = pop_value();
		switch (get_data_tag(v27)) {
			case 1LL: { // Some
				push_resource(r22);
				VAL v28 = mtp_std_maybe_Maybe_1_Some(v27);
				VAL r29 = pop_resource();
				VAL v30 = mtw_std_list_List_1_Cons(v28, r29);
				push_resource(v30);
			} break;
			case 0LL: { // None
				push_resource(r22);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r22);
			}
		}
		mw_std_list_List_1_uncons(v21);
		VAL v31 = pop_value();
		VAL v32 = pop_value();
		push_value(v31);
		push_value(v32);
	}
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	decref(v34);
	VAL r35 = pop_resource();
	VAL v36 = mw_std_list_List_1_reverse(r35);
	int64_t v37 = 0LL /* Nil */;
	push_value(v36);
	VAL v38 = mw_std_list_List_1_reverse(MKI64(v37));
	VAL v39 = pop_value();
	push_resource(v38);
	mw_std_list_List_1_uncons(v39);
	VAL v40 = pop_value();
	VAL v41 = pop_value();
	push_value(v40);
	push_value(v41);
	while(1) {
		VAL v42 = pop_value();
		incref(v42);
		push_value(v42);
		int64_t v43 = mw_std_maybe_Maybe_1_someZAsk(v42);
		if (!((bool)v43)) break;
		VAL v44 = pop_value();
		VAL v45 = mw_std_maybe_Maybe_1_unwrap(v44);
		VAL v46 = pop_value();
		VAL r47 = pop_resource();
		incref(v45);
		VAL v48 = mw_mirth_type_CTypeStackPart_ctype(v45);
		int64_t v49 = mw_mirth_type_CType_phantomZAsk(v48);
		bool v50 = !((bool)v49);
		if (v50) {
			VAL v51 = mtw_std_maybe_Maybe_1_Some(v45);
			push_value(v51);
		} else {
			decref(v45);
			int64_t v52 = 0LL /* None */;
			push_i64(v52);
		}
		VAL v53 = pop_value();
		switch (get_data_tag(v53)) {
			case 1LL: { // Some
				push_resource(r47);
				VAL v54 = mtp_std_maybe_Maybe_1_Some(v53);
				VAL r55 = pop_resource();
				VAL v56 = mtw_std_list_List_1_Cons(v54, r55);
				push_resource(v56);
			} break;
			case 0LL: { // None
				push_resource(r47);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r47);
			}
		}
		mw_std_list_List_1_uncons(v46);
		VAL v57 = pop_value();
		VAL v58 = pop_value();
		push_value(v57);
		push_value(v58);
	}
	VAL v59 = pop_value();
	decref(v59);
	VAL v60 = pop_value();
	decref(v60);
	VAL r61 = pop_resource();
	VAL v62 = mw_std_list_List_1_reverse(r61);
	int64_t v63 = mw_std_list_List_1_len(v62);
	int64_t v64 = 1LL;
	push_i64(v63);
	int64_t v65 = mw_std_prim_Int_ZToNat(v64);
	int64_t v66 = pop_i64();
	bool v67 = (v66 > v65);
	if (v67) {
		STR* v68;
		STRLIT(v68, "External has too many outputs.", 30);
		VAL r69 = pop_resource();
		VAL v70 = (mw_mirth_mirth_ZPlusMirth_errorZBang(MKSTR(v68), r69));
		push_resource(v70);
	} else {
	}
	VAL v71 = pop_value();
	incref(v71);
	VAL v72 = VVAL(VTUP(v71)->cells[1]);
	incref(v72);
	decref(v71);
	VAL v73 = VVAL(VTUP(v72)->cells[2]);
	incref(v73);
	decref(v72);
	int64_t v74 = 0LL /* Nil */;
	push_value(v71);
	push_value(v73);
	VAL v75 = mw_std_list_List_1_reverse(MKI64(v74));
	VAL v76 = pop_value();
	push_resource(v75);
	mw_std_list_List_1_uncons(v76);
	VAL v77 = pop_value();
	VAL v78 = pop_value();
	push_value(v77);
	push_value(v78);
	while(1) {
		VAL v79 = pop_value();
		incref(v79);
		push_value(v79);
		int64_t v80 = mw_std_maybe_Maybe_1_someZAsk(v79);
		if (!((bool)v80)) break;
		VAL v81 = pop_value();
		VAL v82 = mw_std_maybe_Maybe_1_unwrap(v81);
		VAL v83 = pop_value();
		VAL r84 = pop_resource();
		VAL v85 = mw_mirth_type_CTypeStackPart_labelZAsk(v82);
		switch (get_data_tag(v85)) {
			case 1LL: { // Some
				push_resource(r84);
				VAL v86 = mtp_std_maybe_Maybe_1_Some(v85);
				VAL r87 = pop_resource();
				VAL v88 = mtw_std_list_List_1_Cons(v86, r87);
				push_resource(v88);
			} break;
			case 0LL: { // None
				push_resource(r84);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r84);
			}
		}
		mw_std_list_List_1_uncons(v83);
		VAL v89 = pop_value();
		VAL v90 = pop_value();
		push_value(v89);
		push_value(v90);
	}
	VAL v91 = pop_value();
	decref(v91);
	VAL v92 = pop_value();
	decref(v92);
	VAL r93 = pop_resource();
	VAL v94 = mw_std_list_List_1_reverse(r93);
	VAL v95 = pop_value();
	incref(v95);
	VAL v96 = VVAL(VTUP(v95)->cells[2]);
	incref(v96);
	decref(v95);
	VAL v97 = VVAL(VTUP(v96)->cells[2]);
	incref(v97);
	decref(v96);
	int64_t v98 = 0LL /* Nil */;
	push_value(v95);
	push_value(v94);
	push_value(v97);
	VAL v99 = mw_std_list_List_1_reverse(MKI64(v98));
	VAL v100 = pop_value();
	push_resource(v99);
	mw_std_list_List_1_uncons(v100);
	VAL v101 = pop_value();
	VAL v102 = pop_value();
	push_value(v101);
	push_value(v102);
	while(1) {
		VAL v103 = pop_value();
		incref(v103);
		push_value(v103);
		int64_t v104 = mw_std_maybe_Maybe_1_someZAsk(v103);
		if (!((bool)v104)) break;
		VAL v105 = pop_value();
		VAL v106 = mw_std_maybe_Maybe_1_unwrap(v105);
		VAL v107 = pop_value();
		VAL r108 = pop_resource();
		VAL v109 = mw_mirth_type_CTypeStackPart_labelZAsk(v106);
		switch (get_data_tag(v109)) {
			case 1LL: { // Some
				push_resource(r108);
				VAL v110 = mtp_std_maybe_Maybe_1_Some(v109);
				VAL r111 = pop_resource();
				VAL v112 = mtw_std_list_List_1_Cons(v110, r111);
				push_resource(v112);
			} break;
			case 0LL: { // None
				push_resource(r108);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r108);
			}
		}
		mw_std_list_List_1_uncons(v107);
		VAL v113 = pop_value();
		VAL v114 = pop_value();
		push_value(v113);
		push_value(v114);
	}
	VAL v115 = pop_value();
	decref(v115);
	VAL v116 = pop_value();
	decref(v116);
	VAL r117 = pop_resource();
	VAL v118 = mw_std_list_List_1_reverse(r117);
	VAL v119 = pop_value();
	int64_t v120 = 0LL /* Nil */;
	push_value(v119);
	push_value(v118);
	VAL v121 = mw_std_list_List_1_reverse(MKI64(v120));
	VAL v122 = pop_value();
	push_resource(v121);
	mw_std_list_List_1_uncons(v122);
	VAL v123 = pop_value();
	VAL v124 = pop_value();
	push_value(v123);
	push_value(v124);
	while(1) {
		VAL v125 = pop_value();
		incref(v125);
		push_value(v125);
		int64_t v126 = mw_std_maybe_Maybe_1_someZAsk(v125);
		if (!((bool)v126)) break;
		VAL v127 = pop_value();
		VAL v128 = mw_std_maybe_Maybe_1_unwrap(v127);
		VAL v129 = pop_value();
		VAL r130 = pop_resource();
		incref(v128);
		VAL v131 = pop_value();
		incref(v131);
		int64_t v132 = 0LL /* None */;
		push_value(v128);
		push_i64(v132);
		mw_std_list_List_1_uncons(v131);
		VAL v133 = pop_value();
		VAL v134 = pop_value();
		push_value(v133);
		push_value(v134);
		while(1) {
			VAL v135 = pop_value();
			incref(v135);
			push_value(v135);
			int64_t v136 = mw_std_maybe_Maybe_1_someZAsk(v135);
			if (!((bool)v136)) break;
			VAL v137 = pop_value();
			VAL v138 = mw_std_maybe_Maybe_1_unwrap(v137);
			VAL v139 = pop_value();
			VAL v140 = pop_value();
			incref(v138);
			VAL v141 = pop_value();
			incref(v141);
			int64_t v142 = mw_mirth_label_Label_ZEqualZEqual(VU64(v141), VU64(v138));
			if (((bool)v142)) {
				push_value(v141);
				VAL v143 = mtw_std_maybe_Maybe_1_Some(v138);
				push_value(v143);
			} else {
				decref(v138);
				int64_t v144 = 0LL /* None */;
				push_value(v141);
				push_i64(v144);
			}
			VAL v145 = pop_value();
			switch (get_data_tag(v145)) {
				case 0LL: { // None
					push_value(v140);
					push_value(v139);
				} break;
				default: {
					decref(v139);
					decref(v140);
					int64_t v146 = 0LL /* Nil */;
					push_value(v145);
					push_i64(v146);
				} break;
			}
			VAL v147 = pop_value();
			mw_std_list_List_1_uncons(v147);
			VAL v148 = pop_value();
			VAL v149 = pop_value();
			push_value(v148);
			push_value(v149);
		}
		VAL v150 = pop_value();
		decref(v150);
		VAL v151 = pop_value();
		decref(v151);
		VAL v152 = pop_value();
		VAL v153 = pop_value();
		decref(v153);
		int64_t v154 = mw_std_maybe_Maybe_1_someZAsk(v152);
		bool v155 = !((bool)v154);
		if (v155) {
			push_value(v131);
			VAL v156 = mtw_std_maybe_Maybe_1_Some(v128);
			push_value(v156);
		} else {
			decref(v128);
			int64_t v157 = 0LL /* None */;
			push_value(v131);
			push_i64(v157);
		}
		VAL v158 = pop_value();
		switch (get_data_tag(v158)) {
			case 1LL: { // Some
				push_resource(r130);
				VAL v159 = mtp_std_maybe_Maybe_1_Some(v158);
				VAL r160 = pop_resource();
				VAL v161 = mtw_std_list_List_1_Cons(v159, r160);
				push_resource(v161);
			} break;
			case 0LL: { // None
				push_resource(r130);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r130);
			}
		}
		mw_std_list_List_1_uncons(v129);
		VAL v162 = pop_value();
		VAL v163 = pop_value();
		push_value(v162);
		push_value(v163);
	}
	VAL v164 = pop_value();
	decref(v164);
	VAL v165 = pop_value();
	decref(v165);
	VAL r166 = pop_resource();
	VAL v167 = mw_std_list_List_1_reverse(r166);
	VAL v168 = pop_value();
	decref(v168);
	mw_std_list_List_1_uncons(v167);
	VAL v169 = pop_value();
	VAL v170 = pop_value();
	push_value(v169);
	push_value(v170);
	while(1) {
		VAL v171 = pop_value();
		incref(v171);
		push_value(v171);
		int64_t v172 = mw_std_maybe_Maybe_1_someZAsk(v171);
		if (!((bool)v172)) break;
		VAL v173 = pop_value();
		VAL v174 = mw_std_maybe_Maybe_1_unwrap(v173);
		VAL v175 = pop_value();
		STR* v176;
		STRLIT(v176, "", 0);
		STR* v177;
		STRLIT(v177, "Output label ", 13);
		push_value(v174);
		VAL v178 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v177), MKSTR(v176)));
		uint64_t v179 = pop_u64();
		push_resource(v178);
		uint64_t v180 = mw_mirth_label_Label_name(v179);
		VAL v181 = mw_mirth_name_Name_ZToStr(v180);
		VAL r182 = pop_resource();
		VAL v183 = (mw_std_str_ZPlusStr_pushZ_strZBang(v181, r182));
		STR* v184;
		STRLIT(v184, " not present in input", 21);
		VAL v185 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v184), v183));
		VAL r186 = pop_resource();
		VAL v187 = (mw_mirth_mirth_ZPlusMirth_errorZBang(v185, r186));
		push_resource(v187);
		mw_std_list_List_1_uncons(v175);
		VAL v188 = pop_value();
		VAL v189 = pop_value();
		push_value(v188);
		push_value(v189);
	}
	VAL v190 = pop_value();
	decref(v190);
	VAL v191 = pop_value();
	decref(v191);
	VAL r192 = pop_resource();
	VAL v193 = VTUP(r192)->cells[5];
	decref(v193);
	VTUP(r192)->cells[5] = v2;
	push_resource(r192);
}
static void mw_mirth_elab_elabZ_defZ_typeZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_2(x2, r1);
	uint64_t v2 = pop_u64();
	uint64_t v3 = pop_u64();
	VAL r4 = pop_resource();
	lpush(&lbl_target, MKU64(v2));
	lpush(&lbl_head, MKU64(v3));
	VAL v5 = (mw_mirth_token_Token_argsZ_0(v3, r4));
	uint64_t v6 = VU64(lpop(&lbl_head));
	push_resource(v5);
	lpush(&lbl_head, MKU64(v6));
	int64_t v7 = mw_mirth_token_Token_sigZ_typeZ_conZAsk(v6);
	if (((bool)v7)) {
	} else {
		STR* v8;
		STRLIT(v8, "expected type constructor", 25);
		VAL r9 = pop_resource();
		uint64_t v10 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v10, MKSTR(v8), r9);
	}
	uint64_t v11 = VU64(lpop(&lbl_head));
	VAL r12 = pop_resource();
	mw_mirth_elab_elabZ_defZ_head(r12, v11);
	uint64_t v13 = VU64(lpop(&lbl_head));
	VAL v14 = mtw_std_maybe_Maybe_1_Some(MKU64(v13));
	int64_t v15 = VI64(lpop(&lbl_arity));
	VAL v16 = lpop(&lbl_state);
	uint64_t v17 = VU64(lpop(&lbl_name));
	VAL r18 = pop_resource();
	mw_mirth_typedef_TypeDef_newZBang(r18, v14, v17, v16);
	uint64_t v19 = VU64(lpop(&lbl_target));
	VAL v20 = pop_value();
	incref(v20);
	push_value(v20);
	push_u64(v19);
	VAL v21 = mtw_mirth_mirth_PropLabel_TypeDefTarget(VU64(v20));
	FNPTR v22 = &mb_mirth_elab_elabZ_defZ_typeZBang_2;
	VAL r23 = pop_resource();
	VAL v24 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v24, v21, r23, MKFNPTR(v22));
	VAL v25 = pop_value();
	uint64_t v26 = pop_u64();
	void* v27 = mfld_mirth_typedef_TypeDef_ZTildetarget(v26);
	mut_set(v25, MKPTR(v27));
}
static void mw_mirth_elab_elabZ_bufferZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_2(x2, r1);
	uint64_t v2 = pop_u64();
	uint64_t v3 = pop_u64();
	VAL r4 = pop_resource();
	push_u64(v2);
	push_u64(v3);
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined(r4, v3);
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v6);
	push_value(v5);
	push_value(v7);
	VAL v8 = mw_mirth_token_Token_intZAsk(VU64(v7));
	switch (get_data_tag(v8)) {
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v8);
			push_value(v9);
		} break;
		case 0LL: { // None
			STR* v10;
			STRLIT(v10, "expected buffer size", 20);
			VAL r11 = pop_resource();
			uint64_t v12 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v12, MKSTR(v10), r11);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	decref(v14);
	int64_t v15 = mw_std_prim_Int_ZToNat(VI64(v13));
	VAL v16 = pop_value();
	uint64_t v17 = pop_u64();
	VAL r18 = pop_resource();
	mw_mirth_buffer_Buffer_newZBang(r18, v17, v16, v15);
	uint64_t v19 = pop_u64();
}
static void mw_mirth_elab_elabZ_variableZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_2(x2, r1);
	uint64_t v2 = pop_u64();
	uint64_t v3 = pop_u64();
	VAL r4 = pop_resource();
	push_u64(v2);
	push_u64(v3);
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined(r4, v3);
	VAL v5 = pop_value();
	uint64_t v6 = pop_u64();
	VAL r7 = pop_resource();
	mw_mirth_variable_Variable_newZBang(r7, v6, v5);
	VAL v8 = pop_value();
	incref(v8);
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	VAL v10 = mtw_mirth_mirth_PropLabel_VariableType(VU64(v8));
	FNPTR v11 = &mb_mirth_elab_elabZ_variableZBang_1;
	VAL r12 = pop_resource();
	VAL v13 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v13, v10, r12, MKFNPTR(v11));
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	incref(v15);
	void* v16 = mfld_mirth_variable_Variable_ZTildetype(VU64(v15));
	mut_set(v14, MKPTR(v16));
	decref(v15);
}
static void mw_mirth_elab_elabZ_tableZBang (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_1(x2, r1);
	uint64_t v2 = pop_u64();
	lpush(&lbl_head, MKU64(v2));
	int64_t v3 = mw_mirth_token_Token_sigZ_typeZ_conZAsk(v2);
	if (((bool)v3)) {
	} else {
		uint64_t v4 = VU64(lpop(&lbl_head));
		STR* v5;
		STRLIT(v5, "expected type name", 18);
		VAL r6 = pop_resource();
		lpush(&lbl_head, MKU64(v4));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v4, MKSTR(v5), r6);
	}
	uint64_t v7 = VU64(lpop(&lbl_head));
	VAL r8 = pop_resource();
	lpush(&lbl_head, MKU64(v7));
	VAL v9 = (mw_mirth_token_Token_argsZ_0(v7, r8));
	uint64_t v10 = VU64(lpop(&lbl_head));
	push_resource(v9);
	lpush(&lbl_head, MKU64(v10));
	uint64_t v11 = mw_mirth_token_Token_succ(v10);
	int64_t v12 = mw_mirth_token_Token_argZ_endZAsk(v11);
	if (((bool)v12)) {
	} else {
		uint64_t v13 = VU64(lpop(&lbl_head));
		lpush(&lbl_head, MKU64(v13));
		uint64_t v14 = mw_mirth_token_Token_succ(v13);
		STR* v15;
		STRLIT(v15, "expected end of argument after table name", 41);
		VAL r16 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v14, MKSTR(v15), r16);
	}
	uint64_t v17 = VU64(lpop(&lbl_head));
	VAL r18 = pop_resource();
	mw_mirth_elab_elabZ_defZ_head(r18, v17);
	int64_t v19 = VI64(lpop(&lbl_arity));
	VAL v20 = lpop(&lbl_state);
	uint64_t v21 = VU64(lpop(&lbl_name));
	uint64_t v22 = VU64(lpop(&lbl_head));
	VAL r23 = pop_resource();
	mw_mirth_elab_tableZ_newZBang(r23, v22, v21, v20);
	uint64_t v24 = pop_u64();
}
static void mw_mirth_elab_elabZ_entryZ_point (VAL x1, VAL x2) {
	incref(x1);
	push_value(x1);
	mw_mirth_name_QName_defZ_hardZAsk(x2, x1);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL v2 = mw_mirth_def_Def_wordZAsk(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* None */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	switch (get_data_tag(v4)) {
		case 1LL: { // Some
			VAL v5 = mtp_std_maybe_Maybe_1_Some(v4);
			push_value(v5);
		} break;
		case 0LL: { // None
			VAL v6 = pop_value();
			incref(v6);
			VAL v7 = VVAL(VTUP(v6)->cells[1]);
			incref(v7);
			decref(v6);
			VAL r8 = pop_resource();
			mw_mirth_name_Namespace_moduleZAsk(r8, v7);
			VAL v9 = pop_value();
			VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
			uint64_t v11 = mw_mirth_module_Module_start(VU64(v10));
			STR* v12;
			STRLIT(v12, "can't find entry point ", 23);
			VAL r13 = pop_resource();
			push_u64(v11);
			push_str(v12);
			mw_mirth_name_QName_ZToStr(r13, v6);
			STR* v14 = pop_str();
			STR* v15 = pop_str();
			STR* v16 = str_cat(v15, v14);
			VAL r17 = pop_resource();
			uint64_t v18 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v18, MKSTR(v16), r17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	decref(v20);
	incref(v19);
	push_value(v19);
	VAL v21 = mw_mirth_var_Ctx0();
	push_value(v21);
	VAL v22 = mw_mirth_type_T0();
	push_value(v22);
	VAL v23 = mw_mirth_type_RESOURCEz_WORLD();
	VAL v24 = pop_value();
	VAL v25 = mw_mirth_type_TZPlus(v24, v23);
	push_value(v25);
	VAL v26 = mw_mirth_type_T0();
	push_value(v26);
	VAL v27 = mw_mirth_type_RESOURCEz_WORLD();
	VAL v28 = pop_value();
	VAL v29 = mw_mirth_type_TZPlus(v28, v27);
	VAL v30 = pop_value();
	VAL v31 = mw_mirth_type_TZ_ZTo(v30, v29);
	push_value(v31);
	uint64_t v32 = mw_mirth_word_Word_head(VU64(v19));
	push_u64(v32);
	VAL v33 = mtw_mirth_arrow_Home_HomeMain(v32);
	VAL v34 = pop_value();
	VAL v35 = pop_value();
	mw_mirth_type_ArrowType_unpack(v35);
	VAL v36 = pop_value();
	VAL v37 = pop_value();
	VAL v38 = pop_value();
	incref(v34);
	incref(v37);
	int64_t v39 = 0LL /* Nil */;
	push_value(v36);
	VAL v40 = mtw_mirth_arrow_Arrow_Arrow(v33, VU64(v34), VU64(v34), v38, v37, v37, MKI64(v39));
	VAL v41 = pop_value();
	VAL r42 = pop_resource();
	uint64_t v43 = pop_u64();
	mw_mirth_elab_abZ_wordZBang(v43, r42, v40);
	VAL r44 = pop_resource();
	VAL r45 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v41, r45, r44);
	VAL r46 = pop_resource();
	push_value(r46);
}
static void mw_mirth_elab_elabZ_embedZ_strZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	uint64_t v0 = mw_mirth_token_Token_next(x1);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_2(x1, r1);
	uint64_t v2 = pop_u64();
	uint64_t v3 = pop_u64();
	VAL r4 = pop_resource();
	push_u64(v2);
	mw_mirth_elab_elabZ_defZ_head(r4, v3);
	int64_t v5 = VI64(lpop(&lbl_arity));
	int64_t v6 = 0LL;
	bool v7 = (v5 == v6);
	if (v7) {
		lpush(&lbl_arity, MKI64(v5));
	} else {
		uint64_t v8 = VU64(lpop(&lbl_head));
		STR* v9;
		STRLIT(v9, "expected no arguments", 21);
		VAL r10 = pop_resource();
		lpush(&lbl_arity, MKI64(v5));
		lpush(&lbl_head, MKU64(v8));
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v8, MKSTR(v9), r10);
	}
	uint64_t v11 = pop_u64();
	int64_t v12 = 0LL /* None */;
	lpush(&lbl_body, MKU64(v11));
	lpush(&lbl_sigZAsk, MKI64(v12));
	push_u64(v11);
	VAL v13 = mw_mirth_token_Token_strZAsk(v11);
	switch (get_data_tag(v13)) {
		case 1LL: { // Some
			VAL v14 = mtp_std_maybe_Maybe_1_Some(v13);
			push_value(v14);
		} break;
		case 0LL: { // None
			STR* v15;
			STRLIT(v15, "expected source path", 20);
			VAL r16 = pop_resource();
			uint64_t v17 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v17, MKSTR(v15), r16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r18 = pop_resource();
	VAL r19 = pop_resource();
	VAL v20 = pop_value();
	mw_std_prim_ZPlusWorld_openZ_fileZBang(v20, r19);
	VAL r21 = pop_resource();
	VAL v22 = (mw_std_file_ZPlusFileZAsk_unwrapZBang(r21));
	mw_std_file_ZPlusFile_readZ_fileZBang(v22);
	VAL r23 = pop_resource();
	VAL r24 = pop_resource();
	VAL v25 = (mw_std_file_ZPlusFile_closeZ_fileZBang(r24, r23));
	VAL v26 = pop_value();
	VAL v27 = pop_value();
	decref(v27);
	int64_t v28 = VI64(lpop(&lbl_arity));
	uint64_t v29 = VU64(lpop(&lbl_name));
	uint64_t v30 = VU64(lpop(&lbl_body));
	VAL v31 = lpop(&lbl_sigZAsk);
	uint64_t v32 = VU64(lpop(&lbl_head));
	push_resource(v25);
	lpush(&lbl_contents, v26);
	mw_mirth_word_Word_newZBang(v32, v31, v30, v29, v28, r18);
	uint64_t v33 = pop_u64();
	push_u64(v33);
	VAL v34 = mtw_mirth_mirth_PropLabel_WordQName(v33);
	VAL v35 = lpop(&lbl_state);
	VAL v36 = mtw_mirth_mirth_Prop_1_Prop(v34, v35);
	VAL v37 = pop_value();
	incref(v37);
	void* v38 = mfld_mirth_word_Word_ZTildeqname(VU64(v37));
	mut_set(v36, MKPTR(v38));
	push_value(v37);
	VAL v39 = mw_mirth_var_Ctx0();
	push_value(v39);
	VAL v40 = mw_mirth_type_T0();
	push_value(v40);
	VAL v41 = mw_mirth_type_TYPEz_STR();
	VAL v42 = mw_mirth_type_T1(v41);
	VAL v43 = pop_value();
	VAL v44 = mw_mirth_type_TZ_ZTo(v43, v42);
	VAL v45 = pop_value();
	VAL v46 = pop_value();
	incref(v46);
	push_value(v46);
	push_value(v45);
	push_value(v44);
	VAL v47 = mtw_mirth_mirth_PropLabel_WordType(VU64(v46));
	VAL r48 = pop_resource();
	VAL v49 = pop_value();
	VAL v50 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v50, v49, v47, r48);
	VAL v51 = pop_value();
	VAL v52 = pop_value();
	incref(v52);
	void* v53 = mfld_mirth_word_Word_ZTildectxZ_type(VU64(v52));
	mut_set(v51, MKPTR(v53));
	incref(v52);
	VAL r54 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r54, VU64(v52));
	uint64_t v55 = pop_u64();
	VAL v56 = pop_value();
	VAL v57 = pop_value();
	VAL v58 = pop_value();
	mw_mirth_type_ArrowType_unpack(v58);
	VAL v59 = pop_value();
	VAL v60 = pop_value();
	VAL v61 = pop_value();
	incref(v57);
	incref(v60);
	int64_t v62 = 0LL /* Nil */;
	push_value(v59);
	VAL v63 = mtw_mirth_arrow_Arrow_Arrow(v56, VU64(v57), VU64(v57), v61, v60, v60, MKI64(v62));
	VAL v64 = pop_value();
	VAL v65 = lpop(&lbl_contents);
	VAL r66 = pop_resource();
	mw_mirth_elab_abZ_strZBang(v65, r66, v63);
	VAL r67 = pop_resource();
	VAL r68 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v64, r68, r67);
	VAL r69 = pop_resource();
	VAL r70 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r70, r69, v55);
	incref(v52);
	VAL v71 = mtw_mirth_mirth_PropLabel_WordArrow(VU64(v52));
	VAL r72 = pop_resource();
	VAL v73 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v73, v71, r72);
	incref(v52);
	VAL v74 = pop_value();
	void* v75 = mfld_mirth_word_Word_ZTildearrow(VU64(v52));
	mut_set(v74, MKPTR(v75));
	decref(v52);
}
static VAL mw_mirth_elab_typecheckZ_everythingZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_name_Name_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL v6 = mw_mirth_name_Name_defs(((uint64_t)v5));
		mw_std_list_List_1_uncons(v6);
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
		while(1) {
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
			if (!((bool)v10)) break;
			VAL v11 = pop_value();
			VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
			VAL v13 = pop_value();
			incref(v12);
			VAL r14 = pop_resource();
			push_value(v12);
			mw_mirth_def_Def_qnameZ_hard(r14, v12);
			VAL v15 = pop_value();
			decref(v15);
			VAL v16 = pop_value();
			VAL r17 = pop_resource();
			VAL v18 = (mw_mirth_def_Def_typecheckZBang(r17, v16));
			push_resource(v18);
			mw_std_list_List_1_uncons(v13);
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			push_value(v19);
			push_value(v20);
		}
		VAL v21 = pop_value();
		decref(v21);
		VAL v22 = pop_value();
		decref(v22);
		int64_t v23 = 1LL;
		int64_t v24 = i64_add(v5, v23);
		push_i64(v24);
	}
	int64_t v25 = pop_i64();
	int64_t v26 = 1LL;
	push_i64(v26);
	while(1) {
		int64_t v27 = pop_i64();
		void* v28 = mbuf_mirth_arrow_Block_NUM;
		int64_t v29 = *(int64_t*)v28;
		bool v30 = (v27 <= v29);
		push_i64(v27);
		if (!v30) break;
		int64_t v31 = pop_i64();
		VAL r32 = pop_resource();
		VAL v33 = (mw_mirth_arrow_Block_typecheckZBang(r32, ((uint64_t)v31)));
		int64_t v34 = 1LL;
		int64_t v35 = i64_add(v31, v34);
		push_resource(v33);
		push_i64(v35);
	}
	int64_t v36 = pop_i64();
	int64_t v37 = 1LL;
	push_i64(v37);
	while(1) {
		int64_t v38 = pop_i64();
		void* v39 = mbuf_mirth_external_External_NUM;
		int64_t v40 = *(int64_t*)v39;
		bool v41 = (v38 <= v40);
		push_i64(v38);
		if (!v41) break;
		int64_t v42 = pop_i64();
		VAL r43 = pop_resource();
		mw_mirth_external_External_ctype(r43, ((uint64_t)v42));
		VAL v44 = pop_value();
		decref(v44);
		int64_t v45 = 1LL;
		int64_t v46 = i64_add(v42, v45);
		push_i64(v46);
	}
	int64_t v47 = pop_i64();
	VAL r48 = pop_resource();
	return r48;
}
static int64_t mw_mirth_elab_TABLEz_MAXz_COUNT (void) {
	int64_t v0 = 524288LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	return v1;
}
static VAL mw_mirth_elab_tableZ_qname (uint64_t x1, VAL x2, int64_t x3) {
	push_u64(x1);
	lpush(&lbl_arity, MKI64(x3));
	uint64_t v0 = mw_std_prim_Str_ZToName(x2);
	uint64_t v1 = pop_u64();
	lpush(&lbl_name, MKU64(v0));
	VAL v2 = mtw_mirth_tycon_Tycon_TYCONz_TABLE(v1);
	VAL v3 = mtw_mirth_name_Namespace_NAMESPACEz_TYCON(v2);
	int64_t v4 = VI64(lpop(&lbl_arity));
	uint64_t v5 = VU64(lpop(&lbl_name));
	VAL v6 = mtw_mirth_name_QName_MKQNAME(v3, v5, v4);
	return v6;
}
static void mw_mirth_elab_tableZ_wordZ_newZBang (VAL x1, uint64_t x2, VAL x3, int64_t x4) {
	push_resource(x1);
	push_u64(x2);
	push_value(x3);
	push_i64(x4);
	uint64_t v0 = mw_mirth_table_Table_head(x2);
	int64_t v1 = 0LL /* None */;
	int64_t v2 = pop_i64();
	VAL v3 = pop_value();
	incref(v3);
	lpush(&lbl_head, MKU64(v0));
	lpush(&lbl_body, MKU64(v0));
	lpush(&lbl_sigZAsk, MKI64(v1));
	lpush(&lbl_arity, MKI64(v2));
	push_value(v3);
	push_i64(v2);
	uint64_t v4 = mw_std_prim_Str_ZToName(v3);
	int64_t v5 = pop_i64();
	VAL v6 = pop_value();
	uint64_t v7 = pop_u64();
	lpush(&lbl_name, MKU64(v4));
	VAL v8 = mw_mirth_elab_tableZ_qname(v7, v6, v5);
	VAL r9 = pop_resource();
	int64_t v10 = VI64(lpop(&lbl_arity));
	uint64_t v11 = VU64(lpop(&lbl_name));
	uint64_t v12 = VU64(lpop(&lbl_body));
	VAL v13 = lpop(&lbl_sigZAsk);
	uint64_t v14 = VU64(lpop(&lbl_head));
	lpush(&lbl_qname, v8);
	mw_mirth_word_Word_newZBang(v14, v13, v12, v11, v10, r9);
	VAL v15 = lpop(&lbl_qname);
	VAL v16 = pop_value();
	incref(v16);
	push_value(v16);
	push_value(v15);
	VAL v17 = mtw_mirth_mirth_PropLabel_WordQName(VU64(v16));
	VAL r18 = pop_resource();
	VAL v19 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v19, v17, r18);
	VAL v20 = pop_value();
	VAL v21 = pop_value();
	incref(v21);
	void* v22 = mfld_mirth_word_Word_ZTildeqname(VU64(v21));
	mut_set(v20, MKPTR(v22));
	push_value(v21);
}
static void mw_mirth_elab_tableZ_newZBang (VAL x1, uint64_t x2, uint64_t x3, VAL x4) {
	push_resource(x1);
	lpush(&lbl_head, MKU64(x2));
	lpush(&lbl_name, MKU64(x3));
	lpush(&lbl_state, x4);
	uint64_t v0 = mw_mirth_table_Table_allocZBang();
	lpush(&lbl_tbl, MKU64(v0));
	VAL v1 = mtw_mirth_mirth_PropLabel_TableQName(v0);
	VAL v2 = lpop(&lbl_state);
	VAL v3 = mtw_mirth_mirth_Prop_1_Prop(v1, v2);
	uint64_t v4 = VU64(lpop(&lbl_tbl));
	void* v5 = mfld_mirth_table_Table_ZTildeqname(v4);
	mut_set(v3, MKPTR(v5));
	uint64_t v6 = VU64(lpop(&lbl_head));
	void* v7 = mfld_mirth_table_Table_ZTildehead(v4);
	mut_set(MKU64(v6), MKPTR(v7));
	uint64_t v8 = VU64(lpop(&lbl_name));
	void* v9 = mfld_mirth_table_Table_ZTildename(v4);
	mut_set(MKU64(v8), MKPTR(v9));
	lpush(&lbl_tbl, MKU64(v4));
	int64_t v10 = mw_mirth_elab_TABLEz_MAXz_COUNT();
	uint64_t v11 = VU64(lpop(&lbl_tbl));
	void* v12 = mfld_mirth_table_Table_ZTildemaxZ_count(v11);
	mut_set(MKI64(v10), MKPTR(v12));
	lpush(&lbl_tbl, MKU64(v11));
	VAL v13 = mtw_mirth_def_Def_DefTable(v11);
	VAL r14 = pop_resource();
	VAL v15 = (mw_mirth_def_Def_register(r14, v13));
	uint64_t v16 = VU64(lpop(&lbl_tbl));
	STR* v17;
	STRLIT(v17, "MAX", 3);
	int64_t v18 = 0LL;
	lpush(&lbl_tbl, MKU64(v16));
	mw_mirth_elab_tableZ_wordZ_newZBang(v15, v16, MKSTR(v17), v18);
	uint64_t v19 = pop_u64();
	int64_t v20 = 0LL /* Nil */;
	lpush(&lbl_word, MKU64(v19));
	push_i64(v20);
	VAL v21 = mw_mirth_type_T0();
	push_value(v21);
	VAL v22 = mw_mirth_type_TYPEz_INT();
	VAL v23 = mw_mirth_type_T1(v22);
	VAL v24 = pop_value();
	VAL v25 = mw_mirth_type_TZ_ZTo(v24, v23);
	uint64_t v26 = VU64(lpop(&lbl_word));
	push_value(v25);
	lpush(&lbl_word, MKU64(v26));
	VAL v27 = mtw_mirth_mirth_PropLabel_WordType(v26);
	VAL r28 = pop_resource();
	VAL v29 = pop_value();
	VAL v30 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v30, v29, v27, r28);
	uint64_t v31 = VU64(lpop(&lbl_word));
	void* v32 = mfld_mirth_word_Word_ZTildectxZ_type(v31);
	VAL v33 = pop_value();
	mut_set(v33, MKPTR(v32));
	VAL r34 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r34, v31);
	uint64_t v35 = pop_u64();
	VAL v36 = pop_value();
	VAL v37 = pop_value();
	VAL v38 = pop_value();
	mw_mirth_type_ArrowType_unpack(v38);
	VAL v39 = pop_value();
	VAL v40 = pop_value();
	VAL v41 = pop_value();
	incref(v37);
	incref(v40);
	int64_t v42 = 0LL /* Nil */;
	push_value(v39);
	VAL v43 = mtw_mirth_arrow_Arrow_Arrow(v36, VU64(v37), VU64(v37), v41, v40, v40, MKI64(v42));
	VAL v44 = pop_value();
	uint64_t v45 = VU64(lpop(&lbl_tbl));
	push_resource(v43);
	lpush(&lbl_tbl, MKU64(v45));
	uint64_t v46 = mw_mirth_table_Table_head(v45);
	VAL r47 = pop_resource();
	VAL v48 = (mw_mirth_elab_abZ_tokenZBang(r47, v46));
	push_resource(v48);
	int64_t v49 = mw_mirth_elab_TABLEz_MAXz_COUNT();
	VAL r50 = pop_resource();
	VAL r51 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v49, r51, r50);
	VAL r52 = pop_resource();
	VAL r53 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v44, r53, r52);
	VAL r54 = pop_resource();
	VAL r55 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r55, r54, v35);
	VAL v56 = mtw_mirth_mirth_PropLabel_WordArrow(v31);
	VAL r57 = pop_resource();
	VAL v58 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v58, v56, r57);
	VAL v59 = pop_value();
	void* v60 = mfld_mirth_word_Word_ZTildearrow(v31);
	mut_set(v59, MKPTR(v60));
	uint64_t v61 = VU64(lpop(&lbl_tbl));
	STR* v62;
	STRLIT(v62, "nil", 3);
	int64_t v63 = 0LL;
	VAL r64 = pop_resource();
	lpush(&lbl_tbl, MKU64(v61));
	mw_mirth_elab_tableZ_wordZ_newZBang(r64, v61, MKSTR(v62), v63);
	uint64_t v65 = pop_u64();
	int64_t v66 = 0LL /* Nil */;
	lpush(&lbl_word, MKU64(v65));
	push_i64(v66);
	VAL v67 = mw_mirth_type_T0();
	uint64_t v68 = VU64(lpop(&lbl_tbl));
	push_value(v67);
	lpush(&lbl_tbl, MKU64(v68));
	VAL v69 = mtw_mirth_type_Type_TTable(v68);
	VAL v70 = mw_mirth_type_T1(v69);
	VAL v71 = pop_value();
	VAL v72 = mw_mirth_type_TZ_ZTo(v71, v70);
	uint64_t v73 = VU64(lpop(&lbl_word));
	push_value(v72);
	lpush(&lbl_word, MKU64(v73));
	VAL v74 = mtw_mirth_mirth_PropLabel_WordType(v73);
	VAL r75 = pop_resource();
	VAL v76 = pop_value();
	VAL v77 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v77, v76, v74, r75);
	uint64_t v78 = VU64(lpop(&lbl_word));
	void* v79 = mfld_mirth_word_Word_ZTildectxZ_type(v78);
	VAL v80 = pop_value();
	mut_set(v80, MKPTR(v79));
	VAL r81 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r81, v78);
	uint64_t v82 = pop_u64();
	VAL v83 = pop_value();
	VAL v84 = pop_value();
	VAL v85 = pop_value();
	mw_mirth_type_ArrowType_unpack(v85);
	VAL v86 = pop_value();
	VAL v87 = pop_value();
	VAL v88 = pop_value();
	incref(v84);
	incref(v87);
	int64_t v89 = 0LL /* Nil */;
	push_value(v86);
	VAL v90 = mtw_mirth_arrow_Arrow_Arrow(v83, VU64(v84), VU64(v84), v88, v87, v87, MKI64(v89));
	VAL v91 = pop_value();
	uint64_t v92 = VU64(lpop(&lbl_tbl));
	push_resource(v90);
	lpush(&lbl_tbl, MKU64(v92));
	uint64_t v93 = mw_mirth_table_Table_head(v92);
	VAL r94 = pop_resource();
	VAL v95 = (mw_mirth_elab_abZ_tokenZBang(r94, v93));
	int64_t v96 = 0LL;
	VAL r97 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v96, r97, v95);
	int64_t v98 = 0LL /* CoerceUnsafe */;
	VAL r99 = pop_resource();
	VAL r100 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v98), r100, r99);
	VAL r101 = pop_resource();
	VAL r102 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v91, r102, r101);
	VAL r103 = pop_resource();
	VAL r104 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r104, r103, v82);
	VAL v105 = mtw_mirth_mirth_PropLabel_WordArrow(v78);
	VAL r106 = pop_resource();
	VAL v107 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v107, v105, r106);
	VAL v108 = pop_value();
	void* v109 = mfld_mirth_word_Word_ZTildearrow(v78);
	mut_set(v108, MKPTR(v109));
	uint64_t v110 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_tbl, MKU64(v110));
	uint64_t v111 = mw_mirth_table_Table_head(v110);
	uint64_t v112 = VU64(lpop(&lbl_tbl));
	STR* v113;
	STRLIT(v113, "NUM", 3);
	int64_t v114 = 0LL;
	push_u64(v111);
	lpush(&lbl_tbl, MKU64(v112));
	VAL v115 = mw_mirth_elab_tableZ_qname(v112, MKSTR(v113), v114);
	int64_t v116 = 8LL;
	push_value(v115);
	int64_t v117 = mw_std_prim_Int_ZToNat(v116);
	VAL v118 = pop_value();
	uint64_t v119 = pop_u64();
	VAL r120 = pop_resource();
	mw_mirth_buffer_Buffer_newZBang(r120, v119, v118, v117);
	uint64_t v121 = VU64(lpop(&lbl_tbl));
	void* v122 = mfld_mirth_table_Table_ZTildenumZ_buffer(v121);
	VAL v123 = pop_value();
	mut_set(v123, MKPTR(v122));
	STR* v124;
	STRLIT(v124, "index", 5);
	int64_t v125 = 0LL;
	VAL r126 = pop_resource();
	lpush(&lbl_tbl, MKU64(v121));
	mw_mirth_elab_tableZ_wordZ_newZBang(r126, v121, MKSTR(v124), v125);
	uint64_t v127 = pop_u64();
	int64_t v128 = 0LL /* Nil */;
	uint64_t v129 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_word, MKU64(v127));
	push_i64(v128);
	lpush(&lbl_tbl, MKU64(v129));
	VAL v130 = mtw_mirth_type_Type_TTable(v129);
	VAL v131 = mw_mirth_type_T1(v130);
	push_value(v131);
	VAL v132 = mw_mirth_type_TYPEz_INT();
	VAL v133 = mw_mirth_type_T1(v132);
	VAL v134 = pop_value();
	VAL v135 = mw_mirth_type_TZ_ZTo(v134, v133);
	uint64_t v136 = VU64(lpop(&lbl_word));
	push_value(v135);
	lpush(&lbl_word, MKU64(v136));
	VAL v137 = mtw_mirth_mirth_PropLabel_WordType(v136);
	VAL r138 = pop_resource();
	VAL v139 = pop_value();
	VAL v140 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v140, v139, v137, r138);
	uint64_t v141 = VU64(lpop(&lbl_word));
	void* v142 = mfld_mirth_word_Word_ZTildectxZ_type(v141);
	VAL v143 = pop_value();
	mut_set(v143, MKPTR(v142));
	VAL r144 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r144, v141);
	uint64_t v145 = pop_u64();
	VAL v146 = pop_value();
	VAL v147 = pop_value();
	VAL v148 = pop_value();
	mw_mirth_type_ArrowType_unpack(v148);
	VAL v149 = pop_value();
	VAL v150 = pop_value();
	VAL v151 = pop_value();
	incref(v147);
	incref(v150);
	int64_t v152 = 0LL /* Nil */;
	push_value(v149);
	VAL v153 = mtw_mirth_arrow_Arrow_Arrow(v146, VU64(v147), VU64(v147), v151, v150, v150, MKI64(v152));
	VAL v154 = pop_value();
	uint64_t v155 = VU64(lpop(&lbl_tbl));
	push_resource(v153);
	lpush(&lbl_tbl, MKU64(v155));
	uint64_t v156 = mw_mirth_table_Table_head(v155);
	VAL r157 = pop_resource();
	VAL v158 = (mw_mirth_elab_abZ_tokenZBang(r157, v156));
	int64_t v159 = 0LL /* CoerceUnsafe */;
	VAL r160 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v159), r160, v158);
	VAL r161 = pop_resource();
	VAL r162 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v154, r162, r161);
	VAL r163 = pop_resource();
	VAL r164 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r164, r163, v145);
	VAL v165 = mtw_mirth_mirth_PropLabel_WordArrow(v141);
	VAL r166 = pop_resource();
	VAL v167 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v167, v165, r166);
	VAL v168 = pop_value();
	void* v169 = mfld_mirth_word_Word_ZTildearrow(v141);
	mut_set(v168, MKPTR(v169));
	uint64_t v170 = VU64(lpop(&lbl_tbl));
	STR* v171;
	STRLIT(v171, "from-index", 10);
	int64_t v172 = 0LL;
	VAL r173 = pop_resource();
	lpush(&lbl_tbl, MKU64(v170));
	mw_mirth_elab_tableZ_wordZ_newZBang(r173, v170, MKSTR(v171), v172);
	uint64_t v174 = pop_u64();
	int64_t v175 = 0LL /* Nil */;
	uint64_t v176 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_word, MKU64(v174));
	push_i64(v175);
	lpush(&lbl_tbl, MKU64(v176));
	VAL v177 = mtw_mirth_type_Type_TTable(v176);
	VAL v178 = mw_mirth_type_T1(v177);
	push_value(v178);
	VAL v179 = mw_mirth_type_TYPEz_INT();
	VAL v180 = mw_mirth_type_T1(v179);
	VAL v181 = pop_value();
	VAL v182 = mw_mirth_type_TZ_ZTo(v180, v181);
	uint64_t v183 = VU64(lpop(&lbl_word));
	push_value(v182);
	lpush(&lbl_word, MKU64(v183));
	VAL v184 = mtw_mirth_mirth_PropLabel_WordType(v183);
	VAL r185 = pop_resource();
	VAL v186 = pop_value();
	VAL v187 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v187, v186, v184, r185);
	uint64_t v188 = VU64(lpop(&lbl_word));
	void* v189 = mfld_mirth_word_Word_ZTildectxZ_type(v188);
	VAL v190 = pop_value();
	mut_set(v190, MKPTR(v189));
	VAL r191 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r191, v188);
	uint64_t v192 = pop_u64();
	VAL v193 = pop_value();
	VAL v194 = pop_value();
	VAL v195 = pop_value();
	mw_mirth_type_ArrowType_unpack(v195);
	VAL v196 = pop_value();
	VAL v197 = pop_value();
	VAL v198 = pop_value();
	incref(v194);
	incref(v197);
	int64_t v199 = 0LL /* Nil */;
	push_value(v196);
	VAL v200 = mtw_mirth_arrow_Arrow_Arrow(v193, VU64(v194), VU64(v194), v198, v197, v197, MKI64(v199));
	VAL v201 = pop_value();
	uint64_t v202 = VU64(lpop(&lbl_tbl));
	push_resource(v200);
	lpush(&lbl_tbl, MKU64(v202));
	uint64_t v203 = mw_mirth_table_Table_head(v202);
	VAL r204 = pop_resource();
	VAL v205 = (mw_mirth_elab_abZ_tokenZBang(r204, v203));
	int64_t v206 = 0LL /* CoerceUnsafe */;
	VAL r207 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v206), r207, v205);
	VAL r208 = pop_resource();
	VAL r209 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v201, r209, r208);
	VAL r210 = pop_resource();
	VAL r211 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r211, r210, v192);
	VAL v212 = mtw_mirth_mirth_PropLabel_WordArrow(v188);
	VAL r213 = pop_resource();
	VAL v214 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v214, v212, r213);
	VAL v215 = pop_value();
	void* v216 = mfld_mirth_word_Word_ZTildearrow(v188);
	mut_set(v215, MKPTR(v216));
	uint64_t v217 = VU64(lpop(&lbl_tbl));
	STR* v218;
	STRLIT(v218, "succ", 4);
	int64_t v219 = 0LL;
	VAL r220 = pop_resource();
	lpush(&lbl_tbl, MKU64(v217));
	mw_mirth_elab_tableZ_wordZ_newZBang(r220, v217, MKSTR(v218), v219);
	uint64_t v221 = pop_u64();
	int64_t v222 = 0LL /* Nil */;
	uint64_t v223 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_word, MKU64(v221));
	push_i64(v222);
	lpush(&lbl_tbl, MKU64(v223));
	VAL v224 = mtw_mirth_type_Type_TTable(v223);
	VAL v225 = mw_mirth_type_T1(v224);
	incref(v225);
	VAL v226 = mw_mirth_type_TZ_ZTo(v225, v225);
	uint64_t v227 = VU64(lpop(&lbl_word));
	push_value(v226);
	lpush(&lbl_word, MKU64(v227));
	VAL v228 = mtw_mirth_mirth_PropLabel_WordType(v227);
	VAL r229 = pop_resource();
	VAL v230 = pop_value();
	VAL v231 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v231, v230, v228, r229);
	uint64_t v232 = VU64(lpop(&lbl_word));
	void* v233 = mfld_mirth_word_Word_ZTildectxZ_type(v232);
	VAL v234 = pop_value();
	mut_set(v234, MKPTR(v233));
	VAL r235 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r235, v232);
	uint64_t v236 = pop_u64();
	VAL v237 = pop_value();
	VAL v238 = pop_value();
	VAL v239 = pop_value();
	mw_mirth_type_ArrowType_unpack(v239);
	VAL v240 = pop_value();
	VAL v241 = pop_value();
	VAL v242 = pop_value();
	incref(v238);
	incref(v241);
	int64_t v243 = 0LL /* Nil */;
	push_value(v240);
	VAL v244 = mtw_mirth_arrow_Arrow_Arrow(v237, VU64(v238), VU64(v238), v242, v241, v241, MKI64(v243));
	VAL v245 = pop_value();
	uint64_t v246 = VU64(lpop(&lbl_tbl));
	push_resource(v244);
	lpush(&lbl_tbl, MKU64(v246));
	uint64_t v247 = mw_mirth_table_Table_head(v246);
	VAL r248 = pop_resource();
	VAL v249 = (mw_mirth_elab_abZ_tokenZBang(r248, v247));
	int64_t v250 = 0LL /* CoerceUnsafe */;
	VAL r251 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v250), r251, v249);
	int64_t v252 = 1LL;
	VAL r253 = pop_resource();
	VAL r254 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v252, r254, r253);
	int64_t v255 = 20LL /* PRIM_INT_ADD */;
	VAL r256 = pop_resource();
	VAL r257 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v255, r257, r256);
	uint64_t v258 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_tbl, MKU64(v258));
	uint64_t v259 = mw_mirth_table_Table_numZ_buffer(v258);
	VAL r260 = pop_resource();
	VAL r261 = pop_resource();
	mw_mirth_elab_abZ_bufferZBang(v259, r261, r260);
	int64_t v262 = 89LL /* PRIM_U64_GET */;
	VAL r263 = pop_resource();
	VAL r264 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v262, r264, r263);
	int64_t v265 = 0LL /* CoerceUnsafe */;
	VAL r266 = pop_resource();
	VAL r267 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v265), r267, r266);
	int64_t v268 = 1LL;
	VAL r269 = pop_resource();
	VAL r270 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v268, r270, r269);
	int64_t v271 = 20LL /* PRIM_INT_ADD */;
	VAL r272 = pop_resource();
	VAL r273 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v271, r273, r272);
	int64_t v274 = 24LL /* PRIM_INT_MOD */;
	VAL r275 = pop_resource();
	VAL r276 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v274, r276, r275);
	int64_t v277 = 0LL /* CoerceUnsafe */;
	VAL r278 = pop_resource();
	VAL r279 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v277), r279, r278);
	VAL r280 = pop_resource();
	VAL r281 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v245, r281, r280);
	VAL r282 = pop_resource();
	VAL r283 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r283, r282, v236);
	VAL v284 = mtw_mirth_mirth_PropLabel_WordArrow(v232);
	VAL r285 = pop_resource();
	VAL v286 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v286, v284, r285);
	VAL v287 = pop_value();
	void* v288 = mfld_mirth_word_Word_ZTildearrow(v232);
	mut_set(v287, MKPTR(v288));
	uint64_t v289 = VU64(lpop(&lbl_tbl));
	STR* v290;
	STRLIT(v290, "pred", 4);
	int64_t v291 = 0LL;
	VAL r292 = pop_resource();
	lpush(&lbl_tbl, MKU64(v289));
	mw_mirth_elab_tableZ_wordZ_newZBang(r292, v289, MKSTR(v290), v291);
	uint64_t v293 = pop_u64();
	int64_t v294 = 0LL /* Nil */;
	uint64_t v295 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_word, MKU64(v293));
	push_i64(v294);
	lpush(&lbl_tbl, MKU64(v295));
	VAL v296 = mtw_mirth_type_Type_TTable(v295);
	VAL v297 = mw_mirth_type_T1(v296);
	incref(v297);
	VAL v298 = mw_mirth_type_TZ_ZTo(v297, v297);
	uint64_t v299 = VU64(lpop(&lbl_word));
	push_value(v298);
	lpush(&lbl_word, MKU64(v299));
	VAL v300 = mtw_mirth_mirth_PropLabel_WordType(v299);
	VAL r301 = pop_resource();
	VAL v302 = pop_value();
	VAL v303 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v303, v302, v300, r301);
	uint64_t v304 = VU64(lpop(&lbl_word));
	void* v305 = mfld_mirth_word_Word_ZTildectxZ_type(v304);
	VAL v306 = pop_value();
	mut_set(v306, MKPTR(v305));
	VAL r307 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r307, v304);
	uint64_t v308 = pop_u64();
	VAL v309 = pop_value();
	VAL v310 = pop_value();
	VAL v311 = pop_value();
	mw_mirth_type_ArrowType_unpack(v311);
	VAL v312 = pop_value();
	VAL v313 = pop_value();
	VAL v314 = pop_value();
	incref(v310);
	incref(v313);
	int64_t v315 = 0LL /* Nil */;
	push_value(v312);
	VAL v316 = mtw_mirth_arrow_Arrow_Arrow(v309, VU64(v310), VU64(v310), v314, v313, v313, MKI64(v315));
	VAL v317 = pop_value();
	uint64_t v318 = VU64(lpop(&lbl_tbl));
	push_resource(v316);
	lpush(&lbl_tbl, MKU64(v318));
	uint64_t v319 = mw_mirth_table_Table_head(v318);
	VAL r320 = pop_resource();
	VAL v321 = (mw_mirth_elab_abZ_tokenZBang(r320, v319));
	int64_t v322 = 0LL /* CoerceUnsafe */;
	VAL r323 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v322), r323, v321);
	int64_t v324 = 1LL /* PRIM_CORE_DUP */;
	VAL r325 = pop_resource();
	VAL r326 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v324, r326, r325);
	int64_t v327 = 0LL;
	VAL r328 = pop_resource();
	VAL r329 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v327, r329, r328);
	int64_t v330 = 14LL /* PRIM_INT_EQ */;
	VAL r331 = pop_resource();
	VAL r332 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v330, r332, r331);
	VAL r333 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r333);
	VAL r334 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r334);
	uint64_t v335 = mw_mirth_type_MetaVar_newZBang();
	VAL v336 = mtw_mirth_type_StackType_STMeta(v335);
	VAL v337 = pop_value();
	VAL v338 = pop_value();
	VAL r339 = pop_resource();
	push_value(v337);
	push_value(v336);
	push_value(v338);
	mw_mirth_elab_abZ_homeZAt(r339);
	VAL r340 = pop_resource();
	VAL v341 = pop_value();
	uint64_t v342 = pop_u64();
	VAL v343 = pop_value();
	incref(v343);
	VAL v344 = pop_value();
	int64_t v345 = 0LL /* Nil */;
	VAL v346 = mtw_mirth_arrow_Arrow_Arrow(v341, v342, v342, v344, v343, v343, MKI64(v345));
	VAL r347 = pop_resource();
	mw_mirth_arrow_Block_newZBang(r347, v346);
	uint64_t v348 = pop_u64();
	push_resource(r340);
	VAL v349 = mtw_mirth_arrow_Op_OpBlockPush(v348);
	VAL r350 = pop_resource();
	VAL r351 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v349, r351, r350);
	VAL r352 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r352);
	VAL r353 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r353);
	uint64_t v354 = mw_mirth_type_MetaVar_newZBang();
	VAL v355 = mtw_mirth_type_StackType_STMeta(v354);
	VAL v356 = pop_value();
	VAL v357 = pop_value();
	VAL r358 = pop_resource();
	push_value(v356);
	push_value(v355);
	push_value(v357);
	mw_mirth_elab_abZ_homeZAt(r358);
	VAL r359 = pop_resource();
	VAL v360 = pop_value();
	uint64_t v361 = pop_u64();
	VAL v362 = pop_value();
	incref(v362);
	VAL v363 = pop_value();
	int64_t v364 = 0LL /* Nil */;
	VAL v365 = mtw_mirth_arrow_Arrow_Arrow(v360, v361, v361, v363, v362, v362, MKI64(v364));
	int64_t v366 = 1LL;
	VAL r367 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v366, r367, v365);
	int64_t v368 = 21LL /* PRIM_INT_SUB */;
	VAL r369 = pop_resource();
	VAL r370 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v368, r370, r369);
	VAL r371 = pop_resource();
	VAL r372 = pop_resource();
	mw_mirth_arrow_Block_newZBang(r372, r371);
	uint64_t v373 = pop_u64();
	push_resource(r359);
	VAL v374 = mtw_mirth_arrow_Op_OpBlockPush(v373);
	VAL r375 = pop_resource();
	VAL r376 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v374, r376, r375);
	int64_t v377 = 5LL /* PRIM_CORE_IF */;
	VAL r378 = pop_resource();
	VAL r379 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v377, r379, r378);
	int64_t v380 = 0LL /* CoerceUnsafe */;
	VAL r381 = pop_resource();
	VAL r382 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v380), r382, r381);
	VAL r383 = pop_resource();
	VAL r384 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v317, r384, r383);
	VAL r385 = pop_resource();
	VAL r386 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r386, r385, v308);
	VAL v387 = mtw_mirth_mirth_PropLabel_WordArrow(v304);
	VAL r388 = pop_resource();
	VAL v389 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v389, v387, r388);
	VAL v390 = pop_value();
	void* v391 = mfld_mirth_word_Word_ZTildearrow(v304);
	mut_set(v390, MKPTR(v391));
	uint64_t v392 = VU64(lpop(&lbl_tbl));
	STR* v393;
	STRLIT(v393, "for", 3);
	int64_t v394 = 1LL;
	VAL r395 = pop_resource();
	lpush(&lbl_tbl, MKU64(v392));
	mw_mirth_elab_tableZ_wordZ_newZBang(r395, v392, MKSTR(v393), v394);
	uint64_t v396 = pop_u64();
	lpush(&lbl_word, MKU64(v396));
	VAL v397 = mw_mirth_type_TYPEz_STACK();
	STR* v398;
	STRLIT(v398, "*a", 2);
	push_value(v397);
	uint64_t v399 = mw_std_prim_Str_ZToName(MKSTR(v398));
	VAL v400 = pop_value();
	uint64_t v401 = mw_mirth_var_Var_newZBang(v400, v399);
	lpush(&lbl_va, MKU64(v401));
	VAL v402 = mtw_mirth_type_StackType_STVar(v401);
	uint64_t v403 = VU64(lpop(&lbl_tbl));
	push_value(v402);
	lpush(&lbl_tbl, MKU64(v403));
	VAL v404 = mtw_mirth_type_Type_TTable(v403);
	VAL v405 = pop_value();
	VAL v406 = mw_mirth_type_TZMul(v405, v404);
	uint64_t v407 = VU64(lpop(&lbl_va));
	push_value(v406);
	lpush(&lbl_va, MKU64(v407));
	VAL v408 = mtw_mirth_type_StackType_STVar(v407);
	VAL v409 = pop_value();
	VAL v410 = mw_mirth_type_TZ_ZTo(v409, v408);
	VAL v411 = mw_mirth_type_ArrowType_ZToType(v410);
	STR* v412;
	STRLIT(v412, "f", 1);
	push_value(v411);
	uint64_t v413 = mw_std_prim_Str_ZToName(MKSTR(v412));
	VAL v414 = pop_value();
	uint64_t v415 = mw_mirth_var_Var_newZ_autoZ_runZBang(v414, v413);
	uint64_t v416 = VU64(lpop(&lbl_va));
	lpush(&lbl_vx, MKU64(v415));
	lpush(&lbl_va, MKU64(v416));
	VAL v417 = mw_mirth_var_Ctx1(v416);
	uint64_t v418 = VU64(lpop(&lbl_va));
	push_value(v417);
	lpush(&lbl_va, MKU64(v418));
	VAL v419 = mtw_mirth_type_StackType_STVar(v418);
	uint64_t v420 = VU64(lpop(&lbl_vx));
	push_value(v419);
	lpush(&lbl_vx, MKU64(v420));
	VAL v421 = mw_mirth_var_Var_type(v420);
	VAL v422 = pop_value();
	VAL v423 = mw_mirth_type_TZMul(v422, v421);
	uint64_t v424 = VU64(lpop(&lbl_va));
	push_value(v423);
	lpush(&lbl_va, MKU64(v424));
	VAL v425 = mtw_mirth_type_StackType_STVar(v424);
	VAL v426 = pop_value();
	VAL v427 = mw_mirth_type_TZ_ZTo(v426, v425);
	uint64_t v428 = VU64(lpop(&lbl_word));
	push_value(v427);
	lpush(&lbl_word, MKU64(v428));
	VAL v429 = mtw_mirth_mirth_PropLabel_WordType(v428);
	VAL r430 = pop_resource();
	VAL v431 = pop_value();
	VAL v432 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v432, v431, v429, r430);
	uint64_t v433 = VU64(lpop(&lbl_word));
	void* v434 = mfld_mirth_word_Word_ZTildectxZ_type(v433);
	VAL v435 = pop_value();
	mut_set(v435, MKPTR(v434));
	uint64_t v436 = VU64(lpop(&lbl_vx));
	int64_t v437 = 0LL /* Nil */;
	lpush(&lbl_word, MKU64(v433));
	lpush(&lbl_vx, MKU64(v436));
	VAL v438 = mtw_std_list_List_1_Cons(MKU64(v436), MKI64(v437));
	uint64_t v439 = VU64(lpop(&lbl_word));
	push_value(v438);
	lpush(&lbl_word, MKU64(v439));
	VAL v440 = mtw_mirth_mirth_PropLabel_WordParams(v439);
	VAL r441 = pop_resource();
	VAL v442 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v442, v440, r441);
	uint64_t v443 = VU64(lpop(&lbl_word));
	void* v444 = mfld_mirth_word_Word_ZTildeparams(v443);
	VAL v445 = pop_value();
	mut_set(v445, MKPTR(v444));
	lpush(&lbl_word, MKU64(v443));
	mw_mirth_word_Word_makeZ_inlineZBang(v443);
	uint64_t v446 = VU64(lpop(&lbl_word));
	VAL r447 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r447, v446);
	uint64_t v448 = pop_u64();
	VAL v449 = pop_value();
	VAL v450 = pop_value();
	VAL v451 = pop_value();
	mw_mirth_type_ArrowType_unpack(v451);
	VAL v452 = pop_value();
	VAL v453 = pop_value();
	VAL v454 = pop_value();
	incref(v450);
	incref(v453);
	int64_t v455 = 0LL /* Nil */;
	push_value(v452);
	VAL v456 = mtw_mirth_arrow_Arrow_Arrow(v449, VU64(v450), VU64(v450), v454, v453, v453, MKI64(v455));
	VAL v457 = pop_value();
	uint64_t v458 = VU64(lpop(&lbl_tbl));
	push_resource(v456);
	lpush(&lbl_tbl, MKU64(v458));
	uint64_t v459 = mw_mirth_table_Table_head(v458);
	VAL r460 = pop_resource();
	VAL v461 = (mw_mirth_elab_abZ_tokenZBang(r460, v459));
	uint64_t v462 = VU64(lpop(&lbl_vx));
	int64_t v463 = 0LL /* Nil */;
	push_resource(v461);
	lpush(&lbl_vx, MKU64(v462));
	VAL v464 = mtw_std_list_List_1_Cons(MKU64(v462), MKI64(v463));
	VAL r465 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r465);
	incref(v464);
	VAL r466 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r466);
	VAL r467 = pop_resource();
	mw_mirth_elab_abZ_typeZAt(r467);
	VAL v468 = mw_std_list_List_1_reverse(v464);
	mw_std_list_List_1_uncons(v468);
	VAL v469 = pop_value();
	VAL v470 = pop_value();
	push_value(v469);
	push_value(v470);
	while(1) {
		VAL v471 = pop_value();
		incref(v471);
		push_value(v471);
		int64_t v472 = mw_std_maybe_Maybe_1_someZAsk(v471);
		if (!((bool)v472)) break;
		VAL v473 = pop_value();
		VAL v474 = mw_std_maybe_Maybe_1_unwrap(v473);
		VAL v475 = pop_value();
		VAL v476 = pop_value();
		incref(v474);
		VAL v477 = pop_value();
		VAL v478 = mw_mirth_var_Ctx_new(v477, VU64(v474));
		VAL r479 = pop_resource();
		push_value(v478);
		push_value(v474);
		push_value(v476);
		mw_mirth_elab_abZ_tokenZAt(r479);
		VAL r480 = pop_resource();
		uint64_t v481 = pop_u64();
		VAL v482 = pop_value();
		VAL r483 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang(r483, v482, v481);
		uint64_t v484 = pop_u64();
		VAL v485 = pop_value();
		VAL v486 = pop_value();
		VAL v487 = pop_value();
		push_resource(r480);
		push_value(v486);
		push_value(v485);
		VAL v488 = mw_mirth_var_Var_type(VU64(v487));
		VAL r489 = pop_resource();
		VAL v490 = pop_value();
		VAL r491 = pop_resource();
		mw_mirth_elab_elabZ_typeZ_unifyZBang(r491, v490, v488, v484);
		VAL v492 = pop_value();
		decref(v492);
		VAL v493 = pop_value();
		decref(v493);
		push_resource(r489);
		mw_std_list_List_1_uncons(v475);
		VAL v494 = pop_value();
		VAL v495 = pop_value();
		push_value(v494);
		push_value(v495);
	}
	VAL v496 = pop_value();
	decref(v496);
	VAL v497 = pop_value();
	decref(v497);
	VAL v498 = pop_value();
	VAL v499 = pop_value();
	VAL v500 = pop_value();
	VAL r501 = pop_resource();
	push_value(v499);
	push_value(v498);
	push_value(v500);
	mw_mirth_elab_abZ_homeZAt(r501);
	VAL r502 = pop_resource();
	VAL v503 = pop_value();
	uint64_t v504 = pop_u64();
	VAL v505 = pop_value();
	incref(v505);
	VAL v506 = pop_value();
	int64_t v507 = 0LL /* Nil */;
	VAL v508 = mtw_mirth_arrow_Arrow_Arrow(v503, v504, v504, v506, v505, v505, MKI64(v507));
	int64_t v509 = 1LL;
	VAL r510 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v509, r510, v508);
	VAL r511 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r511);
	VAL r512 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r512);
	uint64_t v513 = mw_mirth_type_MetaVar_newZBang();
	VAL v514 = mtw_mirth_type_StackType_STMeta(v513);
	VAL v515 = pop_value();
	VAL v516 = pop_value();
	VAL r517 = pop_resource();
	push_value(v515);
	push_value(v514);
	push_value(v516);
	mw_mirth_elab_abZ_homeZAt(r517);
	VAL r518 = pop_resource();
	VAL v519 = pop_value();
	uint64_t v520 = pop_u64();
	VAL v521 = pop_value();
	incref(v521);
	VAL v522 = pop_value();
	int64_t v523 = 0LL /* Nil */;
	VAL v524 = mtw_mirth_arrow_Arrow_Arrow(v519, v520, v520, v522, v521, v521, MKI64(v523));
	int64_t v525 = 1LL /* PRIM_CORE_DUP */;
	VAL r526 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v525, r526, v524);
	uint64_t v527 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_tbl, MKU64(v527));
	uint64_t v528 = mw_mirth_table_Table_numZ_buffer(v527);
	VAL r529 = pop_resource();
	VAL r530 = pop_resource();
	mw_mirth_elab_abZ_bufferZBang(v528, r530, r529);
	int64_t v531 = 97LL /* PRIM_I64_GET */;
	VAL r532 = pop_resource();
	VAL r533 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v531, r533, r532);
	int64_t v534 = 0LL /* CoerceUnsafe */;
	VAL r535 = pop_resource();
	VAL r536 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v534), r536, r535);
	int64_t v537 = 16LL /* PRIM_INT_LE */;
	VAL r538 = pop_resource();
	VAL r539 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v537, r539, r538);
	VAL r540 = pop_resource();
	VAL r541 = pop_resource();
	mw_mirth_arrow_Block_newZBang(r541, r540);
	uint64_t v542 = pop_u64();
	push_resource(r518);
	VAL v543 = mtw_mirth_arrow_Op_OpBlockPush(v542);
	VAL r544 = pop_resource();
	VAL r545 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v543, r545, r544);
	VAL r546 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r546);
	VAL r547 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r547);
	uint64_t v548 = mw_mirth_type_MetaVar_newZBang();
	VAL v549 = mtw_mirth_type_StackType_STMeta(v548);
	VAL v550 = pop_value();
	VAL v551 = pop_value();
	VAL r552 = pop_resource();
	push_value(v550);
	push_value(v549);
	push_value(v551);
	mw_mirth_elab_abZ_homeZAt(r552);
	VAL r553 = pop_resource();
	VAL v554 = pop_value();
	uint64_t v555 = pop_u64();
	VAL v556 = pop_value();
	incref(v556);
	VAL v557 = pop_value();
	int64_t v558 = 0LL /* Nil */;
	VAL v559 = mtw_mirth_arrow_Arrow_Arrow(v554, v555, v555, v557, v556, v556, MKI64(v558));
	int64_t v560 = 1LL /* PRIM_CORE_DUP */;
	VAL r561 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v560, r561, v559);
	VAL r562 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r562);
	VAL r563 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r563);
	uint64_t v564 = mw_mirth_type_MetaVar_newZBang();
	VAL v565 = mtw_mirth_type_StackType_STMeta(v564);
	VAL v566 = pop_value();
	VAL v567 = pop_value();
	VAL r568 = pop_resource();
	push_value(v566);
	push_value(v565);
	push_value(v567);
	mw_mirth_elab_abZ_homeZAt(r568);
	VAL r569 = pop_resource();
	VAL v570 = pop_value();
	uint64_t v571 = pop_u64();
	VAL v572 = pop_value();
	incref(v572);
	VAL v573 = pop_value();
	int64_t v574 = 0LL /* Nil */;
	VAL v575 = mtw_mirth_arrow_Arrow_Arrow(v570, v571, v571, v573, v572, v572, MKI64(v574));
	int64_t v576 = 0LL /* CoerceUnsafe */;
	VAL r577 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v576), r577, v575);
	uint64_t v578 = VU64(lpop(&lbl_vx));
	VAL r579 = pop_resource();
	VAL r580 = pop_resource();
	lpush(&lbl_vx, MKU64(v578));
	mw_mirth_elab_abZ_varZBang(v578, r580, r579);
	VAL r581 = pop_resource();
	VAL r582 = pop_resource();
	mw_mirth_arrow_Block_newZBang(r582, r581);
	uint64_t v583 = pop_u64();
	push_resource(r569);
	VAL v584 = mtw_mirth_arrow_Op_OpBlockPush(v583);
	VAL r585 = pop_resource();
	VAL r586 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v584, r586, r585);
	int64_t v587 = 4LL /* PRIM_CORE_DIP */;
	VAL r588 = pop_resource();
	VAL r589 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v587, r589, r588);
	int64_t v590 = 1LL;
	VAL r591 = pop_resource();
	VAL r592 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v590, r592, r591);
	int64_t v593 = 20LL /* PRIM_INT_ADD */;
	VAL r594 = pop_resource();
	VAL r595 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v593, r595, r594);
	VAL r596 = pop_resource();
	VAL r597 = pop_resource();
	mw_mirth_arrow_Block_newZBang(r597, r596);
	uint64_t v598 = pop_u64();
	push_resource(r553);
	VAL v599 = mtw_mirth_arrow_Op_OpBlockPush(v598);
	VAL r600 = pop_resource();
	VAL r601 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v599, r601, r600);
	int64_t v602 = 6LL /* PRIM_CORE_WHILE */;
	VAL r603 = pop_resource();
	VAL r604 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v602, r604, r603);
	int64_t v605 = 2LL /* PRIM_CORE_DROP */;
	VAL r606 = pop_resource();
	VAL r607 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v605, r607, r606);
	VAL r608 = pop_resource();
	lpush(&lbl_params, v464);
	lpush(&lbl_body, r608);
	mw_mirth_elab_abZ_ctxZAt(r502);
	VAL v609 = pop_value();
	VAL r610 = pop_resource();
	lpush(&lbl_outerZ_ctx, v609);
	mw_mirth_elab_abZ_typeZAt(r610);
	VAL v611 = pop_value();
	VAL r612 = pop_resource();
	lpush(&lbl_dom, v611);
	mw_mirth_elab_abZ_tokenZAt(r612);
	uint64_t v613 = pop_u64();
	VAL v614 = lpop(&lbl_body);
	VAL v615 = lpop(&lbl_params);
	VAL v616 = lpop(&lbl_dom);
	VAL v617 = lpop(&lbl_outerZ_ctx);
	VAL v618 = mtw_mirth_arrow_Lambda_Lambda(v613, v617, v616, v615, v614);
	VAL v619 = mtw_mirth_arrow_Op_OpLambda(v618);
	VAL r620 = pop_resource();
	VAL r621 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v619, r621, r620);
	VAL r622 = pop_resource();
	VAL r623 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v457, r623, r622);
	VAL r624 = pop_resource();
	VAL r625 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r625, r624, v448);
	VAL v626 = mtw_mirth_mirth_PropLabel_WordArrow(v446);
	VAL r627 = pop_resource();
	VAL v628 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v628, v626, r627);
	VAL v629 = pop_value();
	void* v630 = mfld_mirth_word_Word_ZTildearrow(v446);
	mut_set(v629, MKPTR(v630));
	uint64_t v631 = VU64(lpop(&lbl_va));
	uint64_t v632 = VU64(lpop(&lbl_vx));
	uint64_t v633 = VU64(lpop(&lbl_tbl));
	STR* v634;
	STRLIT(v634, "alloc!", 6);
	int64_t v635 = 0LL;
	VAL r636 = pop_resource();
	lpush(&lbl_tbl, MKU64(v633));
	mw_mirth_elab_tableZ_wordZ_newZBang(r636, v633, MKSTR(v634), v635);
	uint64_t v637 = pop_u64();
	int64_t v638 = 0LL /* Nil */;
	lpush(&lbl_word, MKU64(v637));
	push_i64(v638);
	VAL v639 = mw_mirth_type_T0();
	uint64_t v640 = VU64(lpop(&lbl_tbl));
	push_value(v639);
	lpush(&lbl_tbl, MKU64(v640));
	VAL v641 = mtw_mirth_type_Type_TTable(v640);
	VAL v642 = mw_mirth_type_T1(v641);
	VAL v643 = pop_value();
	VAL v644 = mw_mirth_type_TZ_ZTo(v643, v642);
	uint64_t v645 = VU64(lpop(&lbl_word));
	push_value(v644);
	lpush(&lbl_word, MKU64(v645));
	VAL v646 = mtw_mirth_mirth_PropLabel_WordType(v645);
	VAL r647 = pop_resource();
	VAL v648 = pop_value();
	VAL v649 = pop_value();
	mw_mirth_mirth_PropLabel_prop2(v649, v648, v646, r647);
	uint64_t v650 = VU64(lpop(&lbl_word));
	void* v651 = mfld_mirth_word_Word_ZTildectxZ_type(v650);
	VAL v652 = pop_value();
	mut_set(v652, MKPTR(v651));
	VAL r653 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r653, v650);
	uint64_t v654 = pop_u64();
	VAL v655 = pop_value();
	VAL v656 = pop_value();
	VAL v657 = pop_value();
	mw_mirth_type_ArrowType_unpack(v657);
	VAL v658 = pop_value();
	VAL v659 = pop_value();
	VAL v660 = pop_value();
	incref(v656);
	incref(v659);
	int64_t v661 = 0LL /* Nil */;
	push_value(v658);
	VAL v662 = mtw_mirth_arrow_Arrow_Arrow(v655, VU64(v656), VU64(v656), v660, v659, v659, MKI64(v661));
	VAL v663 = pop_value();
	uint64_t v664 = VU64(lpop(&lbl_tbl));
	push_resource(v662);
	lpush(&lbl_tbl, MKU64(v664));
	uint64_t v665 = mw_mirth_table_Table_head(v664);
	VAL r666 = pop_resource();
	VAL v667 = (mw_mirth_elab_abZ_tokenZBang(r666, v665));
	uint64_t v668 = VU64(lpop(&lbl_tbl));
	push_resource(v667);
	lpush(&lbl_tbl, MKU64(v668));
	uint64_t v669 = mw_mirth_table_Table_numZ_buffer(v668);
	VAL r670 = pop_resource();
	VAL r671 = pop_resource();
	mw_mirth_elab_abZ_bufferZBang(v669, r671, r670);
	int64_t v672 = 89LL /* PRIM_U64_GET */;
	VAL r673 = pop_resource();
	VAL r674 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v672, r674, r673);
	int64_t v675 = 0LL /* CoerceUnsafe */;
	VAL r676 = pop_resource();
	VAL r677 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v675), r677, r676);
	int64_t v678 = 1LL;
	VAL r679 = pop_resource();
	VAL r680 = pop_resource();
	mw_mirth_elab_abZ_intZBang(v678, r680, r679);
	int64_t v681 = 20LL /* PRIM_INT_ADD */;
	VAL r682 = pop_resource();
	VAL r683 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v681, r683, r682);
	int64_t v684 = 1LL /* PRIM_CORE_DUP */;
	VAL r685 = pop_resource();
	VAL r686 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v684, r686, r685);
	int64_t v687 = 0LL /* CoerceUnsafe */;
	VAL r688 = pop_resource();
	VAL r689 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v687), r689, r688);
	uint64_t v690 = VU64(lpop(&lbl_tbl));
	lpush(&lbl_tbl, MKU64(v690));
	uint64_t v691 = mw_mirth_table_Table_numZ_buffer(v690);
	VAL r692 = pop_resource();
	VAL r693 = pop_resource();
	mw_mirth_elab_abZ_bufferZBang(v691, r693, r692);
	int64_t v694 = 90LL /* PRIM_U64_SET */;
	VAL r695 = pop_resource();
	VAL r696 = pop_resource();
	mw_mirth_elab_abZ_primZBang(v694, r696, r695);
	int64_t v697 = 0LL /* CoerceUnsafe */;
	VAL r698 = pop_resource();
	VAL r699 = pop_resource();
	mw_mirth_elab_abZ_coerceZBang(MKI64(v697), r699, r698);
	VAL r700 = pop_resource();
	VAL r701 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v663, r701, r700);
	VAL r702 = pop_resource();
	VAL r703 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r703, r702, v654);
	VAL v704 = mtw_mirth_mirth_PropLabel_WordArrow(v650);
	VAL r705 = pop_resource();
	VAL v706 = pop_value();
	mw_mirth_mirth_PropLabel_prop(v706, v704, r705);
	VAL v707 = pop_value();
	void* v708 = mfld_mirth_word_Word_ZTildearrow(v650);
	mut_set(v707, MKPTR(v708));
	uint64_t v709 = VU64(lpop(&lbl_tbl));
	push_u64(v709);
}
static void mw_mirth_elab_resolveZ_defZ_namespace (VAL x1, uint64_t x2) {
	STR* v0;
	STRLIT(v0, "namespace", 9);
	int64_t v1 = 1LL /* True */;
	int64_t v2 = 0LL /* False */;
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v0), x2, v2, v1, x1);
	VAL r3 = pop_resource();
	VAL v4 = VVAL(VTUP(r3)->cells[3]);
	incref(v4);
	int64_t v5 = 0LL /* Nil */;
	int64_t v6 = 0LL /* Nil */;
	push_resource(r3);
	push_i64(v5);
	push_i64(v6);
	mw_std_list_List_1_uncons(v4);
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	while(1) {
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
		if (!((bool)v10)) break;
		VAL v11 = pop_value();
		VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v12);
		VAL r16 = pop_resource();
		VAL r17 = pop_resource();
		push_value(v12);
		mw_mirth_def_Def_exposedZ_tyconZAsk(r17, v12);
		VAL v18 = pop_value();
		push_resource(r16);
		int64_t v19 = mw_std_maybe_Maybe_1_ZToBool(v18);
		if (((bool)v19)) {
			VAL v20 = pop_value();
			VAL v21 = mtw_std_either_Either_2_Right(v20);
			push_value(v21);
		} else {
			VAL v22 = pop_value();
			VAL v23 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT(v22);
			VAL v24 = mtw_std_either_Either_2_Left(v23);
			push_value(v24);
		}
		VAL v25 = pop_value();
		switch (get_data_tag(v25)) {
			case 0LL: { // Left
				push_value(v15);
				push_value(v14);
				VAL v26 = mtp_std_either_Either_2_Left(v25);
				VAL v27 = pop_value();
				VAL v28 = pop_value();
				VAL v29 = mtw_std_list_List_1_Cons(v26, v28);
				push_value(v29);
				push_value(v27);
			} break;
			case 1LL: { // Right
				push_value(v15);
				push_value(v14);
				VAL v30 = mtp_std_either_Either_2_Right(v25);
				VAL v31 = pop_value();
				VAL v32 = mtw_std_list_List_1_Cons(v30, v31);
				push_value(v32);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_value(v15);
				push_value(v14);
			}
		}
		mw_std_list_List_1_uncons(v13);
		VAL v33 = pop_value();
		VAL v34 = pop_value();
		push_value(v33);
		push_value(v34);
	}
	VAL v35 = pop_value();
	decref(v35);
	VAL v36 = pop_value();
	decref(v36);
	VAL v37 = pop_value();
	VAL v38 = pop_value();
	VAL v39 = mw_std_list_List_1_reverse(v38);
	push_value(v39);
	VAL v40 = mw_std_list_List_1_reverse(v37);
	VAL r41 = pop_resource();
	VAL v42 = VVAL(VTUP(r41)->cells[4]);
	incref(v42);
	VAL v43 = pop_value();
	VAL v44 = mw_std_list_List_1_cat(v43, v42);
	VAL v45 = VTUP(r41)->cells[4];
	decref(v45);
	VTUP(r41)->cells[4] = v44;
	VAL v46 = VTUP(r41)->cells[3];
	decref(v46);
	VTUP(r41)->cells[3] = v40;
	VAL r47 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(r47, r41);
	int64_t v48 = 0LL /* Nil */;
	VAL r49 = pop_resource();
	VAL r50 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots(MKI64(v48), r50, r49);
	VAL r51 = pop_resource();
	VAL r52 = pop_resource();
	mw_mirth_elab_resolveZ_defZ_endZBang(r52, r51);
	VAL v53 = pop_value();
	switch (get_data_tag(v53)) {
		case 1LL: { // Some
			VAL v54 = mtp_std_maybe_Maybe_1_Some(v53);
			VAL r55 = pop_resource();
			mw_mirth_def_Def_asZ_namespaceZAsk(r55, v54);
		} break;
		case 0LL: { // None
			int64_t v56 = 0LL /* None */;
			push_i64(v56);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname (VAL x1, uint64_t x2, VAL x3, int64_t x4) {
	incref(x3);
	push_resource(x1);
	push_u64(x2);
	lpush(&lbl_arity, MKI64(x4));
	push_value(x3);
	VAL v0 = mw_mirth_name_DName_rootZAsk(x3);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			decref(v1);
		} break;
		case 0LL: { // None
			VAL v2 = pop_value();
			decref(v2);
			STR* v3;
			STRLIT(v3, "relative name not allowed", 25);
			VAL r4 = pop_resource();
			uint64_t v5 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v5, MKSTR(v3), r4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v6 = pop_value();
	uint64_t v7 = mw_mirth_name_DName_lastZ_name(v6);
	uint64_t v8 = pop_u64();
	VAL r9 = pop_resource();
	lpush(&lbl_name, MKU64(v7));
	push_u64(v8);
	mw_mirth_elab_resolveZ_defZ_namespace(r9, v8);
	VAL v10 = pop_value();
	switch (get_data_tag(v10)) {
		case 1LL: { // Some
			VAL v11 = mtp_std_maybe_Maybe_1_Some(v10);
			push_value(v11);
		} break;
		case 0LL: { // None
			VAL r12 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang(r12);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v13 = pop_value();
	uint64_t v14 = pop_u64();
	int64_t v15 = VI64(lpop(&lbl_arity));
	uint64_t v16 = VU64(lpop(&lbl_name));
	VAL v17 = mtw_mirth_name_QName_MKQNAME(v13, v16, v15);
	push_value(v17);
}
static int64_t mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk (uint64_t x1, uint64_t x2) {
	push_u64(x2);
	uint64_t v0 = mw_mirth_token_Token_module(x1);
	uint64_t v1 = pop_u64();
	int64_t v2 = mw_mirth_module_Module_visible(v1, v0);
	return v2;
}
static void mw_mirth_elab_elabZ_defZ_qname (VAL x1, uint64_t x2) {
	push_resource(x1);
	push_u64(x2);
	VAL v0 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			STR* v2;
			STRLIT(v2, "expected name", 13);
			VAL r3 = pop_resource();
			uint64_t v4 = pop_u64();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v4, MKSTR(v2), r3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	switch (get_data_tag(v5)) {
		case 0LL: { // Left
			VAL v6 = mtp_std_either_Either_2_Left(v5);
			uint64_t v7 = pop_u64();
			lpush(&lbl_name, v6);
			push_u64(v7);
			uint64_t v8 = mw_mirth_token_Token_module(v7);
			VAL v9 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v8);
			uint64_t v10 = pop_u64();
			lpush(&lbl_namespace, v9);
			int64_t v11 = mw_mirth_token_Token_numZ_args(v10);
			uint64_t v12 = VU64(lpop(&lbl_name));
			VAL v13 = lpop(&lbl_namespace);
			VAL v14 = mtw_mirth_name_QName_MKQNAME(v13, v12, v11);
			push_value(v14);
		} break;
		case 1LL: { // Right
			VAL v15 = mtp_std_either_Either_2_Right(v5);
			VAL v16 = pop_value();
			incref(v16);
			push_value(v16);
			push_value(v15);
			int64_t v17 = mw_mirth_token_Token_numZ_args(VU64(v16));
			VAL v18 = pop_value();
			uint64_t v19 = pop_u64();
			VAL r20 = pop_resource();
			mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname(r20, v19, v18, v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_defZ_qnameZ_undefined (VAL x1, uint64_t x2) {
	push_u64(x2);
	mw_mirth_elab_elabZ_defZ_qname(x1, x2);
	VAL v0 = pop_value();
	incref(v0);
	VAL r1 = pop_resource();
	push_value(v0);
	mw_mirth_name_QName_definedZ_softZAsk(r1, v0);
	bool v2 = pop_bool();
	if (v2) {
		VAL v3 = pop_value();
		decref(v3);
		STR* v4;
		STRLIT(v4, "name already defined", 20);
		VAL r5 = pop_resource();
		uint64_t v6 = pop_u64();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v6, MKSTR(v4), r5);
	} else {
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_elab_elabZ_defZ_head (VAL x1, uint64_t x2) {
	push_resource(x1);
	lpush(&lbl_head, MKU64(x2));
	VAL v0 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			push_value(v1);
		} break;
		case 0LL: { // None
			uint64_t v2 = VU64(lpop(&lbl_head));
			STR* v3;
			STRLIT(v3, "expected name", 13);
			VAL r4 = pop_resource();
			lpush(&lbl_head, MKU64(v2));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v2, MKSTR(v3), r4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	switch (get_data_tag(v5)) {
		case 0LL: { // Left
			VAL v6 = mtp_std_either_Either_2_Left(v5);
			push_value(v6);
		} break;
		case 1LL: { // Right
			VAL v7 = mtp_std_either_Either_2_Right(v5);
			VAL v8 = mw_mirth_name_DName_parts(v7);
			VAL v9 = mw_std_list_ListZPlus_1_last(v8);
			push_value(v9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v10 = pop_u64();
	uint64_t v11 = VU64(lpop(&lbl_head));
	lpush(&lbl_name, MKU64(v10));
	lpush(&lbl_head, MKU64(v11));
	int64_t v12 = mw_mirth_token_Token_numZ_args(v11);
	uint64_t v13 = VU64(lpop(&lbl_head));
	FNPTR v14 = &mb_mirth_elab_elabZ_defZ_head_3;
	lpush(&lbl_arity, MKI64(v12));
	lpush(&lbl_head, MKU64(v13));
	VAL v15 = mtw_mirth_mirth_PropState_1_PSDelay(MKU64(v13), MKFNPTR(v14));
	lpush(&lbl_state, v15);
}
static void mw_mirth_elab_parseZ_field (VAL x1, uint64_t x2) {
	push_resource(x1);
	uint64_t v0 = mw_mirth_token_Token_next(x2);
	VAL r1 = pop_resource();
	push_u64(v0);
	mw_mirth_token_Token_argsZ_3(x2, r1);
	uint64_t v2 = pop_u64();
	uint64_t v3 = pop_u64();
	uint64_t v4 = pop_u64();
	lpush(&lbl_valueZ_type, MKU64(v2));
	lpush(&lbl_indexZ_type, MKU64(v3));
	lpush(&lbl_head, MKU64(v4));
	VAL v5 = mw_mirth_token_Token_nameZ_orZ_dnameZAsk(v4);
	switch (get_data_tag(v5)) {
		case 1LL: { // Some
			VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
			decref(v6);
		} break;
		case 0LL: { // None
			uint64_t v7 = VU64(lpop(&lbl_head));
			STR* v8;
			STRLIT(v8, "expected field name", 19);
			VAL r9 = pop_resource();
			lpush(&lbl_head, MKU64(v7));
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v7, MKSTR(v8), r9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	uint64_t v10 = VU64(lpop(&lbl_head));
	VAL r11 = pop_resource();
	lpush(&lbl_head, MKU64(v10));
	VAL v12 = (mw_mirth_token_Token_argsZ_0(v10, r11));
	push_resource(v12);
}
static void mw_mirth_elab_elabZ_fieldZBang (VAL x1, uint64_t x2) {
	mw_mirth_elab_parseZ_field(x1, x2);
	uint64_t v0 = VU64(lpop(&lbl_head));
	VAL r1 = pop_resource();
	mw_mirth_elab_elabZ_defZ_head(r1, v0);
	uint64_t v2 = mw_mirth_table_Field_allocZBang();
	uint64_t v3 = VU64(lpop(&lbl_name));
	void* v4 = mfld_mirth_table_Field_ZTildename(v2);
	mut_set(MKU64(v3), MKPTR(v4));
	uint64_t v5 = VU64(lpop(&lbl_head));
	void* v6 = mfld_mirth_table_Field_ZTildehead(v2);
	mut_set(MKU64(v5), MKPTR(v6));
	int64_t v7 = VI64(lpop(&lbl_arity));
	int64_t v8 = 0LL;
	bool v9 = (v7 == v8);
	if (v9) {
		lpush(&lbl_fld, MKU64(v2));
		push_i64(v7);
	} else {
		STR* v10;
		STRLIT(v10, "expected arity 0 in elab-field!", 31);
		lpush(&lbl_fld, MKU64(v2));
		push_i64(v7);
		push_str(v10);
		do_panic();
		do_panic();
	}
	int64_t v11 = pop_i64();
	uint64_t v12 = VU64(lpop(&lbl_fld));
	lpush(&lbl_fld, MKU64(v12));
	VAL v13 = mtw_mirth_mirth_PropLabel_FieldQName(v12);
	VAL v14 = lpop(&lbl_state);
	VAL v15 = mtw_mirth_mirth_Prop_1_Prop(v13, v14);
	uint64_t v16 = VU64(lpop(&lbl_fld));
	void* v17 = mfld_mirth_table_Field_ZTildeqname(v16);
	mut_set(v15, MKPTR(v17));
	uint64_t v18 = VU64(lpop(&lbl_indexZ_type));
	push_u64(v18);
	lpush(&lbl_fld, MKU64(v16));
	VAL v19 = mtw_mirth_mirth_PropLabel_FieldIndexType(v16);
	FNPTR v20 = &mb_mirth_elab_elabZ_fieldZBang_2;
	VAL r21 = pop_resource();
	VAL v22 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v22, v19, r21, MKFNPTR(v20));
	uint64_t v23 = VU64(lpop(&lbl_fld));
	void* v24 = mfld_mirth_table_Field_ZTildeindexZ_type(v23);
	VAL v25 = pop_value();
	mut_set(v25, MKPTR(v24));
	uint64_t v26 = VU64(lpop(&lbl_valueZ_type));
	push_u64(v26);
	lpush(&lbl_fld, MKU64(v23));
	VAL v27 = mtw_mirth_mirth_PropLabel_FieldValueType(v23);
	FNPTR v28 = &mb_mirth_elab_elabZ_fieldZBang_3;
	VAL r29 = pop_resource();
	VAL v30 = pop_value();
	mw_mirth_mirth_PropLabel_prop_1(v30, v27, r29, MKFNPTR(v28));
	uint64_t v31 = VU64(lpop(&lbl_fld));
	void* v32 = mfld_mirth_table_Field_ZTildevalueZ_type(v31);
	VAL v33 = pop_value();
	mut_set(v33, MKPTR(v32));
	VAL v34 = mtw_mirth_def_Def_DefField(v31);
	VAL r35 = pop_resource();
	VAL v36 = (mw_mirth_def_Def_register(r35, v34));
	push_resource(v36);
}
static VAL mw_std_map_Map_2_empty (void) {
	int64_t v0 = 0LL /* Nil */;
	return MKI64(v0);
}
static VAL mw_std_map_Map_2_insert (VAL x1, VAL x2) {
	VAL v0 = mtw_std_list_List_1_Cons(x1, x2);
	return v0;
}
static void mw_mirth_specializzer_runZ_specializzerZBang (VAL x1, VAL x2) {
	push_resource(x1);
	push_value(x2);
	VAL v0 = (mw_mirth_specializzer_ZPlusSPCheck_beginZBang());
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v2, r1, v0);
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	mw_mirth_specializzer_ZPlusSPCheck_loopZBang(r4, r3);
	VAL r5 = pop_resource();
	mw_mirth_specializzer_ZPlusSPCheck_endZBang(r5);
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_beginZBang (void) {
	int64_t v0 = 0LL /* Nil */;
	return MKI64(v0);
}
static void mw_mirth_specializzer_ZPlusSPCheck_endZBang (VAL x1) {
	decref(x1);
}
static void mw_mirth_specializzer_ZPlusSPCheck_loopZBang (VAL x1, VAL x2) {
	incref(x2);
	push_resource(x1);
	mw_std_list_List_1_uncons(x2);
	decref(x2);
	VAL v0 = pop_value();
	push_resource(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		int64_t v2 = mw_std_maybe_Maybe_1_someZAsk(v1);
		if (!((bool)v2)) break;
		VAL v3 = pop_value();
		VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
		VAL r5 = pop_resource();
		VAL r6 = pop_resource();
		mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang(v4, r6, r5);
		VAL r7 = pop_resource();
		incref(r7);
		mw_std_list_List_1_uncons(r7);
		decref(r7);
		VAL v8 = pop_value();
		push_resource(v8);
	}
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x1)) {
		case 0LL: { // SPCHECK_WORD
			push_resource(x2);
			push_resource(x3);
			uint64_t v0 = mtp_mirth_specializzer_SPCheckItem_SPCHECKz_WORD(x1);
			VAL r1 = pop_resource();
			VAL r2 = pop_resource();
			lpush(&lbl_w, MKU64(v0));
			mw_mirth_word_Word_arrow(v0, r2);
			VAL r3 = pop_resource();
			VAL v4 = pop_value();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v4, r3, r1);
			uint64_t v5 = VU64(lpop(&lbl_w));
			lpush(&lbl_w, MKU64(v5));
			VAL v6 = mtw_mirth_mirth_PropLabel_WordArrow(v5);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			VAL v9 = pop_value();
			mw_mirth_mirth_PropLabel_prop(v9, v6, r8);
			uint64_t v10 = VU64(lpop(&lbl_w));
			void* v11 = mfld_mirth_word_Word_ZTildearrow(v10);
			VAL v12 = pop_value();
			mut_set(v12, MKPTR(v11));
			push_resource(r7);
		} break;
		case 1LL: { // SPCHECK_BLOCK
			push_resource(x2);
			push_resource(x3);
			uint64_t v13 = mtp_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK(x1);
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			lpush(&lbl_b, MKU64(v13));
			mw_mirth_arrow_Block_arrow(r15, v13);
			VAL r16 = pop_resource();
			VAL v17 = pop_value();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v17, r16, r14);
			uint64_t v18 = VU64(lpop(&lbl_b));
			lpush(&lbl_b, MKU64(v18));
			VAL v19 = mtw_mirth_mirth_PropLabel_BlockArrow(v18);
			VAL r20 = pop_resource();
			VAL r21 = pop_resource();
			VAL v22 = pop_value();
			mw_mirth_mirth_PropLabel_prop(v22, v19, r21);
			uint64_t v23 = VU64(lpop(&lbl_b));
			void* v24 = mfld_mirth_arrow_Block_ZTildearrow(v23);
			VAL v25 = pop_value();
			mut_set(v25, MKPTR(v24));
			push_resource(r20);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_resource(x3);
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	int64_t v1 = 0LL /* Nil */;
	push_resource(x2);
	push_resource(x3);
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	push_resource(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL r12 = pop_resource();
		VAL r13 = pop_resource();
		mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang(v9, r13, r12);
		VAL v14 = pop_value();
		push_resource(r11);
		mw_std_list_List_1_uncons(v14);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
		while(1) {
			VAL v17 = pop_value();
			incref(v17);
			push_value(v17);
			int64_t v18 = mw_std_maybe_Maybe_1_someZAsk(v17);
			if (!((bool)v18)) break;
			VAL v19 = pop_value();
			VAL v20 = mw_std_maybe_Maybe_1_unwrap(v19);
			VAL v21 = pop_value();
			VAL r22 = pop_resource();
			VAL v23 = mtw_std_list_List_1_Cons(v20, r22);
			push_resource(v23);
			mw_std_list_List_1_uncons(v21);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
		}
		VAL v26 = pop_value();
		decref(v26);
		VAL v27 = pop_value();
		decref(v27);
		mw_std_list_List_1_uncons(v10);
		VAL v28 = pop_value();
		VAL v29 = pop_value();
		push_value(v28);
		push_value(v29);
	}
	VAL v30 = pop_value();
	decref(v30);
	VAL v31 = pop_value();
	decref(v31);
	VAL r32 = pop_resource();
	VAL v33 = mw_std_list_List_1_reverse(r32);
	VAL v34 = tup_replace(x1, 7, v33);
	push_value(v34);
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // OpNone
			int64_t v1 = 0LL /* Nil */;
			push_resource(x2);
			push_resource(x3);
			VAL v2 = mtw_std_list_List_1_Cons(x1, MKI64(v1));
			push_value(v2);
		} break;
		case 1LL: { // OpPrim
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			int64_t v3 = mtp_mirth_arrow_Op_OpPrim(v0);
			VAL r4 = pop_resource();
			VAL v5 = pop_value();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang(v5, v3, r4);
		} break;
		case 2LL: { // OpWord
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v6 = mtp_mirth_arrow_Op_OpWord(v0);
			VAL v7 = pop_value();
			VAL r8 = pop_resource();
			VAL r9 = pop_resource();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang(r9, r8, v7, v6);
		} break;
		case 3LL: { // OpExternal
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v10 = mtp_mirth_arrow_Op_OpExternal(v0);
			int64_t v11 = 0LL /* Nil */;
			VAL v12 = pop_value();
			VAL v13 = mtw_std_list_List_1_Cons(v12, MKI64(v11));
			push_value(v13);
		} break;
		case 4LL: { // OpBuffer
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v14 = mtp_mirth_arrow_Op_OpBuffer(v0);
			int64_t v15 = 0LL /* Nil */;
			VAL v16 = pop_value();
			VAL v17 = mtw_std_list_List_1_Cons(v16, MKI64(v15));
			push_value(v17);
		} break;
		case 5LL: { // OpVariable
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v18 = mtp_mirth_arrow_Op_OpVariable(v0);
			int64_t v19 = 0LL /* Nil */;
			VAL v20 = pop_value();
			VAL v21 = mtw_std_list_List_1_Cons(v20, MKI64(v19));
			push_value(v21);
		} break;
		case 6LL: { // OpField
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v22 = mtp_mirth_arrow_Op_OpField(v0);
			int64_t v23 = 0LL /* Nil */;
			VAL v24 = pop_value();
			VAL v25 = mtw_std_list_List_1_Cons(v24, MKI64(v23));
			push_value(v25);
		} break;
		case 7LL: { // OpInt
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			int64_t v26 = mtp_mirth_arrow_Op_OpInt(v0);
			int64_t v27 = 0LL /* Nil */;
			VAL v28 = pop_value();
			VAL v29 = mtw_std_list_List_1_Cons(v28, MKI64(v27));
			push_value(v29);
		} break;
		case 8LL: { // OpF64
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			double v30 = mtp_mirth_arrow_Op_OpF64(v0);
			int64_t v31 = 0LL /* Nil */;
			VAL v32 = pop_value();
			VAL v33 = mtw_std_list_List_1_Cons(v32, MKI64(v31));
			push_value(v33);
		} break;
		case 9LL: { // OpStr
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			VAL v34 = mtp_mirth_arrow_Op_OpStr(v0);
			decref(v34);
			int64_t v35 = 0LL /* Nil */;
			VAL v36 = pop_value();
			VAL v37 = mtw_std_list_List_1_Cons(v36, MKI64(v35));
			push_value(v37);
		} break;
		case 10LL: { // OpTag
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v38 = mtp_mirth_arrow_Op_OpTag(v0);
			int64_t v39 = 0LL /* Nil */;
			VAL v40 = pop_value();
			VAL v41 = mtw_std_list_List_1_Cons(v40, MKI64(v39));
			push_value(v41);
		} break;
		case 11LL: { // OpMatch
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			VAL v42 = mtp_mirth_arrow_Op_OpMatch(v0);
			VAL r43 = pop_resource();
			VAL r44 = pop_resource();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang(v42, r44, r43);
			VAL v45 = pop_value();
			VAL v46 = mtw_mirth_arrow_Op_OpMatch(v45);
			VAL v47 = pop_value();
			VAL v48 = tup_replace(v47, 4, v46);
			int64_t v49 = 0LL /* Nil */;
			VAL v50 = mtw_std_list_List_1_Cons(v48, MKI64(v49));
			push_value(v50);
		} break;
		case 12LL: { // OpLambda
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			VAL v51 = mtp_mirth_arrow_Op_OpLambda(v0);
			VAL r52 = pop_resource();
			VAL r53 = pop_resource();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang(v51, r53, r52);
			VAL v54 = pop_value();
			VAL v55 = mtw_mirth_arrow_Op_OpLambda(v54);
			VAL v56 = pop_value();
			VAL v57 = tup_replace(v56, 4, v55);
			int64_t v58 = 0LL /* Nil */;
			VAL v59 = mtw_std_list_List_1_Cons(v57, MKI64(v58));
			push_value(v59);
		} break;
		case 13LL: { // OpVar
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v60 = mtp_mirth_arrow_Op_OpVar(v0);
			int64_t v61 = 0LL /* Nil */;
			VAL v62 = pop_value();
			VAL v63 = mtw_std_list_List_1_Cons(v62, MKI64(v61));
			push_value(v63);
		} break;
		case 14LL: { // OpBlockPush
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v64 = mtp_mirth_arrow_Op_OpBlockPush(v0);
			VAL r65 = pop_resource();
			VAL v66 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang(v64, r65));
			int64_t v67 = 0LL /* Nil */;
			VAL v68 = pop_value();
			push_resource(v66);
			VAL v69 = mtw_std_list_List_1_Cons(v68, MKI64(v67));
			push_value(v69);
		} break;
		case 15LL: { // OpBlockRun
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v70 = mtp_mirth_arrow_Op_OpBlockRun(v0);
			VAL r71 = pop_resource();
			VAL v72 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang(v70, r71));
			int64_t v73 = 0LL /* Nil */;
			VAL v74 = pop_value();
			push_resource(v72);
			VAL v75 = mtw_std_list_List_1_Cons(v74, MKI64(v73));
			push_value(v75);
		} break;
		case 16LL: { // OpCoerce
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			VAL v76 = mtp_mirth_arrow_Op_OpCoerce(v0);
			decref(v76);
			int64_t v77 = 0LL /* Nil */;
			VAL v78 = pop_value();
			VAL v79 = mtw_std_list_List_1_Cons(v78, MKI64(v77));
			push_value(v79);
		} break;
		case 17LL: { // OpLabelPush
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v80 = mtp_mirth_arrow_Op_OpLabelPush(v0);
			int64_t v81 = 0LL /* Nil */;
			VAL v82 = pop_value();
			VAL v83 = mtw_std_list_List_1_Cons(v82, MKI64(v81));
			push_value(v83);
		} break;
		case 18LL: { // OpLabelPop
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v84 = mtp_mirth_arrow_Op_OpLabelPop(v0);
			int64_t v85 = 0LL /* Nil */;
			VAL v86 = pop_value();
			VAL v87 = mtw_std_list_List_1_Cons(v86, MKI64(v85));
			push_value(v87);
		} break;
		case 19LL: { // OpLabelPushR
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v88 = mtp_mirth_arrow_Op_OpLabelPushR(v0);
			int64_t v89 = 0LL /* Nil */;
			VAL v90 = pop_value();
			VAL v91 = mtw_std_list_List_1_Cons(v90, MKI64(v89));
			push_value(v91);
		} break;
		case 20LL: { // OpLabelPopR
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v92 = mtp_mirth_arrow_Op_OpLabelPopR(v0);
			int64_t v93 = 0LL /* Nil */;
			VAL v94 = pop_value();
			VAL v95 = mtw_std_list_List_1_Cons(v94, MKI64(v93));
			push_value(v95);
		} break;
		case 21LL: { // OpDataGetTag
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			uint64_t v96 = mtp_mirth_arrow_Op_OpDataGetTag(v0);
			int64_t v97 = 0LL /* Nil */;
			VAL v98 = pop_value();
			VAL v99 = mtw_std_list_List_1_Cons(v98, MKI64(v97));
			push_value(v99);
		} break;
		case 22LL: { // OpDataGetLabel
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			mtp_mirth_arrow_Op_OpDataGetLabel(v0);
			VAL v100 = pop_value();
			decref(v100);
			VAL v101 = pop_value();
			decref(v101);
			int64_t v102 = 0LL /* Nil */;
			VAL v103 = pop_value();
			VAL v104 = mtw_std_list_List_1_Cons(v103, MKI64(v102));
			push_value(v104);
		} break;
		case 23LL: { // OpDataSetLabel
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
			mtp_mirth_arrow_Op_OpDataSetLabel(v0);
			VAL v105 = pop_value();
			decref(v105);
			VAL v106 = pop_value();
			decref(v106);
			int64_t v107 = 0LL /* Nil */;
			VAL v108 = pop_value();
			VAL v109 = mtw_std_list_List_1_Cons(v108, MKI64(v107));
			push_value(v109);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_resource(x3);
			push_value(x1);
		}
	}
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang (uint64_t x1, VAL x2) {
	VAL v0 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang(x1, x2));
	return v0;
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang (VAL x1, int64_t x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	push_resource(x3);
	push_value(x1);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL v9 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v6), r8));
		push_resource(v9);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
	int64_t v14 = 0LL /* Nil */;
	VAL v15 = pop_value();
	VAL v16 = mtw_std_list_List_1_Cons(v15, MKI64(v14));
	push_value(v16);
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang (VAL x1, VAL x2, VAL x3, uint64_t x4) {
	push_resource(x1);
	push_value(x3);
	push_u64(x4);
	VAL v0 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang(x4, x2));
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = VVAL(VTUP(v2)->cells[5]);
	incref(v3);
	decref(v2);
	push_resource(v0);
	push_value(v2);
	push_value(v1);
	VAL v4 = mw_std_list_List_1_ZToListZPlus(v3);
	switch (get_data_tag(v4)) {
		case 0LL: { // None
			uint64_t v5 = pop_u64();
			int64_t v6 = 0LL /* Nil */;
			VAL v7 = pop_value();
			VAL v8 = mtw_std_list_List_1_Cons(v7, MKI64(v6));
			push_value(v8);
		} break;
		case 1LL: { // Some
			VAL v9 = mtp_std_maybe_Maybe_1_Some(v4);
			incref(v9);
			push_value(v9);
			mw_std_list_List_1_uncons(v9);
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			push_value(v10);
			push_value(v11);
			while(1) {
				VAL v12 = pop_value();
				incref(v12);
				push_value(v12);
				int64_t v13 = mw_std_maybe_Maybe_1_someZAsk(v12);
				if (!((bool)v13)) break;
				VAL v14 = pop_value();
				VAL v15 = mw_std_maybe_Maybe_1_unwrap(v14);
				VAL v16 = pop_value();
				VAL r17 = pop_resource();
				VAL v18 = (mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang(VU64(v15), r17));
				push_resource(v18);
				mw_std_list_List_1_uncons(v16);
				VAL v19 = pop_value();
				VAL v20 = pop_value();
				push_value(v19);
				push_value(v20);
			}
			VAL v21 = pop_value();
			decref(v21);
			VAL v22 = pop_value();
			decref(v22);
			VAL v23 = pop_value();
			VAL v24 = pop_value();
			incref(v24);
			push_value(v24);
			push_value(v23);
			int64_t v25 = mw_mirth_word_Word_preferZ_inlineZAsk(VU64(v24));
			bool v26 = !((bool)v25);
			if (v26) {
				int64_t v27 = 1LL /* True */;
				push_i64(v27);
			} else {
				VAL v28 = pop_value();
				incref(v28);
				int64_t v29 = 0LL /* None */;
				push_value(v28);
				push_i64(v29);
				mw_std_list_List_1_uncons(v28);
				VAL v30 = pop_value();
				VAL v31 = pop_value();
				push_value(v30);
				push_value(v31);
				while(1) {
					VAL v32 = pop_value();
					incref(v32);
					push_value(v32);
					int64_t v33 = mw_std_maybe_Maybe_1_someZAsk(v32);
					if (!((bool)v33)) break;
					VAL v34 = pop_value();
					VAL v35 = mw_std_maybe_Maybe_1_unwrap(v34);
					VAL v36 = pop_value();
					VAL v37 = pop_value();
					incref(v35);
					VAL r38 = pop_resource();
					VAL r39 = pop_resource();
					mw_mirth_arrow_Arg_freeZ_vars(r39, VU64(v35));
					int64_t v40 = 0LL /* None */;
					VAL v41 = pop_value();
					push_resource(r38);
					push_i64(v40);
					mw_std_list_List_1_uncons(v41);
					VAL v42 = pop_value();
					VAL v43 = pop_value();
					push_value(v42);
					push_value(v43);
					while(1) {
						VAL v44 = pop_value();
						incref(v44);
						push_value(v44);
						int64_t v45 = mw_std_maybe_Maybe_1_someZAsk(v44);
						if (!((bool)v45)) break;
						VAL v46 = pop_value();
						VAL v47 = mw_std_maybe_Maybe_1_unwrap(v46);
						VAL v48 = pop_value();
						VAL v49 = pop_value();
						incref(v47);
						int64_t v50 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v47));
						if (((bool)v50)) {
							VAL v51 = mtw_std_maybe_Maybe_1_Some(v47);
							push_value(v51);
						} else {
							decref(v47);
							int64_t v52 = 0LL /* None */;
							push_i64(v52);
						}
						VAL v53 = pop_value();
						switch (get_data_tag(v53)) {
							case 0LL: { // None
								push_value(v49);
								push_value(v48);
							} break;
							default: {
								decref(v48);
								decref(v49);
								int64_t v54 = 0LL /* Nil */;
								push_value(v53);
								push_i64(v54);
							} break;
						}
						VAL v55 = pop_value();
						mw_std_list_List_1_uncons(v55);
						VAL v56 = pop_value();
						VAL v57 = pop_value();
						push_value(v56);
						push_value(v57);
					}
					VAL v58 = pop_value();
					decref(v58);
					VAL v59 = pop_value();
					decref(v59);
					VAL v60 = pop_value();
					int64_t v61 = mw_std_maybe_Maybe_1_someZAsk(v60);
					if (((bool)v61)) {
						VAL v62 = mtw_std_maybe_Maybe_1_Some(v35);
						push_value(v62);
					} else {
						decref(v35);
						int64_t v63 = 0LL /* None */;
						push_i64(v63);
					}
					VAL v64 = pop_value();
					switch (get_data_tag(v64)) {
						case 0LL: { // None
							push_value(v37);
							push_value(v36);
						} break;
						default: {
							decref(v36);
							decref(v37);
							int64_t v65 = 0LL /* Nil */;
							push_value(v64);
							push_i64(v65);
						} break;
					}
					VAL v66 = pop_value();
					mw_std_list_List_1_uncons(v66);
					VAL v67 = pop_value();
					VAL v68 = pop_value();
					push_value(v67);
					push_value(v68);
				}
				VAL v69 = pop_value();
				decref(v69);
				VAL v70 = pop_value();
				decref(v70);
				VAL v71 = pop_value();
				int64_t v72 = mw_std_maybe_Maybe_1_someZAsk(v71);
				push_i64(v72);
			}
			bool v73 = pop_bool();
			if (v73) {
				VAL v74 = pop_value();
				decref(v74);
				VAL v75 = pop_value();
				decref(v75);
				int64_t v76 = 0LL /* Nil */;
				VAL v77 = pop_value();
				VAL v78 = mtw_std_list_List_1_Cons(v77, MKI64(v76));
				push_value(v78);
			} else {
				VAL v79 = pop_value();
				uint64_t v80 = pop_u64();
				VAL r81 = pop_resource();
				VAL r82 = pop_resource();
				mw_mirth_specializzer_specializzeZ_wordZBang(r82, v79, v80);
				uint64_t v83 = pop_u64();
				push_u64(v83);
				VAL v84 = (mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang(v83, r81));
				uint64_t v85 = pop_u64();
				VAL v86 = pop_value();
				push_u64(v85);
				mtp_mirth_arrow_Atom_Atom(v86);
				VAL v87 = lpop(&lbl_ctx);
				VAL v88 = lpop(&lbl_dom);
				VAL v89 = lpop(&lbl_cod);
				push_value(v87);
				VAL v90 = mw_mirth_type_TZ_ZTo(v88, v89);
				uint64_t v91 = VU64(lpop(&lbl_token));
				VAL v92 = lpop(&lbl_home);
				VAL v93 = lpop(&lbl_subst);
				VAL v94 = lpop(&lbl_op);
				VAL v95 = lpop(&lbl_args);
				decref(v95);
				decref(v94);
				decref(v93);
				mw_mirth_type_ArrowType_unpack(v90);
				VAL v96 = pop_value();
				VAL v97 = pop_value();
				VAL v98 = pop_value();
				incref(v97);
				int64_t v99 = 0LL /* Nil */;
				push_value(v96);
				VAL v100 = mtw_mirth_arrow_Arrow_Arrow(v92, v91, v91, v98, v97, v97, MKI64(v99));
				VAL v101 = pop_value();
				VAL r102 = pop_resource();
				uint64_t v103 = pop_u64();
				mw_mirth_elab_abZ_wordZBang(v103, r102, v100);
				VAL r104 = pop_resource();
				VAL r105 = pop_resource();
				mw_mirth_elab_abZ_unifyZ_typeZBang(v101, r105, r104);
				VAL r106 = pop_resource();
				VAL v107 = VVAL(VTUP(r106)->cells[7]);
				incref(v107);
				decref(r106);
				push_resource(v84);
				push_value(v107);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	int64_t v1 = 0LL /* Nil */;
	push_resource(x2);
	push_resource(x3);
	push_value(v0);
	VAL v2 = mw_std_list_List_1_reverse(MKI64(v1));
	VAL v3 = pop_value();
	push_resource(v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL r12 = pop_resource();
		VAL r13 = pop_resource();
		mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang(v9, r13, r12);
		VAL v14 = pop_value();
		VAL v15 = mtw_std_list_List_1_Cons(v14, r11);
		push_resource(v15);
		mw_std_list_List_1_uncons(v10);
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
	}
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = pop_value();
	decref(v19);
	VAL r20 = pop_resource();
	VAL v21 = mw_std_list_List_1_reverse(r20);
	VAL v22 = tup_replace(x1, 7, v21);
	push_value(v22);
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[2]);
	incref(v0);
	decref(x1);
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v0, x2, x3);
	VAL v1 = pop_value();
	VAL v2 = tup_replace(x1, 2, v1);
	push_value(v2);
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang(v0, x2, x3);
	VAL v1 = pop_value();
	VAL v2 = tup_replace(x1, 5, v1);
	push_value(v2);
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildespZ_checked(x1);
	push_resource(x2);
	push_u64(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v4 = pop_bool();
	if (v4) {
		uint64_t v5 = pop_u64();
	} else {
		int64_t v6 = 1LL /* True */;
		VAL v7 = pop_value();
		incref(v7);
		void* v8 = mfld_mirth_word_Word_ZTildespZ_checked(VU64(v7));
		mut_set(MKI64(v6), MKPTR(v8));
		VAL v9 = mtw_mirth_specializzer_SPCheckItem_SPCHECKz_WORD(VU64(v7));
		VAL r10 = pop_resource();
		incref(r10);
		VAL v11 = mtw_std_list_List_1_Cons(v9, r10);
		decref(r10);
		push_resource(v11);
	}
	VAL r12 = pop_resource();
	return r12;
}
static VAL mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_arrow_Block_ZTildespZ_checked(x1);
	push_resource(x2);
	push_u64(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	bool v4 = pop_bool();
	if (v4) {
		uint64_t v5 = pop_u64();
	} else {
		int64_t v6 = 1LL /* True */;
		VAL v7 = pop_value();
		incref(v7);
		void* v8 = mfld_mirth_arrow_Block_ZTildespZ_checked(VU64(v7));
		mut_set(MKI64(v6), MKPTR(v8));
		VAL v9 = mtw_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK(VU64(v7));
		VAL r10 = pop_resource();
		incref(r10);
		VAL v11 = mtw_std_list_List_1_Cons(v9, r10);
		decref(r10);
		push_resource(v11);
	}
	VAL r12 = pop_resource();
	return r12;
}
static int64_t mw_mirth_specializzer_SPKey_ZEqualZEqual (VAL x1, VAL x2) {
	int64_t v0 = 1LL /* True */;
	push_value(x1);
	push_value(x2);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		mw_std_list_List_1_uncons(v3);
		mw_std_list_List_1_uncons(v2);
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		switch (get_data_tag(v5)) {
			case 0LL: { // None
				VAL v7 = pop_value();
				int64_t v8 = mw_std_maybe_Maybe_1_noneZAsk(v7);
				push_i64(v8);
			} break;
			case 1LL: { // Some
				VAL v9 = mtp_std_maybe_Maybe_1_Some(v5);
				VAL v10 = pop_value();
				switch (get_data_tag(v10)) {
					case 1LL: { // Some
						push_value(v9);
						VAL v11 = mtp_std_maybe_Maybe_1_Some(v10);
						uint64_t v12 = pop_u64();
						int64_t v13 = mw_mirth_arrow_Arg_ZEqualZEqual(VU64(v11), v12);
						push_i64(v13);
					} break;
					case 0LL: { // None
						decref(v9);
						int64_t v14 = 0LL /* False */;
						push_i64(v14);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_value(v9);
					}
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL v15 = pop_value();
		bool v16 = (VBOOL(v15) && ((bool)v1));
		incref(v6);
		push_value(v6);
		push_value(v4);
		push_bool(v16);
		int64_t v17 = mw_std_list_List_1_emptyZAsk(v6);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		incref(v19);
		push_value(v19);
		push_value(v18);
		push_i64(v17);
		int64_t v20 = mw_std_list_List_1_emptyZAsk(v19);
		bool v21 = pop_bool();
		bool v22 = (v21 && ((bool)v20));
		bool v23 = !v22;
		VAL v24 = pop_value();
		incref(v24);
		bool v25 = (v23 && VBOOL(v24));
		push_value(v24);
		if (!v25) break;
	}
	int64_t v26 = pop_i64();
	VAL v27 = pop_value();
	decref(v27);
	VAL v28 = pop_value();
	decref(v28);
	return v26;
}
static void mw_mirth_specializzer_SPKey_ZToStr (VAL x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "", 0);
	STR* v1;
	STRLIT(v1, "(", 1);
	push_resource(x1);
	push_value(x2);
	VAL v2 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v1), MKSTR(v0)));
	VAL v3 = pop_value();
	STR* v4;
	STRLIT(v4, "", 0);
	push_resource(v2);
	push_str(v4);
	mw_std_list_List_1_uncons(v3);
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		int64_t v8 = mw_std_maybe_Maybe_1_someZAsk(v7);
		if (!((bool)v8)) break;
		VAL v9 = pop_value();
		VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
		VAL v11 = pop_value();
		VAL r12 = pop_resource();
		VAL v13 = pop_value();
		VAL v14 = (mw_std_str_ZPlusStr_pushZ_strZBang(v13, r12));
		VAL r15 = pop_resource();
		mw_mirth_arrow_Arg_ZToStr(r15, VU64(v10));
		VAL v16 = pop_value();
		VAL v17 = (mw_std_str_ZPlusStr_pushZ_strZBang(v16, v14));
		STR* v18;
		STRLIT(v18, ",", 1);
		push_resource(v17);
		push_str(v18);
		mw_std_list_List_1_uncons(v11);
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	STR* v24;
	STRLIT(v24, ")", 1);
	VAL r25 = pop_resource();
	VAL v26 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), r25));
	push_value(v26);
}
static void mw_mirth_specializzer_SPKey_ZToName (VAL x1, VAL x2) {
	mw_mirth_specializzer_SPKey_ZToStr(x1, x2);
	VAL v0 = pop_value();
	uint64_t v1 = mw_std_prim_Str_ZToName(v0);
	push_u64(v1);
}
static VAL mw_mirth_word_Word_spZ_synthed (uint64_t x1) {
	void* v0 = mfld_mirth_word_Word_ZTildespZ_synthed(x1);
	VAL v1 = mw_std_prelude_ZAtZAsk(MKPTR(v0));
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			push_value(v2);
		} break;
		case 0LL: { // None
			VAL v3 = mw_std_map_Map_2_empty();
			push_value(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	return v4;
}
static void mw_mirth_specializzer_specializzeZ_wordZBang (VAL x1, VAL x2, uint64_t x3) {
	incref(x2);
	push_resource(x1);
	push_value(x2);
	lpush(&lbl_key, x2);
	lpush(&lbl_word, MKU64(x3));
	VAL v0 = mw_mirth_word_Word_spZ_synthed(x3);
	int64_t v1 = 0LL /* None */;
	push_i64(v1);
	mw_std_list_List_1_uncons(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = pop_value();
		incref(v10);
		VAL v11 = VVAL(VTUP(v7)->cells[1]);
		incref(v11);
		decref(v7);
		int64_t v12 = mw_mirth_specializzer_SPKey_ZEqualZEqual(v10, v11);
		if (((bool)v12)) {
			push_value(v10);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v13);
		} else {
			decref(v7);
			int64_t v14 = 0LL /* None */;
			push_value(v10);
			push_i64(v14);
		}
		VAL v15 = pop_value();
		switch (get_data_tag(v15)) {
			case 0LL: { // None
				push_value(v9);
				push_value(v8);
			} break;
			default: {
				decref(v8);
				decref(v9);
				int64_t v16 = 0LL /* Nil */;
				push_value(v15);
				push_i64(v16);
			} break;
		}
		VAL v17 = pop_value();
		mw_std_list_List_1_uncons(v17);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	decref(v23);
	switch (get_data_tag(v22)) {
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v22);
			VAL v25 = VVAL(VTUP(v24)->cells[2]);
			incref(v25);
			decref(v24);
			VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
			push_value(v26);
		} break;
		case 0LL: { // None
			int64_t v27 = 0LL /* None */;
			push_i64(v27);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v28 = pop_value();
	switch (get_data_tag(v28)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(v28);
			int64_t v30 = 0LL /* False */;
			incref(v29);
			void* v31 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(VU64(v29));
			mut_set(MKI64(v30), MKPTR(v31));
			push_value(v29);
		} break;
		case 0LL: { // None
			uint64_t v32 = VU64(lpop(&lbl_word));
			lpush(&lbl_word, MKU64(v32));
			uint64_t v33 = mw_mirth_word_Word_head(v32);
			int64_t v34 = 0LL /* None */;
			uint64_t v35 = VU64(lpop(&lbl_word));
			lpush(&lbl_head, MKU64(v33));
			lpush(&lbl_sigZAsk, MKI64(v34));
			lpush(&lbl_word, MKU64(v35));
			uint64_t v36 = mw_mirth_word_Word_body(v35);
			VAL v37 = lpop(&lbl_key);
			incref(v37);
			VAL r38 = pop_resource();
			lpush(&lbl_body, MKU64(v36));
			lpush(&lbl_key, v37);
			mw_mirth_specializzer_SPKey_ZToName(r38, v37);
			uint64_t v39 = pop_u64();
			int64_t v40 = 0LL;
			VAL r41 = pop_resource();
			uint64_t v42 = VU64(lpop(&lbl_body));
			VAL v43 = lpop(&lbl_sigZAsk);
			uint64_t v44 = VU64(lpop(&lbl_head));
			mw_mirth_word_Word_newZBang(v44, v43, v42, v39, v40, r41);
			uint64_t v45 = pop_u64();
			uint64_t v46 = VU64(lpop(&lbl_word));
			lpush(&lbl_wordZTick, MKU64(v45));
			lpush(&lbl_word, MKU64(v46));
			VAL v47 = mtw_mirth_name_Namespace_NAMESPACEz_WORD(v46);
			VAL v48 = lpop(&lbl_key);
			incref(v48);
			VAL r49 = pop_resource();
			push_value(v47);
			lpush(&lbl_key, v48);
			mw_mirth_specializzer_SPKey_ZToName(r49, v48);
			uint64_t v50 = pop_u64();
			VAL v51 = pop_value();
			VAL v52 = mw_mirth_name_QNAME0(v51, v50);
			uint64_t v53 = VU64(lpop(&lbl_wordZTick));
			push_value(v52);
			lpush(&lbl_wordZTick, MKU64(v53));
			VAL v54 = mtw_mirth_mirth_PropLabel_WordQName(v53);
			VAL r55 = pop_resource();
			VAL v56 = pop_value();
			mw_mirth_mirth_PropLabel_prop(v56, v54, r55);
			uint64_t v57 = VU64(lpop(&lbl_wordZTick));
			void* v58 = mfld_mirth_word_Word_ZTildeqname(v57);
			VAL v59 = pop_value();
			mut_set(v59, MKPTR(v58));
			VAL v60 = lpop(&lbl_key);
			incref(v60);
			lpush(&lbl_key, v60);
			lpush(&lbl_wordZTick, MKU64(v57));
			VAL v61 = mtw_std_map_KVPair_2_KVPair(v60, MKU64(v57));
			uint64_t v62 = VU64(lpop(&lbl_word));
			push_value(v61);
			lpush(&lbl_word, MKU64(v62));
			VAL v63 = mw_mirth_word_Word_spZ_synthed(v62);
			VAL v64 = pop_value();
			VAL v65 = mw_std_map_Map_2_insert(v64, v63);
			uint64_t v66 = VU64(lpop(&lbl_word));
			void* v67 = mfld_mirth_word_Word_ZTildespZ_synthed(v66);
			mut_set(v65, MKPTR(v67));
			VAL v68 = lpop(&lbl_key);
			incref(v68);
			uint64_t v69 = VU64(lpop(&lbl_wordZTick));
			push_value(v68);
			lpush(&lbl_key, v68);
			push_u64(v66);
			lpush(&lbl_word, MKU64(v66));
			lpush(&lbl_wordZTick, MKU64(v69));
			VAL v70 = mtw_mirth_mirth_PropLabel_WordType(v69);
			VAL v71 = pop_value();
			VAL v72 = pop_value();
			VAL v73 = MKNIL;
			VAL v74 = mkcons(v73, v72);
			VAL v75 = mkcons(v74, v71);
			FNPTR v76 = &mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot63ZRParen_1;
			VAL r77 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v75, v70, r77, MKFNPTR(v76));
			uint64_t v78 = VU64(lpop(&lbl_wordZTick));
			void* v79 = mfld_mirth_word_Word_ZTildectxZ_type(v78);
			VAL v80 = pop_value();
			mut_set(v80, MKPTR(v79));
			int64_t v81 = 1LL /* True */;
			void* v82 = mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk(v78);
			mut_set(MKI64(v81), MKPTR(v82));
			VAL v83 = lpop(&lbl_key);
			incref(v83);
			uint64_t v84 = VU64(lpop(&lbl_word));
			push_value(v83);
			lpush(&lbl_key, v83);
			push_u64(v84);
			lpush(&lbl_word, MKU64(v84));
			lpush(&lbl_wordZTick, MKU64(v78));
			push_u64(v78);
			VAL v85 = mtw_mirth_mirth_PropLabel_WordArrow(v78);
			VAL v86 = pop_value();
			VAL v87 = pop_value();
			VAL v88 = pop_value();
			VAL v89 = MKNIL;
			VAL v90 = mkcons(v89, v88);
			VAL v91 = mkcons(v90, v87);
			VAL v92 = mkcons(v91, v86);
			FNPTR v93 = &mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot81ZRParen_1;
			VAL r94 = pop_resource();
			mw_mirth_mirth_PropLabel_prop_1(v92, v85, r94, MKFNPTR(v93));
			uint64_t v95 = VU64(lpop(&lbl_wordZTick));
			void* v96 = mfld_mirth_word_Word_ZTildearrow(v95);
			VAL v97 = pop_value();
			mut_set(v97, MKPTR(v96));
			push_u64(v95);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v98 = lpop(&lbl_key);
	uint64_t v99 = VU64(lpop(&lbl_word));
	decref(v98);
}
static void mw_mirth_specializzer_specializzeZ_ctxZ_type (VAL x1, VAL x2, VAL x3, VAL x4) {
	decref(x3);
	int64_t v0 = 0LL /* SUBST_NIL */;
	push_resource(x1);
	push_value(x2);
	mw_mirth_type_ArrowType_freshen(MKI64(v0), x4);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	decref(v2);
	VAL v3 = pop_value();
	incref(v3);
	push_value(v1);
	push_value(v3);
	VAL v4 = mw_std_list_ListZPlus_1_first(v3);
	uint64_t v5 = mw_mirth_arrow_Arg_token(VU64(v4));
	VAL v6 = pop_value();
	int64_t v7 = 0LL /* SUBST_NIL */;
	VAL v8 = pop_value();
	push_resource(MKU64(v5));
	mw_mirth_type_ArrowType_unpack(v8);
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	VAL v11 = mw_std_list_List_1_reverse(v6);
	mw_std_list_List_1_uncons(v11);
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	push_value(v12);
	push_value(v13);
	while(1) {
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		int64_t v15 = mw_std_maybe_Maybe_1_someZAsk(v14);
		if (!((bool)v15)) break;
		VAL v16 = pop_value();
		VAL v17 = mw_std_maybe_Maybe_1_unwrap(v16);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		VAL v20 = mw_mirth_type_StackType_forceZ_consZAskZBang(v19);
		switch (get_data_tag(v20)) {
			case 1LL: { // Some
				VAL v21 = mtp_std_maybe_Maybe_1_Some(v20);
				push_value(v21);
			} break;
			case 0LL: { // None
				STR* v22;
				STRLIT(v22, "unexpected domain in specialize-ctx-type", 40);
				push_str(v22);
				do_panic();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL v23 = pop_value();
		VAL v24;
		VAL v25;
		value_uncons(v23, &v24, &v25);
		VAL v26;
		VAL v27;
		value_uncons(v24, &v26, &v27);
		decref(v26);
		push_value(v27);
		push_value(v25);
		VAL v28 = mw_mirth_arrow_Block_type(VU64(v17));
		VAL v29 = mtw_mirth_type_Type_TMorphism(v28);
		VAL v30 = pop_value();
		uint64_t r31 = VU64(pop_resource());
		VAL r32 = pop_resource();
		mw_mirth_type_Type_unifyZBang(r32, r31, v30, v29);
		VAL v33 = pop_value();
		decref(v33);
		mw_std_list_List_1_uncons(v18);
		VAL v34 = pop_value();
		VAL v35 = pop_value();
		push_value(v34);
		push_value(v35);
	}
	VAL v36 = pop_value();
	decref(v36);
	VAL v37 = pop_value();
	decref(v37);
	uint64_t r38 = VU64(pop_resource());
	mw_mirth_type_ZPlusGamma_rdrop(r38);
	VAL v39 = pop_value();
	VAL v40 = pop_value();
	VAL v41 = mw_mirth_type_TZ_ZTo(v39, v40);
	VAL v42 = mw_mirth_var_Ctx0();
	VAL r43 = pop_resource();
	mw_mirth_type_ArrowType_rigidifyZ_sigZBang(r43, v42, v41);
}
static void mw_mirth_specializzer_synthZ_specializzedZ_wordZBang (VAL x1, VAL x2, VAL x3, uint64_t x4) {
	lpush(&lbl_spword, MKU64(x4));
	lpush(&lbl_spkey, x3);
	mw_mirth_word_Word_arrow(x4, x1);
	VAL v0 = pop_value();
	VAL v1 = VVAL(VTUP(v0)->cells[7]);
	incref(v1);
	decref(v0);
	push_resource(x2);
	VAL v2 = mw_std_list_List_1_ZDivL1(v1);
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			STR* v4;
			STRLIT(v4, "unexpected shape for synth-specialized-word!", 44);
			push_str(v4);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	VAL v6 = VVAL(VTUP(v5)->cells[4]);
	incref(v6);
	decref(v5);
	switch (get_data_tag(v6)) {
		case 12LL: { // OpLambda
			VAL v7 = mtp_mirth_arrow_Op_OpLambda(v6);
			incref(v7);
			VAL v8 = VVAL(VTUP(v7)->cells[4]);
			incref(v8);
			decref(v7);
			VAL v9 = lpop(&lbl_spkey);
			incref(v9);
			incref(v8);
			push_value(v7);
			lpush(&lbl_spkey, v9);
			push_value(v8);
			push_value(v9);
			int64_t v10 = mw_std_list_List_1_len(v8);
			VAL v11 = pop_value();
			incref(v11);
			push_value(v11);
			push_i64(v10);
			int64_t v12 = mw_std_list_List_1_len(v11);
			int64_t v13 = pop_i64();
			bool v14 = (v13 == v12);
			if (v14) {
			} else {
				STR* v15;
				STRLIT(v15, "wrong number of lambda params in synth-specialized-word!", 56);
				STR* v16;
				STRLIT(v16, "assertion failed: ", 18);
				STR* v17 = str_cat(v16, v15);
				push_str(v17);
				do_panic();
			}
			int64_t v18 = 0LL /* Nil */;
			VAL v19 = mw_std_list_List_1_reverse(MKI64(v18));
			VAL v20 = pop_value();
			mw_std_list_List_1_uncons(v20);
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			mw_std_list_List_1_uncons(v23);
			VAL v24 = pop_value();
			switch (get_data_tag(v22)) {
				case 0LL: { // None
					VAL v25 = pop_value();
					decref(v25);
					int64_t v26 = 0LL /* None */;
					push_i64(v26);
				} break;
				case 1LL: { // Some
					VAL v27 = mtp_std_maybe_Maybe_1_Some(v22);
					VAL v28 = pop_value();
					switch (get_data_tag(v28)) {
						case 0LL: { // None
							decref(v27);
							int64_t v29 = 0LL /* None */;
							push_i64(v29);
						} break;
						case 1LL: { // Some
							push_value(v27);
							VAL v30 = mtp_std_maybe_Maybe_1_Some(v28);
							uint64_t v31 = pop_u64();
							VAL v32 = mtw_std_map_KVPair_2_KVPair(v30, MKU64(v31));
							VAL v33 = mtw_std_maybe_Maybe_1_Some(v32);
							push_value(v33);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_value(v27);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v34 = pop_value();
			push_value(v24);
			push_value(v21);
			push_value(v34);
			push_resource(v19);
			while(1) {
				VAL v35 = pop_value();
				incref(v35);
				push_value(v35);
				int64_t v36 = mw_std_maybe_Maybe_1_someZAsk(v35);
				if (!((bool)v36)) break;
				VAL v37 = pop_value();
				VAL v38 = mw_std_maybe_Maybe_1_unwrap(v37);
				VAL r39 = pop_resource();
				VAL v40 = mtw_std_list_List_1_Cons(v38, r39);
				VAL v41 = pop_value();
				mw_std_list_List_1_uncons(v41);
				VAL v42 = pop_value();
				VAL v43 = pop_value();
				VAL v44 = pop_value();
				mw_std_list_List_1_uncons(v44);
				VAL v45 = pop_value();
				switch (get_data_tag(v43)) {
					case 0LL: { // None
						VAL v46 = pop_value();
						decref(v46);
						int64_t v47 = 0LL /* None */;
						push_i64(v47);
					} break;
					case 1LL: { // Some
						VAL v48 = mtp_std_maybe_Maybe_1_Some(v43);
						VAL v49 = pop_value();
						switch (get_data_tag(v49)) {
							case 0LL: { // None
								decref(v48);
								int64_t v50 = 0LL /* None */;
								push_i64(v50);
							} break;
							case 1LL: { // Some
								push_value(v48);
								VAL v51 = mtp_std_maybe_Maybe_1_Some(v49);
								uint64_t v52 = pop_u64();
								VAL v53 = mtw_std_map_KVPair_2_KVPair(v51, MKU64(v52));
								VAL v54 = mtw_std_maybe_Maybe_1_Some(v53);
								push_value(v54);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
								push_value(v48);
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
				VAL v55 = pop_value();
				push_value(v45);
				push_value(v42);
				push_value(v55);
				push_resource(v40);
			}
			VAL v56 = pop_value();
			decref(v56);
			VAL r57 = pop_resource();
			VAL v58 = mw_std_list_List_1_reverse(r57);
			VAL v59 = pop_value();
			decref(v59);
			VAL v60 = pop_value();
			decref(v60);
			VAL r61 = pop_resource();
			uint64_t v62 = VU64(lpop(&lbl_spword));
			VAL v63 = lpop(&lbl_spkey);
			VAL v64 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v63, v62, v58, r61));
			VAL v65 = pop_value();
			VAL v66 = VVAL(VTUP(v65)->cells[5]);
			incref(v66);
			decref(v65);
			VAL r67 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(r67, v64, v66);
			VAL r68 = pop_resource();
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r68);
			VAL v69 = lpop(&lbl_spkey);
			uint64_t v70 = VU64(lpop(&lbl_spword));
			VAL v71 = lpop(&lbl_spmap);
			decref(v71);
			decref(v69);
		} break;
		default: {
			STR* v72;
			STRLIT(v72, "unexpected shape", 16);
			push_value(v6);
			push_str(v72);
			do_panic();
		} break;
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x3)->cells[7]);
	incref(v0);
	decref(x3);
	push_resource(x1);
	push_resource(x2);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang(r9, r8, v6);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang (VAL x1, VAL x2, VAL x3) {
	incref(x3);
	uint64_t v0 = VU64(VTUP(x3)->cells[2]);
	decref(x3);
	push_resource(x1);
	push_value(x3);
	push_u64(v0);
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2);
	uint64_t v1 = pop_u64();
	VAL r2 = pop_resource();
	VAL v3 = (mw_mirth_elab_abZ_tokenZBang(r2, v1));
	VAL v4 = lpop(&lbl_spmap);
	uint64_t v5 = VU64(lpop(&lbl_spword));
	VAL v6 = lpop(&lbl_spkey);
	VAL v7 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v6, v5, v4, v3));
	VAL v8 = pop_value();
	incref(v8);
	VAL v9 = VVAL(VTUP(v8)->cells[5]);
	incref(v9);
	decref(v8);
	push_resource(v7);
	push_value(v8);
	mw_std_list_List_1_uncons(v9);
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	push_value(v10);
	push_value(v11);
	while(1) {
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		int64_t v13 = mw_std_maybe_Maybe_1_someZAsk(v12);
		if (!((bool)v13)) break;
		VAL v14 = pop_value();
		VAL v15 = mw_std_maybe_Maybe_1_unwrap(v14);
		VAL v16 = pop_value();
		VAL r17 = pop_resource();
		VAL r18 = pop_resource();
		mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang(r18, r17, VU64(v15));
		mw_std_list_List_1_uncons(v16);
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	VAL v24 = VVAL(VTUP(v23)->cells[4]);
	incref(v24);
	decref(v23);
	VAL r25 = pop_resource();
	VAL r26 = pop_resource();
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang(r26, r25, v24);
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang (VAL x1, VAL x2, uint64_t x3) {
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang(x1, x2, x3);
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x3)) {
		case 11LL: { // OpMatch
			push_resource(x1);
			push_resource(x2);
			VAL v0 = mtp_mirth_arrow_Op_OpMatch(x3);
			VAL r1 = pop_resource();
			VAL r2 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang(r2, r1, v0);
		} break;
		case 12LL: { // OpLambda
			push_resource(x1);
			push_resource(x2);
			VAL v3 = mtp_mirth_arrow_Op_OpLambda(x3);
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang(r5, r4, v3);
		} break;
		case 14LL: { // OpBlockPush
			push_resource(x1);
			push_resource(x2);
			uint64_t v6 = mtp_mirth_arrow_Op_OpBlockPush(x3);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang(r8, r7, v6);
		} break;
		case 15LL: { // OpBlockRun
			push_resource(x1);
			push_resource(x2);
			uint64_t v9 = mtp_mirth_arrow_Op_OpBlockRun(x3);
			VAL r10 = pop_resource();
			VAL r11 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang(r11, r10, v9);
		} break;
		case 13LL: { // OpVar
			push_resource(x1);
			push_resource(x2);
			uint64_t v12 = mtp_mirth_arrow_Op_OpVar(x3);
			VAL r13 = pop_resource();
			VAL r14 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang(r14, r13, v12);
		} break;
		default: {
			push_resource(x1);
			push_value(x3);
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2);
			VAL r15 = pop_resource();
			VAL r16 = pop_resource();
			VAL v17 = pop_value();
			mw_mirth_elab_abZ_opZBang(v17, r16, r15);
			VAL r18 = pop_resource();
			VAL v19 = lpop(&lbl_spmap);
			uint64_t v20 = VU64(lpop(&lbl_spword));
			VAL v21 = lpop(&lbl_spkey);
			VAL v22 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v21, v20, v19, r18));
			push_resource(v22);
		} break;
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang (VAL x1, VAL x2, uint64_t x3) {
	push_u64(x3);
	mw_mirth_arrow_Block_toZ_runZ_var(x1, x3);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			push_resource(x2);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL r2 = pop_resource();
			VAL v3 = VVAL(VTUP(r2)->cells[4]);
			incref(v3);
			int64_t v4 = 0LL /* None */;
			push_value(v1);
			push_resource(r2);
			push_i64(v4);
			mw_std_list_List_1_uncons(v3);
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			push_value(v5);
			push_value(v6);
			while(1) {
				VAL v7 = pop_value();
				incref(v7);
				push_value(v7);
				int64_t v8 = mw_std_maybe_Maybe_1_someZAsk(v7);
				if (!((bool)v8)) break;
				VAL v9 = pop_value();
				VAL v10 = mw_std_maybe_Maybe_1_unwrap(v9);
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				incref(v10);
				VAL v13 = pop_value();
				incref(v13);
				VAL v14 = VVAL(VTUP(v10)->cells[1]);
				incref(v14);
				decref(v10);
				int64_t v15 = mw_mirth_var_Var_ZEqualZEqual(VU64(v13), VU64(v14));
				if (((bool)v15)) {
					push_value(v13);
					VAL v16 = mtw_std_maybe_Maybe_1_Some(v10);
					push_value(v16);
				} else {
					decref(v10);
					int64_t v17 = 0LL /* None */;
					push_value(v13);
					push_i64(v17);
				}
				VAL v18 = pop_value();
				switch (get_data_tag(v18)) {
					case 0LL: { // None
						push_value(v12);
						push_value(v11);
					} break;
					default: {
						decref(v11);
						decref(v12);
						int64_t v19 = 0LL /* Nil */;
						push_value(v18);
						push_i64(v19);
					} break;
				}
				VAL v20 = pop_value();
				mw_std_list_List_1_uncons(v20);
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				push_value(v21);
				push_value(v22);
			}
			VAL v23 = pop_value();
			decref(v23);
			VAL v24 = pop_value();
			decref(v24);
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			decref(v26);
			switch (get_data_tag(v25)) {
				case 1LL: { // Some
					VAL v27 = mtp_std_maybe_Maybe_1_Some(v25);
					VAL v28 = VVAL(VTUP(v27)->cells[2]);
					incref(v28);
					decref(v27);
					VAL v29 = mtw_std_maybe_Maybe_1_Some(v28);
					push_value(v29);
				} break;
				case 0LL: { // None
					int64_t v30 = 0LL /* None */;
					push_i64(v30);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 0LL: { // None
			int64_t v31 = 0LL /* None */;
			push_resource(x2);
			push_i64(v31);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL v32 = pop_value();
	switch (get_data_tag(v32)) {
		case 0LL: { // None
			VAL r33 = pop_resource();
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r33);
			VAL r34 = pop_resource();
			mw_mirth_elab_abZ_tokenZAt(r34);
			VAL r35 = pop_resource();
			mw_mirth_elab_abZ_ctxZAt(r35);
			uint64_t v36 = mw_mirth_type_MetaVar_newZBang();
			VAL v37 = mtw_mirth_type_StackType_STMeta(v36);
			VAL v38 = pop_value();
			VAL v39 = pop_value();
			VAL r40 = pop_resource();
			push_value(v38);
			push_value(v37);
			push_value(v39);
			mw_mirth_elab_abZ_homeZAt(r40);
			VAL r41 = pop_resource();
			VAL v42 = pop_value();
			uint64_t v43 = pop_u64();
			VAL v44 = pop_value();
			incref(v44);
			VAL v45 = pop_value();
			int64_t v46 = 0LL /* Nil */;
			VAL v47 = mtw_mirth_arrow_Arrow_Arrow(v42, v43, v43, v45, v44, v44, MKI64(v46));
			VAL v48 = lpop(&lbl_spmap);
			uint64_t v49 = VU64(lpop(&lbl_spword));
			VAL v50 = lpop(&lbl_spkey);
			VAL v51 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v50, v49, v48, v47));
			uint64_t v52 = pop_u64();
			VAL r53 = pop_resource();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang(r53, v51, v52);
			VAL r54 = pop_resource();
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r54);
			VAL r55 = pop_resource();
			VAL r56 = pop_resource();
			mw_mirth_arrow_Block_newZBang(r56, r55);
			uint64_t v57 = pop_u64();
			push_resource(r41);
			VAL v58 = mtw_mirth_arrow_Op_OpBlockPush(v57);
			VAL r59 = pop_resource();
			VAL r60 = pop_resource();
			mw_mirth_elab_abZ_opZBang(v58, r60, r59);
			VAL r61 = pop_resource();
			VAL v62 = lpop(&lbl_spmap);
			uint64_t v63 = VU64(lpop(&lbl_spword));
			VAL v64 = lpop(&lbl_spkey);
			VAL v65 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v64, v63, v62, r61));
			push_resource(v65);
		} break;
		case 1LL: { // Some
			VAL v66 = mtp_std_maybe_Maybe_1_Some(v32);
			VAL v67 = pop_value();
			decref(v67);
			VAL v68 = mtw_mirth_arrow_Op_OpBlockPush(VU64(v66));
			VAL r69 = pop_resource();
			push_value(v68);
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r69);
			VAL r70 = pop_resource();
			VAL r71 = pop_resource();
			VAL v72 = pop_value();
			mw_mirth_elab_abZ_opZBang(v72, r71, r70);
			VAL r73 = pop_resource();
			VAL v74 = lpop(&lbl_spmap);
			uint64_t v75 = VU64(lpop(&lbl_spword));
			VAL v76 = lpop(&lbl_spkey);
			VAL v77 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v76, v75, v74, r73));
			push_resource(v77);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang (VAL x1, VAL x2, uint64_t x3) {
	mw_mirth_arrow_Block_arrow(x1, x3);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(r1, x2, v0);
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang (VAL x1, VAL x2, uint64_t x3) {
	VAL v0 = VVAL(VTUP(x2)->cells[4]);
	incref(v0);
	int64_t v1 = 0LL /* None */;
	push_resource(x1);
	push_u64(x3);
	push_u64(x3);
	push_resource(x2);
	push_i64(v1);
	mw_std_list_List_1_uncons(v0);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		int64_t v5 = mw_std_maybe_Maybe_1_someZAsk(v4);
		if (!((bool)v5)) break;
		VAL v6 = pop_value();
		VAL v7 = mw_std_maybe_Maybe_1_unwrap(v6);
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = pop_value();
		incref(v10);
		VAL v11 = VVAL(VTUP(v7)->cells[1]);
		incref(v11);
		decref(v7);
		int64_t v12 = mw_mirth_var_Var_ZEqualZEqual(VU64(v10), VU64(v11));
		if (((bool)v12)) {
			push_value(v10);
			VAL v13 = mtw_std_maybe_Maybe_1_Some(v7);
			push_value(v13);
		} else {
			decref(v7);
			int64_t v14 = 0LL /* None */;
			push_value(v10);
			push_i64(v14);
		}
		VAL v15 = pop_value();
		switch (get_data_tag(v15)) {
			case 0LL: { // None
				push_value(v9);
				push_value(v8);
			} break;
			default: {
				decref(v8);
				decref(v9);
				int64_t v16 = 0LL /* Nil */;
				push_value(v15);
				push_i64(v16);
			} break;
		}
		VAL v17 = pop_value();
		mw_std_list_List_1_uncons(v17);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	decref(v23);
	switch (get_data_tag(v22)) {
		case 1LL: { // Some
			VAL v24 = mtp_std_maybe_Maybe_1_Some(v22);
			VAL v25 = VVAL(VTUP(v24)->cells[2]);
			incref(v25);
			decref(v24);
			VAL v26 = mtw_std_maybe_Maybe_1_Some(v25);
			push_value(v26);
		} break;
		case 0LL: { // None
			int64_t v27 = 0LL /* None */;
			push_i64(v27);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v28 = pop_value();
	switch (get_data_tag(v28)) {
		case 1LL: { // Some
			VAL v29 = mtp_std_maybe_Maybe_1_Some(v28);
			VAL v30 = pop_value();
			decref(v30);
			VAL v31 = mtw_mirth_arrow_Op_OpBlockRun(VU64(v29));
			VAL r32 = pop_resource();
			push_value(v31);
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r32);
			VAL r33 = pop_resource();
			VAL r34 = pop_resource();
			VAL v35 = pop_value();
			mw_mirth_elab_abZ_opZBang(v35, r34, r33);
			VAL r36 = pop_resource();
			VAL v37 = lpop(&lbl_spmap);
			uint64_t v38 = VU64(lpop(&lbl_spword));
			VAL v39 = lpop(&lbl_spkey);
			VAL v40 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v39, v38, v37, r36));
			push_resource(v40);
		} break;
		case 0LL: { // None
			VAL r41 = pop_resource();
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r41);
			VAL r42 = pop_resource();
			VAL r43 = pop_resource();
			uint64_t v44 = pop_u64();
			mw_mirth_elab_abZ_varZBang(v44, r43, r42);
			VAL r45 = pop_resource();
			VAL v46 = lpop(&lbl_spmap);
			uint64_t v47 = VU64(lpop(&lbl_spword));
			VAL v48 = lpop(&lbl_spkey);
			VAL v49 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v48, v47, v46, r45));
			push_resource(v49);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x1);
	push_resource(x2);
	push_value(x3);
	uint64_t v0 = mw_mirth_type_MetaVar_newZBang();
	VAL v1 = mtw_mirth_type_StackType_STMeta(v0);
	VAL v2 = pop_value();
	incref(v2);
	uint64_t v3 = VU64(VTUP(v2)->cells[3]);
	decref(v2);
	VAL v4 = VVAL(VTUP(v2)->cells[7]);
	incref(v4);
	decref(v2);
	VAL r5 = pop_resource();
	lpush(&lbl_cod, v1);
	lpush(&lbl_body, MKU64(v3));
	push_value(v4);
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r5);
	VAL r6 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r6);
	VAL v7 = pop_value();
	VAL r8 = pop_resource();
	lpush(&lbl_ctx, v7);
	mw_mirth_elab_abZ_typeZAt(r8);
	VAL v9 = pop_value();
	VAL r10 = pop_resource();
	lpush(&lbl_dom, v9);
	mw_mirth_elab_abZ_tokenZAt(r10);
	uint64_t v11 = pop_u64();
	VAL r12 = pop_resource();
	lpush(&lbl_token, MKU64(v11));
	mw_mirth_elab_abZ_homeZAt(r12);
	VAL v13 = pop_value();
	int64_t v14 = 0LL /* Nil */;
	VAL r15 = pop_resource();
	VAL v16 = lpop(&lbl_cod);
	VAL v17 = lpop(&lbl_dom);
	VAL v18 = lpop(&lbl_ctx);
	uint64_t v19 = VU64(lpop(&lbl_body));
	uint64_t v20 = VU64(lpop(&lbl_token));
	VAL v21 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v13, v20, v19, v18, v17, v16, MKI64(v14)));
	VAL v22 = pop_value();
	push_resource(v21);
	mw_std_list_List_1_uncons(v22);
	VAL v23 = pop_value();
	VAL v24 = pop_value();
	push_value(v23);
	push_value(v24);
	while(1) {
		VAL v25 = pop_value();
		incref(v25);
		push_value(v25);
		int64_t v26 = mw_std_maybe_Maybe_1_someZAsk(v25);
		if (!((bool)v26)) break;
		VAL v27 = pop_value();
		VAL v28 = mw_std_maybe_Maybe_1_unwrap(v27);
		VAL v29 = pop_value();
		incref(v28);
		VAL v30 = VVAL(VTUP(v28)->cells[1]);
		incref(v30);
		decref(v28);
		uint64_t v31 = VU64(VTUP(v30)->cells[2]);
		decref(v30);
		incref(v28);
		VAL v32 = VVAL(VTUP(v28)->cells[2]);
		incref(v32);
		decref(v28);
		uint64_t v33 = VU64(VTUP(v32)->cells[2]);
		decref(v32);
		VAL r34 = pop_resource();
		VAL v35 = VVAL(VTUP(r34)->cells[1]);
		incref(v35);
		VAL v36 = VVAL(VTUP(r34)->cells[4]);
		incref(v36);
		incref(v36);
		int64_t v37 = 0LL /* Nil */;
		VAL v38 = VVAL(VTUP(r34)->cells[5]);
		incref(v38);
		incref(v38);
		int64_t v39 = 0LL /* Nil */;
		push_value(v28);
		push_resource(r34);
		VAL v40 = mtw_mirth_match_Pattern_Pattern(v35, v31, v31, v36, v36, MKI64(v37), v38, v38, MKI64(v39));
		VAL r41 = pop_resource();
		VAL v42 = (mw_mirth_match_Pattern_thaw(v40));
		VAL v43 = pop_value();
		incref(v43);
		VAL v44 = VVAL(VTUP(v43)->cells[1]);
		incref(v44);
		decref(v43);
		VAL v45 = VVAL(VTUP(v44)->cells[9]);
		incref(v45);
		decref(v44);
		push_resource(v42);
		push_value(v43);
		VAL v46 = mw_std_list_List_1_reverse(v45);
		mw_std_list_List_1_uncons(v46);
		VAL v47 = pop_value();
		VAL v48 = pop_value();
		push_value(v47);
		push_value(v48);
		while(1) {
			VAL v49 = pop_value();
			incref(v49);
			push_value(v49);
			int64_t v50 = mw_std_maybe_Maybe_1_someZAsk(v49);
			if (!((bool)v50)) break;
			VAL v51 = pop_value();
			VAL v52 = mw_std_maybe_Maybe_1_unwrap(v51);
			VAL v53 = pop_value();
			VAL v54 = VVAL(VTUP(v52)->cells[7]);
			incref(v54);
			decref(v52);
			VAL r55 = pop_resource();
			VAL r56 = pop_resource();
			mw_mirth_match_ZPlusPattern_opZBang(v54, r56, r55);
			mw_std_list_List_1_uncons(v53);
			VAL v57 = pop_value();
			VAL v58 = pop_value();
			push_value(v57);
			push_value(v58);
		}
		VAL v59 = pop_value();
		decref(v59);
		VAL v60 = pop_value();
		decref(v60);
		VAL r61 = pop_resource();
		VAL v62 = mw_mirth_match_ZPlusPattern_freezze(r61);
		incref(v62);
		VAL v63 = VVAL(VTUP(v62)->cells[5]);
		incref(v63);
		decref(v62);
		incref(v62);
		push_resource(r41);
		push_u64(v33);
		push_value(v63);
		lpush(&lbl_pattern, v62);
		VAL v64 = mw_mirth_match_Pattern_dom(v62);
		VAL r65 = pop_resource();
		VAL v66 = VVAL(VTUP(r65)->cells[6]);
		incref(v66);
		push_resource(r65);
		VAL v67 = mw_mirth_type_TZ_ZTo(v64, v66);
		VAL v68 = pop_value();
		VAL v69 = pop_value();
		VAL r70 = pop_resource();
		VAL v71 = VVAL(VTUP(r70)->cells[1]);
		incref(v71);
		VAL v72 = lpop(&lbl_pattern);
		push_value(v68);
		mw_mirth_type_ArrowType_unpack(v67);
		VAL v73 = pop_value();
		VAL v74 = pop_value();
		VAL v75 = pop_value();
		incref(v69);
		incref(v74);
		int64_t v76 = 0LL /* Nil */;
		push_value(v73);
		VAL v77 = mtw_mirth_arrow_Arrow_Arrow(v71, VU64(v69), VU64(v69), v75, v74, v74, MKI64(v76));
		VAL v78 = pop_value();
		VAL v79 = lpop(&lbl_spmap);
		uint64_t v80 = VU64(lpop(&lbl_spword));
		VAL v81 = lpop(&lbl_spkey);
		VAL v82 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v81, v80, v79, v77));
		VAL v83 = pop_value();
		VAL v84 = VVAL(VTUP(v83)->cells[2]);
		incref(v84);
		decref(v83);
		VAL r85 = pop_resource();
		mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(r85, v82, v84);
		VAL r86 = pop_resource();
		mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r86);
		VAL r87 = pop_resource();
		VAL r88 = pop_resource();
		mw_mirth_elab_abZ_unifyZ_typeZBang(v78, r88, r87);
		VAL r89 = pop_resource();
		push_resource(r70);
		VAL v90 = mtw_mirth_match_Case_CASE(v72, r89);
		VAL r91 = pop_resource();
		VAL r92 = pop_resource();
		mw_mirth_match_ZPlusMatch_addZ_case(r92, r91, v90);
		mw_std_list_List_1_uncons(v29);
		VAL v93 = pop_value();
		VAL v94 = pop_value();
		push_value(v93);
		push_value(v94);
	}
	VAL v95 = pop_value();
	decref(v95);
	VAL v96 = pop_value();
	decref(v96);
	VAL r97 = pop_resource();
	VAL v98 = mw_mirth_match_ZPlusMatch_freezze(r97);
	push_resource(r15);
	VAL v99 = mtw_mirth_arrow_Op_OpMatch(v98);
	VAL r100 = pop_resource();
	VAL r101 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v99, r101, r100);
	VAL r102 = pop_resource();
	VAL v103 = lpop(&lbl_spmap);
	uint64_t v104 = VU64(lpop(&lbl_spword));
	VAL v105 = lpop(&lbl_spkey);
	VAL v106 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v105, v104, v103, r102));
	push_resource(v106);
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang (VAL x1, VAL x2, VAL x3) {
	incref(x3);
	VAL v0 = VVAL(VTUP(x3)->cells[4]);
	incref(v0);
	decref(x3);
	push_resource(x1);
	push_value(x3);
	push_value(v0);
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(x2);
	VAL v1 = pop_value();
	VAL r2 = pop_resource();
	mw_mirth_elab_abZ_tokenZAt(r2);
	incref(v1);
	VAL r3 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r3);
	VAL r4 = pop_resource();
	mw_mirth_elab_abZ_typeZAt(r4);
	VAL v5 = mw_std_list_List_1_reverse(v1);
	mw_std_list_List_1_uncons(v5);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
		if (!((bool)v9)) break;
		VAL v10 = pop_value();
		VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		incref(v11);
		VAL v14 = pop_value();
		VAL v15 = mw_mirth_var_Ctx_new(v14, VU64(v11));
		VAL r16 = pop_resource();
		push_value(v15);
		push_value(v11);
		push_value(v13);
		mw_mirth_elab_abZ_tokenZAt(r16);
		VAL r17 = pop_resource();
		uint64_t v18 = pop_u64();
		VAL v19 = pop_value();
		VAL r20 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang(r20, v19, v18);
		uint64_t v21 = pop_u64();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		push_resource(r17);
		push_value(v23);
		push_value(v22);
		VAL v25 = mw_mirth_var_Var_type(VU64(v24));
		VAL r26 = pop_resource();
		VAL v27 = pop_value();
		VAL r28 = pop_resource();
		mw_mirth_elab_elabZ_typeZ_unifyZBang(r28, v27, v25, v21);
		VAL v29 = pop_value();
		decref(v29);
		VAL v30 = pop_value();
		decref(v30);
		push_resource(r26);
		mw_std_list_List_1_uncons(v12);
		VAL v31 = pop_value();
		VAL v32 = pop_value();
		push_value(v31);
		push_value(v32);
	}
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	decref(v34);
	VAL v35 = pop_value();
	VAL v36 = pop_value();
	VAL v37 = pop_value();
	VAL r38 = pop_resource();
	push_value(v36);
	push_value(v35);
	push_value(v37);
	mw_mirth_elab_abZ_homeZAt(r38);
	VAL r39 = pop_resource();
	VAL v40 = pop_value();
	uint64_t v41 = pop_u64();
	VAL v42 = pop_value();
	incref(v42);
	VAL v43 = pop_value();
	int64_t v44 = 0LL /* Nil */;
	VAL v45 = mtw_mirth_arrow_Arrow_Arrow(v40, v41, v41, v43, v42, v42, MKI64(v44));
	VAL v46 = lpop(&lbl_spmap);
	uint64_t v47 = VU64(lpop(&lbl_spword));
	VAL v48 = lpop(&lbl_spkey);
	VAL v49 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v48, v47, v46, v45));
	VAL v50 = pop_value();
	VAL v51 = VVAL(VTUP(v50)->cells[5]);
	incref(v51);
	decref(v50);
	VAL r52 = pop_resource();
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang(r52, v49, v51);
	VAL r53 = pop_resource();
	mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(r53);
	VAL r54 = pop_resource();
	lpush(&lbl_params, v1);
	lpush(&lbl_body, r54);
	mw_mirth_elab_abZ_ctxZAt(r39);
	VAL v55 = pop_value();
	VAL r56 = pop_resource();
	lpush(&lbl_outerZ_ctx, v55);
	mw_mirth_elab_abZ_typeZAt(r56);
	VAL v57 = pop_value();
	VAL r58 = pop_resource();
	lpush(&lbl_dom, v57);
	mw_mirth_elab_abZ_tokenZAt(r58);
	uint64_t v59 = pop_u64();
	VAL v60 = lpop(&lbl_body);
	VAL v61 = lpop(&lbl_params);
	VAL v62 = lpop(&lbl_dom);
	VAL v63 = lpop(&lbl_outerZ_ctx);
	VAL v64 = mtw_mirth_arrow_Lambda_Lambda(v59, v63, v62, v61, v60);
	VAL v65 = mtw_mirth_arrow_Op_OpLambda(v64);
	VAL r66 = pop_resource();
	VAL r67 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v65, r67, r66);
	VAL r68 = pop_resource();
	VAL v69 = lpop(&lbl_spmap);
	uint64_t v70 = VU64(lpop(&lbl_spword));
	VAL v71 = lpop(&lbl_spkey);
	VAL v72 = (mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH(v71, v70, v69, r68));
	push_resource(v72);
}
static int64_t mw_std_set_SETz_INITIALz_SIZZE (void) {
	int64_t v0 = 256LL;
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	return v1;
}
static VAL mw_std_set_ZPlusSet_new (void) {
	int64_t v0 = mw_std_set_SETz_INITIALz_SIZZE();
	VAL v1 = (mw_std_buffer_ZPlusBuffer_new(v0));
	return v1;
}
static void mw_std_set_ZPlusSet_rdrop (VAL x1) {
	mw_std_buffer_ZPlusBuffer_rdrop(x1);
}
static void mw_std_set_ZPlusSet_offsetZ_mask (int64_t x1, VAL x2) {
	int64_t v0 = 8LL;
	push_i64(x1);
	push_resource(x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL v2 = pop_value();
	incref(v2);
	int64_t v3 = i64_mod(VI64(v2), v1);
	int64_t v4 = i64_div(VI64(v2), v1);
	int64_t v5 = 1LL;
	int64_t v6 = i64_add(v4, v5);
	int64_t v7 = (0);
	VAL r8 = pop_resource();
	push_i64(v4);
	push_i64(v3);
	VAL v9 = (mw_std_buffer_ZPlusBuffer_expandZBang(v6, r8));
	int64_t v10 = pop_i64();
	int64_t v11 = 1LL;
	push_resource(v9);
	push_i64(v10);
	int64_t v12 = mw_std_prim_Int_ZToNat(v11);
	int64_t v13 = pop_i64();
	uint64_t v14 = u64_shl(((uint64_t)v12), ((uint64_t)v13));
	int64_t v15 = mw_std_prim_Int_ZToU8(((int64_t)v14));
	push_i64(v15);
}
static void mw_std_set_ZPlusSet_memberZAsk (int64_t x1, VAL x2) {
	mw_std_set_ZPlusSet_offsetZ_mask(x1, x2);
	int64_t v0 = (0);
	int64_t v1 = pop_i64();
	int64_t v2 = pop_i64();
	VAL r3 = pop_resource();
	push_i64(v1);
	mw_std_buffer_ZPlusBuffer_ZAtU8(v2, r3);
	int64_t v4 = pop_i64();
	uint64_t v5 = pop_u64();
	uint64_t v6 = (v5 & ((uint64_t)v4));
	int64_t v7 = 0LL;
	bool v8 = (((int64_t)v6) != v7);
	push_bool(v8);
}
static VAL mw_std_set_ZPlusSet_insertZBang (int64_t x1, VAL x2) {
	mw_std_set_ZPlusSet_offsetZ_mask(x1, x2);
	int64_t v0 = (0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	VAL r3 = pop_resource();
	push_value(v2);
	push_value(v1);
	mw_std_buffer_ZPlusBuffer_ZAtU8(VI64(v2), r3);
	int64_t v4 = pop_i64();
	uint64_t v5 = pop_u64();
	uint64_t v6 = (v5 | ((uint64_t)v4));
	int64_t v7 = pop_i64();
	VAL r8 = pop_resource();
	VAL v9 = (mw_std_buffer_ZPlusBuffer_ZBangU8(((int64_t)v6), v7, r8));
	return v9;
}
static int64_t mw_mirth_need_Need_ZToNat (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // NEED_WORD
			uint64_t v0 = mtp_mirth_need_Need_NEEDz_WORD(x1);
			int64_t v1 = mw_mirth_word_Word_index(v0);
			int64_t v2 = 4LL;
			int64_t v3 = i64_mul(v1, v2);
			int64_t v4 = mw_std_prim_Int_ZToNat(v3);
			push_i64(v4);
		} break;
		case 1LL: { // NEED_BLOCK
			uint64_t v5 = mtp_mirth_need_Need_NEEDz_BLOCK(x1);
			int64_t v6 = mw_mirth_arrow_Block_index(v5);
			int64_t v7 = 4LL;
			int64_t v8 = i64_mul(v6, v7);
			int64_t v9 = 1LL;
			int64_t v10 = i64_add(v8, v9);
			int64_t v11 = mw_std_prim_Int_ZToNat(v10);
			push_i64(v11);
		} break;
		case 2LL: { // NEED_TAGW
			uint64_t v12 = mtp_mirth_need_Need_NEEDz_TAGW(x1);
			int64_t v13 = mw_mirth_data_Tag_index(v12);
			int64_t v14 = 4LL;
			int64_t v15 = i64_mul(v13, v14);
			int64_t v16 = 2LL;
			int64_t v17 = i64_add(v15, v16);
			int64_t v18 = mw_std_prim_Int_ZToNat(v17);
			push_i64(v18);
		} break;
		case 3LL: { // NEED_TAGP
			uint64_t v19 = mtp_mirth_need_Need_NEEDz_TAGP(x1);
			int64_t v20 = mw_mirth_data_Tag_index(v19);
			int64_t v21 = 4LL;
			int64_t v22 = i64_mul(v20, v21);
			int64_t v23 = 3LL;
			int64_t v24 = i64_add(v22, v23);
			int64_t v25 = mw_std_prim_Int_ZToNat(v24);
			push_i64(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v26 = pop_i64();
	return v26;
}
static VAL mw_mirth_need_ZPlusNeeds_new (void) {
	int64_t v0 = 0LL /* Nil */;
	lpush(&lbl_stack, MKI64(v0));
	VAL v1 = (mw_std_set_ZPlusSet_new());
	VAL v2 = lpop(&lbl_stack);
	VAL v3 = (mtw_mirth_need_ZPlusNeeds_ZPlusNeeds(v2, v1));
	return v3;
}
static void mw_mirth_need_ZPlusNeeds_rdrop (VAL x1) {
	mtp_mirth_need_ZPlusNeeds_ZPlusNeeds(x1);
	VAL v0 = (lpop(&lbl_ZPlusset));
	mw_std_set_ZPlusSet_rdrop(v0);
	VAL v1 = lpop(&lbl_stack);
	decref(v1);
}
static void mw_mirth_need_Need_neededZAsk (VAL x1, VAL x2) {
	push_resource(x2);
	int64_t v0 = mw_mirth_need_Need_ZToNat(x1);
	VAL r1 = pop_resource();
	VAL v2 = (VVAL(VTUP(r1)->cells[2]));
	mw_std_set_ZPlusSet_memberZAsk(v0, v2);
	VAL r3 = pop_resource();
	VTUP(r1)->cells[2] = r3;
	push_resource(r1);
}
static void mw_mirth_word_Word_neededZAsk (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_WORD(x1);
	VAL r1 = pop_resource();
	mw_mirth_need_Need_neededZAsk(v0, r1);
}
static void mw_mirth_arrow_Block_neededZAsk (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_BLOCK(x1);
	VAL r1 = pop_resource();
	mw_mirth_need_Need_neededZAsk(v0, r1);
}
static void mw_mirth_data_Tag_wordZ_neededZAsk (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_TAGW(x1);
	VAL r1 = pop_resource();
	mw_mirth_need_Need_neededZAsk(v0, r1);
}
static void mw_mirth_data_Tag_patZ_neededZAsk (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_TAGP(x1);
	VAL r1 = pop_resource();
	mw_mirth_need_Need_neededZAsk(v0, r1);
}
static VAL mw_mirth_need_ZPlusNeeds_needZBang (VAL x1, VAL x2) {
	incref(x1);
	push_value(x1);
	mw_mirth_need_Need_neededZAsk(x1, x2);
	bool v0 = pop_bool();
	if (v0) {
		VAL v1 = pop_value();
		decref(v1);
	} else {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		int64_t v3 = mw_mirth_need_Need_ZToNat(v2);
		VAL r4 = pop_resource();
		VAL v5 = (VVAL(VTUP(r4)->cells[2]));
		VAL v6 = (mw_std_set_ZPlusSet_insertZBang(v3, v5));
		VTUP(r4)->cells[2] = v6;
		VAL v7 = VVAL(VTUP(r4)->cells[1]);
		incref(v7);
		VAL v8 = pop_value();
		VAL v9 = mtw_std_list_List_1_Cons(v8, v7);
		VAL v10 = VTUP(r4)->cells[1];
		decref(v10);
		VTUP(r4)->cells[1] = v9;
		push_resource(r4);
	}
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_wordZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_WORD(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_need_ZPlusNeeds_needZBang(v0, r1));
	return v2;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_blockZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_BLOCK(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_need_ZPlusNeeds_needZBang(v0, r1));
	return v2;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_TAGW(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_need_ZPlusNeeds_needZBang(v0, r1));
	return v2;
}
static VAL mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mtw_mirth_need_Need_NEEDz_TAGP(x1);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_need_ZPlusNeeds_needZBang(v0, r1));
	return v2;
}
static void mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang (VAL x1, VAL x2, VAL x3) {
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(x1, x2, x3);
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang(r1, r0);
}
static void mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[1]);
	incref(v0);
	push_resource(x1);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = VTUP(x2)->cells[1];
	decref(v2);
	VTUP(x2)->cells[1] = v1;
	push_resource(x2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL r7 = pop_resource();
		VAL r8 = pop_resource();
		mw_mirth_need_ZPlusNeeds_runZ_needZBang(v6, r8, r7);
		VAL r9 = pop_resource();
		VAL v10 = VVAL(VTUP(r9)->cells[1]);
		incref(v10);
		mw_std_list_List_1_uncons(v10);
		VAL v11 = pop_value();
		VAL v12 = VTUP(r9)->cells[1];
		decref(v12);
		VTUP(r9)->cells[1] = v11;
		push_resource(r9);
	}
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_need_ZPlusNeeds_runZ_needZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x1)) {
		case 1LL: { // NEED_BLOCK
			push_resource(x2);
			push_resource(x3);
			uint64_t v0 = mtp_mirth_need_Need_NEEDz_BLOCK(x1);
			VAL r1 = pop_resource();
			VAL r2 = pop_resource();
			mw_mirth_need_ZPlusNeeds_runZ_blockZBang(v0, r2, r1);
		} break;
		case 0LL: { // NEED_WORD
			push_resource(x2);
			push_resource(x3);
			uint64_t v3 = mtp_mirth_need_Need_NEEDz_WORD(x1);
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			mw_mirth_need_ZPlusNeeds_runZ_wordZBang(v3, r5, r4);
		} break;
		case 2LL: { // NEED_TAGW
			push_resource(x2);
			push_resource(x3);
			uint64_t v6 = mtp_mirth_need_Need_NEEDz_TAGW(x1);
		} break;
		case 3LL: { // NEED_TAGP
			push_resource(x2);
			push_resource(x3);
			uint64_t v7 = mtp_mirth_need_Need_NEEDz_TAGP(x1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_resource(x3);
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_runZ_argsZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	mw_std_list_List_1_uncons(x1);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		int64_t v3 = mw_std_maybe_Maybe_1_someZAsk(v2);
		if (!((bool)v3)) break;
		VAL v4 = pop_value();
		VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		VAL r8 = pop_resource();
		mw_mirth_need_ZPlusNeeds_runZ_argZBang(VU64(v5), r8, r7);
		mw_std_list_List_1_uncons(v6);
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
}
static void mw_mirth_need_ZPlusNeeds_runZ_argZBang (uint64_t x1, VAL x2, VAL x3) {
	mw_mirth_need_ZPlusNeeds_runZ_blockZBang(x1, x2, x3);
}
static void mw_mirth_need_ZPlusNeeds_runZ_blockZBang (uint64_t x1, VAL x2, VAL x3) {
	mw_mirth_arrow_Block_arrow(x2, x1);
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v1, r0, x3);
}
static void mw_mirth_need_ZPlusNeeds_runZ_wordZBang (uint64_t x1, VAL x2, VAL x3) {
	mw_mirth_word_Word_arrow(x1, x2);
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v1, r0, x3);
}
static void mw_mirth_need_ZPlusNeeds_runZ_arrowZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	push_resource(x3);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_need_ZPlusNeeds_runZ_atomZBang(v6, r9, r8);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_need_ZPlusNeeds_runZ_atomZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	VAL v1 = VVAL(VTUP(x1)->cells[4]);
	incref(v1);
	decref(x1);
	mw_mirth_need_ZPlusNeeds_runZ_opZBang(v0, v1, x2, x3);
}
static void mw_mirth_need_ZPlusNeeds_runZ_opZBang (VAL x1, VAL x2, VAL x3, VAL x4) {
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			decref(x1);
			push_resource(x3);
			push_resource(x4);
		} break;
		case 7LL: { // OpInt
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			int64_t v0 = mtp_mirth_arrow_Op_OpInt(x2);
			VAL v1 = pop_value();
			decref(v1);
		} break;
		case 8LL: { // OpF64
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			double v2 = mtp_mirth_arrow_Op_OpF64(x2);
			VAL v3 = pop_value();
			decref(v3);
		} break;
		case 9LL: { // OpStr
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			VAL v4 = mtp_mirth_arrow_Op_OpStr(x2);
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
		} break;
		case 2LL: { // OpWord
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v6 = mtp_mirth_arrow_Op_OpWord(x2);
			push_u64(v6);
			int64_t v7 = mw_mirth_word_Word_preferZ_inlineZAsk(v6);
			if (((bool)v7)) {
				VAL r8 = pop_resource();
				VAL r9 = pop_resource();
				uint64_t v10 = pop_u64();
				mw_mirth_need_ZPlusNeeds_runZ_wordZBang(v10, r9, r8);
			} else {
				VAL r11 = pop_resource();
				uint64_t v12 = pop_u64();
				VAL v13 = (mw_mirth_need_ZPlusNeeds_needZ_wordZBang(v12, r11));
				push_resource(v13);
			}
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			VAL v16 = pop_value();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v16, r15, r14);
		} break;
		case 3LL: { // OpExternal
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v17 = mtp_mirth_arrow_Op_OpExternal(x2);
			VAL r18 = pop_resource();
			VAL r19 = pop_resource();
			VAL v20 = pop_value();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v20, r19, r18);
		} break;
		case 4LL: { // OpBuffer
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v21 = mtp_mirth_arrow_Op_OpBuffer(x2);
			VAL r22 = pop_resource();
			VAL r23 = pop_resource();
			VAL v24 = pop_value();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v24, r23, r22);
		} break;
		case 5LL: { // OpVariable
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v25 = mtp_mirth_arrow_Op_OpVariable(x2);
			VAL r26 = pop_resource();
			VAL r27 = pop_resource();
			VAL v28 = pop_value();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v28, r27, r26);
		} break;
		case 6LL: { // OpField
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v29 = mtp_mirth_arrow_Op_OpField(x2);
			VAL r30 = pop_resource();
			VAL r31 = pop_resource();
			VAL v32 = pop_value();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v32, r31, r30);
		} break;
		case 10LL: { // OpTag
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v33 = mtp_mirth_arrow_Op_OpTag(x2);
			VAL r34 = pop_resource();
			VAL v35 = (mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang(v33, r34));
			VAL r36 = pop_resource();
			VAL v37 = pop_value();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v37, r36, v35);
		} break;
		case 1LL: { // OpPrim
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			int64_t v38 = mtp_mirth_arrow_Op_OpPrim(x2);
			VAL r39 = pop_resource();
			VAL r40 = pop_resource();
			VAL v41 = pop_value();
			mw_mirth_need_ZPlusNeeds_runZ_primZBang(v41, v38, r40, r39);
		} break;
		case 11LL: { // OpMatch
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			VAL v42 = mtp_mirth_arrow_Op_OpMatch(x2);
			VAL v43 = pop_value();
			decref(v43);
			VAL r44 = pop_resource();
			VAL r45 = pop_resource();
			mw_mirth_need_ZPlusNeeds_runZ_matchZBang(v42, r45, r44);
		} break;
		case 12LL: { // OpLambda
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			VAL v46 = mtp_mirth_arrow_Op_OpLambda(x2);
			VAL v47 = pop_value();
			decref(v47);
			VAL r48 = pop_resource();
			VAL r49 = pop_resource();
			mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang(v46, r49, r48);
		} break;
		case 13LL: { // OpVar
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v50 = mtp_mirth_arrow_Op_OpVar(x2);
			VAL v51 = pop_value();
			decref(v51);
		} break;
		case 14LL: { // OpBlockPush
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v52 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			VAL v53 = pop_value();
			decref(v53);
			VAL r54 = pop_resource();
			VAL r55 = pop_resource();
			mw_mirth_need_ZPlusNeeds_pushZ_blockZBang(v52, r55, r54);
		} break;
		case 15LL: { // OpBlockRun
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v56 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			VAL v57 = pop_value();
			decref(v57);
			VAL r58 = pop_resource();
			VAL r59 = pop_resource();
			mw_mirth_need_ZPlusNeeds_runZ_blockZBang(v56, r59, r58);
		} break;
		case 16LL: { // OpCoerce
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			VAL v60 = mtp_mirth_arrow_Op_OpCoerce(x2);
			decref(v60);
			VAL v61 = pop_value();
			decref(v61);
		} break;
		case 17LL: { // OpLabelPush
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v62 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			VAL v63 = pop_value();
			decref(v63);
		} break;
		case 18LL: { // OpLabelPop
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v64 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			VAL v65 = pop_value();
			decref(v65);
		} break;
		case 19LL: { // OpLabelPushR
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v66 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			VAL v67 = pop_value();
			decref(v67);
		} break;
		case 20LL: { // OpLabelPopR
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v68 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			VAL v69 = pop_value();
			decref(v69);
		} break;
		case 21LL: { // OpDataGetTag
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			uint64_t v70 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			VAL v71 = pop_value();
			decref(v71);
		} break;
		case 22LL: { // OpDataGetLabel
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			VAL v72 = pop_value();
			decref(v72);
			VAL v73 = pop_value();
			decref(v73);
			VAL v74 = pop_value();
			decref(v74);
		} break;
		case 23LL: { // OpDataSetLabel
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
			mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			VAL v75 = pop_value();
			decref(v75);
			VAL v76 = pop_value();
			decref(v76);
			VAL v77 = pop_value();
			decref(v77);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
			push_resource(x3);
			push_resource(x4);
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_runZ_primZBang (VAL x1, int64_t x2, VAL x3, VAL x4) {
	switch (x2) {
		case 4LL: { // PRIM_CORE_DIP
			incref(x1);
			push_resource(x3);
			push_resource(x4);
			push_value(x1);
			VAL v0 = mw_std_list_List_1_ZDivL1(x1);
			switch (get_data_tag(v0)) {
				case 1LL: { // Some
					VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
					decref(v1);
					VAL r2 = pop_resource();
					VAL r3 = pop_resource();
					VAL v4 = pop_value();
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(v4, r3, r2);
				} break;
				case 0LL: { // None
					VAL r5 = pop_resource();
					VAL r6 = pop_resource();
					VAL v7 = pop_value();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v7, r6, r5);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 13LL: { // PRIM_CORE_RDIP
			incref(x1);
			push_resource(x3);
			push_resource(x4);
			push_value(x1);
			VAL v8 = mw_std_list_List_1_ZDivL1(x1);
			switch (get_data_tag(v8)) {
				case 1LL: { // Some
					VAL v9 = mtp_std_maybe_Maybe_1_Some(v8);
					decref(v9);
					VAL r10 = pop_resource();
					VAL r11 = pop_resource();
					VAL v12 = pop_value();
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(v12, r11, r10);
				} break;
				case 0LL: { // None
					VAL r13 = pop_resource();
					VAL r14 = pop_resource();
					VAL v15 = pop_value();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v15, r14, r13);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 5LL: { // PRIM_CORE_IF
			incref(x1);
			push_resource(x3);
			push_resource(x4);
			push_value(x1);
			VAL v16 = mw_std_list_List_1_ZDivL2(x1);
			switch (get_data_tag(v16)) {
				case 1LL: { // Some
					VAL v17 = mtp_std_maybe_Maybe_1_Some(v16);
					decref(v17);
					VAL r18 = pop_resource();
					VAL r19 = pop_resource();
					VAL v20 = pop_value();
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(v20, r19, r18);
				} break;
				case 0LL: { // None
					VAL r21 = pop_resource();
					VAL r22 = pop_resource();
					VAL v23 = pop_value();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v23, r22, r21);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 6LL: { // PRIM_CORE_WHILE
			incref(x1);
			push_resource(x3);
			push_resource(x4);
			push_value(x1);
			VAL v24 = mw_std_list_List_1_ZDivL2(x1);
			switch (get_data_tag(v24)) {
				case 1LL: { // Some
					VAL v25 = mtp_std_maybe_Maybe_1_Some(v24);
					decref(v25);
					VAL r26 = pop_resource();
					VAL r27 = pop_resource();
					VAL v28 = pop_value();
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang(v28, r27, r26);
				} break;
				case 0LL: { // None
					VAL r29 = pop_resource();
					VAL r30 = pop_resource();
					VAL v31 = pop_value();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(v31, r30, r29);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		default: {
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang(x1, x3, x4);
		} break;
	}
}
static void mw_mirth_need_ZPlusNeeds_runZ_matchZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	push_resource(x3);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_need_ZPlusNeeds_runZ_caseZBang(v6, r9, r8);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_need_ZPlusNeeds_runZ_caseZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	push_value(x1);
	mw_mirth_need_ZPlusNeeds_runZ_patternZBang(v0, x2, x3);
	VAL v1 = pop_value();
	VAL v2 = VVAL(VTUP(v1)->cells[2]);
	incref(v2);
	decref(v1);
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v2, r4, r3);
}
static void mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang(v0, x2, x3);
}
static void mw_mirth_need_ZPlusNeeds_runZ_patternZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[9]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	push_resource(x3);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_need_ZPlusNeeds_runZ_patatomZBang(v6, r9, r8);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_need_ZPlusNeeds_runZ_patatomZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // PatOpUnderscore
			push_resource(x2);
			push_resource(x3);
		} break;
		case 1LL: { // PatOpTag
			push_resource(x2);
			push_resource(x3);
			uint64_t v1 = mtp_mirth_match_PatternOp_PatOpTag(v0);
			VAL r2 = pop_resource();
			VAL v3 = (mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang(v1, r2));
			push_resource(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
			push_resource(x3);
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_pushZ_argsZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	mw_std_list_List_1_uncons(x1);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		int64_t v3 = mw_std_maybe_Maybe_1_someZAsk(v2);
		if (!((bool)v3)) break;
		VAL v4 = pop_value();
		VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		VAL r8 = pop_resource();
		mw_mirth_need_ZPlusNeeds_pushZ_argZBang(VU64(v5), r8, r7);
		mw_std_list_List_1_uncons(v6);
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
}
static void mw_mirth_need_ZPlusNeeds_pushZ_argZBang (uint64_t x1, VAL x2, VAL x3) {
	mw_mirth_need_ZPlusNeeds_pushZ_blockZBang(x1, x2, x3);
}
static void mw_mirth_need_ZPlusNeeds_pushZ_blockZBang (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	mw_mirth_arrow_Block_toZ_runZ_var(x2, x1);
	VAL v0 = pop_value();
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			push_resource(x3);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			decref(v1);
			VAL v2 = pop_value();
			decref(v2);
		} break;
		case 0LL: { // None
			uint64_t v3 = pop_u64();
			VAL v4 = (mw_mirth_need_ZPlusNeeds_needZ_blockZBang(v3, x3));
			push_resource(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x3);
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99_put (VAL x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[5]));
	VAL v1 = (mw_std_output_ZPlusOutput_put(x1, v0));
	VTUP(x2)->cells[5] = v1;
	return x2;
}
static VAL mw_mirth_c99_ZPlusC99_putZ_byte (int64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[5]));
	VAL v1 = (mw_std_output_ZPlusOutput_putZ_byte(x1, v0));
	VTUP(x2)->cells[5] = v1;
	return x2;
}
static VAL mw_mirth_c99_ZPlusC99_line (VAL x1) {
	VAL v0 = (VVAL(VTUP(x1)->cells[5]));
	VAL v1 = (mw_std_output_ZPlusOutput_line(v0));
	VTUP(x1)->cells[5] = v1;
	return x1;
}
static void mw_mirth_c99_c99Z_startZBang (VAL x1, VAL x2, VAL x3, VAL x4) {
	int64_t v0 = 0LL;
	push_value(x1);
	push_resource(x3);
	push_resource(x4);
	lpush(&lbl_options, x2);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	int64_t v2 = 0LL;
	lpush(&lbl_depth, MKI64(v1));
	int64_t v3 = mw_std_prim_Int_ZToNat(v2);
	lpush(&lbl_freshZ_counter, MKI64(v3));
	VAL v4 = (mw_mirth_need_ZPlusNeeds_new());
	VAL v5 = pop_value();
	incref(v5);
	VAL r6 = pop_resource();
	push_value(v5);
	mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang(v5, r6, v4);
	VAL r7 = pop_resource();
	VAL r8 = pop_resource();
	VAL v9 = lpop(&lbl_options);
	incref(v9);
	VAL v10 = VVAL(VTUP(v9)->cells[1]);
	incref(v10);
	decref(v9);
	VAL r11 = pop_resource();
	lpush(&lbl_ZPlusneeds, r7);
	lpush(&lbl_ZPlusmirth, r8);
	lpush(&lbl_options, v9);
	mw_std_prim_ZPlusWorld_createZ_fileZBang(v10, r11);
	VAL r12 = pop_resource();
	VAL v13 = (mw_std_file_ZPlusFileZAsk_unwrapZBang(r12));
	VAL v14 = (mw_std_output_ZPlusOutput_startZBang(v13));
	VAL v15 = (lpop(&lbl_ZPlusmirth));
	VAL v16 = (lpop(&lbl_ZPlusneeds));
	int64_t v17 = VI64(lpop(&lbl_freshZ_counter));
	int64_t v18 = VI64(lpop(&lbl_depth));
	VAL v19 = lpop(&lbl_options);
	VAL v20 = (mtw_mirth_c99_ZPlusC99_ZPlusC99(v19, v18, v17, v16, v14, v15));
	push_resource(v20);
}
static void mw_mirth_c99_c99Z_endZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_c99_ZPlusC99_ZPlusC99(x2);
	int64_t v0 = VI64(lpop(&lbl_depth));
	int64_t v1 = VI64(lpop(&lbl_freshZ_counter));
	VAL v2 = lpop(&lbl_options);
	decref(v2);
	VAL v3 = (lpop(&lbl_ZPlusneeds));
	mw_mirth_need_ZPlusNeeds_rdrop(v3);
	VAL v4 = (lpop(&lbl_ZPlusoutput));
	VAL v5 = (mw_std_output_ZPlusOutput_endZBang(v4));
	VAL r6 = pop_resource();
	VAL v7 = (mw_std_file_ZPlusFile_closeZ_fileZBang(r6, v5));
	VAL v8 = (lpop(&lbl_ZPlusmirth));
	push_resource(v7);
	push_resource(v8);
}
static VAL mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang (VAL x1) {
	int64_t v0 = 0LL;
	push_resource(x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL r2 = pop_resource();
	VTUP(r2)->cells[3] = MKI64(v1);
	return r2;
}
static void mw_mirth_c99_ZPlusC99_freshZ_natZBang (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[3]);
	int64_t v1 = 1LL;
	int64_t v2 = i64_add(v0, v1);
	VTUP(x1)->cells[3] = MKI64(v2);
	push_i64(v0);
	push_resource(x1);
}
static void mw_mirth_c99_ZPlusC99_freshZ_nameZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "v", 1);
	mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang(MKSTR(v0), x1);
}
static void mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "r", 1);
	mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang(MKSTR(v0), x1);
}
static void mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "x", 1);
	mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang(MKSTR(v0), x1);
}
static void mw_mirth_c99_ZPlusC99_freshZ_nameZ_onZBang (VAL x1, VAL x2) {
	push_value(x1);
	mw_mirth_c99_ZPlusC99_freshZ_natZBang(x2);
	int64_t v0 = pop_i64();
	STR* v1 = i64_show(v0);
	STR* v2 = pop_str();
	STR* v3 = str_cat(v2, v1);
	push_str(v3);
}
static void mw_mirth_c99_runZ_outputZ_c99ZBang (VAL x1, VAL x2, VAL x3, VAL x4) {
	int64_t v0 = VI64(VTUP(x4)->cells[1]);
	int64_t v1 = 0LL;
	bool v2 = (v0 > v1);
	if (v2) {
		decref(x2);
		decref(x1);
		push_resource(x3);
		push_resource(x4);
	} else {
		mw_mirth_c99_c99Z_startZBang(x1, x2, x3, x4);
		VAL r3 = pop_resource();
		VAL v4 = (mw_mirth_c99_c99Z_headerZBang(r3));
		VAL v5 = (mw_mirth_c99_c99Z_labelZ_defsZBang(v4));
		VAL v6 = (mw_mirth_c99_c99Z_tagZ_defsZBang(v5));
		VAL v7 = (mw_mirth_c99_c99Z_buffersZBang(v6));
		VAL v8 = (mw_mirth_c99_c99Z_variablesZBang(v7));
		VAL v9 = (mw_mirth_c99_c99Z_externalZ_blocksZBang(v8));
		VAL v10 = (mw_mirth_c99_c99Z_wordZ_sigsZBang(v9));
		VAL v11 = (mw_mirth_c99_c99Z_blockZ_sigsZBang(v10));
		VAL v12 = (mw_mirth_c99_c99Z_fieldZ_sigsZBang(v11));
		VAL v13 = pop_value();
		VAL v14 = (mw_mirth_c99_c99Z_mainZBang(v13, v12));
		VAL v15 = (mw_mirth_c99_c99Z_fieldZ_defsZBang(v14));
		VAL v16 = (mw_mirth_c99_c99Z_wordZ_defsZBang(v15));
		VAL v17 = (mw_mirth_c99_c99Z_blockZ_defsZBang(v16));
		VAL r18 = pop_resource();
		mw_mirth_c99_c99Z_endZBang(r18, v17);
	}
}
static void mw_mirth_data_Tag_wordZ_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_data_Tag_ZTildewordZ_cname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		STR* v3;
		STRLIT(v3, "", 0);
		STR* v4;
		STRLIT(v4, "mtw_", 4);
		push_resource(x1);
		push_u64(x2);
		VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), MKSTR(v3)));
		uint64_t v6 = pop_u64();
		push_resource(v5);
		push_u64(v6);
		VAL v7 = mw_mirth_data_Tag_qname(v6);
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_name_QName_mangled(r9, v7);
		VAL v10 = pop_value();
		VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, r8));
		incref(v11);
		mut_set(v11, MKPTR(v0));
		push_value(v11);
	}
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	decref(v13);
	push_value(v12);
}
static void mw_mirth_data_Tag_patZ_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_data_Tag_ZTildepatZ_cname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		STR* v3;
		STRLIT(v3, "", 0);
		STR* v4;
		STRLIT(v4, "mtp_", 4);
		push_resource(x1);
		push_u64(x2);
		VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), MKSTR(v3)));
		uint64_t v6 = pop_u64();
		push_resource(v5);
		push_u64(v6);
		VAL v7 = mw_mirth_data_Tag_qname(v6);
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_name_QName_mangled(r9, v7);
		VAL v10 = pop_value();
		VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, r8));
		incref(v11);
		mut_set(v11, MKPTR(v0));
		push_value(v11);
	}
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	decref(v13);
	push_value(v12);
}
static void mw_mirth_buffer_Buffer_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_buffer_Buffer_ZTildecname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		STR* v3;
		STRLIT(v3, "", 0);
		STR* v4;
		STRLIT(v4, "mbuf_", 5);
		push_resource(x1);
		push_u64(x2);
		VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), MKSTR(v3)));
		uint64_t v6 = pop_u64();
		push_resource(v5);
		push_u64(v6);
		VAL v7 = mw_mirth_buffer_Buffer_qname(v6);
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_name_QName_mangled(r9, v7);
		VAL v10 = pop_value();
		VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, r8));
		incref(v11);
		mut_set(v11, MKPTR(v0));
		push_value(v11);
	}
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	decref(v13);
	push_value(v12);
}
static void mw_mirth_variable_Variable_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_variable_Variable_ZTildecname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		STR* v3;
		STRLIT(v3, "", 0);
		STR* v4;
		STRLIT(v4, "mvar_", 5);
		push_resource(x1);
		push_u64(x2);
		VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v4), MKSTR(v3)));
		uint64_t v6 = pop_u64();
		push_resource(v5);
		push_u64(v6);
		VAL v7 = mw_mirth_variable_Variable_qname(v6);
		VAL r8 = pop_resource();
		VAL r9 = pop_resource();
		mw_mirth_name_QName_mangled(r9, v7);
		VAL v10 = pop_value();
		VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(v10, r8));
		incref(v11);
		mut_set(v11, MKPTR(v0));
		push_value(v11);
	}
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	decref(v13);
	push_value(v12);
}
static void mw_mirth_table_Field_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_table_Field_ZTildecname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		push_u64(x2);
		mw_mirth_table_Field_qnameZ_hard(x1, x2);
		VAL v3 = pop_value();
		VAL r4 = pop_resource();
		mw_mirth_name_QName_mangled(r4, v3);
		STR* v5;
		STRLIT(v5, "", 0);
		STR* v6;
		STRLIT(v6, "mfld_", 5);
		VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), MKSTR(v5)));
		VAL v8 = pop_value();
		VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(v8, v7));
		incref(v9);
		mut_set(v9, MKPTR(v0));
		push_value(v9);
	}
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	decref(v11);
	push_value(v10);
}
static void mw_mirth_external_External_cname (VAL x1, uint64_t x2) {
	void* v0 = mfld_mirth_external_External_ZTildecname(x2);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x1);
		push_u64(x2);
		push_value(v2);
	} else {
		push_u64(x2);
		mw_mirth_external_External_qnameZ_hard(x1, x2);
		VAL v3 = pop_value();
		VAL r4 = pop_resource();
		mw_mirth_name_QName_mangled(r4, v3);
		STR* v5;
		STRLIT(v5, "", 0);
		STR* v6;
		STRLIT(v6, "mext_", 5);
		VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), MKSTR(v5)));
		VAL v8 = pop_value();
		VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(v8, v7));
		incref(v9);
		mut_set(v9, MKPTR(v0));
		push_value(v9);
	}
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	decref(v11);
	push_value(v10);
}
static VAL mw_mirth_c99_ZPlusC99_sigZ_put (VAL x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "static void ", 12);
	push_value(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	VAL v2 = pop_value();
	VAL v3 = (mw_mirth_c99_ZPlusC99_put(v2, v1));
	STR* v4;
	STRLIT(v4, " (void)", 7);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	return v5;
}
static VAL mw_mirth_c99_c99Z_headerZ_str (void) {
	STR* v0;
	STRLIT(v0,
		"/* MIRTH HEADER */\n"
		"// #line 3 \"src/mirth.h\"\n"
		"\n"
		"#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n"
		"#define MIRTH_WINDOWS 1\n"
		"#elif defined(__linux__)\n"
		"#define MIRTH_LINUX 1\n"
		"#elif defined(__APPLE__)\n"
		"#define MIRTH_MACOS 1\n"
		"#else\n"
		"#error \"Platform not supported.\"\n"
		"#endif\n"
		"\n"
		"#if defined(__x86_64__) || defined(_M_X64)\n"
		"#define MIRTH_AMD64\n"
		"#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n"
		"#define MIRTH_I386\n"
		"#elif defined(__aarch64__) || defined(_M_ARM64)\n"
		"#define MIRTH_ARM64\n"
		"#else\n"
		"#error \"Architecture not supported.\"\n"
		"#endif\n"
		"\n"
		"#include <stdint.h>\n"
		"#include <stdbool.h>\n"
		"#include <stddef.h>\n"
		"#include <float.h>\n"
		"\n"
		"extern void* malloc(size_t);\n"
		"extern void* calloc(size_t, size_t);\n"
		"extern void* realloc(void*, size_t);\n"
		"extern void* memset(void*, int, size_t);\n"
		"extern void* memcpy(void*, const void*, size_t);\n"
		"extern int memcmp(const void*, const void*, size_t);\n"
		"extern int strcmp(const char*, const char*);\n"
		"extern size_t strlen(const char*);\n"
		"extern void free(void*);\n"
		"extern int read(int, void*, size_t);\n"
		"extern int write(int, const char*, size_t);\n"
		"extern int close(int);\n"
		"extern int open(const char*, int, ...);\n"
		"extern void exit(int);\n"
		"extern int sprintf (char * s, const char * format, ...);\n"
		"\n"
		"typedef uint16_t TAG;\n"
		"#define REFS_FLAG \t 0x8000\n"
		"#define TUP_FLAG \t 0x4000\n"
		"#define TUP_LEN_MASK 0x3FFF\n"
		"#define TUP_LEN_MAX  0x3FFF\n"
		"\n"
		"#define TAG_INT 1\n"
		"#define TAG_PTR 1\n"
		"#define TAG_STR (2 | REFS_FLAG)\n"
		"#define TAG_FNPTR 3\n"
		"#define TAG_F32 4\n"
		"#define TAG_F64 5\n"
		"#define TAG_TUP_NIL TUP_FLAG\n"
		"#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)\n"
		"#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (n))\n"
		"\n"
		"typedef uint32_t REFS;\n"
		"typedef uint64_t USIZE;\n"
		"typedef void (*FNPTR)(void);\n"
		"\n"
		"typedef union DATA {\n"
		"\tUSIZE usize;\n"
		"\tuint64_t u64;\n"
		"\tuint32_t u32;\n"
		"\tuint16_t u16;\n"
		"\tuint8_t u8;\n"
		"\tint64_t i64;\n"
		"\tint32_t i32;\n"
		"\tint16_t i16;\n"
		"\tint8_t i8;\n"
		"\tfloat f32;\n"
		"\tdouble f64;\n"
		"\tvoid* ptr;\n"
		"\tFNPTR fnptr;\n"
		"\tREFS* refs;\n"
		"\tstruct TUP* tup;\n"
		"\tstruct STR* str;\n"
		"} DATA;\n"
		"\n"
		"typedef struct VAL {\n"
		"\tDATA data;\n"
		"\tTAG tag;\n"
		"} VAL;\n"
		"\n"
		"#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))\n"
		"\n"
		"#define VREFS(v)  (*(v).data.refs)\n"
		"#define VVAL(v)   (v)\n"
		"#define VINT(v)   ((v).data.i64)\n"
		"#define VI64(v)   ((v).data.i64)\n"
		"#define VI32(v)   ((v).data.i32)\n"
		"#define VI16(v)   ((v).data.i16)\n"
		"#define VI8(v)    ((v).data.i8)\n"
		"#define VU64(v)   ((v).data.u64)\n"
		"#define VU32(v)   ((v).data.u32)\n"
		"#define VU16(v)   ((v).data.u16)\n"
		"#define VU8(v)    ((v).data.u8)\n"
		"#define VBOOL(v)  ((_Bool)((v).data.u64))\n"
		"#define VF32(v)   ((v).data.f32)\n"
		"#define VF64(v)   ((v).data.f64)\n"
		"#define VPTR(v)   ((v).data.ptr)\n"
		"#define VFNPTR(v) ((v).data.fnptr)\n"
		"#define VSTR(v)   ((v).data.str)\n"
		"#define VTUP(v)   ((v).data.tup)\n"
		"#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))\n"
		"\n"
		"#define HAS_REFS(v) ((v).tag & REFS_FLAG)\n"
		"#define IS_VAL(v)   (1)\n"
		"#define IS_INT(v)   ((v).tag == TAG_INT)\n"
		"#define IS_I64(v)   ((v).tag == TAG_INT)\n"
		"#define IS_U64(v)   ((v).tag == TAG_INT)\n"
		"#define IS_BOOL(v)  ((v).tag == TAG_INT)\n"
		"#define IS_F32(v)   ((v).tag == TAG_F32)\n"
		"#define IS_F64(v)   ((v).tag == TAG_F64)\n"
		"#define IS_PTR(v)   ((v).tag == TAG_PTR)\n"
		"#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)\n"
		"#define IS_STR(v)   ((v).tag == TAG_STR)\n"
		"#define IS_TUP(v)   ((v).tag & TUP_FLAG)\n"
		"#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))\n"
		"\n"
		"#define MKVAL(x)   (x)\n"
		"#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI32(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI16(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI8(x)    ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKU32(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKU16(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKU8(x)    ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKBOOL(x)  ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKF32(x)   ((VAL){.tag=TAG_F32, .data={.f32=(x)}})\n"
		"#define MKF64(x)   ((VAL){.tag=TAG_F64, .data={.f64=(x)}})\n"
		"#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})\n"
		"#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})\n"
		"#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})\n"
		"#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})\n"
		"#define MKNIL_C\t         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}\n"
		"#define MKNIL      ((VAL)MKNIL_C)\n"
		"\n"
		"#define STRLIT(v,x,n) \\\n"
		"\tdo { \\\n"
		"\t\tstatic STR* mval = 0; \\\n"
		"\t\tif (!mval) mval = str_make(x,n); \\\n"
		"\t\tincref(MKSTR(mval)); \\\n"
		"\t\tv = mval; \\\n"
		"\t} while(0)\n"
		"\n"
		"typedef uint16_t TUPLEN;\n"
		"typedef struct TUP {\n"
		"\tREFS refs;\n"
		"\tTUPLEN cap;\n"
		"\tTUPLEN size;\n"
		"\tVAL cells[];\n"
		"} TUP;\n"
		"\n"
		"typedef struct STR {\n"
		"\tREFS refs;\n"
		"\tUSIZE cap;\n"
		"\tUSIZE size;\n"
		"\tchar data[];\n"
		"} STR;\n"
		"\n"
		"#define STACK_MAX 0x80000\n"
		"static USIZE stack_counter = STACK_MAX;\n"
		"static VAL stack [STACK_MAX] = {0};\n"
		"static USIZE rstack_counter = STACK_MAX;\n"
		"static VAL rstack [STACK_MAX] = {0};\n"
		"\n"
		"static int global_argc;\n"
		"static char** global_argv;\n"
		"\n"
		"static void push_value(VAL v);\n"
		"static void trace_stack(void);\n"
		"static void trace_rstack(void);\n"
		"\n"
		"#if MIRTH_DEBUG\n"
		"\ttypedef struct LOC {\n"
		"\t\tFNPTR fnptr;\n"
		"\t\tconst char* word;\n"
		"\t\tconst char* path;\n"
		"\t\tUSIZE line, col;\n"
		"\t\tconst char* atom;\n"
		"\t} LOC;\n"
		"\tstatic USIZE fstack_counter = 0;\n"
		"\tstatic LOC fstack [STACK_MAX] = {\n"
		"\t\t{\n"
		"\t\t\t.fnptr=(void(*)(void))0,\n"
		"\t\t\t.word=\"<word>\",\n"
		"\t\t\t.path=\"<path>\",\n"
		"\t\t\t.line=0, .col=0,\n"
		"\t\t\t.atom=\"<atom>\"\n"
		"\t\t},\n"
		"\t};\n"
		"\n"
		"\t#define WORD_ENTER(_f,_w,_p,_l,_c) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tfstack[fstack_counter].fnptr = (_f); \\\n"
		"\t\t\tfstack[fstack_counter].word = (_w); \\\n"
		"\t\t\tfstack[fstack_counter].path = (_p); \\\n"
		"\t\t\tfstack[fstack_counter].line = (_l); \\\n"
		"\t\t\tfstack[fstack_counter].col = (_c); \\\n"
		"\t\t\tfstack[fstack_counter].atom = \"\"; \\\n"
		"\t\t\tfstack_counter++; \\\n"
		"\t\t} while(0)\n"
		"\n"
		"\t#define WORD_ATOM(_l,_c,_n) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tif (fstack_counter > 0) { \\\n"
		"\t\t\t\tfstack[fstack_counter-1].line = (_l); \\\n"
		"\t\t\t\tfstack[fstack_counter-1].col = (_c); \\\n"
		"\t\t\t\tfstack[fstack_counter-1].atom = (_n); \\\n"
		"\t\t\t} \\\n"
		"\t\t} while(0)\n"
		"\n"
		"\t#define WORD_EXIT(_f) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tif ((fstack_counter == 0) || (fstack[fstack_counter-1].fnptr != (_f))) { \\\n"
		"\t\t\t\tTRACE(\"mismatched WORD_EXIT, expected \" #_f \"\\n\"); \\\n"
		"\t\t\t\texit(1); \\\n"
		"\t\t\t} \\\n"
		"\t\t\tfstack_counter--; \\\n"
		"\t\t} while(0)\n"
		"\t#define PRIM_ENTER(_f,_w) WORD_ENTER(_f,_w,__FILE__,__LINE__,1)\n"
		"\t#define PRIM_EXIT(_f) WORD_EXIT(_f)\n"
		"#else\n"
		"\t#define PRIM_ENTER(_f,_w)\n"
		"\t#define PRIM_EXIT(_f)\n"
		"#endif\n"
		"\n"
		"#define TRACE(x) write(2,x,strlen(x))\n"
		"#define _STR(x) #x\n"
		"#define STR(x) _STR(x)\n"
		"\n"
		"#define EXPECT(test,msg) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\ttrace_stack(); \\\n"
		"\t\t\ttrace_rstack(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define EXPECT1(test,msg,v1) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tpush_value(v1); \\\n"
		"\t\t\ttrace_stack(); \\\n"
		"\t\t\ttrace_rstack(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define EXPECT2(test,msg,v1,v2) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tpush_value(v1); \\\n"
		"\t\t\tpush_value(v2); \\\n"
		"\t\t\ttrace_stack(); \\\n"
		"\t\t\ttrace_rstack(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define ASSERT(test) \\\n"
		"\tEXPECT(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\")\n"
		"#define ASSERT1(test,v) \\\n"
		"\tEXPECT1(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v)\n"
		"#define ASSERT2(test,v1,v2) \\\n"
		"\tEXPECT2(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v1, v2)\n"
		"\n"
		"#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)\n"
		"#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)\n"
		"static void free_value(VAL v) {\n"
		"\tASSERT(HAS_REFS(v));\n"
		"\tASSERT(VREFS(v) == 0);\n"
		"\tASSERT1(IS_TUP(v)||IS_STR(v), v);\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tTUP* tup = VTUP(v);\n"
		"\t\tASSERT(tup);\n"
		"\t\tfor (TUPLEN i = 0; i < tup->size; i++) {\n"
		"\t\t\tdecref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tfree(tup);\n"
		"\t} else if (IS_STR(v)) {\n"
		"\t\tSTR* str = VSTR(v);\n"
		"\t\tASSERT(str);\n"
		"\t\tfree(str);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void tup_decref_outer(TUP* tup, size_t n) {\n"
		"\tif (tup->refs == 1) {\n"
		"\t\tfor (size_t i = n; i < tup->size; i++) {\n"
		"\t\t\tdecref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tfree(tup);\n"
		"\t} else {\n"
		"\t\tfor (size_t i = 0; i < n; i++) {\n"
		"\t\t\tincref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tif (!--tup->refs) free_value(MKTUP(tup,n));\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void value_uncons(VAL val, VAL* tail, VAL* head) {\n"
		"\tif (IS_TUP(val)) {\n"
		"\t\tTUPLEN len = VTUPLEN(val);\n"
		"\t\tTUP* tup = VTUP(val);\n"
		"\t\tASSERT1((len > 0) && tup, val);\n"
		"\t\tVAL tailval = MKTUP(tup, len-1);\n"
		"\t\tVAL headval = tup->cells[len-1];\n"
		"\t\tif (len == 1) {\n"
		"\t\t\tincref(headval);\n"
		"\t\t\tdecref(val);\n"
		"\t\t\ttailval = MKNIL;\n"
		"\t\t} else {\n"
		"\t\t\tif (tup->refs == 1) {\n"
		"\t\t\t\tfor (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }\n"
		"\t\t\t\tmemset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));\n"
		"\t\t\t\ttup->size = len-1;\n"
		"\t\t\t} else {\n"
		"\t\t\t\tincref(headval);\n"
		"\t\t\t}\n"
		"\t\t\tif (len == 2) {\n"
		"\t\t\t\tVAL ptval = tup->cells[0];\n"
		"\t\t\t\tif (!IS_TUP(ptval)) {\n"
		"\t\t\t\t\tincref(ptval);\n"
		"\t\t\t\t\tdecref(tailval);\n"
		"\t\t\t\t\ttailval = ptval;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t\t*tail = tailval;\n"
		"\t\t*head = headval;\n"
		"\t} else {\n"
		"\t\t*tail = MKNIL;\n"
		"\t\t*head = val;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static uint64_t value_u64 (VAL v) {\n"
		"\tASSERT1(IS_INT(v),v);\n"
		"\treturn VU64(v);\n"
		"}\n"
		"\n"
		"static int64_t value_i64 (VAL v) {\n"
		"\tASSERT1(IS_INT(v),v);\n"
		"\treturn VI64(v);\n"
		"}\n"
		"\n"
		"static float value_f32 (VAL v) {\n"
		"\tASSERT1(IS_F32(v), v);\n"
		"\treturn VF32(v);\n"
		"}\n"
		"\n"
		"static double value_f64 (VAL v) {\n"
		"\tASSERT1(IS_F64(v), v);\n"
		"\treturn VF64(v);\n"
		"}\n"
		"\n"
		"static void* value_ptr (VAL v) {\n"
		"\tASSERT1(IS_PTR(v),v);\n"
		"\treturn VPTR(v);\n"
		"}\n"
		"\n"
		"static FNPTR value_fnptr (VAL v) {\n"
		"\tASSERT1(IS_FNPTR(v),v);\n"
		"\treturn VFNPTR(v);\n"
		"}\n"
		"\n"
		"static STR* value_str (VAL v) {\n"
		"\tASSERT1(IS_STR(v),v);\n"
		"\treturn VSTR(v);\n"
		"}\n"
		"\n"
		"#define pop_u8() ((uint8_t)pop_u64())\n"
		"#define pop_u16() ((uint16_t)pop_u64())\n"
		"#define pop_u32() ((uint32_t)pop_u64())\n"
		"#define pop_u64() (value_u64(pop_value()))\n"
		"#define pop_i8() ((int8_t)pop_i64())\n"
		"#define pop_i16() ((int16_t)pop_i64())\n"
		"#define pop_i32() ((int32_t)pop_i64())\n"
		"#define pop_i64() (value_i64(pop_value()))\n"
		"#define pop_usize() (pop_u64())\n"
		"#define pop_f32() (value_f32(pop_value()))\n"
		"#define pop_f64() (value_f64(pop_value()))\n"
		"#define pop_bool() ((bool)pop_u64())\n"
		"#define pop_str() (value_str(pop_value()))\n"
		"#define pop_ptr() (value_ptr(pop_value()))\n"
		"#define pop_fnptr() (value_fnptr(pop_value()))\n"
		"\n"
		"#define push_u64(v) push_value(MKU64(v))\n"
		"#define push_i64(v) push_value(MKI64(v))\n"
		"#define push_usize(v) push_u64((uint64_t)(v))\n"
		"#define push_bool(b) push_u64((uint64_t)((bool)(b)))\n"
		"#define push_u8(b) push_u64((uint64_t)(b))\n"
		"#define push_u16(b) push_u64((uint64_t)(b))\n"
		"#define push_u32(b) push_u64((uint64_t)(b))\n"
		"#define push_i8(b) push_i64((int64_t)(b))\n"
		"#define push_i16(b) push_i64((int64_t)(b))\n"
		"#define push_i32(b) push_i64((int64_t)(b))\n"
		"#define push_f32(f) push_value(MKF32(f))\n"
		"#define push_f64(f) push_value(MKF64(f))\n"
		"#define push_str(p) push_value(MKSTR(p))\n"
		"#define push_ptr(p) push_value(MKPTR(p))\n"
		"#define push_fnptr(p) push_value(MKFNPTR(p))\n"
		"\n"
		"static void push_value(VAL x) {\n"
		"\tASSERT(stack_counter > 0);\n"
		"\tstack[--stack_counter] = x;\n"
		"}\n"
		"\n"
		"static VAL top_value(void) {\n"
		"\tASSERT(stack_counter < STACK_MAX);\n"
		"\treturn stack[stack_counter];\n"
		"}\n"
		"\n"
		"static VAL pop_value(void) {\n"
		"\tASSERT(stack_counter < STACK_MAX);\n"
		"\treturn stack[stack_counter++];\n"
		"}\n"
		"\n"
		"static void push_resource(VAL x) {\n"
		"\tASSERT(rstack_counter > 0);\n"
		"\trstack[--rstack_counter] = x;\n"
		"}\n"
		"\n"
		"static VAL top_resource(void) {\n"
		"\tASSERT(rstack_counter < STACK_MAX);\n"
		"\treturn rstack[rstack_counter];\n"
		"}\n"
		"\n"
		"static VAL pop_resource(void) {\n"
		"\tASSERT(rstack_counter < STACK_MAX);\n"
		"\treturn rstack[rstack_counter++];\n"
		"}\n"
		"\n"
		"// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.\n"
		"static TUP* tup_new (TUPLEN cap_hint) {\n"
		"\tif (cap_hint < 3) cap_hint = 3;\n"
		"\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
		"\tTUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
		"\tASSERT(new_tup);\n"
		"\tnew_tup->refs = 1;\n"
		"\tnew_tup->cap = cap_hint;\n"
		"\treturn new_tup;\n"
		"}\n"
		"\n"
		"// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.\n"
		"// Consume old_tup and copy its elements over to the new tuple.\n"
		"static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {\n"
		"\tASSERT(old_tup);\n"
		"\tif (cap_hint < old_tup->size) cap_hint = old_tup->size;\n"
		"\tif (old_tup->refs == 1) {\n"
		"\t\tif (cap_hint < 3) cap_hint = 3;\n"
		"\t\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
		"\t\tTUPLEN old_cap = old_tup->cap;\n"
		"\t\tTUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
		"\t\tASSERT(new_tup);\n"
		"\t\tif (old_cap < cap_hint) {\n"
		"\t\t\tmemset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));\n"
		"\t\t}\n"
		"\t\tnew_tup->cap = cap_hint;\n"
		"\t\treturn new_tup;\n"
		"\t} else {\n"
		"\t\tTUP* new_tup = tup_new(cap_hint);\n"
		"\t\tfor (TUPLEN i = 0; i < old_tup->size; i++) {\n"
		"\t\t\tVAL v = old_tup->cells[i];\n"
		"\t\t\tnew_tup->cells[i] = v;\n"
		"\t\t\tincref(v);\n"
		"\t\t}\n"
		"\t\tnew_tup->size = old_tup->size;\n"
		"\t\told_tup->refs--;\n"
		"\t\treturn new_tup;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static VAL tup_replace (VAL tup, TUPLEN i, VAL v) {\n"
		"\tASSERT(IS_TUP(tup));\n"
		"\tTUPLEN n = VTUPLEN(tup);\n"
		"\tASSERT(i < n);\n"
		"\tif (VTUP(tup)->refs > 1) {\n"
		"\t\tTUP* newtup = tup_new(n);\n"
		"\t\tnewtup->size = n;\n"
		"\t\tmemcpy(newtup->cells, VTUP(tup)->cells, n*sizeof(VAL));\n"
		"\t\tfor (TUPLEN j=0; j<n; j++) incref(newtup->cells[j]);\n"
		"\t\tdecref(tup);\n"
		"\t\ttup = MKTUP(newtup, n);\n"
		"\t}\n"
		"\tVAL u = VTUP(tup)->cells[i];\n"
		"\tVTUP(tup)->cells[i] = v;\n"
		"\tdecref(u);\n"
		"\treturn tup;\n"
		"}\n"
		"\n"
		"static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {\n"
		"\tif (IS_TUP(tail) && HAS_REFS(tail)) {\n"
		"\t\tTUPLEN tail_len = VTUPLEN(tail);\n"
		"\t\tTUP *tail_tup = VTUP(tail);\n"
		"\t\tASSERT1(tail_tup, tail);\n"
		"\t\tASSERT1(tail_len <= tail_tup->size, tail);\n"
		"\t\tif (tail_len < tail_tup->size) {\n"
		"\t\t\tASSERT1(tail_tup->refs >= 1, tail);\n"
		"\t\t\tif (tail_tup->refs == 1) {\n"
		"\t\t\t\tdecref(tail_tup->cells[tail_len]);\n"
		"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
		"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t} else {\n"
		"\t\t\t\tVAL *cmp = &tail_tup->cells[tail_len];\n"
		"\t\t\t\tif (VALEQ(*cmp, head)) {\n"
		"\t\t\t\t\tdecref(head);\n"
		"\t\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t\t} else {\n"
		"\t\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
		"\t\t\t\t\tTUP* new_tup = tup_new(cap_hint);\n"
		"\t\t\t\t\tfor (TUPLEN i = 0; i < tail_len; i++) {\n"
		"\t\t\t\t\t\tVAL v = tail_tup->cells[i];\n"
		"\t\t\t\t\t\tnew_tup->cells[i] = v;\n"
		"\t\t\t\t\t\tincref(v);\n"
		"\t\t\t\t\t}\n"
		"\t\t\t\t\tnew_tup->cells[tail_len] = head;\n"
		"\t\t\t\t\tnew_tup->size = tail_len+1;\n"
		"\t\t\t\t\ttail_tup->refs--;\n"
		"\t\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t} else {\n"
		"\t\t\tASSERT1(tail_len < TUP_LEN_MAX, tail);\n"
		"\t\t\tASSERT1(tail_len <= tail_tup->cap, tail);\n"
		"\t\t\tif (tail_len < tail_tup->cap) {\n"
		"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
		"\t\t\t\ttail_tup->size = tail_len+1;\n"
		"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t} else {\n"
		"\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
		"\t\t\t\tTUP* new_tup = tup_resize(tail_tup, cap_hint);\n"
		"\t\t\t\tASSERT(tail_len < new_tup->cap);\n"
		"\t\t\t\tnew_tup->size = tail_len+1;\n"
		"\t\t\t\tnew_tup->cells[tail_len] = head;\n"
		"\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t} else if (IS_TUP(tail)) { // cons onto nil\n"
		"\t\tASSERT(IS_NIL(tail));\n"
		"\t\tif (IS_TUP(head)) {\n"
		"\t\t\tTUP* tup = tup_new(cap_hint);\n"
		"\t\t\ttup->size = 1;\n"
		"\t\t\ttup->cells[0] = head;\n"
		"\t\t\treturn MKTUP(tup,1);\n"
		"\t\t} else { // non-tup value pretends to be unary tuple\n"
		"\t\t\treturn head;\n"
		"\t\t}\n"
		"\t} else { // cons onto non-tup value pretending to be unary tuple\n"
		"\t\tTUP* tup = tup_new(cap_hint);\n"
		"\t\ttup->size = 2;\n"
		"\t\ttup->cells[0] = tail;\n"
		"\t\ttup->cells[1] = head;\n"
		"\t\treturn MKTUP(tup,2);\n"
		"\t}\n"
		"}\n"
		"static VAL mkcons(VAL tail, VAL head) {\n"
		"\tVAL v = mkcons_hint(tail,head,3);\n"
		"\treturn v;\n"
		"}\n"
		"\n"
		"static VAL lpop(VAL* stk) {\n"
		"\tVAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);\n"
		"\t*stk=lcar; return lcdr;\n"
		"}\n"
		"static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }\n"
		"#define LPOP(v) push_value(lpop(&(v)))\n"
		"#define LPUSH(v) lpush(&(v),pop_value())\n"
		"#define LPOPR(v) push_resource(lpop(&(v)))\n"
		"#define LPUSHR(v) lpush(&(v),pop_resource())\n"
		"\n"
		"static STR* str_alloc (USIZE cap) {\n"
		"\tASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);\n"
		"\tSTR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));\n"
		"\tEXPECT(str, \"failed to allocate string\");\n"
		"\tstr->refs = 1;\n"
		"\tstr->cap = cap;\n"
		"\treturn str;\n"
		"}\n"
		"\n"
		"static STR* str_make (const char* data, USIZE size) {\n"
		"\tASSERT(data);\n"
		"\tASSERT(size <= SIZE_MAX - sizeof(STR) - 4);\n"
		"\tSTR* str = str_alloc(size);\n"
		"\tstr->size = size;\n"
		"\tmemcpy(str->data, data, (size_t)size);\n"
		"\treturn str;\n"
		"}\n"
		"#define mkstr(x,n) MKSTR(str_make((x), (n)))\n"
		"\n"
		"static STR* str_cat (STR* s1, STR* s2) {\n"
		"\tEXPECT(s1 && s2, \"invalid strings in prim-str-cat\");\n"
		"\tUSIZE m = s1->cap;\n"
		"\tUSIZE n1 = s1->size;\n"
		"\tUSIZE n2 = s2->size;\n"
		"\tif ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {\n"
		"\t\tASSERT(n2 <= SIZE_MAX);\n"
		"\t\tmemcpy(s1->data + n1, s2->data, (size_t)n2);\n"
		"\t\ts1->size += n2;\n"
		"\t\tASSERT(s1->size + 4 <= s1->cap);\n"
		"\t\tdecref(MKSTR(s2));\n"
		"\t\treturn s1;\n"
		"\t} else {\n"
		"\t\tUSIZE m2 = n1 + n2 + 4;\n"
		"\t\tif ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;\n"
		"\t\tSTR* str = str_alloc(m2);\n"
		"\t\tstr->size = n1+n2;\n"
		"\t\tASSERT(n1 <= SIZE_MAX);\n"
		"\t\tASSERT(n2 <= SIZE_MAX);\n"
		"\t\tmemcpy(str->data, s1->data, (size_t)n1);\n"
		"\t\tmemcpy(str->data+n1, s2->data, (size_t)n2);\n"
		"\t\tdecref(MKSTR(s1));\n"
		"\t\tdecref(MKSTR(s2));\n"
		"\t\treturn str;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static USIZE get_data_tag(VAL v) {\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tASSERT(VTUPLEN(v) > 0);\n"
		"\t\treturn VU64(VTUP(v)->cells[0]);\n"
		"\t} else {\n"
		"\t\treturn VU64(v);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static USIZE get_top_data_tag(void) {\n"
		"\treturn get_data_tag(top_value());\n"
		"}\n"
		"\n"
		"static USIZE get_top_resource_data_tag(void) {\n"
		"\treturn get_data_tag(top_resource());\n"
		"}\n"
		"\n"
		"static int str_cmp(STR* s1, STR* s2) {\n"
		"\tASSERT(s1 && s2);\n"
		"\tUSIZE n1 = s1->size;\n"
		"\tUSIZE n2 = s2->size;\n"
		"\tUSIZE n = (n1 < n2 ? n1 : n2);\n"
		"\tASSERT(n < SIZE_MAX);\n"
		"\tint r = memcmp(s1->data, s2->data, (size_t)n);\n"
		"\tdecref(MKSTR(s1));\n"
		"\tdecref(MKSTR(s2));\n"
		"\tif (r) return r;\n"
		"\tif (n1 < n2) return -1;\n"
		"\tif (n1 > n2) return 1;\n"
		"\treturn 0;\n"
		"}\n"
		"\n"
		"static void run_value(VAL v) {\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tVAL h = VTUP(v)->cells[0];\n"
		"\t\tASSERT(IS_FNPTR(h));\n"
		"\t\tpush_value(v);\n"
		"\t\tVFNPTR(h)();\n"
		"\t} else {\n"
		"\t\tASSERT(IS_FNPTR(v));\n"
		"\t\tVFNPTR(v)();\n"
		"\t}\n"
		"}\n"
		"\n"
		"static int64_t i64_add (int64_t a, int64_t b) {\n"
		"\tEXPECT(((b >= 0) && (a <= INT64_MAX - b))\n"
		"\t\t|| ((b <  0) && (a >= INT64_MIN - b)),\n"
		"\t\t\"overflow during integer addition\");\n"
		"\treturn a + b;\n"
		"}\n"
		"\n"
		"static int64_t i64_sub (int64_t a, int64_t b) {\n"
		"\tEXPECT(((b >= 0) && (a >= INT64_MIN + b))\n"
		"\t\t|| ((b <  0) && (a <= INT64_MAX + b)),\n"
		"\t\t\"overflow during integer subtraction\");\n"
		"\treturn a - b;\n"
		"}\n"
		"\n"
		"static int64_t i64_mul (int64_t a, int64_t b) {\n"
		"\tEXPECT((a == 0) || (b == 0) ||\n"
		"\t\t((a > 0) && (b > 0) && (a <= INT64_MAX/b)) ||\n"
		"\t\t((a > 0) && (b < 0) && (a <= INT64_MIN/b)) ||\n"
		"\t\t((a < 0) && (b > 0) && (a >= INT64_MIN/b)) ||\n"
		"\t\t((a < 0) && (b < 0) && (a >= INT64_MAX/b)),\n"
		"\t\t\"overflow during integer multiplication\"\n"
		"\t);\n"
		"\treturn a * b;\n"
		"}\n"
		"\n"
		"static int64_t i64_div (int64_t a, int64_t b) {\n"
		"\tEXPECT(b != 0, \"divide by zero\");\n"
		"\tEXPECT(!((b == -1) && (a == INT64_MIN)), \"overflow during integer division\");\n"
		"\tint64_t r = a % b;\n"
		"\tint64_t q = a / b;\n"
		"\tif (((a < 0) ^ (b < 0)) && r) q--;\n"
		"\treturn q;\n"
		"}\n"
		"\n"
		"static int64_t i64_mod (int64_t a, int64_t b) {\n"
		"\tEXPECT(b != 0, \"divide by zero\");\n"
		"\tEXPECT(!((b == -1) && (a == INT64_MIN)), \"overflow during integer division\");\n"
		"\tint64_t r = a % b;\n"
		"\tint64_t q = a / b;\n"
		"\tif (((a < 0) ^ (b < 0)) && r) r += b;\n"
		"\treturn r;\n"
		"}\n"
		"\n"
		"static uint64_t u64_shl (uint64_t a, uint64_t b) {\n"
		"\tif (b >= 64) return 0;\n"
		"\treturn (a << b);\n"
		"}\n"
		"\n"
		"static uint64_t u64_shr (uint64_t a, uint64_t b) {\n"
		"\tif (b >= 64) return 0;\n"
		"\treturn (a >> b);\n"
		"}\n"
		"\n"
		"static STR* f32_show (float d) {\n"
		" \tchar result[DBL_DIG+32] = {0};\n"
		"\tint len = sprintf(result, \"%.*g\", DBL_DIG, d);\n"
		"\treturn str_make(result, len);\n"
		"}\n"
		"\n"
		"static STR* f64_show (double d) {\n"
		" \tchar result[DBL_DIG+32] = {0};\n"
		"\tint len = sprintf(result, \"%.*g\", DBL_DIG, d);\n"
		"\treturn str_make(result, len);\n"
		"}\n"
		"\n"
		"void int_repr(int64_t y, char** out_ptr, size_t *out_size) {\n"
		"\tstatic char c[32] = {0};\n"
		"\tmemset(c, 0, 32);\n"
		"\tchar* p = c+30;\n"
		"\tsize_t n = 0;\n"
		"\tuint64_t x;\n"
		"\tif (y < 0) {\n"
		"\t\tif (y == INT64_MIN) {\n"
		"\t\t\tx = 1+(uint64_t)INT64_MAX;\n"
		"\t\t} else {\n"
		"\t\t\tx = (uint64_t)-y;\n"
		"\t\t}\n"
		"\t} else {\n"
		"\t\tx = (uint64_t)y;\n"
		"\t}\n"
		"\tdo {\n"
		"\t\t*--p = '0' + (x % 10);\n"
		"\t\tx /= 10;\n"
		"\t\tn++;\n"
		"\t} while (x);\n"
		"\tif (y < 0) {\n"
		"\t\t*--p = '-';\n"
		"\t\tn++;\n"
		"\t}\n"
		"\t*out_ptr = p;\n"
		"\t*out_size = n;\n"
		"}\n"
		"\n"
		"void int_trace_(int64_t y, int fd) {\n"
		"\tchar* p; size_t n;\n"
		"\tint_repr(y, &p, &n);\n"
		"\twrite(fd, p, n);\n"
		"}\n"
		"\n"
		"STR* i64_show (int64_t x) {\n"
		"\tbool cache = (0 <= x) && (x <= 255);\n"
		"\tstatic STR* scache[256] = {0};\n"
		"\tif (cache && scache[x]) {\n"
		"\t\tSTR* s = scache[x];\n"
		"\t\tincref(MKSTR(s));\n"
		"\t\treturn s;\n"
		"\t} else {\n"
		"\t\tchar* p; size_t n;\n"
		"\t\tint_repr(x,&p,&n);\n"
		"\t\tSTR* s = str_make(p,n);\n"
		"\t\tif (cache) {\n"
		"\t\t\tscache[x] = s;\n"
		"\t\t\tincref(MKSTR(s));\n"
		"\t\t}\n"
		"\t\treturn s;\n"
		"\t}\n"
		"}\n"
		"\n"
		"void str_trace_(STR* str, int fd) {\n"
		"\tASSERT(str->size <= SIZE_MAX);\n"
		"\twrite(fd, \"\\\"\", 1);\n"
		"\tUSIZE i0 = 0;\n"
		"\tchar xb[4]={'\\\\','x'};\n"
		"\tUSIZE i;\n"
		"\tfor (i = 0; i < str->size; i++) {\n"
		"\t\tconst char* c = NULL; size_t n=0;\n"
		"\t\tuint8_t v=str->data[i];\n"
		"\t\tswitch(v) {\n"
		"\t\t\tcase '\\n': c=\"\\\\n\"; n=2; break;\n"
		"\t\t\tcase '\\r': c=\"\\\\r\"; n=2; break;\n"
		"\t\t\tcase '\\t': c=\"\\\\t\"; n=2; break;\n"
		"\t\t\tcase '\\\\': c=\"\\\\\\\\\"; n=2; break;\n"
		"\t\t\tcase '\\\"': c=\"\\\\\\\"\"; n=2; break;\n"
		"\t\t\tdefault:\n"
		"\t\t\t\tif (!((' ' <= v) && (v < 0x7F))) {\n"
		"\t\t\t\t\txb[2] = '0' + (v&15) + ('A'-'9'-1)*((v&15) > 9);\n"
		"\t\t\t\t\txb[3] = '0' + (v/16) + ('A'-'9'-1)*((v/16) > 9);\n"
		"\t\t\t\t\tc=xb; n=4;\n"
		"\t\t\t\t}\n"
		"\t\t}\n"
		"\t\tif ((n > 0) && (i0 < i)) {\n"
		"\t\t\twrite(fd, str->data+i0, (size_t)(i-i0));\n"
		"\t\t\ti0=i+1;\n"
		"\t\t}\n"
		"\t\twrite(fd, c, n);\n"
		"\t}\n"
		"\tif (i0 < i) write(fd, str->data+i0, (size_t)(i-i0));\n"
		"\twrite(fd, \"\\\"\", 1);\n"
		"}\n"
		"\n"
		"void value_trace_(VAL val, int fd) {\n"
		"\tif (IS_INT(val)) {\n"
		"\t\tint_trace_(VINT(val), fd);\n"
		"\t} else if (IS_STR(val)) {\n"
		"\t\tstr_trace_(VSTR(val), fd);\n"
		"\t} else if (IS_FNPTR(val)) {\n"
		"\t\twrite(fd, \"<fnptr>\", 7);\n"
		"\t} else if (IS_TUP(val)) {\n"
		"\t\tTUPLEN len = VTUPLEN(val);\n"
		"\t\tTUP* tup = VTUP(val);\n"
		"\t\tif (VTUPLEN(val) == 0) {\n"
		"\t\t\twrite(fd, \"[]\", 2);\n"
		"\t\t} else {\n"
		"\t\t\twrite(fd, \"[ \", 2);\n"
		"\t\t\tfor(TUPLEN i = 0; i < len; i++) {\n"
		"\t\t\t\tif (i > 0) write(fd, \" \", 1);\n"
		"\t\t\t\tvalue_trace_(tup->cells[i], fd);\n"
		"\t\t\t}\n"
		"\t\t\twrite(fd, \" ]\", 2);\n"
		"\t\t}\n"
		"\t} else {\n"
		"\t\tTRACE(\"value cannot be traced\");\n"
		"\t\texit(1);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void trace_stack (void) {\n"
		"\tTRACE(\"??\");\n"
		"\tfor (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {\n"
		"\t\tTRACE(\" \");\n"
		"\t\tvalue_trace_(stack[i], 2);\n"
		"\t}\n"
		"\tTRACE(\"\\n\");\n"
		"}\n"
		"\n"
		"static void trace_rstack (void) {\n"
		"\t#if MIRTH_DEBUG\n"
		"\t\tTRACE(\"call stack:\\n\");\n"
		"\t\tfor (USIZE i = fstack_counter; i --> 1;) {\n"
		"\t\t\tTRACE(\"    \");\n"
		"\t\t\tif (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {\n"
		"\t\t\t\tTRACE(fstack[i-1].atom);\n"
		"\t\t\t\tTRACE(\" -> \");\n"
		"\t\t\t}\n"
		"\t\t\tTRACE(fstack[i].word);\n"
		"\t\t\tTRACE(\" at \");\n"
		"\t\t\tTRACE(fstack[i-1].path);\n"
		"\t\t\tTRACE(\":\");\n"
		"\t\t\tint_trace_((int64_t)fstack[i-1].line, 2);\n"
		"\t\t\tTRACE(\":\");\n"
		"\t\t\tint_trace_((int64_t)fstack[i-1].col, 2);\n"
		"\t\t\tTRACE(\"\\n\");\n"
		"\t\t}\n"
		"\t#endif\n"
		"}\n"
		"\n"
		"static void do_panic(void) {\n"
		"\tif ((stack_counter > 0) && IS_STR(top_value())) {\n"
		"\t\tVAL v = pop_value();\n"
		"\t\tsize_t n = (VSTR(v)->size < 2048) ? (size_t)(VSTR(v)->size) : 2048;\n"
		"\t\twrite(2, VSTR(v)->data, n);\n"
		"\t\tTRACE(\"\\n\");\n"
		"\t} else {\n"
		"\t\tTRACE(\"panic!\\n\");\n"
		"\t}\n"
		"\ttrace_stack();\n"
		"\ttrace_rstack();\n"
		"\texit(1);\n"
		"}\n"
		"\n"
		"#if defined(MIRTH_WINDOWS)\n"
		"#define RUNNING_OS 1\n"
		"#elif defined(MIRTH_LINUX)\n"
		"#define RUNNING_OS 2\n"
		"#elif defined(MIRTH_MACOS)\n"
		"#define RUNNING_OS 3\n"
		"#else\n"
		"#define RUNNING_OS 0\n"
		"#endif\n"
		"\n"
		"#if defined(MIRTH_I386)\n"
		"#define RUNNING_ARCH 1\n"
		"#elif defined(MIRTH_AMD64)\n"
		"#define RUNNING_ARCH 2\n"
		"#elif defined(MIRTH_ARM64)\n"
		"#define RUNNING_ARCH 3\n"
		"#else\n"
		"#define RUNNING_ARCH 0\n"
		"#endif\n"
		"\n"
		"static void* ptr_alloc (uint64_t n) {\n"
		"\tEXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), \"invalid size in prim-ptr-alloc\");\n"
		"\tvoid* p = malloc((size_t)n);\n"
		"\tEXPECT(p, \"failed to allocate in prim-ptr-alloc\");\n"
		"\treturn p;\n"
		"}\n"
		"\n"
		"static void* ptr_realloc (void* p, uint64_t n) {\n"
		"\tEXPECT((n > 0) && ((uint64_t)n <= SIZE_MAX), \"invalid size in prim-ptr-realloc\");\n"
		"\tvoid* p2 = realloc(p, n);\n"
		"\tEXPECT(p2, \"failed to reallocate in prim-ptr-realloc\");\n"
		"\treturn p2;\n"
		"}\n"
		"\n"
		"static void ptr_copy (void* src, uint64_t len, void* dst) {\n"
		"\tif (len > 0) {\n"
		"\t\tEXPECT(len <= SIZE_MAX, \"invalid size in prim-ptr-copy\");\n"
		"\t\tEXPECT(src && dst, \"invalid pointer in prim-ptr-copy\");\n"
		"\t\tmemcpy(dst, src, (size_t)len);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void ptr_fill (uint8_t val, uint64_t len, void* dst) {\n"
		"\tif (len > 0) {\n"
		"\t\tEXPECT(len <= SIZE_MAX, \"invalid size in prim-ptr-fill\");\n"
		"\t\tEXPECT(dst, \"invalid pointer in prim-ptr-fill\");\n"
		"\t\tmemset(dst, (int)val, (size_t)len);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void* str_base (STR* s) {\n"
		"\tEXPECT(s && (s->refs > 1), \"invalid string for prim-str-base\");\n"
		"\ts->refs--;\n"
		"\treturn s->data;\n"
		"}\n"
		"\n"
		"static uint64_t str_size (STR* s) {\n"
		"\tEXPECT(s, \"invalid string for prim-str-size\");\n"
		"\tuint64_t n = s->size;\n"
		"\tdecref(MKSTR(s));\n"
		"\treturn n;\n"
		"}\n"
		"\n"
		"static VAL mut_get (VAL mut) {\n"
		"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
		"\tVAL v = *(VAL*)VPTR(mut);\n"
		"\tEXPECT(v.tag, \"tried to read uninitialized value\");\n"
		"\tincref(v);\n"
		"\treturn v;\n"
		"}\n"
		"\n"
		"static void mut_set (VAL newval, VAL mut) {\n"
		"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
		"\tVAL oldval = *(VAL*)VPTR(mut);\n"
		"\t*(VAL*)VPTR(mut) = newval;\n"
		"\tif (oldval.tag) {\n"
		"\t\tdecref(oldval);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static bool mut_is_set (VAL mut) {\n"
		"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
		"\tVAL val = *(VAL*)VPTR(mut);\n"
		"\treturn (val.tag != 0);\n"
		"}\n"
		"\n"
		"/* GENERATED C99 */\n",
		24240
	);
	return MKSTR(v0);
}
static VAL mw_mirth_c99_c99Z_headerZBang (VAL x1) {
	STR* v0;
	STRLIT(v0, "#define MIRTH_DEBUG ", 20);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x1));
	VAL v2 = VVAL(VTUP(v1)->cells[1]);
	incref(v2);
	int64_t v3 = VI64(VTUP(v2)->cells[2]);
	decref(v2);
	if (((bool)v3)) {
		STR* v4;
		STRLIT(v4, "1", 1);
		push_resource(v1);
		push_str(v4);
	} else {
		STR* v5;
		STRLIT(v5, "0", 1);
		push_resource(v1);
		push_str(v5);
	}
	VAL r6 = pop_resource();
	VAL v7 = pop_value();
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(v7, r6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_line(v8));
	push_resource(v9);
	VAL v10 = mw_mirth_c99_c99Z_headerZ_str();
	VAL r11 = pop_resource();
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v10, r11));
	VAL v13 = (mw_mirth_c99_ZPlusC99_line(v12));
	return v13;
}
static VAL mw_mirth_c99_c99Z_buffersZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_buffer_Buffer_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_bufferZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_bufferZBang (uint64_t x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "static char ", 12);
	push_u64(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	uint64_t v2 = pop_u64();
	VAL v3 = (VVAL(VTUP(v1)->cells[6]));
	push_u64(v2);
	mw_mirth_buffer_Buffer_cname(v3, v2);
	VAL r4 = pop_resource();
	VTUP(v1)->cells[6] = r4;
	VAL v5 = pop_value();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v5, v1));
	STR* v7;
	STRLIT(v7, "[", 1);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	uint64_t v9 = pop_u64();
	push_resource(v8);
	int64_t v10 = mw_mirth_buffer_Buffer_sizze(v9);
	STR* v11 = i64_show(v10);
	VAL r12 = pop_resource();
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), r12));
	STR* v14;
	STRLIT(v14, "] = {0};", 8);
	VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
	VAL v16 = (mw_mirth_c99_ZPlusC99_line(v15));
	return v16;
}
static VAL mw_mirth_c99_c99Z_bufferZ_callZBang (uint64_t x1, VAL x2) {
	int64_t v0 = 13LL /* C99RT_PTR */;
	VAL v1 = (VVAL(VTUP(x2)->cells[1]));
	push_u64(x1);
	lpush(&lbl_localZ_repr, MKI64(v0));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	int64_t v4 = VI64(lpop(&lbl_localZ_repr));
	VAL v5 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v4, v2));
	push_resource(v5);
	VAL v6 = (mw_mirth_c99_ZPlusC99_indent(r3));
	VAL r7 = pop_resource();
	int64_t v8 = VI64(VTUP(r7)->cells[1]);
	push_resource(r7);
	push_resource(v6);
	VAL v9 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v8);
	VAL r10 = pop_resource();
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v9, r10));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL r14 = pop_resource();
	VAL v15 = VVAL(VTUP(r14)->cells[2]);
	incref(v15);
	push_resource(r14);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v13));
	STR* v17;
	STRLIT(v17, " = ", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL r19 = pop_resource();
	VAL v20 = (VVAL(VTUP(v18)->cells[6]));
	uint64_t v21 = pop_u64();
	mw_mirth_buffer_Buffer_cname(v20, v21);
	VAL r22 = pop_resource();
	VTUP(v18)->cells[6] = r22;
	VAL v23 = pop_value();
	VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v18));
	STR* v25;
	STRLIT(v25, ";", 1);
	push_resource(r19);
	VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
	VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
	VTUP(x2)->cells[1] = v27;
	VAL r28 = pop_resource();
	VAL v29 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, r28));
	return v29;
}
static VAL mw_mirth_c99_c99Z_variablesZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_variable_Variable_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_variableZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_variableZBang (uint64_t x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "static VAL ", 11);
	push_u64(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	VAL v2 = (VVAL(VTUP(v1)->cells[6]));
	uint64_t v3 = pop_u64();
	mw_mirth_variable_Variable_cname(v2, v3);
	VAL r4 = pop_resource();
	VTUP(v1)->cells[6] = r4;
	VAL v5 = pop_value();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v5, v1));
	STR* v7;
	STRLIT(v7, " = {0};", 7);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_line(v8));
	return v9;
}
static VAL mw_mirth_c99_c99Z_variableZ_callZBang (uint64_t x1, VAL x2) {
	int64_t v0 = 13LL /* C99RT_PTR */;
	VAL v1 = (VVAL(VTUP(x2)->cells[1]));
	push_u64(x1);
	lpush(&lbl_localZ_repr, MKI64(v0));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	int64_t v4 = VI64(lpop(&lbl_localZ_repr));
	VAL v5 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v4, v2));
	push_resource(v5);
	VAL v6 = (mw_mirth_c99_ZPlusC99_indent(r3));
	VAL r7 = pop_resource();
	int64_t v8 = VI64(VTUP(r7)->cells[1]);
	push_resource(r7);
	push_resource(v6);
	VAL v9 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v8);
	VAL r10 = pop_resource();
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v9, r10));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL r14 = pop_resource();
	VAL v15 = VVAL(VTUP(r14)->cells[2]);
	incref(v15);
	push_resource(r14);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v13));
	STR* v17;
	STRLIT(v17, " = ", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL r19 = pop_resource();
	VAL v20 = (VVAL(VTUP(v18)->cells[6]));
	uint64_t v21 = pop_u64();
	mw_mirth_variable_Variable_cname(v20, v21);
	VAL r22 = pop_resource();
	VTUP(v18)->cells[6] = r22;
	VAL v23 = pop_value();
	VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v18));
	STR* v25;
	STRLIT(v25, ";", 1);
	push_resource(r19);
	VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
	VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
	VTUP(x2)->cells[1] = v27;
	VAL r28 = pop_resource();
	VAL v29 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, r28));
	return v29;
}
static VAL mw_mirth_c99_c99Z_tagZ_defsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_data_Tag_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_tagZ_defZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_tagZ_bodyZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	lpush(&lbl_tag, MKU64(x1));
	int64_t v0 = mw_mirth_data_Tag_isZ_transparentZAsk(x1);
	if (((bool)v0)) {
	} else {
		uint64_t v1 = VU64(lpop(&lbl_tag));
		lpush(&lbl_tag, MKU64(v1));
		int64_t v2 = mw_mirth_data_Tag_isZ_semiZ_transparentZAsk(v1);
		if (((bool)v2)) {
			uint64_t v3 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v3));
			VAL v4 = mw_mirth_data_Tag_labelZ_inputs(v3);
			VAL v5 = mw_std_list_List_1_ZDivL1(v4);
			switch (get_data_tag(v5)) {
				case 1LL: { // Some
					VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
					incref(v6);
					uint64_t v7 = VU64(lpop(&lbl_tag));
					VAL r8 = pop_resource();
					VAL v9 = (VVAL(VTUP(r8)->cells[1]));
					VAL v10 = (VVAL(VTUP(v9)->cells[6]));
					lpush(&lbl_label, v6);
					lpush(&lbl_tag, MKU64(v7));
					mw_mirth_data_Tag_projectZ_inputZ_label(v10, VU64(v6), v7);
					VAL r11 = pop_resource();
					VTUP(v9)->cells[6] = r11;
					VTUP(r8)->cells[1] = v9;
					VAL v12 = pop_value();
					push_resource(r8);
					VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
					switch (get_data_tag(v13)) {
						case 0LL: { // Left
							VAL v14 = mtp_std_either_Either_2_Left(v13);
							VAL r15 = pop_resource();
							mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v14, r15);
							uint64_t v16 = VU64(lpop(&lbl_label));
							VAL r17 = pop_resource();
							int64_t v18 = pop_i64();
							lpush(&lbl_label, MKU64(v16));
							mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v18, v16, r17);
							VAL r19 = pop_resource();
							uint64_t v20 = VU64(lpop(&lbl_tag));
							lpush(&lbl_ZPlusfield, r19);
							lpush(&lbl_tag, MKU64(v20));
							int64_t v21 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v20);
							if (((bool)v21)) {
								VAL v22 = (lpop(&lbl_ZPlusfield));
								VAL v23 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v22));
								VAL r24 = pop_resource();
								VAL v25 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r24, v23));
								push_resource(v25);
							} else {
								VAL v26 = (lpop(&lbl_ZPlusfield));
								VAL r27 = pop_resource();
								VAL v28 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r27, v26));
								push_resource(v28);
							}
						} break;
						case 1LL: { // Right
							VAL v29 = mtp_std_either_Either_2_Right(v13);
							VAL r30 = pop_resource();
							mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v29, r30);
							uint64_t v31 = VU64(lpop(&lbl_label));
							VAL r32 = pop_resource();
							int64_t v33 = pop_i64();
							lpush(&lbl_label, MKU64(v31));
							mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v33, v31, r32);
							VAL r34 = pop_resource();
							VAL r35 = pop_resource();
							VAL v36 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r35, r34));
							push_resource(v36);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
					uint64_t v37 = VU64(lpop(&lbl_label));
				} break;
				case 0LL: { // None
					uint64_t v38 = VU64(lpop(&lbl_tag));
					VAL r39 = pop_resource();
					VAL v40 = (VVAL(VTUP(r39)->cells[1]));
					VAL v41 = (VVAL(VTUP(v40)->cells[6]));
					lpush(&lbl_tag, MKU64(v38));
					mw_mirth_data_Tag_type(v41, v38);
					VAL r42 = pop_resource();
					VTUP(v40)->cells[6] = r42;
					VTUP(r39)->cells[1] = v40;
					VAL v43 = pop_value();
					push_resource(r39);
					VAL v44 = mw_mirth_type_ArrowType_dom(v43);
					VAL v45 = mw_mirth_type_StackType_topZ_typeZAsk(v44);
					VAL v46 = mw_std_maybe_Maybe_1_unwrap(v45);
					VAL r47 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v46, r47);
					int64_t v48 = pop_i64();
					VAL r49 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r49, v48);
					VAL r50 = pop_resource();
					VAL v51 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(r50));
					VAL r52 = pop_resource();
					VAL v53 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r52, v51));
					push_resource(v53);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} else {
			uint64_t v54 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v54));
			int64_t v55 = mw_mirth_data_Tag_numZ_totalZ_inputs(v54);
			int64_t v56 = 0LL;
			bool v57 = (v55 == v56);
			if (v57) {
				uint64_t v58 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v58));
				int64_t v59 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v58);
				if (((bool)v59)) {
					int64_t v60 = 2LL /* C99RT_I64 */;
					VAL r61 = pop_resource();
					VAL v62 = (VVAL(VTUP(r61)->cells[1]));
					lpush(&lbl_localZ_resourceZ_repr, MKI64(v60));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v62);
					VAL v63 = pop_value();
					VAL r64 = pop_resource();
					int64_t v65 = VI64(lpop(&lbl_localZ_resourceZ_repr));
					VAL v66 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v65, v63));
					push_resource(v66);
					VAL v67 = (mw_mirth_c99_ZPlusC99_indent(r64));
					VAL r68 = pop_resource();
					int64_t v69 = VI64(VTUP(r68)->cells[1]);
					push_resource(r68);
					push_resource(v67);
					VAL v70 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v69);
					VAL r71 = pop_resource();
					VAL v72 = (mw_mirth_c99_ZPlusC99_put(v70, r71));
					STR* v73;
					STRLIT(v73, " ", 1);
					VAL v74 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v73), v72));
					VAL r75 = pop_resource();
					VAL v76 = VVAL(VTUP(r75)->cells[2]);
					incref(v76);
					push_resource(r75);
					VAL v77 = (mw_mirth_c99_ZPlusC99_put(v76, v74));
					STR* v78;
					STRLIT(v78, " = (", 4);
					VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
					VAL r80 = pop_resource();
					uint64_t v81 = VU64(lpop(&lbl_tag));
					push_resource(v79);
					lpush(&lbl_tag, MKU64(v81));
					VAL v82 = mw_mirth_data_Tag_valueZ_show(v81);
					VAL r83 = pop_resource();
					VAL v84 = (mw_mirth_c99_ZPlusC99_put(v82, r83));
					STR* v85;
					STRLIT(v85, "LL /* ", 6);
					VAL v86 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v85), v84));
					uint64_t v87 = VU64(lpop(&lbl_tag));
					push_resource(v86);
					lpush(&lbl_tag, MKU64(v87));
					uint64_t v88 = mw_mirth_data_Tag_name(v87);
					VAL v89 = mw_mirth_name_Name_ZToStr(v88);
					VAL r90 = pop_resource();
					VAL v91 = (mw_mirth_c99_ZPlusC99_put(v89, r90));
					STR* v92;
					STRLIT(v92, " */", 3);
					VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
					STR* v94;
					STRLIT(v94, ");", 2);
					push_resource(r80);
					VAL v95 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v94), v93));
					VAL v96 = (mw_mirth_c99_ZPlusC99_line(v95));
					VTUP(r61)->cells[1] = v96;
					VAL r97 = pop_resource();
					VAL v98 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r61, r97));
					push_resource(v98);
				} else {
					int64_t v99 = 2LL /* C99RT_I64 */;
					VAL r100 = pop_resource();
					VAL v101 = (VVAL(VTUP(r100)->cells[1]));
					lpush(&lbl_localZ_repr, MKI64(v99));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v101);
					VAL v102 = pop_value();
					VAL r103 = pop_resource();
					int64_t v104 = VI64(lpop(&lbl_localZ_repr));
					VAL v105 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v104, v102));
					push_resource(v105);
					VAL v106 = (mw_mirth_c99_ZPlusC99_indent(r103));
					VAL r107 = pop_resource();
					int64_t v108 = VI64(VTUP(r107)->cells[1]);
					push_resource(r107);
					push_resource(v106);
					VAL v109 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v108);
					VAL r110 = pop_resource();
					VAL v111 = (mw_mirth_c99_ZPlusC99_put(v109, r110));
					STR* v112;
					STRLIT(v112, " ", 1);
					VAL v113 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v112), v111));
					VAL r114 = pop_resource();
					VAL v115 = VVAL(VTUP(r114)->cells[2]);
					incref(v115);
					push_resource(r114);
					VAL v116 = (mw_mirth_c99_ZPlusC99_put(v115, v113));
					STR* v117;
					STRLIT(v117, " = ", 3);
					VAL v118 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v117), v116));
					VAL r119 = pop_resource();
					uint64_t v120 = VU64(lpop(&lbl_tag));
					push_resource(v118);
					lpush(&lbl_tag, MKU64(v120));
					VAL v121 = mw_mirth_data_Tag_valueZ_show(v120);
					VAL r122 = pop_resource();
					VAL v123 = (mw_mirth_c99_ZPlusC99_put(v121, r122));
					STR* v124;
					STRLIT(v124, "LL /* ", 6);
					VAL v125 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v124), v123));
					uint64_t v126 = VU64(lpop(&lbl_tag));
					push_resource(v125);
					lpush(&lbl_tag, MKU64(v126));
					uint64_t v127 = mw_mirth_data_Tag_name(v126);
					VAL v128 = mw_mirth_name_Name_ZToStr(v127);
					VAL r129 = pop_resource();
					VAL v130 = (mw_mirth_c99_ZPlusC99_put(v128, r129));
					STR* v131;
					STRLIT(v131, " */", 3);
					VAL v132 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v131), v130));
					STR* v133;
					STRLIT(v133, ";", 1);
					push_resource(r119);
					VAL v134 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v133), v132));
					VAL v135 = (mw_mirth_c99_ZPlusC99_line(v134));
					VTUP(r100)->cells[1] = v135;
					VAL r136 = pop_resource();
					VAL v137 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r100, r136));
					push_resource(v137);
				}
			} else {
				VAL r138 = pop_resource();
				VAL v139 = (VVAL(VTUP(r138)->cells[1]));
				VAL v140 = (mw_mirth_c99_ZPlusC99_indent(v139));
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v140);
				VAL v141 = pop_value();
				STR* v142;
				STRLIT(v142, "TUP* ", 5);
				VAL r143 = pop_resource();
				lpush(&lbl_tup, v141);
				VAL v144 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v142), r143));
				VAL v145 = lpop(&lbl_tup);
				incref(v145);
				lpush(&lbl_tup, v145);
				VAL v146 = (mw_mirth_c99_ZPlusC99_put(v145, v144));
				STR* v147;
				STRLIT(v147, " = tup_new(", 11);
				VAL v148 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v147), v146));
				uint64_t v149 = VU64(lpop(&lbl_tag));
				push_resource(v148);
				lpush(&lbl_tag, MKU64(v149));
				int64_t v150 = mw_mirth_data_Tag_numZ_totalZ_inputs(v149);
				int64_t v151 = 1LL;
				int64_t v152 = i64_add(v150, v151);
				STR* v153 = i64_show(v152);
				VAL r154 = pop_resource();
				VAL v155 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v153), r154));
				STR* v156;
				STRLIT(v156, ");", 2);
				VAL v157 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v156), v155));
				VAL v158 = (mw_mirth_c99_ZPlusC99_line(v157));
				VTUP(r138)->cells[1] = v158;
				VAL v159 = (VVAL(VTUP(r138)->cells[1]));
				VAL v160 = (mw_mirth_c99_ZPlusC99_indent(v159));
				VAL v161 = lpop(&lbl_tup);
				incref(v161);
				lpush(&lbl_tup, v161);
				VAL v162 = (mw_mirth_c99_ZPlusC99_put(v161, v160));
				STR* v163;
				STRLIT(v163, "->size = ", 9);
				VAL v164 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v163), v162));
				uint64_t v165 = VU64(lpop(&lbl_tag));
				push_resource(v164);
				lpush(&lbl_tag, MKU64(v165));
				int64_t v166 = mw_mirth_data_Tag_numZ_totalZ_inputs(v165);
				int64_t v167 = 1LL;
				int64_t v168 = i64_add(v166, v167);
				STR* v169 = i64_show(v168);
				VAL r170 = pop_resource();
				VAL v171 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v169), r170));
				STR* v172;
				STRLIT(v172, ";", 1);
				VAL v173 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v172), v171));
				VAL v174 = (mw_mirth_c99_ZPlusC99_line(v173));
				VTUP(r138)->cells[1] = v174;
				VAL v175 = (VVAL(VTUP(r138)->cells[1]));
				VAL v176 = (mw_mirth_c99_ZPlusC99_indent(v175));
				VAL v177 = lpop(&lbl_tup);
				incref(v177);
				lpush(&lbl_tup, v177);
				VAL v178 = (mw_mirth_c99_ZPlusC99_put(v177, v176));
				STR* v179;
				STRLIT(v179, "->cells[0] = MKI64(", 19);
				VAL v180 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v179), v178));
				uint64_t v181 = VU64(lpop(&lbl_tag));
				push_resource(v180);
				lpush(&lbl_tag, MKU64(v181));
				VAL v182 = mw_mirth_data_Tag_valueZ_show(v181);
				VAL r183 = pop_resource();
				VAL v184 = (mw_mirth_c99_ZPlusC99_put(v182, r183));
				STR* v185;
				STRLIT(v185, "LL /* ", 6);
				VAL v186 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v185), v184));
				uint64_t v187 = VU64(lpop(&lbl_tag));
				push_resource(v186);
				lpush(&lbl_tag, MKU64(v187));
				uint64_t v188 = mw_mirth_data_Tag_name(v187);
				VAL v189 = mw_mirth_name_Name_ZToStr(v188);
				VAL r190 = pop_resource();
				VAL v191 = (mw_mirth_c99_ZPlusC99_put(v189, r190));
				STR* v192;
				STRLIT(v192, " */);", 5);
				VAL v193 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v192), v191));
				VAL v194 = (mw_mirth_c99_ZPlusC99_line(v193));
				VTUP(r138)->cells[1] = v194;
				uint64_t v195 = VU64(lpop(&lbl_tag));
				push_resource(r138);
				lpush(&lbl_tag, MKU64(v195));
				int64_t v196 = mw_mirth_data_Tag_numZ_totalZ_inputs(v195);
				uint64_t v197 = VU64(lpop(&lbl_tag));
				lpush(&lbl_i, MKI64(v196));
				lpush(&lbl_tag, MKU64(v197));
				VAL v198 = mw_mirth_data_Tag_labelZ_inputs(v197);
				VAL v199 = mw_std_list_List_1_reverse(v198);
				mw_std_list_List_1_uncons(v199);
				VAL v200 = pop_value();
				VAL v201 = pop_value();
				push_value(v200);
				push_value(v201);
				while(1) {
					VAL v202 = pop_value();
					incref(v202);
					push_value(v202);
					int64_t v203 = mw_std_maybe_Maybe_1_someZAsk(v202);
					if (!((bool)v203)) break;
					VAL v204 = pop_value();
					VAL v205 = mw_std_maybe_Maybe_1_unwrap(v204);
					VAL v206 = pop_value();
					incref(v205);
					lpush(&lbl_label, v205);
					int64_t v207 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(VU64(v205));
					if (((bool)v207)) {
						int64_t v208 = 0LL /* C99RT_VAL */;
						uint64_t v209 = VU64(lpop(&lbl_label));
						VAL r210 = pop_resource();
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v208, v209, r210);
						VAL r211 = pop_resource();
						VAL v212 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(r211);
						push_value(v212);
					} else {
						int64_t v213 = 0LL /* C99RT_VAL */;
						uint64_t v214 = VU64(lpop(&lbl_label));
						VAL r215 = pop_resource();
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v213, v214, r215);
						VAL r216 = pop_resource();
						VAL v217 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r216);
						push_value(v217);
					}
					VAL r218 = pop_resource();
					VAL v219 = (VVAL(VTUP(r218)->cells[1]));
					VAL v220 = (mw_mirth_c99_ZPlusC99_indent(v219));
					VAL v221 = lpop(&lbl_tup);
					incref(v221);
					lpush(&lbl_tup, v221);
					VAL v222 = (mw_mirth_c99_ZPlusC99_put(v221, v220));
					STR* v223;
					STRLIT(v223, "->cells[", 8);
					VAL v224 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v223), v222));
					int64_t v225 = VI64(lpop(&lbl_i));
					STR* v226 = i64_show(v225);
					lpush(&lbl_i, MKI64(v225));
					VAL v227 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v226), v224));
					STR* v228;
					STRLIT(v228, "] = ", 4);
					VAL v229 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v228), v227));
					VAL v230 = pop_value();
					VAL v231 = (mw_mirth_c99_ZPlusC99_put(v230, v229));
					STR* v232;
					STRLIT(v232, ";", 1);
					VAL v233 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v232), v231));
					VAL v234 = (mw_mirth_c99_ZPlusC99_line(v233));
					VTUP(r218)->cells[1] = v234;
					int64_t v235 = VI64(lpop(&lbl_i));
					int64_t v236 = 1LL;
					int64_t v237 = i64_sub(v235, v236);
					push_resource(r218);
					int64_t v238 = mw_std_prim_Int_ZToNat(v237);
					lpush(&lbl_i, MKI64(v238));
					mw_std_list_List_1_uncons(v206);
					VAL v239 = pop_value();
					VAL v240 = pop_value();
					push_value(v239);
					push_value(v240);
				}
				VAL v241 = pop_value();
				decref(v241);
				VAL v242 = pop_value();
				decref(v242);
				uint64_t v243 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v243));
				int64_t v244 = mw_mirth_data_Tag_numZ_resourceZ_inputs(v243);
				push_i64(v244);
				while(1) {
					int64_t v245 = pop_i64();
					int64_t v246 = 0LL;
					bool v247 = (v245 > v246);
					push_i64(v245);
					if (!v247) break;
					int64_t v248 = pop_i64();
					int64_t v249 = 0LL /* C99RT_VAL */;
					VAL r250 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r250, v249);
					VAL r251 = pop_resource();
					VAL v252 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(r251);
					VAL r253 = pop_resource();
					VAL v254 = (VVAL(VTUP(r253)->cells[1]));
					push_value(v252);
					VAL v255 = (mw_mirth_c99_ZPlusC99_indent(v254));
					VAL v256 = lpop(&lbl_tup);
					incref(v256);
					lpush(&lbl_tup, v256);
					VAL v257 = (mw_mirth_c99_ZPlusC99_put(v256, v255));
					STR* v258;
					STRLIT(v258, "->cells[", 8);
					VAL v259 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v258), v257));
					int64_t v260 = VI64(lpop(&lbl_i));
					STR* v261 = i64_show(v260);
					lpush(&lbl_i, MKI64(v260));
					VAL v262 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v261), v259));
					STR* v263;
					STRLIT(v263, "] = ", 4);
					VAL v264 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v263), v262));
					VAL v265 = pop_value();
					VAL v266 = (mw_mirth_c99_ZPlusC99_put(v265, v264));
					STR* v267;
					STRLIT(v267, ";", 1);
					VAL v268 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v267), v266));
					VAL v269 = (mw_mirth_c99_ZPlusC99_line(v268));
					VTUP(r253)->cells[1] = v269;
					int64_t v270 = VI64(lpop(&lbl_i));
					int64_t v271 = 1LL;
					int64_t v272 = i64_sub(v270, v271);
					push_resource(r253);
					int64_t v273 = mw_std_prim_Int_ZToNat(v272);
					int64_t v274 = 1LL;
					int64_t v275 = i64_sub(v248, v274);
					lpush(&lbl_i, MKI64(v273));
					int64_t v276 = mw_std_prim_Int_ZToNat(v275);
					push_i64(v276);
				}
				int64_t v277 = pop_i64();
				uint64_t v278 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v278));
				int64_t v279 = mw_mirth_data_Tag_numZ_typeZ_inputs(v278);
				push_i64(v279);
				while(1) {
					int64_t v280 = pop_i64();
					int64_t v281 = 0LL;
					bool v282 = (v280 > v281);
					push_i64(v280);
					if (!v282) break;
					int64_t v283 = pop_i64();
					int64_t v284 = 0LL /* C99RT_VAL */;
					VAL r285 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r285, v284);
					VAL r286 = pop_resource();
					VAL v287 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r286);
					VAL r288 = pop_resource();
					VAL v289 = (VVAL(VTUP(r288)->cells[1]));
					push_value(v287);
					VAL v290 = (mw_mirth_c99_ZPlusC99_indent(v289));
					VAL v291 = lpop(&lbl_tup);
					incref(v291);
					lpush(&lbl_tup, v291);
					VAL v292 = (mw_mirth_c99_ZPlusC99_put(v291, v290));
					STR* v293;
					STRLIT(v293, "->cells[", 8);
					VAL v294 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v293), v292));
					int64_t v295 = VI64(lpop(&lbl_i));
					STR* v296 = i64_show(v295);
					lpush(&lbl_i, MKI64(v295));
					VAL v297 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v296), v294));
					STR* v298;
					STRLIT(v298, "] = ", 4);
					VAL v299 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v298), v297));
					VAL v300 = pop_value();
					VAL v301 = (mw_mirth_c99_ZPlusC99_put(v300, v299));
					STR* v302;
					STRLIT(v302, ";", 1);
					VAL v303 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v302), v301));
					VAL v304 = (mw_mirth_c99_ZPlusC99_line(v303));
					VTUP(r288)->cells[1] = v304;
					int64_t v305 = VI64(lpop(&lbl_i));
					int64_t v306 = 1LL;
					int64_t v307 = i64_sub(v305, v306);
					push_resource(r288);
					int64_t v308 = mw_std_prim_Int_ZToNat(v307);
					int64_t v309 = 1LL;
					int64_t v310 = i64_sub(v283, v309);
					lpush(&lbl_i, MKI64(v308));
					int64_t v311 = mw_std_prim_Int_ZToNat(v310);
					push_i64(v311);
				}
				int64_t v312 = pop_i64();
				int64_t v313 = VI64(lpop(&lbl_i));
				uint64_t v314 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v314));
				int64_t v315 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v314);
				if (((bool)v315)) {
					int64_t v316 = 0LL /* C99RT_VAL */;
					VAL r317 = pop_resource();
					VAL v318 = (VVAL(VTUP(r317)->cells[1]));
					lpush(&lbl_localZ_resourceZ_repr, MKI64(v316));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v318);
					VAL v319 = pop_value();
					VAL r320 = pop_resource();
					int64_t v321 = VI64(lpop(&lbl_localZ_resourceZ_repr));
					VAL v322 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v321, v319));
					push_resource(v322);
					VAL v323 = (mw_mirth_c99_ZPlusC99_indent(r320));
					VAL r324 = pop_resource();
					int64_t v325 = VI64(VTUP(r324)->cells[1]);
					push_resource(r324);
					push_resource(v323);
					VAL v326 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v325);
					VAL r327 = pop_resource();
					VAL v328 = (mw_mirth_c99_ZPlusC99_put(v326, r327));
					STR* v329;
					STRLIT(v329, " ", 1);
					VAL v330 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v329), v328));
					VAL r331 = pop_resource();
					VAL v332 = VVAL(VTUP(r331)->cells[2]);
					incref(v332);
					push_resource(r331);
					VAL v333 = (mw_mirth_c99_ZPlusC99_put(v332, v330));
					STR* v334;
					STRLIT(v334, " = (", 4);
					VAL v335 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v334), v333));
					VAL r336 = pop_resource();
					STR* v337;
					STRLIT(v337, "MKTUP(", 6);
					VAL v338 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v337), v335));
					VAL v339 = lpop(&lbl_tup);
					VAL v340 = (mw_mirth_c99_ZPlusC99_put(v339, v338));
					STR* v341;
					STRLIT(v341, ", ", 2);
					VAL v342 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v341), v340));
					uint64_t v343 = VU64(lpop(&lbl_tag));
					push_resource(v342);
					lpush(&lbl_tag, MKU64(v343));
					int64_t v344 = mw_mirth_data_Tag_numZ_totalZ_inputs(v343);
					int64_t v345 = 1LL;
					int64_t v346 = i64_add(v344, v345);
					STR* v347 = i64_show(v346);
					VAL r348 = pop_resource();
					VAL v349 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v347), r348));
					STR* v350;
					STRLIT(v350, ")", 1);
					VAL v351 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v350), v349));
					STR* v352;
					STRLIT(v352, ");", 2);
					push_resource(r336);
					VAL v353 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v352), v351));
					VAL v354 = (mw_mirth_c99_ZPlusC99_line(v353));
					VTUP(r317)->cells[1] = v354;
					VAL r355 = pop_resource();
					VAL v356 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r317, r355));
					push_resource(v356);
				} else {
					int64_t v357 = 0LL /* C99RT_VAL */;
					VAL r358 = pop_resource();
					VAL v359 = (VVAL(VTUP(r358)->cells[1]));
					lpush(&lbl_localZ_repr, MKI64(v357));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v359);
					VAL v360 = pop_value();
					VAL r361 = pop_resource();
					int64_t v362 = VI64(lpop(&lbl_localZ_repr));
					VAL v363 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v362, v360));
					push_resource(v363);
					VAL v364 = (mw_mirth_c99_ZPlusC99_indent(r361));
					VAL r365 = pop_resource();
					int64_t v366 = VI64(VTUP(r365)->cells[1]);
					push_resource(r365);
					push_resource(v364);
					VAL v367 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v366);
					VAL r368 = pop_resource();
					VAL v369 = (mw_mirth_c99_ZPlusC99_put(v367, r368));
					STR* v370;
					STRLIT(v370, " ", 1);
					VAL v371 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v370), v369));
					VAL r372 = pop_resource();
					VAL v373 = VVAL(VTUP(r372)->cells[2]);
					incref(v373);
					push_resource(r372);
					VAL v374 = (mw_mirth_c99_ZPlusC99_put(v373, v371));
					STR* v375;
					STRLIT(v375, " = ", 3);
					VAL v376 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v375), v374));
					VAL r377 = pop_resource();
					STR* v378;
					STRLIT(v378, "MKTUP(", 6);
					VAL v379 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v378), v376));
					VAL v380 = lpop(&lbl_tup);
					VAL v381 = (mw_mirth_c99_ZPlusC99_put(v380, v379));
					STR* v382;
					STRLIT(v382, ", ", 2);
					VAL v383 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v382), v381));
					uint64_t v384 = VU64(lpop(&lbl_tag));
					push_resource(v383);
					lpush(&lbl_tag, MKU64(v384));
					int64_t v385 = mw_mirth_data_Tag_numZ_totalZ_inputs(v384);
					int64_t v386 = 1LL;
					int64_t v387 = i64_add(v385, v386);
					STR* v388 = i64_show(v387);
					VAL r389 = pop_resource();
					VAL v390 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v388), r389));
					STR* v391;
					STRLIT(v391, ")", 1);
					VAL v392 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v391), v390));
					STR* v393;
					STRLIT(v393, ";", 1);
					push_resource(r377);
					VAL v394 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v393), v392));
					VAL v395 = (mw_mirth_c99_ZPlusC99_line(v394));
					VTUP(r358)->cells[1] = v395;
					VAL r396 = pop_resource();
					VAL v397 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r358, r396));
					push_resource(v397);
				}
			}
		}
	}
	uint64_t v398 = VU64(lpop(&lbl_tag));
	VAL r399 = pop_resource();
	return r399;
}
static VAL mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	lpush(&lbl_tag, MKU64(x1));
	int64_t v0 = mw_mirth_data_Tag_isZ_transparentZAsk(x1);
	if (((bool)v0)) {
	} else {
		uint64_t v1 = VU64(lpop(&lbl_tag));
		lpush(&lbl_tag, MKU64(v1));
		int64_t v2 = mw_mirth_data_Tag_isZ_semiZ_transparentZAsk(v1);
		if (((bool)v2)) {
			uint64_t v3 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v3));
			VAL v4 = mw_mirth_data_Tag_labelZ_inputs(v3);
			VAL v5 = mw_std_list_List_1_ZDivL1(v4);
			switch (get_data_tag(v5)) {
				case 1LL: { // Some
					VAL v6 = mtp_std_maybe_Maybe_1_Some(v5);
					incref(v6);
					uint64_t v7 = VU64(lpop(&lbl_tag));
					VAL r8 = pop_resource();
					VAL v9 = (VVAL(VTUP(r8)->cells[1]));
					VAL v10 = (VVAL(VTUP(v9)->cells[6]));
					lpush(&lbl_label, v6);
					lpush(&lbl_tag, MKU64(v7));
					mw_mirth_data_Tag_projectZ_inputZ_label(v10, VU64(v6), v7);
					VAL r11 = pop_resource();
					VTUP(v9)->cells[6] = r11;
					VTUP(r8)->cells[1] = v9;
					VAL v12 = pop_value();
					push_resource(r8);
					VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
					switch (get_data_tag(v13)) {
						case 0LL: { // Left
							VAL v14 = mtp_std_either_Either_2_Left(v13);
							VAL r15 = pop_resource();
							mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v14, r15);
							uint64_t v16 = VU64(lpop(&lbl_tag));
							lpush(&lbl_tag, MKU64(v16));
							int64_t v17 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v16);
							if (((bool)v17)) {
								int64_t v18 = pop_i64();
								VAL r19 = pop_resource();
								mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r19, v18);
								VAL r20 = pop_resource();
								VAL v21 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(r20));
								push_resource(v21);
							} else {
								int64_t v22 = pop_i64();
								VAL r23 = pop_resource();
								mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r23, v22);
							}
							uint64_t v24 = VU64(lpop(&lbl_label));
							VAL r25 = pop_resource();
							VAL r26 = pop_resource();
							VAL v27 = (mw_mirth_c99_pushZ_localZ_labelZBang(v24, r26, r25));
							push_resource(v27);
						} break;
						case 1LL: { // Right
							VAL v28 = mtp_std_either_Either_2_Right(v13);
							VAL r29 = pop_resource();
							mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v28, r29);
							int64_t v30 = pop_i64();
							VAL r31 = pop_resource();
							mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r31, v30);
							uint64_t v32 = VU64(lpop(&lbl_label));
							VAL r33 = pop_resource();
							VAL r34 = pop_resource();
							VAL v35 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v32, r34, r33));
							push_resource(v35);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
						}
					}
				} break;
				case 0LL: { // None
					uint64_t v36 = VU64(lpop(&lbl_tag));
					VAL r37 = pop_resource();
					VAL v38 = (VVAL(VTUP(r37)->cells[1]));
					VAL v39 = (VVAL(VTUP(v38)->cells[6]));
					lpush(&lbl_tag, MKU64(v36));
					mw_mirth_data_Tag_type(v39, v36);
					VAL r40 = pop_resource();
					VTUP(v38)->cells[6] = r40;
					VTUP(r37)->cells[1] = v38;
					VAL v41 = pop_value();
					push_resource(r37);
					VAL v42 = mw_mirth_type_ArrowType_dom(v41);
					VAL v43 = mw_mirth_type_StackType_topZ_typeZAsk(v42);
					VAL v44 = mw_std_maybe_Maybe_1_unwrap(v43);
					VAL r45 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v44, r45);
					int64_t v46 = pop_i64();
					VAL r47 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r47, v46);
					VAL r48 = pop_resource();
					VAL v49 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(r48));
					VAL r50 = pop_resource();
					VAL v51 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r50, v49));
					push_resource(v51);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} else {
			uint64_t v52 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v52));
			int64_t v53 = mw_mirth_data_Tag_numZ_totalZ_inputs(v52);
			int64_t v54 = 0LL;
			bool v55 = (v53 == v54);
			if (v55) {
				uint64_t v56 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v56));
				uint64_t v57 = mw_mirth_data_Tag_data(v56);
				VAL r58 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v57, r58);
				VAL r59 = pop_resource();
				mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop(r59);
			} else {
				uint64_t v60 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v60));
				uint64_t v61 = mw_mirth_data_Tag_data(v60);
				VAL r62 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v61, r62);
				VAL r63 = pop_resource();
				VAL v64 = mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL(r63);
				STR* v65;
				STRLIT(v65, "", 0);
				STR* v66;
				STRLIT(v66, "VTUP(", 5);
				push_value(v64);
				VAL v67 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v66), MKSTR(v65)));
				VAL v68 = pop_value();
				VAL v69 = (mw_std_str_ZPlusStr_pushZ_strZBang(v68, v67));
				STR* v70;
				STRLIT(v70, ")", 1);
				VAL v71 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v70), v69));
				int64_t v72 = 1LL;
				uint64_t v73 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tup, v71);
				lpush(&lbl_i, MKI64(v72));
				lpush(&lbl_tag, MKU64(v73));
				int64_t v74 = mw_mirth_data_Tag_numZ_typeZ_inputs(v73);
				push_i64(v74);
				while(1) {
					int64_t v75 = pop_i64();
					int64_t v76 = 0LL;
					bool v77 = (v75 > v76);
					push_i64(v75);
					if (!v77) break;
					int64_t v78 = pop_i64();
					int64_t v79 = 0LL /* C99RT_VAL */;
					VAL r80 = pop_resource();
					VAL v81 = (VVAL(VTUP(r80)->cells[1]));
					lpush(&lbl_localZ_repr, MKI64(v79));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v81);
					VAL v82 = pop_value();
					VAL r83 = pop_resource();
					int64_t v84 = VI64(lpop(&lbl_localZ_repr));
					VAL v85 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v84, v82));
					push_resource(v85);
					VAL v86 = (mw_mirth_c99_ZPlusC99_indent(r83));
					VAL r87 = pop_resource();
					int64_t v88 = VI64(VTUP(r87)->cells[1]);
					push_resource(r87);
					push_resource(v86);
					VAL v89 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v88);
					VAL r90 = pop_resource();
					VAL v91 = (mw_mirth_c99_ZPlusC99_put(v89, r90));
					STR* v92;
					STRLIT(v92, " ", 1);
					VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
					VAL r94 = pop_resource();
					VAL v95 = VVAL(VTUP(r94)->cells[2]);
					incref(v95);
					push_resource(r94);
					VAL v96 = (mw_mirth_c99_ZPlusC99_put(v95, v93));
					STR* v97;
					STRLIT(v97, " = ", 3);
					VAL v98 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v97), v96));
					VAL r99 = pop_resource();
					VAL v100 = lpop(&lbl_tup);
					incref(v100);
					lpush(&lbl_tup, v100);
					VAL v101 = (mw_mirth_c99_ZPlusC99_put(v100, v98));
					STR* v102;
					STRLIT(v102, "->cells[", 8);
					VAL v103 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v102), v101));
					int64_t v104 = VI64(lpop(&lbl_i));
					STR* v105 = i64_show(v104);
					lpush(&lbl_i, MKI64(v104));
					VAL v106 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v105), v103));
					STR* v107;
					STRLIT(v107, "]", 1);
					VAL v108 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v107), v106));
					STR* v109;
					STRLIT(v109, ";", 1);
					push_resource(r99);
					VAL v110 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v109), v108));
					VAL v111 = (mw_mirth_c99_ZPlusC99_line(v110));
					VTUP(r80)->cells[1] = v111;
					VAL r112 = pop_resource();
					VAL v113 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r80, r112));
					int64_t v114 = VI64(lpop(&lbl_i));
					int64_t v115 = 1LL;
					int64_t v116 = i64_add(v114, v115);
					int64_t v117 = 1LL;
					int64_t v118 = i64_sub(v78, v117);
					push_resource(v113);
					lpush(&lbl_i, MKI64(v116));
					int64_t v119 = mw_std_prim_Int_ZToNat(v118);
					push_i64(v119);
				}
				int64_t v120 = pop_i64();
				uint64_t v121 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v121));
				int64_t v122 = mw_mirth_data_Tag_numZ_resourceZ_inputs(v121);
				push_i64(v122);
				while(1) {
					int64_t v123 = pop_i64();
					int64_t v124 = 0LL;
					bool v125 = (v123 > v124);
					push_i64(v123);
					if (!v125) break;
					int64_t v126 = pop_i64();
					int64_t v127 = 0LL /* C99RT_VAL */;
					VAL r128 = pop_resource();
					VAL v129 = (VVAL(VTUP(r128)->cells[1]));
					lpush(&lbl_localZ_resourceZ_repr, MKI64(v127));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v129);
					VAL v130 = pop_value();
					VAL r131 = pop_resource();
					int64_t v132 = VI64(lpop(&lbl_localZ_resourceZ_repr));
					VAL v133 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v132, v130));
					push_resource(v133);
					VAL v134 = (mw_mirth_c99_ZPlusC99_indent(r131));
					VAL r135 = pop_resource();
					int64_t v136 = VI64(VTUP(r135)->cells[1]);
					push_resource(r135);
					push_resource(v134);
					VAL v137 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v136);
					VAL r138 = pop_resource();
					VAL v139 = (mw_mirth_c99_ZPlusC99_put(v137, r138));
					STR* v140;
					STRLIT(v140, " ", 1);
					VAL v141 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v140), v139));
					VAL r142 = pop_resource();
					VAL v143 = VVAL(VTUP(r142)->cells[2]);
					incref(v143);
					push_resource(r142);
					VAL v144 = (mw_mirth_c99_ZPlusC99_put(v143, v141));
					STR* v145;
					STRLIT(v145, " = (", 4);
					VAL v146 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v145), v144));
					VAL r147 = pop_resource();
					VAL v148 = lpop(&lbl_tup);
					incref(v148);
					lpush(&lbl_tup, v148);
					VAL v149 = (mw_mirth_c99_ZPlusC99_put(v148, v146));
					STR* v150;
					STRLIT(v150, "->cells[", 8);
					VAL v151 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v150), v149));
					int64_t v152 = VI64(lpop(&lbl_i));
					STR* v153 = i64_show(v152);
					lpush(&lbl_i, MKI64(v152));
					VAL v154 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v153), v151));
					STR* v155;
					STRLIT(v155, "]", 1);
					VAL v156 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v155), v154));
					STR* v157;
					STRLIT(v157, ");", 2);
					push_resource(r147);
					VAL v158 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v157), v156));
					VAL v159 = (mw_mirth_c99_ZPlusC99_line(v158));
					VTUP(r128)->cells[1] = v159;
					VAL r160 = pop_resource();
					VAL v161 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r128, r160));
					int64_t v162 = VI64(lpop(&lbl_i));
					int64_t v163 = 1LL;
					int64_t v164 = i64_add(v162, v163);
					int64_t v165 = 1LL;
					int64_t v166 = i64_sub(v126, v165);
					push_resource(v161);
					lpush(&lbl_i, MKI64(v164));
					int64_t v167 = mw_std_prim_Int_ZToNat(v166);
					push_i64(v167);
				}
				int64_t v168 = pop_i64();
				uint64_t v169 = VU64(lpop(&lbl_tag));
				lpush(&lbl_tag, MKU64(v169));
				VAL v170 = mw_mirth_data_Tag_labelZ_inputs(v169);
				mw_std_list_List_1_uncons(v170);
				VAL v171 = pop_value();
				VAL v172 = pop_value();
				push_value(v171);
				push_value(v172);
				while(1) {
					VAL v173 = pop_value();
					incref(v173);
					push_value(v173);
					int64_t v174 = mw_std_maybe_Maybe_1_someZAsk(v173);
					if (!((bool)v174)) break;
					VAL v175 = pop_value();
					VAL v176 = mw_std_maybe_Maybe_1_unwrap(v175);
					VAL v177 = pop_value();
					int64_t v178 = 0LL /* C99RT_VAL */;
					VAL r179 = pop_resource();
					VAL v180 = (VVAL(VTUP(r179)->cells[1]));
					lpush(&lbl_localZ_repr, MKI64(v178));
					mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v180);
					VAL v181 = pop_value();
					VAL r182 = pop_resource();
					int64_t v183 = VI64(lpop(&lbl_localZ_repr));
					VAL v184 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v183, v181));
					push_resource(v184);
					VAL v185 = (mw_mirth_c99_ZPlusC99_indent(r182));
					VAL r186 = pop_resource();
					int64_t v187 = VI64(VTUP(r186)->cells[1]);
					push_resource(r186);
					push_resource(v185);
					VAL v188 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v187);
					VAL r189 = pop_resource();
					VAL v190 = (mw_mirth_c99_ZPlusC99_put(v188, r189));
					STR* v191;
					STRLIT(v191, " ", 1);
					VAL v192 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v191), v190));
					VAL r193 = pop_resource();
					VAL v194 = VVAL(VTUP(r193)->cells[2]);
					incref(v194);
					push_resource(r193);
					VAL v195 = (mw_mirth_c99_ZPlusC99_put(v194, v192));
					STR* v196;
					STRLIT(v196, " = ", 3);
					VAL v197 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v196), v195));
					VAL r198 = pop_resource();
					VAL v199 = lpop(&lbl_tup);
					incref(v199);
					lpush(&lbl_tup, v199);
					VAL v200 = (mw_mirth_c99_ZPlusC99_put(v199, v197));
					STR* v201;
					STRLIT(v201, "->cells[", 8);
					VAL v202 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v201), v200));
					int64_t v203 = VI64(lpop(&lbl_i));
					STR* v204 = i64_show(v203);
					lpush(&lbl_i, MKI64(v203));
					VAL v205 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v204), v202));
					STR* v206;
					STRLIT(v206, "]", 1);
					VAL v207 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v206), v205));
					STR* v208;
					STRLIT(v208, ";", 1);
					push_resource(r198);
					VAL v209 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v208), v207));
					VAL v210 = (mw_mirth_c99_ZPlusC99_line(v209));
					VTUP(r179)->cells[1] = v210;
					VAL r211 = pop_resource();
					incref(v176);
					push_resource(r179);
					push_resource(r211);
					push_value(v176);
					int64_t v212 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(VU64(v176));
					if (((bool)v212)) {
						VAL r213 = pop_resource();
						VAL v214 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(r213));
						VAL r215 = pop_resource();
						uint64_t v216 = pop_u64();
						VAL v217 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v216, r215, v214));
						push_resource(v217);
					} else {
						VAL r218 = pop_resource();
						VAL r219 = pop_resource();
						uint64_t v220 = pop_u64();
						VAL v221 = (mw_mirth_c99_pushZ_localZ_labelZBang(v220, r219, r218));
						push_resource(v221);
					}
					int64_t v222 = VI64(lpop(&lbl_i));
					int64_t v223 = 1LL;
					int64_t v224 = i64_add(v222, v223);
					lpush(&lbl_i, MKI64(v224));
					mw_std_list_List_1_uncons(v177);
					VAL v225 = pop_value();
					VAL v226 = pop_value();
					push_value(v225);
					push_value(v226);
				}
				VAL v227 = pop_value();
				decref(v227);
				VAL v228 = pop_value();
				decref(v228);
				VAL r229 = pop_resource();
				VAL v230 = (VVAL(VTUP(r229)->cells[1]));
				VAL v231 = (mw_mirth_c99_ZPlusC99_indent(v230));
				STR* v232;
				STRLIT(v232, "tup_decref_outer(", 17);
				VAL v233 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v232), v231));
				VAL v234 = lpop(&lbl_tup);
				VAL v235 = (mw_mirth_c99_ZPlusC99_put(v234, v233));
				STR* v236;
				STRLIT(v236, ",", 1);
				VAL v237 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v236), v235));
				int64_t v238 = VI64(lpop(&lbl_i));
				STR* v239 = i64_show(v238);
				VAL v240 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v239), v237));
				STR* v241;
				STRLIT(v241, ");", 2);
				VAL v242 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v241), v240));
				VAL v243 = (mw_mirth_c99_ZPlusC99_line(v242));
				VTUP(r229)->cells[1] = v243;
				push_resource(r229);
			}
		}
	}
	uint64_t v244 = VU64(lpop(&lbl_tag));
	VAL r245 = pop_resource();
	return r245;
}
static VAL mw_mirth_c99_c99Z_tagZ_defZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	lpush(&lbl_tag, MKU64(x1));
	int64_t v0 = mw_mirth_data_Tag_preferZ_inlineZAsk(x1);
	if (((bool)v0)) {
	} else {
		uint64_t v1 = VU64(lpop(&lbl_tag));
		VAL r2 = pop_resource();
		VAL v3 = (VVAL(VTUP(r2)->cells[4]));
		lpush(&lbl_tag, MKU64(v1));
		mw_mirth_data_Tag_wordZ_neededZAsk(v1, v3);
		VAL r4 = pop_resource();
		VTUP(r2)->cells[4] = r4;
		bool v5 = pop_bool();
		if (v5) {
			uint64_t v6 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v6));
			mw_mirth_data_Tag_wordZ_c99Z_api(v6, r2);
			VAL r7 = pop_resource();
			VAL v8 = (mw_mirth_c99_ZPlusC99_indent(r7));
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			VAL v10 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v9, v8));
			STR* v11;
			STRLIT(v11, " {", 2);
			VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
			VAL v13 = (mw_mirth_c99_ZPlusC99_line(v12));
			int64_t v14 = VI64(VTUP(v13)->cells[2]);
			int64_t v15 = 1LL;
			int64_t v16 = i64_add(v14, v15);
			VTUP(v13)->cells[2] = MKI64(v16);
			VAL v17 = pop_value();
			incref(v17);
			VAL v18 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v17, v13));
			uint64_t v19 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v19));
			VAL v20 = (mw_mirth_c99_c99Z_tagZ_bodyZBang(v19, v18));
			VAL v21 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v17, v20));
			int64_t v22 = VI64(VTUP(v21)->cells[2]);
			int64_t v23 = 1LL;
			int64_t v24 = i64_sub(v22, v23);
			int64_t v25 = mw_std_prim_Int_ZToNat(v24);
			VTUP(v21)->cells[2] = MKI64(v25);
			VAL v26 = (mw_mirth_c99_ZPlusC99_indent(v21));
			STR* v27;
			STRLIT(v27, "}", 1);
			VAL v28 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v27), v26));
			VAL v29 = (mw_mirth_c99_ZPlusC99_line(v28));
			push_resource(v29);
		} else {
			push_resource(r2);
		}
		uint64_t v30 = VU64(lpop(&lbl_tag));
		VAL r31 = pop_resource();
		VAL v32 = (VVAL(VTUP(r31)->cells[4]));
		lpush(&lbl_tag, MKU64(v30));
		mw_mirth_data_Tag_patZ_neededZAsk(v30, v32);
		VAL r33 = pop_resource();
		VTUP(r31)->cells[4] = r33;
		bool v34 = pop_bool();
		if (v34) {
			uint64_t v35 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v35));
			mw_mirth_data_Tag_patZ_c99Z_api(v35, r31);
			VAL r36 = pop_resource();
			VAL v37 = (mw_mirth_c99_ZPlusC99_indent(r36));
			VAL v38 = pop_value();
			incref(v38);
			push_value(v38);
			VAL v39 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v38, v37));
			STR* v40;
			STRLIT(v40, " {", 2);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), v39));
			VAL v42 = (mw_mirth_c99_ZPlusC99_line(v41));
			int64_t v43 = VI64(VTUP(v42)->cells[2]);
			int64_t v44 = 1LL;
			int64_t v45 = i64_add(v43, v44);
			VTUP(v42)->cells[2] = MKI64(v45);
			VAL v46 = pop_value();
			incref(v46);
			VAL v47 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v46, v42));
			uint64_t v48 = VU64(lpop(&lbl_tag));
			lpush(&lbl_tag, MKU64(v48));
			VAL v49 = (mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang(v48, v47));
			VAL v50 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v46, v49));
			int64_t v51 = VI64(VTUP(v50)->cells[2]);
			int64_t v52 = 1LL;
			int64_t v53 = i64_sub(v51, v52);
			int64_t v54 = mw_std_prim_Int_ZToNat(v53);
			VTUP(v50)->cells[2] = MKI64(v54);
			VAL v55 = (mw_mirth_c99_ZPlusC99_indent(v50));
			STR* v56;
			STRLIT(v56, "}", 1);
			VAL v57 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v56), v55));
			VAL v58 = (mw_mirth_c99_ZPlusC99_line(v57));
			push_resource(v58);
		} else {
			push_resource(r31);
		}
	}
	uint64_t v59 = VU64(lpop(&lbl_tag));
	VAL r60 = pop_resource();
	return r60;
}
static void mw_mirth_c99_c99Z_tagZ_labelZ_index (uint64_t x1, uint64_t x2, VAL x3) {
	push_resource(x3);
	push_u64(x1);
	push_u64(x2);
	int64_t v0 = mw_mirth_data_Tag_numZ_totalZ_inputs(x1);
	int64_t v1 = 1LL;
	int64_t v2 = i64_add(v0, v1);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v3);
	push_i64(v2);
	VAL v5 = mw_mirth_data_Tag_labelZ_inputs(VU64(v4));
	VAL v6 = mw_std_list_List_1_reverse(v5);
	int64_t v7 = 0LL /* None */;
	push_i64(v7);
	mw_std_list_List_1_uncons(v6);
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		int64_t v11 = mw_std_maybe_Maybe_1_someZAsk(v10);
		if (!((bool)v11)) break;
		VAL v12 = pop_value();
		VAL v13 = mw_std_maybe_Maybe_1_unwrap(v12);
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v13);
		int64_t v16 = 1LL;
		int64_t v17 = pop_i64();
		int64_t v18 = i64_sub(v17, v16);
		int64_t v19 = mw_std_prim_Int_ZToNat(v18);
		VAL v20 = pop_value();
		incref(v20);
		push_value(v20);
		push_i64(v19);
		int64_t v21 = mw_mirth_label_Label_ZEqualZEqual(VU64(v20), VU64(v13));
		if (((bool)v21)) {
			VAL v22 = mtw_std_maybe_Maybe_1_Some(v13);
			push_value(v22);
		} else {
			decref(v13);
			int64_t v23 = 0LL /* None */;
			push_i64(v23);
		}
		VAL v24 = pop_value();
		switch (get_data_tag(v24)) {
			case 0LL: { // None
				push_value(v15);
				push_value(v14);
			} break;
			default: {
				decref(v14);
				decref(v15);
				int64_t v25 = 0LL /* Nil */;
				push_value(v24);
				push_i64(v25);
			} break;
		}
		VAL v26 = pop_value();
		mw_std_list_List_1_uncons(v26);
		VAL v27 = pop_value();
		VAL v28 = pop_value();
		push_value(v27);
		push_value(v28);
	}
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	decref(v30);
	VAL v31 = pop_value();
	decref(v31);
	int64_t v32 = pop_i64();
	VAL v33 = pop_value();
	decref(v33);
	VAL v34 = pop_value();
	decref(v34);
	push_i64(v32);
}
static VAL mw_mirth_c99_c99Z_tagZ_getZ_labelZBang (uint64_t x1, uint64_t x2, VAL x3) {
	VAL v0 = (VVAL(VTUP(x3)->cells[1]));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	lpush(&lbl_label, MKU64(x2));
	lpush(&lbl_tag, MKU64(x1));
	mw_mirth_data_Tag_projectZ_inputZ_label(v1, x2, x1);
	VAL r2 = pop_resource();
	VTUP(v0)->cells[6] = r2;
	VTUP(x3)->cells[1] = v0;
	VAL v3 = pop_value();
	push_resource(x3);
	VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
	uint64_t v5 = VU64(lpop(&lbl_tag));
	lpush(&lbl_fieldty, v4);
	lpush(&lbl_tag, MKU64(v5));
	int64_t v6 = mw_mirth_data_Tag_isZ_semiZ_transparentZAsk(v5);
	if (((bool)v6)) {
		VAL v7 = lpop(&lbl_fieldty);
		switch (get_data_tag(v7)) {
			case 0LL: { // Left
				VAL v8 = mtp_std_either_Either_2_Left(v7);
				uint64_t v9 = VU64(lpop(&lbl_tag));
				push_value(v8);
				lpush(&lbl_tag, MKU64(v9));
				int64_t v10 = mw_mirth_data_Tag_outputsZ_resourceZAsk(v9);
				if (((bool)v10)) {
					VAL r11 = pop_resource();
					VAL v12 = pop_value();
					mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v12, r11);
					int64_t v13 = pop_i64();
					VAL r14 = pop_resource();
					mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r14, v13);
					VAL r15 = pop_resource();
					VAL r16 = pop_resource();
					mw_mirth_c99_ZPlusC99LocalResource_dupZ_localZ_resourceZ_asZ_valueZBang(r16, r15);
					VAL r17 = pop_resource();
					VAL r18 = pop_resource();
					VAL r19 = pop_resource();
					VAL v20 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r19, r18));
					VAL v21 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v20, r17));
					push_resource(v21);
				} else {
					VAL v22 = pop_value();
					decref(v22);
				}
			} break;
			case 1LL: { // Right
				VAL v23 = mtp_std_either_Either_2_Right(v7);
				decref(v23);
				int64_t v24 = 2LL /* C99RT_I64 */;
				VAL r25 = pop_resource();
				VAL v26 = (VVAL(VTUP(r25)->cells[1]));
				lpush(&lbl_localZ_resourceZ_repr, MKI64(v24));
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v26);
				VAL v27 = pop_value();
				VAL r28 = pop_resource();
				int64_t v29 = VI64(lpop(&lbl_localZ_resourceZ_repr));
				VAL v30 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v29, v27));
				push_resource(v30);
				VAL v31 = (mw_mirth_c99_ZPlusC99_indent(r28));
				VAL r32 = pop_resource();
				int64_t v33 = VI64(VTUP(r32)->cells[1]);
				push_resource(r32);
				push_resource(v31);
				VAL v34 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v33);
				VAL r35 = pop_resource();
				VAL v36 = (mw_mirth_c99_ZPlusC99_put(v34, r35));
				STR* v37;
				STRLIT(v37, " ", 1);
				VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), v36));
				VAL r39 = pop_resource();
				VAL v40 = VVAL(VTUP(r39)->cells[2]);
				incref(v40);
				push_resource(r39);
				VAL v41 = (mw_mirth_c99_ZPlusC99_put(v40, v38));
				STR* v42;
				STRLIT(v42, " = (", 4);
				VAL v43 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), v41));
				VAL r44 = pop_resource();
				STR* v45;
				STRLIT(v45, "0", 1);
				VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v43));
				STR* v47;
				STRLIT(v47, ");", 2);
				push_resource(r44);
				VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), v46));
				VAL v49 = (mw_mirth_c99_ZPlusC99_line(v48));
				VTUP(r25)->cells[1] = v49;
				VAL r50 = pop_resource();
				VAL v51 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r25, r50));
				push_resource(v51);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	} else {
		uint64_t v52 = VU64(lpop(&lbl_tag));
		lpush(&lbl_tag, MKU64(v52));
		uint64_t v53 = mw_mirth_data_Tag_data(v52);
		VAL r54 = pop_resource();
		mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v53, r54);
		VAL r55 = pop_resource();
		VAL v56 = lpop(&lbl_fieldty);
		switch (get_data_tag(v56)) {
			case 0LL: { // Left
				lpush(&lbl_ZPlustuplevar, r55);
				VAL v57 = mtp_std_either_Either_2_Left(v56);
				VAL r58 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v57, r58);
				int64_t v59 = pop_i64();
				VAL r60 = pop_resource();
				VAL v61 = (VVAL(VTUP(r60)->cells[1]));
				lpush(&lbl_fieldrepr, MKI64(v59));
				lpush(&lbl_localZ_repr, MKI64(v59));
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v61);
				VAL v62 = pop_value();
				VAL r63 = pop_resource();
				int64_t v64 = VI64(lpop(&lbl_localZ_repr));
				VAL v65 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v64, v62));
				push_resource(v65);
				VAL v66 = (mw_mirth_c99_ZPlusC99_indent(r63));
				VAL r67 = pop_resource();
				int64_t v68 = VI64(VTUP(r67)->cells[1]);
				push_resource(r67);
				push_resource(v66);
				VAL v69 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v68);
				VAL r70 = pop_resource();
				VAL v71 = (mw_mirth_c99_ZPlusC99_put(v69, r70));
				STR* v72;
				STRLIT(v72, " ", 1);
				VAL v73 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v72), v71));
				VAL r74 = pop_resource();
				VAL v75 = VVAL(VTUP(r74)->cells[2]);
				incref(v75);
				push_resource(r74);
				VAL v76 = (mw_mirth_c99_ZPlusC99_put(v75, v73));
				STR* v77;
				STRLIT(v77, " = ", 3);
				VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v77), v76));
				VAL r79 = pop_resource();
				int64_t v80 = VI64(lpop(&lbl_fieldrepr));
				push_resource(v78);
				VAL v81 = mw_mirth_c99_C99ReprType_vZ_macro(v80);
				VAL r82 = pop_resource();
				VAL v83 = (mw_mirth_c99_ZPlusC99_put(v81, r82));
				STR* v84;
				STRLIT(v84, "(VTUP(", 6);
				VAL v85 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v84), v83));
				VAL v86 = (lpop(&lbl_ZPlustuplevar));
				push_resource(v85);
				mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v86);
				VAL r87 = pop_resource();
				VAL r88 = pop_resource();
				lpush(&lbl_ZPlustuplevar, r87);
				VAL v89 = mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL(r88);
				VAL r90 = pop_resource();
				VAL v91 = (mw_mirth_c99_ZPlusC99_put(v89, r90));
				STR* v92;
				STRLIT(v92, ")->cells[", 9);
				VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
				uint64_t v94 = VU64(lpop(&lbl_tag));
				uint64_t v95 = VU64(lpop(&lbl_label));
				lpush(&lbl_tag, MKU64(v94));
				lpush(&lbl_label, MKU64(v95));
				mw_mirth_c99_c99Z_tagZ_labelZ_index(v94, v95, v93);
				int64_t v96 = pop_i64();
				STR* v97 = i64_show(v96);
				VAL r98 = pop_resource();
				VAL v99 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v97), r98));
				STR* v100;
				STRLIT(v100, "])", 2);
				VAL v101 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v100), v99));
				STR* v102;
				STRLIT(v102, ";", 1);
				push_resource(r79);
				VAL v103 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v102), v101));
				VAL v104 = (mw_mirth_c99_ZPlusC99_line(v103));
				VTUP(r60)->cells[1] = v104;
				VAL r105 = pop_resource();
				mw_mirth_c99_ZPlusC99Local_dupZ_localZBang(r60, r105);
				VAL r106 = pop_resource();
				mw_mirth_c99_ZPlusC99Local_rdrop(r106);
				VAL r107 = pop_resource();
				VAL r108 = pop_resource();
				VAL v109 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r108, r107));
				VAL v110 = (lpop(&lbl_ZPlustuplevar));
				switch (get_data_tag(v110)) {
					case 0LL: { // +Left
						push_resource(v109);
						VAL v111 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v110));
						VAL r112 = pop_resource();
						VAL v113 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(r112, v111));
						push_resource(v113);
					} break;
					case 1LL: { // +Right
						push_resource(v109);
						VAL v114 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v110));
						VAL r115 = pop_resource();
						VAL v116 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r115, v114));
						push_resource(v116);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						push_resource(v109);
					}
				}
			} break;
			case 1LL: { // Right
				lpush(&lbl_ZPlustuplevar, r55);
				VAL v117 = mtp_std_either_Either_2_Right(v56);
				VAL r118 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v117, r118);
				int64_t v119 = pop_i64();
				VAL r120 = pop_resource();
				VAL v121 = (VVAL(VTUP(r120)->cells[1]));
				lpush(&lbl_fieldrepr, MKI64(v119));
				lpush(&lbl_localZ_resourceZ_repr, MKI64(v119));
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v121);
				VAL v122 = pop_value();
				VAL r123 = pop_resource();
				int64_t v124 = VI64(lpop(&lbl_localZ_resourceZ_repr));
				VAL v125 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v124, v122));
				push_resource(v125);
				VAL v126 = (mw_mirth_c99_ZPlusC99_indent(r123));
				VAL r127 = pop_resource();
				int64_t v128 = VI64(VTUP(r127)->cells[1]);
				push_resource(r127);
				push_resource(v126);
				VAL v129 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v128);
				VAL r130 = pop_resource();
				VAL v131 = (mw_mirth_c99_ZPlusC99_put(v129, r130));
				STR* v132;
				STRLIT(v132, " ", 1);
				VAL v133 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v132), v131));
				VAL r134 = pop_resource();
				VAL v135 = VVAL(VTUP(r134)->cells[2]);
				incref(v135);
				push_resource(r134);
				VAL v136 = (mw_mirth_c99_ZPlusC99_put(v135, v133));
				STR* v137;
				STRLIT(v137, " = (", 4);
				VAL v138 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v137), v136));
				VAL r139 = pop_resource();
				int64_t v140 = VI64(lpop(&lbl_fieldrepr));
				push_resource(v138);
				VAL v141 = mw_mirth_c99_C99ReprType_vZ_macro(v140);
				VAL r142 = pop_resource();
				VAL v143 = (mw_mirth_c99_ZPlusC99_put(v141, r142));
				STR* v144;
				STRLIT(v144, "(VTUP(", 6);
				VAL v145 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v144), v143));
				VAL v146 = (lpop(&lbl_ZPlustuplevar));
				push_resource(v145);
				mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v146);
				VAL r147 = pop_resource();
				VAL r148 = pop_resource();
				lpush(&lbl_ZPlustuplevar, r147);
				VAL v149 = mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL(r148);
				VAL r150 = pop_resource();
				VAL v151 = (mw_mirth_c99_ZPlusC99_put(v149, r150));
				STR* v152;
				STRLIT(v152, ")->cells[", 9);
				VAL v153 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v152), v151));
				uint64_t v154 = VU64(lpop(&lbl_tag));
				uint64_t v155 = VU64(lpop(&lbl_label));
				lpush(&lbl_tag, MKU64(v154));
				lpush(&lbl_label, MKU64(v155));
				mw_mirth_c99_c99Z_tagZ_labelZ_index(v154, v155, v153);
				int64_t v156 = pop_i64();
				STR* v157 = i64_show(v156);
				VAL r158 = pop_resource();
				VAL v159 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v157), r158));
				STR* v160;
				STRLIT(v160, "])", 2);
				VAL v161 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v160), v159));
				STR* v162;
				STRLIT(v162, ");", 2);
				push_resource(r139);
				VAL v163 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v162), v161));
				VAL v164 = (mw_mirth_c99_ZPlusC99_line(v163));
				VTUP(r120)->cells[1] = v164;
				VAL r165 = pop_resource();
				VAL v166 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r120, r165));
				VAL v167 = (lpop(&lbl_ZPlustuplevar));
				VAL v168 = (mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang(v166, v167));
				push_resource(v168);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				lpush(&lbl_ZPlustuplevar, r55);
			}
		}
	}
	uint64_t v169 = VU64(lpop(&lbl_label));
	uint64_t v170 = VU64(lpop(&lbl_tag));
	VAL r171 = pop_resource();
	return r171;
}
static VAL mw_mirth_c99_c99Z_tagZ_setZ_labelZBang (uint64_t x1, uint64_t x2, VAL x3) {
	VAL v0 = (VVAL(VTUP(x3)->cells[1]));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	lpush(&lbl_label, MKU64(x2));
	lpush(&lbl_tag, MKU64(x1));
	mw_mirth_data_Tag_projectZ_inputZ_label(v1, x2, x1);
	VAL r2 = pop_resource();
	VTUP(v0)->cells[6] = r2;
	VTUP(x3)->cells[1] = v0;
	VAL v3 = pop_value();
	push_resource(x3);
	VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
	uint64_t v5 = VU64(lpop(&lbl_tag));
	lpush(&lbl_fieldty, v4);
	lpush(&lbl_tag, MKU64(v5));
	int64_t v6 = mw_mirth_data_Tag_isZ_semiZ_transparentZAsk(v5);
	if (((bool)v6)) {
		VAL v7 = lpop(&lbl_fieldty);
		switch (get_data_tag(v7)) {
			case 0LL: { // Left
				VAL v8 = mtp_std_either_Either_2_Left(v7);
				uint64_t v9 = VU64(lpop(&lbl_tag));
				push_value(v8);
				lpush(&lbl_tag, MKU64(v9));
				uint64_t v10 = mw_mirth_data_Tag_data(v9);
				VAL r11 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v10, r11);
				VAL r12 = pop_resource();
				switch (get_data_tag(r12)) {
					case 1LL: { // +Right
						VAL v13 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(r12));
						VAL r14 = pop_resource();
						VAL v15 = (mw_mirth_c99_ZPlusC99LocalResource_dropZ_localZ_resourceZ_asZ_valueZBang(r14, v13));
						VAL v16 = pop_value();
						mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v16, v15);
						int64_t v17 = pop_i64();
						VAL r18 = pop_resource();
						mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r18, v17);
						VAL r19 = pop_resource();
						VAL v20 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(r19));
						VAL r21 = pop_resource();
						VAL v22 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r21, v20));
						push_resource(v22);
					} break;
					case 0LL: { // +Left
						VAL v23 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(r12));
						VAL v24 = pop_value();
						decref(v24);
						VAL r25 = pop_resource();
						VAL v26 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(r25, v23));
						push_resource(v26);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
			} break;
			case 1LL: { // Right
				VAL v27 = mtp_std_either_Either_2_Right(v7);
				int64_t v28 = 2LL /* C99RT_I64 */;
				VAL r29 = pop_resource();
				push_value(v27);
				mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r29, v28);
				VAL r30 = pop_resource();
				mw_mirth_c99_ZPlusC99LocalResource_rdrop(r30);
				VAL v31 = pop_value();
				decref(v31);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	} else {
		uint64_t v32 = VU64(lpop(&lbl_tag));
		lpush(&lbl_tag, MKU64(v32));
		uint64_t v33 = mw_mirth_data_Tag_data(v32);
		VAL r34 = pop_resource();
		mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v33, r34);
		VAL r35 = pop_resource();
		VAL v36 = lpop(&lbl_fieldty);
		incref(v36);
		switch (get_data_tag(v36)) {
			case 0LL: { // Left
				lpush(&lbl_ZPlustuplevar, r35);
				lpush(&lbl_fieldty, v36);
				VAL v37 = mtp_std_either_Either_2_Left(v36);
				VAL r38 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v37, r38);
				int64_t v39 = pop_i64();
				VAL r40 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r40, v39);
				VAL r41 = pop_resource();
				VAL v42 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r41);
				push_value(v42);
			} break;
			case 1LL: { // Right
				lpush(&lbl_ZPlustuplevar, r35);
				lpush(&lbl_fieldty, v36);
				VAL v43 = mtp_std_either_Either_2_Right(v36);
				VAL r44 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v43, r44);
				int64_t v45 = pop_i64();
				VAL r46 = pop_resource();
				mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r46, v45);
				VAL r47 = pop_resource();
				VAL v48 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(r47);
				push_value(v48);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				lpush(&lbl_ZPlustuplevar, r35);
				lpush(&lbl_fieldty, v36);
			}
		}
		VAL v49 = pop_value();
		VAL v50 = (lpop(&lbl_ZPlustuplevar));
		switch (get_data_tag(v50)) {
			case 0LL: { // +Left
				lpush(&lbl_fieldval, v49);
				VAL v51 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(v50));
				VAL v52 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v51);
				int64_t v53 = 0LL /* C99RT_VAL */;
				VAL r54 = pop_resource();
				VAL v55 = (VVAL(VTUP(r54)->cells[1]));
				lpush(&lbl_tupleval, v52);
				lpush(&lbl_localZ_repr, MKI64(v53));
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v55);
				VAL v56 = pop_value();
				VAL r57 = pop_resource();
				int64_t v58 = VI64(lpop(&lbl_localZ_repr));
				VAL v59 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v58, v56));
				push_resource(v59);
				VAL v60 = (mw_mirth_c99_ZPlusC99_indent(r57));
				VAL r61 = pop_resource();
				int64_t v62 = VI64(VTUP(r61)->cells[1]);
				push_resource(r61);
				push_resource(v60);
				VAL v63 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v62);
				VAL r64 = pop_resource();
				VAL v65 = (mw_mirth_c99_ZPlusC99_put(v63, r64));
				STR* v66;
				STRLIT(v66, " ", 1);
				VAL v67 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v66), v65));
				VAL r68 = pop_resource();
				VAL v69 = VVAL(VTUP(r68)->cells[2]);
				incref(v69);
				push_resource(r68);
				VAL v70 = (mw_mirth_c99_ZPlusC99_put(v69, v67));
				STR* v71;
				STRLIT(v71, " = ", 3);
				VAL v72 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v71), v70));
				VAL r73 = pop_resource();
				STR* v74;
				STRLIT(v74, "tup_replace(", 12);
				VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v72));
				VAL v76 = lpop(&lbl_tupleval);
				VAL v77 = (mw_mirth_c99_ZPlusC99_put(v76, v75));
				STR* v78;
				STRLIT(v78, ", ", 2);
				VAL v79 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v78), v77));
				uint64_t v80 = VU64(lpop(&lbl_tag));
				uint64_t v81 = VU64(lpop(&lbl_label));
				lpush(&lbl_tag, MKU64(v80));
				lpush(&lbl_label, MKU64(v81));
				mw_mirth_c99_c99Z_tagZ_labelZ_index(v80, v81, v79);
				int64_t v82 = pop_i64();
				STR* v83 = i64_show(v82);
				VAL r84 = pop_resource();
				VAL v85 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v83), r84));
				STR* v86;
				STRLIT(v86, ", ", 2);
				VAL v87 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v86), v85));
				VAL v88 = lpop(&lbl_fieldval);
				VAL v89 = (mw_mirth_c99_ZPlusC99_put(v88, v87));
				STR* v90;
				STRLIT(v90, ")", 1);
				VAL v91 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v90), v89));
				STR* v92;
				STRLIT(v92, ";", 1);
				push_resource(r73);
				VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
				VAL v94 = (mw_mirth_c99_ZPlusC99_line(v93));
				VTUP(r54)->cells[1] = v94;
				VAL r95 = pop_resource();
				VAL v96 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r54, r95));
				VAL v97 = lpop(&lbl_fieldty);
				decref(v97);
				push_resource(v96);
			} break;
			case 1LL: { // +Right
				lpush(&lbl_fieldval, v49);
				VAL v98 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(v50));
				VAL v99 = lpop(&lbl_fieldty);
				switch (get_data_tag(v99)) {
					case 0LL: { // Left
						lpush(&lbl_ZPlustuplevar, v98);
						VAL v100 = mtp_std_either_Either_2_Left(v99);
						VAL r101 = pop_resource();
						mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v100, r101);
						int64_t v102 = pop_i64();
						lpush(&lbl_fieldrepr, MKI64(v102));
						int64_t v103 = mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk(v102);
						if (((bool)v103)) {
							int64_t v104 = VI64(lpop(&lbl_fieldrepr));
							VAL r105 = pop_resource();
							VAL v106 = (VVAL(VTUP(r105)->cells[1]));
							lpush(&lbl_fieldrepr, MKI64(v104));
							lpush(&lbl_localZ_repr, MKI64(v104));
							mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v106);
							VAL v107 = pop_value();
							VAL r108 = pop_resource();
							int64_t v109 = VI64(lpop(&lbl_localZ_repr));
							VAL v110 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v109, v107));
							push_resource(v110);
							VAL v111 = (mw_mirth_c99_ZPlusC99_indent(r108));
							VAL r112 = pop_resource();
							int64_t v113 = VI64(VTUP(r112)->cells[1]);
							push_resource(r112);
							push_resource(v111);
							VAL v114 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v113);
							VAL r115 = pop_resource();
							VAL v116 = (mw_mirth_c99_ZPlusC99_put(v114, r115));
							STR* v117;
							STRLIT(v117, " ", 1);
							VAL v118 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v117), v116));
							VAL r119 = pop_resource();
							VAL v120 = VVAL(VTUP(r119)->cells[2]);
							incref(v120);
							push_resource(r119);
							VAL v121 = (mw_mirth_c99_ZPlusC99_put(v120, v118));
							STR* v122;
							STRLIT(v122, " = ", 3);
							VAL v123 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v122), v121));
							VAL r124 = pop_resource();
							STR* v125;
							STRLIT(v125, "VTUP(", 5);
							VAL v126 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v125), v123));
							VAL v127 = (lpop(&lbl_ZPlustuplevar));
							push_resource(v126);
							mw_mirth_c99_ZPlusC99LocalResource_rdup(v127);
							VAL r128 = pop_resource();
							VAL r129 = pop_resource();
							lpush(&lbl_ZPlustuplevar, r128);
							VAL v130 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(r129);
							VAL r131 = pop_resource();
							VAL v132 = (mw_mirth_c99_ZPlusC99_put(v130, r131));
							STR* v133;
							STRLIT(v133, ")->cells[", 9);
							VAL v134 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v133), v132));
							uint64_t v135 = VU64(lpop(&lbl_tag));
							uint64_t v136 = VU64(lpop(&lbl_label));
							lpush(&lbl_tag, MKU64(v135));
							lpush(&lbl_label, MKU64(v136));
							mw_mirth_c99_c99Z_tagZ_labelZ_index(v135, v136, v134);
							int64_t v137 = pop_i64();
							STR* v138 = i64_show(v137);
							VAL r139 = pop_resource();
							VAL v140 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v138), r139));
							STR* v141;
							STRLIT(v141, "]", 1);
							VAL v142 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v141), v140));
							STR* v143;
							STRLIT(v143, ";", 1);
							push_resource(r124);
							VAL v144 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v143), v142));
							VAL v145 = (mw_mirth_c99_ZPlusC99_line(v144));
							VTUP(r105)->cells[1] = v145;
							VAL r146 = pop_resource();
							VAL v147 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(r105, r146));
							push_resource(v147);
						} else {
						}
						int64_t v148 = VI64(lpop(&lbl_fieldrepr));
					} break;
					case 1LL: { // Right
						lpush(&lbl_ZPlustuplevar, v98);
						VAL v149 = mtp_std_either_Either_2_Right(v99);
						decref(v149);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
						lpush(&lbl_ZPlustuplevar, v98);
					}
				}
				VAL r150 = pop_resource();
				VAL v151 = (VVAL(VTUP(r150)->cells[1]));
				VAL v152 = (mw_mirth_c99_ZPlusC99_indent(v151));
				STR* v153;
				STRLIT(v153, "VTUP(", 5);
				VAL v154 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v153), v152));
				VAL v155 = (lpop(&lbl_ZPlustuplevar));
				push_resource(v154);
				mw_mirth_c99_ZPlusC99LocalResource_rdup(v155);
				VAL r156 = pop_resource();
				VAL r157 = pop_resource();
				lpush(&lbl_ZPlustuplevar, r156);
				VAL v158 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(r157);
				VAL r159 = pop_resource();
				VAL v160 = (mw_mirth_c99_ZPlusC99_put(v158, r159));
				STR* v161;
				STRLIT(v161, ")->cells[", 9);
				VAL v162 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v161), v160));
				uint64_t v163 = VU64(lpop(&lbl_tag));
				uint64_t v164 = VU64(lpop(&lbl_label));
				lpush(&lbl_tag, MKU64(v163));
				lpush(&lbl_label, MKU64(v164));
				mw_mirth_c99_c99Z_tagZ_labelZ_index(v163, v164, v162);
				int64_t v165 = pop_i64();
				STR* v166 = i64_show(v165);
				VAL r167 = pop_resource();
				VAL v168 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v166), r167));
				STR* v169;
				STRLIT(v169, "] = ", 4);
				VAL v170 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v169), v168));
				VAL v171 = lpop(&lbl_fieldval);
				VAL v172 = (mw_mirth_c99_ZPlusC99_put(v171, v170));
				STR* v173;
				STRLIT(v173, ";", 1);
				VAL v174 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v173), v172));
				VAL v175 = (mw_mirth_c99_ZPlusC99_line(v174));
				VTUP(r150)->cells[1] = v175;
				VAL v176 = (lpop(&lbl_ZPlustuplevar));
				VAL v177 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r150, v176));
				push_resource(v177);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				lpush(&lbl_fieldval, v49);
			}
		}
	}
	uint64_t v178 = VU64(lpop(&lbl_label));
	uint64_t v179 = VU64(lpop(&lbl_tag));
	VAL r180 = pop_resource();
	return r180;
}
static VAL mw_mirth_c99_c99Z_externalZ_blocksZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_external_ExternalBlock_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_externalZ_blockZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_externalZ_blockZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_mirth_external_ExternalBlock_parts(x1);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		switch (get_data_tag(v6)) {
			case 0LL: { // EBPCode
				VAL v8 = mtp_mirth_external_ExternalBlockPart_EBPCode(v6);
				VAL r9 = pop_resource();
				VAL v10 = (mw_mirth_c99_ZPlusC99_put(v8, r9));
				VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
				push_resource(v11);
			} break;
			case 1LL: { // EBPDef
				uint64_t v12 = mtp_mirth_external_ExternalBlockPart_EBPDef(v6);
				VAL r13 = pop_resource();
				VAL v14 = (mw_mirth_c99_c99Z_externalZ_defZBang(v12, r13));
				push_resource(v14);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		mw_std_list_List_1_uncons(v7);
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
	VAL r19 = pop_resource();
	return r19;
}
static VAL mw_mirth_c99_c99Z_externalZ_defZBang (uint64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[6]));
	lpush(&lbl_ext, MKU64(x1));
	mw_mirth_external_External_ctype(v0, x1);
	VAL r1 = pop_resource();
	VTUP(x2)->cells[6] = r1;
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = VVAL(VTUP(v2)->cells[2]);
	incref(v3);
	decref(v2);
	VAL v4 = VVAL(VTUP(v3)->cells[2]);
	incref(v4);
	decref(v3);
	int64_t v5 = 0LL /* None */;
	push_resource(x2);
	lpush(&lbl_cty, v2);
	push_i64(v5);
	mw_std_list_List_1_uncons(v4);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		int64_t v9 = mw_std_maybe_Maybe_1_someZAsk(v8);
		if (!((bool)v9)) break;
		VAL v10 = pop_value();
		VAL v11 = mw_std_maybe_Maybe_1_unwrap(v10);
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		incref(v11);
		incref(v11);
		VAL v14 = mw_mirth_type_CTypeStackPart_labelZAsk(v11);
		int64_t v15 = mw_std_maybe_Maybe_1_noneZAsk(v14);
		if (((bool)v15)) {
			VAL v16 = mw_mirth_type_CTypeStackPart_ctype(v11);
			int64_t v17 = mw_mirth_type_CType_phantomZAsk(v16);
			bool v18 = !((bool)v17);
			push_bool(v18);
		} else {
			decref(v11);
			int64_t v19 = 0LL /* False */;
			push_i64(v19);
		}
		int64_t v20 = pop_i64();
		if (((bool)v20)) {
			VAL v21 = mtw_std_maybe_Maybe_1_Some(v11);
			push_value(v21);
		} else {
			decref(v11);
			int64_t v22 = 0LL /* None */;
			push_i64(v22);
		}
		VAL v23 = pop_value();
		switch (get_data_tag(v23)) {
			case 0LL: { // None
				push_value(v13);
				push_value(v12);
			} break;
			default: {
				decref(v12);
				decref(v13);
				int64_t v24 = 0LL /* Nil */;
				push_value(v23);
				push_i64(v24);
			} break;
		}
		VAL v25 = pop_value();
		mw_std_list_List_1_uncons(v25);
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		push_value(v26);
		push_value(v27);
	}
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	incref(v30);
	switch (get_data_tag(v30)) {
		case 1LL: { // Some
			lpush(&lbl_outty, v30);
			VAL v31 = mtp_std_maybe_Maybe_1_Some(v30);
			VAL v32 = mw_mirth_type_CTypeStackPart_ctype(v31);
			push_value(v32);
		} break;
		case 0LL: { // None
			int64_t v33 = 5LL /* Phantom */;
			lpush(&lbl_outty, v30);
			push_i64(v33);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			lpush(&lbl_outty, v30);
		}
	}
	VAL v34 = pop_value();
	VAL v35 = mw_mirth_type_CType_cname(v34);
	VAL r36 = pop_resource();
	VAL v37 = (mw_mirth_c99_ZPlusC99_put(v35, r36));
	STR* v38;
	STRLIT(v38, " ", 1);
	VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
	uint64_t v40 = VU64(lpop(&lbl_ext));
	push_resource(v39);
	lpush(&lbl_ext, MKU64(v40));
	VAL v41 = mw_mirth_external_External_symbol(v40);
	VAL r42 = pop_resource();
	VAL v43 = (mw_mirth_c99_ZPlusC99_put(v41, r42));
	STR* v44;
	STRLIT(v44, " (", 2);
	VAL v45 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v44), v43));
	VAL v46 = lpop(&lbl_cty);
	incref(v46);
	VAL v47 = VVAL(VTUP(v46)->cells[1]);
	incref(v47);
	decref(v46);
	VAL v48 = VVAL(VTUP(v47)->cells[2]);
	incref(v48);
	decref(v47);
	int64_t v49 = 0LL /* Nil */;
	push_resource(v45);
	lpush(&lbl_cty, v46);
	push_value(v48);
	VAL v50 = mw_std_list_List_1_reverse(MKI64(v49));
	VAL v51 = pop_value();
	push_resource(v50);
	mw_std_list_List_1_uncons(v51);
	VAL v52 = pop_value();
	VAL v53 = pop_value();
	push_value(v52);
	push_value(v53);
	while(1) {
		VAL v54 = pop_value();
		incref(v54);
		push_value(v54);
		int64_t v55 = mw_std_maybe_Maybe_1_someZAsk(v54);
		if (!((bool)v55)) break;
		VAL v56 = pop_value();
		VAL v57 = mw_std_maybe_Maybe_1_unwrap(v56);
		VAL v58 = pop_value();
		VAL r59 = pop_resource();
		incref(v57);
		VAL v60 = mw_mirth_type_CTypeStackPart_ctype(v57);
		int64_t v61 = mw_mirth_type_CType_phantomZAsk(v60);
		bool v62 = !((bool)v61);
		if (v62) {
			VAL v63 = mtw_std_maybe_Maybe_1_Some(v57);
			push_value(v63);
		} else {
			decref(v57);
			int64_t v64 = 0LL /* None */;
			push_i64(v64);
		}
		VAL v65 = pop_value();
		switch (get_data_tag(v65)) {
			case 1LL: { // Some
				push_resource(r59);
				VAL v66 = mtp_std_maybe_Maybe_1_Some(v65);
				VAL r67 = pop_resource();
				VAL v68 = mtw_std_list_List_1_Cons(v66, r67);
				push_resource(v68);
			} break;
			case 0LL: { // None
				push_resource(r59);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r59);
			}
		}
		mw_std_list_List_1_uncons(v58);
		VAL v69 = pop_value();
		VAL v70 = pop_value();
		push_value(v69);
		push_value(v70);
	}
	VAL v71 = pop_value();
	decref(v71);
	VAL v72 = pop_value();
	decref(v72);
	VAL r73 = pop_resource();
	VAL v74 = mw_std_list_List_1_reverse(r73);
	switch (get_data_tag(v74)) {
		case 0LL: { // Nil
			STR* v75;
			STRLIT(v75, "void", 4);
			VAL r76 = pop_resource();
			VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v75), r76));
			push_resource(v77);
		} break;
		default: {
			mw_std_list_List_1_uncons(v74);
			VAL v78 = pop_value();
			VAL v79 = pop_value();
			switch (get_data_tag(v79)) {
				case 1LL: { // Some
					VAL v80 = mtp_std_maybe_Maybe_1_Some(v79);
					VAL v81 = mw_mirth_type_CTypeStackPart_ctype(v80);
					VAL v82 = mw_mirth_type_CType_cname(v81);
					VAL r83 = pop_resource();
					VAL v84 = (mw_mirth_c99_ZPlusC99_put(v82, r83));
					push_resource(v84);
				} break;
				case 0LL: { // None
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			mw_std_list_List_1_uncons(v78);
			VAL v85 = pop_value();
			VAL v86 = pop_value();
			push_value(v85);
			push_value(v86);
			while(1) {
				VAL v87 = pop_value();
				incref(v87);
				push_value(v87);
				int64_t v88 = mw_std_maybe_Maybe_1_someZAsk(v87);
				if (!((bool)v88)) break;
				VAL v89 = pop_value();
				VAL v90 = mw_std_maybe_Maybe_1_unwrap(v89);
				VAL v91 = pop_value();
				STR* v92;
				STRLIT(v92, ", ", 2);
				VAL r93 = pop_resource();
				VAL v94 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), r93));
				push_resource(v94);
				VAL v95 = mw_mirth_type_CTypeStackPart_ctype(v90);
				VAL v96 = mw_mirth_type_CType_cname(v95);
				VAL r97 = pop_resource();
				VAL v98 = (mw_mirth_c99_ZPlusC99_put(v96, r97));
				push_resource(v98);
				mw_std_list_List_1_uncons(v91);
				VAL v99 = pop_value();
				VAL v100 = pop_value();
				push_value(v99);
				push_value(v100);
			}
			VAL v101 = pop_value();
			decref(v101);
			VAL v102 = pop_value();
			decref(v102);
		} break;
	}
	STR* v103;
	STRLIT(v103, ");", 2);
	VAL r104 = pop_resource();
	VAL v105 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v103), r104));
	VAL v106 = (mw_mirth_c99_ZPlusC99_line(v105));
	uint64_t v107 = VU64(lpop(&lbl_ext));
	VAL v108 = (VVAL(VTUP(v106)->cells[6]));
	lpush(&lbl_ext, MKU64(v107));
	mw_mirth_external_External_cname(v108, v107);
	VAL r109 = pop_resource();
	VTUP(v106)->cells[6] = r109;
	VAL v110 = pop_value();
	VAL v111 = (mw_mirth_c99_ZPlusC99_sigZ_put(v110, v106));
	STR* v112;
	STRLIT(v112, " {", 2);
	VAL v113 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v112), v111));
	VAL v114 = (mw_mirth_c99_ZPlusC99_line(v113));
	VAL v115 = (mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang(v114));
	VAL v116 = lpop(&lbl_cty);
	incref(v116);
	VAL v117 = VVAL(VTUP(v116)->cells[1]);
	incref(v117);
	decref(v116);
	VAL v118 = VVAL(VTUP(v117)->cells[2]);
	incref(v118);
	decref(v117);
	incref(v118);
	push_resource(v115);
	lpush(&lbl_cty, v116);
	push_value(v118);
	int64_t v119 = mw_std_list_List_1_len(v118);
	VAL v120 = pop_value();
	lpush(&lbl_argZ_index, MKI64(v119));
	VAL v121 = mw_std_list_List_1_reverse(v120);
	mw_std_list_List_1_uncons(v121);
	VAL v122 = pop_value();
	VAL v123 = pop_value();
	push_value(v122);
	push_value(v123);
	while(1) {
		VAL v124 = pop_value();
		incref(v124);
		push_value(v124);
		int64_t v125 = mw_std_maybe_Maybe_1_someZAsk(v124);
		if (!((bool)v125)) break;
		VAL v126 = pop_value();
		VAL v127 = mw_std_maybe_Maybe_1_unwrap(v126);
		VAL v128 = pop_value();
		incref(v127);
		push_value(v127);
		VAL v129 = mw_mirth_type_CTypeStackPart_ctype(v127);
		int64_t v130 = mw_mirth_type_CType_phantomZAsk(v129);
		if (((bool)v130)) {
		} else {
			STR* v131;
			STRLIT(v131, "\t", 1);
			VAL r132 = pop_resource();
			VAL v133 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v131), r132));
			VAL v134 = pop_value();
			incref(v134);
			push_resource(v133);
			push_value(v134);
			VAL v135 = mw_mirth_type_CTypeStackPart_ctype(v134);
			VAL v136 = mw_mirth_type_CType_cname(v135);
			VAL r137 = pop_resource();
			VAL v138 = (mw_mirth_c99_ZPlusC99_put(v136, r137));
			STR* v139;
			STRLIT(v139, " ", 1);
			VAL v140 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v139), v138));
			VAL v141 = pop_value();
			incref(v141);
			int64_t v142 = VI64(lpop(&lbl_argZ_index));
			push_value(v141);
			mw_mirth_type_CTypeStackPart_c99Z_argZ_name(v142, v141, v140);
			VAL r143 = pop_resource();
			VAL v144 = pop_value();
			VAL v145 = (mw_mirth_c99_ZPlusC99_put(v144, r143));
			STR* v146;
			STRLIT(v146, " = ", 3);
			VAL v147 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v146), v145));
			push_resource(v147);
		}
		VAL r148 = pop_resource();
		VAL v149 = pop_value();
		VAL v150 = (mw_mirth_type_CTypeStackPart_c99Z_pop(v149, r148));
		STR* v151;
		STRLIT(v151, ";", 1);
		VAL v152 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v151), v150));
		VAL v153 = (mw_mirth_c99_ZPlusC99_line(v152));
		int64_t v154 = VI64(lpop(&lbl_argZ_index));
		int64_t v155 = 1LL;
		int64_t v156 = i64_sub(v154, v155);
		push_resource(v153);
		int64_t v157 = mw_std_prim_Int_ZToNat(v156);
		lpush(&lbl_argZ_index, MKI64(v157));
		mw_std_list_List_1_uncons(v128);
		VAL v158 = pop_value();
		VAL v159 = pop_value();
		push_value(v158);
		push_value(v159);
	}
	VAL v160 = pop_value();
	decref(v160);
	VAL v161 = pop_value();
	decref(v161);
	STR* v162;
	STRLIT(v162, "\t", 1);
	VAL r163 = pop_resource();
	VAL v164 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v162), r163));
	VAL v165 = lpop(&lbl_outty);
	incref(v165);
	switch (get_data_tag(v165)) {
		case 1LL: { // Some
			push_resource(v164);
			lpush(&lbl_outty, v165);
			VAL v166 = mtp_std_maybe_Maybe_1_Some(v165);
			VAL v167 = mw_mirth_type_CTypeStackPart_ctype(v166);
			VAL v168 = mw_mirth_type_CType_cname(v167);
			VAL r169 = pop_resource();
			VAL v170 = (mw_mirth_c99_ZPlusC99_put(v168, r169));
			STR* v171;
			STRLIT(v171, " Y = ", 5);
			VAL v172 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v171), v170));
			push_resource(v172);
		} break;
		case 0LL: { // None
			push_resource(v164);
			lpush(&lbl_outty, v165);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(v164);
			lpush(&lbl_outty, v165);
		}
	}
	uint64_t v173 = VU64(lpop(&lbl_ext));
	lpush(&lbl_ext, MKU64(v173));
	VAL v174 = mw_mirth_external_External_symbol(v173);
	VAL r175 = pop_resource();
	VAL v176 = (mw_mirth_c99_ZPlusC99_put(v174, r175));
	STR* v177;
	STRLIT(v177, "(", 1);
	VAL v178 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v177), v176));
	int64_t v179 = 1LL;
	push_resource(v178);
	int64_t v180 = mw_std_prim_Int_ZToNat(v179);
	int64_t v181 = VI64(lpop(&lbl_argZ_index));
	VAL v182 = lpop(&lbl_cty);
	incref(v182);
	VAL v183 = VVAL(VTUP(v182)->cells[1]);
	incref(v183);
	decref(v182);
	VAL v184 = VVAL(VTUP(v183)->cells[2]);
	incref(v184);
	decref(v183);
	int64_t v185 = 0LL /* Nil */;
	lpush(&lbl_argZ_index, MKI64(v180));
	lpush(&lbl_cty, v182);
	push_value(v184);
	VAL v186 = mw_std_list_List_1_reverse(MKI64(v185));
	VAL v187 = pop_value();
	push_resource(v186);
	mw_std_list_List_1_uncons(v187);
	VAL v188 = pop_value();
	VAL v189 = pop_value();
	push_value(v188);
	push_value(v189);
	while(1) {
		VAL v190 = pop_value();
		incref(v190);
		push_value(v190);
		int64_t v191 = mw_std_maybe_Maybe_1_someZAsk(v190);
		if (!((bool)v191)) break;
		VAL v192 = pop_value();
		VAL v193 = mw_std_maybe_Maybe_1_unwrap(v192);
		VAL v194 = pop_value();
		VAL r195 = pop_resource();
		incref(v193);
		push_value(v193);
		VAL v196 = mw_mirth_type_CTypeStackPart_ctype(v193);
		int64_t v197 = mw_mirth_type_CType_phantomZAsk(v196);
		if (((bool)v197)) {
			VAL v198 = pop_value();
			decref(v198);
			int64_t v199 = 0LL /* None */;
			push_i64(v199);
		} else {
			VAL r200 = pop_resource();
			VAL v201 = pop_value();
			int64_t v202 = VI64(lpop(&lbl_argZ_index));
			mw_mirth_type_CTypeStackPart_c99Z_argZ_name(v202, v201, r200);
			VAL v203 = pop_value();
			VAL v204 = mtw_std_maybe_Maybe_1_Some(v203);
			push_value(v204);
		}
		int64_t v205 = VI64(lpop(&lbl_argZ_index));
		int64_t v206 = 1LL;
		int64_t v207 = i64_add(v205, v206);
		VAL v208 = pop_value();
		switch (get_data_tag(v208)) {
			case 1LL: { // Some
				lpush(&lbl_argZ_index, MKI64(v207));
				push_resource(r195);
				VAL v209 = mtp_std_maybe_Maybe_1_Some(v208);
				VAL r210 = pop_resource();
				VAL v211 = mtw_std_list_List_1_Cons(v209, r210);
				push_resource(v211);
			} break;
			case 0LL: { // None
				lpush(&lbl_argZ_index, MKI64(v207));
				push_resource(r195);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				lpush(&lbl_argZ_index, MKI64(v207));
				push_resource(r195);
			}
		}
		mw_std_list_List_1_uncons(v194);
		VAL v212 = pop_value();
		VAL v213 = pop_value();
		push_value(v212);
		push_value(v213);
	}
	VAL v214 = pop_value();
	decref(v214);
	VAL v215 = pop_value();
	decref(v215);
	VAL r216 = pop_resource();
	VAL v217 = mw_std_list_List_1_reverse(r216);
	mw_std_list_List_1_uncons(v217);
	VAL v218 = pop_value();
	VAL v219 = pop_value();
	switch (get_data_tag(v219)) {
		case 1LL: { // Some
			VAL v220 = mtp_std_maybe_Maybe_1_Some(v219);
			VAL r221 = pop_resource();
			VAL v222 = (mw_mirth_c99_ZPlusC99_put(v220, r221));
			push_resource(v222);
		} break;
		case 0LL: { // None
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	mw_std_list_List_1_uncons(v218);
	VAL v223 = pop_value();
	VAL v224 = pop_value();
	push_value(v223);
	push_value(v224);
	while(1) {
		VAL v225 = pop_value();
		incref(v225);
		push_value(v225);
		int64_t v226 = mw_std_maybe_Maybe_1_someZAsk(v225);
		if (!((bool)v226)) break;
		VAL v227 = pop_value();
		VAL v228 = mw_std_maybe_Maybe_1_unwrap(v227);
		VAL v229 = pop_value();
		STR* v230;
		STRLIT(v230, ", ", 2);
		VAL r231 = pop_resource();
		VAL v232 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v230), r231));
		VAL v233 = (mw_mirth_c99_ZPlusC99_put(v228, v232));
		push_resource(v233);
		mw_std_list_List_1_uncons(v229);
		VAL v234 = pop_value();
		VAL v235 = pop_value();
		push_value(v234);
		push_value(v235);
	}
	VAL v236 = pop_value();
	decref(v236);
	VAL v237 = pop_value();
	decref(v237);
	STR* v238;
	STRLIT(v238, ");", 2);
	VAL r239 = pop_resource();
	VAL v240 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v238), r239));
	VAL v241 = (mw_mirth_c99_ZPlusC99_line(v240));
	VAL v242 = lpop(&lbl_cty);
	incref(v242);
	VAL v243 = VVAL(VTUP(v242)->cells[2]);
	incref(v243);
	decref(v242);
	VAL v244 = VVAL(VTUP(v243)->cells[2]);
	incref(v244);
	decref(v243);
	push_resource(v241);
	lpush(&lbl_cty, v242);
	mw_std_list_List_1_uncons(v244);
	VAL v245 = pop_value();
	VAL v246 = pop_value();
	push_value(v245);
	push_value(v246);
	while(1) {
		VAL v247 = pop_value();
		incref(v247);
		push_value(v247);
		int64_t v248 = mw_std_maybe_Maybe_1_someZAsk(v247);
		if (!((bool)v248)) break;
		VAL v249 = pop_value();
		VAL v250 = mw_std_maybe_Maybe_1_unwrap(v249);
		VAL v251 = pop_value();
		STR* v252;
		STRLIT(v252, "\t", 1);
		VAL r253 = pop_resource();
		push_value(v250);
		VAL v254 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v252), r253));
		VAL v255 = pop_value();
		incref(v255);
		push_resource(v254);
		VAL v256 = mw_mirth_type_CTypeStackPart_labelZAsk(v255);
		switch (get_data_tag(v256)) {
			case 1LL: { // Some
				VAL v257 = mtp_std_maybe_Maybe_1_Some(v256);
				uint64_t v258 = mw_mirth_label_Label_name(VU64(v257));
				VAL v259 = mw_mirth_name_Name_mangled(v258);
				push_value(v259);
			} break;
			case 0LL: { // None
				STR* v260;
				STRLIT(v260, "Y", 1);
				push_str(v260);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL r261 = pop_resource();
		VAL v262 = pop_value();
		VAL v263 = (mw_mirth_type_CTypeStackPart_c99Z_push(v262, v255, r261));
		VAL v264 = (mw_mirth_c99_ZPlusC99_line(v263));
		push_resource(v264);
		mw_std_list_List_1_uncons(v251);
		VAL v265 = pop_value();
		VAL v266 = pop_value();
		push_value(v265);
		push_value(v266);
	}
	VAL v267 = pop_value();
	decref(v267);
	VAL v268 = pop_value();
	decref(v268);
	STR* v269;
	STRLIT(v269, "}", 1);
	VAL r270 = pop_resource();
	VAL v271 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v269), r270));
	VAL v272 = (mw_mirth_c99_ZPlusC99_line(v271));
	int64_t v273 = VI64(lpop(&lbl_argZ_index));
	uint64_t v274 = VU64(lpop(&lbl_ext));
	VAL v275 = lpop(&lbl_cty);
	VAL v276 = lpop(&lbl_outty);
	decref(v276);
	decref(v275);
	return v272;
}
static VAL mw_mirth_type_CType_c99Z_popZ_value (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // IntLike
			push_resource(x2);
			VAL v0 = mtp_mirth_type_CType_IntLike(x1);
			STR* v1;
			STRLIT(v1, "(", 1);
			VAL r2 = pop_resource();
			push_value(v0);
			VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), r2));
			VAL v4 = pop_value();
			VAL v5 = (mw_mirth_c99_ZPlusC99_put(v4, v3));
			STR* v6;
			STRLIT(v6, ")pop_i64()", 10);
			VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
			push_resource(v7);
		} break;
		case 1LL: { // F32Like
			push_resource(x2);
			VAL v8 = mtp_mirth_type_CType_F32Like(x1);
			STR* v9;
			STRLIT(v9, "(", 1);
			VAL r10 = pop_resource();
			push_value(v8);
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), r10));
			VAL v12 = pop_value();
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(v12, v11));
			STR* v14;
			STRLIT(v14, ")pop_f32()", 10);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
			push_resource(v15);
		} break;
		case 2LL: { // F64Like
			push_resource(x2);
			VAL v16 = mtp_mirth_type_CType_F64Like(x1);
			STR* v17;
			STRLIT(v17, "(", 1);
			VAL r18 = pop_resource();
			push_value(v16);
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), r18));
			VAL v20 = pop_value();
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v19));
			STR* v22;
			STRLIT(v22, ")pop_f64()", 10);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			push_resource(v23);
		} break;
		case 3LL: { // PtrLike
			push_resource(x2);
			VAL v24 = mtp_mirth_type_CType_PtrLike(x1);
			STR* v25;
			STRLIT(v25, "(", 1);
			VAL r26 = pop_resource();
			push_value(v24);
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), r26));
			VAL v28 = pop_value();
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(v28, v27));
			STR* v30;
			STRLIT(v30, ")pop_ptr()", 10);
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
			push_resource(v31);
		} break;
		case 4LL: { // FnPtr
			push_resource(x2);
			VAL v32 = mtp_mirth_type_CType_FnPtr(x1);
			STR* v33;
			STRLIT(v33, "(", 1);
			VAL r34 = pop_resource();
			push_value(v32);
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), r34));
			VAL v36 = pop_value();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v36, v35));
			STR* v38;
			STRLIT(v38, ")pop_fnptr()", 12);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			push_resource(v39);
		} break;
		case 5LL: { // Phantom
			STR* v40;
			STRLIT(v40, "(void)pop_value()", 17);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), x2));
			push_resource(v41);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r42 = pop_resource();
	return r42;
}
static VAL mw_mirth_type_CType_c99Z_popZ_resource (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // IntLike
			push_resource(x2);
			VAL v0 = mtp_mirth_type_CType_IntLike(x1);
			STR* v1;
			STRLIT(v1, "(", 1);
			VAL r2 = pop_resource();
			push_value(v0);
			VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), r2));
			VAL v4 = pop_value();
			VAL v5 = (mw_mirth_c99_ZPlusC99_put(v4, v3));
			STR* v6;
			STRLIT(v6, ")value_i64(pop_resource())", 26);
			VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
			push_resource(v7);
		} break;
		case 1LL: { // F32Like
			push_resource(x2);
			VAL v8 = mtp_mirth_type_CType_F32Like(x1);
			STR* v9;
			STRLIT(v9, "(", 1);
			VAL r10 = pop_resource();
			push_value(v8);
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), r10));
			VAL v12 = pop_value();
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(v12, v11));
			STR* v14;
			STRLIT(v14, ")value_f32(pop_resource())", 26);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
			push_resource(v15);
		} break;
		case 2LL: { // F64Like
			push_resource(x2);
			VAL v16 = mtp_mirth_type_CType_F64Like(x1);
			STR* v17;
			STRLIT(v17, "(", 1);
			VAL r18 = pop_resource();
			push_value(v16);
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), r18));
			VAL v20 = pop_value();
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v19));
			STR* v22;
			STRLIT(v22, ")value_f64(pop_resource())", 26);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			push_resource(v23);
		} break;
		case 3LL: { // PtrLike
			push_resource(x2);
			VAL v24 = mtp_mirth_type_CType_PtrLike(x1);
			STR* v25;
			STRLIT(v25, "(", 1);
			VAL r26 = pop_resource();
			push_value(v24);
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), r26));
			VAL v28 = pop_value();
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(v28, v27));
			STR* v30;
			STRLIT(v30, ")value_ptr(pop_resource())", 26);
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
			push_resource(v31);
		} break;
		case 4LL: { // FnPtr
			push_resource(x2);
			VAL v32 = mtp_mirth_type_CType_FnPtr(x1);
			STR* v33;
			STRLIT(v33, "(", 1);
			VAL r34 = pop_resource();
			push_value(v32);
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), r34));
			VAL v36 = pop_value();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v36, v35));
			STR* v38;
			STRLIT(v38, ")value_fnptr(pop_resource())", 28);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			push_resource(v39);
		} break;
		case 5LL: { // Phantom
			STR* v40;
			STRLIT(v40, "(void)pop_resource()", 20);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), x2));
			push_resource(v41);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r42 = pop_resource();
	return r42;
}
static VAL mw_mirth_type_CType_c99Z_popZ_label (uint64_t x1, VAL x2, VAL x3) {
	switch (get_data_tag(x2)) {
		case 0LL: { // IntLike
			push_u64(x1);
			push_resource(x3);
			VAL v0 = mtp_mirth_type_CType_IntLike(x2);
			STR* v1;
			STRLIT(v1, "(", 1);
			VAL r2 = pop_resource();
			push_value(v0);
			VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), r2));
			VAL v4 = pop_value();
			VAL v5 = (mw_mirth_c99_ZPlusC99_put(v4, v3));
			STR* v6;
			STRLIT(v6, ")value_i64(lpop(&lbl_", 21);
			VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
			uint64_t v8 = pop_u64();
			push_resource(v7);
			uint64_t v9 = mw_mirth_label_Label_name(v8);
			VAL v10 = mw_mirth_name_Name_mangled(v9);
			VAL r11 = pop_resource();
			VAL v12 = (mw_mirth_c99_ZPlusC99_put(v10, r11));
			STR* v13;
			STRLIT(v13, "))", 2);
			VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
			push_resource(v14);
		} break;
		case 1LL: { // F32Like
			push_u64(x1);
			push_resource(x3);
			VAL v15 = mtp_mirth_type_CType_F32Like(x2);
			STR* v16;
			STRLIT(v16, "(", 1);
			VAL r17 = pop_resource();
			push_value(v15);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), r17));
			VAL v19 = pop_value();
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(v19, v18));
			STR* v21;
			STRLIT(v21, ")value_f32(lpop(&lbl_", 21);
			VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
			uint64_t v23 = pop_u64();
			push_resource(v22);
			uint64_t v24 = mw_mirth_label_Label_name(v23);
			VAL v25 = mw_mirth_name_Name_mangled(v24);
			VAL r26 = pop_resource();
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(v25, r26));
			STR* v28;
			STRLIT(v28, "))", 2);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
			push_resource(v29);
		} break;
		case 2LL: { // F64Like
			push_u64(x1);
			push_resource(x3);
			VAL v30 = mtp_mirth_type_CType_F64Like(x2);
			STR* v31;
			STRLIT(v31, "(", 1);
			VAL r32 = pop_resource();
			push_value(v30);
			VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), r32));
			VAL v34 = pop_value();
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(v34, v33));
			STR* v36;
			STRLIT(v36, ")value_f64(lpop(&lbl_", 21);
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v36), v35));
			uint64_t v38 = pop_u64();
			push_resource(v37);
			uint64_t v39 = mw_mirth_label_Label_name(v38);
			VAL v40 = mw_mirth_name_Name_mangled(v39);
			VAL r41 = pop_resource();
			VAL v42 = (mw_mirth_c99_ZPlusC99_put(v40, r41));
			STR* v43;
			STRLIT(v43, "))", 2);
			VAL v44 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v43), v42));
			push_resource(v44);
		} break;
		case 3LL: { // PtrLike
			push_u64(x1);
			push_resource(x3);
			VAL v45 = mtp_mirth_type_CType_PtrLike(x2);
			STR* v46;
			STRLIT(v46, "(", 1);
			VAL r47 = pop_resource();
			push_value(v45);
			VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v46), r47));
			VAL v49 = pop_value();
			VAL v50 = (mw_mirth_c99_ZPlusC99_put(v49, v48));
			STR* v51;
			STRLIT(v51, ")value_ptr(lpop(&lbl_", 21);
			VAL v52 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v51), v50));
			uint64_t v53 = pop_u64();
			push_resource(v52);
			uint64_t v54 = mw_mirth_label_Label_name(v53);
			VAL v55 = mw_mirth_name_Name_mangled(v54);
			VAL r56 = pop_resource();
			VAL v57 = (mw_mirth_c99_ZPlusC99_put(v55, r56));
			STR* v58;
			STRLIT(v58, "))", 2);
			VAL v59 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v58), v57));
			push_resource(v59);
		} break;
		case 4LL: { // FnPtr
			push_u64(x1);
			push_resource(x3);
			VAL v60 = mtp_mirth_type_CType_FnPtr(x2);
			STR* v61;
			STRLIT(v61, "(", 1);
			VAL r62 = pop_resource();
			push_value(v60);
			VAL v63 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v61), r62));
			VAL v64 = pop_value();
			VAL v65 = (mw_mirth_c99_ZPlusC99_put(v64, v63));
			STR* v66;
			STRLIT(v66, ")value_fnptr(lpop(&lbl_", 23);
			VAL v67 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v66), v65));
			uint64_t v68 = pop_u64();
			push_resource(v67);
			uint64_t v69 = mw_mirth_label_Label_name(v68);
			VAL v70 = mw_mirth_name_Name_mangled(v69);
			VAL r71 = pop_resource();
			VAL v72 = (mw_mirth_c99_ZPlusC99_put(v70, r71));
			STR* v73;
			STRLIT(v73, "))", 2);
			VAL v74 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v73), v72));
			push_resource(v74);
		} break;
		case 5LL: { // Phantom
			STR* v75;
			STRLIT(v75, "(void)lpop(&lbl_", 16);
			push_u64(x1);
			VAL v76 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v75), x3));
			uint64_t v77 = pop_u64();
			push_resource(v76);
			uint64_t v78 = mw_mirth_label_Label_name(v77);
			VAL v79 = mw_mirth_name_Name_mangled(v78);
			VAL r80 = pop_resource();
			VAL v81 = (mw_mirth_c99_ZPlusC99_put(v79, r80));
			STR* v82;
			STRLIT(v82, ")", 1);
			VAL v83 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v82), v81));
			push_resource(v83);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
			push_resource(x3);
		}
	}
	VAL r84 = pop_resource();
	return r84;
}
static VAL mw_mirth_type_CType_c99Z_pushZ_value (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x2)) {
		case 0LL: { // IntLike
			push_value(x1);
			push_resource(x3);
			VAL v0 = mtp_mirth_type_CType_IntLike(x2);
			decref(v0);
			STR* v1;
			STRLIT(v1, "push_i64((int64_t)(", 19);
			VAL r2 = pop_resource();
			VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), r2));
			VAL v4 = pop_value();
			VAL v5 = (mw_mirth_c99_ZPlusC99_put(v4, v3));
			STR* v6;
			STRLIT(v6, "));", 3);
			VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
			push_resource(v7);
		} break;
		case 1LL: { // F32Like
			push_value(x1);
			push_resource(x3);
			VAL v8 = mtp_mirth_type_CType_F32Like(x2);
			decref(v8);
			STR* v9;
			STRLIT(v9, "push_f32((float)(", 17);
			VAL r10 = pop_resource();
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), r10));
			VAL v12 = pop_value();
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(v12, v11));
			STR* v14;
			STRLIT(v14, "));", 3);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
			push_resource(v15);
		} break;
		case 2LL: { // F64Like
			push_value(x1);
			push_resource(x3);
			VAL v16 = mtp_mirth_type_CType_F64Like(x2);
			decref(v16);
			STR* v17;
			STRLIT(v17, "push_f64((double)(", 18);
			VAL r18 = pop_resource();
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), r18));
			VAL v20 = pop_value();
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v19));
			STR* v22;
			STRLIT(v22, "));", 3);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			push_resource(v23);
		} break;
		case 3LL: { // PtrLike
			push_value(x1);
			push_resource(x3);
			VAL v24 = mtp_mirth_type_CType_PtrLike(x2);
			decref(v24);
			STR* v25;
			STRLIT(v25, "push_ptr((void*)(", 17);
			VAL r26 = pop_resource();
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), r26));
			VAL v28 = pop_value();
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(v28, v27));
			STR* v30;
			STRLIT(v30, "));", 3);
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
			push_resource(v31);
		} break;
		case 4LL: { // FnPtr
			push_value(x1);
			push_resource(x3);
			VAL v32 = mtp_mirth_type_CType_FnPtr(x2);
			decref(v32);
			STR* v33;
			STRLIT(v33, "push_fnptr((FNPTR)(", 19);
			VAL r34 = pop_resource();
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), r34));
			VAL v36 = pop_value();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v36, v35));
			STR* v38;
			STRLIT(v38, "));", 3);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			push_resource(v39);
		} break;
		case 5LL: { // Phantom
			decref(x1);
			STR* v40;
			STRLIT(v40, "push_i64(0);", 12);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), x3));
			push_resource(v41);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
			push_resource(x3);
		}
	}
	VAL r42 = pop_resource();
	return r42;
}
static VAL mw_mirth_type_CType_c99Z_pushZ_resource (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x2)) {
		case 0LL: { // IntLike
			push_value(x1);
			push_resource(x3);
			VAL v0 = mtp_mirth_type_CType_IntLike(x2);
			decref(v0);
			STR* v1;
			STRLIT(v1, "push_resource(MKI64((int64_t)(", 30);
			VAL r2 = pop_resource();
			VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), r2));
			VAL v4 = pop_value();
			VAL v5 = (mw_mirth_c99_ZPlusC99_put(v4, v3));
			STR* v6;
			STRLIT(v6, ")));", 4);
			VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
			push_resource(v7);
		} break;
		case 1LL: { // F32Like
			push_value(x1);
			push_resource(x3);
			VAL v8 = mtp_mirth_type_CType_F32Like(x2);
			decref(v8);
			STR* v9;
			STRLIT(v9, "push_resource(MKF32((float)(", 28);
			VAL r10 = pop_resource();
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), r10));
			VAL v12 = pop_value();
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(v12, v11));
			STR* v14;
			STRLIT(v14, ")));", 4);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
			push_resource(v15);
		} break;
		case 2LL: { // F64Like
			push_value(x1);
			push_resource(x3);
			VAL v16 = mtp_mirth_type_CType_F64Like(x2);
			decref(v16);
			STR* v17;
			STRLIT(v17, "push_resource(MKF64((double)(", 29);
			VAL r18 = pop_resource();
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), r18));
			VAL v20 = pop_value();
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v19));
			STR* v22;
			STRLIT(v22, ")));", 4);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			push_resource(v23);
		} break;
		case 3LL: { // PtrLike
			push_value(x1);
			push_resource(x3);
			VAL v24 = mtp_mirth_type_CType_PtrLike(x2);
			decref(v24);
			STR* v25;
			STRLIT(v25, "push_resource(MKPTR((void*)(", 28);
			VAL r26 = pop_resource();
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), r26));
			VAL v28 = pop_value();
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(v28, v27));
			STR* v30;
			STRLIT(v30, ")));", 4);
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
			push_resource(v31);
		} break;
		case 4LL: { // FnPtr
			push_value(x1);
			push_resource(x3);
			VAL v32 = mtp_mirth_type_CType_FnPtr(x2);
			decref(v32);
			STR* v33;
			STRLIT(v33, "push_resource(MKFNPTR((FNPTR)(", 30);
			VAL r34 = pop_resource();
			VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), r34));
			VAL v36 = pop_value();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v36, v35));
			STR* v38;
			STRLIT(v38, ")));", 4);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			push_resource(v39);
		} break;
		case 5LL: { // Phantom
			decref(x1);
			STR* v40;
			STRLIT(v40, "push_resource(MKI64(0));", 24);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), x3));
			push_resource(v41);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
			push_resource(x3);
		}
	}
	VAL r42 = pop_resource();
	return r42;
}
static VAL mw_mirth_type_CType_c99Z_pushZ_label (VAL x1, uint64_t x2, VAL x3, VAL x4) {
	switch (get_data_tag(x3)) {
		case 0LL: { // IntLike
			push_value(x1);
			push_u64(x2);
			push_resource(x4);
			VAL v0 = mtp_mirth_type_CType_IntLike(x3);
			decref(v0);
			STR* v1;
			STRLIT(v1, "lpush(&lbl_", 11);
			VAL r2 = pop_resource();
			VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), r2));
			uint64_t v4 = pop_u64();
			push_resource(v3);
			uint64_t v5 = mw_mirth_label_Label_name(v4);
			VAL v6 = mw_mirth_name_Name_mangled(v5);
			VAL r7 = pop_resource();
			VAL v8 = (mw_mirth_c99_ZPlusC99_put(v6, r7));
			STR* v9;
			STRLIT(v9, ", ", 2);
			VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
			STR* v11;
			STRLIT(v11, "MKI64((int64_t)(", 16);
			VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
			VAL v13 = pop_value();
			VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v12));
			STR* v15;
			STRLIT(v15, ")));", 4);
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
			push_resource(v16);
		} break;
		case 1LL: { // F32Like
			push_value(x1);
			push_u64(x2);
			push_resource(x4);
			VAL v17 = mtp_mirth_type_CType_F32Like(x3);
			decref(v17);
			STR* v18;
			STRLIT(v18, "lpush(&lbl_", 11);
			VAL r19 = pop_resource();
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), r19));
			uint64_t v21 = pop_u64();
			push_resource(v20);
			uint64_t v22 = mw_mirth_label_Label_name(v21);
			VAL v23 = mw_mirth_name_Name_mangled(v22);
			VAL r24 = pop_resource();
			VAL v25 = (mw_mirth_c99_ZPlusC99_put(v23, r24));
			STR* v26;
			STRLIT(v26, ", ", 2);
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v25));
			STR* v28;
			STRLIT(v28, "MKF32((float)(", 14);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
			VAL v30 = pop_value();
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(v30, v29));
			STR* v32;
			STRLIT(v32, ")));", 4);
			VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v31));
			push_resource(v33);
		} break;
		case 2LL: { // F64Like
			push_value(x1);
			push_u64(x2);
			push_resource(x4);
			VAL v34 = mtp_mirth_type_CType_F64Like(x3);
			decref(v34);
			STR* v35;
			STRLIT(v35, "lpush(&lbl_", 11);
			VAL r36 = pop_resource();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), r36));
			uint64_t v38 = pop_u64();
			push_resource(v37);
			uint64_t v39 = mw_mirth_label_Label_name(v38);
			VAL v40 = mw_mirth_name_Name_mangled(v39);
			VAL r41 = pop_resource();
			VAL v42 = (mw_mirth_c99_ZPlusC99_put(v40, r41));
			STR* v43;
			STRLIT(v43, ", ", 2);
			VAL v44 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v43), v42));
			STR* v45;
			STRLIT(v45, "MKF64((double)(", 15);
			VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v44));
			VAL v47 = pop_value();
			VAL v48 = (mw_mirth_c99_ZPlusC99_put(v47, v46));
			STR* v49;
			STRLIT(v49, ")));", 4);
			VAL v50 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v49), v48));
			push_resource(v50);
		} break;
		case 3LL: { // PtrLike
			push_value(x1);
			push_u64(x2);
			push_resource(x4);
			VAL v51 = mtp_mirth_type_CType_PtrLike(x3);
			decref(v51);
			STR* v52;
			STRLIT(v52, "lpush(&lbl_", 11);
			VAL r53 = pop_resource();
			VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v52), r53));
			uint64_t v55 = pop_u64();
			push_resource(v54);
			uint64_t v56 = mw_mirth_label_Label_name(v55);
			VAL v57 = mw_mirth_name_Name_mangled(v56);
			VAL r58 = pop_resource();
			VAL v59 = (mw_mirth_c99_ZPlusC99_put(v57, r58));
			STR* v60;
			STRLIT(v60, ", ", 2);
			VAL v61 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v60), v59));
			STR* v62;
			STRLIT(v62, "MKPTR((void*)(", 14);
			VAL v63 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v62), v61));
			VAL v64 = pop_value();
			VAL v65 = (mw_mirth_c99_ZPlusC99_put(v64, v63));
			STR* v66;
			STRLIT(v66, ")));", 4);
			VAL v67 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v66), v65));
			push_resource(v67);
		} break;
		case 4LL: { // FnPtr
			push_value(x1);
			push_u64(x2);
			push_resource(x4);
			VAL v68 = mtp_mirth_type_CType_FnPtr(x3);
			decref(v68);
			STR* v69;
			STRLIT(v69, "lpush(&lbl_", 11);
			VAL r70 = pop_resource();
			VAL v71 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v69), r70));
			uint64_t v72 = pop_u64();
			push_resource(v71);
			uint64_t v73 = mw_mirth_label_Label_name(v72);
			VAL v74 = mw_mirth_name_Name_mangled(v73);
			VAL r75 = pop_resource();
			VAL v76 = (mw_mirth_c99_ZPlusC99_put(v74, r75));
			STR* v77;
			STRLIT(v77, ", ", 2);
			VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v77), v76));
			STR* v79;
			STRLIT(v79, "MKFNPTR((FNPTR)(", 16);
			VAL v80 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v79), v78));
			VAL v81 = pop_value();
			VAL v82 = (mw_mirth_c99_ZPlusC99_put(v81, v80));
			STR* v83;
			STRLIT(v83, ")));", 4);
			VAL v84 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v83), v82));
			push_resource(v84);
		} break;
		case 5LL: { // Phantom
			decref(x1);
			STR* v85;
			STRLIT(v85, "lpush(&lbl_", 11);
			push_u64(x2);
			VAL v86 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v85), x4));
			uint64_t v87 = pop_u64();
			push_resource(v86);
			uint64_t v88 = mw_mirth_label_Label_name(v87);
			VAL v89 = mw_mirth_name_Name_mangled(v88);
			VAL r90 = pop_resource();
			VAL v91 = (mw_mirth_c99_ZPlusC99_put(v89, r90));
			STR* v92;
			STRLIT(v92, ", ", 2);
			VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
			STR* v94;
			STRLIT(v94, "MKI64((int64_t)(0)));", 21);
			VAL v95 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v94), v93));
			push_resource(v95);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
			push_u64(x2);
			push_resource(x4);
		}
	}
	VAL r96 = pop_resource();
	return r96;
}
static void mw_mirth_type_CTypeStackPart_c99Z_argZ_name (int64_t x1, VAL x2, VAL x3) {
	lpush(&lbl_argZ_index, MKI64(x1));
	push_resource(x3);
	VAL v0 = mw_mirth_type_CTypeStackPart_labelZAsk(x2);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			uint64_t v2 = mw_mirth_label_Label_name(VU64(v1));
			VAL v3 = mw_mirth_name_Name_mangled(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			STR* v4;
			STRLIT(v4, "", 0);
			STR* v5;
			STRLIT(v5, "X", 1);
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), MKSTR(v4)));
			int64_t v7 = VI64(lpop(&lbl_argZ_index));
			STR* v8 = i64_show(v7);
			lpush(&lbl_argZ_index, MKI64(v7));
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v8), v6));
			push_value(v9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_type_CTypeStackPart_c99Z_pop (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // CTSPCons
			push_resource(x2);
			VAL v0 = mtp_mirth_type_CTypeStackPart_CTSPCons(x1);
			VAL r1 = pop_resource();
			VAL v2 = (mw_mirth_type_CType_c99Z_popZ_value(v0, r1));
			push_resource(v2);
		} break;
		case 2LL: { // CTSPWith
			push_resource(x2);
			VAL v3 = mtp_mirth_type_CTypeStackPart_CTSPWith(x1);
			VAL r4 = pop_resource();
			VAL v5 = (mw_mirth_type_CType_c99Z_popZ_resource(v3, r4));
			push_resource(v5);
		} break;
		case 1LL: { // CTSPConsLabel
			push_resource(x2);
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x1);
			uint64_t v6 = pop_u64();
			VAL v7 = pop_value();
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_type_CType_c99Z_popZ_label(v6, v7, r8));
			push_resource(v9);
		} break;
		case 3LL: { // CTSPWithLabel
			push_resource(x2);
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x1);
			uint64_t v10 = pop_u64();
			VAL v11 = pop_value();
			VAL r12 = pop_resource();
			VAL v13 = (mw_mirth_type_CType_c99Z_popZ_label(v10, v11, r12));
			push_resource(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r14 = pop_resource();
	return r14;
}
static VAL mw_mirth_type_CTypeStackPart_c99Z_push (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x2)) {
		case 0LL: { // CTSPCons
			push_value(x1);
			push_resource(x3);
			VAL v0 = mtp_mirth_type_CTypeStackPart_CTSPCons(x2);
			VAL r1 = pop_resource();
			VAL v2 = pop_value();
			VAL v3 = (mw_mirth_type_CType_c99Z_pushZ_value(v2, v0, r1));
			push_resource(v3);
		} break;
		case 2LL: { // CTSPWith
			push_value(x1);
			push_resource(x3);
			VAL v4 = mtp_mirth_type_CTypeStackPart_CTSPWith(x2);
			VAL r5 = pop_resource();
			VAL v6 = pop_value();
			VAL v7 = (mw_mirth_type_CType_c99Z_pushZ_resource(v6, v4, r5));
			push_resource(v7);
		} break;
		case 1LL: { // CTSPConsLabel
			push_value(x1);
			push_resource(x3);
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel(x2);
			uint64_t v8 = pop_u64();
			VAL v9 = pop_value();
			VAL r10 = pop_resource();
			VAL v11 = pop_value();
			VAL v12 = (mw_mirth_type_CType_c99Z_pushZ_label(v11, v8, v9, r10));
			push_resource(v12);
		} break;
		case 3LL: { // CTSPWithLabel
			push_value(x1);
			push_resource(x3);
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel(x2);
			uint64_t v13 = pop_u64();
			VAL v14 = pop_value();
			VAL r15 = pop_resource();
			VAL v16 = pop_value();
			VAL v17 = (mw_mirth_type_CType_c99Z_pushZ_label(v16, v13, v14, r15));
			push_resource(v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
			push_resource(x3);
		}
	}
	VAL r18 = pop_resource();
	return r18;
}
static VAL mw_mirth_c99_ZPlusC99_indent (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[2]);
	push_i64(v0);
	push_resource(x1);
	while(1) {
		int64_t v1 = pop_i64();
		int64_t v2 = 0LL;
		bool v3 = (v1 > v2);
		push_i64(v1);
		if (!v3) break;
		int64_t v4 = pop_i64();
		STR* v5;
		STRLIT(v5, "\t", 1);
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_sub(v4, v8);
		push_resource(v7);
		int64_t v10 = mw_std_prim_Int_ZToNat(v9);
		push_i64(v10);
	}
	int64_t v11 = pop_i64();
	VAL r12 = pop_resource();
	return r12;
}
static VAL mw_mirth_c99_c99Z_callZBang (VAL x1, VAL x2, VAL x3) {
	VAL v0 = (mw_mirth_c99_c99Z_argsZ_pushZBang(x1, x3));
	push_value(x2);
	VAL v1 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(v0));
	VAL v2 = (VVAL(VTUP(v1)->cells[1]));
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(v2));
	VAL v4 = pop_value();
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(v4, v3));
	STR* v6;
	STRLIT(v6, "();", 3);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_line(v7));
	VTUP(v1)->cells[1] = v8;
	return v1;
}
static void mw_mirth_c99_C99APIArg_popZ_consumeZBang (VAL x1, VAL x2) {
	push_resource(x2);
	mtp_mirth_c99_C99APIArg_C99APIArg(x1);
	VAL v0 = lpop(&lbl_name);
	decref(v0);
	int64_t v1 = VI64(lpop(&lbl_repr));
	VAL v2 = lpop(&lbl_source);
	switch (get_data_tag(v2)) {
		case 0LL: { // C99AAS_Value
			VAL r3 = pop_resource();
			push_i64(v1);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r3, v1);
			VAL r4 = pop_resource();
			int64_t v5 = pop_i64();
			VAL v6 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v5, r4);
			push_value(v6);
		} break;
		case 2LL: { // C99AAS_Resource
			VAL r7 = pop_resource();
			push_i64(v1);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r7, v1);
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(r8));
			int64_t v10 = pop_i64();
			VAL v11 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v10, v9);
			push_value(v11);
		} break;
		case 1LL: { // C99AAS_ValueLabel
			push_i64(v1);
			push_i64(v1);
			uint64_t v12 = mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v2);
			VAL r13 = pop_resource();
			int64_t v14 = pop_i64();
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v14, v12, r13);
			VAL r15 = pop_resource();
			int64_t v16 = pop_i64();
			VAL v17 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v16, r15);
			push_value(v17);
		} break;
		case 3LL: { // C99AAS_ResourceLabel
			push_i64(v1);
			push_i64(v1);
			uint64_t v18 = mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v2);
			VAL r19 = pop_resource();
			int64_t v20 = pop_i64();
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v20, v18, r19);
			VAL r21 = pop_resource();
			VAL v22 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(r21));
			int64_t v23 = pop_i64();
			VAL v24 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v23, v22);
			push_value(v24);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_i64(v1);
			push_i64(v1);
		}
	}
}
static VAL mw_mirth_c99_C99APIArg_pushZ_toZBang (VAL x1, VAL x2, VAL x3) {
	push_value(x1);
	push_resource(x3);
	mtp_mirth_c99_C99APIArg_C99APIArg(x2);
	VAL v0 = lpop(&lbl_name);
	decref(v0);
	int64_t v1 = VI64(lpop(&lbl_repr));
	VAL v2 = lpop(&lbl_source);
	switch (get_data_tag(v2)) {
		case 0LL: { // C99AAS_Value
			VAL r3 = pop_resource();
			VAL v4 = (VVAL(VTUP(r3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v1));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v4);
			VAL v5 = pop_value();
			VAL r6 = pop_resource();
			int64_t v7 = VI64(lpop(&lbl_localZ_repr));
			VAL v8 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v7, v5));
			push_resource(v8);
			VAL v9 = (mw_mirth_c99_ZPlusC99_indent(r6));
			VAL r10 = pop_resource();
			int64_t v11 = VI64(VTUP(r10)->cells[1]);
			push_resource(r10);
			push_resource(v9);
			VAL v12 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v11);
			VAL r13 = pop_resource();
			VAL v14 = (mw_mirth_c99_ZPlusC99_put(v12, r13));
			STR* v15;
			STRLIT(v15, " ", 1);
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
			VAL r17 = pop_resource();
			VAL v18 = VVAL(VTUP(r17)->cells[2]);
			incref(v18);
			push_resource(r17);
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(v18, v16));
			STR* v20;
			STRLIT(v20, " = ", 3);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
			VAL r22 = pop_resource();
			VAL v23 = pop_value();
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v21));
			STR* v25;
			STRLIT(v25, ";", 1);
			push_resource(r22);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
			VTUP(r3)->cells[1] = v27;
			VAL r28 = pop_resource();
			VAL v29 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r3, r28));
			push_resource(v29);
		} break;
		case 2LL: { // C99AAS_Resource
			VAL r30 = pop_resource();
			VAL v31 = (VVAL(VTUP(r30)->cells[1]));
			lpush(&lbl_localZ_resourceZ_repr, MKI64(v1));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v31);
			VAL v32 = pop_value();
			VAL r33 = pop_resource();
			int64_t v34 = VI64(lpop(&lbl_localZ_resourceZ_repr));
			VAL v35 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v34, v32));
			push_resource(v35);
			VAL v36 = (mw_mirth_c99_ZPlusC99_indent(r33));
			VAL r37 = pop_resource();
			int64_t v38 = VI64(VTUP(r37)->cells[1]);
			push_resource(r37);
			push_resource(v36);
			VAL v39 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v38);
			VAL r40 = pop_resource();
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(v39, r40));
			STR* v42;
			STRLIT(v42, " ", 1);
			VAL v43 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), v41));
			VAL r44 = pop_resource();
			VAL v45 = VVAL(VTUP(r44)->cells[2]);
			incref(v45);
			push_resource(r44);
			VAL v46 = (mw_mirth_c99_ZPlusC99_put(v45, v43));
			STR* v47;
			STRLIT(v47, " = (", 4);
			VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), v46));
			VAL r49 = pop_resource();
			VAL v50 = pop_value();
			VAL v51 = (mw_mirth_c99_ZPlusC99_put(v50, v48));
			STR* v52;
			STRLIT(v52, ");", 2);
			push_resource(r49);
			VAL v53 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v52), v51));
			VAL v54 = (mw_mirth_c99_ZPlusC99_line(v53));
			VTUP(r30)->cells[1] = v54;
			VAL r55 = pop_resource();
			VAL v56 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r30, r55));
			push_resource(v56);
		} break;
		case 1LL: { // C99AAS_ValueLabel
			push_i64(v1);
			uint64_t v57 = mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v2);
			VAL r58 = pop_resource();
			VAL v59 = (VVAL(VTUP(r58)->cells[1]));
			int64_t v60 = pop_i64();
			lpush(&lbl_localZ_repr, MKI64(v60));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v59);
			VAL v61 = pop_value();
			VAL r62 = pop_resource();
			int64_t v63 = VI64(lpop(&lbl_localZ_repr));
			VAL v64 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v63, v61));
			push_resource(v64);
			VAL v65 = (mw_mirth_c99_ZPlusC99_indent(r62));
			VAL r66 = pop_resource();
			int64_t v67 = VI64(VTUP(r66)->cells[1]);
			push_resource(r66);
			push_resource(v65);
			VAL v68 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v67);
			VAL r69 = pop_resource();
			VAL v70 = (mw_mirth_c99_ZPlusC99_put(v68, r69));
			STR* v71;
			STRLIT(v71, " ", 1);
			VAL v72 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v71), v70));
			VAL r73 = pop_resource();
			VAL v74 = VVAL(VTUP(r73)->cells[2]);
			incref(v74);
			push_resource(r73);
			VAL v75 = (mw_mirth_c99_ZPlusC99_put(v74, v72));
			STR* v76;
			STRLIT(v76, " = ", 3);
			VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v76), v75));
			VAL r78 = pop_resource();
			VAL v79 = pop_value();
			VAL v80 = (mw_mirth_c99_ZPlusC99_put(v79, v77));
			STR* v81;
			STRLIT(v81, ";", 1);
			push_resource(r78);
			VAL v82 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v81), v80));
			VAL v83 = (mw_mirth_c99_ZPlusC99_line(v82));
			VTUP(r58)->cells[1] = v83;
			VAL r84 = pop_resource();
			push_resource(r58);
			push_resource(r84);
			push_u64(v57);
			int64_t v85 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v57);
			if (((bool)v85)) {
				VAL r86 = pop_resource();
				VAL v87 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(r86));
				VAL r88 = pop_resource();
				uint64_t v89 = pop_u64();
				VAL v90 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v89, r88, v87));
				push_resource(v90);
			} else {
				VAL r91 = pop_resource();
				VAL r92 = pop_resource();
				uint64_t v93 = pop_u64();
				VAL v94 = (mw_mirth_c99_pushZ_localZ_labelZBang(v93, r92, r91));
				push_resource(v94);
			}
		} break;
		case 3LL: { // C99AAS_ResourceLabel
			push_i64(v1);
			uint64_t v95 = mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v2);
			VAL r96 = pop_resource();
			VAL v97 = (VVAL(VTUP(r96)->cells[1]));
			int64_t v98 = pop_i64();
			lpush(&lbl_localZ_repr, MKI64(v98));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v97);
			VAL v99 = pop_value();
			VAL r100 = pop_resource();
			int64_t v101 = VI64(lpop(&lbl_localZ_repr));
			VAL v102 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v101, v99));
			push_resource(v102);
			VAL v103 = (mw_mirth_c99_ZPlusC99_indent(r100));
			VAL r104 = pop_resource();
			int64_t v105 = VI64(VTUP(r104)->cells[1]);
			push_resource(r104);
			push_resource(v103);
			VAL v106 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v105);
			VAL r107 = pop_resource();
			VAL v108 = (mw_mirth_c99_ZPlusC99_put(v106, r107));
			STR* v109;
			STRLIT(v109, " ", 1);
			VAL v110 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v109), v108));
			VAL r111 = pop_resource();
			VAL v112 = VVAL(VTUP(r111)->cells[2]);
			incref(v112);
			push_resource(r111);
			VAL v113 = (mw_mirth_c99_ZPlusC99_put(v112, v110));
			STR* v114;
			STRLIT(v114, " = ", 3);
			VAL v115 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v114), v113));
			VAL r116 = pop_resource();
			VAL v117 = pop_value();
			VAL v118 = (mw_mirth_c99_ZPlusC99_put(v117, v115));
			STR* v119;
			STRLIT(v119, ";", 1);
			push_resource(r116);
			VAL v120 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v119), v118));
			VAL v121 = (mw_mirth_c99_ZPlusC99_line(v120));
			VTUP(r96)->cells[1] = v121;
			VAL r122 = pop_resource();
			push_resource(r96);
			push_resource(r122);
			push_u64(v95);
			int64_t v123 = mw_mirth_label_Label_isZ_resourceZ_labelZAsk(v95);
			if (((bool)v123)) {
				VAL r124 = pop_resource();
				VAL v125 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(r124));
				VAL r126 = pop_resource();
				uint64_t v127 = pop_u64();
				VAL v128 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v127, r126, v125));
				push_resource(v128);
			} else {
				VAL r129 = pop_resource();
				VAL r130 = pop_resource();
				uint64_t v131 = pop_u64();
				VAL v132 = (mw_mirth_c99_pushZ_localZ_labelZBang(v131, r130, r129));
				push_resource(v132);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_i64(v1);
		}
	}
	VAL r133 = pop_resource();
	return r133;
}
static VAL mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang (VAL x1, VAL x2) {
	push_resource(x2);
	mtp_mirth_c99_C99APIArg_C99APIArg(x1);
	VAL v0 = lpop(&lbl_name);
	int64_t v1 = VI64(lpop(&lbl_repr));
	VAL v2 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v1, v0));
	VAL v3 = lpop(&lbl_source);
	switch (get_data_tag(v3)) {
		case 0LL: { // C99AAS_Value
			VAL r4 = pop_resource();
			VAL v5 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r4, v2));
			push_resource(v5);
		} break;
		case 1LL: { // C99AAS_ValueLabel
			push_resource(v2);
			uint64_t v6 = mtp_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v3);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_c99_pushZ_localZ_labelZBang(v6, r8, r7));
			push_resource(v9);
		} break;
		case 2LL: { // C99AAS_Resource
			VAL v10 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(v2));
			VAL r11 = pop_resource();
			VAL v12 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r11, v10));
			push_resource(v12);
		} break;
		case 3LL: { // C99AAS_ResourceLabel
			push_resource(v2);
			uint64_t v13 = mtp_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v3);
			VAL r14 = pop_resource();
			push_u64(v13);
			VAL v15 = (mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang(r14));
			VAL r16 = pop_resource();
			uint64_t v17 = pop_u64();
			VAL v18 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v17, r16, v15));
			push_resource(v18);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(v2);
		}
	}
	VAL r19 = pop_resource();
	return r19;
}
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v0 = 0LL /* False */;
			int64_t v1 = 0LL /* Nil */;
			push_resource(x2);
			push_i64(v0);
			push_i64(v1);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v2 = 1LL /* True */;
			int64_t v3 = 0LL /* Nil */;
			push_resource(x2);
			push_i64(v2);
			push_i64(v3);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v4 = 1LL /* True */;
			int64_t v5 = 0LL /* Nil */;
			push_resource(x2);
			push_i64(v4);
			push_i64(v5);
		} break;
		case 4LL: { // STMeta
			push_resource(x2);
			uint64_t v6 = mtp_mirth_type_StackType_STMeta(x1);
			push_u64(v6);
			VAL v7 = mw_mirth_type_MetaVar_typeZAsk(v6);
			switch (get_data_tag(v7)) {
				case 0LL: { // None
					uint64_t v8 = pop_u64();
					int64_t v9 = 1LL /* True */;
					int64_t v10 = 0LL /* Nil */;
					push_i64(v9);
					push_i64(v10);
				} break;
				case 1LL: { // Some
					VAL v11 = mtp_std_maybe_Maybe_1_Some(v7);
					VAL v12 = mw_mirth_type_Type_expand(v11);
					incref(v12);
					VAL v13 = pop_value();
					push_value(v12);
					push_value(v13);
					VAL v14 = mtw_std_maybe_Maybe_1_Some(v12);
					uint64_t v15 = pop_u64();
					void* v16 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v15);
					mut_set(v14, MKPTR(v16));
					VAL v17 = pop_value();
					VAL v18 = mw_mirth_type_Type_ZToStackType(v17);
					VAL r19 = pop_resource();
					mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v18, r19);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 3LL: { // STVar
			push_resource(x2);
			uint64_t v20 = mtp_mirth_type_StackType_STVar(x1);
			int64_t v21 = 1LL /* True */;
			int64_t v22 = 0LL /* Nil */;
			push_i64(v21);
			push_i64(v22);
		} break;
		case 5LL: { // STCons
			push_resource(x2);
			mtp_mirth_type_StackType_STCons(x1);
			int64_t v23 = 0LL /* C99AAS_Value */;
			VAL r24 = pop_resource();
			VAL v25 = (VVAL(VTUP(r24)->cells[6]));
			VAL v26 = pop_value();
			lpush(&lbl_source, MKI64(v23));
			mw_mirth_type_Type_c99Z_repr(v26, v25);
			VAL r27 = pop_resource();
			VTUP(r24)->cells[6] = r27;
			int64_t v28 = pop_i64();
			VAL v29 = pop_value();
			lpush(&lbl_repr, MKI64(v28));
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v29, r24);
			VAL r30 = pop_resource();
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(r30);
			VAL v31 = pop_value();
			int64_t v32 = VI64(lpop(&lbl_repr));
			VAL v33 = lpop(&lbl_source);
			VAL v34 = mtw_mirth_c99_C99APIArg_C99APIArg(v33, v32, v31);
			VAL v35 = pop_value();
			VAL v36 = mtw_std_list_List_1_Cons(v34, v35);
			push_value(v36);
		} break;
		case 7LL: { // STWith
			push_resource(x2);
			mtp_mirth_type_StackType_STWith(x1);
			int64_t v37 = 2LL /* C99AAS_Resource */;
			VAL r38 = pop_resource();
			VAL v39 = (VVAL(VTUP(r38)->cells[6]));
			VAL v40 = pop_value();
			lpush(&lbl_source, MKI64(v37));
			mw_mirth_type_Resource_c99Z_repr(v40, v39);
			VAL r41 = pop_resource();
			VTUP(r38)->cells[6] = r41;
			int64_t v42 = pop_i64();
			VAL v43 = pop_value();
			lpush(&lbl_repr, MKI64(v42));
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v43, r38);
			VAL r44 = pop_resource();
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(r44);
			VAL v45 = pop_value();
			int64_t v46 = VI64(lpop(&lbl_repr));
			VAL v47 = lpop(&lbl_source);
			VAL v48 = mtw_mirth_c99_C99APIArg_C99APIArg(v47, v46, v45);
			VAL v49 = pop_value();
			VAL v50 = mtw_std_list_List_1_Cons(v48, v49);
			push_value(v50);
		} break;
		case 6LL: { // STConsLabel
			push_resource(x2);
			mtp_mirth_type_StackType_STConsLabel(x1);
			uint64_t v51 = pop_u64();
			VAL v52 = mtw_mirth_c99_C99APIArgSource_C99AASz_ValueLabel(v51);
			VAL r53 = pop_resource();
			VAL v54 = (VVAL(VTUP(r53)->cells[6]));
			VAL v55 = pop_value();
			lpush(&lbl_source, v52);
			mw_mirth_type_Type_c99Z_repr(v55, v54);
			VAL r56 = pop_resource();
			VTUP(r53)->cells[6] = r56;
			int64_t v57 = pop_i64();
			VAL v58 = pop_value();
			lpush(&lbl_repr, MKI64(v57));
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v58, r53);
			VAL r59 = pop_resource();
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(r59);
			VAL v60 = pop_value();
			int64_t v61 = VI64(lpop(&lbl_repr));
			VAL v62 = lpop(&lbl_source);
			VAL v63 = mtw_mirth_c99_C99APIArg_C99APIArg(v62, v61, v60);
			VAL v64 = pop_value();
			VAL v65 = mtw_std_list_List_1_Cons(v63, v64);
			push_value(v65);
		} break;
		case 8LL: { // STWithLabel
			push_resource(x2);
			mtp_mirth_type_StackType_STWithLabel(x1);
			uint64_t v66 = pop_u64();
			VAL v67 = mtw_mirth_c99_C99APIArgSource_C99AASz_ResourceLabel(v66);
			VAL r68 = pop_resource();
			VAL v69 = (VVAL(VTUP(r68)->cells[6]));
			VAL v70 = pop_value();
			lpush(&lbl_source, v67);
			mw_mirth_type_Resource_c99Z_repr(v70, v69);
			VAL r71 = pop_resource();
			VTUP(r68)->cells[6] = r71;
			int64_t v72 = pop_i64();
			VAL v73 = pop_value();
			lpush(&lbl_repr, MKI64(v72));
			mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(v73, r68);
			VAL r74 = pop_resource();
			mw_mirth_c99_ZPlusC99_freshZ_argZ_nameZBang(r74);
			VAL v75 = pop_value();
			int64_t v76 = VI64(lpop(&lbl_repr));
			VAL v77 = lpop(&lbl_source);
			VAL v78 = mtw_mirth_c99_C99APIArg_C99APIArg(v77, v76, v75);
			VAL v79 = pop_value();
			VAL v80 = mtw_std_list_List_1_Cons(v78, v79);
			push_value(v80);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
}
static void mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params (VAL x1, VAL x2) {
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_paramsZ_aux(x1, x2);
	VAL v0 = pop_value();
	VAL v1 = mw_std_list_List_1_reverse(v0);
	push_value(v1);
}
static void mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api (VAL x1, VAL x2, VAL x3) {
	int64_t v0 = 1LL;
	push_resource(x3);
	lpush(&lbl_type, x2);
	lpush(&lbl_cname, x1);
	int64_t v1 = mw_std_prim_Int_ZToNat(v0);
	VAL r2 = pop_resource();
	int64_t v3 = VI64(VTUP(r2)->cells[3]);
	VTUP(r2)->cells[3] = MKI64(v1);
	VAL v4 = lpop(&lbl_type);
	incref(v4);
	push_resource(r2);
	lpush(&lbl_type, v4);
	VAL v5 = mw_mirth_type_ArrowType_dom(v4);
	VAL r6 = pop_resource();
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params(v5, r6);
	VAL v7 = pop_value();
	VAL v8 = lpop(&lbl_type);
	incref(v8);
	lpush(&lbl_inZ_params, v7);
	lpush(&lbl_type, v8);
	VAL v9 = mw_mirth_type_ArrowType_cod(v8);
	VAL r10 = pop_resource();
	mw_mirth_c99_ZPlusC99_stackZ_typeZ_toZ_c99Z_apiZ_params(v9, r10);
	VAL v11 = pop_value();
	incref(v11);
	push_value(v11);
	VAL v12 = mw_std_list_List_1_ZDivL1(v11);
	incref(v12);
	switch (get_data_tag(v12)) {
		case 1LL: { // Some
			lpush(&lbl_returnZ_param, v12);
			VAL v13 = mtp_std_maybe_Maybe_1_Some(v12);
			decref(v13);
			VAL v14 = pop_value();
			decref(v14);
			int64_t v15 = 0LL /* Nil */;
			push_i64(v15);
		} break;
		case 0LL: { // None
			lpush(&lbl_returnZ_param, v12);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			lpush(&lbl_returnZ_param, v12);
		}
	}
	VAL v16 = pop_value();
	VAL r17 = pop_resource();
	int64_t v18 = VI64(VTUP(r17)->cells[3]);
	VTUP(r17)->cells[3] = MKI64(v3);
	bool v19 = pop_bool();
	bool v20 = pop_bool();
	bool v21 = (v20 || v19);
	VAL v22 = lpop(&lbl_returnZ_param);
	VAL v23 = lpop(&lbl_inZ_params);
	VAL v24 = lpop(&lbl_type);
	VAL v25 = lpop(&lbl_cname);
	push_resource(r17);
	VAL v26 = mtw_mirth_c99_C99API_C99API(v25, v24, v23, v16, v22, ((int64_t)v21));
	push_value(v26);
}
static VAL mw_mirth_c99_c99Z_smartZ_callZBang (VAL x1, VAL x2, VAL x3) {
	lpush(&lbl_api, x2);
	VAL v0 = (mw_mirth_c99_c99Z_argsZ_pushZBang(x1, x3));
	VAL v1 = lpop(&lbl_api);
	incref(v1);
	VAL v2 = VVAL(VTUP(v1)->cells[3]);
	incref(v2);
	decref(v1);
	push_resource(v0);
	lpush(&lbl_api, v1);
	VAL v3 = mw_std_list_List_1_reverse(v2);
	int64_t v4 = 0LL /* Nil */;
	push_value(v3);
	VAL v5 = mw_std_list_List_1_reverse(MKI64(v4));
	VAL v6 = pop_value();
	push_resource(v5);
	mw_std_list_List_1_uncons(v6);
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	while(1) {
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		int64_t v10 = mw_std_maybe_Maybe_1_someZAsk(v9);
		if (!((bool)v10)) break;
		VAL v11 = pop_value();
		VAL v12 = mw_std_maybe_Maybe_1_unwrap(v11);
		VAL v13 = pop_value();
		VAL r14 = pop_resource();
		VAL r15 = pop_resource();
		mw_mirth_c99_C99APIArg_popZ_consumeZBang(v12, r15);
		VAL v16 = pop_value();
		VAL v17 = mtw_std_list_List_1_Cons(v16, r14);
		push_resource(v17);
		mw_std_list_List_1_uncons(v13);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL r22 = pop_resource();
	VAL v23 = mw_std_list_List_1_reverse(r22);
	VAL v24 = mw_std_list_List_1_reverse(v23);
	VAL r25 = pop_resource();
	lpush(&lbl_poppedZ_inputs, v24);
	VAL v26 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(r25));
	STR* v27;
	STRLIT(v27, "", 0);
	VAL v28 = lpop(&lbl_api);
	incref(v28);
	VAL v29 = VVAL(VTUP(v28)->cells[1]);
	incref(v29);
	decref(v28);
	push_resource(v26);
	lpush(&lbl_api, v28);
	VAL v30 = (mw_std_str_ZPlusStr_pushZ_strZBang(v29, MKSTR(v27)));
	STR* v31;
	STRLIT(v31, "(", 1);
	VAL v32 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v31), v30));
	STR* v33;
	STRLIT(v33, "", 0);
	VAL v34 = lpop(&lbl_poppedZ_inputs);
	push_resource(v32);
	lpush(&lbl_sep, MKSTR(v33));
	mw_std_list_List_1_uncons(v34);
	VAL v35 = pop_value();
	VAL v36 = pop_value();
	push_value(v35);
	push_value(v36);
	while(1) {
		VAL v37 = pop_value();
		incref(v37);
		push_value(v37);
		int64_t v38 = mw_std_maybe_Maybe_1_someZAsk(v37);
		if (!((bool)v38)) break;
		VAL v39 = pop_value();
		VAL v40 = mw_std_maybe_Maybe_1_unwrap(v39);
		VAL v41 = pop_value();
		VAL v42 = lpop(&lbl_sep);
		VAL r43 = pop_resource();
		push_value(v40);
		VAL v44 = (mw_std_str_ZPlusStr_pushZ_strZBang(v42, r43));
		STR* v45;
		STRLIT(v45, ", ", 2);
		VAL v46 = pop_value();
		lpush(&lbl_sep, MKSTR(v45));
		VAL v47 = (mw_std_str_ZPlusStr_pushZ_strZBang(v46, v44));
		push_resource(v47);
		mw_std_list_List_1_uncons(v41);
		VAL v48 = pop_value();
		VAL v49 = pop_value();
		push_value(v48);
		push_value(v49);
	}
	VAL v50 = pop_value();
	decref(v50);
	VAL v51 = pop_value();
	decref(v51);
	VAL v52 = lpop(&lbl_sep);
	decref(v52);
	STR* v53;
	STRLIT(v53, ")", 1);
	VAL r54 = pop_resource();
	VAL v55 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v53), r54));
	VAL v56 = lpop(&lbl_api);
	incref(v56);
	VAL v57 = VVAL(VTUP(v56)->cells[5]);
	incref(v57);
	decref(v56);
	switch (get_data_tag(v57)) {
		case 1LL: { // Some
			push_value(v55);
			lpush(&lbl_api, v56);
			VAL v58 = mtp_std_maybe_Maybe_1_Some(v57);
			VAL r59 = pop_resource();
			VAL v60 = pop_value();
			VAL v61 = (mw_mirth_c99_C99APIArg_pushZ_toZBang(v60, v58, r59));
			push_resource(v61);
		} break;
		case 0LL: { // None
			VAL r62 = pop_resource();
			VAL v63 = (VVAL(VTUP(r62)->cells[1]));
			push_value(v55);
			lpush(&lbl_api, v56);
			VAL v64 = (mw_mirth_c99_ZPlusC99_indent(v63));
			VAL v65 = pop_value();
			VAL v66 = (mw_mirth_c99_ZPlusC99_put(v65, v64));
			STR* v67;
			STRLIT(v67, ";", 1);
			VAL v68 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v67), v66));
			VAL v69 = (mw_mirth_c99_ZPlusC99_line(v68));
			VTUP(r62)->cells[1] = v69;
			push_resource(r62);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(v55);
			lpush(&lbl_api, v56);
		}
	}
	VAL v70 = lpop(&lbl_api);
	decref(v70);
	VAL r71 = pop_resource();
	return r71;
}
static VAL mw_mirth_c99_ZPlusC99_smartZ_sigZ_put (VAL x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "static ", 7);
	lpush(&lbl_api, x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	VAL v2 = lpop(&lbl_api);
	incref(v2);
	VAL v3 = VVAL(VTUP(v2)->cells[5]);
	incref(v3);
	decref(v2);
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			push_resource(v1);
			lpush(&lbl_api, v2);
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			int64_t v5 = VI64(VTUP(v4)->cells[2]);
			decref(v4);
			VAL v6 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v5);
			VAL r7 = pop_resource();
			VAL v8 = (mw_mirth_c99_ZPlusC99_put(v6, r7));
			push_resource(v8);
		} break;
		case 0LL: { // None
			STR* v9;
			STRLIT(v9, "void", 4);
			lpush(&lbl_api, v2);
			VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v1));
			push_resource(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(v1);
			lpush(&lbl_api, v2);
		}
	}
	STR* v11;
	STRLIT(v11, " ", 1);
	VAL r12 = pop_resource();
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), r12));
	VAL v14 = lpop(&lbl_api);
	incref(v14);
	VAL v15 = VVAL(VTUP(v14)->cells[1]);
	incref(v15);
	decref(v14);
	lpush(&lbl_api, v14);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v13));
	STR* v17;
	STRLIT(v17, " (", 2);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	STR* v19;
	STRLIT(v19, "", 0);
	VAL v20 = lpop(&lbl_api);
	incref(v20);
	VAL v21 = VVAL(VTUP(v20)->cells[3]);
	incref(v21);
	decref(v20);
	push_resource(v18);
	lpush(&lbl_sep, MKSTR(v19));
	lpush(&lbl_api, v20);
	mw_std_list_List_1_uncons(v21);
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	push_value(v22);
	push_value(v23);
	while(1) {
		VAL v24 = pop_value();
		incref(v24);
		push_value(v24);
		int64_t v25 = mw_std_maybe_Maybe_1_someZAsk(v24);
		if (!((bool)v25)) break;
		VAL v26 = pop_value();
		VAL v27 = mw_std_maybe_Maybe_1_unwrap(v26);
		VAL v28 = pop_value();
		VAL v29 = lpop(&lbl_sep);
		VAL r30 = pop_resource();
		push_value(v27);
		VAL v31 = (mw_mirth_c99_ZPlusC99_put(v29, r30));
		STR* v32;
		STRLIT(v32, ", ", 2);
		VAL v33 = pop_value();
		incref(v33);
		int64_t v34 = VI64(VTUP(v33)->cells[2]);
		decref(v33);
		push_resource(v31);
		lpush(&lbl_sep, MKSTR(v32));
		push_value(v33);
		VAL v35 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v34);
		VAL r36 = pop_resource();
		VAL v37 = (mw_mirth_c99_ZPlusC99_put(v35, r36));
		STR* v38;
		STRLIT(v38, " ", 1);
		VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
		VAL v40 = pop_value();
		VAL v41 = VVAL(VTUP(v40)->cells[3]);
		incref(v41);
		decref(v40);
		VAL v42 = (mw_mirth_c99_ZPlusC99_put(v41, v39));
		push_resource(v42);
		mw_std_list_List_1_uncons(v28);
		VAL v43 = pop_value();
		VAL v44 = pop_value();
		push_value(v43);
		push_value(v44);
	}
	VAL v45 = pop_value();
	decref(v45);
	VAL v46 = pop_value();
	decref(v46);
	VAL v47 = lpop(&lbl_sep);
	uint64_t v48 = str_size(VSTR(v47));
	int64_t v49 = mw_std_prim_Int_ZToNat(((int64_t)v48));
	int64_t v50 = 0LL;
	bool v51 = (v49 == v50);
	if (v51) {
		STR* v52;
		STRLIT(v52, "void", 4);
		VAL r53 = pop_resource();
		VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v52), r53));
		push_resource(v54);
	} else {
	}
	STR* v55;
	STRLIT(v55, ")", 1);
	VAL r56 = pop_resource();
	VAL v57 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v55), r56));
	VAL v58 = lpop(&lbl_api);
	decref(v58);
	return v57;
}
static VAL mw_mirth_c99_c99Z_smartZ_sigZBang (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99_indent(x2));
	VAL v1 = pop_value();
	VAL v2 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v1, v0));
	STR* v3;
	STRLIT(v3, ";", 1);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), v2));
	VAL v5 = (mw_mirth_c99_ZPlusC99_line(v4));
	return v5;
}
static VAL mw_mirth_c99_c99Z_apiZ_enterZBang (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang(x2));
	VAL v1 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v0));
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = VVAL(VTUP(v2)->cells[3]);
	incref(v3);
	decref(v2);
	push_resource(v1);
	lpush(&lbl_api, v2);
	mw_std_list_List_1_uncons(v3);
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		int64_t v7 = mw_std_maybe_Maybe_1_someZAsk(v6);
		if (!((bool)v7)) break;
		VAL v8 = pop_value();
		VAL v9 = mw_std_maybe_Maybe_1_unwrap(v8);
		VAL v10 = pop_value();
		VAL r11 = pop_resource();
		VAL v12 = (mw_mirth_c99_C99APIArg_pushZ_asZ_localZBang(v9, r11));
		push_resource(v12);
		mw_std_list_List_1_uncons(v10);
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		push_value(v13);
		push_value(v14);
	}
	VAL v15 = pop_value();
	decref(v15);
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = lpop(&lbl_api);
	decref(v17);
	VAL r18 = pop_resource();
	return r18;
}
static VAL mw_mirth_c99_c99Z_apiZ_exitZBang (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x1)->cells[5]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 1LL: { // Some
			push_resource(x2);
			VAL v1 = mtp_std_maybe_Maybe_1_Some(v0);
			VAL r2 = pop_resource();
			mw_mirth_c99_C99APIArg_popZ_consumeZBang(v1, r2);
			VAL r3 = pop_resource();
			VAL v4 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(r3));
			VAL v5 = (mw_mirth_c99_ZPlusC99_indent(v4));
			STR* v6;
			STRLIT(v6, "return ", 7);
			VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
			VAL v8 = pop_value();
			VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
			STR* v10;
			STRLIT(v10, ";", 1);
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
			VAL v12 = (mw_mirth_c99_ZPlusC99_line(v11));
			push_resource(v12);
		} break;
		case 0LL: { // None
			VAL v13 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x2));
			push_resource(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r14 = pop_resource();
	return r14;
}
static VAL mw_mirth_c99_c99Z_arrowZBang (VAL x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	mw_std_list_List_1_uncons(v0);
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		int64_t v4 = mw_std_maybe_Maybe_1_someZAsk(v3);
		if (!((bool)v4)) break;
		VAL v5 = pop_value();
		VAL v6 = mw_std_maybe_Maybe_1_unwrap(v5);
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		VAL v9 = (mw_mirth_c99_c99Z_atomZBang(v6, r8));
		push_resource(v9);
		mw_std_list_List_1_uncons(v7);
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
	VAL r14 = pop_resource();
	return r14;
}
static VAL mw_mirth_c99_c99Z_atomZBang (VAL x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	VTUP(x2)->cells[1] = v0;
	int64_t v2 = VI64(VTUP(v1)->cells[2]);
	decref(v1);
	if (((bool)v2)) {
		incref(x1);
		push_resource(x2);
		push_value(x1);
		int64_t v3 = mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk(x1);
		push_i64(v3);
	} else {
		int64_t v4 = 0LL /* False */;
		push_value(x1);
		push_resource(x2);
		push_i64(v4);
	}
	bool v5 = pop_bool();
	if (v5) {
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[1]));
		VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v7));
		STR* v9;
		STRLIT(v9, "WORD_ATOM(", 10);
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
		VAL v11 = pop_value();
		incref(v11);
		uint64_t v12 = VU64(VTUP(v11)->cells[2]);
		decref(v11);
		push_resource(v10);
		push_value(v11);
		int64_t v13 = mw_mirth_token_Token_row(v12);
		int64_t v14 = mw_mirth_location_Row_ZToInt(v13);
		STR* v15 = i64_show(v14);
		VAL r16 = pop_resource();
		VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), r16));
		STR* v18;
		STRLIT(v18, ", ", 2);
		VAL v19 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v18), v17));
		VAL v20 = pop_value();
		incref(v20);
		uint64_t v21 = VU64(VTUP(v20)->cells[2]);
		decref(v20);
		push_resource(v19);
		push_value(v20);
		int64_t v22 = mw_mirth_token_Token_col(v21);
		int64_t v23 = mw_mirth_location_Col_ZToInt(v22);
		STR* v24 = i64_show(v23);
		VAL r25 = pop_resource();
		VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v24), r25));
		STR* v27;
		STRLIT(v27, ", ", 2);
		VAL v28 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v27), v26));
		VAL v29 = pop_value();
		incref(v29);
		uint64_t v30 = VU64(VTUP(v29)->cells[2]);
		decref(v29);
		push_resource(v28);
		push_value(v29);
		VAL v31 = mw_mirth_token_Token_nameZAsk(v30);
		switch (get_data_tag(v31)) {
			case 1LL: { // Some
				VAL v32 = mtp_std_maybe_Maybe_1_Some(v31);
				VAL v33 = mw_mirth_name_Name_ZToStr(VU64(v32));
				push_value(v33);
			} break;
			case 0LL: { // None
				STR* v34;
				STRLIT(v34, "", 0);
				push_str(v34);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL r35 = pop_resource();
		VAL v36 = pop_value();
		VAL v37 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v36, r35));
		STR* v38;
		STRLIT(v38, ");", 2);
		VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
		VAL v40 = (mw_mirth_c99_ZPlusC99_line(v39));
		VTUP(r6)->cells[1] = v40;
		push_resource(r6);
	} else {
	}
	VAL v41 = pop_value();
	incref(v41);
	VAL v42 = VVAL(VTUP(v41)->cells[4]);
	incref(v42);
	decref(v41);
	VAL r43 = pop_resource();
	VAL v44 = (mw_mirth_c99_c99Z_atomZ_opZBang(v41, v42, r43));
	return v44;
}
static int64_t mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk (VAL x1) {
	VAL v0 = VVAL(VTUP(x1)->cells[4]);
	incref(v0);
	decref(x1);
	switch (get_data_tag(v0)) {
		case 0LL: { // OpNone
			int64_t v1 = 0LL /* False */;
			push_i64(v1);
		} break;
		case 7LL: { // OpInt
			int64_t v2 = mtp_mirth_arrow_Op_OpInt(v0);
			int64_t v3 = 0LL /* False */;
			push_i64(v3);
		} break;
		case 8LL: { // OpF64
			double v4 = mtp_mirth_arrow_Op_OpF64(v0);
			int64_t v5 = 0LL /* False */;
			push_i64(v5);
		} break;
		case 9LL: { // OpStr
			VAL v6 = mtp_mirth_arrow_Op_OpStr(v0);
			decref(v6);
			int64_t v7 = 0LL /* False */;
			push_i64(v7);
		} break;
		case 2LL: { // OpWord
			uint64_t v8 = mtp_mirth_arrow_Op_OpWord(v0);
			int64_t v9 = mw_mirth_word_Word_preferZ_inlineZAsk(v8);
			bool v10 = !((bool)v9);
			push_bool(v10);
		} break;
		case 3LL: { // OpExternal
			uint64_t v11 = mtp_mirth_arrow_Op_OpExternal(v0);
			int64_t v12 = 1LL /* True */;
			push_i64(v12);
		} break;
		case 4LL: { // OpBuffer
			uint64_t v13 = mtp_mirth_arrow_Op_OpBuffer(v0);
			int64_t v14 = 0LL /* False */;
			push_i64(v14);
		} break;
		case 5LL: { // OpVariable
			uint64_t v15 = mtp_mirth_arrow_Op_OpVariable(v0);
			int64_t v16 = 0LL /* False */;
			push_i64(v16);
		} break;
		case 6LL: { // OpField
			uint64_t v17 = mtp_mirth_arrow_Op_OpField(v0);
			int64_t v18 = 0LL /* False */;
			push_i64(v18);
		} break;
		case 10LL: { // OpTag
			uint64_t v19 = mtp_mirth_arrow_Op_OpTag(v0);
			int64_t v20 = mw_mirth_data_Tag_preferZ_inlineZAsk(v19);
			bool v21 = !((bool)v20);
			push_bool(v21);
		} break;
		case 1LL: { // OpPrim
			int64_t v22 = mtp_mirth_arrow_Op_OpPrim(v0);
			int64_t v23 = 1LL /* True */;
			push_i64(v23);
		} break;
		case 11LL: { // OpMatch
			VAL v24 = mtp_mirth_arrow_Op_OpMatch(v0);
			decref(v24);
			int64_t v25 = 0LL /* False */;
			push_i64(v25);
		} break;
		case 12LL: { // OpLambda
			VAL v26 = mtp_mirth_arrow_Op_OpLambda(v0);
			decref(v26);
			int64_t v27 = 0LL /* False */;
			push_i64(v27);
		} break;
		case 13LL: { // OpVar
			uint64_t v28 = mtp_mirth_arrow_Op_OpVar(v0);
			int64_t v29 = 0LL /* False */;
			push_i64(v29);
		} break;
		case 14LL: { // OpBlockPush
			uint64_t v30 = mtp_mirth_arrow_Op_OpBlockPush(v0);
			int64_t v31 = 0LL /* False */;
			push_i64(v31);
		} break;
		case 15LL: { // OpBlockRun
			uint64_t v32 = mtp_mirth_arrow_Op_OpBlockRun(v0);
			int64_t v33 = 0LL /* False */;
			push_i64(v33);
		} break;
		case 16LL: { // OpCoerce
			VAL v34 = mtp_mirth_arrow_Op_OpCoerce(v0);
			decref(v34);
			int64_t v35 = 0LL /* False */;
			push_i64(v35);
		} break;
		case 17LL: { // OpLabelPush
			uint64_t v36 = mtp_mirth_arrow_Op_OpLabelPush(v0);
			int64_t v37 = 0LL /* False */;
			push_i64(v37);
		} break;
		case 18LL: { // OpLabelPop
			uint64_t v38 = mtp_mirth_arrow_Op_OpLabelPop(v0);
			int64_t v39 = 0LL /* False */;
			push_i64(v39);
		} break;
		case 19LL: { // OpLabelPushR
			uint64_t v40 = mtp_mirth_arrow_Op_OpLabelPushR(v0);
			int64_t v41 = 0LL /* False */;
			push_i64(v41);
		} break;
		case 20LL: { // OpLabelPopR
			uint64_t v42 = mtp_mirth_arrow_Op_OpLabelPopR(v0);
			int64_t v43 = 0LL /* False */;
			push_i64(v43);
		} break;
		case 21LL: { // OpDataGetTag
			uint64_t v44 = mtp_mirth_arrow_Op_OpDataGetTag(v0);
			int64_t v45 = 0LL /* False */;
			push_i64(v45);
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel(v0);
			VAL v46 = pop_value();
			decref(v46);
			VAL v47 = pop_value();
			decref(v47);
			int64_t v48 = 0LL /* False */;
			push_i64(v48);
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel(v0);
			VAL v49 = pop_value();
			decref(v49);
			VAL v50 = pop_value();
			decref(v50);
			int64_t v51 = 0LL /* False */;
			push_i64(v51);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v52 = pop_i64();
	return v52;
}
static VAL mw_mirth_c99_c99Z_atomZ_opZBang (VAL x1, VAL x2, VAL x3) {
	switch (get_data_tag(x2)) {
		case 0LL: { // OpNone
			decref(x1);
			push_resource(x3);
		} break;
		case 7LL: { // OpInt
			push_value(x1);
			push_resource(x3);
			int64_t v0 = mtp_mirth_arrow_Op_OpInt(x2);
			VAL v1 = pop_value();
			decref(v1);
			VAL r2 = pop_resource();
			VAL v3 = (mw_mirth_c99_c99Z_intZBang(v0, r2));
			push_resource(v3);
		} break;
		case 8LL: { // OpF64
			push_value(x1);
			push_resource(x3);
			double v4 = mtp_mirth_arrow_Op_OpF64(x2);
			VAL v5 = pop_value();
			decref(v5);
			VAL r6 = pop_resource();
			VAL v7 = (mw_mirth_c99_c99Z_f64ZBang(v4, r6));
			push_resource(v7);
		} break;
		case 9LL: { // OpStr
			push_value(x1);
			push_resource(x3);
			VAL v8 = mtp_mirth_arrow_Op_OpStr(x2);
			VAL v9 = pop_value();
			decref(v9);
			VAL r10 = pop_resource();
			VAL v11 = (mw_mirth_c99_c99Z_strZBang(v8, r10));
			push_resource(v11);
		} break;
		case 2LL: { // OpWord
			push_value(x1);
			push_resource(x3);
			uint64_t v12 = mtp_mirth_arrow_Op_OpWord(x2);
			VAL v13 = pop_value();
			VAL v14 = VVAL(VTUP(v13)->cells[5]);
			incref(v14);
			decref(v13);
			VAL r15 = pop_resource();
			VAL v16 = (mw_mirth_c99_c99Z_wordZBang(v14, v12, r15));
			push_resource(v16);
		} break;
		case 3LL: { // OpExternal
			push_value(x1);
			push_resource(x3);
			uint64_t v17 = mtp_mirth_arrow_Op_OpExternal(x2);
			VAL v18 = pop_value();
			VAL v19 = VVAL(VTUP(v18)->cells[5]);
			incref(v19);
			decref(v18);
			VAL r20 = pop_resource();
			VAL v21 = (VVAL(VTUP(r20)->cells[1]));
			VAL v22 = (VVAL(VTUP(v21)->cells[6]));
			push_value(v19);
			mw_mirth_external_External_cname(v22, v17);
			VAL r23 = pop_resource();
			VTUP(v21)->cells[6] = r23;
			VTUP(r20)->cells[1] = v21;
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			VAL v26 = (mw_mirth_c99_c99Z_callZBang(v25, v24, r20));
			push_resource(v26);
		} break;
		case 4LL: { // OpBuffer
			push_value(x1);
			push_resource(x3);
			uint64_t v27 = mtp_mirth_arrow_Op_OpBuffer(x2);
			VAL v28 = pop_value();
			decref(v28);
			VAL r29 = pop_resource();
			VAL v30 = (mw_mirth_c99_c99Z_bufferZ_callZBang(v27, r29));
			push_resource(v30);
		} break;
		case 5LL: { // OpVariable
			push_value(x1);
			push_resource(x3);
			uint64_t v31 = mtp_mirth_arrow_Op_OpVariable(x2);
			VAL v32 = pop_value();
			decref(v32);
			VAL r33 = pop_resource();
			VAL v34 = (mw_mirth_c99_c99Z_variableZ_callZBang(v31, r33));
			push_resource(v34);
		} break;
		case 6LL: { // OpField
			push_value(x1);
			push_resource(x3);
			uint64_t v35 = mtp_mirth_arrow_Op_OpField(x2);
			VAL v36 = pop_value();
			decref(v36);
			VAL r37 = pop_resource();
			VAL v38 = (mw_mirth_c99_c99Z_fieldZ_callZBang(v35, r37));
			push_resource(v38);
		} break;
		case 10LL: { // OpTag
			push_value(x1);
			push_resource(x3);
			uint64_t v39 = mtp_mirth_arrow_Op_OpTag(x2);
			VAL v40 = pop_value();
			VAL v41 = VVAL(VTUP(v40)->cells[5]);
			incref(v41);
			decref(v40);
			VAL r42 = pop_resource();
			VAL v43 = (mw_mirth_c99_c99Z_tagZ_callZBang(v41, v39, r42));
			push_resource(v43);
		} break;
		case 1LL: { // OpPrim
			push_value(x1);
			push_resource(x3);
			int64_t v44 = mtp_mirth_arrow_Op_OpPrim(x2);
			VAL r45 = pop_resource();
			VAL v46 = pop_value();
			VAL v47 = (mw_mirth_c99_c99Z_primZBang(v46, v44, r45));
			push_resource(v47);
		} break;
		case 11LL: { // OpMatch
			push_value(x1);
			push_resource(x3);
			VAL v48 = mtp_mirth_arrow_Op_OpMatch(x2);
			VAL v49 = pop_value();
			decref(v49);
			VAL r50 = pop_resource();
			VAL v51 = (mw_mirth_c99_c99Z_matchZBang(v48, r50));
			push_resource(v51);
		} break;
		case 12LL: { // OpLambda
			push_value(x1);
			push_resource(x3);
			VAL v52 = mtp_mirth_arrow_Op_OpLambda(x2);
			VAL v53 = pop_value();
			decref(v53);
			VAL r54 = pop_resource();
			VAL v55 = (mw_mirth_c99_c99Z_lambdaZBang(v52, r54));
			push_resource(v55);
		} break;
		case 13LL: { // OpVar
			push_value(x1);
			push_resource(x3);
			uint64_t v56 = mtp_mirth_arrow_Op_OpVar(x2);
			VAL v57 = pop_value();
			decref(v57);
			VAL r58 = pop_resource();
			VAL v59 = (mw_mirth_c99_c99Z_varZBang(v56, r58));
			push_resource(v59);
		} break;
		case 14LL: { // OpBlockPush
			push_value(x1);
			push_resource(x3);
			uint64_t v60 = mtp_mirth_arrow_Op_OpBlockPush(x2);
			VAL v61 = pop_value();
			decref(v61);
			VAL r62 = pop_resource();
			VAL v63 = (mw_mirth_c99_c99Z_blockZ_pushZBang(v60, r62));
			push_resource(v63);
		} break;
		case 15LL: { // OpBlockRun
			push_value(x1);
			push_resource(x3);
			uint64_t v64 = mtp_mirth_arrow_Op_OpBlockRun(x2);
			VAL v65 = pop_value();
			decref(v65);
			VAL r66 = pop_resource();
			VAL v67 = (mw_mirth_c99_c99Z_blockZ_runZBang(v64, r66));
			push_resource(v67);
		} break;
		case 16LL: { // OpCoerce
			push_value(x1);
			push_resource(x3);
			VAL v68 = mtp_mirth_arrow_Op_OpCoerce(x2);
			decref(v68);
			VAL v69 = pop_value();
			decref(v69);
		} break;
		case 17LL: { // OpLabelPush
			push_value(x1);
			push_resource(x3);
			uint64_t v70 = mtp_mirth_arrow_Op_OpLabelPush(x2);
			VAL r71 = pop_resource();
			VAL v72 = pop_value();
			VAL v73 = (mw_mirth_c99_c99Z_labelZ_pushZBang(v72, v70, r71));
			push_resource(v73);
		} break;
		case 18LL: { // OpLabelPop
			push_value(x1);
			push_resource(x3);
			uint64_t v74 = mtp_mirth_arrow_Op_OpLabelPop(x2);
			VAL r75 = pop_resource();
			VAL v76 = pop_value();
			VAL v77 = (mw_mirth_c99_c99Z_labelZ_popZBang(v76, v74, r75));
			push_resource(v77);
		} break;
		case 19LL: { // OpLabelPushR
			push_value(x1);
			push_resource(x3);
			uint64_t v78 = mtp_mirth_arrow_Op_OpLabelPushR(x2);
			VAL r79 = pop_resource();
			VAL v80 = pop_value();
			VAL v81 = (mw_mirth_c99_c99Z_labelZ_pushZ_rZBang(v80, v78, r79));
			push_resource(v81);
		} break;
		case 20LL: { // OpLabelPopR
			push_value(x1);
			push_resource(x3);
			uint64_t v82 = mtp_mirth_arrow_Op_OpLabelPopR(x2);
			VAL r83 = pop_resource();
			VAL v84 = pop_value();
			VAL v85 = (mw_mirth_c99_c99Z_labelZ_popZ_rZBang(v84, v82, r83));
			push_resource(v85);
		} break;
		case 21LL: { // OpDataGetTag
			push_value(x1);
			push_resource(x3);
			uint64_t v86 = mtp_mirth_arrow_Op_OpDataGetTag(x2);
			VAL v87 = pop_value();
			decref(v87);
			VAL r88 = pop_resource();
			VAL v89 = (mw_mirth_c99_c99Z_getZ_dataZ_tagZBang(v86, r88));
			push_resource(v89);
		} break;
		case 22LL: { // OpDataGetLabel
			push_value(x1);
			push_resource(x3);
			mtp_mirth_arrow_Op_OpDataGetLabel(x2);
			VAL r90 = pop_resource();
			uint64_t v91 = pop_u64();
			uint64_t v92 = pop_u64();
			VAL v93 = (mw_mirth_c99_c99Z_tagZ_getZ_labelZBang(v92, v91, r90));
			VAL v94 = pop_value();
			decref(v94);
			push_resource(v93);
		} break;
		case 23LL: { // OpDataSetLabel
			push_value(x1);
			push_resource(x3);
			mtp_mirth_arrow_Op_OpDataSetLabel(x2);
			VAL r95 = pop_resource();
			uint64_t v96 = pop_u64();
			uint64_t v97 = pop_u64();
			VAL v98 = (mw_mirth_c99_c99Z_tagZ_setZ_labelZBang(v97, v96, r95));
			VAL v99 = pop_value();
			decref(v99);
			push_resource(v98);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(x1);
			push_resource(x3);
		}
	}
	VAL r100 = pop_resource();
	return r100;
}
static VAL mw_mirth_c99_c99Z_getZ_dataZ_tagZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_data_Data_isZ_enumZAsk(x1);
	if (((bool)v0)) {
		int64_t v1 = 1LL /* True */;
		push_i64(v1);
	} else {
		uint64_t v2 = pop_u64();
		push_u64(v2);
		int64_t v3 = mw_mirth_data_Data_isZ_unitZAsk(v2);
		push_i64(v3);
	}
	bool v4 = pop_bool();
	if (v4) {
	} else {
		VAL r5 = pop_resource();
		VAL v6 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(r5));
		VAL v7 = (mw_mirth_c99_ZPlusC99_indent(v6));
		STR* v8;
		STRLIT(v8, "{", 1);
		VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), v7));
		VAL v10 = (mw_mirth_c99_ZPlusC99_line(v9));
		int64_t v11 = VI64(VTUP(v10)->cells[2]);
		int64_t v12 = 1LL;
		int64_t v13 = i64_add(v11, v12);
		VTUP(v10)->cells[2] = MKI64(v13);
		VAL v14 = (mw_mirth_c99_ZPlusC99_indent(v10));
		STR* v15;
		STRLIT(v15, "VAL val = pop_value();", 22);
		VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
		VAL v17 = (mw_mirth_c99_ZPlusC99_line(v16));
		uint64_t v18 = pop_u64();
		push_resource(v17);
		push_u64(v18);
		int64_t v19 = mw_mirth_data_Data_isZ_semiZ_transparentZAsk(v18);
		if (((bool)v19)) {
			VAL r20 = pop_resource();
			VAL v21 = (mw_mirth_c99_ZPlusC99_indent(r20));
			STR* v22;
			STRLIT(v22, "push_u64(", 9);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			uint64_t v24 = pop_u64();
			push_resource(v23);
			push_u64(v24);
			VAL v25 = mw_mirth_data_Data_tags(v24);
			VAL v26 = mw_std_list_List_1_ZDivL1(v25);
			VAL v27 = mw_std_maybe_Maybe_1_unwrap(v26);
			int64_t v28 = mw_mirth_data_Tag_value(VU64(v27));
			STR* v29 = i64_show(v28);
			VAL r30 = pop_resource();
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v29), r30));
			STR* v32;
			STRLIT(v32, "LL);", 4);
			VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v31));
			VAL v34 = (mw_mirth_c99_ZPlusC99_line(v33));
			push_resource(v34);
		} else {
			VAL r35 = pop_resource();
			VAL v36 = (mw_mirth_c99_ZPlusC99_indent(r35));
			STR* v37;
			STRLIT(v37, "USIZE tag = get_data_tag(val);", 30);
			VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), v36));
			VAL v39 = (mw_mirth_c99_ZPlusC99_line(v38));
			VAL v40 = (mw_mirth_c99_ZPlusC99_indent(v39));
			STR* v41;
			STRLIT(v41, "push_u64(tag);", 14);
			VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), v40));
			VAL v43 = (mw_mirth_c99_ZPlusC99_line(v42));
			push_resource(v43);
		}
		VAL r44 = pop_resource();
		VAL v45 = (mw_mirth_c99_ZPlusC99_indent(r44));
		STR* v46;
		STRLIT(v46, "decref(val);", 12);
		VAL v47 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v46), v45));
		VAL v48 = (mw_mirth_c99_ZPlusC99_line(v47));
		int64_t v49 = VI64(VTUP(v48)->cells[2]);
		int64_t v50 = 1LL;
		int64_t v51 = i64_sub(v49, v50);
		int64_t v52 = mw_std_prim_Int_ZToNat(v51);
		VTUP(v48)->cells[2] = MKI64(v52);
		VAL v53 = (mw_mirth_c99_ZPlusC99_indent(v48));
		STR* v54;
		STRLIT(v54, "}", 1);
		VAL v55 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v54), v53));
		VAL v56 = (mw_mirth_c99_ZPlusC99_line(v55));
		VAL v57 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v56));
		push_resource(v57);
	}
	uint64_t v58 = pop_u64();
	VAL r59 = pop_resource();
	return r59;
}
static VAL mw_mirth_c99_c99Z_wordZBang (VAL x1, uint64_t x2, VAL x3) {
	push_value(x1);
	push_resource(x3);
	push_u64(x2);
	int64_t v0 = mw_mirth_word_Word_preferZ_inlineZAsk(x2);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		VAL r2 = pop_resource();
		VAL v3 = pop_value();
		VAL v4 = (mw_mirth_c99_c99Z_argsZ_pushZBang(v3, r2));
		VAL v5 = (VVAL(VTUP(v4)->cells[1]));
		VAL v6 = (VVAL(VTUP(v5)->cells[6]));
		mw_mirth_word_Word_arrow(v1, v6);
		VAL r7 = pop_resource();
		VTUP(v5)->cells[6] = r7;
		VTUP(v4)->cells[1] = v5;
		VAL v8 = pop_value();
		VAL v9 = (mw_mirth_c99_c99Z_arrowZBang(v8, v4));
		push_resource(v9);
	} else {
		VAL r10 = pop_resource();
		VAL v11 = (VVAL(VTUP(r10)->cells[1]));
		uint64_t v12 = pop_u64();
		mw_mirth_word_Word_c99Z_api(v12, v11);
		VAL r13 = pop_resource();
		VTUP(r10)->cells[1] = r13;
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		VAL v16 = (mw_mirth_c99_c99Z_smartZ_callZBang(v15, v14, r10));
		push_resource(v16);
	}
	VAL r17 = pop_resource();
	return r17;
}
static VAL mw_mirth_data_Tag_valueZ_show (uint64_t x1) {
	void* v0 = mfld_mirth_data_Tag_ZTildevalueZ_show(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_u64(x1);
		push_value(v2);
	} else {
		push_u64(x1);
		int64_t v3 = mw_mirth_data_Tag_value(x1);
		STR* v4 = i64_show(v3);
		incref(MKSTR(v4));
		mut_set(MKSTR(v4), MKPTR(v0));
		push_str(v4);
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	decref(v6);
	return v5;
}
static VAL mw_mirth_c99_c99Z_tagZ_callZBang (VAL x1, uint64_t x2, VAL x3) {
	push_value(x1);
	push_resource(x3);
	push_u64(x2);
	int64_t v0 = mw_mirth_data_Tag_preferZ_inlineZAsk(x2);
	if (((bool)v0)) {
		VAL v1 = pop_value();
		VAL v2 = pop_value();
		decref(v2);
		VAL r3 = pop_resource();
		VAL v4 = (mw_mirth_c99_c99Z_tagZ_bodyZBang(VU64(v1), r3));
		push_resource(v4);
	} else {
		VAL r5 = pop_resource();
		VAL v6 = (VVAL(VTUP(r5)->cells[1]));
		uint64_t v7 = pop_u64();
		mw_mirth_data_Tag_wordZ_c99Z_api(v7, v6);
		VAL r8 = pop_resource();
		VTUP(r5)->cells[1] = r8;
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		VAL v11 = (mw_mirth_c99_c99Z_smartZ_callZBang(v10, v9, r5));
		push_resource(v11);
	}
	VAL r12 = pop_resource();
	return r12;
}
static VAL mw_mirth_c99_c99Z_reverseZ_tagZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_data_Tag_preferZ_inlineZAsk(x1);
	if (((bool)v0)) {
		VAL r1 = pop_resource();
		uint64_t v2 = pop_u64();
		VAL v3 = (mw_mirth_c99_c99Z_reverseZ_tagZ_bodyZBang(v2, r1));
		push_resource(v3);
	} else {
		uint64_t v4 = pop_u64();
		int64_t v5 = 0LL /* Nil */;
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[1]));
		push_i64(v5);
		mw_mirth_data_Tag_patZ_c99Z_api(v4, v7);
		VAL r8 = pop_resource();
		VTUP(r6)->cells[1] = r8;
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		VAL v11 = (mw_mirth_c99_c99Z_smartZ_callZBang(v10, v9, r6));
		push_resource(v11);
	}
	VAL r12 = pop_resource();
	return r12;
}
static VAL mw_mirth_c99_c99Z_labelZ_defsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_label_Label_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_labelZ_defZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_labelZ_defZBang (uint64_t x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "static VAL lbl_", 15);
	push_u64(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	uint64_t v2 = pop_u64();
	push_resource(v1);
	uint64_t v3 = mw_mirth_label_Label_name(v2);
	VAL v4 = mw_mirth_name_Name_mangled(v3);
	VAL r5 = pop_resource();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v4, r5));
	STR* v7;
	STRLIT(v7, " = MKNIL_C;", 11);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_line(v8));
	return v9;
}
static VAL mw_mirth_c99_pushZ_localZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(x3);
	uint64_t v1 = pop_u64();
	VAL r2 = pop_resource();
	push_value(v0);
	push_u64(v1);
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(r2));
	STR* v4;
	STRLIT(v4, "lpush(&lbl_", 11);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	uint64_t v6 = pop_u64();
	push_resource(v5);
	uint64_t v7 = mw_mirth_label_Label_name(v6);
	VAL v8 = mw_mirth_name_Name_mangled(v7);
	VAL r9 = pop_resource();
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v8, r9));
	STR* v11;
	STRLIT(v11, ", ", 2);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	VAL v13 = pop_value();
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v12));
	STR* v15;
	STRLIT(v15, ");", 2);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL v17 = (mw_mirth_c99_ZPlusC99_line(v16));
	return v17;
}
static VAL mw_mirth_c99_pushZ_localZ_labelZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v0 = (VVAL(VTUP(x2)->cells[2]));
	VAL v1 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(v0, x3, x1));
	VTUP(x2)->cells[2] = v1;
	return x2;
}
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang (uint64_t x1, VAL x2, VAL x3) {
	push_u64(x1);
	push_resource(x2);
	VAL v0 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(x3);
	uint64_t v1 = pop_u64();
	VAL r2 = pop_resource();
	push_value(v0);
	push_u64(v1);
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(r2));
	STR* v4;
	STRLIT(v4, "lpush(&lbl_", 11);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	uint64_t v6 = pop_u64();
	push_resource(v5);
	uint64_t v7 = mw_mirth_label_Label_name(v6);
	VAL v8 = mw_mirth_name_Name_mangled(v7);
	VAL r9 = pop_resource();
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v8, r9));
	STR* v11;
	STRLIT(v11, ", ", 2);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	VAL v13 = pop_value();
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v12));
	STR* v15;
	STRLIT(v15, ");", 2);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL v17 = (mw_mirth_c99_ZPlusC99_line(v16));
	return v17;
}
static VAL mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang (uint64_t x1, VAL x2, VAL x3) {
	VAL v0 = (VVAL(VTUP(x2)->cells[2]));
	VAL v1 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(v0, x3, x1));
	VTUP(x2)->cells[2] = v1;
	return x2;
}
static void mw_mirth_c99_popZ_localZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3) {
	push_u64(x2);
	push_i64(x1);
	lpush(&lbl_localZ_repr, MKI64(x1));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(x3);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	int64_t v2 = VI64(lpop(&lbl_localZ_repr));
	VAL v3 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v2, v0));
	push_resource(v3);
	VAL v4 = (mw_mirth_c99_ZPlusC99_indent(r1));
	VAL r5 = pop_resource();
	int64_t v6 = VI64(VTUP(r5)->cells[1]);
	push_resource(r5);
	push_resource(v4);
	VAL v7 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v6);
	VAL r8 = pop_resource();
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v7, r8));
	STR* v10;
	STRLIT(v10, " ", 1);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	VAL r12 = pop_resource();
	VAL v13 = VVAL(VTUP(r12)->cells[2]);
	incref(v13);
	push_resource(r12);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v11));
	STR* v15;
	STRLIT(v15, " = ", 3);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL r17 = pop_resource();
	int64_t v18 = pop_i64();
	switch (v18) {
		case 0LL: { // C99RT_VAL
			STR* v19;
			STRLIT(v19, "lpop(&lbl_", 10);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v16));
			uint64_t v21 = pop_u64();
			push_resource(v20);
			uint64_t v22 = mw_mirth_label_Label_name(v21);
			VAL v23 = mw_mirth_name_Name_mangled(v22);
			VAL r24 = pop_resource();
			VAL v25 = (mw_mirth_c99_ZPlusC99_put(v23, r24));
			STR* v26;
			STRLIT(v26, ")", 1);
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v25));
			push_resource(v27);
		} break;
		default: {
			push_resource(v16);
			VAL v28 = mw_mirth_c99_C99ReprType_vZ_macro(v18);
			VAL r29 = pop_resource();
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(v28, r29));
			STR* v31;
			STRLIT(v31, "(lpop(&lbl_", 11);
			VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
			uint64_t v33 = pop_u64();
			push_resource(v32);
			uint64_t v34 = mw_mirth_label_Label_name(v33);
			VAL v35 = mw_mirth_name_Name_mangled(v34);
			VAL r36 = pop_resource();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v35, r36));
			STR* v38;
			STRLIT(v38, "))", 2);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			push_resource(v39);
		} break;
	}
	VAL r40 = pop_resource();
	STR* v41;
	STRLIT(v41, ";", 1);
	push_resource(r17);
	VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), r40));
	VAL v43 = (mw_mirth_c99_ZPlusC99_line(v42));
	VAL r44 = pop_resource();
	push_resource(v43);
	push_resource(r44);
}
static void mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang (int64_t x1, uint64_t x2, VAL x3) {
	push_u64(x2);
	push_i64(x1);
	lpush(&lbl_localZ_resourceZ_repr, MKI64(x1));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(x3);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	int64_t v2 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	VAL v3 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v2, v0));
	push_resource(v3);
	VAL v4 = (mw_mirth_c99_ZPlusC99_indent(r1));
	VAL r5 = pop_resource();
	int64_t v6 = VI64(VTUP(r5)->cells[1]);
	push_resource(r5);
	push_resource(v4);
	VAL v7 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v6);
	VAL r8 = pop_resource();
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v7, r8));
	STR* v10;
	STRLIT(v10, " ", 1);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	VAL r12 = pop_resource();
	VAL v13 = VVAL(VTUP(r12)->cells[2]);
	incref(v13);
	push_resource(r12);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v13, v11));
	STR* v15;
	STRLIT(v15, " = (", 4);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL r17 = pop_resource();
	int64_t v18 = pop_i64();
	switch (v18) {
		case 0LL: { // C99RT_VAL
			STR* v19;
			STRLIT(v19, "lpop(&lbl_", 10);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v16));
			uint64_t v21 = pop_u64();
			push_resource(v20);
			uint64_t v22 = mw_mirth_label_Label_name(v21);
			VAL v23 = mw_mirth_name_Name_mangled(v22);
			VAL r24 = pop_resource();
			VAL v25 = (mw_mirth_c99_ZPlusC99_put(v23, r24));
			STR* v26;
			STRLIT(v26, ")", 1);
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v25));
			push_resource(v27);
		} break;
		default: {
			push_resource(v16);
			VAL v28 = mw_mirth_c99_C99ReprType_vZ_macro(v18);
			VAL r29 = pop_resource();
			VAL v30 = (mw_mirth_c99_ZPlusC99_put(v28, r29));
			STR* v31;
			STRLIT(v31, "(lpop(&lbl_", 11);
			VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
			uint64_t v33 = pop_u64();
			push_resource(v32);
			uint64_t v34 = mw_mirth_label_Label_name(v33);
			VAL v35 = mw_mirth_name_Name_mangled(v34);
			VAL r36 = pop_resource();
			VAL v37 = (mw_mirth_c99_ZPlusC99_put(v35, r36));
			STR* v38;
			STRLIT(v38, "))", 2);
			VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), v37));
			push_resource(v39);
		} break;
	}
	VAL r40 = pop_resource();
	STR* v41;
	STRLIT(v41, ");", 2);
	push_resource(r17);
	VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), r40));
	VAL v43 = (mw_mirth_c99_ZPlusC99_line(v42));
	VAL r44 = pop_resource();
	push_resource(v43);
	push_resource(r44);
}
static VAL mw_mirth_c99_c99Z_labelZ_pushZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[6]);
	incref(v0);
	decref(x1);
	push_u64(x2);
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v0, x3);
	VAL v1 = pop_value();
	decref(v1);
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	uint64_t v4 = pop_u64();
	VAL v5 = (mw_mirth_c99_pushZ_localZ_labelZBang(v4, r3, r2));
	return v5;
}
static VAL mw_mirth_c99_c99Z_labelZ_pushZ_rZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[6]);
	incref(v0);
	decref(x1);
	push_u64(x2);
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v0, x3);
	VAL v1 = pop_value();
	decref(v1);
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	uint64_t v4 = pop_u64();
	VAL v5 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v4, r3, r2));
	return v5;
}
static VAL mw_mirth_c99_c99Z_labelZ_popZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[6]);
	incref(v0);
	decref(x1);
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZ_fromZ_stackZ_typeZBang(x2, v0, x3);
	VAL v1 = pop_value();
	decref(v1);
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	VAL v4 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r3, r2));
	return v4;
}
static VAL mw_mirth_c99_c99Z_labelZ_popZ_rZBang (VAL x1, uint64_t x2, VAL x3) {
	VAL v0 = VVAL(VTUP(x1)->cells[6]);
	incref(v0);
	decref(x1);
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZ_fromZ_stackZ_typeZBang(x2, v0, x3);
	VAL v1 = pop_value();
	decref(v1);
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	VAL v4 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r3, r2));
	return v4;
}
static VAL mw_mirth_c99_c99Z_intZBang (int64_t x1, VAL x2) {
	int64_t v0 = 2LL /* C99RT_I64 */;
	VAL v1 = (VVAL(VTUP(x2)->cells[1]));
	push_i64(x1);
	lpush(&lbl_localZ_repr, MKI64(v0));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	int64_t v4 = VI64(lpop(&lbl_localZ_repr));
	VAL v5 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v4, v2));
	push_resource(v5);
	VAL v6 = (mw_mirth_c99_ZPlusC99_indent(r3));
	VAL r7 = pop_resource();
	int64_t v8 = VI64(VTUP(r7)->cells[1]);
	push_resource(r7);
	push_resource(v6);
	VAL v9 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v8);
	VAL r10 = pop_resource();
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v9, r10));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL r14 = pop_resource();
	VAL v15 = VVAL(VTUP(r14)->cells[2]);
	incref(v15);
	push_resource(r14);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v13));
	STR* v17;
	STRLIT(v17, " = ", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL r19 = pop_resource();
	int64_t v20 = pop_i64();
	STR* v21 = i64_show(v20);
	VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v18));
	STR* v23;
	STRLIT(v23, "LL", 2);
	VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
	STR* v25;
	STRLIT(v25, ";", 1);
	push_resource(r19);
	VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
	VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
	VTUP(x2)->cells[1] = v27;
	VAL r28 = pop_resource();
	VAL v29 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, r28));
	return v29;
}
static VAL mw_mirth_c99_c99Z_f64ZBang (double x1, VAL x2) {
	int64_t v0 = 10LL /* C99RT_F64 */;
	VAL v1 = (VVAL(VTUP(x2)->cells[1]));
	push_f64(x1);
	lpush(&lbl_localZ_repr, MKI64(v0));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v1);
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	int64_t v4 = VI64(lpop(&lbl_localZ_repr));
	VAL v5 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v4, v2));
	push_resource(v5);
	VAL v6 = (mw_mirth_c99_ZPlusC99_indent(r3));
	VAL r7 = pop_resource();
	int64_t v8 = VI64(VTUP(r7)->cells[1]);
	push_resource(r7);
	push_resource(v6);
	VAL v9 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v8);
	VAL r10 = pop_resource();
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(v9, r10));
	STR* v12;
	STRLIT(v12, " ", 1);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	VAL r14 = pop_resource();
	VAL v15 = VVAL(VTUP(r14)->cells[2]);
	incref(v15);
	push_resource(r14);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v13));
	STR* v17;
	STRLIT(v17, " = ", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL r19 = pop_resource();
	double v20 = pop_f64();
	STR* v21 = f64_show(v20);
	VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v18));
	STR* v23;
	STRLIT(v23, ";", 1);
	push_resource(r19);
	VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
	VAL v25 = (mw_mirth_c99_ZPlusC99_line(v24));
	VTUP(x2)->cells[1] = v25;
	VAL r26 = pop_resource();
	VAL v27 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, r26));
	return v27;
}
static VAL mw_mirth_c99_c99Z_strZBang (VAL x1, VAL x2) {
	int64_t v0 = 1LL /* C99RT_STR */;
	push_value(x1);
	mw_mirth_c99_C99ReprType_newZ_localZBang(v0, x2);
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	incref(v2);
	uint64_t v3 = str_size(VSTR(v2));
	lpush(&lbl_ZPlusstr, r1);
	push_value(v2);
	int64_t v4 = mw_std_prim_Int_ZToNat(((int64_t)v3));
	int64_t v5 = 4090LL;
	push_i64(v4);
	int64_t v6 = mw_std_prim_Int_ZToNat(v5);
	int64_t v7 = pop_i64();
	bool v8 = (v7 > v6);
	if (v8) {
		VAL r9 = pop_resource();
		VAL v10 = (VVAL(VTUP(r9)->cells[1]));
		VAL v11 = (mw_mirth_c99_ZPlusC99_indent(v10));
		STR* v12;
		STRLIT(v12, "STRLIT(", 7);
		VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
		VAL v14 = (lpop(&lbl_ZPlusstr));
		push_resource(v13);
		mw_mirth_c99_ZPlusC99Local_rdup(v14);
		VAL r15 = pop_resource();
		VAL r16 = pop_resource();
		lpush(&lbl_ZPlusstr, r15);
		VAL v17 = mw_mirth_c99_ZPlusC99Local_consume(r16);
		VAL r18 = pop_resource();
		VAL v19 = (mw_mirth_c99_ZPlusC99_put(v17, r18));
		STR* v20;
		STRLIT(v20, ",", 1);
		VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
		VAL v22 = (mw_mirth_c99_ZPlusC99_line(v21));
		VTUP(r9)->cells[1] = v22;
		VAL v23 = (VVAL(VTUP(r9)->cells[1]));
		int64_t v24 = VI64(VTUP(v23)->cells[2]);
		int64_t v25 = 1LL;
		int64_t v26 = i64_add(v24, v25);
		VTUP(v23)->cells[2] = MKI64(v26);
		VTUP(r9)->cells[1] = v23;
		VAL v27 = (VVAL(VTUP(r9)->cells[1]));
		VAL v28 = (mw_mirth_c99_ZPlusC99_indent(v27));
		VAL v29 = pop_value();
		incref(v29);
		push_value(v29);
		VAL v30 = (mw_mirth_c99_ZPlusC99_putZ_cstrZ_long(v29, v28));
		STR* v31;
		STRLIT(v31, ",", 1);
		VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
		VAL v33 = (mw_mirth_c99_ZPlusC99_line(v32));
		VTUP(r9)->cells[1] = v33;
		VAL v34 = (VVAL(VTUP(r9)->cells[1]));
		VAL v35 = (mw_mirth_c99_ZPlusC99_indent(v34));
		VAL v36 = pop_value();
		incref(v36);
		uint64_t v37 = str_size(VSTR(v36));
		push_resource(v35);
		push_value(v36);
		int64_t v38 = mw_std_prim_Int_ZToNat(((int64_t)v37));
		STR* v39 = i64_show(v38);
		VAL r40 = pop_resource();
		VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v39), r40));
		VAL v42 = (mw_mirth_c99_ZPlusC99_line(v41));
		VTUP(r9)->cells[1] = v42;
		VAL v43 = (VVAL(VTUP(r9)->cells[1]));
		int64_t v44 = VI64(VTUP(v43)->cells[2]);
		int64_t v45 = 1LL;
		int64_t v46 = i64_sub(v44, v45);
		int64_t v47 = mw_std_prim_Int_ZToNat(v46);
		VTUP(v43)->cells[2] = MKI64(v47);
		VTUP(r9)->cells[1] = v43;
		VAL v48 = (VVAL(VTUP(r9)->cells[1]));
		VAL v49 = (mw_mirth_c99_ZPlusC99_indent(v48));
		STR* v50;
		STRLIT(v50, ");", 2);
		VAL v51 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v50), v49));
		VAL v52 = (mw_mirth_c99_ZPlusC99_line(v51));
		VTUP(r9)->cells[1] = v52;
		push_resource(r9);
	} else {
		VAL r53 = pop_resource();
		VAL v54 = (VVAL(VTUP(r53)->cells[1]));
		VAL v55 = (mw_mirth_c99_ZPlusC99_indent(v54));
		STR* v56;
		STRLIT(v56, "STRLIT(", 7);
		VAL v57 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v56), v55));
		VAL v58 = (lpop(&lbl_ZPlusstr));
		push_resource(v57);
		mw_mirth_c99_ZPlusC99Local_rdup(v58);
		VAL r59 = pop_resource();
		VAL r60 = pop_resource();
		lpush(&lbl_ZPlusstr, r59);
		VAL v61 = mw_mirth_c99_ZPlusC99Local_consume(r60);
		VAL r62 = pop_resource();
		VAL v63 = (mw_mirth_c99_ZPlusC99_put(v61, r62));
		STR* v64;
		STRLIT(v64, ", ", 2);
		VAL v65 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v64), v63));
		VAL v66 = pop_value();
		incref(v66);
		push_value(v66);
		VAL v67 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v66, v65));
		STR* v68;
		STRLIT(v68, ", ", 2);
		VAL v69 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v68), v67));
		VAL v70 = pop_value();
		incref(v70);
		uint64_t v71 = str_size(VSTR(v70));
		push_resource(v69);
		push_value(v70);
		int64_t v72 = mw_std_prim_Int_ZToNat(((int64_t)v71));
		STR* v73 = i64_show(v72);
		VAL r74 = pop_resource();
		VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v73), r74));
		STR* v76;
		STRLIT(v76, ");", 2);
		VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v76), v75));
		VAL v78 = (mw_mirth_c99_ZPlusC99_line(v77));
		VTUP(r53)->cells[1] = v78;
		push_resource(r53);
	}
	VAL v79 = pop_value();
	decref(v79);
	VAL v80 = (lpop(&lbl_ZPlusstr));
	VAL r81 = pop_resource();
	VAL v82 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r81, v80));
	return v82;
}
static VAL mw_mirth_c99_ZPlusC99_putZ_cstrZ_long (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* False */;
	int64_t v1 = 34LL /* BQUOTE */;
	push_value(x1);
	lpush(&lbl_avoidZ_hexdigit, MKI64(v0));
	VAL v2 = (mw_mirth_c99_ZPlusC99_putZ_byte(v1, x2));
	int64_t v3 = 0LL /* BNUL */;
	VAL v4 = pop_value();
	incref(v4);
	incref(v4);
	void* v5 = str_base(VSTR(v4));
	uint64_t v6 = str_size(VSTR(v4));
	push_resource(v2);
	push_i64(v3);
	push_ptr(v5);
	int64_t v7 = mw_std_prim_Int_ZToNat(((int64_t)v6));
	push_i64(v7);
	while(1) {
		int64_t v8 = pop_i64();
		int64_t v9 = 0LL;
		bool v10 = (v8 > v9);
		push_i64(v8);
		if (!v10) break;
		int64_t v11 = pop_i64();
		VAL v12 = pop_value();
		incref(v12);
		int64_t v13 = (0LL /* +Unsafe */);
		mw_std_prim_Ptr_ZAtByte(v12, MKI64(v13));
		VAL r14 = pop_resource();
		int64_t v15 = pop_i64();
		int64_t v16 = pop_i64();
		int64_t v17 = 10LL /* BLF */;
		bool v18 = (v16 == v17);
		if (v18) {
			int64_t v19 = 34LL /* BQUOTE */;
			VAL r20 = pop_resource();
			push_i64(v15);
			VAL v21 = (mw_mirth_c99_ZPlusC99_putZ_byte(v19, r20));
			VAL v22 = (mw_mirth_c99_ZPlusC99_line(v21));
			VAL v23 = (mw_mirth_c99_ZPlusC99_indent(v22));
			int64_t v24 = 34LL /* BQUOTE */;
			VAL v25 = (mw_mirth_c99_ZPlusC99_putZ_byte(v24, v23));
			push_resource(v25);
		} else {
			push_i64(v15);
		}
		int64_t v26 = pop_i64();
		VAL r27 = pop_resource();
		int64_t v28 = VI64(lpop(&lbl_avoidZ_hexdigit));
		push_i64(v26);
		mw_mirth_c99_c99Z_stringZ_byteZBang(v26, v28, r27);
		int64_t v29 = 1LL;
		int64_t v30 = (0LL /* +Unsafe */);
		void* v31 = (void*)(v29 + (char*)VPTR(v12));
		int64_t v32 = 1LL;
		int64_t v33 = i64_sub(v11, v32);
		push_ptr(v31);
		int64_t v34 = mw_std_prim_Int_ZToNat(v33);
		push_i64(v34);
	}
	int64_t v35 = pop_i64();
	VAL v36 = pop_value();
	decref(v36);
	decref(v4);
	int64_t v37 = 34LL /* BQUOTE */;
	VAL r38 = pop_resource();
	VAL v39 = (mw_mirth_c99_ZPlusC99_putZ_byte(v37, r38));
	int64_t v40 = VI64(lpop(&lbl_avoidZ_hexdigit));
	VAL v41 = pop_value();
	decref(v41);
	return v39;
}
static VAL mw_mirth_c99_ZPlusC99_putZ_cstr (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* False */;
	int64_t v1 = 34LL /* BQUOTE */;
	push_value(x1);
	lpush(&lbl_avoidZ_hexdigit, MKI64(v0));
	VAL v2 = (mw_mirth_c99_ZPlusC99_putZ_byte(v1, x2));
	VAL v3 = pop_value();
	incref(v3);
	incref(v3);
	void* v4 = str_base(VSTR(v3));
	uint64_t v5 = str_size(VSTR(v3));
	push_resource(v2);
	push_ptr(v4);
	int64_t v6 = mw_std_prim_Int_ZToNat(((int64_t)v5));
	push_i64(v6);
	while(1) {
		int64_t v7 = pop_i64();
		int64_t v8 = 0LL;
		bool v9 = (v7 > v8);
		push_i64(v7);
		if (!v9) break;
		int64_t v10 = pop_i64();
		VAL v11 = pop_value();
		incref(v11);
		int64_t v12 = (0LL /* +Unsafe */);
		mw_std_prim_Ptr_ZAtByte(v11, MKI64(v12));
		VAL r13 = pop_resource();
		VAL r14 = pop_resource();
		int64_t v15 = VI64(lpop(&lbl_avoidZ_hexdigit));
		int64_t v16 = pop_i64();
		mw_mirth_c99_c99Z_stringZ_byteZBang(v16, v15, r14);
		int64_t v17 = 1LL;
		int64_t v18 = (0LL /* +Unsafe */);
		void* v19 = (void*)(v17 + (char*)VPTR(v11));
		int64_t v20 = 1LL;
		int64_t v21 = i64_sub(v10, v20);
		push_ptr(v19);
		int64_t v22 = mw_std_prim_Int_ZToNat(v21);
		push_i64(v22);
	}
	int64_t v23 = pop_i64();
	VAL v24 = pop_value();
	decref(v24);
	decref(v3);
	int64_t v25 = 34LL /* BQUOTE */;
	VAL r26 = pop_resource();
	VAL v27 = (mw_mirth_c99_ZPlusC99_putZ_byte(v25, r26));
	int64_t v28 = VI64(lpop(&lbl_avoidZ_hexdigit));
	return v27;
}
static void mw_mirth_c99_c99Z_stringZ_byteZBang (int64_t x1, int64_t x2, VAL x3) {
	switch (x1) {
		case 92LL: { // B'\'
			STR* v0;
			STRLIT(v0, "\\\\", 2);
			lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
			VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x3));
			int64_t v2 = 0LL /* False */;
			int64_t v3 = VI64(lpop(&lbl_avoidZ_hexdigit));
			push_resource(v1);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v2));
		} break;
		case 34LL: { // BQUOTE
			STR* v4;
			STRLIT(v4, "\\\"", 2);
			lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
			VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), x3));
			int64_t v6 = 0LL /* False */;
			int64_t v7 = VI64(lpop(&lbl_avoidZ_hexdigit));
			push_resource(v5);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v6));
		} break;
		case 9LL: { // BHT
			STR* v8;
			STRLIT(v8, "\\t", 2);
			lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
			VAL v9 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v8), x3));
			int64_t v10 = 0LL /* False */;
			int64_t v11 = VI64(lpop(&lbl_avoidZ_hexdigit));
			push_resource(v9);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v10));
		} break;
		case 10LL: { // BLF
			STR* v12;
			STRLIT(v12, "\\n", 2);
			lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), x3));
			int64_t v14 = 0LL /* False */;
			int64_t v15 = VI64(lpop(&lbl_avoidZ_hexdigit));
			push_resource(v13);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v14));
		} break;
		case 13LL: { // BCR
			STR* v16;
			STRLIT(v16, "\\r", 2);
			lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
			VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), x3));
			int64_t v18 = 0LL /* False */;
			int64_t v19 = VI64(lpop(&lbl_avoidZ_hexdigit));
			push_resource(v17);
			lpush(&lbl_avoidZ_hexdigit, MKI64(v18));
		} break;
		default: {
			int64_t v20 = 32LL /* BSPACE */;
			int64_t v21 = 126LL /* B'~' */;
			bool v22 = (x1 >= v20);
			bool v23 = (x1 <= v21);
			bool v24 = (v22 && v23);
			if (v24) {
				lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
				push_resource(x3);
				push_i64(x1);
				int64_t v25 = mw_std_byte_Byte_isZ_hexdigit(x1);
				int64_t v26 = VI64(lpop(&lbl_avoidZ_hexdigit));
				bool v27 = (((bool)v25) && ((bool)v26));
				bool v28 = !v27;
				lpush(&lbl_avoidZ_hexdigit, MKI64(v26));
				push_bool(v28);
			} else {
				int64_t v29 = 0LL /* False */;
				lpush(&lbl_avoidZ_hexdigit, MKI64(x2));
				push_resource(x3);
				push_i64(x1);
				push_i64(v29);
			}
			bool v30 = pop_bool();
			if (v30) {
				VAL r31 = pop_resource();
				int64_t v32 = pop_i64();
				VAL v33 = (mw_mirth_c99_ZPlusC99_putZ_byte(v32, r31));
				int64_t v34 = 0LL /* False */;
				int64_t v35 = VI64(lpop(&lbl_avoidZ_hexdigit));
				push_resource(v33);
				lpush(&lbl_avoidZ_hexdigit, MKI64(v34));
			} else {
				STR* v36;
				STRLIT(v36, "\\x", 2);
				VAL r37 = pop_resource();
				VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v36), r37));
				int64_t v39 = pop_i64();
				push_resource(v38);
				mw_std_byte_Byte_toZ_hexdigits(v39);
				int64_t v40 = pop_i64();
				VAL r41 = pop_resource();
				int64_t v42 = pop_i64();
				VAL v43 = (mw_mirth_c99_ZPlusC99_putZ_byte(v42, r41));
				VAL v44 = (mw_mirth_c99_ZPlusC99_putZ_byte(v40, v43));
				int64_t v45 = 1LL /* True */;
				int64_t v46 = VI64(lpop(&lbl_avoidZ_hexdigit));
				push_resource(v44);
				lpush(&lbl_avoidZ_hexdigit, MKI64(v45));
			}
		} break;
	}
}
static int64_t mw_mirth_c99_C99ReprType_ZEqualZEqual (int64_t x1, int64_t x2) {
	bool v0 = (x1 == x2);
	return ((int64_t)v0);
}
static int64_t mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk (int64_t x1) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 1LL: { // C99RT_STR
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		default: {
			int64_t v2 = 0LL /* False */;
			push_i64(v2);
		} break;
	}
	int64_t v3 = pop_i64();
	return v3;
}
static int64_t mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk (int64_t x1) {
	switch (x1) {
		case 2LL: { // C99RT_I64
			int64_t v0 = 1LL /* True */;
			push_i64(v0);
		} break;
		case 3LL: { // C99RT_I32
			int64_t v1 = 1LL /* True */;
			push_i64(v1);
		} break;
		case 4LL: { // C99RT_I16
			int64_t v2 = 1LL /* True */;
			push_i64(v2);
		} break;
		case 5LL: { // C99RT_I8
			int64_t v3 = 1LL /* True */;
			push_i64(v3);
		} break;
		case 6LL: { // C99RT_U64
			int64_t v4 = 1LL /* True */;
			push_i64(v4);
		} break;
		case 7LL: { // C99RT_U32
			int64_t v5 = 1LL /* True */;
			push_i64(v5);
		} break;
		case 8LL: { // C99RT_U16
			int64_t v6 = 1LL /* True */;
			push_i64(v6);
		} break;
		case 9LL: { // C99RT_U8
			int64_t v7 = 1LL /* True */;
			push_i64(v7);
		} break;
		case 12LL: { // C99RT_BOOL
			int64_t v8 = 1LL /* True */;
			push_i64(v8);
		} break;
		default: {
			int64_t v9 = 0LL /* False */;
			push_i64(v9);
		} break;
	}
	int64_t v10 = pop_i64();
	return v10;
}
static VAL mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type (int64_t x1) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v0;
			STRLIT(v0, "VAL", 3);
			push_str(v0);
		} break;
		case 1LL: { // C99RT_STR
			STR* v1;
			STRLIT(v1, "STR*", 4);
			push_str(v1);
		} break;
		case 2LL: { // C99RT_I64
			STR* v2;
			STRLIT(v2, "int64_t", 7);
			push_str(v2);
		} break;
		case 3LL: { // C99RT_I32
			STR* v3;
			STRLIT(v3, "int32_t", 7);
			push_str(v3);
		} break;
		case 4LL: { // C99RT_I16
			STR* v4;
			STRLIT(v4, "int16_t", 7);
			push_str(v4);
		} break;
		case 5LL: { // C99RT_I8
			STR* v5;
			STRLIT(v5, "int8_t", 6);
			push_str(v5);
		} break;
		case 6LL: { // C99RT_U64
			STR* v6;
			STRLIT(v6, "uint64_t", 8);
			push_str(v6);
		} break;
		case 7LL: { // C99RT_U32
			STR* v7;
			STRLIT(v7, "uint32_t", 8);
			push_str(v7);
		} break;
		case 8LL: { // C99RT_U16
			STR* v8;
			STRLIT(v8, "uint16_t", 8);
			push_str(v8);
		} break;
		case 9LL: { // C99RT_U8
			STR* v9;
			STRLIT(v9, "uint8_t", 7);
			push_str(v9);
		} break;
		case 10LL: { // C99RT_F64
			STR* v10;
			STRLIT(v10, "double", 6);
			push_str(v10);
		} break;
		case 11LL: { // C99RT_F32
			STR* v11;
			STRLIT(v11, "float", 5);
			push_str(v11);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v12;
			STRLIT(v12, "bool", 4);
			push_str(v12);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v13;
			STRLIT(v13, "void*", 5);
			push_str(v13);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v14;
			STRLIT(v14, "FNPTR", 5);
			push_str(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v15 = pop_value();
	return v15;
}
static VAL mw_mirth_c99_C99ReprType_vZ_macro (int64_t x1) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v0;
			STRLIT(v0, "VVAL", 4);
			push_str(v0);
		} break;
		case 1LL: { // C99RT_STR
			STR* v1;
			STRLIT(v1, "VSTR", 4);
			push_str(v1);
		} break;
		case 2LL: { // C99RT_I64
			STR* v2;
			STRLIT(v2, "VI64", 4);
			push_str(v2);
		} break;
		case 3LL: { // C99RT_I32
			STR* v3;
			STRLIT(v3, "VI32", 4);
			push_str(v3);
		} break;
		case 4LL: { // C99RT_I16
			STR* v4;
			STRLIT(v4, "VI16", 4);
			push_str(v4);
		} break;
		case 5LL: { // C99RT_I8
			STR* v5;
			STRLIT(v5, "VI8", 3);
			push_str(v5);
		} break;
		case 6LL: { // C99RT_U64
			STR* v6;
			STRLIT(v6, "VU64", 4);
			push_str(v6);
		} break;
		case 7LL: { // C99RT_U32
			STR* v7;
			STRLIT(v7, "VU32", 4);
			push_str(v7);
		} break;
		case 8LL: { // C99RT_U16
			STR* v8;
			STRLIT(v8, "VU16", 4);
			push_str(v8);
		} break;
		case 9LL: { // C99RT_U8
			STR* v9;
			STRLIT(v9, "VU8", 3);
			push_str(v9);
		} break;
		case 10LL: { // C99RT_F64
			STR* v10;
			STRLIT(v10, "VF64", 4);
			push_str(v10);
		} break;
		case 11LL: { // C99RT_F32
			STR* v11;
			STRLIT(v11, "VF32", 4);
			push_str(v11);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v12;
			STRLIT(v12, "VBOOL", 5);
			push_str(v12);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v13;
			STRLIT(v13, "VPTR", 4);
			push_str(v13);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v14;
			STRLIT(v14, "VFNPTR", 6);
			push_str(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v15 = pop_value();
	return v15;
}
static VAL mw_mirth_c99_C99ReprType_mkZ_macro (int64_t x1) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v0;
			STRLIT(v0, "MKVAL", 5);
			push_str(v0);
		} break;
		case 1LL: { // C99RT_STR
			STR* v1;
			STRLIT(v1, "MKSTR", 5);
			push_str(v1);
		} break;
		case 2LL: { // C99RT_I64
			STR* v2;
			STRLIT(v2, "MKI64", 5);
			push_str(v2);
		} break;
		case 3LL: { // C99RT_I32
			STR* v3;
			STRLIT(v3, "MKI32", 5);
			push_str(v3);
		} break;
		case 4LL: { // C99RT_I16
			STR* v4;
			STRLIT(v4, "MKI16", 5);
			push_str(v4);
		} break;
		case 5LL: { // C99RT_I8
			STR* v5;
			STRLIT(v5, "MKI8", 4);
			push_str(v5);
		} break;
		case 6LL: { // C99RT_U64
			STR* v6;
			STRLIT(v6, "MKU64", 5);
			push_str(v6);
		} break;
		case 7LL: { // C99RT_U32
			STR* v7;
			STRLIT(v7, "MKU32", 5);
			push_str(v7);
		} break;
		case 8LL: { // C99RT_U16
			STR* v8;
			STRLIT(v8, "MKU16", 5);
			push_str(v8);
		} break;
		case 9LL: { // C99RT_U8
			STR* v9;
			STRLIT(v9, "MKU8", 4);
			push_str(v9);
		} break;
		case 11LL: { // C99RT_F32
			STR* v10;
			STRLIT(v10, "MKF32", 5);
			push_str(v10);
		} break;
		case 10LL: { // C99RT_F64
			STR* v11;
			STRLIT(v11, "MKF64", 5);
			push_str(v11);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v12;
			STRLIT(v12, "MKBOOL", 6);
			push_str(v12);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v13;
			STRLIT(v13, "MKPTR", 5);
			push_str(v13);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v14;
			STRLIT(v14, "MKFNPTR", 7);
			push_str(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v15 = pop_value();
	return v15;
}
static VAL mw_mirth_c99_C99ReprType_popZ_macro (int64_t x1) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v0;
			STRLIT(v0, "pop_value", 9);
			push_str(v0);
		} break;
		case 1LL: { // C99RT_STR
			STR* v1;
			STRLIT(v1, "pop_str", 7);
			push_str(v1);
		} break;
		case 2LL: { // C99RT_I64
			STR* v2;
			STRLIT(v2, "pop_i64", 7);
			push_str(v2);
		} break;
		case 3LL: { // C99RT_I32
			STR* v3;
			STRLIT(v3, "pop_i32", 7);
			push_str(v3);
		} break;
		case 4LL: { // C99RT_I16
			STR* v4;
			STRLIT(v4, "pop_i16", 7);
			push_str(v4);
		} break;
		case 5LL: { // C99RT_I8
			STR* v5;
			STRLIT(v5, "pop_i8", 6);
			push_str(v5);
		} break;
		case 6LL: { // C99RT_U64
			STR* v6;
			STRLIT(v6, "pop_u64", 7);
			push_str(v6);
		} break;
		case 7LL: { // C99RT_U32
			STR* v7;
			STRLIT(v7, "pop_u32", 7);
			push_str(v7);
		} break;
		case 8LL: { // C99RT_U16
			STR* v8;
			STRLIT(v8, "pop_u16", 7);
			push_str(v8);
		} break;
		case 9LL: { // C99RT_U8
			STR* v9;
			STRLIT(v9, "pop_u8", 6);
			push_str(v9);
		} break;
		case 10LL: { // C99RT_F64
			STR* v10;
			STRLIT(v10, "pop_f64", 7);
			push_str(v10);
		} break;
		case 11LL: { // C99RT_F32
			STR* v11;
			STRLIT(v11, "pop_f32", 7);
			push_str(v11);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v12;
			STRLIT(v12, "pop_bool", 8);
			push_str(v12);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v13;
			STRLIT(v13, "pop_ptr", 7);
			push_str(v13);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v14;
			STRLIT(v14, "pop_fnptr", 9);
			push_str(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v15 = pop_value();
	return v15;
}
static VAL mw_mirth_c99_C99ReprType_pushZ_macro (int64_t x1) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			STR* v0;
			STRLIT(v0, "push_value", 10);
			push_str(v0);
		} break;
		case 1LL: { // C99RT_STR
			STR* v1;
			STRLIT(v1, "push_str", 8);
			push_str(v1);
		} break;
		case 2LL: { // C99RT_I64
			STR* v2;
			STRLIT(v2, "push_i64", 8);
			push_str(v2);
		} break;
		case 3LL: { // C99RT_I32
			STR* v3;
			STRLIT(v3, "push_i32", 8);
			push_str(v3);
		} break;
		case 4LL: { // C99RT_I16
			STR* v4;
			STRLIT(v4, "push_i16", 8);
			push_str(v4);
		} break;
		case 5LL: { // C99RT_I8
			STR* v5;
			STRLIT(v5, "push_i8", 7);
			push_str(v5);
		} break;
		case 6LL: { // C99RT_U64
			STR* v6;
			STRLIT(v6, "push_u64", 8);
			push_str(v6);
		} break;
		case 7LL: { // C99RT_U32
			STR* v7;
			STRLIT(v7, "push_u32", 8);
			push_str(v7);
		} break;
		case 8LL: { // C99RT_U16
			STR* v8;
			STRLIT(v8, "push_u16", 8);
			push_str(v8);
		} break;
		case 9LL: { // C99RT_U8
			STR* v9;
			STRLIT(v9, "push_u8", 7);
			push_str(v9);
		} break;
		case 10LL: { // C99RT_F64
			STR* v10;
			STRLIT(v10, "push_f64", 8);
			push_str(v10);
		} break;
		case 11LL: { // C99RT_F32
			STR* v11;
			STRLIT(v11, "push_f32", 8);
			push_str(v11);
		} break;
		case 12LL: { // C99RT_BOOL
			STR* v12;
			STRLIT(v12, "push_bool", 9);
			push_str(v12);
		} break;
		case 13LL: { // C99RT_PTR
			STR* v13;
			STRLIT(v13, "push_ptr", 8);
			push_str(v13);
		} break;
		case 14LL: { // C99RT_FNPTR
			STR* v14;
			STRLIT(v14, "push_fnptr", 10);
			push_str(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v15 = pop_value();
	return v15;
}
static void mw_mirth_type_Resource_c99Z_repr (VAL x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_mirth_type_Resource_ZToType(x1);
	VAL r1 = pop_resource();
	mw_mirth_type_Type_c99Z_repr(v0, r1);
}
static void mw_mirth_type_Type_c99Z_repr (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // TYPE_ERROR
			int64_t v0 = 0LL /* C99RT_VAL */;
			push_resource(x2);
			push_i64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			int64_t v1 = 0LL /* C99RT_VAL */;
			push_resource(x2);
			push_i64(v1);
		} break;
		case 2LL: { // TPrim
			push_resource(x2);
			int64_t v2 = mtp_mirth_type_Type_TPrim(x1);
			int64_t v3 = mw_mirth_type_PrimType_c99Z_repr(v2);
			push_i64(v3);
		} break;
		case 3LL: { // TMeta
			push_resource(x2);
			uint64_t v4 = mtp_mirth_type_Type_TMeta(x1);
			push_u64(v4);
			VAL v5 = mw_mirth_type_MetaVar_typeZAsk(v4);
			switch (get_data_tag(v5)) {
				case 0LL: { // None
					uint64_t v6 = pop_u64();
					int64_t v7 = 0LL /* C99RT_VAL */;
					push_i64(v7);
				} break;
				case 1LL: { // Some
					VAL v8 = mtp_std_maybe_Maybe_1_Some(v5);
					VAL v9 = mw_mirth_type_Type_expand(v8);
					incref(v9);
					VAL v10 = pop_value();
					push_value(v9);
					push_value(v10);
					VAL v11 = mtw_std_maybe_Maybe_1_Some(v9);
					uint64_t v12 = pop_u64();
					void* v13 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v12);
					mut_set(v11, MKPTR(v13));
					VAL r14 = pop_resource();
					VAL v15 = pop_value();
					mw_mirth_type_Type_c99Z_repr(v15, r14);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 4LL: { // THole
			push_resource(x2);
			uint64_t v16 = mtp_mirth_type_Type_THole(x1);
			int64_t v17 = 0LL /* C99RT_VAL */;
			push_i64(v17);
		} break;
		case 5LL: { // TVar
			push_resource(x2);
			uint64_t v18 = mtp_mirth_type_Type_TVar(x1);
			int64_t v19 = 0LL /* C99RT_VAL */;
			push_i64(v19);
		} break;
		case 6LL: { // TTable
			push_resource(x2);
			uint64_t v20 = mtp_mirth_type_Type_TTable(x1);
			int64_t v21 = 6LL /* C99RT_U64 */;
			push_i64(v21);
		} break;
		case 7LL: { // TData
			push_resource(x2);
			uint64_t v22 = mtp_mirth_type_Type_TData(x1);
			VAL r23 = pop_resource();
			mw_mirth_data_Data_c99Z_repr(v22, r23);
		} break;
		case 8LL: { // TDataPartial
			push_resource(x2);
			VAL v24 = mtp_mirth_type_Type_TDataPartial(x1);
			uint64_t v25 = VU64(VTUP(v24)->cells[1]);
			decref(v24);
			VAL r26 = pop_resource();
			mw_mirth_data_Data_c99Z_repr(v25, r26);
		} break;
		case 10LL: { // TMorphism
			push_resource(x2);
			VAL v27 = mtp_mirth_type_Type_TMorphism(x1);
			decref(v27);
			int64_t v28 = 0LL /* C99RT_VAL */;
			push_i64(v28);
		} break;
		case 9LL: { // TTensor
			push_resource(x2);
			VAL v29 = mtp_mirth_type_Type_TTensor(x1);
			decref(v29);
			int64_t v30 = 0LL /* C99RT_VAL */;
			push_i64(v30);
		} break;
		case 11LL: { // TApp
			push_resource(x2);
			mtp_mirth_type_Type_TApp(x1);
			VAL v31 = pop_value();
			decref(v31);
			VAL r32 = pop_resource();
			VAL v33 = pop_value();
			mw_mirth_type_Type_c99Z_repr(v33, r32);
		} break;
		case 12LL: { // TMut
			push_resource(x2);
			VAL v34 = mtp_mirth_type_Type_TMut(x1);
			decref(v34);
			int64_t v35 = 0LL /* C99RT_VAL */;
			push_i64(v35);
		} break;
		case 13LL: { // TValue
			push_resource(x2);
			VAL v36 = mtp_mirth_type_Type_TValue(x1);
			decref(v36);
			int64_t v37 = 0LL /* C99RT_VAL */;
			push_i64(v37);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
}
static int64_t mw_mirth_type_PrimType_c99Z_repr (int64_t x1) {
	switch (x1) {
		case 0LL: { // PRIM_TYPE_TYPE
			int64_t v0 = 0LL /* C99RT_VAL */;
			push_i64(v0);
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			int64_t v1 = 0LL /* C99RT_VAL */;
			push_i64(v1);
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			int64_t v2 = 0LL /* C99RT_VAL */;
			push_i64(v2);
		} break;
		case 3LL: { // PRIM_TYPE_INT
			int64_t v3 = 2LL /* C99RT_I64 */;
			push_i64(v3);
		} break;
		case 4LL: { // PRIM_TYPE_F32
			int64_t v4 = 11LL /* C99RT_F32 */;
			push_i64(v4);
		} break;
		case 5LL: { // PRIM_TYPE_F64
			int64_t v5 = 10LL /* C99RT_F64 */;
			push_i64(v5);
		} break;
		case 7LL: { // PRIM_TYPE_STR
			int64_t v6 = 0LL /* C99RT_VAL */;
			push_i64(v6);
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			int64_t v7 = 0LL /* C99RT_VAL */;
			push_i64(v7);
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			int64_t v8 = 0LL /* C99RT_VAL */;
			push_i64(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	int64_t v9 = pop_i64();
	return v9;
}
static void mw_mirth_data_Data_c99Z_repr (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_data_Data_isZ_enumZAsk(x1);
	if (((bool)v0)) {
		uint64_t v1 = pop_u64();
		int64_t v2 = 2LL /* C99RT_I64 */;
		push_i64(v2);
	} else {
		uint64_t v3 = pop_u64();
		push_u64(v3);
		int64_t v4 = mw_mirth_data_Data_isZ_semiZ_transparentZAsk(v3);
		if (((bool)v4)) {
			uint64_t v5 = pop_u64();
			VAL v6 = mw_mirth_data_Data_tags(v5);
			VAL v7 = mw_std_list_List_1_ZDivL1(v6);
			VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
			VAL r9 = pop_resource();
			mw_mirth_data_Tag_type(r9, VU64(v8));
			VAL v10 = pop_value();
			VAL v11 = mw_mirth_type_ArrowType_dom(v10);
			VAL r12 = pop_resource();
			mw_mirth_type_StackType_c99Z_reprZ_semiZ_transparent(v11, r12);
		} else {
			uint64_t v13 = pop_u64();
			int64_t v14 = 0LL /* C99RT_VAL */;
			push_i64(v14);
		}
	}
}
static void mw_mirth_type_StackType_c99Z_reprZ_semiZ_transparent (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 0LL: { // STACK_TYPE_ERROR
			int64_t v0 = 0LL /* C99RT_VAL */;
			push_resource(x2);
			push_i64(v0);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			int64_t v1 = 0LL /* C99RT_VAL */;
			push_resource(x2);
			push_i64(v1);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			int64_t v2 = 0LL /* C99RT_VAL */;
			push_resource(x2);
			push_i64(v2);
		} break;
		case 3LL: { // STVar
			push_resource(x2);
			uint64_t v3 = mtp_mirth_type_StackType_STVar(x1);
			int64_t v4 = 0LL /* C99RT_VAL */;
			push_i64(v4);
		} break;
		case 4LL: { // STMeta
			push_resource(x2);
			uint64_t v5 = mtp_mirth_type_StackType_STMeta(x1);
			push_u64(v5);
			VAL v6 = mw_mirth_type_MetaVar_typeZAsk(v5);
			switch (get_data_tag(v6)) {
				case 0LL: { // None
					uint64_t v7 = pop_u64();
					int64_t v8 = 0LL /* C99RT_VAL */;
					push_i64(v8);
				} break;
				case 1LL: { // Some
					VAL v9 = mtp_std_maybe_Maybe_1_Some(v6);
					VAL v10 = mw_mirth_type_Type_expand(v9);
					incref(v10);
					VAL v11 = pop_value();
					push_value(v10);
					push_value(v11);
					VAL v12 = mtw_std_maybe_Maybe_1_Some(v10);
					uint64_t v13 = pop_u64();
					void* v14 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v13);
					mut_set(v12, MKPTR(v14));
					VAL v15 = pop_value();
					VAL v16 = mw_mirth_type_Type_ZToStackType(v15);
					VAL r17 = pop_resource();
					mw_mirth_type_StackType_c99Z_reprZ_semiZ_transparent(v16, r17);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 5LL: { // STCons
			push_resource(x2);
			mtp_mirth_type_StackType_STCons(x1);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			decref(v19);
			VAL r20 = pop_resource();
			mw_mirth_type_Type_c99Z_repr(v18, r20);
		} break;
		case 6LL: { // STConsLabel
			push_resource(x2);
			mtp_mirth_type_StackType_STConsLabel(x1);
			uint64_t v21 = pop_u64();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			decref(v23);
			VAL r24 = pop_resource();
			mw_mirth_type_Type_c99Z_repr(v22, r24);
		} break;
		case 7LL: { // STWith
			push_resource(x2);
			mtp_mirth_type_StackType_STWith(x1);
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			decref(v26);
			VAL r27 = pop_resource();
			mw_mirth_type_Resource_c99Z_repr(v25, r27);
		} break;
		case 8LL: { // STWithLabel
			push_resource(x2);
			mtp_mirth_type_StackType_STWithLabel(x1);
			uint64_t v28 = pop_u64();
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			decref(v30);
			VAL r31 = pop_resource();
			mw_mirth_type_Resource_c99Z_repr(v29, r31);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
}
static void mw_mirth_c99_ZPlusC99Local_rdup (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[1]);
	VAL v1 = VVAL(VTUP(x1)->cells[2]);
	incref(v1);
	push_resource(x1);
	VAL v2 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v0, v1));
	push_resource(v2);
}
static void mw_mirth_c99_ZPlusC99Local_rdrop (VAL x1) {
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_repr));
	VAL v1 = lpop(&lbl_localZ_name);
	decref(v1);
}
static void mw_mirth_c99_C99ReprType_newZ_localZBang (int64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	lpush(&lbl_localZ_repr, MKI64(x1));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v0);
	VAL r1 = pop_resource();
	VTUP(x2)->cells[1] = r1;
	VAL v2 = pop_value();
	VAL v3 = (VVAL(VTUP(x2)->cells[1]));
	lpush(&lbl_localZ_name, v2);
	VAL v4 = (mw_mirth_c99_ZPlusC99_indent(v3));
	int64_t v5 = VI64(lpop(&lbl_localZ_repr));
	push_resource(v4);
	lpush(&lbl_localZ_repr, MKI64(v5));
	VAL v6 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v5);
	VAL r7 = pop_resource();
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(v6, r7));
	STR* v9;
	STRLIT(v9, " ", 1);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	VAL v11 = lpop(&lbl_localZ_name);
	incref(v11);
	lpush(&lbl_localZ_name, v11);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(v11, v10));
	STR* v13;
	STRLIT(v13, ";", 1);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = (mw_mirth_c99_ZPlusC99_line(v14));
	VTUP(x2)->cells[1] = v15;
	VAL v16 = lpop(&lbl_localZ_name);
	int64_t v17 = VI64(lpop(&lbl_localZ_repr));
	push_resource(x2);
	VAL v18 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v17, v16));
	push_resource(v18);
}
static void mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang (int64_t x1, VAL x2) {
	lpush(&lbl_localZ_repr, MKI64(x1));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(x2);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	lpush(&lbl_localZ_name, v0);
	VAL v2 = (mw_mirth_c99_ZPlusC99_indent(r1));
	int64_t v3 = VI64(lpop(&lbl_localZ_repr));
	push_resource(v2);
	lpush(&lbl_localZ_repr, MKI64(v3));
	VAL v4 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v3);
	VAL r5 = pop_resource();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v4, r5));
	STR* v7;
	STRLIT(v7, " ", 1);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = lpop(&lbl_localZ_name);
	incref(v9);
	lpush(&lbl_localZ_name, v9);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v9, v8));
	STR* v11;
	STRLIT(v11, " = ", 3);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	int64_t v13 = VI64(lpop(&lbl_localZ_repr));
	push_resource(v12);
	lpush(&lbl_localZ_repr, MKI64(v13));
	VAL v14 = mw_mirth_c99_C99ReprType_popZ_macro(v13);
	VAL r15 = pop_resource();
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v14, r15));
	STR* v17;
	STRLIT(v17, "();", 3);
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
	VAL v19 = (mw_mirth_c99_ZPlusC99_line(v18));
	VAL v20 = lpop(&lbl_localZ_name);
	int64_t v21 = VI64(lpop(&lbl_localZ_repr));
	push_resource(v19);
	VAL v22 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v21, v20));
	push_resource(v22);
}
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x2);
	VAL r0 = pop_resource();
	VAL v1 = (mw_mirth_c99_ZPlusC99_indent(r0));
	int64_t v2 = VI64(lpop(&lbl_localZ_repr));
	push_resource(v1);
	VAL v3 = mw_mirth_c99_C99ReprType_pushZ_macro(v2);
	VAL r4 = pop_resource();
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(v3, r4));
	STR* v6;
	STRLIT(v6, "(", 1);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL v8 = lpop(&lbl_localZ_name);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
	STR* v10;
	STRLIT(v10, ");", 2);
	VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
	VAL v12 = (mw_mirth_c99_ZPlusC99_line(v11));
	return v12;
}
static VAL mw_mirth_c99_ZPlusC99Local_consume (VAL x1) {
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_repr));
	VAL v1 = lpop(&lbl_localZ_name);
	return v1;
}
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL (VAL x1) {
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_repr));
	switch (v0) {
		case 0LL: { // C99RT_VAL
			VAL v1 = lpop(&lbl_localZ_name);
			push_value(v1);
		} break;
		default: {
			STR* v2;
			STRLIT(v2, "", 0);
			push_resource(MKSTR(v2));
			VAL v3 = mw_mirth_c99_C99ReprType_mkZ_macro(v0);
			VAL r4 = pop_resource();
			VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(v3, r4));
			STR* v6;
			STRLIT(v6, "(", 1);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), v5));
			VAL v8 = lpop(&lbl_localZ_name);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(v8, v7));
			STR* v10;
			STRLIT(v10, ")", 1);
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), v9));
			push_value(v11);
		} break;
	}
	VAL v12 = pop_value();
	return v12;
}
static VAL mw_mirth_c99_ZPlusC99Local_consumeZ_as (int64_t x1, VAL x2) {
	switch (x1) {
		case 0LL: { // C99RT_VAL
			VAL v0 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(x2);
			push_value(v0);
		} break;
		default: {
			push_i64(x1);
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x2);
			int64_t v1 = VI64(lpop(&lbl_localZ_repr));
			switch (v1) {
				case 0LL: { // C99RT_VAL
					STR* v2;
					STRLIT(v2, "", 0);
					int64_t v3 = pop_i64();
					lpush(&lbl_localZ_repr, MKI64(v1));
					push_resource(MKSTR(v2));
					VAL v4 = mw_mirth_c99_C99ReprType_vZ_macro(v3);
					VAL r5 = pop_resource();
					VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(v4, r5));
					STR* v7;
					STRLIT(v7, "(", 1);
					VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
					VAL v9 = lpop(&lbl_localZ_name);
					VAL v10 = (mw_std_str_ZPlusStr_pushZ_strZBang(v9, v8));
					STR* v11;
					STRLIT(v11, ")", 1);
					VAL v12 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v11), v10));
					push_value(v12);
				} break;
				default: {
					VAL v13 = pop_value();
					incref(v13);
					lpush(&lbl_localZ_repr, MKI64(v1));
					push_value(v13);
					int64_t v14 = mw_mirth_c99_C99ReprType_ZEqualZEqual(v1, VI64(v13));
					if (((bool)v14)) {
						int64_t v15 = pop_i64();
						VAL v16 = lpop(&lbl_localZ_name);
						push_value(v16);
					} else {
						int64_t v17 = pop_i64();
						push_i64(v17);
						int64_t v18 = mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk(v17);
						int64_t v19 = VI64(lpop(&lbl_localZ_repr));
						push_i64(v18);
						lpush(&lbl_localZ_repr, MKI64(v19));
						int64_t v20 = mw_mirth_c99_C99ReprType_isZ_intZ_likeZAsk(v19);
						bool v21 = pop_bool();
						bool v22 = (v21 && ((bool)v20));
						if (v22) {
							STR* v23;
							STRLIT(v23, "", 0);
							STR* v24;
							STRLIT(v24, "((", 2);
							VAL v25 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v24), MKSTR(v23)));
							int64_t v26 = pop_i64();
							push_resource(v25);
							VAL v27 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v26);
							VAL r28 = pop_resource();
							VAL v29 = (mw_std_str_ZPlusStr_pushZ_strZBang(v27, r28));
							STR* v30;
							STRLIT(v30, ")", 1);
							VAL v31 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v30), v29));
							VAL v32 = lpop(&lbl_localZ_name);
							VAL v33 = (mw_std_str_ZPlusStr_pushZ_strZBang(v32, v31));
							STR* v34;
							STRLIT(v34, ")", 1);
							VAL v35 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v34), v33));
							push_value(v35);
						} else {
							STR* v36;
							STRLIT(v36, "attempted to cast between incompatible C99 repr types", 53);
							push_str(v36);
							do_panic();
						}
					}
				} break;
			}
			int64_t v37 = VI64(lpop(&lbl_localZ_repr));
		} break;
	}
	VAL v38 = pop_value();
	return v38;
}
static VAL mw_mirth_c99_ZPlusC99Local_dropZ_localZBang (VAL x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[1]);
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		VAL v3 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r2);
		VAL r4 = pop_resource();
		VAL v5 = (VVAL(VTUP(r4)->cells[1]));
		push_value(v3);
		VAL v6 = (mw_mirth_c99_ZPlusC99_indent(v5));
		STR* v7;
		STRLIT(v7, "decref(", 7);
		VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
		VAL v9 = pop_value();
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(v9, v8));
		STR* v11;
		STRLIT(v11, ");", 2);
		VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
		VAL v13 = (mw_mirth_c99_ZPlusC99_line(v12));
		VTUP(r4)->cells[1] = v13;
		push_resource(r4);
	} else {
		VAL r14 = pop_resource();
		mw_mirth_c99_ZPlusC99Local_rdrop(r14);
	}
	VAL r15 = pop_resource();
	return r15;
}
static void mw_mirth_c99_ZPlusC99Local_dupZ_localZBang (VAL x1, VAL x2) {
	int64_t v0 = VI64(VTUP(x2)->cells[1]);
	push_resource(x1);
	push_resource(x2);
	int64_t v1 = mw_mirth_c99_C99ReprType_needsZ_refcountingZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		mw_mirth_c99_ZPlusC99Local_rdup(r2);
		VAL r3 = pop_resource();
		VAL v4 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r3);
		VAL r5 = pop_resource();
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[1]));
		push_value(v4);
		VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v7));
		STR* v9;
		STRLIT(v9, "incref(", 7);
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
		VAL v11 = pop_value();
		VAL v12 = (mw_mirth_c99_ZPlusC99_put(v11, v10));
		STR* v13;
		STRLIT(v13, ");", 2);
		VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
		VAL v15 = (mw_mirth_c99_ZPlusC99_line(v14));
		VTUP(r6)->cells[1] = v15;
		push_resource(r6);
		push_resource(r5);
	} else {
	}
	VAL r16 = pop_resource();
	mw_mirth_c99_ZPlusC99Local_rdup(r16);
}
static void mw_mirth_c99_ZPlusC99Local_peekZ_dataZ_tag (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[1]);
	switch (v0) {
		case 0LL: { // C99RT_VAL
			VAL v1 = VVAL(VTUP(x1)->cells[2]);
			incref(v1);
			STR* v2;
			STRLIT(v2, "", 0);
			STR* v3;
			STRLIT(v3, "get_data_tag(", 13);
			push_value(v1);
			push_resource(x1);
			VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), MKSTR(v2)));
			VAL v5 = pop_value();
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(v5, v4));
			STR* v7;
			STRLIT(v7, ")", 1);
			VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
			push_value(v8);
		} break;
		default: {
			VAL v9 = VVAL(VTUP(x1)->cells[2]);
			incref(v9);
			push_value(v9);
			push_resource(x1);
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99LocalResource_rdup (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[1]);
	VAL v1 = VVAL(VTUP(x1)->cells[2]);
	incref(v1);
	push_resource(x1);
	VAL v2 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v0, v1));
	push_resource(v2);
}
static void mw_mirth_c99_ZPlusC99LocalResource_rdrop (VAL x1) {
	VAL v0 = mw_mirth_c99_ZPlusC99LocalResource_consume(x1);
	decref(v0);
}
static VAL mw_mirth_c99_ZPlusC99Local_turnZ_intoZ_resourceZBang (VAL x1) {
	mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_repr));
	VAL v1 = lpop(&lbl_localZ_name);
	VAL v2 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v0, v1));
	return v2;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang (VAL x1) {
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	VAL v1 = lpop(&lbl_localZ_resourceZ_name);
	VAL v2 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v0, v1));
	return v2;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_dropZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2) {
	push_resource(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(x2));
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(r1, v0));
	return v2;
}
static void mw_mirth_c99_ZPlusC99LocalResource_dupZ_localZ_resourceZ_asZ_valueZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mw_mirth_c99_ZPlusC99LocalResource_rdup(x2);
	VAL r0 = pop_resource();
	VAL v1 = (mw_mirth_c99_ZPlusC99LocalResource_turnZ_intoZ_valueZBang(r0));
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	mw_mirth_c99_ZPlusC99Local_dupZ_localZBang(r3, v1);
	VAL r4 = pop_resource();
	mw_mirth_c99_ZPlusC99Local_rdrop(r4);
	VAL r5 = pop_resource();
	push_resource(r2);
	push_resource(r5);
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_consume (VAL x1) {
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	VAL v1 = lpop(&lbl_localZ_resourceZ_name);
	return v1;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL (VAL x1) {
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x1);
	int64_t v0 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	switch (v0) {
		case 0LL: { // C99RT_VAL
			VAL v1 = lpop(&lbl_localZ_resourceZ_name);
			push_value(v1);
		} break;
		default: {
			STR* v2;
			STRLIT(v2, "", 0);
			push_resource(MKSTR(v2));
			VAL v3 = mw_mirth_c99_C99ReprType_mkZ_macro(v0);
			VAL r4 = pop_resource();
			VAL v5 = (mw_std_str_ZPlusStr_pushZ_strZBang(v3, r4));
			STR* v6;
			STRLIT(v6, "(", 1);
			VAL v7 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v6), v5));
			VAL v8 = lpop(&lbl_localZ_resourceZ_name);
			VAL v9 = (mw_std_str_ZPlusStr_pushZ_strZBang(v8, v7));
			STR* v10;
			STRLIT(v10, ")", 1);
			VAL v11 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v10), v9));
			push_value(v11);
		} break;
	}
	VAL v12 = pop_value();
	return v12;
}
static void mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang (VAL x1, int64_t x2) {
	lpush(&lbl_localZ_resourceZ_repr, MKI64(x2));
	mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang(x1);
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	lpush(&lbl_localZ_resourceZ_name, v0);
	VAL v2 = (mw_mirth_c99_ZPlusC99_indent(r1));
	int64_t v3 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	push_resource(v2);
	lpush(&lbl_localZ_resourceZ_repr, MKI64(v3));
	VAL v4 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v3);
	VAL r5 = pop_resource();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v4, r5));
	STR* v7;
	STRLIT(v7, " ", 1);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = lpop(&lbl_localZ_resourceZ_name);
	incref(v9);
	lpush(&lbl_localZ_resourceZ_name, v9);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(v9, v8));
	STR* v11;
	STRLIT(v11, " = ", 3);
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
	int64_t v13 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	switch (v13) {
		case 0LL: { // C99RT_VAL
			STR* v14;
			STRLIT(v14, "pop_resource()", 14);
			lpush(&lbl_localZ_resourceZ_repr, MKI64(v13));
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v12));
			push_resource(v15);
		} break;
		default: {
			push_resource(v12);
			lpush(&lbl_localZ_resourceZ_repr, MKI64(v13));
			VAL v16 = mw_mirth_c99_C99ReprType_vZ_macro(v13);
			VAL r17 = pop_resource();
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(v16, r17));
			STR* v19;
			STRLIT(v19, "(pop_resource())", 16);
			VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
			push_resource(v20);
		} break;
	}
	STR* v21;
	STRLIT(v21, ";", 1);
	VAL r22 = pop_resource();
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), r22));
	VAL v24 = (mw_mirth_c99_ZPlusC99_line(v23));
	VAL v25 = lpop(&lbl_localZ_resourceZ_name);
	int64_t v26 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	push_resource(v24);
	VAL v27 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v26, v25));
	push_resource(v27);
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang (VAL x1, VAL x2) {
	push_resource(x1);
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(x2);
	VAL r0 = pop_resource();
	VAL v1 = (mw_mirth_c99_ZPlusC99_indent(r0));
	STR* v2;
	STRLIT(v2, "push_resource(", 14);
	VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v2), v1));
	int64_t v4 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	switch (v4) {
		case 0LL: { // C99RT_VAL
			VAL v5 = lpop(&lbl_localZ_resourceZ_name);
			VAL v6 = (mw_mirth_c99_ZPlusC99_put(v5, v3));
			push_resource(v6);
		} break;
		default: {
			push_resource(v3);
			VAL v7 = mw_mirth_c99_C99ReprType_mkZ_macro(v4);
			VAL r8 = pop_resource();
			VAL v9 = (mw_mirth_c99_ZPlusC99_put(v7, r8));
			STR* v10;
			STRLIT(v10, "(", 1);
			VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
			VAL v12 = lpop(&lbl_localZ_resourceZ_name);
			VAL v13 = (mw_mirth_c99_ZPlusC99_put(v12, v11));
			STR* v14;
			STRLIT(v14, ")", 1);
			VAL v15 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v14), v13));
			push_resource(v15);
		} break;
	}
	STR* v16;
	STRLIT(v16, ");", 2);
	VAL r17 = pop_resource();
	VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), r17));
	VAL v19 = (mw_mirth_c99_ZPlusC99_line(v18));
	return v19;
}
static void mw_mirth_c99_ZPlusC99LocalResource_peekZ_dataZ_tag (VAL x1) {
	int64_t v0 = VI64(VTUP(x1)->cells[1]);
	switch (v0) {
		case 0LL: { // C99RT_VAL
			VAL v1 = VVAL(VTUP(x1)->cells[2]);
			incref(v1);
			STR* v2;
			STRLIT(v2, "", 0);
			STR* v3;
			STRLIT(v3, "get_data_tag(", 13);
			push_value(v1);
			push_resource(x1);
			VAL v4 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v3), MKSTR(v2)));
			VAL v5 = pop_value();
			VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(v5, v4));
			STR* v7;
			STRLIT(v7, ")", 1);
			VAL v8 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v7), v6));
			push_value(v8);
		} break;
		default: {
			VAL v9 = VVAL(VTUP(x1)->cells[2]);
			incref(v9);
			push_value(v9);
			push_resource(x1);
		} break;
	}
}
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // +Left
			push_resource(x1);
			VAL v0 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x2));
			VAL r1 = pop_resource();
			VAL v2 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r1, v0));
			push_resource(v2);
		} break;
		case 1LL: { // +Right
			push_resource(x1);
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x2));
			VAL r4 = pop_resource();
			VAL v5 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r4, v3));
			push_resource(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
	VAL r6 = pop_resource();
	return r6;
}
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_peekZ_dataZ_tag (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v0 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			mw_mirth_c99_ZPlusC99Local_peekZ_dataZ_tag(v0);
			VAL r1 = pop_resource();
			VAL v2 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(r1));
			push_resource(v2);
		} break;
		case 1LL: { // +Right
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			mw_mirth_c99_ZPlusC99LocalResource_peekZ_dataZ_tag(v3);
			VAL r4 = pop_resource();
			VAL v5 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(r4));
			push_resource(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v0 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			mw_mirth_c99_ZPlusC99Local_rdup(v0);
			VAL r1 = pop_resource();
			VAL v2 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(r1));
			VAL r3 = pop_resource();
			VAL v4 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(r3));
			push_resource(v4);
			push_resource(v2);
		} break;
		case 1LL: { // +Right
			VAL v5 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			mw_mirth_c99_ZPlusC99LocalResource_rdup(v5);
			VAL r6 = pop_resource();
			VAL v7 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(r6));
			VAL r8 = pop_resource();
			VAL v9 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(r8));
			push_resource(v9);
			push_resource(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v0 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			mw_mirth_c99_ZPlusC99Local_rdrop(v0);
		} break;
		case 1LL: { // +Right
			VAL v1 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			mw_mirth_c99_ZPlusC99LocalResource_rdrop(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99LocalValueZDivResource_consumeZ_asZ_VAL (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +Left
			VAL v0 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(x1));
			VAL v1 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v0);
			push_value(v1);
		} break;
		case 1LL: { // +Right
			VAL v2 = (mtp_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(x1));
			VAL v3 = mw_mirth_c99_ZPlusC99LocalResource_consumeZ_asZ_VAL(v2);
			push_value(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v4 = pop_value();
	return v4;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_data_Data_isZ_resourceZAsk(x1);
	if (((bool)v0)) {
		VAL r1 = pop_resource();
		VAL v2 = (VVAL(VTUP(r1)->cells[1]));
		VAL v3 = (VVAL(VTUP(v2)->cells[6]));
		uint64_t v4 = pop_u64();
		mw_mirth_data_Data_c99Z_repr(v4, v3);
		VAL r5 = pop_resource();
		VTUP(v2)->cells[6] = r5;
		VTUP(r1)->cells[1] = v2;
		int64_t v6 = pop_i64();
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r1, v6);
		VAL r7 = pop_resource();
		VAL v8 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusRight(r7));
		push_resource(v8);
	} else {
		VAL r9 = pop_resource();
		VAL v10 = (VVAL(VTUP(r9)->cells[1]));
		VAL v11 = (VVAL(VTUP(v10)->cells[6]));
		uint64_t v12 = pop_u64();
		mw_mirth_data_Data_c99Z_repr(v12, v11);
		VAL r13 = pop_resource();
		VTUP(v10)->cells[6] = r13;
		VTUP(r9)->cells[1] = v10;
		int64_t v14 = pop_i64();
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r9, v14);
		VAL r15 = pop_resource();
		VAL v16 = (mtw_mirth_c99_ZPlusC99LocalValueZDivResource_ZPlusLeft(r15));
		push_resource(v16);
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
			int64_t v0 = (0LL /* +C99LocalNone */);
			int64_t v1 = (0LL /* +SCNil */);
			push_resource(MKI64(v0));
			push_resource(MKI64(v1));
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1);
			VAL r2 = pop_resource();
			VAL v3 = (mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(r2));
			VAL r4 = pop_resource();
			push_resource(v3);
			push_resource(r4);
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1);
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(r6);
			VAL r7 = pop_resource();
			VAL v8 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(r7, r5));
			push_resource(v8);
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1);
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(r10);
			uint64_t v11 = pop_u64();
			VAL r12 = pop_resource();
			VAL v13 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(r12, r9, v11));
			push_resource(v13);
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1);
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(r15);
			uint64_t v16 = pop_u64();
			VAL r17 = pop_resource();
			VAL v18 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(r17, r14, v16));
			push_resource(v18);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
			int64_t v0 = (0LL /* +C99LocalResourceNone */);
			int64_t v1 = (0LL /* +SCNil */);
			push_resource(MKI64(v0));
			push_resource(MKI64(v1));
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1);
			VAL r2 = pop_resource();
			VAL v3 = (mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(r2));
			VAL r4 = pop_resource();
			push_resource(v3);
			push_resource(r4);
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1);
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(r6);
			VAL r7 = pop_resource();
			VAL v8 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(r7, r5));
			push_resource(v8);
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1);
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(r10);
			uint64_t v11 = pop_u64();
			VAL r12 = pop_resource();
			VAL v13 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(r12, r9, v11));
			push_resource(v13);
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1);
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(r15);
			uint64_t v16 = pop_u64();
			VAL r17 = pop_resource();
			VAL v18 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(r17, r14, v16));
			push_resource(v18);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			int64_t v0 = (0LL /* +C99LocalNone */);
			int64_t v1 = (0LL /* +SCNil */);
			push_u64(x1);
			push_resource(MKI64(v0));
			push_resource(MKI64(v1));
		} break;
		case 1LL: { // +SCCons
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			uint64_t v4 = pop_u64();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(v4, r3);
			VAL r5 = pop_resource();
			VAL v6 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(r5, r2));
			push_resource(v6);
		} break;
		case 2LL: { // +SCWith
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			uint64_t v9 = pop_u64();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(v9, r8);
			VAL r10 = pop_resource();
			VAL v11 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(r10, r7));
			push_resource(v11);
		} break;
		case 4LL: { // +SCWithLabel
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2);
			uint64_t v12 = pop_u64();
			VAL r13 = pop_resource();
			VAL r14 = pop_resource();
			uint64_t v15 = pop_u64();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(v15, r14);
			VAL r16 = pop_resource();
			VAL v17 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(r16, r13, v12));
			push_resource(v17);
		} break;
		case 3LL: { // +SCConsLabel
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			incref(v19);
			incref(v18);
			push_value(v19);
			push_value(v18);
			int64_t v20 = mw_mirth_label_Label_ZEqualZEqual(VU64(v19), VU64(v18));
			if (((bool)v20)) {
				uint64_t v21 = pop_u64();
				VAL r22 = pop_resource();
				VAL v23 = (mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(r22));
				VAL r24 = pop_resource();
				push_resource(v23);
				push_resource(r24);
			} else {
				uint64_t v25 = pop_u64();
				VAL r26 = pop_resource();
				VAL r27 = pop_resource();
				uint64_t v28 = pop_u64();
				mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(v28, r27);
				VAL r29 = pop_resource();
				VAL v30 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(r29, r26, v25));
				push_resource(v30);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk (uint64_t x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			int64_t v0 = (0LL /* +C99LocalResourceNone */);
			int64_t v1 = (0LL /* +SCNil */);
			push_u64(x1);
			push_resource(MKI64(v0));
			push_resource(MKI64(v1));
		} break;
		case 1LL: { // +SCCons
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			uint64_t v4 = pop_u64();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(v4, r3);
			VAL r5 = pop_resource();
			VAL v6 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(r5, r2));
			push_resource(v6);
		} break;
		case 2LL: { // +SCWith
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			uint64_t v9 = pop_u64();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(v9, r8);
			VAL r10 = pop_resource();
			VAL v11 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(r10, r7));
			push_resource(v11);
		} break;
		case 3LL: { // +SCConsLabel
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2);
			uint64_t v12 = pop_u64();
			VAL r13 = pop_resource();
			VAL r14 = pop_resource();
			uint64_t v15 = pop_u64();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(v15, r14);
			VAL r16 = pop_resource();
			VAL v17 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(r16, r13, v12));
			push_resource(v17);
		} break;
		case 4LL: { // +SCWithLabel
			push_u64(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2);
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			incref(v19);
			incref(v18);
			push_value(v19);
			push_value(v18);
			int64_t v20 = mw_mirth_label_Label_ZEqualZEqual(VU64(v19), VU64(v18));
			if (((bool)v20)) {
				uint64_t v21 = pop_u64();
				VAL r22 = pop_resource();
				VAL v23 = (mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(r22));
				VAL r24 = pop_resource();
				push_resource(v23);
				push_resource(r24);
			} else {
				uint64_t v25 = pop_u64();
				VAL r26 = pop_resource();
				VAL r27 = pop_resource();
				uint64_t v28 = pop_u64();
				mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(v28, r27);
				VAL r29 = pop_resource();
				VAL v30 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(r29, r26, v25));
				push_resource(v30);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_u64(x1);
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang (VAL x1, VAL x2) {
	switch (get_data_tag(x2)) {
		case 0LL: { // +SCNil
			push_resource(x1);
		} break;
		case 1LL: { // +SCCons
			push_resource(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x2);
			VAL r0 = pop_resource();
			VAL r1 = pop_resource();
			VAL r2 = pop_resource();
			VAL v3 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(r2, r1));
			VAL v4 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang(v3, r0));
			push_resource(v4);
		} break;
		case 2LL: { // +SCWith
			push_resource(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x2);
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			VAL r7 = pop_resource();
			VAL v8 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(r7, r6));
			VAL v9 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang(v8, r5));
			push_resource(v9);
		} break;
		case 3LL: { // +SCConsLabel
			push_resource(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x2);
			VAL r10 = pop_resource();
			VAL r11 = pop_resource();
			VAL r12 = pop_resource();
			VAL v13 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(r12, r11));
			uint64_t v14 = pop_u64();
			VAL v15 = (mw_mirth_c99_pushZ_localZ_labelZ_directZBang(v14, v13, r10));
			push_resource(v15);
		} break;
		case 4LL: { // +SCWithLabel
			push_resource(x1);
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x2);
			VAL r16 = pop_resource();
			VAL r17 = pop_resource();
			VAL r18 = pop_resource();
			VAL v19 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(r18, r17));
			uint64_t v20 = pop_u64();
			VAL v21 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang(v20, v19, r16));
			push_resource(v21);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
	VAL r22 = pop_resource();
	return r22;
}
static void mw_mirth_c99_ZPlusC99StackCache_rdup (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
			int64_t v0 = (0LL /* +SCNil */);
			int64_t v1 = (0LL /* +SCNil */);
			push_resource(MKI64(v0));
			push_resource(MKI64(v1));
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_rdup(r3);
			mw_mirth_c99_ZPlusC99Local_rdup(r2);
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			push_resource(r5);
			VAL v7 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(r6, r4));
			VAL r8 = pop_resource();
			VAL r9 = pop_resource();
			VAL v10 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(r9, r8));
			push_resource(v10);
			push_resource(v7);
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1);
			VAL r11 = pop_resource();
			VAL r12 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_rdup(r12);
			mw_mirth_c99_ZPlusC99LocalResource_rdup(r11);
			VAL r13 = pop_resource();
			VAL r14 = pop_resource();
			VAL r15 = pop_resource();
			push_resource(r14);
			VAL v16 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(r15, r13));
			VAL r17 = pop_resource();
			VAL r18 = pop_resource();
			VAL v19 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(r18, r17));
			push_resource(v19);
			push_resource(v16);
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1);
			uint64_t v20 = pop_u64();
			VAL r21 = pop_resource();
			VAL r22 = pop_resource();
			push_u64(v20);
			push_u64(v20);
			mw_mirth_c99_ZPlusC99StackCache_rdup(r22);
			mw_mirth_c99_ZPlusC99Local_rdup(r21);
			VAL r23 = pop_resource();
			VAL r24 = pop_resource();
			VAL r25 = pop_resource();
			uint64_t v26 = pop_u64();
			push_resource(r24);
			VAL v27 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(r25, r23, v26));
			uint64_t v28 = pop_u64();
			VAL r29 = pop_resource();
			VAL r30 = pop_resource();
			VAL v31 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(r30, r29, v28));
			push_resource(v31);
			push_resource(v27);
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1);
			uint64_t v32 = pop_u64();
			VAL r33 = pop_resource();
			VAL r34 = pop_resource();
			push_u64(v32);
			push_u64(v32);
			mw_mirth_c99_ZPlusC99StackCache_rdup(r34);
			mw_mirth_c99_ZPlusC99LocalResource_rdup(r33);
			VAL r35 = pop_resource();
			VAL r36 = pop_resource();
			VAL r37 = pop_resource();
			uint64_t v38 = pop_u64();
			push_resource(r36);
			VAL v39 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(r37, r35, v38));
			uint64_t v40 = pop_u64();
			VAL r41 = pop_resource();
			VAL r42 = pop_resource();
			VAL v43 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(r42, r41, v40));
			push_resource(v43);
			push_resource(v39);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_rdrop (VAL x1) {
	switch (get_data_tag(x1)) {
		case 0LL: { // +SCNil
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(x1);
			VAL r0 = pop_resource();
			mw_mirth_c99_ZPlusC99Local_rdrop(r0);
			VAL r1 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_rdrop(r1);
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(x1);
			VAL r2 = pop_resource();
			mw_mirth_c99_ZPlusC99LocalResource_rdrop(r2);
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_rdrop(r3);
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel(x1);
			uint64_t v4 = pop_u64();
			VAL r5 = pop_resource();
			mw_mirth_c99_ZPlusC99Local_rdrop(r5);
			VAL r6 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_rdrop(r6);
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel(x1);
			uint64_t v7 = pop_u64();
			VAL r8 = pop_resource();
			mw_mirth_c99_ZPlusC99LocalResource_rdrop(r8);
			VAL r9 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_rdrop(r9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang (VAL x1) {
	mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(x1);
	VAL v0 = (lpop(&lbl_ZPlusstack));
	VAL v1 = (lpop(&lbl_ZPluscore));
	VAL v2 = (mtw_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit(v1, v0));
	return v2;
}
static VAL mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang (VAL x1) {
	mtp_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit(x1);
	VAL v0 = (lpop(&lbl_ZPlusstack));
	mw_mirth_c99_ZPlusC99StackCache_rdrop(v0);
	VAL v1 = (lpop(&lbl_ZPluscore));
	VAL v2 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v1));
	return v2;
}
static VAL mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1 (VAL x1, VAL x2) {
	push_resource(x1);
	push_value(x2);
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL r1 = pop_resource();
		mtp_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit(r1);
		VAL v2 = (lpop(&lbl_ZPlusstack));
		mw_mirth_c99_ZPlusC99StackCache_rdup(v2);
		VAL r3 = pop_resource();
		VAL r4 = pop_resource();
		VAL v5 = (lpop(&lbl_ZPluscore));
		VAL v6 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(v5, r3));
		push_resource(v6);
		incref(var_f);
		run_value(var_f);
		VAL r7 = pop_resource();
		VAL v8 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(r7));
		VAL v9 = (mtw_mirth_c99_ZPlusC99BranchSplit_ZPlusC99BranchSplit(v8, r4));
		decref(var_f);
		push_resource(v9);
	}
	VAL r10 = pop_resource();
	return r10;
}
static VAL mw_mirth_c99_ZPlusC99_startZ_branchZBang (VAL x1) {
	int64_t v0 = (0LL /* +SCNil */);
	VAL v1 = (mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(x1, MKI64(v0)));
	return v1;
}
static VAL mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang (VAL x1) {
	mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch(x1);
	VAL v0 = (lpop(&lbl_ZPluscore));
	VAL v1 = (lpop(&lbl_ZPlusstack));
	VAL v2 = (mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang(v0, v1));
	return v2;
}
static VAL mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang (VAL x1) {
	VAL v0 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x1));
	VAL v1 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v0));
	return v1;
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang (VAL x1, int64_t x2) {
	VAL v0 = (VVAL(VTUP(x1)->cells[2]));
	push_i64(x2);
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk(v0);
	VAL r1 = pop_resource();
	VTUP(x1)->cells[2] = r1;
	VAL r2 = pop_resource();
	switch (get_data_tag(r2)) {
		case 1LL: { // +C99LocalSome
			push_resource(x1);
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(r2));
			int64_t v4 = pop_i64();
			push_resource(v3);
		} break;
		case 0LL: { // +C99LocalNone
			VAL v5 = (VVAL(VTUP(x1)->cells[1]));
			int64_t v6 = pop_i64();
			mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang(v6, v5);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			VTUP(x1)->cells[1] = r8;
			push_resource(x1);
			push_resource(r7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang (int64_t x1, uint64_t x2, VAL x3) {
	VAL v0 = (VVAL(VTUP(x3)->cells[2]));
	push_i64(x1);
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk(x2, v0);
	VAL r1 = pop_resource();
	VTUP(x3)->cells[2] = r1;
	VAL r2 = pop_resource();
	switch (get_data_tag(r2)) {
		case 1LL: { // +C99LocalSome
			push_resource(x3);
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome(r2));
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			push_resource(v3);
		} break;
		case 0LL: { // +C99LocalNone
			VAL v6 = (VVAL(VTUP(x3)->cells[1]));
			uint64_t v7 = pop_u64();
			int64_t v8 = pop_i64();
			mw_mirth_c99_popZ_localZ_labelZ_directZBang(v8, v7, v6);
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			VTUP(x3)->cells[1] = r10;
			push_resource(x3);
			push_resource(r9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x3);
		}
	}
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang (VAL x1, int64_t x2) {
	VAL v0 = (VVAL(VTUP(x1)->cells[2]));
	push_i64(x2);
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk(v0);
	VAL r1 = pop_resource();
	VTUP(x1)->cells[2] = r1;
	VAL r2 = pop_resource();
	switch (get_data_tag(r2)) {
		case 1LL: { // +C99LocalResourceSome
			push_resource(x1);
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(r2));
			int64_t v4 = pop_i64();
			push_resource(v3);
		} break;
		case 0LL: { // +C99LocalResourceNone
			VAL v5 = (VVAL(VTUP(x1)->cells[1]));
			int64_t v6 = pop_i64();
			mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang(v5, v6);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			VTUP(x1)->cells[1] = r8;
			push_resource(x1);
			push_resource(r7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x1);
		}
	}
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang (int64_t x1, uint64_t x2, VAL x3) {
	VAL v0 = (VVAL(VTUP(x3)->cells[2]));
	push_i64(x1);
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk(x2, v0);
	VAL r1 = pop_resource();
	VTUP(x3)->cells[2] = r1;
	VAL r2 = pop_resource();
	switch (get_data_tag(r2)) {
		case 1LL: { // +C99LocalResourceSome
			push_resource(x3);
			VAL v3 = (mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome(r2));
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			push_resource(v3);
		} break;
		case 0LL: { // +C99LocalResourceNone
			VAL v6 = (VVAL(VTUP(x3)->cells[1]));
			uint64_t v7 = pop_u64();
			int64_t v8 = pop_i64();
			mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang(v8, v7, v6);
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			VTUP(x3)->cells[1] = r10;
			push_resource(x3);
			push_resource(r9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x3);
		}
	}
}
static VAL mw_mirth_c99_ZPlusC99Local_pushZ_localZBang (VAL x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x1)->cells[2]));
	VAL v1 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons(v0, x2));
	VTUP(x1)->cells[2] = v1;
	return x1;
}
static VAL mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang (VAL x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x1)->cells[2]));
	VAL v1 = (mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith(v0, x2));
	VTUP(x1)->cells[2] = v1;
	return x1;
}
static VAL mw_mirth_c99_c99Z_binopZ_exprZBang (VAL x1, VAL x2, VAL x3, VAL x4) {
	lpush(&lbl_ZPlusarg1, x2);
	lpush(&lbl_ZPlusarg2, x3);
	push_resource(x4);
	mtp_mirth_c99_C99BinOp_C99BinOp(x1);
	VAL v0 = lpop(&lbl_prefix);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_c99_ZPlusC99_put(v0, r1));
	VAL v3 = (lpop(&lbl_ZPlusarg1));
	int64_t v4 = VI64(lpop(&lbl_arg1Z_type));
	push_resource(v2);
	VAL v5 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v4, v3);
	VAL r6 = pop_resource();
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(v5, r6));
	VAL v8 = lpop(&lbl_operator);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
	VAL v10 = (lpop(&lbl_ZPlusarg2));
	int64_t v11 = VI64(lpop(&lbl_arg2Z_type));
	push_resource(v9);
	VAL v12 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v11, v10);
	VAL r13 = pop_resource();
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v12, r13));
	VAL v15 = lpop(&lbl_suffix);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(v15, v14));
	int64_t v17 = VI64(lpop(&lbl_argsZ_swapped));
	VAL v18 = lpop(&lbl_outZ_type);
	decref(v18);
	return v16;
}
static VAL mw_mirth_c99_c99Z_binopZBang (VAL x1, VAL x2) {
	incref(x1);
	int64_t v0 = VI64(VTUP(x1)->cells[6]);
	decref(x1);
	if (((bool)v0)) {
		incref(x1);
		int64_t v1 = VI64(VTUP(x1)->cells[4]);
		decref(x1);
		push_value(x1);
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v1);
		VAL r2 = pop_resource();
		VAL v3 = pop_value();
		incref(v3);
		int64_t v4 = VI64(VTUP(v3)->cells[5]);
		decref(v3);
		VAL r5 = pop_resource();
		lpush(&lbl_ZPlusarg1, r2);
		push_value(v3);
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r5, v4);
		VAL r6 = pop_resource();
		lpush(&lbl_ZPlusarg2, r6);
	} else {
		incref(x1);
		int64_t v7 = VI64(VTUP(x1)->cells[5]);
		decref(x1);
		push_value(x1);
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v7);
		VAL r8 = pop_resource();
		VAL v9 = pop_value();
		incref(v9);
		int64_t v10 = VI64(VTUP(v9)->cells[4]);
		decref(v9);
		VAL r11 = pop_resource();
		lpush(&lbl_ZPlusarg2, r8);
		push_value(v9);
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r11, v10);
		VAL r12 = pop_resource();
		lpush(&lbl_ZPlusarg1, r12);
	}
	VAL v13 = pop_value();
	incref(v13);
	VAL v14 = VVAL(VTUP(v13)->cells[7]);
	incref(v14);
	decref(v13);
	switch (get_data_tag(v14)) {
		case 1LL: { // Some
			push_value(v13);
			VAL v15 = mtp_std_maybe_Maybe_1_Some(v14);
			VAL r16 = pop_resource();
			VAL v17 = (VVAL(VTUP(r16)->cells[1]));
			lpush(&lbl_localZ_repr, v15);
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v17);
			VAL v18 = pop_value();
			VAL r19 = pop_resource();
			int64_t v20 = VI64(lpop(&lbl_localZ_repr));
			VAL v21 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v20, v18));
			push_resource(v21);
			VAL v22 = (mw_mirth_c99_ZPlusC99_indent(r19));
			VAL r23 = pop_resource();
			int64_t v24 = VI64(VTUP(r23)->cells[1]);
			push_resource(r23);
			push_resource(v22);
			VAL v25 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v24);
			VAL r26 = pop_resource();
			VAL v27 = (mw_mirth_c99_ZPlusC99_put(v25, r26));
			STR* v28;
			STRLIT(v28, " ", 1);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
			VAL r30 = pop_resource();
			VAL v31 = VVAL(VTUP(r30)->cells[2]);
			incref(v31);
			push_resource(r30);
			VAL v32 = (mw_mirth_c99_ZPlusC99_put(v31, v29));
			STR* v33;
			STRLIT(v33, " = ", 3);
			VAL v34 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), v32));
			VAL r35 = pop_resource();
			VAL v36 = (lpop(&lbl_ZPlusarg2));
			VAL v37 = (lpop(&lbl_ZPlusarg1));
			VAL v38 = pop_value();
			VAL v39 = (mw_mirth_c99_c99Z_binopZ_exprZBang(v38, v37, v36, v34));
			STR* v40;
			STRLIT(v40, ";", 1);
			push_resource(r35);
			VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), v39));
			VAL v42 = (mw_mirth_c99_ZPlusC99_line(v41));
			VTUP(r16)->cells[1] = v42;
			VAL r43 = pop_resource();
			VAL v44 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r16, r43));
			push_resource(v44);
		} break;
		case 0LL: { // None
			VAL r45 = pop_resource();
			VAL v46 = (VVAL(VTUP(r45)->cells[1]));
			push_value(v13);
			VAL v47 = (mw_mirth_c99_ZPlusC99_indent(v46));
			VAL v48 = (lpop(&lbl_ZPlusarg2));
			VAL v49 = (lpop(&lbl_ZPlusarg1));
			VAL v50 = pop_value();
			VAL v51 = (mw_mirth_c99_c99Z_binopZ_exprZBang(v50, v49, v48, v47));
			VAL v52 = (mw_mirth_c99_ZPlusC99_line(v51));
			VTUP(r45)->cells[1] = v52;
			push_resource(r45);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_value(v13);
		}
	}
	VAL r53 = pop_resource();
	return r53;
}
static VAL mw_mirth_c99_C99BinOp_Mk (VAL x1, int64_t x2, VAL x3, int64_t x4, VAL x5, int64_t x6, VAL x7) {
	VAL v0 = mtw_mirth_c99_C99BinOp_C99BinOp(x1, x3, x5, x2, x4, x6, x7);
	return v0;
}
static VAL mw_mirth_c99_c99Z_primZ_binopZAsk (int64_t x1) {
	switch (x1) {
		case 20LL: { // PRIM_INT_ADD
			STR* v0;
			STRLIT(v0, "i64_add(", 8);
			int64_t v1 = 2LL /* C99RT_I64 */;
			STR* v2;
			STRLIT(v2, ", ", 2);
			int64_t v3 = 2LL /* C99RT_I64 */;
			STR* v4;
			STRLIT(v4, ")", 1);
			int64_t v5 = 0LL /* False */;
			int64_t v6 = 2LL /* C99RT_I64 */;
			push_str(v0);
			push_i64(v1);
			push_str(v2);
			push_i64(v3);
			push_str(v4);
			push_i64(v5);
			VAL v7 = mtw_std_maybe_Maybe_1_Some(MKI64(v6));
			int64_t v8 = pop_i64();
			VAL v9 = pop_value();
			int64_t v10 = pop_i64();
			VAL v11 = pop_value();
			int64_t v12 = pop_i64();
			VAL v13 = pop_value();
			VAL v14 = mw_mirth_c99_C99BinOp_Mk(v13, v12, v11, v10, v9, v8, v7);
			VAL v15 = mtw_std_maybe_Maybe_1_Some(v14);
			push_value(v15);
		} break;
		case 21LL: { // PRIM_INT_SUB
			STR* v16;
			STRLIT(v16, "i64_sub(", 8);
			int64_t v17 = 2LL /* C99RT_I64 */;
			STR* v18;
			STRLIT(v18, ", ", 2);
			int64_t v19 = 2LL /* C99RT_I64 */;
			STR* v20;
			STRLIT(v20, ")", 1);
			int64_t v21 = 0LL /* False */;
			int64_t v22 = 2LL /* C99RT_I64 */;
			push_str(v16);
			push_i64(v17);
			push_str(v18);
			push_i64(v19);
			push_str(v20);
			push_i64(v21);
			VAL v23 = mtw_std_maybe_Maybe_1_Some(MKI64(v22));
			int64_t v24 = pop_i64();
			VAL v25 = pop_value();
			int64_t v26 = pop_i64();
			VAL v27 = pop_value();
			int64_t v28 = pop_i64();
			VAL v29 = pop_value();
			VAL v30 = mw_mirth_c99_C99BinOp_Mk(v29, v28, v27, v26, v25, v24, v23);
			VAL v31 = mtw_std_maybe_Maybe_1_Some(v30);
			push_value(v31);
		} break;
		case 22LL: { // PRIM_INT_MUL
			STR* v32;
			STRLIT(v32, "i64_mul(", 8);
			int64_t v33 = 2LL /* C99RT_I64 */;
			STR* v34;
			STRLIT(v34, ", ", 2);
			int64_t v35 = 2LL /* C99RT_I64 */;
			STR* v36;
			STRLIT(v36, ")", 1);
			int64_t v37 = 0LL /* False */;
			int64_t v38 = 2LL /* C99RT_I64 */;
			push_str(v32);
			push_i64(v33);
			push_str(v34);
			push_i64(v35);
			push_str(v36);
			push_i64(v37);
			VAL v39 = mtw_std_maybe_Maybe_1_Some(MKI64(v38));
			int64_t v40 = pop_i64();
			VAL v41 = pop_value();
			int64_t v42 = pop_i64();
			VAL v43 = pop_value();
			int64_t v44 = pop_i64();
			VAL v45 = pop_value();
			VAL v46 = mw_mirth_c99_C99BinOp_Mk(v45, v44, v43, v42, v41, v40, v39);
			VAL v47 = mtw_std_maybe_Maybe_1_Some(v46);
			push_value(v47);
		} break;
		case 23LL: { // PRIM_INT_DIV
			STR* v48;
			STRLIT(v48, "i64_div(", 8);
			int64_t v49 = 2LL /* C99RT_I64 */;
			STR* v50;
			STRLIT(v50, ", ", 2);
			int64_t v51 = 2LL /* C99RT_I64 */;
			STR* v52;
			STRLIT(v52, ")", 1);
			int64_t v53 = 0LL /* False */;
			int64_t v54 = 2LL /* C99RT_I64 */;
			push_str(v48);
			push_i64(v49);
			push_str(v50);
			push_i64(v51);
			push_str(v52);
			push_i64(v53);
			VAL v55 = mtw_std_maybe_Maybe_1_Some(MKI64(v54));
			int64_t v56 = pop_i64();
			VAL v57 = pop_value();
			int64_t v58 = pop_i64();
			VAL v59 = pop_value();
			int64_t v60 = pop_i64();
			VAL v61 = pop_value();
			VAL v62 = mw_mirth_c99_C99BinOp_Mk(v61, v60, v59, v58, v57, v56, v55);
			VAL v63 = mtw_std_maybe_Maybe_1_Some(v62);
			push_value(v63);
		} break;
		case 24LL: { // PRIM_INT_MOD
			STR* v64;
			STRLIT(v64, "i64_mod(", 8);
			int64_t v65 = 2LL /* C99RT_I64 */;
			STR* v66;
			STRLIT(v66, ", ", 2);
			int64_t v67 = 2LL /* C99RT_I64 */;
			STR* v68;
			STRLIT(v68, ")", 1);
			int64_t v69 = 0LL /* False */;
			int64_t v70 = 2LL /* C99RT_I64 */;
			push_str(v64);
			push_i64(v65);
			push_str(v66);
			push_i64(v67);
			push_str(v68);
			push_i64(v69);
			VAL v71 = mtw_std_maybe_Maybe_1_Some(MKI64(v70));
			int64_t v72 = pop_i64();
			VAL v73 = pop_value();
			int64_t v74 = pop_i64();
			VAL v75 = pop_value();
			int64_t v76 = pop_i64();
			VAL v77 = pop_value();
			VAL v78 = mw_mirth_c99_C99BinOp_Mk(v77, v76, v75, v74, v73, v72, v71);
			VAL v79 = mtw_std_maybe_Maybe_1_Some(v78);
			push_value(v79);
		} break;
		case 28LL: { // PRIM_INT_SHL
			STR* v80;
			STRLIT(v80, "u64_shl(", 8);
			int64_t v81 = 6LL /* C99RT_U64 */;
			STR* v82;
			STRLIT(v82, ", ", 2);
			int64_t v83 = 6LL /* C99RT_U64 */;
			STR* v84;
			STRLIT(v84, ")", 1);
			int64_t v85 = 0LL /* False */;
			int64_t v86 = 6LL /* C99RT_U64 */;
			push_str(v80);
			push_i64(v81);
			push_str(v82);
			push_i64(v83);
			push_str(v84);
			push_i64(v85);
			VAL v87 = mtw_std_maybe_Maybe_1_Some(MKI64(v86));
			int64_t v88 = pop_i64();
			VAL v89 = pop_value();
			int64_t v90 = pop_i64();
			VAL v91 = pop_value();
			int64_t v92 = pop_i64();
			VAL v93 = pop_value();
			VAL v94 = mw_mirth_c99_C99BinOp_Mk(v93, v92, v91, v90, v89, v88, v87);
			VAL v95 = mtw_std_maybe_Maybe_1_Some(v94);
			push_value(v95);
		} break;
		case 29LL: { // PRIM_INT_SHR
			STR* v96;
			STRLIT(v96, "u64_shr(", 8);
			int64_t v97 = 6LL /* C99RT_U64 */;
			STR* v98;
			STRLIT(v98, ", ", 2);
			int64_t v99 = 6LL /* C99RT_U64 */;
			STR* v100;
			STRLIT(v100, ")", 1);
			int64_t v101 = 0LL /* False */;
			int64_t v102 = 6LL /* C99RT_U64 */;
			push_str(v96);
			push_i64(v97);
			push_str(v98);
			push_i64(v99);
			push_str(v100);
			push_i64(v101);
			VAL v103 = mtw_std_maybe_Maybe_1_Some(MKI64(v102));
			int64_t v104 = pop_i64();
			VAL v105 = pop_value();
			int64_t v106 = pop_i64();
			VAL v107 = pop_value();
			int64_t v108 = pop_i64();
			VAL v109 = pop_value();
			VAL v110 = mw_mirth_c99_C99BinOp_Mk(v109, v108, v107, v106, v105, v104, v103);
			VAL v111 = mtw_std_maybe_Maybe_1_Some(v110);
			push_value(v111);
		} break;
		case 15LL: { // PRIM_INT_LT
			STR* v112;
			STRLIT(v112, "(", 1);
			int64_t v113 = 2LL /* C99RT_I64 */;
			STR* v114;
			STRLIT(v114, " < ", 3);
			int64_t v115 = 2LL /* C99RT_I64 */;
			STR* v116;
			STRLIT(v116, ")", 1);
			int64_t v117 = 0LL /* False */;
			int64_t v118 = 12LL /* C99RT_BOOL */;
			push_str(v112);
			push_i64(v113);
			push_str(v114);
			push_i64(v115);
			push_str(v116);
			push_i64(v117);
			VAL v119 = mtw_std_maybe_Maybe_1_Some(MKI64(v118));
			int64_t v120 = pop_i64();
			VAL v121 = pop_value();
			int64_t v122 = pop_i64();
			VAL v123 = pop_value();
			int64_t v124 = pop_i64();
			VAL v125 = pop_value();
			VAL v126 = mw_mirth_c99_C99BinOp_Mk(v125, v124, v123, v122, v121, v120, v119);
			VAL v127 = mtw_std_maybe_Maybe_1_Some(v126);
			push_value(v127);
		} break;
		case 16LL: { // PRIM_INT_LE
			STR* v128;
			STRLIT(v128, "(", 1);
			int64_t v129 = 2LL /* C99RT_I64 */;
			STR* v130;
			STRLIT(v130, " <= ", 4);
			int64_t v131 = 2LL /* C99RT_I64 */;
			STR* v132;
			STRLIT(v132, ")", 1);
			int64_t v133 = 0LL /* False */;
			int64_t v134 = 12LL /* C99RT_BOOL */;
			push_str(v128);
			push_i64(v129);
			push_str(v130);
			push_i64(v131);
			push_str(v132);
			push_i64(v133);
			VAL v135 = mtw_std_maybe_Maybe_1_Some(MKI64(v134));
			int64_t v136 = pop_i64();
			VAL v137 = pop_value();
			int64_t v138 = pop_i64();
			VAL v139 = pop_value();
			int64_t v140 = pop_i64();
			VAL v141 = pop_value();
			VAL v142 = mw_mirth_c99_C99BinOp_Mk(v141, v140, v139, v138, v137, v136, v135);
			VAL v143 = mtw_std_maybe_Maybe_1_Some(v142);
			push_value(v143);
		} break;
		case 17LL: { // PRIM_INT_GT
			STR* v144;
			STRLIT(v144, "(", 1);
			int64_t v145 = 2LL /* C99RT_I64 */;
			STR* v146;
			STRLIT(v146, " > ", 3);
			int64_t v147 = 2LL /* C99RT_I64 */;
			STR* v148;
			STRLIT(v148, ")", 1);
			int64_t v149 = 0LL /* False */;
			int64_t v150 = 12LL /* C99RT_BOOL */;
			push_str(v144);
			push_i64(v145);
			push_str(v146);
			push_i64(v147);
			push_str(v148);
			push_i64(v149);
			VAL v151 = mtw_std_maybe_Maybe_1_Some(MKI64(v150));
			int64_t v152 = pop_i64();
			VAL v153 = pop_value();
			int64_t v154 = pop_i64();
			VAL v155 = pop_value();
			int64_t v156 = pop_i64();
			VAL v157 = pop_value();
			VAL v158 = mw_mirth_c99_C99BinOp_Mk(v157, v156, v155, v154, v153, v152, v151);
			VAL v159 = mtw_std_maybe_Maybe_1_Some(v158);
			push_value(v159);
		} break;
		case 18LL: { // PRIM_INT_GE
			STR* v160;
			STRLIT(v160, "(", 1);
			int64_t v161 = 2LL /* C99RT_I64 */;
			STR* v162;
			STRLIT(v162, " >= ", 4);
			int64_t v163 = 2LL /* C99RT_I64 */;
			STR* v164;
			STRLIT(v164, ")", 1);
			int64_t v165 = 0LL /* False */;
			int64_t v166 = 12LL /* C99RT_BOOL */;
			push_str(v160);
			push_i64(v161);
			push_str(v162);
			push_i64(v163);
			push_str(v164);
			push_i64(v165);
			VAL v167 = mtw_std_maybe_Maybe_1_Some(MKI64(v166));
			int64_t v168 = pop_i64();
			VAL v169 = pop_value();
			int64_t v170 = pop_i64();
			VAL v171 = pop_value();
			int64_t v172 = pop_i64();
			VAL v173 = pop_value();
			VAL v174 = mw_mirth_c99_C99BinOp_Mk(v173, v172, v171, v170, v169, v168, v167);
			VAL v175 = mtw_std_maybe_Maybe_1_Some(v174);
			push_value(v175);
		} break;
		case 19LL: { // PRIM_INT_NE
			STR* v176;
			STRLIT(v176, "(", 1);
			int64_t v177 = 2LL /* C99RT_I64 */;
			STR* v178;
			STRLIT(v178, " != ", 4);
			int64_t v179 = 2LL /* C99RT_I64 */;
			STR* v180;
			STRLIT(v180, ")", 1);
			int64_t v181 = 0LL /* False */;
			int64_t v182 = 12LL /* C99RT_BOOL */;
			push_str(v176);
			push_i64(v177);
			push_str(v178);
			push_i64(v179);
			push_str(v180);
			push_i64(v181);
			VAL v183 = mtw_std_maybe_Maybe_1_Some(MKI64(v182));
			int64_t v184 = pop_i64();
			VAL v185 = pop_value();
			int64_t v186 = pop_i64();
			VAL v187 = pop_value();
			int64_t v188 = pop_i64();
			VAL v189 = pop_value();
			VAL v190 = mw_mirth_c99_C99BinOp_Mk(v189, v188, v187, v186, v185, v184, v183);
			VAL v191 = mtw_std_maybe_Maybe_1_Some(v190);
			push_value(v191);
		} break;
		case 14LL: { // PRIM_INT_EQ
			STR* v192;
			STRLIT(v192, "(", 1);
			int64_t v193 = 2LL /* C99RT_I64 */;
			STR* v194;
			STRLIT(v194, " == ", 4);
			int64_t v195 = 2LL /* C99RT_I64 */;
			STR* v196;
			STRLIT(v196, ")", 1);
			int64_t v197 = 0LL /* False */;
			int64_t v198 = 12LL /* C99RT_BOOL */;
			push_str(v192);
			push_i64(v193);
			push_str(v194);
			push_i64(v195);
			push_str(v196);
			push_i64(v197);
			VAL v199 = mtw_std_maybe_Maybe_1_Some(MKI64(v198));
			int64_t v200 = pop_i64();
			VAL v201 = pop_value();
			int64_t v202 = pop_i64();
			VAL v203 = pop_value();
			int64_t v204 = pop_i64();
			VAL v205 = pop_value();
			VAL v206 = mw_mirth_c99_C99BinOp_Mk(v205, v204, v203, v202, v201, v200, v199);
			VAL v207 = mtw_std_maybe_Maybe_1_Some(v206);
			push_value(v207);
		} break;
		case 25LL: { // PRIM_INT_AND
			STR* v208;
			STRLIT(v208, "(", 1);
			int64_t v209 = 6LL /* C99RT_U64 */;
			STR* v210;
			STRLIT(v210, " & ", 3);
			int64_t v211 = 6LL /* C99RT_U64 */;
			STR* v212;
			STRLIT(v212, ")", 1);
			int64_t v213 = 0LL /* False */;
			int64_t v214 = 6LL /* C99RT_U64 */;
			push_str(v208);
			push_i64(v209);
			push_str(v210);
			push_i64(v211);
			push_str(v212);
			push_i64(v213);
			VAL v215 = mtw_std_maybe_Maybe_1_Some(MKI64(v214));
			int64_t v216 = pop_i64();
			VAL v217 = pop_value();
			int64_t v218 = pop_i64();
			VAL v219 = pop_value();
			int64_t v220 = pop_i64();
			VAL v221 = pop_value();
			VAL v222 = mw_mirth_c99_C99BinOp_Mk(v221, v220, v219, v218, v217, v216, v215);
			VAL v223 = mtw_std_maybe_Maybe_1_Some(v222);
			push_value(v223);
		} break;
		case 27LL: { // PRIM_INT_XOR
			STR* v224;
			STRLIT(v224, "(", 1);
			int64_t v225 = 6LL /* C99RT_U64 */;
			STR* v226;
			STRLIT(v226, " ^ ", 3);
			int64_t v227 = 6LL /* C99RT_U64 */;
			STR* v228;
			STRLIT(v228, ")", 1);
			int64_t v229 = 0LL /* False */;
			int64_t v230 = 6LL /* C99RT_U64 */;
			push_str(v224);
			push_i64(v225);
			push_str(v226);
			push_i64(v227);
			push_str(v228);
			push_i64(v229);
			VAL v231 = mtw_std_maybe_Maybe_1_Some(MKI64(v230));
			int64_t v232 = pop_i64();
			VAL v233 = pop_value();
			int64_t v234 = pop_i64();
			VAL v235 = pop_value();
			int64_t v236 = pop_i64();
			VAL v237 = pop_value();
			VAL v238 = mw_mirth_c99_C99BinOp_Mk(v237, v236, v235, v234, v233, v232, v231);
			VAL v239 = mtw_std_maybe_Maybe_1_Some(v238);
			push_value(v239);
		} break;
		case 26LL: { // PRIM_INT_OR
			STR* v240;
			STRLIT(v240, "(", 1);
			int64_t v241 = 6LL /* C99RT_U64 */;
			STR* v242;
			STRLIT(v242, " | ", 3);
			int64_t v243 = 6LL /* C99RT_U64 */;
			STR* v244;
			STRLIT(v244, ")", 1);
			int64_t v245 = 0LL /* False */;
			int64_t v246 = 6LL /* C99RT_U64 */;
			push_str(v240);
			push_i64(v241);
			push_str(v242);
			push_i64(v243);
			push_str(v244);
			push_i64(v245);
			VAL v247 = mtw_std_maybe_Maybe_1_Some(MKI64(v246));
			int64_t v248 = pop_i64();
			VAL v249 = pop_value();
			int64_t v250 = pop_i64();
			VAL v251 = pop_value();
			int64_t v252 = pop_i64();
			VAL v253 = pop_value();
			VAL v254 = mw_mirth_c99_C99BinOp_Mk(v253, v252, v251, v250, v249, v248, v247);
			VAL v255 = mtw_std_maybe_Maybe_1_Some(v254);
			push_value(v255);
		} break;
		case 35LL: { // PRIM_F32_ADD
			STR* v256;
			STRLIT(v256, "(", 1);
			int64_t v257 = 11LL /* C99RT_F32 */;
			STR* v258;
			STRLIT(v258, " + ", 3);
			int64_t v259 = 11LL /* C99RT_F32 */;
			STR* v260;
			STRLIT(v260, ")", 1);
			int64_t v261 = 0LL /* False */;
			int64_t v262 = 11LL /* C99RT_F32 */;
			push_str(v256);
			push_i64(v257);
			push_str(v258);
			push_i64(v259);
			push_str(v260);
			push_i64(v261);
			VAL v263 = mtw_std_maybe_Maybe_1_Some(MKI64(v262));
			int64_t v264 = pop_i64();
			VAL v265 = pop_value();
			int64_t v266 = pop_i64();
			VAL v267 = pop_value();
			int64_t v268 = pop_i64();
			VAL v269 = pop_value();
			VAL v270 = mw_mirth_c99_C99BinOp_Mk(v269, v268, v267, v266, v265, v264, v263);
			VAL v271 = mtw_std_maybe_Maybe_1_Some(v270);
			push_value(v271);
		} break;
		case 36LL: { // PRIM_F32_SUB
			STR* v272;
			STRLIT(v272, "(", 1);
			int64_t v273 = 11LL /* C99RT_F32 */;
			STR* v274;
			STRLIT(v274, " - ", 3);
			int64_t v275 = 11LL /* C99RT_F32 */;
			STR* v276;
			STRLIT(v276, ")", 1);
			int64_t v277 = 0LL /* False */;
			int64_t v278 = 11LL /* C99RT_F32 */;
			push_str(v272);
			push_i64(v273);
			push_str(v274);
			push_i64(v275);
			push_str(v276);
			push_i64(v277);
			VAL v279 = mtw_std_maybe_Maybe_1_Some(MKI64(v278));
			int64_t v280 = pop_i64();
			VAL v281 = pop_value();
			int64_t v282 = pop_i64();
			VAL v283 = pop_value();
			int64_t v284 = pop_i64();
			VAL v285 = pop_value();
			VAL v286 = mw_mirth_c99_C99BinOp_Mk(v285, v284, v283, v282, v281, v280, v279);
			VAL v287 = mtw_std_maybe_Maybe_1_Some(v286);
			push_value(v287);
		} break;
		case 37LL: { // PRIM_F32_MUL
			STR* v288;
			STRLIT(v288, "(", 1);
			int64_t v289 = 11LL /* C99RT_F32 */;
			STR* v290;
			STRLIT(v290, " * ", 3);
			int64_t v291 = 11LL /* C99RT_F32 */;
			STR* v292;
			STRLIT(v292, ")", 1);
			int64_t v293 = 0LL /* False */;
			int64_t v294 = 11LL /* C99RT_F32 */;
			push_str(v288);
			push_i64(v289);
			push_str(v290);
			push_i64(v291);
			push_str(v292);
			push_i64(v293);
			VAL v295 = mtw_std_maybe_Maybe_1_Some(MKI64(v294));
			int64_t v296 = pop_i64();
			VAL v297 = pop_value();
			int64_t v298 = pop_i64();
			VAL v299 = pop_value();
			int64_t v300 = pop_i64();
			VAL v301 = pop_value();
			VAL v302 = mw_mirth_c99_C99BinOp_Mk(v301, v300, v299, v298, v297, v296, v295);
			VAL v303 = mtw_std_maybe_Maybe_1_Some(v302);
			push_value(v303);
		} break;
		case 38LL: { // PRIM_F32_DIV
			STR* v304;
			STRLIT(v304, "(", 1);
			int64_t v305 = 11LL /* C99RT_F32 */;
			STR* v306;
			STRLIT(v306, " / ", 3);
			int64_t v307 = 11LL /* C99RT_F32 */;
			STR* v308;
			STRLIT(v308, ")", 1);
			int64_t v309 = 0LL /* False */;
			int64_t v310 = 11LL /* C99RT_F32 */;
			push_str(v304);
			push_i64(v305);
			push_str(v306);
			push_i64(v307);
			push_str(v308);
			push_i64(v309);
			VAL v311 = mtw_std_maybe_Maybe_1_Some(MKI64(v310));
			int64_t v312 = pop_i64();
			VAL v313 = pop_value();
			int64_t v314 = pop_i64();
			VAL v315 = pop_value();
			int64_t v316 = pop_i64();
			VAL v317 = pop_value();
			VAL v318 = mw_mirth_c99_C99BinOp_Mk(v317, v316, v315, v314, v313, v312, v311);
			VAL v319 = mtw_std_maybe_Maybe_1_Some(v318);
			push_value(v319);
		} break;
		case 34LL: { // PRIM_F32_LT
			STR* v320;
			STRLIT(v320, "(", 1);
			int64_t v321 = 11LL /* C99RT_F32 */;
			STR* v322;
			STRLIT(v322, " < ", 3);
			int64_t v323 = 11LL /* C99RT_F32 */;
			STR* v324;
			STRLIT(v324, ")", 1);
			int64_t v325 = 0LL /* False */;
			int64_t v326 = 12LL /* C99RT_BOOL */;
			push_str(v320);
			push_i64(v321);
			push_str(v322);
			push_i64(v323);
			push_str(v324);
			push_i64(v325);
			VAL v327 = mtw_std_maybe_Maybe_1_Some(MKI64(v326));
			int64_t v328 = pop_i64();
			VAL v329 = pop_value();
			int64_t v330 = pop_i64();
			VAL v331 = pop_value();
			int64_t v332 = pop_i64();
			VAL v333 = pop_value();
			VAL v334 = mw_mirth_c99_C99BinOp_Mk(v333, v332, v331, v330, v329, v328, v327);
			VAL v335 = mtw_std_maybe_Maybe_1_Some(v334);
			push_value(v335);
		} break;
		case 33LL: { // PRIM_F32_EQ
			STR* v336;
			STRLIT(v336, "(", 1);
			int64_t v337 = 11LL /* C99RT_F32 */;
			STR* v338;
			STRLIT(v338, " == ", 4);
			int64_t v339 = 11LL /* C99RT_F32 */;
			STR* v340;
			STRLIT(v340, ")", 1);
			int64_t v341 = 0LL /* False */;
			int64_t v342 = 12LL /* C99RT_BOOL */;
			push_str(v336);
			push_i64(v337);
			push_str(v338);
			push_i64(v339);
			push_str(v340);
			push_i64(v341);
			VAL v343 = mtw_std_maybe_Maybe_1_Some(MKI64(v342));
			int64_t v344 = pop_i64();
			VAL v345 = pop_value();
			int64_t v346 = pop_i64();
			VAL v347 = pop_value();
			int64_t v348 = pop_i64();
			VAL v349 = pop_value();
			VAL v350 = mw_mirth_c99_C99BinOp_Mk(v349, v348, v347, v346, v345, v344, v343);
			VAL v351 = mtw_std_maybe_Maybe_1_Some(v350);
			push_value(v351);
		} break;
		case 44LL: { // PRIM_F64_ADD
			STR* v352;
			STRLIT(v352, "(", 1);
			int64_t v353 = 10LL /* C99RT_F64 */;
			STR* v354;
			STRLIT(v354, " + ", 3);
			int64_t v355 = 10LL /* C99RT_F64 */;
			STR* v356;
			STRLIT(v356, ")", 1);
			int64_t v357 = 0LL /* False */;
			int64_t v358 = 10LL /* C99RT_F64 */;
			push_str(v352);
			push_i64(v353);
			push_str(v354);
			push_i64(v355);
			push_str(v356);
			push_i64(v357);
			VAL v359 = mtw_std_maybe_Maybe_1_Some(MKI64(v358));
			int64_t v360 = pop_i64();
			VAL v361 = pop_value();
			int64_t v362 = pop_i64();
			VAL v363 = pop_value();
			int64_t v364 = pop_i64();
			VAL v365 = pop_value();
			VAL v366 = mw_mirth_c99_C99BinOp_Mk(v365, v364, v363, v362, v361, v360, v359);
			VAL v367 = mtw_std_maybe_Maybe_1_Some(v366);
			push_value(v367);
		} break;
		case 45LL: { // PRIM_F64_SUB
			STR* v368;
			STRLIT(v368, "(", 1);
			int64_t v369 = 10LL /* C99RT_F64 */;
			STR* v370;
			STRLIT(v370, " - ", 3);
			int64_t v371 = 10LL /* C99RT_F64 */;
			STR* v372;
			STRLIT(v372, ")", 1);
			int64_t v373 = 0LL /* False */;
			int64_t v374 = 10LL /* C99RT_F64 */;
			push_str(v368);
			push_i64(v369);
			push_str(v370);
			push_i64(v371);
			push_str(v372);
			push_i64(v373);
			VAL v375 = mtw_std_maybe_Maybe_1_Some(MKI64(v374));
			int64_t v376 = pop_i64();
			VAL v377 = pop_value();
			int64_t v378 = pop_i64();
			VAL v379 = pop_value();
			int64_t v380 = pop_i64();
			VAL v381 = pop_value();
			VAL v382 = mw_mirth_c99_C99BinOp_Mk(v381, v380, v379, v378, v377, v376, v375);
			VAL v383 = mtw_std_maybe_Maybe_1_Some(v382);
			push_value(v383);
		} break;
		case 46LL: { // PRIM_F64_MUL
			STR* v384;
			STRLIT(v384, "(", 1);
			int64_t v385 = 10LL /* C99RT_F64 */;
			STR* v386;
			STRLIT(v386, " * ", 3);
			int64_t v387 = 10LL /* C99RT_F64 */;
			STR* v388;
			STRLIT(v388, ")", 1);
			int64_t v389 = 0LL /* False */;
			int64_t v390 = 10LL /* C99RT_F64 */;
			push_str(v384);
			push_i64(v385);
			push_str(v386);
			push_i64(v387);
			push_str(v388);
			push_i64(v389);
			VAL v391 = mtw_std_maybe_Maybe_1_Some(MKI64(v390));
			int64_t v392 = pop_i64();
			VAL v393 = pop_value();
			int64_t v394 = pop_i64();
			VAL v395 = pop_value();
			int64_t v396 = pop_i64();
			VAL v397 = pop_value();
			VAL v398 = mw_mirth_c99_C99BinOp_Mk(v397, v396, v395, v394, v393, v392, v391);
			VAL v399 = mtw_std_maybe_Maybe_1_Some(v398);
			push_value(v399);
		} break;
		case 47LL: { // PRIM_F64_DIV
			STR* v400;
			STRLIT(v400, "(", 1);
			int64_t v401 = 10LL /* C99RT_F64 */;
			STR* v402;
			STRLIT(v402, " / ", 3);
			int64_t v403 = 10LL /* C99RT_F64 */;
			STR* v404;
			STRLIT(v404, ")", 1);
			int64_t v405 = 0LL /* False */;
			int64_t v406 = 10LL /* C99RT_F64 */;
			push_str(v400);
			push_i64(v401);
			push_str(v402);
			push_i64(v403);
			push_str(v404);
			push_i64(v405);
			VAL v407 = mtw_std_maybe_Maybe_1_Some(MKI64(v406));
			int64_t v408 = pop_i64();
			VAL v409 = pop_value();
			int64_t v410 = pop_i64();
			VAL v411 = pop_value();
			int64_t v412 = pop_i64();
			VAL v413 = pop_value();
			VAL v414 = mw_mirth_c99_C99BinOp_Mk(v413, v412, v411, v410, v409, v408, v407);
			VAL v415 = mtw_std_maybe_Maybe_1_Some(v414);
			push_value(v415);
		} break;
		case 43LL: { // PRIM_F64_LT
			STR* v416;
			STRLIT(v416, "(", 1);
			int64_t v417 = 10LL /* C99RT_F64 */;
			STR* v418;
			STRLIT(v418, " < ", 3);
			int64_t v419 = 10LL /* C99RT_F64 */;
			STR* v420;
			STRLIT(v420, ")", 1);
			int64_t v421 = 0LL /* False */;
			int64_t v422 = 12LL /* C99RT_BOOL */;
			push_str(v416);
			push_i64(v417);
			push_str(v418);
			push_i64(v419);
			push_str(v420);
			push_i64(v421);
			VAL v423 = mtw_std_maybe_Maybe_1_Some(MKI64(v422));
			int64_t v424 = pop_i64();
			VAL v425 = pop_value();
			int64_t v426 = pop_i64();
			VAL v427 = pop_value();
			int64_t v428 = pop_i64();
			VAL v429 = pop_value();
			VAL v430 = mw_mirth_c99_C99BinOp_Mk(v429, v428, v427, v426, v425, v424, v423);
			VAL v431 = mtw_std_maybe_Maybe_1_Some(v430);
			push_value(v431);
		} break;
		case 42LL: { // PRIM_F64_EQ
			STR* v432;
			STRLIT(v432, "(", 1);
			int64_t v433 = 10LL /* C99RT_F64 */;
			STR* v434;
			STRLIT(v434, " == ", 4);
			int64_t v435 = 10LL /* C99RT_F64 */;
			STR* v436;
			STRLIT(v436, ")", 1);
			int64_t v437 = 0LL /* False */;
			int64_t v438 = 12LL /* C99RT_BOOL */;
			push_str(v432);
			push_i64(v433);
			push_str(v434);
			push_i64(v435);
			push_str(v436);
			push_i64(v437);
			VAL v439 = mtw_std_maybe_Maybe_1_Some(MKI64(v438));
			int64_t v440 = pop_i64();
			VAL v441 = pop_value();
			int64_t v442 = pop_i64();
			VAL v443 = pop_value();
			int64_t v444 = pop_i64();
			VAL v445 = pop_value();
			VAL v446 = mw_mirth_c99_C99BinOp_Mk(v445, v444, v443, v442, v441, v440, v439);
			VAL v447 = mtw_std_maybe_Maybe_1_Some(v446);
			push_value(v447);
		} break;
		case 51LL: { // PRIM_BOOL_AND
			STR* v448;
			STRLIT(v448, "(", 1);
			int64_t v449 = 12LL /* C99RT_BOOL */;
			STR* v450;
			STRLIT(v450, " && ", 4);
			int64_t v451 = 12LL /* C99RT_BOOL */;
			STR* v452;
			STRLIT(v452, ")", 1);
			int64_t v453 = 0LL /* False */;
			int64_t v454 = 12LL /* C99RT_BOOL */;
			push_str(v448);
			push_i64(v449);
			push_str(v450);
			push_i64(v451);
			push_str(v452);
			push_i64(v453);
			VAL v455 = mtw_std_maybe_Maybe_1_Some(MKI64(v454));
			int64_t v456 = pop_i64();
			VAL v457 = pop_value();
			int64_t v458 = pop_i64();
			VAL v459 = pop_value();
			int64_t v460 = pop_i64();
			VAL v461 = pop_value();
			VAL v462 = mw_mirth_c99_C99BinOp_Mk(v461, v460, v459, v458, v457, v456, v455);
			VAL v463 = mtw_std_maybe_Maybe_1_Some(v462);
			push_value(v463);
		} break;
		case 52LL: { // PRIM_BOOL_OR
			STR* v464;
			STRLIT(v464, "(", 1);
			int64_t v465 = 12LL /* C99RT_BOOL */;
			STR* v466;
			STRLIT(v466, " || ", 4);
			int64_t v467 = 12LL /* C99RT_BOOL */;
			STR* v468;
			STRLIT(v468, ")", 1);
			int64_t v469 = 0LL /* False */;
			int64_t v470 = 12LL /* C99RT_BOOL */;
			push_str(v464);
			push_i64(v465);
			push_str(v466);
			push_i64(v467);
			push_str(v468);
			push_i64(v469);
			VAL v471 = mtw_std_maybe_Maybe_1_Some(MKI64(v470));
			int64_t v472 = pop_i64();
			VAL v473 = pop_value();
			int64_t v474 = pop_i64();
			VAL v475 = pop_value();
			int64_t v476 = pop_i64();
			VAL v477 = pop_value();
			VAL v478 = mw_mirth_c99_C99BinOp_Mk(v477, v476, v475, v474, v473, v472, v471);
			VAL v479 = mtw_std_maybe_Maybe_1_Some(v478);
			push_value(v479);
		} break;
		case 72LL: { // PRIM_STR_COPY
			STR* v480;
			STRLIT(v480, "str_make(", 9);
			int64_t v481 = 13LL /* C99RT_PTR */;
			STR* v482;
			STRLIT(v482, ", ", 2);
			int64_t v483 = 6LL /* C99RT_U64 */;
			STR* v484;
			STRLIT(v484, ")", 1);
			int64_t v485 = 0LL /* False */;
			int64_t v486 = 1LL /* C99RT_STR */;
			push_str(v480);
			push_i64(v481);
			push_str(v482);
			push_i64(v483);
			push_str(v484);
			push_i64(v485);
			VAL v487 = mtw_std_maybe_Maybe_1_Some(MKI64(v486));
			int64_t v488 = pop_i64();
			VAL v489 = pop_value();
			int64_t v490 = pop_i64();
			VAL v491 = pop_value();
			int64_t v492 = pop_i64();
			VAL v493 = pop_value();
			VAL v494 = mw_mirth_c99_C99BinOp_Mk(v493, v492, v491, v490, v489, v488, v487);
			VAL v495 = mtw_std_maybe_Maybe_1_Some(v494);
			push_value(v495);
		} break;
		case 75LL: { // PRIM_STR_CAT
			STR* v496;
			STRLIT(v496, "str_cat(", 8);
			int64_t v497 = 1LL /* C99RT_STR */;
			STR* v498;
			STRLIT(v498, ", ", 2);
			int64_t v499 = 1LL /* C99RT_STR */;
			STR* v500;
			STRLIT(v500, ")", 1);
			int64_t v501 = 0LL /* False */;
			int64_t v502 = 1LL /* C99RT_STR */;
			push_str(v496);
			push_i64(v497);
			push_str(v498);
			push_i64(v499);
			push_str(v500);
			push_i64(v501);
			VAL v503 = mtw_std_maybe_Maybe_1_Some(MKI64(v502));
			int64_t v504 = pop_i64();
			VAL v505 = pop_value();
			int64_t v506 = pop_i64();
			VAL v507 = pop_value();
			int64_t v508 = pop_i64();
			VAL v509 = pop_value();
			VAL v510 = mw_mirth_c99_C99BinOp_Mk(v509, v508, v507, v506, v505, v504, v503);
			VAL v511 = mtw_std_maybe_Maybe_1_Some(v510);
			push_value(v511);
		} break;
		case 76LL: { // PRIM_STR_CMP
			STR* v512;
			STRLIT(v512, "str_cmp(", 8);
			int64_t v513 = 1LL /* C99RT_STR */;
			STR* v514;
			STRLIT(v514, ", ", 2);
			int64_t v515 = 1LL /* C99RT_STR */;
			STR* v516;
			STRLIT(v516, ")", 1);
			int64_t v517 = 0LL /* False */;
			int64_t v518 = 2LL /* C99RT_I64 */;
			push_str(v512);
			push_i64(v513);
			push_str(v514);
			push_i64(v515);
			push_str(v516);
			push_i64(v517);
			VAL v519 = mtw_std_maybe_Maybe_1_Some(MKI64(v518));
			int64_t v520 = pop_i64();
			VAL v521 = pop_value();
			int64_t v522 = pop_i64();
			VAL v523 = pop_value();
			int64_t v524 = pop_i64();
			VAL v525 = pop_value();
			VAL v526 = mw_mirth_c99_C99BinOp_Mk(v525, v524, v523, v522, v521, v520, v519);
			VAL v527 = mtw_std_maybe_Maybe_1_Some(v526);
			push_value(v527);
		} break;
		case 77LL: { // PRIM_STR_EQ
			STR* v528;
			STRLIT(v528, "(str_cmp(", 9);
			int64_t v529 = 1LL /* C99RT_STR */;
			STR* v530;
			STRLIT(v530, ", ", 2);
			int64_t v531 = 1LL /* C99RT_STR */;
			STR* v532;
			STRLIT(v532, ") == 0)", 7);
			int64_t v533 = 0LL /* False */;
			int64_t v534 = 12LL /* C99RT_BOOL */;
			push_str(v528);
			push_i64(v529);
			push_str(v530);
			push_i64(v531);
			push_str(v532);
			push_i64(v533);
			VAL v535 = mtw_std_maybe_Maybe_1_Some(MKI64(v534));
			int64_t v536 = pop_i64();
			VAL v537 = pop_value();
			int64_t v538 = pop_i64();
			VAL v539 = pop_value();
			int64_t v540 = pop_i64();
			VAL v541 = pop_value();
			VAL v542 = mw_mirth_c99_C99BinOp_Mk(v541, v540, v539, v538, v537, v536, v535);
			VAL v543 = mtw_std_maybe_Maybe_1_Some(v542);
			push_value(v543);
		} break;
		case 78LL: { // PRIM_STR_LT
			STR* v544;
			STRLIT(v544, "(str_cmp(", 9);
			int64_t v545 = 1LL /* C99RT_STR */;
			STR* v546;
			STRLIT(v546, ", ", 2);
			int64_t v547 = 1LL /* C99RT_STR */;
			STR* v548;
			STRLIT(v548, ") < 0)", 6);
			int64_t v549 = 0LL /* False */;
			int64_t v550 = 12LL /* C99RT_BOOL */;
			push_str(v544);
			push_i64(v545);
			push_str(v546);
			push_i64(v547);
			push_str(v548);
			push_i64(v549);
			VAL v551 = mtw_std_maybe_Maybe_1_Some(MKI64(v550));
			int64_t v552 = pop_i64();
			VAL v553 = pop_value();
			int64_t v554 = pop_i64();
			VAL v555 = pop_value();
			int64_t v556 = pop_i64();
			VAL v557 = pop_value();
			VAL v558 = mw_mirth_c99_C99BinOp_Mk(v557, v556, v555, v554, v553, v552, v551);
			VAL v559 = mtw_std_maybe_Maybe_1_Some(v558);
			push_value(v559);
		} break;
		case 79LL: { // PRIM_STR_LE
			STR* v560;
			STRLIT(v560, "(str_cmp(", 9);
			int64_t v561 = 1LL /* C99RT_STR */;
			STR* v562;
			STRLIT(v562, ", ", 2);
			int64_t v563 = 1LL /* C99RT_STR */;
			STR* v564;
			STRLIT(v564, ") <= 0)", 7);
			int64_t v565 = 0LL /* False */;
			int64_t v566 = 12LL /* C99RT_BOOL */;
			push_str(v560);
			push_i64(v561);
			push_str(v562);
			push_i64(v563);
			push_str(v564);
			push_i64(v565);
			VAL v567 = mtw_std_maybe_Maybe_1_Some(MKI64(v566));
			int64_t v568 = pop_i64();
			VAL v569 = pop_value();
			int64_t v570 = pop_i64();
			VAL v571 = pop_value();
			int64_t v572 = pop_i64();
			VAL v573 = pop_value();
			VAL v574 = mw_mirth_c99_C99BinOp_Mk(v573, v572, v571, v570, v569, v568, v567);
			VAL v575 = mtw_std_maybe_Maybe_1_Some(v574);
			push_value(v575);
		} break;
		case 80LL: { // PRIM_STR_GT
			STR* v576;
			STRLIT(v576, "(str_cmp(", 9);
			int64_t v577 = 1LL /* C99RT_STR */;
			STR* v578;
			STRLIT(v578, ", ", 2);
			int64_t v579 = 1LL /* C99RT_STR */;
			STR* v580;
			STRLIT(v580, ") > 0)", 6);
			int64_t v581 = 0LL /* False */;
			int64_t v582 = 12LL /* C99RT_BOOL */;
			push_str(v576);
			push_i64(v577);
			push_str(v578);
			push_i64(v579);
			push_str(v580);
			push_i64(v581);
			VAL v583 = mtw_std_maybe_Maybe_1_Some(MKI64(v582));
			int64_t v584 = pop_i64();
			VAL v585 = pop_value();
			int64_t v586 = pop_i64();
			VAL v587 = pop_value();
			int64_t v588 = pop_i64();
			VAL v589 = pop_value();
			VAL v590 = mw_mirth_c99_C99BinOp_Mk(v589, v588, v587, v586, v585, v584, v583);
			VAL v591 = mtw_std_maybe_Maybe_1_Some(v590);
			push_value(v591);
		} break;
		case 81LL: { // PRIM_STR_GE
			STR* v592;
			STRLIT(v592, "(str_cmp(", 9);
			int64_t v593 = 1LL /* C99RT_STR */;
			STR* v594;
			STRLIT(v594, ", ", 2);
			int64_t v595 = 1LL /* C99RT_STR */;
			STR* v596;
			STRLIT(v596, ") >= 0)", 7);
			int64_t v597 = 0LL /* False */;
			int64_t v598 = 12LL /* C99RT_BOOL */;
			push_str(v592);
			push_i64(v593);
			push_str(v594);
			push_i64(v595);
			push_str(v596);
			push_i64(v597);
			VAL v599 = mtw_std_maybe_Maybe_1_Some(MKI64(v598));
			int64_t v600 = pop_i64();
			VAL v601 = pop_value();
			int64_t v602 = pop_i64();
			VAL v603 = pop_value();
			int64_t v604 = pop_i64();
			VAL v605 = pop_value();
			VAL v606 = mw_mirth_c99_C99BinOp_Mk(v605, v604, v603, v602, v601, v600, v599);
			VAL v607 = mtw_std_maybe_Maybe_1_Some(v606);
			push_value(v607);
		} break;
		case 82LL: { // PRIM_STR_NE
			STR* v608;
			STRLIT(v608, "(str_cmp(", 9);
			int64_t v609 = 1LL /* C99RT_STR */;
			STR* v610;
			STRLIT(v610, ", ", 2);
			int64_t v611 = 1LL /* C99RT_STR */;
			STR* v612;
			STRLIT(v612, ") != 0)", 7);
			int64_t v613 = 0LL /* False */;
			int64_t v614 = 12LL /* C99RT_BOOL */;
			push_str(v608);
			push_i64(v609);
			push_str(v610);
			push_i64(v611);
			push_str(v612);
			push_i64(v613);
			VAL v615 = mtw_std_maybe_Maybe_1_Some(MKI64(v614));
			int64_t v616 = pop_i64();
			VAL v617 = pop_value();
			int64_t v618 = pop_i64();
			VAL v619 = pop_value();
			int64_t v620 = pop_i64();
			VAL v621 = pop_value();
			VAL v622 = mw_mirth_c99_C99BinOp_Mk(v621, v620, v619, v618, v617, v616, v615);
			VAL v623 = mtw_std_maybe_Maybe_1_Some(v622);
			push_value(v623);
		} break;
		case 68LL: { // PRIM_PTR_REALLOC
			STR* v624;
			STRLIT(v624, "ptr_realloc(", 12);
			int64_t v625 = 13LL /* C99RT_PTR */;
			STR* v626;
			STRLIT(v626, ",", 1);
			int64_t v627 = 6LL /* C99RT_U64 */;
			STR* v628;
			STRLIT(v628, ")", 1);
			int64_t v629 = 0LL /* False */;
			int64_t v630 = 13LL /* C99RT_PTR */;
			push_str(v624);
			push_i64(v625);
			push_str(v626);
			push_i64(v627);
			push_str(v628);
			push_i64(v629);
			VAL v631 = mtw_std_maybe_Maybe_1_Some(MKI64(v630));
			int64_t v632 = pop_i64();
			VAL v633 = pop_value();
			int64_t v634 = pop_i64();
			VAL v635 = pop_value();
			int64_t v636 = pop_i64();
			VAL v637 = pop_value();
			VAL v638 = mw_mirth_c99_C99BinOp_Mk(v637, v636, v635, v634, v633, v632, v631);
			VAL v639 = mtw_std_maybe_Maybe_1_Some(v638);
			push_value(v639);
		} break;
		case 63LL: { // PRIM_PTR_ADD
			STR* v640;
			STRLIT(v640, "(void*)(", 8);
			int64_t v641 = 2LL /* C99RT_I64 */;
			STR* v642;
			STRLIT(v642, " + (char*)", 10);
			int64_t v643 = 13LL /* C99RT_PTR */;
			STR* v644;
			STRLIT(v644, ")", 1);
			int64_t v645 = 0LL /* False */;
			int64_t v646 = 13LL /* C99RT_PTR */;
			push_str(v640);
			push_i64(v641);
			push_str(v642);
			push_i64(v643);
			push_str(v644);
			push_i64(v645);
			VAL v647 = mtw_std_maybe_Maybe_1_Some(MKI64(v646));
			int64_t v648 = pop_i64();
			VAL v649 = pop_value();
			int64_t v650 = pop_i64();
			VAL v651 = pop_value();
			int64_t v652 = pop_i64();
			VAL v653 = pop_value();
			VAL v654 = mw_mirth_c99_C99BinOp_Mk(v653, v652, v651, v650, v649, v648, v647);
			VAL v655 = mtw_std_maybe_Maybe_1_Some(v654);
			push_value(v655);
		} break;
		case 62LL: { // PRIM_PTR_EQ
			STR* v656;
			STRLIT(v656, "(", 1);
			int64_t v657 = 13LL /* C99RT_PTR */;
			STR* v658;
			STRLIT(v658, " == ", 4);
			int64_t v659 = 13LL /* C99RT_PTR */;
			STR* v660;
			STRLIT(v660, ")", 1);
			int64_t v661 = 0LL /* False */;
			int64_t v662 = 12LL /* C99RT_BOOL */;
			push_str(v656);
			push_i64(v657);
			push_str(v658);
			push_i64(v659);
			push_str(v660);
			push_i64(v661);
			VAL v663 = mtw_std_maybe_Maybe_1_Some(MKI64(v662));
			int64_t v664 = pop_i64();
			VAL v665 = pop_value();
			int64_t v666 = pop_i64();
			VAL v667 = pop_value();
			int64_t v668 = pop_i64();
			VAL v669 = pop_value();
			VAL v670 = mw_mirth_c99_C99BinOp_Mk(v669, v668, v667, v666, v665, v664, v663);
			VAL v671 = mtw_std_maybe_Maybe_1_Some(v670);
			push_value(v671);
		} break;
		case 55LL: { // PRIM_PACK_CONS
			STR* v672;
			STRLIT(v672, "mkcons(", 7);
			int64_t v673 = 0LL /* C99RT_VAL */;
			STR* v674;
			STRLIT(v674, ", ", 2);
			int64_t v675 = 0LL /* C99RT_VAL */;
			STR* v676;
			STRLIT(v676, ")", 1);
			int64_t v677 = 0LL /* False */;
			int64_t v678 = 0LL /* C99RT_VAL */;
			push_str(v672);
			push_i64(v673);
			push_str(v674);
			push_i64(v675);
			push_str(v676);
			push_i64(v677);
			VAL v679 = mtw_std_maybe_Maybe_1_Some(MKI64(v678));
			int64_t v680 = pop_i64();
			VAL v681 = pop_value();
			int64_t v682 = pop_i64();
			VAL v683 = pop_value();
			int64_t v684 = pop_i64();
			VAL v685 = pop_value();
			VAL v686 = mw_mirth_c99_C99BinOp_Mk(v685, v684, v683, v682, v681, v680, v679);
			VAL v687 = mtw_std_maybe_Maybe_1_Some(v686);
			push_value(v687);
		} break;
		case 90LL: { // PRIM_U64_SET
			STR* v688;
			STRLIT(v688, "*(uint64_t*)", 12);
			int64_t v689 = 13LL /* C99RT_PTR */;
			STR* v690;
			STRLIT(v690, " = ", 3);
			int64_t v691 = 6LL /* C99RT_U64 */;
			STR* v692;
			STRLIT(v692, ";", 1);
			int64_t v693 = 1LL /* True */;
			int64_t v694 = 0LL /* None */;
			VAL v695 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v688), v689, MKSTR(v690), v691, MKSTR(v692), v693, MKI64(v694));
			VAL v696 = mtw_std_maybe_Maybe_1_Some(v695);
			push_value(v696);
		} break;
		case 88LL: { // PRIM_U32_SET
			STR* v697;
			STRLIT(v697, "*(uint32_t*)", 12);
			int64_t v698 = 13LL /* C99RT_PTR */;
			STR* v699;
			STRLIT(v699, " = ", 3);
			int64_t v700 = 7LL /* C99RT_U32 */;
			STR* v701;
			STRLIT(v701, ";", 1);
			int64_t v702 = 1LL /* True */;
			int64_t v703 = 0LL /* None */;
			VAL v704 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v697), v698, MKSTR(v699), v700, MKSTR(v701), v702, MKI64(v703));
			VAL v705 = mtw_std_maybe_Maybe_1_Some(v704);
			push_value(v705);
		} break;
		case 86LL: { // PRIM_U16_SET
			STR* v706;
			STRLIT(v706, "*(uint16_t*)", 12);
			int64_t v707 = 13LL /* C99RT_PTR */;
			STR* v708;
			STRLIT(v708, " = ", 3);
			int64_t v709 = 8LL /* C99RT_U16 */;
			STR* v710;
			STRLIT(v710, ";", 1);
			int64_t v711 = 1LL /* True */;
			int64_t v712 = 0LL /* None */;
			VAL v713 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v706), v707, MKSTR(v708), v709, MKSTR(v710), v711, MKI64(v712));
			VAL v714 = mtw_std_maybe_Maybe_1_Some(v713);
			push_value(v714);
		} break;
		case 84LL: { // PRIM_U8_SET
			STR* v715;
			STRLIT(v715, "*(uint8_t*)", 11);
			int64_t v716 = 13LL /* C99RT_PTR */;
			STR* v717;
			STRLIT(v717, " = ", 3);
			int64_t v718 = 9LL /* C99RT_U8 */;
			STR* v719;
			STRLIT(v719, ";", 1);
			int64_t v720 = 1LL /* True */;
			int64_t v721 = 0LL /* None */;
			VAL v722 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v715), v716, MKSTR(v717), v718, MKSTR(v719), v720, MKI64(v721));
			VAL v723 = mtw_std_maybe_Maybe_1_Some(v722);
			push_value(v723);
		} break;
		case 98LL: { // PRIM_I64_SET
			STR* v724;
			STRLIT(v724, "*(int64_t*)", 11);
			int64_t v725 = 13LL /* C99RT_PTR */;
			STR* v726;
			STRLIT(v726, " = ", 3);
			int64_t v727 = 2LL /* C99RT_I64 */;
			STR* v728;
			STRLIT(v728, ";", 1);
			int64_t v729 = 1LL /* True */;
			int64_t v730 = 0LL /* None */;
			VAL v731 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v724), v725, MKSTR(v726), v727, MKSTR(v728), v729, MKI64(v730));
			VAL v732 = mtw_std_maybe_Maybe_1_Some(v731);
			push_value(v732);
		} break;
		case 96LL: { // PRIM_I32_SET
			STR* v733;
			STRLIT(v733, "*(int32_t*)", 11);
			int64_t v734 = 13LL /* C99RT_PTR */;
			STR* v735;
			STRLIT(v735, " = ", 3);
			int64_t v736 = 3LL /* C99RT_I32 */;
			STR* v737;
			STRLIT(v737, ";", 1);
			int64_t v738 = 1LL /* True */;
			int64_t v739 = 0LL /* None */;
			VAL v740 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v733), v734, MKSTR(v735), v736, MKSTR(v737), v738, MKI64(v739));
			VAL v741 = mtw_std_maybe_Maybe_1_Some(v740);
			push_value(v741);
		} break;
		case 94LL: { // PRIM_I16_SET
			STR* v742;
			STRLIT(v742, "*(int16_t*)", 11);
			int64_t v743 = 13LL /* C99RT_PTR */;
			STR* v744;
			STRLIT(v744, " = ", 3);
			int64_t v745 = 4LL /* C99RT_I16 */;
			STR* v746;
			STRLIT(v746, ";", 1);
			int64_t v747 = 1LL /* True */;
			int64_t v748 = 0LL /* None */;
			VAL v749 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v742), v743, MKSTR(v744), v745, MKSTR(v746), v747, MKI64(v748));
			VAL v750 = mtw_std_maybe_Maybe_1_Some(v749);
			push_value(v750);
		} break;
		case 92LL: { // PRIM_I8_SET
			STR* v751;
			STRLIT(v751, "*(int8_t*)", 10);
			int64_t v752 = 13LL /* C99RT_PTR */;
			STR* v753;
			STRLIT(v753, " = ", 3);
			int64_t v754 = 5LL /* C99RT_I8 */;
			STR* v755;
			STRLIT(v755, ";", 1);
			int64_t v756 = 1LL /* True */;
			int64_t v757 = 0LL /* None */;
			VAL v758 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v751), v752, MKSTR(v753), v754, MKSTR(v755), v756, MKI64(v757));
			VAL v759 = mtw_std_maybe_Maybe_1_Some(v758);
			push_value(v759);
		} break;
		case 66LL: { // PRIM_PTR_SET
			STR* v760;
			STRLIT(v760, "*(void**)", 9);
			int64_t v761 = 13LL /* C99RT_PTR */;
			STR* v762;
			STRLIT(v762, " = ", 3);
			int64_t v763 = 13LL /* C99RT_PTR */;
			STR* v764;
			STRLIT(v764, ";", 1);
			int64_t v765 = 1LL /* True */;
			int64_t v766 = 0LL /* None */;
			VAL v767 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v760), v761, MKSTR(v762), v763, MKSTR(v764), v765, MKI64(v766));
			VAL v768 = mtw_std_maybe_Maybe_1_Some(v767);
			push_value(v768);
		} break;
		case 59LL: { // PRIM_MUT_SET
			STR* v769;
			STRLIT(v769, "mut_set(", 8);
			int64_t v770 = 0LL /* C99RT_VAL */;
			STR* v771;
			STRLIT(v771, ", ", 2);
			int64_t v772 = 0LL /* C99RT_VAL */;
			STR* v773;
			STRLIT(v773, ");", 2);
			int64_t v774 = 0LL /* False */;
			int64_t v775 = 0LL /* None */;
			VAL v776 = mw_mirth_c99_C99BinOp_Mk(MKSTR(v769), v770, MKSTR(v771), v772, MKSTR(v773), v774, MKI64(v775));
			VAL v777 = mtw_std_maybe_Maybe_1_Some(v776);
			push_value(v777);
		} break;
		default: {
			int64_t v778 = 0LL /* None */;
			push_i64(v778);
		} break;
	}
	VAL v779 = pop_value();
	return v779;
}
static VAL mw_mirth_c99_c99Z_unopZ_exprZBang (VAL x1, VAL x2, VAL x3) {
	lpush(&lbl_ZPlusarg, x2);
	push_resource(x3);
	mtp_mirth_c99_C99UnOp_C99UnOp(x1);
	VAL v0 = lpop(&lbl_prefix);
	VAL r1 = pop_resource();
	VAL v2 = (mw_mirth_c99_ZPlusC99_put(v0, r1));
	VAL v3 = (lpop(&lbl_ZPlusarg));
	int64_t v4 = VI64(lpop(&lbl_argZ_type));
	push_resource(v2);
	VAL v5 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v4, v3);
	VAL r6 = pop_resource();
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(v5, r6));
	VAL v8 = lpop(&lbl_suffix);
	VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v7));
	VAL v10 = lpop(&lbl_outZ_type);
	decref(v10);
	return v9;
}
static VAL mw_mirth_c99_c99Z_unopZBang (VAL x1, VAL x2) {
	incref(x1);
	int64_t v0 = VI64(VTUP(x1)->cells[2]);
	decref(x1);
	push_value(x1);
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v0);
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = VVAL(VTUP(v2)->cells[4]);
	incref(v3);
	decref(v2);
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			lpush(&lbl_ZPlusarg, r1);
			push_value(v2);
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL r5 = pop_resource();
			VAL v6 = (VVAL(VTUP(r5)->cells[1]));
			lpush(&lbl_localZ_repr, v4);
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v6);
			VAL v7 = pop_value();
			VAL r8 = pop_resource();
			int64_t v9 = VI64(lpop(&lbl_localZ_repr));
			VAL v10 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v9, v7));
			push_resource(v10);
			VAL v11 = (mw_mirth_c99_ZPlusC99_indent(r8));
			VAL r12 = pop_resource();
			int64_t v13 = VI64(VTUP(r12)->cells[1]);
			push_resource(r12);
			push_resource(v11);
			VAL v14 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v13);
			VAL r15 = pop_resource();
			VAL v16 = (mw_mirth_c99_ZPlusC99_put(v14, r15));
			STR* v17;
			STRLIT(v17, " ", 1);
			VAL v18 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v17), v16));
			VAL r19 = pop_resource();
			VAL v20 = VVAL(VTUP(r19)->cells[2]);
			incref(v20);
			push_resource(r19);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(v20, v18));
			STR* v22;
			STRLIT(v22, " = ", 3);
			VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
			VAL r24 = pop_resource();
			VAL v25 = (lpop(&lbl_ZPlusarg));
			VAL v26 = pop_value();
			VAL v27 = (mw_mirth_c99_c99Z_unopZ_exprZBang(v26, v25, v23));
			STR* v28;
			STRLIT(v28, ";", 1);
			push_resource(r24);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
			VAL v30 = (mw_mirth_c99_ZPlusC99_line(v29));
			VTUP(r5)->cells[1] = v30;
			VAL r31 = pop_resource();
			VAL v32 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r5, r31));
			push_resource(v32);
		} break;
		case 0LL: { // None
			VAL r33 = pop_resource();
			VAL v34 = (VVAL(VTUP(r33)->cells[1]));
			lpush(&lbl_ZPlusarg, r1);
			push_value(v2);
			VAL v35 = (mw_mirth_c99_ZPlusC99_indent(v34));
			VAL v36 = (lpop(&lbl_ZPlusarg));
			VAL v37 = pop_value();
			VAL v38 = (mw_mirth_c99_c99Z_unopZ_exprZBang(v37, v36, v35));
			VAL v39 = (mw_mirth_c99_ZPlusC99_line(v38));
			VTUP(r33)->cells[1] = v39;
			push_resource(r33);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			lpush(&lbl_ZPlusarg, r1);
			push_value(v2);
		}
	}
	VAL r40 = pop_resource();
	return r40;
}
static VAL mw_mirth_c99_C99UnOp_Mk (VAL x1, int64_t x2, VAL x3, VAL x4) {
	VAL v0 = mtw_mirth_c99_C99UnOp_C99UnOp(x1, x2, x3, x4);
	return v0;
}
static VAL mw_mirth_c99_c99Z_primZ_unopZAsk (int64_t x1) {
	switch (x1) {
		case 53LL: { // PRIM_BOOL_NOT
			STR* v0;
			STRLIT(v0, "!", 1);
			int64_t v1 = 12LL /* C99RT_BOOL */;
			STR* v2;
			STRLIT(v2, "", 0);
			int64_t v3 = 12LL /* C99RT_BOOL */;
			push_str(v0);
			push_i64(v1);
			push_str(v2);
			VAL v4 = mtw_std_maybe_Maybe_1_Some(MKI64(v3));
			VAL v5 = pop_value();
			int64_t v6 = pop_i64();
			VAL v7 = pop_value();
			VAL v8 = mw_mirth_c99_C99UnOp_Mk(v7, v6, v5, v4);
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v9);
		} break;
		case 97LL: { // PRIM_I64_GET
			STR* v10;
			STRLIT(v10, "*(int64_t*)", 11);
			int64_t v11 = 13LL /* C99RT_PTR */;
			STR* v12;
			STRLIT(v12, "", 0);
			int64_t v13 = 2LL /* C99RT_I64 */;
			push_str(v10);
			push_i64(v11);
			push_str(v12);
			VAL v14 = mtw_std_maybe_Maybe_1_Some(MKI64(v13));
			VAL v15 = pop_value();
			int64_t v16 = pop_i64();
			VAL v17 = pop_value();
			VAL v18 = mw_mirth_c99_C99UnOp_Mk(v17, v16, v15, v14);
			VAL v19 = mtw_std_maybe_Maybe_1_Some(v18);
			push_value(v19);
		} break;
		case 95LL: { // PRIM_I32_GET
			STR* v20;
			STRLIT(v20, "*(int32_t*)", 11);
			int64_t v21 = 13LL /* C99RT_PTR */;
			STR* v22;
			STRLIT(v22, "", 0);
			int64_t v23 = 3LL /* C99RT_I32 */;
			push_str(v20);
			push_i64(v21);
			push_str(v22);
			VAL v24 = mtw_std_maybe_Maybe_1_Some(MKI64(v23));
			VAL v25 = pop_value();
			int64_t v26 = pop_i64();
			VAL v27 = pop_value();
			VAL v28 = mw_mirth_c99_C99UnOp_Mk(v27, v26, v25, v24);
			VAL v29 = mtw_std_maybe_Maybe_1_Some(v28);
			push_value(v29);
		} break;
		case 93LL: { // PRIM_I16_GET
			STR* v30;
			STRLIT(v30, "*(int16_t*)", 11);
			int64_t v31 = 13LL /* C99RT_PTR */;
			STR* v32;
			STRLIT(v32, "", 0);
			int64_t v33 = 4LL /* C99RT_I16 */;
			push_str(v30);
			push_i64(v31);
			push_str(v32);
			VAL v34 = mtw_std_maybe_Maybe_1_Some(MKI64(v33));
			VAL v35 = pop_value();
			int64_t v36 = pop_i64();
			VAL v37 = pop_value();
			VAL v38 = mw_mirth_c99_C99UnOp_Mk(v37, v36, v35, v34);
			VAL v39 = mtw_std_maybe_Maybe_1_Some(v38);
			push_value(v39);
		} break;
		case 91LL: { // PRIM_I8_GET
			STR* v40;
			STRLIT(v40, "*(int8_t*)", 10);
			int64_t v41 = 13LL /* C99RT_PTR */;
			STR* v42;
			STRLIT(v42, "", 0);
			int64_t v43 = 5LL /* C99RT_I8 */;
			push_str(v40);
			push_i64(v41);
			push_str(v42);
			VAL v44 = mtw_std_maybe_Maybe_1_Some(MKI64(v43));
			VAL v45 = pop_value();
			int64_t v46 = pop_i64();
			VAL v47 = pop_value();
			VAL v48 = mw_mirth_c99_C99UnOp_Mk(v47, v46, v45, v44);
			VAL v49 = mtw_std_maybe_Maybe_1_Some(v48);
			push_value(v49);
		} break;
		case 89LL: { // PRIM_U64_GET
			STR* v50;
			STRLIT(v50, "*(uint64_t*)", 12);
			int64_t v51 = 13LL /* C99RT_PTR */;
			STR* v52;
			STRLIT(v52, "", 0);
			int64_t v53 = 6LL /* C99RT_U64 */;
			push_str(v50);
			push_i64(v51);
			push_str(v52);
			VAL v54 = mtw_std_maybe_Maybe_1_Some(MKI64(v53));
			VAL v55 = pop_value();
			int64_t v56 = pop_i64();
			VAL v57 = pop_value();
			VAL v58 = mw_mirth_c99_C99UnOp_Mk(v57, v56, v55, v54);
			VAL v59 = mtw_std_maybe_Maybe_1_Some(v58);
			push_value(v59);
		} break;
		case 87LL: { // PRIM_U32_GET
			STR* v60;
			STRLIT(v60, "*(uint32_t*)", 12);
			int64_t v61 = 13LL /* C99RT_PTR */;
			STR* v62;
			STRLIT(v62, "", 0);
			int64_t v63 = 7LL /* C99RT_U32 */;
			push_str(v60);
			push_i64(v61);
			push_str(v62);
			VAL v64 = mtw_std_maybe_Maybe_1_Some(MKI64(v63));
			VAL v65 = pop_value();
			int64_t v66 = pop_i64();
			VAL v67 = pop_value();
			VAL v68 = mw_mirth_c99_C99UnOp_Mk(v67, v66, v65, v64);
			VAL v69 = mtw_std_maybe_Maybe_1_Some(v68);
			push_value(v69);
		} break;
		case 85LL: { // PRIM_U16_GET
			STR* v70;
			STRLIT(v70, "*(uint16_t*)", 12);
			int64_t v71 = 13LL /* C99RT_PTR */;
			STR* v72;
			STRLIT(v72, "", 0);
			int64_t v73 = 8LL /* C99RT_U16 */;
			push_str(v70);
			push_i64(v71);
			push_str(v72);
			VAL v74 = mtw_std_maybe_Maybe_1_Some(MKI64(v73));
			VAL v75 = pop_value();
			int64_t v76 = pop_i64();
			VAL v77 = pop_value();
			VAL v78 = mw_mirth_c99_C99UnOp_Mk(v77, v76, v75, v74);
			VAL v79 = mtw_std_maybe_Maybe_1_Some(v78);
			push_value(v79);
		} break;
		case 83LL: { // PRIM_U8_GET
			STR* v80;
			STRLIT(v80, "*(uint8_t*)", 11);
			int64_t v81 = 13LL /* C99RT_PTR */;
			STR* v82;
			STRLIT(v82, "", 0);
			int64_t v83 = 9LL /* C99RT_U8 */;
			push_str(v80);
			push_i64(v81);
			push_str(v82);
			VAL v84 = mtw_std_maybe_Maybe_1_Some(MKI64(v83));
			VAL v85 = pop_value();
			int64_t v86 = pop_i64();
			VAL v87 = pop_value();
			VAL v88 = mw_mirth_c99_C99UnOp_Mk(v87, v86, v85, v84);
			VAL v89 = mtw_std_maybe_Maybe_1_Some(v88);
			push_value(v89);
		} break;
		case 65LL: { // PRIM_PTR_GET
			STR* v90;
			STRLIT(v90, "*(void**)", 9);
			int64_t v91 = 13LL /* C99RT_PTR */;
			STR* v92;
			STRLIT(v92, "", 0);
			int64_t v93 = 13LL /* C99RT_PTR */;
			push_str(v90);
			push_i64(v91);
			push_str(v92);
			VAL v94 = mtw_std_maybe_Maybe_1_Some(MKI64(v93));
			VAL v95 = pop_value();
			int64_t v96 = pop_i64();
			VAL v97 = pop_value();
			VAL v98 = mw_mirth_c99_C99UnOp_Mk(v97, v96, v95, v94);
			VAL v99 = mtw_std_maybe_Maybe_1_Some(v98);
			push_value(v99);
		} break;
		case 31LL: { // PRIM_INT_TO_F32
			STR* v100;
			STRLIT(v100, "(float)", 7);
			int64_t v101 = 2LL /* C99RT_I64 */;
			STR* v102;
			STRLIT(v102, "", 0);
			int64_t v103 = 11LL /* C99RT_F32 */;
			push_str(v100);
			push_i64(v101);
			push_str(v102);
			VAL v104 = mtw_std_maybe_Maybe_1_Some(MKI64(v103));
			VAL v105 = pop_value();
			int64_t v106 = pop_i64();
			VAL v107 = pop_value();
			VAL v108 = mw_mirth_c99_C99UnOp_Mk(v107, v106, v105, v104);
			VAL v109 = mtw_std_maybe_Maybe_1_Some(v108);
			push_value(v109);
		} break;
		case 32LL: { // PRIM_INT_TO_F64
			STR* v110;
			STRLIT(v110, "(double)", 8);
			int64_t v111 = 2LL /* C99RT_I64 */;
			STR* v112;
			STRLIT(v112, "", 0);
			int64_t v113 = 10LL /* C99RT_F64 */;
			push_str(v110);
			push_i64(v111);
			push_str(v112);
			VAL v114 = mtw_std_maybe_Maybe_1_Some(MKI64(v113));
			VAL v115 = pop_value();
			int64_t v116 = pop_i64();
			VAL v117 = pop_value();
			VAL v118 = mw_mirth_c99_C99UnOp_Mk(v117, v116, v115, v114);
			VAL v119 = mtw_std_maybe_Maybe_1_Some(v118);
			push_value(v119);
		} break;
		case 30LL: { // PRIM_INT_TO_STR
			STR* v120;
			STRLIT(v120, "i64_show(", 9);
			int64_t v121 = 2LL /* C99RT_I64 */;
			STR* v122;
			STRLIT(v122, ")", 1);
			int64_t v123 = 1LL /* C99RT_STR */;
			push_str(v120);
			push_i64(v121);
			push_str(v122);
			VAL v124 = mtw_std_maybe_Maybe_1_Some(MKI64(v123));
			VAL v125 = pop_value();
			int64_t v126 = pop_i64();
			VAL v127 = pop_value();
			VAL v128 = mw_mirth_c99_C99UnOp_Mk(v127, v126, v125, v124);
			VAL v129 = mtw_std_maybe_Maybe_1_Some(v128);
			push_value(v129);
		} break;
		case 39LL: { // PRIM_F32_TO_INT
			STR* v130;
			STRLIT(v130, "(int64_t)", 9);
			int64_t v131 = 11LL /* C99RT_F32 */;
			STR* v132;
			STRLIT(v132, "", 0);
			int64_t v133 = 2LL /* C99RT_I64 */;
			push_str(v130);
			push_i64(v131);
			push_str(v132);
			VAL v134 = mtw_std_maybe_Maybe_1_Some(MKI64(v133));
			VAL v135 = pop_value();
			int64_t v136 = pop_i64();
			VAL v137 = pop_value();
			VAL v138 = mw_mirth_c99_C99UnOp_Mk(v137, v136, v135, v134);
			VAL v139 = mtw_std_maybe_Maybe_1_Some(v138);
			push_value(v139);
		} break;
		case 41LL: { // PRIM_F32_TO_F64
			STR* v140;
			STRLIT(v140, "(double)", 8);
			int64_t v141 = 11LL /* C99RT_F32 */;
			STR* v142;
			STRLIT(v142, "", 0);
			int64_t v143 = 10LL /* C99RT_F64 */;
			push_str(v140);
			push_i64(v141);
			push_str(v142);
			VAL v144 = mtw_std_maybe_Maybe_1_Some(MKI64(v143));
			VAL v145 = pop_value();
			int64_t v146 = pop_i64();
			VAL v147 = pop_value();
			VAL v148 = mw_mirth_c99_C99UnOp_Mk(v147, v146, v145, v144);
			VAL v149 = mtw_std_maybe_Maybe_1_Some(v148);
			push_value(v149);
		} break;
		case 40LL: { // PRIM_F32_TO_STR
			STR* v150;
			STRLIT(v150, "f32_show(", 9);
			int64_t v151 = 11LL /* C99RT_F32 */;
			STR* v152;
			STRLIT(v152, ")", 1);
			int64_t v153 = 1LL /* C99RT_STR */;
			push_str(v150);
			push_i64(v151);
			push_str(v152);
			VAL v154 = mtw_std_maybe_Maybe_1_Some(MKI64(v153));
			VAL v155 = pop_value();
			int64_t v156 = pop_i64();
			VAL v157 = pop_value();
			VAL v158 = mw_mirth_c99_C99UnOp_Mk(v157, v156, v155, v154);
			VAL v159 = mtw_std_maybe_Maybe_1_Some(v158);
			push_value(v159);
		} break;
		case 48LL: { // PRIM_F64_TO_INT
			STR* v160;
			STRLIT(v160, "(int64_t)", 9);
			int64_t v161 = 10LL /* C99RT_F64 */;
			STR* v162;
			STRLIT(v162, "", 0);
			int64_t v163 = 2LL /* C99RT_I64 */;
			push_str(v160);
			push_i64(v161);
			push_str(v162);
			VAL v164 = mtw_std_maybe_Maybe_1_Some(MKI64(v163));
			VAL v165 = pop_value();
			int64_t v166 = pop_i64();
			VAL v167 = pop_value();
			VAL v168 = mw_mirth_c99_C99UnOp_Mk(v167, v166, v165, v164);
			VAL v169 = mtw_std_maybe_Maybe_1_Some(v168);
			push_value(v169);
		} break;
		case 50LL: { // PRIM_F64_TO_F32
			STR* v170;
			STRLIT(v170, "(float)", 7);
			int64_t v171 = 10LL /* C99RT_F64 */;
			STR* v172;
			STRLIT(v172, "", 0);
			int64_t v173 = 11LL /* C99RT_F32 */;
			push_str(v170);
			push_i64(v171);
			push_str(v172);
			VAL v174 = mtw_std_maybe_Maybe_1_Some(MKI64(v173));
			VAL v175 = pop_value();
			int64_t v176 = pop_i64();
			VAL v177 = pop_value();
			VAL v178 = mw_mirth_c99_C99UnOp_Mk(v177, v176, v175, v174);
			VAL v179 = mtw_std_maybe_Maybe_1_Some(v178);
			push_value(v179);
		} break;
		case 49LL: { // PRIM_F64_TO_STR
			STR* v180;
			STRLIT(v180, "f64_show(", 9);
			int64_t v181 = 10LL /* C99RT_F64 */;
			STR* v182;
			STRLIT(v182, ")", 1);
			int64_t v183 = 1LL /* C99RT_STR */;
			push_str(v180);
			push_i64(v181);
			push_str(v182);
			VAL v184 = mtw_std_maybe_Maybe_1_Some(MKI64(v183));
			VAL v185 = pop_value();
			int64_t v186 = pop_i64();
			VAL v187 = pop_value();
			VAL v188 = mw_mirth_c99_C99UnOp_Mk(v187, v186, v185, v184);
			VAL v189 = mtw_std_maybe_Maybe_1_Some(v188);
			push_value(v189);
		} break;
		case 67LL: { // PRIM_PTR_ALLOC
			STR* v190;
			STRLIT(v190, "ptr_alloc(", 10);
			int64_t v191 = 6LL /* C99RT_U64 */;
			STR* v192;
			STRLIT(v192, ");", 2);
			int64_t v193 = 13LL /* C99RT_PTR */;
			push_str(v190);
			push_i64(v191);
			push_str(v192);
			VAL v194 = mtw_std_maybe_Maybe_1_Some(MKI64(v193));
			VAL v195 = pop_value();
			int64_t v196 = pop_i64();
			VAL v197 = pop_value();
			VAL v198 = mw_mirth_c99_C99UnOp_Mk(v197, v196, v195, v194);
			VAL v199 = mtw_std_maybe_Maybe_1_Some(v198);
			push_value(v199);
		} break;
		case 69LL: { // PRIM_PTR_FREE
			STR* v200;
			STRLIT(v200, "free(", 5);
			int64_t v201 = 13LL /* C99RT_PTR */;
			STR* v202;
			STRLIT(v202, ");", 2);
			int64_t v203 = 0LL /* None */;
			VAL v204 = mw_mirth_c99_C99UnOp_Mk(MKSTR(v200), v201, MKSTR(v202), MKI64(v203));
			VAL v205 = mtw_std_maybe_Maybe_1_Some(v204);
			push_value(v205);
		} break;
		case 74LL: { // PRIM_STR_BASE
			STR* v206;
			STRLIT(v206, "str_base(", 9);
			int64_t v207 = 1LL /* C99RT_STR */;
			STR* v208;
			STRLIT(v208, ")", 1);
			int64_t v209 = 13LL /* C99RT_PTR */;
			push_str(v206);
			push_i64(v207);
			push_str(v208);
			VAL v210 = mtw_std_maybe_Maybe_1_Some(MKI64(v209));
			VAL v211 = pop_value();
			int64_t v212 = pop_i64();
			VAL v213 = pop_value();
			VAL v214 = mw_mirth_c99_C99UnOp_Mk(v213, v212, v211, v210);
			VAL v215 = mtw_std_maybe_Maybe_1_Some(v214);
			push_value(v215);
		} break;
		case 73LL: { // PRIM_STR_NUM_BYTES
			STR* v216;
			STRLIT(v216, "str_size(", 9);
			int64_t v217 = 1LL /* C99RT_STR */;
			STR* v218;
			STRLIT(v218, ")", 1);
			int64_t v219 = 6LL /* C99RT_U64 */;
			push_str(v216);
			push_i64(v217);
			push_str(v218);
			VAL v220 = mtw_std_maybe_Maybe_1_Some(MKI64(v219));
			VAL v221 = pop_value();
			int64_t v222 = pop_i64();
			VAL v223 = pop_value();
			VAL v224 = mw_mirth_c99_C99UnOp_Mk(v223, v222, v221, v220);
			VAL v225 = mtw_std_maybe_Maybe_1_Some(v224);
			push_value(v225);
		} break;
		case 58LL: { // PRIM_MUT_GET
			STR* v226;
			STRLIT(v226, "mut_get(", 8);
			int64_t v227 = 0LL /* C99RT_VAL */;
			STR* v228;
			STRLIT(v228, ")", 1);
			int64_t v229 = 0LL /* C99RT_VAL */;
			push_str(v226);
			push_i64(v227);
			push_str(v228);
			VAL v230 = mtw_std_maybe_Maybe_1_Some(MKI64(v229));
			VAL v231 = pop_value();
			int64_t v232 = pop_i64();
			VAL v233 = pop_value();
			VAL v234 = mw_mirth_c99_C99UnOp_Mk(v233, v232, v231, v230);
			VAL v235 = mtw_std_maybe_Maybe_1_Some(v234);
			push_value(v235);
		} break;
		case 60LL: { // PRIM_MUT_IS_SET
			STR* v236;
			STRLIT(v236, "mut_is_set(", 11);
			int64_t v237 = 0LL /* C99RT_VAL */;
			STR* v238;
			STRLIT(v238, ")", 1);
			int64_t v239 = 12LL /* C99RT_BOOL */;
			push_str(v236);
			push_i64(v237);
			push_str(v238);
			VAL v240 = mtw_std_maybe_Maybe_1_Some(MKI64(v239));
			VAL v241 = pop_value();
			int64_t v242 = pop_i64();
			VAL v243 = pop_value();
			VAL v244 = mw_mirth_c99_C99UnOp_Mk(v243, v242, v241, v240);
			VAL v245 = mtw_std_maybe_Maybe_1_Some(v244);
			push_value(v245);
		} break;
		default: {
			int64_t v246 = 0LL /* None */;
			push_i64(v246);
		} break;
	}
	VAL v247 = pop_value();
	return v247;
}
static void mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr (VAL x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	mw_mirth_type_Type_c99Z_repr(x1, v1);
	VAL r2 = pop_resource();
	VTUP(v0)->cells[6] = r2;
	VTUP(x2)->cells[1] = v0;
	push_resource(x2);
}
static void mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr (VAL x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	mw_mirth_type_Resource_c99Z_repr(x1, v1);
	VAL r2 = pop_resource();
	VTUP(v0)->cells[6] = r2;
	VTUP(x2)->cells[1] = v0;
	push_resource(x2);
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_mirth_type_StackType_forceZ_consZAskZBang(x1);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL r6 = pop_resource();
	push_value(v5);
	mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v3, r6);
	int64_t v7 = pop_i64();
	VAL r8 = pop_resource();
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r8, v7);
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang (VAL x1, VAL x2) {
	push_resource(x2);
	VAL v0 = mw_mirth_type_StackType_forceZ_withZAskZBang(x1);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL r6 = pop_resource();
	push_value(v5);
	mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v3, r6);
	int64_t v7 = pop_i64();
	VAL r8 = pop_resource();
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r8, v7);
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	push_u64(x1);
	VAL v0 = mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang(x1, x2);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL r6 = pop_resource();
	push_value(v5);
	mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v3, r6);
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	VAL r10 = pop_resource();
	push_value(v8);
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(VI64(v7), VU64(v9), r10);
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZ_fromZ_stackZ_typeZBang (uint64_t x1, VAL x2, VAL x3) {
	push_resource(x3);
	push_u64(x1);
	VAL v0 = mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang(x1, x2);
	VAL v1 = mw_std_maybe_Maybe_1_unwrap(v0);
	VAL v2;
	VAL v3;
	value_uncons(v1, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	VAL r6 = pop_resource();
	push_value(v5);
	mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v3, r6);
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	VAL r10 = pop_resource();
	push_value(v8);
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(VI64(v7), VU64(v9), r10);
}
static VAL mw_mirth_c99_c99Z_primZBang (VAL x1, int64_t x2, VAL x3) {
	switch (x2) {
		case 0LL: { // PRIM_CORE_ID
			decref(x1);
			push_resource(x3);
		} break;
		case 2LL: { // PRIM_CORE_DROP
			VAL v0 = VVAL(VTUP(x1)->cells[6]);
			incref(v0);
			decref(x1);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v0, x3);
			VAL v1 = pop_value();
			decref(v1);
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			VAL v4 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(r3, r2));
			push_resource(v4);
		} break;
		case 1LL: { // PRIM_CORE_DUP
			VAL v5 = VVAL(VTUP(x1)->cells[6]);
			incref(v5);
			decref(x1);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v5, x3);
			VAL v6 = pop_value();
			decref(v6);
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			mw_mirth_c99_ZPlusC99Local_dupZ_localZBang(r8, r7);
			VAL r9 = pop_resource();
			VAL r10 = pop_resource();
			VAL r11 = pop_resource();
			VAL v12 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r11, r10));
			VAL v13 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v12, r9));
			push_resource(v13);
		} break;
		case 3LL: { // PRIM_CORE_SWAP
			VAL v14 = VVAL(VTUP(x1)->cells[6]);
			incref(v14);
			decref(x1);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v14, x3);
			VAL r15 = pop_resource();
			VAL r16 = pop_resource();
			VAL v17 = pop_value();
			lpush(&lbl_ZPlusb, r15);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v17, r16);
			VAL r18 = pop_resource();
			VAL v19 = pop_value();
			decref(v19);
			VAL v20 = (lpop(&lbl_ZPlusb));
			VAL r21 = pop_resource();
			lpush(&lbl_ZPlusa, r18);
			VAL v22 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r21, v20));
			VAL v23 = (lpop(&lbl_ZPlusa));
			VAL v24 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v22, v23));
			push_resource(v24);
		} break;
		case 12LL: { // PRIM_CORE_RSWAP
			VAL v25 = VVAL(VTUP(x1)->cells[6]);
			incref(v25);
			decref(x1);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v25, x3);
			VAL r26 = pop_resource();
			VAL r27 = pop_resource();
			VAL v28 = pop_value();
			lpush(&lbl_ZPlusb, r26);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v28, r27);
			VAL r29 = pop_resource();
			VAL v30 = pop_value();
			decref(v30);
			VAL v31 = (lpop(&lbl_ZPlusb));
			VAL r32 = pop_resource();
			lpush(&lbl_ZPlusa, r29);
			VAL v33 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(r32, v31));
			VAL v34 = (lpop(&lbl_ZPlusa));
			VAL v35 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v33, v34));
			push_resource(v35);
		} break;
		case 4LL: { // PRIM_CORE_DIP
			incref(x1);
			VAL v36 = VVAL(VTUP(x1)->cells[5]);
			incref(v36);
			decref(x1);
			push_resource(x3);
			push_value(x1);
			VAL v37 = mw_std_list_List_1_ZDivL1(v36);
			switch (get_data_tag(v37)) {
				case 1LL: { // Some
					VAL v38 = mtp_std_maybe_Maybe_1_Some(v37);
					push_value(v38);
				} break;
				case 0LL: { // None
					STR* v39;
					STRLIT(v39, "unexpected number of arguments to PRIM_CORE_DIP", 47);
					push_str(v39);
					do_panic();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			uint64_t v40 = pop_u64();
			VAL v41 = pop_value();
			VAL v42 = VVAL(VTUP(v41)->cells[6]);
			incref(v42);
			decref(v41);
			VAL r43 = pop_resource();
			push_u64(v40);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_fromZ_stackZ_typeZBang(v42, r43);
			VAL v44 = pop_value();
			decref(v44);
			VAL r45 = pop_resource();
			VAL r46 = pop_resource();
			uint64_t v47 = pop_u64();
			lpush(&lbl_ZPlusdipped, r45);
			VAL v48 = (mw_mirth_c99_c99Z_argZ_runZBang(v47, r46));
			VAL v49 = (lpop(&lbl_ZPlusdipped));
			VAL v50 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v48, v49));
			push_resource(v50);
		} break;
		case 13LL: { // PRIM_CORE_RDIP
			incref(x1);
			VAL v51 = VVAL(VTUP(x1)->cells[5]);
			incref(v51);
			decref(x1);
			push_resource(x3);
			push_value(x1);
			VAL v52 = mw_std_list_List_1_ZDivL1(v51);
			switch (get_data_tag(v52)) {
				case 1LL: { // Some
					VAL v53 = mtp_std_maybe_Maybe_1_Some(v52);
					push_value(v53);
				} break;
				case 0LL: { // None
					STR* v54;
					STRLIT(v54, "unexpected number of arguments to PRIM_CORE_RDIP", 48);
					push_str(v54);
					do_panic();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			uint64_t v55 = pop_u64();
			VAL v56 = pop_value();
			VAL v57 = VVAL(VTUP(v56)->cells[6]);
			incref(v57);
			decref(v56);
			VAL r58 = pop_resource();
			push_u64(v55);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_fromZ_stackZ_typeZBang(v57, r58);
			VAL v59 = pop_value();
			decref(v59);
			VAL r60 = pop_resource();
			VAL r61 = pop_resource();
			uint64_t v62 = pop_u64();
			lpush(&lbl_ZPlusdipped, r60);
			VAL v63 = (mw_mirth_c99_c99Z_argZ_runZBang(v62, r61));
			VAL v64 = (lpop(&lbl_ZPlusdipped));
			VAL v65 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v63, v64));
			push_resource(v65);
		} break;
		case 5LL: { // PRIM_CORE_IF
			VAL v66 = VVAL(VTUP(x1)->cells[5]);
			incref(v66);
			decref(x1);
			incref(v66);
			push_resource(x3);
			push_value(v66);
			VAL v67 = mw_std_list_List_1_ZDivL2(v66);
			switch (get_data_tag(v67)) {
				case 1LL: { // Some
					VAL v68 = mtp_std_maybe_Maybe_1_Some(v67);
					push_value(v68);
				} break;
				case 0LL: { // None
					STR* v69;
					STRLIT(v69, "unexpected number of arguments to PRIM_CORE_IF", 46);
					push_str(v69);
					do_panic();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v70 = pop_value();
			VAL v71 = pop_value();
			decref(v71);
			VAL v72;
			VAL v73;
			value_uncons(v70, &v72, &v73);
			VAL v74;
			VAL v75;
			value_uncons(v72, &v74, &v75);
			decref(v74);
			int64_t v76 = 12LL /* C99RT_BOOL */;
			VAL r77 = pop_resource();
			push_value(v75);
			push_value(v73);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r77, v76);
			VAL r78 = pop_resource();
			VAL r79 = pop_resource();
			lpush(&lbl_ZPluscond, r78);
			VAL v80 = (mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang(r79));
			VAL v81 = (VVAL(VTUP(v80)->cells[1]));
			VAL v82 = (mw_mirth_c99_ZPlusC99_indent(v81));
			STR* v83;
			STRLIT(v83, "if (", 4);
			VAL v84 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v83), v82));
			VAL v85 = (lpop(&lbl_ZPluscond));
			int64_t v86 = 12LL /* C99RT_BOOL */;
			push_resource(v84);
			VAL v87 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v86, v85);
			VAL r88 = pop_resource();
			VAL v89 = (mw_mirth_c99_ZPlusC99_put(v87, r88));
			STR* v90;
			STRLIT(v90, ") {", 3);
			VAL v91 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v90), v89));
			VAL v92 = (mw_mirth_c99_ZPlusC99_line(v91));
			VTUP(v80)->cells[1] = v92;
			VAL v93 = (VVAL(VTUP(v80)->cells[1]));
			int64_t v94 = VI64(VTUP(v93)->cells[2]);
			int64_t v95 = 1LL;
			int64_t v96 = i64_add(v94, v95);
			VTUP(v93)->cells[2] = MKI64(v96);
			VTUP(v80)->cells[1] = v93;
			FNPTR v97 = &mb_mirth_c99_c99Z_primZBang_6;
			VAL v98 = (mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1(v80, MKFNPTR(v97)));
			VAL v99 = (VVAL(VTUP(v98)->cells[1]));
			int64_t v100 = VI64(VTUP(v99)->cells[2]);
			int64_t v101 = 1LL;
			int64_t v102 = i64_sub(v100, v101);
			int64_t v103 = mw_std_prim_Int_ZToNat(v102);
			VTUP(v99)->cells[2] = MKI64(v103);
			VTUP(v98)->cells[1] = v99;
			VAL v104 = (VVAL(VTUP(v98)->cells[1]));
			VAL v105 = (mw_mirth_c99_ZPlusC99_indent(v104));
			STR* v106;
			STRLIT(v106, "} else {", 8);
			VAL v107 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v106), v105));
			VAL v108 = (mw_mirth_c99_ZPlusC99_line(v107));
			VTUP(v98)->cells[1] = v108;
			VAL v109 = (VVAL(VTUP(v98)->cells[1]));
			int64_t v110 = VI64(VTUP(v109)->cells[2]);
			int64_t v111 = 1LL;
			int64_t v112 = i64_add(v110, v111);
			VTUP(v109)->cells[2] = MKI64(v112);
			VTUP(v98)->cells[1] = v109;
			FNPTR v113 = &mb_mirth_c99_c99Z_primZBang_9;
			VAL v114 = (mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1(v98, MKFNPTR(v113)));
			VAL v115 = (VVAL(VTUP(v114)->cells[1]));
			int64_t v116 = VI64(VTUP(v115)->cells[2]);
			int64_t v117 = 1LL;
			int64_t v118 = i64_sub(v116, v117);
			int64_t v119 = mw_std_prim_Int_ZToNat(v118);
			VTUP(v115)->cells[2] = MKI64(v119);
			VTUP(v114)->cells[1] = v115;
			VAL v120 = (VVAL(VTUP(v114)->cells[1]));
			VAL v121 = (mw_mirth_c99_ZPlusC99_indent(v120));
			STR* v122;
			STRLIT(v122, "}", 1);
			VAL v123 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v122), v121));
			VAL v124 = (mw_mirth_c99_ZPlusC99_line(v123));
			VTUP(v114)->cells[1] = v124;
			VAL v125 = (mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang(v114));
			push_resource(v125);
		} break;
		case 6LL: { // PRIM_CORE_WHILE
			VAL v126 = VVAL(VTUP(x1)->cells[5]);
			incref(v126);
			decref(x1);
			incref(v126);
			push_resource(x3);
			push_value(v126);
			VAL v127 = mw_std_list_List_1_ZDivL2(v126);
			switch (get_data_tag(v127)) {
				case 1LL: { // Some
					VAL v128 = mtp_std_maybe_Maybe_1_Some(v127);
					push_value(v128);
				} break;
				case 0LL: { // None
					STR* v129;
					STRLIT(v129, "unexpected number of arguments to PRIM_CORE_WHILE", 49);
					push_str(v129);
					do_panic();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL v130 = pop_value();
			VAL v131 = pop_value();
			decref(v131);
			VAL v132;
			VAL v133;
			value_uncons(v130, &v132, &v133);
			VAL v134;
			VAL v135;
			value_uncons(v132, &v134, &v135);
			decref(v134);
			VAL r136 = pop_resource();
			push_value(v135);
			push_value(v133);
			VAL v137 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(r136));
			VAL v138 = (mw_mirth_c99_ZPlusC99_indent(v137));
			STR* v139;
			STRLIT(v139, "while(1) {", 10);
			VAL v140 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v139), v138));
			VAL v141 = (mw_mirth_c99_ZPlusC99_line(v140));
			int64_t v142 = VI64(VTUP(v141)->cells[2]);
			int64_t v143 = 1LL;
			int64_t v144 = i64_add(v142, v143);
			VTUP(v141)->cells[2] = MKI64(v144);
			VAL v145 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v141));
			uint64_t v146 = pop_u64();
			uint64_t v147 = pop_u64();
			push_u64(v146);
			VAL v148 = (mw_mirth_c99_c99Z_argZ_runZBang(v147, v145));
			int64_t v149 = 12LL /* C99RT_BOOL */;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(v148, v149);
			VAL r150 = pop_resource();
			VAL r151 = pop_resource();
			lpush(&lbl_ZPluscond, r150);
			VAL v152 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(r151));
			VAL v153 = (mw_mirth_c99_ZPlusC99_indent(v152));
			STR* v154;
			STRLIT(v154, "if (!", 5);
			VAL v155 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v154), v153));
			VAL v156 = (lpop(&lbl_ZPluscond));
			int64_t v157 = 12LL /* C99RT_BOOL */;
			push_resource(v155);
			VAL v158 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v157, v156);
			VAL r159 = pop_resource();
			VAL v160 = (mw_mirth_c99_ZPlusC99_put(v158, r159));
			STR* v161;
			STRLIT(v161, ") break;", 8);
			VAL v162 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v161), v160));
			VAL v163 = (mw_mirth_c99_ZPlusC99_line(v162));
			VAL v164 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v163));
			uint64_t v165 = pop_u64();
			VAL v166 = (mw_mirth_c99_c99Z_argZ_runZBang(v165, v164));
			VAL v167 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v166));
			int64_t v168 = VI64(VTUP(v167)->cells[2]);
			int64_t v169 = 1LL;
			int64_t v170 = i64_sub(v168, v169);
			int64_t v171 = mw_std_prim_Int_ZToNat(v170);
			VTUP(v167)->cells[2] = MKI64(v171);
			VAL v172 = (mw_mirth_c99_ZPlusC99_indent(v167));
			STR* v173;
			STRLIT(v173, "}", 1);
			VAL v174 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v173), v172));
			VAL v175 = (mw_mirth_c99_ZPlusC99_line(v174));
			VAL v176 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v175));
			push_resource(v176);
		} break;
		case 9LL: { // PRIM_CORE_RUN
			incref(x1);
			VAL v177 = VVAL(VTUP(x1)->cells[5]);
			incref(v177);
			decref(x1);
			push_resource(x3);
			push_value(x1);
			int64_t v178 = mw_std_list_List_1_emptyZAsk(v177);
			if (((bool)v178)) {
			} else {
				STR* v179;
				STRLIT(v179, "expected no arguments to prim-core-run", 38);
				STR* v180;
				STRLIT(v180, "assertion failed: ", 18);
				STR* v181 = str_cat(v180, v179);
				push_str(v181);
				do_panic();
			}
			VAL v182 = pop_value();
			decref(v182);
			int64_t v183 = 0LL /* C99RT_VAL */;
			VAL r184 = pop_resource();
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r184, v183);
			VAL r185 = pop_resource();
			VAL r186 = pop_resource();
			lpush(&lbl_ZPlusclosure, r185);
			VAL v187 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(r186));
			VAL v188 = (VVAL(VTUP(v187)->cells[1]));
			VAL v189 = (mw_mirth_c99_ZPlusC99_indent(v188));
			STR* v190;
			STRLIT(v190, "run_value(", 10);
			VAL v191 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v190), v189));
			VAL v192 = (lpop(&lbl_ZPlusclosure));
			push_resource(v191);
			VAL v193 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v192);
			VAL r194 = pop_resource();
			VAL v195 = (mw_mirth_c99_ZPlusC99_put(v193, r194));
			STR* v196;
			STRLIT(v196, ");", 2);
			VAL v197 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v196), v195));
			VAL v198 = (mw_mirth_c99_ZPlusC99_line(v197));
			VTUP(v187)->cells[1] = v198;
			push_resource(v187);
		} break;
		case 7LL: { // PRIM_CORE_DEBUG
			decref(x1);
			VAL v199 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(x3));
			VAL v200 = (VVAL(VTUP(v199)->cells[1]));
			VAL v201 = (mw_mirth_c99_ZPlusC99_indent(v200));
			STR* v202;
			STRLIT(v202, "trace_stack();", 14);
			VAL v203 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v202), v201));
			VAL v204 = (mw_mirth_c99_ZPlusC99_line(v203));
			VTUP(v199)->cells[1] = v204;
			push_resource(v199);
		} break;
		case 8LL: { // PRIM_CORE_PANIC
			decref(x1);
			VAL v205 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(x3));
			VAL v206 = (VVAL(VTUP(v205)->cells[1]));
			VAL v207 = (mw_mirth_c99_ZPlusC99_indent(v206));
			STR* v208;
			STRLIT(v208, "do_panic();", 11);
			VAL v209 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v208), v207));
			VAL v210 = (mw_mirth_c99_ZPlusC99_line(v209));
			VTUP(v205)->cells[1] = v210;
			push_resource(v205);
		} break;
		case 54LL: { // PRIM_PACK_NIL
			decref(x1);
			int64_t v211 = 0LL /* C99RT_VAL */;
			VAL v212 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v211));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v212);
			VAL v213 = pop_value();
			VAL r214 = pop_resource();
			int64_t v215 = VI64(lpop(&lbl_localZ_repr));
			VAL v216 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v215, v213));
			push_resource(v216);
			VAL v217 = (mw_mirth_c99_ZPlusC99_indent(r214));
			VAL r218 = pop_resource();
			int64_t v219 = VI64(VTUP(r218)->cells[1]);
			push_resource(r218);
			push_resource(v217);
			VAL v220 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v219);
			VAL r221 = pop_resource();
			VAL v222 = (mw_mirth_c99_ZPlusC99_put(v220, r221));
			STR* v223;
			STRLIT(v223, " ", 1);
			VAL v224 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v223), v222));
			VAL r225 = pop_resource();
			VAL v226 = VVAL(VTUP(r225)->cells[2]);
			incref(v226);
			push_resource(r225);
			VAL v227 = (mw_mirth_c99_ZPlusC99_put(v226, v224));
			STR* v228;
			STRLIT(v228, " = ", 3);
			VAL v229 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v228), v227));
			VAL r230 = pop_resource();
			STR* v231;
			STRLIT(v231, "MKNIL", 5);
			VAL v232 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v231), v229));
			STR* v233;
			STRLIT(v233, ";", 1);
			push_resource(r230);
			VAL v234 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v233), v232));
			VAL v235 = (mw_mirth_c99_ZPlusC99_line(v234));
			VTUP(x3)->cells[1] = v235;
			VAL r236 = pop_resource();
			VAL v237 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r236));
			push_resource(v237);
		} break;
		case 56LL: { // PRIM_PACK_UNCONS
			decref(x1);
			int64_t v238 = 0LL /* C99RT_VAL */;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v238);
			VAL r239 = pop_resource();
			int64_t v240 = 0LL /* C99RT_VAL */;
			VAL r241 = pop_resource();
			lpush(&lbl_ZPluscons, r239);
			mw_mirth_c99_C99ReprType_newZ_localZBang(v240, r241);
			VAL r242 = pop_resource();
			int64_t v243 = 0LL /* C99RT_VAL */;
			VAL r244 = pop_resource();
			lpush(&lbl_ZPlustail, r242);
			mw_mirth_c99_C99ReprType_newZ_localZBang(v243, r244);
			VAL r245 = pop_resource();
			VAL r246 = pop_resource();
			VAL v247 = (VVAL(VTUP(r246)->cells[1]));
			lpush(&lbl_ZPlushead, r245);
			VAL v248 = (mw_mirth_c99_ZPlusC99_indent(v247));
			STR* v249;
			STRLIT(v249, "value_uncons(", 13);
			VAL v250 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v249), v248));
			VAL v251 = (lpop(&lbl_ZPluscons));
			push_resource(v250);
			VAL v252 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v251);
			VAL r253 = pop_resource();
			VAL v254 = (mw_mirth_c99_ZPlusC99_put(v252, r253));
			STR* v255;
			STRLIT(v255, ", &", 3);
			VAL v256 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v255), v254));
			VAL v257 = (lpop(&lbl_ZPlustail));
			VAL v258 = VVAL(VTUP(v257)->cells[2]);
			incref(v258);
			lpush(&lbl_ZPlustail, v257);
			VAL v259 = (mw_mirth_c99_ZPlusC99_put(v258, v256));
			STR* v260;
			STRLIT(v260, ", &", 3);
			VAL v261 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v260), v259));
			VAL v262 = (lpop(&lbl_ZPlushead));
			VAL v263 = VVAL(VTUP(v262)->cells[2]);
			incref(v263);
			lpush(&lbl_ZPlushead, v262);
			VAL v264 = (mw_mirth_c99_ZPlusC99_put(v263, v261));
			STR* v265;
			STRLIT(v265, ");", 2);
			VAL v266 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v265), v264));
			VAL v267 = (mw_mirth_c99_ZPlusC99_line(v266));
			VTUP(r246)->cells[1] = v267;
			VAL v268 = (lpop(&lbl_ZPlustail));
			VAL v269 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r246, v268));
			VAL v270 = (lpop(&lbl_ZPlushead));
			VAL v271 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v269, v270));
			push_resource(v271);
		} break;
		case 61LL: { // PRIM_PTR_NIL
			decref(x1);
			int64_t v272 = 13LL /* C99RT_PTR */;
			VAL v273 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v272));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v273);
			VAL v274 = pop_value();
			VAL r275 = pop_resource();
			int64_t v276 = VI64(lpop(&lbl_localZ_repr));
			VAL v277 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v276, v274));
			push_resource(v277);
			VAL v278 = (mw_mirth_c99_ZPlusC99_indent(r275));
			VAL r279 = pop_resource();
			int64_t v280 = VI64(VTUP(r279)->cells[1]);
			push_resource(r279);
			push_resource(v278);
			VAL v281 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v280);
			VAL r282 = pop_resource();
			VAL v283 = (mw_mirth_c99_ZPlusC99_put(v281, r282));
			STR* v284;
			STRLIT(v284, " ", 1);
			VAL v285 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v284), v283));
			VAL r286 = pop_resource();
			VAL v287 = VVAL(VTUP(r286)->cells[2]);
			incref(v287);
			push_resource(r286);
			VAL v288 = (mw_mirth_c99_ZPlusC99_put(v287, v285));
			STR* v289;
			STRLIT(v289, " = ", 3);
			VAL v290 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v289), v288));
			VAL r291 = pop_resource();
			STR* v292;
			STRLIT(v292, "(void*)0", 8);
			VAL v293 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v292), v290));
			STR* v294;
			STRLIT(v294, ";", 1);
			push_resource(r291);
			VAL v295 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v294), v293));
			VAL v296 = (mw_mirth_c99_ZPlusC99_line(v295));
			VTUP(x3)->cells[1] = v296;
			VAL r297 = pop_resource();
			VAL v298 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r297));
			push_resource(v298);
		} break;
		case 64LL: { // PRIM_PTR_SIZE
			decref(x1);
			int64_t v299 = 6LL /* C99RT_U64 */;
			VAL v300 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v299));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v300);
			VAL v301 = pop_value();
			VAL r302 = pop_resource();
			int64_t v303 = VI64(lpop(&lbl_localZ_repr));
			VAL v304 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v303, v301));
			push_resource(v304);
			VAL v305 = (mw_mirth_c99_ZPlusC99_indent(r302));
			VAL r306 = pop_resource();
			int64_t v307 = VI64(VTUP(r306)->cells[1]);
			push_resource(r306);
			push_resource(v305);
			VAL v308 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v307);
			VAL r309 = pop_resource();
			VAL v310 = (mw_mirth_c99_ZPlusC99_put(v308, r309));
			STR* v311;
			STRLIT(v311, " ", 1);
			VAL v312 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v311), v310));
			VAL r313 = pop_resource();
			VAL v314 = VVAL(VTUP(r313)->cells[2]);
			incref(v314);
			push_resource(r313);
			VAL v315 = (mw_mirth_c99_ZPlusC99_put(v314, v312));
			STR* v316;
			STRLIT(v316, " = ", 3);
			VAL v317 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v316), v315));
			VAL r318 = pop_resource();
			STR* v319;
			STRLIT(v319, "sizeof(void*)", 13);
			VAL v320 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v319), v317));
			STR* v321;
			STRLIT(v321, ";", 1);
			push_resource(r318);
			VAL v322 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v321), v320));
			VAL v323 = (mw_mirth_c99_ZPlusC99_line(v322));
			VTUP(x3)->cells[1] = v323;
			VAL r324 = pop_resource();
			VAL v325 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r324));
			push_resource(v325);
		} break;
		case 70LL: { // PRIM_PTR_COPY
			decref(x1);
			int64_t v326 = 13LL /* C99RT_PTR */;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v326);
			VAL r327 = pop_resource();
			int64_t v328 = 6LL /* C99RT_U64 */;
			VAL r329 = pop_resource();
			lpush(&lbl_ZPlusdst, r327);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r329, v328);
			VAL r330 = pop_resource();
			int64_t v331 = 13LL /* C99RT_PTR */;
			VAL r332 = pop_resource();
			lpush(&lbl_ZPluslen, r330);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r332, v331);
			VAL r333 = pop_resource();
			VAL r334 = pop_resource();
			VAL v335 = (VVAL(VTUP(r334)->cells[1]));
			lpush(&lbl_ZPlussrc, r333);
			VAL v336 = (mw_mirth_c99_ZPlusC99_indent(v335));
			STR* v337;
			STRLIT(v337, "ptr_copy(", 9);
			VAL v338 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v337), v336));
			VAL v339 = (lpop(&lbl_ZPlussrc));
			int64_t v340 = 13LL /* C99RT_PTR */;
			push_resource(v338);
			VAL v341 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v340, v339);
			VAL r342 = pop_resource();
			VAL v343 = (mw_mirth_c99_ZPlusC99_put(v341, r342));
			STR* v344;
			STRLIT(v344, ", ", 2);
			VAL v345 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v344), v343));
			VAL v346 = (lpop(&lbl_ZPluslen));
			int64_t v347 = 6LL /* C99RT_U64 */;
			push_resource(v345);
			VAL v348 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v347, v346);
			VAL r349 = pop_resource();
			VAL v350 = (mw_mirth_c99_ZPlusC99_put(v348, r349));
			STR* v351;
			STRLIT(v351, ", ", 2);
			VAL v352 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v351), v350));
			VAL v353 = (lpop(&lbl_ZPlusdst));
			int64_t v354 = 13LL /* C99RT_PTR */;
			push_resource(v352);
			VAL v355 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v354, v353);
			VAL r356 = pop_resource();
			VAL v357 = (mw_mirth_c99_ZPlusC99_put(v355, r356));
			STR* v358;
			STRLIT(v358, ");", 2);
			VAL v359 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v358), v357));
			VAL v360 = (mw_mirth_c99_ZPlusC99_line(v359));
			VTUP(r334)->cells[1] = v360;
			push_resource(r334);
		} break;
		case 71LL: { // PRIM_PTR_FILL
			decref(x1);
			int64_t v361 = 13LL /* C99RT_PTR */;
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x3, v361);
			VAL r362 = pop_resource();
			int64_t v363 = 6LL /* C99RT_U64 */;
			VAL r364 = pop_resource();
			lpush(&lbl_ZPlusdst, r362);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r364, v363);
			VAL r365 = pop_resource();
			int64_t v366 = 9LL /* C99RT_U8 */;
			VAL r367 = pop_resource();
			lpush(&lbl_ZPluslen, r365);
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r367, v366);
			VAL r368 = pop_resource();
			VAL r369 = pop_resource();
			VAL v370 = (VVAL(VTUP(r369)->cells[1]));
			lpush(&lbl_ZPlusval, r368);
			VAL v371 = (mw_mirth_c99_ZPlusC99_indent(v370));
			STR* v372;
			STRLIT(v372, "ptr_fill(", 9);
			VAL v373 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v372), v371));
			VAL v374 = (lpop(&lbl_ZPlusval));
			int64_t v375 = 9LL /* C99RT_U8 */;
			push_resource(v373);
			VAL v376 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v375, v374);
			VAL r377 = pop_resource();
			VAL v378 = (mw_mirth_c99_ZPlusC99_put(v376, r377));
			STR* v379;
			STRLIT(v379, ", ", 2);
			VAL v380 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v379), v378));
			VAL v381 = (lpop(&lbl_ZPluslen));
			int64_t v382 = 6LL /* C99RT_U64 */;
			push_resource(v380);
			VAL v383 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v382, v381);
			VAL r384 = pop_resource();
			VAL v385 = (mw_mirth_c99_ZPlusC99_put(v383, r384));
			STR* v386;
			STRLIT(v386, ", ", 2);
			VAL v387 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v386), v385));
			VAL v388 = (lpop(&lbl_ZPlusdst));
			int64_t v389 = 13LL /* C99RT_PTR */;
			push_resource(v387);
			VAL v390 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v389, v388);
			VAL r391 = pop_resource();
			VAL v392 = (mw_mirth_c99_ZPlusC99_put(v390, r391));
			STR* v393;
			STRLIT(v393, ");", 2);
			VAL v394 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v393), v392));
			VAL v395 = (mw_mirth_c99_ZPlusC99_line(v394));
			VTUP(r369)->cells[1] = v395;
			push_resource(r369);
		} break;
		case 99LL: { // PRIM_SYS_OS
			decref(x1);
			int64_t v396 = 2LL /* C99RT_I64 */;
			VAL v397 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v396));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v397);
			VAL v398 = pop_value();
			VAL r399 = pop_resource();
			int64_t v400 = VI64(lpop(&lbl_localZ_repr));
			VAL v401 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v400, v398));
			push_resource(v401);
			VAL v402 = (mw_mirth_c99_ZPlusC99_indent(r399));
			VAL r403 = pop_resource();
			int64_t v404 = VI64(VTUP(r403)->cells[1]);
			push_resource(r403);
			push_resource(v402);
			VAL v405 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v404);
			VAL r406 = pop_resource();
			VAL v407 = (mw_mirth_c99_ZPlusC99_put(v405, r406));
			STR* v408;
			STRLIT(v408, " ", 1);
			VAL v409 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v408), v407));
			VAL r410 = pop_resource();
			VAL v411 = VVAL(VTUP(r410)->cells[2]);
			incref(v411);
			push_resource(r410);
			VAL v412 = (mw_mirth_c99_ZPlusC99_put(v411, v409));
			STR* v413;
			STRLIT(v413, " = ", 3);
			VAL v414 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v413), v412));
			VAL r415 = pop_resource();
			STR* v416;
			STRLIT(v416, "RUNNING_OS", 10);
			VAL v417 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v416), v414));
			STR* v418;
			STRLIT(v418, ";", 1);
			push_resource(r415);
			VAL v419 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v418), v417));
			VAL v420 = (mw_mirth_c99_ZPlusC99_line(v419));
			VTUP(x3)->cells[1] = v420;
			VAL r421 = pop_resource();
			VAL v422 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r421));
			push_resource(v422);
		} break;
		case 100LL: { // PRIM_SYS_ARCH
			decref(x1);
			int64_t v423 = 2LL /* C99RT_I64 */;
			VAL v424 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v423));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v424);
			VAL v425 = pop_value();
			VAL r426 = pop_resource();
			int64_t v427 = VI64(lpop(&lbl_localZ_repr));
			VAL v428 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v427, v425));
			push_resource(v428);
			VAL v429 = (mw_mirth_c99_ZPlusC99_indent(r426));
			VAL r430 = pop_resource();
			int64_t v431 = VI64(VTUP(r430)->cells[1]);
			push_resource(r430);
			push_resource(v429);
			VAL v432 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v431);
			VAL r433 = pop_resource();
			VAL v434 = (mw_mirth_c99_ZPlusC99_put(v432, r433));
			STR* v435;
			STRLIT(v435, " ", 1);
			VAL v436 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v435), v434));
			VAL r437 = pop_resource();
			VAL v438 = VVAL(VTUP(r437)->cells[2]);
			incref(v438);
			push_resource(r437);
			VAL v439 = (mw_mirth_c99_ZPlusC99_put(v438, v436));
			STR* v440;
			STRLIT(v440, " = ", 3);
			VAL v441 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v440), v439));
			VAL r442 = pop_resource();
			STR* v443;
			STRLIT(v443, "RUNNING_ARCH", 12);
			VAL v444 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v443), v441));
			STR* v445;
			STRLIT(v445, ";", 1);
			push_resource(r442);
			VAL v446 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v445), v444));
			VAL v447 = (mw_mirth_c99_ZPlusC99_line(v446));
			VTUP(x3)->cells[1] = v447;
			VAL r448 = pop_resource();
			VAL v449 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r448));
			push_resource(v449);
		} break;
		case 101LL: { // PRIM_SYS_ARGC
			decref(x1);
			int64_t v450 = 2LL /* C99RT_I64 */;
			VAL v451 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v450));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v451);
			VAL v452 = pop_value();
			VAL r453 = pop_resource();
			int64_t v454 = VI64(lpop(&lbl_localZ_repr));
			VAL v455 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v454, v452));
			push_resource(v455);
			VAL v456 = (mw_mirth_c99_ZPlusC99_indent(r453));
			VAL r457 = pop_resource();
			int64_t v458 = VI64(VTUP(r457)->cells[1]);
			push_resource(r457);
			push_resource(v456);
			VAL v459 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v458);
			VAL r460 = pop_resource();
			VAL v461 = (mw_mirth_c99_ZPlusC99_put(v459, r460));
			STR* v462;
			STRLIT(v462, " ", 1);
			VAL v463 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v462), v461));
			VAL r464 = pop_resource();
			VAL v465 = VVAL(VTUP(r464)->cells[2]);
			incref(v465);
			push_resource(r464);
			VAL v466 = (mw_mirth_c99_ZPlusC99_put(v465, v463));
			STR* v467;
			STRLIT(v467, " = ", 3);
			VAL v468 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v467), v466));
			VAL r469 = pop_resource();
			STR* v470;
			STRLIT(v470, "global_argc", 11);
			VAL v471 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v470), v468));
			STR* v472;
			STRLIT(v472, ";", 1);
			push_resource(r469);
			VAL v473 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v472), v471));
			VAL v474 = (mw_mirth_c99_ZPlusC99_line(v473));
			VTUP(x3)->cells[1] = v474;
			VAL r475 = pop_resource();
			VAL v476 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r475));
			push_resource(v476);
		} break;
		case 102LL: { // PRIM_SYS_ARGV
			decref(x1);
			int64_t v477 = 13LL /* C99RT_PTR */;
			VAL v478 = (VVAL(VTUP(x3)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v477));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v478);
			VAL v479 = pop_value();
			VAL r480 = pop_resource();
			int64_t v481 = VI64(lpop(&lbl_localZ_repr));
			VAL v482 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v481, v479));
			push_resource(v482);
			VAL v483 = (mw_mirth_c99_ZPlusC99_indent(r480));
			VAL r484 = pop_resource();
			int64_t v485 = VI64(VTUP(r484)->cells[1]);
			push_resource(r484);
			push_resource(v483);
			VAL v486 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v485);
			VAL r487 = pop_resource();
			VAL v488 = (mw_mirth_c99_ZPlusC99_put(v486, r487));
			STR* v489;
			STRLIT(v489, " ", 1);
			VAL v490 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v489), v488));
			VAL r491 = pop_resource();
			VAL v492 = VVAL(VTUP(r491)->cells[2]);
			incref(v492);
			push_resource(r491);
			VAL v493 = (mw_mirth_c99_ZPlusC99_put(v492, v490));
			STR* v494;
			STRLIT(v494, " = ", 3);
			VAL v495 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v494), v493));
			VAL r496 = pop_resource();
			STR* v497;
			STRLIT(v497, "global_argv", 11);
			VAL v498 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v497), v495));
			STR* v499;
			STRLIT(v499, ";", 1);
			push_resource(r496);
			VAL v500 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v499), v498));
			VAL v501 = (mw_mirth_c99_ZPlusC99_line(v500));
			VTUP(x3)->cells[1] = v501;
			VAL r502 = pop_resource();
			VAL v503 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x3, r502));
			push_resource(v503);
		} break;
		default: {
			VAL v504 = VVAL(VTUP(x1)->cells[5]);
			incref(v504);
			decref(x1);
			incref(v504);
			push_resource(x3);
			push_value(v504);
			push_i64(x2);
			int64_t v505 = mw_std_list_List_1_emptyZAsk(v504);
			if (((bool)v505)) {
				int64_t v506 = pop_i64();
				push_i64(v506);
				VAL v507 = mw_mirth_c99_c99Z_primZ_binopZAsk(v506);
				switch (get_data_tag(v507)) {
					case 1LL: { // Some
						VAL v508 = mtp_std_maybe_Maybe_1_Some(v507);
						VAL v509 = pop_value();
						decref(v509);
						VAL v510 = pop_value();
						decref(v510);
						VAL r511 = pop_resource();
						VAL v512 = (mw_mirth_c99_c99Z_binopZBang(v508, r511));
						push_resource(v512);
					} break;
					case 0LL: { // None
						int64_t v513 = pop_i64();
						push_i64(v513);
						VAL v514 = mw_mirth_c99_c99Z_primZ_unopZAsk(v513);
						switch (get_data_tag(v514)) {
							case 1LL: { // Some
								VAL v515 = mtp_std_maybe_Maybe_1_Some(v514);
								VAL v516 = pop_value();
								decref(v516);
								VAL v517 = pop_value();
								decref(v517);
								VAL r518 = pop_resource();
								VAL v519 = (mw_mirth_c99_c99Z_unopZBang(v515, r518));
								push_resource(v519);
							} break;
							case 0LL: { // None
								STR* v520;
								STRLIT(v520, "unimplemented prim", 18);
								push_str(v520);
								do_panic();
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								do_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						do_panic();
					}
				}
			} else {
				STR* v521;
				STRLIT(v521, "unexpected number of arguments!", 31);
				push_str(v521);
				do_panic();
			}
		} break;
	}
	VAL r522 = pop_resource();
	return r522;
}
static VAL mw_mirth_c99_c99Z_argsZ_pushZBang (VAL x1, VAL x2) {
	push_resource(x2);
	mw_std_list_List_1_uncons(x1);
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		int64_t v3 = mw_std_maybe_Maybe_1_someZAsk(v2);
		if (!((bool)v3)) break;
		VAL v4 = pop_value();
		VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		VAL v8 = (mw_mirth_c99_c99Z_argZ_pushZBang(VU64(v5), r7));
		push_resource(v8);
		mw_std_list_List_1_uncons(v6);
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	VAL r13 = pop_resource();
	return r13;
}
static VAL mw_mirth_c99_c99Z_argZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v0 = (mw_mirth_c99_c99Z_blockZ_pushZBang(x1, x2));
	return v0;
}
static VAL mw_mirth_c99_c99Z_argZ_runZBang (uint64_t x1, VAL x2) {
	VAL v0 = (mw_mirth_c99_c99Z_blockZ_runZBang(x1, x2));
	return v0;
}
static VAL mw_mirth_c99_c99Z_blockZ_runZBang (uint64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	mw_mirth_arrow_Block_arrow(v1, x1);
	VAL r2 = pop_resource();
	VTUP(v0)->cells[6] = r2;
	VTUP(x2)->cells[1] = v0;
	VAL v3 = pop_value();
	VAL v4 = (mw_mirth_c99_c99Z_arrowZBang(v3, x2));
	return v4;
}
static VAL mw_mirth_c99_ZPlusC99_varZ_put (uint64_t x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "var_", 4);
	push_u64(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	uint64_t v2 = pop_u64();
	push_resource(v1);
	uint64_t v3 = mw_mirth_var_Var_name(v2);
	VAL v4 = mw_mirth_name_Name_mangled(v3);
	VAL r5 = pop_resource();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v4, r5));
	return v6;
}
static VAL mw_mirth_c99_c99Z_packZ_closureZ_varsZBang (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* Nil */;
	push_value(x1);
	push_resource(x2);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	VAL v2 = pop_value();
	push_resource(v1);
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		incref(v8);
		int64_t v11 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v8));
		if (((bool)v11)) {
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v12);
		} else {
			decref(v8);
			int64_t v13 = 0LL /* None */;
			push_i64(v13);
		}
		VAL v14 = pop_value();
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				push_resource(r10);
				VAL v15 = mtp_std_maybe_Maybe_1_Some(v14);
				VAL r16 = pop_resource();
				VAL v17 = mtw_std_list_List_1_Cons(v15, r16);
				push_resource(v17);
			} break;
			case 0LL: { // None
				push_resource(r10);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r10);
			}
		}
		mw_std_list_List_1_uncons(v9);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL r22 = pop_resource();
	VAL v23 = mw_std_list_List_1_reverse(r22);
	incref(v23);
	push_value(v23);
	int64_t v24 = mw_std_list_List_1_emptyZAsk(v23);
	if (((bool)v24)) {
		VAL v25 = pop_value();
		decref(v25);
	} else {
		int64_t v26 = 14LL /* C99RT_FNPTR */;
		VAL r27 = pop_resource();
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r27, v26);
		VAL r28 = pop_resource();
		int64_t v29 = 0LL /* C99RT_VAL */;
		VAL r30 = pop_resource();
		VAL v31 = (VVAL(VTUP(r30)->cells[1]));
		lpush(&lbl_ZPlusfnptr, r28);
		lpush(&lbl_localZ_repr, MKI64(v29));
		mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v31);
		VAL v32 = pop_value();
		VAL r33 = pop_resource();
		int64_t v34 = VI64(lpop(&lbl_localZ_repr));
		VAL v35 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v34, v32));
		push_resource(v35);
		VAL v36 = (mw_mirth_c99_ZPlusC99_indent(r33));
		VAL r37 = pop_resource();
		int64_t v38 = VI64(VTUP(r37)->cells[1]);
		push_resource(r37);
		push_resource(v36);
		VAL v39 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v38);
		VAL r40 = pop_resource();
		VAL v41 = (mw_mirth_c99_ZPlusC99_put(v39, r40));
		STR* v42;
		STRLIT(v42, " ", 1);
		VAL v43 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), v41));
		VAL r44 = pop_resource();
		VAL v45 = VVAL(VTUP(r44)->cells[2]);
		incref(v45);
		push_resource(r44);
		VAL v46 = (mw_mirth_c99_ZPlusC99_put(v45, v43));
		STR* v47;
		STRLIT(v47, " = ", 3);
		VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), v46));
		VAL r49 = pop_resource();
		STR* v50;
		STRLIT(v50, "tup_new(", 8);
		VAL v51 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v50), v48));
		VAL v52 = pop_value();
		incref(v52);
		push_resource(v51);
		push_value(v52);
		int64_t v53 = mw_std_list_List_1_len(v52);
		int64_t v54 = 1LL;
		int64_t v55 = i64_add(v53, v54);
		STR* v56 = i64_show(v55);
		VAL r57 = pop_resource();
		VAL v58 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v56), r57));
		STR* v59;
		STRLIT(v59, ")", 1);
		VAL v60 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v59), v58));
		STR* v61;
		STRLIT(v61, ";", 1);
		push_resource(r49);
		VAL v62 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v61), v60));
		VAL v63 = (mw_mirth_c99_ZPlusC99_line(v62));
		VTUP(r30)->cells[1] = v63;
		VAL r64 = pop_resource();
		VAL v65 = (VVAL(VTUP(r30)->cells[1]));
		lpush(&lbl_ZPlustup, r64);
		VAL v66 = (mw_mirth_c99_ZPlusC99_indent(v65));
		STR* v67;
		STRLIT(v67, "VTUP(", 5);
		VAL v68 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v67), v66));
		VAL v69 = (lpop(&lbl_ZPlustup));
		push_resource(v68);
		mw_mirth_c99_ZPlusC99Local_rdup(v69);
		VAL r70 = pop_resource();
		VAL r71 = pop_resource();
		lpush(&lbl_ZPlustup, r70);
		VAL v72 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r71);
		VAL r73 = pop_resource();
		VAL v74 = (mw_mirth_c99_ZPlusC99_put(v72, r73));
		STR* v75;
		STRLIT(v75, ")->cells[0] = ", 14);
		VAL v76 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v75), v74));
		VAL v77 = (lpop(&lbl_ZPlusfnptr));
		push_resource(v76);
		VAL v78 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(v77);
		VAL r79 = pop_resource();
		VAL v80 = (mw_mirth_c99_ZPlusC99_put(v78, r79));
		STR* v81;
		STRLIT(v81, ";", 1);
		VAL v82 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v81), v80));
		VAL v83 = (mw_mirth_c99_ZPlusC99_line(v82));
		VTUP(r30)->cells[1] = v83;
		int64_t v84 = 1LL;
		VAL v85 = pop_value();
		push_resource(r30);
		lpush(&lbl_i, MKI64(v84));
		mw_std_list_List_1_uncons(v85);
		VAL v86 = pop_value();
		VAL v87 = pop_value();
		push_value(v86);
		push_value(v87);
		while(1) {
			VAL v88 = pop_value();
			incref(v88);
			push_value(v88);
			int64_t v89 = mw_std_maybe_Maybe_1_someZAsk(v88);
			if (!((bool)v89)) break;
			VAL v90 = pop_value();
			VAL v91 = mw_std_maybe_Maybe_1_unwrap(v90);
			VAL v92 = pop_value();
			VAL r93 = pop_resource();
			VAL v94 = (VVAL(VTUP(r93)->cells[1]));
			lpush(&lbl_var, v91);
			VAL v95 = (mw_mirth_c99_ZPlusC99_indent(v94));
			STR* v96;
			STRLIT(v96, "VTUP(", 5);
			VAL v97 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v96), v95));
			VAL v98 = (lpop(&lbl_ZPlustup));
			push_resource(v97);
			mw_mirth_c99_ZPlusC99Local_rdup(v98);
			VAL r99 = pop_resource();
			VAL r100 = pop_resource();
			lpush(&lbl_ZPlustup, r99);
			VAL v101 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r100);
			VAL r102 = pop_resource();
			VAL v103 = (mw_mirth_c99_ZPlusC99_put(v101, r102));
			STR* v104;
			STRLIT(v104, ")->cells[", 9);
			VAL v105 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v104), v103));
			int64_t v106 = VI64(lpop(&lbl_i));
			STR* v107 = i64_show(v106);
			lpush(&lbl_i, MKI64(v106));
			VAL v108 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v107), v105));
			STR* v109;
			STRLIT(v109, "] = ", 4);
			VAL v110 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v109), v108));
			uint64_t v111 = VU64(lpop(&lbl_var));
			lpush(&lbl_var, MKU64(v111));
			VAL v112 = (mw_mirth_c99_ZPlusC99_varZ_put(v111, v110));
			STR* v113;
			STRLIT(v113, "; incref(", 9);
			VAL v114 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v113), v112));
			uint64_t v115 = VU64(lpop(&lbl_var));
			VAL v116 = (mw_mirth_c99_ZPlusC99_varZ_put(v115, v114));
			STR* v117;
			STRLIT(v117, ");", 2);
			VAL v118 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v117), v116));
			VAL v119 = (mw_mirth_c99_ZPlusC99_line(v118));
			VTUP(r93)->cells[1] = v119;
			int64_t v120 = VI64(lpop(&lbl_i));
			int64_t v121 = 1LL;
			int64_t v122 = i64_add(v120, v121);
			push_resource(r93);
			lpush(&lbl_i, MKI64(v122));
			mw_std_list_List_1_uncons(v92);
			VAL v123 = pop_value();
			VAL v124 = pop_value();
			push_value(v123);
			push_value(v124);
		}
		VAL v125 = pop_value();
		decref(v125);
		VAL v126 = pop_value();
		decref(v126);
		int64_t v127 = VI64(lpop(&lbl_i));
		VAL v128 = (lpop(&lbl_ZPlustup));
		VAL r129 = pop_resource();
		VAL v130 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r129, v128));
		push_resource(v130);
	}
	VAL r131 = pop_resource();
	return r131;
}
static VAL mw_mirth_c99_c99Z_popZ_toZ_varZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	VAL v0 = mw_mirth_var_Var_type(x1);
	VAL r1 = pop_resource();
	VAL v2 = (VVAL(VTUP(r1)->cells[1]));
	VAL v3 = (VVAL(VTUP(v2)->cells[6]));
	mw_mirth_type_Type_c99Z_repr(v0, v3);
	VAL r4 = pop_resource();
	VTUP(v2)->cells[6] = r4;
	VTUP(r1)->cells[1] = v2;
	int64_t v5 = pop_i64();
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r1, v5);
	VAL r6 = pop_resource();
	VAL v7 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r6);
	uint64_t v8 = pop_u64();
	VAL r9 = pop_resource();
	VAL v10 = (VVAL(VTUP(r9)->cells[1]));
	push_value(v7);
	push_u64(v8);
	VAL v11 = (mw_mirth_c99_ZPlusC99_indent(v10));
	STR* v12;
	STRLIT(v12, "VAL ", 4);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	uint64_t v14 = pop_u64();
	VAL v15 = (mw_mirth_c99_ZPlusC99_varZ_put(v14, v13));
	STR* v16;
	STRLIT(v16, " = ", 3);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = pop_value();
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(v18, v17));
	STR* v20;
	STRLIT(v20, ";", 1);
	VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
	VAL v22 = (mw_mirth_c99_ZPlusC99_line(v21));
	VTUP(r9)->cells[1] = v22;
	return r9;
}
static VAL mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* Nil */;
	push_value(x1);
	push_resource(x2);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	VAL v2 = pop_value();
	push_resource(v1);
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		incref(v8);
		int64_t v11 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v8));
		if (((bool)v11)) {
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v12);
		} else {
			decref(v8);
			int64_t v13 = 0LL /* None */;
			push_i64(v13);
		}
		VAL v14 = pop_value();
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				push_resource(r10);
				VAL v15 = mtp_std_maybe_Maybe_1_Some(v14);
				VAL r16 = pop_resource();
				VAL v17 = mtw_std_list_List_1_Cons(v15, r16);
				push_resource(v17);
			} break;
			case 0LL: { // None
				push_resource(r10);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r10);
			}
		}
		mw_std_list_List_1_uncons(v9);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL r22 = pop_resource();
	VAL v23 = mw_std_list_List_1_reverse(r22);
	incref(v23);
	push_value(v23);
	int64_t v24 = mw_std_list_List_1_emptyZAsk(v23);
	if (((bool)v24)) {
		VAL v25 = pop_value();
		decref(v25);
	} else {
		int64_t v26 = 0LL /* C99RT_VAL */;
		VAL r27 = pop_resource();
		mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r27, v26);
		VAL r28 = pop_resource();
		int64_t v29 = 1LL;
		VAL v30 = pop_value();
		lpush(&lbl_ZPlustup, r28);
		lpush(&lbl_i, MKI64(v29));
		mw_std_list_List_1_uncons(v30);
		VAL v31 = pop_value();
		VAL v32 = pop_value();
		push_value(v31);
		push_value(v32);
		while(1) {
			VAL v33 = pop_value();
			incref(v33);
			push_value(v33);
			int64_t v34 = mw_std_maybe_Maybe_1_someZAsk(v33);
			if (!((bool)v34)) break;
			VAL v35 = pop_value();
			VAL v36 = mw_std_maybe_Maybe_1_unwrap(v35);
			VAL v37 = pop_value();
			VAL r38 = pop_resource();
			VAL v39 = (VVAL(VTUP(r38)->cells[1]));
			lpush(&lbl_var, v36);
			VAL v40 = (mw_mirth_c99_ZPlusC99_indent(v39));
			STR* v41;
			STRLIT(v41, "VAL ", 4);
			VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), v40));
			uint64_t v43 = VU64(lpop(&lbl_var));
			lpush(&lbl_var, MKU64(v43));
			VAL v44 = (mw_mirth_c99_ZPlusC99_varZ_put(v43, v42));
			STR* v45;
			STRLIT(v45, " = VTUP(", 8);
			VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v44));
			VAL v47 = (lpop(&lbl_ZPlustup));
			push_resource(v46);
			mw_mirth_c99_ZPlusC99Local_rdup(v47);
			VAL r48 = pop_resource();
			VAL r49 = pop_resource();
			lpush(&lbl_ZPlustup, r48);
			VAL v50 = mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL(r49);
			VAL r51 = pop_resource();
			VAL v52 = (mw_mirth_c99_ZPlusC99_put(v50, r51));
			STR* v53;
			STRLIT(v53, ")->cells[", 9);
			VAL v54 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v53), v52));
			int64_t v55 = VI64(lpop(&lbl_i));
			STR* v56 = i64_show(v55);
			lpush(&lbl_i, MKI64(v55));
			VAL v57 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v56), v54));
			STR* v58;
			STRLIT(v58, "]; incref(", 10);
			VAL v59 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v58), v57));
			uint64_t v60 = VU64(lpop(&lbl_var));
			VAL v61 = (mw_mirth_c99_ZPlusC99_varZ_put(v60, v59));
			STR* v62;
			STRLIT(v62, ");", 2);
			VAL v63 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v62), v61));
			VAL v64 = (mw_mirth_c99_ZPlusC99_line(v63));
			VTUP(r38)->cells[1] = v64;
			int64_t v65 = VI64(lpop(&lbl_i));
			int64_t v66 = 1LL;
			int64_t v67 = i64_add(v65, v66);
			push_resource(r38);
			lpush(&lbl_i, MKI64(v67));
			mw_std_list_List_1_uncons(v37);
			VAL v68 = pop_value();
			VAL v69 = pop_value();
			push_value(v68);
			push_value(v69);
		}
		VAL v70 = pop_value();
		decref(v70);
		VAL v71 = pop_value();
		decref(v71);
		int64_t v72 = VI64(lpop(&lbl_i));
		VAL v73 = (lpop(&lbl_ZPlustup));
		VAL r74 = pop_resource();
		VAL v75 = (mw_mirth_c99_ZPlusC99Local_dropZ_localZBang(r74, v73));
		push_resource(v75);
	}
	VAL r76 = pop_resource();
	return r76;
}
static VAL mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang (VAL x1, VAL x2) {
	int64_t v0 = 0LL /* Nil */;
	push_value(x1);
	push_resource(x2);
	VAL v1 = mw_std_list_List_1_reverse(MKI64(v0));
	VAL v2 = pop_value();
	push_resource(v1);
	mw_std_list_List_1_uncons(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		int64_t v6 = mw_std_maybe_Maybe_1_someZAsk(v5);
		if (!((bool)v6)) break;
		VAL v7 = pop_value();
		VAL v8 = mw_std_maybe_Maybe_1_unwrap(v7);
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		incref(v8);
		int64_t v11 = mw_mirth_var_Var_isZ_physicalZAsk(VU64(v8));
		if (((bool)v11)) {
			VAL v12 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v12);
		} else {
			decref(v8);
			int64_t v13 = 0LL /* None */;
			push_i64(v13);
		}
		VAL v14 = pop_value();
		switch (get_data_tag(v14)) {
			case 1LL: { // Some
				push_resource(r10);
				VAL v15 = mtp_std_maybe_Maybe_1_Some(v14);
				VAL r16 = pop_resource();
				VAL v17 = mtw_std_list_List_1_Cons(v15, r16);
				push_resource(v17);
			} break;
			case 0LL: { // None
				push_resource(r10);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(r10);
			}
		}
		mw_std_list_List_1_uncons(v9);
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL r22 = pop_resource();
	VAL v23 = mw_std_list_List_1_reverse(r22);
	VAL v24 = mw_std_list_List_1_reverse(v23);
	mw_std_list_List_1_uncons(v24);
	VAL v25 = pop_value();
	VAL v26 = pop_value();
	push_value(v25);
	push_value(v26);
	while(1) {
		VAL v27 = pop_value();
		incref(v27);
		push_value(v27);
		int64_t v28 = mw_std_maybe_Maybe_1_someZAsk(v27);
		if (!((bool)v28)) break;
		VAL v29 = pop_value();
		VAL v30 = mw_std_maybe_Maybe_1_unwrap(v29);
		VAL v31 = pop_value();
		VAL r32 = pop_resource();
		VAL v33 = (VVAL(VTUP(r32)->cells[1]));
		push_value(v30);
		VAL v34 = (mw_mirth_c99_ZPlusC99_indent(v33));
		STR* v35;
		STRLIT(v35, "decref(", 7);
		VAL v36 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), v34));
		uint64_t v37 = pop_u64();
		VAL v38 = (mw_mirth_c99_ZPlusC99_varZ_put(v37, v36));
		STR* v39;
		STRLIT(v39, ");", 2);
		VAL v40 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v39), v38));
		VAL v41 = (mw_mirth_c99_ZPlusC99_line(v40));
		VTUP(r32)->cells[1] = v41;
		push_resource(r32);
		mw_std_list_List_1_uncons(v31);
		VAL v42 = pop_value();
		VAL v43 = pop_value();
		push_value(v42);
		push_value(v43);
	}
	VAL v44 = pop_value();
	decref(v44);
	VAL v45 = pop_value();
	decref(v45);
	VAL r46 = pop_resource();
	return r46;
}
static VAL mw_mirth_c99_c99Z_blockZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	push_u64(x1);
	mw_mirth_arrow_Block_toZ_runZ_var(v1, x1);
	VAL r2 = pop_resource();
	VTUP(v0)->cells[6] = r2;
	VTUP(x2)->cells[1] = v0;
	VAL v3 = pop_value();
	switch (get_data_tag(v3)) {
		case 1LL: { // Some
			push_resource(x2);
			VAL v4 = mtp_std_maybe_Maybe_1_Some(v3);
			VAL v5 = pop_value();
			decref(v5);
			VAL r6 = pop_resource();
			VAL v7 = (mw_mirth_c99_c99Z_varZ_pushZBang(VU64(v4), r6));
			push_resource(v7);
		} break;
		case 0LL: { // None
			int64_t v8 = 14LL /* C99RT_FNPTR */;
			VAL v9 = (VVAL(VTUP(x2)->cells[1]));
			lpush(&lbl_localZ_repr, MKI64(v8));
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v9);
			VAL v10 = pop_value();
			VAL r11 = pop_resource();
			int64_t v12 = VI64(lpop(&lbl_localZ_repr));
			VAL v13 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v12, v10));
			push_resource(v13);
			VAL v14 = (mw_mirth_c99_ZPlusC99_indent(r11));
			VAL r15 = pop_resource();
			int64_t v16 = VI64(VTUP(r15)->cells[1]);
			push_resource(r15);
			push_resource(v14);
			VAL v17 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v16);
			VAL r18 = pop_resource();
			VAL v19 = (mw_mirth_c99_ZPlusC99_put(v17, r18));
			STR* v20;
			STRLIT(v20, " ", 1);
			VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
			VAL r22 = pop_resource();
			VAL v23 = VVAL(VTUP(r22)->cells[2]);
			incref(v23);
			push_resource(r22);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(v23, v21));
			STR* v25;
			STRLIT(v25, " = ", 3);
			VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
			VAL r27 = pop_resource();
			STR* v28;
			STRLIT(v28, "&", 1);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v26));
			uint64_t v30 = pop_u64();
			VAL v31 = (VVAL(VTUP(v29)->cells[6]));
			push_u64(v30);
			mw_mirth_arrow_Block_cname(v31, v30);
			VAL r32 = pop_resource();
			VTUP(v29)->cells[6] = r32;
			VAL v33 = pop_value();
			VAL v34 = (mw_mirth_c99_ZPlusC99_put(v33, v29));
			STR* v35;
			STRLIT(v35, ";", 1);
			push_resource(r27);
			VAL v36 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), v34));
			VAL v37 = (mw_mirth_c99_ZPlusC99_line(v36));
			VTUP(x2)->cells[1] = v37;
			VAL r38 = pop_resource();
			VAL v39 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, r38));
			uint64_t v40 = pop_u64();
			VAL v41 = (VVAL(VTUP(v39)->cells[1]));
			VAL v42 = (VVAL(VTUP(v41)->cells[6]));
			push_u64(v40);
			mw_mirth_arrow_Block_freeZ_vars(v42, v40);
			VAL r43 = pop_resource();
			VTUP(v41)->cells[6] = r43;
			VTUP(v39)->cells[1] = v41;
			VAL v44 = pop_value();
			VAL v45 = (mw_mirth_c99_c99Z_packZ_closureZ_varsZBang(v44, v39));
			uint64_t v46 = pop_u64();
			push_resource(v45);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(x2);
		}
	}
	VAL r47 = pop_resource();
	return r47;
}
static VAL mw_mirth_c99_c99Z_varZBang (uint64_t x1, VAL x2) {
	push_resource(x2);
	push_u64(x1);
	int64_t v0 = mw_mirth_var_Var_autoZ_runZAsk(x1);
	if (((bool)v0)) {
		VAL r1 = pop_resource();
		uint64_t v2 = pop_u64();
		VAL v3 = (mw_mirth_c99_c99Z_varZ_runZBang(v2, r1));
		push_resource(v3);
	} else {
		VAL r4 = pop_resource();
		uint64_t v5 = pop_u64();
		VAL v6 = (mw_mirth_c99_c99Z_varZ_pushZBang(v5, r4));
		push_resource(v6);
	}
	VAL r7 = pop_resource();
	return r7;
}
static VAL mw_mirth_c99_c99Z_varZ_runZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang(x2));
	VAL v1 = (VVAL(VTUP(v0)->cells[1]));
	VAL v2 = (mw_mirth_c99_ZPlusC99_indent(v1));
	STR* v3;
	STRLIT(v3, "incref(", 7);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), v2));
	uint64_t v5 = pop_u64();
	push_u64(v5);
	VAL v6 = (mw_mirth_c99_ZPlusC99_varZ_put(v5, v4));
	STR* v7;
	STRLIT(v7, ");", 2);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	VAL v9 = (mw_mirth_c99_ZPlusC99_line(v8));
	VTUP(v0)->cells[1] = v9;
	VAL v10 = (VVAL(VTUP(v0)->cells[1]));
	VAL v11 = (mw_mirth_c99_ZPlusC99_indent(v10));
	STR* v12;
	STRLIT(v12, "run_value(", 10);
	VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
	uint64_t v14 = pop_u64();
	push_u64(v14);
	VAL v15 = (mw_mirth_c99_ZPlusC99_varZ_put(v14, v13));
	STR* v16;
	STRLIT(v16, ");", 2);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = (mw_mirth_c99_ZPlusC99_line(v17));
	VTUP(v0)->cells[1] = v18;
	uint64_t v19 = pop_u64();
	return v0;
}
static VAL mw_mirth_c99_c99Z_varZ_pushZBang (uint64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	push_u64(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_indent(v0));
	STR* v2;
	STRLIT(v2, "incref(", 7);
	VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v2), v1));
	uint64_t v4 = pop_u64();
	push_u64(v4);
	VAL v5 = (mw_mirth_c99_ZPlusC99_varZ_put(v4, v3));
	STR* v6;
	STRLIT(v6, ");", 2);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_line(v7));
	VTUP(x2)->cells[1] = v8;
	int64_t v9 = 0LL /* C99RT_VAL */;
	VAL v10 = (VVAL(VTUP(x2)->cells[1]));
	lpush(&lbl_localZ_repr, MKI64(v9));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v10);
	VAL v11 = pop_value();
	VAL r12 = pop_resource();
	int64_t v13 = VI64(lpop(&lbl_localZ_repr));
	VAL v14 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v13, v11));
	push_resource(v14);
	VAL v15 = (mw_mirth_c99_ZPlusC99_indent(r12));
	VAL r16 = pop_resource();
	int64_t v17 = VI64(VTUP(r16)->cells[1]);
	push_resource(r16);
	push_resource(v15);
	VAL v18 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v17);
	VAL r19 = pop_resource();
	VAL v20 = (mw_mirth_c99_ZPlusC99_put(v18, r19));
	STR* v21;
	STRLIT(v21, " ", 1);
	VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
	VAL r23 = pop_resource();
	VAL v24 = VVAL(VTUP(r23)->cells[2]);
	incref(v24);
	push_resource(r23);
	VAL v25 = (mw_mirth_c99_ZPlusC99_put(v24, v22));
	STR* v26;
	STRLIT(v26, " = ", 3);
	VAL v27 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v26), v25));
	VAL r28 = pop_resource();
	uint64_t v29 = pop_u64();
	push_u64(v29);
	VAL v30 = (mw_mirth_c99_ZPlusC99_varZ_put(v29, v27));
	STR* v31;
	STRLIT(v31, ";", 1);
	push_resource(r28);
	VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
	VAL v33 = (mw_mirth_c99_ZPlusC99_line(v32));
	VTUP(x2)->cells[1] = v33;
	VAL r34 = pop_resource();
	VAL v35 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(x2, r34));
	uint64_t v36 = pop_u64();
	return v35;
}
static VAL mw_mirth_c99_c99Z_lambdaZBang (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x2));
	VAL v1 = (mw_mirth_c99_ZPlusC99_indent(v0));
	STR* v2;
	STRLIT(v2, "{", 1);
	VAL v3 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v2), v1));
	VAL v4 = (mw_mirth_c99_ZPlusC99_line(v3));
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	int64_t v6 = 1LL;
	int64_t v7 = i64_add(v5, v6);
	VTUP(v4)->cells[2] = MKI64(v7);
	VAL v8 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v4));
	VAL v9 = pop_value();
	incref(v9);
	VAL v10 = VVAL(VTUP(v9)->cells[4]);
	incref(v10);
	decref(v9);
	push_resource(v8);
	push_value(v9);
	VAL v11 = mw_std_list_List_1_reverse(v10);
	mw_std_list_List_1_uncons(v11);
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	push_value(v12);
	push_value(v13);
	while(1) {
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		int64_t v15 = mw_std_maybe_Maybe_1_someZAsk(v14);
		if (!((bool)v15)) break;
		VAL v16 = pop_value();
		VAL v17 = mw_std_maybe_Maybe_1_unwrap(v16);
		VAL v18 = pop_value();
		VAL r19 = pop_resource();
		VAL v20 = (mw_mirth_c99_c99Z_popZ_toZ_varZBang(VU64(v17), r19));
		push_resource(v20);
		mw_std_list_List_1_uncons(v18);
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		push_value(v21);
		push_value(v22);
	}
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	decref(v24);
	VAL v25 = pop_value();
	incref(v25);
	VAL v26 = VVAL(VTUP(v25)->cells[5]);
	incref(v26);
	decref(v25);
	VAL r27 = pop_resource();
	push_value(v25);
	VAL v28 = (mw_mirth_c99_c99Z_arrowZBang(v26, r27));
	VAL v29 = pop_value();
	VAL v30 = VVAL(VTUP(v29)->cells[4]);
	incref(v30);
	decref(v29);
	push_resource(v28);
	VAL v31 = mw_std_list_List_1_reverse(v30);
	mw_std_list_List_1_uncons(v31);
	VAL v32 = pop_value();
	VAL v33 = pop_value();
	push_value(v32);
	push_value(v33);
	while(1) {
		VAL v34 = pop_value();
		incref(v34);
		push_value(v34);
		int64_t v35 = mw_std_maybe_Maybe_1_someZAsk(v34);
		if (!((bool)v35)) break;
		VAL v36 = pop_value();
		VAL v37 = mw_std_maybe_Maybe_1_unwrap(v36);
		VAL v38 = pop_value();
		VAL r39 = pop_resource();
		VAL v40 = (VVAL(VTUP(r39)->cells[1]));
		push_value(v37);
		VAL v41 = (mw_mirth_c99_ZPlusC99_indent(v40));
		STR* v42;
		STRLIT(v42, "decref(", 7);
		VAL v43 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), v41));
		uint64_t v44 = pop_u64();
		VAL v45 = (mw_mirth_c99_ZPlusC99_varZ_put(v44, v43));
		STR* v46;
		STRLIT(v46, ");", 2);
		VAL v47 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v46), v45));
		VAL v48 = (mw_mirth_c99_ZPlusC99_line(v47));
		VTUP(r39)->cells[1] = v48;
		push_resource(r39);
		mw_std_list_List_1_uncons(v38);
		VAL v49 = pop_value();
		VAL v50 = pop_value();
		push_value(v49);
		push_value(v50);
	}
	VAL v51 = pop_value();
	decref(v51);
	VAL v52 = pop_value();
	decref(v52);
	VAL r53 = pop_resource();
	VAL v54 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(r53));
	int64_t v55 = VI64(VTUP(v54)->cells[2]);
	int64_t v56 = 1LL;
	int64_t v57 = i64_sub(v55, v56);
	int64_t v58 = mw_std_prim_Int_ZToNat(v57);
	VTUP(v54)->cells[2] = MKI64(v58);
	VAL v59 = (mw_mirth_c99_ZPlusC99_indent(v54));
	STR* v60;
	STRLIT(v60, "}", 1);
	VAL v61 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v60), v59));
	VAL v62 = (mw_mirth_c99_ZPlusC99_line(v61));
	VAL v63 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(v62));
	return v63;
}
static VAL mw_mirth_c99_c99Z_matchZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[7]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	push_value(x1);
	VAL v1 = mw_std_list_List_1_ZDivL1(v0);
	switch (get_data_tag(v1)) {
		case 1LL: { // Some
			VAL v2 = mtp_std_maybe_Maybe_1_Some(v1);
			VAL v3 = pop_value();
			decref(v3);
			VAL r4 = pop_resource();
			VAL v5 = (mw_mirth_c99_c99Z_singleZ_caseZBang(v2, r4));
			push_resource(v5);
		} break;
		case 0LL: { // None
			VAL v6 = pop_value();
			incref(v6);
			push_value(v6);
			VAL v7 = mw_mirth_match_Match_scrutineeZ_dataZAsk(v6);
			switch (get_data_tag(v7)) {
				case 1LL: { // Some
					VAL v8 = mtp_std_maybe_Maybe_1_Some(v7);
					push_value(v8);
				} break;
				case 0LL: { // None
					VAL v9 = pop_value();
					uint64_t v10 = VU64(VTUP(v9)->cells[2]);
					decref(v9);
					STR* v11;
					STRLIT(v11, "non-uniform match, not supported at present", 43);
					VAL r12 = pop_resource();
					VAL v13 = (VVAL(VTUP(r12)->cells[1]));
					VAL v14 = (VVAL(VTUP(v13)->cells[6]));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v10, MKSTR(v11), v14);
					VAL r15 = pop_resource();
					VTUP(v13)->cells[6] = r15;
					VTUP(r12)->cells[1] = v13;
					push_resource(r12);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
			VAL r16 = pop_resource();
			uint64_t v17 = pop_u64();
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_valueZDivresourceZ_dataZBang(v17, r16);
			VAL r18 = pop_resource();
			VAL r19 = pop_resource();
			lpush(&lbl_ZPlusscrutinee, r18);
			VAL v20 = (mw_mirth_c99_ZPlusC99Branch_beginZ_branchZ_splitZBang(r19));
			VAL v21 = (VVAL(VTUP(v20)->cells[1]));
			VAL v22 = (mw_mirth_c99_ZPlusC99_indent(v21));
			STR* v23;
			STRLIT(v23, "switch (", 8);
			VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
			VAL v25 = (lpop(&lbl_ZPlusscrutinee));
			push_resource(v24);
			mw_mirth_c99_ZPlusC99LocalValueZDivResource_peekZ_dataZ_tag(v25);
			VAL r26 = pop_resource();
			VAL r27 = pop_resource();
			VAL v28 = pop_value();
			lpush(&lbl_ZPlusscrutinee, r26);
			VAL v29 = (mw_mirth_c99_ZPlusC99_put(v28, r27));
			STR* v30;
			STRLIT(v30, ") {", 3);
			VAL v31 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v30), v29));
			VAL v32 = (mw_mirth_c99_ZPlusC99_line(v31));
			VTUP(v20)->cells[1] = v32;
			VAL v33 = (VVAL(VTUP(v20)->cells[1]));
			int64_t v34 = VI64(VTUP(v33)->cells[2]);
			int64_t v35 = 1LL;
			int64_t v36 = i64_add(v34, v35);
			VTUP(v33)->cells[2] = MKI64(v36);
			VTUP(v20)->cells[1] = v33;
			VAL v37 = pop_value();
			incref(v37);
			VAL v38 = VVAL(VTUP(v37)->cells[7]);
			incref(v38);
			decref(v37);
			push_resource(v20);
			push_value(v37);
			mw_std_list_List_1_uncons(v38);
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			push_value(v39);
			push_value(v40);
			while(1) {
				VAL v41 = pop_value();
				incref(v41);
				push_value(v41);
				int64_t v42 = mw_std_maybe_Maybe_1_someZAsk(v41);
				if (!((bool)v42)) break;
				VAL v43 = pop_value();
				VAL v44 = mw_std_maybe_Maybe_1_unwrap(v43);
				VAL v45 = pop_value();
				VAL v46 = (lpop(&lbl_ZPlusscrutinee));
				push_value(v44);
				mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdup(v46);
				VAL r47 = pop_resource();
				VAL r48 = pop_resource();
				VAL r49 = pop_resource();
				VAL v50 = pop_value();
				lpush(&lbl_ZPlusscrutinee, r47);
				VAL v51 = (mw_mirth_c99_c99Z_caseZBang(v50, r49, r48));
				push_resource(v51);
				mw_std_list_List_1_uncons(v45);
				VAL v52 = pop_value();
				VAL v53 = pop_value();
				push_value(v52);
				push_value(v53);
			}
			VAL v54 = pop_value();
			decref(v54);
			VAL v55 = pop_value();
			decref(v55);
			VAL v56 = pop_value();
			int64_t v57 = mw_mirth_match_Match_hasZ_defaultZ_caseZAsk(v56);
			if (((bool)v57)) {
			} else {
				VAL r58 = pop_resource();
				VAL v59 = (VVAL(VTUP(r58)->cells[1]));
				VAL v60 = (mw_mirth_c99_ZPlusC99_indent(v59));
				STR* v61;
				STRLIT(v61, "default: {", 10);
				VAL v62 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v61), v60));
				VAL v63 = (mw_mirth_c99_ZPlusC99_line(v62));
				VTUP(r58)->cells[1] = v63;
				VAL v64 = (VVAL(VTUP(r58)->cells[1]));
				int64_t v65 = VI64(VTUP(v64)->cells[2]);
				int64_t v66 = 1LL;
				int64_t v67 = i64_add(v65, v66);
				VTUP(v64)->cells[2] = MKI64(v67);
				VTUP(r58)->cells[1] = v64;
				FNPTR v68 = &mb_mirth_c99_c99Z_matchZBang_11;
				VAL v69 = (mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1(r58, MKFNPTR(v68)));
				VAL v70 = (VVAL(VTUP(v69)->cells[1]));
				int64_t v71 = VI64(VTUP(v70)->cells[2]);
				int64_t v72 = 1LL;
				int64_t v73 = i64_sub(v71, v72);
				int64_t v74 = mw_std_prim_Int_ZToNat(v73);
				VTUP(v70)->cells[2] = MKI64(v74);
				VTUP(v69)->cells[1] = v70;
				VAL v75 = (VVAL(VTUP(v69)->cells[1]));
				VAL v76 = (mw_mirth_c99_ZPlusC99_indent(v75));
				STR* v77;
				STRLIT(v77, "}", 1);
				VAL v78 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v77), v76));
				VAL v79 = (mw_mirth_c99_ZPlusC99_line(v78));
				VTUP(v69)->cells[1] = v79;
				push_resource(v69);
			}
			VAL v80 = (lpop(&lbl_ZPlusscrutinee));
			mw_mirth_c99_ZPlusC99LocalValueZDivResource_rdrop(v80);
			VAL r81 = pop_resource();
			VAL v82 = (VVAL(VTUP(r81)->cells[1]));
			int64_t v83 = VI64(VTUP(v82)->cells[2]);
			int64_t v84 = 1LL;
			int64_t v85 = i64_sub(v83, v84);
			int64_t v86 = mw_std_prim_Int_ZToNat(v85);
			VTUP(v82)->cells[2] = MKI64(v86);
			VTUP(r81)->cells[1] = v82;
			VAL v87 = (VVAL(VTUP(r81)->cells[1]));
			VAL v88 = (mw_mirth_c99_ZPlusC99_indent(v87));
			STR* v89;
			STRLIT(v89, "}", 1);
			VAL v90 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v89), v88));
			VAL v91 = (mw_mirth_c99_ZPlusC99_line(v90));
			VTUP(r81)->cells[1] = v91;
			VAL v92 = (mw_mirth_c99_ZPlusC99BranchSplit_endZ_branchZ_splitZBang(r81));
			push_resource(v92);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL r93 = pop_resource();
	return r93;
}
static VAL mw_mirth_c99_c99Z_singleZ_caseZBang (VAL x1, VAL x2) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	push_value(x1);
	int64_t v1 = mw_mirth_match_Pattern_isZ_defaultZAsk(v0);
	if (((bool)v1)) {
		VAL v2 = pop_value();
		VAL v3 = VVAL(VTUP(v2)->cells[2]);
		incref(v3);
		decref(v2);
		VAL r4 = pop_resource();
		VAL v5 = (mw_mirth_c99_c99Z_arrowZBang(v3, r4));
		push_resource(v5);
	} else {
		VAL v6 = pop_value();
		incref(v6);
		VAL v7 = VVAL(VTUP(v6)->cells[1]);
		incref(v7);
		decref(v6);
		push_value(v6);
		VAL v8 = mw_mirth_match_Pattern_singleZ_tagZAsk(v7);
		switch (get_data_tag(v8)) {
			case 1LL: { // Some
				VAL v9 = mtp_std_maybe_Maybe_1_Some(v8);
				VAL r10 = pop_resource();
				VAL v11 = (mw_mirth_c99_c99Z_reverseZ_tagZBang(VU64(v9), r10));
				VAL v12 = pop_value();
				VAL v13 = VVAL(VTUP(v12)->cells[2]);
				incref(v13);
				decref(v12);
				VAL v14 = (mw_mirth_c99_c99Z_arrowZBang(v13, v11));
				push_resource(v14);
			} break;
			case 0LL: { // None
				VAL v15 = pop_value();
				VAL v16 = VVAL(VTUP(v15)->cells[1]);
				incref(v16);
				decref(v15);
				uint64_t v17 = VU64(VTUP(v16)->cells[2]);
				decref(v16);
				STR* v18;
				STRLIT(v18, "c99 target -- don't know how to compile this pattern", 52);
				VAL r19 = pop_resource();
				VAL v20 = (VVAL(VTUP(r19)->cells[1]));
				VAL v21 = (VVAL(VTUP(v20)->cells[6]));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v17, MKSTR(v18), v21);
				VAL r22 = pop_resource();
				VTUP(v20)->cells[6] = r22;
				VTUP(r19)->cells[1] = v20;
				push_resource(r19);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
	VAL r23 = pop_resource();
	return r23;
}
static VAL mw_mirth_c99_c99Z_caseZBang (VAL x1, VAL x2, VAL x3) {
	incref(x1);
	VAL v0 = VVAL(VTUP(x1)->cells[1]);
	incref(v0);
	decref(x1);
	push_resource(x2);
	lpush(&lbl_ZPlusscrutinee, x3);
	push_value(x1);
	int64_t v1 = mw_mirth_match_Pattern_isZ_defaultZAsk(v0);
	if (((bool)v1)) {
		VAL r2 = pop_resource();
		VAL v3 = (VVAL(VTUP(r2)->cells[1]));
		VAL v4 = (mw_mirth_c99_ZPlusC99_indent(v3));
		STR* v5;
		STRLIT(v5, "default: {", 10);
		VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
		VAL v7 = (mw_mirth_c99_ZPlusC99_line(v6));
		VTUP(r2)->cells[1] = v7;
		VAL v8 = (VVAL(VTUP(r2)->cells[1]));
		int64_t v9 = VI64(VTUP(v8)->cells[2]);
		int64_t v10 = 1LL;
		int64_t v11 = i64_add(v9, v10);
		VTUP(v8)->cells[2] = MKI64(v11);
		VTUP(r2)->cells[1] = v8;
		FNPTR v12 = &mb_mirth_c99_c99Z_caseZBang_4;
		VAL v13 = (mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1(r2, MKFNPTR(v12)));
		VAL v14 = (VVAL(VTUP(v13)->cells[1]));
		int64_t v15 = VI64(VTUP(v14)->cells[2]);
		int64_t v16 = 1LL;
		int64_t v17 = i64_sub(v15, v16);
		int64_t v18 = mw_std_prim_Int_ZToNat(v17);
		VTUP(v14)->cells[2] = MKI64(v18);
		VTUP(v13)->cells[1] = v14;
		VAL v19 = (VVAL(VTUP(v13)->cells[1]));
		VAL v20 = (mw_mirth_c99_ZPlusC99_indent(v19));
		STR* v21;
		STRLIT(v21, "} break;", 8);
		VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
		VAL v23 = (mw_mirth_c99_ZPlusC99_line(v22));
		VTUP(v13)->cells[1] = v23;
		push_resource(v13);
	} else {
		VAL v24 = pop_value();
		incref(v24);
		VAL v25 = VVAL(VTUP(v24)->cells[1]);
		incref(v25);
		decref(v24);
		push_value(v24);
		VAL v26 = mw_mirth_match_Pattern_singleZ_tagZAsk(v25);
		switch (get_data_tag(v26)) {
			case 1LL: { // Some
				VAL v27 = mtp_std_maybe_Maybe_1_Some(v26);
				VAL r28 = pop_resource();
				VAL v29 = (VVAL(VTUP(r28)->cells[1]));
				push_value(v27);
				VAL v30 = (mw_mirth_c99_ZPlusC99_indent(v29));
				STR* v31;
				STRLIT(v31, "case ", 5);
				VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
				uint64_t v33 = pop_u64();
				push_resource(v32);
				push_u64(v33);
				VAL v34 = mw_mirth_data_Tag_valueZ_show(v33);
				VAL r35 = pop_resource();
				VAL v36 = (mw_mirth_c99_ZPlusC99_put(v34, r35));
				STR* v37;
				STRLIT(v37, "LL: { // ", 9);
				VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), v36));
				uint64_t v39 = pop_u64();
				push_resource(v38);
				push_u64(v39);
				uint64_t v40 = mw_mirth_data_Tag_name(v39);
				VAL v41 = mw_mirth_name_Name_ZToStr(v40);
				VAL r42 = pop_resource();
				VAL v43 = (mw_mirth_c99_ZPlusC99_put(v41, r42));
				VAL v44 = (mw_mirth_c99_ZPlusC99_line(v43));
				VTUP(r28)->cells[1] = v44;
				VAL v45 = (VVAL(VTUP(r28)->cells[1]));
				int64_t v46 = VI64(VTUP(v45)->cells[2]);
				int64_t v47 = 1LL;
				int64_t v48 = i64_add(v46, v47);
				VTUP(v45)->cells[2] = MKI64(v48);
				VTUP(r28)->cells[1] = v45;
				FNPTR v49 = &mb_mirth_c99_c99Z_caseZBang_10;
				VAL v50 = (mw_mirth_c99_ZPlusC99BranchSplit_subZ_branch_1(r28, MKFNPTR(v49)));
				VAL v51 = (VVAL(VTUP(v50)->cells[1]));
				int64_t v52 = VI64(VTUP(v51)->cells[2]);
				int64_t v53 = 1LL;
				int64_t v54 = i64_sub(v52, v53);
				int64_t v55 = mw_std_prim_Int_ZToNat(v54);
				VTUP(v51)->cells[2] = MKI64(v55);
				VTUP(v50)->cells[1] = v51;
				VAL v56 = (VVAL(VTUP(v50)->cells[1]));
				VAL v57 = (mw_mirth_c99_ZPlusC99_indent(v56));
				STR* v58;
				STRLIT(v58, "} break;", 8);
				VAL v59 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v58), v57));
				VAL v60 = (mw_mirth_c99_ZPlusC99_line(v59));
				VTUP(v50)->cells[1] = v60;
				push_resource(v50);
			} break;
			case 0LL: { // None
				VAL v61 = pop_value();
				VAL v62 = VVAL(VTUP(v61)->cells[1]);
				incref(v62);
				decref(v61);
				uint64_t v63 = VU64(VTUP(v62)->cells[2]);
				decref(v62);
				STR* v64;
				STRLIT(v64, "c99 target -- don't know how to compile this pattern", 52);
				VAL r65 = pop_resource();
				VAL v66 = (VVAL(VTUP(r65)->cells[1]));
				VAL v67 = (VVAL(VTUP(v66)->cells[6]));
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v63, MKSTR(v64), v67);
				VAL r68 = pop_resource();
				VTUP(v66)->cells[6] = r68;
				VTUP(r65)->cells[1] = v66;
				push_resource(r65);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
	}
	VAL r69 = pop_resource();
	return r69;
}
static void mw_mirth_data_Tag_wordZ_cnameZ_type (uint64_t x1, VAL x2) {
	mw_mirth_data_Tag_wordZ_cname(x2, x1);
	VAL r0 = pop_resource();
	mw_mirth_data_Tag_type(r0, x1);
}
static void mw_mirth_data_Tag_patZ_cnameZ_type (uint64_t x1, VAL x2) {
	mw_mirth_data_Tag_patZ_cname(x2, x1);
	VAL r0 = pop_resource();
	mw_mirth_data_Tag_type(r0, x1);
	VAL v1 = pop_value();
	VAL v2 = mw_mirth_type_ArrowType_invert(v1);
	push_value(v2);
}
static void mw_mirth_word_Word_cnameZ_type (uint64_t x1, VAL x2) {
	mw_mirth_word_Word_cname(x1, x2);
	VAL r0 = pop_resource();
	mw_mirth_word_Word_type(x1, r0);
}
static void mw_mirth_data_Tag_wordZ_c99Z_api (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_data_Tag_ZTildewordZ_c99Z_api(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x2);
		push_u64(x1);
		push_value(v2);
	} else {
		VAL v3 = (VVAL(VTUP(x2)->cells[6]));
		push_u64(x1);
		mw_mirth_data_Tag_wordZ_cnameZ_type(x1, v3);
		VAL r4 = pop_resource();
		VTUP(x2)->cells[6] = r4;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v6, v5, x2);
		VAL v7 = pop_value();
		incref(v7);
		mut_set(v7, MKPTR(v0));
		push_value(v7);
	}
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	decref(v9);
	push_value(v8);
}
static void mw_mirth_data_Tag_patZ_c99Z_api (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_data_Tag_ZTildepatZ_c99Z_api(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x2);
		push_u64(x1);
		push_value(v2);
	} else {
		VAL v3 = (VVAL(VTUP(x2)->cells[6]));
		push_u64(x1);
		mw_mirth_data_Tag_patZ_cnameZ_type(x1, v3);
		VAL r4 = pop_resource();
		VTUP(x2)->cells[6] = r4;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v6, v5, x2);
		VAL v7 = pop_value();
		incref(v7);
		mut_set(v7, MKPTR(v0));
		push_value(v7);
	}
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	decref(v9);
	push_value(v8);
}
static void mw_mirth_word_Word_c99Z_api (uint64_t x1, VAL x2) {
	void* v0 = mfld_mirth_word_Word_ZTildec99Z_api(x1);
	bool v1 = mut_is_set(MKPTR(v0));
	if (v1) {
		VAL v2 = mut_get(MKPTR(v0));
		push_resource(x2);
		push_u64(x1);
		push_value(v2);
	} else {
		VAL v3 = (VVAL(VTUP(x2)->cells[6]));
		push_u64(x1);
		mw_mirth_word_Word_cnameZ_type(x1, v3);
		VAL r4 = pop_resource();
		VTUP(x2)->cells[6] = r4;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		mw_mirth_c99_ZPlusC99_cnameZ_typeZ_toZ_c99Z_api(v6, v5, x2);
		VAL v7 = pop_value();
		incref(v7);
		mut_set(v7, MKPTR(v0));
		push_value(v7);
	}
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	decref(v9);
	push_value(v8);
}
static VAL mw_mirth_c99_c99Z_wordZ_sigsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_word_Word_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[4]));
		push_i64(v5);
		mw_mirth_word_Word_neededZAsk(((uint64_t)v5), v7);
		VAL r8 = pop_resource();
		VTUP(r6)->cells[4] = r8;
		bool v9 = pop_bool();
		if (v9) {
			uint64_t v10 = pop_u64();
			VAL v11 = (mw_mirth_c99_c99Z_wordZ_sigZBang(v10, r6));
			push_resource(v11);
		} else {
			uint64_t v12 = pop_u64();
			push_resource(r6);
		}
		int64_t v13 = 1LL;
		int64_t v14 = i64_add(v5, v13);
		push_i64(v14);
	}
	int64_t v15 = pop_i64();
	VAL r16 = pop_resource();
	return r16;
}
static VAL mw_mirth_c99_c99Z_wordZ_sigZBang (uint64_t x1, VAL x2) {
	mw_mirth_word_Word_c99Z_api(x1, x2);
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2 = (mw_mirth_c99_c99Z_smartZ_sigZBang(v1, r0));
	return v2;
}
static VAL mw_mirth_c99_c99Z_blockZ_sigsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_arrow_Block_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[4]));
		push_i64(v5);
		mw_mirth_arrow_Block_neededZAsk(((uint64_t)v5), v7);
		VAL r8 = pop_resource();
		VTUP(r6)->cells[4] = r8;
		bool v9 = pop_bool();
		if (v9) {
			uint64_t v10 = pop_u64();
			VAL v11 = (mw_mirth_c99_c99Z_blockZ_sigZBang(v10, r6));
			push_resource(v11);
		} else {
			uint64_t v12 = pop_u64();
			push_resource(r6);
		}
		int64_t v13 = 1LL;
		int64_t v14 = i64_add(v5, v13);
		push_i64(v14);
	}
	int64_t v15 = pop_i64();
	VAL r16 = pop_resource();
	return r16;
}
static VAL mw_mirth_c99_c99Z_blockZ_sigZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99_indent(x2));
	VAL v1 = (VVAL(VTUP(v0)->cells[6]));
	uint64_t v2 = pop_u64();
	mw_mirth_arrow_Block_cname(v1, v2);
	VAL r3 = pop_resource();
	VTUP(v0)->cells[6] = r3;
	VAL v4 = pop_value();
	VAL v5 = (mw_mirth_c99_ZPlusC99_sigZ_put(v4, v0));
	STR* v6;
	STRLIT(v6, ";", 1);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_line(v7));
	return v8;
}
static VAL mw_mirth_c99_c99Z_blockZ_enterZBang (uint64_t x1, VAL x2) {
	VAL v0 = VVAL(VTUP(x2)->cells[1]);
	incref(v0);
	int64_t v1 = VI64(VTUP(v0)->cells[2]);
	decref(v0);
	if (((bool)v1)) {
		push_u64(x1);
		VAL v2 = (mw_mirth_c99_ZPlusC99_indent(x2));
		STR* v3;
		STRLIT(v3, "WORD_ENTER(", 11);
		VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), v2));
		uint64_t v5 = pop_u64();
		VAL v6 = (VVAL(VTUP(v4)->cells[6]));
		push_u64(v5);
		mw_mirth_arrow_Block_cname(v6, v5);
		VAL r7 = pop_resource();
		VTUP(v4)->cells[6] = r7;
		VAL v8 = pop_value();
		VAL v9 = (mw_mirth_c99_ZPlusC99_put(v8, v4));
		STR* v10;
		STRLIT(v10, ", ", 2);
		VAL v11 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), v9));
		uint64_t v12 = pop_u64();
		push_resource(v11);
		push_u64(v12);
		VAL v13 = mw_mirth_arrow_Block_home(v12);
		switch (get_data_tag(v13)) {
			case 0LL: { // HomeMain
				uint64_t v14 = mtp_mirth_arrow_Home_HomeMain(v13);
				STR* v15;
				STRLIT(v15, "block", 5);
				push_str(v15);
			} break;
			case 1LL: { // HomeWord
				uint64_t v16 = mtp_mirth_arrow_Home_HomeWord(v13);
				uint64_t v17 = mw_mirth_word_Word_name(v16);
				VAL v18 = mw_mirth_name_Name_ZToStr(v17);
				STR* v19;
				STRLIT(v19, " block", 6);
				STR* v20 = str_cat(VSTR(v18), v19);
				push_str(v20);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
			}
		}
		VAL r21 = pop_resource();
		VAL v22 = pop_value();
		VAL v23 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v22, r21));
		STR* v24;
		STRLIT(v24, ", ", 2);
		VAL v25 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v24), v23));
		uint64_t v26 = pop_u64();
		push_resource(v25);
		push_u64(v26);
		uint64_t v27 = mw_mirth_arrow_Block_token(v26);
		uint64_t v28 = mw_mirth_token_Token_module(v27);
		VAL v29 = mw_mirth_module_Module_sourceZ_path(v28);
		VAL r30 = pop_resource();
		VAL v31 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v29, r30));
		STR* v32;
		STRLIT(v32, ", ", 2);
		VAL v33 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v32), v31));
		uint64_t v34 = pop_u64();
		push_resource(v33);
		push_u64(v34);
		uint64_t v35 = mw_mirth_arrow_Block_token(v34);
		int64_t v36 = mw_mirth_token_Token_row(v35);
		int64_t v37 = mw_mirth_location_Row_ZToInt(v36);
		STR* v38 = i64_show(v37);
		VAL r39 = pop_resource();
		VAL v40 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v38), r39));
		STR* v41;
		STRLIT(v41, ", ", 2);
		VAL v42 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v41), v40));
		uint64_t v43 = pop_u64();
		push_resource(v42);
		push_u64(v43);
		uint64_t v44 = mw_mirth_arrow_Block_token(v43);
		int64_t v45 = mw_mirth_token_Token_col(v44);
		int64_t v46 = mw_mirth_location_Col_ZToInt(v45);
		STR* v47 = i64_show(v46);
		VAL r48 = pop_resource();
		VAL v49 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v47), r48));
		STR* v50;
		STRLIT(v50, ");", 2);
		VAL v51 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v50), v49));
		VAL v52 = (mw_mirth_c99_ZPlusC99_line(v51));
		uint64_t v53 = pop_u64();
		push_resource(v52);
	} else {
		push_resource(x2);
	}
	VAL r54 = pop_resource();
	VAL v55 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(r54));
	return v55;
}
static VAL mw_mirth_c99_c99Z_blockZ_exitZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(x2));
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	int64_t v2 = VI64(VTUP(v1)->cells[2]);
	decref(v1);
	if (((bool)v2)) {
		VAL v3 = (mw_mirth_c99_ZPlusC99_indent(v0));
		STR* v4;
		STRLIT(v4, "WORD_EXIT(", 10);
		VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
		VAL v6 = (VVAL(VTUP(v5)->cells[6]));
		uint64_t v7 = pop_u64();
		mw_mirth_arrow_Block_cname(v6, v7);
		VAL r8 = pop_resource();
		VTUP(v5)->cells[6] = r8;
		VAL v9 = pop_value();
		VAL v10 = (mw_mirth_c99_ZPlusC99_put(v9, v5));
		STR* v11;
		STRLIT(v11, ");", 2);
		VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v11), v10));
		VAL v13 = (mw_mirth_c99_ZPlusC99_line(v12));
		push_resource(v13);
	} else {
		uint64_t v14 = pop_u64();
		push_resource(v0);
	}
	VAL r15 = pop_resource();
	return r15;
}
static VAL mw_mirth_c99_c99Z_blockZ_defsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_arrow_Block_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[4]));
		push_i64(v5);
		mw_mirth_arrow_Block_neededZAsk(((uint64_t)v5), v7);
		VAL r8 = pop_resource();
		VTUP(r6)->cells[4] = r8;
		bool v9 = pop_bool();
		if (v9) {
			uint64_t v10 = pop_u64();
			VAL v11 = (mw_mirth_c99_c99Z_blockZ_defZBang(v10, r6));
			push_resource(v11);
		} else {
			uint64_t v12 = pop_u64();
			push_resource(r6);
		}
		int64_t v13 = 1LL;
		int64_t v14 = i64_add(v5, v13);
		push_i64(v14);
	}
	int64_t v15 = pop_i64();
	VAL r16 = pop_resource();
	return r16;
}
static VAL mw_mirth_c99_c99Z_blockZ_defZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99_indent(x2));
	uint64_t v1 = pop_u64();
	VAL v2 = (VVAL(VTUP(v0)->cells[6]));
	push_u64(v1);
	mw_mirth_arrow_Block_cname(v2, v1);
	VAL r3 = pop_resource();
	VTUP(v0)->cells[6] = r3;
	VAL v4 = pop_value();
	VAL v5 = (mw_mirth_c99_ZPlusC99_sigZ_put(v4, v0));
	STR* v6;
	STRLIT(v6, " {", 2);
	VAL v7 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v6), v5));
	VAL v8 = (mw_mirth_c99_ZPlusC99_line(v7));
	VAL v9 = (mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang(v8));
	int64_t v10 = VI64(VTUP(v9)->cells[2]);
	int64_t v11 = 1LL;
	int64_t v12 = i64_add(v10, v11);
	VTUP(v9)->cells[2] = MKI64(v12);
	uint64_t v13 = pop_u64();
	push_u64(v13);
	VAL v14 = (mw_mirth_c99_c99Z_blockZ_enterZBang(v13, v9));
	uint64_t v15 = pop_u64();
	VAL v16 = (VVAL(VTUP(v14)->cells[1]));
	VAL v17 = (VVAL(VTUP(v16)->cells[6]));
	push_u64(v15);
	mw_mirth_arrow_Block_arrow(v17, v15);
	VAL r18 = pop_resource();
	VTUP(v16)->cells[6] = r18;
	VTUP(v14)->cells[1] = v16;
	VAL v19 = pop_value();
	incref(v19);
	VAL v20 = (VVAL(VTUP(v14)->cells[1]));
	VAL v21 = (VVAL(VTUP(v20)->cells[6]));
	push_value(v19);
	mw_mirth_arrow_Arrow_freeZ_vars(v21, v19);
	VAL r22 = pop_resource();
	VTUP(v20)->cells[6] = r22;
	VTUP(v14)->cells[1] = v20;
	VAL v23 = pop_value();
	VAL v24 = (mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang(v23, v14));
	VAL v25 = pop_value();
	incref(v25);
	VAL v26 = (VVAL(VTUP(v24)->cells[1]));
	VAL v27 = (VVAL(VTUP(v26)->cells[6]));
	push_value(v25);
	push_resource(v27);
	VAL v28 = mw_mirth_arrow_Arrow_type(v25);
	VAL r29 = pop_resource();
	VTUP(v26)->cells[6] = r29;
	VTUP(v24)->cells[1] = v26;
	push_resource(v24);
	VAL v30 = mw_mirth_type_ArrowType_dom(v28);
	VAL r31 = pop_resource();
	VAL v32 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v30, r31));
	VAL v33 = pop_value();
	incref(v33);
	push_value(v33);
	VAL v34 = (mw_mirth_c99_c99Z_arrowZBang(v33, v32));
	VAL v35 = (VVAL(VTUP(v34)->cells[1]));
	VAL v36 = (VVAL(VTUP(v35)->cells[6]));
	VAL v37 = pop_value();
	mw_mirth_arrow_Arrow_freeZ_vars(v36, v37);
	VAL r38 = pop_resource();
	VTUP(v35)->cells[6] = r38;
	VTUP(v34)->cells[1] = v35;
	VAL v39 = pop_value();
	VAL v40 = (mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang(v39, v34));
	uint64_t v41 = pop_u64();
	VAL v42 = (mw_mirth_c99_c99Z_blockZ_exitZBang(v41, v40));
	int64_t v43 = VI64(VTUP(v42)->cells[2]);
	int64_t v44 = 1LL;
	int64_t v45 = i64_sub(v43, v44);
	int64_t v46 = mw_std_prim_Int_ZToNat(v45);
	VTUP(v42)->cells[2] = MKI64(v46);
	VAL v47 = (mw_mirth_c99_ZPlusC99_indent(v42));
	STR* v48;
	STRLIT(v48, "}", 1);
	VAL v49 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v48), v47));
	VAL v50 = (mw_mirth_c99_ZPlusC99_line(v49));
	return v50;
}
static VAL mw_mirth_c99_exposeZ_stackZ_typeZBang (VAL x1, VAL x2) {
	switch (get_data_tag(x1)) {
		case 4LL: { // STMeta
			push_resource(x2);
			uint64_t v0 = mtp_mirth_type_StackType_STMeta(x1);
			push_u64(v0);
			VAL v1 = mw_mirth_type_MetaVar_typeZAsk(v0);
			switch (get_data_tag(v1)) {
				case 0LL: { // None
					uint64_t v2 = pop_u64();
				} break;
				case 1LL: { // Some
					VAL v3 = mtp_std_maybe_Maybe_1_Some(v1);
					VAL v4 = mw_mirth_type_Type_expand(v3);
					incref(v4);
					VAL v5 = pop_value();
					push_value(v4);
					push_value(v5);
					VAL v6 = mtw_std_maybe_Maybe_1_Some(v4);
					uint64_t v7 = pop_u64();
					void* v8 = mfld_mirth_type_MetaVar_ZTildetypeZAsk(v7);
					mut_set(v6, MKPTR(v8));
					VAL v9 = pop_value();
					VAL v10 = mw_mirth_type_Type_ZToStackType(v9);
					VAL r11 = pop_resource();
					VAL v12 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v10, r11));
					push_resource(v12);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		case 5LL: { // STCons
			push_resource(x2);
			mtp_mirth_type_StackType_STCons(x1);
			VAL r13 = pop_resource();
			VAL v14 = pop_value();
			mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v14, r13);
			int64_t v15 = pop_i64();
			VAL r16 = pop_resource();
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(r16, v15);
			VAL r17 = pop_resource();
			VAL r18 = pop_resource();
			VAL v19 = pop_value();
			VAL v20 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v19, r18));
			VAL v21 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(v20, r17));
			push_resource(v21);
		} break;
		case 7LL: { // STWith
			push_resource(x2);
			mtp_mirth_type_StackType_STWith(x1);
			VAL r22 = pop_resource();
			VAL v23 = pop_value();
			mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v23, r22);
			int64_t v24 = pop_i64();
			VAL r25 = pop_resource();
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZBang(r25, v24);
			VAL r26 = pop_resource();
			VAL r27 = pop_resource();
			VAL v28 = pop_value();
			VAL v29 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v28, r27));
			VAL v30 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v29, r26));
			push_resource(v30);
		} break;
		case 6LL: { // STConsLabel
			push_resource(x2);
			mtp_mirth_type_StackType_STConsLabel(x1);
			uint64_t v31 = pop_u64();
			VAL r32 = pop_resource();
			VAL v33 = pop_value();
			lpush(&lbl_label, MKU64(v31));
			mw_mirth_c99_ZPlusC99Branch_typeZ_toZ_c99Z_repr(v33, r32);
			uint64_t v34 = VU64(lpop(&lbl_label));
			VAL r35 = pop_resource();
			int64_t v36 = pop_i64();
			lpush(&lbl_label, MKU64(v34));
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_labelZBang(v36, v34, r35);
			VAL r37 = pop_resource();
			VAL r38 = pop_resource();
			VAL v39 = pop_value();
			VAL v40 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v39, r38));
			uint64_t v41 = VU64(lpop(&lbl_label));
			VAL v42 = (mw_mirth_c99_pushZ_localZ_labelZBang(v41, v40, r37));
			push_resource(v42);
		} break;
		case 8LL: { // STWithLabel
			push_resource(x2);
			mtp_mirth_type_StackType_STWithLabel(x1);
			uint64_t v43 = pop_u64();
			VAL r44 = pop_resource();
			VAL v45 = pop_value();
			lpush(&lbl_label, MKU64(v43));
			mw_mirth_c99_ZPlusC99Branch_resourceZ_toZ_c99Z_repr(v45, r44);
			uint64_t v46 = VU64(lpop(&lbl_label));
			VAL r47 = pop_resource();
			int64_t v48 = pop_i64();
			lpush(&lbl_label, MKU64(v46));
			mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZ_resourceZ_labelZBang(v48, v46, r47);
			VAL r49 = pop_resource();
			VAL r50 = pop_resource();
			VAL v51 = pop_value();
			VAL v52 = (mw_mirth_c99_exposeZ_stackZ_typeZBang(v51, r50));
			uint64_t v53 = VU64(lpop(&lbl_label));
			VAL v54 = (mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang(v53, v52, r49));
			push_resource(v54);
		} break;
		default: {
			decref(x1);
			push_resource(x2);
		} break;
	}
	VAL r55 = pop_resource();
	return r55;
}
static VAL mw_mirth_c99_c99Z_wordZ_enterZBang (uint64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	VTUP(x2)->cells[1] = v0;
	int64_t v2 = VI64(VTUP(v1)->cells[2]);
	decref(v1);
	if (((bool)v2)) {
		VAL v3 = (VVAL(VTUP(x2)->cells[1]));
		push_u64(x1);
		VAL v4 = (mw_mirth_c99_ZPlusC99_indent(v3));
		STR* v5;
		STRLIT(v5, "WORD_ENTER(", 11);
		VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
		uint64_t v7 = pop_u64();
		VAL v8 = (VVAL(VTUP(v6)->cells[6]));
		push_u64(v7);
		mw_mirth_word_Word_cname(v7, v8);
		VAL r9 = pop_resource();
		VTUP(v6)->cells[6] = r9;
		VAL v10 = pop_value();
		VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v6));
		STR* v12;
		STRLIT(v12, ", ", 2);
		VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
		uint64_t v14 = pop_u64();
		push_resource(v13);
		push_u64(v14);
		uint64_t v15 = mw_mirth_word_Word_name(v14);
		VAL v16 = mw_mirth_name_Name_ZToStr(v15);
		VAL r17 = pop_resource();
		VAL v18 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v16, r17));
		STR* v19;
		STRLIT(v19, ", ", 2);
		VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
		uint64_t v21 = pop_u64();
		push_resource(v20);
		push_u64(v21);
		uint64_t v22 = mw_mirth_word_Word_body(v21);
		uint64_t v23 = mw_mirth_token_Token_module(v22);
		VAL v24 = mw_mirth_module_Module_sourceZ_path(v23);
		VAL r25 = pop_resource();
		VAL v26 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v24, r25));
		STR* v27;
		STRLIT(v27, ", ", 2);
		VAL v28 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v27), v26));
		uint64_t v29 = pop_u64();
		push_resource(v28);
		push_u64(v29);
		uint64_t v30 = mw_mirth_word_Word_body(v29);
		int64_t v31 = mw_mirth_token_Token_row(v30);
		int64_t v32 = mw_mirth_location_Row_ZToInt(v31);
		STR* v33 = i64_show(v32);
		VAL r34 = pop_resource();
		VAL v35 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v33), r34));
		STR* v36;
		STRLIT(v36, ", ", 2);
		VAL v37 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v36), v35));
		uint64_t v38 = pop_u64();
		push_resource(v37);
		push_u64(v38);
		uint64_t v39 = mw_mirth_word_Word_body(v38);
		int64_t v40 = mw_mirth_token_Token_col(v39);
		int64_t v41 = mw_mirth_location_Col_ZToInt(v40);
		STR* v42 = i64_show(v41);
		VAL r43 = pop_resource();
		VAL v44 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v42), r43));
		STR* v45;
		STRLIT(v45, ");", 2);
		VAL v46 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v45), v44));
		VAL v47 = (mw_mirth_c99_ZPlusC99_line(v46));
		VTUP(x2)->cells[1] = v47;
		push_resource(x2);
	} else {
		push_u64(x1);
		push_resource(x2);
	}
	uint64_t v48 = pop_u64();
	VAL r49 = pop_resource();
	return r49;
}
static VAL mw_mirth_c99_c99Z_wordZ_exitZBang (uint64_t x1, VAL x2) {
	VAL v0 = (VVAL(VTUP(x2)->cells[1]));
	VAL v1 = VVAL(VTUP(v0)->cells[1]);
	incref(v1);
	VTUP(x2)->cells[1] = v0;
	int64_t v2 = VI64(VTUP(v1)->cells[2]);
	decref(v1);
	if (((bool)v2)) {
		VAL v3 = (VVAL(VTUP(x2)->cells[1]));
		push_u64(x1);
		VAL v4 = (mw_mirth_c99_ZPlusC99_indent(v3));
		STR* v5;
		STRLIT(v5, "WORD_EXIT(", 10);
		VAL v6 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v5), v4));
		VAL v7 = (VVAL(VTUP(v6)->cells[6]));
		uint64_t v8 = pop_u64();
		mw_mirth_word_Word_cname(v8, v7);
		VAL r9 = pop_resource();
		VTUP(v6)->cells[6] = r9;
		VAL v10 = pop_value();
		VAL v11 = (mw_mirth_c99_ZPlusC99_put(v10, v6));
		STR* v12;
		STRLIT(v12, ");", 2);
		VAL v13 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v12), v11));
		VAL v14 = (mw_mirth_c99_ZPlusC99_line(v13));
		VTUP(x2)->cells[1] = v14;
		push_resource(x2);
	} else {
		push_resource(x2);
	}
	VAL r15 = pop_resource();
	return r15;
}
static VAL mw_mirth_c99_c99Z_wordZ_defsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_word_Word_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (VVAL(VTUP(r6)->cells[4]));
		push_i64(v5);
		mw_mirth_word_Word_neededZAsk(((uint64_t)v5), v7);
		VAL r8 = pop_resource();
		VTUP(r6)->cells[4] = r8;
		bool v9 = pop_bool();
		if (v9) {
			uint64_t v10 = pop_u64();
			VAL v11 = (mw_mirth_c99_c99Z_wordZ_defZBang(v10, r6));
			push_resource(v11);
		} else {
			uint64_t v12 = pop_u64();
			push_resource(r6);
		}
		int64_t v13 = 1LL;
		int64_t v14 = i64_add(v5, v13);
		push_i64(v14);
	}
	int64_t v15 = pop_i64();
	VAL r16 = pop_resource();
	return r16;
}
static VAL mw_mirth_c99_c99Z_wordZ_defZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	mw_mirth_word_Word_c99Z_api(x1, x2);
	VAL r0 = pop_resource();
	VAL v1 = (mw_mirth_c99_ZPlusC99_indent(r0));
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	VAL v3 = (mw_mirth_c99_ZPlusC99_smartZ_sigZ_put(v2, v1));
	STR* v4;
	STRLIT(v4, " {", 2);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	VAL v6 = (mw_mirth_c99_ZPlusC99_line(v5));
	int64_t v7 = VI64(VTUP(v6)->cells[2]);
	int64_t v8 = 1LL;
	int64_t v9 = i64_add(v7, v8);
	VTUP(v6)->cells[2] = MKI64(v9);
	VAL v10 = pop_value();
	incref(v10);
	VAL v11 = (mw_mirth_c99_c99Z_apiZ_enterZBang(v10, v6));
	uint64_t v12 = pop_u64();
	push_u64(v12);
	VAL v13 = (mw_mirth_c99_c99Z_wordZ_enterZBang(v12, v11));
	uint64_t v14 = pop_u64();
	VAL v15 = (VVAL(VTUP(v13)->cells[1]));
	VAL v16 = (VVAL(VTUP(v15)->cells[6]));
	push_u64(v14);
	mw_mirth_word_Word_arrow(v14, v16);
	VAL r17 = pop_resource();
	VTUP(v15)->cells[6] = r17;
	VTUP(v13)->cells[1] = v15;
	VAL v18 = pop_value();
	VAL v19 = (mw_mirth_c99_c99Z_arrowZBang(v18, v13));
	uint64_t v20 = pop_u64();
	push_u64(v20);
	VAL v21 = (mw_mirth_c99_c99Z_wordZ_exitZBang(v20, v19));
	VAL v22 = (mw_mirth_c99_c99Z_apiZ_exitZBang(v10, v21));
	int64_t v23 = VI64(VTUP(v22)->cells[2]);
	int64_t v24 = 1LL;
	int64_t v25 = i64_sub(v23, v24);
	int64_t v26 = mw_std_prim_Int_ZToNat(v25);
	VTUP(v22)->cells[2] = MKI64(v26);
	VAL v27 = (mw_mirth_c99_ZPlusC99_indent(v22));
	STR* v28;
	STRLIT(v28, "}", 1);
	VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
	VAL v30 = (mw_mirth_c99_ZPlusC99_line(v29));
	uint64_t v31 = pop_u64();
	return v30;
}
static VAL mw_mirth_c99_fieldZ_sigZ_put (uint64_t x1, VAL x2) {
	STR* v0;
	STRLIT(v0, "static void* ", 13);
	push_u64(x1);
	VAL v1 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v0), x2));
	VAL v2 = (VVAL(VTUP(v1)->cells[6]));
	uint64_t v3 = pop_u64();
	mw_mirth_table_Field_cname(v2, v3);
	VAL r4 = pop_resource();
	VTUP(v1)->cells[6] = r4;
	VAL v5 = pop_value();
	VAL v6 = (mw_mirth_c99_ZPlusC99_put(v5, v1));
	STR* v7;
	STRLIT(v7, " (uint64_t i)", 13);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	return v8;
}
static VAL mw_mirth_c99_c99Z_fieldZ_sigsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_table_Field_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_fieldZ_sigZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_fieldZ_sigZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99_indent(x2));
	uint64_t v1 = pop_u64();
	VAL v2 = (mw_mirth_c99_fieldZ_sigZ_put(v1, v0));
	STR* v3;
	STRLIT(v3, ";", 1);
	VAL v4 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v3), v2));
	VAL v5 = (mw_mirth_c99_ZPlusC99_line(v4));
	return v5;
}
static VAL mw_mirth_c99_c99Z_fieldZ_defsZBang (VAL x1) {
	int64_t v0 = 1LL;
	push_resource(x1);
	push_i64(v0);
	while(1) {
		int64_t v1 = pop_i64();
		void* v2 = mbuf_mirth_table_Field_NUM;
		int64_t v3 = *(int64_t*)v2;
		bool v4 = (v1 <= v3);
		push_i64(v1);
		if (!v4) break;
		int64_t v5 = pop_i64();
		VAL r6 = pop_resource();
		VAL v7 = (mw_mirth_c99_c99Z_fieldZ_defZBang(((uint64_t)v5), r6));
		int64_t v8 = 1LL;
		int64_t v9 = i64_add(v5, v8);
		push_resource(v7);
		push_i64(v9);
	}
	int64_t v10 = pop_i64();
	VAL r11 = pop_resource();
	return r11;
}
static VAL mw_mirth_c99_c99Z_fieldZ_defZBang (uint64_t x1, VAL x2) {
	push_u64(x1);
	VAL v0 = (mw_mirth_c99_fieldZ_sigZ_put(x1, x2));
	STR* v1;
	STRLIT(v1, " {", 2);
	VAL v2 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), v0));
	VAL v3 = (mw_mirth_c99_ZPlusC99_line(v2));
	STR* v4;
	STRLIT(v4, "\tstatic struct VAL * p = 0;", 27);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	VAL v6 = (mw_mirth_c99_ZPlusC99_line(v5));
	STR* v7;
	STRLIT(v7, "\tsize_t m = ", 12);
	VAL v8 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v7), v6));
	push_resource(v8);
	int64_t v9 = mw_mirth_elab_TABLEz_MAXz_COUNT();
	STR* v10 = i64_show(v9);
	VAL r11 = pop_resource();
	VAL v12 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v10), r11));
	STR* v13;
	STRLIT(v13, ";", 1);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = (mw_mirth_c99_ZPlusC99_line(v14));
	STR* v16;
	STRLIT(v16, "\tif (! p) { p = calloc(m, sizeof *p); }", 39);
	VAL v17 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v16), v15));
	VAL v18 = (mw_mirth_c99_ZPlusC99_line(v17));
	STR* v19;
	STRLIT(v19, "\tEXPECT(i<m, \"table grew too big\");", 35);
	VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
	VAL v21 = (mw_mirth_c99_ZPlusC99_line(v20));
	STR* v22;
	STRLIT(v22, "\treturn (void*)(p+i);", 21);
	VAL v23 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v22), v21));
	VAL v24 = (mw_mirth_c99_ZPlusC99_line(v23));
	STR* v25;
	STRLIT(v25, "}", 1);
	VAL v26 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v25), v24));
	VAL v27 = (mw_mirth_c99_ZPlusC99_line(v26));
	VAL v28 = (mw_mirth_c99_ZPlusC99_line(v27));
	uint64_t v29 = pop_u64();
	return v28;
}
static VAL mw_mirth_c99_c99Z_fieldZ_callZBang (uint64_t x1, VAL x2) {
	int64_t v0 = 6LL /* C99RT_U64 */;
	push_u64(x1);
	mw_mirth_c99_ZPlusC99Branch_popZ_toZ_localZBang(x2, v0);
	VAL r1 = pop_resource();
	int64_t v2 = 13LL /* C99RT_PTR */;
	VAL r3 = pop_resource();
	VAL v4 = (VVAL(VTUP(r3)->cells[1]));
	lpush(&lbl_ZPlusindex, r1);
	lpush(&lbl_localZ_repr, MKI64(v2));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v4);
	VAL v5 = pop_value();
	VAL r6 = pop_resource();
	int64_t v7 = VI64(lpop(&lbl_localZ_repr));
	VAL v8 = (mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local(v7, v5));
	push_resource(v8);
	VAL v9 = (mw_mirth_c99_ZPlusC99_indent(r6));
	VAL r10 = pop_resource();
	int64_t v11 = VI64(VTUP(r10)->cells[1]);
	push_resource(r10);
	push_resource(v9);
	VAL v12 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v11);
	VAL r13 = pop_resource();
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(v12, r13));
	STR* v15;
	STRLIT(v15, " ", 1);
	VAL v16 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v15), v14));
	VAL r17 = pop_resource();
	VAL v18 = VVAL(VTUP(r17)->cells[2]);
	incref(v18);
	push_resource(r17);
	VAL v19 = (mw_mirth_c99_ZPlusC99_put(v18, v16));
	STR* v20;
	STRLIT(v20, " = ", 3);
	VAL v21 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v20), v19));
	VAL r22 = pop_resource();
	VAL v23 = (VVAL(VTUP(v21)->cells[6]));
	uint64_t v24 = pop_u64();
	mw_mirth_table_Field_cname(v23, v24);
	VAL r25 = pop_resource();
	VTUP(v21)->cells[6] = r25;
	VAL v26 = pop_value();
	VAL v27 = (mw_mirth_c99_ZPlusC99_put(v26, v21));
	STR* v28;
	STRLIT(v28, "(", 1);
	VAL v29 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v28), v27));
	VAL v30 = (lpop(&lbl_ZPlusindex));
	int64_t v31 = 6LL /* C99RT_U64 */;
	push_resource(v29);
	VAL v32 = mw_mirth_c99_ZPlusC99Local_consumeZ_as(v31, v30);
	VAL r33 = pop_resource();
	VAL v34 = (mw_mirth_c99_ZPlusC99_put(v32, r33));
	STR* v35;
	STRLIT(v35, ")", 1);
	VAL v36 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v35), v34));
	STR* v37;
	STRLIT(v37, ";", 1);
	push_resource(r22);
	VAL v38 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), v36));
	VAL v39 = (mw_mirth_c99_ZPlusC99_line(v38));
	VTUP(r3)->cells[1] = v39;
	VAL r40 = pop_resource();
	VAL v41 = (mw_mirth_c99_ZPlusC99Local_pushZ_localZBang(r3, r40));
	return v41;
}
static VAL mw_mirth_c99_c99Z_mainZBang (VAL x1, VAL x2) {
	push_value(x1);
	VAL v0 = (mw_mirth_c99_ZPlusC99_indent(x2));
	STR* v1;
	STRLIT(v1, "int main (int argc, char** argv) {", 34);
	VAL v2 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v1), v0));
	VAL v3 = (mw_mirth_c99_ZPlusC99_line(v2));
	VAL v4 = (mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang(v3));
	int64_t v5 = VI64(VTUP(v4)->cells[2]);
	int64_t v6 = 1LL;
	int64_t v7 = i64_add(v5, v6);
	VTUP(v4)->cells[2] = MKI64(v7);
	VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v4));
	STR* v9;
	STRLIT(v9, "global_argc = argc;", 19);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
	VAL v12 = (mw_mirth_c99_ZPlusC99_indent(v11));
	STR* v13;
	STRLIT(v13, "global_argv = argv;", 19);
	VAL v14 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v13), v12));
	VAL v15 = (mw_mirth_c99_ZPlusC99_line(v14));
	VAL v16 = VVAL(VTUP(v15)->cells[1]);
	incref(v16);
	int64_t v17 = VI64(VTUP(v16)->cells[2]);
	decref(v16);
	if (((bool)v17)) {
		VAL v18 = (mw_mirth_c99_ZPlusC99_indent(v15));
		STR* v19;
		STRLIT(v19, "WORD_ENTER(", 11);
		VAL v20 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v19), v18));
		STR* v21;
		STRLIT(v21, "(void(*)(void))0, ", 18);
		VAL v22 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v21), v20));
		STR* v23;
		STRLIT(v23, "\"<main>\", ", 10);
		VAL v24 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v23), v22));
		VAL v25 = pop_value();
		incref(v25);
		uint64_t v26 = VU64(VTUP(v25)->cells[2]);
		decref(v25);
		push_resource(v24);
		push_value(v25);
		uint64_t v27 = mw_mirth_token_Token_module(v26);
		VAL v28 = mw_mirth_module_Module_sourceZ_path(v27);
		VAL r29 = pop_resource();
		VAL v30 = (mw_mirth_c99_ZPlusC99_putZ_cstr(v28, r29));
		STR* v31;
		STRLIT(v31, ", ", 2);
		VAL v32 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v31), v30));
		VAL v33 = pop_value();
		incref(v33);
		uint64_t v34 = VU64(VTUP(v33)->cells[2]);
		decref(v33);
		push_resource(v32);
		push_value(v33);
		int64_t v35 = mw_mirth_token_Token_row(v34);
		int64_t v36 = mw_mirth_location_Row_ZToInt(v35);
		STR* v37 = i64_show(v36);
		VAL r38 = pop_resource();
		VAL v39 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v37), r38));
		STR* v40;
		STRLIT(v40, ", ", 2);
		VAL v41 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v40), v39));
		VAL v42 = pop_value();
		incref(v42);
		uint64_t v43 = VU64(VTUP(v42)->cells[2]);
		decref(v42);
		push_resource(v41);
		push_value(v42);
		int64_t v44 = mw_mirth_token_Token_col(v43);
		int64_t v45 = mw_mirth_location_Col_ZToInt(v44);
		STR* v46 = i64_show(v45);
		VAL r47 = pop_resource();
		VAL v48 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v46), r47));
		STR* v49;
		STRLIT(v49, ");", 2);
		VAL v50 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v49), v48));
		VAL v51 = (mw_mirth_c99_ZPlusC99_line(v50));
		push_resource(v51);
	} else {
		push_resource(v15);
	}
	VAL r52 = pop_resource();
	VAL v53 = (mw_mirth_c99_ZPlusC99_startZ_branchZBang(r52));
	int64_t v54 = 2LL /* C99RT_I64 */;
	VAL v55 = (VVAL(VTUP(v53)->cells[1]));
	lpush(&lbl_localZ_resourceZ_repr, MKI64(v54));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang(v55);
	VAL v56 = pop_value();
	VAL r57 = pop_resource();
	int64_t v58 = VI64(lpop(&lbl_localZ_resourceZ_repr));
	VAL v59 = (mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource(v58, v56));
	push_resource(v59);
	VAL v60 = (mw_mirth_c99_ZPlusC99_indent(r57));
	VAL r61 = pop_resource();
	int64_t v62 = VI64(VTUP(r61)->cells[1]);
	push_resource(r61);
	push_resource(v60);
	VAL v63 = mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type(v62);
	VAL r64 = pop_resource();
	VAL v65 = (mw_mirth_c99_ZPlusC99_put(v63, r64));
	STR* v66;
	STRLIT(v66, " ", 1);
	VAL v67 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v66), v65));
	VAL r68 = pop_resource();
	VAL v69 = VVAL(VTUP(r68)->cells[2]);
	incref(v69);
	push_resource(r68);
	VAL v70 = (mw_mirth_c99_ZPlusC99_put(v69, v67));
	STR* v71;
	STRLIT(v71, " = (", 4);
	VAL v72 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v71), v70));
	VAL r73 = pop_resource();
	STR* v74;
	STRLIT(v74, "0 /* The World! */", 18);
	VAL v75 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v74), v72));
	STR* v76;
	STRLIT(v76, ");", 2);
	push_resource(r73);
	VAL v77 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v76), v75));
	VAL v78 = (mw_mirth_c99_ZPlusC99_line(v77));
	VTUP(v53)->cells[1] = v78;
	VAL r79 = pop_resource();
	VAL v80 = (mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang(v53, r79));
	VAL v81 = pop_value();
	VAL v82 = (mw_mirth_c99_c99Z_arrowZBang(v81, v80));
	VAL v83 = (mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang(v82));
	VAL v84 = VVAL(VTUP(v83)->cells[1]);
	incref(v84);
	int64_t v85 = VI64(VTUP(v84)->cells[2]);
	decref(v84);
	if (((bool)v85)) {
		VAL v86 = (mw_mirth_c99_ZPlusC99_indent(v83));
		STR* v87;
		STRLIT(v87, "WORD_EXIT((void(*)(void))0);", 28);
		VAL v88 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v87), v86));
		VAL v89 = (mw_mirth_c99_ZPlusC99_line(v88));
		push_resource(v89);
	} else {
		push_resource(v83);
	}
	VAL r90 = pop_resource();
	VAL v91 = (mw_mirth_c99_ZPlusC99_indent(r90));
	STR* v92;
	STRLIT(v92, "return 0;", 9);
	VAL v93 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v92), v91));
	VAL v94 = (mw_mirth_c99_ZPlusC99_line(v93));
	int64_t v95 = VI64(VTUP(v94)->cells[2]);
	int64_t v96 = 1LL;
	int64_t v97 = i64_sub(v95, v96);
	int64_t v98 = mw_std_prim_Int_ZToNat(v97);
	VTUP(v94)->cells[2] = MKI64(v98);
	VAL v99 = (mw_mirth_c99_ZPlusC99_indent(v94));
	STR* v100;
	STRLIT(v100, "}", 1);
	VAL v101 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v100), v99));
	VAL v102 = (mw_mirth_c99_ZPlusC99_line(v101));
	return v102;
}
static VAL mw_mirth_main_Arguments_default (void) {
	int64_t v0 = 0LL /* False */;
	STR* v1;
	STRLIT(v1, "mirth.mth", 9);
	int64_t v2 = 0LL /* None */;
	STR* v3;
	STRLIT(v3, "main", 4);
	lpush(&lbl_emitZ_debugZ_info, MKI64(v0));
	lpush(&lbl_inputZ_file, MKSTR(v1));
	lpush(&lbl_outputZ_file, MKI64(v2));
	VAL v4 = mtw_std_maybe_Maybe_1_Some(MKSTR(v3));
	int64_t v5 = 0LL /* Nil */;
	int64_t v6 = 0LL /* Nil */;
	int64_t v7 = VI64(lpop(&lbl_emitZ_debugZ_info));
	VAL v8 = lpop(&lbl_outputZ_file);
	VAL v9 = lpop(&lbl_inputZ_file);
	VAL v10 = mtw_mirth_main_Arguments_Arguments(v9, v8, v4, MKI64(v5), MKI64(v6), v7);
	return v10;
}
static void mw_mirth_main_compileZBang (VAL x1, VAL x2, VAL x3) {
	push_resource(x2);
	push_resource(x3);
	mtp_mirth_main_Arguments_Arguments(x1);
	VAL v0 = lpop(&lbl_packageZ_searchZ_paths);
	VAL r1 = pop_resource();
	VAL v2 = VVAL(VTUP(r1)->cells[7]);
	incref(v2);
	decref(v2);
	VAL v3 = VTUP(r1)->cells[7];
	decref(v3);
	VTUP(r1)->cells[7] = v0;
	STR* v4;
	STRLIT(v4, "", 0);
	STR* v5;
	STRLIT(v5, "Compiling ", 10);
	VAL v6 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v5), MKSTR(v4)));
	VAL v7 = lpop(&lbl_inputZ_file);
	incref(v7);
	lpush(&lbl_inputZ_file, v7);
	VAL v8 = (mw_std_path_Path_pathZThen(v7, v6));
	STR* v9;
	STRLIT(v9, "\n", 1);
	STR* v10 = str_cat(VSTR(v8), v9);
	VAL r11 = pop_resource();
	VAL v12 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v10), r11));
	VAL v13 = lpop(&lbl_packages);
	push_resource(v12);
	push_resource(r1);
	mw_std_list_List_1_uncons(v13);
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	push_value(v14);
	push_value(v15);
	while(1) {
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		int64_t v17 = mw_std_maybe_Maybe_1_someZAsk(v16);
		if (!((bool)v17)) break;
		VAL v18 = pop_value();
		VAL v19 = mw_std_maybe_Maybe_1_unwrap(v18);
		VAL v20 = pop_value();
		VAL v21;
		VAL v22;
		value_uncons(v19, &v21, &v22);
		VAL v23;
		VAL v24;
		value_uncons(v21, &v23, &v24);
		decref(v23);
		push_value(v22);
		uint64_t v25 = mw_std_prim_Str_ZToName(v24);
		VAL v26 = pop_value();
		VAL r27 = pop_resource();
		mw_mirth_package_Package_newZ_orZ_pathZBang(r27, v26, v25);
		uint64_t v28 = pop_u64();
		mw_std_list_List_1_uncons(v20);
		VAL v29 = pop_value();
		VAL v30 = pop_value();
		push_value(v29);
		push_value(v30);
	}
	VAL v31 = pop_value();
	decref(v31);
	VAL v32 = pop_value();
	decref(v32);
	VAL v33 = lpop(&lbl_inputZ_file);
	VAL r34 = pop_resource();
	VAL r35 = pop_resource();
	mw_mirth_lexer_runZ_lexerZBang(v33, r35, r34);
	VAL r36 = pop_resource();
	STR* v37;
	STRLIT(v37, "", 0);
	STR* v38;
	STRLIT(v38, "Building.", 9);
	VAL v39 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v38), MKSTR(v37)));
	STR* v40;
	STRLIT(v40, "\n", 1);
	STR* v41 = str_cat(VSTR(v39), v40);
	VAL r42 = pop_resource();
	VAL v43 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v41), r42));
	uint64_t v44 = pop_u64();
	mw_mirth_elab_elabZ_moduleZBang(v44, v43, r36);
	VAL r45 = pop_resource();
	VAL v46 = (mw_mirth_elab_typecheckZ_everythingZBang(r45));
	VAL v47 = lpop(&lbl_entryZ_point);
	switch (get_data_tag(v47)) {
		case 1LL: { // Some
			push_resource(v46);
			VAL v48 = mtp_std_maybe_Maybe_1_Some(v47);
			uint64_t v49 = pop_u64();
			push_u64(v49);
			VAL v50 = mtw_mirth_name_Namespace_NAMESPACEz_MODULE(v49);
			push_value(v50);
			uint64_t v51 = mw_std_prim_Str_ZToName(v48);
			VAL v52 = pop_value();
			VAL v53 = mw_mirth_name_QNAME0(v52, v51);
			VAL r54 = pop_resource();
			mw_mirth_elab_elabZ_entryZ_point(v53, r54);
			VAL v55 = pop_value();
			VAL v56 = mtw_std_maybe_Maybe_1_Some(v55);
			push_value(v56);
		} break;
		case 0LL: { // None
			int64_t v57 = 0LL /* None */;
			push_resource(v46);
			push_i64(v57);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
			push_resource(v46);
		}
	}
	VAL v58 = pop_value();
	VAL v59 = pop_value();
	decref(v59);
	VAL r60 = pop_resource();
	VAL r61 = pop_resource();
	push_value(v58);
	mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang(r61, r60);
	VAL r62 = pop_resource();
	int64_t v63 = VI64(VTUP(r62)->cells[1]);
	int64_t v64 = 0LL;
	bool v65 = (v63 > v64);
	if (v65) {
		int64_t v66 = VI64(VTUP(r62)->cells[1]);
		STR* v67;
		STRLIT(v67, "", 0);
		int64_t v68 = 31LL /* FGRed */;
		push_i64(v66);
		VAL v69 = (mw_std_terminal_Sgr_emitZThen(MKI64(v68), MKSTR(v67)));
		int64_t v70 = pop_i64();
		STR* v71 = i64_show(v70);
		VAL v72 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v71), v69));
		STR* v73;
		STRLIT(v73, " errors.", 8);
		VAL v74 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v73), v72));
		int64_t v75 = 0LL /* Reset */;
		VAL v76 = (mw_std_terminal_Sgr_emitZThen(MKI64(v75), v74));
		STR* v77;
		STRLIT(v77, "\n", 1);
		STR* v78 = str_cat(VSTR(v76), v77);
		VAL r79 = pop_resource();
		VAL v80 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v78), r79));
		int64_t v81 = 1LL;
		push_resource(v80);
		push_resource(r62);
		push_i64(v81);
		mext_std_posix_externalZ_posixZ_exit();
	} else {
		STR* v82;
		STRLIT(v82, "", 0);
		int64_t v83 = 32LL /* FGGreen */;
		VAL v84 = (mw_std_terminal_Sgr_emitZThen(MKI64(v83), MKSTR(v82)));
		STR* v85;
		STRLIT(v85, "No errors.", 10);
		VAL v86 = (mw_std_str_ZPlusStr_pushZ_strZBang(MKSTR(v85), v84));
		int64_t v87 = 0LL /* Reset */;
		VAL v88 = (mw_std_terminal_Sgr_emitZThen(MKI64(v87), v86));
		STR* v89;
		STRLIT(v89, "\n", 1);
		STR* v90 = str_cat(VSTR(v88), v89);
		VAL r91 = pop_resource();
		VAL v92 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v90), r91));
		push_resource(v92);
		push_resource(r62);
	}
	VAL v93 = pop_value();
	switch (get_data_tag(v93)) {
		case 1LL: { // Some
			VAL v94 = mtp_std_maybe_Maybe_1_Some(v93);
			STR* v95;
			STRLIT(v95, "Specializer.", 12);
			VAL r96 = pop_resource();
			STR* v97;
			STRLIT(v97, "\n", 1);
			STR* v98 = str_cat(v95, v97);
			VAL r99 = pop_resource();
			push_value(v94);
			VAL v100 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v98), r99));
			VAL v101 = pop_value();
			push_resource(v100);
			mw_mirth_specializzer_runZ_specializzerZBang(r96, v101);
			STR* v102;
			STRLIT(v102, "Codegen.", 8);
			VAL r103 = pop_resource();
			STR* v104;
			STRLIT(v104, "\n", 1);
			STR* v105 = str_cat(v102, v104);
			VAL r106 = pop_resource();
			VAL v107 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v105), r106));
			VAL v108 = lpop(&lbl_outputZ_file);
			push_resource(v107);
			push_resource(r103);
			VAL v109 = mw_std_maybe_Maybe_1_unwrap(v108);
			int64_t v110 = VI64(lpop(&lbl_emitZ_debugZ_info));
			VAL v111 = mtw_mirth_c99_C99z_Options_C99z_Options(v109, v110);
			VAL r112 = pop_resource();
			VAL r113 = pop_resource();
			VAL v114 = pop_value();
			mw_mirth_c99_runZ_outputZ_c99ZBang(v114, v111, r113, r112);
		} break;
		case 0LL: { // None
			STR* v115;
			STRLIT(v115, "Skipping Codegen.", 17);
			VAL r116 = pop_resource();
			STR* v117;
			STRLIT(v117, "\n", 1);
			STR* v118 = str_cat(v115, v117);
			VAL r119 = pop_resource();
			VAL v120 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v118), r119));
			int64_t v121 = VI64(lpop(&lbl_emitZ_debugZ_info));
			VAL v122 = lpop(&lbl_outputZ_file);
			decref(v122);
			push_resource(v120);
			push_resource(r116);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static VAL mw_mirth_main_parseZ_packageZ_def (VAL x1) {
	int64_t v0 = 58LL /* BCOLON */;
	VAL v1 = mw_std_prim_Str_splitZ_byte(v0, x1);
	VAL v2 = mw_std_list_List_1_ZDivL2(v1);
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
			push_value(v3);
		} break;
		case 0LL: { // None
			STR* v4;
			STRLIT(v4, "Invalid package path definition", 31);
			push_str(v4);
			do_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v5 = pop_value();
	VAL v6;
	VAL v7;
	value_uncons(v5, &v6, &v7);
	VAL v8;
	VAL v9;
	value_uncons(v6, &v8, &v9);
	decref(v8);
	VAL v10 = MKNIL;
	VAL v11 = mkcons(v10, v9);
	VAL v12 = mkcons(v11, v7);
	return v12;
}
static void mw_mirth_main_compilerZ_parseZ_args (VAL x1, VAL x2, VAL x3, VAL x4) {
	switch (get_data_tag(x4)) {
		case 0LL: { // Short
			push_resource(x1);
			push_value(x2);
			push_value(x3);
			int64_t v0 = mtp_argZ_parser_types_ArgpOptionType_Short(x4);
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			switch (v0) {
				case 111LL: { // B'o'
					incref(v2);
					VAL v3 = VVAL(VTUP(v2)->cells[2]);
					incref(v3);
					decref(v2);
					decref(v3);
					VAL v4 = mw_std_maybe_Maybe_1_unwrap(v1);
					VAL v5 = mtw_std_maybe_Maybe_1_Some(v4);
					VAL v6 = tup_replace(v2, 2, v5);
					push_value(v6);
				} break;
				case 101LL: { // B'e'
					incref(v2);
					VAL v7 = VVAL(VTUP(v2)->cells[3]);
					incref(v7);
					decref(v2);
					decref(v7);
					VAL v8 = mw_std_maybe_Maybe_1_unwrap(v1);
					VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
					VAL v10 = tup_replace(v2, 3, v9);
					push_value(v10);
				} break;
				case 99LL: { // B'c'
					incref(v2);
					VAL v11 = VVAL(VTUP(v2)->cells[3]);
					incref(v11);
					decref(v2);
					decref(v11);
					decref(v1);
					int64_t v12 = 0LL /* None */;
					VAL v13 = tup_replace(v2, 3, MKI64(v12));
					push_value(v13);
				} break;
				case 112LL: { // B'p'
					VAL v14 = mw_std_maybe_Maybe_1_unwrap(v1);
					VAL v15 = mw_mirth_main_parseZ_packageZ_def(v14);
					incref(v2);
					VAL v16 = VVAL(VTUP(v2)->cells[4]);
					incref(v16);
					decref(v2);
					VAL v17 = mtw_std_list_List_1_Cons(v15, v16);
					VAL v18 = tup_replace(v2, 4, v17);
					push_value(v18);
				} break;
				case 80LL: { // B'P'
					VAL v19 = mw_std_maybe_Maybe_1_unwrap(v1);
					incref(v2);
					VAL v20 = VVAL(VTUP(v2)->cells[5]);
					incref(v20);
					decref(v2);
					VAL v21 = mtw_std_list_List_1_Cons(v19, v20);
					VAL v22 = tup_replace(v2, 5, v21);
					push_value(v22);
				} break;
				default: {
					decref(v1);
					int64_t v23 = 4LL /* UnknownArg */;
					push_value(v2);
					VAL v24 = mtw_std_maybe_Maybe_1_Some(MKI64(v23));
					VAL r25 = pop_resource();
					VAL v26 = VVAL(VTUP(r25)->cells[2]);
					incref(v26);
					VAL v27 = tup_replace(v26, 6, v24);
					VAL v28 = VTUP(r25)->cells[2];
					decref(v28);
					VTUP(r25)->cells[2] = v27;
					push_resource(r25);
				} break;
			}
		} break;
		case 2LL: { // Positional
			VAL v29 = VVAL(VTUP(x1)->cells[2]);
			incref(v29);
			int64_t v30 = VI64(VTUP(v29)->cells[4]);
			decref(v29);
			int64_t v31 = 0LL;
			bool v32 = (v30 == v31);
			if (v32) {
				incref(x2);
				VAL v33 = VVAL(VTUP(x2)->cells[1]);
				incref(v33);
				decref(x2);
				decref(v33);
				push_resource(x1);
				VAL v34 = mw_std_maybe_Maybe_1_unwrap(x3);
				VAL v35 = tup_replace(x2, 1, v34);
				push_value(v35);
			} else {
				decref(x3);
				int64_t v36 = 2LL /* TooManyArgs */;
				push_resource(x1);
				push_value(x2);
				VAL v37 = mtw_std_maybe_Maybe_1_Some(MKI64(v36));
				VAL r38 = pop_resource();
				VAL v39 = VVAL(VTUP(r38)->cells[2]);
				incref(v39);
				VAL v40 = tup_replace(v39, 6, v37);
				VAL v41 = VTUP(r38)->cells[2];
				decref(v41);
				VTUP(r38)->cells[2] = v40;
				push_resource(r38);
			}
		} break;
		case 1LL: { // LongOnly
			push_resource(x1);
			push_value(x2);
			push_value(x3);
			VAL v42 = mtp_argZ_parser_types_ArgpOptionType_LongOnly(x4);
			incref(v42);
			STR* v43;
			STRLIT(v43, "debug", 5);
			bool v44 = (str_cmp(VSTR(v42), v43) == 0);
			if (v44) {
				decref(v42);
				VAL v45 = pop_value();
				decref(v45);
				int64_t v46 = 1LL /* True */;
				VAL v47 = pop_value();
				VAL v48 = tup_replace(v47, 6, MKI64(v46));
				push_value(v48);
			} else {
				decref(v42);
				VAL v49 = pop_value();
				decref(v49);
				int64_t v50 = 4LL /* UnknownArg */;
				VAL v51 = mtw_std_maybe_Maybe_1_Some(MKI64(v50));
				VAL r52 = pop_resource();
				VAL v53 = VVAL(VTUP(r52)->cells[2]);
				incref(v53);
				VAL v54 = tup_replace(v53, 6, v51);
				VAL v55 = VTUP(r52)->cells[2];
				decref(v55);
				VTUP(r52)->cells[2] = v54;
				push_resource(r52);
			}
		} break;
		case 3LL: { // End
			VAL v56 = VVAL(VTUP(x1)->cells[2]);
			incref(v56);
			int64_t v57 = VI64(VTUP(v56)->cells[4]);
			decref(v56);
			int64_t v58 = 1LL;
			bool v59 = (v57 < v58);
			if (v59) {
				int64_t v60 = 3LL /* TooFewArgs */;
				push_value(x2);
				push_value(x3);
				push_resource(x1);
				VAL v61 = mtw_std_maybe_Maybe_1_Some(MKI64(v60));
				VAL r62 = pop_resource();
				VAL v63 = VVAL(VTUP(r62)->cells[2]);
				incref(v63);
				VAL v64 = tup_replace(v63, 6, v61);
				VAL v65 = VTUP(r62)->cells[2];
				decref(v65);
				VTUP(r62)->cells[2] = v64;
				push_resource(r62);
			} else {
				push_value(x2);
				push_value(x3);
				push_resource(x1);
			}
			VAL r66 = pop_resource();
			VAL v67 = VVAL(VTUP(r66)->cells[2]);
			incref(v67);
			VAL v68 = VVAL(VTUP(v67)->cells[1]);
			incref(v68);
			decref(v67);
			VAL v69 = VVAL(VTUP(v68)->cells[2]);
			incref(v69);
			decref(v68);
			switch (get_data_tag(v69)) {
				case 1LL: { // Some
					push_resource(r66);
					VAL v70 = mtp_std_maybe_Maybe_1_Some(v69);
					decref(v70);
				} break;
				case 0LL: { // None
					VAL v71 = VVAL(VTUP(r66)->cells[2]);
					incref(v71);
					VAL v72 = VVAL(VTUP(v71)->cells[1]);
					incref(v72);
					decref(v71);
					VAL v73 = VVAL(VTUP(v72)->cells[3]);
					incref(v73);
					decref(v72);
					switch (get_data_tag(v73)) {
						case 1LL: { // Some
							push_resource(r66);
							VAL v74 = mtp_std_maybe_Maybe_1_Some(v73);
							decref(v74);
							STR* v75;
							STRLIT(v75, "output-file", 11);
							VAL v76 = mtw_argZ_parser_types_ArgumentParsingError_MissingArg(MKSTR(v75));
							VAL v77 = mtw_std_maybe_Maybe_1_Some(v76);
							VAL r78 = pop_resource();
							VAL v79 = VVAL(VTUP(r78)->cells[2]);
							incref(v79);
							VAL v80 = tup_replace(v79, 6, v77);
							VAL v81 = VTUP(r78)->cells[2];
							decref(v81);
							VTUP(r78)->cells[2] = v80;
							push_resource(r78);
						} break;
						case 0LL: { // None
							push_resource(r66);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							do_panic();
							push_resource(r66);
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
					push_resource(r66);
				}
			}
			VAL v82 = pop_value();
			decref(v82);
		} break;
		default: {
			decref(x4);
			decref(x3);
			int64_t v83 = 4LL /* UnknownArg */;
			push_resource(x1);
			push_value(x2);
			VAL v84 = mtw_std_maybe_Maybe_1_Some(MKI64(v83));
			VAL r85 = pop_resource();
			VAL v86 = VVAL(VTUP(r85)->cells[2]);
			incref(v86);
			VAL v87 = tup_replace(v86, 6, v84);
			VAL v88 = VTUP(r85)->cells[2];
			decref(v88);
			VTUP(r85)->cells[2] = v87;
			push_resource(r85);
		} break;
	}
}
static VAL mw_mirth_main_main (VAL x1) {
	push_resource(x1);
	VAL v0 = (mw_mirth_mirth_ZPlusMirth_InitZBang());
	push_resource(v0);
	VAL v1 = mw_mirth_main_Arguments_default();
	int64_t v2 = 0LL /* Nil */;
	push_value(v1);
	VAL v3 = mw_std_list_List_1_reverse(MKI64(v2));
	STR* v4;
	STRLIT(v4, "output-file", 11);
	push_resource(v3);
	VAL v5 = mtw_std_maybe_Maybe_1_Some(MKSTR(v4));
	int64_t v6 = 111LL /* B'o' */;
	lpush(&lbl_name, v5);
	VAL v7 = mtw_argZ_parser_types_ArgpOptionType_Short(v6);
	STR* v8;
	STRLIT(v8, "OUTPUT_FILE", 11);
	lpush(&lbl_flagZ_type, v7);
	VAL v9 = mtw_std_maybe_Maybe_1_Some(MKSTR(v8));
	STR* v10;
	STRLIT(v10, "Test argument", 13);
	lpush(&lbl_argZ_doc, v9);
	VAL v11 = mtw_std_maybe_Maybe_1_Some(MKSTR(v10));
	int64_t v12 = 0LL /* None */;
	VAL v13 = lpop(&lbl_argZ_doc);
	VAL v14 = lpop(&lbl_flagZ_type);
	VAL v15 = lpop(&lbl_name);
	VAL v16 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v15, v14, v13, v11, MKI64(v12));
	VAL r17 = pop_resource();
	VAL v18 = mtw_std_list_List_1_Cons(v16, r17);
	STR* v19;
	STRLIT(v19, "compile-only", 12);
	push_resource(v18);
	VAL v20 = mtw_std_maybe_Maybe_1_Some(MKSTR(v19));
	int64_t v21 = 99LL /* B'c' */;
	lpush(&lbl_name, v20);
	VAL v22 = mtw_argZ_parser_types_ArgpOptionType_Short(v21);
	int64_t v23 = 0LL /* None */;
	STR* v24;
	STRLIT(v24, "Compile code without running codegen step", 41);
	lpush(&lbl_flagZ_type, v22);
	lpush(&lbl_argZ_doc, MKI64(v23));
	VAL v25 = mtw_std_maybe_Maybe_1_Some(MKSTR(v24));
	int64_t v26 = 0LL /* None */;
	VAL v27 = lpop(&lbl_argZ_doc);
	VAL v28 = lpop(&lbl_flagZ_type);
	VAL v29 = lpop(&lbl_name);
	VAL v30 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v29, v28, v27, v25, MKI64(v26));
	VAL r31 = pop_resource();
	VAL v32 = mtw_std_list_List_1_Cons(v30, r31);
	STR* v33;
	STRLIT(v33, "entry-point", 11);
	push_resource(v32);
	VAL v34 = mtw_std_maybe_Maybe_1_Some(MKSTR(v33));
	int64_t v35 = 101LL /* B'e' */;
	lpush(&lbl_name, v34);
	VAL v36 = mtw_argZ_parser_types_ArgpOptionType_Short(v35);
	STR* v37;
	STRLIT(v37, "ENTRY_POINT", 11);
	lpush(&lbl_flagZ_type, v36);
	VAL v38 = mtw_std_maybe_Maybe_1_Some(MKSTR(v37));
	STR* v39;
	STRLIT(v39, "Custom entry point word for compilation", 39);
	lpush(&lbl_argZ_doc, v38);
	VAL v40 = mtw_std_maybe_Maybe_1_Some(MKSTR(v39));
	int64_t v41 = 0LL /* None */;
	VAL v42 = lpop(&lbl_argZ_doc);
	VAL v43 = lpop(&lbl_flagZ_type);
	VAL v44 = lpop(&lbl_name);
	VAL v45 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v44, v43, v42, v40, MKI64(v41));
	VAL r46 = pop_resource();
	VAL v47 = mtw_std_list_List_1_Cons(v45, r46);
	STR* v48;
	STRLIT(v48, "package", 7);
	push_resource(v47);
	VAL v49 = mtw_std_maybe_Maybe_1_Some(MKSTR(v48));
	int64_t v50 = 112LL /* B'p' */;
	lpush(&lbl_name, v49);
	VAL v51 = mtw_argZ_parser_types_ArgpOptionType_Short(v50);
	STR* v52;
	STRLIT(v52, "(PACKAGE:PATH)*", 15);
	lpush(&lbl_flagZ_type, v51);
	VAL v53 = mtw_std_maybe_Maybe_1_Some(MKSTR(v52));
	STR* v54;
	STRLIT(v54, "Package locations", 17);
	lpush(&lbl_argZ_doc, v53);
	VAL v55 = mtw_std_maybe_Maybe_1_Some(MKSTR(v54));
	int64_t v56 = 0LL /* None */;
	VAL v57 = lpop(&lbl_argZ_doc);
	VAL v58 = lpop(&lbl_flagZ_type);
	VAL v59 = lpop(&lbl_name);
	VAL v60 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v59, v58, v57, v55, MKI64(v56));
	VAL r61 = pop_resource();
	VAL v62 = mtw_std_list_List_1_Cons(v60, r61);
	STR* v63;
	STRLIT(v63, "package-search-path", 19);
	push_resource(v62);
	VAL v64 = mtw_std_maybe_Maybe_1_Some(MKSTR(v63));
	int64_t v65 = 80LL /* B'P' */;
	lpush(&lbl_name, v64);
	VAL v66 = mtw_argZ_parser_types_ArgpOptionType_Short(v65);
	STR* v67;
	STRLIT(v67, "SEARCH_PATH*", 12);
	lpush(&lbl_flagZ_type, v66);
	VAL v68 = mtw_std_maybe_Maybe_1_Some(MKSTR(v67));
	STR* v69;
	STRLIT(v69, "Package search paths", 20);
	lpush(&lbl_argZ_doc, v68);
	VAL v70 = mtw_std_maybe_Maybe_1_Some(MKSTR(v69));
	int64_t v71 = 0LL /* None */;
	VAL v72 = lpop(&lbl_argZ_doc);
	VAL v73 = lpop(&lbl_flagZ_type);
	VAL v74 = lpop(&lbl_name);
	VAL v75 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v74, v73, v72, v70, MKI64(v71));
	VAL r76 = pop_resource();
	VAL v77 = mtw_std_list_List_1_Cons(v75, r76);
	STR* v78;
	STRLIT(v78, "debug", 5);
	push_resource(v77);
	VAL v79 = mtw_std_maybe_Maybe_1_Some(MKSTR(v78));
	STR* v80;
	STRLIT(v80, "debug", 5);
	lpush(&lbl_name, v79);
	VAL v81 = mtw_argZ_parser_types_ArgpOptionType_LongOnly(MKSTR(v80));
	int64_t v82 = 0LL /* None */;
	STR* v83;
	STRLIT(v83, "Emit debugging information during codegen", 41);
	lpush(&lbl_flagZ_type, v81);
	lpush(&lbl_argZ_doc, MKI64(v82));
	VAL v84 = mtw_std_maybe_Maybe_1_Some(MKSTR(v83));
	int64_t v85 = 0LL /* None */;
	VAL v86 = lpop(&lbl_argZ_doc);
	VAL v87 = lpop(&lbl_flagZ_type);
	VAL v88 = lpop(&lbl_name);
	VAL v89 = mtw_argZ_parser_types_ArgpOption_ArgpOption(v88, v87, v86, v84, MKI64(v85));
	VAL r90 = pop_resource();
	VAL v91 = mtw_std_list_List_1_Cons(v89, r90);
	VAL v92 = mw_std_list_List_1_reverse(v91);
	FNPTR v93 = &mb_mirth_main_main_1;
	lpush(&lbl_options, v92);
	VAL v94 = mtw_std_maybe_Maybe_1_Some(MKFNPTR(v93));
	STR* v95;
	STRLIT(v95, "input-file", 10);
	lpush(&lbl_parser, v94);
	VAL v96 = mtw_std_maybe_Maybe_1_Some(MKSTR(v95));
	STR* v97;
	STRLIT(v97, "Mirth Compiler", 14);
	VAL v98 = lpop(&lbl_parser);
	VAL v99 = lpop(&lbl_options);
	VAL v100 = mtw_argZ_parser_types_ArgumentParser_1_ArgumentParser(v99, v98, v96, MKSTR(v97));
	VAL v101 = pop_value();
	VAL v102 = mw_argZ_parser_parse_parseZ_args(v101, v100);
	switch (get_data_tag(v102)) {
		case 1LL: { // Right
			VAL v103 = mtp_std_either_Either_2_Right(v102);
			push_value(v103);
		} break;
		case 0LL: { // Left
			VAL v104 = mtp_std_either_Either_2_Left(v102);
			VAL r105 = pop_resource();
			STR* v106;
			STRLIT(v106, "", 0);
			VAL v107;
			VAL v108;
			value_uncons(v104, &v107, &v108);
			VAL v109;
			VAL v110;
			value_uncons(v107, &v109, &v110);
			decref(v109);
			push_value(v110);
			VAL v111 = (mw_std_str_ZPlusStr_pushZ_strZBang(v108, MKSTR(v106)));
			VAL v112 = pop_value();
			VAL v113 = (mw_argZ_parser_types_ArgumentParsingError_emitZThen(v112, v111));
			STR* v114;
			STRLIT(v114, "\n", 1);
			STR* v115 = str_cat(VSTR(v113), v114);
			VAL r116 = pop_resource();
			VAL v117 = (mw_std_prim_ZPlusWorld_traceZ_(MKSTR(v115), r116));
			int64_t v118 = 1LL;
			push_resource(v117);
			push_resource(r105);
			push_i64(v118);
			mext_std_posix_externalZ_posixZ_exit();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v119 = pop_value();
	incref(v119);
	VAL v120 = VVAL(VTUP(v119)->cells[5]);
	incref(v120);
	decref(v119);
	push_value(v119);
	int64_t v121 = mw_std_list_List_1_emptyZAsk(v120);
	if (((bool)v121)) {
		int64_t v122 = 0LL /* Nil */;
		VAL v123 = mw_std_list_List_1_reverse(MKI64(v122));
		STR* v124;
		STRLIT(v124, "lib", 3);
		VAL v125 = mtw_std_list_List_1_Cons(MKSTR(v124), v123);
		VAL r126 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_mirthZ_baseZ_libZ_path(r126);
		VAL v127 = pop_value();
		switch (get_data_tag(v127)) {
			case 1LL: { // Some
				push_resource(v125);
				VAL v128 = mtp_std_maybe_Maybe_1_Some(v127);
				VAL r129 = pop_resource();
				VAL v130 = mtw_std_list_List_1_Cons(v128, r129);
				push_resource(v130);
			} break;
			case 0LL: { // None
				push_resource(v125);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_resource(v125);
			}
		}
		VAL r131 = pop_resource();
		VAL v132 = mw_std_list_List_1_reverse(r131);
		VAL v133 = pop_value();
		VAL v134 = tup_replace(v133, 5, v132);
		push_value(v134);
	} else {
	}
	VAL r135 = pop_resource();
	VAL r136 = pop_resource();
	VAL v137 = pop_value();
	mw_mirth_main_compileZBang(v137, r136, r135);
	VAL r138 = pop_resource();
	mw_mirth_mirth_ZPlusMirth_rdrop(r138);
	VAL r139 = pop_resource();
	return r139;
}
static void mb_mirth_main_main_1 (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL r3 = pop_resource();
	mw_mirth_main_compilerZ_parseZ_args(r3, v2, v1, v0);
}
static void mb_std_prim_Str_ZToName_2 (void) {
	uint64_t v0 = pop_u64();
	VAL v1 = mw_mirth_name_Name_mangleZ_computeZBang(v0);
	push_value(v1);
}
static void mb_mirth_elab_elabZ_blockZ_atZBang_1 (void) {
	uint64_t v0 = pop_u64();
	VAL r1 = pop_resource();
	push_resource(r1);
	push_u64(v0);
	VAL v2 = mw_mirth_arrow_Block_ctx(v0);
	uint64_t v3 = pop_u64();
	push_value(v2);
	push_u64(v3);
	VAL v4 = mw_mirth_arrow_Block_dom(v3);
	uint64_t v5 = pop_u64();
	push_value(v4);
	push_u64(v5);
	VAL v6 = mw_mirth_arrow_Block_cod(v5);
	uint64_t v7 = pop_u64();
	push_value(v6);
	push_u64(v7);
	uint64_t v8 = mw_mirth_arrow_Block_token(v7);
	uint64_t v9 = pop_u64();
	push_u64(v8);
	VAL v10 = mw_mirth_arrow_Block_home(v9);
	uint64_t v11 = pop_u64();
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	VAL r15 = pop_resource();
	mw_mirth_elab_elabZ_arrowZ_homZBang(r15, v14, v13, v12, v11, v10);
}
static void mb_mirth_elab_elabZ_defZBang_0 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	push_resource(r0);
	push_u64(v1);
	VAL v2 = mw_mirth_word_Word_sigZAsk(v1);
	switch (get_data_tag(v2)) {
		case 1LL: { // Some
			VAL v3 = mtp_std_maybe_Maybe_1_Some(v2);
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = (mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang(VU64(v3)));
			VAL r6 = pop_resource();
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(r6, v5);
			VAL v7 = pop_value();
			VAL r8 = pop_resource();
			VAL v9 = VVAL(VTUP(r8)->cells[1]);
			incref(v9);
			VAL v10 = MKNIL;
			VAL v11 = mkcons(v10, v9);
			VAL v12 = mkcons(v11, v7);
			push_value(v12);
			mw_mirth_elab_ZPlusTypeElab_rdrop(r8);
		} break;
		case 0LL: { // None
			VAL r13 = pop_resource();
			uint64_t v14 = pop_u64();
			mw_mirth_word_Word_arrow(v14, r13);
			VAL v15 = pop_value();
			mw_mirth_arrow_Arrow_ctxZ_type(v15);
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			VAL v18 = MKNIL;
			VAL v19 = mkcons(v18, v17);
			VAL v20 = mkcons(v19, v16);
			push_value(v20);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
}
static void mb_mirth_elab_elabZ_defZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_defZ_paramsZBang(r0, v1);
}
static void mb_mirth_elab_elabZ_defZBang_3 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	push_u64(v1);
	push_u64(v1);
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r0, v1);
	uint64_t v2 = pop_u64();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	mw_mirth_type_ArrowType_unpack(v5);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	incref(v4);
	incref(v7);
	int64_t v9 = 0LL /* Nil */;
	push_value(v6);
	VAL v10 = mtw_mirth_arrow_Arrow_Arrow(v3, VU64(v4), VU64(v4), v8, v7, v7, MKI64(v9));
	VAL v11 = pop_value();
	uint64_t v12 = pop_u64();
	VAL r13 = pop_resource();
	push_value(v11);
	mw_mirth_word_Word_params(v12, r13);
	VAL v14 = pop_value();
	incref(v14);
	push_resource(v10);
	push_value(v14);
	int64_t v15 = mw_std_list_List_1_emptyZAsk(v14);
	if (((bool)v15)) {
		VAL v16 = pop_value();
		decref(v16);
		VAL r17 = pop_resource();
		VAL r18 = pop_resource();
		VAL v19 = pop_value();
		mw_mirth_elab_elabZ_defZ_bodyZBang(v19, r18, r17);
	} else {
		VAL v20 = pop_value();
		VAL r21 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r21);
		incref(v20);
		VAL r22 = pop_resource();
		mw_mirth_elab_abZ_ctxZAt(r22);
		VAL r23 = pop_resource();
		mw_mirth_elab_abZ_typeZAt(r23);
		VAL v24 = mw_std_list_List_1_reverse(v20);
		mw_std_list_List_1_uncons(v24);
		VAL v25 = pop_value();
		VAL v26 = pop_value();
		push_value(v25);
		push_value(v26);
		while(1) {
			VAL v27 = pop_value();
			incref(v27);
			push_value(v27);
			int64_t v28 = mw_std_maybe_Maybe_1_someZAsk(v27);
			if (!((bool)v28)) break;
			VAL v29 = pop_value();
			VAL v30 = mw_std_maybe_Maybe_1_unwrap(v29);
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			incref(v30);
			VAL v33 = pop_value();
			VAL v34 = mw_mirth_var_Ctx_new(v33, VU64(v30));
			VAL r35 = pop_resource();
			push_value(v34);
			push_value(v30);
			push_value(v32);
			mw_mirth_elab_abZ_tokenZAt(r35);
			VAL r36 = pop_resource();
			uint64_t v37 = pop_u64();
			VAL v38 = pop_value();
			VAL r39 = pop_resource();
			mw_mirth_elab_elabZ_expandZ_tensorZBang(r39, v38, v37);
			uint64_t v40 = pop_u64();
			VAL v41 = pop_value();
			VAL v42 = pop_value();
			VAL v43 = pop_value();
			push_resource(r36);
			push_value(v42);
			push_value(v41);
			VAL v44 = mw_mirth_var_Var_type(VU64(v43));
			VAL r45 = pop_resource();
			VAL v46 = pop_value();
			VAL r47 = pop_resource();
			mw_mirth_elab_elabZ_typeZ_unifyZBang(r47, v46, v44, v40);
			VAL v48 = pop_value();
			decref(v48);
			VAL v49 = pop_value();
			decref(v49);
			push_resource(r45);
			mw_std_list_List_1_uncons(v31);
			VAL v50 = pop_value();
			VAL v51 = pop_value();
			push_value(v50);
			push_value(v51);
		}
		VAL v52 = pop_value();
		decref(v52);
		VAL v53 = pop_value();
		decref(v53);
		VAL v54 = pop_value();
		VAL v55 = pop_value();
		VAL v56 = pop_value();
		VAL r57 = pop_resource();
		push_value(v55);
		push_value(v54);
		push_value(v56);
		mw_mirth_elab_abZ_homeZAt(r57);
		VAL r58 = pop_resource();
		VAL v59 = pop_value();
		uint64_t v60 = pop_u64();
		VAL v61 = pop_value();
		incref(v61);
		VAL v62 = pop_value();
		int64_t v63 = 0LL /* Nil */;
		VAL v64 = mtw_mirth_arrow_Arrow_Arrow(v59, v60, v60, v62, v61, v61, MKI64(v63));
		VAL r65 = pop_resource();
		VAL v66 = pop_value();
		mw_mirth_elab_elabZ_defZ_bodyZBang(v66, r65, v64);
		VAL r67 = pop_resource();
		lpush(&lbl_params, v20);
		lpush(&lbl_body, r67);
		mw_mirth_elab_abZ_ctxZAt(r58);
		VAL v68 = pop_value();
		VAL r69 = pop_resource();
		lpush(&lbl_outerZ_ctx, v68);
		mw_mirth_elab_abZ_typeZAt(r69);
		VAL v70 = pop_value();
		VAL r71 = pop_resource();
		lpush(&lbl_dom, v70);
		mw_mirth_elab_abZ_tokenZAt(r71);
		uint64_t v72 = pop_u64();
		VAL v73 = lpop(&lbl_body);
		VAL v74 = lpop(&lbl_params);
		VAL v75 = lpop(&lbl_dom);
		VAL v76 = lpop(&lbl_outerZ_ctx);
		VAL v77 = mtw_mirth_arrow_Lambda_Lambda(v72, v76, v75, v74, v73);
		VAL v78 = mtw_mirth_arrow_Op_OpLambda(v77);
		VAL r79 = pop_resource();
		VAL r80 = pop_resource();
		mw_mirth_elab_abZ_opZBang(v78, r80, r79);
	}
	VAL r81 = pop_resource();
	VAL r82 = pop_resource();
	VAL v83 = pop_value();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v83, r82, r81);
	VAL r84 = pop_resource();
	VAL r85 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r85, r84, v2);
	VAL v86 = pop_value();
	incref(v86);
	VAL v87 = pop_value();
	VAL r88 = pop_resource();
	push_value(v86);
	VAL v89 = (mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang(r88, VU64(v87), v86));
	push_resource(v89);
}
static void mb_mirth_elab_elabZ_defZ_typeZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1);
}
static void mb_mirth_elab_elabZ_variableZBang_1 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1);
}
static void mb_mirth_elab_elabZ_fieldZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1);
}
static void mb_mirth_elab_elabZ_fieldZBang_3 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang(r0, v1);
}
static void mb_mirth_elab_elabZ_dataZ_headerZBang_2 (void) {
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	mw_mirth_elab_elabZ_dataZ_paramsZBang(v1, r0);
}
static void mb_mirth_elab_elabZ_dataZ_tagZBang_1 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	push_resource(r0);
	push_u64(v1);
	uint64_t v2 = mw_mirth_data_Tag_data(v1);
	VAL v3 = mw_mirth_data_Data_headZAsk(v2);
	VAL v4 = mw_std_maybe_Maybe_1_unwrap(v3);
	uint64_t v5 = pop_u64();
	lpush(&lbl_token, v4);
	push_u64(v5);
	uint64_t v6 = mw_mirth_data_Tag_data(v5);
	VAL r7 = pop_resource();
	mw_mirth_data_Data_params(r7, v6);
	VAL v8 = pop_value();
	VAL v9 = mw_std_list_List_1_ZToCtx(v8);
	int64_t v10 = 1LL /* True */;
	int64_t v11 = 0LL /* False */;
	uint64_t v12 = VU64(lpop(&lbl_token));
	VAL v13 = (mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab(v9, v12, v11, v10));
	push_resource(v13);
	VAL v14 = mw_mirth_type_T0();
	VAL v15 = pop_value();
	incref(v15);
	push_value(v15);
	push_value(v14);
	uint64_t v16 = mw_mirth_data_Tag_data(VU64(v15));
	VAL r17 = pop_resource();
	VAL r18 = pop_resource();
	mw_mirth_data_Data_fullZ_type(r18, v16);
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	push_resource(r17);
	VAL v21 = mw_mirth_type_TZMulZPlus(v20, v19);
	uint64_t v22 = pop_u64();
	push_value(v21);
	VAL v23 = mw_mirth_data_Tag_sigZAsk(v22);
	switch (get_data_tag(v23)) {
		case 0LL: { // None
			VAL v24 = mw_mirth_type_T0();
			push_value(v24);
		} break;
		case 1LL: { // Some
			VAL v25 = mtp_std_maybe_Maybe_1_Some(v23);
			VAL r26 = pop_resource();
			VTUP(r26)->cells[2] = v25;
			push_resource(r26);
			VAL v27 = mw_mirth_type_T0();
			VAL r28 = pop_resource();
			VAL r29 = pop_resource();
			mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang(r29, r28, v27);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v30 = pop_value();
	VAL v31 = pop_value();
	VAL v32 = mw_mirth_type_TZ_ZTo(v30, v31);
	VAL r33 = pop_resource();
	VAL v34 = VVAL(VTUP(r33)->cells[1]);
	incref(v34);
	VAL v35 = MKNIL;
	VAL v36 = mkcons(v35, v34);
	VAL v37 = mkcons(v36, v32);
	push_value(v37);
	mw_mirth_elab_ZPlusTypeElab_rdrop(r33);
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_5 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_data_Tag_ctxZ_type(r0, v1);
	VAL v2 = pop_value();
	mw_mirth_type_ArrowType_unpack(v2);
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = mw_mirth_type_TZ_ZTo(v3, v4);
	VAL v6 = pop_value();
	VAL v7 = MKNIL;
	VAL v8 = mkcons(v7, v6);
	VAL v9 = mkcons(v8, v5);
	push_value(v9);
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_6 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	push_resource(r0);
	lpush(&lbl_tag, MKU64(v1));
	VAL v2 = mw_mirth_data_Tag_untag(v1);
	VAL v3 = mw_std_maybe_Maybe_1_unwrap(v2);
	VAL r4 = pop_resource();
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r4, VU64(v3));
	uint64_t v5 = pop_u64();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	mw_mirth_type_ArrowType_unpack(v8);
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	incref(v7);
	incref(v10);
	int64_t v12 = 0LL /* Nil */;
	push_value(v9);
	VAL v13 = mtw_mirth_arrow_Arrow_Arrow(v6, VU64(v7), VU64(v7), v11, v10, v10, MKI64(v12));
	uint64_t v14 = VU64(lpop(&lbl_tag));
	VAL r15 = pop_resource();
	lpush(&lbl_tag, MKU64(v14));
	mw_mirth_data_Tag_type(r15, v14);
	VAL v16 = pop_value();
	push_resource(v13);
	VAL v17 = mw_mirth_type_ArrowType_dom(v16);
	uint64_t v18 = VU64(lpop(&lbl_tag));
	lpush(&lbl_cod, v17);
	lpush(&lbl_tag, MKU64(v18));
	uint64_t v19 = mw_mirth_data_Tag_data(v18);
	VAL v20 = mw_mirth_data_Data_headZAsk(v19);
	VAL v21 = mw_std_maybe_Maybe_1_unwrap(v20);
	VAL r22 = pop_resource();
	lpush(&lbl_body, v21);
	mw_mirth_elab_abZ_ctxZAt(r22);
	VAL v23 = pop_value();
	VAL r24 = pop_resource();
	lpush(&lbl_ctx, v23);
	mw_mirth_elab_abZ_typeZAt(r24);
	VAL v25 = pop_value();
	VAL r26 = pop_resource();
	lpush(&lbl_dom, v25);
	mw_mirth_elab_abZ_tokenZAt(r26);
	uint64_t v27 = pop_u64();
	VAL r28 = pop_resource();
	lpush(&lbl_token, MKU64(v27));
	mw_mirth_elab_abZ_homeZAt(r28);
	VAL v29 = pop_value();
	int64_t v30 = 0LL /* Nil */;
	VAL r31 = pop_resource();
	VAL v32 = lpop(&lbl_cod);
	VAL v33 = lpop(&lbl_dom);
	VAL v34 = lpop(&lbl_ctx);
	uint64_t v35 = VU64(lpop(&lbl_body));
	uint64_t v36 = VU64(lpop(&lbl_token));
	VAL v37 = (mtw_mirth_match_ZPlusMatch_ZPlusMatch(v29, v36, v35, v34, v33, v32, MKI64(v30)));
	uint64_t v38 = VU64(lpop(&lbl_tag));
	push_resource(v37);
	lpush(&lbl_tag, MKU64(v38));
	uint64_t v39 = mw_mirth_data_Tag_data(v38);
	VAL v40 = mw_mirth_data_Data_headZAsk(v39);
	VAL v41 = mw_std_maybe_Maybe_1_unwrap(v40);
	incref(v41);
	VAL r42 = pop_resource();
	VAL v43 = VVAL(VTUP(r42)->cells[1]);
	incref(v43);
	incref(v41);
	VAL v44 = VVAL(VTUP(r42)->cells[4]);
	incref(v44);
	incref(v44);
	int64_t v45 = 0LL /* Nil */;
	VAL v46 = VVAL(VTUP(r42)->cells[5]);
	incref(v46);
	incref(v46);
	int64_t v47 = 0LL /* Nil */;
	push_resource(r42);
	VAL v48 = mtw_mirth_match_Pattern_Pattern(v43, VU64(v41), VU64(v41), v44, v44, MKI64(v45), v46, v46, MKI64(v47));
	VAL r49 = pop_resource();
	VAL v50 = (mw_mirth_match_Pattern_thaw(v48));
	uint64_t v51 = VU64(lpop(&lbl_tag));
	VAL r52 = pop_resource();
	lpush(&lbl_tag, MKU64(v51));
	mw_mirth_match_ZPlusPattern_tagZBang(r52, v50, v51);
	VAL r53 = pop_resource();
	VAL v54 = mw_mirth_match_ZPlusPattern_freezze(r53);
	incref(v54);
	VAL v55 = VVAL(VTUP(v54)->cells[5]);
	incref(v55);
	decref(v54);
	incref(v54);
	push_resource(r49);
	push_value(v41);
	push_value(v55);
	lpush(&lbl_pattern, v54);
	VAL v56 = mw_mirth_match_Pattern_dom(v54);
	VAL r57 = pop_resource();
	VAL v58 = VVAL(VTUP(r57)->cells[6]);
	incref(v58);
	push_resource(r57);
	VAL v59 = mw_mirth_type_TZ_ZTo(v56, v58);
	VAL v60 = pop_value();
	VAL v61 = pop_value();
	VAL r62 = pop_resource();
	VAL v63 = VVAL(VTUP(r62)->cells[1]);
	incref(v63);
	VAL v64 = lpop(&lbl_pattern);
	push_value(v60);
	mw_mirth_type_ArrowType_unpack(v59);
	VAL v65 = pop_value();
	VAL v66 = pop_value();
	VAL v67 = pop_value();
	incref(v61);
	incref(v66);
	int64_t v68 = 0LL /* Nil */;
	push_value(v65);
	VAL v69 = mtw_mirth_arrow_Arrow_Arrow(v63, VU64(v61), VU64(v61), v67, v66, v66, MKI64(v68));
	VAL v70 = pop_value();
	VAL r71 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v70, r71, v69);
	VAL r72 = pop_resource();
	push_resource(r62);
	VAL v73 = mtw_mirth_match_Case_CASE(v64, r72);
	VAL r74 = pop_resource();
	VAL r75 = pop_resource();
	mw_mirth_match_ZPlusMatch_addZ_case(r75, r74, v73);
	VAL r76 = pop_resource();
	VAL v77 = mw_mirth_match_ZPlusMatch_freezze(r76);
	push_resource(r31);
	VAL v78 = mtw_mirth_arrow_Op_OpMatch(v77);
	VAL r79 = pop_resource();
	VAL r80 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v78, r80, r79);
	VAL r81 = pop_resource();
	VAL r82 = pop_resource();
	VAL v83 = pop_value();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v83, r82, r81);
	VAL r84 = pop_resource();
	VAL r85 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r85, r84, v5);
	uint64_t v86 = VU64(lpop(&lbl_tag));
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_12 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	push_resource(r0);
	lpush(&lbl_dat, MKU64(v1));
	int64_t v2 = mw_mirth_data_Data_isZ_unitZAsk(v1);
	if (((bool)v2)) {
		int64_t v3 = 5LL /* Phantom */;
		VAL v4 = mtw_std_maybe_Maybe_1_Some(MKI64(v3));
		push_value(v4);
	} else {
		uint64_t v5 = VU64(lpop(&lbl_dat));
		lpush(&lbl_dat, MKU64(v5));
		int64_t v6 = mw_mirth_data_Data_isZ_enumZAsk(v5);
		if (((bool)v6)) {
			STR* v7;
			STRLIT(v7, "int", 3);
			VAL v8 = mtw_mirth_type_CType_IntLike(MKSTR(v7));
			VAL v9 = mtw_std_maybe_Maybe_1_Some(v8);
			push_value(v9);
		} else {
			uint64_t v10 = VU64(lpop(&lbl_dat));
			lpush(&lbl_dat, MKU64(v10));
			int64_t v11 = mw_mirth_data_Data_isZ_semiZ_transparentZAsk(v10);
			if (((bool)v11)) {
				uint64_t v12 = VU64(lpop(&lbl_dat));
				lpush(&lbl_dat, MKU64(v12));
				VAL v13 = mw_mirth_data_Data_tags(v12);
				VAL v14 = mw_std_list_List_1_ZDivL1(v13);
				VAL v15 = mw_std_maybe_Maybe_1_unwrap(v14);
				VAL r16 = pop_resource();
				mw_mirth_data_Tag_type(r16, VU64(v15));
				VAL v17 = pop_value();
				VAL v18 = mw_mirth_type_ArrowType_dom(v17);
				switch (get_data_tag(v18)) {
					case 5LL: { // STCons
						mtp_mirth_type_StackType_STCons(v18);
						VAL v19 = pop_value();
						VAL v20 = pop_value();
						decref(v20);
						VAL r21 = pop_resource();
						mw_mirth_type_Type_ctypeZAsk(r21, v19);
					} break;
					case 6LL: { // STConsLabel
						mtp_mirth_type_StackType_STConsLabel(v18);
						uint64_t v22 = pop_u64();
						VAL v23 = pop_value();
						VAL v24 = pop_value();
						decref(v24);
						VAL r25 = pop_resource();
						mw_mirth_type_Type_ctypeZAsk(r25, v23);
					} break;
					case 7LL: { // STWith
						mtp_mirth_type_StackType_STWith(v18);
						VAL v26 = pop_value();
						VAL v27 = pop_value();
						decref(v27);
						VAL r28 = pop_resource();
						mw_mirth_type_Resource_ctypeZAsk(r28, v26);
					} break;
					case 8LL: { // STWithLabel
						mtp_mirth_type_StackType_STWithLabel(v18);
						uint64_t v29 = pop_u64();
						VAL v30 = pop_value();
						VAL v31 = pop_value();
						decref(v31);
						VAL r32 = pop_resource();
						mw_mirth_type_Resource_ctypeZAsk(r32, v30);
					} break;
					default: {
						STR* v33;
						STRLIT(v33, "unexpected tag inputs for transparent data", 42);
						push_value(v18);
						push_str(v33);
						do_panic();
					} break;
				}
			} else {
				int64_t v34 = 0LL /* None */;
				push_i64(v34);
			}
		}
	}
	uint64_t v35 = VU64(lpop(&lbl_dat));
}
static void mb_mirth_elab_elabZ_defZ_head_3 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined(r0, v1);
}
static void mb_mirth_elab_createZ_projectorsZBang_15 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_word_Word_type(v1, r0);
	VAL v2 = pop_value();
	VAL v3 = mw_mirth_type_ArrowType_dom(v2);
	VAL v4 = mw_mirth_type_StackType_forceZ_consZAskZBang(v3);
	VAL v5 = mw_std_maybe_Maybe_1_unwrap(v4);
	VAL v6;
	VAL v7;
	value_uncons(v5, &v6, &v7);
	VAL v8;
	VAL v9;
	value_uncons(v6, &v8, &v9);
	decref(v8);
	decref(v9);
	STR* v10;
	STRLIT(v10, "f", 1);
	push_value(v7);
	uint64_t v11 = mw_std_prim_Str_ZToName(MKSTR(v10));
	VAL v12 = pop_value();
	uint64_t v13 = mw_mirth_var_Var_newZ_autoZ_runZBang(v12, v11);
	int64_t v14 = 0LL /* Nil */;
	VAL v15 = mtw_std_list_List_1_Cons(MKU64(v13), MKI64(v14));
	push_value(v15);
}
static void mb_mirth_elab_elabZ_externalZ_defZBang_2 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	push_resource(r0);
	uint64_t v2 = mw_mirth_external_External_sig(v1);
	VAL v3 = (mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang(v2));
	VAL r4 = pop_resource();
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang(r4, v3);
	VAL v5 = pop_value();
	VAL r6 = pop_resource();
	VAL v7 = VVAL(VTUP(r6)->cells[1]);
	incref(v7);
	VAL v8 = MKNIL;
	VAL v9 = mkcons(v8, v7);
	VAL v10 = mkcons(v9, v5);
	push_value(v10);
	mw_mirth_elab_ZPlusTypeElab_rdrop(r6);
}
static void mb_mirth_elab_elabZ_externalZ_defZBang_4 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	mw_mirth_elab_elabZ_defZ_externalZ_ctype(r0, v1);
}
static void mb_mirth_c99_c99Z_primZBang_6 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	uint64_t v2 = pop_u64();
	push_u64(v1);
	VAL v3 = (mw_mirth_c99_c99Z_argZ_runZBang(v2, r0));
	push_resource(v3);
}
static void mb_mirth_c99_c99Z_primZBang_9 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2 = (mw_mirth_c99_c99Z_argZ_runZBang(v1, r0));
	push_resource(v2);
}
static void mb_mirth_c99_c99Z_matchZBang_11 (void) {
	VAL r0 = pop_resource();
	VAL v1 = (lpop(&lbl_ZPlusscrutinee));
	VAL v2 = (VVAL(VTUP(r0)->cells[1]));
	lpush(&lbl_ZPlusscrutinee, v1);
	VAL v3 = (mw_mirth_c99_ZPlusC99_indent(v2));
	STR* v4;
	STRLIT(v4, "push_value(mkstr(\"unexpected fallthrough in match\\n\", 32));", 59);
	VAL v5 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v4), v3));
	VAL v6 = (mw_mirth_c99_ZPlusC99_line(v5));
	VTUP(r0)->cells[1] = v6;
	VAL v7 = (VVAL(VTUP(r0)->cells[1]));
	VAL v8 = (mw_mirth_c99_ZPlusC99_indent(v7));
	STR* v9;
	STRLIT(v9, "do_panic();", 11);
	VAL v10 = (mw_mirth_c99_ZPlusC99_put(MKSTR(v9), v8));
	VAL v11 = (mw_mirth_c99_ZPlusC99_line(v10));
	VTUP(r0)->cells[1] = v11;
	push_resource(r0);
}
static void mb_mirth_c99_c99Z_caseZBang_4 (void) {
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2 = (lpop(&lbl_ZPlusscrutinee));
	push_value(v1);
	VAL v3 = (mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang(r0, v2));
	VAL v4 = pop_value();
	VAL v5 = VVAL(VTUP(v4)->cells[2]);
	incref(v5);
	decref(v4);
	VAL v6 = (mw_mirth_c99_c99Z_arrowZBang(v5, v3));
	push_resource(v6);
}
static void mb_mirth_c99_c99Z_caseZBang_10 (void) {
	VAL r0 = pop_resource();
	uint64_t v1 = pop_u64();
	VAL v2 = pop_value();
	VAL v3 = (lpop(&lbl_ZPlusscrutinee));
	push_value(v2);
	push_u64(v1);
	VAL v4 = (mw_mirth_c99_ZPlusC99LocalValueZDivResource_pushZ_localZ_valueZDivresourceZBang(r0, v3));
	uint64_t v5 = pop_u64();
	VAL v6 = (mw_mirth_c99_c99Z_reverseZ_tagZBang(v5, v4));
	VAL v7 = pop_value();
	VAL v8 = VVAL(VTUP(v7)->cells[2]);
	incref(v8);
	decref(v7);
	VAL v9 = (mw_mirth_c99_c99Z_arrowZBang(v8, v6));
	push_resource(v9);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot81ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	push_value(v7);
	push_value(v5);
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3));
	uint64_t v8 = pop_u64();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	mw_mirth_type_ArrowType_unpack(v11);
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v10);
	incref(v13);
	int64_t v15 = 0LL /* Nil */;
	push_value(v12);
	VAL v16 = mtw_mirth_arrow_Arrow_Arrow(v9, VU64(v10), VU64(v10), v14, v13, v13, MKI64(v15));
	VAL v17 = pop_value();
	uint64_t v18 = pop_u64();
	VAL v19 = pop_value();
	VAL r20 = pop_resource();
	mw_mirth_specializzer_synthZ_specializzedZ_wordZBang(r20, v16, v19, v18);
	VAL r21 = pop_resource();
	VAL r22 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v17, r22, r21);
	VAL r23 = pop_resource();
	VAL r24 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r24, r23, v8);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotspecializzerZDotspecializzeZ_wordZBangZDot63ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	push_value(v5);
	mw_mirth_word_Word_ctxZ_type(VU64(v3), r1);
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	VAL r9 = pop_resource();
	mw_mirth_specializzer_specializzeZ_ctxZ_type(r9, v8, v7, v6);
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	VAL v12 = MKNIL;
	VAL v13 = mkcons(v12, v11);
	VAL v14 = mkcons(v13, v10);
	push_value(v14);
}
static void mb_mirth_mirth_PropLabel_prop4_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot215ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	VAL v8;
	VAL v9;
	value_uncons(v6, &v8, &v9);
	decref(v8);
	incref(v3);
	lpush(&lbl_lblz_set, v5);
	lpush(&lbl_lblz_get, v7);
	lpush(&lbl_dat, v9);
	lpush(&lbl_lblz_lens, v3);
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3));
	uint64_t v10 = pop_u64();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	mw_mirth_type_ArrowType_unpack(v13);
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	incref(v12);
	incref(v15);
	int64_t v17 = 0LL /* Nil */;
	push_value(v14);
	VAL v18 = mtw_mirth_arrow_Arrow_Arrow(v11, VU64(v12), VU64(v12), v16, v15, v15, MKI64(v17));
	uint64_t v19 = VU64(lpop(&lbl_lblz_lens));
	VAL r20 = pop_resource();
	mw_mirth_word_Word_params(v19, r20);
	VAL v21 = pop_value();
	incref(v21);
	push_value(v21);
	mw_mirth_elab_abZ_tokenZAt(v18);
	incref(v21);
	VAL r22 = pop_resource();
	mw_mirth_elab_abZ_ctxZAt(r22);
	VAL r23 = pop_resource();
	mw_mirth_elab_abZ_typeZAt(r23);
	VAL v24 = mw_std_list_List_1_reverse(v21);
	mw_std_list_List_1_uncons(v24);
	VAL v25 = pop_value();
	VAL v26 = pop_value();
	push_value(v25);
	push_value(v26);
	while(1) {
		VAL v27 = pop_value();
		incref(v27);
		push_value(v27);
		int64_t v28 = mw_std_maybe_Maybe_1_someZAsk(v27);
		if (!((bool)v28)) break;
		VAL v29 = pop_value();
		VAL v30 = mw_std_maybe_Maybe_1_unwrap(v29);
		VAL v31 = pop_value();
		VAL v32 = pop_value();
		incref(v30);
		VAL v33 = pop_value();
		VAL v34 = mw_mirth_var_Ctx_new(v33, VU64(v30));
		VAL r35 = pop_resource();
		push_value(v34);
		push_value(v30);
		push_value(v32);
		mw_mirth_elab_abZ_tokenZAt(r35);
		VAL r36 = pop_resource();
		uint64_t v37 = pop_u64();
		VAL v38 = pop_value();
		VAL r39 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang(r39, v38, v37);
		uint64_t v40 = pop_u64();
		VAL v41 = pop_value();
		VAL v42 = pop_value();
		VAL v43 = pop_value();
		push_resource(r36);
		push_value(v42);
		push_value(v41);
		VAL v44 = mw_mirth_var_Var_type(VU64(v43));
		VAL r45 = pop_resource();
		VAL v46 = pop_value();
		VAL r47 = pop_resource();
		mw_mirth_elab_elabZ_typeZ_unifyZBang(r47, v46, v44, v40);
		VAL v48 = pop_value();
		decref(v48);
		VAL v49 = pop_value();
		decref(v49);
		push_resource(r45);
		mw_std_list_List_1_uncons(v31);
		VAL v50 = pop_value();
		VAL v51 = pop_value();
		push_value(v50);
		push_value(v51);
	}
	VAL v52 = pop_value();
	decref(v52);
	VAL v53 = pop_value();
	decref(v53);
	VAL v54 = pop_value();
	VAL v55 = pop_value();
	VAL v56 = pop_value();
	VAL r57 = pop_resource();
	push_value(v55);
	push_value(v54);
	push_value(v56);
	mw_mirth_elab_abZ_homeZAt(r57);
	VAL r58 = pop_resource();
	VAL v59 = pop_value();
	uint64_t v60 = pop_u64();
	VAL v61 = pop_value();
	incref(v61);
	VAL v62 = pop_value();
	int64_t v63 = 0LL /* Nil */;
	VAL v64 = mtw_mirth_arrow_Arrow_Arrow(v59, v60, v60, v62, v61, v61, MKI64(v63));
	VAL v65 = pop_value();
	push_resource(v64);
	VAL v66 = mw_std_list_List_1_ZDivL1(v65);
	VAL v67 = mw_std_maybe_Maybe_1_unwrap(v66);
	uint64_t v68 = VU64(lpop(&lbl_dat));
	lpush(&lbl_f, v67);
	int64_t v69 = mw_mirth_data_Data_isZ_resourceZAsk(v68);
	if (((bool)v69)) {
		uint64_t v70 = VU64(lpop(&lbl_lblz_get));
		VAL r71 = pop_resource();
		VAL r72 = pop_resource();
		mw_mirth_elab_abZ_wordZBang(v70, r72, r71);
		VAL r73 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r73);
		VAL r74 = pop_resource();
		mw_mirth_elab_abZ_ctxZAt(r74);
		uint64_t v75 = mw_mirth_type_MetaVar_newZBang();
		VAL v76 = mtw_mirth_type_StackType_STMeta(v75);
		VAL v77 = pop_value();
		VAL v78 = pop_value();
		VAL r79 = pop_resource();
		push_value(v77);
		push_value(v76);
		push_value(v78);
		mw_mirth_elab_abZ_homeZAt(r79);
		VAL r80 = pop_resource();
		VAL v81 = pop_value();
		uint64_t v82 = pop_u64();
		VAL v83 = pop_value();
		incref(v83);
		VAL v84 = pop_value();
		int64_t v85 = 0LL /* Nil */;
		VAL v86 = mtw_mirth_arrow_Arrow_Arrow(v81, v82, v82, v84, v83, v83, MKI64(v85));
		uint64_t v87 = VU64(lpop(&lbl_f));
		VAL r88 = pop_resource();
		mw_mirth_elab_abZ_varZBang(v87, r88, v86);
		VAL r89 = pop_resource();
		VAL r90 = pop_resource();
		mw_mirth_arrow_Block_newZBang(r90, r89);
		uint64_t v91 = pop_u64();
		push_resource(r80);
		VAL v92 = mtw_mirth_arrow_Op_OpBlockPush(v91);
		VAL r93 = pop_resource();
		VAL r94 = pop_resource();
		mw_mirth_elab_abZ_opZBang(v92, r94, r93);
		int64_t v95 = 13LL /* PRIM_CORE_RDIP */;
		VAL r96 = pop_resource();
		VAL r97 = pop_resource();
		mw_mirth_elab_abZ_primZBang(v95, r97, r96);
		uint64_t v98 = VU64(lpop(&lbl_lblz_set));
		VAL r99 = pop_resource();
		VAL r100 = pop_resource();
		mw_mirth_elab_abZ_wordZBang(v98, r100, r99);
	} else {
		int64_t v101 = 1LL /* PRIM_CORE_DUP */;
		VAL r102 = pop_resource();
		VAL r103 = pop_resource();
		mw_mirth_elab_abZ_primZBang(v101, r103, r102);
		VAL r104 = pop_resource();
		mw_mirth_elab_abZ_tokenZAt(r104);
		VAL r105 = pop_resource();
		mw_mirth_elab_abZ_ctxZAt(r105);
		uint64_t v106 = mw_mirth_type_MetaVar_newZBang();
		VAL v107 = mtw_mirth_type_StackType_STMeta(v106);
		VAL v108 = pop_value();
		VAL v109 = pop_value();
		VAL r110 = pop_resource();
		push_value(v108);
		push_value(v107);
		push_value(v109);
		mw_mirth_elab_abZ_homeZAt(r110);
		VAL r111 = pop_resource();
		VAL v112 = pop_value();
		uint64_t v113 = pop_u64();
		VAL v114 = pop_value();
		incref(v114);
		VAL v115 = pop_value();
		int64_t v116 = 0LL /* Nil */;
		VAL v117 = mtw_mirth_arrow_Arrow_Arrow(v112, v113, v113, v115, v114, v114, MKI64(v116));
		uint64_t v118 = VU64(lpop(&lbl_lblz_get));
		VAL r119 = pop_resource();
		mw_mirth_elab_abZ_wordZBang(v118, r119, v117);
		uint64_t v120 = VU64(lpop(&lbl_f));
		VAL r121 = pop_resource();
		VAL r122 = pop_resource();
		mw_mirth_elab_abZ_varZBang(v120, r122, r121);
		VAL r123 = pop_resource();
		VAL r124 = pop_resource();
		mw_mirth_arrow_Block_newZBang(r124, r123);
		uint64_t v125 = pop_u64();
		push_resource(r111);
		VAL v126 = mtw_mirth_arrow_Op_OpBlockPush(v125);
		VAL r127 = pop_resource();
		VAL r128 = pop_resource();
		mw_mirth_elab_abZ_opZBang(v126, r128, r127);
		int64_t v129 = 4LL /* PRIM_CORE_DIP */;
		VAL r130 = pop_resource();
		VAL r131 = pop_resource();
		mw_mirth_elab_abZ_primZBang(v129, r131, r130);
		uint64_t v132 = VU64(lpop(&lbl_lblz_set));
		VAL r133 = pop_resource();
		VAL r134 = pop_resource();
		mw_mirth_elab_abZ_wordZBang(v132, r134, r133);
	}
	VAL r135 = pop_resource();
	lpush(&lbl_params, v21);
	lpush(&lbl_body, r135);
	mw_mirth_elab_abZ_ctxZAt(r58);
	VAL v136 = pop_value();
	VAL r137 = pop_resource();
	lpush(&lbl_outerZ_ctx, v136);
	mw_mirth_elab_abZ_typeZAt(r137);
	VAL v138 = pop_value();
	VAL r139 = pop_resource();
	lpush(&lbl_dom, v138);
	mw_mirth_elab_abZ_tokenZAt(r139);
	uint64_t v140 = pop_u64();
	VAL v141 = lpop(&lbl_body);
	VAL v142 = lpop(&lbl_params);
	VAL v143 = lpop(&lbl_dom);
	VAL v144 = lpop(&lbl_outerZ_ctx);
	VAL v145 = mtw_mirth_arrow_Lambda_Lambda(v140, v144, v143, v142, v141);
	VAL v146 = mtw_mirth_arrow_Op_OpLambda(v145);
	VAL r147 = pop_resource();
	VAL r148 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v146, r148, r147);
	VAL r149 = pop_resource();
	VAL r150 = pop_resource();
	VAL v151 = pop_value();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v151, r150, r149);
	VAL r152 = pop_resource();
	VAL r153 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r153, r152, v10);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot127ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	push_resource(r1);
	lpush(&lbl_lbl, v3);
	lpush(&lbl_tag, v5);
	VAL v6 = mw_mirth_type_TYPEz_STACK();
	STR* v7;
	STRLIT(v7, "*x", 2);
	push_value(v6);
	uint64_t v8 = mw_std_prim_Str_ZToName(MKSTR(v7));
	VAL v9 = pop_value();
	uint64_t v10 = mw_mirth_var_Var_newZBang(v9, v8);
	lpush(&lbl_sx, MKU64(v10));
	VAL v11 = mw_mirth_type_TYPEz_STACK();
	STR* v12;
	STRLIT(v12, "*y", 2);
	push_value(v11);
	uint64_t v13 = mw_std_prim_Str_ZToName(MKSTR(v12));
	VAL v14 = pop_value();
	uint64_t v15 = mw_mirth_var_Var_newZBang(v14, v13);
	uint64_t v16 = VU64(lpop(&lbl_lbl));
	uint64_t v17 = VU64(lpop(&lbl_tag));
	VAL r18 = pop_resource();
	lpush(&lbl_sy, MKU64(v15));
	lpush(&lbl_tag, MKU64(v17));
	mw_mirth_data_Tag_projectZ_inputZ_label(r18, v16, v17);
	VAL v19 = pop_value();
	VAL v20 = mw_std_maybe_Maybe_1_unwrap(v19);
	uint64_t v21 = VU64(lpop(&lbl_tag));
	VAL r22 = pop_resource();
	lpush(&lbl_lblty, v20);
	lpush(&lbl_tag, MKU64(v21));
	mw_mirth_data_Tag_outputZ_type(r22, v21);
	VAL v23 = pop_value();
	uint64_t v24 = VU64(lpop(&lbl_tag));
	VAL r25 = pop_resource();
	lpush(&lbl_datty, v23);
	lpush(&lbl_tag, MKU64(v24));
	mw_mirth_data_Tag_ctx(r25, v24);
	uint64_t v26 = VU64(lpop(&lbl_sx));
	uint64_t v27 = VU64(lpop(&lbl_sy));
	int64_t v28 = 0LL /* Nil */;
	push_u64(v26);
	lpush(&lbl_sx, MKU64(v26));
	lpush(&lbl_sy, MKU64(v27));
	VAL v29 = mtw_std_list_List_1_Cons(MKU64(v27), MKI64(v28));
	VAL v30 = pop_value();
	VAL v31 = mtw_std_list_List_1_Cons(v30, v29);
	VAL v32 = pop_value();
	VAL v33 = mw_std_list_List_1_cat(v32, v31);
	uint64_t v34 = VU64(lpop(&lbl_sx));
	push_value(v33);
	lpush(&lbl_sx, MKU64(v34));
	VAL v35 = mtw_mirth_type_StackType_STVar(v34);
	VAL v36 = lpop(&lbl_datty);
	incref(v36);
	lpush(&lbl_datty, v36);
	VAL v37 = mw_mirth_type_TZMulZPlus(v35, v36);
	uint64_t v38 = VU64(lpop(&lbl_sx));
	push_value(v37);
	lpush(&lbl_sx, MKU64(v38));
	VAL v39 = mtw_mirth_type_StackType_STVar(v38);
	VAL v40 = lpop(&lbl_lblty);
	incref(v40);
	lpush(&lbl_lblty, v40);
	VAL v41 = mw_mirth_type_TZMulZPlus(v39, v40);
	uint64_t v42 = VU64(lpop(&lbl_sy));
	push_value(v41);
	lpush(&lbl_sy, MKU64(v42));
	VAL v43 = mtw_mirth_type_StackType_STVar(v42);
	VAL v44 = lpop(&lbl_lblty);
	incref(v44);
	lpush(&lbl_lblty, v44);
	VAL v45 = mw_mirth_type_TZMulZPlus(v43, v44);
	VAL v46 = pop_value();
	VAL v47 = mw_mirth_type_TZ_ZTo(v46, v45);
	VAL v48 = mtw_mirth_type_Type_TMorphism(v47);
	VAL v49 = pop_value();
	VAL v50 = mw_mirth_type_TZMul(v49, v48);
	uint64_t v51 = VU64(lpop(&lbl_sy));
	push_value(v50);
	lpush(&lbl_sy, MKU64(v51));
	VAL v52 = mtw_mirth_type_StackType_STVar(v51);
	VAL v53 = lpop(&lbl_datty);
	incref(v53);
	lpush(&lbl_datty, v53);
	VAL v54 = mw_mirth_type_TZMulZPlus(v52, v53);
	VAL v55 = pop_value();
	VAL v56 = mw_mirth_type_TZ_ZTo(v55, v54);
	VAL v57 = pop_value();
	VAL v58 = MKNIL;
	VAL v59 = mkcons(v58, v57);
	VAL v60 = mkcons(v59, v56);
	uint64_t v61 = VU64(lpop(&lbl_sx));
	uint64_t v62 = VU64(lpop(&lbl_sy));
	VAL v63 = lpop(&lbl_lblty);
	VAL v64 = lpop(&lbl_datty);
	decref(v64);
	decref(v63);
	uint64_t v65 = VU64(lpop(&lbl_tag));
	push_value(v60);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot107ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	push_value(v7);
	push_value(v5);
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3));
	uint64_t v8 = pop_u64();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	mw_mirth_type_ArrowType_unpack(v11);
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v10);
	incref(v13);
	int64_t v15 = 0LL /* Nil */;
	push_value(v12);
	VAL v16 = mtw_mirth_arrow_Arrow_Arrow(v9, VU64(v10), VU64(v10), v14, v13, v13, MKI64(v15));
	VAL v17 = pop_value();
	uint64_t v18 = pop_u64();
	uint64_t v19 = pop_u64();
	push_resource(v16);
	VAL v20 = mtw_mirth_arrow_Op_OpDataSetLabel(v19, v18);
	VAL r21 = pop_resource();
	VAL r22 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v20, r22, r21);
	VAL r23 = pop_resource();
	VAL r24 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v17, r24, r23);
	VAL r25 = pop_resource();
	VAL r26 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r26, r25, v8);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot86ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	incref(v5);
	mw_mirth_data_Tag_ctx(r1, VU64(v5));
	VAL r6 = pop_resource();
	mw_mirth_elab_dataZ_setZ_labelZ_type(r6, VU64(v5), VU64(v3));
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	VAL v9 = MKNIL;
	VAL v10 = mkcons(v9, v8);
	VAL v11 = mkcons(v10, v7);
	push_value(v11);
}
static void mb_mirth_mirth_PropLabel_prop3_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot66ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	VAL v6;
	VAL v7;
	value_uncons(v4, &v6, &v7);
	decref(v6);
	push_value(v7);
	push_value(v5);
	mw_mirth_elab_initialZ_ctxZ_typeZ_bodyZ_home(r1, VU64(v3));
	uint64_t v8 = pop_u64();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	mw_mirth_type_ArrowType_unpack(v11);
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v10);
	incref(v13);
	int64_t v15 = 0LL /* Nil */;
	push_value(v12);
	VAL v16 = mtw_mirth_arrow_Arrow_Arrow(v9, VU64(v10), VU64(v10), v14, v13, v13, MKI64(v15));
	VAL v17 = pop_value();
	uint64_t v18 = pop_u64();
	uint64_t v19 = pop_u64();
	push_resource(v16);
	VAL v20 = mtw_mirth_arrow_Op_OpDataGetLabel(v19, v18);
	VAL r21 = pop_resource();
	VAL r22 = pop_resource();
	mw_mirth_elab_abZ_opZBang(v20, r22, r21);
	VAL r23 = pop_resource();
	VAL r24 = pop_resource();
	mw_mirth_elab_abZ_unifyZ_typeZBang(v17, r24, r23);
	VAL r25 = pop_resource();
	VAL r26 = pop_resource();
	mw_mirth_elab_finalizzeZ_wordZ_arrow(r26, r25, v8);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotcreateZ_projectorsZBangZDot45ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	incref(v5);
	mw_mirth_data_Tag_ctx(r1, VU64(v5));
	VAL r6 = pop_resource();
	mw_mirth_elab_dataZ_getZ_labelZ_type(r6, VU64(v5), VU64(v3));
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	VAL v9 = MKNIL;
	VAL v10 = mkcons(v9, v8);
	VAL v11 = mkcons(v10, v7);
	push_value(v11);
}
static void mb_mirth_mirth_PropLabel_prop2_1_ZLParenmirthZDotelabZDotelabZ_aliasZBangZDot16ZRParen_1 (void) {
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	VAL v2;
	VAL v3;
	value_uncons(v0, &v2, &v3);
	VAL v4;
	VAL v5;
	value_uncons(v2, &v4, &v5);
	decref(v4);
	incref(v5);
	STR* v6;
	STRLIT(v6, "target", 6);
	int64_t v7 = 0LL /* False */;
	int64_t v8 = 0LL /* False */;
	lpush(&lbl_alias, v3);
	lpush(&lbl_target, v5);
	mw_mirth_elab_resolveZ_defZ_beginZBang(MKSTR(v6), VU64(v5), v7, v8, r1);
	uint64_t v9 = VU64(lpop(&lbl_alias));
	int64_t v10 = mw_mirth_alias_Alias_arity(v9);
	VAL r11 = pop_resource();
	VAL v12 = VVAL(VTUP(r11)->cells[3]);
	incref(v12);
	int64_t v13 = 0LL /* Nil */;
	int64_t v14 = 0LL /* Nil */;
	push_i64(v10);
	push_resource(r11);
	push_i64(v13);
	push_i64(v14);
	mw_std_list_List_1_uncons(v12);
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	push_value(v15);
	push_value(v16);
	while(1) {
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		int64_t v18 = mw_std_maybe_Maybe_1_someZAsk(v17);
		if (!((bool)v18)) break;
		VAL v19 = pop_value();
		VAL v20 = mw_std_maybe_Maybe_1_unwrap(v19);
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		incref(v24);
		incref(v20);
		VAL r25 = pop_resource();
		push_value(v24);
		push_value(v20);
		push_value(v24);
		int64_t v26 = mw_mirth_def_Def_arity(v20);
		int64_t v27 = pop_i64();
		push_resource(r25);
		int64_t v28 = mw_mirth_elab_arityZ_compatibleZAsk(v27, v26);
		if (((bool)v28)) {
			VAL v29 = pop_value();
			VAL v30 = mtw_std_either_Either_2_Right(v29);
			push_value(v30);
		} else {
			VAL v31 = pop_value();
			VAL v32 = mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY(v31);
			VAL v33 = mtw_std_either_Either_2_Left(v32);
			push_value(v33);
		}
		VAL v34 = pop_value();
		switch (get_data_tag(v34)) {
			case 0LL: { // Left
				push_value(v23);
				push_value(v22);
				VAL v35 = mtp_std_either_Either_2_Left(v34);
				VAL v36 = pop_value();
				VAL v37 = pop_value();
				VAL v38 = mtw_std_list_List_1_Cons(v35, v37);
				push_value(v38);
				push_value(v36);
			} break;
			case 1LL: { // Right
				push_value(v23);
				push_value(v22);
				VAL v39 = mtp_std_either_Either_2_Right(v34);
				VAL v40 = pop_value();
				VAL v41 = mtw_std_list_List_1_Cons(v39, v40);
				push_value(v41);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				do_panic();
				push_value(v23);
				push_value(v22);
			}
		}
		mw_std_list_List_1_uncons(v21);
		VAL v42 = pop_value();
		VAL v43 = pop_value();
		push_value(v42);
		push_value(v43);
	}
	VAL v44 = pop_value();
	decref(v44);
	VAL v45 = pop_value();
	decref(v45);
	VAL v46 = pop_value();
	VAL v47 = pop_value();
	VAL v48 = mw_std_list_List_1_reverse(v47);
	push_value(v48);
	VAL v49 = mw_std_list_List_1_reverse(v46);
	VAL r50 = pop_resource();
	VAL v51 = VVAL(VTUP(r50)->cells[4]);
	incref(v51);
	VAL v52 = pop_value();
	VAL v53 = mw_std_list_List_1_cat(v52, v51);
	VAL v54 = VTUP(r50)->cells[4];
	decref(v54);
	VTUP(r50)->cells[4] = v53;
	VAL v55 = VTUP(r50)->cells[3];
	decref(v55);
	VTUP(r50)->cells[3] = v49;
	int64_t v56 = pop_i64();
	VAL r57 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers(r57, r50);
	int64_t v58 = 0LL /* Nil */;
	VAL r59 = pop_resource();
	VAL r60 = pop_resource();
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots(MKI64(v58), r60, r59);
	VAL r61 = pop_resource();
	VAL r62 = pop_resource();
	mw_mirth_elab_resolveZ_defZ_endZBang(r62, r61);
	VAL v63 = pop_value();
	switch (get_data_tag(v63)) {
		case 1LL: { // Some
			VAL v64 = mtp_std_maybe_Maybe_1_Some(v63);
			push_value(v64);
		} break;
		case 0LL: { // None
			VAL r65 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang(r65);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			do_panic();
		}
	}
	VAL v66 = pop_value();
	switch (get_data_tag(v66)) {
		case 0LL: { // DefAlias
			uint64_t v67 = mtp_mirth_def_Def_DefAlias(v66);
			void* v68 = mfld_mirth_alias_Alias_ZTildetarget(v67);
			VAL r69 = pop_resource();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang(MKPTR(v68), r69);
			VAL v70 = pop_value();
			switch (get_data_tag(v70)) {
				case 1LL: { // Some
					VAL v71 = mtp_std_maybe_Maybe_1_Some(v70);
					push_value(v71);
				} break;
				case 0LL: { // None
					uint64_t v72 = VU64(lpop(&lbl_target));
					STR* v73;
					STRLIT(v73, "Alias points to itself, circular aliases are not allowed.", 57);
					VAL r74 = pop_resource();
					lpush(&lbl_target, MKU64(v72));
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang(v72, MKSTR(v73), r74);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					do_panic();
				}
			}
		} break;
		default: {
			push_value(v66);
		} break;
	}
	uint64_t v75 = VU64(lpop(&lbl_target));
}
